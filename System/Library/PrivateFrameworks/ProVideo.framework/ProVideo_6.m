void sub_1B77F95D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  uint64_t v23;
  void *v25;

  if (__p) {
    operator delete(__p);
  }
  v25 = *(void **)(v23 - 112);
  if (v25)
  {
    *(void *)(v23 - 104) = v25;
    operator delete(v25);
  }
  _Unwind_Resume(exception_object);
}

void HGEquirectProject::HGEquirectProject(HGEquirectProject *this)
{
  v2 = (_OWORD *)((char *)this + 408);
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v3 = &unk_1F10DBF08;
  _OWORD *v2 = xmmword_1B7E736B0;
  v2[1] = xmmword_1B7E736B0;
  *(void *)(v3 + 440) = 0x423400003F800000;
  *(_DWORD *)(v3 + 448) = 1110704128;
  *(unsigned char *)(v3 + 452) = 0;
  *(void *)(v3 + 480) = 0;
  *(void *)(v3 + 488) = 0;
  *(_WORD *)(v3 + 496) = 0;
  *(_OWORD *)((char *)v2 + 92) = xmmword_1B7E73E70;
  *(_OWORD *)((char *)v2 + 108) = xmmword_1B7E74540;
  *(_OWORD *)((char *)v2 + 124) = xmmword_1B7E73E70;
  *(_OWORD *)((char *)v2 + 140) = xmmword_1B7E74540;
  HGNode::SetFlags((HGNode *)v3, 0, 2);
  (*(void (**)(HGEquirectProject *, uint64_t, uint64_t))(*(void *)this + 136))(this, 0xFFFFFFFFLL, 512);
  (*(void (**)(HGEquirectProject *, uint64_t, uint64_t))(*(void *)this + 136))(this, 0xFFFFFFFFLL, 1024);
  (*(void (**)(HGEquirectProject *, uint64_t, uint64_t))(*(void *)this + 136))(this, 0xFFFFFFFFLL, 32);
}

void sub_1B77F980C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGEquirectProject::~HGEquirectProject(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGEquirectProject::GetDOD(HGEquirectProject *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGRect v34 = a4;
  if (!a3 && HGRect::IsNull(&v34)) {
    return 0;
  }
  uint64_t v6 = HGRectMake4f(*((unsigned int *)this + 122), (float)-*((_DWORD *)this + 122) * 0.5, (float)-*((_DWORD *)this + 123) * 0.5, (float)*((int *)this + 122) * 0.5, (float)*((int *)this + 123) * 0.5);
  float v8 = *((float *)this + 125);
  float v9 = 1.0 / v8;
  float v10 = (float)-*((float *)this + 128) / v8;
  float v11 = *((float *)this + 130);
  float v12 = 1.0 / v11;
  float v13 = (float)-*((float *)this + 132) / v11;
  float v14 = v9 * (float)(int)v6;
  float v15 = (float)SHIDWORD(v6) * 0.0;
  float v16 = v10 + (float)(v14 + v15);
  float v17 = (float)(int)v6 * 0.0;
  float v18 = v12 * (float)SHIDWORD(v6);
  float v19 = v13 + (float)(v17 + v18);
  float v20 = v9 * (float)(int)v7;
  float v21 = v10 + (float)(v20 + v15);
  float v22 = (float)(int)v7 * 0.0;
  float v23 = v13 + (float)(v22 + v18);
  float v24 = (float)SHIDWORD(v7) * 0.0;
  float v25 = v10 + (float)(v14 + v24);
  float v26 = v12 * (float)SHIDWORD(v7);
  float v27 = v13 + (float)(v17 + v26);
  float v28 = v10 + (float)(v20 + v24);
  float v29 = v13 + (float)(v22 + v26);
  if (v21 >= v16) {
    float v30 = v16;
  }
  else {
    float v30 = v21;
  }
  if (v25 < v30) {
    float v30 = v25;
  }
  if (v28 < v30) {
    float v30 = v28;
  }
  if (v23 >= v19) {
    float v31 = v19;
  }
  else {
    float v31 = v23;
  }
  if (v27 < v31) {
    float v31 = v27;
  }
  if (v29 < v31) {
    float v31 = v29;
  }
  if (v16 >= v21) {
    float v32 = v16;
  }
  else {
    float v32 = v21;
  }
  if (v32 < v25) {
    float v32 = v25;
  }
  if (v32 >= v28) {
    float v28 = v32;
  }
  if (v19 >= v23) {
    float v33 = v19;
  }
  else {
    float v33 = v23;
  }
  if (v33 >= v27) {
    float v27 = v33;
  }
  if (v27 >= v29) {
    float v29 = v27;
  }
  return HGRectMake4f(HIDWORD(v7), v30, v31, v28, v29);
}

uint64_t HGEquirectProject::GetROI(HGEquirectProject *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v5 = HGRectMake4f(*((unsigned int *)this + 120), (float)-*((_DWORD *)this + 120) * 0.5, (float)-*((_DWORD *)this + 121) * 0.5, (float)*((int *)this + 120) * 0.5, (float)*((int *)this + 121) * 0.5);
  float v7 = *((float *)this + 133);
  float v8 = v7 * (float)(int)v5;
  float v9 = *((float *)this + 134);
  float v10 = v9 * (float)SHIDWORD(v5);
  float v11 = *((float *)this + 136);
  float v12 = v11 + (float)(v8 + v10);
  float v13 = *((float *)this + 137);
  float v14 = v13 * (float)(int)v5;
  float v15 = *((float *)this + 138);
  float v16 = v15 * (float)SHIDWORD(v5);
  float v17 = *((float *)this + 140);
  float v18 = v17 + (float)(v14 + v16);
  float v19 = v7 * (float)(int)v6;
  float v20 = v11 + (float)(v19 + v10);
  float v21 = v13 * (float)(int)v6;
  float v22 = v17 + (float)(v21 + v16);
  float v23 = v9 * (float)SHIDWORD(v6);
  float v24 = v11 + (float)(v8 + v23);
  float v25 = v15 * (float)SHIDWORD(v6);
  float v26 = v17 + (float)(v14 + v25);
  float v27 = v11 + (float)(v19 + v23);
  float v28 = v17 + (float)(v21 + v25);
  if (v20 >= v12) {
    float v29 = v12;
  }
  else {
    float v29 = v20;
  }
  if (v24 < v29) {
    float v29 = v24;
  }
  if (v27 < v29) {
    float v29 = v27;
  }
  if (v22 >= v18) {
    float v30 = v18;
  }
  else {
    float v30 = v22;
  }
  if (v26 < v30) {
    float v30 = v26;
  }
  if (v28 < v30) {
    float v30 = v28;
  }
  if (v12 >= v20) {
    float v31 = v12;
  }
  else {
    float v31 = v20;
  }
  if (v31 < v24) {
    float v31 = v24;
  }
  if (v31 >= v27) {
    float v27 = v31;
  }
  if (v18 >= v22) {
    float v32 = v18;
  }
  else {
    float v32 = v22;
  }
  if (v32 < v26) {
    float v32 = v26;
  }
  if (v32 >= v28) {
    float v28 = v32;
  }

  return HGRectMake4f(HIDWORD(v6), v29, v30, v27, v28);
}

uint64_t HGEquirectProject::IntermediateFormat(uint64_t a1, uint64_t a2)
{
  return a2;
}

HGNode *HGEquirectProject::GetOutput(HGNode *this, HGRenderer *a2)
{
  if (!(*(unsigned int (**)(HGRenderer *))(*(void *)a2 + 304))(a2)) {
    return this;
  }

  return HGRenderer::GetInput(a2, this, 0);
}

const char *HGEquirectProject::GetProgram(HGEquirectProject *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) <= 0x60B0F) {
    return 0;
  }
  else {
    return "\n"
  }
           "\n"
           "constant float pi = 3.14159265358979323846;\n"
           "\n"
           "float2 pointToAngles(const float3 p)\n"
           "{\n"
           "    float2 angle;\n"
           "    \n"
           "    angle.x = atan2(p.z, p.x);  // longitude, the angle around the z axis, theta [-pi, pi]\n"
           "    angle.x = angle.x + pi/2.;  // align the equator and prime meridian to be in center of view\n"
           "    angle.y = asin(p.y);        // latitude, the angle with the z axis, phi [0, pi]\n"
           "\n"
           "    return angle;\n"
           "}\n"
           "\n"
           "float2 equirect2uv(const float3 p)\n"
           "{\n"
           "    float2 angles = pointToAngles(p);\n"
           "    float phi = angles.y;\n"
           "    float theta = angles.x;\n"
           "\n"
           "    /* wrap theta appropriately since we've added pi/2. for alignment */\n"
           "    float theta_larger_than_pi = step(pi, theta);\n"
           "    float amount_larger_than_pi = theta - pi;\n"
           "    theta = (1. - theta_larger_than_pi) * theta +                   // theta < pi\n"
           "            theta_larger_than_pi * (-pi + amount_larger_than_pi) ;  // theta >= pi\n"
           "\n"
           "    float2 t;\n"
           "    t.x = 0.5 + theta / (2.*pi);\n"
           "    t.y = 0.5 - phi/pi;\n"
           "\n"
           "    // reverse the y sampling direction\n"
           "    t.y = 1. - t.y;\n"
           "    \n"
           "    return t;\n"
           "}\n"
           "\n"
           "float wrapXTexCoordAbout0(float s, float2 texLBorder, float2 texSize)\n"
           "{\n"
           "    s += texLBorder.x;\n"
           "    float edge = texLBorder.x;\n"
           "    float shouldWrapLeft = 1. - step(edge,s);\n"
           "    s = mix(s, texLBorder.x + texSize.x - (edge - s), shouldWrapLeft);\n"
           "    return s;\n"
           "}\n"
           "\n"
           "float wrapXTexCoordAboutMaxW(float s, float2 texLBorder, float2 texSize)\n"
           "{\n"
           "    float edge = texLBorder.x + texSize.x;\n"
           "    float shouldWrapRight = step(edge,s);\n"
           "    s = mix(s, texLBorder.x + (s - edge), shouldWrapRight);\n"
           "    return s;\n"
           "}\n"
           "\n"
           "float wrapYTexCoordAbout0(float t, float2 texLBorder, float2 texSize)\n"
           "{\n"
           "    t += texLBorder.y;\n"
           "    float edge = texLBorder.y;\n"
           "    float shouldWrapBottom = 1. - step(edge,t);\n"
           "    t = mix(t, texLBorder.y + texSize.y - (edge - t), shouldWrapBottom);\n"
           "    return t;\n"
           "}\n"
           "\n"
           "float clampYTexCoordAboutMaxH(float t, float2 texLBorder, float2 texSize)\n"
           "{\n"
           "    float edge = texLBorder.y + texSize.y;\n"
           "    float shouldWrapTop = step(edge,t);\n"
           "    t = mix(t, edge-1., shouldWrapTop);\n"
           "    return t;\n"
           "}\n"
           "\n"
           "float4 bilinearSample(float2 uv, float2 texLBorder, float2 texSize,\n"
           "                      texture2d<float> tex, sampler sampler)\n"
           "{\n"
           "    float s = uv.x*texSize.x;\n"
           "    float t = uv.y*texSize.y;\n"
           "    \n"
           "    float sl = floor(s);\n"
           "    float sr = ceil(s);\n"
           "    float tl = floor(t);\n"
           "    float tu = ceil(t);\n"
           "    \n"
           "    sl = wrapXTexCoordAbout0(sl, texLBorder, texSize);\n"
           "    sr = wrapXTexCoordAbout0(sr, texLBorder, texSize);\n"
           "    sl = wrapXTexCoordAboutMaxW(sl, texLBorder, texSize);\n"
           "    sr = wrapXTexCoordAboutMaxW(sr, texLBorder, texSize);\n"
           "    tl = wrapYTexCoordAbout0(tl, texLBorder, texSize);\n"
           "    tu = wrapYTexCoordAbout0(tu, texLBorder, texSize);\n"
           "    tl = clampYTexCoordAboutMaxH(tl, texLBorder, texSize);\n"
           "    tu = clampYTexCoordAboutMaxH(tu, texLBorder, texSize);\n"
           "    \n"
           "    float4 ll = tex.sample(sampler, float2(sl, tl));\n"
           "    float4 lr = tex.sample(sampler, float2(sr, tl));\n"
           "    float4 ul = tex.sample(sampler, float2(sl, tu));\n"
           "    float4 ur = tex.sample(sampler, float2(sr, tu));\n"
           "\n"
           "    float q = fract(s);\n"
           "    float4 lowerColor = mix(ll, lr, q);\n"
           "    float4 upperColor = mix(ul, ur, q);\n"
           "    \n"
           "    float r = fract(t);\n"
           "    float4 finalColor = mix(lowerColor,upperColor,r);\n"
           "    \n"
           "    return finalColor;\n"
           "}\n"
           "\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    float3 p = normalize(frag._texCoord0.xyz);\n"
           "    float2 uv = equirect2uv(p);\n"
           "    float2 texLBorder = hg_Params[0].xy;\n"
           "    float2 texSize = hg_Params[1].xy;\n"
           "    \n"
           "    FragmentOut out;\n"
           "    out.color0 = bilinearSample(uv, texLBorder, texSize, hg_Texture0, hg_Sampler0);\n"
           "    return out;\n"
           "}\n";
}

void HGEquirectProject::initRenderResources(uint64_t a1, GLuint *a2)
{
  float v13 = 0;
  float v14 = 0;
  uint64_t v15 = 0;
  project_util::generateIcosphere(2, (uint64_t)&v13);
  glGenBuffers(1, a2);
  glBindBuffer(0x8892u, *a2);
  glBufferData(0x8892u, v14 - v13, v13, 0x88E4u);
  glBindBuffer(0x8892u, 0);
  v4 = v13;
  a2[1] = ((v14 - v13) >> 2) / 3uLL;
  if (v4)
  {
    float v14 = v4;
    operator delete(v4);
  }
  GLuint v5 = project_util::compileShaderProgram("\n                                                           \n    attribute vec3 position;                               \n"
         "                                                           \n"
         "    uniform mat4 mvp;                                      \n"
         "                                                           \n"
         "    varying vec3 pos;                                      \n"
         "                                                           \n"
         "    void main()                                            \n"
         "    {                                                      \n"
         "        gl_Position = mvp * vec4(position,1.);             \n"
         "        pos = position;                                    \n"
         "    }                                                      \n"
         "    ",
         asc_1B8528209,
         v3);
  a2[2] = v5;
  glUseProgram(v5);
  a2[3] = project_util::getAttribLocation((project_util *)a2[2], "position", v6);
  a2[4] = project_util::getUniformLocation((project_util *)a2[2], "mvp", v7);
  a2[5] = project_util::getUniformLocation((project_util *)a2[2], "tex", v8);
  a2[6] = project_util::getUniformLocation((project_util *)a2[2], "texSize", v9);
  a2[7] = project_util::getUniformLocation((project_util *)a2[2], "texLBorder", v10);
  a2[8] = project_util::getUniformLocation((project_util *)a2[2], "paddedTexSize", v11);
  a2[9] = project_util::getUniformLocation((project_util *)a2[2], "flip", v12);
  glUseProgram(0);
}

void sub_1B77F9D58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *HGEquirectProject::getRenderResources(HGEquirectProject *this, HGGPURenderer *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_13, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_13))
  {
    qword_1EB9A2098 = 0;
    qword_1EB9A2090 = 0;
    qword_1EB9A2088 = (uint64_t)&qword_1EB9A2090;
    __cxa_atexit((void (*)(void *))std::map<HGGPURenderer *,RenderResources>::~map[abi:ne180100], &qword_1EB9A2088, &dword_1B73F3000);
    __cxa_guard_release(&_MergedGlobals_13);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2070, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A2070))
  {
    __cxa_atexit(MEMORY[0x1E4FBA268], &HGEquirectProject::getRenderResources(HGGPURenderer *)::mutex, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A2070);
  }
  std::mutex::lock(&HGEquirectProject::getRenderResources(HGGPURenderer *)::mutex);
  uint64_t v4 = qword_1EB9A2090;
  if (qword_1EB9A2090)
  {
    GLuint v5 = &qword_1EB9A2090;
    uint64_t v6 = qword_1EB9A2090;
    do
    {
      unint64_t v7 = *(void *)(v6 + 32);
      BOOL v8 = v7 >= (unint64_t)a2;
      if (v7 >= (unint64_t)a2) {
        float v9 = (uint64_t *)v6;
      }
      else {
        float v9 = (uint64_t *)(v6 + 8);
      }
      if (v8) {
        GLuint v5 = (uint64_t *)v6;
      }
      uint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 != &qword_1EB9A2090 && v5[4] <= (unint64_t)a2)
    {
      if (qword_1EB9A2090) {
        goto LABEL_28;
      }
LABEL_26:
      uint64_t v15 = &qword_1EB9A2090;
      float v16 = &qword_1EB9A2090;
LABEL_32:
      float v18 = (char *)operator new(0x50uLL);
      *((void *)v18 + 4) = a2;
      *(_OWORD *)(v18 + 40) = 0u;
      *(_OWORD *)(v18 + 56) = 0u;
      *((void *)v18 + 9) = 0;
      *(void *)float v18 = 0;
      *((void *)v18 + 1) = 0;
      *((void *)v18 + 2) = v16;
      *uint64_t v15 = (uint64_t)v18;
      float v19 = (uint64_t *)v18;
      if (*(void *)qword_1EB9A2088)
      {
        qword_1EB9A2088 = *(void *)qword_1EB9A2088;
        float v19 = (uint64_t *)*v15;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)qword_1EB9A2090, v19);
      ++qword_1EB9A2098;
      goto LABEL_36;
    }
    while (1)
    {
      while (1)
      {
        float v11 = (uint64_t *)v4;
        unint64_t v12 = *(void *)(v4 + 32);
        if (v12 <= (unint64_t)a2) {
          break;
        }
        uint64_t v4 = *v11;
        float v10 = v11;
        if (!*v11) {
          goto LABEL_22;
        }
      }
      if (v12 >= (unint64_t)a2) {
        break;
      }
      uint64_t v4 = v11[1];
      if (!v4)
      {
        float v10 = v11 + 1;
        goto LABEL_22;
      }
    }
    float v13 = (char *)v11;
  }
  else
  {
    float v10 = &qword_1EB9A2090;
    float v11 = &qword_1EB9A2090;
LABEL_22:
    float v13 = (char *)operator new(0x50uLL);
    *((void *)v13 + 4) = a2;
    *(_OWORD *)(v13 + 40) = 0u;
    *(_OWORD *)(v13 + 56) = 0u;
    *((void *)v13 + 9) = 0;
    *(void *)float v13 = 0;
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = v11;
    *float v10 = (uint64_t)v13;
    float v14 = (uint64_t *)v13;
    if (*(void *)qword_1EB9A2088)
    {
      qword_1EB9A2088 = *(void *)qword_1EB9A2088;
      float v14 = (uint64_t *)*v10;
    }
    uint64_t v3 = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)qword_1EB9A2090, v14);
    ++qword_1EB9A2098;
  }
  HGEquirectProject::initRenderResources((uint64_t)v3, (GLuint *)v13 + 10);
  uint64_t v4 = qword_1EB9A2090;
  if (!qword_1EB9A2090) {
    goto LABEL_26;
  }
  while (1)
  {
LABEL_28:
    while (1)
    {
      float v16 = (uint64_t *)v4;
      unint64_t v17 = *(void *)(v4 + 32);
      if (v17 <= (unint64_t)a2) {
        break;
      }
      uint64_t v4 = *v16;
      uint64_t v15 = v16;
      if (!*v16) {
        goto LABEL_32;
      }
    }
    if (v17 >= (unint64_t)a2) {
      break;
    }
    uint64_t v4 = v16[1];
    if (!v4)
    {
      uint64_t v15 = v16 + 1;
      goto LABEL_32;
    }
  }
  float v18 = (char *)v16;
LABEL_36:
  std::mutex::unlock(&HGEquirectProject::getRenderResources(HGGPURenderer *)::mutex);
  return v18 + 40;
}

void sub_1B77FA028(_Unwind_Exception *a1)
{
}

uint64_t std::map<HGGPURenderer *,RenderResources>::~map[abi:ne180100](uint64_t a1)
{
  return a1;
}

uint64_t _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEED1B8ne180100Ev(uint64_t a1)
{
  v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void HGEquirectProject::render(uint64_t a1, int *lpsrc, uint64_t a3, uint64_t a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a3 + 168);
  if (lpsrc)
  {
    int v10 = lpsrc[5];
    int v11 = lpsrc[6];
    uint64_t v12 = (uint64_t)(lpsrc + 5);
    int v13 = *(_DWORD *)(v12 + 8);
    int v14 = *(_DWORD *)(v12 + 12);
    if (v9)
    {
      int v15 = v9[34];
      int v16 = v9[35];
    }
    else
    {
      int v15 = 0;
      int v16 = 0;
    }
  }
  else
  {
    int v15 = 0;
    int v16 = 0;
    int v10 = MEMORY[0x14];
    int v11 = MEMORY[0x18];
    uint64_t v12 = 20;
    int v13 = MEMORY[0x1C];
    int v14 = MEMORY[0x20];
  }
  glViewport(v10 - v15, v11 - v16, v13 - v10, v14 - v11);
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glClear(0x4000u);
  glUseProgram(*(_DWORD *)(a4 + 8));
  glBindBuffer(0x8892u, *(_DWORD *)a4);
  glEnableVertexAttribArray(*(_DWORD *)(a4 + 12));
  glVertexAttribPointer(*(_DWORD *)(a4 + 12), 3, 0x1406u, 0, 0, 0);
  *(void *)x = 0;
  *(void *)float v20 = 0;
  *(void *)float v18 = 0;
  *(void *)value = HGGLTexture::GetTextureRect((HGGLTexture *)a3);
  *(void *)&value[2] = v17;
  calculateUniforms(a1 + 408, (int32x2_t *)(a3 + 20), (int32x2_t *)value, (int *)v12, v21, (float32x2_t *)v20, x, (__n64 *)v18, 0);
  *(float32x4_t *)value = v21[0];
  float32x4_t v23 = v21[1];
  float32x4_t v24 = v21[2];
  float32x4_t v25 = v21[3];
  glUniformMatrix4fv(*(_DWORD *)(a4 + 16), 1, 0, value);
  glActiveTexture(0x84C0u);
  glUniform1i(*(_DWORD *)(a4 + 20), 0);
  glUniform1i(*(_DWORD *)(a4 + 36), *(unsigned __int8 *)(a1 + 496));
  glBindTexture(0xDE1u, v8);
  glTexParameteri(0xDE1u, 0x2800u, 9728);
  glTexParameteri(0xDE1u, 0x2801u, 9728);
  glUniform2f(*(_DWORD *)(a4 + 24), x[0], x[1]);
  glUniform2f(*(_DWORD *)(a4 + 28), v20[0], v20[1]);
  glUniform2f(*(_DWORD *)(a4 + 32), v18[0], v18[1]);
  glDrawArrays(4u, 0, *(_DWORD *)(a4 + 4));
  glUseProgram(0);
  glActiveTexture(0x84C0u);
  glBindTexture(0xDE1u, 0);
  glDisableVertexAttribArray(*(_DWORD *)(a4 + 12));
  glBindBuffer(0x8892u, 0);
}

__n64 calculateUniforms(uint64_t a1, int32x2_t *a2, int32x2_t *a3, int *a4, float32x4_t *a5, float32x2_t *a6, _DWORD *a7, __n64 *a8, char a9)
{
  uint64_t v16 = HGRectMake4i(0, 0, *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 84));
  float v18 = *(float *)(a1 + 92);
  float v19 = *(float *)(a1 + 96);
  float v20 = v18 * (float)(int)v16;
  float v21 = v19 * (float)SHIDWORD(v16);
  float v22 = *(float *)(a1 + 104);
  float v23 = *(float *)(a1 + 108);
  float v24 = v22 + (float)(v20 + v21);
  float v25 = v23 * (float)(int)v16;
  float v26 = *(float *)(a1 + 112);
  float v27 = v26 * (float)SHIDWORD(v16);
  float v28 = *(float *)(a1 + 120);
  float v29 = v28 + (float)(v25 + v27);
  float v30 = v18 * (float)(int)v17;
  float v31 = v22 + (float)(v30 + v21);
  float v32 = v23 * (float)(int)v17;
  float v33 = v28 + (float)(v32 + v27);
  float v34 = v19 * (float)SHIDWORD(v17);
  float v35 = v22 + (float)(v20 + v34);
  float v36 = v26 * (float)SHIDWORD(v17);
  float v37 = v28 + (float)(v25 + v36);
  float v38 = v22 + (float)(v30 + v34);
  float v39 = v28 + (float)(v32 + v36);
  if (v31 >= v24) {
    float v40 = v24;
  }
  else {
    float v40 = v31;
  }
  if (v35 < v40) {
    float v40 = v35;
  }
  if (v38 < v40) {
    float v40 = v38;
  }
  if (v33 >= v29) {
    float v41 = v29;
  }
  else {
    float v41 = v33;
  }
  if (v37 < v41) {
    float v41 = v37;
  }
  if (v39 < v41) {
    float v41 = v39;
  }
  if (v24 >= v31) {
    float v42 = v24;
  }
  else {
    float v42 = v31;
  }
  if (v42 < v35) {
    float v42 = v35;
  }
  if (v42 >= v38) {
    float v38 = v42;
  }
  if (v29 >= v33) {
    float v43 = v29;
  }
  else {
    float v43 = v33;
  }
  if (v43 < v37) {
    float v43 = v37;
  }
  if (v43 >= v39) {
    float v39 = v43;
  }
  unint64_t v44 = HGRectMake4f(HIDWORD(v17), v40, v41, v38, v39);
  int v46 = v44;
  uint64_t v48 = v47;
  unint64_t v49 = HIDWORD(v44);
  float v50 = (float)*a4;
  float v51 = (float)a4[2];
  float v52 = (float)a4[1];
  float v53 = (float)a4[3];
  float v54 = *(float *)(a1 + 92);
  float v55 = *(float *)(a1 + 96);
  float v56 = v54 * v50;
  float v57 = v55 * v52;
  float v58 = *(float *)(a1 + 104);
  float v59 = *(float *)(a1 + 108);
  float v60 = v58 + (float)((float)(v54 * v50) + (float)(v55 * v52));
  float v61 = v59 * v50;
  float v62 = *(float *)(a1 + 112);
  float v63 = v62 * v52;
  float v64 = *(float *)(a1 + 120);
  float v65 = v64 + (float)(v61 + v63);
  float v66 = v54 * v51;
  float v67 = v58 + (float)(v66 + v57);
  float v68 = v59 * v51;
  float v69 = v64 + (float)(v68 + v63);
  float v70 = v55 * v53;
  float v71 = v58 + (float)(v56 + (float)(v55 * v53));
  float v72 = v62 * v53;
  float v73 = v64 + (float)(v61 + v72);
  float v74 = v58 + (float)(v66 + v70);
  float v75 = v64 + (float)(v68 + v72);
  if (v67 >= v60) {
    float v76 = v60;
  }
  else {
    float v76 = v67;
  }
  if (v71 < v76) {
    float v76 = v71;
  }
  if (v74 < v76) {
    float v76 = v74;
  }
  if (v69 >= v65) {
    float v77 = v65;
  }
  else {
    float v77 = v69;
  }
  if (v73 < v77) {
    float v77 = v73;
  }
  if (v75 < v77) {
    float v77 = v75;
  }
  if (v60 >= v67) {
    float v78 = v60;
  }
  else {
    float v78 = v67;
  }
  if (v78 < v71) {
    float v78 = v71;
  }
  if (v78 < v74) {
    float v78 = v74;
  }
  if (v65 >= v69) {
    float v79 = v65;
  }
  else {
    float v79 = v69;
  }
  if (v79 < v73) {
    float v79 = v73;
  }
  if (v79 >= v75) {
    float v75 = v79;
  }
  uint64_t v80 = HGRectMake4f(v45, v76, v77, v78, v75);
  double v81 = (double)(int)v80 / (double)(v48 - v46);
  double v83 = (double)v82 / (double)(v48 - v46);
  double v84 = (double)(HIDWORD(v48) - v49);
  double v85 = (double)SHIDWORD(v80) / v84;
  double v87 = (double)v86 / v84;
  if (*(unsigned char *)(a1 + 44))
  {
    float v89 = *(float *)(a1 + 48);
    float v88 = *(float *)(a1 + 52);
    float v91 = *(float *)(a1 + 56);
    float v90 = *(float *)(a1 + 60);
    float v92 = 0.0;
    float v93 = *(float *)(a1 + 64);
    float v94 = *(float *)(a1 + 68);
  }
  else
  {
    double v95 = (double)*(int *)(a1 + 80) / (double)*(int *)(a1 + 84);
    __double2 v96 = __sincos_stret(*(float *)(a1 + 36) * 0.0174532925 * 0.5);
    double v97 = v96.__cosval + v96.__sinval / -0.608761429 * 0.79335334;
    double v98 = -v97;
    if (v97 >= 0.0) {
      double v98 = 0.01;
    }
    float v93 = v98;
    float v94 = fabs(v97 + -1.0) + 0.25;
    float v92 = v97;
    float v99 = v95;
    float v90 = v93 * 0.76733;
    float v88 = (float)(v93 * 0.76733) * v99;
    float v91 = -(float)(v93 * 0.76733);
    float v89 = -v88;
  }
  double v100 = v88;
  double v101 = v100 - v89;
  double v102 = v100 - (0.5 - v81) * v101;
  double v103 = v100 - (0.5 - v83) * v101;
  double v104 = v90;
  double v105 = v104 - v91;
  double v106 = v104 - (0.5 - v85) * v105;
  double v107 = v104 - (0.5 - v87) * v105;
  long long v108 = *(_OWORD *)(a1 + 16);
  long long v109 = *(_OWORD *)(a1 + 12);
  long long v110 = *(_OWORD *)(a1 + 20);
  long long v111 = *(_OWORD *)(a1 + 24);
  long long v112 = *(_OWORD *)(a1 + 28);
  long long v113 = *(_OWORD *)(a1 + 32);
  *(float *)&double v102 = v102;
  *(float *)&double v103 = v103;
  float v114 = *(float *)&v102 + *(float *)&v103;
  *(float *)&double v102 = *(float *)&v103 - *(float *)&v102;
  *(float *)&double v103 = v114 / *(float *)&v102;
  *(float *)&double v106 = v106;
  *(float *)&double v107 = v107;
  float v115 = *(float *)&v106 + *(float *)&v107;
  *(float *)&double v106 = *(float *)&v107 - *(float *)&v106;
  float32_t v116 = v115 / *(float *)&v106;
  float32_t v117 = (float)-(float)(v94 + v93) / (float)(v94 - v93);
  *(float *)&unsigned int v118 = (float)((float)(v94 * -2.0) * v93) / (float)(v94 - v93);
  float v119 = v93 + v93;
  float32x4_t v120 = (float32x4_t)COERCE_UNSIGNED_INT(v119 / *(float *)&v102);
  v121.i32[0] = 0;
  v121.i64[1] = 0;
  v121.f32[1] = v119 / *(float *)&v106;
  __asm { FMOV            V23.4S, #-1.0 }
  _Q23.i32[0] = LODWORD(v103);
  float32x4_t v127 = _Q23;
  v127.f32[1] = v116;
  float32x4_t v128 = v127;
  v128.f32[2] = v117;
  v129.i64[0] = 0;
  v129.i64[1] = v118;
  if (a9)
  {
    float32x4_t v120 = vaddq_f32(vaddq_f32(vmulq_n_f32((float32x4_t)xmmword_1B7E736B0, v120.f32[0]), (float32x4_t)xmmword_1B7E75D30), (float32x4_t)0);
    float32x4_t v121 = vaddq_f32(vmlaq_lane_f32((float32x4_t)0, (float32x4_t)xmmword_1B83475C0, *(float32x2_t *)v121.f32, 1), (float32x4_t)0);
    float32x4_t v128 = vaddq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B7E736B0, _Q23.f32[0]), (float32x4_t)xmmword_1B83475C0, *(float32x2_t *)v127.f32, 1), (float32x4_t)xmmword_1B7E73B40, v128, 2), (float32x4_t)xmmword_1B83475D0);
    float32x4_t v129 = vaddq_f32(vmlaq_laneq_f32((float32x4_t)0, (float32x4_t)xmmword_1B7E73B40, v129, 2), (float32x4_t)0);
  }
  *a5 = vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v120, COERCE_FLOAT(*(_OWORD *)a1)), v121, COERCE_FLOAT(*(_OWORD *)(a1 + 4))), v128, COERCE_FLOAT(*(_OWORD *)(a1 + 8))), (float32x4_t)0, v129);
  a5[1] = vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v120, *(float *)&v109), v121, *(float *)&v108), v128, *(float *)&v110), (float32x4_t)0, v129);
  a5[2] = vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v120, *(float *)&v111), v121, *(float *)&v112), v128, *(float *)&v113), (float32x4_t)0, v129);
  a5[3] = vaddq_f32(v129, vmlaq_n_f32(vmlaq_f32(vmulq_f32(v120, (float32x4_t)0), (float32x4_t)0, v121), v128, v92));
  float32x2_t v130 = vcvt_f32_s32(vsub_s32(*a2, *a3));
  *(float *)&uint64_t v131 = (float)(a2[1].i32[0] - a2->u32[0]);
  *a7 = v131;
  *((float *)&v131 + 1) = (float)(a2[1].i32[1] - a2->i32[1]);
  *(void *)a7 = v131;
  result.n64_f32[0] = (float)(a3[1].i32[0] - a3->i32[0]);
  a8->n64_u32[0] = result.n64_u32[0];
  result.n64_f32[1] = (float)(a3[1].i32[1] - a3->i32[1]);
  a8->n64_u64[0] = result.n64_u64[0];
  *a6 = v130;
  return result;
}

int *HGEquirectProject::RenderPage(HGNode *this, HGRect *a2)
{
  HGPagePullTexturesGuard::HGPagePullTexturesGuard((HGPagePullTexturesGuard *)&v10, this, (HGPage *)a2);
  Buffer = *(int **)&a2->var2;
  if (Buffer)
  {
    (*(void (**)(void))(*(void *)Buffer + 16))(*(void *)&a2->var2);
  }
  else
  {
    Buffer = (int *)HGGPURenderer::CreateBuffer(*(void *)&a2->var0, a2[1], a2[2].var0, 0, (*((_DWORD *)this + 4) >> 12) & 1, LOBYTE(a2[15].var2));
    *(void *)&a2->var2 = Buffer;
  }
  (*(void (**)(void, int *))(**(void **)&a2->var0 + 144))(*(void *)&a2->var0, Buffer);
  (*(void (**)(void, void, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 0, *(void *)&a2[10].var2, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 1, *(void *)&a2[11].var0, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 2, *(void *)&a2[11].var2, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 3, *(void *)&a2[12].var0, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 4, *(void *)&a2[12].var2, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 5, *(void *)&a2[13].var0, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 6, *(void *)&a2[13].var2, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 7, *(void *)&a2[14].var0, 0, 0);
  if (*(void *)&a2[10].var2)
  {
    GLuint v5 = (HGEquirectProject *)(*(uint64_t (**)(void))(**(void **)&a2->var0 + 304))(*(void *)&a2->var0);
    if (v5)
    {
      Buffer = *(int **)&a2[10].var2;
    }
    else
    {
      RenderResources = HGEquirectProject::getRenderResources(v5, *(HGGPURenderer **)&a2->var0);
      unint64_t v7 = *(const void **)&a2[10].var2;
      if (v7) {
      else
      }
        uint64_t v8 = 0;
      HGEquirectProject::render((uint64_t)this, Buffer, (uint64_t)v8, (uint64_t)RenderResources);
    }
  }
  else
  {
    fwrite("HGEquirectProject: no equirect input image.\n", 0x2CuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
  }
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard(&v10);
  return Buffer;
}

void sub_1B77FAC20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

void sub_1B77FAC34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

void sub_1B77FAC48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

void sub_1B77FAC5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

char *HGEquirectProject::RenderPageMetal(HGNode *this, HGPage *a2)
{
  HGPagePullMetalTexturesGuard::HGPagePullMetalTexturesGuard((HGPagePullMetalTexturesGuard *)&v31, this, a2);
  (*(void (**)(void, void))(**(void **)a2 + 144))(*(void *)a2, 0);
  Buffer = (char *)*((void *)a2 + 1);
  if (Buffer) {
    (*(void (**)(void))(*(void *)Buffer + 16))(*((void *)a2 + 1));
  }
  else {
    Buffer = HGGPURenderer::CreateBuffer(*(void *)a2, *((HGRect *)a2 + 1), *((unsigned int *)a2 + 8), 1, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
  }
  HGGPURenderer::ClearMetal(*(HGGPURenderer **)a2, (HGBitmap *)Buffer, *((HGRect *)a2 + 1), v5);
  uint64_t v6 = (const void *)(*(uint64_t (**)(void, void, HGNode *))(**(void **)a2 + 368))(*(void *)a2, *((void *)this + 8), this);
  if (!v6) {
    goto LABEL_38;
  }
  if (!v7) {
    goto LABEL_38;
  }
  uint64_t v8 = v7;
  float v9 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)this + 48))(this);
  size_t v10 = strlen(v9);
  if (v10 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v11 = v10;
  if (v10 >= 0x17)
  {
    uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v13 = v10 | 7;
    }
    uint64_t v14 = v13 + 1;
    p_dst = (float32x4_t *)operator new(v13 + 1);
    *((void *)&__dst + 1) = v11;
    *(void *)&long long v28 = v14 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
  }
  else
  {
    BYTE7(v28) = v10;
    p_dst = (float32x4_t *)&__dst;
    if (!v10) {
      goto LABEL_14;
    }
  }
  memmove(p_dst, v9, v11);
LABEL_14:
  p_dst->i8[v11] = 0;
  HGMetalHandler::SetDebugLabel(v8, (const std::string *)&__dst);
  if (SBYTE7(v28) < 0) {
    operator delete((void *)__dst);
  }
  HGMetalHandler::BindBuffer((HGMetalHandler *)v8, (HGBitmap *)Buffer);
  if (*((void *)a2 + 21))
  {
    (*(void (**)(std::string *, void, void))(v8->__r_.__value_.__r.__words[0] + 72))(v8, 0, 0);
    (*(void (**)(std::string *, void, void))(v8->__r_.__value_.__r.__words[0] + 48))(v8, 0, 0);
    __n128 v15 = HGMetalHandler::BindTexture((HGMetalTexture ***)v8, 0, (HGBitmap *)*((void *)a2 + 21));
  }
  if (*((void *)a2 + 22))
  {
    (*(void (**)(std::string *, uint64_t, void, __n128))(v8->__r_.__value_.__r.__words[0] + 72))(v8, 1, 0, v15);
    (*(void (**)(std::string *, void, void))(v8->__r_.__value_.__r.__words[0] + 48))(v8, 0, 0);
    __n128 v15 = HGMetalHandler::BindTexture((HGMetalTexture ***)v8, 1, (HGBitmap *)*((void *)a2 + 22));
  }
  if (*((void *)a2 + 23))
  {
    (*(void (**)(std::string *, uint64_t, void, __n128))(v8->__r_.__value_.__r.__words[0] + 72))(v8, 2, 0, v15);
    (*(void (**)(std::string *, void, void))(v8->__r_.__value_.__r.__words[0] + 48))(v8, 0, 0);
    __n128 v15 = HGMetalHandler::BindTexture((HGMetalTexture ***)v8, 2, (HGBitmap *)*((void *)a2 + 23));
  }
  if (*((void *)a2 + 24))
  {
    (*(void (**)(std::string *, uint64_t, void, __n128))(v8->__r_.__value_.__r.__words[0] + 72))(v8, 3, 0, v15);
    (*(void (**)(std::string *, void, void))(v8->__r_.__value_.__r.__words[0] + 48))(v8, 0, 0);
    __n128 v15 = HGMetalHandler::BindTexture((HGMetalTexture ***)v8, 3, (HGBitmap *)*((void *)a2 + 24));
  }
  if (*((void *)a2 + 25))
  {
    (*(void (**)(std::string *, uint64_t, void, __n128))(v8->__r_.__value_.__r.__words[0] + 72))(v8, 4, 0, v15);
    (*(void (**)(std::string *, void, void))(v8->__r_.__value_.__r.__words[0] + 48))(v8, 0, 0);
    __n128 v15 = HGMetalHandler::BindTexture((HGMetalTexture ***)v8, 4, (HGBitmap *)*((void *)a2 + 25));
  }
  if (*((void *)a2 + 26))
  {
    (*(void (**)(std::string *, uint64_t, void, __n128))(v8->__r_.__value_.__r.__words[0] + 72))(v8, 5, 0, v15);
    (*(void (**)(std::string *, void, void))(v8->__r_.__value_.__r.__words[0] + 48))(v8, 0, 0);
    __n128 v15 = HGMetalHandler::BindTexture((HGMetalTexture ***)v8, 5, (HGBitmap *)*((void *)a2 + 26));
  }
  if (*((void *)a2 + 27))
  {
    (*(void (**)(std::string *, uint64_t, void, __n128))(v8->__r_.__value_.__r.__words[0] + 72))(v8, 6, 0, v15);
    (*(void (**)(std::string *, void, void))(v8->__r_.__value_.__r.__words[0] + 48))(v8, 0, 0);
    __n128 v15 = HGMetalHandler::BindTexture((HGMetalTexture ***)v8, 6, (HGBitmap *)*((void *)a2 + 27));
  }
  if (*((void *)a2 + 28))
  {
    (*(void (**)(std::string *, uint64_t, void, __n128))(v8->__r_.__value_.__r.__words[0] + 72))(v8, 7, 0, v15);
    (*(void (**)(std::string *, void, void))(v8->__r_.__value_.__r.__words[0] + 48))(v8, 0, 0);
    HGMetalHandler::BindTexture((HGMetalTexture ***)v8, 7, *((HGBitmap **)a2 + 28));
  }
  double v25 = 0.0;
  double v26 = 0.0;
  v24.n64_u64[0] = 0;
  calculateUniforms((uint64_t)this + 408, (int32x2_t *)(*((void *)a2 + 21) + 20), (int32x2_t *)(*((void *)a2 + 21) + 20), (int *)Buffer + 5, (float32x4_t *)&__dst, (float32x2_t *)&v26, &v25, &v24, 1);
  long long v20 = xmmword_1B7E736B0;
  long long v21 = xmmword_1B7E736C0;
  long long v22 = xmmword_1B7E736D0;
  long long v23 = xmmword_1B7E734D0;
  (*(void (**)(std::string *, long long *))(v8->__r_.__value_.__r.__words[0] + 184))(v8, &v20);
  long long v20 = __dst;
  long long v21 = v28;
  long long v22 = v29;
  long long v23 = v30;
  (*(void (**)(std::string *, long long *))(v8->__r_.__value_.__r.__words[0] + 176))(v8, &v20);
  (*(void (**)(std::string *, void, double, float, double, double))(v8->__r_.__value_.__r.__words[0] + 136))(v8, 0, v26, *((float *)&v26 + 1), 0.0, 0.0);
  (*(void (**)(std::string *, uint64_t, double, float, double, double))(v8->__r_.__value_.__r.__words[0] + 136))(v8, 1, v25, *((float *)&v25 + 1), 0.0, 0.0);
  (*(void (**)(HGNode *, HGPage *, void, std::string *))(*(void *)this + 488))(this, a2, 0, v8);
  if (HGNode::IsInPlaceHardwareBlendingEnabled(this))
  {
    HGMetalHandler::EnableBlending((uint64_t)v8);
    uint64_t v16 = (const HGBlendingInfo *)(*(uint64_t (**)(HGNode *))(*(void *)this + 256))(this);
    __n128 v17 = HGMetalHandler::SetBlendingInfo((HGMetalHandler *)v8, v16);
    float v18 = (__n128 *)(*(uint64_t (**)(HGNode *, __n128))(*(void *)this + 272))(this, v17);
    HGMetalHandler::SetBlendingColor((__n128 *)v8, v18);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2078, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A2078))
  {
    qword_1EB9A20A8 = 0;
    qword_1EB9A20B0 = 0;
    qword_1EB9A20A0 = 0;
    __cxa_atexit((void (*)(void *))_ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEED1B8ne180100Ev, &qword_1EB9A20A0, &dword_1B73F3000);
    __cxa_guard_release(&qword_1EB9A2078);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EB9A2080, memory_order_acquire) != -1)
  {
    *(void *)&long long v20 = &v32;
    float v33 = &v20;
    std::__call_once(&qword_1EB9A2080, &v33, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<getIcosphereP(void)::$_0 &&>>);
  }
  HGMetalHandler::PrimitivesDraw((uint64_t)v8, 3u, (void *)qword_1EB9A20A0, (unint64_t)(qword_1EB9A20A8 - qword_1EB9A20A0) >> 4, (void *)qword_1EB9A20A0);
  (*(void (**)(HGNode *, HGPage *, void, std::string *))(*(void *)this + 496))(this, a2, 0, v8);
LABEL_38:
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&v31);
  return Buffer;
}

void sub_1B77FB588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard((HGPage **)(v28 - 104));
  _Unwind_Resume(a1);
}

float HGEquirectProject::setParams(HGEquirectProject *this, const HGEquirectProjectParams *a2)
{
  long long v2 = *(_OWORD *)&a2->var1[1];
  *(_OWORD *)((char *)this + 408) = *(_OWORD *)a2->var0;
  *(_OWORD *)((char *)this + 424) = v2;
  long long v3 = *(_OWORD *)&a2->var2[2];
  long long v4 = *(_OWORD *)&a2->var6;
  long long v5 = *(_OWORD *)&a2->var14;
  *(_OWORD *)((char *)this + 472) = *(_OWORD *)&a2->var10;
  *(_OWORD *)((char *)this + 488) = v5;
  *(_OWORD *)((char *)this + 440) = v3;
  *(_OWORD *)((char *)this + 456) = v4;
  long long v6 = *(_OWORD *)&a2->var18[1];
  long long v7 = *(_OWORD *)&a2->var19[1];
  long long v8 = *(_OWORD *)&a2->var20[1];
  *(_OWORD *)((char *)this + 548) = *(_OWORD *)a2->var21;
  *(_OWORD *)((char *)this + 520) = v7;
  *(_OWORD *)((char *)this + 536) = v8;
  *(_OWORD *)((char *)this + 504) = v6;
  if (!*((unsigned char *)this + 497))
  {
    *((_DWORD *)this + 133) = 1065353216;
    int v9 = *((_DWORD *)this + 120);
    *((void *)this + 67) = 0;
    *((float *)this + 136) = (float)(v9 / 2);
    *((_DWORD *)this + 137) = 0;
    *((void *)this + 69) = 1065353216;
    *((float *)this + 140) = (float)(*((_DWORD *)this + 121) / 2);
    *((_DWORD *)this + 125) = 1065353216;
    float v10 = (float)-*((_DWORD *)this + 122);
    *((void *)this + 63) = 0;
    *((float *)this + 128) = v10 * 0.5;
    *((_DWORD *)this + 129) = 0;
    *((void *)this + 65) = 1065353216;
    *(float *)&long long v6 = (float)-*((_DWORD *)this + 123) * 0.5;
    *((_DWORD *)this + 132) = v6;
  }
  return *(float *)&v6;
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<getIcosphereP(void)::$_0 &&>>()
{
  __p = 0;
  __n64 v24 = 0;
  uint64_t v25 = 0;
  project_util::generateIcosphere(2, (uint64_t)&__p);
  v0 = __p;
  unint64_t v1 = v24 - (unsigned char *)__p;
  unint64_t v2 = ((v24 - (unsigned char *)__p) >> 2) / 3uLL;
  long long v3 = (void *)qword_1EB9A20A0;
  if (v2 > (qword_1EB9A20B0 - qword_1EB9A20A0) >> 4)
  {
    if ((v1 & 0x8000000000000000) != 0) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v4 = qword_1EB9A20A8;
    long long v5 = operator new(16 * v2);
    uint64_t v6 = (uint64_t)v5 + ((v4 - (void)v3) & 0xFFFFFFFFFFFFFFF0);
    uint64_t v7 = v6;
    if ((void *)v4 != v3)
    {
      uint64_t v7 = (uint64_t)v5 + ((v4 - (void)v3) & 0xFFFFFFFFFFFFFFF0);
      do
      {
        long long v8 = *(_OWORD *)(v4 - 16);
        v4 -= 16;
        *(_OWORD *)(v7 - 16) = v8;
        v7 -= 16;
      }
      while ((void *)v4 != v3);
    }
    qword_1EB9A20A0 = v7;
    qword_1EB9A20A8 = v6;
    qword_1EB9A20B0 = (uint64_t)v5 + 16 * v2;
    if (v3) {
      operator delete(v3);
    }
  }
  if (v1 >= 0xC)
  {
    uint64_t v9 = 0;
    if (v2 <= 1) {
      unint64_t v2 = 1;
    }
    float v10 = (_OWORD *)qword_1EB9A20A8;
    while (1)
    {
      *(void *)&long long v12 = *(void *)v0;
      DWORD2(v12) = v0[2];
      HIDWORD(v12) = 1.0;
      if ((unint64_t)v10 >= qword_1EB9A20B0) {
        break;
      }
      *float v10 = v12;
      uint64_t v11 = (uint64_t)(v10 + 1);
LABEL_16:
      qword_1EB9A20A8 = v11;
      v0 += 3;
      ++v9;
      float v10 = (_OWORD *)v11;
      if (v9 == v2) {
        goto LABEL_9;
      }
    }
    uint64_t v13 = qword_1EB9A20A0;
    uint64_t v14 = ((uint64_t)v10 - qword_1EB9A20A0) >> 4;
    unint64_t v15 = v14 + 1;
    if ((unint64_t)(v14 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v16 = qword_1EB9A20B0 - qword_1EB9A20A0;
    if ((qword_1EB9A20B0 - qword_1EB9A20A0) >> 3 > v15) {
      unint64_t v15 = v16 >> 3;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v15;
    }
    if (v17)
    {
      long long v22 = v12;
      if (v17 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float v18 = (char *)operator new(16 * v17);
      float v19 = &v18[16 * v14];
      *(_OWORD *)float v19 = v22;
      uint64_t v11 = (uint64_t)(v19 + 16);
      if (v10 == (_OWORD *)v13) {
        goto LABEL_31;
      }
    }
    else
    {
      float v18 = 0;
      float v19 = (char *)(16 * v14);
      long long v20 = (_OWORD *)(16 * v14);
      *long long v20 = v12;
      uint64_t v11 = (uint64_t)(v20 + 1);
      if (v10 == (_OWORD *)v13) {
        goto LABEL_31;
      }
    }
    do
    {
      long long v21 = *--v10;
      *((_OWORD *)v19 - 1) = v21;
      v19 -= 16;
    }
    while (v10 != (_OWORD *)v13);
    float v10 = (_OWORD *)qword_1EB9A20A0;
LABEL_31:
    qword_1EB9A20A0 = (uint64_t)v19;
    qword_1EB9A20A8 = v11;
    qword_1EB9A20B0 = (uint64_t)&v18[16 * v17];
    if (v10) {
      operator delete(v10);
    }
    goto LABEL_16;
  }
LABEL_9:
  if (__p)
  {
    __n64 v24 = __p;
    operator delete(__p);
  }
}

void sub_1B77FB8EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGComicQuantize::HGComicQuantize(HGComicQuantize *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10DC170;
  *(void *)(v1 + 408) = 0x3F80000000000000;
  *(_DWORD *)(v1 + 16) |= 0x620u;
}

void HGComicQuantize::~HGComicQuantize(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGComicQuantize::SetParameter(HGComicQuantize *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2 == 1)
  {
    if (*((float *)this + 103) != a3)
    {
      *((float *)this + 103) = a3;
      return 1;
    }
  }
  else
  {
    if (a2) {
      return 0xFFFFFFFFLL;
    }
    if (*((float *)this + 102) != a3)
    {
      *((float *)this + 102) = a3;
      return 1;
    }
  }
  return 0;
}

uint64_t HGComicQuantize::GetDOD(HGComicQuantize *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGRect v13 = a4;
  if (a3) {
    return 0;
  }
  if (HGRect::IsInfinite(&v13)) {
    return *(void *)&v13.var0;
  }
  double v6 = *((float *)this + 103);
  HGTransform::HGTransform((HGTransform *)v12);
  HGTransform::Scale((HGTransform *)v12, v6, v6, 1.0);
  uint64_t v7 = *(const HGTransform **)&v13.var0;
  uint64_t v8 = *(void *)&v13.var2;
  float v10 = HGTransformUtils::MinW(v9);
  *(void *)&v14.var0 = v8;
  uint64_t DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v12, v7, v14, 0.5, v10);
  HGTransform::~HGTransform((HGTransform *)v12);
  return DOD;
}

void sub_1B77FBA94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B77FBAA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGComicQuantize::GetROI(HGComicQuantize *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return HGRectNull;
  }
  uint64_t v5 = *(void *)&a4.var2;
  unint64_t v6 = *(void *)&a4.var0;
  double v7 = 1.0 / *((float *)this + 103);
  HGTransform::HGTransform((HGTransform *)v14);
  HGTransform::Scale((HGTransform *)v14, v7, v7, 1.0);
  *(void *)&v15.var0 = 0;
  *(void *)&v15.var2 = 0;
  float v9 = HGTransformUtils::MinW(v8);
  *(void *)&v17.var0 = v5;
  *(void *)&v15.var0 = HGTransformUtils::GetROI((HGTransformUtils *)v14, v6, v17, 0.5, v9);
  *(void *)&v15.var2 = v10;
  uint64_t v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  uint64_t v13 = v12;
  *(void *)&v16.var0 = v11;
  *(void *)&v16.var2 = v13;
  HGRect::Grow(&v15, v16);
  HGTransform::~HGTransform((HGTransform *)v14);
  return *(void *)&v15.var0;
}

void sub_1B77FBBA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B77FBBB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGComicQuantize::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicQuantize::RenderTile(HGComicQuantize *this, float32x4_t **a2)
{
  float v4 = *((float *)this + 103);
  uint64_t v5 = HGTile::Renderer((HGTile *)a2);
  int v6 = (*(uint64_t (**)(HGComicQuantize *, uint64_t))(*(void *)this + 312))(this, v5);
  int32x2_t v8 = (int32x2_t)*a2;
  int v77 = *((_DWORD *)a2 + 3) - ((unint64_t)*a2 >> 32);
  if (v77 >= 1)
  {
    uint64_t v76 = (*((_DWORD *)a2 + 2) - v8.i32[0]);
    if ((int)v76 >= 1)
    {
      int v9 = v6;
      int v10 = 0;
      *(float32x2_t *)v11.f32 = vadd_f32(vcvt_f32_s32(v8), (float32x2_t)0x3F0000003F000000);
      v11.i64[1] = 0x3F80000000000000;
      float v12 = *((float *)this + 102);
      float v81 = 1.0 / v4;
      uint64_t v13 = a2[2];
      float32x4_t v91 = (float32x4_t)vdupq_n_s32(0x42C80000u);
      float32x4_t v82 = v11;
      do
      {
        int v80 = v10;
        uint64_t v14 = v76;
        float v79 = v13;
        float32x4_t v78 = v11;
        float32x4_t v15 = v11;
        do
        {
          float v19 = a2[10];
          uint64_t v20 = *((int *)a2 + 22);
          float32x4_t v21 = vsubq_f32(vmulq_n_f32(v15, v81), v82);
          float32x4_t v90 = v15;
          if (v9)
          {
            int32x4_t v22 = vaddq_s32(vcvtq_s32_f32(v21), vcltzq_f32(v21));
            float32x2_t v23 = (float32x2_t)vsubq_f32(v21, vcvtq_f32_s32(v22)).u64[0];
            __n64 v24 = &v19[v22.i32[0] + v22.i32[1] * (int)v20];
            float32x4_t v25 = vaddq_f32(*v24, vmulq_n_f32(vsubq_f32(v24[1], *v24), v23.f32[0]));
            float32x4_t v26 = vaddq_f32(v25, vmulq_lane_f32(vsubq_f32(vaddq_f32(v24[v20], vmulq_n_f32(vsubq_f32(v24[(int)v20 + 1], v24[v20]), v23.f32[0])), v25), v23, 1));
            float32x4_t v92 = v26;
            if (v26.f32[0] > 0.04045) {
              goto LABEL_10;
            }
          }
          else
          {
            v32.i64[0] = 0x3F0000003F000000;
            v32.i64[1] = 0x3F0000003F000000;
            float32x4_t v33 = vaddq_f32(v21, v32);
            int32x4_t v34 = vcvtq_s32_f32(v33);
            v33.i64[0] = vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v33)).u64[0];
            float32x4_t v26 = v19[v33.i32[0] + v33.i32[1] * (int)v20];
            float32x4_t v92 = v26;
            if (v26.f32[0] > 0.04045)
            {
LABEL_10:
              float v27 = powf((float)(v26.f32[0] + 0.055) / 1.055, 2.4);
              v26.i32[2] = v92.i32[2];
              float v87 = v27;
              float v28 = v92.f32[1];
              if (v92.f32[1] <= 0.04045) {
                goto LABEL_11;
              }
              goto LABEL_15;
            }
          }
          float v87 = v26.f32[0] / 12.92;
          float v28 = v26.f32[1];
          if (v26.f32[1] <= 0.04045)
          {
LABEL_11:
            float v29 = v28 / 12.92;
            float v30 = v26.f32[2];
            if (v26.f32[2] <= 0.04045) {
              goto LABEL_12;
            }
            goto LABEL_16;
          }
LABEL_15:
          float v29 = powf((float)(v28 + 0.055) / 1.055, 2.4);
          float v30 = v92.f32[2];
          if (v92.f32[2] <= 0.04045)
          {
LABEL_12:
            float v31 = v30 / 12.92;
            goto LABEL_17;
          }
LABEL_16:
          float v85 = v29;
          float v31 = powf((float)(v30 + 0.055) / 1.055, 2.4);
          float v29 = v85;
LABEL_17:
          v35.i64[0] = __PAIR64__(LODWORD(v29), LODWORD(v87));
          v35.i64[1] = LODWORD(v31);
          int8x16_t v36 = (int8x16_t)vmulq_f32(v35, (float32x4_t)xmmword_1B8347600);
          *(float32x2_t *)v36.i8 = vadd_f32(*(float32x2_t *)v36.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL));
          int8x16_t v37 = (int8x16_t)vmulq_f32(v35, (float32x4_t)xmmword_1B7E759E0);
          *(float32x2_t *)v37.i8 = vadd_f32(*(float32x2_t *)v37.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL));
          *(float32x2_t *)v36.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v36.i8, *(int32x2_t *)v37.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v36.i8, *(int32x2_t *)v37.i8));
          int8x16_t v38 = (int8x16_t)vmulq_f32(v35, (float32x4_t)xmmword_1B8347610);
          *(float32x2_t *)v38.i8 = vadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL));
          v36.u64[1] = (unint64_t)vadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v38.i8, 1));
          float32x4_t v39 = vdivq_f32(vmulq_f32((float32x4_t)v36, v91), (float32x4_t)xmmword_1B8347620);
          float32x4_t v88 = v39;
          if (v39.f32[0] <= 0.008856)
          {
            float v41 = (float)(v39.f32[0] * 7.787) + 0.13793;
            float v42 = v39.f32[1];
            if (v39.f32[1] <= 0.008856)
            {
LABEL_19:
              float v43 = (float)(v42 * 7.787) + 0.13793;
              float v44 = v39.f32[2];
              if (v39.f32[2] <= 0.008856) {
                goto LABEL_20;
              }
              goto LABEL_23;
            }
          }
          else
          {
            float v40 = powf(v39.f32[0], 0.33333);
            v39.i32[2] = v88.i32[2];
            float v41 = v40;
            float v42 = v88.f32[1];
            if (v88.f32[1] <= 0.008856) {
              goto LABEL_19;
            }
          }
          float v43 = powf(v42, 0.33333);
          float v44 = v88.f32[2];
          if (v88.f32[2] <= 0.008856)
          {
LABEL_20:
            float v45 = (float)(v44 * 7.787) + 0.13793;
            goto LABEL_24;
          }
LABEL_23:
          float v45 = powf(v44, 0.33333);
LABEL_24:
          v46.i32[3] = 0;
          v46.f32[0] = (float)((float)(v43 * 116.0) + -16.0) / 100.0;
          v46.f32[1] = (float)((float)((float)((float)(v41 - v43) * 500.0) / 127.0) * 0.5) + 0.5;
          v46.f32[2] = (float)((float)((float)((float)(v43 - v45) * 200.0) / 127.0) * 0.5) + 0.5;
          float32x4_t v47 = vmaxnmq_f32(v46, (float32x4_t)0);
          __asm { FMOV            V7.4S, #1.0 }
          float32x4_t v53 = vminnmq_f32(v47, _Q7);
          float v54 = (float)((float)((float)((float)(1.0 / v12) * floorf((float)(v12 * v53.f32[0]) + 0.5)) * 100.0) + 16.0)
              / 116.0;
          float v55 = (float)((float)((float)(v53.f32[1] + -0.5) * 254.0) / 500.0) + v54;
          float v56 = v54 - (float)((float)((float)(v53.f32[2] + -0.5) * 254.0) / 200.0);
          BOOL v57 = v55 <= 0.2069;
          float v58 = v55 * (float)(v55 * v55);
          v59.f32[0] = (float)(v55 + -0.13793) / 7.787;
          if (!v57) {
            v59.f32[0] = v58;
          }
          BOOL v57 = v54 <= 0.2069;
          float v60 = v54 * (float)(v54 * v54);
          float v61 = (float)(v54 + -0.13793) / 7.787;
          if (!v57) {
            float v61 = v60;
          }
          BOOL v57 = v56 <= 0.2069;
          float v62 = v56 * (float)(v56 * v56);
          float v63 = (float)(v56 + -0.13793) / 7.787;
          if (!v57) {
            float v63 = v62;
          }
          v59.f32[1] = v61;
          *(float32x2_t *)v64.f32 = vmul_f32(v59, (float32x2_t)0x42C8000042BE1810);
          v64.f32[2] = v63 * 108.88;
          v64.i32[3] = 0;
          float32x4_t v65 = vdivq_f32(v64, v91);
          int8x16_t v66 = (int8x16_t)vmulq_f32(v65, (float32x4_t)xmmword_1B8347630);
          float v67 = vaddv_f32(vadd_f32(*(float32x2_t *)v66.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v66, v66, 8uLL)));
          float32x4_t v89 = _Q7;
          float32x4_t v84 = v65;
          if (v67 <= 0.0031308)
          {
            float v69 = v67 * 12.92;
          }
          else
          {
            float v68 = powf(v67, 0.41667);
            float32x4_t v65 = v84;
            float v69 = (float)(v68 * 1.055) + -0.055;
          }
          int8x16_t v70 = (int8x16_t)vmulq_f32(v65, (float32x4_t)xmmword_1B8347640);
          float v71 = vaddv_f32(vadd_f32(*(float32x2_t *)v70.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v70, v70, 8uLL)));
          float v86 = v69;
          if (v71 <= 0.0031308)
          {
            *(float *)&long long v7 = v71 * 12.92;
          }
          else
          {
            float v72 = powf(v71, 0.41667);
            float32x4_t v65 = v84;
            *(float *)&long long v7 = (float)(v72 * 1.055) + -0.055;
          }
          int8x16_t v73 = (int8x16_t)vmulq_f32(v65, (float32x4_t)xmmword_1B8347650);
          float v74 = vaddv_f32(vadd_f32(*(float32x2_t *)v73.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v73, v73, 8uLL)));
          if (v74 > 0.0031308)
          {
            long long v83 = v7;
            float v16 = powf(v74, 0.41667);
            long long v7 = v83;
            float v17 = (float)(v16 * 1.055) + -0.055;
          }
          else
          {
            float v17 = v74 * 12.92;
          }
          v18.i64[0] = __PAIR64__(v7, LODWORD(v86));
          v18.i64[1] = __PAIR64__(v92.u32[3], LODWORD(v17));
          *v13++ = vmaxnmq_f32(vminnmq_f32(v18, v89), (float32x4_t)0);
          float32x4_t v15 = vaddq_f32(v90, (float32x4_t)xmmword_1B7E736B0);
          --v14;
        }
        while (v14);
        float32x4_t v11 = vaddq_f32(v78, (float32x4_t)xmmword_1B7E736C0);
        uint64_t v13 = &v79[*((int *)a2 + 6)];
        int v10 = v80 + 1;
      }
      while (v80 + 1 != v77);
    }
  }
  return 0;
}

HGComicQuantize *HGComicQuantize::GetOutput(HGComicQuantize *this, HGRenderer *a2, char *a3)
{
  return this;
}

const char *HGComicQuantize::GetProgram(HGComicQuantize *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) > 0x60B0F) {
    return aMetal10Len0000_401;
  }
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
    return aGlfs10Len00000_5;
  }
  return 0;
}

uint64_t HGComicQuantize::BindTexture(HGComicQuantize *this, HGHandler *a2, uint64_t a3)
{
  if ((a3 & 0x80000000) == 0)
  {
    float v5 = 1.0 / *((float *)this + 103);
    HGHandler::TexCoord(a2, a3, 0, 0, 0);
    (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, v5, v5, 1.0);
  }
  (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, 1, 1);
  return 0;
}

uint64_t HGProfiler::init(uint64_t this)
{
  *(void *)(this + 8) = 0;
  return this;
}

void HGProfiler::HGProfiler(HGProfiler *this)
{
  if (HGProfiler::_first)
  {
    mach_timebase_info((mach_timebase_info_t)&HGProfiler::_tb_init(void)::s_tbinfo);
    LODWORD(v2) = HGProfiler::_tb_init(void)::s_tbinfo;
    LODWORD(v3) = *(_DWORD *)algn_1EB9A24E4;
    *(float *)&unint64_t v2 = (double)v2 * 0.000001 / (double)v3;
    HGProfiler::_tbfreq = v2;
    HGProfiler::_first = 0;
  }
  *((void *)this + 1) = 0;
}

uint64_t HGProfiler::start(HGProfiler *this)
{
  uint64_t result = mach_absolute_time();
  *(void *)this = result;
  return result;
}

uint64_t HGProfiler::stop(HGProfiler *this)
{
  uint64_t result = mach_absolute_time();
  *((void *)this + 1) += result - *(void *)this;
  return result;
}

double HGProfiler::getTime(HGProfiler *this)
{
  return (float)(*(float *)&HGProfiler::_tbfreq * (float)*((unint64_t *)this + 1));
}

uint64_t **HGProfilerGuard<(HGProfilerGuardMode)0>::HGProfilerGuard(uint64_t **a1, uint64_t *a2)
{
  *a1 = a2;
  if (a2) {
    *a2 = mach_absolute_time();
  }
  return a1;
}

void **HGProfilerGuard<(HGProfilerGuardMode)0>::~HGProfilerGuard(void **a1)
{
  if (*a1)
  {
    unint64_t v2 = *a1;
    v2[1] += mach_absolute_time() - *v2;
  }
  return a1;
}

void *HGProfilerGuard<(HGProfilerGuardMode)1>::HGProfilerGuard(void *a1, void *a2)
{
  *a1 = a2;
  if (a2) {
    a2[1] += mach_absolute_time() - *a2;
  }
  return a1;
}

uint64_t **HGProfilerGuard<(HGProfilerGuardMode)1>::~HGProfilerGuard(uint64_t **a1)
{
  if (*a1)
  {
    unint64_t v2 = *a1;
    uint64_t *v2 = mach_absolute_time();
  }
  return a1;
}

void HGBitmapLoader::HGBitmapLoader(HGBitmapLoader *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10DC3D8;
  *(void *)(v1 + 416) = 0;
  *(void *)(v1 + 424) = 0;
  *(void *)(v1 + 408) = 0;
  *(_WORD *)(v1 + 432) = 0;
  *(unsigned char *)(v1 + 434) = 1;
  *(_OWORD *)(v1 + 436) = 0u;
  *(_OWORD *)(v1 + 452) = 0u;
  *(_OWORD *)(v1 + 468) = 0u;
  *(_DWORD *)(v1 + 484) = 0;
  int v2 = *(_DWORD *)(v1 + 16) | 0x600;
  *(_DWORD *)(v1 + 12) = 1112363084;
  *(_DWORD *)(v1 + 16) = v2;
}

void HGBitmapLoader::HGBitmapLoader(HGBitmapLoader *this, HGBitmap *a2)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v4 = &unk_1F10DC3D8;
  *(void *)(v4 + 416) = 0;
  *(void *)(v4 + 424) = 0;
  *(void *)(v4 + 408) = 0;
  *(_DWORD *)(v4 + 12) = 1112363084;
  if (a2)
  {
    (*(void (**)(HGBitmap *))(*(void *)a2 + 16))(a2);
    float v5 = (HGBitmap *)*((void *)this + 51);
    if (v5 == a2)
    {
      (*(void (**)(HGBitmap *))(*(void *)a2 + 24))(a2);
    }
    else
    {
      if (v5) {
        (*(void (**)(HGBitmap *))(*(void *)v5 + 24))(v5);
      }
      *((void *)this + 51) = a2;
    }
  }
  *((_WORD *)this + 216) = 0;
  *((unsigned char *)this + 434) = 1;
  *((_DWORD *)this + 121) = 0;
  *(_OWORD *)((char *)this + 436) = 0u;
  *(_OWORD *)((char *)this + 452) = 0u;
  *(_OWORD *)((char *)this + 468) = 0u;
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B77FC90C(_Unwind_Exception *a1)
{
  uint64_t v4 = v2;
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  uint64_t v6 = *(void *)(v1 + 424);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  uint64_t v7 = *(void *)(v1 + 416);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  if (*v3) {
    (*(void (**)(void))(*(void *)*v3 + 24))(*v3);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGBitmapLoader::~HGBitmapLoader(HGBitmapLoader *this)
{
  *(void *)this = &unk_1F10DC3D8;
  HGBitmapLoader::ReleaseNodes(this);
  uint64_t v2 = *((void *)this + 53);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 51);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v1;
  uint64_t vars8;

  HGBitmapLoader::~HGBitmapLoader(this);

  HGObject::operator delete(v1);
}

uint64_t HGBitmapLoader::ReleaseNodes(HGBitmapLoader *this)
{
  uint64_t v2 = *((void *)this + 55);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 55) = 0;
  }
  uint64_t v3 = *((void *)this + 56);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    *((void *)this + 56) = 0;
  }
  uint64_t v4 = *((void *)this + 57);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
    *((void *)this + 57) = 0;
  }
  uint64_t v5 = *((void *)this + 58);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    *((void *)this + 58) = 0;
  }
  uint64_t v6 = *((void *)this + 59);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
    *((void *)this + 59) = 0;
  }
  uint64_t result = *((void *)this + 60);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    *((void *)this + 60) = 0;
  }
  return result;
}

HGBitmap *HGBitmapLoader::SetBitmap(HGNode *this, HGBitmap *a2, char *a3)
{
  if (*((HGBitmap **)this + 51) != a2)
  {
    HGNode::ClearBits(this, (uint64_t)a2, a3);
    *((unsigned char *)this + 434) = 1;
  }
  if (a2)
  {
    (*(void (**)(HGBitmap *))(*(void *)a2 + 16))(a2);
    uint64_t result = (HGBitmap *)*((void *)this + 51);
    if (result == a2) {
      return (HGBitmap *)(*(uint64_t (**)(HGBitmap *))(*(void *)a2 + 24))(a2);
    }
  }
  else
  {
    uint64_t result = (HGBitmap *)*((void *)this + 51);
    if (!result) {
      return result;
    }
  }
  if (result) {
    uint64_t result = (HGBitmap *)(*(uint64_t (**)(HGBitmap *))(*(void *)result + 24))(result);
  }
  *((void *)this + 51) = a2;
  return result;
}

void sub_1B77FCD28(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGBitmapLoader::SetParameter(HGBitmapLoader *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

BOOL HGBitmapLoader::CanBypassTiling(HGBitmapLoader *this, HGRenderer *a2)
{
  if (!*((void *)this + 51) || ((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) != 0) {
    return 0;
  }
  return (TXParagraphStyleFolder_Factory::version(v5) & 1) != 0
      || *((void *)this + 53)
      || (*(unsigned char *)(*((void *)this + 51) + 12) & 0x30) != 0;
}

BOOL HGBitmapLoader::IsBitmapPadded(HGBitmapUtils **this, HGBitmap *a2)
{
  return HGBitmapUtils::isPadded(this[51], a2);
}

unint64_t HGBitmapLoader::GetDOD(HGBitmapLoader *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 51);
  if (!v4) {
    return 0;
  }
  int v5 = *((_DWORD *)this + 109);
  unsigned int v6 = *(_DWORD *)(v4 + 24);
  unsigned int v7 = v6 - v5;
  BOOL v8 = v5 < 1;
  if (v5 >= 1) {
    unsigned int v9 = *(_DWORD *)(v4 + 20) - v5;
  }
  else {
    unsigned int v9 = *(_DWORD *)(v4 + 20);
  }
  if (v8) {
    uint64_t v10 = v6;
  }
  else {
    uint64_t v10 = v7;
  }
  return v9 | (unint64_t)(v10 << 32);
}

uint64_t HGBitmapLoader::GetBitmapPtr(HGBitmapLoader *this)
{
  return *((void *)this + 51);
}

uint64_t HGBitmapLoader::GetBitmapFormat(HGBitmapLoader *this)
{
  uint64_t v1 = *((void *)this + 51);
  if (v1) {
    return *(unsigned int *)(v1 + 16);
  }
  else {
    return 0;
  }
}

uint64_t HGBitmapLoader::PreRenderOption(uint64_t this, HGRenderer *a2)
{
  if (*(unsigned char *)(this + 432))
  {
    uint64_t v3 = this;
    this = (*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2);
    if ((this & 1) == 0)
    {
      this = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 43);
      if (this == 1)
      {
        int v4 = *(unsigned __int8 *)(v3 + 433);
        this = HGGPURenderer::GetNodeRenderAPI(a2, (HGNode *)v3);
        if (this == 1)
        {
          *(void *)&v10.var0 = HGRenderer::GetROI(a2, (HGNode *)v3);
          *(void *)&v10.var2 = v5;
          unsigned int v6 = &v10;
          if (HGRect::IsNull(&v10)) {
            unsigned int v6 = (HGRect *)(*(void *)(v3 + 408) + 20);
          }
          uint64_t v7 = *(void *)&v6->var0;
          uint64_t v8 = *(void *)&v6->var2;
          MetalContext = (HGMetalContext *)HGGPURenderer::GetMetalContext(a2);
          *(void *)&v11.var0 = v7;
          *(void *)&v11.var2 = v8;
          return (uint64_t)HGBitmapLoader::UploadBitmap((HGMetalContext *)v3, v11, MetalContext, v4 == 0);
        }
      }
    }
  }
  return this;
}

HGMetalContext *HGBitmapLoader::UploadBitmap(HGMetalContext *this, HGRect a2, HGMetalContext *a3, uint64_t a4)
{
  *(void *)&v5.var0 = *(void *)&a2.var2;
  *(void *)&a2.var2 = *((void *)this + 51);
  if (*(void *)&a2.var2)
  {
    unsigned int v6 = this;
    if (!*((void *)this + 53))
    {
      *(void *)&v5.var2 = 1;
      HGMetalTexture::createFromBitmap(a3, (HGMetalContext *)0xD, *(HGBitmap **)&a2.var0, v5, *(uint64_t *)&a2.var2, a4, &v8);
      this = (HGMetalContext *)*((void *)v6 + 53);
      uint64_t v7 = v8;
      if (this == v8)
      {
        if (this) {
          return (HGMetalContext *)(*(uint64_t (**)(HGMetalContext *))(*(void *)this + 24))(this);
        }
      }
      else
      {
        if (this)
        {
          this = (HGMetalContext *)(*(uint64_t (**)(HGMetalContext *))(*(void *)this + 24))(this);
          uint64_t v7 = v8;
        }
        *((void *)v6 + 53) = v7;
      }
    }
  }
  return this;
}

void sub_1B77FD0D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGBitmapLoader::RenderTile(HGBitmapLoader *this, HGTile *a2)
{
  (*(void (**)(void, void))(**((void **)this + 51) + 72))(*((void *)this + 51), *((void *)a2 + 2));
  uint64_t v4 = (*((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1)) * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
  HGStats::UnitStats::readTile(*(uint64_t **)(*((void *)a2 + 42) + 424), (HGNode *)this, v4, *(void *)(*((void *)this + 51) + 56) * v4);
  return 0;
}

uint64_t HGBitmapLoader::RenderPage(HGBitmapLoader *this, const char **a2)
{
  return HGBitmapLoader::RenderPage((uint64_t)this, a2, 0);
}

uint64_t HGBitmapLoader::RenderPage(uint64_t a1, const char **a2, char *a3)
{
  int v3 = (int)a3;
  uint64_t v6 = *(void *)(a1 + 408);
  if (v6 && (*(unsigned char *)(v6 + 12) & 0x10) != 0) {
    HGGPURenderer::ValidateGLSharegroupSupport(*a2, "OpenGL sharegroup : HGBitmapLoader's bitmap is an OpenGL object.", a3);
  }
  uint64_t v7 = (HGBitmap **)(a1 + 408);
  if ((*(unsigned char *)(a1 + 16) & 4) != 0)
  {
    uint64_t v8 = *v7;
    HGEdgePolicy::HGEdgePolicy((uint64_t)v28, 1);
    HGBitmap::SetEdgePolicy(v8, (const HGEdgePolicy *)v28);
  }
  MetalContext = (PCICCTransferFunctionLUT *)HGGPURenderer::GetMetalContext((HGGPURenderer *)*a2);
  HGRect v10 = MetalContext;
  if (!MetalContext)
  {
    LUTEnd = 0;
    uint64_t ROI = HGRenderer::GetROI((HGRenderer *)*a2, (HGNode *)a1);
    uint64_t v14 = v15;
    goto LABEL_13;
  }
  LUTEnd = (HGMetalDeviceInfo *)PCICCTransferFunctionLUT::getLUTEnd(MetalContext);
  uint64_t ROI = HGRenderer::GetROI((HGRenderer *)*a2, (HGNode *)a1);
  uint64_t v14 = v13;
  if (!LUTEnd || !HGMetalDeviceInfo::isApple(LUTEnd))
  {
LABEL_13:
    int Texture = HGGPURenderer::ShouldAllocateTexture((uint64_t)*a2, (int)v14 - (int)ROI, HIDWORD(v14) - HIDWORD(ROI), *((_DWORD *)*v7 + 4), v3 == 1, v3 == 0);
    float v17 = (uint64_t *)(a1 + 424);
    uint64_t v18 = *(void *)(a1 + 424);
    if (v18) {
      goto LABEL_42;
    }
    goto LABEL_14;
  }
  int Texture = 1;
  float v17 = (uint64_t *)(a1 + 424);
  uint64_t v18 = *(void *)(a1 + 424);
  if (v18) {
    goto LABEL_42;
  }
LABEL_14:
  float v19 = *v7;
  if (LUTEnd) {
    int v20 = Texture;
  }
  else {
    int v20 = 0;
  }
  if ((*((unsigned char *)v19 + 12) & 0x30) != 0 || v20 == 0 || HG_RENDERER_ENV::FORCE_FULLSIZE_TEXTURE_UPLOAD != 1) {
    goto LABEL_38;
  }
  if (v3)
  {
    int v23 = *((_DWORD *)v10 + 12);
    *(void *)&v29.var0 = ROI;
    *(void *)&v29.var2 = v14;
    __n64 v24 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)*a2, v29, v19);
    float32x4_t v25 = (HGBitmap *)*v17;
    if ((HGBitmap *)*v17 == v24)
    {
      if (v24) {
        (*(void (**)(HGBitmap *))(*(void *)v24 + 24))(v24);
      }
    }
    else
    {
      if (v25) {
        (*(void (**)(HGBitmap *))(*(void *)v25 + 24))(v25);
      }
      *float v17 = (uint64_t)v24;
    }
    *((_DWORD *)v10 + 12) = v23;
LABEL_38:
    uint64_t v18 = *v17;
    if (*v17) {
      goto LABEL_42;
    }
    goto LABEL_39;
  }
  *(void *)&v30.var0 = ROI;
  *(void *)&v30.var2 = v14;
  uint64_t v18 = HGGPURenderer::ConvertToGLTexture((HGGPURenderer *)*a2, v30, v19);
  uint64_t v26 = *v17;
  if (*v17 == v18)
  {
    if (v18)
    {
      (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
      goto LABEL_38;
    }
LABEL_39:
    uint64_t v18 = *(void *)(a1 + 416);
    if (v18)
    {
      float v17 = (uint64_t *)(a1 + 416);
    }
    else
    {
      uint64_t v18 = (uint64_t)*v7;
      float v17 = (uint64_t *)(a1 + 408);
    }
    goto LABEL_42;
  }
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 24))(v26);
  }
  *float v17 = v18;
  if (!v18) {
    goto LABEL_39;
  }
LABEL_42:
  (*(void (**)(uint64_t))(*(void *)v18 + 16))(v18);
  return *v17;
}

void sub_1B77FD488(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGBitmapLoader::RenderPageMetal(HGBitmapLoader *this, const char **a2)
{
  return HGBitmapLoader::RenderPage((uint64_t)this, a2, (char *)1);
}

uint64_t HGBitmapLoader::SetState(HGBitmapLoader *this, HGRenderer *a2, int a3)
{
  if (a3 == 2)
  {
    uint64_t v6 = *((void *)this + 52);
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
    }
    *((void *)this + 52) = 0;
    uint64_t v7 = *((void *)this + 53);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
    }
    *((void *)this + 53) = 0;
  }

  return HGNode::SetState((uint64_t)this, (uint64_t)a2, a3);
}

HGBitmapLoader *HGBitmapLoader::GetOutput(HGBitmapLoader *this, HGRenderer *a2)
{
  uint64_t v2 = this;
  if (*((void *)this + 51)
    && ((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) == 0
    && *((unsigned char *)v2 + 434))
  {
    int v3 = *(_DWORD *)(*((void *)v2 + 51) + 16);
    *((unsigned char *)v2 + 434) = 0;
    HGBitmapLoader::ReleaseNodes(v2);
    switch(v3)
    {
      case 22:
        uint64_t v4 = (HGBitmapLoader *)*((void *)v2 + 56);
        if (!v4)
        {
          HGRect v5 = (HgcPixelFormatConversion_kV4B_WXYZ_input *)HGObject::operator new(0x1A0uLL);
          *(_OWORD *)HGRect v5 = 0u;
          *((_OWORD *)v5 + 1) = 0u;
          *((_OWORD *)v5 + 2) = 0u;
          *((_OWORD *)v5 + 3) = 0u;
          *((_OWORD *)v5 + 4) = 0u;
          *((_OWORD *)v5 + 5) = 0u;
          *((_OWORD *)v5 + 6) = 0u;
          *((_OWORD *)v5 + 7) = 0u;
          *((_OWORD *)v5 + 8) = 0u;
          *((_OWORD *)v5 + 9) = 0u;
          *((_OWORD *)v5 + 10) = 0u;
          *((_OWORD *)v5 + 11) = 0u;
          *((_OWORD *)v5 + 12) = 0u;
          *((_OWORD *)v5 + 13) = 0u;
          *((_OWORD *)v5 + 14) = 0u;
          *((_OWORD *)v5 + 15) = 0u;
          *((_OWORD *)v5 + 16) = 0u;
          *((_OWORD *)v5 + 17) = 0u;
          *((_OWORD *)v5 + 18) = 0u;
          *((_OWORD *)v5 + 19) = 0u;
          *((_OWORD *)v5 + 20) = 0u;
          *((_OWORD *)v5 + 21) = 0u;
          *((_OWORD *)v5 + 22) = 0u;
          *((_OWORD *)v5 + 23) = 0u;
          *((_OWORD *)v5 + 24) = 0u;
          *((_OWORD *)v5 + 25) = 0u;
          HgcPixelFormatConversion_kV4B_WXYZ_input::HgcPixelFormatConversion_kV4B_WXYZ_input(v5);
        }
        goto LABEL_15;
      case 26:
        uint64_t v4 = (HGBitmapLoader *)*((void *)v2 + 57);
        if (!v4)
        {
          uint64_t v6 = (HgcPixelFormatConversion_kV4S_WXYZ_input *)HGObject::operator new(0x1A0uLL);
          *(_OWORD *)uint64_t v6 = 0u;
          *((_OWORD *)v6 + 1) = 0u;
          *((_OWORD *)v6 + 2) = 0u;
          *((_OWORD *)v6 + 3) = 0u;
          *((_OWORD *)v6 + 4) = 0u;
          *((_OWORD *)v6 + 5) = 0u;
          *((_OWORD *)v6 + 6) = 0u;
          *((_OWORD *)v6 + 7) = 0u;
          *((_OWORD *)v6 + 8) = 0u;
          *((_OWORD *)v6 + 9) = 0u;
          *((_OWORD *)v6 + 10) = 0u;
          *((_OWORD *)v6 + 11) = 0u;
          *((_OWORD *)v6 + 12) = 0u;
          *((_OWORD *)v6 + 13) = 0u;
          *((_OWORD *)v6 + 14) = 0u;
          *((_OWORD *)v6 + 15) = 0u;
          *((_OWORD *)v6 + 16) = 0u;
          *((_OWORD *)v6 + 17) = 0u;
          *((_OWORD *)v6 + 18) = 0u;
          *((_OWORD *)v6 + 19) = 0u;
          *((_OWORD *)v6 + 20) = 0u;
          *((_OWORD *)v6 + 21) = 0u;
          *((_OWORD *)v6 + 22) = 0u;
          *((_OWORD *)v6 + 23) = 0u;
          *((_OWORD *)v6 + 24) = 0u;
          *((_OWORD *)v6 + 25) = 0u;
          HgcPixelFormatConversion_kV4S_WXYZ_input::HgcPixelFormatConversion_kV4S_WXYZ_input(v6);
        }
        goto LABEL_15;
      case 29:
        uint64_t v4 = (HGBitmapLoader *)*((void *)v2 + 58);
        if (!v4)
        {
          uint64_t v7 = (HgcPixelFormatConversion_kV4F_WXYZ_input *)HGObject::operator new(0x1A0uLL);
          *(_OWORD *)uint64_t v7 = 0u;
          *((_OWORD *)v7 + 1) = 0u;
          *((_OWORD *)v7 + 2) = 0u;
          *((_OWORD *)v7 + 3) = 0u;
          *((_OWORD *)v7 + 4) = 0u;
          *((_OWORD *)v7 + 5) = 0u;
          *((_OWORD *)v7 + 6) = 0u;
          *((_OWORD *)v7 + 7) = 0u;
          *((_OWORD *)v7 + 8) = 0u;
          *((_OWORD *)v7 + 9) = 0u;
          *((_OWORD *)v7 + 10) = 0u;
          *((_OWORD *)v7 + 11) = 0u;
          *((_OWORD *)v7 + 12) = 0u;
          *((_OWORD *)v7 + 13) = 0u;
          *((_OWORD *)v7 + 14) = 0u;
          *((_OWORD *)v7 + 15) = 0u;
          *((_OWORD *)v7 + 16) = 0u;
          *((_OWORD *)v7 + 17) = 0u;
          *((_OWORD *)v7 + 18) = 0u;
          *((_OWORD *)v7 + 19) = 0u;
          *((_OWORD *)v7 + 20) = 0u;
          *((_OWORD *)v7 + 21) = 0u;
          *((_OWORD *)v7 + 22) = 0u;
          *((_OWORD *)v7 + 23) = 0u;
          *((_OWORD *)v7 + 24) = 0u;
          *((_OWORD *)v7 + 25) = 0u;
          HgcPixelFormatConversion_kV4F_WXYZ_input::HgcPixelFormatConversion_kV4F_WXYZ_input(v7);
        }
        goto LABEL_15;
      case 32:
        uint64_t v4 = (HGBitmapLoader *)*((void *)v2 + 60);
        if (!v4)
        {
          uint64_t v8 = (HgcPixelFormatConversion_kV4B10Bit_BE_input *)HGObject::operator new(0x1A0uLL);
          *(_OWORD *)uint64_t v8 = 0u;
          *((_OWORD *)v8 + 1) = 0u;
          *((_OWORD *)v8 + 2) = 0u;
          *((_OWORD *)v8 + 3) = 0u;
          *((_OWORD *)v8 + 4) = 0u;
          *((_OWORD *)v8 + 5) = 0u;
          *((_OWORD *)v8 + 6) = 0u;
          *((_OWORD *)v8 + 7) = 0u;
          *((_OWORD *)v8 + 8) = 0u;
          *((_OWORD *)v8 + 9) = 0u;
          *((_OWORD *)v8 + 10) = 0u;
          *((_OWORD *)v8 + 11) = 0u;
          *((_OWORD *)v8 + 12) = 0u;
          *((_OWORD *)v8 + 13) = 0u;
          *((_OWORD *)v8 + 14) = 0u;
          *((_OWORD *)v8 + 15) = 0u;
          *((_OWORD *)v8 + 16) = 0u;
          *((_OWORD *)v8 + 17) = 0u;
          *((_OWORD *)v8 + 18) = 0u;
          *((_OWORD *)v8 + 19) = 0u;
          *((_OWORD *)v8 + 20) = 0u;
          *((_OWORD *)v8 + 21) = 0u;
          *((_OWORD *)v8 + 22) = 0u;
          *((_OWORD *)v8 + 23) = 0u;
          *((_OWORD *)v8 + 24) = 0u;
          *((_OWORD *)v8 + 25) = 0u;
          HgcPixelFormatConversion_kV4B10Bit_BE_input::HgcPixelFormatConversion_kV4B10Bit_BE_input(v8);
        }
        goto LABEL_15;
      case 33:
        uint64_t v4 = (HGBitmapLoader *)*((void *)v2 + 59);
        if (!v4)
        {
          unsigned int v9 = (HgcPixelFormatConversion_kV4S_BE_WXYZ_input *)HGObject::operator new(0x1A0uLL);
          *(_OWORD *)unsigned int v9 = 0u;
          *((_OWORD *)v9 + 1) = 0u;
          *((_OWORD *)v9 + 2) = 0u;
          *((_OWORD *)v9 + 3) = 0u;
          *((_OWORD *)v9 + 4) = 0u;
          *((_OWORD *)v9 + 5) = 0u;
          *((_OWORD *)v9 + 6) = 0u;
          *((_OWORD *)v9 + 7) = 0u;
          *((_OWORD *)v9 + 8) = 0u;
          *((_OWORD *)v9 + 9) = 0u;
          *((_OWORD *)v9 + 10) = 0u;
          *((_OWORD *)v9 + 11) = 0u;
          *((_OWORD *)v9 + 12) = 0u;
          *((_OWORD *)v9 + 13) = 0u;
          *((_OWORD *)v9 + 14) = 0u;
          *((_OWORD *)v9 + 15) = 0u;
          *((_OWORD *)v9 + 16) = 0u;
          *((_OWORD *)v9 + 17) = 0u;
          *((_OWORD *)v9 + 18) = 0u;
          *((_OWORD *)v9 + 19) = 0u;
          *((_OWORD *)v9 + 20) = 0u;
          *((_OWORD *)v9 + 21) = 0u;
          *((_OWORD *)v9 + 22) = 0u;
          *((_OWORD *)v9 + 23) = 0u;
          *((_OWORD *)v9 + 24) = 0u;
          *((_OWORD *)v9 + 25) = 0u;
          HgcPixelFormatConversion_kV4S_BE_WXYZ_input::HgcPixelFormatConversion_kV4S_BE_WXYZ_input(v9);
        }
LABEL_15:
        if (v4 != v2)
        {
          uint64_t v10 = (*(uint64_t (**)(HGBitmapLoader *))(*(void *)v2 + 584))(v2);
          *((void *)v2 + 55) = v10;
          *(unsigned char *)(v10 + 434) = 0;
          (*(void (**)(HGBitmapLoader *, void, uint64_t))(*(void *)v4 + 120))(v4, 0, v10);
          uint64_t v2 = v4;
        }
        break;
      default:
        return v2;
    }
  }
  return v2;
}

void sub_1B77FD914(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77FD928(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77FD93C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77FD950(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77FD964(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGBitmapLoader *HGBitmapLoader::Duplicate(HGBitmap **this)
{
  uint64_t v2 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v2, this[51]);
  return v2;
}

void sub_1B77FD9E0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGCPixelFormatConversion_kV4B_WXYZ_input::~HGCPixelFormatConversion_kV4B_WXYZ_input(HGNode *this)
{
  HgcPixelFormatConversion_kV4B_WXYZ_input::~HgcPixelFormatConversion_kV4B_WXYZ_input(this);

  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4B_WXYZ_input::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4B_WXYZ_input::GetROI(HGCPixelFormatConversion_kV4B_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HGCPixelFormatConversion_kV4S_WXYZ_input::~HGCPixelFormatConversion_kV4S_WXYZ_input(HGNode *this)
{
  HgcPixelFormatConversion_kV4S_WXYZ_input::~HgcPixelFormatConversion_kV4S_WXYZ_input(this);

  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4S_WXYZ_input::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4S_WXYZ_input::GetROI(HGCPixelFormatConversion_kV4S_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HGCPixelFormatConversion_kV4F_WXYZ_input::~HGCPixelFormatConversion_kV4F_WXYZ_input(HGNode *this)
{
  HgcPixelFormatConversion_kV4F_WXYZ_input::~HgcPixelFormatConversion_kV4F_WXYZ_input(this);

  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4F_WXYZ_input::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4F_WXYZ_input::GetROI(HGCPixelFormatConversion_kV4F_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HGCPixelFormatConversion_kV4S_BE_WXYZ_input::~HGCPixelFormatConversion_kV4S_BE_WXYZ_input(HGNode *this)
{
  HgcPixelFormatConversion_kV4S_BE_WXYZ_input::~HgcPixelFormatConversion_kV4S_BE_WXYZ_input(this);

  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4S_BE_WXYZ_input::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4S_BE_WXYZ_input::GetROI(HGCPixelFormatConversion_kV4S_BE_WXYZ_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HGCPixelFormatConversion_kV4B10Bit_BE_input::~HGCPixelFormatConversion_kV4B10Bit_BE_input(HGNode *this)
{
  HgcPixelFormatConversion_kV4B10Bit_BE_input::~HgcPixelFormatConversion_kV4B10Bit_BE_input(this);

  HGObject::operator delete(v1);
}

uint64_t HGCPixelFormatConversion_kV4B10Bit_BE_input::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

uint64_t HGCPixelFormatConversion_kV4B10Bit_BE_input::GetROI(HGCPixelFormatConversion_kV4B10Bit_BE_input *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HGComicSobelOperator::HGComicSobelOperator(HGComicSobelOperator *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10DD258;
  *(_DWORD *)(v1 + 408) = 1065353216;
  *(unsigned char *)(v1 + 412) = 0;
  *(_DWORD *)(v1 + 16) |= 0x600u;
}

void HGComicSobelOperator::~HGComicSobelOperator(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGComicSobelOperator::SetParameter(HGComicSobelOperator *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2)
  {
    if (a2 == 1)
    {
      if (*((float *)this + 102) != a3)
      {
        *((float *)this + 102) = a3;
        return 1;
      }
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    int v7 = a3 == 1.0;
    if (*((unsigned __int8 *)this + 412) == v7) {
      return 0;
    }
    *((unsigned char *)this + 412) = v7;
    return 1;
  }
}

HGComicSobelOperator *HGComicSobelOperator::GetOutput(HGComicSobelOperator *this, HGRenderer *a2, char *a3)
{
  float v4 = 1.0;
  if (!*((unsigned char *)this + 412)) {
    float v4 = 0.0;
  }
  HGNode::SetParameter((HGNode *)this, 0, v4, 0.0, 0.0, 0.0, a3);
  return this;
}

uint64_t HGComicSobelOperator::RenderTile(HGComicSobelOperator *this, float32x4_t **a2)
{
  float v4 = *((float *)this + 102);
  uint64_t v5 = HGTile::Renderer((HGTile *)a2);
  int v6 = (*(uint64_t (**)(HGComicSobelOperator *, uint64_t))(*(void *)this + 312))(this, v5);
  int32x2_t v7 = (int32x2_t)*a2;
  int v8 = *((_DWORD *)a2 + 3) - ((unint64_t)*a2 >> 32);
  if (v8 >= 1)
  {
    uint64_t v9 = (*((_DWORD *)a2 + 2) - v7.i32[0]);
    if ((int)v9 >= 1)
    {
      int v10 = 0;
      *(float32x2_t *)v11.f32 = vadd_f32(vcvt_f32_s32(v7), (float32x2_t)0x3F0000003F000000);
      v11.i64[1] = 0x3F80000000000000;
      int v12 = *((unsigned __int8 *)this + 412);
      float v13 = 1.0 / v4;
      uint64_t v14 = a2[2];
      v15.i64[0] = 0x3F0000003F000000;
      v15.i64[1] = 0x3F0000003F000000;
      v16.i64[0] = 0xC0000000C0000000;
      v16.i64[1] = 0xC0000000C0000000;
      float32x4_t v17 = v11;
      do
      {
        uint64_t v18 = v9;
        float v19 = v14;
        float32x4_t v20 = v17;
        do
        {
          float32x4_t v31 = vmulq_n_f32(v20, v13);
          float32x4_t v32 = a2[10];
          uint64_t v33 = *((int *)a2 + 22);
          float32x4_t v34 = vsubq_f32(vaddq_f32(v31, (float32x4_t)xmmword_1B7E76AE0), v11);
          if (v6)
          {
            int32x4_t v35 = vaddq_s32(vcvtq_s32_f32(v34), vcltzq_f32(v34));
            float32x2_t v36 = (float32x2_t)vsubq_f32(v34, vcvtq_f32_s32(v35)).u64[0];
            int8x16_t v37 = &v32[v35.i32[0] + v35.i32[1] * (int)v33];
            float32x4_t v38 = vaddq_f32(*v37, vmulq_n_f32(vsubq_f32(v37[1], *v37), v36.f32[0]));
            float32x4_t v39 = vaddq_f32(v38, vmulq_lane_f32(vsubq_f32(vaddq_f32(v37[v33], vmulq_n_f32(vsubq_f32(v37[(int)v33 + 1], v37[v33]), v36.f32[0])), v38), v36, 1));
            if (!v12) {
              goto LABEL_12;
            }
          }
          else
          {
            float32x4_t v96 = vaddq_f32(v34, v15);
            float32x4_t v38 = (float32x4_t)vcvtq_s32_f32(v96);
            v96.i64[0] = vaddq_s32((int32x4_t)v38, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v38), v96)).u64[0];
            float32x4_t v39 = v32[v96.i32[0] + v96.i32[1] * (int)v33];
            if (!v12) {
              goto LABEL_12;
            }
          }
          v38.i32[0] = v39.i32[3];
          if (v39.f32[3] < 0.000001) {
            v38.f32[0] = 0.000001;
          }
          float32x4_t v40 = vdivq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 0));
          v40.i32[3] = v39.i32[3];
          float32x4_t v39 = v40;
LABEL_12:
          float32x4_t v41 = vsubq_f32(vaddq_f32(v31, (float32x4_t)xmmword_1B8347760), v11);
          if (v6)
          {
            int32x4_t v42 = vaddq_s32(vcvtq_s32_f32(v41), vcltzq_f32(v41));
            float32x2_t v43 = (float32x2_t)vsubq_f32(v41, vcvtq_f32_s32(v42)).u64[0];
            float v44 = &v32[v42.i32[0] + v42.i32[1] * (int)v33];
            float32x4_t v45 = vaddq_f32(*v44, vmulq_n_f32(vsubq_f32(v44[1], *v44), v43.f32[0]));
            float32x4_t v46 = vaddq_f32(v45, vmulq_lane_f32(vsubq_f32(vaddq_f32(v44[v33], vmulq_n_f32(vsubq_f32(v44[(int)v33 + 1], v44[v33]), v43.f32[0])), v45), v43, 1));
            if (!v12) {
              goto LABEL_17;
            }
          }
          else
          {
            float32x4_t v97 = vaddq_f32(v41, v15);
            float32x4_t v45 = (float32x4_t)vcvtq_s32_f32(v97);
            v97.i64[0] = vaddq_s32((int32x4_t)v45, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v45), v97)).u64[0];
            float32x4_t v46 = v32[v97.i32[0] + v97.i32[1] * (int)v33];
            if (!v12) {
              goto LABEL_17;
            }
          }
          v45.i32[0] = v46.i32[3];
          if (v46.f32[3] < 0.000001) {
            v45.f32[0] = 0.000001;
          }
          float32x4_t v47 = vdivq_f32(v46, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 0));
          v47.i32[3] = v46.i32[3];
          float32x4_t v46 = v47;
LABEL_17:
          float32x4_t v48 = vsubq_f32(vaddq_f32(v31, (float32x4_t)xmmword_1B8347770), v11);
          if (v6)
          {
            int32x4_t v49 = vaddq_s32(vcvtq_s32_f32(v48), vcltzq_f32(v48));
            float32x2_t v50 = (float32x2_t)vsubq_f32(v48, vcvtq_f32_s32(v49)).u64[0];
            float v51 = &v32[v49.i32[0] + v49.i32[1] * (int)v33];
            float32x4_t v52 = vaddq_f32(*v51, vmulq_n_f32(vsubq_f32(v51[1], *v51), v50.f32[0]));
            float32x4_t v53 = vaddq_f32(v52, vmulq_lane_f32(vsubq_f32(vaddq_f32(v51[v33], vmulq_n_f32(vsubq_f32(v51[(int)v33 + 1], v51[v33]), v50.f32[0])), v52), v50, 1));
            if (!v12) {
              goto LABEL_22;
            }
          }
          else
          {
            float32x4_t v98 = vaddq_f32(v48, v15);
            float32x4_t v52 = (float32x4_t)vcvtq_s32_f32(v98);
            v98.i64[0] = vaddq_s32((int32x4_t)v52, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v52), v98)).u64[0];
            float32x4_t v53 = v32[v98.i32[0] + v98.i32[1] * (int)v33];
            if (!v12) {
              goto LABEL_22;
            }
          }
          v52.i32[0] = v53.i32[3];
          if (v53.f32[3] < 0.000001) {
            v52.f32[0] = 0.000001;
          }
          float32x4_t v54 = vdivq_f32(v53, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 0));
          v54.i32[3] = v53.i32[3];
          float32x4_t v53 = v54;
LABEL_22:
          float32x4_t v55 = vsubq_f32(vaddq_f32(v31, (float32x4_t)xmmword_1B7E76AD0), v11);
          if (v6)
          {
            int32x4_t v56 = vaddq_s32(vcvtq_s32_f32(v55), vcltzq_f32(v55));
            float32x2_t v57 = (float32x2_t)vsubq_f32(v55, vcvtq_f32_s32(v56)).u64[0];
            float v58 = &v32[v56.i32[0] + v56.i32[1] * (int)v33];
            float32x4_t v59 = vaddq_f32(*v58, vmulq_n_f32(vsubq_f32(v58[1], *v58), v57.f32[0]));
            float32x4_t v60 = vaddq_f32(v59, vmulq_lane_f32(vsubq_f32(vaddq_f32(v58[v33], vmulq_n_f32(vsubq_f32(v58[(int)v33 + 1], v58[v33]), v57.f32[0])), v59), v57, 1));
            if (!v12) {
              goto LABEL_27;
            }
          }
          else
          {
            float32x4_t v99 = vaddq_f32(v55, v15);
            float32x4_t v59 = (float32x4_t)vcvtq_s32_f32(v99);
            v99.i64[0] = vaddq_s32((int32x4_t)v59, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v59), v99)).u64[0];
            float32x4_t v60 = v32[v99.i32[0] + v99.i32[1] * (int)v33];
            if (!v12) {
              goto LABEL_27;
            }
          }
          v59.i32[0] = v60.i32[3];
          if (v60.f32[3] < 0.000001) {
            v59.f32[0] = 0.000001;
          }
          float32x4_t v61 = vdivq_f32(v60, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.f32, 0));
          v61.i32[3] = v60.i32[3];
          float32x4_t v60 = v61;
LABEL_27:
          float32x4_t v62 = vsubq_f32(vaddq_f32(v31, (float32x4_t)xmmword_1B7E736B0), v11);
          if (v6)
          {
            int32x4_t v63 = vaddq_s32(vcvtq_s32_f32(v62), vcltzq_f32(v62));
            float32x2_t v64 = (float32x2_t)vsubq_f32(v62, vcvtq_f32_s32(v63)).u64[0];
            float32x4_t v65 = &v32[v63.i32[0] + v63.i32[1] * (int)v33];
            float32x4_t v66 = vaddq_f32(*v65, vmulq_n_f32(vsubq_f32(v65[1], *v65), v64.f32[0]));
            float32x4_t v67 = vaddq_f32(v66, vmulq_lane_f32(vsubq_f32(vaddq_f32(v65[v33], vmulq_n_f32(vsubq_f32(v65[(int)v33 + 1], v65[v33]), v64.f32[0])), v66), v64, 1));
            if (!v12) {
              goto LABEL_32;
            }
          }
          else
          {
            float32x4_t v100 = vaddq_f32(v62, v15);
            float32x4_t v66 = (float32x4_t)vcvtq_s32_f32(v100);
            v100.i64[0] = vaddq_s32((int32x4_t)v66, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v66), v100)).u64[0];
            float32x4_t v67 = v32[v100.i32[0] + v100.i32[1] * (int)v33];
            if (!v12) {
              goto LABEL_32;
            }
          }
          v66.i32[0] = v67.i32[3];
          if (v67.f32[3] < 0.000001) {
            v66.f32[0] = 0.000001;
          }
          float32x4_t v68 = vdivq_f32(v67, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v66.f32, 0));
          v68.i32[3] = v67.i32[3];
          float32x4_t v67 = v68;
LABEL_32:
          float32x4_t v69 = vsubq_f32(vaddq_f32(v31, (float32x4_t)xmmword_1B7E76300), v11);
          if (v6)
          {
            int32x4_t v70 = vaddq_s32(vcvtq_s32_f32(v69), vcltzq_f32(v69));
            float32x2_t v71 = (float32x2_t)vsubq_f32(v69, vcvtq_f32_s32(v70)).u64[0];
            float v72 = &v32[v70.i32[0] + v70.i32[1] * (int)v33];
            float32x4_t v73 = vaddq_f32(*v72, vmulq_n_f32(vsubq_f32(v72[1], *v72), v71.f32[0]));
            float32x4_t v74 = vaddq_f32(v73, vmulq_lane_f32(vsubq_f32(vaddq_f32(v72[v33], vmulq_n_f32(vsubq_f32(v72[(int)v33 + 1], v72[v33]), v71.f32[0])), v73), v71, 1));
            if (!v12) {
              goto LABEL_37;
            }
          }
          else
          {
            float32x4_t v101 = vaddq_f32(v69, v15);
            float32x4_t v73 = (float32x4_t)vcvtq_s32_f32(v101);
            v101.i64[0] = vaddq_s32((int32x4_t)v73, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v73), v101)).u64[0];
            float32x4_t v74 = v32[v101.i32[0] + v101.i32[1] * (int)v33];
            if (!v12) {
              goto LABEL_37;
            }
          }
          v73.i32[0] = v74.i32[3];
          if (v74.f32[3] < 0.000001) {
            v73.f32[0] = 0.000001;
          }
          float32x4_t v75 = vdivq_f32(v74, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v73.f32, 0));
          v75.i32[3] = v74.i32[3];
          float32x4_t v74 = v75;
LABEL_37:
          float32x4_t v76 = vsubq_f32(vaddq_f32(v31, (float32x4_t)xmmword_1B83475C0), v11);
          if (v6)
          {
            int32x4_t v77 = vaddq_s32(vcvtq_s32_f32(v76), vcltzq_f32(v76));
            float32x2_t v78 = (float32x2_t)vsubq_f32(v76, vcvtq_f32_s32(v77)).u64[0];
            float v79 = &v32[v77.i32[0] + v77.i32[1] * (int)v33];
            float32x4_t v80 = vaddq_f32(*v79, vmulq_n_f32(vsubq_f32(v79[1], *v79), v78.f32[0]));
            float32x4_t v81 = vaddq_f32(v80, vmulq_lane_f32(vsubq_f32(vaddq_f32(v79[v33], vmulq_n_f32(vsubq_f32(v79[(int)v33 + 1], v79[v33]), v78.f32[0])), v80), v78, 1));
            if (!v12) {
              goto LABEL_42;
            }
          }
          else
          {
            float32x4_t v102 = vaddq_f32(v76, v15);
            float32x4_t v80 = (float32x4_t)vcvtq_s32_f32(v102);
            v102.i64[0] = vaddq_s32((int32x4_t)v80, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v80), v102)).u64[0];
            float32x4_t v81 = v32[v102.i32[0] + v102.i32[1] * (int)v33];
            if (!v12) {
              goto LABEL_42;
            }
          }
          v80.i32[0] = v81.i32[3];
          if (v81.f32[3] < 0.000001) {
            v80.f32[0] = 0.000001;
          }
          float32x4_t v82 = vdivq_f32(v81, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v80.f32, 0));
          v82.i32[3] = v81.i32[3];
          float32x4_t v81 = v82;
LABEL_42:
          float32x4_t v83 = vsubq_f32(vaddq_f32(v31, (float32x4_t)xmmword_1B7E736C0), v11);
          if (v6)
          {
            int32x4_t v84 = vaddq_s32(vcvtq_s32_f32(v83), vcltzq_f32(v83));
            float32x2_t v85 = (float32x2_t)vsubq_f32(v83, vcvtq_f32_s32(v84)).u64[0];
            float v86 = &v32[v84.i32[0] + v84.i32[1] * (int)v33];
            float32x4_t v87 = vaddq_f32(*v86, vmulq_n_f32(vsubq_f32(v86[1], *v86), v85.f32[0]));
            float32x4_t v88 = vaddq_f32(v87, vmulq_lane_f32(vsubq_f32(vaddq_f32(v86[v33], vmulq_n_f32(vsubq_f32(v86[(int)v33 + 1], v86[v33]), v85.f32[0])), v87), v85, 1));
            if (!v12) {
              goto LABEL_47;
            }
          }
          else
          {
            float32x4_t v103 = vaddq_f32(v83, v15);
            float32x4_t v87 = (float32x4_t)vcvtq_s32_f32(v103);
            v103.i64[0] = vaddq_s32((int32x4_t)v87, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v87), v103)).u64[0];
            float32x4_t v88 = v32[v103.i32[0] + v103.i32[1] * (int)v33];
            if (!v12) {
              goto LABEL_47;
            }
          }
          v87.i32[0] = v88.i32[3];
          if (v88.f32[3] < 0.000001) {
            v87.f32[0] = 0.000001;
          }
          float32x4_t v89 = vdivq_f32(v88, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87.f32, 0));
          v89.i32[3] = v88.i32[3];
          float32x4_t v88 = v89;
LABEL_47:
          float32x4_t v90 = vsubq_f32(v31, v11);
          if (v6)
          {
            int32x4_t v91 = vaddq_s32(vcvtq_s32_f32(v90), vcltzq_f32(v90));
            float32x2_t v92 = (float32x2_t)vsubq_f32(v90, vcvtq_f32_s32(v91)).u64[0];
            float v93 = &v32[v91.i32[0] + v91.i32[1] * (int)v33];
            float32x4_t v94 = vaddq_f32(*v93, vmulq_n_f32(vsubq_f32(v93[1], *v93), v92.f32[0]));
            float32x4_t v95 = vaddq_f32(v94, vmulq_lane_f32(vsubq_f32(vaddq_f32(v93[v33], vmulq_n_f32(vsubq_f32(v93[(int)v33 + 1], v93[v33]), v92.f32[0])), v94), v92, 1));
          }
          else
          {
            float32x4_t v104 = vaddq_f32(v90, v15);
            int32x4_t v105 = vcvtq_s32_f32(v104);
            v104.i64[0] = vaddq_s32(v105, vcgtq_f32(vcvtq_f32_s32(v105), v104)).u64[0];
            float32x4_t v95 = v32[v104.i32[0] + v104.i32[1] * (int)v33];
          }
          float32x4_t v21 = vaddq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vmulq_f32(v46, v16), v39), v53), v60), vaddq_f32(v67, v67)), v74);
          float32x4_t v22 = vaddq_f32(v74, vaddq_f32(vaddq_f32(v53, vsubq_f32(vsubq_f32(vmulq_f32(v81, v16), v39), v60)), vaddq_f32(v88, v88)));
          int8x16_t v23 = (int8x16_t)vmulq_f32(v21, v21);
          *(float32x2_t *)v23.i8 = vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL));
          int8x16_t v24 = (int8x16_t)vmulq_f32(v22, v22);
          *(float32x2_t *)v24.i8 = vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
          *(float32x2_t *)v23.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v23.i8, *(int32x2_t *)v24.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v23.i8, *(int32x2_t *)v24.i8));
          int8x16_t v25 = (int8x16_t)vmulq_f32(v21, v22);
          *(float *)&v23.i32[2] = (float)(vaddv_f32(vadd_f32(*(float32x2_t *)v25.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL)))+ 1.0)* 0.5;
          v23.i32[3] = v95.i32[3];
          __asm { FMOV            V25.4S, #1.0 }
          *v19++ = vmaxnmq_f32(vminnmq_f32((float32x4_t)v23, _Q25), (float32x4_t)0);
          float32x4_t v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
          --v18;
        }
        while (v18);
        float32x4_t v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B7E736C0);
        v14 += *((int *)a2 + 6);
        ++v10;
      }
      while (v10 != v8);
    }
  }
  return 0;
}

uint64_t HGComicSobelOperator::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicSobelOperator::GetDOD(HGComicSobelOperator *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGRect v13 = a4;
  if (a3) {
    return 0;
  }
  if (HGRect::IsInfinite(&v13)) {
    return *(void *)&v13.var0;
  }
  double v6 = *((float *)this + 102);
  HGTransform::HGTransform((HGTransform *)v12);
  HGTransform::Scale((HGTransform *)v12, v6, v6, 1.0);
  int32x2_t v7 = *(const HGTransform **)&v13.var0;
  uint64_t v8 = *(void *)&v13.var2;
  float v10 = HGTransformUtils::MinW(v9);
  *(void *)&v14.var0 = v8;
  uint64_t DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v12, v7, v14, 0.5, v10);
  HGTransform::~HGTransform((HGTransform *)v12);
  return DOD;
}

void sub_1B77FE730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B77FE744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGComicSobelOperator::GetROI(HGComicSobelOperator *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return HGRectNull;
  }
  uint64_t v5 = *(void *)&a4.var2;
  unint64_t v6 = *(void *)&a4.var0;
  double v7 = 1.0 / *((float *)this + 102);
  HGTransform::HGTransform((HGTransform *)v17);
  HGTransform::Scale((HGTransform *)v17, v7, v7, 1.0);
  *(void *)&v18.var0 = 0;
  *(void *)&v18.var2 = 0;
  float v9 = HGTransformUtils::MinW(v8);
  *(void *)&v21.var0 = v5;
  *(void *)&v18.var0 = HGTransformUtils::GetROI((HGTransformUtils *)v17, v6, v21, 0.5, v9);
  *(void *)&v18.var2 = v10;
  uint64_t v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  uint64_t v13 = v12;
  *(void *)&v19.var0 = v11;
  *(void *)&v19.var2 = v13;
  HGRect::Grow(&v18, v19);
  uint64_t v14 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  uint64_t v16 = v15;
  *(void *)&v20.var0 = v14;
  *(void *)&v20.var2 = v16;
  HGRect::Grow(&v18, v20);
  HGTransform::~HGTransform((HGTransform *)v17);
  return *(void *)&v18.var0;
}

void sub_1B77FE86C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B77FE880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const char *HGComicSobelOperator::GetProgram(HGComicSobelOperator *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) > 0x60B0F) {
    return "//Metal1.0     \n"
  }
           "//LEN=0000000ac6\n"
           "static half3 texelFetch(texture2d<half> inTex, sampler samp, const float2 uv, const float unpremultiplyAlpha)"
           "\n"
           "{\n"
           "    half4 texel = inTex.sample(samp, uv);\n"
           "    \n"
           "    if (unpremultiplyAlpha)\n"
           "        texel.rgb /= max(texel.a, 1e-6h);\n"
           "    \n"
           "    return texel.rgb;\n"
           "}\n"
           "\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    const float2 d {1.0f, 1.0f};\n"
           "    const float2 uv = frag._texCoord0.xy;\n"
           "    const float unpremultiplyAlpha = hg_Params[0].x;\n"
           "    \n"
           "    const float2 NegNeg     = uv + float2(-d.x, -d.y);\n"
           "    const float2 NegZero    = uv + float2(-d.x,  0.0f);\n"
           "    const float2 NegPos     = uv + float2(-d.x, d.y);\n"
           "    const float2 PosNeg     = uv + float2(d.x, -d.y);\n"
           "    const float2 PosZero    = uv + float2(d.x, 0.0f);\n"
           "    const float2 PosPos     = uv + float2(d.x, d.y);\n"
           "    const float2 ZeroNeg    = uv + float2(0.0f, -d.y);\n"
           "    const float2 ZeroPos    = uv + float2(0.0f, d.y);\n"
           "\n"
           "    const half3 Gx =\n"
           "          (-1.0h * texelFetch(hg_Texture0, hg_Sampler0, NegNeg, unpremultiplyAlpha) +\n"
           "           -2.0h * texelFetch(hg_Texture0, hg_Sampler0, NegZero, unpremultiplyAlpha) +\n"
           "           -1.0h * texelFetch(hg_Texture0, hg_Sampler0, NegPos, unpremultiplyAlpha) +\n"
           "           +1.0h * texelFetch(hg_Texture0, hg_Sampler0, PosNeg, unpremultiplyAlpha) +\n"
           "           +2.0h * texelFetch(hg_Texture0, hg_Sampler0, PosZero, unpremultiplyAlpha) +\n"
           "           +1.0h * texelFetch(hg_Texture0, hg_Sampler0, PosPos, unpremultiplyAlpha));\n"
           "\n"
           "    const half3 Gy =\n"
           "          (-1.0h * texelFetch(hg_Texture0, hg_Sampler0, NegNeg, unpremultiplyAlpha) +\n"
           "           -2.0h * texelFetch(hg_Texture0, hg_Sampler0, ZeroNeg, unpremultiplyAlpha) +\n"
           "           -1.0h * texelFetch(hg_Texture0, hg_Sampler0, PosNeg, unpremultiplyAlpha) +\n"
           "           +1.0h * texelFetch(hg_Texture0, hg_Sampler0, NegPos, unpremultiplyAlpha) +\n"
           "           +2.0h * texelFetch(hg_Texture0, hg_Sampler0, ZeroPos, unpremultiplyAlpha) +\n"
           "           +1.0h * texelFetch(hg_Texture0, hg_Sampler0, PosPos, unpremultiplyAlpha));\n"
           "    \n"
           "    FragmentOut out {float4(dot(Gx, Gx), \n"
           "                            dot(Gy, Gy), \n"
           "                            0.5h * (1.0h + dot(Gx, Gy)),\n"
           "                            hg_Texture0.sample(hg_Sampler0, uv).a)};\n"
           "\n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "\n"
           "    return out;\n"
           "}\n"
           "//MD5=eef67a33:7b0e8e00:aeded09b:2240fcf5\n"
           "//SIG=00000000:00000000:00000000:00000001:0018:0001:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
    return "//GLfs1.0      \n"
  }
           "//LEN=0000000a47\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp\n"
           "\n"
           "uniform sampler2DRect inputTexture;\n"
           ""uniform highp vec4 hg_ProgramLocal0;
           "\n"
           "highp vec3 texelFetch(sampler2DRect inTex, highp vec2 uv, lowp float unpremultiplyAlpha)\n"
           "{\n"
           "    vec4 texel = texture2DRect(inTex, uv);\n"
           "    \n"
           "    // Select for alpha-premultiplication (or) depending on wether the flag (unpremultiplyAlpha)\n"
           "    // is set (1.0) or not (0.0).\n"
           "    return  (texel.rgb /= max(texel.a, 1e-6)) * unpremultiplyAlpha +\n"
           "            texel.rgb * (1.0 - unpremultiplyAlpha);\n"
           "}\n"
           "\n"
           "void main()\n"
           "{\n"
           "    highp vec2 d = vec2(1.0, 1.0);\n"
           "    highp vec2 uv = gl_TexCoord[0].xy;\n"
           "    lowp float unpremultiplyAlpha = hg_ProgramLocal0.x;\n"
           "    \n"
           "    vec2 NegNeg     = uv + vec2(-d.x, -d.y);\n"
           "    vec2 NegZero    = uv + vec2(-d.x,  0.0);\n"
           "    vec2 NegPos     = uv + vec2(-d.x, d.y);\n"
           "    vec2 PosNeg     = uv + vec2(d.x, -d.y);\n"
           "    vec2 PosZero    = uv + vec2(d.x, 0.0);\n"
           "    vec2 PosPos     = uv + vec2(d.x, d.y);\n"
           "    vec2 ZeroNeg    = uv + vec2(0.0, -d.y);\n"
           "    vec2 ZeroPos    = uv + vec2(0.0, d.y);\n"
           "\n"
           "    highp vec3 Gx = (\n"
           "               -1.0 * texelFetch(inputTexture, NegNeg, unpremultiplyAlpha) +\n"
           "               -2.0 * texelFetch(inputTexture, NegZero, unpremultiplyAlpha) +\n"
           "               -1.0 * texelFetch(inputTexture, NegPos, unpremultiplyAlpha) +\n"
           "               +1.0 * texelFetch(inputTexture, PosNeg, unpremultiplyAlpha) +\n"
           "               +2.0 * texelFetch(inputTexture, PosZero, unpremultiplyAlpha) +\n"
           "               +1.0 * texelFetch(inputTexture, PosPos, unpremultiplyAlpha))  ;\n"
           "\n"
           "    highp vec3 Gy =(\n"
           "                -1.0 * texelFetch(inputTexture, NegNeg, unpremultiplyAlpha) +\n"
           "                -2.0 * texelFetch(inputTexture, ZeroNeg, unpremultiplyAlpha) +\n"
           "                -1.0 * texelFetch(inputTexture, PosNeg, unpremultiplyAlpha) +\n"
           "                +1.0 * texelFetch(inputTexture, NegPos, unpremultiplyAlpha) +\n"
           "                +2.0 * texelFetch(inputTexture, ZeroPos, unpremultiplyAlpha) +\n"
           "                +1.0 * texelFetch(inputTexture, PosPos, unpremultiplyAlpha))  ;\n"
           "    \n"
           "    highp vec4 uint64_t result = vec4(dot(Gx, Gx), \n"
           "                             dot(Gy, Gy), \n"
           "                             0.5 * (1.0 + dot(Gx, Gy)),\n"
           "                             texture2DRect(inputTexture, uv).a);\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    gl_FragColor = clamp(result, 0.0, 1.0);\n"
           "}\n"
           "//MD5=776e3a33:fba055f3:576fbb1b:bf6537a1\n"
           "//SIG=00000000:00000000:00000000:00000000:0030:0001:0000:0000:0000:0000:0000:0000:0001:00:0:1:0\n";
  return 0;
}

uint64_t HGComicSobelOperator::BindTexture(HGComicSobelOperator *this, HGHandler *a2, uint64_t a3)
{
  if (a3)
  {
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
  }
  else
  {
    float v5 = 1.0 / *((float *)this + 102);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, v5, v5, 1.0);
  }
  (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, 1, 1);
  return 0;
}

void HGLodFilter::HGLodFilter(HGLodFilter *this)
{
  HGMipmapLevel::HGMipmapLevel(this);
  void *v1 = &unk_1F10DD4C0;
  operator new();
}

void sub_1B77FEB2C(_Unwind_Exception *a1)
{
  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HGLodFilter::~HGLodFilter(HGLodFilter *this)
{
  *(void *)this = &unk_1F10DD4C0;
  uint64_t v2 = *((void *)this + 54);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 55);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 52);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *((void *)this + 53);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  uint64_t v6 = *((void *)this + 72);
  if (v6) {
    MEMORY[0x1BA9BFBA0](v6, 0x1000C40FA0F61DDLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  void *v1;
  uint64_t vars8;

  HGLodFilter::~HGLodFilter(this);

  HGObject::operator delete(v1);
}

uint64_t HGLodFilter::SetInput(HGNode *this, int a2, HGNode *a3)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return HGNode::SetInput(this, 0, a3);
  }
}

uint64_t HGLodFilter::SetLevel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  *(_DWORD *)(a1 + 408) = a6;
  *(_DWORD *)(a1 + 412) = a7;
  if (!a7)
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 456) = 0;
    *(_DWORD *)(a1 + 488) = 0;
    return result;
  }
  *(_DWORD *)(a1 + 484) = 0;
  uint64_t v10 = (_OWORD *)(a1 + 488);
  *(_DWORD *)(a1 + 516) = 0;
  uint64_t v11 = (_OWORD *)(a1 + 552);
  *(void *)(a1 + 552) = a2;
  *(void *)(a1 + 560) = a3;
  if (a7 != 3)
  {
    *(void *)(a1 + 520) = HGRectMake4i(0x80000000, 0x80000000, 0x7FFFFFFFu, 0x7FFFFFFFu);
    *(void *)(a1 + 528) = v25;
    long long v26 = *(_OWORD *)(a1 + 520);
    *(_OWORD *)(a1 + 536) = v26;
    *uint64_t v11 = v26;
    *(_DWORD *)(a1 + 488) = a7;
    *(_DWORD *)(a1 + 456) = a7;
    *(_DWORD *)(a1 + 492) = a6;
    *(_DWORD *)(a1 + 460) = a6;
    *(_DWORD *)(a1 + 496) = 1;
    *(_DWORD *)(a1 + 464) = 1;
    *(void *)(a1 + 508) = 0x100000000;
    *(void *)(a1 + 476) = 0x100000000;
    goto LABEL_63;
  }
  unsigned int v12 = HIDWORD(a3) - HIDWORD(a2);
  unsigned int v13 = a3 - a2;
  if ((a3 - a2) < 2)
  {
    int v27 = 0;
    *(_DWORD *)(a1 + 520) = a2;
    *(_DWORD *)(a1 + 536) = a2;
    *(_DWORD *)(a1 + 528) = a3;
    *(_DWORD *)(a1 + 544) = a3;
    *(_DWORD *)(a1 + 464) = 0;
    *(void *)(a1 + 456) = 0;
    long long v28 = 0uLL;
    long long v29 = 0uLL;
    *(_DWORD *)(a1 + 476) = 0;
    *(_DWORD *)(a1 + 484) = a2;
    int v30 = 1;
    *(_DWORD *)(a1 + 480) = 1;
    if (v12 >= 2) {
      goto LABEL_32;
    }
LABEL_22:
    int v33 = 0;
    *(_DWORD *)(a1 + 524) = HIDWORD(a2);
    *(_DWORD *)(a1 + 540) = HIDWORD(a2);
    *(_DWORD *)(a1 + 532) = HIDWORD(a3);
    *(_DWORD *)(a1 + 548) = HIDWORD(a3);
    *(_DWORD *)(a1 + 496) = 0;
    *(void *)(a1 + 488) = 0;
    long long v34 = 0uLL;
    long long v35 = 0uLL;
    *(_DWORD *)(a1 + 508) = 0;
    *(_DWORD *)(a1 + 516) = HIDWORD(a2);
    *(_DWORD *)(a1 + 512) = 1;
    if (v27 != 3) {
      goto LABEL_46;
    }
    goto LABEL_56;
  }
  int v14 = 1;
  if (a6 >= 2)
  {
    do
    {
      BOOL v15 = __CFADD__(v13, 1);
      unsigned int v13 = (v13 + 1) >> 1;
      if (v15) {
        unsigned int v13 = 0x80000000;
      }
      ++v14;
    }
    while (v13 >= 2 && v14 < a6);
  }
  int v17 = v14 - (v14 == a6);
  double v18 = (double)(int)a2;
  int v19 = 1 << v17;
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v20 = (uint64_t)rint(trunc(v18 / (double)v19));
    *(_DWORD *)(a1 + 536) = v20;
    int v21 = v13 + v20;
    *(_DWORD *)(a1 + 544) = v13 + v20;
    if (v13 != 1)
    {
      int v22 = v17 + 1;
      uint64_t v23 = (uint64_t)rint(trunc(v18 / (double)(1 << v22)));
      goto LABEL_26;
    }
    goto LABEL_21;
  }
  double v31 = (double)(v19 + 0x7FFFFFFF);
  uint64_t v32 = (uint64_t)rint(trunc((v18 - (double)(v19 - 1)) / (double)v19));
  LODWORD(v20) = (int)0x80000000 / v19;
  if (v31 <= v18) {
    LODWORD(v20) = v32;
  }
  *(_DWORD *)(a1 + 536) = v20;
  int v21 = v20 + v13;
  *(_DWORD *)(a1 + 544) = v20 + v13;
  if (v13 == 1)
  {
LABEL_21:
    int v27 = 0;
    *(_DWORD *)(a1 + 520) = v20;
    *(_DWORD *)(a1 + 528) = v21;
    *(_DWORD *)(a1 + 456) = 0;
    *(_DWORD *)(a1 + 464) = 0;
    long long v28 = 0uLL;
    long long v29 = 0uLL;
    *(_DWORD *)(a1 + 460) = v17;
    *(_DWORD *)(a1 + 476) = 0;
    *(_DWORD *)(a1 + 484) = v20;
    int v30 = 1;
    *(_DWORD *)(a1 + 480) = 1;
    if (v12 >= 2) {
      goto LABEL_32;
    }
    goto LABEL_22;
  }
  int v22 = v17 + 1;
  uint64_t v23 = (uint64_t)rint(trunc((v18 - (double)((1 << v22) - 1)) / (double)(1 << v22)));
  if ((double)((1 << v22) + 0x7FFFFFFF) > v18) {
    LODWORD(v23) = (int)0x80000000 / (1 << v22);
  }
LABEL_26:
  *(_DWORD *)(a1 + 520) = v23;
  unsigned int v36 = (v13 + 1) >> 1;
  if (v13 == -1) {
    unsigned int v36 = 0x80000000;
  }
  *(_DWORD *)(a1 + 528) = v23 + v36;
  if (v13)
  {
    double v37 = 1.0 / ((double)v36 + (double)v36);
    *(float *)&unsigned int v38 = v37;
    HIDWORD(v28) = 0;
    *(void *)&long long v28 = v38;
    LODWORD(v29) = 0;
    *((float *)&v28 + 2) = -*(float *)&v38;
    float v39 = v37 * (double)(v36 + 1);
    *(float *)&double v37 = v37 * (double)(v36 - 1);
    *((float *)&v29 + 1) = v39;
    *((void *)&v29 + 1) = LODWORD(v37);
    int v27 = 3;
  }
  else
  {
    int v27 = 2;
    long long v28 = 0uLL;
    long long v29 = 0uLL;
  }
  *(_DWORD *)(a1 + 456) = v27;
  *(_DWORD *)(a1 + 464) = 1;
  *(_DWORD *)(a1 + 460) = v22;
  *(_DWORD *)(a1 + 476) = v20 - 2 * v23;
  *(_DWORD *)(a1 + 484) = v23;
  int v30 = 1;
  *(_DWORD *)(a1 + 480) = 1;
  if (v12 < 2) {
    goto LABEL_22;
  }
LABEL_32:
  if (a6 >= 2)
  {
    do
    {
      BOOL v15 = __CFADD__(v12, 1);
      unsigned int v12 = (v12 + 1) >> 1;
      if (v15) {
        unsigned int v12 = 0x80000000;
      }
      ++v30;
    }
    while (v12 >= 2 && v30 < a6);
  }
  int v41 = v30 - (v30 == a6);
  double v42 = (double)SHIDWORD(a2);
  int v43 = 1 << v41;
  if ((a2 & 0x8000000000000000) == 0)
  {
    uint64_t v44 = (uint64_t)rint(trunc(v42 / (double)v43));
    *(_DWORD *)(a1 + 540) = v44;
    int v45 = v12 + v44;
    *(_DWORD *)(a1 + 548) = v12 + v44;
    if (v12 != 1)
    {
      int v46 = v41 + 1;
      uint64_t v47 = (uint64_t)rint(trunc(v42 / (double)(1 << v46)));
      goto LABEL_50;
    }
    goto LABEL_45;
  }
  double v48 = (double)(v43 + 0x7FFFFFFF);
  uint64_t v49 = (uint64_t)rint(trunc((v42 - (double)(v43 - 1)) / (double)v43));
  LODWORD(v44) = (int)0x80000000 / v43;
  if (v48 <= v42) {
    LODWORD(v44) = v49;
  }
  *(_DWORD *)(a1 + 540) = v44;
  int v45 = v44 + v12;
  *(_DWORD *)(a1 + 548) = v44 + v12;
  if (v12 == 1)
  {
LABEL_45:
    int v33 = 0;
    *(_DWORD *)(a1 + 524) = v44;
    *(_DWORD *)(a1 + 532) = v45;
    *(_DWORD *)(a1 + 488) = 0;
    *(_DWORD *)(a1 + 496) = 0;
    long long v34 = 0uLL;
    long long v35 = 0uLL;
    *(_DWORD *)(a1 + 492) = v41;
    *(_DWORD *)(a1 + 508) = 0;
    *(_DWORD *)(a1 + 516) = v44;
    *(_DWORD *)(a1 + 512) = 1;
    if (v27 != 3) {
      goto LABEL_46;
    }
LABEL_56:
    if (v33 == 3)
    {
      uint64_t v54 = *(void *)(a1 + 416);
      if (!v54)
      {
        float32x4_t v55 = (HGMipmapLevel *)HGObject::operator new(0x250uLL);
        HGMipmapLevel::HGMipmapLevel(v55);
        *(void *)float32x4_t v55 = &unk_1F10DD4C0;
        operator new();
      }
      long long v56 = *(_OWORD *)(a1 + 472);
      *(_OWORD *)(v54 + 456) = *(_OWORD *)(a1 + 456);
      *(_OWORD *)(v54 + 472) = v56;
      *(_OWORD *)(*(void *)(a1 + 416) + 552) = *v11;
      *(_OWORD *)(*(void *)(a1 + 416) + 536) = *(_OWORD *)(a1 + 536);
      uint64_t v57 = *(void *)(a1 + 416);
      *(_DWORD *)(v57 + 520) = *(_DWORD *)(a1 + 520);
      *(_DWORD *)(v57 + 528) = *(_DWORD *)(a1 + 528);
      *(_DWORD *)(v57 + 524) = *(_DWORD *)(a1 + 540);
      *(_DWORD *)(v57 + 532) = *(_DWORD *)(a1 + 548);
      *(_OWORD *)*(void *)(v57 + 576) = v28;
      *(_OWORD *)(*(void *)(*(void *)(a1 + 416) + 576) + 32) = v29;
      uint64_t v58 = *(void *)(a1 + 416);
      LODWORD(v57) = *(_DWORD *)(a1 + 492) - 1;
      *(_DWORD *)(v58 + 488) = 0;
      *(_DWORD *)(v58 + 492) = v57;
      *(void *)(v58 + 496) = 0x3F00000000000000;
      *(_OWORD *)(v58 + 504) = xmmword_1B7EBF8F0;
      uint64_t v59 = *(void *)(a1 + 424);
      if (!v59)
      {
        float32x4_t v60 = (HGMipmapLevel *)HGObject::operator new(0x250uLL);
        HGMipmapLevel::HGMipmapLevel(v60);
        *(void *)float32x4_t v60 = &unk_1F10DD4C0;
        operator new();
      }
      int v61 = *(_DWORD *)(a1 + 460);
      *(_DWORD *)(v59 + 456) = 0;
      *(_DWORD *)(v59 + 460) = v61;
      *(void *)(v59 + 464) = 0x3F00000000000000;
      *(_OWORD *)(v59 + 472) = xmmword_1B7EBF8F0;
      long long v62 = *(_OWORD *)(a1 + 504);
      *(_OWORD *)(v59 + 488) = *v10;
      *(_OWORD *)(v59 + 504) = v62;
      *(_OWORD *)(*(void *)(a1 + 424) + 552) = *v11;
      *(_OWORD *)(*(void *)(a1 + 424) + 536) = *(_OWORD *)(*(void *)(a1 + 416) + 520);
      *(_OWORD *)(*(void *)(a1 + 424) + 520) = *(_OWORD *)(a1 + 520);
      *(_OWORD *)*(void *)(*(void *)(a1 + 424) + 576) = v34;
      *(_OWORD *)(*(void *)(*(void *)(a1 + 424) + 576) + 32) = v35;
    }
    else
    {
      *(_OWORD *)*(void *)(a1 + 576) = v28;
      *(_OWORD *)(*(void *)(a1 + 576) + 32) = v29;
    }
    goto LABEL_63;
  }
  int v46 = v41 + 1;
  uint64_t v47 = (uint64_t)rint(trunc((v42 - (double)((1 << v46) - 1)) / (double)(1 << v46)));
  if ((double)((1 << v46) + 0x7FFFFFFF) > v42) {
    LODWORD(v47) = (int)0x80000000 / (1 << v46);
  }
LABEL_50:
  *(_DWORD *)(a1 + 524) = v47;
  unsigned int v50 = (v12 + 1) >> 1;
  if (v12 == -1) {
    unsigned int v50 = 0x80000000;
  }
  *(_DWORD *)(a1 + 532) = v47 + v50;
  if (v12)
  {
    double v51 = 1.0 / ((double)v50 + (double)v50);
    *(float *)&unsigned int v52 = v51;
    HIDWORD(v34) = 0;
    *(void *)&long long v34 = v52;
    LODWORD(v35) = 0;
    *((float *)&v34 + 2) = -*(float *)&v52;
    float v53 = v51 * (double)(v50 + 1);
    *(float *)&double v51 = v51 * (double)(v50 - 1);
    *((float *)&v35 + 1) = v53;
    *((void *)&v35 + 1) = LODWORD(v51);
    int v33 = 3;
  }
  else
  {
    int v33 = 2;
    long long v34 = 0uLL;
    long long v35 = 0uLL;
  }
  *(_DWORD *)(a1 + 488) = v33;
  *(_DWORD *)(a1 + 496) = 1;
  *(_DWORD *)(a1 + 492) = v46;
  *(_DWORD *)(a1 + 508) = v44 - 2 * v47;
  *(_DWORD *)(a1 + 516) = v47;
  *(_DWORD *)(a1 + 512) = 1;
  if (v27 == 3) {
    goto LABEL_56;
  }
LABEL_46:
  if (v33 == 3)
  {
    *(_OWORD *)*(void *)(a1 + 576) = v34;
    *(_OWORD *)(*(void *)(a1 + 576) + 32) = v35;
  }
LABEL_63:
  *(_DWORD *)(a1 + 472) = 1 << *(_DWORD *)(a1 + 464);
  *(_DWORD *)(a1 + 504) = 1 << *(_DWORD *)(a1 + 496);
  int v63 = *(_DWORD *)(a1 + 456);
  if ((v63 == 4 || *(_DWORD *)v10 == 4) && !*(void *)(a1 + 432))
  {
    float32x2_t v64 = (HGBlur *)HGObject::operator new(0x220uLL);
    HGBlur::HGBlur(v64);
    *(void *)(a1 + 432) = v64;
    *((_DWORD *)v64 + 106) = 1;
    int v63 = *(_DWORD *)(a1 + 456);
    if (v63 == 5) {
      goto LABEL_71;
    }
  }
  else if (v63 == 5)
  {
    goto LABEL_71;
  }
  if ((v63 & 0xFFFFFFFE) == 6 || (*(_DWORD *)v10 - 5) <= 2)
  {
LABEL_71:
    if (!*(void *)(a1 + 440))
    {
      float32x4_t v65 = (HGConvolution *)HGObject::operator new(0x220uLL);
      HGConvolution::HGConvolution(v65);
      *(void *)(a1 + 440) = v65;
      int v63 = *(_DWORD *)(a1 + 456);
    }
  }
  if (*(_DWORD *)v10 | v63) {
    return (a6 - 1);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void sub_1B77FF608(_Unwind_Exception *a1)
{
  HGMipmapLevel::~HGMipmapLevel(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77FF638(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77FF64C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77FF660(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGLodFilter::SetParameter(HGLodFilter *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  if (*((_DWORD *)this + 116) != (int)a3)
  {
    *((_DWORD *)this + 116) = (int)a3;
    int v8 = 1;
    int v9 = (int)a4;
    if (*((_DWORD *)this + 124) == (int)a4) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  int v8 = 0;
  int v9 = (int)a4;
  if (*((_DWORD *)this + 124) != (int)a4)
  {
LABEL_7:
    *((_DWORD *)this + 124) = v9;
    int v8 = 1;
  }
LABEL_8:
  if (*((float *)this + 117) != a5)
  {
    *((float *)this + 117) = a5;
    if (*((float *)this + 125) == a6) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (*((float *)this + 125) != a6)
  {
LABEL_12:
    *((float *)this + 125) = a6;
LABEL_13:
    HGNode::ClearBits((HGNode *)this, a2, a7);
    return 1;
  }
  if (v8) {
    goto LABEL_13;
  }
  return 0;
}

HGLodFilter *HGLodFilter::GetOutput(HGLodFilter *this, HGRenderer *a2)
{
  uint64_t v4 = (*(uint64_t (**)(HGLodFilter *, void))(*(void *)this + 128))(this, 0);
  int v5 = *((_DWORD *)this + 114);
  if (!v5)
  {
    int v6 = *((_DWORD *)this + 122);
    if (!v6)
    {
      uint64_t v43 = *((void *)this + 71);
      Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
      if (!v43) {
        return (HGLodFilter *)Input;
      }
      double v42 = *(void (**)(uint64_t, void, HGLodFilter *))(*(void *)v43 + 120);
      uint64_t v41 = v43;
      goto LABEL_50;
    }
LABEL_5:
    if (v6 == 4) {
      goto LABEL_6;
    }
    if ((v5 - 5) < 3 || (v6 - 5) <= 2)
    {
      (*(void (**)(void, void, uint64_t))(**((void **)this + 55) + 120))(*((void *)this + 55), 0, v4);
      float v27 = (float)(1 << *((_DWORD *)this + 116));
      float v28 = (float)(1 << *((_DWORD *)this + 124));
      unsigned __int8 v29 = atomic_load(HGLogger::_enabled);
      if (v29) {
        HGLogger::log((HGLogger *)"lodfilter", (const char *)1, (HGLogger *)"scalex = %.3f, scaley = %.3f, level = %d\n", v25, v26, v27, v28, *((unsigned int *)this + 115));
      }
      HGLinearFilter2D::HGLinearFilter2D((HGLinearFilter2D *)v48);
      HGLinearFilter2D::HGLinearFilter2D((HGLinearFilter2D *)v47);
      int v30 = *((_DWORD *)this + 114);
      if (v30 == 7) {
        unsigned int v31 = 2;
      }
      else {
        unsigned int v31 = v30 == 6;
      }
      int v32 = *((_DWORD *)this + 122);
      if (v32 == 7) {
        unsigned int v33 = 2;
      }
      else {
        unsigned int v33 = v32 == 6;
      }
      *((_DWORD *)this + 112) = HGPrefilterUtils::GetPrefilterRadius(v31, *((float *)this + 117), v27);
      *((_DWORD *)this + 113) = HGPrefilterUtils::GetPrefilterRadius(v33, *((float *)this + 125), v28);
      HGPrefilterUtils::GetSeparablePrefilter(v48, v31, 0, *((float *)this + 117), v27, 1.0 / v27);
      HGPrefilterUtils::GetSeparablePrefilter(v47, v33, 1, *((float *)this + 125), v28, 1.0 / v28);
      HGConvolution::SeparableFilter2D(*((HGConvolution **)this + 55), (const HGLinearFilter2D *)v48, (const HGLinearFilter2D *)v47);
      int v34 = *((_DWORD *)this + 116);
      if (v34 <= 0 && *((int *)this + 124) < 1)
      {
        uint64_t v46 = *((void *)this + 71);
        if (!v46)
        {
          long long v35 = (char *)this + 440;
          goto LABEL_39;
        }
        (*(void (**)(uint64_t, void, void))(*(void *)v46 + 120))(v46, 0, *((void *)this + 55));
      }
      else
      {
        long long v35 = (char *)this + 424;
        unsigned int v36 = (_DWORD *)*((void *)this + 53);
        if (!v36)
        {
          double v37 = (HGMipmapLevel *)HGObject::operator new(0x250uLL);
          HGMipmapLevel::HGMipmapLevel(v37);
          *(void *)double v37 = &unk_1F10DD4C0;
          operator new();
        }
        v36[114] = v34 != 0;
        v36[122] = *((_DWORD *)this + 124) != 0;
        v36[116] = v34;
        v36[124] = *((_DWORD *)this + 124);
        uint64_t v38 = *((void *)this + 71);
        if (!v38) {
          goto LABEL_39;
        }
        (*(void (**)(uint64_t, void))(*(void *)v38 + 120))(v38, 0);
      }
      long long v35 = (char *)this + 568;
LABEL_39:
      Input = *(HGNode **)v35;
      HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)v47);
      HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)v48);
      return (HGLodFilter *)Input;
    }
    if (v5 != 3 || v6 != 3)
    {
      *((_DWORD *)this + 118) = 1 << *((_DWORD *)this + 116);
      *((_DWORD *)this + 126) = 1 << *((_DWORD *)this + 124);
      uint64_t v41 = *((void *)this + 71);
      if (!v41) {
        return this;
      }
      double v42 = *(void (**)(uint64_t, void, HGLodFilter *))(*(void *)v41 + 120);
      uint64_t v44 = this;
      goto LABEL_53;
    }
    (*(void (**)(void, void, uint64_t))(**((void **)this + 52) + 120))(*((void *)this + 52), 0, v4);
    (*(void (**)(void, void, void))(**((void **)this + 53) + 120))(*((void *)this + 53), 0, *((void *)this + 52));
    uint64_t v41 = *((void *)this + 71);
    Input = (HGNode *)*((void *)this + 53);
    if (!v41) {
      return (HGLodFilter *)Input;
    }
    double v42 = *(void (**)(uint64_t, void, HGLodFilter *))(*(void *)v41 + 120);
LABEL_50:
    uint64_t v44 = (HGLodFilter *)Input;
LABEL_53:
    v42(v41, 0, v44);
    return (HGLodFilter *)*((void *)this + 71);
  }
  if (v5 != 4)
  {
    int v6 = *((_DWORD *)this + 122);
    goto LABEL_5;
  }
LABEL_6:
  int v7 = *((_DWORD *)this + 116);
  int v8 = *((_DWORD *)this + 124);
  float v9 = 1.0;
  (*(void (**)(void, void, uint64_t))(**((void **)this + 54) + 120))(*((void *)this + 54), 0, v4);
  float v10 = 1.0;
  if (*((_DWORD *)this + 114) == 4)
  {
    float v11 = 1.0 / (float)(1 << v7);
    float v10 = 0.0;
    if (v11 < 1.0)
    {
      float v12 = v11 * 3.14159265;
      float v10 = (float)(sqrtf(logf(*((float *)this + 117)) * -2.0) * 3.0) / v12;
    }
    *((_DWORD *)this + 112) = (int)v10;
  }
  if (*((_DWORD *)this + 122) == 4)
  {
    float v13 = 1.0 / (float)(1 << v8);
    float v9 = 0.0;
    if (v13 < 1.0)
    {
      float v14 = v13 * 3.14159265;
      float v9 = (float)(sqrtf(logf(*((float *)this + 125)) * -2.0) * 3.0) / v14;
    }
    *((_DWORD *)this + 113) = (int)v9;
  }
  (*(void (**)(void, void, float, float, double, double))(**((void **)this + 54) + 96))(*((void *)this + 54), 0, v10, v9, 0.0, 0.0);
  HGBlur::GetDecimation(*((HGBlur **)this + 54), v10);
  int v16 = v15;
  v18.n128_f32[0] = HGBlur::GetDecimation(*((HGBlur **)this + 54), v9);
  int v19 = *((_DWORD *)this + 116);
  if (v16 >= v19 && v17 >= *((_DWORD *)this + 124))
  {
    float v39 = (char *)this + 432;
    uint64_t v40 = *((void *)this + 71);
    if (v40)
    {
      (*(void (**)(uint64_t, void, void, float))(*(void *)v40 + 120))(v40, 0, *(void *)v39, v18.n128_f32[0]);
      float v39 = (char *)this + 568;
    }
    return *(HGLodFilter **)v39;
  }
  else
  {
    uint64_t v20 = (_DWORD *)*((void *)this + 53);
    if (!v20)
    {
      int v21 = (HGMipmapLevel *)HGObject::operator new(0x250uLL);
      HGMipmapLevel::HGMipmapLevel(v21);
      *(void *)int v21 = &unk_1F10DD4C0;
      operator new();
    }
    v20[114] = v19 != 0;
    v20[122] = *((_DWORD *)this + 124) != 0;
    v20[116] = v19 - v16;
    v20[124] = *((_DWORD *)this + 124) - v17;
    uint64_t v22 = *((void *)this + 71);
    if (v22)
    {
      (*(void (**)(uint64_t, void, __n128))(*(void *)v22 + 120))(v22, 0, v18);
      return (HGLodFilter *)*((void *)this + 71);
    }
    else
    {
      return (HGLodFilter *)*((void *)this + 53);
    }
  }
}

void sub_1B77FFF5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  HGMipmapLevel::~HGMipmapLevel(v17);
  HGObject::operator delete(v17);
  HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)&a13);
  HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)&a17);
  _Unwind_Resume(a1);
}

void sub_1B77FFF90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)va);
  _Unwind_Resume(a1);
}

void sub_1B77FFFA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)va);
  HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)va1);
  _Unwind_Resume(a1);
}

unint64_t HGLodFilter::GetRect(HGLodFilter *this, HGRect a2, int a3, int a4)
{
  unint64_t v4 = *(void *)&a2.var2;
  if (!a3)
  {
    float v9 = HGRectFloat(a2.var0);
    int v13 = *((_DWORD *)this + 114);
    if ((v13 - 4) >= 4)
    {
      if (!v13) {
        goto LABEL_26;
      }
      float v14 = 0.0;
      if (v13 == 3) {
        float v14 = 1.0;
      }
    }
    else
    {
      float v14 = (float)*((int *)this + 112);
    }
    float v28 = (float)*((int *)this + 118);
    float v29 = (float)*((int *)this + 119);
    float v9 = (float)((float)(v9 * v28) + v29) - v14;
    float v11 = v14 + (float)((float)(v11 * v28) + v29);
LABEL_26:
    uint64_t v30 = *((unsigned int *)this + 122);
    if ((v30 - 4) >= 4)
    {
      if (!v30)
      {
LABEL_50:
        unint64_t v50 = HGRectIntegral(v30, v9, v10, v11, v12);
        goto LABEL_51;
      }
      float v31 = 0.0;
      if (v30 == 3) {
        float v31 = 1.0;
      }
    }
    else
    {
      float v31 = (float)*((int *)this + 113);
    }
    float v51 = (float)*((int *)this + 126);
    float v52 = (float)*((int *)this + 127);
    float v10 = (float)((float)(v10 * v51) + v52) - v31;
    float v12 = v31 + (float)((float)(v12 * v51) + v52);
    goto LABEL_50;
  }
  uint64_t var1 = a2.var1;
  int v7 = *((_DWORD *)this + 114);
  if ((v7 - 4) >= 4)
  {
    if (!v7) {
      goto LABEL_20;
    }
    double v8 = 0.0;
    if (v7 == 3) {
      double v8 = 1.0;
    }
  }
  else
  {
    double v8 = (double)*((int *)this + 112);
  }
  double v15 = (double)*((int *)this + 119);
  double v16 = (double)a2.var0 - v15 - v8;
  int v17 = *((_DWORD *)this + 118);
  double v18 = (double)v17;
  uint64_t v19 = (uint64_t)rint(trunc(v16 / (double)v17));
  double v20 = (double)(v17 - 1);
  uint64_t v21 = (uint64_t)rint(trunc((v16 - v20) / (double)v17));
  if (v16 < (double)(v17 + 0x7FFFFFFF)) {
    LODWORD(v21) = (int)0x80000000 / v17;
  }
  if (v16 < 0.0) {
    a2.var0 = v21;
  }
  else {
    a2.var0 = v19;
  }
  double v22 = v8 + (double)a2.var2 - v15;
  double v23 = (double)(int)(0x80000000 - v17);
  uint64_t v24 = (uint64_t)rint(trunc((v22 + v20) / v18));
  LODWORD(v25) = 0x7FFFFFFF / v17;
  if (v22 <= v23) {
    LODWORD(v25) = v24;
  }
  if (v22 < 0.0) {
    uint64_t v25 = (int)(v22 / v18);
  }
  else {
    uint64_t v25 = v25;
  }
  unint64_t v4 = *(void *)&a2.var2 & 0xFFFFFFFF00000000 | v25;
LABEL_20:
  int v26 = *((_DWORD *)this + 122);
  if ((v26 - 4) >= 4)
  {
    if (!v26) {
      goto LABEL_41;
    }
    double v27 = 0.0;
    if (v26 == 3) {
      double v27 = 1.0;
    }
  }
  else
  {
    double v27 = (double)*((int *)this + 113);
  }
  double v32 = (double)*((int *)this + 127);
  double v33 = (double)a2.var1 - v32 - v27;
  int v34 = *((_DWORD *)this + 126);
  double v35 = (double)v34;
  uint64_t var1 = (uint64_t)rint(trunc(v33 / (double)v34));
  double v36 = (double)(v34 - 1);
  uint64_t v37 = (uint64_t)rint(trunc((v33 - v36) / (double)v34));
  if (v33 < (double)(v34 + 0x7FFFFFFF)) {
    LODWORD(v37) = (int)0x80000000 / v34;
  }
  if (v33 < 0.0) {
    uint64_t var1 = v37;
  }
  else {
    uint64_t var1 = var1;
  }
  double v38 = v27 + (double)SHIDWORD(v4) - v32;
  double v39 = (double)(int)(0x80000000 - v34);
  uint64_t v40 = (uint64_t)rint(trunc((v38 + v36) / v35));
  unsigned int v41 = 0x7FFFFFFF / v34;
  if (v38 <= v39) {
    unsigned int v41 = v40;
  }
  if (v38 < 0.0) {
    unsigned int v41 = (int)(v38 / v35);
  }
  unint64_t v4 = v4 | ((unint64_t)v41 << 32);
LABEL_41:
  if (a4 >= 2)
  {
    unint64_t v42 = a2.var0 | (unint64_t)(var1 << 32);
    uint64_t v43 = *((void *)this + 65);
    uint64_t v44 = *((void *)this + 66);
    uint64_t v45 = HGRectMake4i(1 - a4, 1 - a4, a4 - 1, a4 - 1);
    uint64_t v46 = HGRectGrow(v43, v44, v45);
    uint64_t v48 = v47;
    uint64_t v49 = v42;
LABEL_45:
    unint64_t v50 = HGRectIntersection(v49, v4, v46, v48);
LABEL_51:
    uint64_t var1 = HIDWORD(v50);
    a2.var0 = v50;
    return a2.var0 | (unint64_t)(var1 << 32);
  }
  if (a4 == 1)
  {
    uint64_t v49 = a2.var0 | (unint64_t)(var1 << 32);
    uint64_t v46 = *((void *)this + 65);
    uint64_t v48 = *((void *)this + 66);
    goto LABEL_45;
  }
  return a2.var0 | (unint64_t)(var1 << 32);
}

unint64_t HGLodFilter::GetDOD(HGLodFilter *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return HGLodFilter::GetRect(this, a4, 1, 1);
  }
}

uint64_t HGLodFilter::GetROI(HGLodFilter *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v6 = HGRectFloat(a4.var0);
  int v10 = *((_DWORD *)this + 114);
  if ((v10 - 4) >= 4)
  {
    if (!v10) {
      goto LABEL_9;
    }
    float v11 = 0.0;
    if (v10 == 3) {
      float v11 = 1.0;
    }
  }
  else
  {
    float v11 = (float)*((int *)this + 112);
  }
  float v12 = (float)*((int *)this + 118);
  float v13 = (float)*((int *)this + 119);
  float v6 = (float)((float)(v6 * v12) + v13) - v11;
  float v8 = v11 + (float)((float)(v8 * v12) + v13);
LABEL_9:
  uint64_t v14 = *((unsigned int *)this + 122);
  if ((v14 - 4) < 4)
  {
    float v15 = (float)*((int *)this + 113);
LABEL_14:
    float v16 = (float)*((int *)this + 126);
    float v17 = (float)*((int *)this + 127);
    float v7 = (float)((float)(v7 * v16) + v17) - v15;
    float v9 = v15 + (float)((float)(v9 * v16) + v17);
    return HGRectIntegral(v14, v6, v7, v8, v9);
  }
  if (v14)
  {
    float v15 = 0.0;
    if (v14 == 3) {
      float v15 = 1.0;
    }
    goto LABEL_14;
  }
  return HGRectIntegral(v14, v6, v7, v8, v9);
}

const char *HGLodFilter::GetProgram(HGLodFilter *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) < 0x60B10)
  {
    uint64_t result = "//GLfs2.0      \n"
             "//LEN=0000000391\n"
             "#define defaultp mediump\n"
             "uniform highp sampler2D hg_Texture0;\n"
             "uniform highp vec4 hg_ProgramLocal0;\n"
             "uniform highp vec4 hg_ProgramLocal1;\n"
             "uniform highp vec4 hg_ProgramLocal2;\n"
             "uniform highp vec4 hg_ProgramLocal3;\n"
             "varying highp vec4 hg_TexCoord0;\n"
             "varying highp vec4 hg_TexCoord1;\n"
             "varying highp vec4 hg_TexCoord2;\n"
             "varying highp vec4 hg_TexCoord3;\n"
             "            \n"
             "void main()\n"
             "{\n"
             "highp vec4 r0 = texture2D(hg_Texture0, hg_TexCoord0.st / hg_ProgramLocal3.xy);\n"
             "highp vec4 r1 = texture2D(hg_Texture0, hg_TexCoord1.st / hg_ProgramLocal3.xy);\n"
             "highp vec4 r2 = texture2D(hg_Texture0, hg_TexCoord2.st / hg_ProgramLocal3.xy);\n"
             "highp vec4 r3 = hg_ProgramLocal0 * hg_TexCoord3.x + hg_ProgramLocal1;\n"
             "r0 *= r3.x;\n"
             "r0 = r1 * r3.y + r0;\n"
             "gl_FragColor = r2 * r3.z + r0;\n"
             "}\n"
             "//MD5=ff36303c:ca5fc06a:7e48861a:299c157e\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0004:0000:0000:0000:0000:0000:0000:0004:01:0:1:0\n";
    switch(*((_DWORD *)this + 114) + 8 * *((_DWORD *)this + 122))
    {
      case 3:
      case 19:
        return result;
      case 24:
      case 26:
        uint64_t result = "//GLfs2.0      \n"
                 "//LEN=000000038c\n"
                 "#define defaultp mediump\n"
                 "uniform highp sampler2D hg_Texture0;\n"
                 "uniform highp vec4 hg_ProgramLocal0;\n"
                 "uniform highp vec4 hg_ProgramLocal1;\n"
                 "uniform highp vec4 hg_ProgramLocal2;\n"
                 "uniform highp vec4 hg_ProgramLocal3;\n"
                 "varying highp vec4 hg_TexCoord0;\n"
                 "varying highp vec4 hg_TexCoord1;\n"
                 "varying highp vec4 hg_TexCoord2;\n"
                 "varying highp vec4 hg_TexCoord3;\n"
                 "\n"
                 "void main()\n"
                 "{\n"
                 "\thighp vec4 r0 = texture2D(hg_Texture0, hg_TexCoord0.st / hg_ProgramLocal3.xy);\n"
                 "\thighp vec4 r1 = texture2D(hg_Texture0, hg_TexCoord1.st / hg_ProgramLocal3.xy);\n"
                 "\thighp vec4 r2 = texture2D(hg_Texture0, hg_TexCoord2.st / hg_ProgramLocal3.xy);\n"
                 "\thighp vec4 r3 = hg_ProgramLocal0 * hg_TexCoord3.y + hg_ProgramLocal1;\n"
                 "\tr0 *= r3.x;\n"
                 "\tr0 = r1 * r3.y + r0;\n"
                 "\tgl_FragColor = r2 * r3.z + r0;\n"
                 "}\n"
                 "//MD5=4e8fa7bf:c2658db0:334235ed:cff07d69\n"
                 "//SIG=00000000:00000000:00000000:00000000:0000:0004:0000:0000:0000:0000:0000:0000:0004:01:0:1:0\n";
        break;
      default:
        uint64_t result = "//GLfs2.0      \n"
                 "//LEN=00000001fe\n"
                 "#define defaultp mediump\n"
                 "uniform highp sampler2D hg_Texture0;\n"
                 "uniform highp vec4 hg_ProgramLocal0;\n"
                 "uniform highp vec4 hg_ProgramLocal1;\n"
                 "uniform highp vec4 hg_ProgramLocal2;\n"
                 "uniform highp vec4 hg_ProgramLocal3;\n"
                 "varying highp vec4 hg_TexCoord0;\n"
                 "\n"
                 "void main()\n"
                 "{\n"
                 "\tgl_FragColor = texture2D(hg_Texture0, hg_TexCoord0.st / hg_ProgramLocal3.xy);\n"
                 "}\n"
                 "//MD5=5b088dad:7525d40f:06ef5ff0:4b21e5e1\n"
                 "//SIG=00000000:00000000:00000000:00000000:0000:0004:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
        break;
    }
  }
  else
  {
    uint64_t result = "//Metal1.0     \n"
             "//LEN=0000000386\n"
             "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
             "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
             "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
             "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    float4 r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy);\n"
             "    float4 r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy);\n"
             "    float4 r3 = hg_Params[0] * frag._texCoord3.x + hg_Params[1];\n"
             "    \n"
             "    r0 *= r3.x;\n"
             "    r0 = r1 * r3.y + r0;\n"
             "    \n"
             "    FragmentOut out {r2 * r3.z + r0};\n"
             "    \n"
             "    return out;\n"
             "}\n"
             "//MD5=41a05813:cf28d4aa:3695a778:5f7a073f\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0002:0000:0000:0000:0000:001e:0000:0004:01:0:1:0\n";
    switch(*((_DWORD *)this + 114) + 8 * *((_DWORD *)this + 122))
    {
      case 3:
      case 19:
        return result;
      case 24:
      case 26:
        uint64_t result = "//Metal1.0     \n"
                 "//LEN=0000000386\n"
                 "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
                 "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
                 "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
                 "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
                 "{\n"
                 "    float4 r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
                 "    float4 r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy);\n"
                 "    float4 r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy);\n"
                 "    float4 r3 = hg_Params[0] * frag._texCoord3.y + hg_Params[1];\n"
                 "    \n"
                 "    r0 *= r3.x;\n"
                 "    r0 = r1 * r3.y + r0;\n"
                 "    \n"
                 "    FragmentOut out {r2 * r3.z + r0};\n"
                 "    \n"
                 "    return out;\n"
                 "}\n"
                 "//MD5=8278e286:74ca626e:6f50889b:3d54e426\n"
                 "//SIG=00000000:00000000:00000000:00000000:0000:0002:0000:0000:0000:0000:001e:0000:0004:01:0:1:0\n";
        break;
      default:
        uint64_t result = "//Metal1.0     \n"
                 "//LEN=0000000287\n"
                 "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
                 "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
                 "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
                 "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
                 "{\n"
                 "    float4 texel = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
                 "    \n"
                 "    FragmentOut out {texel};\n"
                 "    \n"
                 "    return out;\n"
                 "}\n"
                 "//MD5=b8f77c2b:532d0d81:5b63a9b7:6edf9352\n"
                 "//SIG=00000000:00000000:00000000:00000000:0000:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
        break;
    }
  }
  return result;
}

void HGLodFilter::InitProgramDescriptor(HGLodFilter *this, HGProgramDescriptor *a2)
{
  unsigned int v3 = *((_DWORD *)this + 114) + 8 * *((_DWORD *)this + 122);
  if (v3 > 0x1A || ((1 << (*((unsigned char *)this + 456) + 8 * *((unsigned char *)this + 488))) & 0x5080008) == 0) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = 4;
  }
  HGMetalUtils::stringForMetalHeader((uint64_t)&v28);
  HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)v5, 0, (uint64_t)v26);
  if ((v27 & 0x80u) == 0) {
    float v6 = v26;
  }
  else {
    float v6 = (void **)v26[0];
  }
  if ((v27 & 0x80u) == 0) {
    std::string::size_type v7 = v27;
  }
  else {
    std::string::size_type v7 = (std::string::size_type)v26[1];
  }
  float v8 = std::string::append(&v28, (const std::string::value_type *)v6, v7);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v29.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  HGMetalUtils::stringForMetalVertexShader((HGMetalUtils *)"vertexFunc", (const char *)v5, 0, (uint64_t)v24);
  if ((v25 & 0x80u) == 0) {
    int v10 = v24;
  }
  else {
    int v10 = (void **)v24[0];
  }
  if ((v25 & 0x80u) == 0) {
    std::string::size_type v11 = v25;
  }
  else {
    std::string::size_type v11 = (std::string::size_type)v24[1];
  }
  float v12 = std::string::append(&v29, (const std::string::value_type *)v10, v11);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  HGMetalUtils::stringForMetalFragmentOutputStruct((HGMetalUtils *)1, 0, (uint64_t)__p);
  if ((v23 & 0x80u) == 0) {
    uint64_t v14 = __p;
  }
  else {
    uint64_t v14 = (void **)__p[0];
  }
  if ((v23 & 0x80u) == 0) {
    std::string::size_type v15 = v23;
  }
  else {
    std::string::size_type v15 = (std::string::size_type)__p[1];
  }
  float v16 = std::string::append(&v21, (const std::string::value_type *)v14, v15);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if ((char)v23 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_27:
      if (((char)v25 & 0x80000000) == 0) {
        goto LABEL_28;
      }
      goto LABEL_35;
    }
  }
  else if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_27;
  }
  operator delete(v21.__r_.__value_.__l.__data_);
  if (((char)v25 & 0x80000000) == 0)
  {
LABEL_28:
    if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_36;
  }
LABEL_35:
  operator delete(v24[0]);
  if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_29:
    if (((char)v27 & 0x80000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_37;
  }
LABEL_36:
  operator delete(v29.__r_.__value_.__l.__data_);
  if (((char)v27 & 0x80000000) == 0)
  {
LABEL_30:
    if ((SHIBYTE(v28.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_38;
  }
LABEL_37:
  operator delete(v26[0]);
  if ((SHIBYTE(v28.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_31:
    unsigned int v18 = v3 - 3;
    if (v3 - 3 > 0x17)
    {
LABEL_41:
      uint64_t v19 = "//Metal1.0     \n"
            "//LEN=0000000287\n"
            "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
            "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
            "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
            "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
            "{\n"
            "    float4 texel = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
            "    \n"
            "    FragmentOut out {texel};\n"
            "    \n"
            "    return out;\n"
            "}\n"
            "//MD5=b8f77c2b:532d0d81:5b63a9b7:6edf9352\n"
            "//SIG=00000000:00000000:00000000:00000000:0000:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
LABEL_42:
      std::string::append(&v30, v19);
      if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        double v20 = &v30;
      }
      else {
        double v20 = (std::string *)v30.__r_.__value_.__r.__words[0];
      }
      HGProgramDescriptor::SetShaderProgram(a2, (const char *)v20);
    }
LABEL_39:
    uint64_t v19 = "//Metal1.0     \n"
          "//LEN=0000000386\n"
          "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
          "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
          "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
          "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
          "{\n"
          "    float4 r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
          "    float4 r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy);\n"
          "    float4 r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy);\n"
          "    float4 r3 = hg_Params[0] * frag._texCoord3.x + hg_Params[1];\n"
          "    \n"
          "    r0 *= r3.x;\n"
          "    r0 = r1 * r3.y + r0;\n"
          "    \n"
          "    FragmentOut out {r2 * r3.z + r0};\n"
          "    \n"
          "    return out;\n"
          "}\n"
          "//MD5=41a05813:cf28d4aa:3695a778:5f7a073f\n"
          "//SIG=00000000:00000000:00000000:00000000:0000:0002:0000:0000:0000:0000:001e:0000:0004:01:0:1:0\n";
    switch(v18)
    {
      case 0u:
      case 0x10u:
        goto LABEL_42;
      case 0x15u:
      case 0x17u:
        uint64_t v19 = "//Metal1.0     \n"
              "//LEN=0000000386\n"
              "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
              "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
              "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
              "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
              "{\n"
              "    float4 r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
              "    float4 r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy);\n"
              "    float4 r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy);\n"
              "    float4 r3 = hg_Params[0] * frag._texCoord3.y + hg_Params[1];\n"
              "    \n"
              "    r0 *= r3.x;\n"
              "    r0 = r1 * r3.y + r0;\n"
              "    \n"
              "    FragmentOut out {r2 * r3.z + r0};\n"
              "    \n"
              "    return out;\n"
              "}\n"
              "//MD5=8278e286:74ca626e:6f50889b:3d54e426\n"
              "//SIG=00000000:00000000:00000000:00000000:0000:0002:0000:0000:0000:0000:001e:0000:0004:01:0:1:0\n";
        goto LABEL_42;
      default:
        goto LABEL_41;
    }
  }
LABEL_38:
  operator delete(v28.__r_.__value_.__l.__data_);
  unsigned int v18 = v3 - 3;
  goto LABEL_39;
}

void sub_1B7800E78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *__p, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v46 - 128));
  if (*(char *)(v46 - 73) < 0) {
    operator delete(*(void **)(v46 - 96));
  }
  _Unwind_Resume(a1);
}

uint64_t HGLodFilter::Bind(HGLodFilter *this, HGRenderer **a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2[18], 393216);
  if (Target <= 0x6043F && Target - 394016 > 0xEF)
  {
    uint64_t v5 = (float32x4_t *)*((void *)this + 72);
    float32x4_t v16 = *v5;
    float32x4_t v18 = *v5;
    float32x4_t v15 = v5[2];
    float32x4_t v17 = v15;
    HGHandler::TexCoord((HGHandler *)a2, 0, 0, 0, 0);
    BOOL v6 = 0;
    int v7 = *((_DWORD *)this + 122);
    unsigned int v8 = *((_DWORD *)this + 114) + 8 * v7;
    if (v8 <= 0x1A)
    {
      if (((1 << v8) & 0x10004) != 0)
      {
        BOOL v6 = v7 == 2;
        goto LABEL_15;
      }
      if (((1 << v8) & 0x1000008) != 0) {
        goto LABEL_8;
      }
      if (((1 << v8) & 0x4080000) != 0)
      {
        v9.i64[0] = 0x3F0000003F000000;
        v9.i64[1] = 0x3F0000003F000000;
        float32x4_t v18 = vmulq_f32(v16, v9);
        float32x4_t v17 = vmulq_f32(v15, v9);
LABEL_8:
        (*((void (**)(HGRenderer **, uint64_t, float32x4_t *, uint64_t))*a2 + 18))(a2, 2, &v18, 1);
        (*((void (**)(HGRenderer **, uint64_t, float32x4_t *, uint64_t))*a2 + 18))(a2, 3, &v17, 1);
        BOOL v6 = 0;
      }
    }
LABEL_15:
    (*((void (**)(HGRenderer **, void, float, float, float, float))*a2 + 17))(a2, 0, (float)*((int *)this + 118), (float)*((int *)this + 126), (float)*((int *)this + 8 * v6 + 120), (float)*((int *)this + 8 * !v6 + 120));
    return 0;
  }
  switch(*((_DWORD *)this + 114) + 8 * *((_DWORD *)this + 122))
  {
    case 3:
    case 19:
      HGHandler::TexCoord((HGHandler *)a2, 3, 0, 0, 0);
      (*((void (**)(HGRenderer **, double, double, double))*a2 + 13))(a2, (double)*((int *)this + 120), 1.0, 1.0);
      v10.n128_f64[0] = (double)-*((_DWORD *)this + 121) + -0.5;
      v11.n128_u64[0] = 0;
      (*((void (**)(HGRenderer **, __n128, __n128, double))*a2 + 12))(a2, v10, v11, 0.0);
      goto LABEL_12;
    case 24:
    case 26:
      HGHandler::TexCoord((HGHandler *)a2, 3, 0, 0, 0);
      (*((void (**)(HGRenderer **, double, double, double))*a2 + 13))(a2, 1.0, (double)*((int *)this + 128), 1.0);
      v12.n128_f64[0] = (double)-*((_DWORD *)this + 129) + -0.5;
      v13.n128_u64[0] = 0;
      (*((void (**)(HGRenderer **, __n128, __n128, double))*a2 + 12))(a2, v13, v12, 0.0);
LABEL_12:
      (*((void (**)(HGRenderer **, void, void, uint64_t))*a2 + 18))(a2, 0, *((void *)this + 72), 1);
      (*((void (**)(HGRenderer **, uint64_t, uint64_t, uint64_t))*a2 + 18))(a2, 1, *((void *)this + 72) + 32, 1);
      break;
    default:
      return 0;
  }
  return 0;
}

uint64_t HGLodFilter::BindTexture(HGLodFilter *this, HGRenderer **a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*((void (**)(HGRenderer **, void))*a2 + 9))(a2, 0);
  (*((void (**)(HGRenderer **, void))*a2 + 7))(a2, 0);
  unsigned int Target = HGRenderer::GetTarget(a2[18], 393216);
  if (Target > 0x6043F || Target - 394016 <= 0xEF)
  {
    int v11 = *((_DWORD *)this + 114);
    int v12 = *((_DWORD *)this + 122);
    switch(v11 + 8 * v12)
    {
      case 3:
      case 19:
        if (v12 == 2) {
          double v13 = 0.0;
        }
        else {
          double v13 = 0.5;
        }
        HGHandler::TexCoord((HGHandler *)a2, 0, 0, 0, 0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, (double)*((int *)this + 119) + 0.5 - (double)*((int *)this + 120), v13 + (double)*((int *)this + 127), 0.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 13))(a2, (double)*((int *)this + 118), (double)*((int *)this + 126), 1.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, -0.5, -v13, 0.0);
        if (*((_DWORD *)this + 122) == 2) {
          (*((void (**)(HGRenderer **, uint64_t, uint64_t))*a2 + 6))(a2, 1, 1);
        }
        HGHandler::TexCoord((HGHandler *)a2, 1, 0, 0, 0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, (double)*((int *)this + 119) + 0.5, v13 + (double)*((int *)this + 127), 0.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 13))(a2, (double)*((int *)this + 118), (double)*((int *)this + 126), 1.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, -0.5, -v13, 0.0);
        HGHandler::TexCoord((HGHandler *)a2, 2, 0, 0, 0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, (double)*((int *)this + 119) + 0.5 + (double)*((int *)this + 120), v13 + (double)*((int *)this + 127), 0.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 13))(a2, (double)*((int *)this + 118), (double)*((int *)this + 126), 1.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, -0.5, -v13, 0.0);
        break;
      case 24:
      case 26:
        if (v11 == 2) {
          double v14 = 0.0;
        }
        else {
          double v14 = 0.5;
        }
        HGHandler::TexCoord((HGHandler *)a2, 0, 0, 0, 0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, v14 + (double)*((int *)this + 119), (double)*((int *)this + 127) + 0.5 - (double)*((int *)this + 128), 0.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 13))(a2, (double)*((int *)this + 118), (double)*((int *)this + 126), 1.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, -v14, -0.5, 0.0);
        if (*((_DWORD *)this + 114) == 2) {
          (*((void (**)(HGRenderer **, uint64_t, uint64_t))*a2 + 6))(a2, 1, 1);
        }
        HGHandler::TexCoord((HGHandler *)a2, 1, 0, 0, 0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, v14 + (double)*((int *)this + 119), (double)*((int *)this + 127) + 0.5, 0.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 13))(a2, (double)*((int *)this + 118), (double)*((int *)this + 126), 1.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, -v14, -0.5, 0.0);
        HGHandler::TexCoord((HGHandler *)a2, 2, 0, 0, 0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, v14 + (double)*((int *)this + 119), (double)*((int *)this + 127) + 0.5 + (double)*((int *)this + 128), 0.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 13))(a2, (double)*((int *)this + 118), (double)*((int *)this + 126), 1.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, -v14, -0.5, 0.0);
        break;
      default:
        if (v11 == 2) {
          double v15 = 0.0;
        }
        else {
          double v15 = 0.5;
        }
        if (v12 == 2) {
          double v16 = 0.0;
        }
        else {
          double v16 = 0.5;
        }
        HGHandler::TexCoord((HGHandler *)a2, 0, 0, 0, 0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, v15 + (double)*((int *)this + 119), v16 + (double)*((int *)this + 127), 0.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 13))(a2, (double)*((int *)this + 118), (double)*((int *)this + 126), 1.0);
        (*((void (**)(HGRenderer **, double, double, double))*a2 + 12))(a2, -v15, -v16, 0.0);
        if (*((_DWORD *)this + 114) == 2 || *((_DWORD *)this + 122) == 2) {
          (*((void (**)(HGRenderer **, uint64_t, uint64_t))*a2 + 6))(a2, 1, 1);
        }
        else {
          (*((void (**)(HGRenderer **, void, void))*a2 + 6))(a2, 0, 0);
        }
        break;
    }
  }
  else
  {
    v7.n128_f32[0] = (float)((float)*((int *)this + 119) + 0.5) + (float)*((int *)a2 + 60);
    v8.n128_f32[0] = (float)((float)*((int *)this + 127) + 0.5) + (float)*((int *)a2 + 61);
    if (*((_DWORD *)this + 114) == 3)
    {
      v7.n128_f64[0] = v7.n128_f32[0] - (double)*((int *)this + 120);
      v7.n128_f32[0] = v7.n128_f64[0];
    }
    int v9 = *((_DWORD *)this + 128);
    if (*((_DWORD *)this + 122) == 3)
    {
      float v10 = v8.n128_f32[0] - (double)v9;
      v8.n128_f32[0] = v10;
    }
    (*((void (**)(HGRenderer **, uint64_t, __n128, __n128, float, float))*a2 + 17))(a2, 1, v7, v8, (float)-(*((_DWORD *)this + 120) * *((_DWORD *)this + 121)), (float)-(v9 * *((_DWORD *)this + 129)));
  }
  return 0;
}

uint64_t HGLodFilter::RenderTile(HGLodFilter *this, HGTile *a2, double a3, float32x4_t a4, float32x4_t a5)
{
  int v6 = *(_DWORD *)a2;
  int v5 = *((_DWORD *)a2 + 1);
  int v7 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
  int v8 = *((_DWORD *)a2 + 3) - v5;
  uint64_t v9 = *((int *)a2 + 22);
  uint64_t v10 = *((void *)a2 + 10);
  int v11 = *((_DWORD *)this + 127) * v9;
  uint64_t v12 = *((int *)this + 119);
  uint64_t v13 = v10 + 16 * v11 + 16 * v12;
  uint64_t v14 = *((void *)a2 + 2);
  uint64_t v15 = *((int *)a2 + 6);
  uint64_t v16 = *((int *)this + 118);
  int v17 = *((_DWORD *)this + 126);
  uint64_t v18 = v11;
  uint64_t v19 = *((int *)this + 120);
  int v20 = *((_DWORD *)this + 128);
  int v21 = v20 * v9;
  switch(*((_DWORD *)this + 114) + 8 * *((_DWORD *)this + 122))
  {
    case 2:
      if (v8 >= 1 && v7 >= 1)
      {
        int v22 = 0;
        uint64_t v23 = 16 * ((int)v16 - 1) * v6;
        uint64_t v24 = v13 + v23;
        uint64_t v25 = 16 * v15;
        uint64_t v26 = v10 + v23 + 16 * v19 + 16 * v12 + 16 * v18;
        uint64_t v27 = 16 * v9;
        uint64_t v28 = 16 * v16;
        uint64_t v29 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        v30.i64[0] = 0x3F0000003F000000;
        v30.i64[1] = 0x3F0000003F000000;
        do
        {
          uint64_t v31 = 0;
          uint64_t v32 = 0;
          do
          {
            *(float32x4_t *)(v14 + v32) = vmulq_f32(vaddq_f32(*(float32x4_t *)(v24 + v31), *(float32x4_t *)(v26 + v31)), v30);
            v32 += 16;
            v31 += v28;
          }
          while (v29 != v32);
          ++v22;
          v14 += v25;
          v26 += v27;
          v24 += v27;
        }
        while (v22 != v8);
      }
      break;
    case 3:
      if (v8 >= 1)
      {
        int v33 = 0;
        int v34 = (float32x4_t *)(v13 + 16 * ((int)v16 - 1) * v6);
        uint64_t v35 = 16 * v9;
        uint64_t v36 = 16 * v16;
        uint64_t v37 = 16 * v15;
        __asm { FMOV            V0.4S, #1.0 }
        do
        {
          if (v7 >= 1)
          {
            uint64_t v43 = 0;
            a4.f32[0] = (float)((*(_DWORD *)a2 - *((_DWORD *)this + 121)) * v19);
            a4 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 0);
            uint64_t v44 = v34;
            do
            {
              float32x4_t v45 = vaddq_f32(*(float32x4_t *)(*((void *)this + 72) + 32), vmulq_f32(a4, *(float32x4_t *)*((void *)this + 72)));
              *(float32x4_t *)(v14 + v43) = vaddq_f32(vmulq_laneq_f32(v44[v19], v45, 2), vaddq_f32(vmulq_lane_f32(*v44, *(float32x2_t *)v45.f32, 1), vmulq_n_f32(v44[-v19], v45.f32[0])));
              a4 = vaddq_f32(a4, _Q0);
              uint64_t v44 = (float32x4_t *)((char *)v44 + v36);
              v43 += 16;
            }
            while (16 * v7 != v43);
          }
          ++v33;
          int v34 = (float32x4_t *)((char *)v34 + v35);
          v14 += v37;
        }
        while (v33 != v8);
      }
      break;
    case 16:
      if (v8 >= 1 && v7 >= 1)
      {
        int v54 = 0;
        uint64_t v55 = v17 * (int)v9;
        uint64_t v56 = 16 * (int)v9 * v5 * (v17 - 1);
        uint64_t v57 = v13 + v56;
        uint64_t v58 = v10 + v56 + 16 * v12 + 16 * v21 + 16 * v18;
        uint64_t v59 = 16 * v55;
        uint64_t v60 = 16 * v15;
        uint64_t v61 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        v62.i64[0] = 0x3F0000003F000000;
        v62.i64[1] = 0x3F0000003F000000;
        do
        {
          uint64_t v63 = 0;
          do
          {
            *(float32x4_t *)(v14 + v63) = vmulq_f32(vaddq_f32(*(float32x4_t *)(v57 + v63), *(float32x4_t *)(v58 + v63)), v62);
            v63 += 16;
          }
          while (v61 != v63);
          ++v54;
          v58 += v59;
          v57 += v59;
          v14 += v60;
        }
        while (v54 != v8);
      }
      break;
    case 18:
      if (v8 >= 1 && v7 >= 1)
      {
        int v64 = 0;
        float32x4_t v65 = (float32x4_t *)(v13 + 16 * (((int)v16 - 1) * v6 + (int)v9 * v5 * (v17 - 1)));
        uint64_t v66 = v17 * (int)v9;
        uint64_t v67 = v21;
        uint64_t v68 = 16 * v15;
        uint64_t v69 = v19 + v21;
        uint64_t v70 = 16 * v66;
        uint64_t v71 = 16 * v16;
        uint64_t v72 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        __asm { FMOV            V0.4S, #0.25 }
        do
        {
          uint64_t v74 = 0;
          float32x4_t v75 = v65;
          do
          {
            *(float32x4_t *)(v14 + v74) = vmulq_f32(vaddq_f32(vaddq_f32(*v75, v75[v19]), vaddq_f32(v75[v67], v75[v69])), _Q0);
            v74 += 16;
            float32x4_t v75 = (float32x4_t *)((char *)v75 + v71);
          }
          while (v72 != v74);
          ++v64;
          v14 += v68;
          float32x4_t v65 = (float32x4_t *)((char *)v65 + v70);
        }
        while (v64 != v8);
      }
      break;
    case 19:
      if (v8 >= 1)
      {
        int v76 = 0;
        int32x4_t v77 = (float32x4_t *)(v13 + 16 * (((int)v16 - 1) * v6 + (int)v9 * v5 * (v17 - 1)));
        uint64_t v78 = 16 * v17 * (int)v9;
        uint64_t v79 = 16 * v16;
        uint64_t v80 = v19 + v21;
        uint64_t v81 = v21;
        uint64_t v82 = 16 * v15;
        v83.i64[0] = 0x3F0000003F000000;
        v83.i64[1] = 0x3F0000003F000000;
        __asm { FMOV            V1.4S, #1.0 }
        do
        {
          if (v7 >= 1)
          {
            uint64_t v85 = 0;
            a5.f32[0] = (float)((*(_DWORD *)a2 - *((_DWORD *)this + 121)) * v19);
            a5 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 0);
            float v86 = v77;
            do
            {
              float32x4_t v87 = vaddq_f32(*(float32x4_t *)(*((void *)this + 72) + 32), vmulq_f32(a5, *(float32x4_t *)*((void *)this + 72)));
              *(float32x4_t *)(v14 + v85) = vmulq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(v86[-v19], *(float32x4_t *)((char *)v86 + v81 * 16 - 16 * v19)), v87.f32[0]), vmulq_lane_f32(vaddq_f32(*v86, v86[v81]), *(float32x2_t *)v87.f32, 1)), vmulq_laneq_f32(vaddq_f32(v86[v19], v86[v80]), v87, 2)), v83);
              a5 = vaddq_f32(a5, _Q1);
              float v86 = (float32x4_t *)((char *)v86 + v79);
              v85 += 16;
            }
            while (16 * v7 != v85);
          }
          ++v76;
          int32x4_t v77 = (float32x4_t *)((char *)v77 + v78);
          v14 += v82;
        }
        while (v76 != v8);
      }
      break;
    case 24:
      if (v8 >= 1 && v7 >= 1)
      {
        int v88 = 0;
        int v89 = v17 * v9;
        uint64_t v90 = 16 * (int)v9 * v5 * (v17 - 1);
        *(float *)&a3 = (float)((v5 - *((_DWORD *)this + 129)) * v20);
        float32x4_t v91 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0);
        uint64_t v92 = v13 + v90;
        uint64_t v93 = 16 * v21;
        uint64_t v94 = v90 + 16 * v12 + 16 * v18;
        uint64_t v95 = v10 + v93 + v94;
        uint64_t v96 = 16 * v89;
        uint64_t v97 = 16 * v15;
        uint64_t v98 = v10 + v94 - v93;
        uint64_t v99 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        __asm { FMOV            V1.4S, #1.0 }
        do
        {
          uint64_t v101 = 0;
          float32x4_t v102 = vaddq_f32(*(float32x4_t *)(*((void *)this + 72) + 32), vmulq_f32(v91, *(float32x4_t *)*((void *)this + 72)));
          do
          {
            *(float32x4_t *)(v14 + v101) = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(v95 + v101), v102, 2), vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v98 + v101), v102.f32[0]), vmulq_lane_f32(*(float32x4_t *)(v92 + v101), *(float32x2_t *)v102.f32, 1)));
            v101 += 16;
          }
          while (v99 != v101);
          ++v88;
          v95 += v96;
          float32x4_t v91 = vaddq_f32(v91, _Q1);
          v92 += v96;
          v14 += v97;
          v98 += v96;
        }
        while (v88 != v8);
      }
      break;
    case 26:
      if (v8 >= 1 && v7 >= 1)
      {
        int v103 = 0;
        uint64_t v104 = v17 * (int)v9;
        int32x4_t v105 = (float32x4_t *)(v13 + 16 * (((int)v16 - 1) * v6 + (int)v9 * v5 * (v17 - 1)));
        *(float *)&a3 = (float)((v5 - *((_DWORD *)this + 129)) * v20);
        uint64_t v106 = 16 * v15;
        float32x4_t v107 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0);
        uint64_t v108 = v19 + v21;
        uint64_t v109 = 16 * v16;
        uint64_t v110 = v19;
        uint64_t v111 = 16 * v7;
        v112.i64[0] = 0x3F0000003F000000;
        v112.i64[1] = 0x3F0000003F000000;
        __asm { FMOV            V2.4S, #1.0 }
        do
        {
          uint64_t v114 = 0;
          float32x4_t v115 = vaddq_f32(*(float32x4_t *)(*((void *)this + 72) + 32), vmulq_f32(v107, *(float32x4_t *)*((void *)this + 72)));
          float32_t v116 = v105;
          do
          {
            *(float32x4_t *)(v14 + v114) = vmulq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(v116[-v21], *(float32x4_t *)((char *)v116 + v110 * 16 - 16 * v21)), v115.f32[0]), vmulq_lane_f32(vaddq_f32(*v116, v116[v110]), *(float32x2_t *)v115.f32, 1)), vmulq_laneq_f32(vaddq_f32(v116[v21], v116[v108]), v115, 2)), v112);
            v114 += 16;
            float32_t v116 = (float32x4_t *)((char *)v116 + v109);
          }
          while (v111 != v114);
          float32x4_t v107 = vaddq_f32(v107, _Q2);
          ++v103;
          v14 += v106;
          v105 += v104;
        }
        while (v103 != v8);
      }
      break;
    default:
      if (v8 >= 1 && v7 >= 1)
      {
        int v46 = 0;
        uint64_t v47 = v13 + 16 * (((int)v16 - 1) * v6 + (int)v9 * v5 * (v17 - 1));
        uint64_t v48 = 16 * v15;
        uint64_t v49 = 16 * v17 * (int)v9;
        uint64_t v50 = 16 * v16;
        uint64_t v51 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        do
        {
          uint64_t v52 = 0;
          uint64_t v53 = 0;
          do
          {
            *(_OWORD *)(v14 + v53) = *(_OWORD *)(v47 + v52);
            v53 += 16;
            v52 += v50;
          }
          while (v51 != v53);
          ++v46;
          v14 += v48;
          v47 += v49;
        }
        while (v46 != v8);
      }
      break;
  }
  return 0;
}

char *HGLodFilter::RenderPage(HGLodFilter *this, HGRect *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  (*(void (**)(HGLodFilter *, HGRect *, void))(*(void *)this + 472))(this, a2, 0);
  unint64_t v4 = (const char *)((*(void *)(*(void *)(*(void *)this - 8) + 8) & 0x7FFFFFFFFFFFFFFFLL) - 1);
  do
    int v5 = *(unsigned __int8 *)++v4;
  while ((v5 - 48) < 0xA);
  snprintf(__str, 0x100uLL, "%s::RenderPage( [%d %d %d %d])", v4, a2[1].var0, a2[1].var1, a2[1].var2, a2[1].var3);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v22, "gpu", 1, __str);
  Buffer = *(char **)&a2->var2;
  if (Buffer)
  {
    (*(void (**)(void))(*(void *)Buffer + 16))(*(void *)&a2->var2);
  }
  else
  {
    Buffer = HGGPURenderer::CreateBuffer(*(void *)&a2->var0, a2[1], a2[2].var0, 0, (*((_DWORD *)this + 4) >> 12) & 1, LOBYTE(a2[15].var2));
    *(void *)&a2->var2 = Buffer;
  }
  (*(void (**)(void, char *))(**(void **)&a2->var0 + 144))(*(void *)&a2->var0, Buffer);
  (*(void (**)(void, void, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 0, *(void *)&a2[10].var2, 0, 0);
  uint64_t v7 = *(void *)&a2[10].var2;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 1, *(void *)&a2[11].var0, 0, 0);
  uint64_t v8 = *(void *)&a2[11].var0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 2, *(void *)&a2[11].var2, 0, 0);
  uint64_t v9 = *(void *)&a2[11].var2;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 3, *(void *)&a2[12].var0, 0, 0);
  uint64_t v10 = *(void *)&a2[12].var0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 4, *(void *)&a2[12].var2, 0, 0);
  uint64_t v11 = *(void *)&a2[12].var2;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 5, *(void *)&a2[13].var0, 0, 0);
  uint64_t v12 = *(void *)&a2[13].var0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
  }
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 6, *(void *)&a2[13].var2, 0, 0);
  uint64_t v13 = *(void *)&a2[13].var2;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
  }
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 7, *(void *)&a2[14].var0, 0, 0);
  uint64_t v14 = *(void *)&a2[14].var0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  uint64_t v15 = (HGHandler *)(*(uint64_t (**)(void, void, HGLodFilter *))(**(void **)&a2->var0 + 368))(*(void *)&a2->var0, *((void *)this + 8), this);
  uint64_t v16 = *(const void **)&a2[10].var2;
  if (v16
  {
    uint64_t TextureRect = HGGLTexture::GetTextureRect(v17);
    (*(void (**)(HGHandler *, uint64_t, float, float, double, double))(*(void *)v15 + 136))(v15, 3, (float)(v19 - TextureRect), (float)(v20 - HIDWORD(TextureRect)), 0.0, 0.0);
    (*(void (**)(HGHandler *))(*(void *)v15 + 40))(v15);
    (*(void (**)(HGLodFilter *, HGRect *, void, HGHandler *))(*(void *)this + 488))(this, a2, 0, v15);
    HGGPURenderer::Rect(*(HGGPURenderer **)&a2->var0, v15, a2[1], 8);
    (*(void (**)(HGLodFilter *, HGRect *, void, HGHandler *))(*(void *)this + 496))(this, a2, 0, v15);
  }
  else
  {
    Buffer = 0;
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v22);
  return Buffer;
}

void sub_1B7802B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7802B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7802B30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7802B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGLodFilter::GetTransform(HGLodFilter *this@<X0>, int a2@<W1>, HGTransform *a3@<X8>)
{
  HGTransform::HGTransform(a3);
  HGTransform::LoadIdentity(a3);
  int v6 = *((_DWORD *)this + 103);
  if (!v6) {
    return;
  }
  unsigned int v7 = *((_DWORD *)this + 115);
  double v8 = 0.0;
  double v9 = 0.0;
  if (v7)
  {
    uint64_t v10 = *((int *)this + 114);
    double v9 = 0.5;
    if (v10 <= 7) {
      double v9 = dbl_1B83477C0[v10];
    }
  }
  unsigned int v11 = *((_DWORD *)this + 123);
  if (v11)
  {
    uint64_t v12 = *((int *)this + 122);
    double v8 = 0.5;
    if (v12 <= 7) {
      double v8 = dbl_1B83477C0[v12];
    }
  }
  if (v6 == 3)
  {
    uint64_t v13 = *((void *)this + 70);
    v14.i64[0] = (int)v13;
    v14.i64[1] = SHIDWORD(v13);
    float64x2_t v15 = vcvtq_f64_s64(v14);
    uint64_t v16 = *((void *)this + 69);
    v14.i64[0] = (int)v16;
    v14.i64[1] = SHIDWORD(v16);
    float64x2_t v17 = vsubq_f64(v15, vcvtq_f64_s64(v14));
    uint64_t v18 = *((void *)this + 66);
    v14.i64[0] = (int)v18;
    v14.i64[1] = SHIDWORD(v18);
    float64x2_t v19 = vcvtq_f64_s64(v14);
    uint64_t v20 = *((void *)this + 65);
    v14.i64[0] = (int)v20;
    v14.i64[1] = SHIDWORD(v20);
    float64x2_t v31 = vdivq_f64(v17, vsubq_f64(v19, vcvtq_f64_s64(v14)));
    int v21 = v20;
    if (v20 != 0x80000000)
    {
LABEL_10:
      int v22 = (char *)this + 552;
      goto LABEL_14;
    }
  }
  else
  {
    uint32x2_t v23 = vshl_u32((uint32x2_t)0x100000001, (uint32x2_t)__PAIR64__(v11, v7));
    v24.i64[0] = v23.i32[0];
    v24.i64[1] = v23.i32[1];
    float64x2_t v31 = vcvtq_f64_s64(v24);
    int v21 = *((_DWORD *)this + 130);
    if (v21 != 0x80000000) {
      goto LABEL_10;
    }
  }
  int v21 = *((_DWORD *)this + 132);
  double v25 = 0.0;
  double v26 = 0.0;
  if (v21 == 0x7FFFFFFF) {
    goto LABEL_15;
  }
  int v22 = (char *)this + 560;
LABEL_14:
  double v25 = (double)-v21;
  double v26 = (double)*(int *)v22;
LABEL_15:
  int v27 = *((_DWORD *)this + 131);
  if (v27 != 0x80000000)
  {
    float32x4_t v30 = (char *)this + 556;
    goto LABEL_19;
  }
  int v27 = *((_DWORD *)this + 133);
  double v28 = 0.0;
  double v29 = 0.0;
  if (v27 != 0x7FFFFFFF)
  {
    float32x4_t v30 = (char *)this + 564;
LABEL_19:
    double v28 = (double)-v27;
    double v29 = (double)*(int *)v30;
  }
  if (a2)
  {
    HGTransform::Translate(a3, v25 - v9, v28 - v8, 0.0);
    HGTransform::Scale(a3, v31.f64[0], v31.f64[1], 1.0);
  }
  else
  {
    HGTransform::Translate(a3, -v26, -v29, 0.0);
    HGTransform::Scale(a3, 1.0 / v31.f64[0], 1.0 / v31.f64[1], 1.0);
    double v26 = v9 - v25;
    double v29 = v8 - v28;
  }
  HGTransform::Translate(a3, v26, v29, 0.0);
}

void sub_1B7802D94(_Unwind_Exception *a1)
{
  HGTransform::~HGTransform(v1);
  _Unwind_Resume(a1);
}

void sub_1B7802DA8(_Unwind_Exception *a1)
{
  HGTransform::~HGTransform(v1);
  _Unwind_Resume(a1);
}

uint64_t HGLodFilter::info(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v49);
  if (a2 >= 2)
  {
    int v8 = *(char *)(a3 + 23);
    if (v8 >= 0) {
      uint64_t v9 = a3;
    }
    else {
      uint64_t v9 = *(void *)a3;
    }
    if (v8 >= 0) {
      uint64_t v10 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v10 = *(void *)(a3 + 8);
    }
    unsigned int v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v49, v9, v10);
    uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"lodfilter, ", 11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"axis[", 5);
    uint64_t v13 = (void *)std::ostream::operator<<();
    uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"]: ", 3);
    uint64_t v17 = *(int *)(a1 + 456);
    if (v17 >= 8)
    {
      HGLogger::error((HGLogger *)"HGLodFilter::info: Invalid filter mode: %d", v14, v15, *(int *)(a1 + 456));
      uint64_t v18 = "INVALID FILTER MODE";
    }
    else
    {
      uint64_t v18 = off_1E616CE50[v17];
    }
    size_t v19 = strlen(v18);
    uint64_t v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v18, v19);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)", ", 2);
    int v21 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)", ", 2);
    int v22 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)", ", 2);
    uint32x2_t v23 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)", ", 2);
    int64x2_t v24 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)", ", 2);
    double v25 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)", ", 2);
    double v26 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)", ", 2);
    int v27 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)"\n", 1);
    int v28 = *(char *)(a4 + 23);
    if (v28 >= 0) {
      uint64_t v29 = a4;
    }
    else {
      uint64_t v29 = *(void *)a4;
    }
    if (v28 >= 0) {
      uint64_t v30 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      uint64_t v30 = *(void *)(a4 + 8);
    }
    float64x2_t v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v49, v29, v30);
    uint64_t v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)"lodfilter, ", 11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"axis[", 5);
    int v33 = (void *)std::ostream::operator<<();
    uint64_t v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)"]: ", 3);
    uint64_t v37 = *(int *)(a1 + 488);
    if (v37 >= 8)
    {
      HGLogger::error((HGLogger *)"HGLodFilter::info: Invalid filter mode: %d", v34, v35, *(int *)(a1 + 488));
      double v38 = "INVALID FILTER MODE";
    }
    else
    {
      double v38 = off_1E616CE50[v37];
    }
    size_t v39 = strlen(v38);
    uint64_t v40 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)v38, v39);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)", ", 2);
    unsigned int v41 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)", ", 2);
    unint64_t v42 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)", ", 2);
    uint64_t v43 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, (uint64_t)", ", 2);
    uint64_t v44 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, (uint64_t)", ", 2);
    float32x4_t v45 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)", ", 2);
    int v46 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v46, (uint64_t)", ", 2);
    uint64_t v47 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v47, (uint64_t)"\n", 1);
  }
  std::stringbuf::str();
  v49[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v49 + *(void *)(v49[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v49[1] = MEMORY[0x1E4FBA470] + 16;
  if (v50 < 0) {
    operator delete((void *)v49[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v51);
}

void sub_1B78031C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B78031DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void HGLodPreFilter::HGLodPreFilter(HGNode *a1, uint64_t a2, int a3)
{
  HGNode::HGNode(a1);
  *(void *)uint64_t v5 = &unk_1F10DD718;
  *(void *)(v5 + 408) = a2;
  *(_DWORD *)(v5 + 416) = a3;
}

void HGLodPreFilter::~HGLodPreFilter(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGLodPreFilter::GetDOD(HGLodPreFilter *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0xFFFFFFF0, 0xFFFFFFF0, 0x10u, 0x10u);
  return HGRectGrow(v6, v5, v7);
}

uint64_t HGLodPreFilter::GetROI(HGLodPreFilter *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0xFFFFFFF0, 0xFFFFFFF0, 0x10u, 0x10u);
  return HGRectGrow(v6, v5, v7);
}

const char *HGLodPreFilter::GetProgram(HGLodPreFilter *this, HGRenderer *a2)
{
  if (*((_DWORD *)this + 104)) {
    return "!!ARBfp1.0     \n"
  }
           "##LEN=00000006f8\n"
           "##                          \n"
           "##                            \n"
           "##                                \n"
           "##                                     \n"
           "##$\n"
           "OUTPUT $o0=result.color;\n"
           "ATTRIB $f0=fragment.texcoord[0];\n"
           "ATTRIB $f1=fragment.texcoord[1];\n"
           "PARAM $p0=program.local[0];\n"
           "PARAM $p1=program.local[1];\n"
           "##%\n"
           "TEMP r0,r1,r2,r3;\n"
           "##@\n"
           "##0\n"
           "TEX r0,$f0,texture[0],RECT;\n"
           "RCP r2.w,$f1.w;\n"
           "MUL r3,$f1.xyxy,r2.w;\n"
           "MAD r3,-r3,$p0,$p1;\n"
           "MUL r2.w,r3.y,r3.z;\n"
           "MAD r2.w,r3.x,r3.w,-r2.w;\n"
           "MUL r3,r3,$f1.w;\n"
           "RCP r2.w,r2.w;\n"
           "MUL r3,r3,r2.w;\n"
           "SWZ r3,r3,-z,x,w,-y;\n"
           "MAX r3,r3,-16.;\n"
           "MIN r3,r3,16.;\n"
           "MAD r1,.125,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.125,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.25,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.25,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.375,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.375,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.5,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.5,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.625,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.625,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.75,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.75,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.875,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.875,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "ADD r1,$f0,r3;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "SUB r1,$f0,r3;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MUL $o0,0.0588235294117647,r0;\n"
           "END\n"
           "##MD5=103181ed:3a2f2b1d:dd57ff36:42e782ba\n"
           "##SIG=00000000:00000000:00000000:00000000:0000:0002:0004:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  else {
    return "!!ARBfp1.0     \n"
  }
           "##LEN=00000006f8\n"
           "##                          \n"
           "##                            \n"
           "##                                \n"
           "##                                     \n"
           "##$\n"
           "OUTPUT $o0=result.color;\n"
           "ATTRIB $f0=fragment.texcoord[0];\n"
           "ATTRIB $f1=fragment.texcoord[1];\n"
           "PARAM $p0=program.local[0];\n"
           "PARAM $p1=program.local[1];\n"
           "##%\n"
           "TEMP r0,r1,r2,r3;\n"
           "##@\n"
           "##0\n"
           "TEX r0,$f0,texture[0],RECT;\n"
           "RCP r2.w,$f1.w;\n"
           "MUL r3,$f1.xyxy,r2.w;\n"
           "MAD r3,-r3,$p0,$p1;\n"
           "MUL r2.w,r3.y,r3.z;\n"
           "MAD r2.w,r3.x,r3.w,-r2.w;\n"
           "MUL r3,r3,$f1.w;\n"
           "RCP r2.w,r2.w;\n"
           "MUL r3,r3,r2.w;\n"
           "SWZ r3,r3,w,-y,-z,x;\n"
           "MAX r3,r3,-16.;\n"
           "MIN r3,r3,16.;\n"
           "MAD r1,.125,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.125,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.25,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.25,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.375,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.375,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.5,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.5,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.625,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.625,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.75,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.75,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,.875,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MAD r1,-.875,r3,$f0;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "ADD r1,$f0,r3;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "SUB r1,$f0,r3;\n"
           "##0\n"
           "TEX r1,r1,texture[0],RECT;\n"
           "ADD r0,r1,r0;\n"
           "MUL $o0,0.0588235294117647,r0;\n"
           "END\n"
           "##MD5=871a4a85:797b62fd:7f3669a5:784289d5\n"
           "##SIG=00000000:00000000:00000000:00000000:0000:0002:0004:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
}

uint64_t HGLodPreFilter::BindTexture(HGLodPreFilter *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  HGHandler::TexCoord(a2, 0, a3, 0, 0);
  return 0;
}

uint64_t HGLodPreFilter::Bind(HGLodPreFilter *this, HGHandler *a2)
{
  MatrixPtr = (double *)HGTransform::GetMatrixPtr((HGTransform *)(*((void *)this + 51) + 448));
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HGHandler *, double *))(*(void *)a2 + 112))(a2, MatrixPtr);
  float v5 = MatrixPtr[3] + MatrixPtr[3];
  float v6 = MatrixPtr[7] + MatrixPtr[7];
  (*(void (**)(HGHandler *, void, float, float, float, float))(*(void *)a2 + 136))(a2, 0, v5, v5, v6, v6);
  float v7 = *MatrixPtr + *MatrixPtr;
  float v8 = MatrixPtr[1] + MatrixPtr[1];
  float v9 = MatrixPtr[4] + MatrixPtr[4];
  float v10 = MatrixPtr[5] + MatrixPtr[5];
  (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 1, v7, v8, v9, v10);
  (*(void (**)(HGHandler *, uint64_t, float, double, double, double))(*(void *)a2 + 136))(a2, 2, *(float *)(*((void *)this + 51) + 736), 0.0, 0.0, 0.0);
  return 0;
}

void hgColorConformNodeListCacheLockInitFunction(void)
{
}

void sub_1B7803540(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40BBCAB520);
  _Unwind_Resume(a1);
}

void HGColorConform::HGColorConform(HGColorConform *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v2 = &unk_1F10DD998;
  *(_OWORD *)(v2 + 776) = 0u;
  pthread_once(&hgColorConformNodeListCacheLockInit, (void (*)(void))hgColorConformNodeListCacheLockInitFunction);
  *((_WORD *)this + 216) = 0;
  *((unsigned char *)this + 434) = 0;
  *((void *)this + 51) = 0;
  *((void *)this + 52) = 0;
  *(void *)((char *)this + 436) = 1;
  *((_WORD *)this + 236) = 257;
  *((unsigned char *)this + 474) = 0;
  *((_DWORD *)this + 113) = 1;
  *(_OWORD *)((char *)this + 456) = HGRectInfinite;
  *((_DWORD *)this + 121) = -1;
  unsigned int v3 = (char *)HGObject::operator new(0x78uLL);
  HGObject::HGObject((HGObject *)v3);
  *(void *)unsigned int v3 = &unk_1F10DDC48;
  *((void *)v3 + 2) = 0;
  *((void *)v3 + 9) = 0;
  *((void *)v3 + 10) = 0;
  *((void *)v3 + 8) = 0;
  *((_DWORD *)v3 + 6) = 1065353216;
  *(void *)(v3 + 28) = 0;
  *(void *)(v3 + 44) = 0;
  *(void *)(v3 + 36) = 0;
  *((_DWORD *)v3 + 13) = 0;
  v3[56] = 1;
  *((_DWORD *)v3 + 15) = 2;
  *(_OWORD *)(v3 + 88) = xmmword_1B8347800;
  v3[104] = 1;
  *(void *)(v3 + 108) = 0x100000000;
  *((void *)this + 67) = v3;
  HGColorConform::ClearConversionParams(this);
  *(void *)((char *)this + 444) = 0;
  *(void *)((char *)this + 476) = 0xBF00000040000000;
  *(void *)((char *)this + 748) = 0x3F8000003F800000;
  *(_OWORD *)((char *)this + 716) = xmmword_1B7E75890;
  *(_OWORD *)((char *)this + 732) = xmmword_1B7E77190;
  *((unsigned char *)this + 756) = 1;
  *((void *)this + 95) = 0x3F80000000000320;
  *((unsigned char *)this + 768) = 0;
  *((void *)this + 53) = 0;
}

void sub_1B78036F8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B780371C(_Unwind_Exception *a1)
{
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

double HGColorConform::ClearConversionParams(HGColorConform *this)
{
  *(_OWORD *)((char *)this + 488) = xmmword_1B8347810;
  *((_DWORD *)this + 132) = 0;
  *((void *)this + 63) = 0;
  *((void *)this + 64) = 0;
  *((void *)this + 65) = 0xFFFFFFFFLL;
  *((void *)this + 69) = 0;
  *((_OWORD *)this + 35) = xmmword_1B8347820;
  *((_OWORD *)this + 36) = xmmword_1B8347830;
  *((void *)this + 74) = 0x31AAAC00321E8A92;
  *(_OWORD *)((char *)this + 600) = 0u;
  *(_OWORD *)((char *)this + 616) = 0u;
  *((_OWORD *)this + 40) = xmmword_1B7E736B0;
  *((_OWORD *)this + 41) = xmmword_1B7E736C0;
  *((_OWORD *)this + 42) = xmmword_1B7E736D0;
  *((_OWORD *)this + 43) = xmmword_1B7E734D0;
  *((void *)this + 88) = 0x300000003;
  *((_DWORD *)this + 178) = 0;
  uint64_t v2 = *((void *)this + 67);
  if (v2)
  {
    unsigned int v3 = *(const void **)(v2 + 16);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(v2 + 16) = 0;
    }
    *(_DWORD *)(v2 + 24) = 1065353216;
    *(void *)(v2 + 28) = 0;
    *(void *)(v2 + 44) = 0;
    *(void *)(v2 + 36) = 0;
    *(_DWORD *)(v2 + 52) = 0;
    *(unsigned char *)(v2 + 56) = 1;
    *(_DWORD *)(v2 + 60) = 2;
    *(void *)(v2 + 72) = *(void *)(v2 + 64);
    *(_OWORD *)(v2 + 88) = xmmword_1B8347800;
    *(unsigned char *)(v2 + 104) = 1;
    *(void *)(v2 + 108) = 0x100000000;
  }
  double result = 0.0;
  *((void *)this + 68) = 0;
  return result;
}

void HGColorConform::~HGColorConform(HGColorConform *this)
{
  *(void *)this = &unk_1F10DD998;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 67);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  unint64_t v4 = (HGSynchronizable *)HGColorConform::s_NodeListCacheLock;
  HGSynchronizable::Lock((HGSynchronizable *)HGColorConform::s_NodeListCacheLock);
  uint64_t v5 = *((void *)this + 53);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  HGSynchronizable::Unlock(v4);
  float v6 = (std::__shared_weak_count *)*((void *)this + 98);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    float v7 = (HGNode *)this;
  }
  else
  {
    float v7 = (HGNode *)this;
  }
  HGNode::~HGNode(v7);
}

{
  void *v1;
  uint64_t vars8;

  HGColorConform::~HGColorConform(this);

  HGObject::operator delete(v1);
}

HGNode *HGColorConform::SetInputPixelFormat(uint64_t a1, uint64_t a2, char *a3)
{
  int v3 = a2;
  double result = HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_DWORD *)(a1 + 444) = v3;
  return result;
}

HGNode *HGColorConform::SetOutputPixelFormat(uint64_t a1, uint64_t a2, char *a3)
{
  int v3 = (int)a3;
  int v4 = a2;
  double result = HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_DWORD *)(a1 + 440) = v4;
  *(_DWORD *)(a1 + 448) = v3;
  return result;
}

HGNode *HGColorConform::SetPremultiplyState(HGNode *this, uint64_t a2, char *a3)
{
  int v3 = (int)a3;
  int v4 = this;
  if (*((unsigned __int8 *)this + 472) == a2)
  {
    if (*((unsigned __int8 *)this + 473) == a3) {
      return this;
    }
LABEL_5:
    this = HGNode::ClearBits(v4, a2, a3);
    *((unsigned char *)v4 + 473) = v3;
    return this;
  }
  char v5 = a2;
  this = HGNode::ClearBits(this, a2, a3);
  *((unsigned char *)v4 + 472) = v5;
  if (*((unsigned __int8 *)v4 + 473) != v3) {
    goto LABEL_5;
  }
  return this;
}

double HGColorConformLook3DLUT::Clear(HGColorConformLook3DLUT *this)
{
  uint64_t v2 = (const void *)*((void *)this + 2);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 2) = 0;
  }
  *((_DWORD *)this + 6) = 1065353216;
  *(void *)((char *)this + 28) = 0;
  *(void *)((char *)this + 44) = 0;
  *(void *)((char *)this + 36) = 0;
  *((_DWORD *)this + 13) = 0;
  *((unsigned char *)this + 56) = 1;
  *((_DWORD *)this + 15) = 2;
  *((void *)this + 9) = *((void *)this + 8);
  *(_OWORD *)((char *)this + 88) = xmmword_1B8347800;
  *((unsigned char *)this + 104) = 1;
  *(void *)&double result = 0x100000000;
  *(void *)((char *)this + 108) = 0x100000000;
  return result;
}

uint64_t HGColorConform::SetLook3DLutConversion(uint64_t a1, uint64_t a2, char *a3, int a4)
{
  int v5 = (int)a3;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  *(_DWORD *)(a1 + 484) = 5;
  v8.n128_f64[0] = HGColorConform::ClearConversionParams((HGColorConform *)a1);
  uint64_t v9 = *(void *)(a1 + 536);
  if (v9 != a2)
  {
    if (v9) {
      (*(void (**)(uint64_t, double))(*(void *)v9 + 24))(v9, v8.n128_f64[0]);
    }
    *(void *)(a1 + 536) = a2;
    if (a2) {
      (*(void (**)(uint64_t, __n128))(*(void *)a2 + 16))(a2, v8);
    }
  }
  *(_DWORD *)(a1 + 544) = v5;
  *(_DWORD *)(a1 + 548) = a4;
  return 1;
}

void HGColorConform::Prep3DLUTBitmap()
{
  {
    {
      __cxa_atexit((void (*)(void *))HGColorConformLUTEntryFactory::~HGColorConformLUTEntryFactory, &HGColorConform::Prep3DLUTBitmap(HGRenderer *,unsigned char const*,unsigned long,unsigned long,unsigned long,BOOL,HGColorConform::hgLookLUTEndian)::lutFactory, &dword_1B73F3000);
    }
  }
  operator new();
}

void sub_1B780401C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
  _Unwind_Resume(a1);
}

HGNode *HGColorConform::SetToneQualityMode(HGNode *result, uint64_t a2, char *a3)
{
  if (*((_DWORD *)result + 109) != a2)
  {
    int v3 = a2;
    int v4 = result;
    double result = HGNode::ClearBits(result, a2, a3);
    *((_DWORD *)v4 + 109) = v3;
  }
  return result;
}

HGColorGamma *HGColorConform::CreateColorGammaNode(HGColorConform *this)
{
  uint64_t v2 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
  HGColorGamma::HGColorGamma(v2);
  HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v2, *((unsigned char *)this + 474));
  return v2;
}

void sub_1B7804174(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorConform::PrepareOutputNode(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(result + 452) == 1)
  {
    *(void *)(result + 456) = a3;
    *(void *)(result + 464) = a4;
  }
  return result;
}

uint64_t HGColorConform::SetConversion(HGNode *this, CGColorSpace *a2, CGColorSpace *a3)
{
  HGNode::ClearBits(this, (uint64_t)a2, (char *)a3);
  *((_DWORD *)this + 121) = -1;
  double v8 = HGColorConform::ClearConversionParams((HGColorConform *)this);
  if (!a2 || !a3)
  {
    HGLogger::warning((HGLogger *)"SetConversion does not allow NULL CGColorSpaceRef", v6, v7, v8);
    return 0;
  }
  if (CFEqual(a2, a3)) {
    return 1;
  }
  CFDataRef v10 = CGColorSpaceCopyICCData(a2);
  if (v10)
  {
    CFDataRef v11 = v10;
    uint64_t v12 = ColorSyncProfileCreate(v10, 0);
    CFRelease(v11);
    CFDataRef v13 = CGColorSpaceCopyICCData(a3);
    if (!v13) {
      goto LABEL_18;
    }
    CFDataRef v14 = v13;
LABEL_13:
    float64x2_t v15 = ColorSyncProfileCreate(v14, 0);
    CFRelease(v14);
    if (v12 && v15)
    {
      uint64_t v16 = HGColorConform::SetConversion(this, v12, v15);
      CFRelease(v12);
      CFRelease(v15);
      return v16;
    }
    if (v15) {
      CFRelease(v15);
    }
LABEL_18:
    if (v12)
    {
      CFRelease(v12);
      return 0;
    }
    return 0;
  }
  uint64_t result = (uint64_t)CGColorSpaceCopyICCData(a3);
  if (result)
  {
    CFDataRef v14 = (const __CFData *)result;
    uint64_t v12 = 0;
    goto LABEL_13;
  }
  return result;
}

uint64_t HGColorConform::SetConversion(HGNode *this, const ColorSyncProfile *a2, const ColorSyncProfile *a3)
{
  HGNode::ClearBits(this, (uint64_t)a2, (char *)a3);
  *((_DWORD *)this + 121) = -1;
  HGColorConform::ClearConversionParams((HGColorConform *)this);
  float v6 = (HGSynchronizable *)HGColorConform::s_NodeListCacheLock;
  HGSynchronizable::Lock((HGSynchronizable *)HGColorConform::s_NodeListCacheLock);
  uint64_t v7 = *((void *)this + 53);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  HGSynchronizable::Unlock(v6);
  ColorSyncMD5 MD5 = ColorSyncProfileGetMD5(a2);
  ColorSyncMD5 v9 = ColorSyncProfileGetMD5(a3);
  if (*(void *)MD5.digest == *(void *)v9.digest && *(void *)&MD5.digest[8] == *(void *)&v9.digest[8]) {
    return 1;
  }
  CFDataRef v11 = (const ColorSyncProfile *)((char *)this + 424);
  uint64_t v12 = (HGSynchronizable *)HGColorConform::s_NodeListCacheLock;
  HGSynchronizable::Lock((HGSynchronizable *)HGColorConform::s_NodeListCacheLock);
  if ((HGColorConform::DecodeFragmentList(a2, a3, v11, 0) & 1) != 0
    || HGColorConform::DecodeFragmentList(a2, a3, v11, (HGColorConformNodeListCacheItem **)1))
  {
    (*(void (**)(void))(**(void **)v11 + 16))();
    uint64_t v13 = 1;
  }
  else
  {
    uint64_t v13 = 0;
    *(void *)CFDataRef v11 = 0;
  }
  HGSynchronizable::Unlock(v12);
  return v13;
}

void sub_1B7804474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGColorConform::DecodeFragmentList(HGColorConform *this, const ColorSyncProfile *a2, const ColorSyncProfile *a3, HGColorConformNodeListCacheItem **a4)
{
  int v4 = (int)a4;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (HGColorConform::GetNodeListFromCache(this, a2, a3, a4))
  {
    char v7 = 1;
  }
  else
  {
    int v37 = v4;
    unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
    if (v8) {
      HGLogger::log((HGLogger *)"colorConform", (const char *)1, (HGLogger *)"HGColorConform processing ColorSync fragment list.\n", v5, v6);
    }
    float32x4_t v45 = 0;
    CFDictionaryRef v46 = 0;
    ColorSyncMD5 v9 = (void **)MEMORY[0x1E4F1A768];
    CFDataRef v10 = (void **)MEMORY[0x1E4F1A770];
    CFDataRef v11 = (void *)*MEMORY[0x1E4F1A770];
    uint64_t v12 = (void **)MEMORY[0x1E4F1A7B8];
    keys[0] = *(void **)MEMORY[0x1E4F1A768];
    keys[1] = v11;
    keys[2] = *(void **)MEMORY[0x1E4F1A7B8];
    uint64_t v13 = (void **)MEMORY[0x1E4F1A780];
    CFDataRef v14 = (void *)*MEMORY[0x1E4F1A780];
    values[0] = this;
    values[1] = v14;
    values[2] = *(void **)MEMORY[0x1E4F1A798];
    float32x4_t v45 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, 0, 0);
    float64x2_t v15 = *v10;
    v42[0] = *v9;
    v42[1] = v15;
    v42[2] = *v12;
    uint64_t v16 = *v13;
    v41[0] = a2;
    v41[1] = v16;
    v41[2] = *(void **)MEMORY[0x1E4F1A7A8];
    CFDictionaryRef v46 = CFDictionaryCreate(0, (const void **)v42, (const void **)v41, 3, 0, 0);
    CFArrayRef v17 = CFArrayCreate(0, (const void **)&v45, 2, 0);
    ColorSyncTransformRef v18 = ColorSyncTransformCreate(v17, 0);
    CFRelease(v45);
    CFRelease(v46);
    CFRelease(v17);
    if (v18)
    {
      int v21 = (uint64_t *)MEMORY[0x1E4F1A7A0];
      if (v37) {
        int v21 = (uint64_t *)MEMORY[0x1E4F1A7B0];
      }
      uint64_t v22 = *v21;
      unsigned __int8 v23 = atomic_load(HGLogger::_enabled);
      if (v23)
      {
        int64x2_t v24 = "false";
        if (v37) {
          int64x2_t v24 = "true";
        }
        HGLogger::log((HGLogger *)"colorConform", (const char *)1, (HGLogger *)"HGColorConform using simplified conversion data? %s", v19, v20, v24);
      }
      CFArrayRef theArray = (const __CFArray *)MEMORY[0x1BA9BF350](v18, v22, 0);
      CFRelease(v18);
      if (theArray)
      {
        CFIndex Count = CFArrayGetCount(theArray);
        if (Count)
        {
          unsigned __int8 v29 = atomic_load(HGLogger::_enabled);
          if (v29) {
            HGLogger::log((HGLogger *)"colorConform", (const char *)1, (HGLogger *)"\tRetrieved %i fragments\n", v27, v28, Count);
          }
          operator new();
        }
        CFRelease(theArray);
        unsigned __int8 v34 = atomic_load(HGLogger::_enabled);
        if (v34) {
          HGLogger::log((HGLogger *)"colorConform", (const char *)1, (HGLogger *)"HGColorConform finished processing ColorSync fragment list: FAILURE (0 fragments).\n", v32, v33);
        }
      }
      else
      {
        unsigned __int8 v31 = atomic_load(HGLogger::_enabled);
        if (v31) {
          HGLogger::log((HGLogger *)"colorConform", (const char *)1, (HGLogger *)"HGColorConform finished processing ColorSync fragment list: FAILURE (ColorSyncTransformCopyProperty).\n", v25, v26);
        }
      }
    }
    else
    {
      unsigned __int8 v30 = atomic_load(HGLogger::_enabled);
      if (v30) {
        HGLogger::log((HGLogger *)"colorConform", (const char *)1, (HGLogger *)"HGColorConform finished processing ColorSync fragment list: FAILURE (ColorSyncTransformCreate).\n", v19, v20);
      }
    }
    char v7 = 0;
  }
  return v7 & 1;
}

void sub_1B7806120(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGColorConform::SetConversion(uint64_t a1, uint64_t a2, char *a3)
{
  if ((a2 & 0xFFFFFFFE) != 0x16 && (a2 - 1) >= 5) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if (*(_DWORD *)(a1 + 484) != v4)
  {
    HGNode::ClearBits((HGNode *)a1, a2, a3);
    *(_DWORD *)(a1 + 484) = v4;
    HGColorConform::ClearConversionParams((HGColorConform *)a1);
  }
  return 1;
}

uint64_t HGColorConform::SetConversion(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  if (*(_DWORD *)(a1 + 484) == 1
    && *(_DWORD *)(a1 + 488) == a2
    && *(_DWORD *)(a1 + 496) == a3
    && *(_DWORD *)(a1 + 504) == a4
    && *(_DWORD *)(a1 + 492) == a5
    && *(_DWORD *)(a1 + 500) == a6
    && *(_DWORD *)(a1 + 508) == a7)
  {
    return 1;
  }
  if ((HGColorGamma::TestConversion(a2, a3, a4, a5, a6, a7) & 1) != 0
    || HGColorGamma::TestConversion(a2, a3, a4, a5, 8, 0)
    && HGColorGamma::TestConversion(a5, 8, 0, a5, a6, a7))
  {
    HGNode::ClearBits((HGNode *)a1, v15, v16);
    uint64_t v14 = 1;
    *(_DWORD *)(a1 + 484) = 1;
    HGColorConform::ClearConversionParams((HGColorConform *)a1);
    *(_DWORD *)(a1 + 488) = a2;
    *(_DWORD *)(a1 + 496) = a3;
    *(_DWORD *)(a1 + 504) = a4;
    *(_DWORD *)(a1 + 492) = a5;
    *(_DWORD *)(a1 + 500) = a6;
    *(_DWORD *)(a1 + 508) = a7;
  }
  else
  {
    if (*(_DWORD *)(a1 + 484))
    {
      HGNode::ClearBits((HGNode *)a1, v15, v16);
      *(_DWORD *)(a1 + 484) = 0;
      HGColorConform::ClearConversionParams((HGColorConform *)a1);
    }
    return 0;
  }
  return v14;
}

uint64_t HGColorConform::SetConversion(HGNode *this, uint64_t a2, char *a3, int a4, int a5)
{
  int v6 = (int)a3;
  int v7 = a2;
  if (a5) {
    int v9 = 3;
  }
  else {
    int v9 = 0;
  }
  if (*((_DWORD *)this + 121) != 3
    || *((_DWORD *)this + 128) != a2
    || *((_DWORD *)this + 130) != a3
    || *((_DWORD *)this + 131) != a4
    || *((_DWORD *)this + 132) != v9)
  {
    HGNode::ClearBits(this, a2, a3);
    *((_DWORD *)this + 121) = 3;
    HGColorConform::ClearConversionParams((HGColorConform *)this);
    *((_DWORD *)this + 128) = v7;
    *((_DWORD *)this + 130) = v6;
    *((_DWORD *)this + 131) = a4;
    *((_DWORD *)this + 132) = v9;
  }
  return 1;
}

HGNode *HGColorConform::SetAntiSymmetricToneCurves(HGNode *this, uint64_t a2, char *a3)
{
  if (*((unsigned __int8 *)this + 474) != a2)
  {
    char v3 = a2;
    int v4 = this;
    this = HGNode::ClearBits(this, a2, a3);
    *((unsigned char *)v4 + 474) = v3;
  }
  return this;
}

HGColorGamma *HGColorConform::GetOutput(HGColorConform *this, HGRenderer *a2)
{
  int v4 = *((_DWORD *)this + 121);
  if (v4 == -1)
  {
    if (HGColorConform::CreateColorConformHeliumGraph(this, a2)) {
      goto LABEL_3;
    }
  }
  else if (HGColorConform::CreateColorConformHeliumGraph(this, (uint64_t)a2, v4))
  {
LABEL_3:
    uint64_t v5 = *((void *)this + 51);
    Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
    (*(void (**)(uint64_t, void, HGNode *))(*(void *)v5 + 120))(v5, 0, Input);
    return (HGColorGamma *)*((void *)this + 52);
  }
  unsigned __int8 v8 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
  HGColorGamma::HGColorGamma(v8);
  HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v8, *((unsigned char *)this + 474));
  int v9 = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  (*(void (**)(HGColorGamma *, void, HGNode *))(*(void *)v8 + 120))(v8, 0, v9);
  HGColorGamma::SetConversionPreset((uint64_t)v8, 0, v10);
  HGColorGamma::SetFallbackMode((HGNode *)v8, *((unsigned __int8 *)this + 432), v11);
  HGColorGamma::SetDitherMode((HGNode *)v8, *((unsigned __int8 *)this + 433), v12);
  HGColorGamma::SetInputPixelFormat((uint64_t)v8, *((unsigned int *)this + 111), v13);
  HGColorGamma::SetOutputPixelFormat((uint64_t)v8, *((unsigned int *)this + 110), (char *)*((unsigned int *)this + 112));
  HGColorGamma::SetInOut422FilterMode((uint64_t)v8, *((unsigned int *)this + 113), v14);
  HGColorGamma::SetInOut422FilterRect((HGRect *)v8, *(HGRect *)((char *)this + 456));
  HGColorGamma::SetFixedPointPrecisionMode((HGNode *)v8, *((unsigned __int8 *)this + 434), v15);
  HGColorGamma::SetPremultiplyState(v8, *((unsigned char *)this + 472), *((unsigned char *)this + 473));
  HGColorGamma::Set1DLutScaleAndOffset((HGNode *)v8, *((float *)this + 119), *((float *)this + 120), v16, v17);
  *((void *)this + 51) = v8;
  *((void *)this + 52) = v8;
  return v8;
}

void sub_1B7806630(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorConform::CreateColorConformHeliumGraph(HGColorConform *this, uint64_t a2, int a3)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)this + 52);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    *((void *)this + 52) = 0;
  }
  switch(a3)
  {
    case 1:
      ColorGammaNode = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
      HGColorGamma::HGColorGamma(ColorGammaNode);
      HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)ColorGammaNode, *((unsigned char *)this + 474));
      *((void *)this + 51) = ColorGammaNode;
      HGColorGamma::Set1DLutScaleAndOffset((HGNode *)ColorGammaNode, *((float *)this + 119), *((float *)this + 120), v7, v8);
      if (HGColorGamma::SetConversion((uint64_t)ColorGammaNode, *((unsigned int *)this + 122), (char *)*((unsigned int *)this + 124), *((_DWORD *)this + 126), *((_DWORD *)this + 123), *((_DWORD *)this + 125), *((_DWORD *)this + 127)))
      {
        CFDataRef v10 = 0;
        *((void *)this + 52) = ColorGammaNode;
        if (!ColorGammaNode) {
          goto LABEL_76;
        }
      }
      else
      {
        CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
        HGColorGamma::HGColorGamma(v10);
        HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
        (*(void (**)(HGColorGamma *, void, HGColorGamma *))(*(void *)v10 + 120))(v10, 0, ColorGammaNode);
        (*(void (**)(HGColorGamma *))(*(void *)ColorGammaNode + 24))(ColorGammaNode);
        HGColorGamma::SetConversion((uint64_t)ColorGammaNode, *((unsigned int *)this + 122), (char *)*((unsigned int *)this + 124), *((_DWORD *)this + 126), *((_DWORD *)this + 123), 8, 0);
        HGColorGamma::Set1DLutScaleAndOffset((HGNode *)v10, *((float *)this + 119), *((float *)this + 120), v28, v29);
        HGColorGamma::SetConversion((uint64_t)v10, *((unsigned int *)this + 123), (char *)8, 0, *((_DWORD *)this + 123), *((_DWORD *)this + 125), *((_DWORD *)this + 127));
        *((void *)this + 52) = v10;
      }
LABEL_75:
      HGColorGamma::SetToneQualityMode((uint64_t)ColorGammaNode, *((unsigned int *)this + 109), v9);
      HGColorGamma::SetFallbackMode((HGNode *)ColorGammaNode, *((unsigned __int8 *)this + 432), v86);
      HGColorGamma::SetInOut422FilterMode((uint64_t)ColorGammaNode, *((unsigned int *)this + 113), v87);
      HGColorGamma::SetInOut422FilterRect((HGRect *)ColorGammaNode, *(HGRect *)((char *)this + 456));
      HGColorGamma::SetFixedPointPrecisionMode((HGNode *)ColorGammaNode, *((unsigned __int8 *)this + 434), v88);
LABEL_76:
      if (v10)
      {
        HGColorGamma::SetToneQualityMode((uint64_t)v10, *((unsigned int *)this + 109), v9);
        HGColorGamma::SetFallbackMode((HGNode *)v10, *((unsigned __int8 *)this + 432), v89);
        HGColorGamma::SetInOut422FilterMode((uint64_t)v10, *((unsigned int *)this + 113), v90);
        HGColorGamma::SetInOut422FilterRect((HGRect *)v10, *(HGRect *)((char *)this + 456));
        HGColorGamma::SetFixedPointPrecisionMode((HGNode *)v10, *((unsigned __int8 *)this + 434), v91);
      }
      uint64_t v92 = (const void *)*((void *)this + 52);
      if (!v92) {
        return 0;
      }
      uint64_t v93 = (const void *)*((void *)this + 51);
      if (v93) {
      else
      }
        uint64_t v94 = 0;
      if (v97)
      {
        if (!v94) {
          goto LABEL_88;
        }
      }
      else
      {
        uint64_t v97 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
        HGColorGamma::HGColorGamma(v97);
        HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v97, *((unsigned char *)this + 474));
        (*(void (**)(HGColorGamma *, void, void))(*(void *)v97 + 120))(v97, 0, *((void *)this + 52));
        (*(void (**)(void))(**((void **)this + 52) + 24))(*((void *)this + 52));
        *((void *)this + 52) = v97;
        if (!v94) {
          goto LABEL_88;
        }
      }
      HGColorGamma::SetInputPixelFormat((uint64_t)v94, *((unsigned int *)this + 111), v96);
LABEL_88:
      HGColorGamma::SetOutputPixelFormat((uint64_t)v97, *((unsigned int *)this + 110), (char *)*((unsigned int *)this + 112));
      HGColorGamma::SetDitherMode((HGNode *)v97, *((unsigned __int8 *)this + 433), v98);
      HGColorGamma::SetFixedPointPrecisionMode((HGNode *)v97, *((unsigned __int8 *)this + 434), v99);
      if (*((void *)this + 51) == *((void *)this + 52))
      {
        HGColorGamma::SetPremultiplyState(v97, *((unsigned char *)this + 472), *((unsigned char *)this + 473));
      }
      else
      {
        if (v94) {
          HGColorGamma::SetPremultiplyState(v94, *((unsigned char *)this + 472), 0);
        }
        HGColorGamma::SetPremultiplyState(v97, 0, *((unsigned char *)this + 473));
      }
      return 1;
    case 2:
      switch(*((_DWORD *)this + 129))
      {
        case 1:
        case 2:
          CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
          HGColorGamma::HGColorGamma(v10);
          HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
          *((void *)this + 51) = v10;
          *((void *)this + 52) = v10;
          uint64_t v46 = *((unsigned int *)this + 128);
          int v47 = *((_DWORD *)this + 132);
          if (*((_DWORD *)this + 129) == 1) {
            HGColorGamma::SetConversion((uint64_t)v10, v46, (char *)1, 3u, v47);
          }
          else {
            HGColorGamma::SetConversion((uint64_t)v10, v46, (char *)4, 0, v47);
          }
          goto LABEL_76;
        case 3:
          ColorGammaNode = HGColorConform::CreateColorGammaNode(this);
          CFDataRef v10 = HGColorConform::CreateColorGammaNode(this);
          (*(void (**)(HGColorGamma *, void, HGColorGamma *))(*(void *)v10 + 120))(v10, 0, ColorGammaNode);
          (*(void (**)(HGColorGamma *))(*(void *)ColorGammaNode + 24))(ColorGammaNode);
          *((void *)this + 51) = ColorGammaNode;
          *((void *)this + 52) = v10;
          HGColorGamma::SetConversion((uint64_t)ColorGammaNode, *((unsigned int *)this + 128), 0, 3u, *((_DWORD *)this + 132));
          HGColorGamma::SetConversionPreset((uint64_t)v10, 0, v59);
          HGColorGamma::SetGammaFunction((uint64_t)v10, 0, v60, (__n128)xmmword_1B8347840, (float32x4_t)0, (float32x4_t)0, (float32x4_t)0, (int8x16_t)0, (float32x4_t)0, (float32x4_t)0);
          HGColorGamma::Set1DLutScaleAndOffset((HGNode *)v10, *((float *)this + 119), *((float *)this + 120), v61, v62);
          goto LABEL_75;
        case 4:
        case 5:
          ColorGammaNode = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
          HGColorGamma::HGColorGamma(ColorGammaNode);
          HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)ColorGammaNode, *((unsigned char *)this + 474));
          uint64_t v48 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
          HGColorGamma::HGColorGamma(v48);
          HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v48, *((unsigned char *)this + 474));
          CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
          HGColorGamma::HGColorGamma(v10);
          HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
          (*(void (**)(HGColorGamma *, void, HGColorGamma *))(*(void *)v48 + 120))(v48, 0, ColorGammaNode);
          (*(void (**)(HGColorGamma *, void, HGColorGamma *))(*(void *)v10 + 120))(v10, 0, v48);
          (*(void (**)(HGColorGamma *))(*(void *)ColorGammaNode + 24))(ColorGammaNode);
          (*(void (**)(HGColorGamma *))(*(void *)v48 + 24))(v48);
          *((void *)this + 51) = ColorGammaNode;
          *((void *)this + 52) = v10;
          if (*((_DWORD *)this + 129) == 4)
          {
            uint64_t v49 = 12;
            unsigned int v50 = 11;
          }
          else
          {
            uint64_t v49 = 13;
            unsigned int v50 = 12;
          }
          HGColorGamma::SetConversion((uint64_t)ColorGammaNode, *((unsigned int *)this + 128), (char *)v49, v50, *((_DWORD *)this + 132));
          __asm { FMOV            V0.4S, #1.0 }
          HGColorGamma::SetGammaFunction((uint64_t)v48, 18, v70, _Q0, (float32x4_t)0, (float32x4_t)0, (float32x4_t)0, (int8x16_t)0, (float32x4_t)0, (float32x4_t)0);
          HGColorGamma::SetToneQualityMode((uint64_t)v48, *((unsigned int *)this + 109), v71);
          HGColorGamma::SetPremultiplyState(v48, 0, 0);
          HGColorGamma::SetConversion((uint64_t)v10, *((unsigned int *)this + 132), (char *)1, 0, *((_DWORD *)this + 132), 8, 0);
          goto LABEL_75;
        case 6:
        case 7:
        case 8:
        case 9:
          ColorGammaNode = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
          HGColorGamma::HGColorGamma(ColorGammaNode);
          HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)ColorGammaNode, *((unsigned char *)this + 474));
          uint64_t v14 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
          HGColorGamma::HGColorGamma(v14);
          HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v14, *((unsigned char *)this + 474));
          CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
          HGColorGamma::HGColorGamma(v10);
          HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
          int v15 = *((_DWORD *)this + 129);
          if (v15 == 9 || v15 == 7)
          {
            uint64_t v16 = (HgcColorGamma_bias_clamp *)HGObject::operator new(0x1A0uLL);
            HgcColorGamma_bias_clamp::HgcColorGamma_bias_clamp(v16);
          }
          (*(void (**)(HGColorGamma *, void, HGColorGamma *))(*(void *)v14 + 120))(v14, 0, ColorGammaNode);
          (*(void (**)(HGColorGamma *, void, HGColorGamma *))(*(void *)v10 + 120))(v10, 0, v14);
          (*(void (**)(HGColorGamma *))(*(void *)ColorGammaNode + 24))(ColorGammaNode);
          (*(void (**)(HGColorGamma *))(*(void *)v14 + 24))(v14);
          *((void *)this + 51) = ColorGammaNode;
          *((void *)this + 52) = v10;
          int v54 = *((_DWORD *)this + 129);
          if (v54 == 9 || v54 == 7)
          {
            HGColorGamma::SetConversion((uint64_t)ColorGammaNode, 0, (char *)1, *((_DWORD *)this + 128), 0, 1, 0);
            int v58 = *((_DWORD *)this + 129);
            if (v58 == 9) {
              goto LABEL_61;
            }
          }
          else
          {
            if (v54 == 6)
            {
              uint64_t v55 = 8;
              unsigned int v56 = 5;
            }
            else
            {
              uint64_t v55 = 9;
              unsigned int v56 = 8;
            }
            HGColorGamma::SetConversion((uint64_t)ColorGammaNode, *((unsigned int *)this + 128), (char *)v55, v56, *((_DWORD *)this + 132));
            int v58 = *((_DWORD *)this + 129);
            if (v58 == 9) {
              goto LABEL_61;
            }
          }
          if (v58 != 7) {
            goto LABEL_65;
          }
LABEL_61:
          (*(void (**)(void, void, float, float, float, double))(MEMORY[0] + 96))(0, 0, 0.062561, 0.062561, 0.062561, 0.0);
          (*(void (**)(void, uint64_t, float, float, float, float))(MEMORY[0] + 96))(0, 1, 0.85631, 0.85631, 0.85631, 1.0);
          (*(void (**)(void, uint64_t, float, float, float, float))(MEMORY[0] + 96))(0, 2, -3.4028e38, -3.4028e38, -3.4028e38, -3.4028e38);
          (*(void (**)(void, uint64_t, float, float, float, float))(MEMORY[0] + 96))(0, 3, 3.4028e38, 3.4028e38, 3.4028e38, 3.4028e38);
          if (*((_DWORD *)this + 129) == 7) {
            unsigned int v72 = 7;
          }
          else {
            unsigned int v72 = 8;
          }
          HGColorGamma::SetConversion((uint64_t)ColorGammaNode, 0, (char *)9, v72, *((_DWORD *)this + 132));
          HGColorGamma::SetToneQualityMode((uint64_t)ColorGammaNode, *((unsigned int *)this + 109), v73);
          HGColorGamma::SetPremultiplyState(ColorGammaNode, 0, 0);
          int v58 = *((_DWORD *)this + 129);
LABEL_65:
          if (v58 == 7)
          {
            uint64_t v74 = 7;
          }
          else if (v58 == 6)
          {
            uint64_t v74 = 5;
            if (*((unsigned char *)this + 768)) {
              uint64_t v74 = 6;
            }
          }
          else
          {
            uint64_t v74 = 8;
          }
          uint64_t v75 = v74 << 6;
          int v76 = (float32x4_t *)((char *)&HGColorGamma::logGamutRGBToRec2020RGB + v75);
          int32x4_t v77 = (float32x4_t *)((char *)&HGColorGamma::logGamutRGBToRec709RGB + v75);
          if (*((_DWORD *)this + 132) == 3) {
            int32x4_t v77 = v76;
          }
          uint64_t v78 = (const float *)((char *)this + 764);
          float32x4_t v79 = vld1q_dup_f32(v78);
          v79.i32[3] = 1.0;
          float32x4_t v80 = vmulq_f32(v79, v77[1]);
          float32x4_t v107 = vmulq_f32(*v77, v79);
          float32x4_t v108 = v80;
          float32x4_t v81 = vmulq_f32(v79, v77[2]);
          float32x4_t v82 = vmulq_f32(v79, v77[3]);
          float32x4_t v109 = v81;
          float32x4_t v110 = v82;
          HGColorGamma::LoadMatrix2((uint64_t)ColorGammaNode, (uint64_t)&v107, v57);
          __asm { FMOV            V0.4S, #1.0 }
          HGColorGamma::SetGammaFunction((uint64_t)v14, 18, v84, _Q0, (float32x4_t)0, (float32x4_t)0, (float32x4_t)0, (int8x16_t)0, (float32x4_t)0, (float32x4_t)0);
          HGColorGamma::SetToneQualityMode((uint64_t)v14, *((unsigned int *)this + 109), v85);
          HGColorGamma::SetPremultiplyState(v14, 0, 0);
          HGColorGamma::SetConversion((uint64_t)v10, *((unsigned int *)this + 132), (char *)1, 0, *((_DWORD *)this + 132), 8, 0);
          break;
        default:
          CFDataRef v10 = HGColorConform::CreateColorGammaNode(this);
          *((void *)this + 51) = v10;
          *((void *)this + 52) = v10;
          HGColorGamma::Set1DLutScaleAndOffset((HGNode *)v10, *((float *)this + 119), *((float *)this + 120), v63, v64);
          goto LABEL_54;
      }
      goto LABEL_75;
    case 3:
      int v17 = *((_DWORD *)this + 130);
      if ((v17 & 0xFFFFFFFE) == 8)
      {
        ColorSyncTransformRef v18 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
        uint64_t v19 = (uint64_t)v18;
        if (v17 != 8)
        {
          HGColorGamma::HGColorGamma(v18);
          HGColorGamma::SetAntiSymmetricToneCurves(v19, *((unsigned char *)this + 474));
          uint64_t v35 = (HgcColorGamma_bias_clamp *)HGObject::operator new(0x1A0uLL);
          HgcColorGamma_bias_clamp::HgcColorGamma_bias_clamp(v35);
        }
        HGColorGamma::HGColorGamma(v18);
        HGColorGamma::SetAntiSymmetricToneCurves(v19, *((unsigned char *)this + 474));
        *((void *)this + 51) = v19;
        *((void *)this + 52) = v19;
        CFDataRef v10 = (HGColorGamma *)v19;
        uint64_t v20 = (char *)*((unsigned int *)this + 130);
        if (v20 == 8) {
          uint64_t v21 = *((unsigned int *)this + 128);
        }
        else {
          uint64_t v21 = 0;
        }
        HGColorGamma::SetConversion(v19, v21, v20, *((_DWORD *)this + 131), *((_DWORD *)this + 132));
        unsigned int v37 = *((_DWORD *)this + 131);
        if (v37 - 5 <= 1)
        {
          if (*((unsigned char *)this + 768)) {
            unsigned int v37 = 6;
          }
          else {
            unsigned int v37 = 5;
          }
        }
        unint64_t v38 = (unint64_t)v37 << 6;
        size_t v39 = (float32x4_t *)((char *)&HGColorGamma::logGamutRGBToRec709RGB + v38);
        uint64_t v40 = (float32x4_t *)((char *)&HGColorGamma::logGamutRGBToRec2020RGB + v38);
        if (!*((_DWORD *)this + 132)) {
          uint64_t v40 = v39;
        }
        unsigned int v41 = (const float *)((char *)this + 764);
        float32x4_t v42 = vld1q_dup_f32(v41);
        v42.i32[3] = 1.0;
        float32x4_t v43 = vmulq_f32(v42, v40[1]);
        float32x4_t v107 = vmulq_f32(*v40, v42);
        float32x4_t v108 = v43;
        float32x4_t v44 = vmulq_f32(v42, v40[2]);
        float32x4_t v45 = vmulq_f32(v42, v40[3]);
        float32x4_t v109 = v44;
        float32x4_t v110 = v45;
        HGColorGamma::LoadMatrix2(v19, (uint64_t)&v107, v36);
      }
      else
      {
        CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
        HGColorGamma::HGColorGamma(v10);
        HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
        *((void *)this + 51) = v10;
        *((void *)this + 52) = v10;
        int v27 = (char *)*((unsigned int *)this + 130);
        if (v27 == -1)
        {
          HGColorGamma::SetConversionPreset((uint64_t)v10, 0, v27);
          HGColorGamma::Set1DLutScaleAndOffset((HGNode *)v10, *((float *)this + 119), *((float *)this + 120), v51, v52);
        }
        else
        {
          HGColorGamma::SetConversion((uint64_t)v10, *((unsigned int *)this + 128), v27, *((_DWORD *)this + 131), *((_DWORD *)this + 132));
          if (*((_DWORD *)this + 130) == 2) {
            HGColorGamma::SetARRILogCExposureIndex((HGNode *)v10, *((unsigned int *)this + 190), v9);
          }
        }
      }
      goto LABEL_76;
    case 4:
      int v22 = *((_DWORD *)this + 139);
      unsigned __int8 v23 = (HgcWhiteBalanceRAW *)HGObject::operator new(0x1A0uLL);
      int64x2_t v24 = v23;
      if (v22)
      {
        *((_OWORD *)v23 + 24) = 0u;
        *((_OWORD *)v23 + 25) = 0u;
        *((_OWORD *)v23 + 22) = 0u;
        *((_OWORD *)v23 + 23) = 0u;
        *((_OWORD *)v23 + 20) = 0u;
        *((_OWORD *)v23 + 21) = 0u;
        *((_OWORD *)v23 + 18) = 0u;
        *((_OWORD *)v23 + 19) = 0u;
        *((_OWORD *)v23 + 16) = 0u;
        *((_OWORD *)v23 + 17) = 0u;
        *((_OWORD *)v23 + 14) = 0u;
        *((_OWORD *)v23 + 15) = 0u;
        *((_OWORD *)v23 + 12) = 0u;
        *((_OWORD *)v23 + 13) = 0u;
        *((_OWORD *)v23 + 10) = 0u;
        *((_OWORD *)v23 + 11) = 0u;
        *((_OWORD *)v23 + 8) = 0u;
        *((_OWORD *)v23 + 9) = 0u;
        *((_OWORD *)v23 + 6) = 0u;
        *((_OWORD *)v23 + 7) = 0u;
        *((_OWORD *)v23 + 4) = 0u;
        *((_OWORD *)v23 + 5) = 0u;
        *((_OWORD *)v23 + 2) = 0u;
        *((_OWORD *)v23 + 3) = 0u;
        *(_OWORD *)unsigned __int8 v23 = 0u;
        *((_OWORD *)v23 + 1) = 0u;
        HgcWhiteBalanceRAW::HgcWhiteBalanceRAW(v23);
      }
      HGDemosaic::HGDemosaic(v23);
      *((void *)this + 51) = v24;
      (*(void (**)(HgcWhiteBalanceRAW *, void, float, double, double, double))(*(void *)v24 + 96))(v24, 0, (float)*((unsigned int *)this + 138), 0.0, 0.0, 0.0);
      (*(void (**)(HgcWhiteBalanceRAW *, uint64_t, float, double, double, double))(*(void *)v24 + 96))(v24, 1, *((float *)this + 141), 0.0, 0.0, 0.0);
      (*(void (**)(HgcWhiteBalanceRAW *, uint64_t, float, double, double, double))(*(void *)v24 + 96))(v24, 2, 65535.0 / *((float *)this + 140), 0.0, 0.0, 0.0);
      (*(void (**)(HgcWhiteBalanceRAW *, uint64_t, float, float, double, double))(*(void *)v24 + 96))(v24, 3, *((float *)this + 145), *((float *)this + 146), 0.0, 0.0);
      (*(void (**)(HgcWhiteBalanceRAW *, uint64_t, float, double, double, double))(*(void *)v24 + 96))(v24, 4, *((float *)this + 142), 0.0, 0.0, 0.0);
      (*(void (**)(HgcWhiteBalanceRAW *, uint64_t, float, double, double, double))(*(void *)v24 + 96))(v24, 5, *((float *)this + 147), 0.0, 0.0, 0.0);
      (*(void (**)(HgcWhiteBalanceRAW *, uint64_t, float, double, double, double))(*(void *)v24 + 96))(v24, 6, *((float *)this + 148), 0.0, 0.0, 0.0);
      (*(void (**)(HgcWhiteBalanceRAW *, uint64_t, float, double, double, double))(*(void *)v24 + 96))(v24, 7, *((float *)this + 149), 0.0, 0.0, 0.0);
      v30.n128_u32[0] = *((_DWORD *)this + 143);
      v31.n128_u32[0] = *((_DWORD *)this + 144);
      v32.n128_u64[0] = 0;
      v33.n128_u64[0] = 0;
      (*(void (**)(HgcWhiteBalanceRAW *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)v24 + 96))(v24, 8, v30, v31, v32, v33);
      unsigned __int8 v34 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
      HGColorMatrix::HGColorMatrix(v34);
    case 5:
      ColorGammaNode = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
      HGColorGamma::HGColorGamma(ColorGammaNode);
      HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)ColorGammaNode, *((unsigned char *)this + 474));
      if (*(void *)(*((void *)this + 67) + 16))
      {
        if (!*((unsigned char *)this + 756))
        {
          double v25 = (HgcASC_CDL *)HGObject::operator new(0x1A0uLL);
          HgcASC_CDL::HgcASC_CDL(v25);
          (*(void (**)(HgcASC_CDL *, void, HGColorGamma *))(*(void *)v25 + 120))(v25, 0, ColorGammaNode);
          (*(void (**)(HGColorGamma *))(*(void *)ColorGammaNode + 24))(ColorGammaNode);
          (*(void (**)(HgcASC_CDL *, void, float, float, float, float))(*(void *)v25 + 96))(v25, 0, *((float *)this + 179), *((float *)this + 180), *((float *)this + 181), 1.0);
          (*(void (**)(HgcASC_CDL *, uint64_t, float, float, float, double))(*(void *)v25 + 96))(v25, 1, *((float *)this + 182), *((float *)this + 183), *((float *)this + 184), 0.0);
          (*(void (**)(HgcASC_CDL *, uint64_t, float, float, float, float))(*(void *)v25 + 96))(v25, 2, *((float *)this + 185), *((float *)this + 186), *((float *)this + 187), 1.0);
          (*(void (**)(HgcASC_CDL *, uint64_t, float, double, double, double))(*(void *)v25 + 96))(v25, 3, *((float *)this + 188), 0.0, 0.0, 0.0);
        }
        double v26 = (HGNode *)HGObject::operator new(0x210uLL);
        HGApply3DLUT::HGApply3DLUT(v26, *(void *)(*((void *)this + 67) + 32), 0x19u, 1, 1, 1, 1, 1, *(float *)(*((void *)this + 67) + 24), *(float *)(*((void *)this + 67) + 28), 0.0, 1.0, 0.0, 0.0, 0);
      }
      CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
      HGColorGamma::HGColorGamma(v10);
      HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
      (*(void (**)(HGColorGamma *, void, HGColorGamma *))(*(void *)v10 + 120))(v10, 0, ColorGammaNode);
      (*(void (**)(HGColorGamma *))(*(void *)ColorGammaNode + 24))(ColorGammaNode);
      *((void *)this + 51) = ColorGammaNode;
      *((void *)this + 52) = v10;
      unsigned int v53 = *((_DWORD *)this + 136);
      if (v53) {
        HGColorGamma::SetConversion((uint64_t)ColorGammaNode, 0, (char *)1, v53, 0, 1, 0);
      }
      HGColorGamma::SetConversion((uint64_t)v10, *(unsigned int *)(*((void *)this + 67) + 108), (char *)*(unsigned int *)(*((void *)this + 67) + 112), 0, *((_DWORD *)this + 137), 8, 0);
      if (!ColorGammaNode) {
        goto LABEL_76;
      }
      goto LABEL_75;
    default:
      CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
      HGColorGamma::HGColorGamma(v10);
      HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
      *((void *)this + 51) = v10;
      *((void *)this + 52) = v10;
      HGColorGamma::Set1DLutScaleAndOffset((HGNode *)v10, *((float *)this + 119), *((float *)this + 120), v11, v12);
      switch(a3)
      {
        case 6:
          HGColorGamma::SetConversionPreset((uint64_t)v10, 1, v13);
          goto LABEL_76;
        case 7:
          HGColorGamma::SetConversionPreset((uint64_t)v10, 2, v13);
          goto LABEL_76;
        case 8:
          HGColorGamma::SetConversionPreset((uint64_t)v10, 3, v13);
          goto LABEL_76;
        case 9:
          HGColorGamma::SetConversionPreset((uint64_t)v10, 4, v13);
          goto LABEL_76;
        case 10:
          HGColorGamma::SetConversionPreset((uint64_t)v10, 5, v13);
          goto LABEL_76;
        case 11:
          HGColorGamma::SetConversionPreset((uint64_t)v10, 6, v13);
          goto LABEL_76;
        case 12:
          uint64_t v100 = (uint64_t)v10;
          uint64_t v101 = 0;
          uint64_t v102 = 1;
          unsigned int v103 = 1;
          goto LABEL_106;
        case 13:
          uint64_t v100 = (uint64_t)v10;
          uint64_t v101 = 2;
          goto LABEL_102;
        case 14:
          uint64_t v100 = (uint64_t)v10;
          uint64_t v101 = 1;
LABEL_102:
          uint64_t v102 = 1;
          unsigned int v103 = 2;
          goto LABEL_106;
        case 15:
          uint64_t v100 = (uint64_t)v10;
          uint64_t v101 = 0;
          goto LABEL_105;
        case 16:
          uint64_t v100 = (uint64_t)v10;
          uint64_t v101 = 2;
LABEL_105:
          uint64_t v102 = 1;
          unsigned int v103 = 0;
LABEL_106:
          int v104 = 8;
          goto LABEL_114;
        case 17:
          HGColorGamma::SetConversion((uint64_t)v10, 0, (char *)8, 0, 0, 1, 1u);
          goto LABEL_76;
        case 18:
          uint64_t v105 = (uint64_t)v10;
          unsigned int v106 = 2;
          goto LABEL_110;
        case 19:
          uint64_t v105 = (uint64_t)v10;
          unsigned int v106 = 1;
LABEL_110:
          HGColorGamma::SetConversion(v105, 0, (char *)8, 0, v106, 1, 2u);
          goto LABEL_76;
        case 20:
          uint64_t v100 = (uint64_t)v10;
          uint64_t v101 = 0;
          uint64_t v102 = 8;
          unsigned int v103 = 0;
          goto LABEL_113;
        case 21:
          uint64_t v100 = (uint64_t)v10;
          uint64_t v101 = 0;
          uint64_t v102 = 1;
          unsigned int v103 = 1;
LABEL_113:
          int v104 = 1;
LABEL_114:
          HGColorGamma::SetConversion(v100, v101, (char *)v102, v103, 0, v104, 0);
          break;
        default:
LABEL_54:
          HGColorGamma::SetConversionPreset((uint64_t)v10, 0, v13);
          break;
      }
      goto LABEL_76;
  }
}

void sub_1B7808258(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B780826C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808280(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808294(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78082A8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78082BC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78082D0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78082E4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78082F8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B780830C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808320(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808334(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808348(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B780835C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808370(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808384(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808398(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78083AC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78083C0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78083D4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78083E8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78083FC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808410(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808424(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808438(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B780844C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808460(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7808474(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGColorConform::CreateColorConformHeliumGraph(HGColorConform *this, HGRenderer *a2)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 53);
  if (!v2) {
    return 0;
  }
  char v3 = *(uint64_t **)(v2 + 16);
  unint64_t v4 = (unint64_t)(v3[1] - *v3) >> 3;
  if (!v4) {
    return 0;
  }
  uint64_t v7 = *((void *)this + 52);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  if ((int)v4 >= 1)
  {
    int v8 = 0;
    int v9 = 0;
    while (1)
    {
      int v11 = v4 - v8;
      if ((int)v4 - v8 >= 3) {
        break;
      }
      if (v11 == 2)
      {
        uint64_t v13 = *v3;
        unint64_t v12 = v8;
        unint64_t v14 = (v3[1] - *v3) >> 3;
        goto LABEL_32;
      }
      if (v11 >= 1)
      {
        uint64_t v13 = *v3;
        unint64_t v12 = v8;
        unint64_t v14 = (v3[1] - *v3) >> 3;
LABEL_63:
        if (v14 <= v12) {
          std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
        }
        int v53 = **(_DWORD **)(v13 + 8 * v12);
        if (v53 < 2)
        {
          if (v53 == 1)
          {
            CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
            HGColorGamma::HGColorGamma(v10);
            HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
            HGColorGamma::SetPremultiplyState(v10, 0, 0);
            HGColorGamma::Set1DLutScaleAndOffset((HGNode *)v10, *((float *)this + 119), *((float *)this + 120), v63, v64);
            HGColorGamma::SetToneQualityMode((uint64_t)v10, *((unsigned int *)this + 109), v65);
            HGColorGamma::SetFallbackMode((HGNode *)v10, *((unsigned __int8 *)this + 432), v66);
            HGColorGamma::SetInOut422FilterMode((uint64_t)v10, *((unsigned int *)this + 113), v67);
            HGColorGamma::SetInOut422FilterRect((HGRect *)v10, *(HGRect *)((char *)this + 456));
            HGColorGamma::SetFixedPointPrecisionMode((HGNode *)v10, *((unsigned __int8 *)this + 434), v68);
            if (v12 >= (v3[1] - *v3) >> 3) {
              std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
            }
            long long v86 = *(_OWORD *)(*(void *)(*v3 + 8 * v12) + 16);
            if (v12 >= (v3[1] - *v3) >> 3) {
              std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
            }
            long long v87 = *(_OWORD *)(*(void *)(*v3 + 8 * v12) + 32);
            if (v12 >= (v3[1] - *v3) >> 3) {
              std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
            }
            long long v88 = *(_OWORD *)(*(void *)(*v3 + 8 * v12) + 48);
            if (v12 >= (v3[1] - *v3) >> 3) {
              std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
            }
            long long v89 = *(_OWORD *)(*(void *)(*v3 + 8 * v12) + 64);
            __n128 Matrix1 = HGColorGamma::LoadMatrix1((uint64_t)v10, (uint64_t)&v86, v69);
            if (v8)
            {
              (*(void (**)(HGColorGamma *, void, HGColorGamma *, __n128))(*(void *)v10 + 120))(v10, 0, v9, Matrix1);
              (*(void (**)(HGColorGamma *))(*(void *)v9 + 24))(v9);
              goto LABEL_101;
            }
LABEL_100:
            *((void *)this + 51) = v10;
            goto LABEL_101;
          }
        }
        else
        {
          if (v53 <= 6)
          {
            CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
            HGColorGamma::HGColorGamma(v10);
            HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
            HGColorGamma::SetPremultiplyState(v10, 0, 0);
            HGColorGamma::Set1DLutScaleAndOffset((HGNode *)v10, *((float *)this + 119), *((float *)this + 120), v54, v55);
            HGColorGamma::SetToneQualityMode((uint64_t)v10, *((unsigned int *)this + 109), v56);
            HGColorGamma::SetFallbackMode((HGNode *)v10, *((unsigned __int8 *)this + 432), v57);
            HGColorGamma::SetInOut422FilterMode((uint64_t)v10, *((unsigned int *)this + 113), v58);
            HGColorGamma::SetInOut422FilterRect((HGRect *)v10, *(HGRect *)((char *)this + 456));
            HGColorGamma::SetFixedPointPrecisionMode((HGNode *)v10, *((unsigned __int8 *)this + 434), v59);
            if (v12 >= (v3[1] - *v3) >> 3) {
              std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
            }
            uint64_t v61 = *(void *)(*v3 + 8 * v12);
            if ((*(_DWORD *)v61 - 3) >= 4) {
              uint64_t v62 = 0;
            }
            else {
              uint64_t v62 = (*(_DWORD *)v61 - 2);
            }
            HGColorGamma::SetGammaFunction((uint64_t)v10, v62, v60, *(__n128 *)(v61 + 80), *(float32x4_t *)(v61 + 96), *(float32x4_t *)(v61 + 112), *(float32x4_t *)(v61 + 128), *(int8x16_t *)(v61 + 144), *(float32x4_t *)(v61 + 160), *(float32x4_t *)(v61 + 176));
            if (v8)
            {
              (*(void (**)(HGColorGamma *, void, HGColorGamma *))(*(void *)v10 + 120))(v10, 0, v9);
              (*(void (**)(HGColorGamma *))(*(void *)v9 + 24))(v9);
LABEL_101:
              ++v8;
              goto LABEL_8;
            }
            goto LABEL_100;
          }
          if (v53 == 8)
          {
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9EE58A8, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1E9EE58A8))
            {
              __cxa_atexit((void (*)(void *))HGColorConformLUTEntryFactory::~HGColorConformLUTEntryFactory, &off_1EB9A04E0, &dword_1B73F3000);
              __cxa_guard_release(&qword_1E9EE58A8);
            }
            HGLUTCacheManager::getLUTCache(*((void *)a2 + 69), (uint64_t *)&off_1EB9A04E0);
            if (v12 < (v3[1] - *v3) >> 3)
            {
              int v73 = *(_DWORD *)(*(void *)(*v3 + 8 * v12) + 204);
              if (v73 != 25 && v73 != 19)
              {
                int v76 = (HGNode *)HGObject::operator new(0x210uLL);
                if (v12 < (v3[1] - *v3) >> 3) {
                  HGApply3DLUT::HGApply3DLUT(v76, *(_DWORD *)(*(void *)(*v3 + 8 * v12) + 200), *(_DWORD *)(*(void *)(*v3 + 8 * v12) + 204), 1, 1, 1, 1, 1, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0);
                }
                std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
              }
              uint64_t v75 = (HGNode *)HGObject::operator new(0x210uLL);
              if (v12 < (v3[1] - *v3) >> 3) {
                HGApply3DLUT::HGApply3DLUT(v75, *(_DWORD *)(*(void *)(*v3 + 8 * v12) + 200), 0x19u, 1, 1, 1, 1, 1, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0);
              }
              std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
            }
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          if (v53 == 7)
          {
            uint64_t v71 = (HGApply1DLUT *)HGObject::operator new(0x1D0uLL);
            HGApply1DLUT::HGApply1DLUT(v71);
            if (v12 < (v3[1] - *v3) >> 3)
            {
              HGApply1DLUT::Init(v71, *(_DWORD *)(*(void *)(*v3 + 8 * v12) + 200), 1.0, 0.0, 1, 1, 1, *(unsigned char *)(*(void *)(*v3 + 8 * v12) + 216), 1, 1);
              if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_103, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&_MergedGlobals_103))
              {
                __cxa_atexit((void (*)(void *))HGColorConformLUTEntryFactory::~HGColorConformLUTEntryFactory, _MergedGlobals_0, &dword_1B73F3000);
                __cxa_guard_release(&_MergedGlobals_103);
              }
              if (v12 < (v3[1] - *v3) >> 3)
              {
                uint64_t v72 = *(void *)(*(void *)(*v3 + 8 * v12) + 208);
                if (v72) {
                  (*(void (**)(uint64_t))(*(void *)v72 + 16))(v72);
                }
                operator new();
              }
              std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
            }
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
        }
      }
      CFDataRef v10 = v9;
LABEL_8:
      int v9 = v10;
      if (v8 >= (int)v4) {
        goto LABEL_108;
      }
    }
    unint64_t v12 = v8;
    uint64_t v13 = *v3;
    unint64_t v14 = (v3[1] - *v3) >> 3;
    if (v14 <= v8) {
      std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
    }
    if (**(_DWORD **)(v13 + 8 * v8) == 1)
    {
      unint64_t v15 = v8 + 1;
      if (v14 <= v15) {
        std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
      }
      if ((**(_DWORD **)(v13 + 8 * v15) - 2) <= 4)
      {
        unint64_t v16 = v8 + 2;
        if (v14 <= v16) {
          std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
        }
        if (**(_DWORD **)(v13 + 8 * v16) == 1)
        {
          CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
          HGColorGamma::HGColorGamma(v10);
          HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
          HGColorGamma::SetPremultiplyState(v10, 0, 0);
          HGColorGamma::Set1DLutScaleAndOffset((HGNode *)v10, *((float *)this + 119), *((float *)this + 120), v17, v18);
          if (v8 >= (unint64_t)((v3[1] - *v3) >> 3)) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v86 = *(_OWORD *)(*(void *)(*v3 + 8 * v8) + 16);
          if (v8 >= (unint64_t)((v3[1] - *v3) >> 3)) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v87 = *(_OWORD *)(*(void *)(*v3 + 8 * v8) + 32);
          if (v8 >= (unint64_t)((v3[1] - *v3) >> 3)) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v88 = *(_OWORD *)(*(void *)(*v3 + 8 * v8) + 48);
          if (v8 >= (unint64_t)((v3[1] - *v3) >> 3)) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v89 = *(_OWORD *)(*(void *)(*v3 + 8 * v8) + 64);
          HGColorGamma::LoadMatrix1((uint64_t)v10, (uint64_t)&v86, v19);
          HGColorGamma::SetToneQualityMode((uint64_t)v10, *((unsigned int *)this + 109), v20);
          HGColorGamma::SetFallbackMode((HGNode *)v10, *((unsigned __int8 *)this + 432), v21);
          HGColorGamma::SetInOut422FilterMode((uint64_t)v10, *((unsigned int *)this + 113), v22);
          HGColorGamma::SetInOut422FilterRect((HGRect *)v10, *(HGRect *)((char *)this + 456));
          HGColorGamma::SetFixedPointPrecisionMode((HGNode *)v10, *((unsigned __int8 *)this + 434), v23);
          if (v15 >= (v3[1] - *v3) >> 3) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          uint64_t v25 = *(void *)(*v3 + 8 * v15);
          if ((*(_DWORD *)v25 - 3) >= 4) {
            uint64_t v26 = 0;
          }
          else {
            uint64_t v26 = (*(_DWORD *)v25 - 2);
          }
          HGColorGamma::SetGammaFunction((uint64_t)v10, v26, v24, *(__n128 *)(v25 + 80), *(float32x4_t *)(v25 + 96), *(float32x4_t *)(v25 + 112), *(float32x4_t *)(v25 + 128), *(int8x16_t *)(v25 + 144), *(float32x4_t *)(v25 + 160), *(float32x4_t *)(v25 + 176));
          if (v16 >= (v3[1] - *v3) >> 3) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v86 = *(_OWORD *)(*(void *)(*v3 + 8 * v16) + 16);
          if (v16 >= (v3[1] - *v3) >> 3) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v87 = *(_OWORD *)(*(void *)(*v3 + 8 * v16) + 32);
          if (v16 >= (v3[1] - *v3) >> 3) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v88 = *(_OWORD *)(*(void *)(*v3 + 8 * v16) + 48);
          if (v16 >= (v3[1] - *v3) >> 3) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v89 = *(_OWORD *)(*(void *)(*v3 + 8 * v16) + 64);
          __n128 Matrix2 = HGColorGamma::LoadMatrix2((uint64_t)v10, (uint64_t)&v86, v27);
          if (v8)
          {
            (*(void (**)(HGColorGamma *, void, HGColorGamma *, __n128))(*(void *)v10 + 120))(v10, 0, v9, Matrix2);
            (*(void (**)(HGColorGamma *))(*(void *)v9 + 24))(v9);
            v8 += 3;
          }
          else
          {
            *((void *)this + 51) = v10;
            int v8 = 3;
          }
          goto LABEL_8;
        }
      }
    }
LABEL_32:
    if (v14 <= v12) {
      std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
    }
    int v29 = **(_DWORD **)(v13 + 8 * v12);
    if (v29 < 2)
    {
      if (v29 == 1)
      {
        unint64_t v42 = v8 + 1;
        if (v14 <= v42) {
          std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
        }
        if ((**(_DWORD **)(v13 + 8 * v42) - 2) <= 4)
        {
          CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
          HGColorGamma::HGColorGamma(v10);
          HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
          HGColorGamma::SetPremultiplyState(v10, 0, 0);
          HGColorGamma::Set1DLutScaleAndOffset((HGNode *)v10, *((float *)this + 119), *((float *)this + 120), v43, v44);
          HGColorGamma::SetToneQualityMode((uint64_t)v10, *((unsigned int *)this + 109), v45);
          HGColorGamma::SetFallbackMode((HGNode *)v10, *((unsigned __int8 *)this + 432), v46);
          HGColorGamma::SetInOut422FilterMode((uint64_t)v10, *((unsigned int *)this + 113), v47);
          HGColorGamma::SetInOut422FilterRect((HGRect *)v10, *(HGRect *)((char *)this + 456));
          HGColorGamma::SetFixedPointPrecisionMode((HGNode *)v10, *((unsigned __int8 *)this + 434), v48);
          if (v12 >= (v3[1] - *v3) >> 3) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v86 = *(_OWORD *)(*(void *)(*v3 + 8 * v12) + 16);
          if (v12 >= (v3[1] - *v3) >> 3) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v87 = *(_OWORD *)(*(void *)(*v3 + 8 * v12) + 32);
          if (v12 >= (v3[1] - *v3) >> 3) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v88 = *(_OWORD *)(*(void *)(*v3 + 8 * v12) + 48);
          if (v12 >= (v3[1] - *v3) >> 3) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          long long v89 = *(_OWORD *)(*(void *)(*v3 + 8 * v12) + 64);
          HGColorGamma::LoadMatrix1((uint64_t)v10, (uint64_t)&v86, v49);
          if (v42 >= (v3[1] - *v3) >> 3) {
            std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
          }
          uint64_t v51 = *(void *)(*v3 + 8 * v42);
          if ((*(_DWORD *)v51 - 3) >= 4) {
            uint64_t v52 = 0;
          }
          else {
            uint64_t v52 = (*(_DWORD *)v51 - 2);
          }
          HGColorGamma::SetGammaFunction((uint64_t)v10, v52, v50, *(__n128 *)(v51 + 80), *(float32x4_t *)(v51 + 96), *(float32x4_t *)(v51 + 112), *(float32x4_t *)(v51 + 128), *(int8x16_t *)(v51 + 144), *(float32x4_t *)(v51 + 160), *(float32x4_t *)(v51 + 176));
          if (!v8)
          {
LABEL_87:
            *((void *)this + 51) = v10;
            v8 += 2;
            goto LABEL_8;
          }
          (*(void (**)(HGColorGamma *, void, HGColorGamma *))(*(void *)v10 + 120))(v10, 0, v9);
          (*(void (**)(HGColorGamma *))(*(void *)v9 + 24))(v9);
          goto LABEL_60;
        }
      }
    }
    else if (v29 <= 6)
    {
      unint64_t v30 = v8 + 1;
      if (v14 <= v30) {
        std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
      }
      if (**(_DWORD **)(v13 + 8 * v30) == 1)
      {
        CFDataRef v10 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
        HGColorGamma::HGColorGamma(v10);
        HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v10, *((unsigned char *)this + 474));
        HGColorGamma::SetPremultiplyState(v10, 0, 0);
        HGColorGamma::Set1DLutScaleAndOffset((HGNode *)v10, *((float *)this + 119), *((float *)this + 120), v31, v32);
        HGColorGamma::SetToneQualityMode((uint64_t)v10, *((unsigned int *)this + 109), v33);
        HGColorGamma::SetFallbackMode((HGNode *)v10, *((unsigned __int8 *)this + 432), v34);
        HGColorGamma::SetInOut422FilterMode((uint64_t)v10, *((unsigned int *)this + 113), v35);
        HGColorGamma::SetInOut422FilterRect((HGRect *)v10, *(HGRect *)((char *)this + 456));
        HGColorGamma::SetFixedPointPrecisionMode((HGNode *)v10, *((unsigned __int8 *)this + 434), v36);
        if (v12 >= (v3[1] - *v3) >> 3) {
          std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
        }
        uint64_t v38 = *(void *)(*v3 + 8 * v12);
        if ((*(_DWORD *)v38 - 3) >= 4) {
          uint64_t v39 = 0;
        }
        else {
          uint64_t v39 = (*(_DWORD *)v38 - 2);
        }
        HGColorGamma::SetGammaFunction((uint64_t)v10, v39, v37, *(__n128 *)(v38 + 80), *(float32x4_t *)(v38 + 96), *(float32x4_t *)(v38 + 112), *(float32x4_t *)(v38 + 128), *(int8x16_t *)(v38 + 144), *(float32x4_t *)(v38 + 160), *(float32x4_t *)(v38 + 176));
        if (v30 >= (v3[1] - *v3) >> 3) {
          std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
        }
        long long v86 = *(_OWORD *)(*(void *)(*v3 + 8 * v30) + 16);
        if (v30 >= (v3[1] - *v3) >> 3) {
          std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
        }
        long long v87 = *(_OWORD *)(*(void *)(*v3 + 8 * v30) + 32);
        if (v30 >= (v3[1] - *v3) >> 3) {
          std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
        }
        long long v88 = *(_OWORD *)(*(void *)(*v3 + 8 * v30) + 48);
        if (v30 >= (v3[1] - *v3) >> 3) {
          std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
        }
        long long v89 = *(_OWORD *)(*(void *)(*v3 + 8 * v30) + 64);
        __n128 v41 = HGColorGamma::LoadMatrix2((uint64_t)v10, (uint64_t)&v86, v40);
        if (!v8) {
          goto LABEL_87;
        }
        (*(void (**)(HGColorGamma *, void, HGColorGamma *, __n128))(*(void *)v10 + 120))(v10, 0, v9, v41);
        (*(void (**)(HGColorGamma *))(*(void *)v9 + 24))(v9);
LABEL_60:
        v8 += 2;
        goto LABEL_8;
      }
    }
    goto LABEL_63;
  }
  CFDataRef v10 = 0;
LABEL_108:
  *((void *)this + 52) = v10;
  uint64_t v78 = (const void *)*((void *)this + 51);
  if (v78
  {
    if (!v10) {
      goto LABEL_114;
    }
  }
  else
  {
    float32x4_t v79 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
    HGColorGamma::HGColorGamma(v79);
    HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v79, *((unsigned char *)this + 474));
    (*(void (**)(void, void, HGColorGamma *))(**((void **)this + 51) + 120))(*((void *)this + 51), 0, v79);
    (*(void (**)(HGColorGamma *))(*(void *)v79 + 24))(v79);
    *((void *)this + 51) = v79;
    CFDataRef v10 = (HGColorGamma *)*((void *)this + 52);
    if (!v10)
    {
LABEL_114:
      float32x4_t v81 = (HGColorGamma *)HGObject::operator new(0x4A0uLL);
      HGColorGamma::HGColorGamma(v81);
      HGColorGamma::SetAntiSymmetricToneCurves((uint64_t)v81, *((unsigned char *)this + 474));
      (*(void (**)(HGColorGamma *, void, void))(*(void *)v81 + 120))(v81, 0, *((void *)this + 52));
      (*(void (**)(void))(**((void **)this + 52) + 24))(*((void *)this + 52));
      *((void *)this + 52) = v81;
      goto LABEL_115;
    }
  }
  if (!v81) {
    goto LABEL_114;
  }
LABEL_115:
  HGColorGamma::SetInputPixelFormat((uint64_t)v79, *((unsigned int *)this + 111), v80);
  HGColorGamma::SetOutputPixelFormat((uint64_t)v81, *((unsigned int *)this + 110), (char *)*((unsigned int *)this + 112));
  HGColorGamma::SetDitherMode((HGNode *)v81, *((unsigned __int8 *)this + 433), v82);
  HGColorGamma::SetFixedPointPrecisionMode((HGNode *)v79, *((unsigned __int8 *)this + 434), v83);
  HGColorGamma::SetFixedPointPrecisionMode((HGNode *)v81, *((unsigned __int8 *)this + 434), v84);
  int v85 = *((unsigned __int8 *)this + 472);
  if (*((void *)this + 51) == *((void *)this + 52))
  {
    HGColorGamma::SetPremultiplyState(v79, v85 != 0, *((unsigned char *)this + 473));
  }
  else
  {
    HGColorGamma::SetPremultiplyState(v79, v85 != 0, 0);
    HGColorGamma::SetPremultiplyState(v81, 0, *((unsigned char *)this + 473));
  }
  return 1;
}

void sub_1B7809A20(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7809A34(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7809A48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL HGColorConform::GetNodeListFromCache(HGColorConform *this, const ColorSyncProfile *a2, const ColorSyncProfile *a3, HGColorConformNodeListCacheItem **a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (HGSynchronizable *)HGColorConform::s_NodeListCacheLock;
  HGSynchronizable::Lock((HGSynchronizable *)HGColorConform::s_NodeListCacheLock);
  CFMutableDictionaryRef Mutable = (CFMutableDictionaryRef)HGColorConform::s_NodeListCache;
  if (!HGColorConform::s_NodeListCache)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 50, MEMORY[0x1E4F1D530], 0);
    HGColorConform::s_NodeListCache = (uint64_t)Mutable;
  }
  HGSynchronizable::Unlock(v7);
  if (!Mutable) {
    return 0;
  }
  ColorSyncMD5 MD5 = ColorSyncProfileGetMD5(this);
  ColorSyncMD5 v15 = ColorSyncProfileGetMD5(a2);
  fillBufWithAsciiHexMD5(bytes, MD5.digest);
  fillBufWithAsciiHexMD5(v14, v15.digest);
  CFStringRef v9 = CFStringCreateWithBytes(0, bytes, 64, 0x600u, 0);
  Value = CFDictionaryGetValue((CFDictionaryRef)HGColorConform::s_NodeListCache, v9);
  *(void *)a3 = Value;
  BOOL v11 = Value != 0;
  CFRelease(v9);
  return v11;
}

void sub_1B7809DD8(_Unwind_Exception *a1)
{
  HGSynchronizable::Unlock(v1);
  _Unwind_Resume(a1);
}

void std::vector<HGColorConformNodeListItem *>::push_back[abi:ne180100](void **a1, void *a2)
{
  uint64_t v5 = (char *)a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  int v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    int v8 = (char *)*a1;
    uint64_t v9 = v5 - (unsigned char *)*a1;
    uint64_t v10 = v9 >> 3;
    unint64_t v11 = (v9 >> 3) + 1;
    if (v11 >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v4 - (void)v8;
    if (v12 >> 2 > v11) {
      unint64_t v11 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      if (v13 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v14 = operator new(8 * v13);
    }
    else
    {
      unint64_t v14 = 0;
    }
    ColorSyncMD5 v15 = &v14[8 * v10];
    *ColorSyncMD5 v15 = *a2;
    uint64_t v7 = v15 + 1;
    if (v5 != v8)
    {
      unint64_t v16 = v5 - v8 - 8;
      if (v16 < 0x58) {
        goto LABEL_28;
      }
      if ((unint64_t)(v5 - v14 - v9) < 0x20) {
        goto LABEL_28;
      }
      uint64_t v17 = (v16 >> 3) + 1;
      uint64_t v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
      int v6 = &v5[-v18];
      ColorSyncMD5 v15 = (void *)((char *)v15 - v18);
      uint64_t v19 = &v14[8 * v10 - 16];
      uint64_t v20 = (long long *)(v5 - 16);
      uint64_t v21 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v22 = *v20;
        *(v19 - 1) = *(v20 - 1);
        *uint64_t v19 = v22;
        v19 -= 2;
        v20 -= 2;
        v21 -= 4;
      }
      while (v21);
      if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_28:
        do
        {
          uint64_t v23 = *((void *)v6 - 1);
          v6 -= 8;
          *--ColorSyncMD5 v15 = v23;
        }
        while (v6 != v8);
      }
      int v6 = (char *)*a1;
    }
    *a1 = v15;
    a1[1] = v7;
    a1[2] = &v14[8 * v13];
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *(void *)uint64_t v5 = *a2;
    uint64_t v7 = v5 + 8;
  }
  a1[1] = v7;
}

void std::vector<unsigned char>::push_back[abi:ne180100](void *a1, char *a2)
{
  uint64_t v5 = (char *)a1[1];
  unint64_t v4 = a1[2];
  int v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    int v8 = (char *)*a1;
    unint64_t v9 = (unint64_t)&v5[-*a1];
    unint64_t v10 = v9 + 1;
    if ((uint64_t)(v9 + 1) < 0) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = v4 - (void)v8;
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v12 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v12 = v10;
    }
    if (v12) {
      unint64_t v13 = operator new(v12);
    }
    else {
      unint64_t v13 = 0;
    }
    unint64_t v14 = &v13[v9];
    ColorSyncMD5 v15 = &v13[v12];
    v13[v9] = *a2;
    uint64_t v7 = (uint64_t)&v13[v9 + 1];
    if (v5 == v8)
    {
      *a1 = v14;
      a1[1] = v7;
      a1[2] = v15;
      if (!v5) {
        goto LABEL_32;
      }
      goto LABEL_31;
    }
    if (v9 < 8 || (unint64_t)(v8 - v13) < 0x20) {
      goto LABEL_28;
    }
    if (v9 >= 0x20)
    {
      unint64_t v16 = v9 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v17 = (long long *)(v5 - 16);
      uint64_t v18 = &v13[v5 - 16 - v8];
      unint64_t v19 = v9 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v20 = *v17;
        *(v18 - 1) = *(v17 - 1);
        *uint64_t v18 = v20;
        v18 -= 2;
        v17 -= 2;
        v19 -= 32;
      }
      while (v19);
      if (v9 == v16)
      {
LABEL_30:
        int v6 = (char *)*a1;
        *a1 = v13;
        a1[1] = v7;
        a1[2] = v15;
        if (!v6) {
          goto LABEL_32;
        }
LABEL_31:
        operator delete(v6);
        goto LABEL_32;
      }
      if ((v9 & 0x18) == 0)
      {
        v14 -= v16;
        int v6 = &v5[-v16];
        goto LABEL_28;
      }
    }
    else
    {
      unint64_t v16 = 0;
    }
    int v6 = &v5[-(v9 & 0xFFFFFFFFFFFFFFF8)];
    v14 -= v9 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v21 = &v5[-v16 - 8];
    long long v22 = &v13[v21 - v8];
    unint64_t v23 = v16 - (v9 & 0xFFFFFFFFFFFFFFF8);
    do
    {
      uint64_t v24 = *(void *)v21;
      v21 -= 8;
      *v22-- = v24;
      v23 += 8;
    }
    while (v23);
    if (v9 == (v9 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_30;
    }
LABEL_28:
    uint64_t v25 = v14 - 1;
    do
    {
      char v26 = *--v6;
      *v25-- = v26;
    }
    while (v6 != v8);
    goto LABEL_30;
  }
  *uint64_t v5 = *a2;
  uint64_t v7 = (uint64_t)(v5 + 1);
LABEL_32:
  a1[1] = v7;
}

HGObject *HGColorConform::AddNodeListToCache(const ColorSyncProfile *a1, const ColorSyncProfile *a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v6 = (HGObject *)HGObject::operator new(0x18uLL);
  HGObject::HGObject(v6);
  *(void *)int v6 = &unk_1F10DDC10;
  *((void *)v6 + 2) = a3;
  uint64_t v7 = (HGSynchronizable *)HGColorConform::s_NodeListCacheLock;
  uint64_t v12 = HGColorConform::s_NodeListCacheLock;
  char v13 = 0;
  HGSynchronizable::Lock((HGSynchronizable *)HGColorConform::s_NodeListCacheLock);
  CFMutableDictionaryRef Mutable = (CFMutableDictionaryRef)HGColorConform::s_NodeListCache;
  if (!HGColorConform::s_NodeListCache)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 50, MEMORY[0x1E4F1D530], 0);
    HGColorConform::s_NodeListCache = (uint64_t)Mutable;
  }
  HGSynchronizable::Unlock(v7);
  if (Mutable)
  {
    ColorSyncMD5 MD5 = ColorSyncProfileGetMD5(a1);
    ColorSyncMD5 v15 = ColorSyncProfileGetMD5(a2);
    fillBufWithAsciiHexMD5(&v12, MD5.digest);
    fillBufWithAsciiHexMD5(v14, v15.digest);
    CFStringRef v9 = CFStringCreateWithBytes(0, (const UInt8 *)&v12, 64, 0x600u, 0);
    if (CFDictionaryGetCount((CFDictionaryRef)HGColorConform::s_NodeListCache) == 50)
    {
      Value = CFDictionaryGetValue((CFDictionaryRef)HGColorConform::s_NodeListCache, (const void *)HGColorConform::s_LastAddedCacheKey);
      (*(void (**)(const void *))(*(void *)Value + 24))(Value);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)HGColorConform::s_NodeListCache, (const void *)HGColorConform::s_LastAddedCacheKey);
    }
    CFDictionaryAddValue((CFMutableDictionaryRef)HGColorConform::s_NodeListCache, v9, v6);
    if (HGColorConform::s_LastAddedCacheKey) {
      CFRelease((CFTypeRef)HGColorConform::s_LastAddedCacheKey);
    }
    HGColorConform::s_LastAddedCacheKey = (uint64_t)v9;
  }
  return v6;
}

void sub_1B780A2D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B780A2E8(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void ***HGColorConform::DeleteNodeList(void ***result)
{
  uint64_t v1 = *result;
  if (*result)
  {
    uint64_t v2 = result;
    char v3 = *v1;
    if (*v1 != v1[1])
    {
      unint64_t v4 = 0;
      unsigned int v5 = 1;
      do
      {
        int v6 = (void *)v3[v4];
        if (v6)
        {
          uint64_t v7 = (void *)v6[28];
          if (v7)
          {
            v6[29] = v7;
            operator delete(v7);
          }
          uint64_t v8 = v6[26];
          if (v8) {
            (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
          }
          MEMORY[0x1BA9BFBA0](v6, 0x1030C40C41003B7);
          uint64_t v1 = *v2;
          char v3 = **v2;
        }
        unint64_t v4 = v5++;
      }
      while (v4 < ((unsigned char *)v1[1] - (unsigned char *)v3) >> 3);
    }
    if (v3)
    {
      v1[1] = v3;
      operator delete(v3);
    }
    uint64_t result = (void ***)MEMORY[0x1BA9BFBA0](v1, 0x80C40D6874129);
    HGColorGamma *v2 = 0;
  }
  return result;
}

unsigned char *fillBufWithAsciiHexMD5(unsigned char *result, unsigned __int8 *a2)
{
  unsigned int v2 = *a2;
  unsigned int v3 = v2 & 0xF;
  int v4 = (v2 >> 4) + 55;
  if (v2 < 0xA0) {
    LOBYTE(v4) = (*a2 >> 4) | 0x30;
  }
  *uint64_t result = v4;
  char v5 = v2 & 0xF | 0x30;
  char v6 = v3 + 55;
  if (v3 < 0xA) {
    char v6 = v5;
  }
  result[1] = v6;
  unsigned int v7 = a2[1];
  unsigned int v8 = v7 & 0xF;
  int v9 = (v7 >> 4) + 55;
  if (v7 < 0xA0) {
    LOBYTE(v9) = (a2[1] >> 4) | 0x30;
  }
  result[2] = v9;
  char v10 = v7 & 0xF | 0x30;
  char v11 = v8 + 55;
  if (v8 < 0xA) {
    char v11 = v10;
  }
  result[3] = v11;
  unsigned int v12 = a2[2];
  unsigned int v13 = v12 & 0xF;
  int v14 = (v12 >> 4) + 55;
  if (v12 < 0xA0) {
    LOBYTE(v14) = (a2[2] >> 4) | 0x30;
  }
  result[4] = v14;
  char v15 = v12 & 0xF | 0x30;
  char v16 = v13 + 55;
  if (v13 < 0xA) {
    char v16 = v15;
  }
  result[5] = v16;
  unsigned int v17 = a2[3];
  unsigned int v18 = v17 & 0xF;
  int v19 = (v17 >> 4) + 55;
  if (v17 < 0xA0) {
    LOBYTE(v19) = (a2[3] >> 4) | 0x30;
  }
  result[6] = v19;
  char v20 = v17 & 0xF | 0x30;
  char v21 = v18 + 55;
  if (v18 < 0xA) {
    char v21 = v20;
  }
  result[7] = v21;
  unsigned int v22 = a2[4];
  unsigned int v23 = v22 & 0xF;
  int v24 = (v22 >> 4) + 55;
  if (v22 < 0xA0) {
    LOBYTE(v24) = (a2[4] >> 4) | 0x30;
  }
  result[8] = v24;
  char v25 = v22 & 0xF | 0x30;
  char v26 = v23 + 55;
  if (v23 < 0xA) {
    char v26 = v25;
  }
  result[9] = v26;
  unsigned int v27 = a2[5];
  unsigned int v28 = v27 & 0xF;
  int v29 = (v27 >> 4) + 55;
  if (v27 < 0xA0) {
    LOBYTE(v29) = (a2[5] >> 4) | 0x30;
  }
  result[10] = v29;
  char v30 = v27 & 0xF | 0x30;
  char v31 = v28 + 55;
  if (v28 < 0xA) {
    char v31 = v30;
  }
  result[11] = v31;
  unsigned int v32 = a2[6];
  unsigned int v33 = v32 & 0xF;
  int v34 = (v32 >> 4) + 55;
  if (v32 < 0xA0) {
    LOBYTE(v34) = (a2[6] >> 4) | 0x30;
  }
  result[12] = v34;
  char v35 = v32 & 0xF | 0x30;
  char v36 = v33 + 55;
  if (v33 < 0xA) {
    char v36 = v35;
  }
  result[13] = v36;
  unsigned int v37 = a2[7];
  unsigned int v38 = v37 & 0xF;
  int v39 = (v37 >> 4) + 55;
  if (v37 < 0xA0) {
    LOBYTE(v39) = (a2[7] >> 4) | 0x30;
  }
  result[14] = v39;
  char v40 = v37 & 0xF | 0x30;
  char v41 = v38 + 55;
  if (v38 < 0xA) {
    char v41 = v40;
  }
  result[15] = v41;
  unsigned int v42 = a2[8];
  unsigned int v43 = v42 & 0xF;
  int v44 = (v42 >> 4) + 55;
  if (v42 < 0xA0) {
    LOBYTE(v44) = (a2[8] >> 4) | 0x30;
  }
  result[16] = v44;
  char v45 = v42 & 0xF | 0x30;
  char v46 = v43 + 55;
  if (v43 < 0xA) {
    char v46 = v45;
  }
  result[17] = v46;
  unsigned int v47 = a2[9];
  unsigned int v48 = v47 & 0xF;
  int v49 = (v47 >> 4) + 55;
  if (v47 < 0xA0) {
    LOBYTE(v49) = (a2[9] >> 4) | 0x30;
  }
  result[18] = v49;
  char v50 = v47 & 0xF | 0x30;
  char v51 = v48 + 55;
  if (v48 < 0xA) {
    char v51 = v50;
  }
  result[19] = v51;
  unsigned int v52 = a2[10];
  unsigned int v53 = v52 & 0xF;
  int v54 = (v52 >> 4) + 55;
  if (v52 < 0xA0) {
    LOBYTE(v54) = (a2[10] >> 4) | 0x30;
  }
  result[20] = v54;
  char v55 = v52 & 0xF | 0x30;
  char v56 = v53 + 55;
  if (v53 < 0xA) {
    char v56 = v55;
  }
  result[21] = v56;
  unsigned int v57 = a2[11];
  unsigned int v58 = v57 & 0xF;
  int v59 = (v57 >> 4) + 55;
  if (v57 < 0xA0) {
    LOBYTE(v59) = (a2[11] >> 4) | 0x30;
  }
  result[22] = v59;
  char v60 = v57 & 0xF | 0x30;
  char v61 = v58 + 55;
  if (v58 < 0xA) {
    char v61 = v60;
  }
  result[23] = v61;
  unsigned int v62 = a2[12];
  unsigned int v63 = v62 & 0xF;
  int v64 = (v62 >> 4) + 55;
  if (v62 < 0xA0) {
    LOBYTE(v64) = (a2[12] >> 4) | 0x30;
  }
  result[24] = v64;
  char v65 = v62 & 0xF | 0x30;
  char v66 = v63 + 55;
  if (v63 < 0xA) {
    char v66 = v65;
  }
  result[25] = v66;
  unsigned int v67 = a2[13];
  unsigned int v68 = v67 & 0xF;
  int v69 = (v67 >> 4) + 55;
  if (v67 < 0xA0) {
    LOBYTE(v69) = (a2[13] >> 4) | 0x30;
  }
  result[26] = v69;
  char v70 = v67 & 0xF | 0x30;
  char v71 = v68 + 55;
  if (v68 < 0xA) {
    char v71 = v70;
  }
  result[27] = v71;
  unsigned int v72 = a2[14];
  unsigned int v73 = v72 & 0xF;
  int v74 = (v72 >> 4) + 55;
  if (v72 < 0xA0) {
    LOBYTE(v74) = (a2[14] >> 4) | 0x30;
  }
  result[28] = v74;
  char v75 = v72 & 0xF | 0x30;
  char v76 = v73 + 55;
  if (v73 < 0xA) {
    char v76 = v75;
  }
  result[29] = v76;
  unsigned int v77 = a2[15];
  unsigned int v78 = v77 & 0xF;
  int v79 = (v77 >> 4) + 55;
  if (v77 < 0xA0) {
    LOBYTE(v79) = (a2[15] >> 4) | 0x30;
  }
  result[30] = v79;
  char v80 = v77 & 0xF | 0x30;
  if (v78 >= 0xA) {
    char v80 = v78 + 55;
  }
  result[31] = v80;
  result[32] = 0;
  return result;
}

void HGColorConformNodeListCacheItem::~HGColorConformNodeListCacheItem(void ***this)
{
  *this = (void **)&unk_1F10DDC10;
  HGColorConform::DeleteNodeList(this + 2);

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;
  uint64_t vars8;

  *this = (void **)&unk_1F10DDC10;
  HGColorConform::DeleteNodeList(this + 2);
  HGObject::~HGObject((HGObject *)this);

  HGObject::operator delete(v2);
}

void HGColorConformLook3DLUT::SetBuffer(HGColorConformLook3DLUT *this, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)*((void *)this + 2);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *((void *)this + 2) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

void HGColorConformLook3DLUT::SetChecksum(HGColorConformLook3DLUT *this, unsigned __int8 *a2, uint64_t a3)
{
  CFTypeRef v3 = (unint64_t *)((char *)this + 64);
  int v4 = (unsigned char *)*((void *)this + 8);
  *((void *)this + 9) = v4;
  if (a3)
  {
    uint64_t v8 = 0;
    while (1)
    {
      unint64_t v10 = *((void *)this + 10);
      if ((unint64_t)v4 >= v10) {
        break;
      }
      unsigned char *v4 = a2[v8];
      uint64_t v9 = (uint64_t)(v4 + 1);
LABEL_4:
      *((void *)this + 9) = v9;
      ++v8;
      int v4 = (unsigned char *)v9;
      if (v8 == a3) {
        return;
      }
    }
    unint64_t v11 = *v3;
    unint64_t v12 = (unint64_t)&v4[-*v3];
    unint64_t v13 = v12 + 1;
    if ((uint64_t)(v12 + 1) < 0) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v14 = v10 - v11;
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v15 = v13;
    }
    if (v15)
    {
      char v16 = operator new(v15);
      unsigned int v17 = (char *)v16 + v12;
      *((unsigned char *)v16 + v12) = a2[v8];
      uint64_t v9 = (uint64_t)v16 + v12 + 1;
      if (v4 == (unsigned char *)v11)
      {
LABEL_24:
        *((void *)this + 8) = v17;
        *((void *)this + 9) = v9;
        *((void *)this + 10) = (char *)v16 + v15;
        if (v4) {
          operator delete(v4);
        }
        goto LABEL_4;
      }
    }
    else
    {
      char v16 = 0;
      unsigned int v17 = &v4[-*v3];
      *(unsigned char *)unint64_t v12 = a2[v8];
      uint64_t v9 = v12 + 1;
      if (v4 == (unsigned char *)v11) {
        goto LABEL_24;
      }
    }
    if (v12 < 8
      || (char *)v16 + v12 + v11 - (void)v4 > (char *)v16 + v12 - 1
      || v11 > (unint64_t)(v4 - 1)
      || v11 - (unint64_t)v16 < 0x20)
    {
      unsigned int v18 = v4;
      goto LABEL_21;
    }
    if (v12 >= 0x20)
    {
      unint64_t v21 = v12 & 0xFFFFFFFFFFFFFFE0;
      unsigned int v22 = (char *)v16 + v12 - 16;
      unsigned int v23 = (long long *)(v4 - 16);
      unint64_t v24 = v12 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v25 = *v23;
        *(v22 - 1) = *(v23 - 1);
        *unsigned int v22 = v25;
        v22 -= 2;
        v23 -= 2;
        v24 -= 32;
      }
      while (v24);
      if (v12 == v21) {
        goto LABEL_23;
      }
      if ((v12 & 0x18) == 0)
      {
        v17 -= v21;
        unsigned int v18 = &v4[-v21];
LABEL_21:
        int v19 = v17 - 1;
        do
        {
          char v20 = *--v18;
          *v19-- = v20;
        }
        while (v18 != (unsigned char *)v11);
LABEL_23:
        int v4 = (unsigned char *)*v3;
        unsigned int v17 = (char *)v16;
        goto LABEL_24;
      }
    }
    else
    {
      unint64_t v21 = 0;
    }
    unsigned int v18 = &v4[-(v12 & 0xFFFFFFFFFFFFFFF8)];
    v17 -= v12 & 0xFFFFFFFFFFFFFFF8;
    char v26 = &v4[-v21 - v11 - 8 + (void)v16];
    unsigned int v27 = (uint64_t *)&v4[-v21 - 8];
    unint64_t v28 = v21 - (v12 & 0xFFFFFFFFFFFFFFF8);
    do
    {
      uint64_t v29 = *v27--;
      *v26-- = v29;
      v28 += 8;
    }
    while (v28);
    if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }
}

void HGColorConformLook3DLUT::~HGColorConformLook3DLUT(HGColorConformLook3DLUT *this)
{
  *(void *)this = &unk_1F10DDC48;
  unsigned int v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef v3 = (void *)*((void *)this + 8);
  if (v3)
  {
    *((void *)this + 9) = v3;
    operator delete(v3);
  }

  HGObject::~HGObject(this);
}

{
  const void *v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10DDC48;
  unsigned int v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef v3 = (void *)*((void *)this + 8);
  if (v3)
  {
    *((void *)this + 9) = v3;
    operator delete(v3);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v4);
}

void HGColorConformLUTData::HGColorConformLUTData(HGObject *a1, uint64_t a2, int a3)
{
  HGObject::HGObject(a1);
  *(void *)uint64_t v5 = &unk_1F10DDC80;
  *(void *)(v5 + 16) = a2;
  *(_DWORD *)(v5 + 32) = a3;
  operator new[]();
}

void sub_1B780AC20(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGColorConformLUTData::~HGColorConformLUTData(HGColorConformLUTData *this)
{
  *(void *)this = &unk_1F10DDC80;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    MEMORY[0x1BA9BFB70](v2, 0x1000C8077774924);
  }
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;

  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10DDC80;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    MEMORY[0x1BA9BFB70](v2, 0x1000C8077774924);
  }
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  HGObject::~HGObject(this);

  HGObject::operator delete(v3);
}

void HGColorConformLUTEntryFactory::~HGColorConformLUTEntryFactory(HGColorConformLUTEntryFactory *this)
{
}

void HGColorConformLUTEntryFactory::createLUTEntry()
{
}

void sub_1B780AD84(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0xA1C40987D6AD5);
  _Unwind_Resume(a1);
}

uint64_t HGColorConformLUTInfo::HGColorConformLUTInfo(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int a5, float a6, float a7)
{
  uint64_t v9 = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, a3, a5, a6, a7);
  *(void *)uint64_t v9 = &unk_1F10DDD30;
  *(void *)(v9 + 40) = 0;
  *(void *)(v9 + 56) = 0;
  *(unsigned char *)(v9 + 48) = 1;
  *(void *)(v9 + 64) = 0;
  *(void *)(v9 + 72) = 0;
  unint64_t v10 = *(const void **)a4;
  size_t v11 = *(void *)(a4 + 8) - *(void *)a4;
  if (v11)
  {
    if ((v11 & 0x8000000000000000) != 0) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v12 = (unsigned __int8 *)operator new(v11);
    *(void *)(a1 + 56) = v12;
    *(void *)(a1 + 64) = v12;
    *(void *)(a1 + 72) = &v12[v11];
    memcpy(v12, v10, v11);
    *(void *)(a1 + 64) = &v12[v11];
    BOOL v13 = 1;
    do
    {
      while (v13)
      {
        int v14 = *v12++;
        BOOL v13 = v14 == 0;
        if (!--v11) {
          goto LABEL_7;
        }
      }
      BOOL v13 = 0;
      ++v12;
      --v11;
    }
    while (v11);
LABEL_7:
    *(unsigned char *)(a1 + 48) = v13;
  }
  return a1;
}

void sub_1B780AE98(_Unwind_Exception *exception_object)
{
  int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 64) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void *)(v1 + 40);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  _Unwind_Resume(exception_object);
}

void HGColorConformLUTInfo::~HGColorConformLUTInfo(HGColorConformLUTInfo *this)
{
  *(void *)this = &unk_1F10DDD30;
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 8) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((void *)this + 5);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
}

{
  void *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10DDD30;
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 8) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((void *)this + 5);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void HGColorConformLUTInfo::duplicate(HGColorConformLUTInfo *this)
{
}

void sub_1B780B180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12)
{
  MEMORY[0x1BA9BFBA0](v12, 0x10B1C40693A545BLL);
  _Unwind_Resume(a1);
}

PCICCTransferFunctionLUT *HGColorConformLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (result)
  {
    if (*(unsigned char *)(a1 + 48))
    {
      return 0;
    }
    else
    {
      int v4 = result;
      if (!*((unsigned char *)result + 48)
        && (uint64_t LUTEnd = PCICCTransferFunctionLUT::getLUTEnd((PCICCTransferFunctionLUT *)a1),
            LUTEnd == PCICCTransferFunctionLUT::getLUTEnd(v4))
        && (uint64_t FactoryForSerialization = OZFactoryBase::getFactoryForSerialization(a1),
            FactoryForSerialization == OZFactoryBase::getFactoryForSerialization((uint64_t)v4))
        && (int LUTStorageFormat = HGApplyNDLUTInfo::getLUTStorageFormat((HGApplyNDLUTInfo *)a1),
            LUTStorageFormat == HGApplyNDLUTInfo::getLUTStorageFormat(v4))
        && (uint64_t v8 = *(const void **)(a1 + 56),
            size_t v9 = *(void *)(a1 + 64) - (void)v8,
            unint64_t v10 = (const void *)*((void *)v4 + 7),
            v9 == *((void *)v4 + 8) - (void)v10))
      {
        return (PCICCTransferFunctionLUT *)(memcmp(v8, v10, v9) == 0);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void HGColorConformLUTInfo::colorAtIndex(HGColorConformLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  uint64_t LUTEnd = PCICCTransferFunctionLUT::getLUTEnd(this);
  unint64_t FactoryForSerialization = OZFactoryBase::getFactoryForSerialization((uint64_t)this);
  if (LUTEnd == 3)
  {
    int v22 = *(_DWORD *)(*((void *)this + 5) + 32);
    float v23 = a2 - HGApplyNDLUTInfo::getRangeOffset(this);
    float v24 = (float)(FactoryForSerialization - 1);
    float v25 = fmaxf(fminf(v23 / PCICCTransferFunctionParametric3::getD(this), 1.0), 0.0) * v24;
    float v26 = a3 - HGApplyNDLUTInfo::getRangeOffset(this);
    float v27 = fmaxf(fminf(v26 / PCICCTransferFunctionParametric3::getD(this), 1.0), 0.0) * v24;
    float v28 = a4 - HGApplyNDLUTInfo::getRangeOffset(this);
    signed int v29 = llroundf(v25);
    signed int v30 = llroundf(v27);
    signed int v31 = llroundf(fmaxf(fminf(v28 / PCICCTransferFunctionParametric3::getD(this), 1.0), 0.0) * v24);
    unsigned int v32 = HGFormatUtils::bytesPerPixel(v22);
    unint64_t v34 = FactoryForSerialization * v32;
    unint64_t v35 = v34 * FactoryForSerialization;
    if (v22 == 25 || v22 == 19)
    {
      char v36 = (_WORD *)(*(void *)(*((void *)this + 5) + 24) + v29 * (unint64_t)v32 + v34 * v30 + v35 * v31);
      LOWORD(v33) = *v36;
      *(float *)&unsigned int v37 = (float)v33 / 65535.0;
      *a5 = *(float *)&v37;
      LOWORD(v37) = v36[1];
      *(float *)&unsigned int v38 = (float)v37 / 65535.0;
      *a6 = *(float *)&v38;
      LOWORD(v38) = v36[2];
      float v39 = (float)v38 / 65535.0;
    }
    else
    {
      unsigned int v42 = (float *)(*(void *)(*((void *)this + 5) + 24) + v29 * (unint64_t)v32 + v34 * v30 + v35 * v31);
      *a5 = *v42;
      *a6 = v42[1];
      float v39 = v42[2];
    }
    *a7 = v39;
    *a8 = 1.0;
  }
  else
  {
    if (LUTEnd == 1)
    {
      float v18 = a2 - HGApplyNDLUTInfo::getRangeOffset(this);
      float v19 = fmaxf(fminf(v18 / PCICCTransferFunctionParametric3::getD(this), 1.0), 0.0)
          * (float)(FactoryForSerialization - 1);
      signed int v20 = llroundf(v19);
      if (FactoryForSerialization >= v20)
      {
        uint64_t v40 = *(void *)(*((void *)this + 5) + 24);
        char v41 = (float *)(v40 + 16 * v20);
        *a5 = *v41;
        *a6 = *(float *)(v40 + 16 * v20 + 4);
        *a7 = v41[2];
        *a8 = v41[3];
        return;
      }
      unint64_t v21 = this;
    }
    else
    {
      unint64_t v21 = this;
      float v19 = a2;
    }
    HGApplyNDLUTInfo::colorAtIndex(v21, v19, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t HGColorConformLUTInfo::HGColorConformLUTInfo(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t a4, uint64_t a5, int a6, float a7, float a8)
{
  *(void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a3, a4, a6, a7, a8) = &unk_1F10DDD30;
  uint64_t v11 = *a2;
  *(void *)(a1 + 40) = *a2;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
  }
  *(void *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 48) = 1;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  uint64_t v12 = *(const void **)a5;
  size_t v13 = *(void *)(a5 + 8) - *(void *)a5;
  if (v13)
  {
    if ((v13 & 0x8000000000000000) != 0) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    int v14 = (unsigned __int8 *)operator new(v13);
    *(void *)(a1 + 56) = v14;
    *(void *)(a1 + 64) = v14;
    *(void *)(a1 + 72) = &v14[v13];
    memcpy(v14, v12, v13);
    *(void *)(a1 + 64) = &v14[v13];
    BOOL v15 = 1;
    do
    {
      while (v15)
      {
        int v16 = *v14++;
        BOOL v15 = v16 == 0;
        if (!--v13) {
          goto LABEL_9;
        }
      }
      BOOL v15 = 0;
      ++v14;
      --v13;
    }
    while (v13);
LABEL_9:
    *(unsigned char *)(a1 + 48) = v15;
  }
  return a1;
}

void sub_1B780B720(_Unwind_Exception *exception_object)
{
  int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 64) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void *)(v1 + 40);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  _Unwind_Resume(exception_object);
}

void HGWhiteBalanceRAW::~HGWhiteBalanceRAW(HGNode *this)
{
  HgcWhiteBalanceRAW::~HgcWhiteBalanceRAW(this);

  HGObject::operator delete(v1);
}

uint64_t HGWhiteBalanceRAW::GetDOD(HGWhiteBalanceRAW *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HGWhiteBalanceRAW::GetROI(HGWhiteBalanceRAW *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  return HGRectGrow(v6, v5, v7);
}

uint64_t HGColorMatrix::SetParameter(HGColorMatrix *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = (float *)((char *)this + 16 * a2 + 432);
  if (*v7 == a3
    && *((float *)this + 4 * a2 + 109) == a4
    && *((float *)this + 4 * a2 + 110) == a5
    && *((float *)this + 4 * a2 + 111) == a6)
  {
    return 0;
  }
  *uint64_t v7 = a3;
  *((float *)this + 4 * a2 + 109) = a4;
  *((float *)this + 4 * a2 + 110) = a5;
  *((float *)this + 4 * a2 + 111) = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

HGNode *HGColorMatrix::GetOutput(HGColorMatrix *this, HGRenderer *a2, double a3, double a4, int32x2_t a5)
{
  a5.i32[0] = 925353388;
  if (HGMath::IsEqualWithinTolerance(*((float32x4_t *)this + 27), (float32x4_t)xmmword_1B7E736B0, a5))
  {
    v7.i32[0] = 925353388;
    if (HGMath::IsEqualWithinTolerance(*((float32x4_t *)this + 28), (float32x4_t)xmmword_1B7E736C0, v7))
    {
      v8.i32[0] = 925353388;
      if (HGMath::IsEqualWithinTolerance(*((float32x4_t *)this + 29), (float32x4_t)xmmword_1B7E736D0, v8))
      {
        v9.i32[0] = 925353388;
        if (HGMath::IsEqualWithinTolerance(*((float32x4_t *)this + 30), (float32x4_t)xmmword_1B7E734D0, v9))
        {
          return HGRenderer::GetInput(a2, (HGNode *)this, 0);
        }
      }
    }
  }
  if (HGRenderer::IsMergeable(a2, (HGNode *)this, 0, 0))
  {
    Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
    if (Input)
    {
      uint64_t v12 = Input;
      int v13 = *((_DWORD *)Input + 3);
      if (v13 == -735746938)
      {
LABEL_15:
        float32x4_t v17 = *((float32x4_t *)this + 27);
        float32x4_t v18 = *((float32x4_t *)this + 28);
        float32x4_t v19 = *((float32x4_t *)this + 29);
        float32x4_t v20 = *((float32x4_t *)this + 30);
        float32x4_t v21 = vaddq_f32(vmulq_laneq_f32(v20, *((float32x4_t *)v12 + 28), 3), vaddq_f32(vmulq_laneq_f32(v19, *((float32x4_t *)v12 + 28), 2), vaddq_f32(vmulq_lane_f32(v18, *(float32x2_t *)((char *)v12 + 448), 1), vmulq_n_f32(v17, COERCE_FLOAT(*((_OWORD *)v12 + 28))))));
        *((float32x4_t *)v12 + 27) = vaddq_f32(vmulq_laneq_f32(v20, *((float32x4_t *)v12 + 27), 3), vaddq_f32(vmulq_laneq_f32(v19, *((float32x4_t *)v12 + 27), 2), vaddq_f32(vmulq_lane_f32(v18, *(float32x2_t *)((char *)v12 + 432), 1), vmulq_n_f32(v17, COERCE_FLOAT(*((_OWORD *)v12 + 27))))));
        *((float32x4_t *)v12 + 28) = v21;
        float32x4_t v22 = vaddq_f32(vmulq_laneq_f32(v20, *((float32x4_t *)v12 + 29), 3), vaddq_f32(vmulq_laneq_f32(v19, *((float32x4_t *)v12 + 29), 2), vaddq_f32(vmulq_lane_f32(v18, *(float32x2_t *)((char *)v12 + 464), 1), vmulq_n_f32(v17, COERCE_FLOAT(*((_OWORD *)v12 + 29))))));
        float32x4_t v23 = vaddq_f32(vmulq_laneq_f32(v20, *((float32x4_t *)v12 + 30), 3), vaddq_f32(vmulq_laneq_f32(v19, *((float32x4_t *)v12 + 30), 2), vaddq_f32(vmulq_lane_f32(v18, *(float32x2_t *)((char *)v12 + 480), 1), vmulq_n_f32(v17, COERCE_FLOAT(*((_OWORD *)v12 + 30))))));
        *((float32x4_t *)v12 + 29) = v22;
        *((float32x4_t *)v12 + 30) = v23;
        HGColorMatrix::ParameterizeMatrix((__n128 *)v12, a2);
        return v12;
      }
      if (v13 == -735746939)
      {
        int v14 = (HGNode *)*((void *)this + 51);
        if (!v14)
        {
          BOOL v15 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
          HGColorMatrix::HGColorMatrix(v15);
        }
        *((_OWORD *)v14 + 27) = *((_OWORD *)Input + 27);
        *((_OWORD *)v14 + 28) = *((_OWORD *)Input + 28);
        *((_OWORD *)v14 + 29) = *((_OWORD *)Input + 29);
        *((_OWORD *)v14 + 30) = *((_OWORD *)Input + 30);
        int v16 = HGRenderer::GetInput(a2, Input, 0);
        (*(void (**)(HGNode *, void, HGNode *))(*(void *)v14 + 120))(v14, 0, v16);
        uint64_t v12 = v14;
        goto LABEL_15;
      }
    }
  }
  uint64_t v24 = *((void *)this + 51);
  if (v24) {
    (*(void (**)(uint64_t, void, void))(*(void *)v24 + 120))(v24, 0, 0);
  }
  HGColorMatrix::ParameterizeMatrix((__n128 *)this, a2);
  return (HGNode *)this;
}

void sub_1B780BB44(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

_OWORD *HGColorMatrix::LoadMatrix(_OWORD *result, _OWORD *a2, char a3)
{
  int32x4_t v3 = *(int32x4_t *)a2;
  if (a3)
  {
    int v4 = (const float *)(a2 + 2);
    float32x2x4_t v10 = vld4_f32(v4);
    int32x4_t v5 = *((int32x4_t *)a2 + 1);
    int8x16_t v6 = (int8x16_t)vtrn1q_s32(v3, v5);
    *(void *)&long long v7 = vextq_s8(v6, v6, 8uLL).u64[0];
    v6.i64[1] = (uint64_t)v10.val[0];
    int8x16_t v8 = (int8x16_t)vtrn2q_s32(v3, v5);
    *(void *)&long long v9 = vextq_s8(v8, v8, 8uLL).u64[0];
    v8.i64[1] = (uint64_t)v10.val[1];
    result[27] = v6;
    result[28] = v8;
    *((void *)&v7 + 1) = v10.val[2];
    *((void *)&v9 + 1) = v10.val[3];
    result[29] = v7;
  }
  else
  {
    result[27] = v3;
    result[28] = a2[1];
    result[29] = a2[2];
    long long v9 = a2[3];
  }
  result[30] = v9;
  return result;
}

float32x4_t HGColorMatrix::MultMatrix(float32x4_t *a1, float32x4_t *a2, char a3)
{
  float32x4_t v3 = *a2;
  float32x4_t v4 = a2[1];
  if (a3)
  {
    int8x16_t v5 = (int8x16_t)vtrn2q_s32((int32x4_t)v3, (int32x4_t)v4);
    int8x16_t v6 = (int8x16_t)vtrn1q_s32((int32x4_t)v3, (int32x4_t)v4);
    f32 = a2[2].f32;
    float32x2x4_t v13 = vld4_f32(f32);
    v3.i64[0] = v6.i64[0];
    v3.i64[1] = (uint64_t)v13.val[0];
    v4.i64[0] = v5.i64[0];
    v4.i64[1] = (uint64_t)v13.val[1];
    v8.i64[0] = vextq_s8(v6, v6, 8uLL).u64[0];
    v8.i64[1] = (uint64_t)v13.val[2];
    v9.i64[0] = vextq_s8(v5, v5, 8uLL).u64[0];
    v9.i64[1] = (uint64_t)v13.val[3];
  }
  else
  {
    float32x4_t v8 = a2[2];
    float32x4_t v9 = a2[3];
  }
  float32x4_t v10 = vaddq_f32(vmulq_laneq_f32(v9, a1[28], 3), vaddq_f32(vmulq_laneq_f32(v8, a1[28], 2), vaddq_f32(vmulq_lane_f32(v4, *(float32x2_t *)a1[28].f32, 1), vmulq_n_f32(v3, COERCE_FLOAT(*(_OWORD *)&a1[28])))));
  a1[27] = vaddq_f32(vmulq_laneq_f32(v9, a1[27], 3), vaddq_f32(vmulq_laneq_f32(v8, a1[27], 2), vaddq_f32(vmulq_lane_f32(v4, *(float32x2_t *)a1[27].f32, 1), vmulq_n_f32(v3, COERCE_FLOAT(*(_OWORD *)&a1[27])))));
  a1[28] = v10;
  float32x4_t v11 = vaddq_f32(vmulq_laneq_f32(v9, a1[29], 3), vaddq_f32(vmulq_laneq_f32(v8, a1[29], 2), vaddq_f32(vmulq_lane_f32(v4, *(float32x2_t *)a1[29].f32, 1), vmulq_n_f32(v3, COERCE_FLOAT(*(_OWORD *)&a1[29])))));
  float32x4_t result = vaddq_f32(vmulq_laneq_f32(v9, a1[30], 3), vaddq_f32(vmulq_laneq_f32(v8, a1[30], 2), vaddq_f32(vmulq_lane_f32(v4, *(float32x2_t *)a1[30].f32, 1), vmulq_n_f32(v3, COERCE_FLOAT(*(_OWORD *)&a1[30])))));
  a1[29] = v11;
  a1[30] = result;
  return result;
}

float32x4_t HGColorMatrix::Scale(float32x4_t *this, float a2, float a3, float32_t a4)
{
  __asm { FMOV            V3.4S, #1.0 }
  _Q3.i64[0] = __PAIR64__(LODWORD(a3), LODWORD(a2));
  _Q3.f32[2] = a4;
  float32x4_t v9 = vmulq_f32(_Q3, this[28]);
  this[27] = vmulq_f32(_Q3, this[27]);
  this[28] = v9;
  float32x4_t result = vmulq_f32(_Q3, this[29]);
  this[29] = result;
  return result;
}

float32x4_t HGColorMatrix::Translate(float32x4_t *this, float a2, float a3, float32_t a4)
{
  __asm { FMOV            V3.4S, #1.0 }
  _Q3.i64[0] = __PAIR64__(LODWORD(a3), LODWORD(a2));
  _Q3.f32[2] = a4;
  float32x4_t v9 = vaddq_f32(vmulq_laneq_f32(_Q3, this[28], 3), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B7E736D0, this[28], 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1B7E736C0, *(float32x2_t *)this[28].f32, 1), vmulq_n_f32((float32x4_t)xmmword_1B7E736B0, COERCE_FLOAT(*(_OWORD *)&this[28])))));
  this[27] = vaddq_f32(vmulq_laneq_f32(_Q3, this[27], 3), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B7E736D0, this[27], 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1B7E736C0, *(float32x2_t *)this[27].f32, 1), vmulq_n_f32((float32x4_t)xmmword_1B7E736B0, COERCE_FLOAT(*(_OWORD *)&this[27])))));
  this[28] = v9;
  float32x4_t result = vaddq_f32(vmulq_laneq_f32(_Q3, this[30], 3), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B7E736D0, this[30], 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1B7E736C0, *(float32x2_t *)this[30].f32, 1), vmulq_n_f32((float32x4_t)xmmword_1B7E736B0, COERCE_FLOAT(*(_OWORD *)&this[30])))));
  this[29] = vaddq_f32(vmulq_laneq_f32(_Q3, this[29], 3), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B7E736D0, this[29], 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1B7E736C0, *(float32x2_t *)this[29].f32, 1), vmulq_n_f32((float32x4_t)xmmword_1B7E736B0, COERCE_FLOAT(*(_OWORD *)&this[29])))));
  this[30] = result;
  return result;
}

uint64_t HGColorMatrix::info@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  if (a2 >= 1) {
    return HGLoggerUtils::matrixPrettyString(result + 432, 4, 4, a3, a4);
  }
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  return result;
}

uint64_t c0()
{
  return 0;
}

uint64_t c1(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 8);
    unsigned int v5 = v4 - *(_DWORD *)a1;
    uint64_t v6 = *(void *)(a1 + 80) + 16 * a3;
    long long v7 = *(float32x4_t **)(a1 + 16);
    float32x4_t v8 = *a2;
    uint64_t v9 = (int)(*(_DWORD *)(a1 + 24) - v5);
    uint64_t v10 = (int)(*(_DWORD *)(a1 + 88) - v5);
    if (v5 >= 4)
    {
      do
      {
        for (unsigned int i = v5; i > 3; i -= 4)
        {
          float32x4_t v19 = *(float32x4_t *)(v6 + 32);
          float32x4_t v20 = *(float32x4_t *)(v6 + 48);
          float32x4_t v21 = vmulq_f32(v8, *(float32x4_t *)(v6 + 16));
          *long long v7 = vmulq_f32(v8, *(float32x4_t *)v6);
          v7[1] = v21;
          v7[2] = vmulq_f32(v8, v19);
          v7[3] = vmulq_f32(v8, v20);
          v7 += 4;
          v6 += 64;
        }
        if (i)
        {
          int v22 = 0;
          unint64_t v23 = 0;
          do
          {
            v7[v23 / 0x10] = vmulq_f32(v8, *(float32x4_t *)(v6 + v23));
            v23 += 16;
            ++v22;
          }
          while (i != v22);
          long long v7 = (float32x4_t *)((char *)v7 + v23);
          v6 += v23;
        }
        v7 += v9;
        v6 += 16 * v10;
        --v3;
      }
      while (v3);
    }
    else if (v5)
    {
      uint64_t v11 = 16 * v9;
      uint64_t v12 = 16 * v10;
      int v13 = *(_DWORD *)a1 - v4;
      do
      {
        int v14 = v13;
        do
        {
          float32x4_t v15 = *(float32x4_t *)v6;
          v6 += 16;
          *v7++ = vmulq_f32(v8, v15);
        }
        while (!__CFADD__(v14++, 1));
        long long v7 = (float32x4_t *)((char *)v7 + v11);
        v6 += v12;
        --v3;
      }
      while (v3);
    }
  }
  return 1;
}

uint64_t c2x(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 12);
  int v4 = *(_DWORD *)(a1 + 4);
  int v5 = v3 - v4;
  if (v3 != v4)
  {
    unsigned int v6 = *(_DWORD *)(a1 + 8) - *(_DWORD *)a1;
    uint64_t v7 = *(void *)(a1 + 80);
    float32x4_t v8 = *(float32x4_t **)(a1 + 16);
    float32x4_t v9 = *a2;
    float32x4_t v10 = a2[1];
    uint64_t v11 = (int)(*(_DWORD *)(a1 + 24) - v6);
    uint64_t v12 = (int)(*(_DWORD *)(a1 + 88) - v6);
    if (v6 < 2)
    {
      if (v6)
      {
        uint64_t v24 = (float32x4_t *)(v7 + 16 * a3 + 16);
        int v25 = v4 - v3;
        do
        {
          *float32x4_t v8 = vaddq_f32(vmulq_f32(v9, v24[-1]), vmulq_f32(v10, *v24));
          v8 += v11 + 1;
          v24 += v12 + 1;
        }
        while (!__CFADD__(v25++, 1));
      }
    }
    else
    {
      int v13 = (float32x4_t *)(v7 + 16 * a3);
      uint64_t v14 = 16 * v11 - 32;
      uint64_t v15 = 16 * v12 - 32;
      do
      {
        uint64_t v18 = 0;
        float32x4_t v19 = *v13;
        for (unsigned int i = v6; i > 1; i -= 2)
        {
          float32x4_t v21 = vmulq_f32(v9, v19);
          float32x4_t v22 = v13[v18 + 1];
          float32x4_t v19 = v13[v18 + 2];
          unint64_t v23 = &v8[v18];
          *unint64_t v23 = vaddq_f32(v21, vmulq_f32(v10, v22));
          v23[1] = vaddq_f32(vmulq_f32(v9, v22), vmulq_f32(v10, v19));
          v18 += 2;
        }
        if (i)
        {
          v8[v18] = vaddq_f32(vmulq_f32(v9, v19), vmulq_f32(v10, v13[v18 + 1]));
          uint64_t v16 = 3;
        }
        else
        {
          uint64_t v16 = 2;
        }
        uint64_t v17 = 16 * v16;
        float32x4_t v8 = (float32x4_t *)((char *)v8 + v14 + v17 + v18 * 16);
        int v13 = (float32x4_t *)((char *)v13 + v15 + v17 + v18 * 16);
        --v5;
      }
      while (v5);
    }
  }
  return 2;
}

uint64_t c3x(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 8);
    unsigned int v5 = v4 - *(_DWORD *)a1;
    unsigned int v6 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * a3);
    uint64_t v7 = *(float32x4_t **)(a1 + 16);
    float32x4_t v8 = *a2;
    float32x4_t v9 = a2[1];
    float32x4_t v10 = a2[2];
    uint64_t v11 = (int)(*(_DWORD *)(a1 + 24) - v5);
    uint64_t v12 = (int)(*(_DWORD *)(a1 + 88) - v5);
    if (v5 >= 3)
    {
      do
      {
        float32x4_t v23 = *v6;
        float32x4_t v24 = v6[1];
        for (unsigned int i = v5; i > 2; i -= 3)
        {
          float32x4_t v26 = vmulq_f32(v8, v23);
          float32x4_t v27 = v6[3];
          v6 += 3;
          float32x4_t v23 = v27;
          float32x4_t v28 = v6[-1];
          *uint64_t v7 = vaddq_f32(vmulq_f32(v9, v24), vaddq_f32(v26, vmulq_f32(v10, v28)));
          float32x4_t v29 = vaddq_f32(vmulq_f32(v9, v28), vaddq_f32(vmulq_f32(v8, v24), vmulq_f32(v10, v27)));
          float32x4_t v24 = v6[1];
          v7[1] = v29;
          v7[2] = vaddq_f32(vmulq_f32(v9, v27), vaddq_f32(vmulq_f32(v8, v28), vmulq_f32(v10, v24)));
          v7 += 3;
        }
        if (i)
        {
          int v30 = 0;
          uint64_t v31 = 0;
          do
          {
            float32x4_t v32 = vmulq_f32(v8, v23);
            float32x4_t v33 = vmulq_f32(v9, v24);
            float32x4_t v23 = v24;
            float32x4_t v24 = v6[v31 + 2];
            v7[v31++] = vaddq_f32(v33, vaddq_f32(v32, vmulq_f32(v10, v24)));
            ++v30;
          }
          while (i != v30);
          uint64_t v7 = (float32x4_t *)((char *)v7 + v31 * 16);
          unsigned int v6 = (float32x4_t *)((char *)v6 + v31 * 16);
        }
        v7 += v11;
        v6 += v12;
        --v3;
      }
      while (v3);
    }
    else if (v5)
    {
      uint64_t v13 = 16 * v11;
      uint64_t v14 = 16 * v12;
      int v15 = *(_DWORD *)a1 - v4;
      do
      {
        float32x4_t v16 = *v6;
        float32x4_t v17 = v6[1];
        int v18 = v15;
        do
        {
          float32x4_t v19 = vmulq_f32(v8, v16);
          float32x4_t v20 = vmulq_f32(v9, v17);
          float32x4_t v16 = v17;
          float32x4_t v17 = v6[2];
          *v7++ = vaddq_f32(v20, vaddq_f32(v19, vmulq_f32(v10, v17)));
          ++v6;
        }
        while (!__CFADD__(v18++, 1));
        uint64_t v7 = (float32x4_t *)((char *)v7 + v13);
        unsigned int v6 = (float32x4_t *)((char *)v6 + v14);
        --v3;
      }
      while (v3);
    }
  }
  return 3;
}

uint64_t c4x(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 8);
    unsigned int v5 = v4 - *(_DWORD *)a1;
    unsigned int v6 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * a3);
    uint64_t v7 = *(float32x4_t **)(a1 + 16);
    float32x4_t v8 = *a2;
    float32x4_t v9 = a2[1];
    float32x4_t v10 = a2[2];
    float32x4_t v11 = a2[3];
    uint64_t v12 = (int)(*(_DWORD *)(a1 + 24) - v5);
    uint64_t v13 = (int)(*(_DWORD *)(a1 + 88) - v5);
    if (v5 >= 4)
    {
      do
      {
        float32x4_t v25 = *v6;
        float32x4_t v26 = v6[1];
        unsigned int v27 = v5;
        float32x4_t v28 = v6[2];
        do
        {
          float32x4_t v29 = vmulq_f32(v8, v25);
          float32x4_t v30 = v6[4];
          v6 += 4;
          float32x4_t v25 = v30;
          float32x4_t v31 = v6[-1];
          *uint64_t v7 = vaddq_f32(vaddq_f32(v29, vmulq_f32(v10, v28)), vaddq_f32(vmulq_f32(v9, v26), vmulq_f32(v11, v31)));
          float32x4_t v32 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v26), vmulq_f32(v10, v31)), vaddq_f32(vmulq_f32(v9, v28), vmulq_f32(v11, v30)));
          float32x4_t v26 = v6[1];
          v7[1] = v32;
          float32x4_t v33 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v28), vmulq_f32(v10, v30)), vaddq_f32(vmulq_f32(v9, v31), vmulq_f32(v11, v26)));
          float32x4_t v28 = v6[2];
          v7[2] = v33;
          v7[3] = vaddq_f32(vaddq_f32(vmulq_f32(v8, v31), vmulq_f32(v10, v26)), vaddq_f32(vmulq_f32(v9, v30), vmulq_f32(v11, v28)));
          v7 += 4;
          v27 -= 4;
        }
        while (v27 > 3);
        if (v27)
        {
          int v34 = 0;
          uint64_t v35 = 0;
          do
          {
            float32x4_t v36 = vmulq_f32(v8, v25);
            float32x4_t v37 = vmulq_f32(v9, v26);
            float32x4_t v25 = v26;
            float32x4_t v26 = v28;
            float32x4_t v28 = v6[v35 + 3];
            v7[v35++] = vaddq_f32(vaddq_f32(v36, vmulq_f32(v10, v26)), vaddq_f32(v37, vmulq_f32(v11, v28)));
            ++v34;
          }
          while (v27 != v34);
          uint64_t v7 = (float32x4_t *)((char *)v7 + v35 * 16);
          unsigned int v6 = (float32x4_t *)((char *)v6 + v35 * 16);
        }
        v7 += v12;
        v6 += v13;
        --v3;
      }
      while (v3);
    }
    else if (v5)
    {
      uint64_t v14 = 16 * v12;
      uint64_t v15 = 16 * v13;
      int v16 = *(_DWORD *)a1 - v4;
      do
      {
        float32x4_t v17 = *v6;
        float32x4_t v18 = v6[1];
        int v19 = v16;
        float32x4_t v20 = v6[2];
        do
        {
          float32x4_t v21 = vmulq_f32(v8, v17);
          float32x4_t v22 = vmulq_f32(v9, v18);
          float32x4_t v17 = v18;
          float32x4_t v18 = v20;
          float32x4_t v20 = v6[3];
          *v7++ = vaddq_f32(vaddq_f32(v21, vmulq_f32(v10, v18)), vaddq_f32(v22, vmulq_f32(v11, v20)));
          ++v6;
        }
        while (!__CFADD__(v19++, 1));
        uint64_t v7 = (float32x4_t *)((char *)v7 + v14);
        unsigned int v6 = (float32x4_t *)((char *)v6 + v15);
        --v3;
      }
      while (v3);
    }
  }
  return 4;
}

uint64_t c5x(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 8);
    unsigned int v5 = v4 - *(_DWORD *)a1;
    unsigned int v6 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * a3);
    uint64_t v7 = *(float32x4_t **)(a1 + 16);
    float32x4_t v8 = *a2;
    float32x4_t v9 = a2[1];
    float32x4_t v10 = a2[2];
    uint64_t v11 = (int)(*(_DWORD *)(a1 + 24) - v5);
    uint64_t v12 = (int)(*(_DWORD *)(a1 + 88) - v5);
    if (v5 >= 3)
    {
      do
      {
        float32x4_t v36 = *v6;
        float32x4_t v37 = v6[1];
        for (unsigned int i = v5; i > 2; i -= 3)
        {
          float32x4_t v39 = vmulq_f32(v8, v36);
          float32x4_t v40 = v6[3];
          v6 += 3;
          float32x4_t v36 = v40;
          float32x4_t v41 = v6[-1];
          *uint64_t v7 = vaddq_f32(vmulq_f32(v9, v37), vaddq_f32(v39, vmulq_f32(v10, v41)));
          float32x4_t v42 = vaddq_f32(vmulq_f32(v9, v41), vaddq_f32(vmulq_f32(v8, v37), vmulq_f32(v10, v40)));
          float32x4_t v37 = v6[1];
          v7[1] = v42;
          v7[2] = vaddq_f32(vmulq_f32(v9, v40), vaddq_f32(vmulq_f32(v8, v41), vmulq_f32(v10, v37)));
          v7 += 3;
        }
        if (i)
        {
          int v43 = 0;
          uint64_t v44 = 0;
          do
          {
            float32x4_t v45 = vmulq_f32(v8, v36);
            float32x4_t v46 = vmulq_f32(v9, v37);
            float32x4_t v36 = v37;
            float32x4_t v37 = v6[v44 + 2];
            v7[v44++] = vaddq_f32(v46, vaddq_f32(v45, vmulq_f32(v10, v37)));
            ++v43;
          }
          while (i != v43);
          uint64_t v7 = (float32x4_t *)((char *)v7 + v44 * 16);
          unsigned int v6 = (float32x4_t *)((char *)v6 + v44 * 16);
        }
        v7 += v11;
        v6 += v12;
        --v3;
      }
      while (v3);
    }
    else if (v5)
    {
      uint64_t v13 = 16 * v11;
      uint64_t v14 = 16 * v12;
      int v15 = *(_DWORD *)a1 - v4;
      do
      {
        float32x4_t v16 = *v6;
        float32x4_t v17 = v6[1];
        int v18 = v15;
        do
        {
          float32x4_t v19 = vmulq_f32(v8, v16);
          float32x4_t v20 = vmulq_f32(v9, v17);
          float32x4_t v16 = v17;
          float32x4_t v17 = v6[2];
          *v7++ = vaddq_f32(v20, vaddq_f32(v19, vmulq_f32(v10, v17)));
          ++v6;
          BOOL v21 = __CFADD__(v18++, 1);
        }
        while (!v21);
        uint64_t v7 = (float32x4_t *)((char *)v7 + v13);
        unsigned int v6 = (float32x4_t *)((char *)v6 + v14);
        --v3;
      }
      while (v3);
    }
  }
  uint64_t v22 = a3 + 3;
  int v23 = *(_DWORD *)(a1 + 12);
  int v24 = *(_DWORD *)(a1 + 4);
  unsigned int v25 = *(_DWORD *)(a1 + 8) - *(_DWORD *)a1;
  uint64_t v26 = *(void *)(a1 + 80);
  unsigned int v27 = *(float32x4_t **)(a1 + 16);
  float32x4_t v28 = a2[3];
  float32x4_t v29 = a2[4];
  uint64_t v30 = (int)(*(_DWORD *)(a1 + 24) - v25);
  uint64_t v31 = (int)(*(_DWORD *)(a1 + 88) - v25);
  if (v25 < 2)
  {
    if (v25)
    {
      int v56 = v24 - v23;
      unsigned int v57 = (float32x4_t *)(v26 + 16 * v22 + 16);
      do
      {
        *unsigned int v27 = vaddq_f32(vmulq_f32(v29, *v57), vaddq_f32(vmulq_f32(v28, v57[-1]), *v27));
        v57 += v31 + 1;
        v27 += v30 + 1;
        BOOL v21 = __CFADD__(v56++, 1);
      }
      while (!v21);
    }
  }
  else
  {
    int v32 = v23 - v24;
    float32x4_t v33 = (float32x4_t *)(v26 + 16 * v22);
    uint64_t v34 = 16 * v30 - 32;
    uint64_t v35 = 16 * v31 - 32;
    do
    {
      uint64_t v49 = 0;
      float32x4_t v50 = *v33;
      for (unsigned int j = v25; j > 1; j -= 2)
      {
        unsigned int v52 = &v27[v49];
        float32x4_t v53 = vaddq_f32(vmulq_f32(v28, v50), v27[v49]);
        float32x4_t v54 = v33[v49 + 1];
        float32x4_t v50 = v33[v49 + 2];
        float32x4_t v55 = vaddq_f32(vmulq_f32(v29, v50), vaddq_f32(vmulq_f32(v28, v54), v27[v49 + 1]));
        *unsigned int v52 = vaddq_f32(vmulq_f32(v29, v54), v53);
        v52[1] = v55;
        v49 += 2;
      }
      if (j)
      {
        v27[v49] = vaddq_f32(vmulq_f32(v29, v33[v49 + 1]), vaddq_f32(vmulq_f32(v28, v50), v27[v49]));
        uint64_t v47 = 3;
      }
      else
      {
        uint64_t v47 = 2;
      }
      uint64_t v48 = 16 * v47;
      unsigned int v27 = (float32x4_t *)((char *)v27 + v34 + v48 + v49 * 16);
      float32x4_t v33 = (float32x4_t *)((char *)v33 + v35 + v48 + v49 * 16);
      --v32;
    }
    while (v32);
  }
  return 5;
}

uint64_t c6x(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 8);
    unsigned int v5 = v4 - *(_DWORD *)a1;
    unsigned int v6 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * a3);
    uint64_t v7 = *(float32x4_t **)(a1 + 16);
    float32x4_t v8 = *a2;
    float32x4_t v9 = a2[1];
    float32x4_t v10 = a2[2];
    uint64_t v11 = (int)(*(_DWORD *)(a1 + 24) - v5);
    uint64_t v12 = (int)(*(_DWORD *)(a1 + 88) - v5);
    if (v5 >= 3)
    {
      do
      {
        float32x4_t v54 = *v6;
        float32x4_t v55 = v6[1];
        for (unsigned int i = v5; i > 2; i -= 3)
        {
          float32x4_t v57 = vmulq_f32(v8, v54);
          float32x4_t v58 = v6[3];
          v6 += 3;
          float32x4_t v54 = v58;
          float32x4_t v59 = v6[-1];
          *uint64_t v7 = vaddq_f32(vmulq_f32(v9, v55), vaddq_f32(v57, vmulq_f32(v10, v59)));
          float32x4_t v60 = vaddq_f32(vmulq_f32(v9, v59), vaddq_f32(vmulq_f32(v8, v55), vmulq_f32(v10, v58)));
          float32x4_t v55 = v6[1];
          v7[1] = v60;
          v7[2] = vaddq_f32(vmulq_f32(v9, v58), vaddq_f32(vmulq_f32(v8, v59), vmulq_f32(v10, v55)));
          v7 += 3;
        }
        if (i)
        {
          int v61 = 0;
          uint64_t v62 = 0;
          do
          {
            float32x4_t v63 = vmulq_f32(v8, v54);
            float32x4_t v64 = vmulq_f32(v9, v55);
            float32x4_t v54 = v55;
            float32x4_t v55 = v6[v62 + 2];
            v7[v62++] = vaddq_f32(v64, vaddq_f32(v63, vmulq_f32(v10, v55)));
            ++v61;
          }
          while (i != v61);
          uint64_t v7 = (float32x4_t *)((char *)v7 + v62 * 16);
          unsigned int v6 = (float32x4_t *)((char *)v6 + v62 * 16);
        }
        v7 += v11;
        v6 += v12;
        --v3;
      }
      while (v3);
    }
    else if (v5)
    {
      uint64_t v13 = 16 * v11;
      uint64_t v14 = 16 * v12;
      int v15 = *(_DWORD *)a1 - v4;
      do
      {
        float32x4_t v16 = *v6;
        float32x4_t v17 = v6[1];
        int v18 = v15;
        do
        {
          float32x4_t v19 = vmulq_f32(v8, v16);
          float32x4_t v20 = vmulq_f32(v9, v17);
          float32x4_t v16 = v17;
          float32x4_t v17 = v6[2];
          *v7++ = vaddq_f32(v20, vaddq_f32(v19, vmulq_f32(v10, v17)));
          ++v6;
          BOOL v21 = __CFADD__(v18++, 1);
        }
        while (!v21);
        uint64_t v7 = (float32x4_t *)((char *)v7 + v13);
        unsigned int v6 = (float32x4_t *)((char *)v6 + v14);
        --v3;
      }
      while (v3);
    }
  }
  int v22 = *(_DWORD *)(a1 + 8);
  unsigned int v23 = v22 - *(_DWORD *)a1;
  int v24 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  unsigned int v25 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * a3 + 48);
  uint64_t v26 = *(float32x4_t **)(a1 + 16);
  float32x4_t v27 = a2[3];
  float32x4_t v28 = a2[4];
  float32x4_t v29 = a2[5];
  uint64_t v30 = (int)(*(_DWORD *)(a1 + 24) - v23);
  uint64_t v31 = (int)(*(_DWORD *)(a1 + 88) - v23);
  if (v23 >= 3)
  {
    do
    {
      float32x4_t v42 = *v25;
      float32x4_t v41 = v25[1];
      for (unsigned int j = v23; j > 2; j -= 3)
      {
        float32x4_t v44 = vmulq_f32(v27, v42);
        float32x4_t v45 = v25[3];
        v25 += 3;
        float32x4_t v42 = v45;
        float32x4_t v46 = v25[-1];
        float32x4_t v47 = v26[1];
        *uint64_t v26 = vaddq_f32(vaddq_f32(vmulq_f32(v28, v41), *v26), vaddq_f32(v44, vmulq_f32(v29, v46)));
        float32x4_t v48 = vaddq_f32(vaddq_f32(vmulq_f32(v27, v41), vmulq_f32(v29, v45)), vaddq_f32(vmulq_f32(v28, v46), v47));
        float32x4_t v41 = v25[1];
        float32x4_t v49 = vaddq_f32(vaddq_f32(vmulq_f32(v27, v46), vmulq_f32(v29, v41)), vaddq_f32(vmulq_f32(v28, v45), v26[2]));
        v26[1] = v48;
        v26[2] = v49;
        v26 += 3;
      }
      if (j)
      {
        int v50 = 0;
        uint64_t v51 = 0;
        do
        {
          float32x4_t v52 = vmulq_f32(v27, v42);
          float32x4_t v53 = vmulq_f32(v28, v41);
          float32x4_t v42 = v41;
          float32x4_t v41 = v25[v51 + 2];
          v26[v51] = vaddq_f32(vaddq_f32(v53, v26[v51]), vaddq_f32(v52, vmulq_f32(v29, v41)));
          ++v51;
          ++v50;
        }
        while (j != v50);
        uint64_t v26 = (float32x4_t *)((char *)v26 + v51 * 16);
        unsigned int v25 = (float32x4_t *)((char *)v25 + v51 * 16);
      }
      v26 += v30;
      v25 += v31;
      --v24;
    }
    while (v24);
  }
  else if (v23)
  {
    uint64_t v32 = 16 * v30;
    uint64_t v33 = 16 * v31;
    int v34 = *(_DWORD *)a1 - v22;
    do
    {
      float32x4_t v35 = *v25;
      float32x4_t v36 = v25[1];
      int v37 = v34;
      do
      {
        float32x4_t v38 = vmulq_f32(v27, v35);
        float32x4_t v39 = vmulq_f32(v28, v36);
        float32x4_t v35 = v36;
        float32x4_t v36 = v25[2];
        *uint64_t v26 = vaddq_f32(vaddq_f32(v39, *v26), vaddq_f32(v38, vmulq_f32(v29, v36)));
        ++v26;
        ++v25;
        BOOL v21 = __CFADD__(v37++, 1);
      }
      while (!v21);
      uint64_t v26 = (float32x4_t *)((char *)v26 + v32);
      unsigned int v25 = (float32x4_t *)((char *)v25 + v33);
      --v24;
    }
    while (v24);
  }
  return 6;
}

uint64_t c7x(uint64_t a1, float32x4_t *a2, int a3)
{
  c4x(a1, a2, a3);
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = v6 - *(_DWORD *)a1;
  int v8 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  float32x4_t v9 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * (a3 + 4));
  float32x4_t v10 = *(float32x4_t **)(a1 + 16);
  float32x4_t v11 = a2[4];
  float32x4_t v12 = a2[5];
  float32x4_t v13 = a2[6];
  uint64_t v14 = (int)(*(_DWORD *)(a1 + 24) - v7);
  uint64_t v15 = (int)(*(_DWORD *)(a1 + 88) - v7);
  if (v7 >= 3)
  {
    do
    {
      float32x4_t v27 = *v9;
      float32x4_t v26 = v9[1];
      for (unsigned int i = v7; i > 2; i -= 3)
      {
        float32x4_t v29 = vmulq_f32(v11, v27);
        float32x4_t v30 = v9[3];
        v9 += 3;
        float32x4_t v27 = v30;
        float32x4_t v31 = v9[-1];
        float32x4_t v32 = v10[1];
        *float32x4_t v10 = vaddq_f32(vaddq_f32(vmulq_f32(v12, v26), *v10), vaddq_f32(v29, vmulq_f32(v13, v31)));
        float32x4_t v33 = vaddq_f32(vaddq_f32(vmulq_f32(v11, v26), vmulq_f32(v13, v30)), vaddq_f32(vmulq_f32(v12, v31), v32));
        float32x4_t v26 = v9[1];
        float32x4_t v34 = vaddq_f32(vaddq_f32(vmulq_f32(v11, v31), vmulq_f32(v13, v26)), vaddq_f32(vmulq_f32(v12, v30), v10[2]));
        v10[1] = v33;
        v10[2] = v34;
        v10 += 3;
      }
      if (i)
      {
        int v35 = 0;
        uint64_t v36 = 0;
        do
        {
          float32x4_t v37 = vmulq_f32(v11, v27);
          float32x4_t v38 = vmulq_f32(v12, v26);
          float32x4_t v27 = v26;
          float32x4_t v26 = v9[v36 + 2];
          v10[v36] = vaddq_f32(vaddq_f32(v38, v10[v36]), vaddq_f32(v37, vmulq_f32(v13, v26)));
          ++v36;
          ++v35;
        }
        while (i != v35);
        float32x4_t v10 = (float32x4_t *)((char *)v10 + v36 * 16);
        float32x4_t v9 = (float32x4_t *)((char *)v9 + v36 * 16);
      }
      v10 += v14;
      v9 += v15;
      --v8;
    }
    while (v8);
  }
  else if (v7)
  {
    uint64_t v16 = 16 * v14;
    uint64_t v17 = 16 * v15;
    int v18 = *(_DWORD *)a1 - v6;
    do
    {
      float32x4_t v19 = *v9;
      float32x4_t v20 = v9[1];
      int v21 = v18;
      do
      {
        float32x4_t v22 = vmulq_f32(v11, v19);
        float32x4_t v23 = vmulq_f32(v12, v20);
        float32x4_t v19 = v20;
        float32x4_t v20 = v9[2];
        *float32x4_t v10 = vaddq_f32(vaddq_f32(v23, *v10), vaddq_f32(v22, vmulq_f32(v13, v20)));
        ++v10;
        ++v9;
      }
      while (!__CFADD__(v21++, 1));
      float32x4_t v10 = (float32x4_t *)((char *)v10 + v16);
      float32x4_t v9 = (float32x4_t *)((char *)v9 + v17);
      --v8;
    }
    while (v8);
  }
  return 7;
}

uint64_t cadd1(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 8);
  unint64_t v4 = (v3 - *(_DWORD *)a1);
  int v5 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  uint64_t v6 = *(void *)(a1 + 80) + 16 * a3;
  uint64_t v7 = *(int *)(a1 + 88);
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(int *)(a1 + 24);
  float32x4_t v10 = *a2;
  if (v4 < 4)
  {
    if (v3 != *(_DWORD *)a1)
    {
      do
      {
        uint64_t v20 = 0;
        do
        {
          *(float32x4_t *)(v8 + 16 * v20) = vaddq_f32(vmulq_f32(v10, *(float32x4_t *)(v6 + 16 * v20)), *(float32x4_t *)(v8 + 16 * v20));
          ++v20;
        }
        while (v4 != v20);
        v6 += 16 * v7;
        v8 += 16 * v9;
        --v5;
      }
      while (v5);
    }
  }
  else
  {
    uint64_t v11 = 16 * v9;
    uint64_t v12 = 16 * v7;
    do
    {
      int v13 = 0;
      uint64_t v14 = 32;
      do
      {
        uint64_t v15 = (float32x4_t *)(v8 + v14);
        float32x4_t v16 = vaddq_f32(vmulq_f32(v10, *(float32x4_t *)(v6 + v14 - 16)), *(float32x4_t *)(v8 + v14 - 16));
        float32x4_t v17 = vaddq_f32(vmulq_f32(v10, *(float32x4_t *)(v6 + v14)), *(float32x4_t *)(v8 + v14));
        float32x4_t v18 = vaddq_f32(vmulq_f32(v10, *(float32x4_t *)(v6 + v14 + 16)), *(float32x4_t *)(v8 + v14 + 16));
        v15[-2] = vaddq_f32(vmulq_f32(v10, *(float32x4_t *)(v6 + v14 - 32)), *(float32x4_t *)(v8 + v14 - 32));
        v15[-1] = v16;
        *uint64_t v15 = v17;
        v15[1] = v18;
        v13 -= 4;
        v14 += 64;
      }
      while ((v4 + v13) > 3);
      unint64_t v19 = -v13;
      if (v4 > v19)
      {
        do
        {
          *(float32x4_t *)(v8 + 16 * v19) = vaddq_f32(vmulq_f32(v10, *(float32x4_t *)(v6 + 16 * v19)), *(float32x4_t *)(v8 + 16 * v19));
          ++v19;
        }
        while (v19 < v4);
      }
      v8 += v11;
      v6 += v12;
      --v5;
    }
    while (v5);
  }
  return 1;
}

uint64_t cadd2x(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 12);
  int v4 = *(_DWORD *)(a1 + 4);
  unsigned int v5 = *(_DWORD *)(a1 + 8) - *(_DWORD *)a1;
  uint64_t v6 = *(void *)(a1 + 80);
  uint64_t v7 = *(float32x4_t **)(a1 + 16);
  float32x4_t v8 = *a2;
  float32x4_t v9 = a2[1];
  uint64_t v10 = (int)(*(_DWORD *)(a1 + 24) - v5);
  uint64_t v11 = (int)(*(_DWORD *)(a1 + 88) - v5);
  if (v5 < 2)
  {
    if (v5)
    {
      int v25 = v4 - v3;
      float32x4_t v26 = (float32x4_t *)(v6 + 16 * a3 + 16);
      do
      {
        *uint64_t v7 = vaddq_f32(vmulq_f32(v9, *v26), vaddq_f32(vmulq_f32(v8, v26[-1]), *v7));
        v26 += v11 + 1;
        v7 += v10 + 1;
      }
      while (!__CFADD__(v25++, 1));
    }
  }
  else
  {
    int v12 = v3 - v4;
    int v13 = (float32x4_t *)(v6 + 16 * a3);
    uint64_t v14 = 16 * v10 - 32;
    uint64_t v15 = 16 * v11 - 32;
    do
    {
      uint64_t v18 = 0;
      float32x4_t v19 = *v13;
      for (unsigned int i = v5; i > 1; i -= 2)
      {
        int v21 = &v7[v18];
        float32x4_t v22 = vaddq_f32(vmulq_f32(v8, v19), v7[v18]);
        float32x4_t v23 = v13[v18 + 1];
        float32x4_t v19 = v13[v18 + 2];
        float32x4_t v24 = vaddq_f32(vmulq_f32(v9, v19), vaddq_f32(vmulq_f32(v8, v23), v7[v18 + 1]));
        *int v21 = vaddq_f32(vmulq_f32(v9, v23), v22);
        v21[1] = v24;
        v18 += 2;
      }
      if (i)
      {
        v7[v18] = vaddq_f32(vmulq_f32(v9, v13[v18 + 1]), vaddq_f32(vmulq_f32(v8, v19), v7[v18]));
        uint64_t v16 = 3;
      }
      else
      {
        uint64_t v16 = 2;
      }
      uint64_t v17 = 16 * v16;
      uint64_t v7 = (float32x4_t *)((char *)v7 + v14 + v17 + v18 * 16);
      int v13 = (float32x4_t *)((char *)v13 + v15 + v17 + v18 * 16);
      --v12;
    }
    while (v12);
  }
  return 2;
}

uint64_t cadd3x(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 8);
  unsigned int v4 = v3 - *(_DWORD *)a1;
  int v5 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  uint64_t v6 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * a3);
  uint64_t v7 = *(float32x4_t **)(a1 + 16);
  float32x4_t v8 = *a2;
  float32x4_t v9 = a2[1];
  float32x4_t v10 = a2[2];
  uint64_t v11 = (int)(*(_DWORD *)(a1 + 24) - v4);
  uint64_t v12 = (int)(*(_DWORD *)(a1 + 88) - v4);
  if (v4 >= 3)
  {
    do
    {
      float32x4_t v24 = *v6;
      float32x4_t v23 = v6[1];
      for (unsigned int i = v4; i > 2; i -= 3)
      {
        float32x4_t v26 = vmulq_f32(v8, v24);
        float32x4_t v27 = v6[3];
        v6 += 3;
        float32x4_t v24 = v27;
        float32x4_t v28 = v6[-1];
        float32x4_t v29 = v7[1];
        *uint64_t v7 = vaddq_f32(vaddq_f32(vmulq_f32(v9, v23), *v7), vaddq_f32(v26, vmulq_f32(v10, v28)));
        float32x4_t v30 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v23), vmulq_f32(v10, v27)), vaddq_f32(vmulq_f32(v9, v28), v29));
        float32x4_t v23 = v6[1];
        float32x4_t v31 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v28), vmulq_f32(v10, v23)), vaddq_f32(vmulq_f32(v9, v27), v7[2]));
        v7[1] = v30;
        v7[2] = v31;
        v7 += 3;
      }
      if (i)
      {
        int v32 = 0;
        uint64_t v33 = 0;
        do
        {
          float32x4_t v34 = vmulq_f32(v8, v24);
          float32x4_t v35 = vmulq_f32(v9, v23);
          float32x4_t v24 = v23;
          float32x4_t v23 = v6[v33 + 2];
          v7[v33] = vaddq_f32(vaddq_f32(v35, v7[v33]), vaddq_f32(v34, vmulq_f32(v10, v23)));
          ++v33;
          ++v32;
        }
        while (i != v32);
        uint64_t v7 = (float32x4_t *)((char *)v7 + v33 * 16);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v33 * 16);
      }
      v7 += v11;
      v6 += v12;
      --v5;
    }
    while (v5);
  }
  else if (v4)
  {
    uint64_t v13 = 16 * v11;
    uint64_t v14 = 16 * v12;
    int v15 = *(_DWORD *)a1 - v3;
    do
    {
      float32x4_t v16 = *v6;
      float32x4_t v17 = v6[1];
      int v18 = v15;
      do
      {
        float32x4_t v19 = vmulq_f32(v8, v16);
        float32x4_t v20 = vmulq_f32(v9, v17);
        float32x4_t v16 = v17;
        float32x4_t v17 = v6[2];
        *uint64_t v7 = vaddq_f32(vaddq_f32(v20, *v7), vaddq_f32(v19, vmulq_f32(v10, v17)));
        ++v7;
        ++v6;
      }
      while (!__CFADD__(v18++, 1));
      uint64_t v7 = (float32x4_t *)((char *)v7 + v13);
      uint64_t v6 = (float32x4_t *)((char *)v6 + v14);
      --v5;
    }
    while (v5);
  }
  return 3;
}

uint64_t cadd4x(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 8);
  unsigned int v4 = v3 - *(_DWORD *)a1;
  int v5 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  uint64_t v6 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * a3);
  uint64_t v7 = *(float32x4_t **)(a1 + 16);
  float32x4_t v8 = *a2;
  float32x4_t v9 = a2[1];
  float32x4_t v10 = a2[2];
  float32x4_t v11 = a2[3];
  uint64_t v12 = (int)(*(_DWORD *)(a1 + 24) - v4);
  uint64_t v13 = (int)(*(_DWORD *)(a1 + 88) - v4);
  if (v4 >= 4)
  {
    do
    {
      float32x4_t v26 = *v6;
      float32x4_t v25 = v6[1];
      unsigned int v27 = v4;
      float32x4_t v28 = v6[2];
      do
      {
        float32x4_t v29 = vmulq_f32(v8, v26);
        float32x4_t v30 = v6[4];
        v6 += 4;
        float32x4_t v26 = v30;
        float32x4_t v31 = v6[-1];
        float32x4_t v32 = v7[1];
        *uint64_t v7 = vaddq_f32(vaddq_f32(v29, vmulq_f32(v10, v28)), vaddq_f32(vmulq_f32(v11, v31), vaddq_f32(vmulq_f32(v9, v25), *v7)));
        float32x4_t v33 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v25), vmulq_f32(v10, v31)), vaddq_f32(vmulq_f32(v11, v30), vaddq_f32(vmulq_f32(v9, v28), v32)));
        float32x4_t v25 = v6[1];
        v7[1] = v33;
        float32x4_t v34 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v28), vmulq_f32(v10, v30)), vaddq_f32(vmulq_f32(v11, v25), vaddq_f32(vmulq_f32(v9, v31), v7[2])));
        float32x4_t v28 = v6[2];
        float32x4_t v35 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v31), vmulq_f32(v10, v25)), vaddq_f32(vmulq_f32(v11, v28), vaddq_f32(vmulq_f32(v9, v30), v7[3])));
        v7[2] = v34;
        v7[3] = v35;
        v7 += 4;
        v27 -= 4;
      }
      while (v27 > 3);
      if (v27)
      {
        int v36 = 0;
        uint64_t v37 = 0;
        do
        {
          float32x4_t v38 = vmulq_f32(v8, v26);
          float32x4_t v39 = vmulq_f32(v9, v25);
          float32x4_t v26 = v25;
          float32x4_t v25 = v28;
          float32x4_t v28 = v6[v37 + 3];
          v7[v37] = vaddq_f32(vaddq_f32(v38, vmulq_f32(v10, v25)), vaddq_f32(vmulq_f32(v11, v28), vaddq_f32(v39, v7[v37])));
          ++v37;
          ++v36;
        }
        while (v27 != v36);
        uint64_t v7 = (float32x4_t *)((char *)v7 + v37 * 16);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v37 * 16);
      }
      v7 += v12;
      v6 += v13;
      --v5;
    }
    while (v5);
  }
  else if (v4)
  {
    uint64_t v14 = 16 * v12;
    uint64_t v15 = 16 * v13;
    int v16 = *(_DWORD *)a1 - v3;
    do
    {
      float32x4_t v17 = *v6;
      float32x4_t v18 = v6[1];
      int v19 = v16;
      float32x4_t v20 = v6[2];
      do
      {
        float32x4_t v21 = vmulq_f32(v8, v17);
        float32x4_t v22 = vmulq_f32(v9, v18);
        float32x4_t v17 = v18;
        float32x4_t v18 = v20;
        float32x4_t v20 = v6[3];
        *uint64_t v7 = vaddq_f32(vaddq_f32(v21, vmulq_f32(v10, v18)), vaddq_f32(vmulq_f32(v11, v20), vaddq_f32(v22, *v7)));
        ++v7;
        ++v6;
      }
      while (!__CFADD__(v19++, 1));
      uint64_t v7 = (float32x4_t *)((char *)v7 + v14);
      uint64_t v6 = (float32x4_t *)((char *)v6 + v15);
      --v5;
    }
    while (v5);
  }
  return 4;
}

uint64_t cadd5x(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 8);
  unsigned int v4 = v3 - *(_DWORD *)a1;
  int v5 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  uint64_t v6 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * a3);
  uint64_t v7 = *(float32x4_t **)(a1 + 16);
  float32x4_t v8 = *a2;
  float32x4_t v9 = a2[1];
  float32x4_t v10 = a2[2];
  uint64_t v11 = (int)(*(_DWORD *)(a1 + 24) - v4);
  uint64_t v12 = (int)(*(_DWORD *)(a1 + 88) - v4);
  if (v4 >= 3)
  {
    do
    {
      float32x4_t v37 = *v6;
      float32x4_t v36 = v6[1];
      for (unsigned int i = v4; i > 2; i -= 3)
      {
        float32x4_t v39 = vmulq_f32(v8, v37);
        float32x4_t v40 = v6[3];
        v6 += 3;
        float32x4_t v37 = v40;
        float32x4_t v41 = v6[-1];
        float32x4_t v42 = v7[1];
        *uint64_t v7 = vaddq_f32(vaddq_f32(vmulq_f32(v9, v36), *v7), vaddq_f32(v39, vmulq_f32(v10, v41)));
        float32x4_t v43 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v36), vmulq_f32(v10, v40)), vaddq_f32(vmulq_f32(v9, v41), v42));
        float32x4_t v36 = v6[1];
        float32x4_t v44 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v41), vmulq_f32(v10, v36)), vaddq_f32(vmulq_f32(v9, v40), v7[2]));
        v7[1] = v43;
        v7[2] = v44;
        v7 += 3;
      }
      if (i)
      {
        int v45 = 0;
        uint64_t v46 = 0;
        do
        {
          float32x4_t v47 = vmulq_f32(v8, v37);
          float32x4_t v48 = vmulq_f32(v9, v36);
          float32x4_t v37 = v36;
          float32x4_t v36 = v6[v46 + 2];
          v7[v46] = vaddq_f32(vaddq_f32(v48, v7[v46]), vaddq_f32(v47, vmulq_f32(v10, v36)));
          ++v46;
          ++v45;
        }
        while (i != v45);
        uint64_t v7 = (float32x4_t *)((char *)v7 + v46 * 16);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v46 * 16);
      }
      v7 += v11;
      v6 += v12;
      --v5;
    }
    while (v5);
  }
  else if (v4)
  {
    uint64_t v13 = 16 * v11;
    uint64_t v14 = 16 * v12;
    int v15 = *(_DWORD *)a1 - v3;
    do
    {
      float32x4_t v16 = *v6;
      float32x4_t v17 = v6[1];
      int v18 = v15;
      do
      {
        float32x4_t v19 = vmulq_f32(v8, v16);
        float32x4_t v20 = vmulq_f32(v9, v17);
        float32x4_t v16 = v17;
        float32x4_t v17 = v6[2];
        *uint64_t v7 = vaddq_f32(vaddq_f32(v20, *v7), vaddq_f32(v19, vmulq_f32(v10, v17)));
        ++v7;
        ++v6;
        BOOL v21 = __CFADD__(v18++, 1);
      }
      while (!v21);
      uint64_t v7 = (float32x4_t *)((char *)v7 + v13);
      uint64_t v6 = (float32x4_t *)((char *)v6 + v14);
      --v5;
    }
    while (v5);
  }
  uint64_t v22 = a3 + 3;
  int v23 = *(_DWORD *)(a1 + 12);
  int v24 = *(_DWORD *)(a1 + 4);
  unsigned int v25 = *(_DWORD *)(a1 + 8) - *(_DWORD *)a1;
  uint64_t v26 = *(void *)(a1 + 80);
  unsigned int v27 = *(float32x4_t **)(a1 + 16);
  float32x4_t v28 = a2[3];
  float32x4_t v29 = a2[4];
  uint64_t v30 = (int)(*(_DWORD *)(a1 + 24) - v25);
  uint64_t v31 = (int)(*(_DWORD *)(a1 + 88) - v25);
  if (v25 < 2)
  {
    if (v25)
    {
      int v58 = v24 - v23;
      float32x4_t v59 = (float32x4_t *)(v26 + 16 * v22 + 16);
      do
      {
        *unsigned int v27 = vaddq_f32(vmulq_f32(v29, *v59), vaddq_f32(vmulq_f32(v28, v59[-1]), *v27));
        v59 += v31 + 1;
        v27 += v30 + 1;
        BOOL v21 = __CFADD__(v58++, 1);
      }
      while (!v21);
    }
  }
  else
  {
    int v32 = v23 - v24;
    float32x4_t v33 = (float32x4_t *)(v26 + 16 * v22);
    uint64_t v34 = 16 * v30 - 32;
    uint64_t v35 = 16 * v31 - 32;
    do
    {
      uint64_t v51 = 0;
      float32x4_t v52 = *v33;
      for (unsigned int j = v25; j > 1; j -= 2)
      {
        float32x4_t v54 = &v27[v51];
        float32x4_t v55 = vaddq_f32(vmulq_f32(v28, v52), v27[v51]);
        float32x4_t v56 = v33[v51 + 1];
        float32x4_t v52 = v33[v51 + 2];
        float32x4_t v57 = vaddq_f32(vmulq_f32(v29, v52), vaddq_f32(vmulq_f32(v28, v56), v27[v51 + 1]));
        *float32x4_t v54 = vaddq_f32(vmulq_f32(v29, v56), v55);
        v54[1] = v57;
        v51 += 2;
      }
      if (j)
      {
        v27[v51] = vaddq_f32(vmulq_f32(v29, v33[v51 + 1]), vaddq_f32(vmulq_f32(v28, v52), v27[v51]));
        uint64_t v49 = 3;
      }
      else
      {
        uint64_t v49 = 2;
      }
      uint64_t v50 = 16 * v49;
      unsigned int v27 = (float32x4_t *)((char *)v27 + v34 + v50 + v51 * 16);
      float32x4_t v33 = (float32x4_t *)((char *)v33 + v35 + v50 + v51 * 16);
      --v32;
    }
    while (v32);
  }
  return 5;
}

uint64_t cadd6x(uint64_t a1, float32x4_t *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 8);
  unsigned int v4 = v3 - *(_DWORD *)a1;
  int v5 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  uint64_t v6 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * a3);
  uint64_t v7 = *(float32x4_t **)(a1 + 16);
  float32x4_t v8 = *a2;
  float32x4_t v9 = a2[1];
  float32x4_t v10 = a2[2];
  uint64_t v11 = (int)(*(_DWORD *)(a1 + 24) - v4);
  uint64_t v12 = (int)(*(_DWORD *)(a1 + 88) - v4);
  if (v4 >= 3)
  {
    do
    {
      float32x4_t v42 = *v6;
      float32x4_t v41 = v6[1];
      for (unsigned int i = v4; i > 2; i -= 3)
      {
        float32x4_t v44 = vmulq_f32(v8, v42);
        float32x4_t v45 = v6[3];
        v6 += 3;
        float32x4_t v42 = v45;
        float32x4_t v46 = v6[-1];
        float32x4_t v47 = v7[1];
        *uint64_t v7 = vaddq_f32(vaddq_f32(vmulq_f32(v9, v41), *v7), vaddq_f32(v44, vmulq_f32(v10, v46)));
        float32x4_t v48 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v41), vmulq_f32(v10, v45)), vaddq_f32(vmulq_f32(v9, v46), v47));
        float32x4_t v41 = v6[1];
        float32x4_t v49 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v46), vmulq_f32(v10, v41)), vaddq_f32(vmulq_f32(v9, v45), v7[2]));
        v7[1] = v48;
        v7[2] = v49;
        v7 += 3;
      }
      if (i)
      {
        int v50 = 0;
        uint64_t v51 = 0;
        do
        {
          float32x4_t v52 = vmulq_f32(v8, v42);
          float32x4_t v53 = vmulq_f32(v9, v41);
          float32x4_t v42 = v41;
          float32x4_t v41 = v6[v51 + 2];
          v7[v51] = vaddq_f32(vaddq_f32(v53, v7[v51]), vaddq_f32(v52, vmulq_f32(v10, v41)));
          ++v51;
          ++v50;
        }
        while (i != v50);
        uint64_t v7 = (float32x4_t *)((char *)v7 + v51 * 16);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v51 * 16);
      }
      v7 += v11;
      v6 += v12;
      --v5;
    }
    while (v5);
  }
  else if (v4)
  {
    uint64_t v13 = 16 * v11;
    uint64_t v14 = 16 * v12;
    int v15 = *(_DWORD *)a1 - v3;
    do
    {
      float32x4_t v16 = *v6;
      float32x4_t v17 = v6[1];
      int v18 = v15;
      do
      {
        float32x4_t v19 = vmulq_f32(v8, v16);
        float32x4_t v20 = vmulq_f32(v9, v17);
        float32x4_t v16 = v17;
        float32x4_t v17 = v6[2];
        *uint64_t v7 = vaddq_f32(vaddq_f32(v20, *v7), vaddq_f32(v19, vmulq_f32(v10, v17)));
        ++v7;
        ++v6;
        BOOL v21 = __CFADD__(v18++, 1);
      }
      while (!v21);
      uint64_t v7 = (float32x4_t *)((char *)v7 + v13);
      uint64_t v6 = (float32x4_t *)((char *)v6 + v14);
      --v5;
    }
    while (v5);
  }
  int v22 = *(_DWORD *)(a1 + 8);
  unsigned int v23 = v22 - *(_DWORD *)a1;
  int v24 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  unsigned int v25 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * a3 + 48);
  uint64_t v26 = *(float32x4_t **)(a1 + 16);
  float32x4_t v27 = a2[3];
  float32x4_t v28 = a2[4];
  float32x4_t v29 = a2[5];
  uint64_t v30 = (int)(*(_DWORD *)(a1 + 24) - v23);
  uint64_t v31 = (int)(*(_DWORD *)(a1 + 88) - v23);
  if (v23 >= 3)
  {
    do
    {
      float32x4_t v55 = *v25;
      float32x4_t v54 = v25[1];
      for (unsigned int j = v23; j > 2; j -= 3)
      {
        float32x4_t v57 = vmulq_f32(v27, v55);
        float32x4_t v58 = v25[3];
        v25 += 3;
        float32x4_t v55 = v58;
        float32x4_t v59 = v25[-1];
        float32x4_t v60 = v26[1];
        *uint64_t v26 = vaddq_f32(vaddq_f32(vmulq_f32(v28, v54), *v26), vaddq_f32(v57, vmulq_f32(v29, v59)));
        float32x4_t v61 = vaddq_f32(vaddq_f32(vmulq_f32(v27, v54), vmulq_f32(v29, v58)), vaddq_f32(vmulq_f32(v28, v59), v60));
        float32x4_t v54 = v25[1];
        float32x4_t v62 = vaddq_f32(vaddq_f32(vmulq_f32(v27, v59), vmulq_f32(v29, v54)), vaddq_f32(vmulq_f32(v28, v58), v26[2]));
        v26[1] = v61;
        v26[2] = v62;
        v26 += 3;
      }
      if (j)
      {
        int v63 = 0;
        uint64_t v64 = 0;
        do
        {
          float32x4_t v65 = vmulq_f32(v27, v55);
          float32x4_t v66 = vmulq_f32(v28, v54);
          float32x4_t v55 = v54;
          float32x4_t v54 = v25[v64 + 2];
          v26[v64] = vaddq_f32(vaddq_f32(v66, v26[v64]), vaddq_f32(v65, vmulq_f32(v29, v54)));
          ++v64;
          ++v63;
        }
        while (j != v63);
        uint64_t v26 = (float32x4_t *)((char *)v26 + v64 * 16);
        unsigned int v25 = (float32x4_t *)((char *)v25 + v64 * 16);
      }
      v26 += v30;
      v25 += v31;
      --v24;
    }
    while (v24);
  }
  else if (v23)
  {
    uint64_t v32 = 16 * v30;
    uint64_t v33 = 16 * v31;
    int v34 = *(_DWORD *)a1 - v22;
    do
    {
      float32x4_t v35 = *v25;
      float32x4_t v36 = v25[1];
      int v37 = v34;
      do
      {
        float32x4_t v38 = vmulq_f32(v27, v35);
        float32x4_t v39 = vmulq_f32(v28, v36);
        float32x4_t v35 = v36;
        float32x4_t v36 = v25[2];
        *uint64_t v26 = vaddq_f32(vaddq_f32(v39, *v26), vaddq_f32(v38, vmulq_f32(v29, v36)));
        ++v26;
        ++v25;
        BOOL v21 = __CFADD__(v37++, 1);
      }
      while (!v21);
      uint64_t v26 = (float32x4_t *)((char *)v26 + v32);
      unsigned int v25 = (float32x4_t *)((char *)v25 + v33);
      --v24;
    }
    while (v24);
  }
  return 6;
}

uint64_t cadd7x(uint64_t a1, float32x4_t *a2, int a3)
{
  cadd4x(a1, a2, a3);
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = v6 - *(_DWORD *)a1;
  int v8 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  float32x4_t v9 = (float32x4_t *)(*(void *)(a1 + 80) + 16 * (a3 + 4));
  float32x4_t v10 = *(float32x4_t **)(a1 + 16);
  float32x4_t v11 = a2[4];
  float32x4_t v12 = a2[5];
  float32x4_t v13 = a2[6];
  uint64_t v14 = (int)(*(_DWORD *)(a1 + 24) - v7);
  uint64_t v15 = (int)(*(_DWORD *)(a1 + 88) - v7);
  if (v7 >= 3)
  {
    do
    {
      float32x4_t v27 = *v9;
      float32x4_t v26 = v9[1];
      for (unsigned int i = v7; i > 2; i -= 3)
      {
        float32x4_t v29 = vmulq_f32(v11, v27);
        float32x4_t v30 = v9[3];
        v9 += 3;
        float32x4_t v27 = v30;
        float32x4_t v31 = v9[-1];
        float32x4_t v32 = v10[1];
        *float32x4_t v10 = vaddq_f32(vaddq_f32(vmulq_f32(v12, v26), *v10), vaddq_f32(v29, vmulq_f32(v13, v31)));
        float32x4_t v33 = vaddq_f32(vaddq_f32(vmulq_f32(v11, v26), vmulq_f32(v13, v30)), vaddq_f32(vmulq_f32(v12, v31), v32));
        float32x4_t v26 = v9[1];
        float32x4_t v34 = vaddq_f32(vaddq_f32(vmulq_f32(v11, v31), vmulq_f32(v13, v26)), vaddq_f32(vmulq_f32(v12, v30), v10[2]));
        v10[1] = v33;
        v10[2] = v34;
        v10 += 3;
      }
      if (i)
      {
        int v35 = 0;
        uint64_t v36 = 0;
        do
        {
          float32x4_t v37 = vmulq_f32(v11, v27);
          float32x4_t v38 = vmulq_f32(v12, v26);
          float32x4_t v27 = v26;
          float32x4_t v26 = v9[v36 + 2];
          v10[v36] = vaddq_f32(vaddq_f32(v38, v10[v36]), vaddq_f32(v37, vmulq_f32(v13, v26)));
          ++v36;
          ++v35;
        }
        while (i != v35);
        float32x4_t v10 = (float32x4_t *)((char *)v10 + v36 * 16);
        float32x4_t v9 = (float32x4_t *)((char *)v9 + v36 * 16);
      }
      v10 += v14;
      v9 += v15;
      --v8;
    }
    while (v8);
  }
  else if (v7)
  {
    uint64_t v16 = 16 * v14;
    uint64_t v17 = 16 * v15;
    int v18 = *(_DWORD *)a1 - v6;
    do
    {
      float32x4_t v19 = *v9;
      float32x4_t v20 = v9[1];
      int v21 = v18;
      do
      {
        float32x4_t v22 = vmulq_f32(v11, v19);
        float32x4_t v23 = vmulq_f32(v12, v20);
        float32x4_t v19 = v20;
        float32x4_t v20 = v9[2];
        *float32x4_t v10 = vaddq_f32(vaddq_f32(v23, *v10), vaddq_f32(v22, vmulq_f32(v13, v20)));
        ++v10;
        ++v9;
      }
      while (!__CFADD__(v21++, 1));
      float32x4_t v10 = (float32x4_t *)((char *)v10 + v16);
      float32x4_t v9 = (float32x4_t *)((char *)v9 + v17);
      --v8;
    }
    while (v8);
  }
  return 7;
}

uint64_t c2y(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v3)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
    float32x4_t v5 = *a2;
    float32x4_t v6 = a2[1];
    uint64_t v7 = *(int *)(a1 + 88);
    if (v4 < 2)
    {
      if (v4)
      {
        uint64_t v24 = 0;
        uint64_t v25 = 16 * a3;
        uint64_t v26 = v25 + 16 * v7;
        do
        {
          *(float32x4_t *)(*(void *)(a1 + 16) + 16 * v24) = vaddq_f32(vmulq_f32(v5, *(float32x4_t *)(*(void *)(a1 + 80) + v25 + 16 * v24)), vmulq_f32(v6, *(float32x4_t *)(*(void *)(a1 + 80) + v26 + 16 * v24)));
          ++v24;
        }
        while (v3 != v24);
      }
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      uint64_t v10 = *(int *)(a1 + 24);
      uint64_t v11 = 32 * v10;
      uint64_t v12 = 16 * v10;
      uint64_t v13 = 32 * v7;
      do
      {
        uint64_t v14 = *(void *)(a1 + 80);
        float32x4_t v15 = *(float32x4_t *)(v14 + 16 * v9 + 16 * a3);
        uint64_t v16 = *(void *)(a1 + 16);
        uint64_t v17 = v16 + v12;
        uint64_t v18 = v14 + 16 * a3;
        uint64_t v19 = v14 + 16 * a3 + 32 * v7;
        uint64_t v20 = v14 + 16 * a3 + 16 * v7;
        unsigned int v21 = v4;
        do
        {
          float32x4_t v22 = *(float32x4_t *)(v20 + v8);
          float32x4_t v23 = vaddq_f32(vmulq_f32(v5, v15), vmulq_f32(v6, v22));
          float32x4_t v15 = *(float32x4_t *)(v19 + v8);
          *(float32x4_t *)(v16 + v8) = v23;
          *(float32x4_t *)(v17 + v8) = vaddq_f32(vmulq_f32(v5, v22), vmulq_f32(v6, v15));
          v21 -= 2;
          v16 += v11;
          v17 += v11;
          v18 += v13;
          v19 += v13;
          v20 += v13;
        }
        while (v21 > 1);
        if (v21) {
          *(float32x4_t *)(v16 + v8) = vaddq_f32(vmulq_f32(v5, v15), vmulq_f32(v6, *(float32x4_t *)(v18 + v8 + 16 * v7)));
        }
        ++v9;
        v8 += 16;
      }
      while (v9 != v3);
    }
  }
  return 2;
}

uint64_t c3y(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 12);
    int v5 = *(_DWORD *)(a1 + 4);
    unsigned int v6 = v4 - v5;
    float32x4_t v7 = *a2;
    float32x4_t v8 = a2[1];
    float32x4_t v9 = a2[2];
    uint64_t v10 = *(int *)(a1 + 24);
    uint64_t v11 = *(int *)(a1 + 88);
    uint64_t v12 = a3;
    if ((v4 - v5) < 3)
    {
      if (v6)
      {
        uint64_t v41 = 0;
        uint64_t v42 = 0;
        uint64_t v43 = 16 * v10;
        int v44 = v5 - v4;
        uint64_t v45 = 16 * a3 + 32 * v11;
        do
        {
          uint64_t v46 = *(void *)(a1 + 80);
          float32x4_t v47 = (float32x4_t *)(v46 + 16 * v42 + 16 * v12);
          float32x4_t v48 = *v47;
          float32x4_t v49 = v47[v11];
          int v50 = (float32x4_t *)(*(void *)(a1 + 16) + v41);
          uint64_t v51 = (float32x4_t *)(v46 + v45);
          int v52 = v44;
          do
          {
            float32x4_t v53 = vmulq_f32(v7, v48);
            float32x4_t v54 = vmulq_f32(v8, v49);
            float32x4_t v48 = v49;
            float32x4_t v49 = *v51;
            *int v50 = vaddq_f32(v54, vaddq_f32(v53, vmulq_f32(v9, *v51)));
            int v50 = (float32x4_t *)((char *)v50 + v43);
            v51 += v11;
          }
          while (!__CFADD__(v52++, 1));
          ++v42;
          v41 += 16;
          v45 += 16;
        }
        while (v42 != v3);
      }
    }
    else
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 48 * v10;
      uint64_t v16 = 16 * v10;
      uint64_t v17 = 48 * v11;
      uint64_t v18 = 16 * v12 + 48 * v11;
      uint64_t v19 = v18;
      do
      {
        uint64_t v20 = *(void *)(a1 + 80);
        unsigned int v21 = (float32x4_t *)(v20 + 16 * v14 + 16 * v12);
        uint64_t v22 = *(void *)(a1 + 16);
        float32x4_t v23 = v21[v11];
        uint64_t v24 = v22 + 32 * v10;
        uint64_t v25 = v22 + v16;
        uint64_t v26 = v20 + 16 * v12;
        uint64_t v27 = v20 + v18 + 16 * v11;
        float32x4_t v28 = *v21;
        uint64_t v29 = v20 + v18;
        uint64_t v30 = v20 + 16 * v12 + 32 * v11;
        uint64_t v31 = v20 + v19;
        unsigned int v32 = v6;
        do
        {
          float32x4_t v33 = *(float32x4_t *)(v30 + v13);
          float32x4_t v34 = vaddq_f32(vmulq_f32(v7, v28), vmulq_f32(v9, v33));
          float32x4_t v28 = *(float32x4_t *)(v29 + v13);
          *(float32x4_t *)(v22 + v13) = vaddq_f32(vmulq_f32(v8, v23), v34);
          float32x4_t v35 = vaddq_f32(vmulq_f32(v8, v33), vaddq_f32(vmulq_f32(v7, v23), vmulq_f32(v9, v28)));
          float32x4_t v23 = *(float32x4_t *)(v27 + v13);
          *(float32x4_t *)(v25 + v13) = v35;
          uint64_t v36 = v31;
          *(float32x4_t *)(v24 + v13) = vaddq_f32(vmulq_f32(v8, v28), vaddq_f32(vmulq_f32(v7, v33), vmulq_f32(v9, v23)));
          v32 -= 3;
          v22 += v15;
          v24 += v15;
          v25 += v15;
          v26 += v17;
          v27 += v17;
          v29 += v17;
          v30 += v17;
          v31 += v17;
        }
        while (v32 > 2);
        if (v32)
        {
          int v37 = 0;
          uint64_t v38 = v13;
          do
          {
            float32x4_t v39 = vmulq_f32(v7, v28);
            float32x4_t v40 = vmulq_f32(v8, v23);
            float32x4_t v28 = v23;
            float32x4_t v23 = *(float32x4_t *)(v36 + 32 * v11);
            *(float32x4_t *)(v22 + v38) = vaddq_f32(v40, vaddq_f32(v39, vmulq_f32(v9, v23)));
            v38 += v16;
            v36 += 16 * v11;
            ++v37;
          }
          while (v32 != v37);
        }
        ++v14;
        v13 += 16;
        v19 += 16;
      }
      while (v14 != v3);
    }
  }
  return 3;
}

uint64_t c4y(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 12);
    int v5 = *(_DWORD *)(a1 + 4);
    unsigned int v6 = v4 - v5;
    float32x4_t v7 = *a2;
    float32x4_t v8 = a2[1];
    float32x4_t v9 = a2[2];
    float32x4_t v10 = a2[3];
    uint64_t v11 = *(int *)(a1 + 24);
    uint64_t v12 = *(int *)(a1 + 88);
    uint64_t v13 = a3;
    if ((v4 - v5) < 4)
    {
      if (v6) {
        uint64_t v47 = 2 * v12;
      }
      else {
        uint64_t v47 = 0;
      }
      if (v6)
      {
        uint64_t v48 = 0;
        uint64_t v49 = 0;
        uint64_t v50 = 16 * v11;
        uint64_t v51 = 16 * v47 + 16 * a3 + 16 * v12;
        int v52 = v5 - v4;
        do
        {
          uint64_t v53 = *(void *)(a1 + 80);
          float32x4_t v54 = (float32x4_t *)(v53 + 16 * v49 + 16 * v13);
          float32x4_t v55 = v54[v12];
          float32x4_t v56 = *v54;
          float32x4_t v57 = v54[2 * v12];
          float32x4_t v58 = (float32x4_t *)(*(void *)(a1 + 16) + v48);
          float32x4_t v59 = (float32x4_t *)(v53 + v51);
          int v60 = v52;
          do
          {
            float32x4_t v61 = vmulq_f32(v7, v56);
            float32x4_t v62 = vmulq_f32(v8, v55);
            float32x4_t v56 = v55;
            float32x4_t v55 = v57;
            float32x4_t v57 = *v59;
            *float32x4_t v58 = vaddq_f32(vaddq_f32(v61, vmulq_f32(v9, v55)), vaddq_f32(v62, vmulq_f32(v10, *v59)));
            float32x4_t v58 = (float32x4_t *)((char *)v58 + v50);
            v59 += v12;
          }
          while (!__CFADD__(v60++, 1));
          ++v49;
          v48 += 16;
          v51 += 16;
        }
        while (v49 != v3);
      }
    }
    else
    {
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      uint64_t v16 = 2 * v11;
      uint64_t v17 = v11 << 6;
      uint64_t v18 = 16 * v11;
      uint64_t v19 = 16 * v16;
      uint64_t v20 = v12 << 6;
      uint64_t v21 = 16 * a3 + (v12 << 6);
      do
      {
        uint64_t v22 = *(void *)(a1 + 80);
        float32x4_t v23 = (float32x4_t *)(v22 + 16 * v15 + 16 * a3);
        float32x4_t v24 = v23[v12];
        float32x4_t v25 = v23[2 * v12];
        uint64_t v26 = *(void *)(a1 + 16);
        uint64_t v27 = v26 + v17 - v18;
        uint64_t v28 = v26 + v19;
        uint64_t v29 = v26 + v18;
        uint64_t v30 = v22 + 16 * a3;
        uint64_t v31 = v22 + v21 + 32 * v12;
        float32x4_t v32 = *v23;
        uint64_t v33 = v22 + v21 + 16 * v12;
        uint64_t v34 = v22 + v21;
        uint64_t v35 = v22 + v21 - 16 * v12;
        uint64_t v36 = v26 + v17;
        unsigned int v37 = v6;
        do
        {
          uint64_t v38 = v36;
          float32x4_t v39 = *(float32x4_t *)(v35 + v14);
          float32x4_t v40 = vaddq_f32(vaddq_f32(vmulq_f32(v7, v32), vmulq_f32(v9, v25)), vaddq_f32(vmulq_f32(v8, v24), vmulq_f32(v10, v39)));
          float32x4_t v32 = *(float32x4_t *)(v34 + v14);
          *(float32x4_t *)(v26 + v14) = v40;
          float32x4_t v41 = vaddq_f32(vaddq_f32(vmulq_f32(v7, v24), vmulq_f32(v9, v39)), vaddq_f32(vmulq_f32(v8, v25), vmulq_f32(v10, v32)));
          float32x4_t v24 = *(float32x4_t *)(v33 + v14);
          *(float32x4_t *)(v29 + v14) = v41;
          float32x4_t v42 = vaddq_f32(vmulq_f32(v7, v25), vmulq_f32(v9, v32));
          float32x4_t v25 = *(float32x4_t *)(v31 + v14);
          *(float32x4_t *)(v28 + v14) = vaddq_f32(v42, vaddq_f32(vmulq_f32(v8, v39), vmulq_f32(v10, v24)));
          *(float32x4_t *)(v27 + v14) = vaddq_f32(vaddq_f32(vmulq_f32(v7, v39), vmulq_f32(v9, v24)), vaddq_f32(vmulq_f32(v8, v32), vmulq_f32(v10, v25)));
          v37 -= 4;
          v26 += v17;
          v27 += v17;
          v28 += v17;
          v29 += v17;
          v30 += v20;
          v31 += v20;
          v33 += v20;
          v34 += v20;
          v35 += v20;
          v36 += v17;
        }
        while (v37 > 3);
        if (v37)
        {
          int v43 = 0;
          int v44 = (float32x4_t *)(v30 + v14 + 32 * v12);
          do
          {
            float32x4_t v45 = vmulq_f32(v7, v32);
            float32x4_t v46 = vmulq_f32(v8, v24);
            float32x4_t v32 = v24;
            float32x4_t v24 = v25;
            v44 += v12;
            float32x4_t v25 = *v44;
            *(float32x4_t *)(v38 + v14) = vaddq_f32(vaddq_f32(v45, vmulq_f32(v9, v24)), vaddq_f32(v46, vmulq_f32(v10, *v44)));
            v38 += v18;
            ++v43;
          }
          while (v37 != v43);
        }
        ++v15;
        v14 += 16;
      }
      while (v15 != v3);
    }
  }
  return 4;
}

uint64_t c5y(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 12);
    int v5 = *(_DWORD *)(a1 + 4);
    unsigned int v6 = v4 - v5;
    float32x4_t v7 = *a2;
    float32x4_t v8 = a2[1];
    float32x4_t v9 = a2[2];
    uint64_t v10 = *(int *)(a1 + 24);
    uint64_t v11 = *(int *)(a1 + 88);
    if ((v4 - v5) < 3)
    {
      if (v6)
      {
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        uint64_t v42 = 16 * v10;
        int v43 = v5 - v4;
        uint64_t v44 = 16 * a3 + 32 * v11;
        do
        {
          uint64_t v45 = *(void *)(a1 + 80);
          float32x4_t v46 = (float32x4_t *)(v45 + 16 * v41 + 16 * a3);
          float32x4_t v47 = *v46;
          float32x4_t v48 = v46[v11];
          uint64_t v49 = (float32x4_t *)(*(void *)(a1 + 16) + v40);
          uint64_t v50 = (float32x4_t *)(v45 + v44);
          int v51 = v43;
          do
          {
            float32x4_t v52 = vmulq_f32(v7, v47);
            float32x4_t v53 = vmulq_f32(v8, v48);
            float32x4_t v47 = v48;
            float32x4_t v48 = *v50;
            *uint64_t v49 = vaddq_f32(v53, vaddq_f32(v52, vmulq_f32(v9, *v50)));
            uint64_t v49 = (float32x4_t *)((char *)v49 + v42);
            v50 += v11;
          }
          while (!__CFADD__(v51++, 1));
          ++v41;
          v40 += 16;
          v44 += 16;
        }
        while (v41 != v3);
      }
    }
    else
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = 48 * v10;
      uint64_t v15 = 16 * v10;
      uint64_t v16 = 48 * v11;
      uint64_t v17 = 16 * a3 + 48 * v11;
      uint64_t v18 = v17;
      do
      {
        uint64_t v19 = *(void *)(a1 + 80);
        uint64_t v20 = (float32x4_t *)(v19 + 16 * v13 + 16 * a3);
        uint64_t v21 = *(void *)(a1 + 16);
        float32x4_t v22 = v20[v11];
        uint64_t v23 = v21 + 32 * v10;
        uint64_t v24 = v21 + v15;
        uint64_t v25 = v19 + 16 * a3;
        uint64_t v26 = v19 + v17 + 16 * v11;
        float32x4_t v27 = *v20;
        uint64_t v28 = v19 + v17;
        uint64_t v29 = v19 + 16 * a3 + 32 * v11;
        uint64_t v30 = v19 + v18;
        unsigned int v31 = v6;
        do
        {
          float32x4_t v32 = *(float32x4_t *)(v29 + v12);
          float32x4_t v33 = vaddq_f32(vmulq_f32(v7, v27), vmulq_f32(v9, v32));
          float32x4_t v27 = *(float32x4_t *)(v28 + v12);
          *(float32x4_t *)(v21 + v12) = vaddq_f32(vmulq_f32(v8, v22), v33);
          float32x4_t v34 = vaddq_f32(vmulq_f32(v8, v32), vaddq_f32(vmulq_f32(v7, v22), vmulq_f32(v9, v27)));
          float32x4_t v22 = *(float32x4_t *)(v26 + v12);
          *(float32x4_t *)(v24 + v12) = v34;
          uint64_t v35 = v30;
          *(float32x4_t *)(v23 + v12) = vaddq_f32(vmulq_f32(v8, v27), vaddq_f32(vmulq_f32(v7, v32), vmulq_f32(v9, v22)));
          v31 -= 3;
          v21 += v14;
          v23 += v14;
          v24 += v14;
          v25 += v16;
          v26 += v16;
          v28 += v16;
          v29 += v16;
          v30 += v16;
        }
        while (v31 > 2);
        if (v31)
        {
          int v36 = 0;
          uint64_t v37 = v12;
          do
          {
            float32x4_t v38 = vmulq_f32(v7, v27);
            float32x4_t v39 = vmulq_f32(v8, v22);
            float32x4_t v27 = v22;
            float32x4_t v22 = *(float32x4_t *)(v35 + 32 * v11);
            *(float32x4_t *)(v21 + v37) = vaddq_f32(v39, vaddq_f32(v38, vmulq_f32(v9, v22)));
            v37 += v15;
            v35 += 16 * v11;
            ++v36;
          }
          while (v31 != v36);
        }
        ++v13;
        v12 += 16;
        v18 += 16;
      }
      while (v13 != v3);
    }
  }
  uint64_t v55 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v55)
  {
    unsigned int v56 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
    float32x4_t v57 = a2[3];
    float32x4_t v58 = a2[4];
    uint64_t v59 = *(int *)(a1 + 88);
    uint64_t v60 = 3 * (int)v59 + a3;
    if (v56 < 2)
    {
      if (v56)
      {
        uint64_t v77 = 0;
        uint64_t v78 = 16 * v60;
        uint64_t v79 = v78 + 16 * v59;
        do
        {
          *(float32x4_t *)(*(void *)(a1 + 16) + 16 * v77) = vaddq_f32(vmulq_f32(v58, *(float32x4_t *)(*(void *)(a1 + 80) + v79 + 16 * v77)), vaddq_f32(vmulq_f32(v57, *(float32x4_t *)(*(void *)(a1 + 80)+ v78+ 16 * v77)), *(float32x4_t *)(*(void *)(a1 + 16) + 16 * v77)));
          ++v77;
        }
        while (v55 != v77);
      }
    }
    else
    {
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      uint64_t v63 = *(int *)(a1 + 24);
      uint64_t v64 = 32 * v63;
      uint64_t v65 = 16 * v63;
      uint64_t v66 = 32 * v59;
      do
      {
        uint64_t v67 = *(void *)(a1 + 80);
        float32x4_t v68 = *(float32x4_t *)(v67 + 16 * v62 + 16 * v60);
        uint64_t v69 = *(void *)(a1 + 16);
        uint64_t v70 = v69 + v65;
        uint64_t v71 = v67 + 16 * v60;
        uint64_t v72 = v67 + 32 * v59 + 16 * v60;
        uint64_t v73 = v67 + 16 * v60 + 16 * v59;
        unsigned int v74 = v56;
        do
        {
          float32x4_t v75 = *(float32x4_t *)(v73 + v61);
          float32x4_t v76 = vaddq_f32(vmulq_f32(v57, v68), *(float32x4_t *)(v69 + v61));
          float32x4_t v68 = *(float32x4_t *)(v72 + v61);
          *(float32x4_t *)(v69 + v61) = vaddq_f32(vmulq_f32(v58, v75), v76);
          *(float32x4_t *)(v70 + v61) = vaddq_f32(vmulq_f32(v58, v68), vaddq_f32(vmulq_f32(v57, v75), *(float32x4_t *)(v70 + v61)));
          v74 -= 2;
          v69 += v64;
          v70 += v64;
          v71 += v66;
          v72 += v66;
          v73 += v66;
        }
        while (v74 > 1);
        if (v74) {
          *(float32x4_t *)(v69 + v61) = vaddq_f32(vmulq_f32(v58, *(float32x4_t *)(v71 + v61 + 16 * v59)), vaddq_f32(vmulq_f32(v57, v68), *(float32x4_t *)(v69 + v61)));
        }
        ++v62;
        v61 += 16;
      }
      while (v62 != v55);
    }
  }
  return 5;
}

uint64_t c6y(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 12);
    int v5 = *(_DWORD *)(a1 + 4);
    unsigned int v6 = v4 - v5;
    float32x4_t v7 = *a2;
    float32x4_t v8 = a2[1];
    float32x4_t v9 = a2[2];
    uint64_t v10 = *(int *)(a1 + 24);
    uint64_t v11 = *(int *)(a1 + 88);
    if ((v4 - v5) < 3)
    {
      if (v6)
      {
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        uint64_t v42 = 16 * v10;
        int v43 = v5 - v4;
        uint64_t v44 = 16 * a3 + 32 * v11;
        do
        {
          uint64_t v45 = *(void *)(a1 + 80);
          float32x4_t v46 = (float32x4_t *)(v45 + 16 * v41 + 16 * a3);
          float32x4_t v47 = *v46;
          float32x4_t v48 = v46[v11];
          uint64_t v49 = (float32x4_t *)(*(void *)(a1 + 16) + v40);
          uint64_t v50 = (float32x4_t *)(v45 + v44);
          int v51 = v43;
          do
          {
            float32x4_t v52 = vmulq_f32(v7, v47);
            float32x4_t v53 = vmulq_f32(v8, v48);
            float32x4_t v47 = v48;
            float32x4_t v48 = *v50;
            *uint64_t v49 = vaddq_f32(v53, vaddq_f32(v52, vmulq_f32(v9, *v50)));
            uint64_t v49 = (float32x4_t *)((char *)v49 + v42);
            v50 += v11;
            BOOL v54 = __CFADD__(v51++, 1);
          }
          while (!v54);
          ++v41;
          v40 += 16;
          v44 += 16;
        }
        while (v41 != v3);
      }
    }
    else
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = 48 * v10;
      uint64_t v15 = 16 * v10;
      uint64_t v16 = 48 * v11;
      uint64_t v17 = 16 * a3 + 48 * v11;
      uint64_t v18 = v17;
      do
      {
        uint64_t v19 = *(void *)(a1 + 80);
        uint64_t v20 = (float32x4_t *)(v19 + 16 * v13 + 16 * a3);
        uint64_t v21 = *(void *)(a1 + 16);
        float32x4_t v22 = v20[v11];
        uint64_t v23 = v21 + 32 * v10;
        uint64_t v24 = v21 + v15;
        uint64_t v25 = v19 + 16 * a3;
        uint64_t v26 = v19 + v17 + 16 * v11;
        float32x4_t v27 = *v20;
        uint64_t v28 = v19 + v17;
        uint64_t v29 = v19 + 16 * a3 + 32 * v11;
        uint64_t v30 = v19 + v18;
        unsigned int v31 = v6;
        do
        {
          float32x4_t v32 = *(float32x4_t *)(v29 + v12);
          float32x4_t v33 = vaddq_f32(vmulq_f32(v7, v27), vmulq_f32(v9, v32));
          float32x4_t v27 = *(float32x4_t *)(v28 + v12);
          *(float32x4_t *)(v21 + v12) = vaddq_f32(vmulq_f32(v8, v22), v33);
          float32x4_t v34 = vaddq_f32(vmulq_f32(v8, v32), vaddq_f32(vmulq_f32(v7, v22), vmulq_f32(v9, v27)));
          float32x4_t v22 = *(float32x4_t *)(v26 + v12);
          *(float32x4_t *)(v24 + v12) = v34;
          uint64_t v35 = v30;
          *(float32x4_t *)(v23 + v12) = vaddq_f32(vmulq_f32(v8, v27), vaddq_f32(vmulq_f32(v7, v32), vmulq_f32(v9, v22)));
          v31 -= 3;
          v21 += v14;
          v23 += v14;
          v24 += v14;
          v25 += v16;
          v26 += v16;
          v28 += v16;
          v29 += v16;
          v30 += v16;
        }
        while (v31 > 2);
        if (v31)
        {
          int v36 = 0;
          uint64_t v37 = v12;
          do
          {
            float32x4_t v38 = vmulq_f32(v7, v27);
            float32x4_t v39 = vmulq_f32(v8, v22);
            float32x4_t v27 = v22;
            float32x4_t v22 = *(float32x4_t *)(v35 + 32 * v11);
            *(float32x4_t *)(v21 + v37) = vaddq_f32(v39, vaddq_f32(v38, vmulq_f32(v9, v22)));
            v37 += v15;
            v35 += 16 * v11;
            ++v36;
          }
          while (v31 != v36);
        }
        ++v13;
        v12 += 16;
        v18 += 16;
      }
      while (v13 != v3);
    }
  }
  uint64_t v55 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v55)
  {
    int v56 = *(_DWORD *)(a1 + 12);
    int v57 = *(_DWORD *)(a1 + 4);
    unsigned int v58 = v56 - v57;
    float32x4_t v59 = a2[3];
    float32x4_t v60 = a2[4];
    float32x4_t v61 = a2[5];
    uint64_t v62 = *(int *)(a1 + 88);
    uint64_t v63 = *(int *)(a1 + 24);
    uint64_t v64 = 3 * (int)v62 + a3;
    if ((v56 - v57) < 3)
    {
      if (v58)
      {
        uint64_t v94 = 0;
        uint64_t v95 = 0;
        uint64_t v96 = 16 * v63;
        int v97 = v57 - v56;
        uint64_t v98 = 32 * v62 + 16 * v64;
        do
        {
          uint64_t v99 = *(void *)(a1 + 80);
          uint64_t v100 = (float32x4_t *)(v99 + 16 * v95 + 16 * v64);
          float32x4_t v101 = *v100;
          float32x4_t v102 = v100[v62];
          unsigned int v103 = (float32x4_t *)(*(void *)(a1 + 16) + v94);
          int v104 = (float32x4_t *)(v99 + v98);
          int v105 = v97;
          do
          {
            float32x4_t v106 = vmulq_f32(v59, v101);
            float32x4_t v107 = vmulq_f32(v60, v102);
            float32x4_t v101 = v102;
            float32x4_t v102 = *v104;
            *unsigned int v103 = vaddq_f32(vaddq_f32(v107, *v103), vaddq_f32(v106, vmulq_f32(v61, *v104)));
            unsigned int v103 = (float32x4_t *)((char *)v103 + v96);
            v104 += v62;
            BOOL v54 = __CFADD__(v105++, 1);
          }
          while (!v54);
          ++v95;
          v94 += 16;
          v98 += 16;
        }
        while (v95 != v55);
      }
    }
    else
    {
      uint64_t v65 = 0;
      uint64_t v66 = 0;
      uint64_t v67 = 48 * v63;
      uint64_t v68 = 32 * v63;
      uint64_t v69 = 16 * v63;
      uint64_t v70 = 48 * v62;
      uint64_t v71 = 48 * v62 + 16 * v64;
      uint64_t v72 = v71;
      do
      {
        uint64_t v73 = *(void *)(a1 + 80);
        unsigned int v74 = (float32x4_t *)(v73 + 16 * v66 + 16 * v64);
        uint64_t v75 = *(void *)(a1 + 16);
        float32x4_t v76 = v74[v62];
        uint64_t v77 = v75 + v68;
        uint64_t v78 = v75 + v69;
        uint64_t v79 = v73 + 16 * v64;
        uint64_t v80 = v73 + v71 + 16 * v62;
        float32x4_t v81 = *v74;
        uint64_t v82 = v73 + v71;
        uint64_t v83 = v73 + 16 * v64 + 32 * v62;
        uint64_t v84 = v73 + v72;
        unsigned int v85 = v58;
        do
        {
          uint64_t v86 = v84;
          float32x4_t v87 = *(float32x4_t *)(v83 + v65);
          float32x4_t v88 = vaddq_f32(vaddq_f32(vmulq_f32(v60, v76), *(float32x4_t *)(v75 + v65)), vaddq_f32(vmulq_f32(v59, v81), vmulq_f32(v61, v87)));
          float32x4_t v81 = *(float32x4_t *)(v82 + v65);
          *(float32x4_t *)(v75 + v65) = v88;
          float32x4_t v89 = vaddq_f32(vaddq_f32(vmulq_f32(v59, v76), vmulq_f32(v61, v81)), vaddq_f32(vmulq_f32(v60, v87), *(float32x4_t *)(v78 + v65)));
          float32x4_t v76 = *(float32x4_t *)(v80 + v65);
          *(float32x4_t *)(v78 + v65) = v89;
          *(float32x4_t *)(v77 + v65) = vaddq_f32(vaddq_f32(vmulq_f32(v59, v87), vmulq_f32(v61, v76)), vaddq_f32(vmulq_f32(v60, v81), *(float32x4_t *)(v77 + v65)));
          v85 -= 3;
          v75 += v67;
          v77 += v67;
          v78 += v67;
          v79 += v70;
          v80 += v70;
          v82 += v70;
          v83 += v70;
          v84 += v70;
        }
        while (v85 > 2);
        if (v85)
        {
          int v90 = 0;
          uint64_t v91 = v65;
          do
          {
            float32x4_t v92 = vmulq_f32(v59, v81);
            float32x4_t v93 = vmulq_f32(v60, v76);
            float32x4_t v81 = v76;
            float32x4_t v76 = *(float32x4_t *)(v86 + 32 * v62);
            *(float32x4_t *)(v75 + v91) = vaddq_f32(vaddq_f32(v93, *(float32x4_t *)(v75 + v91)), vaddq_f32(v92, vmulq_f32(v61, v76)));
            v91 += v69;
            v86 += 16 * v62;
            ++v90;
          }
          while (v85 != v90);
        }
        ++v66;
        v65 += 16;
        v72 += 16;
      }
      while (v66 != v55);
    }
  }
  return 6;
}

uint64_t c7y(uint64_t a1, float32x4_t *a2, int a3)
{
  c4y(a1, a2, a3);
  uint64_t v6 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v6)
  {
    int v7 = *(_DWORD *)(a1 + 12);
    int v8 = *(_DWORD *)(a1 + 4);
    unsigned int v9 = v7 - v8;
    float32x4_t v10 = a2[4];
    float32x4_t v11 = a2[5];
    float32x4_t v12 = a2[6];
    uint64_t v13 = *(int *)(a1 + 88);
    uint64_t v14 = *(int *)(a1 + 24);
    uint64_t v15 = a3 + 4 * (int)v13;
    if ((v7 - v8) < 3)
    {
      if (v9)
      {
        uint64_t v45 = 0;
        uint64_t v46 = 0;
        uint64_t v47 = 16 * v14;
        int v48 = v8 - v7;
        uint64_t v49 = 32 * v13 + 16 * v15;
        do
        {
          uint64_t v50 = *(void *)(a1 + 80);
          int v51 = (float32x4_t *)(v50 + 16 * v46 + 16 * v15);
          float32x4_t v52 = *v51;
          float32x4_t v53 = v51[v13];
          BOOL v54 = (float32x4_t *)(*(void *)(a1 + 16) + v45);
          uint64_t v55 = (float32x4_t *)(v50 + v49);
          int v56 = v48;
          do
          {
            float32x4_t v57 = vmulq_f32(v10, v52);
            float32x4_t v58 = vmulq_f32(v11, v53);
            float32x4_t v52 = v53;
            float32x4_t v53 = *v55;
            *BOOL v54 = vaddq_f32(vaddq_f32(v58, *v54), vaddq_f32(v57, vmulq_f32(v12, *v55)));
            BOOL v54 = (float32x4_t *)((char *)v54 + v47);
            v55 += v13;
          }
          while (!__CFADD__(v56++, 1));
          ++v46;
          v45 += 16;
          v49 += 16;
        }
        while (v46 != v6);
      }
    }
    else
    {
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      uint64_t v18 = 48 * v14;
      uint64_t v19 = 32 * v14;
      uint64_t v20 = 16 * v14;
      uint64_t v21 = 48 * v13;
      uint64_t v22 = v21 + 16 * v15;
      uint64_t v23 = v22;
      do
      {
        uint64_t v24 = *(void *)(a1 + 80);
        uint64_t v25 = (float32x4_t *)(v24 + 16 * v17 + 16 * v15);
        uint64_t v26 = *(void *)(a1 + 16);
        float32x4_t v27 = v25[v13];
        uint64_t v28 = v26 + v19;
        uint64_t v29 = v26 + v20;
        uint64_t v30 = v24 + 16 * v15;
        uint64_t v31 = v24 + v22 + 16 * v13;
        float32x4_t v32 = *v25;
        uint64_t v33 = v24 + v22;
        uint64_t v34 = v24 + 16 * v15 + 32 * v13;
        uint64_t v35 = v24 + v23;
        unsigned int v36 = v9;
        do
        {
          uint64_t v37 = v35;
          float32x4_t v38 = *(float32x4_t *)(v34 + v16);
          float32x4_t v39 = vaddq_f32(vaddq_f32(vmulq_f32(v11, v27), *(float32x4_t *)(v26 + v16)), vaddq_f32(vmulq_f32(v10, v32), vmulq_f32(v12, v38)));
          float32x4_t v32 = *(float32x4_t *)(v33 + v16);
          *(float32x4_t *)(v26 + v16) = v39;
          float32x4_t v40 = vaddq_f32(vaddq_f32(vmulq_f32(v10, v27), vmulq_f32(v12, v32)), vaddq_f32(vmulq_f32(v11, v38), *(float32x4_t *)(v29 + v16)));
          float32x4_t v27 = *(float32x4_t *)(v31 + v16);
          *(float32x4_t *)(v29 + v16) = v40;
          *(float32x4_t *)(v28 + v16) = vaddq_f32(vaddq_f32(vmulq_f32(v10, v38), vmulq_f32(v12, v27)), vaddq_f32(vmulq_f32(v11, v32), *(float32x4_t *)(v28 + v16)));
          v36 -= 3;
          v26 += v18;
          v28 += v18;
          v29 += v18;
          v30 += v21;
          v31 += v21;
          v33 += v21;
          v34 += v21;
          v35 += v21;
        }
        while (v36 > 2);
        if (v36)
        {
          int v41 = 0;
          uint64_t v42 = v16;
          do
          {
            float32x4_t v43 = vmulq_f32(v10, v32);
            float32x4_t v44 = vmulq_f32(v11, v27);
            float32x4_t v32 = v27;
            float32x4_t v27 = *(float32x4_t *)(v37 + 32 * v13);
            *(float32x4_t *)(v26 + v42) = vaddq_f32(vaddq_f32(v44, *(float32x4_t *)(v26 + v42)), vaddq_f32(v43, vmulq_f32(v12, v27)));
            v42 += v20;
            v37 += 16 * v13;
            ++v41;
          }
          while (v36 != v41);
        }
        ++v17;
        v16 += 16;
        v23 += 16;
      }
      while (v17 != v6);
    }
  }
  return 7;
}

uint64_t cadd2y(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v3)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
    float32x4_t v5 = *a2;
    float32x4_t v6 = a2[1];
    uint64_t v7 = *(int *)(a1 + 88);
    if (v4 < 2)
    {
      if (v4)
      {
        uint64_t v24 = 0;
        uint64_t v25 = 16 * a3;
        uint64_t v26 = v25 + 16 * v7;
        do
        {
          *(float32x4_t *)(*(void *)(a1 + 16) + 16 * v24) = vaddq_f32(vmulq_f32(v6, *(float32x4_t *)(*(void *)(a1 + 80) + v26 + 16 * v24)), vaddq_f32(vmulq_f32(v5, *(float32x4_t *)(*(void *)(a1 + 80)+ v25+ 16 * v24)), *(float32x4_t *)(*(void *)(a1 + 16) + 16 * v24)));
          ++v24;
        }
        while (v3 != v24);
      }
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      uint64_t v10 = *(int *)(a1 + 24);
      uint64_t v11 = 32 * v10;
      uint64_t v12 = 16 * v10;
      uint64_t v13 = 32 * v7;
      do
      {
        uint64_t v14 = *(void *)(a1 + 80);
        float32x4_t v15 = *(float32x4_t *)(v14 + 16 * v9 + 16 * a3);
        uint64_t v16 = *(void *)(a1 + 16);
        uint64_t v17 = v16 + v12;
        uint64_t v18 = v14 + 16 * a3;
        uint64_t v19 = v14 + 16 * a3 + 32 * v7;
        uint64_t v20 = v14 + 16 * a3 + 16 * v7;
        unsigned int v21 = v4;
        do
        {
          float32x4_t v22 = *(float32x4_t *)(v20 + v8);
          float32x4_t v23 = vaddq_f32(vmulq_f32(v5, v15), *(float32x4_t *)(v16 + v8));
          float32x4_t v15 = *(float32x4_t *)(v19 + v8);
          *(float32x4_t *)(v16 + v8) = vaddq_f32(vmulq_f32(v6, v22), v23);
          *(float32x4_t *)(v17 + v8) = vaddq_f32(vmulq_f32(v6, v15), vaddq_f32(vmulq_f32(v5, v22), *(float32x4_t *)(v17 + v8)));
          v21 -= 2;
          v16 += v11;
          v17 += v11;
          v18 += v13;
          v19 += v13;
          v20 += v13;
        }
        while (v21 > 1);
        if (v21) {
          *(float32x4_t *)(v16 + v8) = vaddq_f32(vmulq_f32(v6, *(float32x4_t *)(v18 + v8 + 16 * v7)), vaddq_f32(vmulq_f32(v5, v15), *(float32x4_t *)(v16 + v8)));
        }
        ++v9;
        v8 += 16;
      }
      while (v9 != v3);
    }
  }
  return 2;
}

uint64_t cadd3y(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 12);
    int v5 = *(_DWORD *)(a1 + 4);
    unsigned int v6 = v4 - v5;
    float32x4_t v7 = *a2;
    float32x4_t v8 = a2[1];
    float32x4_t v9 = a2[2];
    uint64_t v10 = *(int *)(a1 + 24);
    uint64_t v11 = *(int *)(a1 + 88);
    uint64_t v12 = a3;
    if ((v4 - v5) < 3)
    {
      if (v6)
      {
        uint64_t v41 = 0;
        uint64_t v42 = 0;
        uint64_t v43 = 16 * v10;
        int v44 = v5 - v4;
        uint64_t v45 = 16 * a3 + 32 * v11;
        do
        {
          uint64_t v46 = *(void *)(a1 + 80);
          uint64_t v47 = (float32x4_t *)(v46 + 16 * v42 + 16 * v12);
          float32x4_t v48 = *v47;
          float32x4_t v49 = v47[v11];
          uint64_t v50 = (float32x4_t *)(*(void *)(a1 + 16) + v41);
          int v51 = (float32x4_t *)(v46 + v45);
          int v52 = v44;
          do
          {
            float32x4_t v53 = vmulq_f32(v7, v48);
            float32x4_t v54 = vmulq_f32(v8, v49);
            float32x4_t v48 = v49;
            float32x4_t v49 = *v51;
            *uint64_t v50 = vaddq_f32(vaddq_f32(v54, *v50), vaddq_f32(v53, vmulq_f32(v9, *v51)));
            uint64_t v50 = (float32x4_t *)((char *)v50 + v43);
            v51 += v11;
          }
          while (!__CFADD__(v52++, 1));
          ++v42;
          v41 += 16;
          v45 += 16;
        }
        while (v42 != v3);
      }
    }
    else
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 48 * v10;
      uint64_t v16 = 16 * v10;
      uint64_t v17 = 48 * v11;
      uint64_t v18 = 16 * v12 + 48 * v11;
      uint64_t v19 = v18;
      do
      {
        uint64_t v20 = *(void *)(a1 + 80);
        unsigned int v21 = (float32x4_t *)(v20 + 16 * v14 + 16 * v12);
        uint64_t v22 = *(void *)(a1 + 16);
        float32x4_t v23 = v21[v11];
        uint64_t v24 = v22 + 32 * v10;
        uint64_t v25 = v22 + v16;
        uint64_t v26 = v20 + 16 * v12;
        uint64_t v27 = v20 + v18 + 16 * v11;
        float32x4_t v28 = *v21;
        uint64_t v29 = v20 + v18;
        uint64_t v30 = v20 + 16 * v12 + 32 * v11;
        uint64_t v31 = v20 + v19;
        unsigned int v32 = v6;
        do
        {
          uint64_t v33 = v31;
          float32x4_t v34 = *(float32x4_t *)(v30 + v13);
          float32x4_t v35 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v23), *(float32x4_t *)(v22 + v13)), vaddq_f32(vmulq_f32(v7, v28), vmulq_f32(v9, v34)));
          float32x4_t v28 = *(float32x4_t *)(v29 + v13);
          *(float32x4_t *)(v22 + v13) = v35;
          float32x4_t v36 = vaddq_f32(vaddq_f32(vmulq_f32(v7, v23), vmulq_f32(v9, v28)), vaddq_f32(vmulq_f32(v8, v34), *(float32x4_t *)(v25 + v13)));
          float32x4_t v23 = *(float32x4_t *)(v27 + v13);
          *(float32x4_t *)(v25 + v13) = v36;
          *(float32x4_t *)(v24 + v13) = vaddq_f32(vaddq_f32(vmulq_f32(v7, v34), vmulq_f32(v9, v23)), vaddq_f32(vmulq_f32(v8, v28), *(float32x4_t *)(v24 + v13)));
          v32 -= 3;
          v22 += v15;
          v24 += v15;
          v25 += v15;
          v26 += v17;
          v27 += v17;
          v29 += v17;
          v30 += v17;
          v31 += v17;
        }
        while (v32 > 2);
        if (v32)
        {
          int v37 = 0;
          uint64_t v38 = v13;
          do
          {
            float32x4_t v39 = vmulq_f32(v7, v28);
            float32x4_t v40 = vmulq_f32(v8, v23);
            float32x4_t v28 = v23;
            float32x4_t v23 = *(float32x4_t *)(v33 + 32 * v11);
            *(float32x4_t *)(v22 + v38) = vaddq_f32(vaddq_f32(v40, *(float32x4_t *)(v22 + v38)), vaddq_f32(v39, vmulq_f32(v9, v23)));
            v38 += v16;
            v33 += 16 * v11;
            ++v37;
          }
          while (v32 != v37);
        }
        ++v14;
        v13 += 16;
        v19 += 16;
      }
      while (v14 != v3);
    }
  }
  return 3;
}

uint64_t cadd4y(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 12);
    int v5 = *(_DWORD *)(a1 + 4);
    unsigned int v6 = v4 - v5;
    float32x4_t v7 = *a2;
    float32x4_t v8 = a2[1];
    float32x4_t v9 = a2[2];
    float32x4_t v10 = a2[3];
    uint64_t v11 = *(int *)(a1 + 24);
    uint64_t v12 = *(int *)(a1 + 88);
    uint64_t v13 = a3;
    if ((v4 - v5) < 4)
    {
      if (v6) {
        uint64_t v47 = 2 * v12;
      }
      else {
        uint64_t v47 = 0;
      }
      if (v6)
      {
        uint64_t v48 = 0;
        uint64_t v49 = 0;
        uint64_t v50 = 16 * v11;
        uint64_t v51 = 16 * v47 + 16 * a3 + 16 * v12;
        int v52 = v5 - v4;
        do
        {
          uint64_t v53 = *(void *)(a1 + 80);
          float32x4_t v54 = (float32x4_t *)(v53 + 16 * v49 + 16 * v13);
          float32x4_t v55 = v54[v12];
          float32x4_t v56 = *v54;
          float32x4_t v57 = v54[2 * v12];
          float32x4_t v58 = (float32x4_t *)(*(void *)(a1 + 16) + v48);
          float32x4_t v59 = (float32x4_t *)(v53 + v51);
          int v60 = v52;
          do
          {
            float32x4_t v61 = vmulq_f32(v7, v56);
            float32x4_t v62 = vmulq_f32(v8, v55);
            float32x4_t v56 = v55;
            float32x4_t v55 = v57;
            float32x4_t v57 = *v59;
            *float32x4_t v58 = vaddq_f32(vaddq_f32(v61, vmulq_f32(v9, v55)), vaddq_f32(vmulq_f32(v10, *v59), vaddq_f32(v62, *v58)));
            float32x4_t v58 = (float32x4_t *)((char *)v58 + v50);
            v59 += v12;
          }
          while (!__CFADD__(v60++, 1));
          ++v49;
          v48 += 16;
          v51 += 16;
        }
        while (v49 != v3);
      }
    }
    else
    {
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      uint64_t v16 = 2 * v11;
      uint64_t v17 = v11 << 6;
      uint64_t v18 = 16 * v11;
      uint64_t v19 = 16 * v16;
      uint64_t v20 = v12 << 6;
      uint64_t v21 = 16 * a3 + (v12 << 6);
      do
      {
        uint64_t v22 = *(void *)(a1 + 80);
        float32x4_t v23 = (float32x4_t *)(v22 + 16 * v15 + 16 * a3);
        float32x4_t v24 = v23[v12];
        float32x4_t v25 = v23[2 * v12];
        uint64_t v26 = *(void *)(a1 + 16);
        uint64_t v27 = v26 + v17 - v18;
        uint64_t v28 = v26 + v19;
        uint64_t v29 = v26 + v18;
        uint64_t v30 = v22 + 16 * a3;
        uint64_t v31 = v22 + v21 + 32 * v12;
        float32x4_t v32 = *v23;
        uint64_t v33 = v22 + v21 + 16 * v12;
        uint64_t v34 = v22 + v21;
        uint64_t v35 = v22 + v21 - 16 * v12;
        uint64_t v36 = v26 + v17;
        unsigned int v37 = v6;
        do
        {
          uint64_t v38 = v36;
          float32x4_t v39 = *(float32x4_t *)(v35 + v14);
          float32x4_t v40 = vaddq_f32(vaddq_f32(vmulq_f32(v7, v32), vmulq_f32(v9, v25)), vaddq_f32(vmulq_f32(v10, v39), vaddq_f32(vmulq_f32(v8, v24), *(float32x4_t *)(v26 + v14))));
          float32x4_t v32 = *(float32x4_t *)(v34 + v14);
          *(float32x4_t *)(v26 + v14) = v40;
          float32x4_t v41 = vaddq_f32(vaddq_f32(vmulq_f32(v7, v24), vmulq_f32(v9, v39)), vaddq_f32(vmulq_f32(v10, v32), vaddq_f32(vmulq_f32(v8, v25), *(float32x4_t *)(v29 + v14))));
          float32x4_t v24 = *(float32x4_t *)(v33 + v14);
          *(float32x4_t *)(v29 + v14) = v41;
          float32x4_t v42 = vaddq_f32(vaddq_f32(vmulq_f32(v7, v25), vmulq_f32(v9, v32)), vaddq_f32(vmulq_f32(v10, v24), vaddq_f32(vmulq_f32(v8, v39), *(float32x4_t *)(v28 + v14))));
          float32x4_t v25 = *(float32x4_t *)(v31 + v14);
          *(float32x4_t *)(v28 + v14) = v42;
          *(float32x4_t *)(v27 + v14) = vaddq_f32(vaddq_f32(vmulq_f32(v7, v39), vmulq_f32(v9, v24)), vaddq_f32(vmulq_f32(v10, v25), vaddq_f32(vmulq_f32(v8, v32), *(float32x4_t *)(v27 + v14))));
          v37 -= 4;
          v26 += v17;
          v27 += v17;
          v28 += v17;
          v29 += v17;
          v30 += v20;
          v31 += v20;
          v33 += v20;
          v34 += v20;
          v35 += v20;
          v36 += v17;
        }
        while (v37 > 3);
        if (v37)
        {
          int v43 = 0;
          int v44 = (float32x4_t *)(v30 + v14 + 32 * v12);
          do
          {
            float32x4_t v45 = vmulq_f32(v7, v32);
            float32x4_t v46 = vmulq_f32(v8, v24);
            float32x4_t v32 = v24;
            float32x4_t v24 = v25;
            v44 += v12;
            float32x4_t v25 = *v44;
            *(float32x4_t *)(v38 + v14) = vaddq_f32(vaddq_f32(v45, vmulq_f32(v9, v24)), vaddq_f32(vmulq_f32(v10, *v44), vaddq_f32(v46, *(float32x4_t *)(v38 + v14))));
            v38 += v18;
            ++v43;
          }
          while (v37 != v43);
        }
        ++v15;
        v14 += 16;
      }
      while (v15 != v3);
    }
  }
  return 4;
}

uint64_t cadd5y(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 12);
    int v5 = *(_DWORD *)(a1 + 4);
    unsigned int v6 = v4 - v5;
    float32x4_t v7 = *a2;
    float32x4_t v8 = a2[1];
    float32x4_t v9 = a2[2];
    uint64_t v10 = *(int *)(a1 + 24);
    uint64_t v11 = *(int *)(a1 + 88);
    if ((v4 - v5) < 3)
    {
      if (v6)
      {
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        uint64_t v42 = 16 * v10;
        int v43 = v5 - v4;
        uint64_t v44 = 16 * a3 + 32 * v11;
        do
        {
          uint64_t v45 = *(void *)(a1 + 80);
          float32x4_t v46 = (float32x4_t *)(v45 + 16 * v41 + 16 * a3);
          float32x4_t v47 = *v46;
          float32x4_t v48 = v46[v11];
          uint64_t v49 = (float32x4_t *)(*(void *)(a1 + 16) + v40);
          uint64_t v50 = (float32x4_t *)(v45 + v44);
          int v51 = v43;
          do
          {
            float32x4_t v52 = vmulq_f32(v7, v47);
            float32x4_t v53 = vmulq_f32(v8, v48);
            float32x4_t v47 = v48;
            float32x4_t v48 = *v50;
            *uint64_t v49 = vaddq_f32(vaddq_f32(v53, *v49), vaddq_f32(v52, vmulq_f32(v9, *v50)));
            uint64_t v49 = (float32x4_t *)((char *)v49 + v42);
            v50 += v11;
          }
          while (!__CFADD__(v51++, 1));
          ++v41;
          v40 += 16;
          v44 += 16;
        }
        while (v41 != v3);
      }
    }
    else
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = 48 * v10;
      uint64_t v15 = 16 * v10;
      uint64_t v16 = 48 * v11;
      uint64_t v17 = 16 * a3 + 48 * v11;
      uint64_t v18 = v17;
      do
      {
        uint64_t v19 = *(void *)(a1 + 80);
        uint64_t v20 = (float32x4_t *)(v19 + 16 * v13 + 16 * a3);
        uint64_t v21 = *(void *)(a1 + 16);
        float32x4_t v22 = v20[v11];
        uint64_t v23 = v21 + 32 * v10;
        uint64_t v24 = v21 + v15;
        uint64_t v25 = v19 + 16 * a3;
        uint64_t v26 = v19 + v17 + 16 * v11;
        float32x4_t v27 = *v20;
        uint64_t v28 = v19 + v17;
        uint64_t v29 = v19 + 16 * a3 + 32 * v11;
        uint64_t v30 = v19 + v18;
        unsigned int v31 = v6;
        do
        {
          uint64_t v32 = v30;
          float32x4_t v33 = *(float32x4_t *)(v29 + v12);
          float32x4_t v34 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v22), *(float32x4_t *)(v21 + v12)), vaddq_f32(vmulq_f32(v7, v27), vmulq_f32(v9, v33)));
          float32x4_t v27 = *(float32x4_t *)(v28 + v12);
          *(float32x4_t *)(v21 + v12) = v34;
          float32x4_t v35 = vaddq_f32(vaddq_f32(vmulq_f32(v7, v22), vmulq_f32(v9, v27)), vaddq_f32(vmulq_f32(v8, v33), *(float32x4_t *)(v24 + v12)));
          float32x4_t v22 = *(float32x4_t *)(v26 + v12);
          *(float32x4_t *)(v24 + v12) = v35;
          *(float32x4_t *)(v23 + v12) = vaddq_f32(vaddq_f32(vmulq_f32(v7, v33), vmulq_f32(v9, v22)), vaddq_f32(vmulq_f32(v8, v27), *(float32x4_t *)(v23 + v12)));
          v31 -= 3;
          v21 += v14;
          v23 += v14;
          v24 += v14;
          v25 += v16;
          v26 += v16;
          v28 += v16;
          v29 += v16;
          v30 += v16;
        }
        while (v31 > 2);
        if (v31)
        {
          int v36 = 0;
          uint64_t v37 = v12;
          do
          {
            float32x4_t v38 = vmulq_f32(v7, v27);
            float32x4_t v39 = vmulq_f32(v8, v22);
            float32x4_t v27 = v22;
            float32x4_t v22 = *(float32x4_t *)(v32 + 32 * v11);
            *(float32x4_t *)(v21 + v37) = vaddq_f32(vaddq_f32(v39, *(float32x4_t *)(v21 + v37)), vaddq_f32(v38, vmulq_f32(v9, v22)));
            v37 += v15;
            v32 += 16 * v11;
            ++v36;
          }
          while (v31 != v36);
        }
        ++v13;
        v12 += 16;
        v18 += 16;
      }
      while (v13 != v3);
    }
  }
  uint64_t v55 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v55)
  {
    unsigned int v56 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
    float32x4_t v57 = a2[3];
    float32x4_t v58 = a2[4];
    uint64_t v59 = *(int *)(a1 + 88);
    uint64_t v60 = 3 * (int)v59 + a3;
    if (v56 < 2)
    {
      if (v56)
      {
        uint64_t v77 = 0;
        uint64_t v78 = 16 * v60;
        uint64_t v79 = v78 + 16 * v59;
        do
        {
          *(float32x4_t *)(*(void *)(a1 + 16) + 16 * v77) = vaddq_f32(vmulq_f32(v58, *(float32x4_t *)(*(void *)(a1 + 80) + v79 + 16 * v77)), vaddq_f32(vmulq_f32(v57, *(float32x4_t *)(*(void *)(a1 + 80)+ v78+ 16 * v77)), *(float32x4_t *)(*(void *)(a1 + 16) + 16 * v77)));
          ++v77;
        }
        while (v55 != v77);
      }
    }
    else
    {
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      uint64_t v63 = *(int *)(a1 + 24);
      uint64_t v64 = 32 * v63;
      uint64_t v65 = 16 * v63;
      uint64_t v66 = 32 * v59;
      do
      {
        uint64_t v67 = *(void *)(a1 + 80);
        float32x4_t v68 = *(float32x4_t *)(v67 + 16 * v62 + 16 * v60);
        uint64_t v69 = *(void *)(a1 + 16);
        uint64_t v70 = v69 + v65;
        uint64_t v71 = v67 + 16 * v60;
        uint64_t v72 = v67 + 32 * v59 + 16 * v60;
        uint64_t v73 = v67 + 16 * v60 + 16 * v59;
        unsigned int v74 = v56;
        do
        {
          float32x4_t v75 = *(float32x4_t *)(v73 + v61);
          float32x4_t v76 = vaddq_f32(vmulq_f32(v57, v68), *(float32x4_t *)(v69 + v61));
          float32x4_t v68 = *(float32x4_t *)(v72 + v61);
          *(float32x4_t *)(v69 + v61) = vaddq_f32(vmulq_f32(v58, v75), v76);
          *(float32x4_t *)(v70 + v61) = vaddq_f32(vmulq_f32(v58, v68), vaddq_f32(vmulq_f32(v57, v75), *(float32x4_t *)(v70 + v61)));
          v74 -= 2;
          v69 += v64;
          v70 += v64;
          v71 += v66;
          v72 += v66;
          v73 += v66;
        }
        while (v74 > 1);
        if (v74) {
          *(float32x4_t *)(v69 + v61) = vaddq_f32(vmulq_f32(v58, *(float32x4_t *)(v71 + v61 + 16 * v59)), vaddq_f32(vmulq_f32(v57, v68), *(float32x4_t *)(v69 + v61)));
        }
        ++v62;
        v61 += 16;
      }
      while (v62 != v55);
    }
  }
  return 5;
}

uint64_t cadd6y(uint64_t a1, float32x4_t *a2, int a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 12);
    int v5 = *(_DWORD *)(a1 + 4);
    unsigned int v6 = v4 - v5;
    float32x4_t v7 = *a2;
    float32x4_t v8 = a2[1];
    float32x4_t v9 = a2[2];
    uint64_t v10 = *(int *)(a1 + 24);
    uint64_t v11 = *(int *)(a1 + 88);
    if ((v4 - v5) < 3)
    {
      if (v6)
      {
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        uint64_t v42 = 16 * v10;
        int v43 = v5 - v4;
        uint64_t v44 = 16 * a3 + 32 * v11;
        do
        {
          uint64_t v45 = *(void *)(a1 + 80);
          float32x4_t v46 = (float32x4_t *)(v45 + 16 * v41 + 16 * a3);
          float32x4_t v47 = *v46;
          float32x4_t v48 = v46[v11];
          uint64_t v49 = (float32x4_t *)(*(void *)(a1 + 16) + v40);
          uint64_t v50 = (float32x4_t *)(v45 + v44);
          int v51 = v43;
          do
          {
            float32x4_t v52 = vmulq_f32(v7, v47);
            float32x4_t v53 = vmulq_f32(v8, v48);
            float32x4_t v47 = v48;
            float32x4_t v48 = *v50;
            *uint64_t v49 = vaddq_f32(vaddq_f32(v53, *v49), vaddq_f32(v52, vmulq_f32(v9, *v50)));
            uint64_t v49 = (float32x4_t *)((char *)v49 + v42);
            v50 += v11;
            BOOL v54 = __CFADD__(v51++, 1);
          }
          while (!v54);
          ++v41;
          v40 += 16;
          v44 += 16;
        }
        while (v41 != v3);
      }
    }
    else
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = 48 * v10;
      uint64_t v15 = 16 * v10;
      uint64_t v16 = 48 * v11;
      uint64_t v17 = 16 * a3 + 48 * v11;
      uint64_t v18 = v17;
      do
      {
        uint64_t v19 = *(void *)(a1 + 80);
        uint64_t v20 = (float32x4_t *)(v19 + 16 * v13 + 16 * a3);
        uint64_t v21 = *(void *)(a1 + 16);
        float32x4_t v22 = v20[v11];
        uint64_t v23 = v21 + 32 * v10;
        uint64_t v24 = v21 + v15;
        uint64_t v25 = v19 + 16 * a3;
        uint64_t v26 = v19 + v17 + 16 * v11;
        float32x4_t v27 = *v20;
        uint64_t v28 = v19 + v17;
        uint64_t v29 = v19 + 16 * a3 + 32 * v11;
        uint64_t v30 = v19 + v18;
        unsigned int v31 = v6;
        do
        {
          uint64_t v32 = v30;
          float32x4_t v33 = *(float32x4_t *)(v29 + v12);
          float32x4_t v34 = vaddq_f32(vaddq_f32(vmulq_f32(v8, v22), *(float32x4_t *)(v21 + v12)), vaddq_f32(vmulq_f32(v7, v27), vmulq_f32(v9, v33)));
          float32x4_t v27 = *(float32x4_t *)(v28 + v12);
          *(float32x4_t *)(v21 + v12) = v34;
          float32x4_t v35 = vaddq_f32(vaddq_f32(vmulq_f32(v7, v22), vmulq_f32(v9, v27)), vaddq_f32(vmulq_f32(v8, v33), *(float32x4_t *)(v24 + v12)));
          float32x4_t v22 = *(float32x4_t *)(v26 + v12);
          *(float32x4_t *)(v24 + v12) = v35;
          *(float32x4_t *)(v23 + v12) = vaddq_f32(vaddq_f32(vmulq_f32(v7, v33), vmulq_f32(v9, v22)), vaddq_f32(vmulq_f32(v8, v27), *(float32x4_t *)(v23 + v12)));
          v31 -= 3;
          v21 += v14;
          v23 += v14;
          v24 += v14;
          v25 += v16;
          v26 += v16;
          v28 += v16;
          v29 += v16;
          v30 += v16;
        }
        while (v31 > 2);
        if (v31)
        {
          int v36 = 0;
          uint64_t v37 = v12;
          do
          {
            float32x4_t v38 = vmulq_f32(v7, v27);
            float32x4_t v39 = vmulq_f32(v8, v22);
            float32x4_t v27 = v22;
            float32x4_t v22 = *(float32x4_t *)(v32 + 32 * v11);
            *(float32x4_t *)(v21 + v37) = vaddq_f32(vaddq_f32(v39, *(float32x4_t *)(v21 + v37)), vaddq_f32(v38, vmulq_f32(v9, v22)));
            v37 += v15;
            v32 += 16 * v11;
            ++v36;
          }
          while (v31 != v36);
        }
        ++v13;
        v12 += 16;
        v18 += 16;
      }
      while (v13 != v3);
    }
  }
  uint64_t v55 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v55)
  {
    int v56 = *(_DWORD *)(a1 + 12);
    int v57 = *(_DWORD *)(a1 + 4);
    unsigned int v58 = v56 - v57;
    float32x4_t v59 = a2[3];
    float32x4_t v60 = a2[4];
    float32x4_t v61 = a2[5];
    uint64_t v62 = *(int *)(a1 + 88);
    uint64_t v63 = *(int *)(a1 + 24);
    uint64_t v64 = 3 * (int)v62 + a3;
    if ((v56 - v57) < 3)
    {
      if (v58)
      {
        uint64_t v94 = 0;
        uint64_t v95 = 0;
        uint64_t v96 = 16 * v63;
        int v97 = v57 - v56;
        uint64_t v98 = 32 * v62 + 16 * v64;
        do
        {
          uint64_t v99 = *(void *)(a1 + 80);
          uint64_t v100 = (float32x4_t *)(v99 + 16 * v95 + 16 * v64);
          float32x4_t v101 = *v100;
          float32x4_t v102 = v100[v62];
          unsigned int v103 = (float32x4_t *)(*(void *)(a1 + 16) + v94);
          int v104 = (float32x4_t *)(v99 + v98);
          int v105 = v97;
          do
          {
            float32x4_t v106 = vmulq_f32(v59, v101);
            float32x4_t v107 = vmulq_f32(v60, v102);
            float32x4_t v101 = v102;
            float32x4_t v102 = *v104;
            *unsigned int v103 = vaddq_f32(vaddq_f32(v107, *v103), vaddq_f32(v106, vmulq_f32(v61, *v104)));
            unsigned int v103 = (float32x4_t *)((char *)v103 + v96);
            v104 += v62;
            BOOL v54 = __CFADD__(v105++, 1);
          }
          while (!v54);
          ++v95;
          v94 += 16;
          v98 += 16;
        }
        while (v95 != v55);
      }
    }
    else
    {
      uint64_t v65 = 0;
      uint64_t v66 = 0;
      uint64_t v67 = 48 * v63;
      uint64_t v68 = 32 * v63;
      uint64_t v69 = 16 * v63;
      uint64_t v70 = 48 * v62;
      uint64_t v71 = 48 * v62 + 16 * v64;
      uint64_t v72 = v71;
      do
      {
        uint64_t v73 = *(void *)(a1 + 80);
        unsigned int v74 = (float32x4_t *)(v73 + 16 * v66 + 16 * v64);
        uint64_t v75 = *(void *)(a1 + 16);
        float32x4_t v76 = v74[v62];
        uint64_t v77 = v75 + v68;
        uint64_t v78 = v75 + v69;
        uint64_t v79 = v73 + 16 * v64;
        uint64_t v80 = v73 + v71 + 16 * v62;
        float32x4_t v81 = *v74;
        uint64_t v82 = v73 + v71;
        uint64_t v83 = v73 + 16 * v64 + 32 * v62;
        uint64_t v84 = v73 + v72;
        unsigned int v85 = v58;
        do
        {
          uint64_t v86 = v84;
          float32x4_t v87 = *(float32x4_t *)(v83 + v65);
          float32x4_t v88 = vaddq_f32(vaddq_f32(vmulq_f32(v60, v76), *(float32x4_t *)(v75 + v65)), vaddq_f32(vmulq_f32(v59, v81), vmulq_f32(v61, v87)));
          float32x4_t v81 = *(float32x4_t *)(v82 + v65);
          *(float32x4_t *)(v75 + v65) = v88;
          float32x4_t v89 = vaddq_f32(vaddq_f32(vmulq_f32(v59, v76), vmulq_f32(v61, v81)), vaddq_f32(vmulq_f32(v60, v87), *(float32x4_t *)(v78 + v65)));
          float32x4_t v76 = *(float32x4_t *)(v80 + v65);
          *(float32x4_t *)(v78 + v65) = v89;
          *(float32x4_t *)(v77 + v65) = vaddq_f32(vaddq_f32(vmulq_f32(v59, v87), vmulq_f32(v61, v76)), vaddq_f32(vmulq_f32(v60, v81), *(float32x4_t *)(v77 + v65)));
          v85 -= 3;
          v75 += v67;
          v77 += v67;
          v78 += v67;
          v79 += v70;
          v80 += v70;
          v82 += v70;
          v83 += v70;
          v84 += v70;
        }
        while (v85 > 2);
        if (v85)
        {
          int v90 = 0;
          uint64_t v91 = v65;
          do
          {
            float32x4_t v92 = vmulq_f32(v59, v81);
            float32x4_t v93 = vmulq_f32(v60, v76);
            float32x4_t v81 = v76;
            float32x4_t v76 = *(float32x4_t *)(v86 + 32 * v62);
            *(float32x4_t *)(v75 + v91) = vaddq_f32(vaddq_f32(v93, *(float32x4_t *)(v75 + v91)), vaddq_f32(v92, vmulq_f32(v61, v76)));
            v91 += v69;
            v86 += 16 * v62;
            ++v90;
          }
          while (v85 != v90);
        }
        ++v66;
        v65 += 16;
        v72 += 16;
      }
      while (v66 != v55);
    }
  }
  return 6;
}

uint64_t cadd7y(uint64_t a1, float32x4_t *a2, int a3)
{
  cadd4y(a1, a2, a3);
  uint64_t v6 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
  if (v6)
  {
    int v7 = *(_DWORD *)(a1 + 12);
    int v8 = *(_DWORD *)(a1 + 4);
    unsigned int v9 = v7 - v8;
    float32x4_t v10 = a2[4];
    float32x4_t v11 = a2[5];
    float32x4_t v12 = a2[6];
    uint64_t v13 = *(int *)(a1 + 88);
    uint64_t v14 = *(int *)(a1 + 24);
    uint64_t v15 = a3 + 4 * (int)v13;
    if ((v7 - v8) < 3)
    {
      if (v9)
      {
        uint64_t v45 = 0;
        uint64_t v46 = 0;
        uint64_t v47 = 16 * v14;
        int v48 = v8 - v7;
        uint64_t v49 = 32 * v13 + 16 * v15;
        do
        {
          uint64_t v50 = *(void *)(a1 + 80);
          int v51 = (float32x4_t *)(v50 + 16 * v46 + 16 * v15);
          float32x4_t v52 = *v51;
          float32x4_t v53 = v51[v13];
          BOOL v54 = (float32x4_t *)(*(void *)(a1 + 16) + v45);
          uint64_t v55 = (float32x4_t *)(v50 + v49);
          int v56 = v48;
          do
          {
            float32x4_t v57 = vmulq_f32(v10, v52);
            float32x4_t v58 = vmulq_f32(v11, v53);
            float32x4_t v52 = v53;
            float32x4_t v53 = *v55;
            *BOOL v54 = vaddq_f32(vaddq_f32(v58, *v54), vaddq_f32(v57, vmulq_f32(v12, *v55)));
            BOOL v54 = (float32x4_t *)((char *)v54 + v47);
            v55 += v13;
          }
          while (!__CFADD__(v56++, 1));
          ++v46;
          v45 += 16;
          v49 += 16;
        }
        while (v46 != v6);
      }
    }
    else
    {
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      uint64_t v18 = 48 * v14;
      uint64_t v19 = 32 * v14;
      uint64_t v20 = 16 * v14;
      uint64_t v21 = 48 * v13;
      uint64_t v22 = v21 + 16 * v15;
      uint64_t v23 = v22;
      do
      {
        uint64_t v24 = *(void *)(a1 + 80);
        uint64_t v25 = (float32x4_t *)(v24 + 16 * v17 + 16 * v15);
        uint64_t v26 = *(void *)(a1 + 16);
        float32x4_t v27 = v25[v13];
        uint64_t v28 = v26 + v19;
        uint64_t v29 = v26 + v20;
        uint64_t v30 = v24 + 16 * v15;
        uint64_t v31 = v24 + v22 + 16 * v13;
        float32x4_t v32 = *v25;
        uint64_t v33 = v24 + v22;
        uint64_t v34 = v24 + 16 * v15 + 32 * v13;
        uint64_t v35 = v24 + v23;
        unsigned int v36 = v9;
        do
        {
          uint64_t v37 = v35;
          float32x4_t v38 = *(float32x4_t *)(v34 + v16);
          float32x4_t v39 = vaddq_f32(vaddq_f32(vmulq_f32(v11, v27), *(float32x4_t *)(v26 + v16)), vaddq_f32(vmulq_f32(v10, v32), vmulq_f32(v12, v38)));
          float32x4_t v32 = *(float32x4_t *)(v33 + v16);
          *(float32x4_t *)(v26 + v16) = v39;
          float32x4_t v40 = vaddq_f32(vaddq_f32(vmulq_f32(v10, v27), vmulq_f32(v12, v32)), vaddq_f32(vmulq_f32(v11, v38), *(float32x4_t *)(v29 + v16)));
          float32x4_t v27 = *(float32x4_t *)(v31 + v16);
          *(float32x4_t *)(v29 + v16) = v40;
          *(float32x4_t *)(v28 + v16) = vaddq_f32(vaddq_f32(vmulq_f32(v10, v38), vmulq_f32(v12, v27)), vaddq_f32(vmulq_f32(v11, v32), *(float32x4_t *)(v28 + v16)));
          v36 -= 3;
          v26 += v18;
          v28 += v18;
          v29 += v18;
          v30 += v21;
          v31 += v21;
          v33 += v21;
          v34 += v21;
          v35 += v21;
        }
        while (v36 > 2);
        if (v36)
        {
          int v41 = 0;
          uint64_t v42 = v16;
          do
          {
            float32x4_t v43 = vmulq_f32(v10, v32);
            float32x4_t v44 = vmulq_f32(v11, v27);
            float32x4_t v32 = v27;
            float32x4_t v27 = *(float32x4_t *)(v37 + 32 * v13);
            *(float32x4_t *)(v26 + v42) = vaddq_f32(vaddq_f32(v44, *(float32x4_t *)(v26 + v42)), vaddq_f32(v43, vmulq_f32(v12, v27)));
            v42 += v20;
            v37 += 16 * v13;
            ++v41;
          }
          while (v36 != v41);
        }
        ++v17;
        v16 += 16;
        v23 += 16;
      }
      while (v17 != v6);
    }
  }
  return 7;
}

void HGConvolutionShader::~HGConvolutionShader(HGNode *this)
{
  *(void *)this = &unk_1F10DE0E8;
  uint64_t v2 = *((void *)this + 54);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1080C4057E67DB5);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10DE0E8;
  uint64_t v2 = *((void *)this + 54);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1080C4057E67DB5);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGConvolutionShader::addRound(HGConvolutionShader *this, const HGLinearFilter2D *a2, int a3, int a4, int a5, char a6)
{
  int v9 = *((_DWORD *)this + 110);
  uint64_t v10 = *((void *)this + 54);
  if (!v10) {
    operator new[]();
  }
  if (a6)
  {
    int v11 = *((_DWORD *)this + 110);
    uint64_t v12 = v11;
    uint64_t v13 = (_DWORD *)(v10 + 16 * v11);
    *uint64_t v13 = a3;
    v13[1] = a4;
    uint64_t v14 = a5;
    uint64_t v15 = &cx[v14];
    uint64_t v16 = &caddx[v14];
    if (!v9) {
      uint64_t v16 = v15;
    }
    goto LABEL_55;
  }
  int v18 = *((_DWORD *)a2 + 2);
  int v17 = *((_DWORD *)a2 + 3);
  if (v17 >= a4)
  {
    int v11 = *((_DWORD *)this + 110);
    int v46 = *((_DWORD *)a2 + 3);
    uint64_t v12 = v11;
    int v47 = a3 - v18;
    if (a3 <= v18) {
      goto LABEL_30;
    }
  }
  else
  {
    int v19 = v18 + *((_DWORD *)a2 + 4);
    int v20 = v19 - 1;
    int v21 = v19 - 6;
    int v11 = *((_DWORD *)this + 110);
    if (v18 < v21)
    {
      int v22 = v18 + 4;
      if (v21 <= v18 + 8) {
        int v23 = v18 + 8;
      }
      else {
        int v23 = v21;
      }
      unsigned int v24 = v23 - v18 - 5;
      uint64_t v25 = (v24 >> 2) + 1;
      uint64_t v26 = v25 & 0x7FFFFFFE;
      int v27 = 4 * (v25 & 0x7FFFFFFE);
      int v28 = v22 + v27;
      int v29 = v18 + v27;
      uint64_t v30 = c4x;
      int v31 = v17;
      while (1)
      {
        while (1)
        {
          uint64_t v35 = v11;
          uint64_t v36 = v10 + 16 * v11;
          *(_DWORD *)uint64_t v36 = v18;
          *(_DWORD *)(v36 + 4) = v31;
          *(void *)(v36 + 8) = v30;
          uint64_t v37 = v11 + 1;
          if (v22 < v21) {
            break;
          }
          int v42 = v18;
          int v38 = v18 + 4;
          int v43 = v20 - v22;
          if (v20 - v22 <= 3) {
            goto LABEL_27;
          }
LABEL_13:
          uint64_t v32 = v10 + 16 * (int)v37;
          *(_DWORD *)uint64_t v32 = v38;
          *(_DWORD *)(v32 + 4) = v31;
          *(void *)(v32 + 8) = cadd3x;
          uint64_t v33 = (int)v35 + 2;
          uint64_t v34 = v10 + 16 * v33;
          *(_DWORD *)uint64_t v34 = v42 + 7;
          *(_DWORD *)(v34 + 4) = v31;
          *(void *)(v34 + 8) = caddx[v43 - 2];
          int v11 = v33 + 1;
          ++v31;
          uint64_t v30 = cadd4x;
          if (v31 == a4) {
            goto LABEL_42;
          }
        }
        int v38 = v18 + 4;
        if (v24 < 4) {
          goto LABEL_24;
        }
        v37 += v26;
        int v39 = v18 + 8;
        uint64_t v40 = v25 & 0x7FFFFFFE;
        uint64_t v41 = v10 + 20 + 16 * v35;
        do
        {
          *(_DWORD *)(v41 - 4) = v39 - 4;
          *(_DWORD *)uint64_t v41 = v31;
          *(_DWORD *)(v41 + 12) = v39;
          *(_DWORD *)(v41 + 16) = v31;
          *(void *)(v41 + 4) = cadd4x;
          *(void *)(v41 + 20) = cadd4x;
          v39 += 8;
          v41 += 32;
          v40 -= 2;
        }
        while (v40);
        if (v26 != v25) {
          break;
        }
        LODWORD(v35) = v26 + v35;
        int v42 = v29;
        int v38 = v28;
        int v43 = v20 - v28;
        if (v20 - v28 > 3) {
          goto LABEL_13;
        }
LABEL_27:
        uint64_t v45 = v10 + 16 * (int)v37;
        *(_DWORD *)uint64_t v45 = v38;
        *(_DWORD *)(v45 + 4) = v31;
        *(void *)(v45 + 8) = caddx[v43 + 1];
        int v11 = v37 + 1;
        ++v31;
        uint64_t v30 = cadd4x;
        if (v31 == a4) {
          goto LABEL_42;
        }
      }
      int v38 = v28;
LABEL_24:
      uint64_t v44 = v10 + 4 + 16 * v37;
      do
      {
        *(_DWORD *)(v44 - 4) = v38;
        *(_DWORD *)uint64_t v44 = v31;
        *(void *)(v44 + 4) = cadd4x;
        LODWORD(v37) = v37 + 1;
        v38 += 4;
        v44 += 16;
      }
      while (v38 < v21);
      LODWORD(v35) = v37 - 1;
      int v42 = v38 - 4;
      int v43 = v20 - v38;
      if (v20 - v38 <= 3) {
        goto LABEL_27;
      }
      goto LABEL_13;
    }
    int v52 = v20 - v18;
    if (v20 - v18 >= 4)
    {
      int v53 = v18 + 3;
      BOOL v54 = caddx[v52 - 2];
      uint64_t v55 = v10 + 16 * v11;
      *(_DWORD *)uint64_t v55 = v18;
      *(_DWORD *)(v55 + 4) = v17;
      *(void *)(v55 + 8) = c3x;
      *(_DWORD *)(v55 + 16) = v18 + 3;
      *(_DWORD *)(v55 + 20) = v17;
      *(void *)(v55 + 24) = v54;
      uint64_t v56 = v11 + 2;
      int v57 = v17 + 1;
      if (v17 + 1 != a4)
      {
        if (a4 - 2 == v17) {
          goto LABEL_39;
        }
        uint64_t v58 = (a4 - 2 - v17) + 1;
        v56 += 2 * (v58 & 0x1FFFFFFFELL);
        v57 += v58 & 0xFFFFFFFE;
        uint64_t v59 = v10 + 16 * v11 + 48;
        int v60 = v17 + 2;
        uint64_t v61 = v58 & 0x1FFFFFFFELL;
        do
        {
          *(_DWORD *)(v59 - 16) = v18;
          *(_DWORD *)(v59 - 12) = v60 - 1;
          *(_DWORD *)(v59 + 16) = v18;
          *(_DWORD *)(v59 + 20) = v60;
          *(void *)(v59 - 8) = cadd3x;
          *(void *)(v59 + 24) = cadd3x;
          *(_DWORD *)uint64_t v59 = v53;
          *(_DWORD *)(v59 + 4) = v60 - 1;
          *(_DWORD *)(v59 + 32) = v53;
          *(_DWORD *)(v59 + 36) = v60;
          *(void *)(v59 + 8) = v54;
          *(void *)(v59 + 40) = v54;
          v59 += 64;
          v60 += 2;
          v61 -= 2;
        }
        while (v61);
        if (v58 != (v58 & 0x1FFFFFFFELL))
        {
LABEL_39:
          uint64_t v62 = v10 + 16 * v56 + 16;
          do
          {
            *(_DWORD *)(v62 - 16) = v18;
            *(_DWORD *)(v62 - 12) = v57;
            *(void *)(v62 - 8) = cadd3x;
            *(_DWORD *)uint64_t v62 = v53;
            *(_DWORD *)(v62 + 4) = v57;
            *(void *)(v62 + 8) = v54;
            LODWORD(v56) = v56 + 2;
            ++v57;
            v62 += 32;
          }
          while (a4 != v57);
        }
      }
      int v11 = v56;
LABEL_42:
      int v46 = a4;
      uint64_t v12 = v11;
      int v47 = a3 - v18;
      if (a3 > v18) {
        goto LABEL_43;
      }
LABEL_30:
      int v48 = (_DWORD *)(v10 + 16 * v12);
      *int v48 = a3;
      v48[1] = a4;
      uint64_t v49 = a5;
      uint64_t v50 = &cx[v49];
      int v51 = &caddx[v49];
      if (v17 >= a4) {
        uint64_t v16 = v50;
      }
      else {
        uint64_t v16 = v51;
      }
      goto LABEL_55;
    }
    uint64_t v72 = v52 + 1;
    uint64_t v73 = v10 + 16 * v11;
    *(_DWORD *)uint64_t v73 = v18;
    *(_DWORD *)(v73 + 4) = v17;
    *(void *)(v73 + 8) = cx[v72];
    uint64_t v12 = v11 + 1;
    int v74 = v17 + 1;
    if (v17 + 1 != a4)
    {
      uint64_t v75 = caddx[v72];
      if (a4 - 2 == v17) {
        goto LABEL_61;
      }
      uint64_t v76 = (a4 - 2 - v17) + 1;
      v12 += v76 & 0x1FFFFFFFELL;
      v74 += v76 & 0xFFFFFFFE;
      int v77 = v17 + 2;
      uint64_t v78 = v10 + 16 * v11 + 20;
      uint64_t v79 = v76 & 0x1FFFFFFFELL;
      do
      {
        *(_DWORD *)(v78 - 4) = v18;
        *(_DWORD *)uint64_t v78 = v77 - 1;
        *(_DWORD *)(v78 + 12) = v18;
        *(_DWORD *)(v78 + 16) = v77;
        v77 += 2;
        *(void *)(v78 + 4) = v75;
        *(void *)(v78 + 20) = v75;
        v78 += 32;
        v79 -= 2;
      }
      while (v79);
      if (v76 != (v76 & 0x1FFFFFFFELL))
      {
LABEL_61:
        uint64_t v80 = v10 + 16 * v12 + 4;
        do
        {
          *(_DWORD *)(v80 - 4) = v18;
          *(_DWORD *)uint64_t v80 = v74;
          *(void *)(v80 + 4) = v75;
          LODWORD(v12) = v12 + 1;
          ++v74;
          v80 += 16;
        }
        while (a4 != v74);
      }
    }
    int v11 = v12;
    int v46 = a4;
    uint64_t v12 = (int)v12;
    int v47 = a3 - v18;
    if (a3 <= v18) {
      goto LABEL_30;
    }
  }
LABEL_43:
  if (v47 >= 4) {
    int v63 = 4;
  }
  else {
    int v63 = v47;
  }
  uint64_t v64 = v10 + 16 * v12;
  *(_DWORD *)uint64_t v64 = v18;
  *(_DWORD *)(v64 + 4) = v46;
  if (v17 >= a4) {
    uint64_t v65 = cx;
  }
  else {
    uint64_t v65 = caddx;
  }
  *(void *)(v64 + 8) = v65[v63];
  int v11 = v12 + 1;
  int v66 = v63 + v18;
  if (v63 + v18 < a3)
  {
    uint64_t v67 = (uint64_t (**)())(v64 + 24);
    do
    {
      int v68 = a3 - v66;
      if (a3 - v66 >= 4) {
        int v68 = 4;
      }
      uint64_t v69 = caddx[v68];
      *((_DWORD *)v67 - 2) = v66;
      *((_DWORD *)v67 - 1) = v46;
      *uint64_t v67 = v69;
      v67 += 2;
      ++v11;
      v66 += v68;
    }
    while (v66 < a3);
  }
  uint64_t v12 = v11;
  uint64_t v70 = (_DWORD *)(v10 + 16 * v11);
  *uint64_t v70 = a3;
  v70[1] = a4;
  uint64_t v16 = &caddx[a5];
LABEL_55:
  *(void *)(v10 + 16 * v12 + 8) = *v16;
  *((_DWORD *)this + 110) = v11 + 1;
  return 1;
}

uint64_t HGConvolutionShader::GetDOD(HGConvolutionShader *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  if (HGRectIsNull(*(uint64_t *)&a4.var0, *(uint64_t *)&a4.var2)) {
    return 0;
  }
  uint64_t v8 = HGRectMake4i(*((_DWORD *)this + 104), *((_DWORD *)this + 105), *((_DWORD *)this + 104) + *((_DWORD *)this + 102) - 1, *((_DWORD *)this + 105) + *((_DWORD *)this + 103) - 1);
  return HGRectGrow(v5, v4, v8);
}

uint64_t HGConvolutionShader::GetROI(HGConvolutionShader *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1) {
    return HGRectMake4i(0, 0, *((_DWORD *)this + 103) * *((_DWORD *)this + 102), 1u);
  }
  if (a3) {
    return 0;
  }
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  uint64_t v6 = HGRectMake4i(*((_DWORD *)this + 104), *((_DWORD *)this + 105), *((_DWORD *)this + 104) + *((_DWORD *)this + 102) - 1, *((_DWORD *)this + 105) + *((_DWORD *)this + 103) - 1);
  return HGRectGrow(v5, v4, v6);
}

uint64_t HGConvolutionShader::compile(HGConvolutionShader *this, const HGLinearFilter2D *a2, char *a3, int a4, char a5)
{
  int v5 = (int)a3;
  uint64_t v8 = *(float32x4_t **)a2;
  *((void *)this + 53) = *(void *)a2;
  uint64_t v9 = *((void *)a2 + 2);
  *((void *)this + 51) = v9;
  int v10 = *((_DWORD *)a2 + 2);
  int v11 = *((_DWORD *)a2 + 3);
  *((_DWORD *)this + 104) = v10;
  *((_DWORD *)this + 105) = v11;
  int v12 = v9;
  int v55 = a4;
  if (v11 >= a4)
  {
    int v14 = v10;
    int v55 = v11;
    if ((int)v9 < 1) {
      goto LABEL_48;
    }
    goto LABEL_6;
  }
  int v54 = (int)a3;
  int v13 = v9 + v10 - 1;
  if (v10 > v13)
  {
    uint64_t v8 = (float32x4_t *)((char *)v8 + (16 * (~v11 + a4) + 16) * (int)v9);
    if ((int)v9 > 0)
    {
      int v14 = v10;
      int v5 = (int)a3;
      goto LABEL_6;
    }
    unsigned __int8 v17 = 0;
    int v14 = v10;
    int v5 = (int)a3;
    if (v10 < (int)a3) {
      goto LABEL_50;
    }
    goto LABEL_67;
  }
  int v14 = v10;
  while (2)
  {
    unsigned int v26 = v12 - 1;
    if (v12 < 1)
    {
      unsigned __int8 v28 = 0;
    }
    else
    {
      if (v26 >= 7) {
        unsigned int v26 = 7;
      }
      int8x16_t v27 = (int8x16_t)vceqzq_f32(*v8);
      *(int32x2_t *)v27.i8 = vpmax_s32(*(int32x2_t *)v27.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL));
      unsigned __int8 v28 = vpmax_s32(*(int32x2_t *)v27.i8, *(int32x2_t *)v27.i8).u32[0] == 0;
      if (v26)
      {
        unsigned int v29 = v26 + 1;
        int8x16_t v30 = (int8x16_t)vceqzq_f32(v8[1]);
        *(int32x2_t *)v30.i8 = vpmax_s32(*(int32x2_t *)v30.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
        v28 |= 2 * (vpmax_s32(*(int32x2_t *)v30.i8, *(int32x2_t *)v30.i8).u32[0] == 0);
        if (v29 != 2)
        {
          int8x16_t v31 = (int8x16_t)vceqzq_f32(v8[2]);
          *(int32x2_t *)v31.i8 = vpmax_s32(*(int32x2_t *)v31.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
          v28 |= 4 * (vpmax_s32(*(int32x2_t *)v31.i8, *(int32x2_t *)v31.i8).u32[0] == 0);
          if (v29 != 3)
          {
            int8x16_t v32 = (int8x16_t)vceqzq_f32(v8[3]);
            *(int32x2_t *)v32.i8 = vpmax_s32(*(int32x2_t *)v32.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
            v28 |= 8 * (vpmax_s32(*(int32x2_t *)v32.i8, *(int32x2_t *)v32.i8).u32[0] == 0);
            if (v29 != 4)
            {
              int8x16_t v33 = (int8x16_t)vceqzq_f32(v8[4]);
              *(int32x2_t *)v33.i8 = vpmax_s32(*(int32x2_t *)v33.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
              v28 |= 16 * (vpmax_s32(*(int32x2_t *)v33.i8, *(int32x2_t *)v33.i8).u32[0] == 0);
              if (v29 != 5)
              {
                int8x16_t v34 = (int8x16_t)vceqzq_f32(v8[5]);
                *(int32x2_t *)v34.i8 = vpmax_s32(*(int32x2_t *)v34.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
                v28 |= 32 * (vpmax_s32(*(int32x2_t *)v34.i8, *(int32x2_t *)v34.i8).u32[0] == 0);
                if (v29 != 6)
                {
                  int8x16_t v35 = (int8x16_t)vceqzq_f32(v8[6]);
                  *(int32x2_t *)v35.i8 = vpmax_s32(*(int32x2_t *)v35.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL));
                  v28 |= (vpmax_s32(*(int32x2_t *)v35.i8, *(int32x2_t *)v35.i8).u32[0] == 0) << 6;
                  if (v29 != 7)
                  {
                    int8x16_t v36 = (int8x16_t)vceqzq_f32(v8[7]);
                    *(int32x2_t *)v36.i8 = vpmax_s32(*(int32x2_t *)v36.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL));
                    v28 |= (vpmax_s32(*(int32x2_t *)v36.i8, *(int32x2_t *)v36.i8).u32[0] == 0) << 7;
                  }
                }
              }
            }
          }
        }
      }
    }
    int v37 = v10;
    do
    {
      if ((v28 & 1) == 0)
      {
        int v39 = 1;
        if ((a5 & 1) == 0) {
          HGConvolutionShader::compile(this, a2, v37, v11, 1);
        }
        goto LABEL_42;
      }
      int v39 = lut[v28 >> 1];
      if (a5) {
        goto LABEL_41;
      }
      int v40 = v14 + v12 + ~v37;
      if (v40 >= 3) {
        int v40 = 3;
      }
      if (v39 <= v40)
      {
LABEL_41:
        HGConvolutionShader::addRound(this, a2, v37, v11, v39, a5 & 1);
LABEL_42:
        a5 = 1;
        goto LABEL_43;
      }
      a5 = 0;
LABEL_43:
      int v14 = *((_DWORD *)a2 + 2);
      int v12 = *((_DWORD *)a2 + 4);
      int v41 = v39 - 1;
      int v42 = v37 + v39;
      int v43 = 8 - v10 + v37;
      int v44 = ~v37 + v14 + v12;
      do
      {
        v28 >>= 1;
        if (v44 >= 8)
        {
          int8x16_t v45 = (int8x16_t)vceqzq_f32(v8[v43]);
          *(int32x2_t *)v45.i8 = vpmax_s32(*(int32x2_t *)v45.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL));
          v28 |= (vpmax_s32(*(int32x2_t *)v45.i8, *(int32x2_t *)v45.i8).u32[0] == 0) << 7;
        }
        ++v43;
        --v44;
        --v39;
      }
      while (v39);
      int v38 = v37 + v41;
      int v37 = v42;
    }
    while (v38 < v13);
    v8 += v12;
    if (++v11 != v55) {
      continue;
    }
    break;
  }
  int v5 = v54;
  if (v12 < 1)
  {
LABEL_48:
    unsigned __int8 v17 = 0;
    goto LABEL_49;
  }
LABEL_6:
  int v15 = v12 - 1;
  if ((v12 - 1) >= 7) {
    int v15 = 7;
  }
  int8x16_t v16 = (int8x16_t)vceqzq_f32(*v8);
  *(int32x2_t *)v16.i8 = vpmax_s32(*(int32x2_t *)v16.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL));
  unsigned __int8 v17 = vpmax_s32(*(int32x2_t *)v16.i8, *(int32x2_t *)v16.i8).u32[0] == 0;
  if (v15)
  {
    int v18 = v15 + 1;
    int8x16_t v19 = (int8x16_t)vceqzq_f32(v8[1]);
    *(int32x2_t *)v19.i8 = vpmax_s32(*(int32x2_t *)v19.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL));
    v17 |= 2 * (vpmax_s32(*(int32x2_t *)v19.i8, *(int32x2_t *)v19.i8).u32[0] == 0);
    if (v18 != 2)
    {
      int8x16_t v20 = (int8x16_t)vceqzq_f32(v8[2]);
      *(int32x2_t *)v20.i8 = vpmax_s32(*(int32x2_t *)v20.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL));
      v17 |= 4 * (vpmax_s32(*(int32x2_t *)v20.i8, *(int32x2_t *)v20.i8).u32[0] == 0);
      if (v18 != 3)
      {
        int8x16_t v21 = (int8x16_t)vceqzq_f32(v8[3]);
        *(int32x2_t *)v21.i8 = vpmax_s32(*(int32x2_t *)v21.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
        v17 |= 8 * (vpmax_s32(*(int32x2_t *)v21.i8, *(int32x2_t *)v21.i8).u32[0] == 0);
        if (v18 != 4)
        {
          int8x16_t v22 = (int8x16_t)vceqzq_f32(v8[4]);
          *(int32x2_t *)v22.i8 = vpmax_s32(*(int32x2_t *)v22.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
          v17 |= 16 * (vpmax_s32(*(int32x2_t *)v22.i8, *(int32x2_t *)v22.i8).u32[0] == 0);
          if (v18 != 5)
          {
            int8x16_t v23 = (int8x16_t)vceqzq_f32(v8[5]);
            *(int32x2_t *)v23.i8 = vpmax_s32(*(int32x2_t *)v23.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL));
            v17 |= 32 * (vpmax_s32(*(int32x2_t *)v23.i8, *(int32x2_t *)v23.i8).u32[0] == 0);
            if (v18 != 6)
            {
              int8x16_t v24 = (int8x16_t)vceqzq_f32(v8[6]);
              *(int32x2_t *)v24.i8 = vpmax_s32(*(int32x2_t *)v24.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
              v17 |= (vpmax_s32(*(int32x2_t *)v24.i8, *(int32x2_t *)v24.i8).u32[0] == 0) << 6;
              if (v18 != 7)
              {
                int8x16_t v25 = (int8x16_t)vceqzq_f32(v8[7]);
                *(int32x2_t *)v25.i8 = vpmax_s32(*(int32x2_t *)v25.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL));
                v17 |= (vpmax_s32(*(int32x2_t *)v25.i8, *(int32x2_t *)v25.i8).u32[0] == 0) << 7;
                if (v10 >= v5) {
                  goto LABEL_67;
                }
LABEL_50:
                int v46 = 8 - v10;
                while (2)
                {
                  if (v17)
                  {
                    int v47 = lut[v17 >> 1];
                    if (a5) {
                      goto LABEL_60;
                    }
                    int v48 = v14 + v12 + ~v10;
                    if (v48 >= 3) {
                      int v48 = 3;
                    }
                    if (v47 <= v48)
                    {
LABEL_60:
                      HGConvolutionShader::addRound(this, a2, v10, v55, v47, a5 & 1);
                      goto LABEL_61;
                    }
                    a5 = 0;
                  }
                  else
                  {
                    int v47 = 1;
                    if ((a5 & 1) == 0) {
                      HGConvolutionShader::compile(this, a2, v10, v55, 1);
                    }
LABEL_61:
                    a5 = 1;
                  }
                  int v14 = *((_DWORD *)a2 + 2);
                  int v12 = *((_DWORD *)a2 + 4);
                  int v49 = v46 + v10;
                  int v50 = ~v10 + v14 + v12;
                  int v51 = v47;
                  do
                  {
                    v17 >>= 1;
                    if (v50 >= 8)
                    {
                      int8x16_t v52 = (int8x16_t)vceqzq_f32(v8[v49]);
                      *(int32x2_t *)v52.i8 = vpmax_s32(*(int32x2_t *)v52.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v52, v52, 8uLL));
                      v17 |= (vpmax_s32(*(int32x2_t *)v52.i8, *(int32x2_t *)v52.i8).u32[0] == 0) << 7;
                    }
                    ++v49;
                    --v50;
                    --v51;
                  }
                  while (v51);
                  v10 += v47;
                  if (v10 >= v5) {
                    goto LABEL_67;
                  }
                  continue;
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_49:
  if (v10 < v5) {
    goto LABEL_50;
  }
LABEL_67:
  HGNode::ClearBits((HGNode *)this, (uint64_t)a2, a3);
  return 1;
}

const char *HGConvolutionShader::GetProgram(HGConvolutionShader *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) < 0x60B10) {
    return 0;
  }
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 19) == 27) {
    return "//Metal1.0     \n"
  }
           "//LEN=00000007cf\n"
           "fragment FragmentOut fragmentFunc(VertexInOut             frag        [[ stage_in ]],\n"
           "                                  const constant float4 * hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >       hg_Texture0 [[ texture(0) ]], // base image\n"
           "                                  sampler                 hg_Sampler0 [[ sampler(0) ]],\n"
           "                                  texture2d< float >      hg_Texture1 [[ texture(1) ]], // coefficents, flatt"
           "ened to 1D in x\n"
           "                                  sampler                 hg_Sampler1 [[ sampler(1) ]])\n"
           "{\n"
           "    const int16_t width {static_cast<int16_t>(hg_Params[0].x)};\n"
           "    const int16_t height {static_cast<int16_t>(hg_Params[0].y)};\n"
           "    \n"
           "    // Accumulator\n"
           "    float4 R0 {0.0, 0.0, 0.0, 0.0};\n"
           "    \n"
           "    // Coordinate Offsets\n"
           "    const float xOff {static_cast<float>(hg_Params[0].z)};\n"
           "    const float yOff {static_cast<float>(hg_Params[0].w)};\n"
           "    \n"
           "    for (int16_t j {0}; j < height; ++j)\n"
           "    {\n"
           "        for (int16_t k {0}; k < width; ++k)\n"
           "        {\n"
           "            // Coefficient index\n"
           "            const int16_t cIndex {static_cast<int16_t>(k + (j * width))};\n"
           "            \n"
           "            // Coefficient (sample the centers of the coefficient texels)\n"
           "            const float4 C0 {hg_Texture1.sample(hg_Sampler1, float2(cIndex + 0.5, 0.5))};\n"
           "            \n"
           "            // Determine sample texture coordinates centered about the current fragment\n"
           "            const float u = {frag._texCoord0.x + xOff + static_cast<float>(k)};\n"
           "            const float v = {frag._texCoord0.y + yOff + static_cast<float>(j)};\n"
           "            \n"
           "            // Retrieve sample\n"
           "            const half4 S0 {hg_Texture0.sample(hg_Sampler0, float2(u,v))};\n"
           "\n"
           "            // Accumulate\n"
           "            R0 += {C0 * static_cast<float4>(S0)};\n"
           "        }\n"
           "    }\n"
           "    \n"
           "    FragmentOut ret {R0};\n"
           "    return ret;\n"
           "}\n"
           "//MD5=8c980f69:cd21baa0:e0ab4b40:4b70610a\n"
           "//SIG=00000000:00000000:00000000:00000001:0008:0001:0000:0000:0000:0000:0002:0000:0001:02:0:0:0\n";
  return "//Metal1.0     \n"
         "//LEN=00000007d0\n"
         "fragment FragmentOut fragmentFunc(VertexInOut             frag        [[ stage_in ]],\n"
         "                                  const constant float4 * hg_Params   [[ buffer(0) ]],\n"
         "                                  texture2d< float >      hg_Texture0 [[ texture(0) ]], // base image\n"
         "                                  sampler                 hg_Sampler0 [[ sampler(0) ]],\n"
         "                                  texture2d< float >      hg_Texture1 [[ texture(1) ]], // coefficents, flatten"
         "ed to 1D in x\n"
         "                                  sampler                 hg_Sampler1 [[ sampler(1) ]])\n"
         "{\n"
         "    const int16_t width {static_cast<int16_t>(hg_Params[0].x)};\n"
         "    const int16_t height {static_cast<int16_t>(hg_Params[0].y)};\n"
         "    \n"
         "    // Accumulator\n"
         "    float4 R0 {0.0, 0.0, 0.0, 0.0};\n"
         "    \n"
         "    // Coordinate Offsets\n"
         "    const float xOff {static_cast<float>(hg_Params[0].z)};\n"
         "    const float yOff {static_cast<float>(hg_Params[0].w)};\n"
         "    \n"
         "    for (int16_t j {0}; j < height; ++j)\n"
         "    {\n"
         "        for (int16_t k {0}; k < width; ++k)\n"
         "        {\n"
         "            // Coefficient index\n"
         "            const int16_t cIndex {static_cast<int16_t>(k + (j * width))};\n"
         "            \n"
         "            // Coefficient (sample the centers of the coefficient texels)\n"
         "            const float4 C0 {hg_Texture1.sample(hg_Sampler1, float2(cIndex + 0.5, 0.5))};\n"
         "            \n"
         "            // Determine sample texture coordinates centered about the current fragment\n"
         "            const float u = {frag._texCoord0.x + xOff + static_cast<float>(k)};\n"
         "            const float v = {frag._texCoord0.y + yOff + static_cast<float>(j)};\n"
         "            \n"
         "            // Retrieve sample\n"
         "            const float4 S0 {hg_Texture0.sample(hg_Sampler0, float2(u,v))};\n"
         "\n"
         "            // Accumulate\n"
         "            R0 += {C0 * static_cast<float4>(S0)};\n"
         "        }\n"
         "    }\n"
         "    \n"
         "    FragmentOut ret {R0};\n"
         "    return ret;\n"
         "}\n"
         "//MD5=038605c0:7066b788:55c1d230:a6da0cc5\n"
         "//SIG=00000000:00000000:00000000:00000000:0008:0001:0000:0000:0000:0000:0002:0000:0001:02:0:0:0\n";
}

void HGConvolutionShader::InitProgramDescriptor(HGConvolutionShader *this, HGProgramDescriptor *a2)
{
  HGMetalUtils::stringForMetalHeader((uint64_t)&v25);
  HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)1, 0, (uint64_t)v23);
  if ((v24 & 0x80u) == 0) {
    uint64_t v3 = v23;
  }
  else {
    uint64_t v3 = (void **)v23[0];
  }
  if ((v24 & 0x80u) == 0) {
    std::string::size_type v4 = v24;
  }
  else {
    std::string::size_type v4 = (std::string::size_type)v23[1];
  }
  int v5 = std::string::append(&v25, (const std::string::value_type *)v3, v4);
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  HGMetalUtils::stringForMetalVertexShader((HGMetalUtils *)"vertexFunc", (const char *)1, 0, (uint64_t)v21);
  if ((v22 & 0x80u) == 0) {
    int v7 = v21;
  }
  else {
    int v7 = (void **)v21[0];
  }
  if ((v22 & 0x80u) == 0) {
    std::string::size_type v8 = v22;
  }
  else {
    std::string::size_type v8 = (std::string::size_type)v21[1];
  }
  uint64_t v9 = std::string::append(&v26, (const std::string::value_type *)v7, v8);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v27.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v27.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  HGMetalUtils::stringForMetalFragmentOutputStruct((HGMetalUtils *)1, 0, (uint64_t)__p);
  if ((v20 & 0x80u) == 0) {
    int v11 = __p;
  }
  else {
    int v11 = (void **)__p[0];
  }
  if ((v20 & 0x80u) == 0) {
    std::string::size_type v12 = v20;
  }
  else {
    std::string::size_type v12 = (std::string::size_type)__p[1];
  }
  int v13 = std::string::append(&v27, (const std::string::value_type *)v11, v12);
  long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v18.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  int v15 = std::string::append(&v18, "//Metal1.0     \n//LEN=00000007d0\nfragment FragmentOut fragmentFunc(VertexInOut             frag        [[ stage_in ]],\n                                  const constant float4 * hg_Params   [[ buffer(0) ]],\n                                  texture2d< float >      hg_Texture0 [[ texture(0) ]], // base image\n                                  sampler                 hg_Sampler0 [[ sampler(0) ]],\n                                  texture2d< float >      hg_Texture1 [[ texture(1) ]], // coefficents, flattened to 1D in x\n                                  sampler                 hg_Sampler1 [[ sampler(1) ]])\n{\n    const int16_t width {static_cast<int16_t>(hg_Params[0].x)};\n"
          "    const int16_t height {static_cast<int16_t>(hg_Params[0].y)};\n"
          "    \n"
          "    // Accumulator\n"
          "    float4 R0 {0.0, 0.0, 0.0, 0.0};\n"
          "    \n"
          "    // Coordinate Offsets\n"
          "    const float xOff {static_cast<float>(hg_Params[0].z)};\n"
          "    const float yOff {static_cast<float>(hg_Params[0].w)};\n"
          "    \n"
          "    for (int16_t j {0}; j < height; ++j)\n"
          "    {\n"
          "        for (int16_t k {0}; k < width; ++k)\n"
          "        {\n"
          "            // Coefficient index\n"
          "            const int16_t cIndex {static_cast<int16_t>(k + (j * width))};\n"
          "            \n"
          "            // Coefficient (sample the centers of the coefficient texels)\n"
          "            const float4 C0 {hg_Texture1.sample(hg_Sampler1, float2(cIndex + 0.5, 0.5))};\n"
          "            \n"
          "            // Determine sample texture coordinates centered about the current fragment\n"
          "            const float u = {frag._texCoord0.x + xOff + static_cast<float>(k)};\n"
          "            const float v = {frag._texCoord0.y + yOff + static_cast<float>(j)};\n"
          "            \n"
          "            // Retrieve sample\n"
          "            const float4 S0 {hg_Texture0.sample(hg_Sampler0, float2(u,v))};\n"
          "\n"
          "            // Accumulate\n"
          "            R0 += {C0 * static_cast<float4>(S0)};\n"
          "        }\n"
          "    }\n"
          "    \n"
          "    FragmentOut ret {R0};\n"
          "    return ret;\n"
          "}\n"
          "//MD5=038605c0:7066b788:55c1d230:a6da0cc5\n"
          "//SIG=00000000:00000000:00000000:00000000:0008:0001:0000:0000:0000:0000:0002:0000:0001:02:0:0:0\n");
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  int64_t v29 = v15->__r_.__value_.__r.__words[2];
  long long v28 = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v18.__r_.__value_.__l.__data_);
    if (((char)v20 & 0x80000000) == 0)
    {
LABEL_21:
      if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_22;
      }
      goto LABEL_32;
    }
  }
  else if (((char)v20 & 0x80000000) == 0)
  {
    goto LABEL_21;
  }
  operator delete(__p[0]);
  if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_22:
    if (((char)v22 & 0x80000000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_33;
  }
LABEL_32:
  operator delete(v27.__r_.__value_.__l.__data_);
  if (((char)v22 & 0x80000000) == 0)
  {
LABEL_23:
    if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_34;
  }
LABEL_33:
  operator delete(v21[0]);
  if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_24:
    if (((char)v24 & 0x80000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_35;
  }
LABEL_34:
  operator delete(v26.__r_.__value_.__l.__data_);
  if (((char)v24 & 0x80000000) == 0)
  {
LABEL_25:
    if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_26;
    }
LABEL_36:
    operator delete(v25.__r_.__value_.__l.__data_);
LABEL_26:
    if (v29 >= 0) {
      unsigned __int8 v17 = (const char *)&v28;
    }
    else {
      unsigned __int8 v17 = (const char *)v28;
    }
    HGProgramDescriptor::SetShaderProgram(a2, v17);
  }
LABEL_35:
  operator delete(v23[0]);
  if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_26;
  }
  goto LABEL_36;
}

void sub_1B78111C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *__p, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v48 - 128));
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v48 - 96));
  if (*(char *)(v48 - 41) < 0) {
    operator delete(*(void **)(v48 - 64));
  }
  _Unwind_Resume(a1);
}

uint64_t HGConvolutionShader::Bind(HGConvolutionShader *this, HGHandler *a2)
{
  return 0;
}

uint64_t HGConvolutionShader::RenderTile(HGConvolutionShader *this, HGTile *a2)
{
  uint64_t v4 = *((int *)a2 + 22);
  int v5 = (float32x4_t *)*((void *)this + 53);
  if (*((_DWORD *)this + 110))
  {
    long long v6 = (int *)*((void *)this + 54);
    int v7 = v6[1];
    uint64_t v8 = (uint64_t)&v5[(v7 - *((_DWORD *)this + 105)) * *((_DWORD *)this + 102) - *((_DWORD *)this + 104)];
    int v9 = v7 * v4;
    (*((void (**)(HGTile *, uint64_t, void))v6 + 1))(a2, v8 + 16 * *v6, (*v6 + v7 * v4));
    if (*((int *)this + 110) >= 2)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 1;
      do
      {
        uint64_t v12 = *((void *)this + 54) + v10;
        int v13 = *(_DWORD *)(v12 + 20);
        if (v13 != *(_DWORD *)(v12 + 4))
        {
          uint64_t v8 = *((void *)this + 53)
             + 16 * ((v13 - *((_DWORD *)this + 105)) * *((_DWORD *)this + 102) - *((_DWORD *)this + 104));
          int v9 = v13 * v4;
        }
        (*(void (**)(HGTile *, uint64_t, void))(v12 + 24))(a2, v8 + 16 * *(int *)(v12 + 16), (*(_DWORD *)(v12 + 16) + v9));
        ++v11;
        v10 += 16;
      }
      while (v11 < *((int *)this + 110));
    }
    return 1;
  }
  int v14 = *((_DWORD *)this + 104);
  int v15 = *((_DWORD *)this + 105);
  LODWORD(v16) = v14 + v15 * v4;
  uint64_t v17 = *((unsigned int *)this + 102);
  uint64_t v18 = *((int *)this + 103);
  if ((int)v17 < 2)
  {
    if ((int)v18 < 7)
    {
      ((void (*)(HGTile *, float32x4_t *, void))cy[v18])(a2, v5, (v14 + v15 * v4));
    }
    else
    {
      c4y((uint64_t)a2, v5, v14 + v15 * v4);
      if (v18 < 0xB)
      {
        int v23 = v18 - 4;
        int v24 = 4;
      }
      else
      {
        int v22 = v14 + v4 * (v15 + 4);
        int v23 = v18 - 4;
        int v24 = 4;
        do
        {
          cadd4y((uint64_t)a2, &v5[v24], v22);
          v24 += 4;
          v22 += 4 * v4;
          v23 -= 4;
        }
        while (v23 > 6);
      }
      ((void (*)(HGTile *, float32x4_t *, void))caddy[v23])(a2, &v5[v24], (v24 * v4 + v16));
    }
    return 1;
  }
  if (v17 < 7)
  {
    ((void (*)(HGTile *, float32x4_t *, void))cx[v17])(a2, v5, (v14 + v15 * v4));
    int v21 = v18 - 1;
    if (v18 == 1) {
      return 1;
    }
    goto LABEL_19;
  }
  c4x((uint64_t)a2, v5, v14 + v15 * v4);
  int v19 = v17 - 4;
  int v20 = 4;
  if (v17 >= 0xB)
  {
    do
    {
      cadd4x((uint64_t)a2, &v5[v20], v16 + v20);
      v20 += 4;
      v19 -= 4;
    }
    while (v19 > 6);
  }
  ((void (*)(HGTile *, float32x4_t *, void))caddx[v19])(a2, &v5[v20], (v20 + v16));
  int v21 = v18 - 1;
  if (v18 != 1)
  {
LABEL_19:
    if ((int)v17 < 7)
    {
      int v63 = caddx[(int)v17];
      uint64_t v64 = v17;
      uint64_t v65 = &v5[v64];
      uint64_t v66 = (v14 + v4 + v4 * v15);
      do
      {
        ((void (*)(HGTile *, float32x4_t *, uint64_t))v63)(a2, v65, v66);
        uint64_t v65 = (float32x4_t *)((char *)v65 + v64 * 16);
        uint64_t v66 = (v66 + v4);
        --v21;
      }
      while (v21);
    }
    else
    {
      uint64_t v16 = (int)v16;
      do
      {
        uint64_t v25 = 0;
        v16 += v4;
        v5 += v17;
        do
        {
          std::string v26 = &v5[v25];
          int v27 = *((_DWORD *)a2 + 2);
          unsigned int v28 = v27 - *(_DWORD *)a2;
          int v29 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
          int8x16_t v30 = (float32x4_t *)(*((void *)a2 + 10) + 16 * (v25 + v16));
          int8x16_t v31 = (float32x4_t *)*((void *)a2 + 2);
          float32x4_t v32 = *v26;
          float32x4_t v33 = v26[1];
          float32x4_t v34 = v26[2];
          float32x4_t v35 = v26[3];
          uint64_t v36 = (int)(*((_DWORD *)a2 + 6) - v28);
          uint64_t v37 = (int)(*((_DWORD *)a2 + 22) - v28);
          if (v28 >= 4)
          {
            do
            {
              float32x4_t v49 = *v30;
              float32x4_t v48 = v30[1];
              unsigned int v50 = v28;
              float32x4_t v51 = v30[2];
              do
              {
                float32x4_t v52 = vmulq_f32(v32, v49);
                float32x4_t v53 = v30[4];
                v30 += 4;
                float32x4_t v49 = v53;
                float32x4_t v54 = v30[-1];
                float32x4_t v55 = v31[1];
                *int8x16_t v31 = vaddq_f32(vaddq_f32(vmulq_f32(v34, v51), v52), vaddq_f32(vmulq_f32(v35, v54), vaddq_f32(vmulq_f32(v33, v48), *v31)));
                float32x4_t v56 = vaddq_f32(vaddq_f32(vmulq_f32(v32, v48), vmulq_f32(v34, v54)), vaddq_f32(vmulq_f32(v35, v53), vaddq_f32(vmulq_f32(v33, v51), v55)));
                float32x4_t v48 = v30[1];
                v31[1] = v56;
                float32x4_t v57 = vaddq_f32(vaddq_f32(vmulq_f32(v32, v51), vmulq_f32(v34, v53)), vaddq_f32(vmulq_f32(v35, v48), vaddq_f32(vmulq_f32(v33, v54), v31[2])));
                float32x4_t v51 = v30[2];
                float32x4_t v58 = vaddq_f32(vaddq_f32(vmulq_f32(v32, v54), vmulq_f32(v34, v48)), vaddq_f32(vmulq_f32(v35, v51), vaddq_f32(vmulq_f32(v33, v53), v31[3])));
                v31[2] = v57;
                v31[3] = v58;
                v31 += 4;
                v50 -= 4;
              }
              while (v50 > 3);
              if (v50)
              {
                int v59 = 0;
                uint64_t v60 = 0;
                do
                {
                  float32x4_t v61 = vmulq_f32(v32, v49);
                  float32x4_t v62 = vmulq_f32(v33, v48);
                  float32x4_t v49 = v48;
                  float32x4_t v48 = v51;
                  float32x4_t v51 = v30[v60 + 3];
                  v31[v60] = vaddq_f32(vaddq_f32(vmulq_f32(v34, v48), v61), vaddq_f32(vmulq_f32(v35, v51), vaddq_f32(v62, v31[v60])));
                  ++v60;
                  ++v59;
                }
                while (v50 != v59);
                int8x16_t v31 = (float32x4_t *)((char *)v31 + v60 * 16);
                int8x16_t v30 = (float32x4_t *)((char *)v30 + v60 * 16);
              }
              v31 += v36;
              v30 += v37;
              --v29;
            }
            while (v29);
          }
          else if (v28)
          {
            uint64_t v38 = 16 * v36;
            uint64_t v39 = 16 * v37;
            int v40 = *(_DWORD *)a2 - v27;
            do
            {
              float32x4_t v41 = *v30;
              float32x4_t v42 = v30[1];
              int v43 = v40;
              float32x4_t v44 = v30[2];
              do
              {
                float32x4_t v45 = vmulq_f32(v32, v41);
                float32x4_t v46 = vmulq_f32(v33, v42);
                float32x4_t v41 = v42;
                float32x4_t v42 = v44;
                float32x4_t v44 = v30[3];
                *int8x16_t v31 = vaddq_f32(vaddq_f32(vmulq_f32(v34, v42), v45), vaddq_f32(vmulq_f32(v35, v44), vaddq_f32(v46, *v31)));
                ++v31;
                ++v30;
              }
              while (!__CFADD__(v43++, 1));
              int8x16_t v31 = (float32x4_t *)((char *)v31 + v38);
              int8x16_t v30 = (float32x4_t *)((char *)v30 + v39);
              --v29;
            }
            while (v29);
          }
          v25 += 4;
        }
        while ((int)v17 - (int)v25 > 6);
        ((void (*)(HGTile *, float32x4_t *, void))caddx[(int)v17 - (int)v25])(a2, &v5[(int)v25], (v25 + v16));
        --v21;
      }
      while (v21);
    }
  }
  return 1;
}

void HGConvolution::HGConvolution(HGConvolution *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v2 = &unk_1F10DE338;
  uint64_t v3 = (HGLinearFilter2D *)(v2 + 51);
  HGLinearFilter2D::HGLinearFilter2D((HGLinearFilter2D *)(v2 + 51));
  HGLinearFilter2D::HGLinearFilter2D((HGConvolution *)((char *)this + 440));
  *(_OWORD *)((char *)this + 520) = 0u;
  HGLinearFilter2D::setType(v3, 0, 4);
  HGLinearFilter2D::setType((HGConvolution *)((char *)this + 440), 0, 4);
  *((_DWORD *)this + 118) = -1;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
}

void sub_1B7811948(_Unwind_Exception *a1)
{
  HGLinearFilter2D::~HGLinearFilter2D(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7811964(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7811978(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void *)(v1 + 528);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  if (*v4) {
    (*(void (**)(void))(*(void *)*v4 + 24))(*v4);
  }
  HGLinearFilter2D::~HGLinearFilter2D(v3);
  HGLinearFilter2D::~HGLinearFilter2D(v2);
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGConvolution::~HGConvolution(HGConvolution *this)
{
  *(void *)this = &unk_1F10DE338;
  uint64_t v2 = *((void *)this + 63);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 62);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 61);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *((void *)this + 60);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  uint64_t v6 = *((void *)this + 66);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  uint64_t v7 = *((void *)this + 65);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  HGLinearFilter2D::~HGLinearFilter2D((HGConvolution *)((char *)this + 440));
  HGLinearFilter2D::~HGLinearFilter2D((HGConvolution *)((char *)this + 408));

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v1;
  uint64_t vars8;

  HGConvolution::~HGConvolution(this);

  HGObject::operator delete(v1);
}

uint64_t HGConvolution::SetSize(HGConvolution *this, int a2, int a3)
{
  if (a2 < 1 || a3 < 1)
  {
    if (!*((void *)this + 51))
    {
LABEL_11:
      uint64_t result = 0;
      *((_DWORD *)this + 128) = 1;
      return result;
    }
    HGLinearFilter2D::reset((uint64_t)this + 408, 0, 0);
  }
  else
  {
    int v4 = *((_DWORD *)this + 104);
    if (*((int *)this + 128) < 2)
    {
      int v5 = *((_DWORD *)this + 105);
      if (*((_DWORD *)this + 106) == a2 && *((_DWORD *)this + 107) == a3) {
        goto LABEL_11;
      }
    }
    else
    {
      v4 += *((_DWORD *)this + 112);
      int v5 = *((_DWORD *)this + 113) + *((_DWORD *)this + 105);
      if (*((_DWORD *)this + 106) + *((_DWORD *)this + 114) - 1 == a2
        && *((_DWORD *)this + 107) + *((_DWORD *)this + 115) - 1 == a3)
      {
        goto LABEL_11;
      }
    }
    HGLinearFilter2D::resize((HGConvolution *)((char *)this + 408), v4, v5, a2 + v4 - 1, a3 + v5 - 1, 0);
  }
  *((_DWORD *)this + 118) = -1;
  HGNode::ClearBits((HGNode *)this, v6, v7);
  uint64_t result = 1;
  *((_DWORD *)this + 128) = 1;
  return result;
}

uint64_t HGConvolution::SetParameter(int32x2_t *this, uint64_t a2, float32x4_t a3, float32_t a4, float a5, float a6, char *a7)
{
  if (!a2)
  {
    float v36 = a4;
    float v38 = a3.f32[0];
    unsigned int v13 = HGConvolution::SetSize((HGConvolution *)this, vcvtps_s32_f32(a5), vcvtps_s32_f32(a6));
    uint64_t v14 = (uint64_t)rintf(v38);
    uint64_t v15 = (uint64_t)rintf(v36);
    __int32 v16 = this[52].i32[0];
    if (this[64].i32[0] < 2)
    {
      int v17 = v14 - v16;
      int v18 = v15 - this[52].i32[1];
      int v19 = v18 | (v14 - v16);
      if (!v19) {
        return v19 | v13;
      }
    }
    else
    {
      int v17 = v14 - (this[56].i32[0] + v16);
      int v18 = v15 - (this[56].i32[1] + this[52].i32[1]);
      int v19 = v18 | v17;
      if (!(v18 | v17)) {
        return v19 | v13;
      }
    }
    HGLinearFilter2D::translate(&this[51], v17, v18);
    this[59].i32[0] = -1;
    HGNode::ClearBits((HGNode *)this, v21, v22);
    int v19 = 1;
    return v19 | v13;
  }
  int v8 = this[64].i32[0];
  unsigned __int32 v9 = this[53].u32[0];
  if (v8 >= 2)
  {
    unsigned int v10 = v9 + this[57].i32[0] - 1;
    unsigned int v11 = this[53].i32[1] + this[57].i32[1] - 1;
    if ((int)(v11 * v10) < (int)a2) {
      return 0xFFFFFFFFLL;
    }
    signed int v23 = ((int)a2 - 1) % v10;
    signed int v24 = ((int)a2 - 1) / v11;
    float v37 = a4;
    unsigned __int32 v39 = a3.i32[0];
    float v34 = a5;
    float v35 = a6;
    HGLinearFilter2D::convolve(this + 51, (const HGLinearFilter2D *)&this[55]);
    a5 = v34;
    a6 = v35;
    a4 = v37;
    a3.i32[0] = v39;
    this[59].i32[0] |= 0x15u;
    this[64].i32[0] = 1;
    __int32 v25 = this[52].i32[0];
    __int32 v26 = v23 - v25;
    if (v23 >= v25) {
      goto LABEL_14;
    }
    return 0xFFFFFFFFLL;
  }
  unsigned __int32 v20 = this[53].u32[1];
  if ((int)(v20 * v9) < (int)a2) {
    return 0xFFFFFFFFLL;
  }
  signed int v23 = ((int)a2 - 1) % v9;
  signed int v24 = ((int)a2 - 1) / v20;
  __int32 v25 = this[52].i32[0];
  __int32 v26 = v23 - v25;
  if (v23 < v25) {
    return 0xFFFFFFFFLL;
  }
LABEL_14:
  __int32 v27 = this[53].i32[0];
  if (v25 + v27 - 1 < v23) {
    return 0xFFFFFFFFLL;
  }
  __int32 v28 = this[52].i32[1];
  __int32 v29 = v24 - v28;
  if (v24 < v28) {
    return 0xFFFFFFFFLL;
  }
  if (v28 + this[53].i32[1] - 1 < v24) {
    return 0xFFFFFFFFLL;
  }
  int32x2_t v30 = this[51];
  a3.f32[1] = a4;
  a3.i64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
  __int32 v31 = v26 + v29 * v27;
  int8x16_t v32 = veorq_s8((int8x16_t)vceqzq_f32(a3), (int8x16_t)vceqzq_f32(*(float32x4_t *)(*(void *)&v30 + 16 * v31)));
  int32x2_t v33 = vpmin_s32(*(int32x2_t *)v32.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
  if (vpmin_s32(v33, v33).u32[0])
  {
    this[59].i32[0] |= 0x11u;
    *(float32x4_t *)(*(void *)&v30 + 16 * v31) = a3;
LABEL_25:
    HGNode::ClearBits((HGNode *)this, a2, a7);
    return 1;
  }
  if (v8 >= 2) {
    goto LABEL_25;
  }
  return 0;
}

uint64_t HGConvolution::SeparableFilter2D(HGConvolution *this, const HGLinearFilter2D *a2, const HGLinearFilter2D *a3)
{
  uint64_t v6 = (char *)this + 408;
  uint64_t v7 = (char *)this + 408;
  if (*((_DWORD *)a2 + 5) >= *((_DWORD *)a3 + 5))
  {
    if (HGLinearFilter2D::operator==((uint64_t)v7, (uint64_t)a3))
    {
      unsigned int v10 = (char *)this + 440;
      uint64_t result = HGLinearFilter2D::operator==((uint64_t)this + 440, (uint64_t)a2);
      if (result) {
        goto LABEL_4;
      }
    }
    else
    {
      HGLinearFilter2D::operator=((uint64_t)v6, (uint64_t)a3);
      *((_DWORD *)this + 118) |= 0x15u;
      unsigned int v10 = (char *)this + 440;
      uint64_t result = HGLinearFilter2D::operator==((uint64_t)this + 440, (uint64_t)a2);
      if (result) {
        goto LABEL_4;
      }
    }
    uint64_t v11 = (uint64_t)v10;
    uint64_t v12 = a2;
  }
  else
  {
    if (HGLinearFilter2D::operator==((uint64_t)v7, (uint64_t)a2))
    {
      int v8 = (char *)this + 440;
      uint64_t result = HGLinearFilter2D::operator==((uint64_t)this + 440, (uint64_t)a3);
      if (result)
      {
LABEL_4:
        *((_DWORD *)this + 128) = 2;
        return result;
      }
    }
    else
    {
      HGLinearFilter2D::operator=((uint64_t)v6, (uint64_t)a2);
      *((_DWORD *)this + 118) |= 0x15u;
      int v8 = (char *)this + 440;
      uint64_t result = HGLinearFilter2D::operator==((uint64_t)this + 440, (uint64_t)a3);
      if (result) {
        goto LABEL_4;
      }
    }
    uint64_t v11 = (uint64_t)v8;
    uint64_t v12 = a3;
  }
  uint64_t result = HGLinearFilter2D::operator=(v11, (uint64_t)v12);
  *((_DWORD *)this + 118) |= 0x2Au;
  *((_DWORD *)this + 128) = 2;
  return result;
}

HGBitmapLoader *HGConvolution::PopulateCoeffInputForKernel(HGConvolution *this, HGGPURenderer *a2, int a3)
{
  uint64_t v4 = a3;
  int v5 = (char *)this + 32 * a3;
  uint64_t v6 = HGRectMake4i(0, 0, *((_DWORD *)v5 + 107) * *((_DWORD *)v5 + 106), 1u);
  uint64_t v8 = v7;
  uint64_t v9 = *((void *)v5 + 51);
  unsigned int v10 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v10, v6, v8, 28, v9);
  uint64_t v11 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v11, v10);
  uint64_t v12 = (char *)this + 8 * v4;
  uint64_t result = (HGBitmapLoader *)*((void *)v12 + 65);
  if (result == v11)
  {
    if (v11) {
      uint64_t result = (HGBitmapLoader *)(*(uint64_t (**)(HGBitmapLoader *))(*(void *)v11 + 24))(v11);
    }
  }
  else
  {
    if (result) {
      uint64_t result = (HGBitmapLoader *)(*(uint64_t (**)(HGBitmapLoader *))(*(void *)result + 24))(result);
    }
    *((void *)v12 + 65) = v11;
  }
  if (v10) {
    return (HGBitmapLoader *)(*(uint64_t (**)(HGBitmap *))(*(void *)v10 + 24))(v10);
  }
  return result;
}

void sub_1B78121F8(_Unwind_Exception *exception_object)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

HGNode *HGConvolution::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  *((_DWORD *)this + 118) &= 0xFFFFFFCF;
  uint64_t v6 = (unsigned __int32 *)*((void *)this + 51);
  if (!v6) {
    return Input;
  }
  int v7 = *((_DWORD *)this + 128);
  if (v7 >= 2 && !*((void *)this + 55)) {
    return Input;
  }
  if (!*((void *)this + 52) && *((_DWORD *)this + 106) == 1 && *((_DWORD *)this + 107) == 1)
  {
    v5.n128_u32[0] = *v6;
    if (*(float *)v6 == 0.0)
    {
      v5.n128_u32[0] = v6[1];
      if (v5.n128_f32[0] == 0.0)
      {
        v5.n128_u32[0] = v6[2];
        if (v5.n128_f32[0] == 0.0)
        {
          v5.n128_u32[0] = v6[3];
          if (v5.n128_f32[0] == 0.0)
          {
            if (v7 < 2) {
              return Input;
            }
            if (!*((void *)this + 56) && *((_DWORD *)this + 114) == 1 && *((_DWORD *)this + 115) == 1)
            {
              int v17 = (unsigned __int32 *)*((void *)this + 55);
              v5.n128_u32[0] = *v17;
              if (*(float *)v17 == 0.0)
              {
                v5.n128_u32[0] = v17[1];
                if (v5.n128_f32[0] == 0.0)
                {
                  v5.n128_u32[0] = v17[2];
                  if (v5.n128_f32[0] == 0.0)
                  {
                    v5.n128_u32[0] = v17[3];
                    if (v5.n128_f32[0] == 0.0) {
                      return Input;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ((*(uint64_t (**)(HGRenderer *, __n128))(*(void *)a2 + 304))(a2, v5))
  {
    uint64_t v8 = (char *)*((void *)this + 60);
    if (v8)
    {
      uint64_t v9 = *(void (***)(void *, void, HGNode *))v8;
    }
    else
    {
      uint64_t v8 = (char *)HGObject::operator new(0x1C0uLL);
      HGNode::HGNode((HGNode *)v8);
      uint64_t v9 = (void (**)(void *, void, HGNode *))&unk_1F10DE0E8;
      *(void *)uint64_t v8 = &unk_1F10DE0E8;
      *((_DWORD *)v8 + 110) = 0;
      *(_OWORD *)(v8 + 408) = 0u;
      *(_OWORD *)(v8 + 424) = 0u;
      *((_DWORD *)v8 + 4) = *((_DWORD *)v8 + 4) & 0xFFFFF9FF | 0x400;
      *((void *)this + 60) = v8;
    }
    v9[15](v8, 0, Input);
    if (*((unsigned char *)this + 472))
    {
      HGConvolutionShader::compile(*((HGConvolutionShader **)this + 60), (const HGLinearFilter2D *)((char *)this + 408), (char *)(*((_DWORD *)this + 106) + *((_DWORD *)this + 104)), *((_DWORD *)this + 105) + *((_DWORD *)this + 107) - 1, 0);
      *((_DWORD *)this + 118) &= ~1u;
    }
    if (*((int *)this + 128) < 2)
    {
      return (HGNode *)*((void *)this + 60);
    }
    else
    {
      uint64_t v15 = (char *)*((void *)this + 61);
      if (v15)
      {
        __int32 v16 = *(void **)v15;
      }
      else
      {
        uint64_t v15 = (char *)HGObject::operator new(0x1C0uLL);
        HGNode::HGNode((HGNode *)v15);
        __int32 v16 = &unk_1F10DE0E8;
        *(void *)uint64_t v15 = &unk_1F10DE0E8;
        *((_DWORD *)v15 + 110) = 0;
        *(_OWORD *)(v15 + 408) = 0u;
        *(_OWORD *)(v15 + 424) = 0u;
        *((_DWORD *)v15 + 4) = *((_DWORD *)v15 + 4) & 0xFFFFF9FF | 0x400;
        *((void *)this + 61) = v15;
      }
      (*((void (**)(char *, void, void))v16 + 15))(v15, 0, *((void *)this + 60));
      if ((*((unsigned char *)this + 472) & 2) != 0)
      {
        HGConvolutionShader::compile(*((HGConvolutionShader **)this + 61), (const HGLinearFilter2D *)((char *)this + 440), (char *)(*((_DWORD *)this + 114) + *((_DWORD *)this + 112)), *((_DWORD *)this + 113) + *((_DWORD *)this + 115) - 1, 0);
        *((_DWORD *)this + 118) &= ~2u;
      }
      return (HGNode *)*((void *)this + 61);
    }
  }
  else
  {
    unsigned int v10 = (char *)*((void *)this + 62);
    if (!v10)
    {
      unsigned int v10 = (char *)HGObject::operator new(0x1C0uLL);
      HGNode::HGNode((HGNode *)v10);
      *(void *)unsigned int v10 = &unk_1F10DE0E8;
      *((_DWORD *)v10 + 110) = 0;
      *(_OWORD *)(v10 + 408) = 0u;
      *(_OWORD *)(v10 + 424) = 0u;
      *((_DWORD *)v10 + 4) = *((_DWORD *)v10 + 4) & 0xFFFFF9FF | 0x400;
      *((void *)this + 62) = v10;
    }
    if ((*((unsigned char *)this + 472) & 4) != 0)
    {
      HGConvolutionShader::compile((HGConvolutionShader *)v10, (const HGLinearFilter2D *)((char *)this + 408), (char *)(*((_DWORD *)this + 106) + *((_DWORD *)this + 104)), *((_DWORD *)this + 105) + *((_DWORD *)this + 107) - 1, 0);
      HGConvolution::PopulateCoeffInputForKernel((HGConvolution *)this, v11, 0);
      *((_DWORD *)this + 118) &= ~4u;
      unsigned int v10 = (char *)*((void *)this + 62);
    }
    (*(void (**)(char *, void, HGNode *))(*(void *)v10 + 120))(v10, 0, Input);
    (*(void (**)(void, uint64_t, void))(**((void **)this + 62) + 120))(*((void *)this + 62), 1, *((void *)this + 65));
    if (*((int *)this + 128) >= 2)
    {
      uint64_t v12 = (char *)*((void *)this + 63);
      if (!v12)
      {
        uint64_t v12 = (char *)HGObject::operator new(0x1C0uLL);
        HGNode::HGNode((HGNode *)v12);
        *(void *)uint64_t v12 = &unk_1F10DE0E8;
        *((_DWORD *)v12 + 110) = 0;
        *(_OWORD *)(v12 + 408) = 0u;
        *(_OWORD *)(v12 + 424) = 0u;
        *((_DWORD *)v12 + 4) = *((_DWORD *)v12 + 4) & 0xFFFFF9FF | 0x400;
        *((void *)this + 63) = v12;
      }
      if ((*((unsigned char *)this + 472) & 8) != 0)
      {
        HGConvolutionShader::compile((HGConvolutionShader *)v12, (const HGLinearFilter2D *)((char *)this + 440), (char *)(*((_DWORD *)this + 114) + *((_DWORD *)this + 112)), *((_DWORD *)this + 113) + *((_DWORD *)this + 115) - 1, 0);
        HGConvolution::PopulateCoeffInputForKernel((HGConvolution *)this, v13, 1);
        *((_DWORD *)this + 118) &= ~8u;
        uint64_t v12 = (char *)*((void *)this + 63);
      }
      (*(void (**)(char *, void, void))(*(void *)v12 + 120))(v12, 0, *((void *)this + 62));
      (*(void (**)(void, uint64_t, void))(**((void **)this + 63) + 120))(*((void *)this + 63), 1, *((void *)this + 66));
      return (HGNode *)*((void *)this + 63);
    }
    return (HGNode *)*((void *)this + 62);
  }
}

void sub_1B78128AC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78128C0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78128D4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78128E8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGFlipAndOffset::HGFlipAndOffset(HGFlipAndOffset *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v2 = &unk_1F10DE5B8;
  *(_DWORD *)(v2 + 420) = 0;
  *(void *)(v2 + 408) = 0;
  *(_WORD *)(v2 + 416) = 0;
  HGNode::SetFlags((HGNode *)v2, 0, 32);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B7812964(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGFlipAndOffset::~HGFlipAndOffset(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGFlipAndOffset::info(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v31);
  if (a2 >= 1)
  {
    int v7 = *(char *)(a3 + 23);
    if (v7 >= 0) {
      uint64_t v8 = a3;
    }
    else {
      uint64_t v8 = *(void *)a3;
    }
    if (v7 >= 0) {
      uint64_t v9 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v9 = *(void *)(a3 + 8);
    }
    unsigned int v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, v8, v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"    [ [", 7);
    uint64_t v11 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" 0 0 ", 5);
    uint64_t v12 = (void *)std::ostream::operator<<();
    unsigned int v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"]\n", 2);
    int v14 = *(char *)(a4 + 23);
    if (v14 >= 0) {
      uint64_t v15 = a4;
    }
    else {
      uint64_t v15 = *(void *)a4;
    }
    if (v14 >= 0) {
      uint64_t v16 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      uint64_t v16 = *(void *)(a4 + 8);
    }
    int v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v15, v16);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"      [0 ", 9);
    int v18 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" 0 ", 3);
    int v19 = (void *)std::ostream::operator<<();
    unsigned __int32 v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"]\n", 2);
    int v21 = *(char *)(a4 + 23);
    if (v21 >= 0) {
      uint64_t v22 = a4;
    }
    else {
      uint64_t v22 = *(void *)a4;
    }
    if (v21 >= 0) {
      uint64_t v23 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      uint64_t v23 = *(void *)(a4 + 8);
    }
    signed int v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, v22, v23);
    __int32 v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"      [0 0 1 0]\n", 16);
    int v26 = *(char *)(a4 + 23);
    if (v26 >= 0) {
      uint64_t v27 = a4;
    }
    else {
      uint64_t v27 = *(void *)a4;
    }
    if (v26 >= 0) {
      uint64_t v28 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      uint64_t v28 = *(void *)(a4 + 8);
    }
    __int32 v29 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, v27, v28);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)"      [0 0 0 1] ]", 17);
  }
  std::stringbuf::str();
  v31[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v31 + *(void *)(v31[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v31[1] = MEMORY[0x1E4FBA470] + 16;
  if (v32 < 0) {
    operator delete((void *)v31[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v33);
}

void sub_1B7812C1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGFlipAndOffset::SetParameter(HGFlipAndOffset *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 == 2)
  {
    if (*((_DWORD *)this + 105) != a3)
    {
      *((_DWORD *)this + 105) = a3;
      return 1;
    }
    return 0;
  }
  if (a2 == 1)
  {
    int v9 = a3 != 0.0;
    int v10 = a4 != 0.0;
    if (*((unsigned __int8 *)this + 416) != v9 || *((unsigned __int8 *)this + 417) != v10)
    {
      *((unsigned char *)this + 416) = v9;
      *((unsigned char *)this + 417) = v10;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    }
    return 0;
  }
  if (a2) {
    return 0;
  }
  if (vabds_f32(a3, (float)(int)roundf(a3)) > 0.001) {
    return 0xFFFFFFFFLL;
  }
  int v7 = llroundf(a4);
  if (vabds_f32(a4, (float)v7) > 0.001) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v11 = llroundf(a3);
  if (*((_DWORD *)this + 102) == v11 && *((_DWORD *)this + 103) == v7) {
    return 0;
  }
  *((_DWORD *)this + 102) = v11;
  *((_DWORD *)this + 103) = v7;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HGFlipAndOffset::GetParameter(int32x2_t *this, int a2, float32x2_t *a3)
{
  if (a2 == 2)
  {
    a3->f32[0] = (float)this[52].u32[1];
    return 0;
  }
  if (a2 != 1)
  {
    if (!a2)
    {
      *a3 = vcvt_f32_s32(this[51]);
      return 0;
    }
    return 0;
  }
  v4.i32[0] = this[52].u8[0];
  v4.i32[1] = this[52].u8[1];
  __asm { FMOV            V1.2S, #1.0 }
  *a3 = (float32x2_t)vbic_s8(_D1, (int8x8_t)vceqz_s32(v4));
  return 0;
}

HGFlipAndOffset *HGFlipAndOffset::GetOutput(HGFlipAndOffset *this, HGRenderer *a2)
{
  if (*((unsigned char *)this + 416) || *((unsigned char *)this + 417))
  {
    (*(void (**)(HGFlipAndOffset *, void, uint64_t))(*(void *)this + 136))(this, 0, 1);
    *((_DWORD *)this + 4) |= 1u;
  }
  return this;
}

uint64_t HGFlipAndOffset::GetDOD(HGFlipAndOffset *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return HGRectNull;
  }
  float v7 = HGRectFloat(a4.var0);
  if (*((unsigned char *)this + 416)) {
    float v11 = -1.0;
  }
  else {
    float v11 = 1.0;
  }
  float v12 = HGRectScale(v7, v8, v9, v10, v11);
  float v16 = HGRectTranslate(v12, v13, v14, v15, (float)*((int *)this + 102));
  *(void *)&long long v25 = HGRectIntegral(v17, v16, v18, v19, v20);
  *((void *)&v25 + 1) = v21;
  if (!(*(unsigned int (**)(HGFlipAndOffset *, HGRenderer *))(*(void *)this + 312))(this, a2)) {
    return v25;
  }
  uint64_t v22 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  uint64_t v24 = v23;
  *(void *)&v26.var0 = v22;
  *(void *)&v26.var2 = v24;
  HGRect::Grow((HGRect *)&v25, v26);
  return v25;
}

uint64_t HGFlipAndOffset::GetROI(HGFlipAndOffset *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  float v6 = HGRectFloat(a4.var0);
  float v10 = HGRectTranslate(v6, v7, v8, v9, (float)-*((_DWORD *)this + 102));
  if (*((unsigned char *)this + 416)) {
    float v14 = -1.0;
  }
  else {
    float v14 = 1.0;
  }
  float v15 = HGRectScale(v10, v11, v12, v13, v14);
  return HGRectIntegral(v16, v15, v17, v18, v19);
}

uint64_t HGFlipAndOffset::SupportsInplaceHardwareBlending(HGFlipAndOffset *this, float a2)
{
  return 1;
}

uint64_t HGFlipAndOffset::BindTexture(HGFlipAndOffset *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  v7.n128_u64[0] = -1.0;
  if (*((unsigned char *)this + 416)) {
    v6.n128_f64[0] = -1.0;
  }
  else {
    v6.n128_f64[0] = 1.0;
  }
  if (!*((unsigned char *)this + 417)) {
    v7.n128_f64[0] = 1.0;
  }
  (*(void (**)(HGHandler *, __n128, __n128))(*(void *)a2 + 104))(a2, v6, v7);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, (double)-*((_DWORD *)this + 102), (double)-*((_DWORD *)this + 103), 0.0);
  double v8 = (*(double (**)(HGFlipAndOffset *))(*(void *)this + 288))(this);
  (*(void (**)(HGHandler *, void, double, float, float, float))(*(void *)a2 + 136))(a2, 0, v8, *(float *)&v8, *(float *)&v8, *(float *)&v8);
  int v9 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v9)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 21))
    {
      (*(void (**)(HGHandler *, uint64_t, double, double, float, float))(*(void *)a2 + 136))(a2, 1, 0.0, 0.0, 1.0, 1.0);
      unsigned int v10 = *((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55);
      unsigned int v11 = *((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56);
      (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 2, (float)(v10 + 1) * 0.5, (float)(v11 + 1) * 0.5, (float)v10, (float)v11);
    }
    return 0;
  }
  return result;
}

uint64_t HGFlipAndOffset::IntermediateFormat(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 420);
  if ((int)v2 <= (int)a2) {
    return a2;
  }
  else {
    return v2;
  }
}

uint64_t HGFlipAndOffset::RenderTile(HGFlipAndOffset *this, HGTile *a2)
{
  if (*((unsigned char *)this + 416))
  {
    int v2 = *((_DWORD *)a2 + 2);
    int v3 = *(_DWORD *)a2;
    int v4 = *((_DWORD *)a2 + 1);
    int v5 = v2 - *(_DWORD *)a2;
    int v6 = *((_DWORD *)a2 + 3) - v4;
    if (*((unsigned char *)this + 417))
    {
      if (v6 >= 1 && v5 >= 1)
      {
        int v7 = 0;
        int v8 = *((_DWORD *)a2 + 22);
        uint64_t v9 = -v8;
        uint64_t v10 = *((void *)a2 + 10)
            + 16 * (*((_DWORD *)a2 + 52) - v3 + (*((_DWORD *)a2 + 53) - v4) * v8)
            + 16 * v8 * (v6 - 1);
        uint64_t v11 = *((void *)a2 + 2);
        uint64_t v12 = 16 * (v2 - *(_DWORD *)a2);
        uint64_t v13 = 16 * *((int *)a2 + 6);
        int v14 = ~v3 + v2;
        do
        {
          uint64_t v15 = 0;
          int v16 = v14;
          do
          {
            *(_OWORD *)(v11 + v15) = *(_OWORD *)(v10 + 16 * v16);
            v15 += 16;
            --v16;
          }
          while (v12 != v15);
          v10 += 16 * v9;
          ++v7;
          v11 += v13;
        }
        while (v7 != v6);
      }
    }
    else if (v6 >= 1 && v5 >= 1)
    {
      int v25 = 0;
      uint64_t v26 = *((int *)a2 + 22);
      uint64_t v27 = *((void *)a2 + 10) + 16 * (*((_DWORD *)a2 + 52) - v3 + (*((_DWORD *)a2 + 53) - v4) * (int)v26);
      uint64_t v28 = *((void *)a2 + 2);
      uint64_t v29 = 16 * (v2 - *(_DWORD *)a2);
      uint64_t v30 = 16 * *((int *)a2 + 6);
      int v31 = ~v3 + v2;
      do
      {
        uint64_t v32 = 0;
        int v33 = v31;
        do
        {
          *(_OWORD *)(v28 + v32) = *(_OWORD *)(v27 + 16 * v33);
          v32 += 16;
          --v33;
        }
        while (v29 != v32);
        v27 += 16 * v26;
        ++v25;
        v28 += v30;
      }
      while (v25 != v6);
    }
  }
  else if (*((unsigned char *)this + 417))
  {
    int v17 = *((_DWORD *)a2 + 1);
    int v18 = *((_DWORD *)a2 + 3) - v17;
    if (v18 >= 1)
    {
      float v19 = (char *)*((void *)a2 + 2);
      uint64_t v20 = *((int *)a2 + 22);
      uint64_t v21 = (char *)(*((void *)a2 + 10)
                   + 16 * (*((_DWORD *)a2 + 52) - *(_DWORD *)a2 + (*((_DWORD *)a2 + 53) - v17) * (int)v20)
                   + 16 * (int)v20 * (v18 - 1));
      size_t v22 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
      uint64_t v23 = 16 * *((int *)a2 + 6);
      uint64_t v24 = -16 * v20;
      do
      {
        memcpy(v19, v21, v22);
        v19 += v23;
        v21 += v24;
        --v18;
      }
      while (v18);
    }
  }
  return 0;
}

uint64_t HGPool::BasePool::BasePool(uint64_t this)
{
  *(void *)this = &unk_1F10DE820;
  *(_DWORD *)(this + 8) = 0;
  *(_WORD *)(this + 10) = atomic_fetch_add(HGPool::BasePool::BasePool(void)::poolCounter, 1u) + 1;
  return this;
}

void HGPool::registerPool(HGPool *this, HGPool::BasePool *a2)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&_MergedGlobals_14, memory_order_acquire) != -1)
  {
    uint64_t v29 = &v27;
    uint64_t v28 = &v29;
    std::__call_once(&_MergedGlobals_14, &v28, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<HGPool::registerPool(HGPool::BasePool *)::$_0 &&>>);
  }
  int v3 = (std::mutex *)(qword_1EB9A20C0 + 24);
  std::mutex::lock((std::mutex *)(qword_1EB9A20C0 + 24));
  int v4 = (char **)qword_1EB9A20C0;
  int v6 = *(char **)(qword_1EB9A20C0 + 8);
  unint64_t v5 = *(void *)(qword_1EB9A20C0 + 16);
  if ((unint64_t)v6 < v5)
  {
    *(void *)int v6 = this;
    uint64_t v7 = (uint64_t)(v6 + 8);
    goto LABEL_16;
  }
  int v8 = *(char **)qword_1EB9A20C0;
  uint64_t v9 = (uint64_t)&v6[-*(void *)qword_1EB9A20C0];
  uint64_t v10 = v9 >> 3;
  unint64_t v11 = (v9 >> 3) + 1;
  if (v11 >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v12 = v5 - (void)v8;
  if (v12 >> 2 > v11) {
    unint64_t v11 = v12 >> 2;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v11;
  }
  if (v13)
  {
    if (v13 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int v14 = operator new(8 * v13);
    uint64_t v15 = &v14[8 * v10];
    int v16 = &v14[8 * v13];
    *(void *)uint64_t v15 = this;
    uint64_t v7 = (uint64_t)(v15 + 8);
    int v17 = (char *)(v6 - v8);
    if (v6 == v8)
    {
LABEL_14:
      void *v4 = v15;
      v4[1] = (char *)v7;
      v4[2] = v16;
      if (!v6) {
        goto LABEL_16;
      }
LABEL_15:
      operator delete(v6);
      goto LABEL_16;
    }
  }
  else
  {
    int v14 = 0;
    uint64_t v15 = (char *)(8 * v10);
    int v16 = 0;
    *(void *)(8 * v10) = this;
    uint64_t v7 = 8 * v10 + 8;
    int v17 = (char *)(v6 - v8);
    if (v6 == v8) {
      goto LABEL_14;
    }
  }
  unint64_t v18 = (unint64_t)(v17 - 8);
  if (v18 < 0x58) {
    goto LABEL_30;
  }
  if ((unint64_t)(v6 - v14 - v9) < 0x20) {
    goto LABEL_30;
  }
  uint64_t v19 = (v18 >> 3) + 1;
  uint64_t v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
  uint64_t v21 = &v6[-v20];
  v15 -= v20;
  size_t v22 = &v14[8 * v10 - 16];
  uint64_t v23 = v6 - 16;
  uint64_t v24 = v19 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v25 = *(_OWORD *)v23;
    *(v22 - 1) = *((_OWORD *)v23 - 1);
    *size_t v22 = v25;
    v22 -= 2;
    v23 -= 32;
    v24 -= 4;
  }
  while (v24);
  int v6 = v21;
  if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_30:
    do
    {
      uint64_t v26 = *((void *)v6 - 1);
      v6 -= 8;
      *((void *)v15 - 1) = v26;
      v15 -= 8;
    }
    while (v6 != v8);
  }
  int v6 = *v4;
  void *v4 = v15;
  v4[1] = (char *)v7;
  v4[2] = v16;
  if (v6) {
    goto LABEL_15;
  }
LABEL_16:
  v4[1] = (char *)v7;
  std::mutex::unlock(v3);
}

void sub_1B78136D4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::unregisterPool(HGPool *this, HGPool::BasePool *a2)
{
  int v3 = (std::mutex *)(qword_1EB9A20C0 + 24);
  std::mutex::lock((std::mutex *)(qword_1EB9A20C0 + 24));
  uint64_t v4 = qword_1EB9A20C0;
  int v6 = *(HGPool ***)qword_1EB9A20C0;
  unint64_t v5 = *(HGPool ***)(qword_1EB9A20C0 + 8);
  if (*(HGPool ***)qword_1EB9A20C0 != v5)
  {
    while (*v6 != this)
    {
      if (++v6 == v5)
      {
        int v6 = *(HGPool ***)(qword_1EB9A20C0 + 8);
        break;
      }
    }
  }
  if (v6 != v5)
  {
    int64_t v7 = (char *)v5 - (char *)(v6 + 1);
    if (v5 != v6 + 1) {
      memmove(v6, v6 + 1, (char *)v5 - (char *)(v6 + 1));
    }
    *(void *)(v4 + 8) = (char *)v6 + v7;
  }

  std::mutex::unlock(v3);
}

void sub_1B78138D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  std::mutex::unlock(v11);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a11);
  _Unwind_Resume(a1);
}

uint64_t HGPool::setObserverThreadWakeInterval(uint64_t this)
{
  return this;
}

unint64_t HGPool::TotalUsageServicingPolicy::maxObjectsCount(HGPool::TotalUsageServicingPolicy *this, const HGPool::BasePool *a2)
{
  unint64_t v4 = (*(uint64_t (**)(HGPool::TotalUsageServicingPolicy *))(*(void *)this + 40))(this);
  unint64_t v5 = (*(uint64_t (**)(HGPool::TotalUsageServicingPolicy *, const HGPool::BasePool *))(*(void *)this + 56))(this, a2);
  unint64_t v6 = (*(uint64_t (**)(const HGPool::BasePool *))(*(void *)a2 + 16))(a2);
  unint64_t v7 = v5 - v6;
  if (v5 < v6) {
    unint64_t v7 = 0;
  }
  if (v4 >= v7) {
    return v7;
  }
  else {
    return v4;
  }
}

unint64_t HGPool::TotalUsageServicingPolicy::maxBytesUsage(HGPool::TotalUsageServicingPolicy *this, const HGPool::BasePool *a2)
{
  unint64_t v4 = (*(uint64_t (**)(HGPool::TotalUsageServicingPolicy *))(*(void *)this + 48))(this);
  unint64_t v5 = (*(uint64_t (**)(HGPool::TotalUsageServicingPolicy *, const HGPool::BasePool *))(*(void *)this + 64))(this, a2);
  unint64_t v6 = (*(uint64_t (**)(const HGPool::BasePool *))(*(void *)a2 + 24))(a2);
  unint64_t v7 = v5 - v6;
  if (v5 < v6) {
    unint64_t v7 = 0;
  }
  if (v4 >= v7) {
    return v7;
  }
  else {
    return v4;
  }
}

unint64_t HGPool::GroupServicingPolicy::_maxValue<(HGPool::GroupServicingPolicy::PolicyType)0>(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 16))(a2);
  unint64_t v7 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 32))(a2);
  uint64_t v9 = (void *)(a1 + 16);
  int v8 = *(void **)(a1 + 16);
  if (!v8) {
    goto LABEL_12;
  }
  uint64_t v10 = (void *)(a1 + 16);
  do
  {
    unint64_t v11 = v8[4];
    BOOL v12 = v11 >= a2;
    if (v11 >= a2) {
      unint64_t v13 = v8;
    }
    else {
      unint64_t v13 = v8 + 1;
    }
    if (v12) {
      uint64_t v10 = v8;
    }
    int v8 = (void *)*v13;
  }
  while (*v13);
  if (v10 == v9 || v10[4] > a2) {
LABEL_12:
  }
    uint64_t v10 = (void *)(a1 + 16);
  uint64_t v14 = v10[5];
  if (!v14
    || (unint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v14 + 16))(v14, a2), v7 <= result))
  {
    uint64_t v32 = v4;
    uint64_t v33 = a1;
    int v16 = *(void **)(a1 + 8);
    if (v16 != v9)
    {
      uint64_t v17 = 0;
      unint64_t v18 = 0;
      while (1)
      {
        long long v19 = *((_OWORD *)v16 + 2);
        uint64_t v20 = (std::__shared_weak_count *)v16[6];
        if (v20) {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v21 = v19;
        if ((void)v19 != a2)
        {
          uint64_t v22 = (*(uint64_t (**)(void))(*(void *)v19 + 32))(v19);
          uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 16))(v21);
          v18 += v22;
          v17 += v23 + (*(uint64_t (**)(uint64_t))(*(void *)v21 + 32))(v21);
        }
        if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
          uint64_t v24 = (void *)v16[1];
          if (!v24)
          {
            do
            {
LABEL_28:
              long long v25 = (void *)v16[2];
              BOOL v26 = *v25 == (void)v16;
              int v16 = v25;
            }
            while (!v26);
            goto LABEL_17;
          }
        }
        else
        {
          uint64_t v24 = (void *)v16[1];
          if (!v24) {
            goto LABEL_28;
          }
        }
        do
        {
          long long v25 = v24;
          uint64_t v24 = (void *)*v24;
        }
        while (v24);
LABEL_17:
        int v16 = v25;
        if (v25 == v9) {
          goto LABEL_32;
        }
      }
    }
    unint64_t v18 = 0;
    uint64_t v17 = 0;
LABEL_32:
    unsigned __int8 v27 = atomic_load(HGLogger::_enabled);
    if (v27) {
      HGLogger::log((HGLogger *)"sp", (const char *)1, (HGLogger *)"total other objects : free=%zu, total=%zu\n", v5, v6, v18, v17);
    }
    unint64_t v28 = v17 + v32;
    unint64_t v29 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v33 + 56))(v33, a2);
    unint64_t v30 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v33 + 40))(v33, a2);
    if (v30 >= v18 && v29 >= v28)
    {
      if (v30 - v18 >= v29 - v28) {
        return v29 - v28;
      }
      else {
        return v30 - v18;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_1B7813DD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::pair<HGPool::BasePool const* const,std::shared_ptr<HGPool::ServicingPolicy>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

unint64_t HGPool::GroupServicingPolicy::_maxValue<(HGPool::GroupServicingPolicy::PolicyType)1>(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 24))(a2);
  unint64_t v7 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 40))(a2);
  uint64_t v9 = (void *)(a1 + 16);
  int v8 = *(void **)(a1 + 16);
  if (!v8) {
    goto LABEL_12;
  }
  uint64_t v10 = (void *)(a1 + 16);
  do
  {
    unint64_t v11 = v8[4];
    BOOL v12 = v11 >= a2;
    if (v11 >= a2) {
      unint64_t v13 = v8;
    }
    else {
      unint64_t v13 = v8 + 1;
    }
    if (v12) {
      uint64_t v10 = v8;
    }
    int v8 = (void *)*v13;
  }
  while (*v13);
  if (v10 == v9 || v10[4] > a2) {
LABEL_12:
  }
    uint64_t v10 = (void *)(a1 + 16);
  uint64_t v14 = v10[5];
  if (!v14
    || (unint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v14 + 24))(v14, a2), v7 <= result))
  {
    uint64_t v32 = v4;
    uint64_t v33 = a1;
    int v16 = *(void **)(a1 + 8);
    if (v16 != v9)
    {
      uint64_t v17 = 0;
      unint64_t v18 = 0;
      while (1)
      {
        long long v19 = *((_OWORD *)v16 + 2);
        uint64_t v20 = (std::__shared_weak_count *)v16[6];
        if (v20) {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v21 = v19;
        if ((void)v19 != a2)
        {
          uint64_t v22 = (*(uint64_t (**)(void))(*(void *)v19 + 40))(v19);
          uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 24))(v21);
          v18 += v22;
          v17 += v23 + (*(uint64_t (**)(uint64_t))(*(void *)v21 + 40))(v21);
        }
        if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
          uint64_t v24 = (void *)v16[1];
          if (!v24)
          {
            do
            {
LABEL_28:
              long long v25 = (void *)v16[2];
              BOOL v26 = *v25 == (void)v16;
              int v16 = v25;
            }
            while (!v26);
            goto LABEL_17;
          }
        }
        else
        {
          uint64_t v24 = (void *)v16[1];
          if (!v24) {
            goto LABEL_28;
          }
        }
        do
        {
          long long v25 = v24;
          uint64_t v24 = (void *)*v24;
        }
        while (v24);
LABEL_17:
        int v16 = v25;
        if (v25 == v9) {
          goto LABEL_32;
        }
      }
    }
    unint64_t v18 = 0;
    uint64_t v17 = 0;
LABEL_32:
    unsigned __int8 v27 = atomic_load(HGLogger::_enabled);
    if (v27) {
      HGLogger::log((HGLogger *)"sp", (const char *)1, (HGLogger *)"total other objects : free=%zu, total=%zu\n", v5, v6, v18, v17);
    }
    unint64_t v28 = v17 + v32;
    unint64_t v29 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v33 + 64))(v33, a2);
    unint64_t v30 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v33 + 48))(v33, a2);
    if (v30 >= v18 && v29 >= v28)
    {
      if (v30 - v18 >= v29 - v28) {
        return v29 - v28;
      }
      else {
        return v30 - v18;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_1B7814124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::pair<HGPool::BasePool const* const,std::shared_ptr<HGPool::ServicingPolicy>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGPool::GroupServicingPolicy::maxObjectAgeNS(HGPool::GroupServicingPolicy *this, const HGPool::BasePool *a2)
{
  uint64_t v4 = (void *)*((void *)this + 2);
  int v2 = (char *)this + 16;
  int v3 = v4;
  if (!v4) {
    goto LABEL_12;
  }
  unint64_t v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= (unint64_t)a2;
    if (v6 >= (unint64_t)a2) {
      int v8 = v3;
    }
    else {
      int v8 = v3 + 1;
    }
    if (v7) {
      unint64_t v5 = (char *)v3;
    }
    int v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2 || *((void *)v5 + 4) > (unint64_t)a2) {
LABEL_12:
  }
    unint64_t v5 = v2;
  uint64_t v9 = *((void *)v5 + 5);
  if (v9) {
    return (*(uint64_t (**)(uint64_t, const HGPool::BasePool *))(*(void *)v9 + 32))(v9, a2);
  }
  else {
    return -1;
  }
}

void HGPool::GroupServicingPolicy::addPool(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  BOOL v7 = (uint64_t **)(a1 + 16);
  unint64_t v6 = *(uint64_t **)(a1 + 16);
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v6;
        unint64_t v9 = v6[4];
        if (v9 <= (unint64_t)a2) {
          break;
        }
        unint64_t v6 = *v8;
        BOOL v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= (unint64_t)a2) {
        break;
      }
      unint64_t v6 = v8[1];
      if (!v6)
      {
        BOOL v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    int v8 = (uint64_t **)(a1 + 16);
LABEL_8:
    uint64_t v10 = (uint64_t *)v8;
    int v8 = (uint64_t **)operator new(0x38uLL);
    v8[5] = 0;
    v8[6] = 0;
    v8[4] = a2;
    *int v8 = 0;
    v8[1] = 0;
    v8[2] = v10;
    *BOOL v7 = (uint64_t *)v8;
    uint64_t v11 = **(void **)(a1 + 8);
    BOOL v12 = (uint64_t *)v8;
    if (v11)
    {
      *(void *)(a1 + 8) = v11;
      BOOL v12 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v12);
    ++*(void *)(a1 + 24);
  }
  uint64_t v14 = *a3;
  unint64_t v13 = a3[1];
  if (v13) {
    atomic_fetch_add_explicit(v13 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = (std::__shared_weak_count *)v8[6];
  v8[5] = v14;
  v8[6] = v13;
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
}

void HGPool::GroupServicingPolicy::~GroupServicingPolicy(HGPool::GroupServicingPolicy *this)
{
  *(void *)this = &unk_1F10DE8A8;
  std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy((uint64_t)this + 8, *((void **)this + 2));
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F10DE8A8;
  std::__tree<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::__map_value_compare<HGPool::BasePool const*,std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>,std::less<HGPool::BasePool const*>,true>,std::allocator<std::__value_type<HGPool::BasePool const*,std::shared_ptr<HGPool::ServicingPolicy>>>>::destroy((uint64_t)this + 8, *((void **)this + 2));

  JUMPOUT(0x1BA9BFBA0);
}

void HGPool::BasePool::~BasePool(HGPool::BasePool *this)
{
}

uint64_t std::pair<HGPool::BasePool const* const,std::shared_ptr<HGPool::ServicingPolicy>>::~pair(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(std::__shared_weak_count **)(result + 16);
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
      return v1;
    }
  }
  return result;
}

void std::__call_once_proxy[abi:ne180100]<std::tuple<HGPool::registerPool(HGPool::BasePool *)::$_0 &&>>()
{
}

void sub_1B78144C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::thread a10)
{
}

void anonymous namespace'::poolsObserverThreadFunction(_anonymous_namespace_ *this)
{
  uint64_t v1 = (HGPool *)pthread_setname_np("com.apple.helium-pools");
  while (1)
  {
    if (qword_1EB9A20C0)
    {
      HGTraceGuard::HGTraceGuard((HGTraceGuard *)&__ns, "hgpool", 2, "HGPool::logAllPools");
      int v2 = (std::mutex *)(qword_1EB9A20C0 + 24);
      std::mutex::lock((std::mutex *)(qword_1EB9A20C0 + 24));
      int v3 = *(void **)qword_1EB9A20C0;
      uint64_t v4 = *(void **)(qword_1EB9A20C0 + 8);
      while (v3 != v4)
      {
        uint64_t v5 = *v3;
        if ((*(unsigned int (**)(void))(*(void *)*v3 + 88))(*v3)) {
          (*(void (**)(uint64_t))(*(void *)v5 + 64))(v5);
        }
        ++v3;
      }
      std::mutex::unlock(v2);
      HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&__ns);
    }
    HGPool::traceAllPools(v1);
    if (qword_1EB9A20C0)
    {
      HGTraceGuard::HGTraceGuard((HGTraceGuard *)&__ns, "hgpool", 1, "HGPool::serviceAllPools");
      unint64_t v6 = (std::mutex *)(qword_1EB9A20C0 + 24);
      std::mutex::lock((std::mutex *)(qword_1EB9A20C0 + 24));
      int v8 = *(uint64_t **)qword_1EB9A20C0;
      BOOL v7 = *(uint64_t **)(qword_1EB9A20C0 + 8);
      while (v8 != v7)
      {
        uint64_t v9 = *v8;
        if ((*(unsigned int (**)(uint64_t))(*(void *)*v8 + 72))(*v8))
        {
          unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
          if (v12) {
            HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"service pool (%p)\n", v10, v11, v9);
          }
          (*(void (**)(uint64_t))(*(void *)v9 + 48))(v9);
        }
        ++v8;
      }
      std::mutex::unlock(v6);
      HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&__ns);
    }
    if (v13)
    {
      __ns.__rep_ = 1000000000 * v13;
      std::this_thread::sleep_for (&__ns);
    }
  }
}

void sub_1B78146D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B78146EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7814700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  std::mutex::unlock(v11);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a11);
  _Unwind_Resume(a1);
}

void _ZNSt3__16threadC2IRFvvEJEvEEOT_DpOT0_()
{
}

void sub_1B78147D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__thread_struct>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B78147E4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

void sub_1B7814808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10)
{
}

uint64_t std::__thread_proxy[abi:ne180100]<std::tuple<std::unique_ptr<std::__thread_struct>,void (*)(void)>>(uint64_t a1)
{
  int v2 = std::__thread_local_data();
  int v3 = *(const void **)a1;
  *(void *)a1 = 0;
  uint64_t v4 = pthread_setspecific(v2->__key_, v3);
  (*(void (**)(uint64_t))(a1 + 8))(v4);
  uint64_t v5 = *(const void **)a1;
  *(void *)a1 = 0;
  if (v5)
  {
    uint64_t v6 = MEMORY[0x1BA9BF880]();
    MEMORY[0x1BA9BFBA0](v6, 0x20C4093837F09);
  }
  MEMORY[0x1BA9BFBA0](a1, 0xA0C40AFF93C70);
  return 0;
}

void sub_1B78148AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (*)(void)>>::~unique_ptr[abi:ne180100]((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t **std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (*)(void)>>::~unique_ptr[abi:ne180100](uint64_t **a1)
{
  int v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *v2;
    uint64_t *v2 = 0;
    if (v3)
    {
      uint64_t v4 = MEMORY[0x1BA9BF880]();
      MEMORY[0x1BA9BFBA0](v4, 0x20C4093837F09);
    }
    MEMORY[0x1BA9BFBA0](v2, 0xA0C40AFF93C70);
  }
  return a1;
}

uint64_t *std::unique_ptr<std::__thread_struct>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = MEMORY[0x1BA9BF880]();
    MEMORY[0x1BA9BFBA0](v3, 0x20C4093837F09);
  }
  return a1;
}

BOOL HGMath::IsEqualWithinTolerance(float32x4_t a1, float32x4_t a2, int32x2_t a3)
{
  int8x16_t v3 = vmvnq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(a3, 0), vabdq_f32(a1, a2)));
  *(int32x2_t *)v3.i8 = vpmin_s32(*(int32x2_t *)v3.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v3, v3, 8uLL));
  return vpmin_s32(*(int32x2_t *)v3.i8, *(int32x2_t *)v3.i8).u32[0] == 0;
}

void HGGLBlendingInfo::HGGLBlendingInfo(HGGLBlendingInfo *this, const HGBlendingInfo *a2)
{
  uint64_t v2 = *((int *)a2 + 2);
  if (v2 > 0xC)
  {
    *(_DWORD *)this = 1;
    uint64_t v3 = *((int *)a2 + 3);
    if (v3 > 0xC)
    {
LABEL_3:
      *((_DWORD *)this + 1) = 1;
      uint64_t v4 = *((int *)a2 + 4);
      if (v4 > 0xC) {
        goto LABEL_4;
      }
LABEL_8:
      *((_DWORD *)this + 2) = dword_1B8347C10[v4];
      uint64_t v5 = *((int *)a2 + 5);
      if (v5 > 0xC) {
        goto LABEL_5;
      }
      goto LABEL_9;
    }
  }
  else
  {
    *(_DWORD *)this = dword_1B8347C10[v2];
    uint64_t v3 = *((int *)a2 + 3);
    if (v3 > 0xC) {
      goto LABEL_3;
    }
  }
  *((_DWORD *)this + 1) = dword_1B8347C10[v3];
  uint64_t v4 = *((int *)a2 + 4);
  if (v4 <= 0xC) {
    goto LABEL_8;
  }
LABEL_4:
  *((_DWORD *)this + 2) = 1;
  uint64_t v5 = *((int *)a2 + 5);
  if (v5 > 0xC)
  {
LABEL_5:
    int v6 = 1;
    goto LABEL_10;
  }
LABEL_9:
  int v6 = dword_1B8347C10[v5];
LABEL_10:
  *((_DWORD *)this + 3) = v6;
  int v7 = *((_DWORD *)a2 + 6) - 1;
  if (v7 > 3)
  {
    *((_DWORD *)this + 4) = 32774;
    unsigned int v8 = *((_DWORD *)a2 + 7) - 1;
    if (v8 > 3) {
      goto LABEL_12;
    }
  }
  else
  {
    *((_DWORD *)this + 4) = dword_1B8347C50[v7];
    unsigned int v8 = *((_DWORD *)a2 + 7) - 1;
    if (v8 > 3)
    {
LABEL_12:
      *((_DWORD *)this + 5) = 32774;
      return;
    }
  }
  *((_DWORD *)this + 5) = dword_1B8347C50[v8];
}

uint64_t HGGLBlendingInfo::GetDstRGBFactor(HGGLBlendingInfo *this)
{
  return *((unsigned int *)this + 1);
}

uint64_t HGGLBlendingInfo::GetDstAlphaFactor(HGGLBlendingInfo *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t HGGLBlendingInfo::GetRGBOperation(HGGLBlendingInfo *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t HGGLBlendingInfo::GetAlphaOperation(HGGLBlendingInfo *this)
{
  return *((unsigned int *)this + 5);
}

void HGOverwrite::HGOverwrite(HGOverwrite *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v2 = &unk_1F10DE918;
  HGNode::SetFlags(v2, 0xFFFFFFFFLL, 1);
  *((_DWORD *)this + 4) |= 0x600u;
}

void sub_1B7814B1C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGOverwrite::~HGOverwrite(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

char *HGOverwrite::RenderPage(HGOverwrite *this, HGPage *a2)
{
  uint64_t v4 = *(HGGPURenderer **)a2;
  int v5 = (*(uint64_t (**)(HGOverwrite *))(*(void *)this + 112))(this);
  Buffer = (char *)*((void *)a2 + 1);
  if (Buffer)
  {
    (*(void (**)(void))(*(void *)Buffer + 16))(*((void *)a2 + 1));
  }
  else
  {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v4, *((HGRect *)a2 + 1), *((unsigned int *)a2 + 8), 0, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
    *((void *)a2 + 1) = Buffer;
  }
  (*(void (**)(HGGPURenderer *, char *))(*(void *)v4 + 144))(v4, Buffer);
  uint64_t v23 = (HGRect *)a2;
  HGGPURenderer::Clear(v4, *((HGRect *)a2 + 1), v7, v8);
  if (v5 >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = v5;
    uint64_t v11 = (uint64_t *)((char *)a2 + 44);
    do
    {
      uint64_t v13 = *(v11 - 1);
      uint64_t v14 = *v11;
      Input = HGRenderer::GetInput(v4, (HGNode *)this, v9);
      if (HGRectIsNull(v13, v14) || Input == 0) {
        goto LABEL_7;
      }
      *(void *)&v26.var0 = v13;
      *(void *)&v26.var2 = v14;
      NodeBitmap = HGGPURenderer::GetNodeBitmap(v4, Input, v26, (HGBuffer *)Buffer, 1u);
      unint64_t v18 = NodeBitmap;
      if (NodeBitmap) {
        BOOL v19 = NodeBitmap == (HGBitmap *)Buffer;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19)
      {
        (*(void (**)(HGGPURenderer *, char *))(*(void *)v4 + 144))(v4, Buffer);
        if (!v18)
        {
          HGGPURenderer::Clear(v4, v23[1], v20, v21);
          goto LABEL_7;
        }
      }
      else
      {
        *(void *)&v24.var0 = v13;
        *(void *)&v24.var2 = v14;
        uint64_t v12 = HGGPURenderer::ConvertToGLTexture(v4, v24, NodeBitmap);
        (*(void (**)(HGGPURenderer *, char *))(*(void *)v4 + 144))(v4, Buffer);
        (*(void (**)(HGGPURenderer *, void, uint64_t, void, void))(*(void *)v4 + 152))(v4, 0, v12, 0, 0);
        *(void *)&v25.var0 = v13;
        *(void *)&v25.var2 = v14;
        HGGPURenderer::Rect(v4, v25);
        (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
      }
      (*(void (**)(HGBitmap *))(*(void *)v18 + 24))(v18);
LABEL_7:
      v11 += 2;
      ++v9;
    }
    while (v10 != v9);
  }
  (*(void (**)(HGGPURenderer *, void, void, void, void))(*(void *)v4 + 152))(v4, 0, 0, 0, 0);
  return Buffer;
}

char *HGOverwrite::RenderPageMetal(HGOverwrite *this, HGPage *a2)
{
  uint64_t v4 = *(HGGPURenderer **)a2;
  int v5 = (*(uint64_t (**)(HGOverwrite *))(*(void *)this + 112))(this);
  (*(void (**)(HGGPURenderer *, void))(*(void *)v4 + 144))(v4, 0);
  Buffer = (char *)*((void *)a2 + 1);
  if (Buffer)
  {
    (*(void (**)(void))(*(void *)Buffer + 16))(*((void *)a2 + 1));
  }
  else
  {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v4, *((HGRect *)a2 + 1), *((unsigned int *)a2 + 8), 1, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
    *((void *)a2 + 1) = Buffer;
  }
  uint64_t v21 = (HGRect *)a2;
  HGGPURenderer::ClearMetal(v4, (HGBitmap *)Buffer, *((HGRect *)a2 + 1), v7);
  if (v5 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = v5;
    uint64_t v10 = (uint64_t *)((char *)a2 + 44);
    do
    {
      uint64_t v12 = *(v10 - 1);
      uint64_t v13 = *v10;
      Input = HGRenderer::GetInput(v4, (HGNode *)this, v8);
      if (HGRectIsNull(v12, v13) || Input == 0) {
        goto LABEL_7;
      }
      *(void *)&v24.var0 = v12;
      *(void *)&v24.var2 = v13;
      NodeBitmap = HGGPURenderer::GetNodeBitmap(v4, Input, v24, (HGBuffer *)Buffer, 1u);
      unint64_t v18 = NodeBitmap;
      if (NodeBitmap) {
        BOOL v19 = NodeBitmap == (HGBitmap *)Buffer;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19)
      {
        if (!NodeBitmap)
        {
          HGGPURenderer::ClearMetal(v4, (HGBitmap *)Buffer, v21[1], v17);
          goto LABEL_7;
        }
      }
      else
      {
        *(void *)&v22.var0 = v12;
        *(void *)&v22.var2 = v13;
        uint64_t v11 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v4, v22, NodeBitmap);
        *(void *)&v23.var0 = v12;
        *(void *)&v23.var2 = v13;
        HGGPURenderer::CopyMetal(v4, (HGBitmap *)Buffer, v23, v11);
        (*(void (**)(HGBitmap *))(*(void *)v11 + 24))(v11);
      }
      (*(void (**)(HGBitmap *))(*(void *)v18 + 24))(v18);
LABEL_7:
      v10 += 2;
      ++v8;
    }
    while (v9 != v8);
  }
  return Buffer;
}

uint64_t HGOverwrite::RenderTile(HGNode *this, HGTile *a2)
{
  uint64_t v3 = *(HGRenderer **)(*((void *)a2 + 42) + 152);
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = *((void *)a2 + 1);
  uint64_t v32 = HIDWORD(*(void *)a2);
  int v6 = (*(uint64_t (**)(HGNode *))(*(void *)this + 112))(this);
  uint64_t v7 = v6;
  if (v6 < 1) {
    goto LABEL_8;
  }
  uint64_t v8 = 0;
  char v35 = 0;
  uint64_t v9 = (uint64_t *)((char *)a2 + 216);
  char v33 = 1;
  do
  {
    if (HGRenderer::GetInput(v3, this, v8))
    {
      uint64_t v10 = *(v9 - 1);
      uint64_t v11 = *v9;
      uint64_t v12 = HGRectIntersection(v10, *v9, v4, v5);
      if (!HGRectIsNull(v12, v13))
      {
        char v33 = 0;
        v35 |= HGRectIsEqual(v10, v11, v4, v5);
      }
    }
    ++v8;
    v9 += 2;
  }
  while (v6 != v8);
  if (v33 & 1 | ((v35 & 1) == 0)) {
LABEL_8:
  }
    bzero(*((void **)a2 + 2), 16 * *((_DWORD *)a2 + 6) * (HIDWORD(v5) - (int)v32));
  uint64_t v34 = v5;
  uint64_t v36 = v4;
  if (v6 >= 1)
  {
    uint64_t v14 = 0;
    do
    {
      if (HGRenderer::GetInput(v3, this, v14))
      {
        uint64_t v15 = HGRectIntersection(*((void *)a2 + 2 * v14 + 26), *((void *)a2 + 2 * v14 + 27), v36, v34);
        uint64_t v17 = v16;
        if (!HGRectIsNull(v15, v16))
        {
          int v18 = HIDWORD(v17) - HIDWORD(v15);
          if (HIDWORD(v17) - HIDWORD(v15) >= 1)
          {
            int v19 = v15 - v36;
            uint64_t v20 = (char *)a2 + 16 * v14;
            uint64_t v21 = *((void *)v20 + 10);
            uint64_t v22 = *((int *)v20 + 22);
            int v23 = HIDWORD(v15) - v32;
            uint64_t v24 = *((int *)a2 + 6);
            size_t v25 = 16 * ((int)v17 - (int)v15);
            uint64_t v26 = 16 * v19;
            unsigned __int8 v27 = (char *)(v21 + v26 + 16 * (int)v22 * v23);
            uint64_t v28 = 16 * v22;
            unint64_t v29 = (char *)(*((void *)a2 + 2) + v26 + 16 * (int)v24 * v23);
            uint64_t v30 = 16 * v24;
            do
            {
              memcpy(v29, v27, v25);
              v27 += v28;
              v29 += v30;
              --v18;
            }
            while (v18);
          }
        }
      }
      ++v14;
    }
    while (v14 != v7);
  }
  return 0;
}

uint64_t HGOverwrite::GetDOD(HGOverwrite *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 8) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HGOverwrite::GetROI(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  Input = HGRenderer::GetInput(a2, this, a3);
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v12 = HGRectIntersection(DOD, v11, v5, v4);
  uint64_t v14 = v13;
  signed int v15 = (*(uint64_t (**)(HGNode *))(*(void *)this + 112))(this);
  signed int v16 = a3 + 1;
  if (v16 < v15)
  {
    signed int v17 = v15;
    do
    {
      if (HGRectIsNull(v12, v14)) {
        break;
      }
      int v18 = HGRenderer::GetInput(a2, this, v16);
      if (v18)
      {
        uint64_t v19 = HGRenderer::GetDOD(a2, v18);
        if (HGRectContainsRect(v19, v20, v12, v14))
        {
          uint64_t v12 = 0;
          uint64_t v14 = 0;
        }
      }
      ++v16;
    }
    while (v17 != v16);
  }
  return v12;
}

uint64_t HGOverwrite::SetParameter(HGOverwrite *this, float a2, float a3, float a4, float a5)
{
  return 0;
}

void HGPremultiply::HGPremultiply(HGPremultiply *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10DEB80;
  uint64_t v2 = (HgcPremultiply *)HGObject::operator new(0x1A0uLL);
  HgcPremultiply::HgcPremultiply(v2);
}

void sub_1B7815464(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7815480(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPremultiply::~HGPremultiply(HGPremultiply *this)
{
  *(void *)this = &unk_1F10DEB80;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10DEB80;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));
  HGNode::~HGNode((HGNode *)this);

  HGObject::operator delete(v2);
}

uint64_t HGPremultiply::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(void, void, HGNode *))(**((void **)this + 51) + 120))(*((void *)this + 51), 0, Input);
  return *((void *)this + 51);
}

void HGUnpremultiply::HGUnpremultiply(HGUnpremultiply *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10DEDD0;
  uint64_t v2 = (HgcUnpremultiply *)HGObject::operator new(0x1A0uLL);
  HgcUnpremultiply::HgcUnpremultiply(v2);
}

void sub_1B7815654(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7815670(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGUnpremultiply::~HGUnpremultiply(HGUnpremultiply *this)
{
  *(void *)this = &unk_1F10DEDD0;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10DEDD0;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));
  HGNode::~HGNode((HGNode *)this);

  HGObject::operator delete(v2);
}

uint64_t HGUnpremultiply::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(void, void, HGNode *))(**((void **)this + 51) + 120))(*((void *)this + 51), 0, Input);
  return *((void *)this + 51);
}

void HGPremultiplyWhiteToBlack::HGPremultiplyWhiteToBlack(HGPremultiplyWhiteToBlack *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10DF020;
  uint64_t v2 = (HgcPremultiplyWhiteToBlack *)HGObject::operator new(0x1A0uLL);
  HgcPremultiplyWhiteToBlack::HgcPremultiplyWhiteToBlack(v2);
}

void sub_1B7815844(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7815860(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGPremultiplyWhiteToBlack::~HGPremultiplyWhiteToBlack(HGPremultiplyWhiteToBlack *this)
{
  *(void *)this = &unk_1F10DF020;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10DF020;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));
  HGNode::~HGNode((HGNode *)this);

  HGObject::operator delete(v2);
}

uint64_t HGPremultiplyWhiteToBlack::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(void, void, HGNode *))(**((void **)this + 51) + 120))(*((void *)this + 51), 0, Input);
  return *((void *)this + 51);
}

HGBitmap *HGTW::_setupSamplerWrappedBuffer(uint64_t a1, HGBitmapLoader *this, HGRect *a3, int a4, int a5, const HGEdgePolicy *a6)
{
  if (*((_DWORD *)this + 3) == 1112363084 && !HGBitmapLoader::IsBitmapPadded((HGBitmapUtils **)this, (HGBitmap *)this)) {
    Buffer = 0;
  }
  else {
    Buffer = HGGPURenderer::CreateBuffer(*(void *)a1, *a3, *(unsigned int *)(a1 + 32), a5, a4, 0);
  }
  NodeBitmap = HGGPURenderer::GetNodeBitmap(*(HGGPURenderer **)a1, (HGNode *)this, *a3, (HGBuffer *)Buffer, 0);
  if (Buffer) {
    (*(void (**)(char *))(*(void *)Buffer + 24))(Buffer);
  }
  int v14 = *((_DWORD *)NodeBitmap + 3);
  if ((v14 & 0x10) == 0)
  {
    signed int v15 = (HGBuffer *)HGObject::operator new(0x80uLL);
    HGBuffer::HGBuffer(v15, *(HGRect *)((char *)NodeBitmap + 20), NodeBitmap);
LABEL_14:
    (*(void (**)(HGBitmap *))(*(void *)NodeBitmap + 24))(NodeBitmap);
    NodeBitmap = (HGBitmap *)v15;
    goto LABEL_15;
  }
  if ((v14 & 0x200) != 0)
  {
    signed int v15 = (HGBuffer *)HGObject::operator new(0xC8uLL);
    HGGLTexture::HGGLTexture((uint64_t)v15, *(void *)((char *)NodeBitmap + 20), *(void *)((char *)NodeBitmap + 28), *((_DWORD *)NodeBitmap + 4), *(void *)a1, *((_DWORD *)NodeBitmap + 40), *((void *)NodeBitmap + 21), 1);
    goto LABEL_13;
  }
  if ((v14 & 0x100) != 0)
  {
    signed int v15 = (HGBuffer *)HGObject::operator new(0xB8uLL);
    HGGLBuffer::HGGLBuffer((uint64_t)v15, *(void *)((char *)NodeBitmap + 20), *(void *)((char *)NodeBitmap + 28), *((_DWORD *)NodeBitmap + 4), *(void *)a1, *((_DWORD *)NodeBitmap + 38), *((_DWORD *)NodeBitmap + 39), 1);
LABEL_13:
    HGBitmap::SetStorage((HGBitmap *)v15, (HGObject *)NodeBitmap);
    goto LABEL_14;
  }
LABEL_15:
  HGBitmap::SetEdgePolicy(NodeBitmap, a6);
  return NodeBitmap;
}

void sub_1B7815B78(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7815B8C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7815BA0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGTW::HGTextureWrapClampToEdge::HGTextureWrapClampToEdge(HGTW::HGTextureWrapClampToEdge *this)
{
}

void sub_1B7815C5C(_Unwind_Exception *a1)
{
  HgcTextureWrapClampToEdge::~HgcTextureWrapClampToEdge(v1);
  _Unwind_Resume(a1);
}

void HGTW::HGTextureWrapClampToEdge::~HGTextureWrapClampToEdge(HGNode *this)
{
  HgcTextureWrapClampToEdge::~HgcTextureWrapClampToEdge(this);

  HGObject::operator delete(v1);
}

uint64_t HGTW::HGTextureWrapClampToEdge::SetParameter@<X0>(HGTW::HGTextureWrapClampToEdge *this@<X0>, float a2@<S0>, float a3@<S1>, float a4@<S2>, float a5@<S3>, int a6@<W1>, uint64_t a7@<X8>)
{
  if (a6 == 1)
  {
    uint64_t result = 0;
    *((unsigned char *)this + 432) = vcvtms_s32_f32(a2) != 0;
  }
  else
  {
    if (a6) {
      return 0;
    }
    uint64_t v8 = HGRectMake4f(a7, a2, a3, a4, a5);
    uint64_t v10 = v9;
    if (HGRectIsEqual(v8, v9, *((void *)this + 52), *((void *)this + 53)))
    {
      return 0;
    }
    else
    {
      *((void *)this + 52) = v8;
      *((void *)this + 53) = v10;
      return 1;
    }
  }
  return result;
}

uint64_t HGTW::HGTextureWrapClampToEdge::GetDOD(HGTW::HGTextureWrapClampToEdge *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = &HGRectNull;
  if (a3) {
    return 0;
  }
  *(HGRect *)((char *)this + 436) = a4;
  if (!HGRectIsNull(*(uint64_t *)&a4.var0, *(uint64_t *)&a4.var2)) {
    uint64_t v4 = (long long *)((char *)this + 416);
  }
  return *(void *)v4;
}

uint64_t HGTW::HGTextureWrapClampToEdge::GetROI(HGTW::HGTextureWrapClampToEdge *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
  {
    long long v9 = HGRectNull;
    return HGRectNull;
  }
  else
  {
    int32x2_t v5 = vmax_s32(vadd_s32(*(int32x2_t *)((char *)this + 436), (int32x2_t)0x200000002), *(int32x2_t *)&a4.var2);
    *(int32x2_t *)&long long v9 = vmin_s32(*(int32x2_t *)&a4.var0, vadd_s32(*(int32x2_t *)((char *)this + 444), (int32x2_t)0x100000001));
    *((int32x2_t *)&v9 + 1) = v5;
    HGRect::Intersection((HGRect *)&v9, *(HGRect *)((char *)this + 436));
    uint64_t v6 = HGRectMake4i(0xFFFFFFFE, 0xFFFFFFFE, 2u, 2u);
    uint64_t v8 = v7;
    *(void *)&v10.var0 = v6;
    *(void *)&v10.var2 = v8;
    HGRect::Grow((HGRect *)&v9, v10);
    return v9;
  }
}

HGBitmap *HGTW::HGTextureWrapClampToEdge::RenderPage(HGNode *this, HGPage *a2)
{
  return HGTW::HGTextureWrapClampToEdge::_renderPage(this, (uint64_t)a2, 0);
}

HGBitmap *HGTW::HGTextureWrapClampToEdge::_renderPage(HGNode *a1, uint64_t a2, int a3)
{
  Input = HGRenderer::GetInput(*(HGRenderer **)a2, a1, 0);
  uint64_t DOD = HGRenderer::GetDOD(*(HGRenderer **)a2, Input);
  *(void *)&v16.var0 = HGRectIntersection(DOD, v8, *(void *)(a2 + 16), *(void *)(a2 + 24));
  *(void *)&v16.var2 = v9;
  BOOL IsNull = HGRectIsNull(*(uint64_t *)&v16.var0, v9);
  BOOL IsInfinite = HGRectIsInfinite(*((void *)a1 + 52), *((void *)a1 + 53));
  BOOL v12 = 0;
  if (IsInfinite)
  {
    if (IsNull)
    {
LABEL_9:
      if (a3)
      {
        return (HGBitmap *)HGNode::RenderPageMetal(a1, (HGPage *)a2);
      }
      else
      {
        return (HGBitmap *)HGNode::RenderPage(a1, (HGRect *)a2);
      }
    }
  }
  else
  {
    BOOL v12 = *((unsigned char *)a1 + 432) == 0;
    if (IsNull) {
      goto LABEL_9;
    }
  }
  if (v12) {
    goto LABEL_9;
  }
  int v13 = 1;
  HGEdgePolicy::HGEdgePolicy((uint64_t)v15, 1);
  if ((*((unsigned char *)Input + 17) & 0x10) == 0) {
    int v13 = (*((unsigned __int8 *)a1 + 17) >> 4) & 1;
  }
  return HGTW::_setupSamplerWrappedBuffer(a2, (HGBitmapLoader *)Input, &v16, v13, a3, (const HGEdgePolicy *)v15);
}

HGBitmap *HGTW::HGTextureWrapClampToEdge::RenderPageMetal(HGNode *this, HGPage *a2)
{
  return HGTW::HGTextureWrapClampToEdge::_renderPage(this, (uint64_t)a2, 1);
}

uint64_t HGTW::HGTextureWrapClampToEdge::RenderTile(HGNode *this, HGTile *a2)
{
  uint64_t v4 = *(HGRenderer **)(*((void *)a2 + 42) + 152);
  Input = HGRenderer::GetInput(v4, this, 0);
  uint64_t DOD = HGRenderer::GetDOD(v4, Input);
  if (HGRectContainsRect(DOD, v7, *(void *)a2, *((void *)a2 + 1)))
  {
    int v8 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
    if (v8 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
    {
      int v9 = 0;
      uint64_t v10 = *((void *)a2 + 10);
      uint64_t v11 = 16 * *((int *)a2 + 22);
      uint64_t v12 = *((void *)a2 + 2);
      uint64_t v13 = 16 * *((int *)a2 + 6);
      uint64_t v14 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
      do
      {
        uint64_t v15 = 0;
        do
        {
          *(_OWORD *)(v12 + v15) = *(_OWORD *)(v10 + v15);
          v15 += 16;
        }
        while (v14 != v15);
        ++v9;
        v10 += v11;
        v12 += v13;
      }
      while (v9 != v8);
    }
    return 0;
  }
  else
  {
    return HgcTextureWrapClampToEdge::RenderTile((HgcTextureWrapClampToEdge *)this, (int32x2_t *)a2);
  }
}

void HGTW::HGTextureWrapClampToColor::~HGTextureWrapClampToColor(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGTW::HGTextureWrapClampToColor::SetParameter(HGTW::HGTextureWrapClampToColor *this, int a2, float a3, float a4, float a5, float a6, char *a7)
{
  HGNode::SetParameter((HGNode *)this, a2, a3, a4, a5, a6, a7);
  if (a2 == 2)
  {
    uint64_t result = 0;
    *(void *)&long long v14 = __PAIR64__(LODWORD(a4), LODWORD(a3));
    *((void *)&v14 + 1) = __PAIR64__(LODWORD(a6), LODWORD(a5));
    *((_OWORD *)this + 27) = v14;
  }
  else if (a2 == 1)
  {
    uint64_t result = 0;
    *((unsigned char *)this + 448) = vcvtms_s32_f32(a3) != 0;
  }
  else
  {
    if (a2) {
      return 0;
    }
    uint64_t v10 = HGRectMake4f(v9, a3, a4, a5, a6);
    uint64_t v12 = v11;
    if (HGRectIsEqual(v10, v11, *((void *)this + 51), *((void *)this + 52)))
    {
      return 0;
    }
    else
    {
      *((void *)this + 51) = v10;
      *((void *)this + 52) = v12;
      return 1;
    }
  }
  return result;
}

uint64_t HGTW::HGTextureWrapClampToColor::GetDOD(HGTW::HGTextureWrapClampToColor *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = &HGRectNull;
  if (a3) {
    return 0;
  }
  if (!HGRectIsNull(*(uint64_t *)&a4.var0, *(uint64_t *)&a4.var2)) {
    uint64_t v4 = (long long *)((char *)this + 408);
  }
  return *(void *)v4;
}

uint64_t HGTW::HGTextureWrapClampToColor::GetROI(HGTW::HGTextureWrapClampToColor *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

HGBitmap *HGTW::HGTextureWrapClampToColor::RenderPage(HGNode *this, HGPage *a2)
{
  return HGTW::HGTextureWrapClampToColor::_renderPage(this, (uint64_t)a2, 0);
}

HGBitmap *HGTW::HGTextureWrapClampToColor::_renderPage(HGNode *a1, uint64_t a2, int a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  BOOL v6 = *((float *)a1 + 108) == 0.0
    && *((float *)a1 + 109) == 0.0
    && *((float *)a1 + 110) == 0.0
    && *((float *)a1 + 111) == 0.0;
  uint64_t v7 = *(HGRenderer **)a2;
  Input = HGRenderer::GetInput(*(HGRenderer **)a2, a1, 0);
  uint64_t DOD = HGRenderer::GetDOD(v7, Input);
  uint64_t v11 = v10;
  *(void *)&v35.var0 = HGRectIntersection(DOD, v10, *(void *)(a2 + 16), *(void *)(a2 + 24));
  *(void *)&v35.var2 = v12;
  BOOL IsNull = HGRectIsNull(*(uint64_t *)&v35.var0, v12);
  if (HGRectIsInfinite(*((void *)a1 + 51), *((void *)a1 + 52)))
  {
    BOOL v14 = 1;
    if (!a3) {
      goto LABEL_22;
    }
  }
  else
  {
    BOOL v14 = *((unsigned char *)a1 + 448) != 0;
    if (!a3) {
      goto LABEL_22;
    }
  }
  MetalContext = (PCICCTransferFunctionLUT *)HGGPURenderer::GetMetalContext(v7);
  if (MetalContext)
  {
    BOOL v16 = *(unsigned char *)(PCICCTransferFunctionLUT::getLUTEnd(MetalContext) + 56) && v6;
    BOOL v17 = v16 && !IsNull;
    if (v17 && v14)
    {
      HGEdgePolicy::HGEdgePolicy((uint64_t)__str, 0);
      long long v37 = *(_OWORD *)(*((void *)a1 + 6) + 32);
      if ((*((unsigned char *)Input + 17) & 0x10) != 0) {
        int v18 = 1;
      }
      else {
        int v18 = (*((unsigned __int8 *)a1 + 17) >> 4) & 1;
      }
      return HGTW::_setupSamplerWrappedBuffer(a2, (HGBitmapLoader *)Input, &v35, v18, a3, (const HGEdgePolicy *)__str);
    }
  }
LABEL_22:
  if (!HGRectContainsRect(DOD, v11, *(void *)(a2 + 16), *(void *)(a2 + 24)))
  {
    uint64_t v22 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)a1 + 48))(a1);
    snprintf(__str, 0x100uLL, "%s::_renderPage( [%d %d %d %d])", v22, *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 20), *(_DWORD *)(a2 + 24), *(_DWORD *)(a2 + 28));
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v34, "gpu", 1, __str);
    Buffer = *(char **)(a2 + 8);
    if (Buffer) {
      (*(void (**)(void))(*(void *)Buffer + 16))(*(void *)(a2 + 8));
    }
    else {
      Buffer = HGGPURenderer::CreateBuffer((uint64_t)v7, *(HGRect *)(a2 + 16), *(unsigned int *)(a2 + 32), a3, (*((_DWORD *)a1 + 4) >> 12) & 1, *(unsigned __int8 *)(a2 + 248));
    }
    uint64_t v24 = HGRectIntersection(*(void *)(a2 + 16), *(void *)(a2 + 24), *(void *)(a2 + 36), *(void *)(a2 + 44));
    uint64_t v26 = (float *)((char *)a1 + 432);
    if (HGRectIsNull(v24, v25))
    {
      if (a3)
      {
        HGGPURenderer::ClearMetal(v7, (HGBitmap *)Buffer, *(HGRect *)(a2 + 16), v26);
      }
      else
      {
        (*(void (**)(HGRenderer *, char *))(*(void *)v7 + 144))(v7, Buffer);
        HGGPURenderer::Clear(v7, *(HGRect *)(a2 + 16), v26, v27);
      }
LABEL_45:
      HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v34);
      return (HGBitmap *)Buffer;
    }
    if (*(void *)(a2 + 168))
    {
      if (!a3) {
        goto LABEL_42;
      }
    }
    else
    {
      HGRect v28 = *(HGRect *)(a2 + 36);
      if (!a3)
      {
        *(void *)(a2 + 168) = HGGPURenderer::GetNodeTexture(v7, Input, v28, 0, 1u);
LABEL_42:
        (*(void (**)(HGRenderer *, char *))(*(void *)v7 + 144))(v7, Buffer);
        HGGPURenderer::Clear(v7, *(HGRect *)(a2 + 16), v26, v31);
        (*(void (**)(HGRenderer *, void, void, void, void))(*(void *)v7 + 152))(v7, 0, *(void *)(a2 + 168), 0, 0);
        HGGPURenderer::Copy(v7, *(HGRect *)(*(void *)(a2 + 168) + 20), 0, v32);
LABEL_43:
        uint64_t v33 = *(void *)(a2 + 168);
        if (v33) {
          (*(void (**)(uint64_t))(*(void *)v33 + 24))(v33);
        }
        goto LABEL_45;
      }
      NodeBitmap = HGGPURenderer::GetNodeBitmap(v7, Input, v28, 0, 1u);
      uint64_t v30 = (HGTexture *)HGObject::operator new(0x80uLL);
      *(void *)&v40.var0 = *(void *)((char *)NodeBitmap + 20);
      *(void *)&v40.var2 = *(void *)((char *)NodeBitmap + 28);
      HGTexture::HGTexture(v30, v40, NodeBitmap);
      *(void *)(a2 + 168) = v30;
      (*(void (**)(HGBitmap *))(*(void *)NodeBitmap + 24))(NodeBitmap);
    }
    HGGPURenderer::ClearMetal(v7, (HGBitmap *)Buffer, *(HGRect *)(a2 + 16), v26);
    HGGPURenderer::CopyMetal(v7, (HGBitmap *)Buffer, *(HGRect *)(*(void *)(a2 + 168) + 20), *(HGBitmap **)(a2 + 168));
    goto LABEL_43;
  }
  HGRect v19 = *(HGRect *)(a2 + 16);
  uint64_t v20 = *(HGBuffer **)(a2 + 8);

  return HGGPURenderer::GetNodeBitmap(v7, Input, v19, v20, 1u);
}

void sub_1B78166E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  HGObject::operator delete(v15);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a15);
  _Unwind_Resume(a1);
}

void sub_1B7816700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7816714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B781672C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

HGBitmap *HGTW::HGTextureWrapClampToColor::RenderPageMetal(HGNode *this, HGPage *a2)
{
  return HGTW::HGTextureWrapClampToColor::_renderPage(this, (uint64_t)a2, 1);
}

uint64_t HGTW::HGTextureWrapClampToColor::RenderTile(HGNode *this, HGTile *a2)
{
  if (*((float *)this + 108) != 0.0
    || *((float *)this + 109) != 0.0
    || *((float *)this + 110) != 0.0
    || *((float *)this + 111) != 0.0)
  {
    uint64_t v4 = *(HGRenderer **)(*((void *)a2 + 42) + 152);
    Input = HGRenderer::GetInput(v4, this, 0);
    unint64_t DOD = HGRenderer::GetDOD(v4, Input);
    uint64_t v8 = v7;
    if (!HGRectContainsRect(DOD, v7, *(void *)a2, *((void *)a2 + 1)))
    {
      uint64_t v10 = HGRectIntersection(DOD, v8, *(void *)a2, *((void *)a2 + 1));
      if (HGRectIsNull(v10, v11))
      {
        int v12 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
        if (v12 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
        {
          int v13 = 0;
          long long v14 = *((_OWORD *)this + 27);
          uint64_t v15 = *((void *)a2 + 2);
          uint64_t v16 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
          uint64_t v17 = 16 * *((int *)a2 + 6);
          do
          {
            uint64_t v18 = 0;
            do
            {
              *(_OWORD *)(v15 + v18) = v14;
              v18 += 16;
            }
            while (v16 != v18);
            ++v13;
            v15 += v17;
          }
          while (v13 != v12);
        }
      }
      else
      {
        unint64_t v19 = HIDWORD(DOD);
        int v21 = *(_DWORD *)a2;
        int v20 = *((_DWORD *)a2 + 1);
        if (v20 < SHIDWORD(DOD))
        {
          if (*((_DWORD *)a2 + 3) < SHIDWORD(DOD)) {
            LODWORD(v19) = *((_DWORD *)a2 + 3);
          }
          int v22 = v19 - v20;
          if (v22 >= 1)
          {
            int v23 = *((_DWORD *)a2 + 2) - v21;
            if (v23 >= 1)
            {
              int v24 = 0;
              uint64_t v25 = *((void *)a2 + 2);
              long long v26 = *((_OWORD *)this + 27);
              uint64_t v27 = 16 * v23;
              uint64_t v28 = 16 * *((int *)a2 + 6);
              do
              {
                uint64_t v29 = 0;
                do
                {
                  *(_OWORD *)(v25 + v29) = v26;
                  v29 += 16;
                }
                while (v27 != v29);
                ++v24;
                v25 += v28;
              }
              while (v24 != v22);
              int v21 = *(_DWORD *)a2;
            }
          }
        }
        int v30 = *((_DWORD *)a2 + 2);
        if (v21 < (int)DOD)
        {
          int v31 = v30 >= (int)DOD ? DOD : *((_DWORD *)a2 + 2);
          int v32 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
          if (v32 >= 1)
          {
            int v33 = v31 - v21;
            if (v33 >= 1)
            {
              int v34 = 0;
              uint64_t v35 = *((void *)a2 + 2);
              long long v36 = *((_OWORD *)this + 27);
              uint64_t v37 = 16 * v33;
              uint64_t v38 = 16 * *((int *)a2 + 6);
              do
              {
                uint64_t v39 = 0;
                do
                {
                  *(_OWORD *)(v35 + v39) = v36;
                  v39 += 16;
                }
                while (v37 != v39);
                ++v34;
                v35 += v38;
              }
              while (v34 != v32);
              int v30 = *((_DWORD *)a2 + 2);
            }
          }
        }
        if (v30 > (int)v8)
        {
          int v40 = *(_DWORD *)a2 <= (int)v8 ? v8 : *(_DWORD *)a2;
          int v41 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
          if (v41 >= 1)
          {
            unsigned int v42 = v30 - v40;
            if (v30 - v40 >= 1)
            {
              int v43 = 0;
              uint64_t v44 = *((void *)a2 + 2) + 16 * (v40 - *(_DWORD *)a2);
              long long v45 = *((_OWORD *)this + 27);
              uint64_t v46 = 16 * v42;
              uint64_t v47 = 16 * *((int *)a2 + 6);
              do
              {
                uint64_t v48 = 0;
                do
                {
                  *(_OWORD *)(v44 + v48) = v45;
                  v48 += 16;
                }
                while (v46 != v48);
                ++v43;
                v44 += v47;
              }
              while (v43 != v41);
            }
          }
        }
        int v49 = *((_DWORD *)a2 + 3);
        if (v49 > SHIDWORD(v8))
        {
          int v50 = *((_DWORD *)a2 + 1);
          int v51 = v50 <= SHIDWORD(v8) ? HIDWORD(v8) : *((_DWORD *)a2 + 1);
          int v52 = v49 - v51;
          if (v52 >= 1 && *((_DWORD *)a2 + 2) - *(_DWORD *)a2 >= 1)
          {
            int v54 = 0;
            uint64_t v55 = *((int *)a2 + 6);
            uint64_t v56 = *((void *)a2 + 2) + 16 * (v51 - v50) * (int)v55;
            long long v57 = *((_OWORD *)this + 27);
            uint64_t v58 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
            do
            {
              uint64_t v59 = 0;
              do
              {
                *(_OWORD *)(v56 + v59) = v57;
                v59 += 16;
              }
              while (v58 != v59);
              ++v54;
              v56 += 16 * v55;
            }
            while (v54 != v52);
          }
        }
      }
    }
  }
  return 0;
}

void HGTW::HGTextureWrapRepeat::~HGTextureWrapRepeat(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGTW::HGTextureWrapRepeat::SetParameter(HGTW::HGTextureWrapRepeat *this, int a2, float a3, float a4, float a5, float a6, char *a7)
{
  HGNode::SetParameter((HGNode *)this, a2, a3, a4, a5, a6, a7);
  if (a2) {
    return 0;
  }
  uint64_t v14 = HGRectMake4f(v13, a3, a4, a5, a6);
  uint64_t v16 = v15;
  if (HGRectIsEqual(v14, v15, *((void *)this + 51), *((void *)this + 52))) {
    return 0;
  }
  *((void *)this + 51) = v14;
  *((void *)this + 52) = v16;
  return 1;
}

uint64_t HGTW::HGTextureWrapRepeat::GetDOD(HGTW::HGTextureWrapRepeat *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = &HGRectNull;
  if (a3) {
    return 0;
  }
  if (!HGRectIsNull(*(uint64_t *)&a4.var0, *(uint64_t *)&a4.var2)) {
    uint64_t v4 = (long long *)((char *)this + 408);
  }
  return *(void *)v4;
}

uint64_t HGTW::HGTextureWrapRepeat::GetROI(HGTW::HGTextureWrapRepeat *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  if (*((_DWORD *)this + 10) == 1) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  if (HGRectIsNull(*(uint64_t *)&a4.var0, *(uint64_t *)&a4.var2)) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v13 = v12;
  HGTW::HGTextureWrapRepeat::_computeRoiSegments((uint64_t)this, (int)DOD, (int)v12, (int)v6, (int)v5, (char **)&v22);
  HGTW::HGTextureWrapRepeat::_computeRoiSegments((uint64_t)this, DOD >> 32, v13 >> 32, v6 >> 32, v5 >> 32, (char **)&v20);
  uint64_t v15 = (void *)v22;
  long long v16 = v22;
  uint64_t v17 = v23;
  uint64_t v14 = (void *)v20;
  long long v18 = v20;
  uint64_t v19 = v21;
  HGTW::HGTextureWrapRepeat::_buildRoiList((uint64_t)this, (int **)&v16, 0, (uint64_t **)&v22);
  uint64_t v8 = *(void *)v22;
  *((void *)&v22 + 1) = v22;
  operator delete((void *)v22);
  if (v14) {
    operator delete(v14);
  }
  if (v15) {
    operator delete(v15);
  }
  return v8;
}

void sub_1B7816CA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::pair<std::vector<HGTW::HGTextureWrapRepeat::Segment>,std::vector<HGTW::HGTextureWrapRepeat::Segment>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B7816CB8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 - 80);
  if (v3)
  {
    *(void *)(v1 - 72) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void HGTW::HGTextureWrapRepeat::_buildRoiList(uint64_t a1@<X0>, int **a2@<X1>, char a3@<W2>, uint64_t **a4@<X8>)
{
  HGTW::HGTextureWrapRepeat::_buildRoiSegments(a1, a2, a3, &__p);
  HGTW::HGTextureWrapRepeat::_buildRoiSegments(a1, a2 + 3, a3, (void **)&v29);
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  uint64_t v8 = (unsigned int *)__p;
  uint64_t v9 = v29;
  uint64_t v10 = v30;
  uint64_t v28 = v32;
  if (__p == v32)
  {
LABEL_25:
    if (!v9) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if (v29 != v30)
  {
    uint64_t v11 = 0;
    uint64_t v27 = v29;
    while (1)
    {
      uint64_t v12 = HGRectMake4i(*v8, *v9, v8[1], v9[1]);
      uint64_t v14 = v12;
      uint64_t v15 = v13;
      unint64_t v16 = (unint64_t)a4[2];
      if ((unint64_t)v11 < v16)
      {
        *uint64_t v11 = v12;
        v11[1] = v13;
        v11 += 2;
        goto LABEL_5;
      }
      uint64_t v17 = *a4;
      uint64_t v18 = ((char *)v11 - (char *)*a4) >> 4;
      unint64_t v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) >> 60) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v20 = v16 - (void)v17;
      if (v20 >> 3 > v19) {
        unint64_t v19 = v20 >> 3;
      }
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v21 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v21 = v19;
      }
      if (v21)
      {
        if (v21 >> 60) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        long long v22 = (char *)operator new(16 * v21);
        uint64_t v23 = (uint64_t *)&v22[16 * v18];
        *uint64_t v23 = v14;
        v23[1] = v15;
        if (v11 == v17)
        {
LABEL_21:
          uint64_t v25 = v11;
          uint64_t v11 = v23 + 2;
          *a4 = v23;
          a4[1] = v23 + 2;
          a4[2] = (uint64_t *)&v22[16 * v21];
          if (!v25) {
            goto LABEL_5;
          }
          goto LABEL_22;
        }
      }
      else
      {
        long long v22 = 0;
        uint64_t v23 = (uint64_t *)(16 * v18);
        *uint64_t v23 = v14;
        v23[1] = v13;
        if (v11 == v17) {
          goto LABEL_21;
        }
      }
      int v24 = v23;
      do
      {
        *((_OWORD *)v24 - 1) = *((_OWORD *)v11 - 1);
        v24 -= 2;
        v11 -= 2;
      }
      while (v11 != v17);
      uint64_t v25 = *a4;
      uint64_t v11 = v23 + 2;
      *a4 = v24;
      a4[1] = v23 + 2;
      a4[2] = (uint64_t *)&v22[16 * v21];
      if (!v25) {
        goto LABEL_5;
      }
LABEL_22:
      operator delete(v25);
LABEL_5:
      a4[1] = v11;
      v9 += 2;
      if (v9 == v10)
      {
        v8 += 2;
        uint64_t v9 = v27;
        if (v8 == v28)
        {
          uint64_t v9 = v29;
          goto LABEL_25;
        }
      }
    }
  }
  uint64_t v9 = v30;
  if (v30) {
LABEL_26:
  }
    operator delete(v9);
LABEL_27:
  long long v26 = __p;
  if (__p)
  {
    operator delete(v26);
  }
}

void sub_1B7816EF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (!__p) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::pair<std::vector<HGTW::HGTextureWrapRepeat::Segment>,std::vector<HGTW::HGTextureWrapRepeat::Segment>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

string_t HGTW::HGTextureWrapRepeat::GetProgram(HGTW::HGTextureWrapRepeat *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) <= 0x60B0F)
  {
    if (!*((unsigned char *)this + 448)) {
      return 0;
    }
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
      HGString::sampleRect((HGString *)0x60310, 0, v14);
    }
    else {
      HGString::sample2d((HGString *)0x60620, 0, 0, (HGString *)v14);
    }
    string_t v8 = HGString::c_str(v14, v9, v10, v11);
  }
  else
  {
    BOOL v4 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27;
    HGString::sample2d((HGString *)0x60B10, 0, v4, (HGString *)v14);
    string_t v8 = HGString::c_str(v14, v5, v6, v7);
  }
  string_t v13 = v8;
  HGString::~HGString((HGString *)v14);
  return v13;
}

void sub_1B78170DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B78170F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7817104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGTW::HGTextureWrapRepeat::InitProgramDescriptor(HGTW::HGTextureWrapRepeat *this, HGProgramDescriptor *a2)
{
  HGMetalUtils::stringForMetalHeader((uint64_t)&v28);
  HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)1, 0, (uint64_t)v26);
  if ((v27 & 0x80u) == 0) {
    uint64_t v3 = v26;
  }
  else {
    uint64_t v3 = (void **)v26[0];
  }
  if ((v27 & 0x80u) == 0) {
    std::string::size_type v4 = v27;
  }
  else {
    std::string::size_type v4 = (std::string::size_type)v26[1];
  }
  double v5 = std::string::append(&v28, (const std::string::value_type *)v3, v4);
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v29.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  HGMetalUtils::stringForMetalVertexShader((HGMetalUtils *)"vertexFunc", (const char *)1, 0, (uint64_t)v24);
  if ((v25 & 0x80u) == 0) {
    uint32x4_t v7 = v24;
  }
  else {
    uint32x4_t v7 = (void **)v24[0];
  }
  if ((v25 & 0x80u) == 0) {
    std::string::size_type v8 = v25;
  }
  else {
    std::string::size_type v8 = (std::string::size_type)v24[1];
  }
  double v9 = std::string::append(&v29, (const std::string::value_type *)v7, v8);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  HGMetalUtils::stringForMetalFragmentOutputStruct((HGMetalUtils *)1, 0, (uint64_t)__p);
  if ((v23 & 0x80u) == 0) {
    uint32x4_t v11 = __p;
  }
  else {
    uint32x4_t v11 = (void **)__p[0];
  }
  if ((v23 & 0x80u) == 0) {
    std::string::size_type v12 = v23;
  }
  else {
    std::string::size_type v12 = (std::string::size_type)__p[1];
  }
  string_t v13 = std::string::append(&v30, (const std::string::value_type *)v11, v12);
  long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v31.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  HGString::sample2d((HGString *)0x60B10, 0, 0, (HGString *)&v21);
  uint64_t v18 = HGString::c_str(&v21, v15, v16, v17);
  unint64_t v19 = std::string::append(&v31, v18);
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  std::string::size_type v33 = v19->__r_.__value_.__r.__words[2];
  long long v32 = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  HGString::~HGString((HGString *)&v21);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v31.__r_.__value_.__l.__data_);
    if (((char)v23 & 0x80000000) == 0)
    {
LABEL_21:
      if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_22;
      }
      goto LABEL_29;
    }
  }
  else if (((char)v23 & 0x80000000) == 0)
  {
    goto LABEL_21;
  }
  operator delete(__p[0]);
  if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_22:
    if (((char)v25 & 0x80000000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_30;
  }
LABEL_29:
  operator delete(v30.__r_.__value_.__l.__data_);
  if (((char)v25 & 0x80000000) == 0)
  {
LABEL_23:
    if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_31;
  }
LABEL_30:
  operator delete(v24[0]);
  if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_24:
    if (((char)v27 & 0x80000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_32;
  }
LABEL_31:
  operator delete(v29.__r_.__value_.__l.__data_);
  if (((char)v27 & 0x80000000) == 0)
  {
LABEL_25:
    if ((SHIBYTE(v28.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_26;
    }
LABEL_33:
    operator delete(v28.__r_.__value_.__l.__data_);
LABEL_26:
    HGProgramDescriptor::SetVertexFunctionName(a2, "vertexFunc");
  }
LABEL_32:
  operator delete(v26[0]);
  if ((SHIBYTE(v28.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_26;
  }
  goto LABEL_33;
}

void sub_1B7817760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v49 - 128));
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v49 - 96));
  if (*(char *)(v49 - 41) < 0) {
    operator delete(*(void **)(v49 - 64));
  }
  _Unwind_Resume(a1);
}

uint64_t HGTW::HGTextureWrapRepeat::BindTexture(HGTW::HGTextureWrapRepeat *this, HGHandler *a2, int a3)
{
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  return 0;
}

uint64_t HGTW::HGTextureWrapRepeat::Bind(HGTW::HGTextureWrapRepeat *this, HGHandler *a2)
{
  return 0;
}

HGBitmap *HGTW::HGTextureWrapRepeat::RenderPage(HGNode *this, HGPage *a2)
{
  return HGTW::HGTextureWrapRepeat::_renderPage(this, (uint64_t)a2, 0);
}

HGBitmap *HGTW::HGTextureWrapRepeat::_renderPage(HGNode *a1, uint64_t a2, int a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  long long v6 = *(HGRenderer **)a2;
  Input = HGRenderer::GetInput(*(HGRenderer **)a2, a1, 0);
  uint64_t DOD = HGRenderer::GetDOD(v6, Input);
  uint64_t v10 = v9;
  if (HGRectContainsRect(DOD, v9, *(void *)(a2 + 16), *(void *)(a2 + 24)))
  {
    HGRect v11 = *(HGRect *)(a2 + 16);
    std::string::size_type v12 = *(HGBuffer **)(a2 + 8);
    return HGGPURenderer::GetNodeBitmap(v6, Input, v11, v12, 1u);
  }
  long long v14 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)a1 + 48))(a1);
  snprintf(__str, 0x100uLL, "%s::_renderPage( [%d %d %d %d])", v14, *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 20), *(_DWORD *)(a2 + 24), *(_DWORD *)(a2 + 28));
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v42, "gpu", 1, __str);
  uint64_t v15 = *(void *)(a2 + 16);
  uint64_t v16 = *(void *)(a2 + 24);
  HGTW::HGTextureWrapRepeat::_computeRoiSegments((uint64_t)a1, (int)DOD, (int)v10, (int)v15, (int)v16, (char **)__p);
  HGTW::HGTextureWrapRepeat::_computeRoiSegments((uint64_t)a1, DOD >> 32, v10 >> 32, v15 >> 32, v16 >> 32, (char **)&v43);
  long long v36 = __p[0];
  long long v38 = *(_OWORD *)__p;
  uint64_t v39 = v46;
  uint64_t v35 = (void *)v43;
  long long v40 = v43;
  uint64_t v41 = v44;
  HGTW::HGTextureWrapRepeat::_buildRoiList((uint64_t)a1, (int **)&v38, 1, (uint64_t **)__p);
  if (a3 == 1) {
    (*(void (**)(HGRenderer *, void))(*(void *)v6 + 144))(v6, 0);
  }
  Buffer = *(char **)(a2 + 8);
  if (Buffer)
  {
    (*(void (**)(void))(*(void *)Buffer + 16))(*(void *)(a2 + 8));
    int v37 = a3;
    unint64_t v19 = __p[0];
    uint64_t v18 = __p[1];
    if (__p[1] == __p[0]) {
      goto LABEL_20;
    }
LABEL_11:
    if (v37)
    {
      unint64_t v20 = 0;
      unsigned int v21 = 1;
      do
      {
        uint64_t v22 = a2 + 8 * v20;
        uint64_t v24 = *(void *)(v22 + 168);
        unsigned __int8 v23 = (HGTexture **)(v22 + 168);
        if (!v24)
        {
          unsigned __int8 v25 = (HGRect *)&v19[16 * v20];
          *(HGRect *)(a2 + 16 * v20 + 36) = *v25;
          NodeBitmap = HGGPURenderer::GetNodeBitmap(v6, Input, *v25, 0, 1u);
          unsigned __int8 v27 = HGGPURenderer::ConvertToNonGLTexture(v6, NodeBitmap);
          std::string v28 = (HGTexture *)HGObject::operator new(0x80uLL);
          *(void *)&v50.var0 = *(void *)((char *)v27 + 20);
          *(void *)&v50.var2 = *(void *)((char *)v27 + 28);
          HGTexture::HGTexture(v28, v50, v27);
          *unsigned __int8 v23 = v28;
          (*(void (**)(HGBitmap *))(*(void *)v27 + 24))(v27);
          (*(void (**)(HGBitmap *))(*(void *)NodeBitmap + 24))(NodeBitmap);
          unint64_t v19 = __p[0];
          uint64_t v18 = __p[1];
        }
        unint64_t v20 = v21++;
      }
      while (v20 < (v18 - v19) >> 4);
    }
    else
    {
      unint64_t v29 = 0;
      unsigned int v30 = 1;
      do
      {
        uint64_t v31 = a2 + 8 * v29;
        uint64_t v33 = *(void *)(v31 + 168);
        long long v32 = (unsigned int **)(v31 + 168);
        if (!v33)
        {
          int v34 = (HGRect *)&v19[16 * v29];
          *(HGRect *)(a2 + 16 * v29 + 36) = *v34;
          *long long v32 = HGGPURenderer::GetNodeTexture(v6, Input, *v34, 0, 1u);
          unint64_t v19 = __p[0];
          uint64_t v18 = __p[1];
        }
        unint64_t v29 = v30++;
      }
      while (v29 < (v18 - v19) >> 4);
    }
    goto LABEL_20;
  }
  Buffer = HGGPURenderer::CreateBuffer((uint64_t)v6, *(HGRect *)(a2 + 16), *(unsigned int *)(a2 + 32), a3, (*((_DWORD *)a1 + 4) >> 12) & 1, *(unsigned __int8 *)(a2 + 248));
  int v37 = a3;
  unint64_t v19 = __p[0];
  uint64_t v18 = __p[1];
  if (__p[1] != __p[0]) {
    goto LABEL_11;
  }
LABEL_20:
  if (v37 == 1)
  {
    HGTW::HGTextureWrapRepeat::_renderPageCore_Metal(a1, (void *)a2, (uint64_t *)&v38, (uint64_t **)__p, (HGBitmap *)Buffer);
  }
  else if (!v37)
  {
    HGTW::HGTextureWrapRepeat::_renderPageCore_GL((uint64_t)a1, (HGGPURenderer **)a2, &v38, (uint64_t **)__p, (uint64_t)Buffer);
  }
  HGPage::ReleaseTextures((HGPage *)a2);
  if (!v37) {
    glFlush();
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v35) {
    operator delete(v35);
  }
  if (v36) {
    operator delete(v36);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v42);
  return (HGBitmap *)Buffer;
}

void sub_1B7817EF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34)
{
  if (__p)
  {
    a34 = (uint64_t)__p;
    operator delete(__p);
  }
  std::pair<std::vector<HGTW::HGTextureWrapRepeat::Segment>,std::vector<HGTW::HGTextureWrapRepeat::Segment>>::~pair((uint64_t)&a21);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a27);
  _Unwind_Resume(a1);
}

HGBitmap *HGTW::HGTextureWrapRepeat::RenderPageMetal(HGNode *this, HGPage *a2)
{
  return HGTW::HGTextureWrapRepeat::_renderPage(this, (uint64_t)a2, 1);
}

uint64_t HGTW::HGTextureWrapRepeat::_renderPageCore_GL(uint64_t a1, HGGPURenderer **a2, void *a3, uint64_t **a4, uint64_t a5)
{
  std::string::size_type v8 = *a2;
  uint64_t result = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)*a2 + 144))(*a2, a5);
  uint64_t v10 = *a3;
  uint64_t v27 = a3[1];
  std::string v28 = a3;
  if (*a3 != v27)
  {
    uint64_t v31 = (unsigned char *)a3[4];
    if ((unsigned char *)a3[3] != v31)
    {
      __asm { FMOV            V8.2S, #1.0 }
      unsigned int v30 = a4;
      while (1)
      {
        uint64_t v16 = (unsigned char *)v28[3];
        if (v16 != v31) {
          break;
        }
LABEL_4:
        v10 += 20;
        if (v10 == v27) {
          return result;
        }
      }
      uint32x4_t v17 = v16 + 16;
      while (1)
      {
        unint64_t v19 = v17 - 16;
        uint64_t v20 = HGRectMake4i(*(_DWORD *)v10, *((_DWORD *)v17 - 4), *(_DWORD *)(v10 + 4), *((_DWORD *)v17 - 3));
        uint64_t v22 = v21;
        uint64_t v23 = HGRectMake4i(*(_DWORD *)(v10 + 8), *((_DWORD *)v17 - 2), *(_DWORD *)(v10 + 12), *((_DWORD *)v17 - 1));
        uint64_t v25 = v24;
        uint64_t result = HGRectContainsRect(**a4, (*a4)[1], v23, v24);
        if (result)
        {
          uint64_t v26 = 0;
          if (!*(unsigned char *)(a1 + 448)) {
            goto LABEL_8;
          }
        }
        else
        {
          uint64_t result = HGRectContainsRect((*a4)[2], (*a4)[3], v23, v25);
          if (result)
          {
            uint64_t v26 = 1;
            if (!*(unsigned char *)(a1 + 448)) {
              goto LABEL_8;
            }
          }
          else
          {
            uint64_t result = HGRectContainsRect((*a4)[4], (*a4)[5], v23, v25);
            if (result)
            {
              uint64_t v26 = 2;
              if (!*(unsigned char *)(a1 + 448)) {
                goto LABEL_8;
              }
            }
            else
            {
              uint64_t result = HGRectContainsRect((*a4)[6], (*a4)[7], v23, v25);
              if (result) {
                uint64_t v26 = 3;
              }
              else {
                uint64_t v26 = 0;
              }
              if (!*(unsigned char *)(a1 + 448)) {
                goto LABEL_8;
              }
            }
          }
        }
        *(void *)(a1 + 432) = _D8;
        *(float *)(a1 + 424) = (float)-(int)v20;
        *(float *)(a1 + 428) = (float)-HIDWORD(v20);
        *(float *)(a1 + 440) = (float)(int)v23;
        *(float *)(a1 + 444) = (float)SHIDWORD(v23);
        if (*(unsigned char *)(v10 + 16))
        {
          if (!*v17) {
            goto LABEL_26;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 432) = -1082130432;
          *(float *)(a1 + 440) = (float)(int)v23 + (float)(v25 - v23);
          if (!*v17)
          {
LABEL_26:
            *(_DWORD *)(a1 + 436) = -1082130432;
            *(float *)(a1 + 444) = (float)SHIDWORD(v23) + (float)(HIDWORD(v25) - HIDWORD(v23));
          }
        }
        (*(void (**)(HGGPURenderer *, void, HGGPURenderer *, void, void))(*(void *)v8 + 152))(v8, 0, a2[v26 + 21], 0, 0);
        uint64_t v18 = (HGHandler *)(*(uint64_t (**)(HGGPURenderer *, void, uint64_t))(*(void *)v8 + 368))(v8, *(void *)(a1 + 64), a1);
        (*(void (**)(uint64_t, HGGPURenderer **, uint64_t, HGHandler *))(*(void *)a1 + 488))(a1, a2, v26, v18);
        *(void *)&v32.var0 = v20;
        *(void *)&v32.var2 = v22;
        HGGPURenderer::Rect(v8, v18, v32, 1);
        (*(void (**)(uint64_t, HGGPURenderer **, uint64_t, HGHandler *))(*(void *)a1 + 496))(a1, a2, v26, v18);
        uint64_t result = (*(uint64_t (**)(HGGPURenderer *, void, void, void, void))(*(void *)v8 + 152))(v8, 0, 0, 0, 0);
LABEL_8:
        v17 += 20;
        a4 = v30;
        if (v19 + 20 == v31) {
          goto LABEL_4;
        }
      }
    }
  }
  return result;
}

void HGTW::HGTextureWrapRepeat::_renderPageCore_Metal(void *a1, void *a2, uint64_t *a3, uint64_t **a4, HGBitmap *a5)
{
  uint64_t v215 = *MEMORY[0x1E4F143B8];
  long long v213 = 0u;
  long long v214 = 0u;
  long long v211 = 0u;
  long long v212 = 0u;
  long long v210 = 0u;
  long long v209 = 0u;
  *(_OWORD *)__p = 0u;
  long long v208 = 0u;
  long long v205 = 0u;
  *(_OWORD *)v206 = 0u;
  *(_OWORD *)v203 = 0u;
  *(_OWORD *)v204 = 0u;
  uint64_t v5 = *a3;
  uint64_t v178 = a3[1];
  if (*a3 != v178)
  {
    uint64_t v183 = a3[4];
    if (a3[3] != v183)
    {
      while (1)
      {
        uint64_t v6 = a3[3];
        if (v6 != v183) {
          break;
        }
LABEL_4:
        v5 += 20;
        if (v5 == v178) {
          goto LABEL_239;
        }
      }
      uint64_t v182 = v5;
      while (1)
      {
        uint64_t v8 = HGRectMake4i(*(_DWORD *)v5, *(_DWORD *)v6, *(_DWORD *)(v5 + 4), *(_DWORD *)(v6 + 4));
        uint64_t v10 = v9;
        uint64_t v11 = HGRectMake4i(*(_DWORD *)(v5 + 8), *(_DWORD *)(v6 + 8), *(_DWORD *)(v5 + 12), *(_DWORD *)(v6 + 12));
        uint64_t v13 = v12;
        if (HGRectContainsRect(**a4, (*a4)[1], v11, v12))
        {
          unsigned int v16 = 0;
        }
        else if (HGRectContainsRect((*a4)[2], (*a4)[3], v11, v13))
        {
          unsigned int v16 = 1;
        }
        else if (HGRectContainsRect((*a4)[4], (*a4)[5], v11, v13))
        {
          unsigned int v16 = 2;
        }
        else if (HGRectContainsRect((*a4)[6], (*a4)[7], v11, v13))
        {
          unsigned int v16 = 3;
        }
        else
        {
          unsigned int v16 = 0;
        }
        unint64_t v17 = v13 & 0xFFFFFFFF00000000 | v11;
        if (*(unsigned char *)(v5 + 16))
        {
          unint64_t v17 = v13;
          int v18 = v11;
        }
        else
        {
          int v18 = v13;
        }
        int v187 = v18;
        unint64_t v19 = v17 | v11 & 0xFFFFFFFF00000000;
        if (*(unsigned char *)(v6 + 16)) {
          unint64_t v19 = v17;
        }
        unint64_t v188 = v19;
        if (*(unsigned char *)(v6 + 16)) {
          int v20 = HIDWORD(v11);
        }
        else {
          int v20 = HIDWORD(v17);
        }
        int v186 = v20;
        uint64_t v21 = (char **)&v209 + 3 * v16;
        *(float *)&long long v14 = (float)(int)v8;
        float v22 = (float)SHIDWORD(v8);
        DWORD2(v14) = 0;
        HIDWORD(v14) = 1.0;
        long long v23 = v14;
        *((float *)&v23 + 1) = (float)SHIDWORD(v8);
        uint64_t v24 = (uint64_t *)(v21 + 1);
        uint64_t v25 = v21[1];
        uint64_t v27 = (unint64_t *)(v21 + 2);
        unint64_t v26 = (unint64_t)v21[2];
        long long v198 = v14;
        if ((unint64_t)v25 < v26)
        {
          *(_OWORD *)uint64_t v25 = v23;
          std::string v28 = (char *)*v27;
          unint64_t v29 = v25 + 16;
          goto LABEL_43;
        }
        unsigned int v30 = *v21;
        uint64_t v31 = (v25 - *v21) >> 4;
        unint64_t v32 = v31 + 1;
        if ((unint64_t)(v31 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v33 = v26 - (void)v30;
        if (v33 >> 3 > v32) {
          unint64_t v32 = v33 >> 3;
        }
        if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v34 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v34 = v32;
        }
        float v195 = v22;
        if (v34)
        {
          long long v189 = v23;
          if (v34 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v35 = (char *)operator new(16 * v34);
          float v22 = v195;
          long long v14 = v198;
          DWORD1(v23) = DWORD1(v189);
          long long v36 = &v35[16 * v31];
          *(_OWORD *)long long v36 = v189;
          unint64_t v29 = v36 + 16;
          if (v25 == v30) {
            goto LABEL_41;
          }
        }
        else
        {
          uint64_t v35 = 0;
          long long v36 = (char *)(16 * v31);
          int v37 = (_OWORD *)(16 * v31);
          *int v37 = v23;
          unint64_t v29 = (char *)(v37 + 1);
          if (v25 == v30) {
            goto LABEL_41;
          }
        }
        do
        {
          long long v38 = *((_OWORD *)v25 - 1);
          v25 -= 16;
          DWORD1(v23) = DWORD1(v38);
          *((_OWORD *)v36 - 1) = v38;
          v36 -= 16;
        }
        while (v25 != v30);
        uint64_t v25 = *v21;
LABEL_41:
        std::string v28 = &v35[16 * v34];
        *uint64_t v21 = v36;
        *uint64_t v27 = (unint64_t)v28;
        if (v25)
        {
          operator delete(v25);
          float v22 = v195;
          long long v14 = v198;
        }
LABEL_43:
        *uint64_t v24 = (uint64_t)v29;
        *(float *)&long long v15 = (float)(int)v10;
        DWORD2(v15) = 0;
        HIDWORD(v15) = 1.0;
        long long v190 = v15;
        *((float *)&v15 + 1) = v22;
        long long v196 = v15;
        if (v29 < v28)
        {
          *(_OWORD *)unint64_t v29 = v15;
          long long v40 = (char *)*v27;
          uint64_t v41 = v29 + 16;
          goto LABEL_61;
        }
        unsigned int v42 = *v21;
        uint64_t v43 = (v29 - *v21) >> 4;
        unint64_t v44 = v43 + 1;
        if ((unint64_t)(v43 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if ((v28 - v42) >> 3 > v44) {
          unint64_t v44 = (v28 - v42) >> 3;
        }
        if ((unint64_t)(v28 - v42) >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v45 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v45 = v44;
        }
        if (v45)
        {
          if (v45 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v46 = (char *)operator new(16 * v45);
          DWORD1(v15) = DWORD1(v196);
          long long v14 = v198;
          uint64_t v47 = &v46[16 * v43];
          long long v40 = &v46[16 * v45];
          *(_OWORD *)uint64_t v47 = v196;
          uint64_t v41 = v47 + 16;
          if (v29 == v42)
          {
LABEL_59:
            *uint64_t v21 = v47;
            *uint64_t v27 = (unint64_t)v40;
LABEL_60:
            operator delete(v29);
            long long v14 = v198;
            goto LABEL_61;
          }
        }
        else
        {
          uint64_t v47 = (char *)(16 * v43);
          long long v40 = 0;
          uint64_t v48 = (_OWORD *)(16 * v43);
          *uint64_t v48 = v15;
          uint64_t v41 = (char *)(v48 + 1);
          if (v29 == v42) {
            goto LABEL_59;
          }
        }
        do
        {
          long long v49 = *((_OWORD *)v29 - 1);
          v29 -= 16;
          DWORD1(v23) = DWORD1(v49);
          *((_OWORD *)v47 - 1) = v49;
          v47 -= 16;
        }
        while (v29 != v42);
        unint64_t v29 = *v21;
        *uint64_t v21 = v47;
        *uint64_t v27 = (unint64_t)v40;
        if (v29) {
          goto LABEL_60;
        }
LABEL_61:
        *uint64_t v24 = (uint64_t)v41;
        *(float *)&long long v23 = (float)SHIDWORD(v10);
        uint64_t v185 = v23;
        *((float *)&v14 + 1) = (float)SHIDWORD(v10);
        long long v199 = v14;
        if (v41 < v40)
        {
          *(_OWORD *)uint64_t v41 = v14;
          unint64_t v50 = *v27;
          int v51 = v41 + 16;
          long long v52 = v196;
          *uint64_t v24 = (uint64_t)(v41 + 16);
          if ((unint64_t)(v41 + 16) < v50) {
            goto LABEL_78;
          }
          goto LABEL_82;
        }
        float32x4_t v53 = *v21;
        uint64_t v54 = (v41 - *v21) >> 4;
        unint64_t v55 = v54 + 1;
        if ((unint64_t)(v54 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if ((v40 - v53) >> 3 > v55) {
          unint64_t v55 = (v40 - v53) >> 3;
        }
        if ((unint64_t)(v40 - v53) >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v56 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v56 = v55;
        }
        if (v56)
        {
          if (v56 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          long long v57 = (char *)operator new(16 * v56);
          long long v14 = v199;
          uint64_t v58 = &v57[16 * v54];
          unint64_t v50 = (unint64_t)&v57[16 * v56];
          *(_OWORD *)uint64_t v58 = v199;
          int v51 = v58 + 16;
          if (v41 == v53)
          {
LABEL_80:
            *uint64_t v21 = v58;
            *uint64_t v27 = v50;
            goto LABEL_81;
          }
        }
        else
        {
          uint64_t v58 = (char *)(16 * v54);
          unint64_t v50 = 0;
          uint64_t v59 = (_OWORD *)(16 * v54);
          *uint64_t v59 = v14;
          int v51 = (char *)(v59 + 1);
          if (v41 == v53) {
            goto LABEL_80;
          }
        }
        do
        {
          long long v60 = *((_OWORD *)v41 - 1);
          v41 -= 16;
          *((_OWORD *)v58 - 1) = v60;
          v58 -= 16;
        }
        while (v41 != v53);
        uint64_t v41 = *v21;
        *uint64_t v21 = v58;
        *uint64_t v27 = v50;
        if (!v41)
        {
          long long v52 = v196;
          *uint64_t v24 = (uint64_t)v51;
          if ((unint64_t)v51 < v50) {
            goto LABEL_78;
          }
          goto LABEL_82;
        }
LABEL_81:
        operator delete(v41);
        long long v52 = v196;
        long long v14 = v199;
        *uint64_t v24 = (uint64_t)v51;
        if ((unint64_t)v51 < v50)
        {
LABEL_78:
          *(_OWORD *)int v51 = v52;
          unint64_t v61 = *v27;
          float32x4_t v62 = v51 + 16;
          *uint64_t v24 = (uint64_t)(v51 + 16);
          if ((unint64_t)(v51 + 16) < v61) {
            goto LABEL_96;
          }
          goto LABEL_100;
        }
LABEL_82:
        int v63 = *v21;
        uint64_t v64 = (v51 - *v21) >> 4;
        unint64_t v65 = v64 + 1;
        if ((unint64_t)(v64 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if ((uint64_t)(v50 - (void)v63) >> 3 > v65) {
          unint64_t v65 = (uint64_t)(v50 - (void)v63) >> 3;
        }
        if (v50 - (unint64_t)v63 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v66 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v66 = v65;
        }
        if (v66)
        {
          if (v66 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v67 = (char *)operator new(16 * v66);
          long long v14 = v199;
          int v68 = &v67[16 * v64];
          unint64_t v61 = (unint64_t)&v67[16 * v66];
          *(_OWORD *)int v68 = v196;
          float32x4_t v62 = v68 + 16;
          if (v51 == v63)
          {
LABEL_98:
            *uint64_t v21 = v68;
            *uint64_t v27 = v61;
            goto LABEL_99;
          }
        }
        else
        {
          int v68 = (char *)(16 * v64);
          unint64_t v61 = 0;
          uint64_t v69 = (_OWORD *)(16 * v64);
          *uint64_t v69 = v52;
          float32x4_t v62 = (char *)(v69 + 1);
          if (v51 == v63) {
            goto LABEL_98;
          }
        }
        do
        {
          long long v70 = *((_OWORD *)v51 - 1);
          v51 -= 16;
          *((_OWORD *)v68 - 1) = v70;
          v68 -= 16;
        }
        while (v51 != v63);
        int v51 = *v21;
        *uint64_t v21 = v68;
        *uint64_t v27 = v61;
        if (!v51)
        {
          *uint64_t v24 = (uint64_t)v62;
          if ((unint64_t)v62 < v61) {
            goto LABEL_96;
          }
          goto LABEL_100;
        }
LABEL_99:
        operator delete(v51);
        long long v14 = v199;
        *uint64_t v24 = (uint64_t)v62;
        if ((unint64_t)v62 < v61)
        {
LABEL_96:
          *(_OWORD *)float32x4_t v62 = v14;
          unint64_t v71 = *v27;
          uint64_t v72 = v62 + 16;
          *uint64_t v24 = (uint64_t)(v62 + 16);
          long long v73 = v190;
          DWORD1(v14) = HIDWORD(v185);
          DWORD1(v73) = v185;
          if ((unint64_t)(v62 + 16) < v71) {
            goto LABEL_114;
          }
          goto LABEL_117;
        }
LABEL_100:
        int v74 = *v21;
        uint64_t v75 = (v62 - *v21) >> 4;
        unint64_t v76 = v75 + 1;
        if ((unint64_t)(v75 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if ((uint64_t)(v61 - (void)v74) >> 3 > v76) {
          unint64_t v76 = (uint64_t)(v61 - (void)v74) >> 3;
        }
        if (v61 - (unint64_t)v74 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v77 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v77 = v76;
        }
        if (v77)
        {
          if (v77 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v78 = (char *)operator new(16 * v77);
          uint64_t v79 = &v78[16 * v75];
          unint64_t v71 = (unint64_t)&v78[16 * v77];
          *(_OWORD *)uint64_t v79 = v199;
          uint64_t v72 = v79 + 16;
          if (v62 == v74)
          {
LABEL_115:
            *uint64_t v21 = v79;
            *uint64_t v27 = v71;
            goto LABEL_116;
          }
        }
        else
        {
          uint64_t v79 = (char *)(16 * v75);
          unint64_t v71 = 0;
          uint64_t v80 = (_OWORD *)(16 * v75);
          *uint64_t v80 = v14;
          uint64_t v72 = (char *)(v80 + 1);
          if (v62 == v74) {
            goto LABEL_115;
          }
        }
        do
        {
          long long v81 = *((_OWORD *)v62 - 1);
          v62 -= 16;
          *((_OWORD *)v79 - 1) = v81;
          v79 -= 16;
        }
        while (v62 != v74);
        float32x4_t v62 = *v21;
        *uint64_t v21 = v79;
        *uint64_t v27 = v71;
        if (!v62)
        {
          *uint64_t v24 = (uint64_t)v72;
          long long v73 = v190;
          DWORD1(v14) = HIDWORD(v185);
          DWORD1(v73) = v185;
          if ((unint64_t)v72 < v71) {
            goto LABEL_114;
          }
          goto LABEL_117;
        }
LABEL_116:
        operator delete(v62);
        *uint64_t v24 = (uint64_t)v72;
        long long v73 = v190;
        DWORD1(v14) = HIDWORD(v185);
        DWORD1(v73) = v185;
        if ((unint64_t)v72 < v71)
        {
LABEL_114:
          *(_OWORD *)uint64_t v72 = v73;
          uint64_t v82 = (uint64_t)(v72 + 16);
          unint64_t v83 = v188;
          goto LABEL_133;
        }
LABEL_117:
        uint64_t v84 = *v21;
        uint64_t v85 = (v72 - *v21) >> 4;
        unint64_t v86 = v85 + 1;
        if ((unint64_t)(v85 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if ((uint64_t)(v71 - (void)v84) >> 3 > v86) {
          unint64_t v86 = (uint64_t)(v71 - (void)v84) >> 3;
        }
        if (v71 - (unint64_t)v84 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v87 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v87 = v86;
        }
        if (v87)
        {
          long long v191 = v73;
          if (v87 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          float32x4_t v88 = (char *)operator new(16 * v87);
          float32x4_t v89 = &v88[16 * v85];
          int v90 = &v88[16 * v87];
          *(_OWORD *)float32x4_t v89 = v191;
          uint64_t v82 = (uint64_t)(v89 + 16);
          if (v72 == v84)
          {
LABEL_131:
            *uint64_t v21 = v89;
            *uint64_t v27 = (unint64_t)v90;
            unint64_t v83 = v188;
LABEL_132:
            operator delete(v72);
            goto LABEL_133;
          }
        }
        else
        {
          float32x4_t v89 = (char *)(16 * v85);
          int v90 = 0;
          *(_OWORD *)(16 * v85) = v73;
          uint64_t v82 = 16 * v85 + 16;
          if (v72 == v84) {
            goto LABEL_131;
          }
        }
        unint64_t v83 = v188;
        do
        {
          long long v91 = *((_OWORD *)v72 - 1);
          v72 -= 16;
          *((_OWORD *)v89 - 1) = v91;
          v89 -= 16;
        }
        while (v72 != v84);
        uint64_t v72 = *v21;
        *uint64_t v21 = v89;
        *uint64_t v27 = (unint64_t)v90;
        if (v72) {
          goto LABEL_132;
        }
LABEL_133:
        *uint64_t v24 = v82;
        float32x4_t v92 = &v203[3 * v16];
        *(float *)&long long v14 = (float)v187;
        float v93 = (float)v186;
        DWORD2(v14) = 0;
        HIDWORD(v14) = 1.0;
        long long v94 = v14;
        *((float *)&v94 + 1) = (float)v186;
        uint64_t v95 = (uint64_t *)(v92 + 1);
        uint64_t v96 = (char *)v92[1];
        uint64_t v98 = (unint64_t *)(v92 + 2);
        int v97 = (char *)v92[2];
        long long v200 = v14;
        if (v96 < v97)
        {
          *(_OWORD *)uint64_t v96 = v94;
          uint64_t v99 = (char *)*v98;
          uint64_t v100 = v96 + 16;
          goto LABEL_150;
        }
        float32x4_t v101 = (char *)*v92;
        uint64_t v102 = (v96 - (unsigned char *)*v92) >> 4;
        unint64_t v103 = v102 + 1;
        if ((unint64_t)(v102 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v104 = v97 - v101;
        if (v104 >> 3 > v103) {
          unint64_t v103 = v104 >> 3;
        }
        if ((unint64_t)v104 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v105 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v105 = v103;
        }
        if (v105)
        {
          long long v192 = v94;
          if (v105 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          float32x4_t v106 = (char *)operator new(16 * v105);
          float v93 = (float)v186;
          long long v14 = v200;
          float32x4_t v107 = &v106[16 * v102];
          *(_OWORD *)float32x4_t v107 = v192;
          uint64_t v100 = v107 + 16;
          if (v96 == v101) {
            goto LABEL_148;
          }
        }
        else
        {
          float32x4_t v106 = 0;
          float32x4_t v107 = (char *)(16 * v102);
          float32x4_t v108 = (_OWORD *)(16 * v102);
          *float32x4_t v108 = v94;
          uint64_t v100 = (char *)(v108 + 1);
          if (v96 == v101) {
            goto LABEL_148;
          }
        }
        do
        {
          long long v109 = *((_OWORD *)v96 - 1);
          v96 -= 16;
          *((_OWORD *)v107 - 1) = v109;
          v107 -= 16;
        }
        while (v96 != v101);
        uint64_t v96 = (char *)*v92;
LABEL_148:
        uint64_t v99 = &v106[16 * v105];
        *float32x4_t v92 = v107;
        *uint64_t v98 = (unint64_t)v99;
        if (v96)
        {
          operator delete(v96);
          float v93 = (float)v186;
          long long v14 = v200;
        }
LABEL_150:
        *uint64_t v95 = (uint64_t)v100;
        *(float *)&long long v15 = (float)(int)v83;
        DWORD2(v15) = 0;
        HIDWORD(v15) = 1.0;
        long long v193 = v15;
        *((float *)&v15 + 1) = v93;
        long long v197 = v15;
        if (v100 < v99)
        {
          *(_OWORD *)uint64_t v100 = v15;
          uint64_t v111 = (char *)*v98;
          float32x4_t v112 = v100 + 16;
          goto LABEL_168;
        }
        long long v113 = (char *)*v92;
        uint64_t v114 = (v100 - (unsigned char *)*v92) >> 4;
        unint64_t v115 = v114 + 1;
        if ((unint64_t)(v114 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if ((v99 - v113) >> 3 > v115) {
          unint64_t v115 = (v99 - v113) >> 3;
        }
        if ((unint64_t)(v99 - v113) >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v116 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v116 = v115;
        }
        if (v116)
        {
          if (v116 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          float32_t v117 = (char *)operator new(16 * v116);
          long long v14 = v200;
          unsigned int v118 = &v117[16 * v114];
          uint64_t v111 = &v117[16 * v116];
          *(_OWORD *)unsigned int v118 = v197;
          float32x4_t v112 = v118 + 16;
          if (v100 == v113)
          {
LABEL_166:
            *float32x4_t v92 = v118;
            *uint64_t v98 = (unint64_t)v111;
LABEL_167:
            operator delete(v100);
            long long v14 = v200;
            goto LABEL_168;
          }
        }
        else
        {
          unsigned int v118 = (char *)(16 * v114);
          uint64_t v111 = 0;
          float v119 = (_OWORD *)(16 * v114);
          *float v119 = v15;
          float32x4_t v112 = (char *)(v119 + 1);
          if (v100 == v113) {
            goto LABEL_166;
          }
        }
        do
        {
          long long v120 = *((_OWORD *)v100 - 1);
          v100 -= 16;
          *((_OWORD *)v118 - 1) = v120;
          v118 -= 16;
        }
        while (v100 != v113);
        uint64_t v100 = (char *)*v92;
        *float32x4_t v92 = v118;
        *uint64_t v98 = (unint64_t)v111;
        if (v100) {
          goto LABEL_167;
        }
LABEL_168:
        *uint64_t v95 = (uint64_t)v112;
        *((float *)&v14 + 1) = (float)SHIDWORD(v83);
        long long v201 = v14;
        if (v112 < v111)
        {
          *(_OWORD *)float32x4_t v112 = v14;
          unint64_t v121 = *v98;
          v122 = v112 + 16;
          long long v123 = v197;
          *uint64_t v95 = (uint64_t)(v112 + 16);
          if ((unint64_t)(v112 + 16) < v121) {
            goto LABEL_185;
          }
          goto LABEL_189;
        }
        v124 = (char *)*v92;
        uint64_t v125 = (v112 - (unsigned char *)*v92) >> 4;
        unint64_t v126 = v125 + 1;
        if ((unint64_t)(v125 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if ((v111 - v124) >> 3 > v126) {
          unint64_t v126 = (v111 - v124) >> 3;
        }
        if ((unint64_t)(v111 - v124) >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v127 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v127 = v126;
        }
        if (v127)
        {
          if (v127 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          float32x4_t v128 = (char *)operator new(16 * v127);
          long long v14 = v201;
          float32x4_t v129 = &v128[16 * v125];
          unint64_t v121 = (unint64_t)&v128[16 * v127];
          *(_OWORD *)float32x4_t v129 = v201;
          v122 = v129 + 16;
          if (v112 == v124)
          {
LABEL_187:
            *float32x4_t v92 = v129;
            *uint64_t v98 = v121;
            goto LABEL_188;
          }
        }
        else
        {
          float32x4_t v129 = (char *)(16 * v125);
          unint64_t v121 = 0;
          float32x2_t v130 = (_OWORD *)(16 * v125);
          *float32x2_t v130 = v14;
          v122 = (char *)(v130 + 1);
          if (v112 == v124) {
            goto LABEL_187;
          }
        }
        do
        {
          long long v131 = *((_OWORD *)v112 - 1);
          v112 -= 16;
          *((_OWORD *)v129 - 1) = v131;
          v129 -= 16;
        }
        while (v112 != v124);
        float32x4_t v112 = (char *)*v92;
        *float32x4_t v92 = v129;
        *uint64_t v98 = v121;
        if (!v112)
        {
          long long v123 = v197;
          *uint64_t v95 = (uint64_t)v122;
          if ((unint64_t)v122 < v121) {
            goto LABEL_185;
          }
          goto LABEL_189;
        }
LABEL_188:
        operator delete(v112);
        long long v123 = v197;
        long long v14 = v201;
        *uint64_t v95 = (uint64_t)v122;
        if ((unint64_t)v122 < v121)
        {
LABEL_185:
          *(_OWORD *)v122 = v123;
          unint64_t v132 = *v98;
          v133 = v122 + 16;
          *uint64_t v95 = (uint64_t)(v122 + 16);
          if ((unint64_t)(v122 + 16) < v132) {
            goto LABEL_203;
          }
          goto LABEL_206;
        }
LABEL_189:
        v134 = (char *)*v92;
        uint64_t v135 = (v122 - (unsigned char *)*v92) >> 4;
        unint64_t v136 = v135 + 1;
        if ((unint64_t)(v135 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if ((uint64_t)(v121 - (void)v134) >> 3 > v136) {
          unint64_t v136 = (uint64_t)(v121 - (void)v134) >> 3;
        }
        if (v121 - (unint64_t)v134 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v137 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v137 = v136;
        }
        if (v137)
        {
          if (v137 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          v138 = (char *)operator new(16 * v137);
          long long v14 = v201;
          v139 = &v138[16 * v135];
          unint64_t v132 = (unint64_t)&v138[16 * v137];
          *(_OWORD *)v139 = v197;
          v133 = v139 + 16;
          if (v122 == v134)
          {
LABEL_204:
            *float32x4_t v92 = v139;
            *uint64_t v98 = v132;
            goto LABEL_205;
          }
        }
        else
        {
          v139 = (char *)(16 * v135);
          unint64_t v132 = 0;
          v140 = (_OWORD *)(16 * v135);
          _OWORD *v140 = v123;
          v133 = (char *)(v140 + 1);
          if (v122 == v134) {
            goto LABEL_204;
          }
        }
        do
        {
          long long v141 = *((_OWORD *)v122 - 1);
          v122 -= 16;
          *((_OWORD *)v139 - 1) = v141;
          v139 -= 16;
        }
        while (v122 != v134);
        v122 = (char *)*v92;
        *float32x4_t v92 = v139;
        *uint64_t v98 = v132;
        if (!v122)
        {
          *uint64_t v95 = (uint64_t)v133;
          if ((unint64_t)v133 < v132) {
            goto LABEL_203;
          }
          goto LABEL_206;
        }
LABEL_205:
        operator delete(v122);
        long long v14 = v201;
        *uint64_t v95 = (uint64_t)v133;
        if ((unint64_t)v133 < v132)
        {
LABEL_203:
          *(_OWORD *)v133 = v14;
          v142 = (char *)*v98;
          v143 = v133 + 16;
          goto LABEL_222;
        }
LABEL_206:
        v144 = (char *)*v92;
        uint64_t v145 = (v133 - (unsigned char *)*v92) >> 4;
        unint64_t v146 = v145 + 1;
        if ((unint64_t)(v145 + 1) >> 60) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if ((uint64_t)(v132 - (void)v144) >> 3 > v146) {
          unint64_t v146 = (uint64_t)(v132 - (void)v144) >> 3;
        }
        if (v132 - (unint64_t)v144 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v147 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v147 = v146;
        }
        if (v147)
        {
          if (v147 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          v148 = (char *)operator new(16 * v147);
          v149 = &v148[16 * v145];
          v142 = &v148[16 * v147];
          *(_OWORD *)v149 = v201;
          v143 = v149 + 16;
          if (v133 == v144)
          {
LABEL_220:
            *float32x4_t v92 = v149;
            *uint64_t v98 = (unint64_t)v142;
LABEL_221:
            operator delete(v133);
            goto LABEL_222;
          }
        }
        else
        {
          v149 = (char *)(16 * v145);
          v142 = 0;
          v150 = (_OWORD *)(16 * v145);
          _OWORD *v150 = v14;
          v143 = (char *)(v150 + 1);
          if (v133 == v144) {
            goto LABEL_220;
          }
        }
        do
        {
          long long v151 = *((_OWORD *)v133 - 1);
          v133 -= 16;
          *((_OWORD *)v149 - 1) = v151;
          v149 -= 16;
        }
        while (v133 != v144);
        v133 = (char *)*v92;
        *float32x4_t v92 = v149;
        *uint64_t v98 = (unint64_t)v142;
        if (v133) {
          goto LABEL_221;
        }
LABEL_222:
        *uint64_t v95 = (uint64_t)v143;
        long long v152 = v193;
        *((float *)&v152 + 1) = (float)SHIDWORD(v83);
        if (v143 >= v142)
        {
          v153 = (char *)*v92;
          uint64_t v154 = (v143 - (unsigned char *)*v92) >> 4;
          unint64_t v155 = v154 + 1;
          if ((unint64_t)(v154 + 1) >> 60) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          if ((v142 - v153) >> 3 > v155) {
            unint64_t v155 = (v142 - v153) >> 3;
          }
          if ((unint64_t)(v142 - v153) >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v156 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v156 = v155;
          }
          if (v156)
          {
            long long v194 = v152;
            if (v156 >> 60) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            v157 = (char *)operator new(16 * v156);
            v158 = &v157[16 * v154];
            v159 = &v157[16 * v156];
            *(_OWORD *)v158 = v194;
            uint64_t v7 = (uint64_t)(v158 + 16);
            if (v143 == v153)
            {
LABEL_237:
              *float32x4_t v92 = v158;
              *uint64_t v98 = (unint64_t)v159;
LABEL_238:
              operator delete(v143);
              goto LABEL_8;
            }
          }
          else
          {
            v158 = (char *)(16 * v154);
            v159 = 0;
            *(_OWORD *)(16 * v154) = v152;
            uint64_t v7 = 16 * v154 + 16;
            if (v143 == v153) {
              goto LABEL_237;
            }
          }
          do
          {
            long long v160 = *((_OWORD *)v143 - 1);
            v143 -= 16;
            *((_OWORD *)v158 - 1) = v160;
            v158 -= 16;
          }
          while (v143 != v153);
          v143 = (char *)*v92;
          *float32x4_t v92 = v158;
          *uint64_t v98 = (unint64_t)v159;
          if (!v143) {
            goto LABEL_8;
          }
          goto LABEL_238;
        }
        *(_OWORD *)v143 = v152;
        uint64_t v7 = (uint64_t)(v143 + 16);
LABEL_8:
        uint64_t v5 = v182;
        *uint64_t v95 = v7;
        v6 += 20;
        if (v6 == v183) {
          goto LABEL_4;
        }
      }
    }
  }
LABEL_239:
  unint64_t v161 = 0;
  uint64_t v162 = 0;
  while (*(void *)((char *)&v209 + v161) != *(void *)((char *)&v209 + v161 + 8))
  {
    v163 = (const void *)(*(uint64_t (**)(void, void))(*(void *)*a2 + 368))(*a2, a1[8]);
    if (v163)
    {
      if (v164)
      {
        v165 = v164;
        v166 = (const char *)(*(uint64_t (**)(void *))(*a1 + 48))(a1);
        size_t v167 = strlen(v166);
        if (v167 >= 0x7FFFFFFFFFFFFFF8) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        std::string::size_type v168 = v167;
        if (v167 >= 0x17)
        {
          uint64_t v170 = (v167 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v167 | 7) != 0x17) {
            uint64_t v170 = v167 | 7;
          }
          uint64_t v171 = v170 + 1;
          p_dst = (std::string *)operator new(v170 + 1);
          __dst.__r_.__value_.__l.__size_ = v168;
          __dst.__r_.__value_.__r.__words[2] = v171 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
        }
        else
        {
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v167;
          p_dst = &__dst;
          if (!v167) {
            goto LABEL_252;
          }
        }
        memmove(p_dst, v166, v168);
LABEL_252:
        p_dst->__r_.__value_.__s.__data_[v168] = 0;
        HGMetalHandler::SetDebugLabel(v165, &__dst);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        HGMetalHandler::BindBuffer((HGMetalHandler *)v165, a5);
        v172 = &a2[v162];
        HGMetalHandler::BindTexture((HGMetalTexture ***)v165, 0, (HGBitmap *)v172[21]);
        __n128 v173 = HGMetalHandler::BindTexture((HGMetalTexture ***)v165, v162, (HGBitmap *)v172[21]);
        v174 = *(void **)((char *)&v209 + v161);
        v175 = v203[v161 / 8];
        uint64_t v176 = *(void *)((char *)&v209 + v161 + 8);
        (*(void (**)(void *, void *, uint64_t, std::string *, __n128))(*a1 + 488))(a1, a2, v162, v165, v173);
        HGMetalHandler::PrimitivesDraw((uint64_t)v165, 3u, v174, (unint64_t)(v176 - (void)v174) >> 4, v175);
        (*(void (**)(void *, void *, uint64_t, std::string *))(*a1 + 496))(a1, a2, v162, v165);
      }
    }
    ++v162;
    v161 += 24;
    if (v162 == 4) {
      break;
    }
  }
  if (__p[1])
  {
    *(void **)&long long v208 = __p[1];
    operator delete(__p[1]);
  }
  if (v206[0])
  {
    v206[1] = v206[0];
    operator delete(v206[0]);
  }
  if (v204[1])
  {
    *(void **)&long long v205 = v204[1];
    operator delete(v204[1]);
  }
  if (v203[0])
  {
    v203[1] = v203[0];
    operator delete(v203[0]);
  }
  if (*((void *)&v213 + 1))
  {
    *(void *)&long long v214 = *((void *)&v213 + 1);
    operator delete(*((void **)&v213 + 1));
  }
  if ((void)v212)
  {
    *((void *)&v212 + 1) = v212;
    operator delete((void *)v212);
  }
  if (*((void *)&v210 + 1))
  {
    *(void *)&long long v211 = *((void *)&v210 + 1);
    operator delete(*((void **)&v210 + 1));
  }
  if ((void)v209)
  {
    *((void *)&v209 + 1) = v209;
    operator delete((void *)v209);
  }
}

void sub_1B78194D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46)
{
  if (a35 < 0)
  {
    operator delete(__p);
    uint64_t v48 = a45;
    if (!a45)
    {
LABEL_3:
      long long v49 = a42;
      if (!a42) {
        goto LABEL_4;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v48 = a45;
    if (!a45) {
      goto LABEL_3;
    }
  }
  operator delete(v48);
  long long v49 = a42;
  if (!a42)
  {
LABEL_4:
    unint64_t v50 = a39;
    if (!a39) {
      goto LABEL_5;
    }
    goto LABEL_14;
  }
LABEL_13:
  operator delete(v49);
  unint64_t v50 = a39;
  if (!a39)
  {
LABEL_5:
    int v51 = a36;
    if (!a36) {
      goto LABEL_6;
    }
    goto LABEL_15;
  }
LABEL_14:
  operator delete(v50);
  int v51 = a36;
  if (!a36)
  {
LABEL_6:
    long long v52 = *(void **)(v46 - 136);
    if (!v52) {
      goto LABEL_7;
    }
    goto LABEL_16;
  }
LABEL_15:
  operator delete(v51);
  long long v52 = *(void **)(v46 - 136);
  if (!v52)
  {
LABEL_7:
    float32x4_t v53 = *(void **)(v46 - 160);
    if (!v53) {
      goto LABEL_8;
    }
    goto LABEL_17;
  }
LABEL_16:
  *(void *)(v46 - 128) = v52;
  operator delete(v52);
  float32x4_t v53 = *(void **)(v46 - 160);
  if (!v53)
  {
LABEL_8:
    uint64_t v54 = *(void **)(v46 - 184);
    if (!v54) {
      goto LABEL_9;
    }
    goto LABEL_18;
  }
LABEL_17:
  *(void *)(v46 - 152) = v53;
  operator delete(v53);
  uint64_t v54 = *(void **)(v46 - 184);
  if (!v54)
  {
LABEL_9:
    unint64_t v55 = *(void **)(v46 - 208);
    if (!v55) {
      goto LABEL_10;
    }
    goto LABEL_19;
  }
LABEL_18:
  *(void *)(v46 - 176) = v54;
  operator delete(v54);
  unint64_t v55 = *(void **)(v46 - 208);
  if (!v55) {
LABEL_10:
  }
    _Unwind_Resume(exception_object);
LABEL_19:
  *(void *)(v46 - 200) = v55;
  operator delete(v55);
  _Unwind_Resume(exception_object);
}

uint64_t HGTW::HGTextureWrapRepeat::RenderTile(HGNode *this, HGTile *a2)
{
  uint64_t v4 = *((void *)a2 + 42);
  uint64_t v5 = *(HGRenderer **)(v4 + 152);
  Input = HGRenderer::GetInput(v5, this, 0);
  uint64_t DOD = HGRenderer::GetDOD(v5, Input);
  uint64_t v9 = v8;
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *((void *)a2 + 1);
  HGTW::HGTextureWrapRepeat::_computeRoiSegments((uint64_t)this, (int)DOD, (int)v8, (int)*(void *)a2, (int)v11, (char **)&v39);
  HGTW::HGTextureWrapRepeat::_computeRoiSegments((uint64_t)this, DOD >> 32, v9 >> 32, v10 >> 32, v11 >> 32, v38);
  long long v12 = v39;
  uint64_t v13 = v38[0];
  int v37 = v38[1];
  HGExecutionUnit::CommitStack(v4, *((void *)a2 + 2), *((int *)a2 + 6) * (*((int *)a2 + 3) - (uint64_t)*((int *)a2 + 1)));
  if ((void)v12 != *((void *)&v12 + 1) && v13 != v37)
  {
    for (unsigned int i = (int *)v12; i != *((int **)&v12 + 1); i += 5)
    {
      long long v15 = v13;
      do
      {
        unint64_t v16 = HGRectMake4i(i[2], *((_DWORD *)v15 + 2), i[3], *((_DWORD *)v15 + 3));
        *((void *)a2 + 26) = v16;
        *((void *)a2 + 27) = v17;
        *(void *)&long long v39 = 0;
        DWORD2(v39) = 0;
        HGRenderer::RenderInput((uint64_t)v5, v4, (uint64_t)this, 0, (uint64_t)&v39, v16, v17, 0);
        *((_OWORD *)a2 + 5) = v39;
        if (*((unsigned char *)i + 16))
        {
          int v18 = i[2];
          uint64_t v19 = 1;
          uint64_t v20 = *((int *)a2 + 22);
          if (!v15[16]) {
            goto LABEL_12;
          }
        }
        else
        {
          int v18 = i[3] - 1;
          uint64_t v19 = -1;
          uint64_t v20 = *((int *)a2 + 22);
          if (!v15[16])
          {
LABEL_12:
            int v21 = *((_DWORD *)v15 + 3) - 1;
            int v22 = -1;
            int v23 = *((_DWORD *)v15 + 1);
            uint64_t v24 = *(int *)v15;
            if ((int)v24 >= v23) {
              goto LABEL_6;
            }
            goto LABEL_13;
          }
        }
        int v21 = *((_DWORD *)v15 + 2);
        int v22 = 1;
        int v23 = *((_DWORD *)v15 + 1);
        uint64_t v24 = *(int *)v15;
        if ((int)v24 >= v23) {
          goto LABEL_6;
        }
LABEL_13:
        LODWORD(v25) = i[1];
        if (*i < (int)v25)
        {
          uint64_t v26 = *((int *)a2 + 6);
          uint64_t v27 = v21;
          uint64_t v28 = 16 * (v24 - *((int *)a2 + 1)) * v26 - 16 * *(int *)a2;
          uint64_t v29 = 16 * v26;
          uint64_t v30 = 16 * (v27 - *((int *)a2 + 53)) * v20 + 16 * v18 - 16 * *((int *)a2 + 52);
          uint64_t v31 = 16 * v22 * (uint64_t)(int)v20;
          uint64_t v32 = 16 * v19;
          do
          {
            uint64_t v33 = *i;
            if ((int)v33 < (int)v25)
            {
              uint64_t v34 = *((void *)a2 + 2) + v28;
              uint64_t v35 = (_OWORD *)(*((void *)a2 + 10) + v30);
              do
              {
                *(_OWORD *)(v34 + 16 * v33++) = *v35;
                uint64_t v25 = i[1];
                uint64_t v35 = (_OWORD *)((char *)v35 + v32);
              }
              while (v33 < v25);
              int v23 = *((_DWORD *)v15 + 1);
            }
            ++v24;
            v28 += v29;
            v30 += v31;
          }
          while (v24 < v23);
        }
LABEL_6:
        v15 += 20;
      }
      while (v15 != v37);
    }
  }
  if (v13) {
    operator delete(v13);
  }
  if ((void)v12) {
    operator delete((void *)v12);
  }
  return 0;
}

void sub_1B7819900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::pair<std::vector<HGTW::HGTextureWrapRepeat::Segment>,std::vector<HGTW::HGTextureWrapRepeat::Segment>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B7819914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B7819930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::pair<std::vector<HGTW::HGTextureWrapRepeat::Segment>,std::vector<HGTW::HGTextureWrapRepeat::Segment>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B7819944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::pair<std::vector<HGTW::HGTextureWrapRepeat::Segment>,std::vector<HGTW::HGTextureWrapRepeat::Segment>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGTW::HGTextureWrapRepeat::_computeRoiSegments@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, char **a6@<X8>)
{
  uint64_t v6 = a6;
  *a6 = 0;
  a6[1] = 0;
  a6[2] = 0;
  uint64_t v7 = a3 - a2;
  uint64_t v8 = (a4 - a2) % (a3 - a2);
  uint64_t v9 = (a5 - a2) % (a3 - a2);
  uint64_t v10 = (v8 >> 63) + (a4 - a2) / (a3 - a2);
  uint64_t v11 = (v9 >> 63) + (a5 - a2) / (a3 - a2);
  if (v10 <= v11)
  {
    long long v12 = 0;
    uint64_t v13 = ((v8 >> 63) & v7) + v8;
    int v14 = ((v9 >> 63) & v7) + v9;
    int v15 = v14 + a2;
    int v16 = a3 + a2;
    uint64_t v17 = v10;
    uint64_t v46 = this;
    int v47 = a2;
    int v48 = a3;
    long long v49 = v6;
    uint64_t v44 = v10;
    int v45 = a3 - a2;
    int v42 = v13;
    uint64_t v43 = (v9 >> 63) + (a5 - a2) / (a3 - a2);
    int v40 = v14 + a2;
    int v41 = v14;
    int v39 = a3 + a2;
    do
    {
      while (1)
      {
        int v18 = v17 * v7 + a2;
        int v19 = v17 == v10 ? v13 : 0;
        int v20 = v18 + v19;
        int v21 = v19 + a2;
        int v22 = v18 + v14;
        BOOL v23 = (v17 & 1) == 0 || *(unsigned char *)(this + 449) == 0;
        BOOL v24 = v23;
        int v25 = v17 == v11 ? v15 : a3;
        int v26 = v17 == v11 ? v22 : v17 * v7 + a3;
        int v27 = v24 ? v21 : v16 - v25;
        int v28 = v24 ? v25 : v16 - v21;
        unint64_t v29 = (unint64_t)v6[2];
        if ((unint64_t)v12 >= v29) {
          break;
        }
        *(_DWORD *)long long v12 = v20;
        *((_DWORD *)v12 + 1) = v26;
        *((_DWORD *)v12 + 2) = v27;
        *((_DWORD *)v12 + 3) = v28;
        v12[16] = v24;
        *(_WORD *)(v12 + 17) = 0;
        v12[19] = 0;
        v6[1] = v12 + 20;
        v12 += 20;
        BOOL v23 = v17++ == v11;
        if (v23) {
          return this;
        }
      }
      uint64_t v30 = *v6;
      unint64_t v31 = 0xCCCCCCCCCCCCCCCDLL * ((v12 - v30) >> 2) + 1;
      if (v31 > 0xCCCCCCCCCCCCCCCLL) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v32 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v29 - (void)v30) >> 2);
      if (2 * v32 > v31) {
        unint64_t v31 = 2 * v32;
      }
      if (v32 >= 0x666666666666666) {
        unint64_t v33 = 0xCCCCCCCCCCCCCCCLL;
      }
      else {
        unint64_t v33 = v31;
      }
      if (v33)
      {
        if (v33 > 0xCCCCCCCCCCCCCCCLL) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v34 = (char *)operator new(20 * v33);
      }
      else
      {
        uint64_t v34 = 0;
      }
      uint64_t v35 = &v34[4 * ((v12 - v30) >> 2)];
      *(_DWORD *)uint64_t v35 = v20;
      *((_DWORD *)v35 + 1) = v26;
      *((_DWORD *)v35 + 2) = v27;
      *((_DWORD *)v35 + 3) = v28;
      v35[16] = v24;
      *(_WORD *)(v35 + 17) = 0;
      v35[19] = 0;
      long long v36 = v35;
      if (v12 == v30)
      {
        uint64_t v6 = v49;
        long long v38 = v35 + 20;
        *long long v49 = v35;
        v49[1] = v35 + 20;
        v49[2] = &v34[20 * v33];
        if (!v12) {
          goto LABEL_41;
        }
      }
      else
      {
        do
        {
          long long v37 = *(_OWORD *)(v12 - 20);
          *((_DWORD *)v36 - 1) = *((_DWORD *)v12 - 1);
          *(_OWORD *)(v36 - 20) = v37;
          v36 -= 20;
          v12 -= 20;
        }
        while (v12 != v30);
        uint64_t v6 = v49;
        long long v12 = *v49;
        long long v38 = v35 + 20;
        *long long v49 = v36;
        v49[1] = v35 + 20;
        v49[2] = &v34[20 * v33];
        if (!v12) {
          goto LABEL_41;
        }
      }
      operator delete(v12);
LABEL_41:
      LODWORD(a2) = v47;
      LODWORD(a3) = v48;
      LODWORD(v7) = v45;
      this = v46;
      uint64_t v11 = v43;
      uint64_t v10 = v44;
      int v14 = v41;
      LODWORD(v13) = v42;
      int v16 = v39;
      int v15 = v40;
      v6[1] = v38;
      long long v12 = v38;
      BOOL v23 = v17++ == v43;
    }
    while (!v23);
  }
  return this;
}

void sub_1B7819BF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (v20)
  {
    *(void *)(a20 + 8) = v20;
    operator delete(v20);
  }
  _Unwind_Resume(exception_object);
}

void HGTW::HGTextureWrapRepeat::_buildRoiSegments(uint64_t a1@<X0>, int **a2@<X1>, char a3@<W2>, void **a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  uint64_t v5 = *a2;
  unint64_t v6 = 0xCCCCCCCCCCCCCCCDLL * (a2[1] - *a2);
  if (v6 != 2)
  {
    if (v6 == 1)
    {
      uint64_t v7 = *((void *)v5 + 1);
      uint64_t v8 = operator new(8uLL);
      *a4 = v8;
      *uint64_t v8 = v7;
      uint64_t v9 = v8 + 1;
LABEL_23:
      a4[1] = v9;
      a4[2] = v9;
      return;
    }
    if (v6 < 3) {
      return;
    }
    unsigned int v14 = v5[2];
    unsigned int v15 = v5[3];
    unsigned int v17 = v5[7];
    unsigned int v16 = v5[8];
    if ((int)v17 >= (int)v14) {
      uint64_t v18 = v14;
    }
    else {
      uint64_t v18 = v17;
    }
    if ((int)v15 <= (int)v16) {
      uint64_t v10 = v16;
    }
    else {
      uint64_t v10 = v15;
    }
LABEL_22:
    int v19 = operator new(8uLL);
    *a4 = v19;
    *int v19 = v18 | (v10 << 32);
    uint64_t v9 = v19 + 1;
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 449) || (a3 & 1) == 0)
  {
    int v12 = v5[2];
    LODWORD(v10) = v5[3];
    int v11 = v5[7];
    int v13 = v5[8];
    goto LABEL_16;
  }
  LODWORD(v10) = v5[3];
  int v11 = v5[7];
  if ((int)v10 >= v11)
  {
    int v13 = v5[8];
    int v12 = v5[2];
    if (v13 < v12) {
      goto LABEL_26;
    }
LABEL_16:
    if (v11 >= v12) {
      uint64_t v18 = v12;
    }
    else {
      uint64_t v18 = v11;
    }
    if ((int)v10 <= v13) {
      uint64_t v10 = v13;
    }
    else {
      uint64_t v10 = v10;
    }
    goto LABEL_22;
  }
  int v12 = v5[2];
  int v13 = v5[8];
LABEL_26:
  uint64_t v20 = 2;
  if (v11 < v12) {
    uint64_t v20 = 7;
  }
  uint64_t v21 = 3;
  if (v13 < (int)v10) {
    uint64_t v21 = 8;
  }
  uint64_t v22 = v5[v20];
  uint64_t v23 = v5[v21];
  BOOL v24 = operator new(8uLL);
  *BOOL v24 = v22 | (v23 << 32);
  a4[1] = v24 + 1;
  a4[2] = v24 + 1;
  *a4 = v24;
  int v25 = operator new(0x10uLL);
  if ((int)v10 <= v13) {
    uint64_t v26 = v13;
  }
  else {
    uint64_t v26 = v10;
  }
  if (v12 <= v11) {
    uint64_t v27 = v11;
  }
  else {
    uint64_t v27 = v12;
  }
  int v28 = v25 + 2;
  *int v25 = *v24;
  v25[1] = v27 | (v26 << 32);
  unint64_t v29 = *a4;
  *a4 = v25;
  a4[1] = v25 + 2;
  a4[2] = v25 + 2;
  if (v29) {
    operator delete(v29);
  }
  a4[1] = v28;
}

void sub_1B7819DD8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGTextureWrap::SetTextureWrapMode(uint64_t a1, const char *a2, char *a3)
{
  *(_DWORD *)(a1 + 416) = a2;
  WrapNode = HGTextureWrap::_createWrapNode(a1, a2, a3);
  uint64_t v9 = *(char **)(a1 + 408);
  if (v9 == WrapNode)
  {
    if (WrapNode)
    {
      (*(void (**)(char *))(*(void *)WrapNode + 24))(WrapNode);
      WrapNode = *(char **)(a1 + 408);
    }
  }
  else
  {
    if (v9) {
      (*(void (**)(char *))(*(void *)v9 + 24))(v9);
    }
    *(void *)(a1 + 408) = WrapNode;
  }
  v5.n128_u32[0] = *(_DWORD *)(a1 + 420);
  v6.n128_u32[0] = *(_DWORD *)(a1 + 424);
  v7.n128_u32[0] = *(_DWORD *)(a1 + 428);
  v8.n128_u32[0] = *(_DWORD *)(a1 + 432);
  uint64_t v10 = *(uint64_t (**)(char *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)WrapNode + 96);

  return v10(WrapNode, 2, v5, v6, v7, v8);
}

void sub_1B7819ED8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

void HGTextureWrap::HGTextureWrap(HGTextureWrap *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10DF9A8;
  *(void *)(v1 + 408) = 0;
  *(_DWORD *)(v1 + 416) = 0;
  *(_OWORD *)(v1 + 436) = HGRectInfinite;
  *(unsigned char *)(v1 + 452) = 0;
  *(void *)(v1 + 428) = 0;
  *(void *)(v1 + 420) = 0;
  HGTextureWrap::SetTextureWrapMode(v1, 0, v2);
}

void sub_1B7819F90(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 408);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGTextureWrap::~HGTextureWrap(HGNode *this)
{
  *(void *)this = &unk_1F10DF9A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10DF9A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGTextureWrap::SetParameter(HGTextureWrap *this, int a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 == 2)
  {
    __n128 v8 = (uint64_t *)((char *)this + 436);
    uint64_t v9 = HGRectMake4i((int)a3, (int)a4, (int)a5, (int)a6);
    uint64_t v11 = v10;
    if (!HGRectIsEqual(*v8, v8[1], v9, v10))
    {
      *__n128 v8 = v9;
      v8[1] = v11;
      return 1;
    }
    return 0;
  }
  if (a2 != 1)
  {
    if (!a2)
    {
      return HGTextureWrap::SetTextureWrapMode((uint64_t)this, (const char *)a3, a7);
    }
    return 0;
  }
  *((float *)this + 105) = a3;
  *((float *)this + 106) = a4;
  *((float *)this + 107) = a5;
  *((float *)this + 108) = a6;
  int v12 = *(uint64_t (**)(void))(**((void **)this + 51) + 96);

  return v12();
}

uint64_t HGTextureWrap::SetTextureBorderColor(HGTextureWrap *this, float *a2)
{
  *((float *)this + 105) = *a2;
  *((float *)this + 106) = a2[1];
  *((float *)this + 107) = a2[2];
  *((float *)this + 108) = a2[3];
  return (*(uint64_t (**)(void, uint64_t))(**((void **)this + 51) + 96))(*((void *)this + 51), 2);
}

uint64_t HGTextureWrap::SetCropRect(HGTextureWrap *this, const HGRect *a2)
{
  uint64_t v3 = (HGRect *)((char *)this + 436);
  if (HGRectIsEqual(*(void *)((char *)this + 436), *(void *)((char *)this + 444), *(void *)&a2->var0, *(void *)&a2->var2))
  {
    return 0;
  }
  *uint64_t v3 = *a2;
  return 1;
}

char *HGTextureWrap::_createWrapNode(uint64_t a1, const char *a2, char *a3)
{
  switch((int)a2)
  {
    case 0:
      uint64_t v3 = (char *)HGObject::operator new(0x1D0uLL);
      HGNode::HGNode((HGNode *)v3);
      *(void *)uint64_t v3 = &unk_1F10DF508;
      *(_OWORD *)(v3 + 408) = HGRectInfinite;
      *((void *)v3 + 54) = 0;
      *((void *)v3 + 55) = 0;
      v3[448] = 0;
      *((_DWORD *)v3 + 4) |= 0x600u;
      HGNode::SetFlags((HGNode *)v3, 0, 0x2000);
      goto LABEL_3;
    case 1:
      __n128 v5 = (HGTW::HGTextureWrapClampToEdge *)HGObject::operator new(0x1D0uLL);
      HGTW::HGTextureWrapClampToEdge::HGTextureWrapClampToEdge(v5);
    case 2:
      __n128 v6 = (char *)HGObject::operator new(0x1D0uLL);
      HGNode::HGNode((HGNode *)v6);
      *(void *)__n128 v6 = &unk_1F10DF758;
      *(_OWORD *)(v6 + 408) = HGRectInfinite;
      *((_WORD *)v6 + 224) = 257;
      *(_OWORD *)(v6 + 424) = xmmword_1B7E77190;
      *((void *)v6 + 55) = 0;
      HGNode::SetFlags((HGNode *)v6, 0, 16);
      (*(void (**)(char *, void, uint64_t))(*(void *)v6 + 136))(v6, 0, 32);
      (*(void (**)(char *, uint64_t, uint64_t))(*(void *)v6 + 136))(v6, 0xFFFFFFFFLL, 32);
      goto LABEL_7;
    case 3:
      __n128 v6 = (char *)HGObject::operator new(0x1D0uLL);
      HGNode::HGNode((HGNode *)v6);
      *(void *)__n128 v6 = &unk_1F10DF758;
      *(_OWORD *)(v6 + 408) = HGRectInfinite;
      *((_WORD *)v6 + 224) = 1;
      *(_OWORD *)(v6 + 424) = xmmword_1B7E77190;
      *((void *)v6 + 55) = 0;
      HGNode::SetFlags((HGNode *)v6, 0, 16);
      (*(void (**)(char *, void, uint64_t))(*(void *)v6 + 136))(v6, 0, 32);
      (*(void (**)(char *, uint64_t, uint64_t))(*(void *)v6 + 136))(v6, 0xFFFFFFFFLL, 32);
LABEL_7:
      *((_DWORD *)v6 + 4) |= 0x600u;
      uint64_t result = v6;
      break;
    default:
      HGLogger::warning((HGLogger *)"HGTextureWrap -- invalid mode", a2, a3);
      uint64_t v3 = (char *)HGObject::operator new(0x1A0uLL);
      HGNode::HGNode((HGNode *)v3);
LABEL_3:
      uint64_t result = v3;
      break;
  }
  return result;
}

void sub_1B781A514(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B781A53C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

uint64_t HGTextureWrap::GetTextureWrapMode(HGTextureWrap *this)
{
  return *((unsigned int *)this + 104);
}

float HGTextureWrap::GetTextureBorderColor(HGTextureWrap *this, float *a2)
{
  *a2 = *((float *)this + 105);
  a2[1] = *((float *)this + 106);
  a2[2] = *((float *)this + 107);
  float result = *((float *)this + 108);
  a2[3] = result;
  return result;
}

HGNode *HGTextureWrap::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  *(void *)&v11.var0 = HGRenderer::GetDOD(a2, Input);
  *(void *)&v11.var2 = v5;
  if (!HGRect::IsInfinite(&v11))
  {
    (*(void (**)(void, void, HGNode *))(**((void **)this + 51) + 120))(*((void *)this + 51), 0, Input);
    HGNode::SetOutputFormatComponents(*((const char **)this + 51), (const char *)*((unsigned int *)this + 8), v6);
    HGNode::SetSupportedFormatPrecisions(*((HGNode **)this + 51), (const char *)*((unsigned int *)this + 9), v7);
    (*(void (**)(void, void, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, (float)*((int *)this + 109), (float)*((int *)this + 110), (float)*((int *)this + 111), (float)*((int *)this + 112));
    v8.n128_u32[0] = 1.0;
    v9.n128_u64[0] = 0;
    if (!*((unsigned char *)this + 452)) {
      v8.n128_f32[0] = 0.0;
    }
    (*(void (**)(void, uint64_t, __n128, __n128, double, double))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, v8, v9, 0.0, 0.0);
    return (HGNode *)*((void *)this + 51);
  }
  return Input;
}

const char *HGTW::HGTextureWrapClampToEdge::label_A(HGTW::HGTextureWrapClampToEdge *this)
{
  return "HGTextureWrapClampToEdge";
}

uint64_t HGTW::HGTextureWrapClampToEdge::CanBypassTiling(HGTW::HGTextureWrapClampToEdge *this, HGRenderer *a2)
{
  return 1;
}

const char *HGTW::HGTextureWrapClampToColor::label_A(HGTW::HGTextureWrapClampToColor *this)
{
  return "HGTextureWrapClampToColor";
}

const char *HGTW::HGTextureWrapRepeat::label_A(HGTW::HGTextureWrapRepeat *this)
{
  return "HGTextureWrapRepeat";
}

const char *HGTW::HGTextureWrapRepeat::label_B(HGTW::HGTextureWrapRepeat *this)
{
  if (*((unsigned char *)this + 449)) {
    return "(mirror)";
  }
  else {
    return "(repeat)";
  }
}

void HGNodeBuffer::ReadTile(HGNodeBuffer *this, char *a2, HGRect a3, uint64_t a4)
{
  uint64_t v5 = *((void *)this + 17);
  int v6 = *(_DWORD *)(v5 + 36);
  int v7 = *(_DWORD *)(v5 + 112);
  HGExecutionUnit::RenderTile(v5, a2, *(unint64_t *)&a3.var0, *(unint64_t *)&a3.var2, *((void *)this + 16), a4);
  uint64_t v8 = *((void *)this + 17);
  *(_DWORD *)(v8 + 36) = v6;
  *(_DWORD *)(v8 + 112) = v7;
}

void HGXForm::HGXForm(HGXForm *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v2 = &unk_1F10DFCC0;
  uint64_t v3 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v3);
  *((void *)this + 51) = v3;
  uint64_t v4 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v4);
  *((void *)this + 52) = v4;
  uint64_t v5 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v5);
  *((void *)this + 53) = v5;
  *((_DWORD *)this + 108) = 1;
  *((void *)this + 55) = 0;
  *((void *)this + 56) = this;
  *((void *)this + 57) = this;
  *((void *)this + 58) = 1065353216;
  *((void *)this + 59) = 0;
  *(_OWORD *)((char *)this + 484) = xmmword_1B7E76300;
  *(void *)((char *)this + 500) = 1098907648;
  *((_DWORD *)this + 127) = 3;
  *((unsigned char *)this + 512) = 0;
  *((float *)this + 129) = HGTransformUtils::MinW(v6);
  *((_DWORD *)this + 130) = 0;
  int v7 = *((_DWORD *)this + 4) | 0x600;
  *((_DWORD *)this + 3) = 1481003597;
  *((_DWORD *)this + 4) = v7;
}

void sub_1B781A854(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  HGObject::operator delete(v3);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B781A87C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGXForm::~HGXForm(HGXForm *this)
{
  *(void *)this = &unk_1F10DFCC0;
  uint64_t v2 = (HGXForm *)*((void *)this + 56);
  if (v2 != this)
  {
    (*(void (**)(HGXForm *))(*(void *)v2 + 24))(v2);
    *((void *)this + 56) = this;
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    *((void *)this + 51) = 0;
  }
  uint64_t v4 = *((void *)this + 52);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
    *((void *)this + 52) = 0;
  }
  uint64_t v5 = *((void *)this + 53);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    *((void *)this + 53) = 0;
  }

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v1;
  uint64_t vars8;

  HGXForm::~HGXForm(this);

  HGObject::operator delete(v1);
}

uint64_t HGXForm::info@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  if (a2 < 1)
  {
    *a5 = 0;
    a5[1] = 0;
    a5[2] = 0;
  }
  else
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)result + 584))(result);
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 272))(v7);
    return HGLoggerUtils::matrixPrettyString(v8, 4, 4, a3, a4);
  }
  return result;
}

uint64_t HGXForm::SupportsInplaceHardwareBlending(HGXForm *this, float a2)
{
  return 1;
}

uint64_t HGXForm::QueueNode(HGXForm *this, HGNode *a2)
{
  if (*((HGXForm **)this + 56) == this)
  {
    uint64_t result = (*(uint64_t (**)(HGNode *, void, void))(*(void *)a2 + 120))(a2, 0, *((void *)this + 55));
  }
  else
  {
    (*(void (**)(HGNode *, void))(*(void *)a2 + 120))(a2, 0);
    uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 56) + 24))(*((void *)this + 56));
  }
  *((void *)this + 56) = a2;
  return result;
}

uint64_t HGXForm::SupportsEarlyConcatenation(HGXForm *this)
{
  return 1;
}

uint64_t HGXForm::AttemptEarlyConcatenation(HGXForm *this, HGNode *a2)
{
  uint64_t result = (*(uint64_t (**)(HGNode *, void))(*(void *)a2 + 128))(a2, 0);
  if (*((_DWORD *)a2 + 3) != *((_DWORD *)this + 3) || result == 0) {
    return result;
  }
  uint64_t v6 = result;
  float v7 = *((float *)a2 + 126);
  float v8 = *((float *)this + 126);
  if (v7 == 0.0 || v8 == 0.0)
  {
    if (v7 != 0.0
      || v8 != 0.0
      || *((_DWORD *)a2 + 108) < *((_DWORD *)this + 108)
      || *((float *)a2 + 116) != *((float *)this + 116)
      || *((_DWORD *)a2 + 117) != *((_DWORD *)this + 117)
      || *((float *)a2 + 121) != *((float *)this + 121)
      || *((float *)a2 + 122) != *((float *)this + 122))
    {
      return result;
    }
    goto LABEL_24;
  }
  if (*((_DWORD *)a2 + 108) >= *((_DWORD *)this + 108) && v7 >= v8)
  {
    float v10 = *((float *)a2 + 123);
    float v11 = *((float *)this + 123);
    if ((float)(*((float *)a2 + 124) - v10) <= (float)(*((float *)this + 124) - v11)
      && (float)(*((float *)a2 + 125) - v10) >= (float)(*((float *)this + 125) - v11)
      && *((_DWORD *)a2 + 127) >= *((_DWORD *)this + 127))
    {
LABEL_24:
      int v12 = (HGTransform *)HGObject::operator new(0x90uLL);
      HGTransform::HGTransform(v12);
      uint64_t v13 = (*(uint64_t (**)(HGXForm *))(*(void *)this + 584))(this);
      (*(void (**)(HGTransform *, uint64_t))(*(void *)v12 + 96))(v12, v13);
      uint64_t v14 = (*(uint64_t (**)(HGNode *))(*(void *)a2 + 584))(a2);
      (*(void (**)(HGTransform *, uint64_t))(*(void *)v12 + 200))(v12, v14);
      (*(void (**)(HGXForm *, void, uint64_t))(*(void *)this + 120))(this, 0, v6);
      (*(void (**)(HGXForm *, HGTransform *))(*(void *)this + 576))(this, v12);
      v15.n128_f32[0] = *((float *)a2 + 123) + *((float *)this + 123);
      (*(void (**)(HGXForm *, __n128))(*(void *)this + 608))(this, v15);
      uint64_t result = (*(uint64_t (**)(HGTransform *))(*(void *)v12 + 24))(v12);
      int v16 = *((_DWORD *)a2 + 130);
      if (v16 <= *((_DWORD *)this + 130)) {
        int v16 = *((_DWORD *)this + 130);
      }
      *((_DWORD *)this + 130) = v16;
    }
  }
  return result;
}

void sub_1B781AE9C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGXForm *HGXForm::GetOutput(HGXForm *this, HGRenderer *a2)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 108) = (*(uint64_t (**)(HGXForm *))(*(void *)this + 312))(this);
  (*(void (**)(void, void))(**((void **)this + 52) + 96))(*((void *)this + 52), *((void *)this + 51));
  uint64_t v4 = (HGXForm *)*((void *)this + 56);
  if (v4 != this)
  {
    (*(void (**)(HGXForm *))(*(void *)v4 + 24))(v4);
    *((void *)this + 56) = this;
  }
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  *((void *)this + 55) = Input;
  *((_DWORD *)this + 4) &= ~0x10u;
  *((void *)this + 59) = 0;
  (*(void (**)(void))(**((void **)this + 52) + 184))(*((void *)this + 52));
  if (!Input) {
    goto LABEL_22;
  }
  if (*((_DWORD *)Input + 3) == *((_DWORD *)this + 3)
    && HGRenderer::IsMergeable(a2, (HGNode *)this, 0, 0)
    && *((float *)Input + 123) == 0.0
    && *((float *)Input + 124) == 0.0)
  {
    uint64_t v6 = (HGXForm *)HGObject::operator new(0x210uLL);
    HGXForm::HGXForm(v6);
    float v7 = (HGTransform *)HGObject::operator new(0x90uLL);
    HGTransform::HGTransform(v7);
    (*(void (**)(HGTransform *, void))(*(void *)v7 + 96))(v7, *((void *)this + 52));
    (*(void (**)(HGTransform *, void))(*(void *)v7 + 200))(v7, *((void *)Input + 52));
    float v8 = HGRenderer::GetInput(a2, (HGNode *)Input, 0);
    (*(void (**)(HGXForm *, void, HGNode *))(*(void *)v6 + 120))(v6, 0, v8);
    (*(void (**)(HGXForm *, HGTransform *))(*(void *)v6 + 576))(v6, v7);
    (*(void (**)(HGXForm *, void))(*(void *)v6 + 160))(v6, *((unsigned int *)this + 108));
    v9.n128_u32[0] = *((_DWORD *)this + 116);
    (*(void (**)(HGXForm *, void, __n128))(*(void *)v6 + 592))(v6, *((unsigned int *)this + 117), v9);
    (*(void (**)(HGXForm *, void, float, float, float, float))(*(void *)v6 + 96))(v6, 0, *((float *)this + 123), *((float *)this + 124), *((float *)this + 125), *((float *)this + 126));
    unsigned int v10 = *((_DWORD *)this + 130);
    if ((signed int)v10 <= *((_DWORD *)Input + 130)) {
      unsigned int v10 = *((_DWORD *)Input + 130);
    }
    (*(void (**)(HGXForm *, uint64_t, float, double, double, double))(*(void *)v6 + 96))(v6, 1, (float)v10, 0.0, 0.0, 0.0);
    (*(void (**)(HGXForm *, void))(*(void *)v6 + 640))(v6, *((unsigned int *)this + 127));
    *((void *)this + 56) = v6;
    (*(void (**)(HGTransform *))(*(void *)v7 + 24))(v7);
    return v6;
  }
  if (!v11 || (int v12 = v11, !HGRenderer::IsMergeable(a2, (HGNode *)this, 0, 0)))
  {
LABEL_22:
    (*(void (**)(void))(**((void **)this + 52) + 184))(*((void *)this + 52));
    float v18 = *((float *)this + 123);
    if (v18 == 0.0)
    {
      if ((*(unsigned int (**)(void))(**((void **)this + 52) + 224))(*((void *)this + 52))) {
        return (HGXForm *)Input;
      }
      float v18 = *((float *)this + 123);
    }
    if (v18 == 0.0
      && (*(unsigned int (**)(void))(**((void **)this + 52) + 240))(*((void *)this + 52)))
    {
      uint64_t v19 = (*(uint64_t (**)(void))(**((void **)this + 52) + 272))(*((void *)this + 52));
      Input = HGObject::operator new(0x1B0uLL);
      HGFlipAndOffset::HGFlipAndOffset((HGFlipAndOffset *)Input);
      (*(void (**)(void *, void))(*(void *)Input + 160))(Input, *((unsigned int *)this + 108));
      float v20 = *(double *)(v19 + 96);
      float v21 = *(double *)(v19 + 104);
      (*(void (**)(void *, void, float, float, double, double))(*(void *)Input + 96))(Input, 0, v20, v21, 0.0, 0.0);
      v22.n128_u64[0] = *(void *)v19;
      v23.n128_u64[0] = -1.0;
      if (*(double *)v19 == -1.0) {
        v22.n128_f32[0] = 1.0;
      }
      else {
        v22.n128_f32[0] = 0.0;
      }
      if (*(double *)(v19 + 40) == -1.0) {
        v23.n128_f32[0] = 1.0;
      }
      else {
        v23.n128_f32[0] = 0.0;
      }
      (*(void (**)(void *, uint64_t, __n128, __n128, double, double))(*(void *)Input + 96))(Input, 1, v22, v23, 0.0, 0.0);
      (*(void (**)(void *, uint64_t, float, double, double, double))(*(void *)Input + 96))(Input, 2, (float)*((unsigned int *)this + 130), 0.0, 0.0, 0.0);
      if (*((HGXForm **)this + 56) == this) {
        goto LABEL_34;
      }
      goto LABEL_37;
    }
    if (*((float *)this + 126) > 0.0)
    {
      Input = HGObject::operator new(0x1F0uLL);
      HGAnisotropicXForm::HGAnisotropicXForm((HGAnisotropicXForm *)Input);
      (*(void (**)(void *, void))(*(void *)Input + 576))(Input, *((void *)this + 51));
      (*(void (**)(void *, void))(*(void *)Input + 160))(Input, *((unsigned int *)this + 108));
      (*(void (**)(void *, void))(*(void *)Input + 592))(Input, *((unsigned int *)this + 127));
      (*(void (**)(void *, void, float, float, float, float))(*(void *)Input + 96))(Input, 0, *((float *)this + 123), *((float *)this + 124), *((float *)this + 125), *((float *)this + 126));
      (*(void (**)(void *, uint64_t, float, double, double, double))(*(void *)Input + 96))(Input, 1, (float)*((unsigned int *)this + 130), 0.0, 0.0, 0.0);
      if (*((HGXForm **)this + 56) == this)
      {
LABEL_34:
        (*(void (**)(void *, void, void))(*(void *)Input + 120))(Input, 0, *((void *)this + 55));
        *((void *)this + 56) = Input;
        return (HGXForm *)Input;
      }
LABEL_37:
      (*(void (**)(void *, void))(*(void *)Input + 120))(Input, 0);
      (*(void (**)(void))(**((void **)this + 56) + 24))(*((void *)this + 56));
      *((void *)this + 56) = Input;
      return (HGXForm *)Input;
    }
    (*(void (**)(void, void))(**((void **)this + 53) + 96))(*((void *)this + 53), *((void *)this + 52));
    (*(void (**)(void))(**((void **)this + 53) + 168))(*((void *)this + 53));
    v84[0] = 0.0;
    float v81 = 0.0;
    uint64_t v25 = (*(uint64_t (**)(void))(**((void **)this + 53) + 272))();
    v28.n128_u64[0] = *(void *)(v25 + 8);
    if (v28.n128_f64[0] != 0.0) {
      goto LABEL_50;
    }
    v28.n128_u64[0] = *(void *)(v25 + 16);
    if (v28.n128_f64[0] != 0.0) {
      goto LABEL_50;
    }
    v28.n128_u64[0] = *(void *)(v25 + 24);
    if (v28.n128_f64[0] == 0.0
      && (v28.n128_u64[0] = *(void *)(v25 + 32), v28.n128_f64[0] == 0.0)
      && (v28.n128_u64[0] = *(void *)(v25 + 48), v28.n128_f64[0] == 0.0)
      && (v28.n128_u64[0] = *(void *)(v25 + 56), v28.n128_f64[0] == 0.0)
      && (v28.n128_u64[0] = *(void *)(v25 + 64), v28.n128_f64[0] == 0.0)
      && (v28.n128_u64[0] = *(void *)(v25 + 72), v28.n128_f64[0] == 0.0)
      && (v28.n128_u64[0] = *(void *)(v25 + 88), v28.n128_f64[0] == 0.0))
    {
      double v29 = *(double *)(v25 + 120);
      if (v29 == 0.0)
      {
        v28.n128_u64[0] = 0x7FF0000000000000;
        double v30 = INFINITY;
      }
      else
      {
        v28.n128_f64[0] = *(double *)v25 / v29;
        double v30 = *(double *)(v25 + 40) / v29;
      }
      double v32 = fabs(v28.n128_f64[0]);
      double v34 = fabs(v30);
      unsigned __int8 v73 = atomic_load(HGLogger::_enabled);
      int v33 = 1;
      if (v73) {
        HGLogger::log((HGLogger *)"xform", (const char *)1, (HGLogger *)"scalex=%.3f, scaley=%.3f (accurate)\n", v26, v27, *(void *)&v32, *(void *)&v34);
      }
    }
    else
    {
LABEL_50:
      unsigned __int8 v31 = atomic_load(HGLogger::_enabled);
      double v32 = 0.0;
      if (v31) {
        HGLogger::log((HGLogger *)"xform", (const char *)1, (HGLogger *)"scalex=%.3f, scaley=%.3f (using l_EQX and l_EQY)\n", v26, v27, 0, 0);
      }
      int v33 = 0;
      double v34 = 0.0;
    }
    v28.n128_u32[0] = *((_DWORD *)this + 116);
    if (v28.n128_f32[0] > 0.0)
    {
      char v35 = v33 ^ 1;
      if (*((_DWORD *)this + 117) != 6) {
        char v35 = 0;
      }
      if ((v35 & 1) == 0)
      {
        HGXForm::ComputePreFilterAmount(this, v84, &v81);
        if (v84[0] > 0.0 || (v28.n128_f32[0] = v81, v81 > 0.0))
        {
          unsigned __int8 v38 = atomic_load(HGLogger::_enabled);
          if (v38) {
            HGLogger::log((HGLogger *)"xform", (const char *)1, (HGLogger *)"Prefilter = %f, l_EQX = %f, l_EQY=%f\n", v36, v37, *((float *)this + 116), v84[0], v81);
          }
          int v39 = *((_DWORD *)this + 117);
          if (!v39)
          {
            int v51 = (HGBlur *)HGObject::operator new(0x220uLL);
            HGBlur::HGBlur(v51);
            float v52 = v84[0];
            float v53 = v81;
            (*(void (**)(HGBlur *, void, float, float, double, double))(*(void *)v51 + 96))(v51, 0, v84[0], v81, 0.0, 0.0);
            *((_DWORD *)v51 + 106) = 1;
            HGXForm::QueueNode(this, (HGNode *)v51);
            if (!*((_DWORD *)v51 + 106)) {
              goto LABEL_115;
            }
            HGTransform::HGTransform((HGTransform *)v83);
            HGBlur::GetDecimation(v51, v52);
            float v55 = ldexpf(1.0, v54);
            HGBlur::GetDecimation(v51, v53);
            float v57 = ldexpf(1.0, v56);
            HGTransform::Scale((HGTransform *)v83, v55, v57, 1.0);
            (*(void (**)(void, float *))(**((void **)this + 52) + 200))(*((void *)this + 52), v83);
            goto LABEL_114;
          }
          if (v39 != 6)
          {
            if (v33) {
              double v58 = v32;
            }
            else {
              double v58 = v84[0];
            }
            double v59 = 1.0;
            unsigned int v60 = -1;
            do
            {
              double v61 = v59;
              double v59 = v59 + v59;
              ++v60;
            }
            while (v59 <= v58);
            if (v33) {
              double v62 = v34;
            }
            else {
              double v62 = v81;
            }
            double v63 = 1.0;
            unsigned int v64 = -1;
            do
            {
              double v65 = v63;
              double v63 = v63 + v63;
              ++v64;
            }
            while (v63 <= v62);
            if (v60 >= v64) {
              int v66 = v64;
            }
            else {
              int v66 = v60;
            }
            if (v39 == 2 && v66 >= 2)
            {
              int v67 = v66 + 1;
              uint64_t v68 = 5;
              float v69 = 2.0;
              float v70 = 0.2;
            }
            else
            {
              int v67 = v66;
              float v70 = 0.0;
              float v69 = 1.0;
              uint64_t v68 = 5;
              switch(v39)
              {
                case 1:
                case 2:
                  break;
                case 3:
                  uint64_t v68 = 6;
                  break;
                case 4:
                  uint64_t v68 = 7;
                  break;
                case 5:
                  uint64_t v68 = 2;
                  break;
                default:
                  uint64_t v68 = 0;
                  break;
              }
            }
            HGTransform::HGTransform((HGTransform *)v83);
            HGTransform::Scale((HGTransform *)v83, 1.0 / v61, 1.0 / v65, 1.0);
            int v74 = (HGAnisotropicXForm *)HGObject::operator new(0x1F0uLL);
            HGAnisotropicXForm::HGAnisotropicXForm(v74);
            (*(void (**)(HGAnisotropicXForm *, float *))(*(void *)v74 + 576))(v74, v83);
            (*(void (**)(HGAnisotropicXForm *, void))(*(void *)v74 + 160))(v74, 0);
            (*(void (**)(HGAnisotropicXForm *, uint64_t))(*(void *)v74 + 592))(v74, v68);
            (*(void (**)(HGAnisotropicXForm *, void, float, float, float, float))(*(void *)v74 + 96))(v74, 0, v70, (float)v66, (float)v67, v69);
            HGXForm::QueueNode(this, (HGNode *)v74);
            HGTransform::HGTransform((HGTransform *)v82);
            HGTransform::Scale((HGTransform *)v82, v61, v65, 1.0);
            (*(void (**)(void, float *))(**((void **)this + 52) + 200))(*((void *)this + 52), v82);
            (*(void (**)(void, void))(**((void **)this + 53) + 96))(*((void *)this + 53), *((void *)this + 52));
            (*(void (**)(void))(**((void **)this + 53) + 168))(*((void *)this + 53));
            float v75 = v58 / v61;
            if (v75 != 1.0)
            {
              float v76 = v62 / v65;
              if (v76 != 1.0)
              {
                unint64_t v77 = (HGConvolution *)HGObject::operator new(0x220uLL);
                HGConvolution::HGConvolution(v77);
                HGXForm::SetConvolutionFilter(this, v77, v75, v76);
                HGXForm::QueueNode(this, (HGNode *)v77);
              }
            }
            HGTransform::~HGTransform((HGTransform *)v82);
            goto LABEL_114;
          }
          float v40 = 1.0 / v32;
          for (i = 0; v40 < 0.5; float v40 = v40 + v40)
            ++i;
          v28.n128_f64[0] = 1.0 / v34;
          v28.n128_f32[0] = 1.0 / v34;
          for (unsigned int j = 0; v28.n128_f32[0] < 0.5; v28.n128_f32[0] = v28.n128_f32[0] + v28.n128_f32[0])
            ++j;
          if (i <= j) {
            int v43 = j;
          }
          else {
            int v43 = i;
          }
          uint64_t v44 = (HGXForm *)*((void *)this + 55);
          if (v43 < 1)
          {
            unint64_t v50 = (HGXForm *)*((void *)this + 55);
          }
          else
          {
            int v45 = v43 + 1;
            int v46 = j;
            int v47 = i;
            do
            {
              HGTransform::HGTransform((HGTransform *)v83);
              if (v47 <= 0) {
                double v48 = 1.0;
              }
              else {
                double v48 = 0.5;
              }
              if (v46 <= 0) {
                double v49 = 1.0;
              }
              else {
                double v49 = 0.5;
              }
              HGTransform::Scale((HGTransform *)v83, v48, v49, 1.0);
              unint64_t v50 = (HGXForm *)HGObject::operator new(0x210uLL);
              HGXForm::HGXForm(v50);
              (*(void (**)(HGXForm *, void, HGXForm *))(*(void *)v50 + 120))(v50, 0, v44);
              (*(void (**)(HGXForm *, float *))(*(void *)v50 + 576))(v50, v83);
              (*(void (**)(HGXForm *, uint64_t))(*(void *)v50 + 160))(v50, 1);
              (*(void (**)(HGXForm *, void, double))(*(void *)v50 + 592))(v50, 0, 0.0);
              (*(void (**)(HGXForm *, uint64_t, uint64_t))(*(void *)v50 + 136))(v50, 0xFFFFFFFFLL, 32);
              (*(void (**)(HGXForm *, void, uint64_t))(*(void *)v50 + 136))(v50, 0, 32);
              (*(void (**)(HGXForm *, uint64_t, uint64_t))(*(void *)v50 + 136))(v50, 1, 32);
              if (v44 != *((HGXForm **)this + 55)) {
                (*(void (**)(HGXForm *))(*(void *)v44 + 24))(v44);
              }
              HGTransform::~HGTransform((HGTransform *)v83);
              --v45;
              --v46;
              --v47;
              uint64_t v44 = v50;
            }
            while (v45 > 1);
          }
          if (v43)
          {
            *((void *)this + 56) = v50;
            HGTransform::HGTransform((HGTransform *)v83);
            float v71 = ldexpf(1.0, i);
            float v72 = ldexpf(1.0, j);
            HGTransform::Scale((HGTransform *)v83, v71, v72, 1.0);
            (*(void (**)(void, float *))(**((void **)this + 52) + 200))(*((void *)this + 52), v83);
LABEL_114:
            HGTransform::~HGTransform((HGTransform *)v83);
          }
        }
      }
    }
LABEL_115:
    if (*((HGXForm **)this + 56) != this)
    {
      if (!(*(unsigned int (**)(void, __n128))(**((void **)this + 52) + 224))(*((void *)this + 52), v28))
      {
        uint64_t v78 = (HGXForm *)HGObject::operator new(0x210uLL);
        HGXForm::HGXForm(v78);
        (*(void (**)(HGXForm *, void))(*(void *)v78 + 576))(v78, *((void *)this + 52));
        (*(void (**)(HGXForm *, void))(*(void *)v78 + 160))(v78, *((unsigned int *)this + 108));
        (*(void (**)(HGXForm *, void, double))(*(void *)v78 + 592))(v78, 0, 0.0);
        *((void *)v78 + 57) = this;
        *((_DWORD *)v78 + 130) = *((_DWORD *)this + 130);
        if (*((HGXForm **)this + 56) == this)
        {
          (*(void (**)(HGXForm *, void, void))(*(void *)v78 + 120))(v78, 0, *((void *)this + 55));
        }
        else
        {
          (*(void (**)(HGXForm *, void))(*(void *)v78 + 120))(v78, 0);
          (*(void (**)(void))(**((void **)this + 56) + 24))(*((void *)this + 56));
        }
        *((void *)this + 56) = v78;
      }
      return (HGXForm *)*((void *)this + 56);
    }
    *((_DWORD *)this + 4) |= 0x10u;
    *((_DWORD *)this + 118) = 1;
    *((_DWORD *)this + 119) = (*(uint64_t (**)(void, __n128))(**((void **)this + 53) + 248))(*((void *)this + 53), v28);
    int v79 = *((_DWORD *)this + 108);
    if (v79 == 1)
    {
      int v80 = 1056964608;
    }
    else
    {
      if (!v79)
      {
        *((_DWORD *)this + 120) = 0;
        return (HGXForm *)*((void *)this + 56);
      }
      int v80 = 1069547520;
    }
    *((_DWORD *)this + 120) = v80;
    return (HGXForm *)*((void *)this + 56);
  }
  (*(void (**)(HGNode *, void, float *))(*(void *)v12 + 104))(v12, 0, v82);
  (*(void (**)(HGNode *, uint64_t, float *))(*(void *)v12 + 104))(v12, 1, v83);
  if (v83[0] == 0.0) {
    float v13 = 1.0;
  }
  else {
    float v13 = -1.0;
  }
  if (v83[1] == 0.0) {
    float v14 = 1.0;
  }
  else {
    float v14 = -1.0;
  }
  Input = HGObject::operator new(0x210uLL);
  HGXForm::HGXForm((HGXForm *)Input);
  __n128 v15 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v15);
  (*(void (**)(HGTransform *))(*(void *)v15 + 56))(v15);
  (*(void (**)(HGTransform *, double, double, double))(*(void *)v15 + 144))(v15, v13, v14, 1.0);
  (*(void (**)(HGTransform *, double, double, double))(*(void *)v15 + 120))(v15, v82[0], v82[1], 0.0);
  (*(void (**)(HGTransform *, void))(*(void *)v15 + 192))(v15, *((void *)this + 52));
  int v16 = HGRenderer::GetInput(a2, v12, 0);
  (*(void (**)(void *, void, HGNode *))(*(void *)Input + 120))(Input, 0, v16);
  (*(void (**)(void *, HGTransform *))(*(void *)Input + 576))(Input, v15);
  (*(void (**)(void *, void))(*(void *)Input + 160))(Input, *((unsigned int *)this + 108));
  (*(void (**)(void *, void, float))(*(void *)Input + 592))(Input, 0, *((float *)this + 116));
  (*(void (**)(void *, void, float, float, float, float))(*(void *)Input + 96))(Input, 0, *((float *)this + 123), *((float *)this + 124), *((float *)this + 125), *((float *)this + 126));
  (*(void (**)(HGNode *, uint64_t, float *))(*(void *)v12 + 104))(v12, 2, v84);
  unsigned int v17 = v84[0];
  if (*((_DWORD *)this + 130) > (signed int)v84[0]) {
    unsigned int v17 = *((_DWORD *)this + 130);
  }
  (*(void (**)(void *, uint64_t, float, double, double, double))(*(void *)Input + 96))(Input, 1, (float)v17, 0.0, 0.0, 0.0);
  (*(void (**)(void *, void))(*(void *)Input + 640))(Input, *((unsigned int *)this + 127));
  *((void *)this + 56) = Input;
  (*(void (**)(HGTransform *))(*(void *)v15 + 24))(v15);
  return (HGXForm *)Input;
}

void sub_1B781C530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  HGObject::operator delete(v31);
  HGTransform::~HGTransform((HGTransform *)&a13);
  HGTransform::~HGTransform((HGTransform *)&a31);
  _Unwind_Resume(a1);
}

void sub_1B781C554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B781C568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B781C57C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  HGObject::operator delete(v31);
  HGTransform::~HGTransform((HGTransform *)&a31);
  _Unwind_Resume(a1);
}

void sub_1B781C598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B781C5AC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B781C5C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B781C5D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B781C608(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B781C61C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B781C630(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B781C644(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B781C658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  HGObject::operator delete(v31);
  HGTransform::~HGTransform((HGTransform *)&a31);
  _Unwind_Resume(a1);
}

void sub_1B781C674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B781C688(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B781C69C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B781C6B0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B781C6C8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B781C6DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void HGXForm::ComputePreFilterAmount(HGXForm *this, float *a2, float *a3)
{
  uint64_t v6 = (double *)(*(uint64_t (**)(void))(**((void **)this + 53) + 272))(*((void *)this + 53));
  double v7 = v6[12];
  double v8 = v6[13];
  double v9 = v6[15];
  double v10 = fmax(fabs((*v6 * v9 - v6[3] * v7) / (v9 * v9)), fabs((v6[4] * v9 - v6[3] * v8) / (v9 * v9)))
      * *((float *)this + 121);
  double v11 = fmax(fabs((v6[1] * v9 - v6[7] * v7) / (v9 * v9)), fabs((v6[5] * v9 - v6[7] * v8) / (v9 * v9)))
      * *((float *)this + 122);
  float v30 = exp2f(-*((float *)this + 116));
  float v12 = 0.0;
  float v13 = 0.0;
  if (v10 > 1.0)
  {
    float v14 = 1.0 / v10;
    float v15 = log2f(v14);
    float v16 = floorf(v15);
    float v17 = exp2f(v16);
    float v18 = 0.0;
    if (v17 < 1.0)
    {
      float v19 = v17 * 3.14159265;
      float v13 = (float)(sqrtf(logf(v30) * -2.0) * 3.0) / v19;
    }
    float v20 = exp2f(v16 + 1.0);
    if (v20 < 1.0)
    {
      float v21 = v20 * 3.14159265;
      float v18 = (float)(sqrtf(logf(v30) * -2.0) * 3.0) / v21;
    }
    float v13 = v13 + (float)((float)(v15 - v16) * (float)(v18 - v13));
  }
  if (v11 > 1.0)
  {
    float v22 = 1.0 / v11;
    float v23 = log2f(v22);
    float v24 = floorf(v23);
    float v25 = exp2f(v24);
    float v26 = 0.0;
    if (v25 < 1.0)
    {
      float v27 = v25 * 3.14159265;
      float v12 = (float)(sqrtf(logf(v30) * -2.0) * 3.0) / v27;
    }
    float v28 = exp2f(v24 + 1.0);
    if (v28 < 1.0)
    {
      float v29 = v28 * 3.14159265;
      float v26 = (float)(sqrtf(logf(v30) * -2.0) * 3.0) / v29;
    }
    float v12 = v12 + (float)((float)(v23 - v24) * (float)(v26 - v12));
  }
  *a2 = v13;
  *a3 = v12;
}

void HGXForm::SetConvolutionFilter(HGXForm *this, HGConvolution *a2, float a3, float a4)
{
  HGLinearFilter2D::HGLinearFilter2D((HGLinearFilter2D *)v13);
  HGLinearFilter2D::HGLinearFilter2D((HGLinearFilter2D *)v12);
  int v8 = *((_DWORD *)this + 117) - 1;
  if (v8 >= 5
    || (unsigned int v9 = dword_1B8347D4C[v8],
        float v10 = exp2f(-*((float *)this + 116)),
        int SeparablePrefilter = HGPrefilterUtils::GetSeparablePrefilter(v13, v9, 0, v10, a3, 0.0),
        (SeparablePrefilter | HGPrefilterUtils::GetSeparablePrefilter(v12, v9, 1, v10, a4, 0.0)) == 1))
  {
    HGConvolution::SeparableFilter2D(a2, (const HGLinearFilter2D *)v13, (const HGLinearFilter2D *)v12);
  }
  HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)v12);
  HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)v13);
}

void sub_1B781CAB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t HGXForm::SetTransform(HGXForm *this, HGTransform *a2)
{
  uint64_t v3 = **((void **)this + 51);
  if (a2)
  {
    if ((*(unsigned int (**)(void))(v3 + 232))())
    {
      return 0;
    }
    else
    {
      (*(void (**)(void, HGTransform *))(**((void **)this + 51) + 96))(*((void *)this + 51), a2);
      HGNode::ClearBits((HGNode *)this, v6, v7);
      return 1;
    }
  }
  else if ((*(unsigned int (**)(void))(v3 + 224))())
  {
    return 0;
  }
  else
  {
    (*(void (**)(void))(**((void **)this + 51) + 56))(*((void *)this + 51));
    HGNode::ClearBits((HGNode *)this, v8, v9);
    return 1;
  }
}

uint64_t HGXForm::GetTransform(HGXForm *this)
{
  return *((void *)this + 51);
}

uint64_t HGXForm::SetPreFilter(uint64_t a1, uint64_t a2, char *a3, float a4)
{
  if (*(float *)(a1 + 464) == a4 && *(_DWORD *)(a1 + 468) == a2) {
    return 0;
  }
  *(float *)(a1 + 464) = a4;
  *(_DWORD *)(a1 + 468) = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  return 1;
}

HGXForm *HGXForm::SetFilterSize(HGXForm *this, float a2, float a3)
{
  if (a2 == 0.0) {
    a2 = 0.00000011921;
  }
  *((float *)this + 121) = a2;
  if (a3 == 0.0) {
    float v3 = 0.00000011921;
  }
  else {
    float v3 = a3;
  }
  *((float *)this + 122) = v3;
  return this;
}

uint64_t HGXForm::GetDOD(HGXForm *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 || !*((_DWORD *)this + 118)) {
    return HGNode::GetDOD((uint64_t)this, (uint64_t)a2, v4, *(uint64_t *)&a4.var0);
  }
  uint64_t v6 = *(void *)&a4.var2;
  return HGTransformUtils::GetDOD(*((HGTransformUtils **)this + 52), *(const HGTransform **)&a4.var0, a4, *((float *)this + 120), *((float *)this + 129));
}

uint64_t HGXForm::GetROI(HGXForm *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  if (v8 || !*((_DWORD *)this + 118))
  {
    return HGNode::GetROI((uint64_t)this, (uint64_t)a2, v9, *(uint64_t *)&a4.var0);
  }
  else
  {
    uint64_t v11 = *(void *)&a4.var2;
    uint64_t ROI = HGTransformUtils::GetROI(*((HGTransformUtils **)this + 53), *(unint64_t *)&a4.var0, a4, *((float *)this + 120), *((float *)this + 129));
    uint64_t v14 = v13;
    if (*((_DWORD *)this + 10) != 1)
    {
      Input = HGRenderer::GetInput(a2, *((HGNode **)this + 56), 0);
      uint64_t DOD = HGRenderer::GetDOD(a2, Input);
      *(void *)&v20.var0 = HGRectIntersection(ROI, v14, DOD, v17);
      *(void *)&v20.var2 = v18;
      *(void *)&v21.var0 = v5;
      *(void *)&v21.var2 = v4;
      if (HGXForm::TestPerspective(this, v18, v20, v21)) {
        (*(void (**)(HGNode *, uint64_t, uint64_t))(*(void *)Input + 136))(Input, 0xFFFFFFFFLL, 2);
      }
    }
    return ROI;
  }
}

BOOL HGXForm::TestPerspective(HGXForm *this, HGRenderer *a2, HGRect a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  int var2 = a3.var2;
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  int var3 = a3.var3;
  uint64_t v9 = (a3.var0 - 2);
  uint64_t v10 = (a3.var1 - 2);
  (*(void (**)(void, float *, uint64_t, uint64_t))(**((void **)this + 52) + 216))(*((void *)this + 52), &v61, v9, v10);
  uint64_t v11 = (var2 + 2);
  (*(void (**)(void, float *, uint64_t, uint64_t))(**((void **)this + 52) + 216))(*((void *)this + 52), &v63, v11, v10);
  (*(void (**)(void, float *, uint64_t, void))(**((void **)this + 52) + 216))(*((void *)this + 52), &v65, v11, (var3 + 2));
  (*(void (**)(void, float *, uint64_t, void))(**((void **)this + 52) + 216))(*((void *)this + 52), &v67, v9, (var3 + 2));
  double v12 = v61;
  double v13 = v62;
  double v14 = v63;
  double v15 = v64;
  double v16 = v67;
  double v17 = v68;
  double v18 = v65;
  double v19 = v66 - v68;
  double v20 = v63 - v61;
  double v21 = v65 - v67;
  double v22 = v62 - v64;
  if (vabdd_f64(v20 * v19, v22 * v21) >= 0.000001)
  {
    double v24 = v20 * v19 - v22 * v21;
    double v23 = v13 - v17;
    double v25 = ((v13 - v17) * v21 - (v12 - v16) * v19) / v24;
    double v26 = v20 * v25 + v12;
    double v27 = (v15 - v13) * v25 + v13;
    double v28 = (double)(int)v5;
    double v29 = (double)(int)v4;
    double v30 = (double)SHIDWORD(v4);
    if (v27 >= (double)SHIDWORD(v5) && v26 >= v28 && v26 <= v29 && v27 <= v30) {
      return 1;
    }
    double v34 = (v20 * v23 - (v15 - v13) * (v12 - v16)) / v24;
    double v35 = v19 * v34 + v17;
    double v36 = v21 * v34 + v16;
    BOOL v37 = v35 < (double)SHIDWORD(v5) || v36 < v28;
    BOOL v38 = v37 || v36 > v29;
    if (!v38 && v35 <= v30) {
      return 1;
    }
  }
  else
  {
    double v23 = v13 - v17;
  }
  double v40 = v66 - v15;
  double v41 = v16 - v12;
  double v42 = (v16 - v12) * v40;
  double v43 = v18 - v14;
  double v44 = v23 * (v18 - v14);
  if (vabdd_f64(v42, v44) < 0.000001) {
    return 0;
  }
  double v46 = v42 - v44;
  double v47 = (v22 * v43 - (v12 - v14) * v40) / v46;
  double v48 = v17 - v13;
  double v49 = v41 * v47 + v12;
  double v50 = (v17 - v13) * v47 + v13;
  double v51 = (double)(int)v5;
  double v52 = (double)(int)v4;
  double v53 = (double)SHIDWORD(v4);
  if (v50 >= (double)SHIDWORD(v5) && v49 >= v51 && v49 <= v52 && v50 <= v53) {
    return 1;
  }
  double v57 = (v22 * v41 - (v12 - v14) * v48) / v46;
  double v58 = v40 * v57 + v15;
  double v59 = v43 * v57 + v14;
  BOOL v60 = v59 >= v51;
  if (v59 > v52) {
    BOOL v60 = 0;
  }
  if (v58 < (double)SHIDWORD(v5)) {
    BOOL v60 = 0;
  }
  return v58 <= v53 && v60;
}

uint64_t HGXForm::RenderTile(HGXForm *this, HGTile *a2)
{
  if (*((_DWORD *)this + 118))
  {
    uint64_t v4 = *(HGRenderer **)(*((void *)a2 + 42) + 152);
    Input = HGRenderer::GetInput(v4, (HGNode *)this, 0);
    uint64_t ROI = HGRenderer::GetROI(v4, Input);
    unint64_t v8 = v7;
    if (((*(uint64_t (**)(HGXForm *, void))(*(void *)this + 152))(this, 0) & 2) != 0)
    {
      HGRenderer::RenderInput((uint64_t)v4, *((void *)a2 + 42), (uint64_t)this, 0, (uint64_t)&v16, ROI, v8, 0);
      uint64_t v12 = v17;
      uint64_t v10 = HGObject::operator new(0x80uLL);
      HGBitmap::HGBitmap(v10, ROI, v8, 28, v16, 16 * v12);
    }
    else
    {
      int v9 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)v4 + 128))(v4, 19);
      uint64_t v10 = HGObject::operator new(0x90uLL);
      uint64_t v11 = *((void *)a2 + 42);
      HGBuffer::HGBuffer((uint64_t)v10, ROI, v8, v9, 0);
      *uint64_t v10 = &unk_1F10DFC58;
      v10[16] = Input;
      v10[17] = v11;
    }
    *(_DWORD *)(*((void *)a2 + 42) + 36) = *((_DWORD *)this + 108);
    __int32 v13 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)v4 + 128))(v4, 4);
    double v14 = (float32x4_t *)*((void *)a2 + 42);
    v14[7].i32[0] = v13;
    HGSampler::ReadTile(v14, v10, *((void *)this + 53), *((int8x16_t **)a2 + 2), *(void *)a2, *((void *)a2 + 1), *((_DWORD *)a2 + 6) - *((void *)a2 + 1) + *(void *)a2);
    if (v10) {
      (*(void (**)(void *))(*v10 + 24))(v10);
    }
  }
  return 0;
}

void sub_1B781D338(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B781D34C(_Unwind_Exception *a1)
{
}

void sub_1B781D354(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B781D36C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

const char *HGXForm::GetProgram(HGXForm *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target > 0x60B0F)
  {
    int v5 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20);
    uint64_t v6 = "//Metal1.0     \n"
         "//LEN=0000000328\n"
         "fragment FragmentOut fragmentFunc(VertexInOut           frag        [[ stage_in ]],\n"
         "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
         "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
         "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
         "{\n"
         "    FragmentOut out;\n"
         "    float4 opacity = float4(hg_Params[0]);\n"
         "    out.color0 = float4(0.0f);\n"
         "    if (frag._texCoord0.w > 0)\n"
         "    {\n"
         "        float2 coords = frag._texCoord0.xy / frag._texCoord0.w;\n"
         "        out.color0 = hg_Texture0.sample(hg_Sampler0, coords) * opacity;\n"
         "    }\n"
         "    return out;\n"
         "}\n"
         "//MD5=ff0a9e5f:fb2b6628:41f3111f:93dff02b\n"
         "//SIG=00000000:00000000:00000000:00000000:0002:0001:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
    if (v5 == 27) {
      uint64_t v6 = "//Metal1.0     \n"
    }
           "//LEN=0000000351\n"
           "fragment FragmentOut fragmentFunc(VertexInOut           frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    FragmentOut out;\n"
           "    half4 opacity = half4(hg_Params[0]);\n"
           "    half4 color = half4(0.0f);\n"
           "    if (frag._texCoord0.w > 0)\n"
           "    {\n"
           "        float2 coords = frag._texCoord0.xy / frag._texCoord0.w;\n"
           "        color = hg_Texture0.sample(hg_Sampler0, coords);\n"
           "        color *= opacity;\n"
           "    }\n"
           "    out.color0 = float4(color);\n"
           "    return out;\n"
           "}\n"
           "//MD5=d87d279d:1a15ee10:6cfaa609:bc4cd42e\n"
           "//SIG=00000000:00000000:00000000:00000001:0002:0001:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    unint64_t v7 = "//Metal1.0     \n"
         "//LEN=00000002c6\n"
         "fragment FragmentOut fragmentFunc(VertexInOut           frag        [[ stage_in ]],\n"
         "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
         "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
         "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
         "{\n"
         "    FragmentOut out;\n"
         "    half4 opacity = half4(hg_Params[0]);\n"
         "    half4 color = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
         "    out.color0 = float4(color * opacity);\n"
         "    return out;\n"
         "}\n"
         "//MD5=a3cb44f9:6715c139:a9f991d6:a1c11988\n"
         "//SIG=00000000:00000000:00000000:00000001:0000:0001:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    if (v5 != 27) {
      unint64_t v7 = "//Metal1.0     \n"
    }
           "//LEN=00000002c1\n"
           "fragment FragmentOut fragmentFunc(VertexInOut           frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    FragmentOut out;\n"
           "    float4 opacity = float4(hg_Params[0]);\n"
           "    float4 color = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "    out.color0 = color * opacity;\n"
           "    return out;\n"
           "}\n"
           "//MD5=b060eb93:167cbcc8:62f25ab3:18c99b04\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
    if (*((_DWORD *)this + 119)) {
      return v6;
    }
    else {
      return v7;
    }
  }
  unsigned int v10 = Target;
  if (Target > 0x6060F && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  {
    if (*((unsigned char *)this + 512) && *((_DWORD *)this + 118)) {
      return "//GLfs2.0      \n"
    }
             "//LEN=0000000295\n"
             "#ifndef GL_ES\n"
             "#define lowp\n"
             "#define mediump\n"
             "#define highp\n"
             "#endif\n"
             "#define defaultp mediump\n"
             "uniform defaultp sampler2D hg_Texture0;\n"
             "uniform defaultp vec4 hg_ProgramLocal0;\n"
             "varying highp vec4 hg_TexCoord0;\n"
             "void main()\n"
             "{\n"
             "    defaultp vec4 r1;\n"
             "    lowp vec4 r0;\n"
             "    bvec4 b0;\n"
             "\n"
             "    r1 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
             "    b0.xy = lessThan(vec2(0.0), hg_TexCoord0.xy);\n"
             "    b0.zw = lessThan(hg_TexCoord0.xy, vec2(1.0));\n"
             "    r0 = vec4(all(b0));\n"
             "    gl_FragColor = r1*hg_ProgramLocal0*r0;\n"
             "}\n"
             "//MD5=8924dd58:af75c4ef:65163cb7:950dc52e\n"
             "//SIG=00000000:00000000:00000000:00000000:0004:0001:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
    if (*((_DWORD *)this + 119)) {
      return "//GLfs2.0      \n"
    }
             "//LEN=00000001f3\n"
             "#ifndef GL_ES\n"
             "#define lowp\n"
             "#define mediump\n"
             "#define highp\n"
             "#endif\n"
             "#define defaultp mediump\n"
             "uniform defaultp sampler2D hg_Texture0;\n"
             "uniform defaultp vec4 hg_ProgramLocal0;\n"
             "varying highp vec4 hg_TexCoord0;\n"
             "void main()\n"
             "{\n"
             "\n"
             "    gl_FragColor = hg_TexCoord0.w>0. ? texture2DProj(hg_Texture0, hg_TexCoord0)*hg_ProgramLocal0 : vec4(0.)"
             ";\n"
             "}\n"
             "//MD5=6da3c304:b0faeba4:dba5c887:64ab3ead\n"
             "//SIG=00000000:00000000:00000000:00000000:0002:0001:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
    if (*((_DWORD *)this + 118)) {
      return "//GLfs2.0      \n"
    }
             "//LEN=00000001f6\n"
             "#ifndef GL_ES\n"
             "#define lowp\n"
             "#define mediump\n"
             "#define highp\n"
             "#endif\n"
             "#define defaultp mediump\n"
             "uniform defaultp sampler2D hg_Texture0;\n"
             "uniform defaultp vec4 hg_ProgramLocal0;\n"
             "varying highp vec4 hg_TexCoord0;\n"
             "void main()\n"
             "{\n"
             "    defaultp vec4 r0;\n"
             "\n"
             "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
             "    gl_FragColor = r0*hg_ProgramLocal0;\n"
             "}\n"
             "//MD5=67977a2c:d8a14038:8edc7643:d46e92bc\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
    HGString::sample2d((HGString *)0x60620, 0, 0, (HGString *)v24);
    string_t v19 = HGString::c_str(v24, v21, v22, v23);
LABEL_25:
    string_t v20 = v19;
    HGString::~HGString((HGString *)v24);
    return v20;
  }
  if (!*((_DWORD *)this + 118))
  {
    HGString::sampleRect((HGString *)0x60310, 0, v24);
    string_t v19 = HGString::c_str(v24, v16, v17, v18);
    goto LABEL_25;
  }
  unint64_t v8 = "!!ARBfp1.0     \n"
       "##LEN=000000020e\n"
       "##                          \n"
       "##                            \n"
       "##                                \n"
       "##                                     \n"
       "##$\n"
       "OUTPUT $o0=result.color;\n"
       "ATTRIB $f0=fragment.texcoord[0];\n"
       "PARAM $p0=program.local[0];\n"
       "##%\n"
       "TEMP r0;\n"
       "##@\n"
       "RCP r0.x,$f0.w;\n"
       "MUL r0.xy,$f0,r0.xxxx;\n"
       "##0\n"
       "TEX r0,r0,texture[0],RECT;\n"
       "MUL r0,r0,$p0;\n"
       "CMP $o0,-$f0.wwww,r0,0;\n"
       "END\n"
       "##MD5=ba6baee1:6abbea5d:27d71074:2b006e3e\n"
       "##SIG=00000000:00000000:00000000:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  if (v10 > 0x6043F || v10 - 394016 < 0xF0) {
    return v8;
  }
  int v11 = *((_DWORD *)this + 108);
  BOOL v12 = v11 == 0;
  if (v11) {
    __int32 v13 = "!!ARBfp1.0     \n"
  }
          "##LEN=0000000470\n"
          "##                          \n"
          "##                            \n"
          "##                                \n"
          "##                                     \n"
          "##$\n"
          "OUTPUT $o0=result.color;\n"
          "ATTRIB $f0=fragment.texcoord[0];\n"
          "ATTRIB $f1=fragment.texcoord[1];\n"
          "PARAM $p0=program.local[0];\n"
          "PARAM $p1=program.local[1];\n"
          "PARAM $p2=program.local[2];\n"
          "PARAM $p3=program.local[3];\n"
          "PARAM $c0={0.5,0.5,0,0};\n"
          "PARAM $c1={1,0,0,0};\n"
          "PARAM $c2={1,1,0,0};\n"
          "PARAM $c3={0,1,0,0};\n"
          "##%\n"
          "TEMP r0,r1,r2,r3,r4,r5,r6;\n"
          "##@\n"
          "MOV r1,$f0;\n"
          "FLR r1.xy,r1;\n"
          "ADD r1.xy,r1,$c0;\n"
          "DP4 r0.x,r1,$p1;\n"
          "DP4 r0.y,r1,$p2;\n"
          "DP4 r0.w,r1,$p3;\n"
          "RCP r6.w,r0.w;\n"
          "MUL r0.xy,r0,r6.w;\n"
          "ADD r0.xy,r0,$f1;\n"
          "SUB r5.xy,r0,$c0;\n"
          "FLR r4.xy,r5;\n"
          "ADD r0.xy,r4,$c0;\n"
          "ADD r1.xy,r0,$c1;\n"
          "ADD r2.xy,r0,$c2;\n"
          "ADD r3.xy,r0,$c3;\n"
          "SUB r4.xy,r5,r4;\n"
          "##0\n"
          "TEX r0,r0,texture[0],RECT;\n"
          "##0\n"
          "TEX r1,r1,texture[0],RECT;\n"
          "##0\n"
          "TEX r2,r2,texture[0],RECT;\n"
          "##0\n"
          "TEX r3,r3,texture[0],RECT;\n"
          "LRP r0,r4.xxxx,r1,r0;\n"
          "LRP r3,r4.xxxx,r2,r3;\n"
          "LRP r4,r4.yyyy,r3,r0;\n"
          "MUL r4,r4,$p0;\n"
          "CMP $o0,-r6.wwww,r4,0;\n"
          "END\n"
          "##MD5=e8e320ed:12e7f96c:37a47e61:fd7395c2\n"
          "##SIG=00000000:00000000:00000000:00000000:0004:0004:0007:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  else {
    __int32 v13 = "!!ARBfp1.0     \n"
  }
          "##LEN=000000030a\n"
          "##                          \n"
          "##                            \n"
          "##                                \n"
          "##                                     \n"
          "##$\n"
          "OUTPUT $o0=result.color;\n"
          "ATTRIB $f0=fragment.texcoord[0];\n"
          "ATTRIB $f1=fragment.texcoord[1];\n"
          "PARAM $p0=program.local[0];\n"
          "PARAM $p1=program.local[1];\n"
          "PARAM $p2=program.local[2];\n"
          "PARAM $p3=program.local[3];\n"
          "PARAM $c0={0.5,0.5,0,0};\n"
          "##%\n"
          "TEMP r0,r1;\n"
          "##@\n"
          "MOV r1,$f0;\n"
          "FLR r1.xy,r1;\n"
          "ADD r1.xy,r1,$c0;\n"
          "DP4 r0.x,r1,$p1;\n"
          "DP4 r0.y,r1,$p2;\n"
          "DP4 r0.w,r1,$p3;\n"
          "RCP r1.w,r0.w;\n"
          "MUL r0.xy,r0,r1.w;\n"
          "ADD r0.xy,r0,$f1;\n"
          "##0\n"
          "TEX r0,r0,texture[0],RECT;\n"
          "MUL r0,r0,$p0;\n"
          "CMP $o0,-r1.wwww,r0,0;\n"
          "END\n"
          "##MD5=bffa8b15:90b4d691:b0bcecc3:a4d117c6\n"
          "##SIG=00000000:00000000:00000000:00000000:0001:0004:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  double v14 = "!!ARBfp1.0     \n"
        "##LEN=0000000390\n"
        "##                          \n"
        "##                            \n"
        "##                                \n"
        "##                                     \n"
        "##$\n"
        "OUTPUT $o0=result.color;\n"
        "ATTRIB $f0=fragment.texcoord[0];\n"
        "PARAM $p0=program.local[0];\n"
        "PARAM $c0={0.5,0.5,0,0};\n"
        "PARAM $c1={1,0,0,0};\n"
        "PARAM $c2={1,1,0,0};\n"
        "PARAM $c3={0,1,0,0};\n"
        "##%\n"
        "TEMP r0,r1,r2,r3,r4,r5,r6;\n"
        "##@\n"
        "RCP r6.x,$f0.w;\n"
        "MUL r0.xy,$f0,r6.xxxx;\n"
        "SUB r5.xy,r0,$c0;\n"
        "FLR r4.xy,r5;\n"
        "ADD r0.xy,r4,$c0;\n"
        "ADD r1.xy,r0,$c1;\n"
        "ADD r2.xy,r0,$c2;\n"
        "ADD r3.xy,r0,$c3;\n"
        "SUB r4.xy,r5,r4;\n"
        "##0\n"
        "TEX r0,r0,texture[0],RECT;\n"
        "##0\n"
        "TEX r1,r1,texture[0],RECT;\n"
        "##0\n"
        "TEX r2,r2,texture[0],RECT;\n"
        "##0\n"
        "TEX r3,r3,texture[0],RECT;\n"
        "LRP r0,r4.xxxx,r1,r0;\n"
        "LRP r3,r4.xxxx,r2,r3;\n"
        "LRP r4,r4.yyyy,r3,r0;\n"
        "MUL r4,r4,$p0;\n"
        "CMP $o0,-$f0.wwww,r4,0;\n"
        "END\n"
        "##MD5=3b007a19:592e1872:2b7c0a61:288374c5\n"
        "##SIG=00000000:00000000:00000000:00000000:0004:0001:0007:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  if (v12) {
    double v14 = "!!ARBfp1.0     \n"
  }
          "##LEN=000000020e\n"
          "##                          \n"
          "##                            \n"
          "##                                \n"
          "##                                     \n"
          "##$\n"
          "OUTPUT $o0=result.color;\n"
          "ATTRIB $f0=fragment.texcoord[0];\n"
          "PARAM $p0=program.local[0];\n"
          "##%\n"
          "TEMP r0;\n"
          "##@\n"
          "RCP r0.x,$f0.w;\n"
          "MUL r0.xy,$f0,r0.xxxx;\n"
          "##0\n"
          "TEX r0,r0,texture[0],RECT;\n"
          "MUL r0,r0,$p0;\n"
          "CMP $o0,-$f0.wwww,r0,0;\n"
          "END\n"
          "##MD5=ba6baee1:6abbea5d:27d71074:2b006e3e\n"
          "##SIG=00000000:00000000:00000000:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  if (v10 > 0x6030F) {
    return v14;
  }
  else {
    return v13;
  }
}

void sub_1B781D5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B781D608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGXForm::InitProgramDescriptor(HGXForm *this, HGProgramDescriptor *a2)
{
  HGMetalUtils::stringForMetalHeader((uint64_t)&v27);
  HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)1, 0, (uint64_t)v25);
  if ((v26 & 0x80u) == 0) {
    uint64_t v4 = v25;
  }
  else {
    uint64_t v4 = (void **)v25[0];
  }
  if ((v26 & 0x80u) == 0) {
    std::string::size_type v5 = v26;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)v25[1];
  }
  uint64_t v6 = std::string::append(&v27, (const std::string::value_type *)v4, v5);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v28.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  HGMetalUtils::stringForMetalVertexShader((HGMetalUtils *)"vertexFunc", (const char *)1, 0, (uint64_t)v23);
  if ((v24 & 0x80u) == 0) {
    unint64_t v8 = v23;
  }
  else {
    unint64_t v8 = (void **)v23[0];
  }
  if ((v24 & 0x80u) == 0) {
    std::string::size_type v9 = v24;
  }
  else {
    std::string::size_type v9 = (std::string::size_type)v23[1];
  }
  unsigned int v10 = std::string::append(&v28, (const std::string::value_type *)v8, v9);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v29.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  HGMetalUtils::stringForMetalFragmentOutputStruct((HGMetalUtils *)1, 0, (uint64_t)__p);
  if ((v22 & 0x80u) == 0) {
    BOOL v12 = __p;
  }
  else {
    BOOL v12 = (void **)__p[0];
  }
  if ((v22 & 0x80u) == 0) {
    std::string::size_type v13 = v22;
  }
  else {
    std::string::size_type v13 = (std::string::size_type)__p[1];
  }
  double v14 = std::string::append(&v29, (const std::string::value_type *)v12, v13);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (*((_DWORD *)this + 119)) {
    double v16 = "//Metal1.0     \n"
  }
          "//LEN=0000000328\n"
          "fragment FragmentOut fragmentFunc(VertexInOut           frag        [[ stage_in ]],\n"
          "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
          "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
          "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
          "{\n"
          "    FragmentOut out;\n"
          "    float4 opacity = float4(hg_Params[0]);\n"
          "    out.color0 = float4(0.0f);\n"
          "    if (frag._texCoord0.w > 0)\n"
          "    {\n"
          "        float2 coords = frag._texCoord0.xy / frag._texCoord0.w;\n"
          "        out.color0 = hg_Texture0.sample(hg_Sampler0, coords) * opacity;\n"
          "    }\n"
          "    return out;\n"
          "}\n"
          "//MD5=ff0a9e5f:fb2b6628:41f3111f:93dff02b\n"
          "//SIG=00000000:00000000:00000000:00000000:0002:0001:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  else {
    double v16 = "//Metal1.0     \n"
  }
          "//LEN=00000002c1\n"
          "fragment FragmentOut fragmentFunc(VertexInOut           frag        [[ stage_in ]],\n"
          "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
          "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
          "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
          "{\n"
          "    FragmentOut out;\n"
          "    float4 opacity = float4(hg_Params[0]);\n"
          "    float4 color = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
          "    out.color0 = color * opacity;\n"
          "    return out;\n"
          "}\n"
          "//MD5=b060eb93:167cbcc8:62f25ab3:18c99b04\n"
          "//SIG=00000000:00000000:00000000:00000000:0000:0001:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  double v17 = std::string::append(&v20, v16);
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  int64_t v31 = v17->__r_.__value_.__r.__words[2];
  long long v30 = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v20.__r_.__value_.__l.__data_);
    if (((char)v22 & 0x80000000) == 0)
    {
LABEL_24:
      if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_25;
      }
      goto LABEL_35;
    }
  }
  else if (((char)v22 & 0x80000000) == 0)
  {
    goto LABEL_24;
  }
  operator delete(__p[0]);
  if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_25:
    if (((char)v24 & 0x80000000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_36;
  }
LABEL_35:
  operator delete(v29.__r_.__value_.__l.__data_);
  if (((char)v24 & 0x80000000) == 0)
  {
LABEL_26:
    if ((SHIBYTE(v28.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_37;
  }
LABEL_36:
  operator delete(v23[0]);
  if ((SHIBYTE(v28.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_27:
    if (((char)v26 & 0x80000000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_38;
  }
LABEL_37:
  operator delete(v28.__r_.__value_.__l.__data_);
  if (((char)v26 & 0x80000000) == 0)
  {
LABEL_28:
    if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_29;
    }
LABEL_39:
    operator delete(v27.__r_.__value_.__l.__data_);
LABEL_29:
    if (v31 >= 0) {
      string_t v19 = (const char *)&v30;
    }
    else {
      string_t v19 = (const char *)v30;
    }
    HGProgramDescriptor::SetShaderProgram(a2, v19);
  }
LABEL_38:
  operator delete(v25[0]);
  if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_29;
  }
  goto LABEL_39;
}

void sub_1B781DC58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *__p, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v46 - 128));
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v46 - 96));
  if (*(char *)(v46 - 41) < 0) {
    operator delete(*(void **)(v46 - 64));
  }
  _Unwind_Resume(a1);
}

uint64_t HGXForm::Bind(HGXForm *this, HGRenderer **a2)
{
  double v4 = (*(double (**)(HGXForm *))(*(void *)this + 288))(this);
  (*((void (**)(HGRenderer **, void, double, float, float, float))*a2 + 17))(a2, 0, v4, *(float *)&v4, *(float *)&v4, *(float *)&v4);
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2[18] + 128))(a2[18], 46))
  {
    std::string::size_type v5 = (double *)(*(uint64_t (**)(void))(**((void **)this + 53) + 272))(*((void *)this + 53));
    if (HGRenderer::GetTarget(a2[18], 393216) <= 0x6030F)
    {
      HGHandler::TexCoord((HGHandler *)a2, 0, 0, 0, 0);
      float v6 = *v5;
      float v7 = v5[4];
      float v8 = v5[8];
      float v9 = v5[12];
      (*((void (**)(HGRenderer **, uint64_t, float, float, float, float))*a2 + 17))(a2, 1, v6, v7, v8, v9);
      float v10 = v5[1];
      float v11 = v5[5];
      float v12 = v5[9];
      float v13 = v5[13];
      (*((void (**)(HGRenderer **, uint64_t, float, float, float, float))*a2 + 17))(a2, 2, v10, v11, v12, v13);
      float v14 = v5[3];
      float v15 = v5[7];
      float v16 = v5[11];
      float v17 = v5[15];
      (*((void (**)(HGRenderer **, uint64_t, float, float, float, float))*a2 + 17))(a2, 3, v14, v15, v16, v17);
    }
  }
  return 0;
}

uint64_t HGXForm::BindTexture(HGXForm *this, HGRenderer **a2, int a3)
{
  if (a3) {
    return 0;
  }
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2[18] + 128))(a2[18], 46))
  {
    unsigned int Target = HGRenderer::GetTarget(a2[18], 393216);
    if (Target <= 0x6030F)
    {
      (*((void (**)(HGRenderer **, void, void))*a2 + 9))(a2, 0, 0);
      (*((void (**)(HGRenderer **, void, void))*a2 + 6))(a2, 0, 0);
      HGHandler::TexOffset((HGHandler *)a2, 1, 0, 0);
      return 0;
    }
    else
    {
      unsigned int v7 = Target;
      float v8 = (const double *)(*(uint64_t (**)(void))(**((void **)this + 53) + 272))(*((void *)this + 53));
      HGHandler::TexCoord((HGHandler *)a2, 0, 0, 0, v8);
      (*((void (**)(HGRenderer **, void, void))*a2 + 9))(a2, 0, 0);
      if (v7 > 0x6043F || v7 - 394016 <= 0xEF) {
        (*((void (**)(HGRenderer **, void, void))*a2 + 6))(a2, *((unsigned int *)this + 108), *((unsigned int *)this + 108));
      }
      else {
        (*((void (**)(HGRenderer **, void, void))*a2 + 6))(a2, 0, 0);
      }
      return 0;
    }
  }
  else
  {
    float v9 = (const double *)(*(uint64_t (**)(void))(**((void **)this + 53) + 272))(*((void *)this + 53));
    (*((void (**)(HGRenderer **, void, void))*a2 + 9))(a2, 0, 0);
    (*((void (**)(HGRenderer **, void, void))*a2 + 6))(a2, *((unsigned int *)this + 108), *((unsigned int *)this + 108));
    HGHandler::TexCoord((HGHandler *)a2, 0, 0, 0, v9);
    (*((void (**)(HGRenderer **))*a2 + 21))(a2);
    return 0;
  }
}

uint64_t HGXForm::IntermediateFormat(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 520);
  if ((int)v2 <= (int)a2) {
    return a2;
  }
  else {
    return v2;
  }
}

uint64_t HGXForm::GetParameterCount(HGXForm *this)
{
  return 1;
}

const char *HGXForm::GetParameterName(HGXForm *this, int a2)
{
  if (a2) {
    return 0;
  }
  else {
    return "bias:min:max:anisotropy";
  }
}

uint64_t HGXForm::SetParameter(HGXForm *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2 != 1)
  {
    if (!a2)
    {
      int v10 = (*(uint64_t (**)(HGXForm *, float))(*(void *)this + 608))(this, a3);
      int v11 = (*(uint64_t (**)(HGXForm *, float))(*(void *)this + 616))(this, a4) | v10;
      int v12 = (*(uint64_t (**)(HGXForm *, float))(*(void *)this + 624))(this, a5);
      return v11 | v12 | (*(unsigned int (**)(HGXForm *, float))(*(void *)this + 632))(this, a6);
    }
    return 0;
  }
  if (*((_DWORD *)this + 130) == a3) {
    return 0;
  }
  *((_DWORD *)this + 130) = a3;
  return 1;
}

float HGXForm::GetParameter(HGXForm *this, int a2, float *a3)
{
  if (!a2)
  {
    *a3 = *((float *)this + 123);
    a3[1] = *((float *)this + 124);
    a3[2] = *((float *)this + 125);
    float result = *((float *)this + 126);
    a3[3] = result;
  }
  return result;
}

uint64_t HGXForm::SetLodBias(HGXForm *this, float a2, uint64_t a3, char *a4)
{
  if (*((float *)this + 123) == a2) {
    return 0;
  }
  *((float *)this + 123) = a2;
  HGNode::ClearBits((HGNode *)this, a3, a4);
  return 1;
}

uint64_t HGXForm::SetMinLod(HGXForm *this, float a2, uint64_t a3, char *a4)
{
  if (*((float *)this + 124) == a2) {
    return 0;
  }
  *((float *)this + 124) = a2;
  HGNode::ClearBits((HGNode *)this, a3, a4);
  return 1;
}

uint64_t HGXForm::SetMaxLod(HGXForm *this, float a2, uint64_t a3, char *a4)
{
  if (*((float *)this + 125) == a2) {
    return 0;
  }
  *((float *)this + 125) = a2;
  HGNode::ClearBits((HGNode *)this, a3, a4);
  return 1;
}

uint64_t HGXForm::SetAnisotropy(HGXForm *this, float a2, uint64_t a3, char *a4)
{
  if (*((float *)this + 126) == a2) {
    return 0;
  }
  *((float *)this + 126) = a2;
  HGNode::ClearBits((HGNode *)this, a3, a4);
  return 1;
}

uint64_t HGXForm::SetLodFilter(uint64_t a1, uint64_t a2, char *a3)
{
  if (*(_DWORD *)(a1 + 508) == a2) {
    return 0;
  }
  *(_DWORD *)(a1 + 508) = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  return 1;
}

uint64_t HGXForm::SetClipDistance(HGXForm *this, float a2, uint64_t a3, char *a4)
{
  if (*((float *)this + 129) == a2) {
    return 0;
  }
  *((float *)this + 129) = a2;
  HGNode::ClearBits((HGNode *)this, a3, a4);
  return 1;
}

float HGXForm::GetClipDistance(HGXForm *this)
{
  return *((float *)this + 129);
}

BOOL HGXForm::IsAnisotropic(HGXForm *this)
{
  return (*((float *)this + 123) != 0.0 || *((float *)this + 124) != 0.0) && *((float *)this + 126) > 0.0;
}

void HGNodeBuffer::~HGNodeBuffer(HGNodeBuffer *this)
{
  HGBuffer::~HGBuffer(this);

  HGObject::operator delete(v1);
}

void HGHWMultiBlend::HGHWMultiBlend(HGHWMultiBlend *this)
{
}

void sub_1B781E7B0(_Unwind_Exception *a1)
{
  double v4 = v3;
  std::__hash_table<std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::__unordered_map_hasher<OZSceneNode *,std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::hash<OZSceneNode *>,std::equal_to<OZSceneNode *>,true>,std::__unordered_map_equal<OZSceneNode *,std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::equal_to<OZSceneNode *>,std::hash<OZSceneNode *>,true>,std::allocator<std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>>>::~__hash_table(v2);
  float v6 = *v4;
  if (*v4)
  {
    *((void *)v1 + 72) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *((void *)v1 + 68);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  HGHWBlendFlipped::~HGHWBlendFlipped(v1);
  _Unwind_Resume(a1);
}

uint64_t HGHWMultiBlend::label_B(HGHWMultiBlend *this)
{
  return 0;
}

uint64_t HGHWMultiBlend::SetInput(HGHWMultiBlend *this, uint64_t a2, HGNode *a3)
{
  return (*(uint64_t (**)(HGHWMultiBlend *, uint64_t, HGNode *, void, float))(*(void *)this + 624))(this, a2, a3, 0, 1.0);
}

uint64_t HGHWMultiBlend::SetInput(HGHWMultiBlend *this, uint64_t a2, HGNode *a3, uint64_t a4, float a5, uint64_t a6)
{
  __asm { FMOV            V1.4S, #1.0 }
  long long v12 = _Q1;
  return (*(uint64_t (**)(HGHWMultiBlend *, uint64_t, HGNode *, uint64_t, long long *, uint64_t, float))(*(void *)this + 640))(this, a2, a3, a4, &v12, a6, a5);
}

uint64_t HGHWMultiBlend::SetInput(HGNode *this, uint64_t a2, HGNode *a3, int a4, long long *a5, int a6, float a7)
{
  int v14 = a2 & 0xFFFFFFF8;
  float v15 = (uint64_t *)((char *)this + 568);
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 72) - *((void *)this + 71)) >> 4);
  unint64_t v17 = (int)((a2 & 0xFFFFFFF8) + 8);
  if (v17 > v16) {
    std::vector<HGLayerParams>::__append((void **)this + 71, v17 - v16);
  }
  int v18 = *((_DWORD *)this + 22);
  if (v18 <= (int)a2)
  {
    if (v18 < (int)a2)
    {
      int v32 = a6;
      string_t v19 = (HGNode *)HGObject::operator new(0x1A0uLL);
      HGNode::HGNode(v19);
      signed int v20 = *((_DWORD *)this + 22);
      if (v20 < (int)a2)
      {
        do
          HGNode::SetInput(this, v20++, v19);
        while (a2 != v20);
      }
      (*(void (**)(HGNode *))(*(void *)v19 + 24))(v19);
      int v18 = *((_DWORD *)this + 22);
      a6 = v32;
    }
    if (v18 < (int)v17)
    {
      uint64_t v21 = *v15;
      uint64_t v22 = v14 + 8;
      unint64_t v23 = v22 - v18;
      if (v23 < 2)
      {
        unint64_t v24 = v18;
LABEL_14:
        std::string v27 = (_DWORD *)(v21 + 48 * v24 + 8);
        do
        {
          *std::string v27 = v24;
          v27 += 12;
          ++v24;
        }
        while (v22 != v24);
        goto LABEL_16;
      }
      unint64_t v24 = (v23 & 0xFFFFFFFFFFFFFFFELL) + v18;
      double v25 = (_DWORD *)(v21 + 48 * v18 + 56);
      unint64_t v26 = v23 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        *(v25 - 12) = v18;
        *double v25 = v18 + 1;
        v25 += 24;
        v18 += 2;
        v26 -= 2;
      }
      while (v26);
      if (v23 != (v23 & 0xFFFFFFFFFFFFFFFELL)) {
        goto LABEL_14;
      }
    }
  }
LABEL_16:
  uint64_t v28 = HGNode::SetInput(this, a2, a3);
  if ((int)a2 >= 1)
  {
    (*(void (**)(HGNode *, uint64_t, uint64_t))(*(void *)this + 136))(this, a2, 16);
    long long v29 = *a5;
    uint64_t v30 = *((void *)this + 71) + 48 * a2;
    *(_DWORD *)uint64_t v30 = a4;
    *(float *)(v30 + 4) = a7;
    *(_DWORD *)(v30 + 8) = a6;
    *(_OWORD *)(v30 + 16) = v29;
    *(_DWORD *)(v30 + 32) = 0;
  }
  return v28;
}

void sub_1B781EAC0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGHWMultiBlend::SetInput(HGHWMultiBlend *this, uint64_t a2, HGNode *a3, uint64_t a4, float a5)
{
  __asm { FMOV            V1.4S, #1.0 }
  long long v11 = _Q1;
  return (*(uint64_t (**)(HGHWMultiBlend *, uint64_t, HGNode *, uint64_t, long long *, uint64_t, float))(*(void *)this + 640))(this, a2, a3, a4, &v11, a2, a5);
}

uint64_t HGHWMultiBlend::SetInput(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 640))(a1, a2, a3, a4, a5, a2);
}

uint64_t HGHWMultiBlend::UpdateHWBlendStatus(uint64_t this, HGRenderer *a2)
{
  *(unsigned char *)(this + 480) = *(_DWORD *)(this + 472) != 0;
  return this;
}

HGHWMultiBlend *HGHWMultiBlend::GetOutput(HGHWMultiBlend *this, HGRenderer *a2)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v110, "multiblend", 1, "HGHWMultiBlend::GetOutput");
  if ((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2)) {
    goto LABEL_2;
  }
  (*(void (**)(HGHWMultiBlend *, HGRenderer *))(*(void *)this + 592))(this, a2);
  Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
  if (*((int *)this + 22) >= 2)
  {
    *(void *)uint64_t v100 = 0;
    unsigned int v6 = 0;
    char v95 = 0;
    unint64_t v7 = 1;
    while (1)
    {
      uint64_t v10 = *((void *)this + 71);
      uint64_t v11 = v10 + 48 * v7;
      *((_DWORD *)this + 106) = *(_DWORD *)v11;
      float v12 = *(float *)(v11 + 4);
      *((float *)this + 104) = v12;
      *((_OWORD *)this + 31) = *(_OWORD *)(v11 + 16);
      if (v12 == 0.0) {
        goto LABEL_8;
      }
      float v13 = HGRenderer::GetInput(a2, (HGNode *)this, v7);
      uint64_t DOD = HGRenderer::GetDOD(a2, v13);
      uint64_t v16 = HGRectIntersection(DOD, v15, *((void *)this + 69), *((void *)this + 70));
      uint64_t v18 = v17;
      if (HGRectIsNull(v16, v17)) {
        goto LABEL_8;
      }
      *(_DWORD *)(*((void *)this + 71) + 48 * v7 + 32) |= 1u;
      uint64_t v19 = v10 + 48 * v7;
      int v21 = *(_DWORD *)(v19 + 8);
      signed int v20 = (int *)(v19 + 8);
      if (v21)
      {
        LODWORD(__p[0]) = 0;
        unint64_t v22 = *v20;
        LODWORD(__p[0]) = v22;
        int8x8_t v23 = *(int8x8_t *)((char *)this + 600);
        if (v23)
        {
          uint8x8_t v24 = (uint8x8_t)vcnt_s8(v23);
          v24.i16[0] = vaddlv_u8(v24);
          if (v24.u32[0] > 1uLL)
          {
            unint64_t v25 = v22;
            if (*(void *)&v23 <= v22) {
              unint64_t v25 = v22 % *(void *)&v23;
            }
          }
          else
          {
            unint64_t v25 = (*(void *)&v23 - 1) & v22;
          }
          unint64_t v26 = *(uint64_t ***)(*((void *)this + 74) + 8 * v25);
          if (v26)
          {
            std::string v27 = *v26;
            if (v27)
            {
              if (v24.u32[0] < 2uLL)
              {
                uint64_t v28 = *(void *)&v23 - 1;
                while (1)
                {
                  uint64_t v30 = v27[1];
                  if (v30 == v22)
                  {
                    if (*((_DWORD *)v27 + 4) == v22) {
                      goto LABEL_33;
                    }
                  }
                  else if ((v30 & v28) != v25)
                  {
                    goto LABEL_34;
                  }
                  std::string v27 = (uint64_t *)*v27;
                  if (!v27) {
                    goto LABEL_34;
                  }
                }
              }
              do
              {
                unint64_t v29 = v27[1];
                if (v29 == v22)
                {
                  if (*((_DWORD *)v27 + 4) == v22)
                  {
LABEL_33:
                    uint64_t v16 = HGRectUnion(*(uint64_t *)((char *)v27 + 20), *(uint64_t *)((char *)v27 + 28), v16, v18);
                    uint64_t v18 = v31;
                    break;
                  }
                }
                else
                {
                  if (v29 >= *(void *)&v23) {
                    v29 %= *(void *)&v23;
                  }
                  if (v29 != v25) {
                    break;
                  }
                }
                std::string v27 = (uint64_t *)*v27;
              }
              while (v27);
            }
          }
        }
LABEL_34:
        v103[0] = __p;
        int v32 = std::__hash_table<std::__hash_value_type<int,HGRect>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HGRect>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HGRect>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HGRect>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)this + 592, (int *)__p, (uint64_t)&std::piecewise_construct, v103);
        *(uint64_t *)((char *)v32 + 20) = v16;
        *(uint64_t *)((char *)v32 + 28) = v18;
      }
      if (HGHWBlendFlipped::IsHardwareBlendSupported(this, a2))
      {
        *(_DWORD *)(*((void *)this + 71) + 48 * v7 + 32) |= 2u;
        if (HGNode::DoInplaceHardwareBlending(v13, a2, (HGNode *)this, *((float *)this + 104))) {
          *(_DWORD *)(*((void *)this + 71) + 48 * v7 + 32) |= 4u;
        }
      }
      ++v100[1];
      if (v7 >= 2)
      {
        uint64_t v33 = *((void *)this + 71);
        uint64_t v34 = v33 + 48 * v6;
        int v37 = *(_DWORD *)(v34 + 32);
        double v35 = (int *)(v34 + 32);
        int v36 = v37;
        if (*(v35 - 6) == *(_DWORD *)(v33 + 48 * v7 + 8))
        {
          *double v35 = v36 | 8;
          float v8 = (_DWORD *)(v33 + 48 * v7 + 32);
          int v9 = 8;
        }
        else
        {
          if ((v36 & 2) != 0) {
            goto LABEL_7;
          }
          uint64_t v38 = v33 + 48 * v7;
          char v39 = *(unsigned char *)(v38 + 32);
          float v8 = (_DWORD *)(v38 + 32);
          if ((v39 & 2) != 0) {
            goto LABEL_7;
          }
          *double v35 = v36 | 0x10;
          char v95 = 1;
          int v9 = 16;
        }
        *v8 |= v9;
      }
LABEL_7:
      unsigned int v6 = v7;
      v100[0] = v7;
LABEL_8:
      if ((uint64_t)++v7 >= *((int *)this + 22)) {
        goto LABEL_44;
      }
    }
  }
  char v95 = 0;
  *(void *)uint64_t v100 = 0;
LABEL_44:
  unsigned __int8 v40 = atomic_load(HGLogger::_enabled);
  if ((v40 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"multiblend", v5) >= 1)
  {
    int v41 = *((_DWORD *)this + 22);
    if (v41 >= 2)
    {
      uint64_t v42 = 0;
      uint64_t v99 = (_DWORD *)*MEMORY[0x1E4FBA408];
      uint64_t v43 = 1;
      uint64_t v97 = *(void *)(MEMORY[0x1E4FBA408] + 72);
      uint64_t v98 = *(_DWORD **)(MEMORY[0x1E4FBA408] + 64);
      do
      {
        uint64_t v44 = *((void *)this + 71) + v42;
        if (*(unsigned char *)(v44 + 80))
        {
          std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v103);
          *(void *)&v106[*(void *)(v104 - 24)] = 3;
          int v45 = (void *)std::ostream::operator<<();
          uint64_t v46 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)" : [", 4);
          if ((*(_DWORD *)(v44 + 80) & 2) != 0) {
            double v47 = "H";
          }
          else {
            double v47 = " ";
          }
          double v48 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v46, (uint64_t)v47, 1);
          if ((*(_DWORD *)(v44 + 80) & 4) != 0) {
            double v49 = "I";
          }
          else {
            double v49 = " ";
          }
          double v50 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v48, (uint64_t)v49, 1);
          if ((*(_DWORD *)(v44 + 80) & 8) != 0) {
            double v51 = "S";
          }
          else {
            double v51 = " ";
          }
          double v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v50, (uint64_t)v51, 1);
          if ((*(_DWORD *)(v44 + 80) & 0x10) != 0) {
            double v53 = "C";
          }
          else {
            double v53 = " ";
          }
          int v54 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v52, (uint64_t)v53, 1);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v54, (uint64_t)"] p(", 4);
          float v55 = (void *)std::ostream::operator<<();
          int v56 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v55, (uint64_t)") ", 2);
          double v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v56, (uint64_t)"o(", 2);
          uint64_t v58 = *v57;
          *(_DWORD *)((char *)v57 + *(void *)(*v57 - 24) + 8) = *(_DWORD *)((unsigned char *)v57 + *(void *)(*v57 - 24) + 8) & 0xFFFFFEFB | 4;
          *(uint64_t *)((char *)v57 + *(void *)(v58 - 24) + 16) = 2;
          double v59 = (void *)std::ostream::operator<<();
          BOOL v60 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)") ", 2);
          BlendModeLabel = HGHWBlendFlipped::GetBlendModeLabel((HGHWBlendFlipped *)*(unsigned int *)(v44 + 48));
          size_t v62 = strlen(BlendModeLabel);
          float v63 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v60, (uint64_t)BlendModeLabel, v62);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v63, (uint64_t)"(", 1);
          float v64 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v64, (uint64_t)") ", 2);
          unsigned __int8 v65 = atomic_load(HGLogger::_enabled);
          if (v65)
          {
            std::stringbuf::str();
            float v68 = __p;
            if (v102 < 0) {
              float v68 = (void **)__p[0];
            }
            HGLogger::log((HGLogger *)"multiblend", (const char *)1, (HGLogger *)"  %s\n", v66, v67, v68);
            if (v102 < 0) {
              operator delete(__p[0]);
            }
          }
          v103[0] = v99;
          *(_DWORD **)((char *)v103 + *((void *)v99 - 3)) = v98;
          uint64_t v104 = v97;
          uint64_t v105 = MEMORY[0x1E4FBA470] + 16;
          if (v108 < 0) {
            operator delete(v107);
          }
          std::streambuf::~streambuf();
          std::iostream::~basic_iostream();
          MEMORY[0x1BA9BFAB0](&v109);
          int v41 = *((_DWORD *)this + 22);
        }
        ++v43;
        v42 += 48;
      }
      while (v43 < v41);
    }
  }
  if (!v100[1])
  {
    double v4 = (HGHWMultiBlend *)Input;
    goto LABEL_103;
  }
  if (v100[1] == 1)
  {
    uint64_t v69 = (HGHWBlendFlipped *)HGObject::operator new(0x220uLL);
    HGHWBlendFlipped::HGHWBlendFlipped(v69);
    float v70 = (HGHWBlendFlipped *)*((void *)this + 68);
    if (v70 == v69)
    {
      if (v69) {
        (*(void (**)(HGHWBlendFlipped *))(*(void *)v69 + 24))(v69);
      }
    }
    else
    {
      if (v70) {
        (*(void (**)(HGHWBlendFlipped *))(*(void *)v70 + 24))(v70);
      }
      *((void *)this + 68) = v69;
    }
    int v80 = HGRenderer::GetInput(a2, (HGNode *)this, v100[0]);
    (*(void (**)(void, void, HGNode *))(**((void **)this + 68) + 120))(*((void *)this + 68), 0, Input);
    (*(void (**)(void, uint64_t, HGNode *))(**((void **)this + 68) + 120))(*((void *)this + 68), 1, v80);
    uint64_t v81 = *((void *)this + 71);
    (*(void (**)(void, void, float, double, double, double))(**((void **)this + 68) + 96))(*((void *)this + 68), 0, (float)*(int *)(v81 + 48 * v100[0]), 0.0, 0.0, 0.0);
    (*(void (**)(void, uint64_t, float, double, double, double))(**((void **)this + 68) + 96))(*((void *)this + 68), 1, *(float *)(v81 + 48 * v100[0] + 4), 0.0, 0.0, 0.0);
    (*(void (**)(void, uint64_t, double, double, double, double))(**((void **)this + 68) + 96))(*((void *)this + 68), 2, 0.0, 0.0, 0.0, 0.0);
    uint64_t v82 = HGRenderer::GetDOD(a2, Input);
    uint64_t v84 = HGRectIntersection(v82, v83, *((void *)this + 69), *((void *)this + 70));
    uint64_t v86 = v85;
    uint64_t v87 = HGRenderer::GetDOD(a2, v80);
    uint64_t v89 = HGRectIntersection(v87, v88, *((void *)this + 69), *((void *)this + 70));
    BOOL IsEqual = HGRectIsEqual(v84, v86, v89, v90);
    v92.n128_u32[0] = 1.0;
    if (!IsEqual) {
      v92.n128_f32[0] = 2.0;
    }
    (*(void (**)(void, uint64_t, __n128, double, double, double))(**((void **)this + 68) + 96))(*((void *)this + 68), 3, v92, 0.0, 0.0, 0.0);
    (*(void (**)(void, uint64_t, float, double, double, double))(**((void **)this + 68) + 96))(*((void *)this + 68), 4, (float)*((int *)this + 119), 0.0, 0.0, 0.0);
    (*(void (**)(void, uint64_t, float, double, double, double))(**((void **)this + 68) + 96))(*((void *)this + 68), 5, *((float *)this + 105), 0.0, 0.0, 0.0);
    (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 68) + 96))(*((void *)this + 68), 6, *(float *)(v81 + 48 * v100[0] + 16), *(float *)(v81 + 48 * v100[0] + 20), *(float *)(v81 + 48 * v100[0] + 24), *(float *)(v81 + 48 * v100[0] + 28));
    double v4 = (HGHWMultiBlend *)*((void *)this + 68);
  }
  else
  {
    if ((v95 & 1) == 0)
    {
LABEL_2:
      double v4 = this;
      goto LABEL_103;
    }
    float v71 = HGRenderer::GetInput(a2, (HGNode *)this, 0);
    float v72 = (HGHWBlendFlipped *)v71;
    if (v71) {
      (*(void (**)(HGNode *))(*(void *)v71 + 16))(v71);
    }
    if (*((int *)this + 22) >= 2)
    {
      uint64_t v73 = 1;
      uint64_t v74 = 48;
      do
      {
        uint64_t v75 = *((void *)this + 71);
        uint64_t v76 = v75 + v74;
        if (*(unsigned char *)(v75 + v74 + 32))
        {
          unint64_t v77 = HGRenderer::GetInput(a2, (HGNode *)this, v73);
          if ((*(unsigned char *)(v76 + 32) & 0x10) == 0)
          {
            uint64_t v78 = (HGHWMultiBlend *)HGObject::operator new(0x280uLL);
            HGHWMultiBlend::HGHWMultiBlend(v78);
          }
          int v79 = (HGHWBlendFlipped *)HGObject::operator new(0x220uLL);
          HGHWBlendFlipped::HGHWBlendFlipped(v79);
          (*(void (**)(HGHWBlendFlipped *, void, HGHWBlendFlipped *))(*(void *)v79 + 120))(v79, 0, v72);
          (*(void (**)(HGHWBlendFlipped *, uint64_t, HGNode *))(*(void *)v79 + 120))(v79, 1, v77);
          (*(void (**)(HGHWBlendFlipped *, void, float, double, double, double))(*(void *)v79 + 96))(v79, 0, (float)*(int *)v76, 0.0, 0.0, 0.0);
          (*(void (**)(HGHWBlendFlipped *, uint64_t, float, double, double, double))(*(void *)v79 + 96))(v79, 1, *(float *)(v75 + v74 + 4), 0.0, 0.0, 0.0);
          (*(void (**)(HGHWBlendFlipped *, uint64_t, double, double, double, double))(*(void *)v79 + 96))(v79, 2, 0.0, 0.0, 0.0, 0.0);
          (*(void (**)(HGHWBlendFlipped *, uint64_t, double, double, double, double))(*(void *)v79 + 96))(v79, 3, 0.0, 0.0, 0.0, 0.0);
          (*(void (**)(HGHWBlendFlipped *, uint64_t, float, double, double, double))(*(void *)v79 + 96))(v79, 4, (float)*((int *)this + 119), 0.0, 0.0, 0.0);
          (*(void (**)(HGHWBlendFlipped *, uint64_t, float, double, double, double))(*(void *)v79 + 96))(v79, 5, *((float *)this + 105), 0.0, 0.0, 0.0);
          (*(void (**)(HGHWBlendFlipped *, uint64_t, float, float, float, float))(*(void *)v79 + 96))(v79, 6, *(float *)(v75 + v74 + 16), *(float *)(v75 + v74 + 20), *(float *)(v75 + v74 + 24), *(float *)(v75 + v74 + 28));
          if (v72 != v79)
          {
            if (v72) {
              (*(void (**)(HGHWBlendFlipped *))(*(void *)v72 + 24))(v72);
            }
            float v72 = v79;
            (*(void (**)(HGHWBlendFlipped *))(*(void *)v79 + 16))(v79);
          }
          (*(void (**)(HGHWBlendFlipped *))(*(void *)v79 + 24))(v79);
        }
        ++v73;
        v74 += 48;
      }
      while (v73 < *((int *)this + 22));
    }
    float v93 = (HGHWBlendFlipped *)*((void *)this + 68);
    double v4 = v72;
    if (v93 != v72)
    {
      if (v93) {
        (*(void (**)(HGHWBlendFlipped *))(*(void *)v93 + 24))(v93);
      }
      *((void *)this + 68) = v72;
      if (v72)
      {
        (*(void (**)(HGHWBlendFlipped *))(*(void *)v72 + 16))(v72);
        double v4 = (HGHWMultiBlend *)*((void *)this + 68);
      }
      else
      {
        double v4 = 0;
      }
    }
    if (v72) {
      (*(void (**)(HGHWBlendFlipped *))(*(void *)v72 + 24))(v72);
    }
  }
LABEL_103:
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v110);
  return v4;
}

void sub_1B781FB8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v25 - 112));
  _Unwind_Resume(a1);
}

uint64_t HGHWMultiBlend::GetDOD(HGHWMultiBlend *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if ((a3 & 0x80000000) != 0
    || *((_DWORD *)this + 22) <= (signed int)a3
    || a3 && *(float *)(*((void *)this + 71) + 48 * a3 + 4) == 0.0)
  {
    return 0;
  }
  else
  {
    return *(void *)&a4.var0;
  }
}

uint64_t HGHWMultiBlend::GetROI(HGHWMultiBlend *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if ((a3 & 0x80000000) != 0
    || *((_DWORD *)this + 22) <= (signed int)a3
    || a3 && *(float *)(*((void *)this + 71) + 48 * a3 + 4) == 0.0)
  {
    return 0;
  }
  else
  {
    return *(void *)&a4.var0;
  }
}

uint64_t HGHWMultiBlend::GetProgram(HGHWMultiBlend *this, HGRenderer *a2)
{
  return 0;
}

uint64_t HGHWMultiBlend::RenderTile(HGNode *this, HGTile *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (*((int *)this + 22) >= 2)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *((void *)a2 + 42);
    unsigned int v6 = *(HGRenderer **)(v5 + 152);
    unint64_t v7 = (char *)a2 + 96;
    uint64_t v8 = 1;
    do
    {
      if (*(float *)(*((void *)this + 71) + v4 + 52) != 0.0)
      {
        Input = HGRenderer::GetInput(v6, this, v8);
        uint64_t DOD = HGRenderer::GetDOD(v6, Input);
        uint64_t v12 = HGRectIntersection(DOD, v11, *(void *)a2, *((void *)a2 + 1));
        if (!HGRectIsNull(v12, v13))
        {
          int isObjectRef = OZChannelBase::isObjectRef((OZChannelBase *)this);
          uint64_t v16 = *((void *)this + 71);
          uint64_t v17 = v16 + v4;
          unsigned int v18 = *(_DWORD *)(v16 + v4 + 48) & 0xFFFFFFFE;
          v19.i32[0] = *(_DWORD *)(v16 + v4 + 52);
          if (isObjectRef)
          {
            if (v18 == 36)
            {
              signed int v20 = (float *)(v16 + v4);
              *(float *)v24.i32 = *(float *)v19.i32 * v20[16];
              v23.i32[0] = v24.i32[0];
              *(float *)&v24.i32[1] = *(float *)(v17 + 52) * v20[17];
              v23.i32[1] = v24.i32[1];
              *(float *)&v24.i32[2] = *(float *)(v17 + 52) * v20[18];
              v23.i32[2] = v24.i32[2];
              v24.i32[3] = *(_DWORD *)(v17 + 52);
              v23.i32[3] = v24.i32[3];
            }
            else
            {
              int32x4_t v19 = vdupq_lane_s32(*(int32x2_t *)v19.i8, 0);
              int32x4_t v23 = v19;
              int32x4_t v24 = v19;
            }
            v19.i32[0] = *((_DWORD *)this + 105);
            *(float *)v15.i32 = 1.0 / *(float *)v19.i32;
            int32x4_t v25 = vdupq_lane_s32(v15, 0);
            int32x4_t v26 = v25;
            int32x4_t v27 = vdupq_lane_s32(*(int32x2_t *)v19.i8, 0);
            int32x4_t v28 = v27;
          }
          else
          {
            if (v18 == 36)
            {
              int v21 = (float *)(v16 + v4);
              *(float *)v23.i32 = *(float *)v19.i32 * v21[16];
              *(float *)&v23.i32[1] = *(float *)(v17 + 52) * v21[17];
              *(float *)&v23.i32[2] = *(float *)(v17 + 52) * v21[18];
              v23.i32[3] = *(_DWORD *)(v17 + 52);
            }
            else
            {
              int32x4_t v19 = vdupq_lane_s32(*(int32x2_t *)v19.i8, 0);
              int32x4_t v23 = v19;
            }
            v19.i32[0] = *((_DWORD *)this + 105);
            *(float *)v15.i32 = 1.0 / *(float *)v19.i32;
            int32x4_t v24 = vdupq_lane_s32(v15, 0);
            int32x4_t v25 = vdupq_lane_s32(*(int32x2_t *)v19.i8, 0);
          }
          HGRenderer::RenderInput((uint64_t)v6, v5, (uint64_t)this, v8, (uint64_t)v7, *(void *)a2, *((void *)a2 + 1), 1);
          HGHWBlendFlipped::RenderTile((float32x2_t *)this, a2, *(_DWORD *)(*((void *)this + 71) + v4 + 48), (float *)v23.i32);
        }
      }
      ++v8;
      v4 += 48;
    }
    while (v8 < *((int *)this + 22));
  }
  return 0;
}

uint64_t HGHWMultiBlend::PageBegin(HGNode *this, HGPage *a2, int a3, HGHandler *a4)
{
  return HGNode::PageBegin(this, a2, 0, 0);
}

char *HGHWMultiBlend::RenderPage(HGHWMultiBlend *this, HGPage *a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (const char *)(*(uint64_t (**)(HGHWMultiBlend *))(*(void *)this + 48))(this);
  double v59 = (uint64_t *)((char *)a2 + 24);
  BOOL v60 = (uint64_t *)((char *)a2 + 16);
  snprintf(__str, 0x100uLL, "%s::RenderPage( [%d %d %d %d])", v4, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v63, "gpu", 1, __str);
  uint64_t v5 = *(HGRenderer **)a2;
  Buffer = (char *)*((void *)a2 + 1);
  unint64_t v7 = (unsigned int *)(Buffer + 16);
  if (!Buffer) {
    unint64_t v7 = (unsigned int *)((char *)a2 + 32);
  }
  unsigned int v52 = *v7;
  Input = HGRenderer::GetInput(v5, (HGNode *)this, *((_DWORD *)this + 107));
  if (Buffer)
  {
    (*(void (**)(char *))(*(void *)Buffer + 16))(Buffer);
  }
  else
  {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v5, *((HGRect *)a2 + 1), v52, 0, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
    *((void *)a2 + 1) = Buffer;
  }
  *(void *)&v71.var0 = *v60;
  *(void *)&v71.int var2 = *v59;
  NodeBitmap = HGGPURenderer::GetNodeBitmap(v5, Input, v71, (HGBuffer *)Buffer, 1u);
  uint64_t v10 = (char *)NodeBitmap;
  if (NodeBitmap && NodeBitmap == (HGBitmap *)Buffer) {
    HGRenderer::DotLogInplaceRendering(v5, Input);
  }
  int v11 = *((_DWORD *)this + 22);
  if (v11 < 2)
  {
    uint64_t v47 = 0;
    if (!Buffer)
    {
LABEL_82:
      if (v47) {
        goto LABEL_83;
      }
      goto LABEL_84;
    }
LABEL_81:
    (*(void (**)(char *))(*(void *)Buffer + 24))(Buffer);
    goto LABEL_82;
  }
  int v56 = (HGBitmap *)v10;
  uint64_t v57 = 0;
  uint64_t v12 = 0;
  int v58 = 0;
  int v55 = 0;
  int v50 = *((_DWORD *)this + 106);
  long long v49 = *((_OWORD *)this + 31);
  int v13 = *((_DWORD *)this + 104);
  double v51 = (char *)this + 496;
  double v53 = (void *)((char *)a2 + 168);
  uint64_t v14 = 1;
  uint64_t v10 = Buffer;
  do
  {
    uint64_t v15 = *((void *)this + 71);
    uint64_t v16 = v15 + v12;
    if (*(float *)(v15 + v12 + 52) != 0.0)
    {
      uint64_t v17 = HGRenderer::GetInput(v5, (HGNode *)this, v14);
      uint64_t DOD = HGRenderer::GetDOD(v5, v17);
      uint64_t v20 = HGRectIntersection(DOD, v19, *v60, *v59);
      uint64_t v61 = v21;
      uint64_t v62 = v20;
      if (HGRectIsNull(v20, v21)) {
        goto LABEL_14;
      }
      *((_DWORD *)this + 106) = *(_DWORD *)(v16 + 48);
      *((_DWORD *)this + 104) = *(_DWORD *)(v16 + 52);
      *((_OWORD *)this + 31) = *(_OWORD *)(v15 + v12 + 64);
      if (HGHWBlendFlipped::IsHardwareBlendSupported(this, v5))
      {
        if (!v58 && v56 && v56 != (HGBitmap *)v10)
        {
          *(void *)&v66.var0 = *v60;
          *(void *)&v66.int var2 = *v59;
          uint64_t v57 = HGGPURenderer::ConvertToGLTexture(v5, v66, v56);
        }
        if (!v10)
        {
          uint64_t v10 = HGGPURenderer::CreateBuffer((uint64_t)v5, *((HGRect *)a2 + 1), v52, 0, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
          *((void *)a2 + 1) = v10;
          int v55 = *(_DWORD *)(v15 + v12 + 56);
        }
        (*(void (**)(HGRenderer *, char *))(*(void *)v5 + 144))(v5, v10);
        if (!v58 && v56 != (HGBitmap *)v10)
        {
          (*(void (**)(HGRenderer *, void, uint64_t, void, void))(*(void *)v5 + 152))(v5, 0, v57, 0, 0);
          *(void *)&v67.var0 = *v60;
          *(void *)&v67.int var2 = *v59;
          HGGPURenderer::Copy(v5, v67, 0, v22);
          (*(void (**)(HGRenderer *, void, void, void, void))(*(void *)v5 + 152))(v5, 0, 0, 0, 0);
          if (v56) {
            (*(void (**)(HGBitmap *))(*(void *)v56 + 24))(v56);
          }
          int v56 = 0;
        }
        float v23 = *((float *)this + 104);
        BOOL v24 = v23 != 1.0;
        if (HGNode::DoInplaceHardwareBlending(v17, v5, (HGNode *)this, v23))
        {
          (*(void (**)(HGNode *))(*(void *)v17 + 240))(v17);
          if (*((_DWORD *)this + 119)) {
            uint64_t v25 = 41;
          }
          else {
            uint64_t v25 = *((unsigned int *)this + 106);
          }
          uint64_t v39 = HGBlendingInfo::Get((HGBlendingInfo *)v25);
          (*(void (**)(HGNode *, uint64_t))(*(void *)v17 + 248))(v17, v39);
          (*(void (**)(HGNode *, float))(*(void *)v17 + 280))(v17, *((float *)this + 104));
          (*(void (**)(HGNode *, char *))(*(void *)v17 + 264))(v17, v51);
          *(void *)&v74.int var2 = v61;
          *(void *)&v74.var0 = v62;
          uint64_t v38 = HGGPURenderer::GetNodeBitmap(v5, v17, v74, (HGBuffer *)v10, 1u);
          HGNode::DisableInplaceHardwareBlending(v17);
          HGRenderer::DotLogHWBlending(v5, v17, (HGNode *)this, 1);
          BOOL v24 = 0;
          if (!v38) {
            goto LABEL_11;
          }
        }
        else
        {
          *(void *)&v73.int var2 = v61;
          *(void *)&v73.var0 = v62;
          uint64_t v38 = HGGPURenderer::GetNodeBitmap(v5, v17, v73, 0, 1u);
          if (!v38) {
            goto LABEL_11;
          }
        }
        if (v38 != (HGBitmap *)v10)
        {
          *(void *)&v69.int var2 = v61;
          *(void *)&v69.var0 = v62;
          uint64_t v40 = HGGPURenderer::ConvertToGLTexture(v5, v69, v38);
          (*(void (**)(HGRenderer *, char *))(*(void *)v5 + 144))(v5, v10);
          (*(void (**)(HGRenderer *, void, uint64_t, void, void))(*(void *)v5 + 152))(v5, 0, v40, 0, 0);
          if (v24)
          {
            uint64_t v41 = (*(uint64_t (**)(HGHWMultiBlend *, HGRenderer *))(*(void *)this + 600))(this, v5);
            uint64_t v42 = (int32x4_t *)(*(uint64_t (**)(HGRenderer *, uint64_t, HGHWMultiBlend *))(*(void *)v5 + 376))(v5, v41, this);
            *((unsigned char *)this + 481) = 1;
            *(void *)((char *)a2 + 36) = v62;
            *(void *)((char *)a2 + 44) = v61;
            *((void *)a2 + 21) = v40;
            HGNode::PageBegin((HGNode *)this, a2, 0, v42);
            *((unsigned char *)this + 481) = 0;
          }
          else
          {
            uint64_t v42 = 0;
          }
          (*(void (**)(HGHWMultiBlend *))(*(void *)this + 240))(this);
          if (*((_DWORD *)this + 119)) {
            uint64_t v43 = 41;
          }
          else {
            uint64_t v43 = *((unsigned int *)this + 106);
          }
          uint64_t v44 = HGBlendingInfo::Get((HGBlendingInfo *)v43);
          (*(void (**)(HGHWMultiBlend *, uint64_t))(*(void *)this + 248))(this, v44);
          (*(void (**)(HGHWMultiBlend *, char *))(*(void *)this + 264))(this, v51);
          (*(void (**)(HGHWMultiBlend *))(*(void *)this + 344))(this);
          *(void *)&v46.int var2 = v61;
          *(void *)&v46.var0 = v62;
          if (v42)
          {
            HGGPURenderer::Rect(v5, (HGHandler *)v42, v46, 1);
          }
          else
          {
            *(void *)&v70.var0 = v62;
            *(void *)&v70.int var2 = v61;
            HGGPURenderer::Copy(v5, v70, 0, v45);
          }
          (*(void (**)(HGHWMultiBlend *))(*(void *)this + 352))(this);
          HGNode::DisableInplaceHardwareBlending((HGNode *)this);
          if (v42) {
            (*(void (**)(HGHWMultiBlend *, HGPage *, void, int32x4_t *))(*(void *)this + 496))(this, a2, 0, v42);
          }
          (*(void (**)(HGRenderer *, void, void, void, void))(*(void *)v5 + 152))(v5, 0, 0, 0, 0);
          (*(void (**)(uint64_t))(*(void *)v40 + 24))(v40);
          *double v53 = 0;
          *((void *)a2 + 22) = 0;
          HGRenderer::DotLogHWBlending(v5, v17, (HGNode *)this, 0);
          goto LABEL_12;
        }
LABEL_11:
        if (!v38)
        {
LABEL_13:
          ++v58;
LABEL_14:
          int v11 = *((_DWORD *)this + 22);
          goto LABEL_15;
        }
LABEL_12:
        (*(void (**)(HGBitmap *))(*(void *)v38 + 24))(v38);
        goto LABEL_13;
      }
      uint64_t v26 = v15 + v12;
      int v27 = *(_DWORD *)(v15 + v12 + 56);
      if (!v58)
      {
        int32x4_t v28 = (char *)v56;
        if (!v56)
        {
LABEL_37:
          if (v55 != v27 && v58 != 0 || v28 == v10)
          {
            (*(void (**)(HGRenderer *, void))(*(void *)v5 + 144))(v5, 0);
            (*(void (**)(HGRenderer *, char *))(*(void *)v5 + 144))(v5, v10);
            if (v57) {
              (*(void (**)(uint64_t))(*(void *)v57 + 24))(v57);
            }
            uint64_t v57 = (*(uint64_t (**)(HGRenderer *))(*(void *)v5 + 328))(v5);
            (*(void (**)(HGRenderer *, void))(*(void *)v5 + 144))(v5, 0);
            if (v10)
            {
              (*(void (**)(char *))(*(void *)v10 + 24))(v10);
              uint64_t v10 = 0;
            }
          }
          uint64_t Program = HGHWBlendFlipped::GetProgram(this, v5);
          int v54 = v27;
          *(void *)&v72.int var2 = v61;
          *(void *)&v72.var0 = v62;
          Nodeint Texture = HGGPURenderer::GetNodeTexture(v5, v17, v72, 0, 1u);
          int v33 = v55;
          if (!v10)
          {
            uint64_t v10 = HGGPURenderer::CreateBuffer((uint64_t)v5, *((HGRect *)a2 + 1), v52, 0, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
            *((void *)a2 + 1) = v10;
            int v33 = *(_DWORD *)(v26 + 56);
          }
          (*(void (**)(HGRenderer *, char *))(*(void *)v5 + 144))(v5, v10);
          uint64_t v34 = (int32x4_t *)(*(uint64_t (**)(HGRenderer *, uint64_t, HGHWMultiBlend *))(*(void *)v5 + 376))(v5, Program, this);
          (*(void (**)(HGRenderer *, void, uint64_t, void, void))(*(void *)v5 + 152))(v5, 0, v57, 0, 0);
          (*(void (**)(HGRenderer *, uint64_t, unsigned int *, void, void))(*(void *)v5 + 152))(v5, 1, NodeTexture, 0, 0);
          *(_OWORD *)((char *)a2 + 36) = *(_OWORD *)v60;
          *(void *)((char *)a2 + 52) = v62;
          *(void *)((char *)a2 + 60) = v61;
          *((void *)a2 + 21) = v57;
          *((void *)a2 + 22) = NodeTexture;
          HGNode::PageBegin((HGNode *)this, a2, 0, v34);
          double v35 = (uint64_t *)((char *)a2 + 16);
          if (v55 == v54) {
            double v35 = &v62;
          }
          *(void *)&v36.var0 = *v35;
          int v37 = (uint64_t *)((char *)a2 + 24);
          if (v55 == v54) {
            int v37 = &v61;
          }
          *(void *)&v36.int var2 = *v37;
          HGGPURenderer::Rect(v5, (HGHandler *)v34, v36, 2);
          (*(void (**)(HGHWMultiBlend *, HGPage *, void, int32x4_t *))(*(void *)this + 496))(this, a2, 0, v34);
          (*(void (**)(HGRenderer *, void, void, void, void))(*(void *)v5 + 152))(v5, 0, 0, 0, 0);
          (*(void (**)(HGRenderer *, uint64_t, void, void, void))(*(void *)v5 + 152))(v5, 1, 0, 0, 0);
          (*(void (**)(unsigned int *))(*(void *)NodeTexture + 24))(NodeTexture);
          *double v53 = 0;
          *((void *)a2 + 22) = 0;
          int v55 = v33;
          goto LABEL_13;
        }
        *(void *)&v68.var0 = *v60;
        *(void *)&v68.int var2 = *v59;
        uint64_t v57 = HGGPURenderer::ConvertToGLTexture(v5, v68, v56);
      }
      int32x4_t v28 = (char *)v56;
      goto LABEL_37;
    }
LABEL_15:
    ++v14;
    v12 += 48;
  }
  while (v14 < v11);
  *((_DWORD *)this + 106) = v50;
  *((_DWORD *)this + 104) = v13;
  *((_OWORD *)this + 31) = v49;
  if (!v58)
  {
    Buffer = v10;
    uint64_t v10 = (char *)v56;
    uint64_t v47 = v57;
    if (!Buffer) {
      goto LABEL_82;
    }
    goto LABEL_81;
  }
  uint64_t v47 = v57;
  if (v56) {
    (*(void (**)(HGBitmap *))(*(void *)v56 + 24))(v56);
  }
  if (v57) {
LABEL_83:
  }
    (*(void (**)(uint64_t))(*(void *)v47 + 24))(v47);
LABEL_84:
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v63);
  return v10;
}

void sub_1B7820DE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820DFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820E60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820E74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820E9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820EB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1B7820EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void *HGHWMultiBlend::RenderPageMetal(HGHWMultiBlend *this, HGRect *a2)
{
  uint64_t v201 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (const char *)(*(uint64_t (**)(HGHWMultiBlend *))(*(void *)this + 48))(this);
  p_unsigned int var0 = (uint64_t *)&a2[1].var0;
  p_int var2 = (uint64_t *)&a2[1].var2;
  snprintf(__str, 0x100uLL, "%s::RenderPageMetal( [%d %d %d %d])", v4, a2[1].var0, a2[1].var1, a2[1].var2, a2[1].var3);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v198, "gpu", 1, __str);
  uint64_t v5 = *(HGRenderer **)&a2->var0;
  Buffer = *(char **)&a2->var2;
  unint64_t v7 = (HGRect *)(Buffer + 16);
  if (!Buffer) {
    unint64_t v7 = a2 + 2;
  }
  unsigned int var0 = v7->var0;
  Input = HGRenderer::GetInput(v5, (HGNode *)this, *((_DWORD *)this + 107));
  uint64_t v185 = v5;
  int v9 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)v5 + 128))(v5, 46);
  if (!Buffer || (Buffer[12] & 1) != 0) {
    Buffer = HGGPURenderer::CreateBuffer((uint64_t)v5, a2[1], var0, 1, 0, LOBYTE(a2[15].var2));
  }
  else {
    (*(void (**)(char *))(*(void *)Buffer + 16))(Buffer);
  }
  uint64_t v10 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v5, (HGBitmap *)Buffer);
  int v186 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGBuffer::HGBuffer((HGBuffer *)v186, *(HGRect *)(Buffer + 20), v10);
  (*(void (**)(HGBitmap *))(*(void *)v10 + 24))(v10);
  unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
  if (v13) {
    HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"RENDER INPUT : GetNodeBitmap(0)\n", v11, v12);
  }
  *(void *)&v206.unsigned int var0 = *p_var0;
  *(void *)&v206.int var2 = *p_var2;
  NodeBitmap = HGGPURenderer::GetNodeBitmap(v5, Input, v206, (HGBuffer *)v186, 1u);
  uint64_t v15 = NodeBitmap;
  if (NodeBitmap && NodeBitmap == v186) {
    HGRenderer::DotLogInplaceRendering(v185, Input);
  }
  uint64_t v182 = v15;
  uint64_t v183 = Buffer;
  int v173 = *((_DWORD *)this + 106);
  long long v174 = *((_OWORD *)this + 31);
  int v16 = *((_DWORD *)this + 104);
  *(_OWORD *)float v195 = 0u;
  *(_OWORD *)__p = 0u;
  int v197 = 1065353216;
  int v17 = *((_DWORD *)this + 22);
  long long v190 = (HGNode *)this;
  if (v17 >= 2)
  {
    int v170 = v9;
    v180 = 0;
    int v184 = 0;
    int v181 = 0;
    v177 = &a2[10].var2;
    uint64_t v178 = (HGPage *)a2;
    p_uint64_t var1 = &a2[2].var1;
    v172 = (char *)this + 496;
    unint64_t v18 = 1;
    uint64_t v19 = v185;
    while (1)
    {
      uint64_t v188 = *((void *)v190 + 71);
      uint64_t v20 = v188 + 48 * v18;
      float v22 = *(float *)(v20 + 4);
      uint64_t v21 = (_DWORD *)(v20 + 4);
      if (v22 != 0.0)
      {
        float v23 = HGRenderer::GetInput(v19, v190, v18);
        uint64_t DOD = HGRenderer::GetDOD(v19, v23);
        uint64_t v26 = HGRectIntersection(DOD, v25, *p_var0, *p_var2);
        uint64_t v193 = v27;
        uint64_t v194 = v26;
        if (!HGRectIsNull(v26, v27))
        {
          v179 = (_DWORD *)(v188 + 48 * v18);
          if (!v195[1]) {
            goto LABEL_35;
          }
          uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v195[1]);
          v30.i16[0] = vaddlv_u8(v30);
          if (v30.u32[0] > 1uLL)
          {
            unint64_t v31 = v18;
            if (v195[1] <= (void *)v18) {
              unint64_t v31 = v18 % (unint64_t)v195[1];
            }
          }
          else
          {
            unint64_t v31 = ((unint64_t)v195[1] + 0x7FFFFFFF) & v18;
          }
          int v32 = (uint64_t **)*((void *)v195[0] + v31);
          if (!v32)
          {
LABEL_35:
            int v33 = 0;
            unsigned __int8 v35 = atomic_load(HGLogger::_enabled);
            if (v35) {
              goto LABEL_43;
            }
            goto LABEL_46;
          }
          int v33 = *v32;
          if (!*v32) {
            goto LABEL_42;
          }
          if (v30.u32[0] >= 2uLL)
          {
            while (1)
            {
              unint64_t v34 = v33[1];
              if (v34 == v18)
              {
                if (v18 == *((_DWORD *)v33 + 4)) {
                  goto LABEL_42;
                }
              }
              else
              {
                if ((void *)v34 >= v195[1]) {
                  v34 %= (unint64_t)v195[1];
                }
                if (v34 != v31) {
                  goto LABEL_35;
                }
              }
              int v33 = (uint64_t *)*v33;
              if (!v33) {
                goto LABEL_42;
              }
            }
          }
          while (2)
          {
            uint64_t v36 = v33[1];
            if (v36 == v18)
            {
              if (v18 == *((_DWORD *)v33 + 4)) {
                goto LABEL_42;
              }
            }
            else if ((v36 & ((uint64_t)v195[1] - 1)) != v31)
            {
              int v33 = 0;
LABEL_42:
              unsigned __int8 v37 = atomic_load(HGLogger::_enabled);
              if (v37)
              {
LABEL_43:
                uint64_t v38 = "NO";
                if (v33) {
                  uint64_t v38 = "YES";
                }
                HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"layer #%d -- input already rendered ? %s\n", v28, v29, v18, v38);
              }
LABEL_46:
              if (!v33)
              {
                HGTraceGuard::HGTraceGuard((HGTraceGuard *)&v191, "multiblend", 1, "PreRenderInputs");
                v175 = v23;
                if (__p[1])
                {
                  uint64_t v41 = __p[0];
                  if (__p[0])
                  {
                    do
                    {
                      uint64_t v82 = (void *)*v41;
                      uint64_t v83 = v41[3];
                      if (v83) {
                        (*(void (**)(uint64_t))(*(void *)v83 + 24))(v83);
                      }
                      operator delete(v41);
                      uint64_t v41 = v82;
                    }
                    while (v82);
                  }
                  __p[0] = 0;
                  uint64_t v42 = (char *)v195[1];
                  if (v195[1])
                  {
                    uint64_t v43 = 0;
                    do
                      *((void *)v195[0] + (void)v43++) = 0;
                    while (v42 != v43);
                  }
                  __p[1] = 0;
                }
                unsigned int v192 = v18;
                uint64_t v44 = v190;
                if ((uint64_t)v18 < *((int *)v190 + 22))
                {
                  int v45 = 0;
                  signed int v46 = v18;
                  do
                  {
                    uint64_t v47 = *((void *)v44 + 71);
                    uint64_t v48 = v47 + 48 * v46;
                    char v50 = *(unsigned char *)(v48 + 32);
                    long long v49 = (unsigned int *)(v48 + 32);
                    if ((v50 & 1) == 0)
                    {
                      unsigned __int8 v51 = atomic_load(HGLogger::_enabled);
                      if (v51) {
                        HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"layer #%d -- null layer\n", v39, v40, v192);
                      }
                      goto LABEL_55;
                    }
                    signed int v52 = v46;
                    double v53 = HGRenderer::GetInput(v185, v44, v46);
                    uint64_t v54 = HGRenderer::GetDOD(v185, v53);
                    uint64_t v56 = HGRectIntersection(v54, v55, *p_var0, *p_var2);
                    uint64_t v58 = v57;
                    if (HGRectIsNull(v56, v57))
                    {
                      unsigned __int8 v59 = atomic_load(HGLogger::_enabled);
                      if (v59) {
                        HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"layer #%d -- null ROI\n", v39, v40, v192);
                      }
                      goto LABEL_55;
                    }
                    uint64_t v60 = v192;
                    unsigned int v61 = *v49;
                    int v62 = *(_DWORD *)(v47 + 48 * v52 + 8);
                    if (v18 == v192 && (v61 & 8) != 0)
                    {
                      int v63 = 1;
                      unsigned __int8 v64 = atomic_load(HGLogger::_enabled);
                      if (v64) {
                        goto LABEL_73;
                      }
                    }
                    else
                    {
                      if (v62) {
                        BOOL v65 = v62 == v45;
                      }
                      else {
                        BOOL v65 = 0;
                      }
                      int v63 = v65;
                      unsigned __int8 v66 = atomic_load(HGLogger::_enabled);
                      if (v66)
                      {
LABEL_73:
                        HGRect v67 = "N";
                        if (v18 == v192) {
                          HGRect v68 = "Y";
                        }
                        else {
                          HGRect v68 = "N";
                        }
                        if ((v61 & 2) != 0) {
                          HGRect v69 = "Y";
                        }
                        else {
                          HGRect v69 = "N";
                        }
                        if (v63) {
                          HGRect v70 = "Y";
                        }
                        else {
                          HGRect v70 = "N";
                        }
                        if ((v61 & 4) != 0) {
                          HGRect v67 = "Y";
                        }
                        HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"next layer #%d -- newGroup(%s), hardware(%s), sharedPass(%s), inplace(%s)\n", v39, v40, v192, v68, v69, v70, v67);
                      }
                    }
                    int v71 = (v61 >> 1) & 1;
                    if (v18 == v60) {
                      int v71 = 1;
                    }
                    int v72 = v71 | v63;
                    unsigned __int8 v73 = atomic_load(HGLogger::_enabled);
                    if (v72 != 1 || (v61 & 4) != 0)
                    {
                      if (v73) {
                        HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"  break. done rendering inputs (total = %lu).\n", v39, v40, __p[1]);
                      }
                      break;
                    }
                    if (v73) {
                      HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"  RENDER INPUT : GetNodeBitmap(%d)\n", v39, v40, v192);
                    }
                    *(void *)&v207.unsigned int var0 = v56;
                    *(void *)&v207.int var2 = v58;
                    uint64_t v75 = HGGPURenderer::GetNodeBitmap(v185, v53, v207, 0, 1u);
                    *(void *)&v202.unsigned int var0 = v56;
                    *(void *)&v202.int var2 = v58;
                    uint64_t v78 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v185, v202, v75);
                    unsigned __int8 v79 = atomic_load(HGLogger::_enabled);
                    if (v79) {
                      HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"    result bitmap : %p [%d %d %d %d]\n", v76, v77, v75, *((unsigned int *)v75 + 5), *((unsigned int *)v75 + 6), *((unsigned int *)v75 + 7), *((unsigned int *)v75 + 8));
                    }
                    if (v78) {
                      (*(void (**)(HGBitmap *))(*(void *)v78 + 16))(v78);
                    }
                    long long v199 = &v192;
                    int v80 = std::__hash_table<std::__hash_value_type<int,HGRef<HGBitmap>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HGRef<HGBitmap>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HGRef<HGBitmap>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HGRef<HGBitmap>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v195, (int *)&v192, (uint64_t)&std::piecewise_construct, &v199);
                    uint64_t v81 = (HGBitmap *)v80[3];
                    if (v81 == v78)
                    {
                      if (v78) {
                        (*(void (**)(HGBitmap *))(*(void *)v78 + 24))(v78);
                      }
                    }
                    else
                    {
                      if (v81) {
                        (*(void (**)(HGBitmap *))(*(void *)v81 + 24))(v81);
                      }
                      v80[3] = v78;
                    }
                    (*(void (**)(HGBitmap *))(*(void *)v78 + 24))(v78);
                    (*(void (**)(HGBitmap *))(*(void *)v75 + 24))(v75);
                    int v45 = v62;
LABEL_55:
                    signed int v46 = v192 + 1;
                    unsigned int v192 = v46;
                    uint64_t v44 = v190;
                  }
                  while (v46 < *((_DWORD *)v190 + 22));
                }
                HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&v191);
                uint64_t v19 = v185;
                float v23 = v175;
              }
              *((_DWORD *)v190 + 106) = *v179;
              *((_DWORD *)v190 + 104) = *v21;
              uint64_t v84 = (__n128 *)(v188 + 48 * v18);
              __n128 v86 = v84[1];
              uint64_t v85 = v84 + 1;
              *((__n128 *)v190 + 31) = v86;
              char IsHardwareBlendSupported = HGHWBlendFlipped::IsHardwareBlendSupported((HGHWBlendFlipped *)v190, v19);
              uint64_t v90 = v188 + 48 * v18;
              v86.n128_u32[0] = *(_DWORD *)(v90 + 8);
              __n128 v92 = (int *)(v90 + 8);
              unsigned __int32 v91 = v86.n128_u32[0];
              if (IsHardwareBlendSupported)
              {
                unsigned __int8 v93 = atomic_load(HGLogger::_enabled);
                if (v93)
                {
                  long long v94 = "NO";
                  if (v181 == v91) {
                    long long v94 = "YES";
                  }
                  HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"  RENDER LAYER %d -- hw blending (same pass = %s)\n", v88, v89, v18, v94);
                }
                if (v184)
                {
LABEL_120:
                  char v95 = v186;
                }
                else
                {
                  char v95 = v186;
                  if (v182 && v182 != v186)
                  {
                    v180 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v19, v182);
                    goto LABEL_120;
                  }
                }
                if (v183)
                {
                  int v96 = v181;
                  int v186 = v95;
                  if (v184) {
                    goto LABEL_156;
                  }
LABEL_152:
                  if (v182 != v95)
                  {
                    *(void *)&v208.unsigned int var0 = *p_var0;
                    *(void *)&v208.int var2 = *p_var2;
                    HGGPURenderer::CopyMetal(v19, v95, v208, v180);
                    if (v182) {
                      (*(void (**)(HGBitmap *))(*(void *)v182 + 24))(v182);
                    }
                    uint64_t v182 = 0;
                  }
                }
                else
                {
                  uint64_t v183 = HGGPURenderer::CreateBuffer((uint64_t)v19, *((HGRect *)v178 + 1), var0, 1, 0, *((unsigned __int8 *)v178 + 248));
                  if (v186) {
                    (*(void (**)(HGBitmap *))(*(void *)v186 + 24))(v186);
                  }
                  char v102 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v19, (HGBitmap *)v183);
                  unint64_t v103 = (HGBuffer *)HGObject::operator new(0x80uLL);
                  HGBuffer::HGBuffer(v103, *(HGRect *)(v183 + 20), v102);
                  (*(void (**)(HGBitmap *))(*(void *)v102 + 24))(v102);
                  int v96 = *v92;
                  char v95 = (HGBitmap *)v103;
                  int v186 = (HGBitmap *)v103;
                  if (!v184) {
                    goto LABEL_152;
                  }
                }
LABEL_156:
                float v104 = *((float *)v190 + 104);
                BOOL v105 = v104 != 1.0;
                if (HGNode::DoInplaceHardwareBlending(v23, v19, v190, v104))
                {
                  unsigned __int8 v108 = atomic_load(HGLogger::_enabled);
                  if (v108) {
                    HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"  great! using in-place input rendering as well!\n", v106, v107);
                  }
                  (*(void (**)(HGNode *))(*(void *)v23 + 240))(v23);
                  uint64_t v109 = HGBlendingInfo::Get((HGBlendingInfo *)*v179);
                  (*(void (**)(HGNode *, uint64_t))(*(void *)v23 + 248))(v23, v109);
                  (*(void (**)(HGNode *, float))(*(void *)v23 + 280))(v23, *((float *)v190 + 104));
                  (*(void (**)(HGNode *, char *))(*(void *)v23 + 264))(v23, v172);
                  *(void *)&v209.int var2 = v193;
                  *(void *)&v209.unsigned int var0 = v194;
                  float32x4_t v110 = HGGPURenderer::GetNodeBitmap(v19, v23, v209, (HGBuffer *)v186, 1u);
                  HGNode::DisableInplaceHardwareBlending(v23);
                  HGRenderer::DotLogHWBlending(v19, v23, v190, 1);
                  BOOL v105 = 0;
                  if (v110) {
                    BOOL v111 = v110 == v186;
                  }
                  else {
                    BOOL v111 = 1;
                  }
                  if (v111) {
                    goto LABEL_164;
                  }
LABEL_234:
                  *(void *)&v204.int var2 = v193;
                  *(void *)&v204.unsigned int var0 = v194;
                  unint64_t v147 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v19, v204, v110);
                  if (v105)
                  {
                    uint64_t v148 = (*(uint64_t (**)(HGNode *, HGRenderer *))(*(void *)v190 + 608))(v190, v19);
                    if (v148
                      && (v149 = (const void *)(*(uint64_t (**)(void, uint64_t, HGNode *))(**(void **)v178 + 376))(*(void *)v178, v148, v190)) != 0)
                    {
                      if (v152)
                      {
                        unsigned __int8 v153 = atomic_load(HGLogger::_enabled);
                        if (v153) {
                          HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"  hw blend render pass -- with opacity\n", v150, v151);
                        }
                        *((unsigned char *)&v191.__r_.__value_.__s + 23) = 13;
                        strcpy((char *)&v191, "mblendInplace");
                        HGMetalHandler::SetDebugLabel(v152, &v191);
                        if (SHIBYTE(v191.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v191.__r_.__value_.__l.__data_);
                        }
                        HGMetalHandler::EnableBlending((uint64_t)v152);
                        uint64_t v154 = (const HGBlendingInfo *)HGBlendingInfo::Get((HGBlendingInfo *)*v179);
                        HGMetalHandler::SetBlendingInfo((HGMetalHandler *)v152, v154);
                        HGMetalHandler::SetBlendingColor((__n128 *)v152, v85);
                        (*(void (**)(std::string *, void, float, float, float, float))(v152->__r_.__value_.__r.__words[0]
                                                                                                  + 136))(v152, 0, *((float *)v190 + 104), *((float *)v190 + 104), *((float *)v190 + 104), *((float *)v190 + 104));
                        HGMetalHandler::BindBuffer((HGMetalHandler *)v152, v186);
                        HGMetalHandler::BindTexture((HGMetalTexture ***)v152, 0, v147);
                        uint64_t v155 = v193;
                        uint64_t v156 = v194;
                        *(void *)&v205.unsigned int var0 = v194;
                        *(void *)&v205.int var2 = v193;
                        HGMetalHandler::InitTextureUnit((HGMetalHandler *)v152, v205, 0);
                        (*(void (**)(std::string *, void, void))(v152->__r_.__value_.__r.__words[0] + 72))(v152, 0, 0);
                        (*(void (**)(std::string *, void, void))(v152->__r_.__value_.__r.__words[0] + 48))(v152, 0, 0);
                        HGHandler::TexCoord((HGHandler *)v152, 0, 0, 0, 0);
                        if (!v170) {
                          (*(void (**)(std::string *))(v152->__r_.__value_.__r.__words[0] + 168))(v152);
                        }
                        (*(void (**)(std::string *))(v152->__r_.__value_.__r.__words[0] + 40))(v152);
                        (*(void (**)(std::string *, uint64_t, uint64_t, uint64_t))(v152->__r_.__value_.__r.__words[0]
                                                                                         + 192))(v152, v156, v155, 1);
                      }
                    }
                    else
                    {
                      long long v152 = 0;
                    }
                    (*(void (**)(HGNode *, HGPage *, void, std::string *))(*(void *)v190 + 496))(v190, v178, 0, v152);
                    (*(void (**)(HGBitmap *))(*(void *)v147 + 24))(v147);
                  }
                  else
                  {
                    unsigned __int8 v157 = atomic_load(HGLogger::_enabled);
                    if (v157) {
                      HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"  hw blend render pass -- no opacity\n", v145, v146);
                    }
                    uint64_t v159 = v193;
                    uint64_t v158 = v194;
                    long long v160 = (const HGBlendingInfo *)HGBlendingInfo::Get((HGBlendingInfo *)*v179);
                    *(void *)&v212.unsigned int var0 = v158;
                    *(void *)&v212.int var2 = v159;
                    HGGPURenderer::CopyMetal(v19, v186, v212, (char *)v147, v160, v85, 1);
                    (*(void (**)(HGBitmap *))(*(void *)v147 + 24))(v147);
                  }
                  void *v177 = 0;
                  v177[1] = 0;
                  HGRenderer::DotLogHWBlending(v19, v23, v190, 0);
                  goto LABEL_251;
                }
                if (!v195[1]) {
                  goto LABEL_230;
                }
                uint8x8_t v112 = (uint8x8_t)vcnt_s8((int8x8_t)v195[1]);
                v112.i16[0] = vaddlv_u8(v112);
                if (v112.u32[0] > 1uLL)
                {
                  unint64_t v113 = v18;
                  if (v195[1] <= (void *)v18) {
                    unint64_t v113 = v18 % (unint64_t)v195[1];
                  }
                }
                else
                {
                  unint64_t v113 = ((unint64_t)v195[1] + 0x7FFFFFFF) & v18;
                }
                v139 = (uint64_t **)*((void *)v195[0] + v113);
                if (!v139 || (v140 = *v139) == 0)
                {
LABEL_230:
                  *(void *)&v211.int var2 = v193;
                  *(void *)&v211.unsigned int var0 = v194;
                  v143 = HGGPURenderer::GetNodeBitmap(v19, v23, v211, 0, 1u);
                  float32x4_t v110 = v143;
                  if (v143) {
                    BOOL v144 = v143 == v186;
                  }
                  else {
                    BOOL v144 = 1;
                  }
                  if (!v144) {
                    goto LABEL_234;
                  }
                  goto LABEL_164;
                }
                if (v112.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v142 = v140[1];
                    if (v142 == v18)
                    {
                      if (v18 == *((_DWORD *)v140 + 4)) {
                        goto LABEL_254;
                      }
                    }
                    else if ((v142 & ((uint64_t)v195[1] - 1)) != v113)
                    {
                      goto LABEL_230;
                    }
                    v140 = (uint64_t *)*v140;
                    if (!v140) {
                      goto LABEL_230;
                    }
                  }
                }
                while (1)
                {
                  unint64_t v141 = v140[1];
                  if (v141 == v18)
                  {
                    if (v18 == *((_DWORD *)v140 + 4))
                    {
LABEL_254:
                      uint64_t v162 = v140[3];
                      if (!v162) {
                        goto LABEL_15;
                      }
                      (*(void (**)(uint64_t))(*(void *)v162 + 16))(v162);
                      float32x4_t v110 = (HGBitmap *)v140[3];
                      if (v110) {
                        BOOL v163 = v110 == v186;
                      }
                      else {
                        BOOL v163 = 1;
                      }
                      if (!v163) {
                        goto LABEL_234;
                      }
LABEL_164:
                      if (!v110)
                      {
LABEL_15:
                        ++v184;
                        int v181 = v96;
                        goto LABEL_16;
                      }
LABEL_251:
                      (*(void (**)(HGBitmap *))(*(void *)v110 + 24))(v110);
                      goto LABEL_15;
                    }
                  }
                  else
                  {
                    if ((void *)v141 >= v195[1]) {
                      v141 %= (unint64_t)v195[1];
                    }
                    if (v141 != v113) {
                      goto LABEL_230;
                    }
                  }
                  v140 = (uint64_t *)*v140;
                  if (!v140) {
                    goto LABEL_230;
                  }
                }
              }
              unsigned __int8 v97 = atomic_load(HGLogger::_enabled);
              if (v97)
              {
                uint64_t v98 = "NO";
                if (v181 == v91) {
                  uint64_t v98 = "YES";
                }
                HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"BLEND LAYER %d -- shader blending (same pass = %s)\n", v88, v89, v18, v98);
              }
              if (v184 || !v182)
              {
                if (v181 != v91 && v184 != 0 || v182 == v186)
                {
                  if (v180) {
                    (*(void (**)(HGBitmap *, HGBitmap *))(*(void *)v180 + 24))(v180, v182);
                  }
                  v180 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v19, v186);
                  if (v186) {
                    (*(void (**)(HGBitmap *))(*(void *)v186 + 24))(v186);
                  }
                  uint64_t v99 = v183;
                  if (v183) {
LABEL_147:
                  }
                    (*(void (**)(char *))(*(void *)v183 + 24))(v99);
LABEL_148:
                  int v186 = 0;
                  uint64_t v183 = 0;
                }
              }
              else
              {
                v180 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v19, v182);
                if (v186)
                {
                  if (v186 == v182)
                  {
                    (*(void (**)(HGBitmap *))(*(void *)v186 + 24))(v186);
                    uint64_t v99 = v183;
                    if (v183) {
                      goto LABEL_147;
                    }
                    goto LABEL_148;
                  }
                }
                else
                {
                  int v186 = 0;
                }
              }
              uint64_t v114 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)v19 + 128))(v19, 32);
              (*(void (**)(HGRenderer *, uint64_t, uint64_t))(*(void *)v19 + 120))(v19, 32, 396048);
              uint64_t Program = HGHWBlendFlipped::GetProgram((HGHWBlendFlipped *)v190, v19);
              (*(void (**)(HGRenderer *, uint64_t, uint64_t))(*(void *)v19 + 120))(v19, 32, v114);
              if (!v195[1]) {
                goto LABEL_190;
              }
              uint8x8_t v116 = (uint8x8_t)vcnt_s8((int8x8_t)v195[1]);
              v116.i16[0] = vaddlv_u8(v116);
              if (v116.u32[0] > 1uLL)
              {
                unint64_t v117 = v18;
                if (v195[1] <= (void *)v18) {
                  unint64_t v117 = v18 % (unint64_t)v195[1];
                }
              }
              else
              {
                unint64_t v117 = ((unint64_t)v195[1] + 0x7FFFFFFF) & v18;
              }
              unsigned int v118 = (uint64_t **)*((void *)v195[0] + v117);
              if (!v118 || (float v119 = *v118) == 0)
              {
LABEL_190:
                uint64_t v123 = v193;
                uint64_t v122 = v194;
                *(void *)&v210.unsigned int var0 = v194;
                *(void *)&v210.int var2 = v193;
                v124 = HGGPURenderer::GetNodeBitmap(v19, v23, v210, 0, 1u);
                goto LABEL_191;
              }
              if (v116.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v121 = v119[1];
                  if (v121 == v18)
                  {
                    if (v18 == *((_DWORD *)v119 + 4)) {
                      goto LABEL_252;
                    }
                  }
                  else if ((v121 & ((uint64_t)v195[1] - 1)) != v117)
                  {
                    goto LABEL_190;
                  }
                  float v119 = (uint64_t *)*v119;
                  if (!v119) {
                    goto LABEL_190;
                  }
                }
              }
              while (1)
              {
                unint64_t v120 = v119[1];
                if (v120 == v18)
                {
                  if (v18 == *((_DWORD *)v119 + 4))
                  {
LABEL_252:
                    uint64_t v161 = v119[3];
                    if (v161)
                    {
                      (*(void (**)(uint64_t))(*(void *)v161 + 16))(v161);
                      v124 = (HGBitmap *)v119[3];
                    }
                    else
                    {
                      v124 = 0;
                    }
                    uint64_t v123 = v193;
                    uint64_t v122 = v194;
LABEL_191:
                    *(void *)&v203.unsigned int var0 = v122;
                    *(void *)&v203.int var2 = v123;
                    uint64_t v125 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v19, v203, v124);
                    (*(void (**)(HGBitmap *))(*(void *)v124 + 24))(v124);
                    if (v183)
                    {
                      int v96 = v181;
                      if (v180) {
                        goto LABEL_193;
                      }
LABEL_197:
                      unint64_t v126 = 0;
                    }
                    else
                    {
                      uint64_t v183 = HGGPURenderer::CreateBuffer((uint64_t)v19, *((HGRect *)v178 + 1), var0, 1, 0, *((unsigned __int8 *)v178 + 248));
                      if (v186) {
                        (*(void (**)(HGBitmap *))(*(void *)v186 + 24))(v186);
                      }
                      unint64_t v127 = HGGPURenderer::ConvertToMetalTexture((HGMetalTexture **)v19, (HGBitmap *)v183);
                      int v186 = (HGBitmap *)HGObject::operator new(0x80uLL);
                      HGBuffer::HGBuffer((HGBuffer *)v186, *(HGRect *)(v183 + 20), v127);
                      (*(void (**)(HGBitmap *))(*(void *)v127 + 24))(v127);
                      int v96 = *v92;
                      if (!v180) {
                        goto LABEL_197;
                      }
LABEL_193:
                      unint64_t v126 = (HGTexture *)HGObject::operator new(0x80uLL);
                      HGTexture::HGTexture(v126, *(HGRect *)((char *)v180 + 20), v180);
                    }
                    void *v177 = v126;
                    float32x4_t v128 = (HGTexture *)HGObject::operator new(0x80uLL);
                    HGTexture::HGTexture(v128, *(HGRect *)((char *)v125 + 20), v125);
                    *((void *)v178 + 22) = v128;
                    float32x4_t v129 = (const void *)(*(uint64_t (**)(HGRenderer *, uint64_t, HGNode *))(*(void *)v19 + 376))(v19, Program, v190);
                    if (v129)
                    {
                      if (v130)
                      {
                        v133 = v130;
                        unsigned __int8 v134 = atomic_load(HGLogger::_enabled);
                        if (v134) {
                          HGLogger::log((HGLogger *)"multiblend", (const char *)2, (HGLogger *)"  dual inputs blend shader pass\n", v131, v132);
                        }
                        *((unsigned char *)&v191.__r_.__value_.__s + 23) = 13;
                        strcpy((char *)&v191, "mblend2Inputs");
                        HGMetalHandler::SetDebugLabel(v133, &v191);
                        if (SHIBYTE(v191.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v191.__r_.__value_.__l.__data_);
                        }
                        HGMetalHandler::DisableBlending((uint64_t)v133);
                        (*(void (**)(std::string *, void, float, float, float, float))(v133->__r_.__value_.__r.__words[0]
                                                                                                  + 136))(v133, 0, *((float *)v190 + 104), *((float *)v190 + 104), *((float *)v190 + 104), *((float *)v190 + 104));
                        HGMetalHandler::BindBuffer((HGMetalHandler *)v133, v186);
                        HGMetalHandler::BindTexture((HGMetalTexture ***)v133, 0, (HGBitmap *)*v177);
                        HGMetalHandler::BindTexture((HGMetalTexture ***)v133, 1, *((HGBitmap **)v178 + 22));
                        *(_OWORD *)p_uint64_t var1 = *(_OWORD *)p_var0;
                        *(void *)((char *)v178 + 52) = v194;
                        *(void *)((char *)v178 + 60) = v193;
                        HGNode::PageBegin(v190, v178, 0, (int32x4_t *)v133);
                        uint64_t v135 = p_var0;
                        if (v181 == v91) {
                          uint64_t v135 = &v194;
                        }
                        uint64_t v136 = *v135;
                        unint64_t v137 = p_var2;
                        if (v181 == v91) {
                          unint64_t v137 = &v193;
                        }
                        (*(void (**)(std::string *, uint64_t, uint64_t, uint64_t))(v133->__r_.__value_.__r.__words[0]
                                                                                         + 192))(v133, v136, *v137, 2);
                        (*(void (**)(HGNode *, HGPage *, void, std::string *))(*(void *)v190 + 496))(v190, v178, 0, v133);
                      }
                    }
                    (*(void (**)(HGBitmap *))(*(void *)v125 + 24))(v125);
                    if (*v177) {
                      (*(void (**)(void))(*(void *)*v177 + 24))(*v177);
                    }
                    uint64_t v138 = *((void *)v178 + 22);
                    if (v138) {
                      (*(void (**)(uint64_t))(*(void *)v138 + 24))(v138);
                    }
                    void *v177 = 0;
                    v177[1] = 0;
                    goto LABEL_15;
                  }
                }
                else
                {
                  if ((void *)v120 >= v195[1]) {
                    v120 %= (unint64_t)v195[1];
                  }
                  if (v120 != v117) {
                    goto LABEL_190;
                  }
                }
                float v119 = (uint64_t *)*v119;
                if (!v119) {
                  goto LABEL_190;
                }
              }
            }
            int v33 = (uint64_t *)*v33;
            if (!v33) {
              goto LABEL_42;
            }
            continue;
          }
        }
LABEL_16:
        int v17 = *((_DWORD *)v190 + 22);
      }
      if ((uint64_t)++v18 >= v17) {
        goto LABEL_263;
      }
    }
  }
  int v184 = 0;
  v180 = 0;
LABEL_263:
  *((_DWORD *)v190 + 106) = v173;
  *((_DWORD *)v190 + 104) = v16;
  *((_OWORD *)v190 + 31) = v174;
  v164 = v182;
  if (v186) {
    (*(void (**)(HGBitmap *))(*(void *)v186 + 24))(v186);
  }
  if (v184)
  {
    if (v182) {
      (*(void (**)(HGBitmap *))(*(void *)v182 + 24))(v182);
    }
    if (!v180)
    {
      v164 = v183;
      v165 = __p[0];
      if (!__p[0]) {
        goto LABEL_275;
      }
      goto LABEL_281;
    }
    (*(void (**)(HGBitmap *))(*(void *)v180 + 24))(v180);
    v164 = v183;
  }
  else
  {
    if (v183) {
      (*(void (**)(char *))(*(void *)v183 + 24))(v183);
    }
    if (v180) {
      (*(void (**)(HGBitmap *))(*(void *)v180 + 24))(v180);
    }
  }
  v165 = __p[0];
  if (!__p[0]) {
    goto LABEL_275;
  }
  do
  {
LABEL_281:
    std::string::size_type v168 = (void *)*v165;
    uint64_t v169 = v165[3];
    if (v169) {
      (*(void (**)(uint64_t))(*(void *)v169 + 24))(v169);
    }
    operator delete(v165);
    v165 = v168;
  }
  while (v168);
LABEL_275:
  v166 = v195[0];
  v195[0] = 0;
  if (v166) {
    operator delete(v166);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v198);
  return v164;
}

void sub_1B78229B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
}

uint64_t std::unordered_map<int,HGRef<HGBitmap>>::~unordered_map[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v5 = (void *)*v2;
      uint64_t v6 = v2[3];
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  float v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

uint64_t HGHWMultiBlend::PrepareOutputNode(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)(result + 552) = a3;
  *(void *)(result + 560) = a4;
  return result;
}

void HGHWMultiBlend::~HGHWMultiBlend(HGHWMultiBlend *this)
{
  HGHWMultiBlend::~HGHWMultiBlend(this);

  HGObject::operator delete(v1);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t vars8;

  *(void *)this = &unk_1F10DFF98;
  uint64_t v2 = (void *)*((void *)this + 76);
  if (v2)
  {
    do
    {
      float v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 74);
  *((void *)this + 74) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 71);
  if (v5)
  {
    *((void *)this + 72) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *((void *)this + 68);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }

  HGHWBlendFlipped::~HGHWBlendFlipped(this);
}

void std::vector<HGLayerParams>::__append(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)v4) >> 4) >= a2)
  {
    if (a2)
    {
      int v11 = &v4[12 * a2];
      __asm { FMOV            V0.4S, #1.0 }
      do
      {
        *(void *)uint64_t v4 = 0x3F80000000000000;
        v4[2] = 0;
        *((_OWORD *)v4 + 1) = _Q0;
        v4[8] = 0;
        v4 += 12;
      }
      while (v4 != v11);
      uint64_t v4 = v11;
    }
    a1[1] = v4;
  }
  else
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * (((char *)v4 - (unsigned char *)*a1) >> 4);
    unint64_t v7 = v6 + a2;
    if (v6 + a2 > 0x555555555555555) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)*a1) >> 4);
    if (2 * v8 > v7) {
      unint64_t v7 = 2 * v8;
    }
    if (v8 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v9 = 0x555555555555555;
    }
    else {
      unint64_t v9 = v7;
    }
    if (v9)
    {
      if (v9 > 0x555555555555555) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v10 = (char *)operator new(48 * v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
    int v17 = &v10[48 * v6];
    unint64_t v18 = &v17[48 * a2];
    __asm { FMOV            V0.4S, #1.0 }
    uint64_t v20 = v17;
    do
    {
      *(void *)uint64_t v20 = 0x3F80000000000000;
      *((_DWORD *)v20 + 2) = 0;
      *((_OWORD *)v20 + 1) = _Q0;
      *((_DWORD *)v20 + 8) = 0;
      v20 += 48;
    }
    while (v20 != v18);
    uint64_t v21 = &v10[48 * v9];
    float v23 = (char *)*a1;
    float v22 = (char *)a1[1];
    if (v22 != *a1)
    {
      do
      {
        long long v24 = *((_OWORD *)v22 - 3);
        long long v25 = *((_OWORD *)v22 - 2);
        *((_DWORD *)v17 - 4) = *((_DWORD *)v22 - 4);
        *((_OWORD *)v17 - 3) = v24;
        *((_OWORD *)v17 - 2) = v25;
        v17 -= 48;
        v22 -= 48;
      }
      while (v22 != v23);
      float v22 = (char *)*a1;
    }
    *a1 = v17;
    a1[1] = v18;
    a1[2] = v21;
    if (v22)
    {
      operator delete(v22);
    }
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<int,HGRect>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HGRect>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HGRect>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HGRect>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      int v11 = *v10;
      if (*v10)
      {
        if (v9.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v13 = v11[1];
            if (v13 == v7)
            {
              if (*((_DWORD *)v11 + 4) == v7) {
                return v11;
              }
            }
            else if ((v13 & (v8 - 1)) != v4)
            {
              goto LABEL_23;
            }
            int v11 = (uint64_t *)*v11;
            if (!v11) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
            if (v12 != v4) {
              break;
            }
          }
          int v11 = (uint64_t *)*v11;
        }
        while (v11);
      }
    }
  }
LABEL_23:
  uint64_t v15 = operator new(0x28uLL);
  *uint64_t v15 = 0;
  v15[1] = v7;
  *((_DWORD *)v15 + 4) = **a4;
  *(void *)((char *)v15 + 20) = 0;
  *(void *)((char *)v15 + 28) = 0;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (v8 && (float)(v17 * (float)v8) >= v16)
  {
    uint64_t v18 = *(void *)a1;
    uint64_t v19 = *(void **)(*(void *)a1 + 8 * v4);
    if (v19)
    {
LABEL_26:
      *uint64_t v15 = *v19;
LABEL_61:
      *uint64_t v19 = v15;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v20 = 1;
    if (v8 >= 3) {
      BOOL v20 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v8);
    unint64_t v22 = vcvtps_u32_f32(v16 / v17);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v8 = *(void *)(a1 + 8);
    }
    if (prime > v8) {
      goto LABEL_37;
    }
    if (prime < v8)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v8 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (prime <= v24) {
        size_t prime = v24;
      }
      if (prime < v8) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v8 = *(void *)(a1 + 8);
    unint64_t v27 = v8 - 1;
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
      {
        unint64_t v4 = v7 % v8;
        uint64_t v18 = *(void *)a1;
        uint64_t v19 = *(void **)(*(void *)a1 + 8 * (v7 % v8));
        if (v19) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v7;
        uint64_t v18 = *(void *)a1;
        uint64_t v19 = *(void **)(*(void *)a1 + 8 * v7);
        if (v19) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v27 & v7;
      uint64_t v18 = *(void *)a1;
      uint64_t v19 = *(void **)(*(void *)a1 + 8 * (v27 & v7));
      if (v19) {
        goto LABEL_26;
      }
    }
  }
  *uint64_t v15 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v15;
  *(void *)(v18 + 8 * v4) = a1 + 16;
  if (*v15)
  {
    unint64_t v28 = *(void *)(*v15 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v28 >= v8) {
        v28 %= v8;
      }
    }
    else
    {
      v28 &= v8 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v15;
}

void sub_1B78231DC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<int,HGRef<HGBitmap>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HGRef<HGBitmap>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HGRef<HGBitmap>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HGRef<HGBitmap>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      int v11 = *v10;
      if (*v10)
      {
        if (v9.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v13 = v11[1];
            if (v13 == v7)
            {
              if (*((_DWORD *)v11 + 4) == v7) {
                return v11;
              }
            }
            else if ((v13 & (v8 - 1)) != v4)
            {
              goto LABEL_23;
            }
            int v11 = (void *)*v11;
            if (!v11) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
            if (v12 != v4) {
              break;
            }
          }
          int v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
LABEL_23:
  uint64_t v14 = (void *)(a1 + 16);
  int v11 = operator new(0x20uLL);
  *int v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  v11[3] = 0;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (v8 && (float)(v16 * (float)v8) >= v15)
  {
    uint64_t v17 = *(void *)a1;
    uint64_t v18 = *(void **)(*(void *)a1 + 8 * v4);
    if (v18)
    {
LABEL_26:
      *int v11 = *v18;
LABEL_61:
      *uint64_t v18 = v11;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v19 = 1;
    if (v8 >= 3) {
      BOOL v19 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v8);
    unint64_t v21 = vcvtps_u32_f32(v15 / v16);
    if (v20 <= v21) {
      size_t prime = v21;
    }
    else {
      size_t prime = v20;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v8 = *(void *)(a1 + 8);
    }
    if (prime > v8) {
      goto LABEL_37;
    }
    if (prime < v8)
    {
      unint64_t v23 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v8 < 3 || (uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v24.i16[0] = vaddlv_u8(v24), v24.u32[0] > 1uLL))
      {
        unint64_t v23 = std::__next_prime(v23);
      }
      else
      {
        uint64_t v25 = 1 << -(char)__clz(v23 - 1);
        if (v23 >= 2) {
          unint64_t v23 = v25;
        }
      }
      if (prime <= v23) {
        size_t prime = v23;
      }
      if (prime < v8) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v8 = *(void *)(a1 + 8);
    unint64_t v26 = v8 - 1;
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
      {
        unint64_t v4 = v7 % v8;
        uint64_t v17 = *(void *)a1;
        uint64_t v18 = *(void **)(*(void *)a1 + 8 * (v7 % v8));
        if (v18) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v7;
        uint64_t v17 = *(void *)a1;
        uint64_t v18 = *(void **)(*(void *)a1 + 8 * v7);
        if (v18) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v26 & v7;
      uint64_t v17 = *(void *)a1;
      uint64_t v18 = *(void **)(*(void *)a1 + 8 * (v26 & v7));
      if (v18) {
        goto LABEL_26;
      }
    }
  }
  *int v11 = *v14;
  *uint64_t v14 = v11;
  *(void *)(v17 + 8 * v4) = v14;
  if (*v11)
  {
    unint64_t v27 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v27 >= v8) {
        v27 %= v8;
      }
    }
    else
    {
      v27 &= v8 - 1;
    }
    uint64_t v18 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1B7823510(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,HGRef<HGBitmap>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,HGRef<HGBitmap>>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<int,HGRef<HGBitmap>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,HGRef<HGBitmap>>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = v2[3];
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void HGLightWrapBlend::HGLightWrapBlend(HGLightWrapBlend *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v2 = &unk_1F10E0250;
  *(void *)(v2 + 408) = 0x412000003F800000;
  *(_DWORD *)(v2 + 432) = 9;
  uint64_t v3 = (HGLightWrap **)(v2 + 440);
  *(void *)(v2 + 440) = 0;
  *(void *)(v2 + 448) = 0;
  unint64_t v4 = (HGLightWrap *)HGObject::operator new(0x1C0uLL);
  HGLightWrap::HGLightWrap(v4);
  uint64_t v5 = *v3;
  if (*v3 == v4)
  {
    if (v4) {
      (*(void (**)(HGLightWrap *))(*(void *)v4 + 24))(v4);
    }
  }
  else
  {
    if (v5) {
      (*(void (**)(HGLightWrap *))(*(void *)v5 + 24))(v5);
    }
    *uint64_t v3 = v4;
  }
  unint64_t v6 = (HGHWMultiBlend *)HGObject::operator new(0x280uLL);
  HGHWMultiBlend::HGHWMultiBlend(v6);
  unint64_t v7 = (HGHWMultiBlend *)*((void *)this + 56);
  if (v7 == v6)
  {
    if (v6) {
      (*(void (**)(HGHWMultiBlend *))(*(void *)v6 + 24))(v6);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(HGHWMultiBlend *))(*(void *)v7 + 24))(v7);
    }
    *((void *)this + 56) = v6;
  }
}

void sub_1B7823704(_Unwind_Exception *a1)
{
  uint64_t v4 = v2;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v6 = *(void *)(v1 + 448);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  if (*v3) {
    (*(void (**)(void))(*(void *)*v3 + 24))(*v3);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGLightWrapBlend::~HGLightWrapBlend(HGNode *this)
{
  *(void *)this = &unk_1F10E0250;
  uint64_t v2 = *((void *)this + 56);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 55);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10E0250;
  uint64_t v2 = *((void *)this + 56);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 55);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

uint64_t HGLightWrapBlend::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  uint64_t v5 = Input;
  if (Input) {
    (*(void (**)(HGNode *))(*(void *)Input + 16))(Input);
  }
  uint64_t v6 = HGRenderer::GetInput(a2, this, 1u);
  unint64_t v7 = v6;
  if (v6) {
    (*(void (**)(HGNode *))(*(void *)v6 + 16))(v6);
  }
  unint64_t v8 = (HGHWMultiBlend *)HGObject::operator new(0x280uLL);
  HGHWMultiBlend::HGHWMultiBlend(v8);
  (*(void (**)(HGHWMultiBlend *, void, HGNode *))(*(void *)v8 + 120))(v8, 0, v5);
  (*(void (**)(HGHWMultiBlend *, uint64_t, HGNode *, void, float))(*(void *)v8 + 624))(v8, 1, v7, *((unsigned int *)this + 108), *((float *)this + 102));
  uint8x8_t v9 = (HGBlur *)HGObject::operator new(0x220uLL);
  HGBlur::HGBlur(v9);
  (*(void (**)(HGBlur *, void, float, float, double, double))(*(void *)v9 + 96))(v9, 0, *((float *)this + 103), *((float *)this + 103), 0.0, 0.0);
  (*(void (**)(HGBlur *, void, HGNode *))(*(void *)v9 + 120))(v9, 0, v5);
  uint64_t v10 = (HGGamma *)HGObject::operator new(0x1B0uLL);
  HGGamma::HGGamma(v10);
  HGGamma::SetPremultiplyState((uint64_t)v10, 0);
  double v11 = *((float *)this + 104);
  double v12 = 1.0 / v11;
  BOOL v13 = v11 < 0.06;
  double v14 = 16.6666667;
  if (!v13) {
    double v14 = v12;
  }
  float v15 = v14;
  (*(void (**)(HGGamma *, void, float, float, float, float))(*(void *)v10 + 96))(v10, 0, v15, v15, v15, 1.0);
  if (*((float *)this + 105) != 1.0)
  {
    float v16 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
    HGColorMatrix::HGColorMatrix(v16);
  }
  (*(void (**)(HGGamma *, void, HGBlur *))(*(void *)v10 + 120))(v10, 0, v9);
  (*(void (**)(void, uint64_t, HGGamma *))(**((void **)this + 55) + 120))(*((void *)this + 55), 1, v10);
  uint64_t v17 = (HGBlur *)HGObject::operator new(0x220uLL);
  HGBlur::HGBlur(v17);
  (*(void (**)(HGBlur *, void, float, float, float, float))(*(void *)v17 + 96))(v17, 0, *((float *)this + 103), *((float *)this + 103), *((float *)this + 103), *((float *)this + 103));
  (*(void (**)(HGBlur *, void, HGNode *))(*(void *)v17 + 120))(v17, 0, v7);
  (*(void (**)(void, void, HGBlur *))(**((void **)this + 55) + 120))(*((void *)this + 55), 0, v17);
  (*(void (**)(void, uint64_t, HGNode *))(**((void **)this + 55) + 120))(*((void *)this + 55), 2, v7);
  (*(void (**)(void, void, float, float, float, float))(**((void **)this + 55) + 96))(*((void *)this + 55), 0, 1.0, 1.0, 1.0, 1.0);
  (*(void (**)(void, void, HGHWMultiBlend *))(**((void **)this + 56) + 120))(*((void *)this + 56), 0, v8);
  (*(void (**)(void, uint64_t, void, void, float))(**((void **)this + 56) + 624))(*((void *)this + 56), 1, *((void *)this + 55), *((unsigned int *)this + 107), *((float *)this + 106));
  uint64_t v18 = *((void *)this + 56);
  (*(void (**)(HGBlur *))(*(void *)v17 + 24))(v17);
  (*(void (**)(HGGamma *))(*(void *)v10 + 24))(v10);
  (*(void (**)(HGBlur *))(*(void *)v9 + 24))(v9);
  (*(void (**)(HGHWMultiBlend *))(*(void *)v8 + 24))(v8);
  if (v7) {
    (*(void (**)(HGNode *))(*(void *)v7 + 24))(v7);
  }
  if (v5) {
    (*(void (**)(HGNode *))(*(void *)v5 + 24))(v5);
  }
  return v18;
}

void sub_1B7824034(_Unwind_Exception *a1)
{
  HGObject::operator delete(v7);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t HGLightWrapBlend::SetParameter(HGNode *this, int a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 == 1)
  {
    *((float *)this + 102) = a3;
  }
  else if (!a2)
  {
    *((_DWORD *)this + 108) = vcvtms_u32_f32(a3);
  }
  return HGNode::SetParameter(this, a2, a3, a4, a5, a6, a7);
}

uint64_t HGLightWrapBlend::SetLightWrapParams(uint64_t result, int a2, float a3, float a4, float a5, float a6)
{
  *(float *)(result + 412) = a3;
  *(float *)(result + 416) = a4;
  *(float *)(result + 420) = a5;
  *(_DWORD *)(result + 428) = a2;
  *(float *)(result + 424) = a6;
  return result;
}

void HGUserExecUnit::HGUserExecUnit(HGUserExecUnit *this, HGRenderQueue *a2)
{
  *(void *)this = &unk_1F10E04B8;
  *((void *)this + 2) = a2;
  *((_DWORD *)this + 6) = ++HGUserExecUnit::_count;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 2) = 0;
}

void HGUserExecUnit::~HGUserExecUnit(HGUserExecUnit *this)
{
}

HGUserExecUnit *StartUserExecUnitFunc(HGUserExecUnit *a1)
{
  return a1;
}

HGSynchronizable *HGUserExecUnit::RunLoop(HGUserExecUnit *this)
{
  pthread_setname_np("com.apple.helium-render-queue-exec-unit-user");
  while (!HGRenderQueue::IsShuttingDown(*((HGRenderQueue **)this + 2)))
  {
    uint64_t v5 = 0;
    if (HGRenderQueue::GetUserJob(*((HGRenderQueue **)this + 2), this, &v5))
    {
      *((_DWORD *)this + 2) = 2;
      HGUserJob::SetState((uint64_t)v5, 3);
      HGUserJob::CallNotifyFunc(v5);
      uint64_t v4 = *(HGSynchronizable **)(*((void *)this + 2) + 472);
      HGSynchronizable::Lock(v4);
      std::list<HGGPUReadbackJob *>::remove((void *)(*((void *)this + 2) + 400), &v5);
      HGSynchronizable::Unlock(v4);
      (*(void (**)(HGUserJob *))(*(void *)v5 + 24))(v5);
      *((_DWORD *)this + 2) = 1;
    }
  }
  uint64_t v2 = *(HGSynchronizable **)(*((void *)this + 2) + 472);
  HGSynchronizable::Lock(v2);
  *((_DWORD *)this + 2) = 3;
  return HGSynchronizable::Unlock(v2);
}

void sub_1B7824450(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

uint64_t HGUserExecUnit::StartRunLoop(HGUserExecUnit *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (pthread_t *)((char *)this + 32);
  if (*((void *)this + 4)) {
    return 0;
  }
  pthread_attr_init(&v5);
  pthread_attr_setdetachstate(&v5, 2);
  uint64_t v2 = pthread_create(v1, &v5, (void *(__cdecl *)(void *))StartUserExecUnitFunc, this);
  pthread_attr_destroy(&v5);
  return v2;
}

void HGUserJob::HGUserJob(HGUserJob *this)
{
  HGObject::HGObject(this);
  *(void *)uint64_t v1 = &unk_1F10E04E8;
  *(void *)(v1 + 12) = 0x100000005;
  *(_OWORD *)(v1 + 20) = 0u;
  *(_OWORD *)(v1 + 36) = 0u;
  *(_OWORD *)(v1 + 52) = 0u;
  *(_DWORD *)(v1 + 68) = 0;
}

void HGUserJob::~HGUserJob(HGUserJob *this)
{
  *(void *)this = &unk_1F10E04E8;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2) {
    free(v2);
  }

  HGObject::~HGObject(this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10E04E8;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2) {
    free(v2);
  }

  HGObject::~HGObject(this);
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E04E8;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2) {
    free(v2);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v3);
}

uint64_t HGUserJob::SetQueueID(uint64_t this, int a2)
{
  *(_DWORD *)(this + 20) = a2;
  return this;
}

uint64_t HGUserJob::SetPriority(uint64_t result, int a2)
{
  *(_DWORD *)(result + 12) = a2;
  return result;
}

uint64_t HGUserJob::SetState(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t HGUserJob::SetNotifyFunc(uint64_t this, void (*a2)(HGUserJob *))
{
  *(void *)(this + 64) = a2;
  return this;
}

uint64_t HGUserJob::CallNotifyFunc(HGUserJob *this)
{
  uint64_t v2 = mach_absolute_time();
  uint64_t v3 = (void (*)(HGUserJob *))*((void *)this + 8);
  if (v3) {
    v3(this);
  }
  uint64_t v4 = (HGTiming *)mach_absolute_time();
  *((double *)this + 3) = HGTiming::GetMachTimeConversionFactor(v4) * (double)((unint64_t)v4 - v2);
  uint64_t result = HGRenderQueue::GetDebugQueueVerboseMask(*((HGRenderQueue **)this + 7));
  if ((result & 0x200) != 0)
  {
    int v6 = *((_DWORD *)this + 4);
    switch(v6)
    {
      case 0:
        uint64_t result = printf("UserJob<%p>::CallNotifyFunc():kStateNoError  : %5.1f ms\n");
        break;
      case 1:
        uint64_t result = printf("UserJob<%p>::CallNotifyFunc():kStateInitialized  : %5.1f ms\n");
        break;
      case 2:
        uint64_t result = printf("UserJob<%p>::CallNotifyFunc():kStateQueued  : %5.1f ms\n");
        break;
      case 3:
        uint64_t result = printf("UserJob<%p>::CallNotifyFunc():kStateExecuting  : %5.1f ms\n");
        break;
      case 4:
        uint64_t result = printf("UserJob<%p>::CallNotifyFunc():kStateCancelled  : %5.1f ms\n");
        break;
      case 5:
        uint64_t result = printf("UserJob<%p>::CallNotifyFunc():kStateFinished  : %5.1f ms\n");
        break;
      default:
        if (v6 == -1000)
        {
          uint64_t result = printf("UserJob<%p>::CallNotifyFunc():kStateError  : %5.1f ms\n");
        }
        else if (v6 == -999)
        {
          uint64_t result = printf("UserJob<%p>::CallNotifyFunc():kStateEnqueueFail  : %5.1f ms\n");
        }
        break;
    }
  }
  return result;
}

void HGDotGraph::HGDotGraph(HGDotGraph *this)
{
  *((void *)this + 1) = 0;
  *(void *)this = (char *)this + 8;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = (char *)this + 32;
  *((_WORD *)this + 28) = 256;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 8) = 0;
}

void HGDotGraph::~HGDotGraph(HGDotGraph *this)
{
  if (*((char *)this + 87) < 0) {
    operator delete(*((void **)this + 8));
  }
  std::__tree<std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>,std::__map_value_compare<std::tuple<unsigned long,unsigned long>,std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>,std::less<std::tuple<unsigned long,unsigned long>>,true>,std::allocator<std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>>>::destroy((uint64_t)this + 24, *((char **)this + 4));
  std::__tree<std::__value_type<unsigned long,HGDotGraph::Node>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,HGDotGraph::Node>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,HGDotGraph::Node>>>::destroy((uint64_t)this, *((void *)this + 1));
}

uint64_t HGDotGraph::on(HGDotGraph *this)
{
  return *((unsigned __int8 *)this + 56);
}

uint64_t HGDotGraph::footnode(uint64_t this, char a2)
{
  *(unsigned char *)(this + 57) = a2;
  return this;
}

void HGDotGraph::begin(HGDotGraph *this, const char *a2)
{
  if (*((unsigned char *)this + 56))
  {
    HGLogger::setLevel((HGLogger *)"dot", (const char *)1);
    uint64_t v4 = fopen(a2, "w");
    *((void *)this + 6) = v4;
    if (!v4)
    {
      unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
      if (v7) {
        HGLogger::log((HGLogger *)"dot", (const char *)1, (HGLogger *)"ERROR - invalid path for dot files : %s\n", v5, v6, a2);
      }
      unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
      if (v8) {
        HGLogger::log((HGLogger *)"dot", (const char *)1, (HGLogger *)"  Use HG_ENV_DOT_GRAPH_OUTPUT_DIR or HGRenderer::SetDotGraphOutputDir() with a valid directory.\n", v5, v6);
      }
    }
    if (*((unsigned char *)this + 56))
    {
      uint8x8_t v9 = (FILE *)*((void *)this + 6);
      if (v9)
      {
        fwrite("digraph rendertree\n", 0x13uLL, 1uLL, v9);
        uint64_t v10 = (FILE *)*((void *)this + 6);
        fwrite("{\n", 2uLL, 1uLL, v10);
      }
    }
  }
}

void HGDotGraph::end(HGDotGraph *this)
{
  if (*((unsigned char *)this + 56) && *((void *)this + 6))
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v8);
    HGDotGraph::_streamAll((uint64_t)this, v9);
    uint64_t v2 = (FILE *)*((void *)this + 6);
    std::stringbuf::str();
    if (v7 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    fputs(p_p, v2);
    if (v7 < 0) {
      operator delete(__p);
    }
    fwrite("}\n", 2uLL, 1uLL, *((FILE **)this + 6));
    v8[0] = *MEMORY[0x1E4FBA408];
    uint64_t v4 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    *(void *)((char *)v8 + *(void *)(v8[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
    v9[0] = v4;
    v9[1] = MEMORY[0x1E4FBA470] + 16;
    if (v10 < 0) {
      operator delete((void *)v9[9]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1BA9BFAB0](&v11);
  }
  pthread_attr_t v5 = (FILE *)*((void *)this + 6);
  if (v5)
  {
    fclose(v5);
    *((void *)this + 6) = 0;
  }
  std::__tree<std::__value_type<unsigned long,HGDotGraph::Node>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,HGDotGraph::Node>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,HGDotGraph::Node>>>::destroy((uint64_t)this, *((void *)this + 1));
  *(void *)this = (char *)this + 8;
  *((void *)this + 2) = 0;
  *((void *)this + 1) = 0;
  std::__tree<std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>,std::__map_value_compare<std::tuple<unsigned long,unsigned long>,std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>,std::less<std::tuple<unsigned long,unsigned long>>,true>,std::allocator<std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>>>::destroy((uint64_t)this + 24, *((char **)this + 4));
  *((void *)this + 3) = (char *)this + 32;
  *((void *)this + 5) = 0;
  *((void *)this + 4) = 0;
}

void sub_1B7824B90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B7824BA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void HGDotGraph::_streamAll(uint64_t a1, void *a2)
{
  uint64_t v4 = (void *)(a1 + 8);
  pthread_attr_t v5 = *(void **)a1;
  if (*(void *)a1 != a1 + 8)
  {
    do
    {
      HGDotGraph::Node::Node((uint64_t)&v22 + 8, (uint64_t)(v5 + 5));
      int v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"_0x", 3);
      *(_DWORD *)((char *)v6 + *(void *)(*v6 - 24) + 8) = *(_DWORD *)((unsigned char *)v6 + *(void *)(*v6 - 24) + 8) & 0xFFFFFFB5 | 8;
      char v7 = (void *)std::ostream::operator<<();
      unsigned __int8 v8 = operator<<(v7, (unsigned int *)&v22 + 2);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)";\n", 2);
      if (v30 < 0)
      {
        operator delete(__p);
        if ((v28 & 0x80000000) == 0)
        {
LABEL_6:
          if ((v26 & 0x80000000) == 0) {
            goto LABEL_7;
          }
          goto LABEL_12;
        }
      }
      else if ((v28 & 0x80000000) == 0)
      {
        goto LABEL_6;
      }
      operator delete(v27);
      if ((v26 & 0x80000000) == 0)
      {
LABEL_7:
        if ((v24.__r_.__value_.__s.__data_[15] & 0x80000000) == 0) {
          goto LABEL_8;
        }
        goto LABEL_13;
      }
LABEL_12:
      operator delete((void *)v24.__r_.__value_.__r.__words[2]);
      if ((v24.__r_.__value_.__s.__data_[15] & 0x80000000) == 0)
      {
LABEL_8:
        uint8x8_t v9 = (void *)v5[1];
        if (v9) {
          goto LABEL_14;
        }
        goto LABEL_16;
      }
LABEL_13:
      operator delete(v23);
      uint8x8_t v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
LABEL_14:
          char v10 = v9;
          uint8x8_t v9 = (void *)*v9;
        }
        while (v9);
        goto LABEL_3;
      }
      do
      {
LABEL_16:
        char v10 = (void *)v5[2];
        BOOL v11 = *v10 == (void)v5;
        pthread_attr_t v5 = v10;
      }
      while (!v11);
LABEL_3:
      pthread_attr_t v5 = v10;
    }
    while (v10 != v4);
  }
  double v12 = *(void **)(a1 + 24);
  if (v12 != (void *)(a1 + 32))
  {
    do
    {
      long long v22 = *((_OWORD *)v12 + 2);
      unint64_t v23 = (void *)v12[6];
      if (*((char *)v12 + 79) < 0) {
        std::string::__init_copy_ctor_external(&v24, (const std::string::value_type *)v12[7], v12[8]);
      }
      else {
        std::string v24 = *(std::string *)(v12 + 7);
      }
      char v25 = *((unsigned char *)v12 + 80);
      BOOL v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"_0x", 3);
      *(_DWORD *)((char *)v13 + *(void *)(*v13 - 24) + 8) = *(_DWORD *)((unsigned char *)v13 + *(void *)(*v13 - 24) + 8) & 0xFFFFFFB5 | 8;
      double v14 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)" -> _0x", 7);
      float v15 = (void *)std::ostream::operator<<();
      float v16 = operator<<(v15, (unsigned int *)&v23);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)";\n", 2);
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v24.__r_.__value_.__l.__data_);
        uint64_t v17 = (void *)v12[1];
        if (v17)
        {
          do
          {
LABEL_29:
            uint64_t v18 = v17;
            uint64_t v17 = (void *)*v17;
          }
          while (v17);
          goto LABEL_21;
        }
      }
      else
      {
        uint64_t v17 = (void *)v12[1];
        if (v17) {
          goto LABEL_29;
        }
      }
      do
      {
        uint64_t v18 = (void *)v12[2];
        BOOL v11 = *v18 == (void)v12;
        double v12 = v18;
      }
      while (!v11);
LABEL_21:
      double v12 = v18;
    }
    while (v18 != (void *)(a1 + 32));
  }
  if (*(unsigned char *)(a1 + 57))
  {
    BOOL v19 = (char *)operator new(0x38uLL);
    strcpy(v19, "https://confluence.aso.apple.com/confluence/x/yRtHCw");
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"labelloc=\"b\";", 13);
    unint64_t v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"label=\"\nHelium DOT reference: ", 30);
    unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)v19, 52);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"\";", 2);
    operator delete(v19);
  }
}

void sub_1B7824F04(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7824F18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7824F2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *HGDotGraph::node(uint64_t *result, unint64_t a2, uint64_t a3, int a4)
{
  if (*((unsigned char *)result + 56))
  {
    char v7 = result;
    uint8x8_t v9 = (uint64_t **)(result + 1);
    unsigned __int8 v8 = (char *)result[1];
    if (v8)
    {
      while (1)
      {
        while (1)
        {
          char v10 = v8;
          unint64_t v11 = *((void *)v8 + 4);
          if (v11 <= a2) {
            break;
          }
          unsigned __int8 v8 = *(char **)v10;
          uint8x8_t v9 = (uint64_t **)v10;
          if (!*(void *)v10) {
            goto LABEL_9;
          }
        }
        if (v11 >= a2) {
          break;
        }
        unsigned __int8 v8 = (char *)*((void *)v10 + 1);
        if (!v8)
        {
          uint8x8_t v9 = (uint64_t **)(v10 + 8);
          goto LABEL_9;
        }
      }
    }
    else
    {
      char v10 = (char *)(result + 1);
LABEL_9:
      double v12 = v10;
      char v10 = (char *)operator new(0x98uLL);
      *((void *)v10 + 4) = a2;
      *(_OWORD *)(v10 + 40) = 0u;
      *(_OWORD *)(v10 + 56) = 0u;
      *(_OWORD *)(v10 + 72) = 0u;
      *(_OWORD *)(v10 + 88) = 0u;
      *(_OWORD *)(v10 + 104) = 0u;
      *(_OWORD *)(v10 + 120) = 0u;
      *(_OWORD *)(v10 + 136) = 0u;
      *(void *)char v10 = 0;
      *((void *)v10 + 1) = 0;
      *((void *)v10 + 2) = v12;
      *uint8x8_t v9 = (uint64_t *)v10;
      uint64_t v13 = *(void *)*v7;
      double v14 = (uint64_t *)v10;
      if (v13)
      {
        *char v7 = v13;
        double v14 = *v9;
      }
      uint64_t result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v7[1], v14);
      ++v7[2];
    }
    *((_DWORD *)v10 + 10) = a4;
    if (a3)
    {
      JUMPOUT(0x1BA9BF660);
    }
  }
  return result;
}

uint64_t *HGDotGraph::dashed(uint64_t *this, unint64_t a2)
{
  if (*((unsigned char *)this + 56))
  {
    uint64_t v3 = (uint64_t)this;
    pthread_attr_t v5 = (uint64_t **)(this + 1);
    uint64_t v4 = (unint64_t *)this[1];
    if (v4)
    {
      while (1)
      {
        while (1)
        {
          int v6 = (char *)v4;
          unint64_t v7 = v4[4];
          if (v7 <= a2) {
            break;
          }
          uint64_t v4 = *(unint64_t **)v6;
          pthread_attr_t v5 = (uint64_t **)v6;
          if (!*(void *)v6) {
            goto LABEL_9;
          }
        }
        if (v7 >= a2) {
          break;
        }
        uint64_t v4 = (unint64_t *)*((void *)v6 + 1);
        if (!v4)
        {
          pthread_attr_t v5 = (uint64_t **)(v6 + 8);
          goto LABEL_9;
        }
      }
    }
    else
    {
      int v6 = (char *)(this + 1);
LABEL_9:
      unsigned __int8 v8 = v6;
      int v6 = (char *)operator new(0x98uLL);
      *((void *)v6 + 4) = a2;
      *(_OWORD *)(v6 + 40) = 0u;
      *(_OWORD *)(v6 + 56) = 0u;
      *(_OWORD *)(v6 + 72) = 0u;
      *(_OWORD *)(v6 + 88) = 0u;
      *(_OWORD *)(v6 + 104) = 0u;
      *(_OWORD *)(v6 + 120) = 0u;
      *(_OWORD *)(v6 + 136) = 0u;
      *(void *)int v6 = 0;
      *((void *)v6 + 1) = 0;
      *((void *)v6 + 2) = v8;
      *pthread_attr_t v5 = (uint64_t *)v6;
      uint64_t v9 = **(void **)v3;
      char v10 = (uint64_t *)v6;
      if (v9)
      {
        *(void *)uint64_t v3 = v9;
        char v10 = *v5;
      }
      this = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v3 + 8), v10);
      ++*(void *)(v3 + 16);
    }
    v6[149] = 1;
  }
  return this;
}

uint64_t HGDotGraph::outline(uint64_t this, unint64_t a2, const char *a3)
{
  if (*(unsigned char *)(this + 56))
  {
    uint64_t v4 = this;
    int v6 = (uint64_t **)(this + 8);
    pthread_attr_t v5 = *(unint64_t **)(this + 8);
    if (v5)
    {
      do
      {
        while (1)
        {
          unint64_t v7 = (char *)v5;
          unint64_t v8 = v5[4];
          if (v8 <= a2) {
            break;
          }
          pthread_attr_t v5 = *(unint64_t **)v7;
          int v6 = (uint64_t **)v7;
          if (!*(void *)v7) {
            goto LABEL_9;
          }
        }
        if (v8 >= a2) {
          goto LABEL_12;
        }
        pthread_attr_t v5 = (unint64_t *)*((void *)v7 + 1);
      }
      while (v5);
      int v6 = (uint64_t **)(v7 + 8);
    }
    else
    {
      unint64_t v7 = (char *)(this + 8);
    }
LABEL_9:
    uint64_t v9 = v7;
    unint64_t v7 = (char *)operator new(0x98uLL);
    *((void *)v7 + 4) = a2;
    *(_OWORD *)(v7 + 40) = 0u;
    *(_OWORD *)(v7 + 56) = 0u;
    *(_OWORD *)(v7 + 72) = 0u;
    *(_OWORD *)(v7 + 88) = 0u;
    *(_OWORD *)(v7 + 104) = 0u;
    *(_OWORD *)(v7 + 120) = 0u;
    *(_OWORD *)(v7 + 136) = 0u;
    *(void *)unint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v9;
    *int v6 = (uint64_t *)v7;
    uint64_t v10 = **(void **)v4;
    unint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *(void *)uint64_t v4 = v10;
      unint64_t v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 8), v11);
    ++*(void *)(v4 + 16);
LABEL_12:
    v7[148] = 1;
    JUMPOUT(0x1BA9BF660);
  }
  return this;
}

uint64_t HGDotGraph::filled(uint64_t this, unint64_t a2, const char *a3)
{
  if (*(unsigned char *)(this + 56))
  {
    uint64_t v4 = this;
    int v6 = (uint64_t **)(this + 8);
    pthread_attr_t v5 = *(uint64_t **)(this + 8);
    if (v5)
    {
      do
      {
        while (1)
        {
          unint64_t v7 = (uint64_t **)v5;
          unint64_t v8 = v5[4];
          if (v8 <= a2) {
            break;
          }
          pthread_attr_t v5 = *v7;
          int v6 = v7;
          if (!*v7) {
            goto LABEL_9;
          }
        }
        if (v8 >= a2) {
          goto LABEL_12;
        }
        pthread_attr_t v5 = v7[1];
      }
      while (v5);
      int v6 = v7 + 1;
    }
    else
    {
      unint64_t v7 = (uint64_t **)(this + 8);
    }
LABEL_9:
    uint64_t v9 = v7;
    uint64_t v10 = (char *)operator new(0x98uLL);
    *((void *)v10 + 4) = a2;
    *(_OWORD *)(v10 + 40) = 0u;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    *(_OWORD *)(v10 + 88) = 0u;
    *(_OWORD *)(v10 + 104) = 0u;
    *(_OWORD *)(v10 + 120) = 0u;
    *(_OWORD *)(v10 + 136) = 0u;
    *(void *)uint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = v9;
    *int v6 = (uint64_t *)v10;
    uint64_t v11 = **(void **)v4;
    double v12 = (uint64_t *)v10;
    if (v11)
    {
      *(void *)uint64_t v4 = v11;
      double v12 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 8), v12);
    ++*(void *)(v4 + 16);
LABEL_12:
    JUMPOUT(0x1BA9BF660);
  }
  return this;
}

uint64_t HGDotGraph::fontColor(uint64_t this, unint64_t a2, const char *a3)
{
  if (a3)
  {
    uint64_t v3 = this;
    if (*(unsigned char *)(this + 56))
    {
      int v6 = (uint64_t **)(this + 8);
      pthread_attr_t v5 = *(uint64_t **)(this + 8);
      if (v5)
      {
        do
        {
          while (1)
          {
            unint64_t v7 = (uint64_t **)v5;
            unint64_t v8 = v5[4];
            if (v8 <= a2) {
              break;
            }
            pthread_attr_t v5 = *v7;
            int v6 = v7;
            if (!*v7) {
              goto LABEL_10;
            }
          }
          if (v8 >= a2) {
            goto LABEL_13;
          }
          pthread_attr_t v5 = v7[1];
        }
        while (v5);
        int v6 = v7 + 1;
      }
      else
      {
        unint64_t v7 = (uint64_t **)(this + 8);
      }
LABEL_10:
      uint64_t v9 = v7;
      uint64_t v10 = (char *)operator new(0x98uLL);
      *((void *)v10 + 4) = a2;
      *(_OWORD *)(v10 + 40) = 0u;
      *(_OWORD *)(v10 + 56) = 0u;
      *(_OWORD *)(v10 + 72) = 0u;
      *(_OWORD *)(v10 + 88) = 0u;
      *(_OWORD *)(v10 + 104) = 0u;
      *(_OWORD *)(v10 + 120) = 0u;
      *(_OWORD *)(v10 + 136) = 0u;
      *(void *)uint64_t v10 = 0;
      *((void *)v10 + 1) = 0;
      *((void *)v10 + 2) = v9;
      *int v6 = (uint64_t *)v10;
      uint64_t v11 = **(void **)v3;
      double v12 = (uint64_t *)v10;
      if (v11)
      {
        *(void *)uint64_t v3 = v11;
        double v12 = *v6;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v3 + 8), v12);
      ++*(void *)(v3 + 16);
LABEL_13:
      JUMPOUT(0x1BA9BF660);
    }
  }
  return this;
}

uint64_t *HGDotGraph::fontSize(uint64_t *this, unint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = (uint64_t)this;
    if (*((unsigned char *)this + 56))
    {
      unint64_t v7 = (uint64_t **)(this + 1);
      int v6 = (unint64_t *)this[1];
      if (v6)
      {
        while (1)
        {
          while (1)
          {
            unint64_t v8 = (char *)v6;
            unint64_t v9 = v6[4];
            if (v9 <= a2) {
              break;
            }
            int v6 = *(unint64_t **)v8;
            unint64_t v7 = (uint64_t **)v8;
            if (!*(void *)v8) {
              goto LABEL_10;
            }
          }
          if (v9 >= a2) {
            break;
          }
          int v6 = (unint64_t *)*((void *)v8 + 1);
          if (!v6)
          {
            unint64_t v7 = (uint64_t **)(v8 + 8);
            goto LABEL_10;
          }
        }
      }
      else
      {
        unint64_t v8 = (char *)(this + 1);
LABEL_10:
        uint64_t v10 = v8;
        unint64_t v8 = (char *)operator new(0x98uLL);
        *((void *)v8 + 4) = a2;
        *(_OWORD *)(v8 + 40) = 0u;
        *(_OWORD *)(v8 + 56) = 0u;
        *(_OWORD *)(v8 + 72) = 0u;
        *(_OWORD *)(v8 + 88) = 0u;
        *(_OWORD *)(v8 + 104) = 0u;
        *(_OWORD *)(v8 + 120) = 0u;
        *(_OWORD *)(v8 + 136) = 0u;
        *(void *)unint64_t v8 = 0;
        *((void *)v8 + 1) = 0;
        *((void *)v8 + 2) = v10;
        *unint64_t v7 = (uint64_t *)v8;
        uint64_t v11 = **(void **)v3;
        double v12 = (uint64_t *)v8;
        if (v11)
        {
          *(void *)uint64_t v3 = v11;
          double v12 = *v7;
        }
        this = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v3 + 8), v12);
        ++*(void *)(v3 + 16);
      }
      *((_DWORD *)v8 + 36) = a3;
    }
  }
  return this;
}

uint64_t *HGDotGraph::record(uint64_t *this, unint64_t a2, const char *a3)
{
  if (*((unsigned char *)this + 56))
  {
    uint64_t v5 = (uint64_t)this;
    unint64_t v7 = (uint64_t **)(this + 1);
    int v6 = (unint64_t *)this[1];
    if (v6)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v8 = (char *)v6;
          unint64_t v9 = v6[4];
          if (v9 <= a2) {
            break;
          }
          int v6 = *(unint64_t **)v8;
          unint64_t v7 = (uint64_t **)v8;
          if (!*(void *)v8) {
            goto LABEL_9;
          }
        }
        if (v9 >= a2) {
          break;
        }
        int v6 = (unint64_t *)*((void *)v8 + 1);
        if (!v6)
        {
          unint64_t v7 = (uint64_t **)(v8 + 8);
          goto LABEL_9;
        }
      }
    }
    else
    {
      unint64_t v8 = (char *)(this + 1);
LABEL_9:
      uint64_t v10 = v8;
      unint64_t v8 = (char *)operator new(0x98uLL);
      *((void *)v8 + 4) = a2;
      *(_OWORD *)(v8 + 40) = 0u;
      *(_OWORD *)(v8 + 56) = 0u;
      *(_OWORD *)(v8 + 72) = 0u;
      *(_OWORD *)(v8 + 88) = 0u;
      *(_OWORD *)(v8 + 104) = 0u;
      *(_OWORD *)(v8 + 120) = 0u;
      *(_OWORD *)(v8 + 136) = 0u;
      *(void *)unint64_t v8 = 0;
      *((void *)v8 + 1) = 0;
      *((void *)v8 + 2) = v10;
      *unint64_t v7 = (uint64_t *)v8;
      uint64_t v11 = **(void **)v5;
      double v12 = (uint64_t *)v8;
      if (v11)
      {
        *(void *)uint64_t v5 = v11;
        double v12 = *v7;
      }
      this = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v5 + 8), v12);
      ++*(void *)(v5 + 16);
    }
    *((_DWORD *)v8 + 10) = 4;
    if (a3)
    {
      JUMPOUT(0x1BA9BF660);
    }
  }
  return this;
}

uint64_t *HGDotGraph::link(uint64_t *this, unint64_t a2, unint64_t a3, const char *a4, char a5)
{
  if (!*((unsigned char *)this + 56)) {
    return this;
  }
  uint64_t v9 = (uint64_t)this;
  uint64_t v11 = (uint64_t **)(this + 4);
  uint64_t v10 = (unint64_t *)this[4];
  if (v10)
  {
    while (1)
    {
      double v12 = v10;
      unint64_t v13 = v10[4];
      if (v13 > a2) {
        goto LABEL_4;
      }
      if (v13 < a2)
      {
LABEL_9:
        uint64_t v10 = (unint64_t *)v12[1];
        if (!v10)
        {
          uint64_t v11 = (uint64_t **)(v12 + 1);
          goto LABEL_11;
        }
      }
      else
      {
        unint64_t v14 = v12[5];
        if (v14 <= a3)
        {
          if (v14 >= a3) {
            goto LABEL_14;
          }
          goto LABEL_9;
        }
LABEL_4:
        uint64_t v10 = (unint64_t *)*v12;
        uint64_t v11 = (uint64_t **)v12;
        if (!*v12) {
          goto LABEL_11;
        }
      }
    }
  }
  double v12 = this + 4;
LABEL_11:
  float v15 = v12;
  double v12 = operator new(0x58uLL);
  v12[4] = a2;
  v12[5] = a3;
  *((_OWORD *)v12 + 3) = 0u;
  *((_OWORD *)v12 + 4) = 0u;
  v12[10] = 0;
  *double v12 = 0;
  v12[1] = 0;
  v12[2] = v15;
  *uint64_t v11 = v12;
  uint64_t v16 = **(void **)(v9 + 24);
  uint64_t v17 = v12;
  if (v16)
  {
    *(void *)(v9 + 24) = v16;
    uint64_t v17 = *v11;
  }
  this = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v9 + 32), v17);
  ++*(void *)(v9 + 40);
LABEL_14:
  *((unsigned char *)v12 + 80) = a5;
  if (a4)
  {
    JUMPOUT(0x1BA9BF660);
  }
  return this;
}

uint64_t *HGDotGraph::linkStyle(uint64_t *result, uint64_t *a2, uint64_t *a3, int a4, int a5)
{
  if (!*((unsigned char *)result + 56)) {
    return result;
  }
  uint64_t v9 = result;
  uint64_t v11 = (uint64_t **)(result + 4);
  uint64_t v10 = (uint64_t *)result[4];
  if (v10)
  {
    while (1)
    {
      double v12 = (uint64_t **)v10;
      unint64_t v13 = v10[4];
      if (v13 > (unint64_t)a2) {
        goto LABEL_4;
      }
      if (v13 < (unint64_t)a2)
      {
LABEL_9:
        uint64_t v10 = v12[1];
        if (!v10)
        {
          uint64_t v11 = v12 + 1;
          goto LABEL_11;
        }
      }
      else
      {
        unint64_t v14 = v12[5];
        if (v14 <= a3)
        {
          if (v14 >= a3) {
            goto LABEL_14;
          }
          goto LABEL_9;
        }
LABEL_4:
        uint64_t v10 = *v12;
        uint64_t v11 = v12;
        if (!*v12) {
          goto LABEL_11;
        }
      }
    }
  }
  double v12 = (uint64_t **)(result + 4);
LABEL_11:
  float v15 = (uint64_t *)v12;
  double v12 = (uint64_t **)operator new(0x58uLL);
  v12[4] = a2;
  v12[5] = a3;
  *((_OWORD *)v12 + 3) = 0u;
  *((_OWORD *)v12 + 4) = 0u;
  v12[10] = 0;
  *double v12 = 0;
  v12[1] = 0;
  v12[2] = v15;
  *uint64_t v11 = (uint64_t *)v12;
  uint64_t v16 = *(void *)v9[3];
  uint64_t v17 = (uint64_t *)v12;
  if (v16)
  {
    v9[3] = v16;
    uint64_t v17 = *v11;
  }
  uint64_t result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v9[4], v17);
  ++v9[5];
LABEL_14:
  if (a4) {
    *((_DWORD *)v12 + 12) = a5;
  }
  else {
    *((_DWORD *)v12 + 13) = a5;
  }
  return result;
}

uint64_t HGDotGraph::beginRank(uint64_t this)
{
  if (*(unsigned char *)(this + 56))
  {
    if (*(void *)(this + 48)) {
      JUMPOUT(0x1BA9BF660);
    }
  }
  return this;
}

std::string *HGDotGraph::rank(std::string *this, const void *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (this[2].__r_.__value_.__s.__data_[8])
  {
    uint64_t v2 = this;
    if (this[2].__r_.__value_.__r.__words[0])
    {
      snprintf(__str, 0x20uLL, "_%p", a2);
      uint64_t v3 = (std::string *)((char *)v2 + 64);
      std::string::append(v3, __str);
      return std::string::append(v3, " ");
    }
  }
  return this;
}

uint64_t HGDotGraph::endRank(uint64_t this)
{
  if (*(unsigned char *)(this + 56))
  {
    uint64_t v1 = this;
    if (*(void *)(this + 48))
    {
      uint64_t v2 = (const char **)(this + 64);
      std::string::append((std::string *)(this + 64), "}\n");
      uint64_t v3 = *(FILE **)(v1 + 48);
      if (*(char *)(v1 + 87) < 0)
      {
        uint64_t v4 = *v2;
      }
      else
      {
        uint64_t v4 = (const char *)(v1 + 64);
      }
      return fputs(v4, v3);
    }
  }
  return this;
}

void *operator<<(void *a1, unsigned int *a2)
{
  uint64_t v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)" [shape=", 8);
  size_t v5 = strlen(operator<<(std::ostream &,HGDotGraph::Node const&)::shapeStrings[*a2]);
  int v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)operator<<(std::ostream &,HGDotGraph::Node const&)::shapeStrings[*a2], v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"]", 1);
  if (*((char *)a2 + 55) >= 0) {
    uint64_t v7 = *((unsigned __int8 *)a2 + 55);
  }
  else {
    uint64_t v7 = *((void *)a2 + 5);
  }
  if (*((unsigned char *)a2 + 108) || *((unsigned char *)a2 + 109) || v7)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)" [style=\"", 9);
    if (*((unsigned char *)a2 + 108)) {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"bold,", 5);
    }
    if (*((unsigned char *)a2 + 109)) {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"dashed,", 7);
    }
    if (v7) {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"filled,", 7);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"\"]", 2);
  }
  uint64_t v8 = *((unsigned __int8 *)a2 + 31);
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *((void *)a2 + 2);
  }
  if (v8)
  {
    uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)" [color=\"", 9);
    int v10 = *((char *)a2 + 31);
    if (v10 >= 0) {
      uint64_t v11 = (uint64_t)(a2 + 2);
    }
    else {
      uint64_t v11 = *((void *)a2 + 1);
    }
    if (v10 >= 0) {
      uint64_t v12 = *((unsigned __int8 *)a2 + 31);
    }
    else {
      uint64_t v12 = *((void *)a2 + 2);
    }
    unint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, v11, v12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"\"]", 2);
  }
  uint64_t v14 = *((unsigned __int8 *)a2 + 55);
  if ((v14 & 0x80u) != 0) {
    uint64_t v14 = *((void *)a2 + 5);
  }
  if (v14)
  {
    float v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)" [fillcolor=\"", 13);
    int v16 = *((char *)a2 + 55);
    if (v16 >= 0) {
      uint64_t v17 = (uint64_t)(a2 + 8);
    }
    else {
      uint64_t v17 = *((void *)a2 + 4);
    }
    if (v16 >= 0) {
      uint64_t v18 = *((unsigned __int8 *)a2 + 55);
    }
    else {
      uint64_t v18 = *((void *)a2 + 5);
    }
    BOOL v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, v17, v18);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"\"]", 2);
  }
  uint64_t v20 = *((unsigned __int8 *)a2 + 79);
  if ((v20 & 0x80u) != 0) {
    uint64_t v20 = *((void *)a2 + 8);
  }
  if (v20)
  {
    unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)" [fontcolor=\"", 13);
    int v22 = *((char *)a2 + 79);
    if (v22 >= 0) {
      uint64_t v23 = (uint64_t)(a2 + 14);
    }
    else {
      uint64_t v23 = *((void *)a2 + 7);
    }
    if (v22 >= 0) {
      uint64_t v24 = *((unsigned __int8 *)a2 + 79);
    }
    else {
      uint64_t v24 = *((void *)a2 + 8);
    }
    char v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, v23, v24);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"\"]", 2);
  }
  if (a2[26])
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)" [fontsize=", 11);
    char v26 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"]", 1);
  }
  unint64_t v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)" [label=\"", 9);
  uint64_t v30 = *((void *)a2 + 10);
  uint64_t v29 = a2 + 20;
  uint64_t v28 = v30;
  int v31 = *((char *)v29 + 23);
  if (v31 >= 0) {
    uint64_t v32 = (uint64_t)v29;
  }
  else {
    uint64_t v32 = v28;
  }
  if (v31 >= 0) {
    uint64_t v33 = *((unsigned __int8 *)v29 + 23);
  }
  else {
    uint64_t v33 = *((void *)v29 + 1);
  }
  unint64_t v34 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v32, v33);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, (uint64_t)"\"]", 2);
  return a1;
}

{
  unsigned int v4;
  int v5;
  BOOL v6;
  const char *v7;
  void *v8;
  size_t v9;
  void *v10;
  void *v11;
  size_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;

  size_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (*a2) {
    int v6 = v4 == 0;
  }
  else {
    int v6 = 1;
  }
  if (!v6)
  {
    uint64_t v7 = " [dir=both]";
LABEL_8:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v7, 11);
    goto LABEL_9;
  }
  if (!(v5 | v4))
  {
    uint64_t v7 = " [dir=none]";
    goto LABEL_8;
  }
  if (!v5 && v4)
  {
    uint64_t v7 = " [dir=back]";
    goto LABEL_8;
  }
LABEL_9:
  if (*a2)
  {
    uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)" [arrowhead=", 12);
    uint64_t v9 = strlen(operator<<(std::ostream &,HGDotGraph::Edge const&)::arrowStrings[*a2]);
    int v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)operator<<(std::ostream &,HGDotGraph::Edge const&)::arrowStrings[*a2], v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"]", 1);
  }
  if (a2[1])
  {
    uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)" [arrowtail=", 12);
    uint64_t v12 = strlen(operator<<(std::ostream &,HGDotGraph::Edge const&)::arrowStrings[a2[1]]);
    unint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)operator<<(std::ostream &,HGDotGraph::Edge const&)::arrowStrings[a2[1]], v12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"]", 1);
  }
  if (*((unsigned char *)a2 + 32)) {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)" [style=dotted]", 15);
  }
  uint64_t v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)" [headlabel=\"", 13);
  uint64_t v17 = *((void *)a2 + 1);
  int v16 = a2 + 2;
  float v15 = v17;
  uint64_t v18 = *((char *)v16 + 23);
  if (v18 >= 0) {
    BOOL v19 = (uint64_t)v16;
  }
  else {
    BOOL v19 = v15;
  }
  if (v18 >= 0) {
    uint64_t v20 = *((unsigned __int8 *)v16 + 23);
  }
  else {
    uint64_t v20 = *((void *)v16 + 1);
  }
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, v19, v20);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"\"]", 2);
  return a1;
}

uint64_t std::pair<unsigned long const,HGDotGraph::Node>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 111) < 0)
  {
    operator delete(*(void **)(a1 + 88));
    if ((*(char *)(a1 + 87) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(a1 + 63) & 0x80000000) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      operator delete(*(void **)(a1 + 40));
      if ((*(char *)(a1 + 39) & 0x80000000) == 0) {
        return a1;
      }
      goto LABEL_9;
    }
  }
  else if ((*(char *)(a1 + 87) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(a1 + 64));
  if (*(char *)(a1 + 63) < 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((*(char *)(a1 + 39) & 0x80000000) == 0) {
    return a1;
  }
LABEL_9:
  operator delete(*(void **)(a1 + 16));
  return a1;
}

uint64_t HGDotGraph::Node::Node(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 8), *(const std::string::value_type **)(a2 + 8), *(void *)(a2 + 16));
    size_t v5 = (std::string *)(a1 + 32);
    if ((*(char *)(a2 + 55) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
    size_t v5 = (std::string *)(a1 + 32);
    if ((*(char *)(a2 + 55) & 0x80000000) == 0)
    {
LABEL_3:
      long long v6 = *(_OWORD *)(a2 + 32);
      v5->__r_.__value_.__r.__words[2] = *(void *)(a2 + 48);
      *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
      goto LABEL_6;
    }
  }
  std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a2 + 32), *(void *)(a2 + 40));
LABEL_6:
  if (*(char *)(a2 + 79) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 56), *(const std::string::value_type **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v7;
  }
  uint64_t v8 = (std::string *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  int v10 = *(_DWORD *)(a2 + 104);
  *(_WORD *)(a1 + 108) = *(_WORD *)(a2 + 108);
  *(_DWORD *)(a1 + 104) = v10;
  return a1;
}

void sub_1B7826060(_Unwind_Exception *exception_object)
{
  if (v1[79] < 0)
  {
    operator delete(*v4);
    if ((v1[55] & 0x80000000) == 0)
    {
LABEL_3:
      if ((v1[31] & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((v1[55] & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*v3);
  if ((v1[31] & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<unsigned long,HGDotGraph::Node>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,HGDotGraph::Node>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,HGDotGraph::Node>>>::destroy(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long,HGDotGraph::Node>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,HGDotGraph::Node>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,HGDotGraph::Node>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<unsigned long,HGDotGraph::Node>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,HGDotGraph::Node>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,HGDotGraph::Node>>>::destroy(a1, *(void *)(a2 + 8));
    if (*(char *)(a2 + 143) < 0)
    {
      operator delete(*(void **)(a2 + 120));
      if ((*(char *)(a2 + 119) & 0x80000000) == 0)
      {
LABEL_4:
        if ((*(char *)(a2 + 95) & 0x80000000) == 0) {
          goto LABEL_5;
        }
        goto LABEL_12;
      }
    }
    else if ((*(char *)(a2 + 119) & 0x80000000) == 0)
    {
      goto LABEL_4;
    }
    operator delete(*(void **)(a2 + 96));
    if ((*(char *)(a2 + 95) & 0x80000000) == 0)
    {
LABEL_5:
      if ((*(char *)(a2 + 71) & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_13;
    }
LABEL_12:
    operator delete(*(void **)(a2 + 72));
    if ((*(char *)(a2 + 71) & 0x80000000) == 0)
    {
LABEL_6:
      long long v4 = (void *)a2;
LABEL_8:
      operator delete(v4);
      return;
    }
LABEL_13:
    operator delete(*(void **)(a2 + 48));
    long long v4 = (void *)a2;
    goto LABEL_8;
  }
}

void std::__tree<std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>,std::__map_value_compare<std::tuple<unsigned long,unsigned long>,std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>,std::less<std::tuple<unsigned long,unsigned long>>,true>,std::allocator<std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>,std::__map_value_compare<std::tuple<unsigned long,unsigned long>,std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>,std::less<std::tuple<unsigned long,unsigned long>>,true>,std::allocator<std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>,std::__map_value_compare<std::tuple<unsigned long,unsigned long>,std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>,std::less<std::tuple<unsigned long,unsigned long>>,true>,std::allocator<std::__value_type<std::tuple<unsigned long,unsigned long>,HGDotGraph::Edge>>>::destroy(a1, *((void *)a2 + 1));
    if (a2[79] < 0)
    {
      operator delete(*((void **)a2 + 7));
      long long v4 = a2;
    }
    else
    {
      long long v4 = a2;
    }
    operator delete(v4);
  }
}

void HGGamutMap::HGGamutMap(HGGamutMap *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10E0538;
  *(void *)(v1 + 456) = 0;
  *(_DWORD *)(v1 + 464) = 0;
  *(unsigned char *)(v1 + 468) = 0;
  *(void *)(v1 + 416) = 0;
  *(void *)(v1 + 424) = 0;
  *(void *)(v1 + 408) = 0;
  *(_DWORD *)(v1 + 432) = 0;
  *(_OWORD *)(v1 + 436) = xmmword_1B8347DC0;
}

void HGGamutMap::~HGGamutMap(CGColorSpaceRef *this)
{
  *this = (CGColorSpaceRef)&unk_1F10E0538;
  CGColorSpaceRelease(this[51]);
  CGColorSpaceRelease(this[52]);
  CGColorSpaceRef v2 = this[57];
  if (v2) {
    (*(void (**)(CGColorSpaceRef))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode((HGNode *)this);
}

{
  CGColorSpaceRef v2;
  void *v3;
  uint64_t vars8;

  *this = (CGColorSpaceRef)&unk_1F10E0538;
  CGColorSpaceRelease(this[51]);
  CGColorSpaceRelease(this[52]);
  CGColorSpaceRef v2 = this[57];
  if (v2) {
    (*(void (**)(CGColorSpaceRef))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode((HGNode *)this);

  HGObject::operator delete(v3);
}

void HGGamutMap::SetConversion(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(_DWORD *)(a1 + 424) = 1;
  *(_DWORD *)(a1 + 428) = a2;
  *(_DWORD *)(a1 + 436) = a3;
  *(_DWORD *)(a1 + 444) = a4;
  *(_DWORD *)(a1 + 432) = a5;
  *(_DWORD *)(a1 + 440) = a6;
  *(_DWORD *)(a1 + 448) = a7;
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 408));
  *(void *)(a1 + 408) = 0;
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 416));
  *(void *)(a1 + 416) = 0;
}

HGNode *HGGamutMap::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t result = HGRenderer::GetInput(a2, this, 0);
  long long v4 = result;
  if (*((unsigned char *)this + 468))
  {
    size_t v5 = (HgcGamutDebug *)HGObject::operator new(0x1A0uLL);
    HgcGamutDebug::HgcGamutDebug(v5);
  }
  uint64_t v6 = *((void *)this + 51);
  if (v6 && (uint64_t v7 = *((void *)this + 52)) != 0)
  {
    if (v6 != v7) {
      goto LABEL_10;
    }
  }
  else
  {
    if (!*((_DWORD *)this + 106)) {
      return result;
    }
    if (v6 != *((void *)this + 52)) {
      goto LABEL_10;
    }
  }
  if (*((_DWORD *)this + 106))
  {
LABEL_10:
    if (result) {
      (*(void (**)(HGNode *))(*(void *)result + 16))(result);
    }
    uint64_t v8 = (HGColorConform *)HGObject::operator new(0x320uLL);
    HGColorConform::HGColorConform(v8);
    (*(void (**)(HGColorConform *, void, HGNode *))(*(void *)v8 + 120))(v8, 0, v4);
    uint64_t v10 = *((unsigned int *)this + 106);
    if (v10)
    {
      if (v10 == 1) {
        HGColorConform::SetConversion((uint64_t)v8, *((_DWORD *)this + 107), *((_DWORD *)this + 109), *((_DWORD *)this + 111), *((_DWORD *)this + 108), *((_DWORD *)this + 110), *((_DWORD *)this + 112));
      }
      else {
        HGColorConform::SetConversion((uint64_t)v8, v10, v9);
      }
    }
    else
    {
      HGColorConform::SetConversion((HGNode *)v8, *((CGColorSpace **)this + 51), *((CGColorSpace **)this + 52));
    }
    uint64_t v11 = (HgcGamutMap *)HGObject::operator new(0x1A0uLL);
    HgcGamutMap::HgcGamutMap(v11);
  }
  return result;
}

void sub_1B7826778(_Unwind_Exception *a1)
{
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(a1);
}

void HGRenderContext::HGRenderContext(HGRenderContext *this)
{
  HGObject::HGObject(this);
  void *v1 = &unk_1F10E07A0;
  v1[2] = 0;
  v1[3] = 0;
  v1[14] = 0;
  v1[15] = 0;
  v1[16] = 0;
  operator new();
}

void sub_1B78269B0(_Unwind_Exception *a1)
{
  uint64_t v5 = v3;
  MEMORY[0x1BA9BFBA0](v5, 0x10A1C40BBCAB520);
  uint64_t v7 = *v4;
  if (*v4)
  {
    *((void *)v1 + 15) = v7;
    operator delete(v7);
  }
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v2);
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGRenderContext::~HGRenderContext(HGRenderContext *this)
{
  *(void *)this = &unk_1F10E07A0;
  uint64_t v2 = *((void *)this + 8);
  if (v2)
  {
    if (!*(unsigned char *)(v2 + 8)) {
      HGSynchronizable::Unlock(*(HGSynchronizable **)v2);
    }
    MEMORY[0x1BA9BFBA0](v2, 0x1020C405F07FB98);
  }
  uint64_t v3 = *((void *)this + 7);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  long long v4 = (void *)*((void *)this + 14);
  if (v4)
  {
    *((void *)this + 15) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    uint64_t v6 = this;
  }
  else
  {
    uint64_t v6 = this;
  }
  HGObject::~HGObject(v6);
}

uint64_t HGRenderContext::Lock(uint64_t this)
{
  if (!*(void *)(this + 64)) {
    operator new();
  }
  return this;
}

void sub_1B7826B94(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1020C405F07FB98);
  _Unwind_Resume(a1);
}

uint64_t HGRenderContext::Unlock(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 64);
  if (v1)
  {
    uint64_t v2 = this;
    if (!*(unsigned char *)(v1 + 8)) {
      HGSynchronizable::Unlock(*(HGSynchronizable **)v1);
    }
    this = MEMORY[0x1BA9BFBA0](v1, 0x1020C405F07FB98);
    *(void *)(v2 + 64) = 0;
  }
  return this;
}

BOOL HGRenderContext::IsCPU(HGRenderContext *this)
{
  return *((_DWORD *)this + 9) == 0;
}

BOOL HGRenderContext::IsGPU(HGRenderContext *this)
{
  return *((_DWORD *)this + 9) == 1;
}

uint64_t HGRenderContext::SetWorkMode(uint64_t result, int a2)
{
  *(_DWORD *)(result + 40) = a2;
  return result;
}

uint64_t HGRenderContext::GetType(HGRenderContext *this)
{
  return *((unsigned int *)this + 9);
}

uint64_t HGRenderContext::GetRenderer(HGRenderContext *this)
{
  return *((void *)this + 9);
}

void HGRenderContext::PushRenderTime(HGRenderContext *this, float a2)
{
  uint64_t v4 = *((void *)this + 14);
  uint64_t v6 = (float *)*((void *)this + 15);
  uint64_t v5 = (void **)((char *)this + 112);
  if (*((void *)this + 13) < (unint64_t)(((uint64_t)v6 - v4) >> 2))
  {
    size_t v7 = (size_t)v6 - v4 - 4;
    if (v7) {
      memmove(*((void **)this + 14), (const void *)(v4 + 4), v7);
    }
    uint64_t v6 = (float *)(v4 + v7);
    *((void *)this + 15) = v6;
  }
  unint64_t v8 = *((void *)this + 16);
  if ((unint64_t)v6 < v8)
  {
    *uint64_t v6 = a2;
    uint64_t v9 = (uint64_t)(v6 + 1);
    goto LABEL_28;
  }
  uint64_t v10 = (float *)*v5;
  uint64_t v11 = (char *)v6 - (unsigned char *)*v5;
  uint64_t v12 = v11 >> 2;
  unint64_t v13 = (v11 >> 2) + 1;
  if (v13 >> 62) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v14 = v8 - (void)v10;
  if (v14 >> 1 > v13) {
    unint64_t v13 = v14 >> 1;
  }
  if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v15 = v13;
  }
  if (v15)
  {
    if (v15 >> 62) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int v16 = operator new(4 * v15);
    uint64_t v17 = (float *)&v16[4 * v12];
    uint64_t v18 = &v16[4 * v15];
    *uint64_t v17 = a2;
    uint64_t v9 = (uint64_t)(v17 + 1);
    int64_t v19 = (char *)v6 - (char *)v10;
    if (v6 == v10) {
      goto LABEL_26;
    }
  }
  else
  {
    int v16 = 0;
    uint64_t v17 = (float *)(4 * v12);
    uint64_t v18 = 0;
    *(float *)(4 * v12) = a2;
    uint64_t v9 = 4 * v12 + 4;
    int64_t v19 = (char *)v6 - (char *)v10;
    if (v6 == v10) {
      goto LABEL_26;
    }
  }
  unint64_t v20 = v19 - 4;
  if (v20 < 0x2C)
  {
    unint64_t v21 = v6;
    goto LABEL_25;
  }
  if ((unint64_t)((char *)v6 - v16 - v11) < 0x20)
  {
    unint64_t v21 = v6;
    do
    {
LABEL_25:
      int v28 = *((_DWORD *)v21-- - 1);
      *((_DWORD *)v17-- - 1) = v28;
    }
    while (v21 != v10);
    goto LABEL_26;
  }
  uint64_t v22 = (v20 >> 2) + 1;
  uint64_t v23 = 4 * (v22 & 0x7FFFFFFFFFFFFFF8);
  unint64_t v21 = &v6[v23 / 0xFFFFFFFFFFFFFFFCLL];
  uint64_t v17 = (float *)((char *)v17 - v23);
  uint64_t v24 = &v16[4 * v12 - 16];
  char v25 = v6 - 4;
  uint64_t v26 = v22 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    long long v27 = *(_OWORD *)v25;
    *(v24 - 1) = *((_OWORD *)v25 - 1);
    *uint64_t v24 = v27;
    v24 -= 2;
    v25 -= 8;
    v26 -= 8;
  }
  while (v26);
  if (v22 != (v22 & 0x7FFFFFFFFFFFFFF8)) {
    goto LABEL_25;
  }
LABEL_26:
  *((void *)this + 14) = v17;
  *((void *)this + 15) = v9;
  *((void *)this + 16) = v18;
  if (v10) {
    operator delete(v10);
  }
LABEL_28:
  *((void *)this + 15) = v9;
}

void HGRenderContext::DumpHistogram(HGRenderContext *this)
{
  if (!*((unsigned char *)this + 92)) {
    return;
  }
  uint64_t v3 = (float *)*((void *)this + 14);
  uint64_t v2 = (float *)*((void *)this + 15);
  unint64_t v4 = v2 - v3;
  unint64_t v5 = *((void *)this + 12);
  unint64_t v6 = v4 - v5;
  if (v4 < v5) {
    return;
  }
  if (v4 > v5)
  {
    double v7 = 0.0;
    uint64_t v8 = *((void *)this + 12);
    if (v6 < 8) {
      goto LABEL_9;
    }
    uint64_t v8 = v5 + (v6 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v9 = (float32x4_t *)&v3[v5 + 4];
    float64x2_t v10 = (float64x2_t)vdupq_n_s64(0x408F400000000000uLL);
    unint64_t v11 = v6 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      float32x4_t v12 = v9[-1];
      float64x2_t v13 = vcvtq_f64_f32(*(float32x2_t *)v12.f32);
      float64x2_t v14 = vmulq_f64(vcvt_hight_f64_f32(v12), v10);
      float64x2_t v15 = vmulq_f64(v13, v10);
      float64x2_t v16 = vmulq_f64(vcvt_hight_f64_f32(*v9), v10);
      float64x2_t v17 = vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v9->f32), v10);
      double v7 = v7 + v15.f64[0] + v15.f64[1] + v14.f64[0] + v14.f64[1] + v17.f64[0] + v17.f64[1] + v16.f64[0] + v16.f64[1];
      v9 += 2;
      v11 -= 8;
    }
    while (v11);
    if (v6 != (v6 & 0xFFFFFFFFFFFFFFF8))
    {
LABEL_9:
      uint64_t v18 = v4 - v8;
      int64_t v19 = &v3[v8];
      do
      {
        float v20 = *v19++;
        double v7 = v7 + v20 * 1000.0;
        --v18;
      }
      while (v18);
    }
    double v39 = (double)v6;
    double v41 = v7 / (double)v6;
    double v40 = 0.0;
    if (v6 < 8) {
      goto LABEL_15;
    }
    unint64_t v21 = v5 + (v6 & 0xFFFFFFFFFFFFFFF8);
    double v22 = v41;
    float64x2_t v23 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v41, 0);
    uint64_t v24 = (float32x2_t *)&v3[v5 + 4];
    float64x2_t v25 = (float64x2_t)vdupq_n_s64(0x408F400000000000uLL);
    unint64_t v26 = v6 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      float32x4_t v27 = *(float32x4_t *)v24[-2].f32;
      float64x2_t v28 = vsubq_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v27.f32), v25), v23);
      float64x2_t v29 = vsubq_f64(vmulq_f64(vcvt_hight_f64_f32(v27), v25), v23);
      float64x2_t v30 = vsubq_f64(vmulq_f64(vcvtq_f64_f32(*v24), v25), v23);
      float64x2_t v31 = vsubq_f64(vmulq_f64(vcvt_hight_f64_f32(*(float32x4_t *)v24->f32), v25), v23);
      float64x2_t v32 = vmulq_f64(v29, v29);
      float64x2_t v33 = vmulq_f64(v28, v28);
      float64x2_t v34 = vmulq_f64(v31, v31);
      float64x2_t v35 = vmulq_f64(v30, v30);
      double v40 = v40 + v33.f64[0] + v33.f64[1] + v32.f64[0] + v32.f64[1] + v35.f64[0] + v35.f64[1] + v34.f64[0] + v34.f64[1];
      v24 += 4;
      v26 -= 8;
    }
    while (v26);
    unint64_t v5 = v21;
    double v41 = v22;
    if (v6 != (v6 & 0xFFFFFFFFFFFFFFF8))
    {
LABEL_15:
      uint64_t v36 = v4 - v5;
      unsigned __int8 v37 = &v3[v5];
      do
      {
        float v38 = *v37++;
        double v40 = v40 + (v38 * 1000.0 - v41) * (v38 * 1000.0 - v41);
        --v36;
      }
      while (v36);
    }
  }
  else
  {
    double v39 = (double)v6;
    double v40 = 0.0;
    double v41 = 0.0 / (double)v6;
  }
  unsigned __int8 v59 = 0;
  uint64_t v60 = 0;
  uint64_t v58 = &v59;
  double v57 = v41;
  if (v3 == v2) {
    goto LABEL_46;
  }
  for (unsigned int i = 0; ; unsigned int i = v59)
  {
    int v43 = (int)(*v3 * 1000.0);
    uint64_t v44 = &v59;
    int v45 = &v59;
    if (i) {
      break;
    }
LABEL_26:
    uint64_t v48 = operator new(0x28uLL);
    v48[7] = v43;
    unsigned int v48[8] = 0;
    *(void *)uint64_t v48 = 0;
    *((void *)v48 + 1) = 0;
    *((void *)v48 + 2) = v45;
    *uint64_t v44 = (uint64_t *)v48;
    long long v49 = (uint64_t *)v48;
    if (*v58)
    {
      uint64_t v58 = (uint64_t **)*v58;
      long long v49 = *v44;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v59, v49);
    ++v60;
    ++v48[8];
    if (++v3 == v2) {
      goto LABEL_32;
    }
LABEL_31:
    ;
  }
  signed int v46 = i;
  while (1)
  {
    while (1)
    {
      int v45 = (uint64_t **)v46;
      int v47 = *((_DWORD *)v46 + 7);
      if (v47 <= v43) {
        break;
      }
      signed int v46 = *v45;
      uint64_t v44 = v45;
      if (!*v45) {
        goto LABEL_26;
      }
    }
    if (v47 >= v43) {
      break;
    }
    signed int v46 = v45[1];
    if (!v46)
    {
      uint64_t v44 = v45 + 1;
      goto LABEL_26;
    }
  }
  ++*((_DWORD *)v45 + 8);
  if (++v3 != v2) {
    goto LABEL_31;
  }
LABEL_32:
  char v50 = v58;
  if (v58 == &v59)
  {
LABEL_46:
    int v52 = 0;
    goto LABEL_47;
  }
  int v51 = 0;
  int v52 = 0;
  do
  {
    if (*((_DWORD *)v50 + 8) > v51)
    {
      int v52 = *((_DWORD *)v50 + 7);
      int v51 = *((_DWORD *)v50 + 8);
    }
    printf("[%d]", *((_DWORD *)v50 + 7));
    if (*((int *)v50 + 8) >= 1)
    {
      int v53 = 0;
      do
      {
        putchar(42);
        ++v53;
      }
      while (v53 < *((_DWORD *)v50 + 8));
    }
    putchar(10);
    uint64_t v54 = v50[1];
    if (v54)
    {
      do
      {
        uint64_t v55 = (uint64_t **)v54;
        uint64_t v54 = (uint64_t *)*v54;
      }
      while (v54);
    }
    else
    {
      do
      {
        uint64_t v55 = (uint64_t **)v50[2];
        BOOL v56 = *v55 == (uint64_t *)v50;
        char v50 = v55;
      }
      while (!v56);
    }
    char v50 = v55;
  }
  while (v55 != &v59);
LABEL_47:
  printf("Num renders: %lu  Average: %.1f ms  Std Deviation: %.1f  Mode: %d\n\n", (uint64_t)(*((void *)this + 15) - *((void *)this + 14)) >> 2, v57, sqrt(v40 / v39), v52);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v58, v59);
}

void sub_1B782723C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)va, v8);
  _Unwind_Resume(a1);
}

void HGRenderExecUnit::HGRenderExecUnit(HGRenderExecUnit *this, HGRenderContext *a2, HGRenderQueue *a3, int a4)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1F10E07F8;
  *((_DWORD *)this + 2) = a4;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 6) = a2;
  (*(void (**)(HGRenderContext *))(*(void *)a2 + 16))(a2);
  uint64_t v5 = *(void *)(*((void *)this + 6) + 72);
  *((void *)this + 7) = v5;
  (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
  *((void *)this + 9) = 0;
  operator new();
}

void sub_1B78274BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  double v7 = *v5;
  if (*v5)
  {
    *(void *)(v4 + 120) = v7;
    operator delete(v7);
  }
  _Unwind_Resume(a1);
}

void HGRenderExecUnit::~HGRenderExecUnit(HGRenderExecUnit *this)
{
  *(void *)this = &unk_1F10E07F8;
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 6);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 2);
  if (v4) {
    free(v4);
  }
  uint64_t v5 = *((void *)this + 9);
  if (v5) {
    dispatch_release(v5);
  }
  uint64_t v6 = *((void *)this + 10);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  double v7 = (void *)*((void *)this + 14);
  if (v7)
  {
    *((void *)this + 15) = v7;
    operator delete(v7);
  }
}

{
  uint64_t vars8;

  HGRenderExecUnit::~HGRenderExecUnit(this);

  JUMPOUT(0x1BA9BFBA0);
}

BOOL HGRenderExecUnit::IsGPU(HGRenderExecUnit *this)
{
  return *((_DWORD *)this + 10) == 0;
}

BOOL HGRenderExecUnit::IsCPU(HGRenderExecUnit *this)
{
  return *((_DWORD *)this + 10) == 1;
}

BOOL HGRenderExecUnit::CanPerformJobType(uint64_t a1, int a2)
{
  int v3 = HGPixelBufferObj::format(*(HGPixelBufferObj **)(a1 + 48));
  BOOL result = 1;
  switch(a2)
  {
    case 0:
    case 1:
    case 7:
    case 8:
      BOOL result = (v3 & 0xFFFFFFFD) == 0;
      break;
    case 2:
    case 3:
      BOOL result = (v3 - 1) < 2;
      break;
    case 4:
    case 5:
    case 6:
      return result;
    default:
      BOOL result = 0;
      break;
  }
  return result;
}

HGSynchronizable *HGRenderExecUnit::AddEnqueuedRenderJob(HGRenderExecUnit *this, HGRenderJob *a2)
{
  unint64_t v26 = (HGSynchronizable *)*((void *)this + 10);
  HGSynchronizable::Lock(v26);
  uint64_t v5 = (char *)*((void *)this + 15);
  unint64_t v4 = *((void *)this + 16);
  uint64_t v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    *(void *)uint64_t v5 = a2;
    uint64_t v7 = (uint64_t)(v5 + 8);
    goto LABEL_14;
  }
  uint64_t v8 = (char *)*((void *)this + 14);
  uint64_t v9 = (v5 - v8) >> 3;
  unint64_t v10 = v9 + 1;
  if ((unint64_t)(v9 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v11 = v4 - (void)v8;
  if (v11 >> 2 > v10) {
    unint64_t v10 = v11 >> 2;
  }
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v12 = v10;
  }
  if (v12)
  {
    if (v12 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    float64x2_t v13 = (char *)operator new(8 * v12);
    float64x2_t v14 = &v13[8 * v9];
    float64x2_t v15 = &v13[8 * v12];
    *(void *)float64x2_t v14 = a2;
    uint64_t v7 = (uint64_t)(v14 + 8);
    float64x2_t v16 = (char *)(v5 - v8);
    if (v5 == v8)
    {
LABEL_12:
      *((void *)this + 14) = v14;
      *((void *)this + 15) = v7;
      *((void *)this + 16) = v15;
      if (!v5) {
        goto LABEL_14;
      }
LABEL_13:
      operator delete(v6);
      goto LABEL_14;
    }
  }
  else
  {
    float64x2_t v13 = 0;
    float64x2_t v14 = (char *)(8 * v9);
    float64x2_t v15 = 0;
    *(void *)(8 * v9) = a2;
    uint64_t v7 = 8 * v9 + 8;
    float64x2_t v16 = (char *)(v5 - v8);
    if (v5 == v8) {
      goto LABEL_12;
    }
  }
  unint64_t v18 = (unint64_t)(v16 - 8);
  if (v18 < 0x58) {
    goto LABEL_28;
  }
  if ((unint64_t)(v8 - v13) < 0x20) {
    goto LABEL_28;
  }
  uint64_t v19 = (v18 >> 3) + 1;
  uint64_t v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
  uint64_t v6 = &v5[-v20];
  v14 -= v20;
  unint64_t v21 = &v13[8 * v9 - 16];
  double v22 = v5 - 16;
  uint64_t v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v24 = *(_OWORD *)v22;
    *((_OWORD *)v21 - 1) = *((_OWORD *)v22 - 1);
    *(_OWORD *)unint64_t v21 = v24;
    v21 -= 32;
    v22 -= 32;
    v23 -= 4;
  }
  while (v23);
  if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_28:
    do
    {
      uint64_t v25 = *((void *)v6 - 1);
      v6 -= 8;
      *((void *)v14 - 1) = v25;
      v14 -= 8;
    }
    while (v6 != v8);
  }
  uint64_t v6 = (char *)*((void *)this + 14);
  *((void *)this + 14) = v14;
  *((void *)this + 15) = v7;
  *((void *)this + 16) = v15;
  if (v6) {
    goto LABEL_13;
  }
LABEL_14:
  *((void *)this + 15) = v7;
  return HGSynchronizable::Unlock(v26);
}

void sub_1B78278CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

uint64_t HGRenderExecUnit::RemoveEnqueuedRenderJob(HGRenderExecUnit *this, HGRenderJob *a2)
{
  unint64_t v4 = (HGSynchronizable *)*((void *)this + 10);
  HGSynchronizable::Lock(v4);
  uint64_t v6 = (char *)*((void *)this + 14);
  uint64_t v5 = (char *)*((void *)this + 15);
  if (v6 == v5)
  {
LABEL_5:
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v7 = 0;
    while (*(HGRenderJob **)&v6[v7] != a2)
    {
      v7 += 8;
      if (&v6[v7] == v5) {
        goto LABEL_5;
      }
    }
    uint64_t v9 = &v6[v7];
    unint64_t v10 = &v6[v7 + 8];
    int64_t v11 = v5 - v10;
    if (v5 != v10) {
      memmove(&v6[v7], v10, v5 - v10);
    }
    *((void *)this + 15) = &v9[v11];
    uint64_t v8 = 1;
  }
  HGSynchronizable::Unlock(v4);
  return v8;
}

BOOL HGRenderExecUnit::HasEnqueuedRenderJob(HGRenderExecUnit *this, HGRenderJob *a2)
{
  unint64_t v4 = (HGSynchronizable *)*((void *)this + 10);
  HGSynchronizable::Lock(v4);
  uint64_t v6 = *((void *)this + 14);
  uint64_t v5 = *((void *)this + 15);
  if (v6 == v5)
  {
    BOOL v9 = 0;
  }
  else
  {
    uint64_t v7 = v6 + 8;
    do
    {
      uint64_t v8 = *(HGRenderJob **)(v7 - 8);
      BOOL v9 = v8 == a2;
      BOOL v10 = v8 == a2 || v7 == v5;
      v7 += 8;
    }
    while (!v10);
  }
  HGSynchronizable::Unlock(v4);
  return v9;
}

uint64_t HGRenderExecUnit::NumEnqueuedRenderJobs(HGRenderExecUnit *this)
{
  uint64_t v2 = (HGSynchronizable *)*((void *)this + 10);
  HGSynchronizable::Lock(v2);
  uint64_t v5 = (char *)this + 112;
  uint64_t v3 = *((void *)this + 14);
  uint64_t v4 = *((void *)v5 + 1);
  HGSynchronizable::Unlock(v2);
  return (v4 - v3) >> 3;
}

HGRenderExecUnit *StartRenderExecUnitFunc(HGRenderExecUnit *a1)
{
  return a1;
}

HGSynchronizable *HGRenderExecUnit::RunLoop(HGRenderExecUnit *this)
{
  uint64_t v125 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 10) == 1)
  {
    snprintf(__str, 0x200uLL, "com.apple.helium.rq.cpu-ru%d", *((_DWORD *)this + 2));
    pthread_setname_np(__str);
  }
  else
  {
    uint64_t v2 = (_DWORD *)*((void *)this + 6);
    if (v3)
    {
      uint64_t v4 = (HGGLContext **)v3;
      uint64_t FrameStats = PVRenderJob::GetFrameStats(v3);
      uint64_t v6 = *(HGGPUComputeDevice **)FrameStats;
      uint64_t v7 = *(std::__shared_weak_count **)(FrameStats + 8);
      *(void *)policy_infoCnt = *(void *)FrameStats;
      uint64_t v122 = v7;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      HGGPUComputeDevice::GetGLVirtualScreen(v6);
      HGGPURenderContext::GetGLContext(v4, (HGGLContextPtr *)&v120);
      v119.unsigned int var0 = v120.var0;
      HGGLSetCurrentContext(&v119.var0);
      PCSharedCount::PCSharedCount(&v119);
      PCSharedCount::PCSharedCount(&v120);
      if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      uint64_t v2 = (_DWORD *)*((void *)this + 6);
    }
    if (v2[10] == 1) {
      snprintf(__str, 0x200uLL, "com.apple.helium.rq.gpu-cu%d.vs%d");
    }
    else {
      snprintf(__str, 0x200uLL, "com.apple.helium.rq.gpu-ru%d.vs%d");
    }
    pthread_setname_np(__str);
  }
  uint64_t v8 = dispatch_group_create();
  if (!HGRenderQueue::IsShuttingDown(*((HGRenderQueue **)this + 8)))
  {
    while (1)
    {
      v120.unsigned int var0 = 0;
      if (HGRenderQueue::GetRenderJob(*((HGRenderQueue **)this + 8), this, (HGRenderJob **)&v120)) {
        break;
      }
LABEL_146:
      if (HGRenderQueue::IsShuttingDown(*((HGRenderQueue **)this + 8))) {
        goto LABEL_15;
      }
    }
    HGAutoReleasePoolScopeGuard::HGAutoReleasePoolScopeGuard((HGAutoReleasePoolScopeGuard *)&v118);
    HGRenderContext::Lock(*((void *)this + 6));
    *((void *)v120.var0 + 29) = *((void *)this + 6);
    uint64_t v11 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 7) + 128))(*((void *)this + 7), 15);
    uint64_t v12 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 7) + 128))(*((void *)this + 7), 30);
    uint64_t v13 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 7) + 128))(*((void *)this + 7), 22);
    uint64_t v14 = *((void *)this + 6);
    unsigned int var0 = v120.var0;
    uint64_t v17 = *(void *)(v14 + 16);
    uint64_t v16 = *(void *)(v14 + 24);
    if (v16) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v18 = (std::__shared_weak_count *)*((void *)var0 + 9);
    *((void *)var0 + 8) = v17;
    *((void *)var0 + 9) = v16;
    if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
    uint64_t v19 = v120.var0;
    int v20 = *((_DWORD *)v120.var0 + 3);
    switch(v20)
    {
      case 0:
      case 1:
        uint64_t v21 = *((void *)this + 7);
        if (v20 == 1 && *((void *)v120.var0 + 22)) {
          uint64_t v21 = *((void *)v120.var0 + 22);
        }
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v21 + 120))(v21, 22, *((unsigned __int8 *)v120.var0 + 196));
        double v22 = v120.var0;
        if (*((_DWORD *)v120.var0 + 69))
        {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 30);
          double v22 = v120.var0;
        }
        if (*((_DWORD *)v22 + 68))
        {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 15);
          double v22 = v120.var0;
        }
        if (*((_DWORD *)v22 + 70))
        {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 16);
          double v22 = v120.var0;
        }
        if (*((unsigned char *)v22 + 197)) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 40, 1);
        }
        if (*((_DWORD *)this + 10))
        {
          unsigned int v116 = 0;
          goto LABEL_92;
        }
        unsigned int v116 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v21 + 128))(v21, 43);
        int v48 = *((_DWORD *)v120.var0 + 25);
        if (v48 == 2 && v116 != 1)
        {
          uint64_t v49 = 1;
LABEL_81:
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 43, v49);
          goto LABEL_82;
        }
        if (v48 == 1 && v116)
        {
          uint64_t v49 = 0;
          goto LABEL_81;
        }
LABEL_82:
        if (*((_DWORD *)v120.var0 + 34)) {
          uint64_t v50 = 28;
        }
        else {
          uint64_t v50 = 27;
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 20, v50);
        int v51 = v120.var0;
        if ((*(_DWORD *)(*((void *)this + 8) + 60) & 0x80000000) == 0 && *((_DWORD *)v120.var0 + 25) != 1)
        {
          BOOL HasCPUBufferDestinationsOnly = HGRenderJob::HasCPUBufferDestinationsOnly((HGRenderJob *)v120.var0);
          int v51 = v120.var0;
          if (!HasCPUBufferDestinationsOnly && !*((unsigned char *)v120.var0 + 197))
          {
            (*(void (**)(uint64_t, uint64_t, void))(*(void *)v21 + 120))(v21, 42, *(unsigned int *)(*((void *)this + 8) + 60));
            int v51 = v120.var0;
          }
        }
        if (*((_DWORD *)v51 + 71)) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 47);
        }
LABEL_92:
        int v53 = *((_DWORD *)v120.var0 + 33) - 1;
        if (v53 <= 2) {
          (*(void (**)(uint64_t, uint64_t, void))(*(void *)v21 + 120))(v21, 19, dword_1B8347E28[v53]);
        }
        uint64_t v54 = mach_absolute_time();
        uint64_t v55 = v54;
        BOOL v56 = v120.var0;
        *((void *)v120.var0 + 18) = v54;
        if ((*(unsigned char *)(*((void *)this + 8) + 70) & 2) != 0)
        {
          if (*((_DWORD *)this + 10))
          {
            printf("Executing CPU Render Job <%p>:                %llu\n", v56, v54);
          }
          else
          {
            uint64_t v66 = PVRenderJob::GetFrameStats(*((PVRenderJob **)this + 6));
            HGRect v67 = *(HGGPUComputeDevice **)v66;
            HGRect v68 = *(std::__shared_weak_count **)(v66 + 8);
            *(void *)__str = *(void *)v66;
            v124 = v68;
            if (v68) {
              atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            int GLVirtualScreen = HGGPUComputeDevice::GetGLVirtualScreen(v67);
            printf("Executing GPU Render Job <%p>:                %llu   vs%i\n", v120.var0, v55, GLVirtualScreen);
            if (v68 && !atomic_fetch_add(&v68->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
              std::__shared_weak_count::__release_weak(v68);
            }
          }
        }
        kdebug_trace();
        double v57 = v120.var0;
        if (*((_DWORD *)this + 10) != 1)
        {
          *((_DWORD *)v120.var0 + 5) = 2;
          HGRenderJob::SetState((uint64_t)v57, 4);
          HGRenderJob::CallNotifyFunc((HGRenderJob *)v120.var0);
          unsigned __int8 v64 = (const void *)*((void *)this + 6);
          if (v64) {
          else
          }
            BOOL v65 = 0;
          HGGPURenderContext::GetGLContextPriority(v65);
          HGGPURenderContext::SetGLContextPriority((uint64_t)v65);
        }
        *((_DWORD *)v120.var0 + 5) = 1;
        HGRenderJob::SetState((uint64_t)v57, 4);
        HGRenderJob::CallNotifyFunc((HGRenderJob *)v120.var0);
        uint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v21 + 128))(v21, 6);
        uint64_t v61 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 7) + 128))(*((void *)this + 7), 5);
        int v62 = v120.var0;
        if (*((int *)v120.var0 + 24) >= 1)
        {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 5);
          int v62 = v120.var0;
        }
        uint64_t v63 = *((unsigned int *)v62 + 28);
        if (v63 <= 4) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 6);
        }
        HGRenderExecUnit::ExecuteRenderCPU(this, (HGRenderJob *)v120.var0, v63, v59, v60);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 6, v58);
        if (*((int *)v120.var0 + 24) >= 1) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 5, v61);
        }
        uint64_t v78 = (HGTiming *)mach_absolute_time();
        double v79 = HGTiming::GetMachTimeConversionFactor(v78) * (double)((unint64_t)v78 - v55);
        int v80 = v120.var0;
        *((double *)v120.var0 + 19) = v79;
        if ((*(unsigned char *)(*((void *)this + 8) + 70) & 2) != 0)
        {
          if (*((_DWORD *)this + 10))
          {
            printf("Completed CPU Render Job <%p>:                %llu  %5.1f ms\n", v80, v78, v79 * 1000.0);
          }
          else
          {
            uint64_t v94 = PVRenderJob::GetFrameStats(*((PVRenderJob **)this + 6));
            char v95 = *(HGGPUComputeDevice **)v94;
            int v96 = *(std::__shared_weak_count **)(v94 + 8);
            *(void *)__str = *(void *)v94;
            v124 = v96;
            if (v96) {
              atomic_fetch_add_explicit(&v96->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            int v97 = HGGPUComputeDevice::GetGLVirtualScreen(v95);
            printf("Completed GPU Render Job <%p>:                %llu  %5.1f ms  vs%i\n", v120.var0, v78, *((double *)v120.var0 + 19) * 1000.0, v97);
            if (v96 && !atomic_fetch_add(&v96->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
              std::__shared_weak_count::__release_weak(v96);
            }
          }
        }
        kdebug_trace();
        uint64_t v81 = (HGRenderContext *)*((void *)this + 6);
        if (*((unsigned char *)v81 + 92))
        {
          float v82 = *((double *)v120.var0 + 19);
          HGRenderContext::PushRenderTime(v81, v82);
        }
        if ((*(unsigned char *)(*((void *)this + 8) + 68) & 8) == 0) {
          goto LABEL_129;
        }
        if (*((_DWORD *)this + 10))
        {
          uint64_t v83 = (const char *)*((void *)this + 2);
          double v84 = *((double *)v120.var0 + 19);
          UserName = HGRenderJob::GetUserName((HGRenderJob *)v120.var0);
          printf("%s : kRenderFinished    :  time: %5.1f (ms)  attached: -  '%s'\n", v83, v84 * 1000.0, UserName);
        }
        else
        {
          uint64_t v98 = PVRenderJob::GetFrameStats(*((PVRenderJob **)this + 6));
          uint64_t v99 = *(TXParagraphStyleFolder_Factory **)v98;
          uint64_t v100 = *(std::__shared_weak_count **)(v98 + 8);
          *(void *)__str = v99;
          v124 = v100;
          if (v100) {
            atomic_fetch_add_explicit(&v100->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          int v101 = TXParagraphStyleFolder_Factory::version(v99);
          unint64_t v115 = v8;
          uint64_t v102 = 1;
          if (v101) {
            uint64_t v102 = 0;
          }
          atomic_fetch_add(&_MergedGlobals_15[v102], 1u);
          unsigned int v103 = atomic_load((unsigned int *)_MergedGlobals_15);
          if (v103 && (unsigned int v104 = atomic_load((unsigned int *)&dword_1EB9A20CC)) != 0)
          {
            BOOL v105 = (const char *)*((void *)this + 2);
            double v106 = *((double *)v120.var0 + 19);
            float32x4_t v107 = HGRenderJob::GetUserName((HGRenderJob *)v120.var0);
            int v108 = _MergedGlobals_15[0];
            int v109 = dword_1EB9A20CC;
            uint64_t NumJobsInRenderQueue = HGRenderQueue::GetNumJobsInRenderQueue(*((HGRenderQueue **)this + 8));
            printf("%s : kRenderFinished    :  time: %5.1f (ms)  attached: %d  '%s'  gpu split: %d:%d  num enqueued: %zu\n", v105, v106 * 1000.0, v101, v107, v108, v109, NumJobsInRenderQueue);
            uint64_t v8 = v115;
            BOOL v111 = v124;
            if (!v124) {
              goto LABEL_129;
            }
          }
          else
          {
            uint8x8_t v112 = (const char *)*((void *)this + 2);
            double v113 = *((double *)v120.var0 + 19);
            uint64_t v114 = HGRenderJob::GetUserName((HGRenderJob *)v120.var0);
            printf("%s : kRenderFinished    :  time: %5.1f (ms)  attached: %d  '%s'\n", v112, v113 * 1000.0, v101, v114);
            BOOL v111 = v124;
            if (!v124) {
              goto LABEL_129;
            }
          }
          if (!atomic_fetch_add(&v111->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
            std::__shared_weak_count::__release_weak(v111);
          }
        }
LABEL_129:
        __n128 v86 = *(HGSynchronizable **)(*((void *)this + 8) + 344);
        *(void *)__str = v86;
        LOBYTE(v124) = 0;
        HGSynchronizable::Lock(v86);
        std::list<HGGPUReadbackJob *>::remove((void *)(*((void *)this + 8) + 136), &v120);
        HGSynchronizable::Unlock(v86);
        uint64_t v87 = *((void *)this + 8);
        if (*(unsigned char *)(v87 + 72) && !*((_DWORD *)this + 10))
        {
          uint64_t v89 = *(HGSynchronizable **)(v87 + 128);
          *(void *)__str = v89;
          LOBYTE(v124) = 0;
          HGSynchronizable::Lock(v89);
          HGSynchronizable::NotifyAll(v89);
          HGSynchronizable::Unlock(v89);
        }
        else if (*(unsigned char *)(v87 + 73) && *((_DWORD *)this + 10) == 1)
        {
          uint64_t v88 = *(HGSynchronizable **)(v87 + 120);
          *(void *)__str = v88;
          LOBYTE(v124) = 0;
          HGSynchronizable::Lock(v88);
          HGSynchronizable::NotifyAll(v88);
          HGSynchronizable::Unlock(v88);
        }
        int v90 = *((_DWORD *)v120.var0 + 27);
        if (v90 == -1000 || v90 == 6)
        {
          HGRenderJob::CallNotifyFunc((HGRenderJob *)v120.var0);
          uint64_t v91 = *((void *)v120.var0 + 38);
          if (*((void *)v120.var0 + 39) != v91)
          {
            unint64_t v92 = 0;
            do
            {
              unsigned __int8 v93 = *(char **)(v91 + 8 * v92);
              HGRenderNode::CallNotifyFunc(v93);
              HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v93);
              ++v92;
              uint64_t v91 = *((void *)v120.var0 + 38);
            }
            while (v92 < (*((void *)v120.var0 + 39) - v91) >> 3);
          }
        }
        else
        {
          HGRenderJob::SetState((uint64_t)v120.var0, 7);
          HGRenderJob::CallNotifyFunc((HGRenderJob *)v120.var0);
          HGRenderExecUnit::FinalizeRenderNodes(this, (HGRenderJob *)v120.var0);
        }
        (*(void (**)(PC_Sp_counted_base *))(*(void *)v120.var0 + 24))(v120.var0);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 15, v11);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 30, v12);
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v21 + 120))(v21, 40, 0);
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v21 + 120))(v21, 19, *(unsigned int *)(*((void *)this + 6) + 80));
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 120))(v21, 22, v13);
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v21 + 120))(v21, 47, 0);
        if (!*((_DWORD *)this + 10)) {
          (*(void (**)(uint64_t, uint64_t, void))(*(void *)v21 + 120))(v21, 43, v116);
        }
        ++*((void *)this + 11);
LABEL_145:
        *((_DWORD *)this + 6) = 2;
        HGRenderContext::Unlock(*((void *)this + 6));
        HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&v118);
        goto LABEL_146;
      case 2:
        float64x2_t v32 = (HGRenderNode *)**((void **)v120.var0 + 38);
        HGRenderExecUnit::ExecuteCopyCPUBitmapToGPUTexture((uint64_t)this, v32);
        uint64_t v33 = *((void *)this + 8);
        if (*(unsigned char *)(v33 + 77))
        {
          float64x2_t v34 = *(HGSynchronizable **)(v33 + 344);
          *(void *)__str = v34;
          LOBYTE(v124) = 0;
          HGSynchronizable::Lock(v34);
          std::list<HGGPUReadbackJob *>::remove((void *)(*((void *)this + 8) + 136), &v120);
          HGSynchronizable::Unlock(v34);
        }
        HGRenderNode::CallNotifyFunc((const char *)v32);
        HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v32);
        (*(void (**)(PC_Sp_counted_base *))(*(void *)v120.var0 + 24))(v120.var0);
        goto LABEL_145;
      case 3:
        float64x2_t v35 = (char *)**((void **)v120.var0 + 38);
        HGRenderNode::CallNotifyFunc(v35);
        HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v35);
        (*(void (**)(PC_Sp_counted_base *))(*(void *)v120.var0 + 24))(v120.var0);
        goto LABEL_145;
      case 4:
        goto LABEL_74;
      case 5:
        uint64_t v36 = (uint64_t *)*((void *)v120.var0 + 38);
        uint64_t v37 = *v36;
        float v38 = *(HGPixelBufferObj **)(*v36 + 136);
        if (v38)
        {
          HGRenderQueue::ReleasePBOToSharedPool(*((HGRenderQueue **)this + 8), v38);
          uint64_t v19 = v120.var0;
          double v39 = (uint64_t *)*((void *)v120.var0 + 38);
          *(void *)(*v39 + 136) = 0;
          uint64_t v37 = *v39;
        }
        uint64_t v40 = *(void *)(v37 + 16);
        if (v40)
        {
          (*(void (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v19 = v120.var0;
          double v41 = (uint64_t *)*((void *)v120.var0 + 38);
          *(void *)(*v41 + 16) = 0;
          uint64_t v37 = *v41;
        }
        uint64_t v42 = *(void *)(v37 + 24);
        if (!v42) {
          goto LABEL_74;
        }
        (*(void (**)(uint64_t))(*(void *)v42 + 24))(v42);
LABEL_67:
        uint64_t v19 = v120.var0;
        *(void *)(**((void **)v120.var0 + 38) + 24) = 0;
LABEL_74:
        (*(void (**)(PC_Sp_counted_base *))(*(void *)v19 + 24))(v19);
        goto LABEL_145;
      case 6:
        uint64_t v43 = *(void *)(**((void **)v120.var0 + 38) + 24);
        (*(void (**)(uint64_t))(*(void *)v43 + 24))(v43);
        goto LABEL_67;
      case 7:
      case 8:
        kdebug_trace();
        HGRenderJob::SetState((uint64_t)v120.var0, 4);
        uint64_t v23 = v120.var0;
        int v24 = *((_DWORD *)v120.var0 + 29);
        if (v24)
        {
          if (!*((void *)this + 9))
          {
            if (HGRenderContext::IsCPU(*((HGRenderContext **)this + 6))) {
              snprintf(__str, 0x200uLL, "com.apple.helium.rq.cpu-render-unit%d.gcd", *((_DWORD *)this + 2));
            }
            uint64_t v25 = PVRenderJob::GetFrameStats(*((PVRenderJob **)this + 6));
            unint64_t v26 = *(HGGPUComputeDevice **)v25;
            float32x4_t v27 = *(std::__shared_weak_count **)(v25 + 8);
            *(void *)policy_infoCnt = *(void *)v25;
            uint64_t v122 = v27;
            if (v27) {
              atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            HGGPUComputeDevice::GetGLVirtualScreen(v26);
            if (*(_DWORD *)(*((void *)this + 6) + 40) == 1) {
              snprintf(__str, 0x200uLL, "com.apple.helium.rq.gpu-cu%d.vs%d.gcd");
            }
            else {
              snprintf(__str, 0x200uLL, "com.apple.helium.rq.gpu-ru%d.vs%d.gcd");
            }
            if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
              std::__shared_weak_count::__release_weak(v27);
            }
            float64x2_t v28 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
            *((void *)this + 9) = dispatch_queue_create(__str, v28);
            int v24 = *((_DWORD *)v120.var0 + 29);
          }
          if (v24 == 3) {
            int v29 = 25;
          }
          else {
            int v29 = 21;
          }
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 0x40000000;
          block[2] = ___ZN16HGRenderExecUnit7RunLoopEv_block_invoke_2;
          block[3] = &__block_descriptor_tmp_16;
          if (v24 == 1) {
            dispatch_qos_class_t v30 = QOS_CLASS_UTILITY;
          }
          else {
            dispatch_qos_class_t v30 = v29;
          }
          block[4] = v23;
          block[5] = this;
          dispatch_block_t v31 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_DETACHED, v30, 0, block);
          dispatch_group_async(v8, *((dispatch_queue_t *)this + 9), v31);
          dispatch_group_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
          _Block_release(v31);
        }
        else
        {
          HGRenderJob::CallNotifyFunc((HGRenderJob *)v120.var0);
        }
        uint64_t v44 = *(HGSynchronizable **)(*((void *)this + 8) + 344);
        *(void *)__str = v44;
        LOBYTE(v124) = 0;
        HGSynchronizable::Lock(v44);
        std::list<HGGPUReadbackJob *>::remove((void *)(*((void *)this + 8) + 160), &v120);
        HGSynchronizable::Unlock(v44);
        if ((*(unsigned char *)(*((void *)this + 8) + 68) & 8) != 0)
        {
          if (*((_DWORD *)this + 10))
          {
            int v45 = (const char *)*((void *)this + 2);
            double v46 = *((double *)v120.var0 + 20);
            int v47 = HGRenderJob::GetUserName((HGRenderJob *)v120.var0);
            printf("%s : kCustomJobFinished :  time: %5.1f (ms)  attached: -  '%s'  job <%p>\n", v45, v46 * 1000.0, v47, v120.var0);
          }
          else
          {
            uint64_t v70 = PVRenderJob::GetFrameStats(*((PVRenderJob **)this + 6));
            int v71 = *(TXParagraphStyleFolder_Factory **)v70;
            int v72 = *(std::__shared_weak_count **)(v70 + 8);
            *(void *)__str = *(void *)v70;
            v124 = v72;
            if (v72) {
              atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            int v73 = TXParagraphStyleFolder_Factory::version(v71);
            uint64_t v74 = 3;
            if (v73) {
              uint64_t v74 = 2;
            }
            ++_MergedGlobals_15[v74];
            uint64_t v75 = (const char *)*((void *)this + 2);
            double v76 = *((double *)v120.var0 + 20);
            unint64_t v77 = HGRenderJob::GetUserName((HGRenderJob *)v120.var0);
            printf("%s : kCustomJobFinished :  time: %5.1f (ms)  attached: %d  '%s'  count: %d/%d  job <%p>\n", v75, v76 * 1000.0, v73, v77, dword_1EB9A20D0, *(_DWORD *)algn_1EB9A20D4, v120.var0);
            if (v72 && !atomic_fetch_add(&v72->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
              std::__shared_weak_count::__release_weak(v72);
            }
          }
        }
        kdebug_trace();
        uint64_t v19 = v120.var0;
        if (*((_DWORD *)v120.var0 + 3) == 8)
        {
          HGSynchronizable::NotifyAll(*((HGSynchronizable **)v120.var0 + 37));
          uint64_t v19 = v120.var0;
        }
        goto LABEL_74;
      default:
        goto LABEL_145;
    }
  }
LABEL_15:
  dispatch_release(v8);
  BOOL v9 = *(HGSynchronizable **)(*((void *)this + 8) + 344);
  HGSynchronizable::Lock(v9);
  *((_DWORD *)this + 6) = 5;
  return HGSynchronizable::Unlock(v9);
}

void sub_1B78291DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34,PCSharedCount a35,PCSharedCount a36,char a37,uint64_t a38,char a39)
{
}

void sub_1B78292FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B7829310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B782932C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B7829344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B7829360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B7829374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
}

void sub_1B7829390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B78293A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B78293B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B78293D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B78293EC(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B78293FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,HGSynchronizable *a39)
{
}

void sub_1B7829418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B782942C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B7829440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B7829454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B7829468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B782947C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B7829490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B78294A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B78294B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B78294CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B78294E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B78294F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B7829508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B782951C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

void sub_1B7829530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
}

uint64_t HGRenderExecUnit::StartRunLoop(HGRenderExecUnit *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (pthread_t *)((char *)this + 32);
  if (*((void *)this + 4)) {
    return 0;
  }
  size_t v5 = 0;
  pthread_attr_init(&v6);
  pthread_attr_getstacksize(&v6, &v5);
  if (!(v5 >> 20)) {
    pthread_attr_setstacksize(&v6, 0x100000uLL);
  }
  pthread_attr_setdetachstate(&v6, 2);
  uint64_t v2 = pthread_create(v1, &v6, (void *(__cdecl *)(void *))StartRenderExecUnitFunc, this);
  pthread_attr_destroy(&v6);
  return v2;
}

void HGRenderExecUnit::ExecuteRenderGPU(HGRenderExecUnit *this, HGRenderJob *a2)
{
  HGAutoReleasePoolScopeGuard::HGAutoReleasePoolScopeGuard((HGAutoReleasePoolScopeGuard *)&v97);
  uint64_t v4 = (uint64_t *)*((void *)a2 + 38);
  unint64_t v5 = *((void *)a2 + 39) - (void)v4;
  unint64_t v6 = v5 >> 3;
  uint64_t v7 = (HGRenderer *)*((void *)this + 7);
  if (*((_DWORD *)a2 + 3) == 1 && *((void *)a2 + 22)) {
    uint64_t v7 = (HGRenderer *)*((void *)a2 + 22);
  }
  if (v6 == 1)
  {
    uint64_t v8 = *v4;
    HGRenderNode::SetRenderer(*v4, v7);
    if (*(_DWORD *)(v8 + 60) == 1 && !*(void *)(v8 + 24))
    {
      BOOL v9 = (HGBitmap *)HGObject::operator new(0x80uLL);
      HGBitmap::HGBitmap(v9, *(void *)(v8 + 32), *(void *)(v8 + 40), *(unsigned int *)(v8 + 48));
      HGRenderNode::SetBitmap((HGRenderNode *)v8, v9);
      *(_DWORD *)(v8 + 64) = 1;
      (*(void (**)(HGBitmap *))(*(void *)v9 + 24))(v9);
    }
    uint64_t v10 = *(void *)(v8 + 24);
    if (v10)
    {
      (*(void (**)(HGRenderer *, uint64_t, void))(*(void *)v7 + 64))(v7, v10, *(void *)(v8 + 16));
      if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)v7 + 128))(v7, 13))
      {
        HGRenderNode::SetState(v8, 8);
        (*(void (**)(HGRenderer *, uint64_t, void))(*(void *)v7 + 120))(v7, 13, 0);
      }
      else
      {
        *(unsigned char *)(v8 + 96) = 0;
        *(_DWORD *)(v8 + 56) = 9;
        if ((*(unsigned char *)(*(void *)(v8 + 24) + 12) & 0x30) != 0) {
          *(_DWORD *)(v8 + 64) = 4;
        }
      }
      goto LABEL_170;
    }
    int v45 = *(_DWORD *)(v8 + 60) - 3;
    if (v45 > 3) {
      int v46 = 0;
    }
    else {
      int v46 = dword_1B8347E50[v45];
    }
    uint64_t v96 = 0;
    *(_OWORD *)__p = 0u;
    long long v95 = 0u;
    HGRendererOutput::HGRendererOutput((uint64_t)__p, *(void *)(v8 + 16), *(void *)(v8 + 32), *(void *)(v8 + 40), *(_DWORD *)(v8 + 48), v46);
    HGRenderer::RenderNode(v7, (const HGRendererOutput *)__p, (char *)1, &v93);
    if (v93)
    {
      (*(void (**)(uint64_t))(*(void *)v93 + 16))(v93);
      uint64_t v47 = v93;
    }
    else
    {
      uint64_t v47 = 0;
    }
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)v7 + 128))(v7, 13))
    {
      HGRenderNode::SetState(v8, 8);
      (*(void (**)(HGRenderer *, uint64_t, void))(*(void *)v7 + 120))(v7, 13, 0);
      if (v47) {
        (*(void (**)(uint64_t))(*(void *)v47 + 24))(v47);
      }
      goto LABEL_168;
    }
    if (!v47)
    {
      int v78 = -999;
LABEL_167:
      *(_DWORD *)(v8 + 56) = v78;
      goto LABEL_168;
    }
    if ((~*(_DWORD *)(v47 + 12) & 0x110) == 0)
    {
      uint64_t v73 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)v7 + 104))(v7, v47);
      (*(void (**)(uint64_t))(*(void *)v47 + 24))(v47);
      uint64_t v47 = v73;
    }
    *(void *)(v8 + 24) = v47;
    if (*(_DWORD *)(v8 + 60) == 3 && (*(unsigned char *)(v47 + 12) & 1) != 0)
    {
      uint64_t v74 = *(unsigned int *)(v8 + 48);
      if (*(_DWORD *)(v47 + 16) != v74)
      {
        Buffer = HGGPURenderer::CreateBuffer((uint64_t)v7, *(HGRect *)(v47 + 20), v74, 0, 0, 0);
        HGGPURenderer::BufferCopyOpenGL(v7, (HGBuffer *)Buffer, *(HGRect *)(*(void *)(v8 + 24) + 20), *(HGBitmap **)(v8 + 24));
        uint64_t v47 = HGGPURenderer::ConvertToGLTexture(v7, *(HGRect *)(Buffer + 20), (HGBitmap *)Buffer);
        (*(void (**)(char *))(*(void *)Buffer + 24))(Buffer);
        (*(void (**)(void))(**(void **)(v8 + 24) + 24))(*(void *)(v8 + 24));
        *(void *)(v8 + 24) = v47;
      }
    }
    *(unsigned char *)(v8 + 96) = 0;
    *(_DWORD *)(v8 + 56) = 9;
    int v76 = *(_DWORD *)(v47 + 12);
    if ((v76 & 0x31) == 0)
    {
      *(_DWORD *)(v8 + 64) = 1;
      goto LABEL_164;
    }
    if (v76)
    {
      int v77 = 6;
    }
    else if ((v76 & 0x20) != 0)
    {
      int v77 = 5;
    }
    else
    {
      if ((v76 & 0x10) == 0)
      {
LABEL_160:
        if ((*(_DWORD *)(v8 + 60) - 1) <= 1 || (uint64_t v79 = *(void *)(v8 + 72)) != 0 && !*(_DWORD *)(v79 + 8))
        {
          *(unsigned char *)(v8 + 96) = 1;
          *(_DWORD *)(v8 + 56) = 4;
        }
LABEL_164:
        int v80 = *(HGGLContext **)(v8 + 88);
        if (v80)
        {
          if (*(_DWORD *)(v8 + 64) == 1)
          {
LABEL_166:
            *(unsigned char *)(v8 + 96) = 1;
            int v78 = 3;
            goto LABEL_167;
          }
          uint64_t v81 = *(void *)(v8 + 72);
          if (!v81)
          {
            VirtualScreen = (HGComputeDeviceManager *)HGGLContext::getVirtualScreen(v80);
            HGComputeDeviceManager::GetGPUComputeDeviceForCGLVirtualScreen(VirtualScreen, &v88);
            std::shared_ptr<HGComputeDevice const>::operator=[abi:ne180100]<HGGPUComputeDevice const,void>((void *)(v8 + 72), (uint64_t *)&v88);
            std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v88);
            uint64_t v81 = *(void *)(v8 + 72);
          }
        }
        else
        {
          uint64_t v81 = *(void *)(v8 + 72);
          if (!v81 || *(_DWORD *)(v81 + 8) != 1)
          {
LABEL_168:
            if (v93) {
              (*(void (**)(uint64_t))(*(void *)v93 + 24))(v93);
            }
            goto LABEL_170;
          }
          if (*(_DWORD *)(v8 + 64) == 1) {
            goto LABEL_166;
          }
        }
        uint64_t v84 = *((void *)a2 + 8);
        uint64_t v83 = (char *)a2 + 64;
        if (v81 != v84)
        {
          *(unsigned char *)(v8 + 96) = 1;
          HGToGPUComputeDevicePtr((uint64_t)v83, &v88);
          HGToGPUComputeDevicePtr(v8 + 72, &v91);
          if (*(unsigned char *)(*((void *)this + 8) + 78)
            && (uint64_t v85 = *((void *)v88 + 17)) != 0
            && v85 == *(void *)(v91 + 136)
            && (*(unsigned char *)(*(void *)(v8 + 24) + 12) & 0x21) != 0)
          {
            int v86 = 6;
          }
          else
          {
            int v86 = 5;
          }
          *(_DWORD *)(v8 + 56) = v86;
          std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v91);
          std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v88);
        }
        goto LABEL_168;
      }
      int v77 = 3;
    }
    *(_DWORD *)(v8 + 64) = v77;
    goto LABEL_160;
  }
  if ((int)v6 < 2) {
    goto LABEL_170;
  }
  uint64_t v87 = this;
  uint64_t v88 = 0;
  uint64_t v11 = 0;
  uint64_t v89 = 0;
  unint64_t v90 = 0;
  uint64_t v12 = (v5 >> 3);
  do
  {
    uint64_t v16 = *(void *)(*((void *)a2 + 38) + 8 * v11);
    HGRenderNode::SetRenderer(v16, v7);
    if (*(void *)(v16 + 24))
    {
      uint64_t v96 = 0;
      *(_OWORD *)__p = 0u;
      long long v95 = 0u;
      HGRendererOutput::HGRendererOutput((HGRendererOutput *)__p, *(HGNode **)(v16 + 16), *(HGBitmap **)(v16 + 24));
      uint64_t v19 = v89;
      if ((unint64_t)v89 < v90) {
        goto LABEL_13;
      }
      int v20 = (char *)v88;
      unint64_t v21 = 0xCCCCCCCCCCCCCCCDLL * ((v89 - (unsigned char *)v88) >> 3);
      unint64_t v22 = v21 + 1;
      if (v21 + 1 > 0x666666666666666) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      if (0x999999999999999ALL * ((uint64_t)(v90 - (void)v88) >> 3) > v22) {
        unint64_t v22 = 0x999999999999999ALL * ((uint64_t)(v90 - (void)v88) >> 3);
      }
      if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v90 - (void)v88) >> 3) >= 0x333333333333333) {
        unint64_t v23 = 0x666666666666666;
      }
      else {
        unint64_t v23 = v22;
      }
      if (v23)
      {
        if (v23 > 0x666666666666666) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        int v24 = (char *)operator new(40 * v23);
      }
      else
      {
        int v24 = 0;
      }
      int v29 = &v24[8 * ((v89 - (unsigned char *)v88) >> 3)];
      long long v30 = v95;
      *(_OWORD *)int v29 = *(_OWORD *)__p;
      *((_OWORD *)v29 + 1) = v30;
      *((void *)v29 + 4) = v96;
      dispatch_block_t v31 = &v24[40 * v21];
      if (v19 != v20)
      {
        do
        {
          long long v32 = *(_OWORD *)(v19 - 40);
          long long v33 = *(_OWORD *)(v19 - 24);
          *((void *)v31 - 1) = *((void *)v19 - 1);
          *(_OWORD *)(v31 - 24) = v33;
          *(_OWORD *)(v31 - 40) = v32;
          v31 -= 40;
          v19 -= 40;
        }
        while (v19 != v20);
LABEL_46:
        uint64_t v19 = v20;
      }
    }
    else
    {
      int v25 = *(_DWORD *)(v16 + 60) - 1;
      if (v25 >= 6) {
        int v26 = 0;
      }
      else {
        int v26 = dword_1B8347E34[v25];
      }
      uint64_t v96 = 0;
      *(_OWORD *)__p = 0u;
      long long v95 = 0u;
      HGRendererOutput::HGRendererOutput((uint64_t)__p, *(void *)(v16 + 16), *(void *)(v16 + 32), *(void *)(v16 + 40), *(_DWORD *)(v16 + 48), v26);
      uint64_t v19 = v89;
      if ((unint64_t)v89 < v90)
      {
LABEL_13:
        long long v13 = *(_OWORD *)__p;
        long long v14 = v95;
        *((void *)v19 + 4) = v96;
        *(_OWORD *)uint64_t v19 = v13;
        *((_OWORD *)v19 + 1) = v14;
        float64x2_t v15 = v19 + 40;
        goto LABEL_14;
      }
      int v20 = (char *)v88;
      unint64_t v27 = 0xCCCCCCCCCCCCCCCDLL * ((v89 - (unsigned char *)v88) >> 3);
      unint64_t v28 = v27 + 1;
      if (v27 + 1 > 0x666666666666666) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      if (0x999999999999999ALL * ((uint64_t)(v90 - (void)v88) >> 3) > v28) {
        unint64_t v28 = 0x999999999999999ALL * ((uint64_t)(v90 - (void)v88) >> 3);
      }
      if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v90 - (void)v88) >> 3) >= 0x333333333333333) {
        unint64_t v23 = 0x666666666666666;
      }
      else {
        unint64_t v23 = v28;
      }
      if (v23)
      {
        if (v23 > 0x666666666666666) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        int v24 = (char *)operator new(40 * v23);
      }
      else
      {
        int v24 = 0;
      }
      int v29 = &v24[8 * ((v89 - (unsigned char *)v88) >> 3)];
      long long v34 = v95;
      *(_OWORD *)int v29 = *(_OWORD *)__p;
      *((_OWORD *)v29 + 1) = v34;
      *((void *)v29 + 4) = v96;
      dispatch_block_t v31 = &v24[40 * v27];
      if (v19 != v20)
      {
        do
        {
          long long v35 = *(_OWORD *)(v19 - 40);
          long long v36 = *(_OWORD *)(v19 - 24);
          *((void *)v31 - 1) = *((void *)v19 - 1);
          *(_OWORD *)(v31 - 24) = v36;
          *(_OWORD *)(v31 - 40) = v35;
          v31 -= 40;
          v19 -= 40;
        }
        while (v19 != v20);
        goto LABEL_46;
      }
    }
    uint64_t v37 = &v24[40 * v23];
    float64x2_t v15 = v29 + 40;
    uint64_t v88 = v31;
    uint64_t v89 = v29 + 40;
    unint64_t v90 = (unint64_t)v37;
    if (v19) {
      operator delete(v19);
    }
LABEL_14:
    uint64_t v89 = v15;
    ++v11;
  }
  while (v11 != v12);
  HGRenderer::RenderNodes((uint64_t)v7, (const char *)&v88, (char *)1, v17, v18, __p);
  if (!(*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)v7 + 128))(v7, 13))
  {
    uint64_t v48 = 0;
    while (1)
    {
      uint64_t v49 = *(void *)(*((void *)a2 + 38) + v48);
      uint64_t v50 = (char *)__p[0];
      uint64_t v51 = *(void *)((char *)__p[0] + v48);
      if (!v51)
      {
        *(_DWORD *)(v49 + 56) = -999;
        goto LABEL_72;
      }
      (*(void (**)(uint64_t))(*(void *)v51 + 16))(v51);
      uint64_t v52 = *(void *)&v50[v48];
      uint64_t v53 = *(void *)(v49 + 24);
      if (v53) {
        (*(void (**)(uint64_t))(*(void *)v53 + 24))(v53);
      }
      if ((~*(_DWORD *)(v52 + 12) & 0x110) == 0)
      {
        uint64_t v54 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)v7 + 104))(v7, v52);
        (*(void (**)(uint64_t))(*(void *)v52 + 24))(v52);
        uint64_t v52 = v54;
      }
      *(void *)(v49 + 24) = v52;
      if (*(_DWORD *)(v49 + 60) == 3 && (*(unsigned char *)(v52 + 12) & 1) != 0)
      {
        uint64_t v55 = *(unsigned int *)(v49 + 48);
        if (*(_DWORD *)(v52 + 16) != v55)
        {
          BOOL v56 = HGGPURenderer::CreateBuffer((uint64_t)v7, *(HGRect *)(v52 + 20), v55, 0, 0, 0);
          HGGPURenderer::BufferCopyOpenGL(v7, (HGBuffer *)v56, *(HGRect *)(*(void *)(v49 + 24) + 20), *(HGBitmap **)(v49 + 24));
          uint64_t v52 = HGGPURenderer::ConvertToGLTexture(v7, *(HGRect *)(v56 + 20), (HGBitmap *)v56);
          (*(void (**)(char *))(*(void *)v56 + 24))(v56);
          (*(void (**)(void))(**(void **)(v49 + 24) + 24))(*(void *)(v49 + 24));
          *(void *)(v49 + 24) = v52;
        }
      }
      *(unsigned char *)(v49 + 96) = 0;
      *(_DWORD *)(v49 + 56) = 9;
      int v57 = *(_DWORD *)(v52 + 12);
      if ((v57 & 0x31) != 0) {
        break;
      }
      *(_DWORD *)(v49 + 64) = 1;
LABEL_95:
      uint64_t v60 = *(HGGLContext **)(v49 + 88);
      if (v60)
      {
        if (*(_DWORD *)(v49 + 64) == 1) {
          goto LABEL_97;
        }
        uint64_t v61 = *(std::__shared_weak_count **)(v49 + 72);
        if (!v61)
        {
          int v62 = (HGComputeDeviceManager *)HGGLContext::getVirtualScreen(v60);
          HGComputeDeviceManager::GetGPUComputeDeviceForCGLVirtualScreen(v62, &v91);
          uint64_t v64 = v91;
          uint64_t v63 = v92;
          if (v92) {
            atomic_fetch_add_explicit(&v92->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          BOOL v65 = *(std::__shared_weak_count **)(v49 + 80);
          *(void *)(v49 + 72) = v64;
          *(void *)(v49 + 80) = v63;
          if (v65 && !atomic_fetch_add(&v65->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
            std::__shared_weak_count::__release_weak(v65);
          }
          uint64_t v66 = v92;
          if (v92 && !atomic_fetch_add(&v92->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
            std::__shared_weak_count::__release_weak(v66);
          }
          uint64_t v61 = *(std::__shared_weak_count **)(v49 + 72);
        }
      }
      else
      {
        uint64_t v61 = *(std::__shared_weak_count **)(v49 + 72);
        if (!v61 || LODWORD(v61->__shared_owners_) != 1) {
          goto LABEL_72;
        }
        if (*(_DWORD *)(v49 + 64) == 1)
        {
LABEL_97:
          *(unsigned char *)(v49 + 96) = 1;
          *(_DWORD *)(v49 + 56) = 3;
          goto LABEL_72;
        }
      }
      HGRect v67 = (std::__shared_weak_count *)*((void *)a2 + 8);
      if (v61 != v67)
      {
        *(unsigned char *)(v49 + 96) = 1;
        if (v67)
        {
          if (v68)
          {
            HGRect v69 = (std::__shared_weak_count *)*((void *)a2 + 9);
            if (v69)
            {
              atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v61 = *(std::__shared_weak_count **)(v49 + 72);
              if (!v61) {
                goto LABEL_117;
              }
LABEL_120:
              if (!v70)
              {
                uint64_t v61 = 0;
                if (!*(unsigned char *)(*((void *)v87 + 8) + 78)) {
                  goto LABEL_132;
                }
                goto LABEL_125;
              }
              uint64_t v61 = *(std::__shared_weak_count **)(v49 + 80);
              if (v61)
              {
                atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
                if (!*(unsigned char *)(*((void *)v87 + 8) + 78)) {
                  goto LABEL_132;
                }
LABEL_125:
                uint64_t v71 = v68[17];
                if (v71 && v71 == v70[17] && (*(unsigned char *)(*(void *)(v49 + 24) + 12) & 0x21) != 0) {
                  int v72 = 6;
                }
                else {
LABEL_132:
                }
                  int v72 = 5;
                *(_DWORD *)(v49 + 56) = v72;
                if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
                  std::__shared_weak_count::__release_weak(v61);
                }
                if (v69 && !atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
                  std::__shared_weak_count::__release_weak(v69);
                }
                goto LABEL_72;
              }
LABEL_124:
              if (!*(unsigned char *)(*((void *)v87 + 8) + 78)) {
                goto LABEL_132;
              }
              goto LABEL_125;
            }
LABEL_119:
            if (v61) {
              goto LABEL_120;
            }
          }
          else
          {
            HGRect v69 = 0;
            if (v61) {
              goto LABEL_120;
            }
          }
LABEL_117:
          uint64_t v70 = 0;
          goto LABEL_124;
        }
        HGRect v68 = 0;
        HGRect v69 = 0;
        goto LABEL_119;
      }
LABEL_72:
      v48 += 8;
      if (8 * v12 == v48) {
        goto LABEL_53;
      }
    }
    if (v57)
    {
      int v58 = 6;
    }
    else if ((v57 & 0x20) != 0)
    {
      int v58 = 5;
    }
    else
    {
      if ((v57 & 0x10) == 0)
      {
LABEL_91:
        if ((*(_DWORD *)(v49 + 60) - 1) <= 1
          || (uint64_t v59 = *(void *)(v49 + 72)) != 0 && !*(_DWORD *)(v59 + 8))
        {
          *(unsigned char *)(v49 + 96) = 1;
          *(_DWORD *)(v49 + 56) = 4;
        }
        goto LABEL_95;
      }
      int v58 = 3;
    }
    *(_DWORD *)(v49 + 64) = v58;
    goto LABEL_91;
  }
  uint64_t v38 = 0;
  uint64_t v39 = 8 * v12;
  do
  {
    HGRenderNode::SetState(*(void *)(*((void *)a2 + 38) + v38), 8);
    v38 += 8;
  }
  while (v39 != v38);
  (*(void (**)(HGRenderer *, uint64_t, void))(*(void *)v7 + 120))(v7, 13, 0);
LABEL_53:
  uint64_t v40 = (char *)__p[0];
  if (__p[0])
  {
    double v41 = (char *)__p[1];
    uint64_t v42 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        uint64_t v44 = *((void *)v41 - 1);
        v41 -= 8;
        uint64_t v43 = v44;
        if (v44) {
          (*(void (**)(uint64_t))(*(void *)v43 + 24))(v43);
        }
      }
      while (v41 != v40);
      uint64_t v42 = __p[0];
    }
    __p[1] = v40;
    operator delete(v42);
  }
  if (v88)
  {
    uint64_t v89 = (char *)v88;
    operator delete(v88);
  }
LABEL_170:
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&v97);
}

void sub_1B782A52C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a16) {
    (*(void (**)(uint64_t))(*(void *)a16 + 24))(a16);
  }
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)(v17 - 88));
  _Unwind_Resume(a1);
}

void HGRenderExecUnit::ExecuteRenderCPU(HGRenderExecUnit *this, HGRenderJob *a2, uint64_t a3, const char *a4, char *a5)
{
  unint64_t v6 = (uint64_t *)*((void *)a2 + 38);
  unint64_t v7 = *((void *)a2 + 39) - (void)v6;
  unint64_t v8 = v7 >> 3;
  BOOL v9 = (HGRenderer *)*((void *)this + 7);
  if (*((_DWORD *)a2 + 3) == 1 && *((void *)a2 + 22)) {
    BOOL v9 = (HGRenderer *)*((void *)a2 + 22);
  }
  if (v8 == 1)
  {
    uint64_t v10 = *v6;
    HGRenderNode::SetRenderer(*v6, v9);
    uint64_t v11 = *(void *)(v10 + 24);
    if (v11)
    {
      (*(void (**)(HGRenderer *, uint64_t, void))(*(void *)v9 + 64))(v9, v11, *(void *)(v10 + 16));
      if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)v9 + 128))(v9, 13))
      {
        HGRenderNode::SetState(v10, 8);
        (*(void (**)(HGRenderer *, uint64_t, void))(*(void *)v9 + 120))(v9, 13, 0);
      }
      else
      {
        *(unsigned char *)(v10 + 96) = 0;
        *(_DWORD *)(v10 + 56) = 9;
        *(_DWORD *)(v10 + 64) = *(_DWORD *)(v10 + 60);
      }
      return;
    }
    if (*(_DWORD *)(v10 + 60) == 6)
    {
      HGCVBitmap::create(*(void *)(v10 + 32), *(void *)(v10 + 40), *(_DWORD *)(v10 + 48), __p);
      if (__p[0])
      {
        (*(void (**)(void *))(*(void *)__p[0] + 16))(__p[0]);
        uint64_t v54 = (HGCVBitmap *)__p[0];
      }
      else
      {
        uint64_t v54 = 0;
      }
      HGCVBitmap::lock(v54, 0);
      (*(void (**)(HGRenderer *, HGCVBitmap *, void))(*(void *)v9 + 64))(v9, v54, *(void *)(v10 + 16));
      HGCVBitmap::unlock(v54, 0);
      if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)v9 + 128))(v9, 13))
      {
        HGRenderNode::SetState(v10, 8);
        (*(void (**)(HGRenderer *, uint64_t, void))(*(void *)v9 + 120))(v9, 13, 0);
        (*(void (**)(HGCVBitmap *))(*(void *)v54 + 24))(v54);
        uint64_t v70 = *(void *)(v10 + 72);
        if (!v70) {
          goto LABEL_129;
        }
      }
      else
      {
        *(void *)(v10 + 24) = v54;
        *(_DWORD *)(v10 + 64) = 6;
        uint64_t v70 = *(void *)(v10 + 72);
        if (!v70)
        {
LABEL_129:
          if (!*(void *)(v10 + 88))
          {
            *(unsigned char *)(v10 + 96) = 0;
            *(_DWORD *)(v10 + 56) = 9;
            int v77 = __p[0];
            if (!__p[0]) {
              return;
            }
LABEL_134:
            (*(void (**)(void *))(*(void *)v77 + 24))(v77);
            return;
          }
          LOBYTE(v76) = 1;
LABEL_131:
          *(unsigned char *)(v10 + 96) = v76;
          *(_DWORD *)(v10 + 56) = 3;
          int v77 = __p[0];
          if (!__p[0]) {
            return;
          }
          goto LABEL_134;
        }
      }
      int v76 = *(_DWORD *)(v70 + 8);
      if (v76 == 1) {
        goto LABEL_131;
      }
      goto LABEL_129;
    }
    uint64_t v85 = 0;
    *(_OWORD *)__p = 0u;
    long long v84 = 0u;
    HGRendererOutput::HGRendererOutput((uint64_t)__p, *(void *)(v10 + 16), *(void *)(v10 + 32), *(void *)(v10 + 40), *(_DWORD *)(v10 + 48), 0);
    HGRenderer::RenderNode(v9, (const HGRendererOutput *)__p, (char *)1, &v80);
    if (v80)
    {
      (*(void (**)(void *))(*(void *)v80 + 16))(v80);
      uint64_t v60 = v80;
    }
    else
    {
      uint64_t v60 = 0;
    }
    *(void *)(v10 + 24) = v60;
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)v9 + 128))(v9, 13))
    {
      HGRenderNode::SetState(v10, 8);
      (*(void (**)(HGRenderer *, uint64_t, void))(*(void *)v9 + 120))(v9, 13, 0);
      uint64_t v71 = *(void *)(v10 + 24);
      if (v71)
      {
        (*(void (**)(uint64_t))(*(void *)v71 + 24))(v71);
        *(void *)(v10 + 24) = 0;
      }
      int v72 = v80;
      if (!v80) {
        return;
      }
LABEL_138:
      (*(void (**)(void *))(*(void *)v72 + 24))(v72);
      return;
    }
    if (*(void *)(v10 + 24))
    {
      *(_DWORD *)(v10 + 64) = 1;
      if (*(_DWORD *)(v10 + 60) != 1)
      {
        uint64_t v73 = *(void *)(v10 + 72);
        if (v73)
        {
          int v74 = *(_DWORD *)(v73 + 8);
          if (v74 == 1) {
            goto LABEL_126;
          }
        }
        if (*(void *)(v10 + 88))
        {
          LOBYTE(v74) = 1;
LABEL_126:
          *(unsigned char *)(v10 + 96) = v74;
          int v75 = 3;
          goto LABEL_137;
        }
      }
      *(unsigned char *)(v10 + 96) = 0;
      int v75 = 9;
    }
    else
    {
      int v75 = -999;
    }
LABEL_137:
    *(_DWORD *)(v10 + 56) = v75;
    int v72 = v80;
    if (!v80) {
      return;
    }
    goto LABEL_138;
  }
  if ((int)v8 < 2) {
    return;
  }
  int v78 = *(unsigned __int8 *)(*v6 + 52);
  int v80 = 0;
  uint64_t v81 = 0;
  float v82 = 0;
  uint64_t v12 = (v7 >> 3);
  if ((v7 >> 3))
  {
    for (uint64_t i = 0; i != v12; ++i)
    {
      uint64_t v17 = *(void *)(*((void *)a2 + 38) + 8 * i);
      HGRenderNode::SetRenderer(v17, v9);
      unint64_t v18 = *(HGCVBitmap **)(v17 + 24);
      if (v18)
      {
        if (*((unsigned char *)v18 + 12))
        {
          HGCVBitmap::lock(v18, 0);
          unint64_t v18 = *(HGCVBitmap **)(v17 + 24);
        }
        (*(void (**)(HGCVBitmap *))(*(void *)v18 + 16))(v18);
        uint64_t v85 = 0;
        *(_OWORD *)__p = 0u;
        long long v84 = 0u;
        HGRendererOutput::HGRendererOutput((HGRendererOutput *)__p, *(HGNode **)(v17 + 16), *(HGBitmap **)(v17 + 24));
        uint64_t v19 = v81;
        if (v81 >= v82)
        {
          int v20 = v80;
          unint64_t v21 = 0xCCCCCCCCCCCCCCCDLL * ((v81 - (unsigned char *)v80) >> 3);
          unint64_t v22 = v21 + 1;
          if (v21 + 1 > 0x666666666666666) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          if (0x999999999999999ALL * ((v82 - (unsigned char *)v80) >> 3) > v22) {
            unint64_t v22 = 0x999999999999999ALL * ((v82 - (unsigned char *)v80) >> 3);
          }
          if (0xCCCCCCCCCCCCCCCDLL * ((v82 - (unsigned char *)v80) >> 3) >= 0x333333333333333) {
            unint64_t v23 = 0x666666666666666;
          }
          else {
            unint64_t v23 = v22;
          }
          if (v23)
          {
            if (v23 > 0x666666666666666) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            int v24 = (char *)operator new(40 * v23);
          }
          else
          {
            int v24 = 0;
          }
          unint64_t v28 = &v24[40 * v21];
          long long v29 = v84;
          *(_OWORD *)unint64_t v28 = *(_OWORD *)__p;
          *((_OWORD *)v28 + 1) = v29;
          *((void *)v28 + 4) = v85;
          long long v30 = v28;
          if (v19 != v20)
          {
            do
            {
              long long v31 = *(_OWORD *)((char *)v19 - 40);
              long long v32 = *(_OWORD *)((char *)v19 - 24);
              *((void *)v30 - 1) = *((void *)v19 - 1);
              *(_OWORD *)(v30 - 24) = v32;
              *(_OWORD *)(v30 - 40) = v31;
              v30 -= 40;
              uint64_t v19 = (_OWORD *)((char *)v19 - 40);
            }
            while (v19 != v20);
            goto LABEL_59;
          }
          goto LABEL_60;
        }
      }
      else
      {
        if (*(_DWORD *)(v17 + 60) == 6)
        {
          HGCVBitmap::create(*(void *)(v17 + 32), *(void *)(v17 + 40), *(_DWORD *)(v17 + 48), &v79);
          if (v79)
          {
            (*(void (**)(HGCVBitmap *))(*(void *)v79 + 16))(v79);
            int v25 = v79;
          }
          else
          {
            int v25 = 0;
          }
          HGCVBitmap::lock(v25, 0);
          uint64_t v85 = 0;
          *(_OWORD *)__p = 0u;
          long long v84 = 0u;
          HGRendererOutput::HGRendererOutput((HGRendererOutput *)__p, *(HGNode **)(v17 + 16), (HGBitmap *)v25);
          long long v33 = v81;
          if (v81 >= v82)
          {
            uint64_t v37 = v80;
            unint64_t v38 = 0xCCCCCCCCCCCCCCCDLL * ((v81 - (unsigned char *)v80) >> 3);
            unint64_t v39 = v38 + 1;
            if (v38 + 1 > 0x666666666666666) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            if (0x999999999999999ALL * ((v82 - (unsigned char *)v80) >> 3) > v39) {
              unint64_t v39 = 0x999999999999999ALL * ((v82 - (unsigned char *)v80) >> 3);
            }
            if (0xCCCCCCCCCCCCCCCDLL * ((v82 - (unsigned char *)v80) >> 3) >= 0x333333333333333) {
              unint64_t v40 = 0x666666666666666;
            }
            else {
              unint64_t v40 = v39;
            }
            if (v40)
            {
              if (v40 > 0x666666666666666) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              double v41 = (char *)operator new(40 * v40);
            }
            else
            {
              double v41 = 0;
            }
            int v45 = &v41[40 * v38];
            long long v46 = v84;
            *(_OWORD *)int v45 = *(_OWORD *)__p;
            *((_OWORD *)v45 + 1) = v46;
            *((void *)v45 + 4) = v85;
            uint64_t v47 = v45;
            if (v33 != v37)
            {
              do
              {
                long long v48 = *(_OWORD *)((char *)v33 - 40);
                long long v49 = *(_OWORD *)((char *)v33 - 24);
                *((void *)v47 - 1) = *((void *)v33 - 1);
                *(_OWORD *)(v47 - 24) = v49;
                *(_OWORD *)(v47 - 40) = v48;
                v47 -= 40;
                long long v33 = (_OWORD *)((char *)v33 - 40);
              }
              while (v33 != v37);
              long long v33 = v37;
            }
            long long v36 = v45 + 40;
            int v80 = v47;
            uint64_t v81 = v45 + 40;
            float v82 = &v41[40 * v40];
            if (v33) {
              operator delete(v33);
            }
          }
          else
          {
            long long v34 = *(_OWORD *)__p;
            long long v35 = v84;
            *((void *)v81 + 4) = v85;
            *long long v33 = v34;
            v33[1] = v35;
            long long v36 = (char *)v33 + 40;
          }
          uint64_t v81 = v36;
          if (v79) {
            (*(void (**)(HGCVBitmap *))(*(void *)v79 + 24))(v79);
          }
          continue;
        }
        uint64_t v85 = 0;
        *(_OWORD *)__p = 0u;
        long long v84 = 0u;
        HGRendererOutput::HGRendererOutput((uint64_t)__p, *(void *)(v17 + 16), *(void *)(v17 + 32), *(void *)(v17 + 40), *(_DWORD *)(v17 + 48), 0);
        uint64_t v19 = v81;
        if (v81 >= v82)
        {
          int v20 = v80;
          unint64_t v26 = 0xCCCCCCCCCCCCCCCDLL * ((v81 - (unsigned char *)v80) >> 3);
          unint64_t v27 = v26 + 1;
          if (v26 + 1 > 0x666666666666666) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          if (0x999999999999999ALL * ((v82 - (unsigned char *)v80) >> 3) > v27) {
            unint64_t v27 = 0x999999999999999ALL * ((v82 - (unsigned char *)v80) >> 3);
          }
          if (0xCCCCCCCCCCCCCCCDLL * ((v82 - (unsigned char *)v80) >> 3) >= 0x333333333333333) {
            unint64_t v23 = 0x666666666666666;
          }
          else {
            unint64_t v23 = v27;
          }
          if (v23)
          {
            if (v23 > 0x666666666666666) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            int v24 = (char *)operator new(40 * v23);
          }
          else
          {
            int v24 = 0;
          }
          unint64_t v28 = &v24[40 * v26];
          long long v42 = v84;
          *(_OWORD *)unint64_t v28 = *(_OWORD *)__p;
          *((_OWORD *)v28 + 1) = v42;
          *((void *)v28 + 4) = v85;
          long long v30 = v28;
          if (v19 != v20)
          {
            do
            {
              long long v43 = *(_OWORD *)((char *)v19 - 40);
              long long v44 = *(_OWORD *)((char *)v19 - 24);
              *((void *)v30 - 1) = *((void *)v19 - 1);
              *(_OWORD *)(v30 - 24) = v44;
              *(_OWORD *)(v30 - 40) = v43;
              v30 -= 40;
              uint64_t v19 = (_OWORD *)((char *)v19 - 40);
            }
            while (v19 != v20);
LABEL_59:
            uint64_t v19 = v20;
          }
LABEL_60:
          uint64_t v16 = v28 + 40;
          int v80 = v30;
          uint64_t v81 = v28 + 40;
          float v82 = &v24[40 * v23];
          if (v19) {
            operator delete(v19);
          }
          goto LABEL_12;
        }
      }
      long long v14 = *(_OWORD *)__p;
      long long v15 = v84;
      *((void *)v19 + 4) = v85;
      *uint64_t v19 = v14;
      v19[1] = v15;
      uint64_t v16 = (char *)v19 + 40;
LABEL_12:
      uint64_t v81 = v16;
    }
  }
  HGRenderer::RenderNodes((uint64_t)v9, (const char *)&v80, (char *)(v78 != 0), a4, a5, __p);
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)v9 + 128))(v9, 13))
  {
    if (v12)
    {
      uint64_t v50 = 0;
      uint64_t v51 = 8 * v12;
      uint64_t v52 = 8;
      do
      {
        HGRenderNode::SetState(*(void *)(*((void *)a2 + 38) + v50), 8);
        uint64_t v53 = *(void *)((char *)v80 + v52);
        if (v53) {
          (*(void (**)(uint64_t))(*(void *)v53 + 24))(v53);
        }
        v50 += 8;
        v52 += 40;
      }
      while (v51 != v50);
    }
    (*(void (**)(HGRenderer *, uint64_t, void))(*(void *)v9 + 120))(v9, 13, 0);
    goto LABEL_80;
  }
  if (v12)
  {
    uint64_t v61 = 0;
    uint64_t v62 = 8 * v12;
    uint64_t v63 = 8;
    do
    {
      uint64_t v64 = *(void *)(*((void *)a2 + 38) + v61);
      uint64_t v65 = *(void *)(v64 + 24);
      if (v65) {
        (*(void (**)(void))(*(void *)v65 + 24))(*(void *)(v64 + 24));
      }
      uint64_t v66 = (char *)__p[0];
      HGRect v67 = *(HGCVBitmap **)((char *)__p[0] + v61);
      if (v67)
      {
        (*(void (**)(HGCVBitmap *))(*(void *)v67 + 16))(v67);
        HGRect v67 = *(HGCVBitmap **)&v66[v61];
      }
      *(void *)(v64 + 24) = v67;
      uint64_t v68 = *(void *)((char *)v80 + v63);
      if (v68)
      {
        (*(void (**)(void))(*(void *)v68 + 24))(*(void *)((char *)v80 + v63));
        HGRect v67 = *(HGCVBitmap **)(v64 + 24);
      }
      if (*((unsigned char *)v67 + 12))
      {
        HGCVBitmap::unlock(v67, 0);
        *(_DWORD *)(v64 + 64) = 6;
        *(unsigned char *)(v64 + 96) = 0;
        *(_DWORD *)(v64 + 56) = 9;
        if (!v65)
        {
LABEL_105:
          if (*(_DWORD *)(v64 + 60) != 1
            && ((uint64_t v69 = *(void *)(v64 + 72)) != 0 && *(_DWORD *)(v69 + 8) == 1 || *(void *)(v64 + 88)))
          {
            *(unsigned char *)(v64 + 96) = 1;
            *(_DWORD *)(v64 + 56) = 3;
          }
        }
      }
      else
      {
        *(_DWORD *)(v64 + 64) = 1;
        *(unsigned char *)(v64 + 96) = 0;
        *(_DWORD *)(v64 + 56) = 9;
        if (!v65) {
          goto LABEL_105;
        }
      }
      v61 += 8;
      v63 += 40;
    }
    while (v62 != v61);
  }
LABEL_80:
  uint64_t v55 = (char *)__p[0];
  if (__p[0])
  {
    BOOL v56 = (char *)__p[1];
    int v57 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        uint64_t v59 = *((void *)v56 - 1);
        v56 -= 8;
        uint64_t v58 = v59;
        if (v59) {
          (*(void (**)(uint64_t))(*(void *)v58 + 24))(v58);
        }
      }
      while (v56 != v55);
      int v57 = __p[0];
    }
    __p[1] = v55;
    operator delete(v57);
  }
  if (v80)
  {
    uint64_t v81 = (char *)v80;
    operator delete(v80);
  }
}

void sub_1B782B248(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (!__p) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN16HGRenderExecUnit7RunLoopEv_block_invoke(uint64_t a1)
{
}

void HGRenderExecUnit::FinalizeRenderNodes(HGRenderExecUnit *this, HGRenderJob *a2)
{
  uint64_t v4 = (HGGPURenderer *)*((void *)this + 7);
  if (*((_DWORD *)a2 + 3) == 1 && *((void *)a2 + 22)) {
    uint64_t v4 = (HGGPURenderer *)*((void *)a2 + 22);
  }
  uint64_t v5 = *((void *)a2 + 39) - *((void *)a2 + 38);
  if (v5)
  {
    unint64_t v6 = 0;
    unint64_t v7 = v5 >> 3;
    unsigned int v8 = 1;
    do
    {
      uint64_t v9 = *(void *)(*((void *)a2 + 38) + 8 * v6);
      if (*(unsigned char *)(v9 + 96))
      {
        int v10 = *(_DWORD *)(v9 + 56);
        if ((v10 - 4) < 2)
        {
          long long v13 = (const void *)*((void *)this + 6);
          if (v13)
          {
            if (v14)
            {
              uint64_t FrameStats = (uint64_t *)PVRenderJob::GetFrameStats(v14);
              uint64_t v16 = (std::__shared_weak_count *)FrameStats[1];
              uint64_t v23 = *FrameStats;
              int v24 = v16;
              if (v16) {
                atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              HGGPURenderer::GetCurrentContext(v4, (uint64_t *)&v22);
              uint64_t v17 = (HGGLContext **)HGObject::operator new(0x30uLL);
              v21.unsigned int var0 = v22.var0;
              HGGPUReadbackJob::HGGPUReadbackJob(v17, &v23, &v21, v9);
              PCSharedCount::PCSharedCount(&v21);
              HGRenderQueue::EnqueueGPUReadbackJob(*((HGRenderQueue **)this + 8), v17);
              (*((void (**)(HGGLContext **))*v17 + 3))(v17);
              PCSharedCount::PCSharedCount(&v22);
              unint64_t v18 = v24;
              if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
                std::__shared_weak_count::__release_weak(v18);
              }
            }
          }
          goto LABEL_7;
        }
        if (v10 == 6)
        {
          uint64_t v11 = (HGRenderJob *)HGObject::operator new(0x160uLL);
          HGRenderJob::HGRenderJob(v11);
          HGRenderJob::AddRenderNodeInternal(v11, (HGRenderNode *)v9);
          HGUserJob::SetPriority((uint64_t)v11, 3);
          HGUserJob::SetState((uint64_t)v11, 6);
          HGRenderJob::SetComputeDevice((uint64_t)v11, (uint64_t *)(v9 + 72));
          HGRenderJob::SetPriority((uint64_t)v11, 11);
LABEL_25:
          HGRenderNode::CallNotifyFunc((const char *)v9);
          if (HGRenderQueue::EnqueueRenderJob(*((HGRenderQueue **)this + 8), v11))
          {
            *(_DWORD *)(v9 + 56) = -997;
            HGRenderNode::CallNotifyFunc((const char *)v9);
            HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v9);
          }
          (*(void (**)(HGRenderJob *))(*(void *)v11 + 24))(v11);
          goto LABEL_7;
        }
        if (v10 == 3)
        {
          uint64_t v11 = (HGRenderJob *)HGObject::operator new(0x160uLL);
          HGRenderJob::HGRenderJob(v11);
          HGRenderJob::AddRenderNodeInternal(v11, (HGRenderNode *)v9);
          HGUserJob::SetPriority((uint64_t)v11, 2);
          HGUserJob::SetState((uint64_t)v11, 2);
          HGRenderJob::SetPriority((uint64_t)v11, 11);
          uint64_t v12 = *(void *)(v9 + 72);
          if (v12 && *(_DWORD *)(v12 + 8) == 1)
          {
            HGRenderJob::SetComputeDevice((uint64_t)v11, (uint64_t *)(v9 + 72));
          }
          else
          {
            uint64_t v19 = *(HGGLContext **)(v9 + 88);
            if (v19)
            {
              int VirtualScreen = HGGLContext::getVirtualScreen(v19);
              HGRenderJob::SetVirtualScreen(v11, VirtualScreen);
            }
          }
          goto LABEL_25;
        }
      }
      else
      {
        HGRenderNode::CallNotifyFunc((const char *)v9);
        HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v9);
      }
LABEL_7:
      unint64_t v6 = v8++;
    }
    while (v7 > v6);
  }
}

void sub_1B782B68C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10, char a11)
{
  PCSharedCount::PCSharedCount((PCSharedCount *)&a9);
  HGObject::operator delete(v11);
  PCSharedCount::PCSharedCount(&a10);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1B782B6B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B782B6CC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B782B6E0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B782B6F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10, char a11)
{
}

uint64_t HGRenderExecUnit::ExecuteCopyCPUBitmapToGPUTexture(uint64_t this, HGRenderNode *a2)
{
  uint64_t v3 = this;
  if (!*((void *)a2 + 3))
  {
    if (!*((void *)a2 + 17)) {
      return this;
    }
    uint64_t v11 = mach_absolute_time();
    uint64_t v12 = v11;
    if ((*(unsigned char *)(*(void *)(v3 + 64) + 70) & 2) != 0) {
      printf("Executing PBO-to-GPU Buffer Copy Job <%p>:    %llu\n", *((const void **)a2 + 24), v11);
    }
    kdebug_trace();
    long long v13 = (HGPBOBitmap *)HGObject::operator new(0x88uLL);
    HGPBOBitmap::HGPBOBitmap(v13, *((HGPixelBufferObj **)a2 + 17));
    uint64_t v14 = (*(uint64_t (**)(void, HGPBOBitmap *))(**(void **)(v3 + 56) + 104))(*(void *)(v3 + 56), v13);
    (*(void (**)(HGPBOBitmap *))(*(void *)v13 + 24))(v13);
    long long v15 = (HGTiming *)mach_absolute_time();
    double v16 = HGTiming::GetMachTimeConversionFactor(v15) * (double)((unint64_t)v15 - v12);
    *((double *)a2 + 15) = v16;
    *((double *)a2 + 13) = *((double *)a2 + 13) + v16;
    if ((*(unsigned char *)(*(void *)(v3 + 64) + 70) & 2) != 0) {
      printf("Completed PBO-to-GPU Buffer Copy Job <%p>:    %llu  %5.1f ms\n", *((const void **)a2 + 24), v15, v16 * 1000.0);
    }
    this = kdebug_trace();
    if (v14)
    {
      uint64_t v17 = (const void *)*((void *)a2 + 3);
      if (v17)
      {
        HGRenderQueue::EnqueueDeleteHGGLTexture(*(HGRenderQueue **)(v3 + 64), v18);
      }
      *((void *)a2 + 3) = v14;
      *((_DWORD *)a2 + 14) = 9;
      *((_DWORD *)a2 + 16) = 3;
      HGPixelBufferObj::ReleaseDataPtr(*((HGPixelBufferObj **)a2 + 17));
      this = (uint64_t)HGRenderQueue::ReleasePBOToSharedPool(*(HGRenderQueue **)(v3 + 64), *((HGPixelBufferObj **)a2 + 17));
      *((void *)a2 + 17) = 0;
      if ((*(unsigned char *)(*(void *)(v3 + 64) + 70) & 4) == 0) {
        return this;
      }
    }
    else
    {
      *((_DWORD *)a2 + 14) = -997;
      if ((*(unsigned char *)(*(void *)(v3 + 64) + 70) & 4) == 0) {
        return this;
      }
    }
    uint64_t v25 = *((void *)a2 + 24);
    float32x2_t v26 = vcvt_f32_f64(vmulq_f64(*((float64x2_t *)a2 + 7), (float64x2_t)vdupq_n_s64(0x408F400000000000uLL)));
    unint64_t v27 = *(const char **)(v3 + 16);
    if (*((_DWORD *)a2 + 14) == -997) {
      unint64_t v28 = "kXGPUCopy *ERROR*  ";
    }
    else {
      unint64_t v28 = "kXGPUCopyFinished  ";
    }
    double v29 = vaddv_f32(v26);
    double v30 = v26.f32[0];
    double v31 = v26.f32[1];
    int v32 = *(_DWORD *)(v25 + 184);
    UserName = HGRenderJob::GetUserName((HGRenderJob *)v25);
    return printf("%s : %s: from vs=%d   time: %5.1f (ms)  download time: %5.1f (ms)  upload time: %5.1f (ms) '%s'\n", v27, v28, v32, v29, v30, v31, UserName);
  }
  uint64_t v4 = mach_absolute_time();
  uint64_t v6 = v4;
  if ((*(unsigned char *)(*(void *)(v3 + 64) + 70) & 2) != 0) {
    printf("Executing CPU-to-GPU Buffer Copy Job <%p>:    %llu\n", *((const void **)a2 + 24), v4);
  }
  uint64_t v7 = *((void *)a2 + 3);
  unsigned int v8 = *(void **)(v3 + 56);
  if (v8) {
  int v9 = *((_DWORD *)a2 + 15);
  }
  if (v9)
  {
    if (v9 == 3 || v9 == 6 && *(_DWORD *)(*((void *)a2 + 24) + 100) == 1)
    {
      BOOL v10 = v9 == 6;
      goto LABEL_23;
    }
    BOOL v19 = v9 == 6;
  }
  else
  {
    BOOL v19 = 0;
    BOOL v10 = 0;
    if (*(_DWORD *)(*((void *)a2 + 24) + 100) == 1)
    {
LABEL_23:
      GLint Texture = (HGMetalContext *)HGGPURenderer::GetGLTexture((HGGPURenderer *)v8, (HGBitmap *)v7, v5);
      mach_absolute_time();
      *((void *)a2 + 15) = 0;
      int v21 = 1;
      v22.n128_u64[0] = 0;
      BOOL v19 = v10;
      if ((*(unsigned char *)(*(void *)(v3 + 64) + 70) & 2) == 0) {
        goto LABEL_43;
      }
LABEL_30:
      if (((v21 ^ 1) & 1) != 0 || !v19)
      {
        if ((v19 | v21 ^ 1))
        {
          if ((v21 | !v19)) {
            printf("Completed CPU-to-GPU Buffer Copy Job <%p>: MTLTexture    :  %llu  %5.1f ms\n");
          }
          else {
            printf("Completed CPU-to-GPU Buffer Copy Job <%p>: MTL-IOSurface :  %llu  %5.1f ms\n");
          }
        }
        else
        {
          printf("Completed CPU-to-GPU Buffer Copy Job <%p>: GLTexture     :  %llu  %5.1f ms\n");
        }
      }
      else
      {
        printf("Completed CPU-to-GPU Buffer Copy Job <%p>: GL-IOSurface  :  %llu  %5.1f ms\n");
      }
      goto LABEL_43;
    }
  }
  MetalContext = (HGMetalTexture *)HGGPURenderer::GetMetalContext((HGGPURenderer *)v8);
  *(void *)&v45.unsigned int var0 = *(void *)(v7 + 28);
  *(void *)&v45.int var2 = 1;
  HGMetalTexture::createFromBitmap(MetalContext, (HGMetalContext *)0xD, *(HGBitmap **)(v7 + 20), v45, v7, 1, &v44);
  if (v44)
  {
    (*(void (**)(HGMetalContext *))(*(void *)v44 + 16))(v44);
    GLint Texture = v44;
    if (v44) {
      (*(void (**)(HGMetalContext *))(*(void *)v44 + 24))(v44);
    }
  }
  else
  {
    GLint Texture = 0;
  }
  int v24 = (HGTiming *)mach_absolute_time();
  v22.n128_f64[0] = HGTiming::GetMachTimeConversionFactor(v24);
  int v21 = 0;
  v22.n128_f64[0] = v22.n128_f64[0] * (double)((unint64_t)v24 - v6);
  *((void *)a2 + 15) = v22.n128_u64[0];
  *((double *)a2 + 13) = *((double *)a2 + 13) + v22.n128_f64[0];
  v22.n128_f64[0] = v22.n128_f64[0] * 1000.0;
  if ((*(unsigned char *)(*(void *)(v3 + 64) + 70) & 2) != 0) {
    goto LABEL_30;
  }
LABEL_43:
  if (*((_DWORD *)a2 + 14) == 5 && (*(unsigned char *)(*(void *)(v3 + 64) + 70) & 4) != 0)
  {
    uint64_t v34 = *((void *)a2 + 24);
    float32x2_t v35 = vcvt_f32_f64(vmulq_f64(*((float64x2_t *)a2 + 7), (float64x2_t)vdupq_n_s64(0x408F400000000000uLL)));
    long long v36 = *(const char **)(v3 + 16);
    double v37 = vaddv_f32(v35);
    double v38 = v35.f32[0];
    double v39 = v35.f32[1];
    int v40 = *(_DWORD *)(v34 + 184);
    double v41 = HGRenderJob::GetUserName((HGRenderJob *)v34);
    printf("%s : %s: from vs=%d   time: %5.1f (ms)  download time: %5.1f (ms)  upload time: %5.1f (ms) '%s'\n", v36, "kXGPUCopyFinished  ", v40, v37, v38, v39, v41);
  }
  this = (*(uint64_t (**)(uint64_t, __n128))(*(void *)v7 + 24))(v7, v22);
  if (GLTexture)
  {
    *((void *)a2 + 3) = GLTexture;
    *((_DWORD *)a2 + 14) = 9;
    int v42 = *((_DWORD *)GLTexture + 3);
    if (v42)
    {
      int v43 = 6;
    }
    else if ((v42 & 0x20) != 0)
    {
      int v43 = 5;
    }
    else
    {
      if ((v42 & 0x10) == 0) {
        return this;
      }
      int v43 = 3;
    }
    *((_DWORD *)a2 + 16) = v43;
  }
  else
  {
    *((void *)a2 + 3) = 0;
    *((_DWORD *)a2 + 14) = -997;
  }
  return this;
}

void sub_1B782BD00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    (*(void (**)(uint64_t))(*(void *)a16 + 24))(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN16HGRenderExecUnit7RunLoopEv_block_invoke_2(uint64_t a1)
{
  return HGRenderJob::CallNotifyFunc(*(HGRenderJob **)(a1 + 32));
}

void *std::shared_ptr<HGComputeDevice const>::operator=[abi:ne180100]<HGGPUComputeDevice const,void>(void *result, uint64_t *a2)
{
  uint64_t v2 = result;
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::__shared_weak_count *)result[1];
  *BOOL result = v4;
  result[1] = v3;
  if (v5)
  {
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
      return v2;
    }
  }
  return result;
}

void *HGToGPUComputeDevicePtr@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  BOOL result = *(void **)a1;
  if (result
  {
    uint64_t v5 = *(void *)(a1 + 8);
    *a2 = result;
    a2[1] = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return result;
}

void HGRenderJob::HGRenderJob(HGRenderJob *this)
{
  HGObject::HGObject((HGObject *)this);
  *(void *)uint64_t v1 = &unk_1F10E0828;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 20) = 1;
  *(_OWORD *)(v1 + 24) = 0u;
  *(_OWORD *)(v1 + 40) = 0u;
  *(_OWORD *)(v1 + 56) = 0u;
  *(_OWORD *)(v1 + 72) = 0u;
  *(_OWORD *)(v1 + 88) = 0u;
  *(_OWORD *)(v1 + 104) = xmmword_1B8347E60;
  *(void *)(v1 + 120) = 0;
  *(void *)(v1 + 128) = 0xFFFFFFFFLL;
  *(_DWORD *)(v1 + 136) = 1;
  *(_OWORD *)(v1 + 152) = 0u;
  *(_OWORD *)(v1 + 168) = 0u;
  *(void *)(v1 + 184) = 0;
  *(_DWORD *)(v1 + 192) = -9999;
  *(_DWORD *)(v1 + 196) = -16777215;
  *(_OWORD *)(v1 + 216) = 0u;
  *(_OWORD *)(v1 + 232) = 0u;
  *(_OWORD *)(v1 + 248) = 0u;
  *(_OWORD *)(v1 + 200) = 0u;
  *(void *)(v1 + 280) = 0;
  *(_OWORD *)(v1 + 264) = 0u;
  *(void *)(v1 + 344) = 0;
  *(_OWORD *)(v1 + 312) = 0u;
  *(_OWORD *)(v1 + 328) = 0u;
  *(_OWORD *)(v1 + 296) = 0u;
  operator new();
}

void sub_1B782BF88(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  MEMORY[0x1BA9BFBA0](v4, 0x10A1C40BBCAB520);
  uint64_t v6 = *(void **)(v1 + 328);
  if (v6)
  {
    *(void *)(v1 + 336) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(void **)(v1 + 304);
  if (v7)
  {
    *(void *)(v1 + 312) = v7;
    operator delete(v7);
  }
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v1 + 80);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v1 + 64);
  std::vector<std::shared_ptr<HGComputeDevice const>>::~vector[abi:ne180100]((void **)(v1 + 40));
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v2);
  HGObject::~HGObject((HGObject *)v1);
  _Unwind_Resume(a1);
}

void HGRenderJob::~HGRenderJob(HGRenderJob *this)
{
  *(void *)this = &unk_1F10E0828;
  uint64_t v2 = *((void *)this + 39);
  if (v2 != *((void *)this + 38))
  {
    unint64_t v3 = 0;
    unsigned int v4 = 1;
    uint64_t v2 = *((void *)this + 38);
    do
    {
      (*(void (**)(void))(**(void **)(v2 + 8 * v3) + 24))(*(void *)(v2 + 8 * v3));
      unint64_t v3 = v4;
      uint64_t v2 = *((void *)this + 38);
      ++v4;
    }
    while (v3 < (*((void *)this + 39) - v2) >> 3);
  }
  *((void *)this + 39) = v2;
  *((void *)this + 31) = 0;
  uint64_t v5 = *((void *)this + 36);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 27);
  if (v6) {
    free(v6);
  }
  uint64_t v7 = *((void *)this + 37);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  unsigned int v8 = (void *)*((void *)this + 41);
  if (v8)
  {
    *((void *)this + 42) = v8;
    operator delete(v8);
  }
  int v9 = (void *)*((void *)this + 38);
  if (v9)
  {
    *((void *)this + 39) = v9;
    operator delete(v9);
  }
  BOOL v10 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v12 = *((void *)this + 5);
  if (v12)
  {
    uint64_t v13 = *((void *)this + 6);
    uint64_t v14 = (void *)*((void *)this + 5);
    if (v13 != v12)
    {
      do
      {
        long long v15 = *(std::__shared_weak_count **)(v13 - 8);
        if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
        v13 -= 16;
      }
      while (v13 != v12);
      uint64_t v14 = (void *)*((void *)this + 5);
    }
    *((void *)this + 6) = v12;
    operator delete(v14);
  }
  double v16 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v1;
  uint64_t vars8;

  HGRenderJob::~HGRenderJob(this);

  HGObject::operator delete(v1);
}

const char *HGRenderJob::GetTypeLabel(HGRenderJob *this)
{
  uint64_t v1 = *((int *)this + 3);
  if (v1 > 8) {
    return "?????? unknown job type ???????";
  }
  else {
    return off_1E616CF18[v1];
  }
}

void HGRenderJob::AddRenderNode(HGRenderJob *this, HGRenderNode *a2)
{
  (*(void (**)(HGRenderNode *))(*(void *)a2 + 16))(a2);
  uint64_t v5 = (char *)*((void *)this + 39);
  unint64_t v4 = *((void *)this + 40);
  uint64_t v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    *(void *)uint64_t v5 = a2;
    uint64_t v7 = (uint64_t)(v5 + 8);
    goto LABEL_23;
  }
  unsigned int v8 = (char *)*((void *)this + 38);
  uint64_t v9 = (v5 - v8) >> 3;
  unint64_t v10 = v9 + 1;
  if ((unint64_t)(v9 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v11 = v4 - (void)v8;
  if (v11 >> 2 > v10) {
    unint64_t v10 = v11 >> 2;
  }
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v12 = v10;
  }
  if (v12)
  {
    if (v12 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v13 = (char *)operator new(8 * v12);
    uint64_t v14 = &v13[8 * v9];
    long long v15 = &v13[8 * v12];
    *(void *)uint64_t v14 = a2;
    uint64_t v7 = (uint64_t)(v14 + 8);
    double v16 = (char *)(v5 - v8);
    if (v5 == v8) {
      goto LABEL_21;
    }
    goto LABEL_14;
  }
  uint64_t v13 = 0;
  uint64_t v14 = (char *)(8 * v9);
  long long v15 = 0;
  *(void *)(8 * v9) = a2;
  uint64_t v7 = 8 * v9 + 8;
  double v16 = (char *)(v5 - v8);
  if (v5 != v8)
  {
LABEL_14:
    unint64_t v17 = (unint64_t)(v16 - 8);
    if (v17 < 0x58) {
      goto LABEL_32;
    }
    if ((unint64_t)(v8 - v13) < 0x20) {
      goto LABEL_32;
    }
    uint64_t v18 = (v17 >> 3) + 1;
    uint64_t v19 = 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v6 = &v5[-v19];
    v14 -= v19;
    int v20 = &v13[8 * v9 - 16];
    int v21 = (long long *)(v5 - 16);
    uint64_t v22 = v18 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v23 = *v21;
      *((_OWORD *)v20 - 1) = *(v21 - 1);
      *(_OWORD *)int v20 = v23;
      v20 -= 32;
      v21 -= 2;
      v22 -= 4;
    }
    while (v22);
    if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_32:
      do
      {
        uint64_t v24 = *((void *)v6 - 1);
        v6 -= 8;
        *((void *)v14 - 1) = v24;
        v14 -= 8;
      }
      while (v6 != v8);
    }
    uint64_t v6 = (char *)*((void *)this + 38);
  }
LABEL_21:
  *((void *)this + 38) = v14;
  *((void *)this + 39) = v7;
  *((void *)this + 40) = v15;
  if (v6) {
    operator delete(v6);
  }
LABEL_23:
  *((void *)this + 39) = v7;
  *((void *)this + 31) = (v7 - *((void *)this + 38)) >> 3;
  uint64_t v25 = (HGRenderer *)*((void *)this + 22);
  if (v25)
  {
    HGRenderNode::SetRenderer((uint64_t)a2, v25);
  }
}

void HGRenderJob::AddRenderNodeInternal(HGRenderJob *this, HGRenderNode *a2)
{
  (*(void (**)(HGRenderNode *))(*(void *)a2 + 16))(a2);
  uint64_t v5 = (char *)*((void *)this + 39);
  unint64_t v4 = *((void *)this + 40);
  uint64_t v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    *(void *)uint64_t v5 = a2;
    uint64_t v7 = (uint64_t)(v5 + 8);
    goto LABEL_23;
  }
  unsigned int v8 = (char *)*((void *)this + 38);
  uint64_t v9 = (v5 - v8) >> 3;
  unint64_t v10 = v9 + 1;
  if ((unint64_t)(v9 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v11 = v4 - (void)v8;
  if (v11 >> 2 > v10) {
    unint64_t v10 = v11 >> 2;
  }
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v12 = v10;
  }
  if (v12)
  {
    if (v12 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v13 = (char *)operator new(8 * v12);
    uint64_t v14 = &v13[8 * v9];
    long long v15 = &v13[8 * v12];
    *(void *)uint64_t v14 = a2;
    uint64_t v7 = (uint64_t)(v14 + 8);
    double v16 = (char *)(v5 - v8);
    if (v5 == v8) {
      goto LABEL_21;
    }
    goto LABEL_14;
  }
  uint64_t v13 = 0;
  uint64_t v14 = (char *)(8 * v9);
  long long v15 = 0;
  *(void *)(8 * v9) = a2;
  uint64_t v7 = 8 * v9 + 8;
  double v16 = (char *)(v5 - v8);
  if (v5 != v8)
  {
LABEL_14:
    unint64_t v17 = (unint64_t)(v16 - 8);
    if (v17 < 0x58) {
      goto LABEL_32;
    }
    if ((unint64_t)(v8 - v13) < 0x20) {
      goto LABEL_32;
    }
    uint64_t v18 = (v17 >> 3) + 1;
    uint64_t v19 = 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v6 = &v5[-v19];
    v14 -= v19;
    int v20 = &v13[8 * v9 - 16];
    int v21 = (long long *)(v5 - 16);
    uint64_t v22 = v18 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v23 = *v21;
      *((_OWORD *)v20 - 1) = *(v21 - 1);
      *(_OWORD *)int v20 = v23;
      v20 -= 32;
      v21 -= 2;
      v22 -= 4;
    }
    while (v22);
    if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_32:
      do
      {
        uint64_t v24 = *((void *)v6 - 1);
        v6 -= 8;
        *((void *)v14 - 1) = v24;
        v14 -= 8;
      }
      while (v6 != v8);
    }
    uint64_t v6 = (char *)*((void *)this + 38);
  }
LABEL_21:
  *((void *)this + 38) = v14;
  *((void *)this + 39) = v7;
  *((void *)this + 40) = v15;
  if (v6) {
    operator delete(v6);
  }
LABEL_23:
  *((void *)this + 39) = v7;
  uint64_t v25 = (HGRenderer *)*((void *)this + 22);
  if (v25)
  {
    HGRenderNode::SetRenderer((uint64_t)a2, v25);
  }
}

void HGRenderJob::SetComputeDevice(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 32);
  *(void *)(a1 + 24) = v3;
  *(void *)(a1 + 32) = v2;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t HGRenderJob::SetGPUGraphicsAPI(uint64_t result, int a2)
{
  *(_DWORD *)(result + 100) = a2;
  return result;
}

uint64_t HGRenderJob::SetPriority(uint64_t result, int a2)
{
  *(_DWORD *)(result + 104) = a2;
  return result;
}

uint64_t HGRenderJob::SetRenderThreadPriority(uint64_t result, int a2)
{
  *(_DWORD *)(result + 112) = a2;
  return result;
}

uint64_t HGRenderJob::SetCustomJobThreadPriority(uint64_t result, int a2)
{
  *(_DWORD *)(result + 116) = a2;
  return result;
}

uint64_t HGRenderJob::SetGLContextPriority(uint64_t result, int a2)
{
  *(_DWORD *)(result + 128) = a2;
  return result;
}

uint64_t HGRenderJob::SetProcessingBufferPrecision(uint64_t result, int a2)
{
  *(_DWORD *)(result + 132) = a2;
  return result;
}

uint64_t HGRenderJob::SetMetalShaderPrecision(uint64_t result, int a2)
{
  *(_DWORD *)(result + 136) = a2;
  return result;
}

HGRenderJob *HGRenderJob::SetRenderer(HGRenderJob *this, HGRenderer *a2)
{
  uint64_t v3 = this;
  *((void *)this + 22) = a2;
  uint64_t v4 = *((void *)this + 38);
  if (*((void *)this + 39) != v4)
  {
    unint64_t v5 = 0;
    unsigned int v6 = 1;
    do
    {
      this = (HGRenderJob *)HGRenderNode::SetRenderer(*(void *)(v4 + 8 * v5), a2);
      unint64_t v5 = v6;
      uint64_t v4 = *((void *)v3 + 38);
      ++v6;
    }
    while (v5 < (*((void *)v3 + 39) - v4) >> 3);
  }
  if (a2)
  {
    this = (HGRenderJob *)(*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2);
    if (this) {
      int v7 = 1;
    }
    else {
      int v7 = 2;
    }
    *((_DWORD *)v3 + 4) = v7;
  }
  return this;
}

HGRenderJob *HGRenderJob::SetVirtualScreen(HGRenderJob *this, int a2)
{
  if ((a2 & 0x80000000) == 0) {
    *((_DWORD *)this + 47) = 1 << a2;
  }
  return this;
}

HGRenderJob *HGRenderJob::SetGraphConcatenationFlag(HGRenderJob *this, char a2)
{
  *((unsigned char *)this + 196) = a2;
  return this;
}

uint64_t HGRenderJob::SetState(uint64_t result, int a2)
{
  *(_DWORD *)(result + 108) = a2;
  return result;
}

HGRenderJob *HGRenderJob::SetUserTag(HGRenderJob *this, uint64_t a2)
{
  *((void *)this + 25) = a2;
  return this;
}

HGRenderJob *HGRenderJob::SetUserData(HGRenderJob *this, void *a2)
{
  *((void *)this + 26) = a2;
  return this;
}

void HGRenderJob::SetUserName(HGRenderJob *this, const char *__s1)
{
  uint64_t v4 = (void *)*((void *)this + 27);
  if (v4)
  {
    free(v4);
    *((void *)this + 27) = 0;
  }
  if (__s1) {
    *((void *)this + 27) = strdup(__s1);
  }
}

HGRenderJob *HGRenderJob::SetNotifyFunc(HGRenderJob *this, void (*a2)(HGRenderJob *))
{
  *((void *)this + 30) = a2;
  return this;
}

HGRenderJob *HGRenderJob::SetDumpHeliumGraphLevel(HGRenderJob *this, int a2)
{
  *((_DWORD *)this + 68) = a2;
  return this;
}

HGRenderJob *HGRenderJob::SetDumpHeliumDotGraphLevel(HGRenderJob *this, int a2)
{
  *((_DWORD *)this + 69) = a2;
  return this;
}

uint64_t HGRenderJob::GetState(HGRenderJob *this)
{
  return *((unsigned int *)this + 27);
}

uint64_t HGRenderJob::GetUserTag(HGRenderJob *this)
{
  return *((void *)this + 25);
}

uint64_t HGRenderJob::GetUserData(HGRenderJob *this)
{
  return *((void *)this + 26);
}

const char *HGRenderJob::GetUserName(HGRenderJob *this)
{
  if (*((void *)this + 27)) {
    return (const char *)*((void *)this + 27);
  }
  else {
    return "";
  }
}

uint64_t HGRenderJob::GetRenderNodeList(HGRenderJob *this)
{
  return (uint64_t)this + 304;
}

uint64_t HGRenderJob::GetRenderer(HGRenderJob *this)
{
  return *((void *)this + 22);
}

uint64_t HGRenderJob::GetRenderContext(HGRenderJob *this)
{
  return *((void *)this + 29);
}

uint64_t HGRenderJob::CallNotifyFunc(HGRenderJob *this)
{
  uint64_t v2 = mach_absolute_time();
  uint64_t v3 = (void (*)(HGRenderJob *))*((void *)this + 30);
  if (v3) {
    v3(this);
  }
  uint64_t v4 = (HGTiming *)mach_absolute_time();
  double v5 = HGTiming::GetMachTimeConversionFactor(v4) * (double)((unint64_t)v4 - v2);
  unsigned int v6 = (HGSynchronizable *)*((void *)this + 36);
  HGSynchronizable::Lock(v6);
  *((double *)this + 20) = v5 + *((double *)this + 20);
  HGSynchronizable::Unlock(v6);
  uint64_t result = HGRenderQueue::GetDebugQueueVerboseMask(*((HGRenderQueue **)this + 28));
  if ((result & 0x200) != 0)
  {
    int v8 = *((_DWORD *)this + 27);
    if (v8 < 0)
    {
      switch(v8)
      {
        case -1000:
          return printf("RenderJob<%p>::CallNotifyFunc():kStateError  : %5.1f ms\n");
        case -999:
          return printf("RenderJob<%p>::CallNotifyFunc():kStateEnqueueFail  : %5.1f ms\n");
        case -998:
          return printf("RenderJob<%p>::CallNotifyFunc():kStateBufferCopyFail  : %5.1f ms\n");
      }
    }
    else
    {
      switch(v8)
      {
        case 0:
          uint64_t result = printf("RenderJob<%p>::CallNotifyFunc():kStateNoError  : %5.1f ms\n");
          break;
        case 1:
          uint64_t result = printf("RenderJob<%p>::CallNotifyFunc():kStateInitialized  : %5.1f ms\n");
          break;
        case 2:
          uint64_t result = printf("RenderJob<%p>::CallNotifyFunc():kStateQueued  : %5.1f ms\n");
          break;
        case 3:
          uint64_t result = printf("RenderJob<%p>::CallNotifyFunc():kStateDequeued  : %5.1f ms\n");
          break;
        case 4:
          uint64_t result = printf("RenderJob<%p>::CallNotifyFunc():kStateExecuting  : %5.1f ms\n");
          break;
        case 5:
          uint64_t result = printf("RenderJob<%p>::CallNotifyFunc():kStatePaused  : %5.1f ms\n");
          break;
        case 6:
          uint64_t result = printf("RenderJob<%p>::CallNotifyFunc():kStateCancelled  : %5.1f ms\n");
          break;
        case 7:
          uint64_t result = printf("RenderJob<%p>::CallNotifyFunc():kStateRenderFinished  : %5.1f ms\n");
          break;
        case 8:
          uint64_t result = printf("RenderJob<%p>::CallNotifyFunc():kStateFinished  : %5.1f ms\n");
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

HGSynchronizable *HGRenderJob::AddNotifyTime(HGRenderJob *this, double a2)
{
  uint64_t v4 = (HGSynchronizable *)*((void *)this + 36);
  HGSynchronizable::Lock(v4);
  *((double *)this + 20) = *((double *)this + 20) + a2;
  return HGSynchronizable::Unlock(v4);
}

uint64_t HGRenderJob::IsRequestedVirtualScreen(HGRenderJob *this, int a2)
{
  if (a2 < 0) {
    return 0;
  }
  else {
    return (*((_DWORD *)this + 47) >> a2) & 1;
  }
}

BOOL HGRenderJob::UsesOnlyGPUResource(HGRenderJob *this)
{
  int v1 = *((_DWORD *)this + 4);
  if ((v1 - 2) < 4) {
    return 1;
  }
  if (v1 != 6) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3 && *(_DWORD *)(v3 + 8) == 1) {
    return 1;
  }
  if (*((void *)this + 10)) {
    return 1;
  }
  uint64_t v5 = *((void *)this + 5);
  uint64_t v4 = *((void *)this + 6);
  if (v5 == v4) {
    return 0;
  }
  uint64_t v6 = v5 + 16;
  do
  {
    int v7 = *(_DWORD *)(*(void *)(v6 - 16) + 8);
    BOOL result = v7 != 0;
    if (v7) {
      BOOL v8 = v6 == v4;
    }
    else {
      BOOL v8 = 1;
    }
    v6 += 16;
  }
  while (!v8);
  return result;
}

BOOL HGRenderJob::UsesOnlyCPUResource(HGRenderJob *this)
{
  int v1 = *((_DWORD *)this + 4);
  if (v1 == 1) {
    return 1;
  }
  if (v1 != 6) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    if (!*(_DWORD *)(v2 + 8)) {
      return 1;
    }
  }
  uint64_t v4 = *((void *)this + 5);
  uint64_t v3 = *((void *)this + 6);
  if (v4 == v3) {
    return 0;
  }
  uint64_t v5 = v4 + 16;
  do
  {
    int v6 = *(_DWORD *)(*(void *)(v5 - 16) + 8);
    BOOL result = v6 == 0;
    if (v6) {
      BOOL v8 = 1;
    }
    else {
      BOOL v8 = v5 == v3;
    }
    v5 += 16;
  }
  while (!v8);
  return result;
}

uint64_t HGRenderJob::SpecifiesComputeDevices(HGRenderJob *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (*((_DWORD *)this + 4) == 6)
  {
    if (v1) {
      return 1;
    }
    if (*((void *)this + 10)) {
      return 1;
    }
    if (*((void *)this + 5) != *((void *)this + 6)) {
      return 1;
    }
  }
  else
  {
    if (v1) {
      return 1;
    }
    if (*((void *)this + 10)) {
      return 1;
    }
    if (*((void *)this + 5) != *((void *)this + 6)) {
      return 1;
    }
  }
  return 0;
}

BOOL HGRenderJob::HasCPUBufferDestinationsOnly(HGRenderJob *this)
{
  uint64_t v2 = *((void *)this + 38);
  uint64_t v1 = *((void *)this + 39);
  if (v2 == v1) {
    return 1;
  }
  uint64_t v3 = v2 + 8;
  do
  {
    int v4 = *(_DWORD *)(*(void *)(v3 - 8) + 60);
    BOOL result = v4 == 1;
    BOOL v6 = v4 != 1 || v3 == v1;
    v3 += 8;
  }
  while (!v6);
  return result;
}

HGSynchronizable *HGRenderJob::RenderNodeCallback(HGRenderJob *this, HGRenderNode *a2)
{
  uint64_t v3 = (HGSynchronizable *)*((void *)this + 36);
  HGSynchronizable::Lock(v3);
  uint64_t v4 = *((void *)this + 31);
  uint64_t v5 = *((void *)this + 32) + 1;
  *((void *)this + 32) = v5;
  if (v5 == v4)
  {
    if (*((_DWORD *)this + 27) == 7) {
      *((_DWORD *)this + 27) = 8;
    }
    HGRenderJob::CallNotifyFunc(this);
    if (*((_DWORD *)this + 3) == 1) {
      HGSynchronizable::NotifyAll(*((HGSynchronizable **)this + 37));
    }
  }
  return HGSynchronizable::Unlock(v3);
}

void sub_1B782CD64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

unsigned int HGPrefilterUtils::GetPrefilterRadius(unsigned int a1, float a2, float a3)
{
  if (a1 > 3) {
    return 0;
  }
  else {
    return vcvtps_s32_f32((float)(log10f(a2) / -0.30103) * (float)(flt_1B8347EA0[a1] * a3));
  }
}

uint64_t HGPrefilterUtils::GetSeparablePrefilter(unsigned int *a1, unsigned int a2, char a3, float a4, float a5, float a6)
{
  *(float *)&double v13 = log10f(a4);
  if (a2 >= 4)
  {
    unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
    if (v17) {
      HGLogger::log((HGLogger *)"prefilter", (const char *)1, (HGLogger *)"WARNING: Invalid filter kernel", v11, v12, v13);
    }
    goto LABEL_12;
  }
  float v14 = *(float *)&v13 / -0.30103;
  if ((float)(*(float *)&v13 / -0.30103) <= 0.0 || a5 <= 1.0)
  {
    unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
    if (v16) {
      HGLogger::log((HGLogger *)"prefilter", (const char *)1, (HGLogger *)"WARNING: Invalid filter coefficients", v11, v12);
    }
LABEL_12:
    HGLinearFilter2D::HGLinearFilter2D((HGLinearFilter2D *)v56, 0);
    HGLinearFilter2D::operator=((uint64_t)a1, (uint64_t)v56);
    HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)v56);
    return 0;
  }
  uint64_t v19 = (int)a2;
  float v20 = *(float *)((char *)&unk_1B8347E90 + v19 * 4);
  int v21 = vcvtps_s32_f32(v14 * (float)(flt_1B8347EA0[v19] * a5));
  int v22 = 2 * v21;
  BOOL v23 = a6 != 0.0;
  if (a6 == 0.0) {
    uint64_t v24 = (v22 + 1);
  }
  else {
    uint64_t v24 = (v22 + 2);
  }
  HGLinearFilter2D::reset((uint64_t)a1, 0, 0);
  Level = (HGLinearFilter *)HGLogger::getLevel((HGLogger *)"prefilter", v25);
  if (Level)
  {
    unsigned __int8 v29 = atomic_load(HGLogger::_enabled);
    if (v29) {
      HGLogger::log((HGLogger *)"prefilter", (const char *)1, (HGLogger *)"downsample_factor_x=%f num_taps=%d\n", v27, v28, a5, v24);
    }
    unsigned __int8 v30 = atomic_load(HGLogger::_enabled);
    if (v30) {
      HGLogger::log((HGLogger *)"prefilter", (const char *)1, (HGLogger *)"downsample_factor_x=%f coeffx[%d]={\n", v27, v28, a5, v24);
    }
  }
  if ((v21 & 0x80000000) == 0)
  {
    float v31 = v14 * a5;
    if (a2 == 2)
    {
      int v36 = v23 - v21;
      do
      {
        *(float *)v37.i32 = HGLinearFilter::bicubic(Level, (float)((float)v21 - a6) / v31, 0.0, 0.75);
        __int32 v38 = v37.i32[0];
        int8x16_t v39 = HGLinearFilter2D::set((HGLinearFilter2D *)a1, v21, 0, v37, 4);
        v39.i32[0] = v38;
        HGLinearFilter2D::set((HGLinearFilter2D *)a1, v36, 0, *(int32x2_t *)v39.i8, 4);
        --v21;
        ++v36;
      }
      while (v21 != -1);
    }
    else if (a2 == 3)
    {
      int v32 = v23 - v21;
      do
      {
        *(float *)v33.i32 = HGLinearFilter::rect(Level, (float)((float)v21 - a6) / v31, 0.0, 0.0);
        __int32 v34 = v33.i32[0];
        int8x16_t v35 = HGLinearFilter2D::set((HGLinearFilter2D *)a1, v21, 0, v33, 4);
        v35.i32[0] = v34;
        HGLinearFilter2D::set((HGLinearFilter2D *)a1, v32, 0, *(int32x2_t *)v35.i8, 4);
        --v21;
        ++v32;
      }
      while (v21 != -1);
    }
    else
    {
      int v40 = v23 - v21;
      do
      {
        HGLinearFilter::lanczos(Level, (float)((float)v21 - a6) / v31, v20, 0.0);
        __int32 v42 = v41.i32[0];
        int8x16_t v43 = HGLinearFilter2D::set((HGLinearFilter2D *)a1, v21, 0, v41, 4);
        v43.i32[0] = v42;
        HGLinearFilter2D::set((HGLinearFilter2D *)a1, v40, 0, *(int32x2_t *)v43.i8, 4);
        --v21;
        ++v40;
      }
      while (v21 != -1);
    }
  }
  __asm { FMOV            V0.4S, #1.0 }
  HGLinearFilter2D::normalize((uint64_t)a1, 4u, _Q0);
  if (HGLogger::getLevel((HGLogger *)"prefilter", v49))
  {
    uint64_t v52 = a1[2];
    unsigned int v53 = a1[4];
    if ((int)v52 <= (int)(v52 + v53 - 1))
    {
      do
      {
        unsigned __int8 v55 = atomic_load(HGLogger::_enabled);
        if (v55) {
          HGLogger::log((HGLogger *)"prefilter", (const char *)1, (HGLogger *)"[%d] = %f\n", v50, v51, v52, *(float *)(*(void *)a1 + 16 * (int)(v52 - (a1[2] + a1[4] * a1[3]))));
        }
        uint64_t v52 = (v52 + 1);
        --v53;
      }
      while (v53);
    }
    unsigned __int8 v54 = atomic_load(HGLogger::_enabled);
    if (v54) {
      HGLogger::log((HGLogger *)"prefilter", (const char *)1, (HGLogger *)"}\n", v50, v51);
    }
  }
  if (a3) {
    HGLinearFilter2D::transpose((uint64_t)a1);
  }
  return 1;
}

void sub_1B782D1D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)va);
  _Unwind_Resume(a1);
}

void sub_1B782D1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGLinearFilter2D::~HGLinearFilter2D((HGLinearFilter2D *)va);
  _Unwind_Resume(a1);
}

void HGRenderNode::HGRenderNode(HGRenderNode *this)
{
  HGObject::HGObject(this);
  *(void *)uint64_t v1 = &unk_1F10E0878;
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 48) = 24;
  *(unsigned char *)(v1 + 52) = 0;
  *(void *)(v1 + 56) = 1;
  *(_DWORD *)(v1 + 64) = 0;
  *(void *)(v1 + 80) = 0;
  *(void *)(v1 + 88) = 0;
  *(void *)(v1 + 72) = 0;
  *(unsigned char *)(v1 + 96) = 0;
  *(_OWORD *)(v1 + 104) = 0u;
  *(_OWORD *)(v1 + 120) = 0u;
  *(_OWORD *)(v1 + 136) = 0u;
  *(_OWORD *)(v1 + 152) = 0u;
  *(_OWORD *)(v1 + 168) = 0u;
  *(_OWORD *)(v1 + 184) = 0u;
  *(void *)(v1 + 200) = 0;
}

void HGRenderNode::~HGRenderNode(HGRenderNode *this)
{
  *(void *)this = &unk_1F10E0878;
  uint64_t v2 = (HGRenderQueue *)*((void *)this + 25);
  if (v2
    && *((void *)this + 23)
    && (*((void *)this + 2) || *((void *)this + 3) || *((void *)this + 17))
    && *((_DWORD *)this + 14) != 8)
  {
    HGRenderQueue::EnqueueDeleteRenderNode(v2, this);
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 3);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 20);
  if (v5) {
    free(v5);
  }
  BOOL v6 = (HGPixelBufferObj *)*((void *)this + 17);
  if (v6)
  {
    HGPixelBufferObj::ReleaseDataPtr(v6);
    (*(void (**)(void))(**((void **)this + 17) + 24))(*((void *)this + 17));
  }
  uint64_t v7 = *((void *)this + 25);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  uint64_t v8 = *((void *)this + 11);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    unint64_t v10 = this;
  }
  else
  {
    unint64_t v10 = this;
  }
  HGObject::~HGObject(v10);
}

{
  void *v1;
  uint64_t vars8;

  HGRenderNode::~HGRenderNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGRenderNode::SetNode(HGRenderNode *this, HGNode *a2)
{
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  uint64_t result = *((void *)this + 2);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
  }
  *((void *)this + 2) = a2;
  return result;
}

uint64_t HGRenderNode::SetBitmap(HGRenderNode *this, HGBitmap *a2)
{
  if (a2) {
    (*(void (**)(HGBitmap *))(*(void *)a2 + 16))(a2);
  }
  uint64_t result = *((void *)this + 3);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
  }
  *((void *)this + 3) = a2;
  return result;
}

uint64_t HGRenderNode::SetFormat(uint64_t result, int a2)
{
  *(_DWORD *)(result + 48) = a2;
  return result;
}

HGRect *HGRenderNode::SetROI(HGRect *this, HGRect a2)
{
  this[2] = a2;
  return this;
}

uint64_t HGRenderNode::SetFullROIFlag(uint64_t this, char a2)
{
  *(unsigned char *)(this + 52) = a2;
  return this;
}

uint64_t HGRenderNode::SetState(uint64_t result, int a2)
{
  *(_DWORD *)(result + 56) = a2;
  return result;
}

uint64_t HGRenderNode::SetRenderer(uint64_t this, HGRenderer *a2)
{
  *(void *)(this + 184) = a2;
  return this;
}

uint64_t HGRenderNode::SetRenderQueue(HGRenderNode *this, HGRenderQueue *a2)
{
  uint64_t v4 = *((void *)this + 25);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  *((void *)this + 25) = a2;
  uint64_t v5 = *(uint64_t (**)(HGRenderQueue *))(*(void *)a2 + 16);

  return v5(a2);
}

uint64_t HGRenderNode::SetDestination(uint64_t result, int a2)
{
  *(_DWORD *)(result + 60) = a2;
  return result;
}

uint64_t HGRenderNode::SetUserTag(uint64_t this, uint64_t a2)
{
  *(void *)(this + 144) = a2;
  return this;
}

void HGRenderNode::SetUserName(HGRenderNode *this, const char *__s)
{
  uint64_t v4 = (void *)*((void *)this + 20);
  if (v4)
  {
    free(v4);
    *((void *)this + 20) = 0;
  }
  if (__s)
  {
    size_t v5 = strlen(__s);
    BOOL v6 = (char *)malloc_type_malloc(v5 + 1, 0x674E99C9uLL);
    *((void *)this + 20) = v6;
    strcpy(v6, __s);
  }
}

uint64_t HGRenderNode::SetNotifyFunc(uint64_t this, void (*a2)(HGRenderNode *))
{
  *(void *)(this + 168) = a2;
  return this;
}

uint64_t HGRenderNode::GetState(HGRenderNode *this)
{
  return *((unsigned int *)this + 14);
}

uint64_t HGRenderNode::GetRenderer(HGRenderNode *this)
{
  return *((void *)this + 23);
}

const char *HGRenderNode::CallNotifyFunc(const char *this)
{
  if (*((void *)this + 21))
  {
    uint64_t v1 = this;
    uint64_t v2 = mach_absolute_time();
    (*((void (**)(const char *))v1 + 21))(v1);
    uint64_t v3 = (HGTiming *)mach_absolute_time();
    double v4 = HGTiming::GetMachTimeConversionFactor(v3) * (double)((unint64_t)v3 - v2);
    HGRenderJob::AddNotifyTime(*((HGRenderJob **)v1 + 24), v4);
    this = (const char *)HGRenderQueue::GetDebugQueueVerboseMask(*((HGRenderQueue **)v1 + 25));
    if (((unsigned __int16)this & 0x200) != 0)
    {
      int v5 = *((_DWORD *)v1 + 14);
      switch(v5)
      {
        case 0:
          this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateNoError  : %5.1f ms\n");
          break;
        case 1:
          this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateInitialized  : %5.1f ms\n");
          break;
        case 2:
          this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateFinalizingBuffers  : %5.1f ms\n");
          break;
        case 3:
          this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateAsyncGPUUpload  : %5.1f ms\n");
          break;
        case 4:
          this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateAsyncGPUReadback  : %5.1f ms\n");
          break;
        case 5:
          this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateAsyncXGPUBufferCopy  : %5.1f ms\n");
          break;
        case 6:
          this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateAsyncXGMIBufferCopy  : %5.1f ms\n");
          break;
        case 7:
          this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateJobDequeued  : %5.1f ms\n");
          break;
        case 8:
          this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateCancelled  : %5.1f ms\n");
          break;
        case 9:
          this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateFinished  : %5.1f ms\n");
          break;
        default:
          this = "RenderNode<%p>::CallNotifyFunc():kStateError  : %5.1f ms\n";
          switch(v5)
          {
            case -1000:
              goto LABEL_19;
            case -999:
              this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateRenderError  : %5.1f ms\n");
              break;
            case -998:
              this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateBufferSetupError  : %5.1f ms\n");
              break;
            case -997:
              this = (const char *)printf("RenderNode<%p>::CallNotifyFunc():kStateBufferCopyError  : %5.1f ms\n");
              break;
            case -996:
              this = "RenderNode<%p>::CallNotifyFunc():kStateBufferDeleteError  : %5.1f ms\n";
LABEL_19:
              this = (const char *)printf(this, v1, v4 * 1000.0);
              break;
            default:
              return this;
          }
          break;
      }
    }
  }
  return this;
}

uint64_t HGRenderNode::NotifyRenderJobFinished(HGRenderJob **this)
{
  HGRenderJob::RenderNodeCallback(this[24], (HGRenderNode *)this);
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)this[24] + 24);

  return v2();
}

void HGRenderQueue::HGRenderQueue(HGRenderQueue *this)
{
  HGObject::HGObject((HGObject *)this);
  *(void *)uint64_t v1 = &unk_1F10E08C8;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 20) = 1;
  *(_WORD *)(v1 + 41) = 0;
  *(unsigned char *)(v1 + 43) = 0;
  *(void *)(v1 + 48) = 0;
  *(void *)(v1 + 24) = 0;
  *(void *)(v1 + 32) = 0;
  *(void *)(v1 + 56) = 0xFFFFFFFF00000000;
  *(unsigned char *)(v1 + 64) = 1;
  *(_DWORD *)(v1 + 68) = dword_1EB9A20DC;
  *(_DWORD *)(v1 + 72) = 65793;
  *(_WORD *)(v1 + 76) = 0;
  *(unsigned char *)(v1 + 78) = 1;
  *(_DWORD *)(v1 + 80) = 0;
  *(void *)(v1 + 96) = v1 + 96;
  *(void *)(v1 + 104) = v1 + 96;
  *(void *)(v1 + 112) = 0;
  *(void *)(v1 + 136) = v1 + 136;
  *(void *)(v1 + 144) = v1 + 136;
  *(void *)(v1 + 152) = 0;
  *(void *)(v1 + 160) = v1 + 160;
  *(void *)(v1 + 168) = v1 + 160;
  *(void *)(v1 + 176) = 0;
  *(void *)(v1 + 192) = 0;
  *(void *)(v1 + 216) = 0;
  *(void *)(v1 + 208) = 0;
  *(void *)(v1 + 232) = 0;
  *(void *)(v1 + 200) = v1 + 208;
  *(void *)(v1 + 240) = 0;
  *(void *)(v1 + 224) = v1 + 232;
  *(void *)(v1 + 256) = 0;
  *(void *)(v1 + 248) = v1 + 256;
  *(void *)(v1 + 264) = 0;
  *(void *)(v1 + 280) = 0;
  *(void *)(v1 + 272) = v1 + 280;
  *(void *)(v1 + 288) = 0;
  *(_OWORD *)(v1 + 296) = 0u;
  *(_OWORD *)(v1 + 312) = 0u;
  *(_OWORD *)(v1 + 328) = 0u;
  *(void *)(v1 + 368) = v1 + 368;
  *(void *)(v1 + 376) = v1 + 368;
  *(void *)(v1 + 384) = 0;
  *(void *)(v1 + 400) = v1 + 400;
  *(void *)(v1 + 408) = v1 + 400;
  *(void *)(v1 + 464) = 0;
  *(_OWORD *)(v1 + 448) = 0u;
  *(_OWORD *)(v1 + 432) = 0u;
  *(_OWORD *)(v1 + 416) = 0u;
  *(void *)(v1 + 480) = v1 + 480;
  *(void *)(v1 + 488) = v1 + 480;
  *(void *)(v1 + 496) = 0;
  *(_OWORD *)(v1 + 512) = xmmword_1B8347ED0;
  *(void *)(v1 + 528) = 3;
  *(_OWORD *)(v1 + 536) = 0u;
  *(_OWORD *)(v1 + 552) = 0u;
  *(_OWORD *)(v1 + 568) = 0u;
  *(void *)(v1 + 592) = v1 + 592;
  *(void *)(v1 + 600) = v1 + 592;
  *(void *)(v1 + 624) = 0;
  *(void *)(v1 + 632) = 0;
  *(void *)(v1 + 608) = 0;
  *(void *)(v1 + 616) = v1 + 624;
  *(_OWORD *)(v1 + 712) = 0u;
  *(_OWORD *)(v1 + 728) = 0u;
  *(_OWORD *)(v1 + 680) = 0u;
  *(_OWORD *)(v1 + 696) = 0u;
  *(_OWORD *)(v1 + 648) = 0u;
  *(_OWORD *)(v1 + 664) = 0u;
  operator new();
}

void sub_1B782DEA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t *a10, uint64_t *a11, uint64_t *a12, uint64_t *a13, uint64_t a14, uint64_t a15, uint64_t *a16, uint64_t *a17, uint64_t *a18, uint64_t a19, uint64_t a20)
{
  std::deque<HGRef<HGGLContext>>::~deque[abi:ne180100]((uint64_t)v20 + 696);
  std::deque<HGNode *>::~deque[abi:ne180100](v21 + 416);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v21 + 384, *((void **)v20 + 78));
  std::list<HGGPUReadbackJob *>::~list(a10);
  std::deque<HGNode *>::~deque[abi:ne180100](v21 + 304);
  std::list<HGGPUReadbackJob *>::~list(a11);
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)v20 + 424);
  std::list<HGGPUReadbackJob *>::~list(a12);
  std::list<HGGPUReadbackJob *>::~list(a13);
  std::deque<HGNode *>::~deque[abi:ne180100](a14);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v22, *((void **)v20 + 35));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a15, *((void **)v20 + 32));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a20, *((void **)v20 + 29));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a19, *((void **)v20 + 26));
  std::list<HGGPUReadbackJob *>::~list(a16);
  std::list<HGGPUReadbackJob *>::~list(a17);
  std::list<HGGPUReadbackJob *>::~list(a18);
  HGObject::~HGObject(v20);
  _Unwind_Resume(a1);
}

uint64_t ___ZN13HGRenderQueueC2Ev_block_invoke()
{
  Boolean keyExistsAndHasValidFormat = 0;
  CFStringRef v0 = (const __CFString *)*MEMORY[0x1E4F1D3D8];
  int AppIntegerValue = CFPreferencesGetAppIntegerValue(@"HGRenderQueueDebugFlags", (CFStringRef)*MEMORY[0x1E4F1D3D8], &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    dword_1EB9A20DC = AppIntegerValue;
  }
  Boolean keyExistsAndHasValidFormat = 0;
  int AppBooleanValue = CFPreferencesGetAppBooleanValue(@"HGRenderQueueDebugDumpBuffers", v0, &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    LOBYTE(_MergedGlobals_16) = AppBooleanValue != 0;
  }
  Boolean keyExistsAndHasValidFormat = 0;
  uint64_t result = CFPreferencesGetAppBooleanValue(@"HGRenderQueueDebugAlwaysBuffer", v0, &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    HIBYTE(_MergedGlobals_16) = result != 0;
  }
  return result;
}

uint64_t *std::list<HGGPUReadbackJob *>::~list(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        int v5 = (uint64_t *)v2[1];
        operator delete(v2);
        uint64_t v2 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

void HGRenderQueue::~HGRenderQueue(HGRenderQueue *this)
{
  *(void *)this = &unk_1F10E08C8;
  if ((*((unsigned char *)this + 70) & 0x10) != 0)
  {
    uint64_t v2 = *((void *)this + 13);
    if ((HGRenderQueue *)v2 != (HGRenderQueue *)((char *)this + 96))
    {
      int v3 = 0;
      int v4 = 0;
      do
      {
        uint64_t v5 = v2 + 8;
        uint64_t v2 = *(void *)(v2 + 8);
        int v6 = *(_DWORD *)(*(void *)(v5 + 8) + 24);
        if (v6 == 1) {
          ++v4;
        }
        if (v6 == 3) {
          ++v3;
        }
      }
      while ((HGRenderQueue *)v2 != (HGRenderQueue *)((char *)this + 96));
      if (v3 | v4)
      {
        printf("HGRenderQueue::~HGRenderQueue: Warning: Not all RenderExecUnits are in shutdown state: Executing: %d  Waiting: %d\n", v3, v4);
        puts("First call HGRenderQueue::Shutdown() before deleting");
      }
    }
    uint64_t v7 = *((void *)this + 61);
    if ((HGRenderQueue *)v7 != (HGRenderQueue *)((char *)this + 480))
    {
      int v8 = 0;
      int v9 = 0;
      do
      {
        uint64_t v10 = v7 + 8;
        uint64_t v7 = *(void *)(v7 + 8);
        int v11 = *(_DWORD *)(*(void *)(v10 + 8) + 12);
        if (v11 == 2) {
          int v12 = v8 + 1;
        }
        else {
          int v12 = v8;
        }
        if (v11 == 1) {
          ++v9;
        }
        else {
          int v8 = v12;
        }
      }
      while ((HGRenderQueue *)v7 != (HGRenderQueue *)((char *)this + 480));
      if (v8 | v9)
      {
        printf("HGRenderQueue::~HGRenderQueue: Warning: Not all PBODownloadExecUnits are in shutdown state: Executing: %d  Waiting: %d\n", v8, v9);
        puts("First call HGRenderQueue::Shutdown() before deleting");
      }
    }
    uint64_t v13 = *((void *)this + 47);
    if ((HGRenderQueue *)v13 != (HGRenderQueue *)((char *)this + 368))
    {
      int v14 = 0;
      int v15 = 0;
      do
      {
        uint64_t v16 = v13 + 8;
        uint64_t v13 = *(void *)(v13 + 8);
        int v17 = *(_DWORD *)(*(void *)(v16 + 8) + 8);
        if (v17 == 1) {
          ++v15;
        }
        if (v17 == 2) {
          ++v14;
        }
      }
      while ((HGRenderQueue *)v13 != (HGRenderQueue *)((char *)this + 368));
      if (v14 | v15)
      {
        printf("HGRenderQueue::~HGRenderQueue: Warning: Not all UserExecUnits are in shutdown state: Executing: %d  Waiting: %d\n", v14, v15);
        puts("First call HGRenderQueue::Shutdown() before deleting");
      }
    }
  }
  uint64_t v18 = *((void *)this + 63);
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  uint64_t v19 = *((void *)this + 15);
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  uint64_t v20 = *((void *)this + 16);
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  uint64_t v21 = *((void *)this + 49);
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  uint64_t v22 = *((void *)this + 43);
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  }
  uint64_t v23 = *((void *)this + 59);
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  uint64_t v24 = *((void *)this + 80);
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  uint64_t v25 = (TXParagraphStyleFolder_Factory *)*((void *)this + 73);
  if (v25) {
    uint64_t v25 = (TXParagraphStyleFolder_Factory *)(*(uint64_t (**)(TXParagraphStyleFolder_Factory *))(*(void *)v25 + 8))(v25);
  }
  int v26 = TXParagraphStyleFolder_Factory::version(v25);
  if ((v26 & 0x80000000) == 0)
  {
    unint64_t v27 = (uint64_t **)((char *)this + 280);
    for (int i = -1; i != v26; ++i)
    {
      unsigned __int8 v29 = *v27;
      unsigned __int8 v30 = (uint64_t **)((char *)this + 280);
      float v31 = (uint64_t **)((char *)this + 280);
      if (*v27)
      {
        while (1)
        {
          while (1)
          {
            float v31 = (uint64_t **)v29;
            int v32 = *((_DWORD *)v29 + 8);
            if (i >= v32) {
              break;
            }
            unsigned __int8 v29 = *v31;
            unsigned __int8 v30 = v31;
            if (!*v31) {
              goto LABEL_57;
            }
          }
          if (v32 >= i) {
            break;
          }
          unsigned __int8 v29 = v31[1];
          if (!v29)
          {
            unsigned __int8 v30 = v31 + 1;
            goto LABEL_57;
          }
        }
        int v36 = v31[5];
        if (!v36) {
          continue;
        }
      }
      else
      {
LABEL_57:
        int32x2_t v33 = operator new(0x30uLL);
        v33[8] = i;
        *((void *)v33 + 5) = 0;
        *(void *)int32x2_t v33 = 0;
        *((void *)v33 + 1) = 0;
        *((void *)v33 + 2) = v31;
        *unsigned __int8 v30 = (uint64_t *)v33;
        uint64_t v34 = **((void **)this + 34);
        int8x16_t v35 = (uint64_t *)v33;
        if (v34)
        {
          *((void *)this + 34) = v34;
          int8x16_t v35 = *v30;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 35), v35);
        ++*((void *)this + 36);
        int v36 = (uint64_t *)*((void *)v33 + 5);
        if (!v36) {
          continue;
        }
      }
      (*(void (**)(uint64_t *))(*v36 + 8))(v36);
    }
  }
  int32x2_t v37 = (char *)this + 96;
  for (uint64_t j = *((void *)this + 13); (char *)j != v37; uint64_t j = *(void *)(j + 8))
  {
    uint64_t v39 = *(void *)(j + 16);
    if (v39) {
      (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
    }
  }
  int v40 = (char *)this + 480;
  for (uint64_t k = *((void *)this + 61); (char *)k != v40; uint64_t k = *(void *)(k + 8))
  {
    uint64_t v42 = *(void *)(k + 16);
    if (v42) {
      (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
    }
  }
  int8x16_t v43 = (char *)this + 368;
  for (uint64_t m = *((void *)this + 47); (char *)m != v43; uint64_t m = *(void *)(m + 8))
  {
    uint64_t v45 = *(void *)(m + 16);
    if (v45) {
      (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
    }
  }
  if (*((void *)this + 86))
  {
    unint64_t v46 = 0;
    do
    {
      uint64_t v47 = *(void *)(*(void *)(*((void *)this + 82)
                                  + (((v46 + *((void *)this + 85)) >> 6) & 0x3FFFFFFFFFFFFF8))
                      + 8 * ((v46 + *((void *)this + 85)) & 0x1FF));
      (*(void (**)(uint64_t))(*(void *)v47 + 24))(v47);
      ++v46;
    }
    while (*((void *)this + 86) > v46);
  }
  long long v48 = *((void *)this + 93);
  dispatch_time_t v49 = dispatch_time(0, 10000000000);
  if (dispatch_group_wait(v48, v49)) {
    puts("HGRenderQueue::~HGRenderQueue: Warning: dispatch_group _getRenderJobSynchronizer is non zero after waiting 10s, might crash");
  }
  dispatch_release(*((dispatch_object_t *)this + 93));
  std::deque<HGRef<HGGLContext>>::~deque[abi:ne180100]((uint64_t)this + 696);
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)this + 648);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 616, *((void **)this + 78));
  if (*((void *)this + 76))
  {
    uint64_t v50 = (HGRenderQueue *)*((void *)this + 75);
    uint64_t v51 = *((void *)this + 74);
    uint64_t v52 = *(void *)v50;
    *(void *)(v52 + 8) = *(void *)(v51 + 8);
    **(void **)(v51 + 8) = v52;
    *((void *)this + 76) = 0;
    if (v50 != (HGRenderQueue *)((char *)this + 592))
    {
      do
      {
        unsigned int v53 = (HGRenderQueue *)*((void *)v50 + 1);
        operator delete(v50);
        uint64_t v50 = v53;
      }
      while (v53 != (HGRenderQueue *)((char *)this + 592));
    }
  }
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)this + 536);
  if (*((void *)this + 62))
  {
    uint64_t v55 = *((void *)this + 60);
    unsigned __int8 v54 = (char *)*((void *)this + 61);
    uint64_t v56 = *(void *)v54;
    *(void *)(v56 + 8) = *(void *)(v55 + 8);
    **(void **)(v55 + 8) = v56;
    *((void *)this + 62) = 0;
    if (v54 != v40)
    {
      do
      {
        int v57 = (char *)*((void *)v54 + 1);
        operator delete(v54);
        unsigned __int8 v54 = v57;
      }
      while (v57 != v40);
    }
  }
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)this + 424);
  if (*((void *)this + 52))
  {
    uint64_t v59 = *((void *)this + 50);
    uint64_t v58 = (HGRenderQueue *)*((void *)this + 51);
    uint64_t v60 = *(void *)v58;
    *(void *)(v60 + 8) = *(void *)(v59 + 8);
    **(void **)(v59 + 8) = v60;
    *((void *)this + 52) = 0;
    if (v58 != (HGRenderQueue *)((char *)this + 400))
    {
      do
      {
        uint64_t v61 = (HGRenderQueue *)*((void *)v58 + 1);
        operator delete(v58);
        uint64_t v58 = v61;
      }
      while (v61 != (HGRenderQueue *)((char *)this + 400));
    }
  }
  if (*((void *)this + 48))
  {
    uint64_t v63 = *((void *)this + 46);
    uint64_t v62 = (char *)*((void *)this + 47);
    uint64_t v64 = *(void *)v62;
    *(void *)(v64 + 8) = *(void *)(v63 + 8);
    **(void **)(v63 + 8) = v64;
    *((void *)this + 48) = 0;
    if (v62 != v43)
    {
      do
      {
        uint64_t v65 = (char *)*((void *)v62 + 1);
        operator delete(v62);
        uint64_t v62 = v65;
      }
      while (v65 != v43);
    }
  }
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)this + 296);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 272, *((void **)this + 35));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 248, *((void **)this + 32));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 224, *((void **)this + 29));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 200, *((void **)this + 26));
  if (*((void *)this + 22))
  {
    uint64_t v67 = *((void *)this + 20);
    uint64_t v66 = (HGRenderQueue *)*((void *)this + 21);
    uint64_t v68 = *(void *)v66;
    *(void *)(v68 + 8) = *(void *)(v67 + 8);
    **(void **)(v67 + 8) = v68;
    *((void *)this + 22) = 0;
    if (v66 != (HGRenderQueue *)((char *)this + 160))
    {
      do
      {
        uint64_t v69 = (HGRenderQueue *)*((void *)v66 + 1);
        operator delete(v66);
        uint64_t v66 = v69;
      }
      while (v69 != (HGRenderQueue *)((char *)this + 160));
    }
  }
  if (*((void *)this + 19))
  {
    uint64_t v71 = *((void *)this + 17);
    uint64_t v70 = (HGRenderQueue *)*((void *)this + 18);
    uint64_t v72 = *(void *)v70;
    *(void *)(v72 + 8) = *(void *)(v71 + 8);
    **(void **)(v71 + 8) = v72;
    *((void *)this + 19) = 0;
    if (v70 != (HGRenderQueue *)((char *)this + 136))
    {
      do
      {
        uint64_t v73 = (HGRenderQueue *)*((void *)v70 + 1);
        operator delete(v70);
        uint64_t v70 = v73;
      }
      while (v73 != (HGRenderQueue *)((char *)this + 136));
    }
  }
  if (*((void *)this + 14))
  {
    uint64_t v75 = *((void *)this + 12);
    int v74 = (char *)*((void *)this + 13);
    uint64_t v76 = *(void *)v74;
    *(void *)(v76 + 8) = *(void *)(v75 + 8);
    **(void **)(v75 + 8) = v76;
    *((void *)this + 14) = 0;
    if (v74 != v37)
    {
      do
      {
        int v77 = (char *)*((void *)v74 + 1);
        operator delete(v74);
        int v74 = v77;
      }
      while (v77 != v37);
    }
  }

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v1;
  uint64_t vars8;

  HGRenderQueue::~HGRenderQueue(this);

  HGObject::operator delete(v1);
}

uint64_t HGRenderQueue::AddRenderContext(HGRenderQueue *this, HGRenderContext *a2)
{
  uint64_t v5 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v5);
  if (*((_DWORD *)this + 4) != 3 && *((void *)a2 + 9)) {
    operator new();
  }
  HGSynchronizable::Unlock(v5);
  return 0;
}

void sub_1B782EC60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va1);
  _Unwind_Resume(a1);
}

void sub_1B782EC7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B782ECC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11, PCSharedCount a12, char a13, uint64_t a14, HGSynchronizable *a15)
{
  PCSharedCount::PCSharedCount(&a11);
  MEMORY[0x1BA9BFBA0](v15, 0x10E1C404D8AC037);
  PCSharedCount::PCSharedCount(&a12);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  HGSynchronizer::~HGSynchronizer(&a15);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGRenderQueue::SetRunMode(uint64_t a1, int a2)
{
  int v4 = *(HGSynchronizable **)(a1 + 344);
  HGSynchronizable::Lock(v4);
  *(_DWORD *)(a1 + 12) = a2;
  return HGSynchronizable::Unlock(v4);
}

HGSynchronizable *HGRenderQueue::SetPreferredResource(uint64_t a1, int a2)
{
  int v4 = *(HGSynchronizable **)(a1 + 344);
  HGSynchronizable::Lock(v4);
  *(_DWORD *)(a1 + 20) = a2;
  return HGSynchronizable::Unlock(v4);
}

HGRenderQueue *HGRenderQueue::SetSerializeRendersFlag(HGRenderQueue *this, char a2)
{
  *((unsigned char *)this + 73) = a2;
  *((unsigned char *)this + 72) = a2;
  return this;
}

HGRenderQueue *HGRenderQueue::SetRelaxRenderSerializationForPriorityInversionsFlag(HGRenderQueue *this, char a2)
{
  *((unsigned char *)this + 74) = a2;
  return this;
}

HGRenderQueue *HGRenderQueue::SetDebugQueueVerboseMask(HGRenderQueue *this, int a2)
{
  *((_DWORD *)this + 17) = a2;
  return this;
}

uint64_t HGRenderQueue::GetDebugQueueVerboseMask(HGRenderQueue *this)
{
  return *((unsigned int *)this + 17);
}

HGSynchronizable *HGRenderQueue::SetSerializeGPUReadbacksFlag(HGRenderQueue *this, char a2)
{
  int v4 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v4);
  *((unsigned char *)this + 76) = a2;
  return HGSynchronizable::Unlock(v4);
}

HGSynchronizable *HGRenderQueue::SetNumGPUReadbackExecUnitsPerGPURenderer(HGRenderQueue *this, uint64_t a2)
{
  int v4 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v4);
  *((void *)this + 64) = a2;
  return HGSynchronizable::Unlock(v4);
}

HGSynchronizable *HGRenderQueue::SetNumPBOsPerGPUReadbackExecUnit(HGRenderQueue *this, uint64_t a2)
{
  int v4 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v4);
  *((void *)this + 65) = a2;
  return HGSynchronizable::Unlock(v4);
}

HGSynchronizable *HGRenderQueue::SetGPUReadbackQueueThrottleSize(HGRenderQueue *this, uint64_t a2)
{
  int v4 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v4);
  *((void *)this + 66) = a2;
  return HGSynchronizable::Unlock(v4);
}

HGSynchronizable *HGRenderQueue::Start(HGRenderQueue *this)
{
  uint64_t v2 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v2);
  int v3 = *((_DWORD *)this + 4);
  uint64_t result = HGSynchronizable::Unlock(v2);
  if (v3 != 3)
  {
    uint64_t v5 = (HGSynchronizable *)*((void *)this + 43);
    HGSynchronizable::Lock(v5);
    *((_DWORD *)this + 4) = 1;
    for (uint64_t i = *((void *)this + 13); (HGRenderQueue *)i != (HGRenderQueue *)((char *)this + 96); uint64_t i = *(void *)(i + 8))
    {
      uint64_t v7 = *(void *)(i + 16);
      if (!*(_DWORD *)(v7 + 24))
      {
        HGRenderExecUnit::StartRunLoop(*(HGRenderExecUnit **)(i + 16));
        *(_DWORD *)(v7 + 24) = 1;
      }
    }
    for (uint64_t j = *((void *)this + 47); (HGRenderQueue *)j != (HGRenderQueue *)((char *)this + 368); uint64_t j = *(void *)(j + 8))
    {
      uint64_t v9 = *(void *)(j + 16);
      if (!*(_DWORD *)(v9 + 8))
      {
        HGUserExecUnit::StartRunLoop(*(HGUserExecUnit **)(j + 16));
        *(_DWORD *)(v9 + 8) = 1;
      }
    }
    for (uint64_t k = *((void *)this + 61); (HGRenderQueue *)k != (HGRenderQueue *)((char *)this + 480); uint64_t k = *(void *)(k + 8))
    {
      uint64_t v11 = *(void *)(k + 16);
      if (!*(_DWORD *)(v11 + 12))
      {
        HGGPUReadbackExecUnit::StartRunLoop(*(HGGPUReadbackExecUnit **)(k + 16));
        *(_DWORD *)(v11 + 12) = 1;
      }
    }
    HGSynchronizable::Unlock(v5);
    int v12 = (HGSynchronizable *)*((void *)this + 16);
    HGSynchronizable::Lock(v12);
    HGSynchronizable::NotifyAll(v12);
    HGSynchronizable::Unlock(v12);
    uint64_t v13 = (HGSynchronizable *)*((void *)this + 15);
    HGSynchronizable::Lock(v13);
    HGSynchronizable::NotifyAll(v13);
    HGSynchronizable::Unlock(v13);
    int v14 = (HGSynchronizable *)*((void *)this + 49);
    HGSynchronizable::Lock(v14);
    HGSynchronizable::NotifyAll(v14);
    HGSynchronizable::Unlock(v14);
    uint64_t v15 = (HGSynchronizable *)*((void *)this + 63);
    HGSynchronizable::Lock(v15);
    HGSynchronizable::NotifyAll(v15);
    return HGSynchronizable::Unlock(v15);
  }
  return result;
}

void sub_1B782F0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F0C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F0DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F0F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

BOOL HGRenderQueue::IsShuttingDown(HGRenderQueue *this)
{
  uint64_t v1 = this;
  uint64_t v2 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v2);
  LODWORD(v1) = *((_DWORD *)v1 + 4);
  HGSynchronizable::Unlock(v2);
  return v1 == 3;
}

HGSynchronizable *HGRenderQueue::Pause(HGRenderQueue *this)
{
  uint64_t v2 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v2);
  if (*((_DWORD *)this + 4) != 3) {
    *((_DWORD *)this + 4) = 2;
  }
  return HGSynchronizable::Unlock(v2);
}

HGSynchronizable *HGRenderQueue::Restart(HGRenderQueue *this)
{
  uint64_t v2 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v2);
  int v3 = *((_DWORD *)this + 4);
  if (v3 != 3)
  {
    for (uint64_t i = *((void *)this + 13); (HGRenderQueue *)i != (HGRenderQueue *)((char *)this + 96); uint64_t i = *(void *)(i + 8))
    {
      uint64_t v5 = *(void *)(i + 16);
      if (!*(_DWORD *)(v5 + 24))
      {
        HGRenderExecUnit::StartRunLoop(*(HGRenderExecUnit **)(i + 16));
        *(_DWORD *)(v5 + 24) = 1;
      }
    }
    for (uint64_t j = *((void *)this + 47); (HGRenderQueue *)j != (HGRenderQueue *)((char *)this + 368); uint64_t j = *(void *)(j + 8))
    {
      uint64_t v7 = *(void *)(j + 16);
      if (!*(_DWORD *)(v7 + 8))
      {
        HGUserExecUnit::StartRunLoop(*(HGUserExecUnit **)(j + 16));
        *(_DWORD *)(v7 + 8) = 1;
      }
    }
    for (uint64_t k = *((void *)this + 61); (HGRenderQueue *)k != (HGRenderQueue *)((char *)this + 480); uint64_t k = *(void *)(k + 8))
    {
      uint64_t v9 = *(void *)(k + 16);
      if (!*(_DWORD *)(v9 + 12))
      {
        HGGPUReadbackExecUnit::StartRunLoop(*(HGGPUReadbackExecUnit **)(k + 16));
        *(_DWORD *)(v9 + 12) = 1;
      }
    }
    *((_DWORD *)this + 4) = 1;
  }
  uint64_t result = HGSynchronizable::Unlock(v2);
  if (v3 != 3)
  {
    uint64_t v11 = (HGSynchronizable *)*((void *)this + 16);
    HGSynchronizable::Lock(v11);
    HGSynchronizable::NotifyAll(v11);
    HGSynchronizable::Unlock(v11);
    int v12 = (HGSynchronizable *)*((void *)this + 15);
    HGSynchronizable::Lock(v12);
    HGSynchronizable::NotifyAll(v12);
    HGSynchronizable::Unlock(v12);
    uint64_t v13 = (HGSynchronizable *)*((void *)this + 49);
    HGSynchronizable::Lock(v13);
    HGSynchronizable::NotifyAll(v13);
    HGSynchronizable::Unlock(v13);
    int v14 = (HGSynchronizable *)*((void *)this + 63);
    HGSynchronizable::Lock(v14);
    HGSynchronizable::NotifyAll(v14);
    return HGSynchronizable::Unlock(v14);
  }
  return result;
}

void sub_1B782F3A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F3C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F3D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F41C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B782F430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

HGSynchronizable *HGRenderQueue::Drain(HGRenderQueue *this)
{
  uint64_t v2 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v2);
  int v27 = *((_DWORD *)this + 14);
  *((_DWORD *)this + 14) = 0;
  HGSynchronizable::Unlock(v2);
  uint64_t v3 = mach_absolute_time();
  int v4 = (char *)this + 96;
  uint64_t v5 = (char *)this + 368;
  uint64_t v6 = (char *)this + 480;
  do
  {
    uint64_t v7 = (HGSynchronizable *)*((void *)this + 43);
    HGSynchronizable::Lock(v7);
    uint64_t v8 = *((void *)this + 42);
    HGSynchronizable::Unlock(v7);
    BOOL v9 = v8 == 0;
    if (v8)
    {
      uint64_t v10 = *((void *)this + 13);
      if ((char *)v10 == v4)
      {
LABEL_10:
        uint64_t v13 = (HGSynchronizable *)*((void *)this + 16);
        HGSynchronizable::Lock(v13);
        HGSynchronizable::NotifyAll(v13);
        HGSynchronizable::Unlock(v13);
        int v14 = (HGSynchronizable *)*((void *)this + 15);
        HGSynchronizable::Lock(v14);
        HGSynchronizable::NotifyAll(v14);
        HGSynchronizable::Unlock(v14);
      }
      else
      {
        while (1)
        {
          int v11 = *(_DWORD *)(*(void *)(v10 + 16) + 24);
          if (v11 != 4 && v11 != 1) {
            break;
          }
          uint64_t v10 = *(void *)(v10 + 8);
          if ((char *)v10 == v4) {
            goto LABEL_10;
          }
        }
      }
    }
    uint64_t v15 = (HGSynchronizable *)*((void *)this + 59);
    HGSynchronizable::Lock(v15);
    uint64_t v16 = *((void *)this + 58);
    HGSynchronizable::Unlock(v15);
    if (v16)
    {
      uint64_t v17 = *((void *)this + 47);
      if ((char *)v17 == v5)
      {
LABEL_15:
        uint64_t v18 = (HGSynchronizable *)*((void *)this + 49);
        HGSynchronizable::Lock(v18);
        HGSynchronizable::NotifyAll(v18);
        HGSynchronizable::Unlock(v18);
      }
      else
      {
        while (*(_DWORD *)(*(void *)(v17 + 16) + 8) == 1)
        {
          uint64_t v17 = *(void *)(v17 + 8);
          if ((char *)v17 == v5) {
            goto LABEL_15;
          }
        }
      }
      BOOL v9 = 0;
    }
    uint64_t v19 = (HGSynchronizable *)*((void *)this + 73);
    HGSynchronizable::Lock(v19);
    uint64_t v20 = *((void *)this + 72);
    HGSynchronizable::Unlock(v19);
    if (v20)
    {
      uint64_t v21 = *((void *)this + 61);
      if ((char *)v21 == v6)
      {
LABEL_21:
        uint64_t v22 = (HGSynchronizable *)*((void *)this + 63);
        HGSynchronizable::Lock(v22);
        HGSynchronizable::NotifyAll(v22);
        HGSynchronizable::Unlock(v22);
      }
      else
      {
        while (*(_DWORD *)(*(void *)(v21 + 16) + 12) == 1)
        {
          uint64_t v21 = *(void *)(v21 + 8);
          if ((char *)v21 == v6) {
            goto LABEL_21;
          }
        }
      }
      BOOL v9 = 0;
    }
    uint64_t v23 = mach_absolute_time();
    if (qword_1EB9A20F8 != -1) {
      dispatch_once(&qword_1EB9A20F8, &__block_literal_global_90);
    }
    char v24 = *(double *)&qword_1EB9A20F0 * (double)(v23 - v3) >= 5.0 || v9;
  }
  while ((v24 & 1) == 0);
  uint64_t v25 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v25);
  *((_DWORD *)this + 14) = v27;
  return HGSynchronizable::Unlock(v25);
}

void sub_1B782F6B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B782F6D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B782F6E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B782F700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetNumJobsInRenderQueue(HGRenderQueue *this)
{
  uint64_t v2 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v2);
  uint64_t v3 = *((void *)this + 42);
  HGSynchronizable::Unlock(v2);
  return v3;
}

void HGRenderQueue::Shutdown(HGRenderQueue *this)
{
  uint64_t v2 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v2);
  uint64_t v3 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v3);
  int v4 = *((_DWORD *)this + 4);
  HGSynchronizable::Unlock(v3);
  if (v4) {
    *((_DWORD *)this + 4) = 3;
  }
  HGSynchronizable::Unlock(v2);
  if (v4)
  {
    uint64_t v5 = (HGSynchronizable *)*((void *)this + 16);
    HGSynchronizable::Lock(v5);
    HGSynchronizable::NotifyAll(v5);
    HGSynchronizable::Unlock(v5);
    uint64_t v6 = (HGSynchronizable *)*((void *)this + 15);
    HGSynchronizable::Lock(v6);
    HGSynchronizable::NotifyAll(v6);
    HGSynchronizable::Unlock(v6);
    uint64_t v7 = (HGSynchronizable *)*((void *)this + 49);
    HGSynchronizable::Lock(v7);
    HGSynchronizable::NotifyAll(v7);
    HGSynchronizable::Unlock(v7);
    uint64_t v8 = (HGSynchronizable *)*((void *)this + 63);
    HGSynchronizable::Lock(v8);
    HGSynchronizable::NotifyAll(v8);
    HGSynchronizable::Unlock(v8);
    BOOL v9 = (char *)this + 96;
    uint64_t v10 = (char *)this + 368;
    int v11 = (char *)this + 480;
    do
    {
      uint64_t v13 = (HGSynchronizable *)*((void *)this + 43);
      HGSynchronizable::Lock(v13);
      uint64_t v14 = *((void *)this + 13);
      if ((char *)v14 == v9)
      {
LABEL_12:
        BOOL v16 = 1;
        int v12 = 1;
      }
      else
      {
        while (1)
        {
          int v15 = *(_DWORD *)(*(void *)(v14 + 16) + 24);
          BOOL v16 = v15 == 5;
          if (v15 != 5) {
            break;
          }
          uint64_t v14 = *(void *)(v14 + 8);
          if ((char *)v14 == v9) {
            goto LABEL_12;
          }
        }
        int v12 = 0;
      }
      HGSynchronizable::Unlock(v13);
      if (v16)
      {
        uint64_t v17 = (HGSynchronizable *)*((void *)this + 59);
        HGSynchronizable::Lock(v17);
        uint64_t v18 = *((void *)this + 47);
        if ((char *)v18 != v10)
        {
          while (*(_DWORD *)(*(void *)(v18 + 16) + 8) == 3)
          {
            uint64_t v18 = *(void *)(v18 + 8);
            if ((char *)v18 == v10) {
              goto LABEL_19;
            }
          }
          int v12 = 0;
        }
LABEL_19:
        HGSynchronizable::Unlock(v17);
      }
      if (v12)
      {
        uint64_t v19 = (HGSynchronizable *)*((void *)this + 43);
        HGSynchronizable::Lock(v19);
        uint64_t v20 = *((void *)this + 61);
        if ((char *)v20 != v11)
        {
          while (*(_DWORD *)(*(void *)(v20 + 16) + 12) == 3)
          {
            uint64_t v20 = *(void *)(v20 + 8);
            if ((char *)v20 == v11) {
              goto LABEL_6;
            }
          }
          int v12 = 0;
        }
LABEL_6:
        HGSynchronizable::Unlock(v19);
      }
    }
    while (!v12);
    if ((*((unsigned char *)this + 70) & 0x20) != 0)
    {
      uint64_t v21 = *((void *)this + 13);
      if ((char *)v21 != v9)
      {
        int v22 = 0;
        do
        {
          uint64_t v23 = *(void *)(v21 + 16);
          char v24 = *(HGPixelBufferObj **)(v23 + 48);
          if (*((void *)v24 + 15) != *((void *)v24 + 14)
            && (HGPixelBufferObj::format(v24) == 2
             || !HGPixelBufferObj::format(*(HGPixelBufferObj **)(v23 + 48))))
          {
            if (HGRenderContext::IsGPU(*(HGRenderContext **)(v23 + 48)))
            {
              uint64_t v25 = *(PVRenderJob **)(v23 + 48);
              if (v25) {
              uint64_t FrameStats = PVRenderJob::GetFrameStats(v25);
              }
              unint64_t v28 = *(TXParagraphStyleFolder_Factory **)FrameStats;
              int v27 = *(std::__shared_weak_count **)(FrameStats + 8);
              if (v27) {
                atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              TXParagraphStyleFolder_Factory::version(v28);
              HGGPUComputeDevice::GetGLVirtualScreen(v28);
              if (v27)
              {
                if (!atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
                  std::__shared_weak_count::__release_weak(v27);
                }
              }
              printf("\nRender Times Histogram [ms]: GPU Render Context[%i]: vs=%d, attached=%d\n");
            }
            else
            {
              printf("\nRender Times Histogram [ms]: CPU Render Context[%i]\n");
            }
            HGRenderContext::DumpHistogram(*(HGRenderContext **)(v23 + 48));
          }
          ++v22;
          uint64_t v21 = *(void *)(v21 + 8);
        }
        while ((char *)v21 != v9);
      }
    }
  }
}

void sub_1B782FAD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B782FAEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B782FB04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B782FB1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B782FB38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B782FB4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGRenderQueue::DumpRenderJobQueues(HGRenderQueue *this)
{
  uint64_t v2 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v2);
  printf("Queued RenderJobs: [");
  uint64_t v3 = *((void *)this + 38);
  if (*((void *)this + 39) != v3)
  {
    unint64_t v4 = *((void *)this + 41);
    uint64_t v5 = (void *)(v3 + 8 * (v4 >> 9));
    uint64_t v6 = *v5 + 8 * (v4 & 0x1FF);
    uint64_t v7 = *(void *)(v3 + (((*((void *)this + 42) + v4) >> 6) & 0x3FFFFFFFFFFFFF8))
       + 8 * ((*((void *)this + 42) + v4) & 0x1FF);
    while (v6 != v7)
    {
      uint64_t v8 = *(int *)(*(void *)v6 + 12);
      if v8 <= 7 && ((0xBDu >> v8)) {
        printf(off_1E616CFE0[v8]);
      }
      v6 += 8;
      if (v6 - *v5 == 4096)
      {
        uint64_t v9 = v5[1];
        ++v5;
        uint64_t v6 = v9;
      }
    }
  }
  putchar(93);
  printf(" : Active RenderJobs: [");
  for (uint64_t i = *((void *)this + 18); (HGRenderQueue *)i != (HGRenderQueue *)((char *)this + 136); uint64_t i = *(void *)(i + 8))
  {
    if (*(void *)(i + 16)) {
      printf("REN,");
    }
  }
  for (uint64_t j = *((void *)this + 21); (HGRenderQueue *)j != (HGRenderQueue *)((char *)this + 160); uint64_t j = *(void *)(j + 8))
  {
    if (*(void *)(j + 16)) {
      printf("CUS,");
    }
  }
  puts("]");
  return HGSynchronizable::Unlock(v2);
}

uint64_t HGRenderQueue::EnqueueRenderJob(HGRenderQueue *this, HGRenderJob *a2)
{
  int v4 = *((_DWORD *)a2 + 3);
  BOOL v5 = v4 == 8 || v4 == 1;
  if (v5 && !*((void *)a2 + 37)) {
    return 4294966304;
  }
  if (!*((void *)this + 14)) {
    return 4294966296;
  }
  (*(void (**)(HGRenderJob *))(*(void *)a2 + 16))(a2);
  uint64_t v6 = *((void *)a2 + 38);
  if (*((void *)a2 + 39) != v6)
  {
    unint64_t v7 = 0;
    do
    {
      HGRenderNode::SetRenderQueue(*(HGRenderNode **)(v6 + 8 * v7++), this);
      uint64_t v6 = *((void *)a2 + 38);
    }
    while (v7 < (*((void *)a2 + 39) - v6) >> 3);
  }
  uint64_t v8 = (char *)this + 96;
  uint64_t v9 = *((void *)a2 + 22);
  if (!v9)
  {
    if (!HGRenderJob::SpecifiesComputeDevices(a2))
    {
      if (*((_DWORD *)a2 + 4) == 1)
      {
        uint64_t v147 = *((void *)this + 13);
        if ((char *)v147 == v8)
        {
LABEL_79:
          uint64_t v12 = 4294966299;
          goto LABEL_119;
        }
        while (*(_DWORD *)(*(void *)(v147 + 16) + 40) != 1)
        {
          uint64_t v147 = *(void *)(v147 + 8);
          if ((char *)v147 == v8) {
            goto LABEL_79;
          }
        }
      }
      else
      {
        if (HGRenderJob::UsesOnlyGPUResource(a2))
        {
          uint64_t v148 = *((void *)this + 13);
          uint64_t v12 = 4294966300;
          if ((char *)v148 == v8) {
            goto LABEL_119;
          }
          while (1)
          {
            uint64_t v149 = *(void *)(v148 + 16);
            if (HGRenderContext::IsGPU(*(HGRenderContext **)(v149 + 48)))
            {
              if (*((_DWORD *)a2 + 47))
              {
                uint64_t FrameStats = PVRenderJob::GetFrameStats(*(PVRenderJob **)(v149 + 48));
                long long v151 = *(HGGPUComputeDevice **)FrameStats;
                long long v152 = *(std::__shared_weak_count **)(FrameStats + 8);
                uint64_t v169 = *(HGGPUComputeDevice **)FrameStats;
                int v170 = v152;
                if (v152) {
                  atomic_fetch_add_explicit(&v152->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                int GLVirtualScreen = HGGPUComputeDevice::GetGLVirtualScreen(v151);
                IsRequestedint VirtualScreen = HGRenderJob::IsRequestedVirtualScreen(a2, GLVirtualScreen);
                char v155 = IsRequestedVirtualScreen;
                if (IsRequestedVirtualScreen) {
                  uint64_t v12 = HGRenderQueue::EnqueueRenderJobWithPriority(this, a2);
                }
                if (v152 && !atomic_fetch_add(&v152->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v152->__on_zero_shared)(v152);
                  std::__shared_weak_count::__release_weak(v152);
                }
                if (v155) {
                  goto LABEL_118;
                }
              }
              else
              {
                if (*((_DWORD *)a2 + 3) != 2) {
                  goto LABEL_117;
                }
                uint64_t v156 = **((void **)a2 + 38);
                if (*(void *)(v156 + 72))
                {
                  unsigned __int8 v157 = *(PVRenderJob **)(v149 + 48);
                  if (v157) {
                  uint64_t v158 = PVRenderJob::GetFrameStats(v157);
                  }
                  uint64_t v159 = *(HGGPUComputeDevice **)v158;
                  long long v160 = *(std::__shared_weak_count **)(v158 + 8);
                  uint64_t v169 = *(HGGPUComputeDevice **)v158;
                  int v170 = v160;
                  if (v160) {
                    atomic_fetch_add_explicit(&v160->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  if (v159 == *(HGGPUComputeDevice **)(v156 + 72))
                  {
                    uint64_t v12 = HGRenderQueue::EnqueueRenderJobWithPriority(this, a2);
                    std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v169);
                    if (!v12) {
                      goto LABEL_120;
                    }
LABEL_119:
                    *((void *)a2 + 28) = this;
                    HGRenderJob::SetState((uint64_t)a2, -999);
                    HGRenderJob::CallNotifyFunc(a2);
                    goto LABEL_120;
                  }
                  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v169);
                }
                else if (*(void *)(v156 + 88))
                {
                  uint64_t v161 = *(PVRenderJob **)(v149 + 48);
                  if (v161) {
                  uint64_t v162 = PVRenderJob::GetFrameStats(v161);
                  }
                  BOOL v163 = *(HGGPUComputeDevice **)v162;
                  v164 = *(std::__shared_weak_count **)(v162 + 8);
                  uint64_t v169 = v163;
                  int v170 = v164;
                  if (v164) {
                    atomic_fetch_add_explicit(&v164->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  v165 = *(HGGLContext **)(v156 + 88);
                  if (v165)
                  {
                    (*(void (**)(HGGLContext *))(*(void *)v165 + 16))(v165);
                    BOOL v163 = v169;
                  }
                  int v166 = HGGPUComputeDevice::GetGLVirtualScreen(v163);
                  int VirtualScreen = HGGLContext::getVirtualScreen(v165);
                  if (v166 == VirtualScreen) {
                    uint64_t v12 = HGRenderQueue::EnqueueRenderJobWithPriority(this, a2);
                  }
                  if (v165) {
                    (*(void (**)(HGGLContext *))(*(void *)v165 + 24))(v165);
                  }
                  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v169);
                  if (v166 == VirtualScreen) {
                    goto LABEL_118;
                  }
                }
              }
            }
            uint64_t v148 = *(void *)(v148 + 8);
            if ((char *)v148 == v8) {
              goto LABEL_118;
            }
          }
        }
        if (*((_DWORD *)a2 + 4))
        {
          uint64_t v12 = 0;
          goto LABEL_120;
        }
      }
      goto LABEL_117;
    }
    uint64_t v13 = *((void *)this + 13);
    uint64_t v12 = 4294966298;
    if ((char *)v13 == v8) {
      goto LABEL_119;
    }
    while (1)
    {
      uint64_t v14 = *(void *)(*(void *)(v13 + 16) + 48);
      int v15 = *(HGGPUComputeDevice **)(v14 + 16);
      BOOL v16 = *(std::__shared_weak_count **)(v14 + 24);
      uint64_t v169 = v15;
      int v170 = v16;
      if (v16) {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v17 = (HGGPUComputeDevice *)*((void *)a2 + 3);
      if (v17) {
        BOOL v18 = v17 == v15;
      }
      else {
        BOOL v18 = 0;
      }
      if (v18)
      {
LABEL_64:
        uint64_t v12 = HGRenderQueue::EnqueueRenderJobWithPriority(this, a2);
        char v144 = 1;
        if (v16) {
          goto LABEL_67;
        }
        goto LABEL_69;
      }
      uint64_t v19 = (HGGPUComputeDevice *)*((void *)a2 + 10);
      uint64_t v21 = (HGGPUComputeDevice **)*((void *)a2 + 5);
      uint64_t v20 = (char *)*((void *)a2 + 6);
      if (v19 && v19 == v15)
      {
        if (v21 == (HGGPUComputeDevice **)v20) {
          goto LABEL_64;
        }
        unint64_t v22 = v20 - (char *)v21 - 16;
        if (v22 < 0x80)
        {
          LOBYTE(v23) = 0;
          goto LABEL_49;
        }
        unint64_t v25 = v22 >> 4;
        uint64_t v26 = (v22 >> 4) + 1;
        if (v22 >= 0x200)
        {
          unint64_t v32 = 32;
          if ((v26 & 0x1F) != 0) {
            unint64_t v32 = v26 & 0x1F;
          }
          unint64_t v27 = v26 - v32;
          int64x2_t v33 = vdupq_n_s64((unint64_t)v15);
          uint64_t v34 = (const double *)(v21 + 32);
          int8x16_t v35 = 0uLL;
          uint64_t v36 = v26;
          int8x16_t v37 = 0uLL;
          do
          {
            __int32 v38 = v34 - 32;
            unsigned long long v39 = (unsigned __int128)vld2q_f64(v38);
            int v40 = v34 - 28;
            unsigned long long v41 = (unsigned __int128)vld2q_f64(v40);
            uint64_t v42 = v34 - 24;
            unsigned long long v43 = (unsigned __int128)vld2q_f64(v42);
            long long v44 = v34 - 20;
            unsigned long long v45 = (unsigned __int128)vld2q_f64(v44);
            unint64_t v46 = v34 - 16;
            unsigned long long v47 = (unsigned __int128)vld2q_f64(v46);
            long long v48 = v34 - 12;
            unsigned long long v49 = (unsigned __int128)vld2q_f64(v48);
            uint64_t v50 = v34 - 8;
            unsigned long long v51 = (unsigned __int128)vld2q_f64(v50);
            uint64_t v52 = v34 - 4;
            int32x4_t v53 = (int32x4_t)vceqq_s64(v33, (int64x2_t)v45);
            unsigned long long v54 = (unsigned __int128)vld2q_f64(v52);
            uint64_t v55 = v34;
            int16x8_t v56 = (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v33, (int64x2_t)v43), v53);
            unsigned long long v57 = (unsigned __int128)vld2q_f64(v55);
            v55 += 4;
            unsigned long long v58 = (unsigned __int128)vld2q_f64(v55);
            int8x16_t v59 = (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v33, (int64x2_t)v39), (int32x4_t)vceqq_s64(v33, (int64x2_t)v41)), v56);
            uint64_t v60 = v34 + 8;
            unsigned long long v61 = (unsigned __int128)vld2q_f64(v60);
            uint64_t v62 = v34 + 12;
            unsigned long long v63 = (unsigned __int128)vld2q_f64(v62);
            uint64_t v64 = v34 + 16;
            unsigned long long v65 = (unsigned __int128)vld2q_f64(v64);
            int8x16_t v66 = vuzp1q_s8(v59, (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v33, (int64x2_t)v47), (int32x4_t)vceqq_s64(v33, (int64x2_t)v49)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v33, (int64x2_t)v51), (int32x4_t)vceqq_s64(v33, (int64x2_t)v54))));
            uint64_t v67 = v34 + 20;
            int16x8_t v68 = (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v33, (int64x2_t)v61), (int32x4_t)vceqq_s64(v33, (int64x2_t)v63));
            unsigned long long v69 = (unsigned __int128)vld2q_f64(v67);
            uint64_t v70 = v34 + 24;
            int16x8_t v71 = (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v33, (int64x2_t)v57), (int32x4_t)vceqq_s64(v33, (int64x2_t)v58));
            unsigned long long v72 = (unsigned __int128)vld2q_f64(v70);
            uint64_t v73 = v34 + 28;
            unsigned long long v74 = (unsigned __int128)vld2q_f64(v73);
            int8x16_t v35 = vorrq_s8(v66, v35);
            int8x16_t v37 = vorrq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16(v71, v68), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v33, (int64x2_t)v65), (int32x4_t)vceqq_s64(v33, (int64x2_t)v69)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v33, (int64x2_t)v72), (int32x4_t)vceqq_s64(v33, (int64x2_t)v74)))), v37);
            v34 += 64;
            v36 -= 32;
          }
          while (v32 != v36);
          unsigned int v23 = vmaxvq_u8((uint8x16_t)vcltzq_s8(vshlq_n_s8(vorrq_s8(v35, v37), 7uLL))) & 1;
          if (v32 < 9)
          {
            v21 += 2 * v27;
            do
            {
LABEL_49:
              uint64_t v88 = *v21;
              v21 += 2;
              LOBYTE(v23) = (v15 == v88) | v23;
            }
            while (v21 != (HGGPUComputeDevice **)v20);
            goto LABEL_63;
          }
        }
        else
        {
          unsigned int v23 = 0;
          unint64_t v27 = 0;
        }
        uint64_t v75 = v26 & 7;
        if ((v26 & 7) == 0) {
          uint64_t v75 = 8;
        }
        uint64_t v76 = &v21[2 * (v26 - v75)];
        int8x8_t v77 = vdup_n_s8(v23);
        int64x2_t v78 = vdupq_n_s64((unint64_t)v15);
        uint64_t v79 = (const double *)&v21[2 * v27];
        uint64_t v80 = ~v25 + v27 + v75;
        do
        {
          uint64_t v81 = v79;
          unsigned long long v82 = (unsigned __int128)vld2q_f64(v81);
          v81 += 4;
          unsigned long long v83 = (unsigned __int128)vld2q_f64(v81);
          long long v84 = v79 + 8;
          unsigned long long v85 = (unsigned __int128)vld2q_f64(v84);
          int v86 = v79 + 12;
          unsigned long long v87 = (unsigned __int128)vld2q_f64(v86);
          int8x8_t v77 = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v78, (int64x2_t)v82), (int32x4_t)vceqq_s64(v78, (int64x2_t)v83)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v78, (int64x2_t)v85), (int32x4_t)vceqq_s64(v78, (int64x2_t)v87)))), v77);
          v79 += 16;
          v80 += 8;
        }
        while (v80);
        LOBYTE(v23) = vmaxv_u8((uint8x8_t)vcltz_s8(vshl_n_s8(v77, 7uLL))) & 1;
        uint64_t v21 = v76;
        goto LABEL_49;
      }
      if (v21 == (HGGPUComputeDevice **)v20) {
        goto LABEL_66;
      }
      unint64_t v24 = v20 - (char *)v21 - 16;
      if (v24 >= 0x80)
      {
        unint64_t v28 = v24 >> 4;
        uint64_t v29 = (v24 >> 4) + 1;
        int64x2_t v30 = vdupq_n_s64((unint64_t)v15);
        if (v24 < 0x200)
        {
          unsigned int v23 = 0;
          unint64_t v31 = 0;
LABEL_57:
          uint64_t v131 = v29 & 7;
          if ((v29 & 7) == 0) {
            uint64_t v131 = 8;
          }
          unint64_t v132 = &v21[2 * (v29 - v131)];
          int8x8_t v133 = vdup_n_s8(v23);
          unsigned __int8 v134 = (const double *)&v21[2 * v31];
          uint64_t v135 = ~v28 + v31 + v131;
          do
          {
            uint64_t v136 = v134;
            unsigned long long v137 = (unsigned __int128)vld2q_f64(v136);
            v136 += 4;
            unsigned long long v138 = (unsigned __int128)vld2q_f64(v136);
            v139 = v134 + 8;
            unsigned long long v140 = (unsigned __int128)vld2q_f64(v139);
            unint64_t v141 = v134 + 12;
            unsigned long long v142 = (unsigned __int128)vld2q_f64(v141);
            int8x8_t v133 = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v30, (int64x2_t)v137), (int32x4_t)vceqq_s64(v30, (int64x2_t)v138)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v30, (int64x2_t)v140), (int32x4_t)vceqq_s64(v30, (int64x2_t)v142)))), v133);
            v134 += 16;
            v135 += 8;
          }
          while (v135);
          LOBYTE(v23) = vmaxv_u8((uint8x8_t)vcltz_s8(vshl_n_s8(v133, 7uLL))) & 1;
          uint64_t v21 = v132;
          goto LABEL_62;
        }
        unint64_t v89 = 32;
        if ((v29 & 0x1F) != 0) {
          unint64_t v89 = v29 & 0x1F;
        }
        unint64_t v31 = v29 - v89;
        unint64_t v90 = (const double *)(v21 + 32);
        int8x16_t v91 = 0uLL;
        uint64_t v92 = v29;
        int8x16_t v93 = 0uLL;
        do
        {
          uint64_t v94 = v90 - 32;
          unsigned long long v95 = (unsigned __int128)vld2q_f64(v94);
          uint64_t v96 = v90 - 28;
          unsigned long long v97 = (unsigned __int128)vld2q_f64(v96);
          uint64_t v98 = v90 - 24;
          unsigned long long v99 = (unsigned __int128)vld2q_f64(v98);
          uint64_t v100 = v90 - 20;
          unsigned long long v101 = (unsigned __int128)vld2q_f64(v100);
          uint64_t v102 = v90 - 16;
          unsigned long long v103 = (unsigned __int128)vld2q_f64(v102);
          unsigned int v104 = v90 - 12;
          unsigned long long v105 = (unsigned __int128)vld2q_f64(v104);
          double v106 = v90 - 8;
          unsigned long long v107 = (unsigned __int128)vld2q_f64(v106);
          int v108 = v90 - 4;
          int32x4_t v109 = (int32x4_t)vceqq_s64(v30, (int64x2_t)v101);
          unsigned long long v110 = (unsigned __int128)vld2q_f64(v108);
          BOOL v111 = v90;
          int16x8_t v112 = (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v30, (int64x2_t)v99), v109);
          unsigned long long v113 = (unsigned __int128)vld2q_f64(v111);
          v111 += 4;
          unsigned long long v114 = (unsigned __int128)vld2q_f64(v111);
          int8x16_t v115 = (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v30, (int64x2_t)v95), (int32x4_t)vceqq_s64(v30, (int64x2_t)v97)), v112);
          unsigned int v116 = v90 + 8;
          unsigned long long v117 = (unsigned __int128)vld2q_f64(v116);
          id v118 = v90 + 12;
          unsigned long long v119 = (unsigned __int128)vld2q_f64(v118);
          PCSharedCount v120 = v90 + 16;
          unsigned long long v121 = (unsigned __int128)vld2q_f64(v120);
          int8x16_t v122 = vuzp1q_s8(v115, (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v30, (int64x2_t)v103), (int32x4_t)vceqq_s64(v30, (int64x2_t)v105)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v30, (int64x2_t)v107), (int32x4_t)vceqq_s64(v30, (int64x2_t)v110))));
          uint64_t v123 = v90 + 20;
          int16x8_t v124 = (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v30, (int64x2_t)v117), (int32x4_t)vceqq_s64(v30, (int64x2_t)v119));
          unsigned long long v125 = (unsigned __int128)vld2q_f64(v123);
          unint64_t v126 = v90 + 24;
          int16x8_t v127 = (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v30, (int64x2_t)v113), (int32x4_t)vceqq_s64(v30, (int64x2_t)v114));
          unsigned long long v128 = (unsigned __int128)vld2q_f64(v126);
          float32x4_t v129 = v90 + 28;
          unsigned long long v130 = (unsigned __int128)vld2q_f64(v129);
          int8x16_t v91 = vorrq_s8(v122, v91);
          int8x16_t v93 = vorrq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16(v127, v124), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v30, (int64x2_t)v121), (int32x4_t)vceqq_s64(v30, (int64x2_t)v125)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqq_s64(v30, (int64x2_t)v128), (int32x4_t)vceqq_s64(v30, (int64x2_t)v130)))), v93);
          v90 += 64;
          v92 -= 32;
        }
        while (v89 != v92);
        unsigned int v23 = vmaxvq_u8((uint8x16_t)vcltzq_s8(vshlq_n_s8(vorrq_s8(v91, v93), 7uLL))) & 1;
        if (v89 >= 9) {
          goto LABEL_57;
        }
        v21 += 2 * v31;
      }
      else
      {
        LOBYTE(v23) = 0;
      }
      do
      {
LABEL_62:
        v143 = *v21;
        v21 += 2;
        LOBYTE(v23) = (v15 == v143) | v23;
      }
      while (v21 != (HGGPUComputeDevice **)v20);
LABEL_63:
      if (v23) {
        goto LABEL_64;
      }
LABEL_66:
      char v144 = 0;
      if (v16)
      {
LABEL_67:
        if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
LABEL_69:
      if ((v144 & 1) == 0)
      {
        uint64_t v13 = *(void *)(v13 + 8);
        if ((char *)v13 != v8) {
          continue;
        }
      }
      goto LABEL_118;
    }
  }
  uint64_t v10 = *((void *)this + 13);
  if ((char *)v10 == v8)
  {
LABEL_15:
    uint64_t v12 = 4294966297;
    goto LABEL_119;
  }
  while (1)
  {
    uint64_t v11 = *(void *)(v10 + 16);
    if (*(void *)(v11 + 56) == v9) {
      break;
    }
    uint64_t v10 = *(void *)(v10 + 8);
    if ((char *)v10 == v8) {
      goto LABEL_15;
    }
  }
  if (!*((_DWORD *)a2 + 3))
  {
    HGRenderExecUnit::AddEnqueuedRenderJob(*(HGRenderExecUnit **)(v10 + 16), a2);
    if ((*((unsigned char *)this + 69) & 4) != 0)
    {
      int v145 = *(_DWORD *)(v11 + 8);
      uint64_t v146 = HGRenderExecUnit::NumEnqueuedRenderJobs((HGRenderExecUnit *)v11);
      printf("RenderUnit<%d> Enqueue: Count: %lu\n", v145, v146);
    }
  }
LABEL_117:
  uint64_t v12 = HGRenderQueue::EnqueueRenderJobWithPriority(this, a2);
LABEL_118:
  if (v12) {
    goto LABEL_119;
  }
LABEL_120:
  (*(void (**)(HGRenderJob *))(*(void *)a2 + 24))(a2);
  return v12;
}

void sub_1B78306DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B7830734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::EnqueueRenderJobWithPriority(HGRenderQueue *this, HGRenderJob *a2)
{
  int64x2_t v33 = a2;
  if ((*((_DWORD *)a2 + 4) - 3) <= 2)
  {
    if (qword_1EB9A20E8 != -1) {
      dispatch_once(&qword_1EB9A20E8, &__block_literal_global_31);
    }
    *((_DWORD *)a2 + 4) = 2;
  }
  if (*((_DWORD *)a2 + 3) != 4)
  {
    (*(void (**)(HGRenderJob *))(*(void *)a2 + 16))(a2);
    HGRenderJob::SetState((uint64_t)a2, 2);
    *((void *)a2 + 28) = this;
    HGRenderJob::CallNotifyFunc(a2);
  }
  int v4 = (HGSynchronizable *)*((void *)this + 43);
  unint64_t v31 = v4;
  char v32 = 0;
  HGSynchronizable::Lock(v4);
  int v5 = *((_DWORD *)this + 4);
  if (v5 != 3)
  {
    unint64_t v6 = *((void *)this + 41);
    uint64_t v7 = *((void *)this + 38);
    uint64_t v8 = v7 + 8 * (v6 >> 9);
    if (*((void *)this + 39) == v7)
    {
      uint64_t v9 = 0;
      int v12 = 0;
      uint64_t v10 = (int *)((char *)this + 336);
    }
    else
    {
      uint64_t v9 = *(void *)v8 + 8 * (*((void *)this + 41) & 0x1FFLL);
      uint64_t v10 = (int *)((char *)this + 336);
      uint64_t v11 = *(void *)(v7 + (((*((void *)this + 42) + v6) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*((void *)this + 42) + v6) & 0x1FF);
      if (v9 == v11)
      {
        int v12 = 0;
      }
      else
      {
        int v12 = 0;
        while (*((_DWORD *)a2 + 26) <= *(_DWORD *)(*(void *)v9 + 104))
        {
          v9 += 8;
          if (v9 - *(void *)v8 == 4096)
          {
            uint64_t v13 = *(void *)(v8 + 8);
            v8 += 8;
            uint64_t v9 = v13;
          }
          ++v12;
          if (v9 == v11)
          {
            uint64_t v9 = v11;
            break;
          }
        }
      }
    }
    std::deque<HGRenderJob *>::insert((void *)this + 37, (char *)v8, v9, (char *)&v33);
    if ((*((unsigned char *)this + 69) & 4) != 0)
    {
      int v14 = *v10;
      int v15 = v33;
      TypeLabel = HGRenderJob::GetTypeLabel(v33);
      UserName = HGRenderJob::GetUserName(v33);
      printf("EnqueueJob: %p  Type: %s  Queue[%d,%d] '%s'\n", v15, TypeLabel, v12, v14, UserName);
    }
    BOOL v18 = v33;
    if (*((_DWORD *)v33 + 3) <= 1u)
    {
      uint64_t v19 = *((void *)v33 + 38);
      if (*((void *)v33 + 39) != v19)
      {
        unint64_t v20 = 0;
        unsigned int v21 = 1;
        do
        {
          *(void *)(*(void *)(v19 + 8 * v20) + 192) = v18;
          (*(void (**)(HGRenderJob *))(*(void *)v18 + 16))(v18);
          unint64_t v20 = v21;
          BOOL v18 = v33;
          uint64_t v19 = *((void *)v33 + 38);
          ++v21;
        }
        while (v20 < (*((void *)v33 + 39) - v19) >> 3);
      }
      if ((*((unsigned char *)this + 69) & 8) != 0 && *((unsigned char *)this + 352))
      {
        *((unsigned char *)this + 352) = 0;
        uint64_t v22 = mach_absolute_time();
        uint64_t v23 = *((void *)this + 45);
        if (qword_1EB9A20F8 != -1) {
          dispatch_once(&qword_1EB9A20F8, &__block_literal_global_90);
        }
        float v24 = *(double *)&qword_1EB9A20F0 * (double)(v22 - v23) * 1000.0;
        printf("RenderJobQueue Empty Time (ms): %5.1f\n", v24);
      }
    }
  }
  HGSynchronizable::Unlock(v4);
  if (v5 == 3) {
    return 4294966305;
  }
  uint64_t v26 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v26);
  int v27 = *((_DWORD *)this + 4);
  HGSynchronizable::Unlock(v26);
  if (v27 != 2)
  {
    if (HGRenderJob::UsesOnlyGPUResource(v33))
    {
      unint64_t v31 = (HGSynchronizable *)*((void *)this + 16);
      char v32 = 0;
      HGSynchronizable::Lock(v31);
      HGSynchronizable::NotifyAll(v31);
      HGSynchronizable::Unlock(v31);
      return 0;
    }
    if (HGRenderJob::UsesOnlyCPUResource(v33))
    {
      unint64_t v31 = (HGSynchronizable *)*((void *)this + 15);
      char v32 = 0;
      HGSynchronizable::Lock(v31);
      HGSynchronizable::NotifyAll(v31);
      HGSynchronizable::Unlock(v31);
      return 0;
    }
    int v28 = *((_DWORD *)this + 5);
    if (v28 == 2)
    {
      if (*((unsigned char *)this + 42))
      {
        unint64_t v31 = (HGSynchronizable *)*((void *)this + 15);
        char v32 = 0;
        HGSynchronizable::Lock(v31);
        HGSynchronizable::NotifyAll(v31);
        HGSynchronizer::~HGSynchronizer(&v31);
        if ((unint64_t)HGRenderQueue::GetNumJobsInRenderQueue(this) < 2) {
          return 0;
        }
        int64x2_t v30 = (HGSynchronizable *)*((void *)this + 16);
        unint64_t v31 = v30;
        char v32 = 0;
        HGSynchronizable::Lock(v30);
        HGSynchronizable::NotifyAll(v30);
        goto LABEL_44;
      }
    }
    else if (v28 == 1 && *((unsigned char *)this + 41))
    {
      unint64_t v31 = (HGSynchronizable *)*((void *)this + 16);
      char v32 = 0;
      HGSynchronizable::Lock(v31);
      HGSynchronizable::NotifyAll(v31);
      HGSynchronizer::~HGSynchronizer(&v31);
      if ((unint64_t)HGRenderQueue::GetNumJobsInRenderQueue(this) < 2) {
        return 0;
      }
      uint64_t v29 = (HGSynchronizable *)*((void *)this + 15);
      unint64_t v31 = v29;
      char v32 = 0;
      HGSynchronizable::Lock(v29);
      HGSynchronizable::NotifyAll(v29);
LABEL_44:
      HGSynchronizer::~HGSynchronizer(&v31);
      return 0;
    }
    unint64_t v31 = (HGSynchronizable *)*((void *)this + 16);
    char v32 = 0;
    HGSynchronizable::Lock(v31);
    HGSynchronizable::NotifyAll(v31);
    HGSynchronizable::Unlock(v31);
    unint64_t v31 = (HGSynchronizable *)*((void *)this + 15);
    char v32 = 0;
    HGSynchronizable::Lock(v31);
    HGSynchronizable::NotifyAll(v31);
    HGSynchronizable::Unlock(v31);
  }
  return 0;
}

void sub_1B7830BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7830BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7830C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7830C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7830C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7830C4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7830C64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7830C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7830C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7830CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7830CBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7830CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN13HGRenderQueue28EnqueueRenderJobWithPriorityEP11HGRenderJob_block_invoke()
{
  return printf("HGRenderQueue does not support kResourceGPU_AuxOnly or kResourceGPU_PreferAux or kResourceGPU_AttachedOnly");
}

void *std::deque<HGRenderJob *>::insert(void *a1, char *a2, uint64_t a3, char *a4)
{
  unint64_t v6 = a1[4];
  uint64_t v7 = a1[1];
  uint64_t v8 = a1[2];
  uint64_t v9 = (char *)(v7 + 8 * (v6 >> 9));
  if (v8 == v7)
  {
    uint64_t v10 = 0;
    if (a3)
    {
LABEL_3:
      unint64_t v11 = ((a3 - *(void *)a2) >> 3) + ((a2 - v9) << 6) - ((v10 - *(void *)v9) >> 3);
      unint64_t v12 = a1[5];
      unint64_t v13 = v12 - v11;
      if (v11 < v12 - v11) {
        goto LABEL_4;
      }
LABEL_14:
      if (v8 == v7) {
        uint64_t v22 = 0;
      }
      else {
        uint64_t v22 = ((v8 - v7) << 6) - 1;
      }
      if (v22 == v12 + v6)
      {
        std::deque<HGRenderJob *>::__add_back_capacity((uint64_t)a1);
        unint64_t v12 = a1[5];
        unint64_t v13 = v12 - v11;
      }
      if (v12 == v11)
      {
        *(void *)(*(void *)(a1[1] + (((a1[4] + v11) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[4] + v11) & 0x1FF)) = *(void *)a4;
        a1[5] = v11 + 1;
        unint64_t v23 = a1[4];
        uint64_t v24 = a1[1];
        uint64_t result = (void *)(v24 + 8 * (v23 >> 9));
        if (a1[2] != v24) {
          goto LABEL_55;
        }
        goto LABEL_47;
      }
      unsigned long long v63 = a4;
      unint64_t v26 = a1[4] + v12;
      uint64_t v27 = a1[1];
      int v28 = (char *)(v27 + 8 * (v26 >> 9));
      uint64_t v29 = *(void *)v28 + 8 * (v26 & 0x1FF);
      if (a1[2] == v27) {
        int64x2_t v30 = 0;
      }
      else {
        int64x2_t v30 = (char *)v29;
      }
      uint64_t v31 = (uint64_t)&v30[-*(void *)v28];
      uint64_t v32 = v31 >> 3;
      if (v31 < 9)
      {
        unint64_t v51 = 512 - v32;
        uint64_t v34 = &v28[-8 * (v51 >> 9)];
        int8x16_t v35 = (char *)(*(void *)v34 + 8 * (~(_WORD)v51 & 0x1FF));
        if (v35 != a4) {
          goto LABEL_44;
        }
      }
      else
      {
        unint64_t v33 = v32 - 1;
        uint64_t v34 = &v28[8 * (v33 >> 9)];
        int8x16_t v35 = (char *)(*(void *)v34 + 8 * (v33 & 0x1FF));
        if (v35 != a4) {
          goto LABEL_44;
        }
      }
      unsigned long long v63 = v30;
      a4 = v30;
LABEL_44:
      *(void *)int64x2_t v30 = *(void *)v35;
      a1[5] = v12 + 1;
      if (v13 >= 2)
      {
        uint64_t v55 = ((uint64_t)&v30[-*(void *)v28] >> 3) - v13;
        if (v55 < 1)
        {
          unint64_t v61 = 511 - v55;
          int16x8_t v56 = &v28[-8 * (v61 >> 9)];
          unsigned long long v57 = (char *)(*(void *)v56 + 8 * (~(_WORD)v61 & 0x1FF));
        }
        else
        {
          int16x8_t v56 = &v28[8 * ((unint64_t)v55 >> 9)];
          unsigned long long v57 = (char *)(*(void *)v56 + 8 * (v55 & 0x1FF));
        }
        int v28 = std::deque<HGRenderJob *>::__move_backward_and_check((uint64_t)a1, v56, v57, v34, v35, v28, v30, (unint64_t *)&v63);
        int64x2_t v30 = v62;
        uint64_t v52 = *(void *)v63;
        if (v62 != *(char **)v28)
        {
LABEL_46:
          *((void *)v30 - 1) = v52;
          unint64_t v23 = a1[4];
          uint64_t v53 = a1[1];
          uint64_t result = (void *)(v53 + 8 * (v23 >> 9));
          if (a1[2] != v53) {
            goto LABEL_55;
          }
          goto LABEL_47;
        }
      }
      else
      {
        uint64_t v52 = *(void *)a4;
        if (v30 != *(char **)v28) {
          goto LABEL_46;
        }
      }
      int64x2_t v30 = (char *)(*((void *)v28 - 1) + 4096);
      goto LABEL_46;
    }
  }
  else
  {
    uint64_t v10 = *(void *)v9 + 8 * (a1[4] & 0x1FFLL);
    if (a3 != v10) {
      goto LABEL_3;
    }
  }
  unint64_t v11 = 0;
  unint64_t v12 = a1[5];
  unint64_t v13 = v12;
  if (!v12) {
    goto LABEL_14;
  }
LABEL_4:
  if (v6)
  {
    if (v11) {
      goto LABEL_6;
    }
  }
  else
  {
    std::deque<HGRenderJob *>::__add_front_capacity((uint64_t)a1);
    if (v11)
    {
LABEL_6:
      unsigned long long v63 = a4;
      unint64_t v14 = a1[4];
      uint64_t v15 = a1[1];
      BOOL v16 = (char *)(v15 + 8 * (v14 >> 9));
      uint64_t v17 = *(void *)v16;
      if (a1[2] == v15) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = (char *)(*(void *)v16 + 8 * (a1[4] & 0x1FFLL));
      }
      uint64_t v19 = (uint64_t)&v18[-v17];
      uint64_t v20 = (uint64_t)&v18[-v17] >> 3;
      if (v19 < 9)
      {
        unsigned int v21 = (char *)(*(void *)&v16[-8 * ((unint64_t)(512 - v20) >> 9)] + 8 * (~(512 - (_WORD)v20) & 0x1FF));
        if (v18 != a4) {
          goto LABEL_38;
        }
      }
      else
      {
        unsigned int v21 = (char *)(*(void *)&v16[((unint64_t)(v20 - 1) >> 6) & 0x3FFFFFFFFFFFFF8]
                     + 8 * ((v20 - 1) & 0x1FF));
        if (v18 != a4) {
          goto LABEL_38;
        }
      }
      unsigned long long v63 = v21;
      a4 = v21;
LABEL_38:
      *(void *)unsigned int v21 = *(void *)v18;
      uint64_t v42 = a1[5] + 1;
      a1[4] = v14 - 1;
      a1[5] = v42;
      if (v11 < 2) {
        goto LABEL_54;
      }
      uint64_t v43 = (uint64_t)&v18[-*(void *)v16];
      uint64_t v44 = v43 >> 3;
      if (v43 < -7)
      {
        unsigned long long v45 = &v16[-8 * ((unint64_t)(510 - v44) >> 9)];
        unint64_t v46 = (char *)(*(void *)v45 + 8 * (~(510 - (_WORD)v44) & 0x1FF));
        uint64_t v47 = v44 + v11;
        if (v47 < 1) {
          goto LABEL_41;
        }
      }
      else
      {
        unsigned long long v45 = &v16[8 * ((unint64_t)(v44 + 1) >> 9)];
        unint64_t v46 = (char *)(*(void *)v45 + 8 * ((v44 + 1) & 0x1FF));
        uint64_t v47 = v44 + v11;
        if (v47 < 1)
        {
LABEL_41:
          unint64_t v48 = 511 - v47;
          unsigned long long v49 = &v16[-8 * (v48 >> 9)];
          uint64_t v50 = (char *)(*(void *)v49 + 8 * (~(_WORD)v48 & 0x1FF));
LABEL_53:
          std::deque<HGRenderJob *>::__move_and_check((int)a1, v45, v46, v49, v50, v16, v18, (unint64_t *)&v63);
          BOOL v18 = v58;
          a4 = v63;
LABEL_54:
          *(void *)BOOL v18 = *(void *)a4;
          unint64_t v23 = a1[4];
          uint64_t v59 = a1[1];
          uint64_t result = (void *)(v59 + 8 * (v23 >> 9));
          if (a1[2] != v59) {
            goto LABEL_55;
          }
          goto LABEL_47;
        }
      }
      unsigned long long v49 = &v16[8 * ((unint64_t)v47 >> 9)];
      uint64_t v50 = (char *)(*(void *)v49 + 8 * (v47 & 0x1FF));
      goto LABEL_53;
    }
  }
  unint64_t v36 = a1[4];
  uint64_t v37 = a1[1];
  __int32 v38 = (void *)(v37 + 8 * (v36 >> 9));
  if (a1[2] == v37) {
    uint64_t v39 = 0;
  }
  else {
    uint64_t v39 = *v38 + 8 * (a1[4] & 0x1FFLL);
  }
  if (v39 == *v38) {
    uint64_t v39 = *(v38 - 1) + 4096;
  }
  *(void *)(v39 - 8) = *(void *)a4;
  uint64_t v40 = a1[5] + 1;
  a1[4] = v36 - 1;
  a1[5] = v40;
  unint64_t v23 = a1[4];
  uint64_t v41 = a1[1];
  uint64_t result = (void *)(v41 + 8 * (v23 >> 9));
  if (a1[2] != v41)
  {
LABEL_55:
    uint64_t v54 = *result + 8 * (v23 & 0x1FF);
    if (!v11) {
      return result;
    }
    goto LABEL_56;
  }
LABEL_47:
  uint64_t v54 = 0;
  if (!v11) {
    return result;
  }
LABEL_56:
  uint64_t v60 = v11 + ((v54 - *result) >> 3);
  if (v60 < 1) {
    result -= (unint64_t)(511 - v60) >> 9;
  }
  else {
    result += (unint64_t)v60 >> 9;
  }
  return result;
}

uint64_t HGRenderQueue::CancelAllQueuedRenderJobs(HGRenderQueue *this)
{
  long long v39 = 0u;
  long long v40 = 0u;
  *(_OWORD *)__p = 0u;
  uint64_t v2 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v2);
  uint64_t v3 = *((void *)this + 38);
  uint64_t v4 = *((void *)this + 39);
  int v5 = (void **)(v3 + 8 * (*((void *)this + 41) >> 9));
  if (v4 == v3) {
    unint64_t v6 = 0;
  }
  else {
    unint64_t v6 = (char *)*v5 + 8 * (*((void *)this + 41) & 0x1FFLL);
  }
  uint64_t v7 = 0;
  uint64_t v8 = (char *)this + 96;
LABEL_5:
  uint64_t v9 = (HGRenderJob **)v6;
  while (v4 != v3)
  {
    unint64_t v10 = *((void *)this + 42) + *((void *)this + 41);
    if (v9 == (HGRenderJob **)(*(void *)(v3 + ((v10 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v10 & 0x1FF))) {
      goto LABEL_32;
    }
LABEL_10:
    int v11 = *((_DWORD *)*v9 + 3);
    if (v11 == 7) {
      goto LABEL_21;
    }
    if (!v11)
    {
      if (*((void *)*v9 + 22))
      {
        uint64_t v13 = *((void *)this + 13);
        if ((char *)v13 != v8)
        {
          while (!HGRenderExecUnit::HasEnqueuedRenderJob(*(HGRenderExecUnit **)(v13 + 16), *v9))
          {
            uint64_t v13 = *(void *)(v13 + 8);
            if ((char *)v13 == v8) {
              goto LABEL_21;
            }
          }
          HGRenderExecUnit::RemoveEnqueuedRenderJob(*(HGRenderExecUnit **)(v13 + 16), *v9);
          if ((*((unsigned char *)this + 69) & 4) != 0)
          {
            unint64_t v14 = *(HGRenderExecUnit **)(v13 + 16);
            int v15 = *((_DWORD *)v14 + 2);
            uint64_t v16 = HGRenderExecUnit::NumEnqueuedRenderJobs(v14);
            printf("RenderUnit<%d> Dequeue: Count: %lu\n", v15, v16);
          }
        }
      }
LABEL_21:
      uint64_t v17 = *v9;
      HGRenderJob::SetState((uint64_t)v17, 6);
      uint64_t v18 = *((void *)v17 + 38);
      if (*((void *)v17 + 39) == v18)
      {
        HGRenderJob::CallNotifyFunc(v17);
      }
      else
      {
        unint64_t v19 = 0;
        unsigned int v20 = 1;
        do
        {
          unsigned int v21 = *(char **)(v18 + 8 * v19);
          HGRenderNode::SetState((uint64_t)v21, 8);
          HGRenderNode::CallNotifyFunc(v21);
          HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v21);
          unint64_t v19 = v20;
          uint64_t v18 = *((void *)v17 + 38);
          ++v20;
        }
        while (v19 < (*((void *)v17 + 39) - v18) >> 3);
      }
      uint64_t v22 = (char *)__p[1];
      if ((void *)v39 == __p[1]) {
        unint64_t v23 = 0;
      }
      else {
        unint64_t v23 = (((void)v39 - (unint64_t)__p[1]) << 6) - 1;
      }
      uint64_t v24 = *((void *)&v40 + 1);
      unint64_t v25 = *((void *)&v40 + 1) + v40;
      if (v23 == *((void *)&v40 + 1) + (void)v40)
      {
        std::deque<HGRenderJob *>::__add_back_capacity((uint64_t)__p);
        uint64_t v24 = *((void *)&v40 + 1);
        uint64_t v22 = (char *)__p[1];
        unint64_t v25 = v40 + *((void *)&v40 + 1);
      }
      *(void *)(*(void *)&v22[(v25 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v25 & 0x1FF)) = v17;
      *((void *)&v40 + 1) = v24 + 1;
      int v5 = std::deque<Pipeline *>::erase((int64x2_t *)((char *)this + 296), (char *)v5, v6);
      unint64_t v6 = v26;
      uint64_t v7 = (v7 + 1);
      uint64_t v3 = *((void *)this + 38);
      uint64_t v4 = *((void *)this + 39);
      goto LABEL_5;
    }
    ++v9;
    v6 += 8;
    if ((char *)*v5 + 4096 == v6)
    {
      unint64_t v12 = (char *)v5[1];
      ++v5;
      unint64_t v6 = v12;
      goto LABEL_5;
    }
  }
  if (v9) {
    goto LABEL_10;
  }
LABEL_32:
  HGSynchronizable::Unlock(v2);
  uint64_t v27 = (void **)__p[1];
  int v28 = (void **)v39;
  if (*((void *)&v40 + 1))
  {
    uint64_t v29 = (char *)__p[1] + 8 * ((unint64_t)v40 >> 9);
    if ((void *)v39 == __p[1]) {
      int64x2_t v30 = 0;
    }
    else {
      int64x2_t v30 = (char *)(*(void *)v29 + 8 * (v40 & 0x1FF));
    }
    while (1)
    {
      uint64_t v27 = (void **)__p[1];
      int v28 = (void **)v39;
      if ((void *)v39 == __p[1])
      {
        if (!v30) {
          break;
        }
      }
      else if ((char *)(*(void *)((char *)__p[1] {
                                   + (((*((void *)&v40 + 1) + (void)v40) >> 6) & 0x3FFFFFFFFFFFFF8))
      }
                       + 8 * ((*((void *)&v40 + 1) + v40) & 0x1FF)) == v30)
      {
        break;
      }
      uint64_t v32 = *(void *)v30;
      if (*(void *)(*(void *)v30 + 176))
      {
        *(_DWORD *)(v32 + 12) = 4;
        *(_DWORD *)(v32 + 104) = 10;
        HGRenderQueue::EnqueueRenderJob(this, (HGRenderJob *)v32);
      }
      else
      {
        (*(void (**)(void))(*(void *)v32 + 24))(*(void *)v30);
      }
      uint64_t v29 = (char *)std::deque<Pipeline *>::erase((int64x2_t *)__p, v29, v30);
      int64x2_t v30 = v31;
    }
  }
  *((void *)&v40 + 1) = 0;
  unint64_t v33 = (char *)v28 - (char *)v27;
  if ((unint64_t)((char *)v28 - (char *)v27) >= 0x11)
  {
    do
    {
      operator delete(*v27);
      int v28 = (void **)v39;
      uint64_t v27 = (void **)((char *)__p[1] + 8);
      __p[1] = v27;
      unint64_t v33 = v39 - (void)v27;
    }
    while ((void)v39 - (void)v27 > 0x10uLL);
  }
  unint64_t v34 = v33 >> 3;
  if (v34 == 1)
  {
    uint64_t v35 = 256;
LABEL_51:
    *(void *)&long long v40 = v35;
  }
  else if (v34 == 2)
  {
    uint64_t v35 = 512;
    goto LABEL_51;
  }
  if (v27 != v28)
  {
    do
    {
      unint64_t v36 = *v27++;
      operator delete(v36);
    }
    while (v27 != v28);
    if ((void *)v39 != __p[1]) {
      *(void *)&long long v39 = v39 + (((unint64_t)__p[1] - v39 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_1B78315E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, HGSynchronizable *);
  uint64_t v6 = va_arg(va1, void);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::CancelAllActiveRenderJobs(HGRenderQueue *this, int a2)
{
  uint64_t v4 = (HGSynchronizable *)*((void *)this + 43);
  __rqtp.tv_sec = (__darwin_time_t)v4;
  LOBYTE(__rqtp.tv_nsec) = 0;
  HGSynchronizable::Lock(v4);
  int v5 = (char *)this + 136;
  uint64_t v6 = *((void *)this + 18);
  if ((HGRenderQueue *)v6 == (HGRenderQueue *)((char *)this + 136))
  {
    uint64_t v7 = 0;
  }
  else
  {
    LODWORD(v7) = 0;
    do
    {
      uint64_t v8 = *(void *)(v6 + 16);
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v8 + 176) + 120))(*(void *)(v8 + 176), 13, 1);
      *(_DWORD *)(v8 + 108) = 6;
      uint64_t v7 = (v7 + 1);
      uint64_t v6 = *(void *)(v6 + 8);
    }
    while ((char *)v6 != v5);
  }
  HGSynchronizable::Unlock(v4);
  uint64_t v9 = (HGSynchronizable *)*((void *)this + 43);
  __rqtp.tv_sec = (__darwin_time_t)v9;
  LOBYTE(__rqtp.tv_nsec) = 0;
  HGSynchronizable::Lock(v9);
  unint64_t v10 = (char *)this + 160;
  uint64_t v11 = *((void *)this + 21);
  if ((HGRenderQueue *)v11 != (HGRenderQueue *)((char *)this + 160))
  {
    do
    {
      uint64_t v12 = *(void *)(v11 + 16);
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v12 + 176) + 120))(*(void *)(v12 + 176), 13, 1);
      *(_DWORD *)(v12 + 108) = 6;
      uint64_t v7 = (v7 + 1);
      uint64_t v11 = *(void *)(v11 + 8);
    }
    while ((char *)v11 != v10);
  }
  HGSynchronizable::Unlock(v9);
  if (a2)
  {
    LOBYTE(v13) = 0;
LABEL_11:
    unint64_t v14 = (HGSynchronizable *)*((void *)this + 43);
    HGSynchronizable::Lock(v14);
    uint64_t v15 = *((void *)this + 18);
    if ((char *)v15 == v5)
    {
LABEL_14:
      BOOL v17 = 1;
    }
    else
    {
      while (1)
      {
        int v16 = *(_DWORD *)(*(void *)(v15 + 16) + 108);
        BOOL v17 = v16 != 6;
        if (v16 == 6) {
          break;
        }
        uint64_t v15 = *(void *)(v15 + 8);
        if ((char *)v15 == v5) {
          goto LABEL_14;
        }
      }
    }
    HGSynchronizable::Unlock(v14);
    if (v13)
    {
LABEL_16:
      BOOL v13 = 1;
      goto LABEL_23;
    }
    while (1)
    {
      uint64_t v18 = (HGSynchronizable *)*((void *)this + 43);
      HGSynchronizable::Lock(v18);
      uint64_t v19 = *((void *)this + 21);
      if ((char *)v19 == v10)
      {
LABEL_21:
        BOOL v13 = 1;
      }
      else
      {
        while (1)
        {
          int v20 = *(_DWORD *)(*(void *)(v19 + 16) + 108);
          BOOL v13 = v20 != 6;
          if (v20 == 6) {
            break;
          }
          uint64_t v19 = *(void *)(v19 + 8);
          if ((char *)v19 == v10) {
            goto LABEL_21;
          }
        }
      }
      HGSynchronizable::Unlock(v18);
LABEL_23:
      if (v17 && v13) {
        break;
      }
      timespec __rqtp = (timespec)xmmword_1B8347EE0;
      nanosleep(&__rqtp, &__rmtp);
      if (!v17) {
        goto LABEL_11;
      }
      BOOL v17 = 1;
      if (v13) {
        goto LABEL_16;
      }
    }
  }
  return v7;
}

void sub_1B7831864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7831878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::CancelAllRenderJobs(HGRenderQueue *this, int a2)
{
  int v4 = HGRenderQueue::CancelAllQueuedRenderJobs(this);
  return HGRenderQueue::CancelAllActiveRenderJobs(this, a2) + v4;
}

uint64_t HGRenderQueue::CancelRenderJob(HGRenderQueue *this, HGRenderJob *a2)
{
  int v4 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v4);
  uint64_t v5 = *((void *)this + 38);
  if (*((void *)this + 39) != v5)
  {
    unint64_t v6 = *((void *)this + 41);
    uint64_t v7 = v5 + 8 * (v6 >> 9);
    uint64_t v8 = (char *)(*(void *)v7 + 8 * (v6 & 0x1FF));
    uint64_t v9 = *(void *)(v5 + (((*((void *)this + 42) + v6) >> 6) & 0x3FFFFFFFFFFFFF8))
       + 8 * ((*((void *)this + 42) + v6) & 0x1FF);
    if (v8 != (char *)v9)
    {
      while (*(HGRenderJob **)v8 != a2)
      {
        v8 += 8;
        if (&v8[-*(void *)v7] == (char *)4096)
        {
          unint64_t v10 = *(char **)(v7 + 8);
          v7 += 8;
          uint64_t v8 = v10;
        }
        if (v8 == (char *)v9) {
          goto LABEL_8;
        }
      }
      std::deque<Pipeline *>::erase((int64x2_t *)((char *)this + 296), (char *)v7, v8);
      HGRenderJob::SetState((uint64_t)a2, 6);
      int v13 = *((_DWORD *)a2 + 3);
      if (v13)
      {
        if (v13 == 8)
        {
LABEL_15:
          HGSynchronizable::NotifyAll(*((HGSynchronizable **)a2 + 37));
LABEL_29:
          (*(void (**)(HGRenderJob *))(*(void *)a2 + 24))(a2);
          goto LABEL_30;
        }
      }
      else
      {
        if (*((void *)a2 + 22))
        {
          uint64_t v14 = *((void *)this + 13);
          if ((HGRenderQueue *)v14 != (HGRenderQueue *)((char *)this + 96))
          {
            while (!HGRenderExecUnit::HasEnqueuedRenderJob(*(HGRenderExecUnit **)(v14 + 16), *(HGRenderJob **)v8))
            {
              uint64_t v14 = *(void *)(v14 + 8);
              if ((HGRenderQueue *)v14 == (HGRenderQueue *)((char *)this + 96)) {
                goto LABEL_23;
              }
            }
            HGRenderExecUnit::RemoveEnqueuedRenderJob(*(HGRenderExecUnit **)(v14 + 16), *(HGRenderJob **)v8);
            if ((*((unsigned char *)this + 69) & 4) != 0)
            {
              uint64_t v15 = *(HGRenderExecUnit **)(v14 + 16);
              int v16 = *((_DWORD *)v15 + 2);
              uint64_t v17 = HGRenderExecUnit::NumEnqueuedRenderJobs(v15);
              printf("RenderUnit<%d> Dequeue: Count: %lu\n", v16, v17);
            }
          }
        }
LABEL_23:
        if (*((_DWORD *)a2 + 3) == 8) {
          goto LABEL_15;
        }
      }
      uint64_t v18 = *((void *)a2 + 38);
      if (*((void *)a2 + 39) == v18)
      {
        HGRenderJob::CallNotifyFunc(a2);
      }
      else
      {
        unint64_t v19 = 0;
        unsigned int v20 = 1;
        do
        {
          unsigned int v21 = *(char **)(v18 + 8 * v19);
          HGRenderNode::SetState((uint64_t)v21, 7);
          HGRenderNode::CallNotifyFunc(v21);
          HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v21);
          unint64_t v19 = v20;
          uint64_t v18 = *((void *)a2 + 38);
          ++v20;
        }
        while (v19 < (*((void *)a2 + 39) - v18) >> 3);
      }
      goto LABEL_29;
    }
  }
LABEL_8:
  uint64_t v11 = *((void *)this + 18);
  if ((HGRenderQueue *)v11 == (HGRenderQueue *)((char *)this + 136))
  {
LABEL_11:
    int v12 = 1;
    goto LABEL_31;
  }
  while (*(HGRenderJob **)(v11 + 16) != a2)
  {
    uint64_t v11 = *(void *)(v11 + 8);
    if ((HGRenderQueue *)v11 == (HGRenderQueue *)((char *)this + 136)) {
      goto LABEL_11;
    }
  }
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)a2 + 22) + 120))(*((void *)a2 + 22), 13, 1);
  HGRenderJob::SetState((uint64_t)a2, 6);
LABEL_30:
  int v12 = 0;
LABEL_31:
  HGSynchronizable::Unlock(v4);
  if (v12)
  {
    uint64_t v22 = (HGSynchronizable *)*((void *)this + 73);
    HGSynchronizable::Lock(v22);
    uint64_t v23 = *((void *)this + 68);
    uint64_t v24 = (void **)(v23 + 8 * (*((void *)this + 71) >> 9));
    uint64_t v25 = *((void *)this + 69);
    if (v25 == v23) {
      unint64_t v26 = 0;
    }
    else {
      unint64_t v26 = (char *)*v24 + 8 * (*((void *)this + 71) & 0x1FFLL);
    }
    uint64_t v27 = 0;
LABEL_37:
    int v28 = v26;
    while (1)
    {
      if (v25 == v23)
      {
        if (!v28)
        {
LABEL_46:
          HGSynchronizable::Unlock(v22);
          return v27;
        }
      }
      else
      {
        unint64_t v29 = *((void *)this + 72) + *((void *)this + 71);
        if (v28 == (char *)(*(void *)(v23 + ((v29 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v29 & 0x1FF))) {
          goto LABEL_46;
        }
      }
      int64x2_t v30 = *(void **)v28;
      if (*(HGRenderJob **)(*(void *)(*(void *)v28 + 40) + 192) == a2)
      {
        uint64_t v24 = std::deque<Pipeline *>::erase((int64x2_t *)((char *)this + 536), (char *)v24, v26);
        unint64_t v26 = v32;
        HGRenderJob::SetState((uint64_t)a2, 6);
        unint64_t v33 = (char *)v30[5];
        HGRenderNode::SetState((uint64_t)v33, 8);
        HGRenderNode::CallNotifyFunc(v33);
        HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v33);
        (*(void (**)(void *))(*v30 + 24))(v30);
        uint64_t v23 = *((void *)this + 68);
        uint64_t v25 = *((void *)this + 69);
        uint64_t v27 = 1;
        goto LABEL_37;
      }
      v28 += 8;
      v26 += 8;
      if ((char *)*v24 + 4096 == v26)
      {
        uint64_t v31 = (char *)v24[1];
        ++v24;
        unint64_t v26 = v31;
        goto LABEL_37;
      }
    }
  }
  return 1;
}

void sub_1B7831C9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7831CB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7831CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7831CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7831CF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7831D04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7831D1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7831D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::ExecuteRenderJob(HGRenderQueue *this, HGRenderJob *a2)
{
  int v2 = *((_DWORD *)a2 + 3);
  if (v2 == 8 || v2 == 1)
  {
    uint64_t v5 = *((void *)a2 + 22);
    if (v5)
    {
      if (((*(uint64_t (**)(uint64_t))(*(void *)v5 + 304))(v5) & 1) == 0)
      {
        *((_DWORD *)a2 + 4) = 2;
        HGGPURenderer::GetCurrentContext(*((HGGPURenderer **)a2 + 22), &v7);
        HGGLContext::Share();
      }
      *((_DWORD *)a2 + 4) = 1;
    }
    operator new();
  }
  return 4294966304;
}

void sub_1B7831EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
}

void sub_1B7831F00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGRenderQueue::GetNumActiveCPURenderJobs(HGRenderQueue *this)
{
  int v2 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v2);
  uint64_t v3 = (char *)this + 136;
  uint64_t v4 = *((void *)this + 18);
  if ((HGRenderQueue *)v4 == (HGRenderQueue *)((char *)this + 136))
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    do
    {
      v5 += (*(unsigned int (**)(void))(**(void **)(*(void *)(v4 + 16) + 176) + 304))(*(void *)(*(void *)(v4 + 16) + 176));
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while ((char *)v4 != v3);
  }
  HGSynchronizable::Unlock(v2);
  return v5;
}

void sub_1B783202C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

uint64_t HGRenderQueue::GetNumActiveGPURenderJobs(uint64_t a1, int a2, int a3)
{
  unint64_t v6 = *(HGSynchronizable **)(a1 + 344);
  HGSynchronizable::Lock(v6);
  uint64_t v7 = a1 + 136;
  uint64_t v8 = *(void *)(a1 + 144);
  if (v8 == a1 + 136)
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(void *)(v8 + 16);
      if (((*(uint64_t (**)(void))(**(void **)(v10 + 176) + 304))(*(void *)(v10 + 176)) & 1) == 0
        && *(_DWORD *)(v10 + 104) >= a3
        && *(_DWORD *)(v10 + 184) == a2)
      {
        ++v9;
      }
      uint64_t v8 = *(void *)(v8 + 8);
    }
    while (v8 != v7);
  }
  HGSynchronizable::Unlock(v6);
  return v9;
}

void sub_1B7832128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

uint64_t HGRenderQueue::GetNumActiveGPUCustomRenderJobs(HGRenderQueue *this)
{
  int v2 = (HGSynchronizable *)*((void *)this + 43);
  v6[2] = (uint64_t)v2;
  char v7 = 0;
  HGSynchronizable::Lock(v2);
  for (uint64_t i = *((void *)this + 21); (HGRenderQueue *)i != (HGRenderQueue *)((char *)this + 160); uint64_t i = *(void *)(i + 8))
  {
    uint64_t v4 = *(void *)(i + 16);
    if (((*(uint64_t (**)(void))(**(void **)(v4 + 176) + 304))(*(void *)(v4 + 176)) & 1) == 0)
    {
      HGGPURenderer::GetContext(*(void *)(v4 + 176), 24, v6);
      HGGLContext::Share();
    }
  }
  HGSynchronizable::Unlock(v2);
  return 0;
}

void sub_1B7832264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (a3) {
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
  }
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGRenderQueue::SetMinJobExecPriority(HGRenderQueue *this, int a2)
{
  uint64_t v4 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v4);
  int v5 = *((_DWORD *)this + 14);
  *((_DWORD *)this + 14) = a2;
  uint64_t result = HGSynchronizable::Unlock(v4);
  if (v5 > a2)
  {
    char v7 = (HGSynchronizable *)*((void *)this + 16);
    HGSynchronizable::Lock(v7);
    HGSynchronizable::NotifyAll(v7);
    HGSynchronizable::Unlock(v7);
    uint64_t v8 = (HGSynchronizable *)*((void *)this + 15);
    HGSynchronizable::Lock(v8);
    HGSynchronizable::NotifyAll(v8);
    return HGSynchronizable::Unlock(v8);
  }
  return result;
}

void sub_1B7832374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

void sub_1B783238C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

uint64_t HGRenderQueue::EnqueueDeleteRenderNode(HGRenderQueue *this, HGRenderNode *a2)
{
  uint64_t v4 = *((void *)a2 + 23);
  if (v4)
  {
    int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 304))(v4) ^ 1;
    uint64_t v6 = *((void *)a2 + 3);
    if (!v6) {
      goto LABEL_3;
    }
  }
  else
  {
    int v5 = 0;
    uint64_t v6 = *((void *)a2 + 3);
    if (!v6)
    {
LABEL_3:
      if (!v5) {
        goto LABEL_16;
      }
      goto LABEL_14;
    }
  }
  if ((*(unsigned char *)(v6 + 12) & 0x10) == 0 || !*(void *)(v6 + 128))
  {
    uint64_t v6 = 0;
    if (!v5) {
      goto LABEL_16;
    }
    goto LABEL_14;
  }
  char v7 = (HGRenderNode *)HGObject::operator new(0xD0uLL);
  HGRenderNode::HGRenderNode(v7);
  *((void *)v7 + 3) = *((void *)a2 + 3);
  *((void *)a2 + 3) = 0;
  if (v5 && *((void *)a2 + 23) == *(void *)(v6 + 128))
  {
    *((void *)v7 + 2) = *((void *)a2 + 2);
    *((void *)a2 + 2) = 0;
  }
  uint64_t v8 = (HGRenderJob *)HGObject::operator new(0x160uLL);
  HGRenderJob::HGRenderJob(v8);
  HGUserJob::SetPriority((uint64_t)v8, 5);
  HGRenderJob::SetRenderer(v8, *(HGRenderer **)(v6 + 128));
  HGRenderJob::AddRenderNodeInternal(v8, v7);
  HGRenderJob::SetPriority((uint64_t)v8, 12);
  uint64_t v6 = HGRenderQueue::EnqueueRenderJob(this, v8);
  (*(void (**)(HGRenderJob *))(*(void *)v8 + 24))(v8);
  (*(void (**)(HGRenderNode *))(*(void *)v7 + 24))(v7);
  if (v5)
  {
LABEL_14:
    if (*((void *)a2 + 2))
    {
      uint64_t v9 = (HGRenderNode *)HGObject::operator new(0xD0uLL);
      HGRenderNode::HGRenderNode(v9);
      *((void *)v9 + 2) = *((void *)a2 + 2);
      *((void *)a2 + 2) = 0;
      uint64_t v10 = (HGRenderJob *)HGObject::operator new(0x160uLL);
      HGRenderJob::HGRenderJob(v10);
      HGUserJob::SetPriority((uint64_t)v10, 5);
      HGRenderJob::SetRenderer(v10, *((HGRenderer **)a2 + 23));
      HGRenderJob::AddRenderNodeInternal(v10, v9);
      HGRenderJob::SetPriority((uint64_t)v10, 12);
      uint64_t v6 = HGRenderQueue::EnqueueRenderJob(this, v10);
      (*(void (**)(HGRenderJob *))(*(void *)v10 + 24))(v10);
      (*(void (**)(HGRenderNode *))(*(void *)v9 + 24))(v9);
    }
  }
LABEL_16:
  uint64_t v11 = (HGPixelBufferObj *)*((void *)a2 + 17);
  if (v11)
  {
    HGRenderQueue::ReleasePBOToSharedPool(this, v11);
    *((void *)a2 + 17) = 0;
  }
  return v6;
}

void sub_1B7832604(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B783261C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7832630(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7832648(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGRenderQueue::ReleasePBOToSharedPool(HGRenderQueue *this, HGPixelBufferObj *a2)
{
  int v5 = (HGSynchronizable *)*((void *)this + 80);
  HGSynchronizable::Lock(v5);
  (*(void (**)(HGPixelBufferObj *))(*(void *)a2 + 24))(a2);
  if ((*((unsigned char *)this + 69) & 0x10) != 0) {
    HGGLContext::Share();
  }
  HGSynchronizable::Unlock(v5);
  uint64_t v6 = (HGSynchronizable *)*((void *)this + 63);
  HGSynchronizable::Lock(v6);
  HGSynchronizable::NotifyAll(v6);
  return HGSynchronizable::Unlock(v6);
}

void sub_1B7832878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, PCSharedCount a13, uint64_t a14, HGSynchronizable *a15)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 24))(a14);
  }
  HGSynchronizer::~HGSynchronizer(&a15);
  _Unwind_Resume(a1);
}

uint64_t **std::map<HGPixelBufferObj *,unsigned long long>::operator[](uint64_t **a1, uint64_t **a2)
{
  uint64_t v4 = a1 + 1;
  uint64_t v3 = a1[1];
  int v5 = *a2;
  if (v3)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v3;
        unint64_t v7 = v3[4];
        if ((unint64_t)v5 >= v7) {
          break;
        }
        uint64_t v3 = *v6;
        uint64_t v4 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      if (v7 >= (unint64_t)v5) {
        break;
      }
      uint64_t v3 = v6[1];
      if (!v3)
      {
        uint64_t v4 = v6 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64_t v6 = a1 + 1;
LABEL_8:
    uint64_t v8 = (uint64_t *)v6;
    uint64_t v6 = (uint64_t **)operator new(0x30uLL);
    v6[4] = v5;
    v6[5] = 0;
    *uint64_t v6 = 0;
    v6[1] = 0;
    v6[2] = v8;
    HGSynchronizable *v4 = (uint64_t *)v6;
    uint64_t v9 = (uint64_t *)**a1;
    uint64_t v10 = (uint64_t *)v6;
    if (v9)
    {
      *a1 = v9;
      uint64_t v10 = *v4;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6 + 5;
}

uint64_t HGRenderQueue::DeleteHGGLTexture(HGRenderQueue *this, HGGLTexture *a2)
{
  if (*((void *)a2 + 16))
  {
    return HGRenderQueue::EnqueueDeleteHGGLTexture(this, a2);
  }
  else
  {
    (*(void (**)(HGGLTexture *))(*(void *)a2 + 24))(a2);
    return 0;
  }
}

uint64_t HGRenderQueue::EnqueueDeleteHGGLTexture(HGRenderQueue *this, HGGLTexture *a2)
{
  for (uint64_t i = *((void *)this + 13); (HGRenderQueue *)i != (HGRenderQueue *)((char *)this + 96); uint64_t i = *(void *)(i + 8))
  {
    if (*(void *)(*(void *)(i + 16) + 56) == *((void *)a2 + 16)) {
      break;
    }
  }
  int v5 = (HGRenderNode *)HGObject::operator new(0xD0uLL);
  HGRenderNode::HGRenderNode(v5);
  HGRenderNode::SetBitmap(v5, (HGBitmap *)a2);
  HGRenderNode::SetRenderer((uint64_t)v5, *((HGRenderer **)a2 + 16));
  (*(void (**)(HGGLTexture *))(*(void *)a2 + 24))(a2);
  uint64_t v6 = (HGRenderJob *)HGObject::operator new(0x160uLL);
  HGRenderJob::HGRenderJob(v6);
  HGUserJob::SetPriority((uint64_t)v6, 6);
  HGRenderJob::AddRenderNodeInternal(v6, v5);
  HGRenderJob::SetRenderer(v6, *((HGRenderer **)a2 + 16));
  HGRenderJob::SetPriority((uint64_t)v6, 12);
  uint64_t v7 = HGRenderQueue::EnqueueRenderJob(this, v6);
  if (v7)
  {
    (*(void (**)(HGGLTexture *))(*(void *)a2 + 16))(a2);
    HGRenderNode::SetBitmap(v5, 0);
  }
  (*(void (**)(HGRenderJob *))(*(void *)v6 + 24))(v6);
  (*(void (**)(HGRenderNode *))(*(void *)v5 + 24))(v5);
  return v7;
}

void sub_1B7832BA0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7832BB8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::FindIdleRenderExecUnitForJobWithPreferredVirtualScreen(HGRenderQueue *this, HGRenderJob *a2)
{
  int v2 = a2;
  uint64_t v4 = (HGGPUComputeDevice *)*((void *)a2 + 10);
  if (v4)
  {
    int GLVirtualScreen = HGGPUComputeDevice::GetGLVirtualScreen(v4);
    uint64_t v6 = (char *)this + 96;
    uint64_t v7 = *((void *)this + 13);
    if ((HGRenderQueue *)v7 == (HGRenderQueue *)((char *)this + 96)) {
      return 0;
    }
    goto LABEL_5;
  }
  int GLVirtualScreen = *((_DWORD *)a2 + 48);
  uint64_t v6 = (char *)this + 96;
  uint64_t v7 = *((void *)this + 13);
  if ((HGRenderQueue *)v7 != (HGRenderQueue *)((char *)this + 96))
  {
LABEL_5:
    int v28 = this;
    unint64_t v29 = (uint64_t **)((char *)this + 208);
    while (1)
    {
      uint64_t v10 = *(void *)(v7 + 16);
      if (!HGRenderExecUnit::IsGPU((HGRenderExecUnit *)v10)
        || (*(_DWORD *)(v10 + 24) - 1) > 1
        || !HGRenderExecUnit::CanPerformJobType(v10, *((_DWORD *)v2 + 3)))
      {
        goto LABEL_6;
      }
      uint64_t v11 = *(const void **)(v10 + 48);
      if (!v11) {
        break;
      }
      int v12 = (PVRenderJob *)__dynamic_cast(v11, v8, v9, 0);
      if (v12)
      {
        uint64_t FrameStats = PVRenderJob::GetFrameStats(v12);
        uint64_t v14 = *(HGGPUComputeDevice **)FrameStats;
        uint64_t v15 = *(std::__shared_weak_count **)(FrameStats + 8);
        if (v15) {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v16 = HGGPUComputeDevice::GetGLVirtualScreen(v14);
        if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
          if (v16 != GLVirtualScreen) {
            goto LABEL_6;
          }
          goto LABEL_20;
        }
        goto LABEL_19;
      }
      if (GLVirtualScreen != -1) {
        goto LABEL_6;
      }
LABEL_20:
      uint64_t v17 = v29;
      while (1)
      {
        uint64_t v18 = *v17;
        unint64_t v19 = v17;
        if (!*v17) {
          break;
        }
        while (1)
        {
          uint64_t v17 = (uint64_t **)v18;
          int v20 = *((_DWORD *)v18 + 7);
          if (GLVirtualScreen < v20) {
            break;
          }
          if (v20 >= GLVirtualScreen) {
            goto LABEL_29;
          }
          uint64_t v18 = v17[1];
          if (!v18)
          {
            unint64_t v19 = v17 + 1;
            goto LABEL_26;
          }
        }
      }
LABEL_26:
      unsigned int v21 = v2;
      uint64_t v22 = v9;
      uint64_t v23 = v8;
      uint64_t v24 = (uint64_t *)v17;
      uint64_t v17 = (uint64_t **)operator new(0x28uLL);
      *((_DWORD *)v17 + 7) = GLVirtualScreen;
      *((unsigned char *)v17 + 32) = 0;
      *uint64_t v17 = 0;
      v17[1] = 0;
      v17[2] = v24;
      *unint64_t v19 = (uint64_t *)v17;
      uint64_t v25 = **((void **)v28 + 25);
      unint64_t v26 = (uint64_t *)v17;
      if (v25)
      {
        *((void *)v28 + 25) = v25;
        unint64_t v26 = *v19;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v28 + 26), v26);
      ++*((void *)v28 + 27);
      uint64_t v8 = v23;
      uint64_t v9 = v22;
      int v2 = v21;
LABEL_29:
      if (!*((unsigned char *)v17 + 32) && !HGRenderExecUnit::NumEnqueuedRenderJobs((HGRenderExecUnit *)v10)) {
        return 1;
      }
LABEL_6:
      uint64_t v7 = *(void *)(v7 + 8);
      if ((char *)v7 == v6) {
        return 0;
      }
    }
    int v16 = -1;
LABEL_19:
    if (v16 != GLVirtualScreen) {
      goto LABEL_6;
    }
    goto LABEL_20;
  }
  return 0;
}

void sub_1B7832E48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::NotifyIdleRenderUnits(HGRenderQueue *this)
{
  atomic_exchange((atomic_uint *volatile)this + 20, 0);
  unint64_t v2 = atomic_load((unint64_t *)this + 24);
  if (v2 && (*((unsigned char *)this + 68) & 2) != 0)
  {
    uint64_t v3 = mach_absolute_time();
    unint64_t v4 = atomic_load((unint64_t *)this + 24);
    if (qword_1EB9A20F8 != -1) {
      dispatch_once(&qword_1EB9A20F8, &__block_literal_global_90);
    }
    float v5 = *(double *)&qword_1EB9A20F0 * (double)(v3 - v4) * 1000.0;
    printf("HGRenderQueue::NotifyIdleRenderUnits: Elapsed time: %7.1f (ms)\n", v5);
  }
  uint64_t v6 = (HGSynchronizable *)*((void *)this + 16);
  HGSynchronizable::Lock(v6);
  HGSynchronizable::NotifyAll(v6);
  HGSynchronizable::Unlock(v6);
  uint64_t v7 = (HGSynchronizable *)*((void *)this + 15);
  HGSynchronizable::Lock(v7);
  HGSynchronizable::NotifyAll(v7);
  HGSynchronizable::Unlock(v7);
  uint64_t result = mach_absolute_time();
  atomic_store(result, (unint64_t *)this + 24);
  return result;
}

void sub_1B7832F74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7832F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

BOOL HGRenderQueue::GetThrottleFlagOnVirtualScreen(HGRenderQueue *this, int a2)
{
  int v13 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v13);
  float v5 = (uint64_t **)((char *)this + 208);
  unint64_t v4 = (uint64_t *)*((void *)this + 26);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v4;
        int v7 = *((_DWORD *)v4 + 7);
        if (v7 <= a2) {
          break;
        }
        unint64_t v4 = *v6;
        float v5 = v6;
        if (!*v6) {
          goto LABEL_9;
        }
      }
      if (v7 >= a2)
      {
        uint64_t v10 = v6;
        goto LABEL_12;
      }
      unint64_t v4 = v6[1];
    }
    while (v4);
    float v5 = v6 + 1;
  }
  else
  {
    uint64_t v6 = (uint64_t **)((char *)this + 208);
  }
LABEL_9:
  uint64_t v10 = operator new(0x28uLL);
  v10[7] = a2;
  *((unsigned char *)v10 + 32) = 0;
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = v6;
  *float v5 = (uint64_t *)v10;
  uint64_t v8 = **((void **)this + 25);
  uint64_t v9 = (uint64_t *)v10;
  if (v8)
  {
    *((void *)this + 25) = v8;
    uint64_t v9 = *v5;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 26), v9);
  ++*((void *)this + 27);
LABEL_12:
  int v11 = *((unsigned __int8 *)v10 + 32);
  HGSynchronizable::Unlock(v13);
  return v11 != 0;
}

void sub_1B7833094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

HGSynchronizable *HGRenderQueue::SetThrottleFlagOnVirtualScreen(HGRenderQueue *this, int a2, char a3)
{
  uint64_t v14 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v14);
  int v7 = (uint64_t **)((char *)this + 208);
  uint64_t v6 = (char *)*((void *)this + 26);
  if (!v6)
  {
    uint64_t v8 = (uint64_t **)((char *)this + 208);
LABEL_8:
    uint64_t v10 = operator new(0x28uLL);
    v10[7] = a2;
    *((unsigned char *)v10 + 32) = 0;
    *(void *)uint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = v8;
    *int v7 = (uint64_t *)v10;
    uint64_t v11 = **((void **)this + 25);
    int v12 = (uint64_t *)v10;
    if (v11)
    {
      *((void *)this + 25) = v11;
      int v12 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 26), v12);
    ++*((void *)this + 27);
    *((unsigned char *)v10 + 32) = a3;
    if (a3) {
      return HGSynchronizable::Unlock(v14);
    }
LABEL_13:
    HGSynchronizable::NotifyAll(*((HGSynchronizable **)this + 16));
    return HGSynchronizable::Unlock(v14);
  }
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (uint64_t **)v6;
      int v9 = *((_DWORD *)v6 + 7);
      if (v9 <= a2) {
        break;
      }
      uint64_t v6 = (char *)*v8;
      int v7 = v8;
      if (!*v8) {
        goto LABEL_8;
      }
    }
    if (v9 >= a2) {
      break;
    }
    uint64_t v6 = (char *)v8[1];
    if (!v6)
    {
      int v7 = v8 + 1;
      goto LABEL_8;
    }
  }
  *((unsigned char *)v8 + 32) = a3;
  if ((a3 & 1) == 0) {
    goto LABEL_13;
  }
  return HGSynchronizable::Unlock(v14);
}

void sub_1B78331B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

BOOL HGRenderQueue::GetLockFlagOnVirtualScreen(HGRenderQueue *this, int a2)
{
  int v13 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v13);
  float v5 = (uint64_t **)((char *)this + 232);
  unint64_t v4 = (uint64_t *)*((void *)this + 29);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v4;
        int v7 = *((_DWORD *)v4 + 7);
        if (v7 <= a2) {
          break;
        }
        unint64_t v4 = *v6;
        float v5 = v6;
        if (!*v6) {
          goto LABEL_9;
        }
      }
      if (v7 >= a2)
      {
        uint64_t v10 = v6;
        goto LABEL_12;
      }
      unint64_t v4 = v6[1];
    }
    while (v4);
    float v5 = v6 + 1;
  }
  else
  {
    uint64_t v6 = (uint64_t **)((char *)this + 232);
  }
LABEL_9:
  uint64_t v10 = operator new(0x28uLL);
  v10[7] = a2;
  *((unsigned char *)v10 + 32) = 0;
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = v6;
  *float v5 = (uint64_t *)v10;
  uint64_t v8 = **((void **)this + 28);
  int v9 = (uint64_t *)v10;
  if (v8)
  {
    *((void *)this + 28) = v8;
    int v9 = *v5;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 29), v9);
  ++*((void *)this + 30);
LABEL_12:
  int v11 = *((unsigned __int8 *)v10 + 32);
  HGSynchronizable::Unlock(v13);
  return v11 != 0;
}

void sub_1B78332BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

uint64_t HGRenderQueue::GetRenderJob(HGRenderQueue *this, HGRenderExecUnit *a2, HGRenderJob **a3)
{
  uint64_t v6 = 120;
  if (!*((_DWORD *)a2 + 10)) {
    uint64_t v6 = 128;
  }
  int v7 = *(HGSynchronizable **)((char *)this + v6);
  unint64_t v29 = v7;
  char v30 = 0;
  HGSynchronizable::Lock(v7);
  while (1)
  {
    uint64_t RenderJobFromQueue = HGRenderQueue::GetRenderJobFromQueue(this, a2, a3);
    if (RenderJobFromQueue) {
      break;
    }
    if (*((_DWORD *)a2 + 6) != 4)
    {
      *((_DWORD *)a2 + 6) = 1;
      *((void *)a2 + 12) = mach_absolute_time();
      if (*((unsigned char *)this + 68))
      {
        uint64_t LUTEnd = (const char *)PCICCTransferFunctionLUT::getLUTEnd(a2);
        printf("%s : going idle\n", LUTEnd);
      }
      uint64_t v10 = (HGSynchronizable *)*((void *)this + 43);
      HGSynchronizable::Lock(v10);
      unint64_t v11 = *((void *)this + 4) + 1;
      *((void *)this + 4) = v11;
      BOOL v12 = *((void *)this + 42)
         && v11 >= 2
         && *(_DWORD *)(*(void *)(*(void *)(*((void *)this + 38)
                                              + ((*((void *)this + 41) >> 6) & 0x3FFFFFFFFFFFFF8))
                                  + 8 * (*((void *)this + 41) & 0x1FFLL))
                      + 104) >= *((_DWORD *)this + 14);
      HGSynchronizable::Unlock(v10);
      if (v12 && !atomic_fetch_or((atomic_uint *volatile)this + 20, 1u))
      {
        global_queue = dispatch_get_global_queue(0, 0);
        dispatch_group_enter(*((dispatch_group_t *)this + 93));
        dispatch_time_t v14 = dispatch_time(0, 2000000);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        block[2] = ___ZN13HGRenderQueue12GetRenderJobEP16HGRenderExecUnitPP11HGRenderJob_block_invoke;
        block[3] = &__block_descriptor_tmp_41;
        block[4] = this;
        dispatch_after(v14, global_queue, block);
      }
    }
    int v7 = v29;
    HGSynchronizable::Wait(v29);
    uint64_t v15 = (HGSynchronizable *)*((void *)this + 43);
    HGSynchronizable::Lock(v15);
    int v16 = *((_DWORD *)this + 4);
    HGSynchronizable::Unlock(v15);
    if (v16 == 3) {
      goto LABEL_25;
    }
    if (*((_DWORD *)a2 + 6) != 4)
    {
      uint64_t v17 = (HGSynchronizable *)*((void *)this + 43);
      HGSynchronizable::Lock(v17);
      --*((void *)this + 4);
      HGSynchronizable::Unlock(v17);
      *((_DWORD *)a2 + 6) = 2;
      *((void *)a2 + 13) = mach_absolute_time();
      if ((*((unsigned char *)this + 68) & 2) != 0
        && HGRenderExecUnit::IsGPU(a2)
        && (*(_DWORD *)(*((void *)a2 + 6) + 40) | 2) == 2)
      {
        uint64_t v18 = mach_absolute_time();
        uint64_t v19 = *((void *)this + 11);
        if (qword_1EB9A20F8 != -1) {
          dispatch_once(&qword_1EB9A20F8, &__block_literal_global_90);
        }
        double v20 = *(double *)&qword_1EB9A20F0;
        uint64_t v22 = *((void *)a2 + 12);
        uint64_t v21 = *((void *)a2 + 13);
        double v23 = *(double *)&qword_1EB9A20F0;
        uint64_t v24 = (const char *)PCICCTransferFunctionLUT::getLUTEnd(a2);
        float v25 = v23 * (double)(unint64_t)(v21 - v22) * 1000.0;
        float v26 = v20 * (double)(v18 - v19) * 1000.0;
        printf("%s : woke up : %5.2f (ms) :  queue time : %6.1f (ms) : ", v24, v25, v26);
        HGRenderQueue::DumpRenderJobQueues(this);
      }
    }
  }
  *((_DWORD *)a2 + 6) = 3;
LABEL_25:
  if (!v30) {
    HGSynchronizable::Unlock(v7);
  }
  return RenderJobFromQueue;
}

void sub_1B7833608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B783361C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7833634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7833650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetRenderJobFromQueue(HGRenderQueue *this, HGRenderExecUnit *a2, HGRenderJob **a3)
{
  int8x16_t v93 = (HGSynchronizable *)*((void *)this + 43);
  char v94 = 0;
  HGSynchronizable::Lock(v93);
  *a3 = 0;
  if (!*((void *)this + 42)
    || *((_DWORD *)a2 + 6) == 4
    || (uint64_t v6 = (_DWORD *)*((void *)a2 + 6), v6[8] == 3)
    || (*((_DWORD *)this + 4) & 0xFFFFFFFE) == 2
    || *((_DWORD *)this + 3) == 1 && !*((void *)this + 6))
  {
    uint64_t v7 = 0;
    goto LABEL_6;
  }
  int8x16_t v91 = 0;
  uint64_t v92 = 0;
  if (*((_DWORD *)a2 + 10)
  {
    int GLVirtualScreen = -1;
  }
  else
  {
    uint64_t FrameStats = (uint64_t *)PVRenderJob::GetFrameStats(v9);
    std::shared_ptr<HGComputeDevice const>::operator=[abi:ne180100]<HGGPUComputeDevice const,void>(&v91, FrameStats);
    int GLVirtualScreen = HGGPUComputeDevice::GetGLVirtualScreen(v91);
    uint64_t v6 = (_DWORD *)*((void *)a2 + 6);
  }
  uint64_t v11 = HGPixelBufferObj::format((HGPixelBufferObj *)v6);
  uint64_t v12 = *((void *)this + 38);
  uint64_t v13 = *((void *)this + 39);
  uint64_t v14 = v12 + 8 * (*((void *)this + 41) >> 9);
  if (v13 == v12) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v15 = (HGRenderJob **)(*(void *)v14 + 8 * (*((void *)this + 41) & 0x1FFLL));
  }
  unsigned long long v85 = 0;
  uint64_t v16 = 0;
  unsigned long long v87 = (uint64_t *)((char *)this + 136);
  while (1)
  {
    if (v13 == v12)
    {
      if (!v15) {
        goto LABEL_180;
      }
    }
    else
    {
      unint64_t v17 = *((void *)this + 42) + *((void *)this + 41);
      if (v15 == (HGRenderJob **)(*(void *)(v12 + ((v17 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v17 & 0x1FF))) {
        goto LABEL_180;
      }
    }
    if ((*((_DWORD *)this + 17) & 0x80000000) != 0)
    {
      uint64_t v19 = *v15;
      TypeLabel = HGRenderJob::GetTypeLabel(*v15);
      printf("GetRenderJobFromQueue: Job<%p> type %s priority [%d] :  min exec priority [%d]\n", v19, TypeLabel, *((_DWORD *)*v15 + 26), *((_DWORD *)this + 14));
      uint64_t v18 = *v15;
      if (*((_DWORD *)*v15 + 27) != 6) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v18 = *v15;
      if (*((_DWORD *)*v15 + 27) != 6) {
        goto LABEL_28;
      }
    }
    if (*((_DWORD *)v18 + 3) != 4) {
      goto LABEL_118;
    }
LABEL_28:
    if (v11 == 1 && (*((_DWORD *)v18 + 3) - 2) >= 5) {
      break;
    }
    if (*((_DWORD *)v18 + 26) < *((_DWORD *)this + 14))
    {
      if ((*((unsigned char *)this + 68) & 0x40) == 0) {
        goto LABEL_157;
      }
      printf("GetRenderJobFromQueue: Job<%p> not executed: priority [%d] is lower than min priority [%d]\n");
      goto LABEL_166;
    }
    int v21 = *((_DWORD *)v18 + 3);
    switch(v21)
    {
      case 1:
        if (!*((_DWORD *)v18 + 4))
        {
          uint64_t v27 = v16;
          int v28 = "Synchronous Render Job: ANY resource requested.";
          goto LABEL_99;
        }
        if (HGRenderJob::UsesOnlyCPUResource(v18) && HGRenderExecUnit::IsCPU(a2))
        {
          uint64_t v18 = *v15;
          *a3 = *v15;
          uint64_t v32 = "Synchronous Render Job: CPU resource requested.";
        }
        else
        {
          if (!HGRenderJob::UsesOnlyGPUResource(*v15) || !HGRenderExecUnit::IsGPU(a2)) {
            goto LABEL_118;
          }
          unint64_t v34 = *v15;
          if (!*((_DWORD *)*v15 + 47))
          {
            *a3 = v34;
            unsigned long long v85 = "Synchronous Render Job: GPU resource requested.";
            goto LABEL_181;
          }
          if (!HGRenderJob::IsRequestedVirtualScreen(v34, GLVirtualScreen)) {
            goto LABEL_118;
          }
          uint64_t v18 = *v15;
          *a3 = *v15;
          uint64_t v32 = "Synchronous Render Job: GPU Renderer/VScreen specified.";
        }
        break;
      case 3:
        BOOL IsGPU = HGRenderExecUnit::IsGPU(a2);
        if (v11) {
          BOOL v30 = IsGPU;
        }
        else {
          BOOL v30 = 0;
        }
        if (!v30) {
          goto LABEL_51;
        }
        uint64_t v18 = *v15;
        uint64_t v31 = *((void *)*v15 + 3);
        if (!v31 || v31 != *(void *)(*((void *)a2 + 6) + 16)) {
          goto LABEL_51;
        }
        uint64_t v27 = v16;
        int v28 = "XGMI Buffer Copy Job: Destination compute device match";
        goto LABEL_99;
      case 2:
        BOOL v22 = HGRenderExecUnit::IsGPU(a2);
        if (v11) {
          BOOL v23 = v22;
        }
        else {
          BOOL v23 = 0;
        }
        if (!v23) {
          goto LABEL_51;
        }
        IsRequestedint VirtualScreen = HGRenderJob::IsRequestedVirtualScreen(*v15, GLVirtualScreen);
        uint64_t v18 = *v15;
        uint64_t v25 = *((void *)*v15 + 22);
        if (v25) {
          LODWORD(v25) = v25 == *((void *)a2 + 7);
        }
        uint64_t v26 = *((void *)v18 + 3);
        if (v26) {
          LOBYTE(v26) = v26 == *(void *)(*((void *)a2 + 6) + 16);
        }
        if (((IsRequestedVirtualScreen | v25) & 1) == 0 && (v26 & 1) == 0)
        {
LABEL_51:
          unsigned long long v85 = 0;
          goto LABEL_135;
        }
        uint64_t v27 = v16;
        int v28 = "CPU Buffer Copy To GPU Job: Virtual Screen, Renderer, or Compute Device Match";
        goto LABEL_99;
      default:
        uint64_t v33 = *((void *)v18 + 22);
        if (v33)
        {
          if (v33 != *((void *)a2 + 7))
          {
            if (!v21
              && ((*(uint64_t (**)(uint64_t))(*(void *)v33 + 304))(v33) & 1) == 0
              && HGRenderExecUnit::IsGPU(a2))
            {
              HGGPURenderer::GetContext(*((void *)*v15 + 22), 24, (uint64_t *)&v90);
              HGGLContext::Share();
            }
LABEL_118:
            unsigned long long v85 = 0;
LABEL_119:
            uint64_t v18 = *a3;
            if (!*a3) {
              goto LABEL_135;
            }
            goto LABEL_120;
          }
          BOOL v44 = v21 == 4;
          uint64_t v27 = (v21 == 4) & v16;
          if (!v44)
          {
            unsigned long long v85 = "Renderer Specified";
            if ((v16 ^ 1)) {
              goto LABEL_100;
            }
            unsigned long long v85 = 0;
            uint64_t v16 = 1;
            goto LABEL_119;
          }
          int v28 = "Renderer Specified";
LABEL_99:
          unsigned long long v85 = v28;
LABEL_100:
          *a3 = v18;
          uint64_t v16 = v27;
          goto LABEL_120;
        }
        if (HGRenderJob::SpecifiesComputeDevices(v18))
        {
          uint64_t v35 = *((void *)a2 + 6);
          unint64_t v36 = *(HGSynchronizable **)(v35 + 16);
          uint64_t v37 = *(void *)(v35 + 24);
          unsigned long long v95 = v36;
          uint64_t v96 = v37;
          if (v37) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v37 + 8), 1uLL, memory_order_relaxed);
          }
          __int32 v38 = *v15;
          if (*((HGSynchronizable **)*v15 + 3) == v36)
          {
            *a3 = v38;
            unsigned long long v45 = "Compute Device Specified";
            goto LABEL_114;
          }
          long long v39 = (HGSynchronizable *)*((void *)v38 + 10);
          if (v39)
          {
            if (v39 == v36)
            {
              *a3 = v38;
              unsigned long long v45 = "Preferred GPU Compute Device Specified";
              goto LABEL_114;
            }
            if ((HGRenderQueue::FindIdleRenderExecUnitForJobWithPreferredVirtualScreen(this, v38) & 1) == 0)
            {
              long long v40 = (HGSynchronizable **)*((void *)*v15 + 5);
              uint64_t v41 = (HGSynchronizable **)*((void *)*v15 + 6);
              if (v40 == v41)
              {
                *a3 = *v15;
                unsigned long long v45 = "Preferred Compute Device Not Available. Using Alternate Compute Device.";
              }
              else
              {
                while (1)
                {
                  uint64_t v42 = *v40;
                  uint64_t v88 = *v40;
                  uint64_t v43 = v40[1];
                  unint64_t v89 = v43;
                  if (v43) {
                    atomic_fetch_add_explicit(&v43->var1.__sig, 1uLL, memory_order_relaxed);
                  }
                  if (v42 == v95) {
                    break;
                  }
                  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v88);
                  v40 += 2;
                  if (v40 == v41) {
                    goto LABEL_106;
                  }
                }
                *a3 = *v15;
                std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v88);
                unsigned long long v45 = "Preferred Compute Device Not Available. Using Alternate Compute Device From List.";
              }
              goto LABEL_114;
            }
LABEL_106:
            unsigned long long v85 = 0;
          }
          else
          {
            unint64_t v46 = (HGSynchronizable **)*((void *)v38 + 5);
            uint64_t v47 = (HGSynchronizable **)*((void *)v38 + 6);
            if (v46 == v47) {
              goto LABEL_106;
            }
            while (1)
            {
              unint64_t v48 = *v46;
              uint64_t v88 = *v46;
              unsigned long long v49 = v46[1];
              unint64_t v89 = v49;
              if (v49) {
                atomic_fetch_add_explicit(&v49->var1.__sig, 1uLL, memory_order_relaxed);
              }
              if (v48 == v95) {
                break;
              }
              std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v88);
              v46 += 2;
              if (v46 == v47) {
                goto LABEL_106;
              }
            }
            *a3 = *v15;
            std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v88);
            unsigned long long v45 = "Compute Device Selected from Compute Device List";
LABEL_114:
            unsigned long long v85 = v45;
          }
          std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&v95);
          goto LABEL_119;
        }
        uint64_t v18 = *v15;
        if (!*((_DWORD *)*v15 + 4))
        {
          uint64_t v27 = v16;
          int v28 = "Any Resource";
          goto LABEL_99;
        }
        if (HGRenderJob::UsesOnlyCPUResource(*v15) && HGRenderExecUnit::IsCPU(a2))
        {
          uint64_t v18 = *v15;
          *a3 = *v15;
          uint64_t v32 = "CPU Resource";
        }
        else
        {
          if (!HGRenderJob::UsesOnlyGPUResource(*v15) || !HGRenderExecUnit::IsGPU(a2)) {
            goto LABEL_118;
          }
          uint64_t v18 = *v15;
          if (*((_DWORD *)*v15 + 47))
          {
            if (!HGRenderJob::IsRequestedVirtualScreen(*v15, GLVirtualScreen)) {
              goto LABEL_118;
            }
            uint64_t v18 = *v15;
            *a3 = *v15;
            uint64_t v32 = "GPU Resource, VScreen requested and was available";
          }
          else
          {
            int v50 = *((_DWORD *)v18 + 48);
            if (v50 < 0)
            {
              uint64_t v27 = v16;
              int v28 = "GPU Resource, Any screen";
              goto LABEL_99;
            }
            if (v50 == GLVirtualScreen)
            {
              uint64_t v27 = v16;
              int v28 = "GPU Resource, Preferred VScreen requested and was available";
              goto LABEL_99;
            }
            if (HGRenderQueue::FindIdleRenderExecUnitForJobWithPreferredVirtualScreen(this, *v15)) {
              goto LABEL_118;
            }
            uint64_t v18 = *v15;
            *a3 = *v15;
            uint64_t v32 = "GPU Resource, Preferred VScreen requested but was not available";
          }
        }
        break;
    }
    unsigned long long v85 = v32;
    if (!v18) {
      goto LABEL_135;
    }
LABEL_120:
    unsigned int v51 = *((_DWORD *)v18 + 3);
    if (v51 != 2)
    {
      if (v51 >= 2)
      {
        if (v51 != 7) {
          goto LABEL_180;
        }
        if (*((unsigned char *)this + 75))
        {
          if (HGRenderQueue::GetNumActiveGPUCustomRenderJobs(this))
          {
            if ((*((unsigned char *)this + 68) & 0x10) != 0)
            {
              PCICCTransferFunctionLUT::getLUTEnd(a2);
              HGRenderJob::GetUserName(*a3);
              printf("%s : NOT DEQUEUED : kTypeCustom : (%s) :  Reason: Serialize custom jobs. '%s'\n");
            }
            goto LABEL_211;
          }
          uint64_t v18 = *a3;
        }
        if (!*((void *)v18 + 22)) {
          *((void *)v18 + 22) = *((void *)a2 + 7);
        }
        unsigned long long v87 = (uint64_t *)((char *)this + 160);
      }
      else
      {
        if (!*((_DWORD *)a2 + 10))
        {
          if (HGRenderQueue::GetThrottleFlagOnVirtualScreen(this, GLVirtualScreen))
          {
            if (*((unsigned char *)this + 69))
            {
              PCICCTransferFunctionLUT::getLUTEnd(a2);
              HGRenderJob::GetUserName(*a3);
              printf("%s :NOT DEQUEUED: kTypeRender : (%s) :  Reason: Throttle for PBO downloads. '%s'\n");
            }
          }
          else
          {
            if (!HGRenderQueue::GetLockFlagOnVirtualScreen(this, GLVirtualScreen))
            {
              if (*((unsigned char *)this + 72))
              {
                if (*((unsigned char *)this + 74)) {
                  int v78 = *((_DWORD *)*a3 + 26);
                }
                else {
                  int v78 = 0;
                }
                if (HGRenderQueue::GetNumActiveGPURenderJobs((uint64_t)this, GLVirtualScreen, v78))
                {
                  if ((*((unsigned char *)this + 68) & 0x10) != 0)
                  {
                    PCICCTransferFunctionLUT::getLUTEnd(a2);
                    HGRenderJob::GetUserName(*a3);
                    printf("%s : NOT DEQUEUED : kTypeRender : (%s) :  Reason: Serialize renders. '%s'\n");
                  }
                  goto LABEL_211;
                }
                unsigned long long v83 = *a3;
                *((_DWORD *)v83 + 46) = GLVirtualScreen;
                if (!*((void *)v83 + 22))
                {
                  *((void *)v83 + 22) = *((void *)a2 + 7);
                  goto LABEL_179;
                }
                HGRenderExecUnit::RemoveEnqueuedRenderJob(a2, v83);
                if ((*((unsigned char *)this + 69) & 4) == 0) {
                  goto LABEL_179;
                }
              }
              else
              {
                uint64_t v79 = *a3;
                *((_DWORD *)v79 + 46) = GLVirtualScreen;
                if (!*((void *)v79 + 22))
                {
                  *((void *)v79 + 22) = *((void *)a2 + 7);
                  goto LABEL_179;
                }
                HGRenderExecUnit::RemoveEnqueuedRenderJob(a2, v79);
                if ((*((unsigned char *)this + 69) & 4) == 0) {
                  goto LABEL_179;
                }
              }
              int v80 = *((_DWORD *)a2 + 2);
              uint64_t v81 = HGRenderExecUnit::NumEnqueuedRenderJobs(a2);
              printf("RenderUnit<%d> Execute: Count: %lu\n", v80, v81);
              goto LABEL_179;
            }
            if ((*((unsigned char *)this + 68) & 0x10) != 0)
            {
              PCICCTransferFunctionLUT::getLUTEnd(a2);
              HGRenderJob::GetUserName(*a3);
              printf("%s :NOT DEQUEUED: kTypeRender : (%s) :  Reason: Virtual Screen Locked by Client. '%s'\n");
            }
          }
LABEL_211:
          uint64_t v7 = 0;
          *a3 = 0;
          goto LABEL_212;
        }
        if (HGRenderQueue::GetLockFlagOnVirtualScreen(this, -1))
        {
          if ((*((unsigned char *)this + 68) & 0x10) != 0)
          {
            PCICCTransferFunctionLUT::getLUTEnd(a2);
            HGRenderJob::GetUserName(*a3);
            printf("%s :NOT DEQUEUED: kTypeRender : (%s) :  Reason: CPU Locked by Client. '%s'\n");
          }
          goto LABEL_211;
        }
        if (*((unsigned char *)this + 73) && HGRenderQueue::GetNumActiveCPURenderJobs(this))
        {
          if ((*((unsigned char *)this + 68) & 0x10) != 0)
          {
            PCICCTransferFunctionLUT::getLUTEnd(a2);
            HGRenderJob::GetUserName(*a3);
            printf("%s :NOT DEQUEUED: kTypeRender : (%s) :  Reason: Serializing CPU renders. '%s'\n");
          }
          goto LABEL_211;
        }
        if (!*((void *)*a3 + 22)) {
          *((void *)*a3 + 22) = *((void *)a2 + 7);
        }
      }
LABEL_179:
      std::list<HGRenderJob *>::push_back(v87, (uint64_t *)a3);
      goto LABEL_180;
    }
    if (!*((unsigned char *)this + 77))
    {
      *((_DWORD *)v18 + 46) = GLVirtualScreen;
      if (!*((void *)v18 + 22))
      {
        *((void *)v18 + 22) = *((void *)a2 + 7);
        uint64_t v18 = *a3;
      }
      uint64_t v63 = *((void *)v18 + 8);
      uint64_t v62 = (void *)((char *)v18 + 64);
      if (!v63)
      {
        std::shared_ptr<HGComputeDevice const>::operator=[abi:ne180100]<HGGPUComputeDevice const,void>(v62, (uint64_t *)(*((void *)a2 + 6) + 16));
        goto LABEL_180;
      }
      goto LABEL_181;
    }
    uint64_t v52 = (HGSynchronizable *)*((void *)this + 43);
    unsigned long long v95 = v52;
    LOBYTE(v96) = 0;
    HGSynchronizable::Lock(v52);
    long long v84 = v15;
    uint64_t v53 = a2;
    uint64_t v54 = v11;
    uint64_t v55 = v14;
    int16x8_t v56 = (uint64_t *)*((void *)this + 18);
    if (v56 == v87)
    {
      uint64_t v57 = 0;
    }
    else
    {
      uint64_t v57 = 0;
      do
      {
        uint64_t v58 = v56[2];
        if (((*(uint64_t (**)(void))(**(void **)(v58 + 176) + 304))(*(void *)(v58 + 176)) & 1) == 0
          && (*(_DWORD *)(v58 + 104) & 0x80000000) == 0
          && *(_DWORD *)(v58 + 184) == GLVirtualScreen)
        {
          ++v57;
        }
        int16x8_t v56 = (uint64_t *)v56[1];
      }
      while (v56 != v87);
    }
    HGSynchronizable::Unlock(v52);
    uint64_t v14 = v55;
    if (!v57)
    {
      uint64_t v64 = *a3;
      *((_DWORD *)v64 + 46) = GLVirtualScreen;
      a2 = v53;
      if (!*((void *)v64 + 22))
      {
        *((void *)v64 + 22) = *((void *)v53 + 7);
        uint64_t v64 = *a3;
      }
      uint64_t v66 = *((void *)v64 + 8);
      unsigned long long v65 = (void *)((char *)v64 + 64);
      uint64_t v15 = v84;
      if (!v66) {
        std::shared_ptr<HGComputeDevice const>::operator=[abi:ne180100]<HGGPUComputeDevice const,void>(v65, (uint64_t *)(*((void *)a2 + 6) + 16));
      }
      goto LABEL_179;
    }
    uint64_t v11 = v54;
    a2 = v53;
    uint64_t v15 = v84;
    if ((*((unsigned char *)this + 68) & 0x10) != 0)
    {
      uint64_t LUTEnd = (const char *)PCICCTransferFunctionLUT::getLUTEnd(a2);
      UserName = HGRenderJob::GetUserName(*a3);
      printf("%s :NOT DEQUEUED: kTypeCopyCPUBitmapToGPUTexture : (%s) :  Reason: Serialize renders/uploads. '%s'\n", LUTEnd, v85, UserName);
    }
    *a3 = 0;
LABEL_135:
    if ((HGRenderJob **)((char *)++v15 - *(void *)v14) == (HGRenderJob **)4096)
    {
      unint64_t v61 = *(HGRenderJob ***)(v14 + 8);
      v14 += 8;
      uint64_t v15 = v61;
    }
    uint64_t v12 = *((void *)this + 38);
    uint64_t v13 = *((void *)this + 39);
  }
  if ((*((unsigned char *)this + 69) & 0x40) == 0)
  {
LABEL_157:
    unsigned long long v85 = 0;
    goto LABEL_180;
  }
  printf("GetRenderJobFromQueue: Job<%p> not executed: Work unit only performs CPU to GPU buffer copy/delete jobs \n");
LABEL_166:
  unsigned long long v85 = 0;
LABEL_180:
  if (*a3)
  {
LABEL_181:
    std::deque<Pipeline *>::erase((int64x2_t *)((char *)this + 296), (char *)v14, (char *)v15);
    uint64_t v67 = *((void *)*a3 + 22);
    if (v67) {
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v67 + 120))(v67, 13, 0);
    }
    if ((*((unsigned char *)this + 71) & 0x40) != 0)
    {
      int16x8_t v68 = (const char *)PCICCTransferFunctionLUT::getLUTEnd(a2);
      unsigned long long v69 = HGRenderJob::GetTypeLabel(*a3);
      uint64_t v70 = *a3;
      int16x8_t v71 = HGRenderJob::GetUserName(*a3);
      printf("%s : DequeueJob: %s : %s (job %p) '%s'\n", v68, v69, v85, v70, v71);
    }
    if (*((_DWORD *)this + 3) == 1) {
      --*((void *)this + 6);
    }
    if ((*((unsigned char *)this + 69) & 8) == 0 || *((_DWORD *)*a3 + 3))
    {
LABEL_189:
      uint64_t v7 = 1;
      goto LABEL_212;
    }
    uint64_t v7 = 1;
    if (!*((unsigned char *)this + 352))
    {
      *((unsigned char *)this + 352) = 1;
      uint64_t v72 = *((void *)this + 38);
      if (*((void *)this + 39) != v72)
      {
        unint64_t v73 = *((void *)this + 41);
        unsigned long long v74 = (void *)(v72 + 8 * (v73 >> 9));
        uint64_t v75 = *v74 + 8 * (v73 & 0x1FF);
        uint64_t v76 = *(void *)(v72 + (((*((void *)this + 42) + v73) >> 6) & 0x3FFFFFFFFFFFFF8))
            + 8 * ((*((void *)this + 42) + v73) & 0x1FF);
        while (v75 != v76)
        {
          if (!*(_DWORD *)(*(void *)v75 + 12))
          {
            *((unsigned char *)this + 352) = 0;
            goto LABEL_189;
          }
          v75 += 8;
          if (v75 - *v74 == 4096)
          {
            uint64_t v77 = v74[1];
            ++v74;
            uint64_t v75 = v77;
          }
        }
      }
      *((void *)this + 45) = mach_absolute_time();
      goto LABEL_189;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
LABEL_212:
  unsigned long long v82 = v92;
  if (v92 && !atomic_fetch_add(&v92->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
    std::__shared_weak_count::__release_weak(v82);
  }
  if (!v94) {
LABEL_6:
  }
    HGSynchronizable::Unlock(v93);
  return v7;
}

void sub_1B7834420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,PCSharedCount a21,char a22,uint64_t a23,HGSynchronizable *a24)
{
}

void sub_1B78344E8()
{
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)(v0 - 104));
  JUMPOUT(0x1B78344F4);
}

void ___ZN13HGRenderQueue12GetRenderJobEP16HGRenderExecUnitPP11HGRenderJob_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  HGRenderQueue::NotifyIdleRenderUnits((HGRenderQueue *)v1);
  unint64_t v2 = *(NSObject **)(v1 + 744);

  dispatch_group_leave(v2);
}

void *std::list<HGRenderJob *>::push_back(uint64_t *a1, uint64_t *a2)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v5 = *a2;
  result[1] = a1;
  result[2] = v5;
  uint64_t v6 = *a1;
  *uint64_t result = *a1;
  *(void *)(v6 + 8) = result;
  *a1 = (uint64_t)result;
  ++a1[2];
  return result;
}

void HGRenderQueue::AddUserJobQueue(HGRenderQueue *this)
{
}

void sub_1B783464C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
  MEMORY[0x1BA9BFBA0](v9, 0x10A1C4022CE9198);
  HGSynchronizer::~HGSynchronizer(&a9);
  _Unwind_Resume(a1);
}

void sub_1B7834678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

uint64_t HGRenderQueue::EnqueueUserJob(HGRenderQueue *this, HGUserJob *a2)
{
  double v20 = a2;
  unint64_t v4 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v4);
  if (*((_DWORD *)this + 4) == 3)
  {
    BOOL v5 = 0;
    uint64_t v6 = 4294966305;
  }
  else if (*((unsigned char *)this + 43))
  {
    int v7 = *((_DWORD *)a2 + 5);
    if (v7)
    {
      uint64_t v8 = *((void *)this + 47);
      if ((HGRenderQueue *)v8 == (HGRenderQueue *)((char *)this + 368))
      {
LABEL_8:
        BOOL v5 = 0;
      }
      else
      {
        while (1)
        {
          int v9 = *(_DWORD *)(*(void *)(v8 + 16) + 24);
          BOOL v5 = v9 == v7;
          if (v9 == v7) {
            break;
          }
          uint64_t v8 = *(void *)(v8 + 8);
          if ((HGRenderQueue *)v8 == (HGRenderQueue *)((char *)this + 368)) {
            goto LABEL_8;
          }
        }
      }
      uint64_t v6 = 4294966302;
    }
    else
    {
      uint64_t v6 = 4294966302;
      BOOL v5 = 1;
    }
  }
  else
  {
    BOOL v5 = 0;
    uint64_t v6 = 4294966301;
  }
  HGSynchronizable::Unlock(v4);
  if (v5)
  {
    (*(void (**)(HGUserJob *))(*(void *)a2 + 16))(a2);
    HGUserJob::SetState((uint64_t)a2, 2);
    *((void *)a2 + 7) = this;
    HGUserJob::CallNotifyFunc(a2);
    uint64_t v10 = (HGSynchronizable *)*((void *)this + 59);
    HGSynchronizable::Lock(v10);
    unint64_t v11 = *((void *)this + 57);
    uint64_t v12 = *((void *)this + 54);
    uint64_t v13 = v12 + 8 * (v11 >> 9);
    if (*((void *)this + 55) == v12)
    {
      uint64_t v14 = 0;
      uint64_t v15 = (void *)((char *)this + 464);
    }
    else
    {
      uint64_t v14 = *(void *)v13 + 8 * (*((void *)this + 57) & 0x1FFLL);
      uint64_t v15 = (void *)((char *)this + 464);
      uint64_t v16 = *(void *)(v12 + (((*((void *)this + 58) + v11) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*((void *)this + 58) + v11) & 0x1FF);
      if (v14 != v16)
      {
        while (*((_DWORD *)a2 + 3) <= *(_DWORD *)(*(void *)v14 + 12))
        {
          v14 += 8;
          if (v14 - *(void *)v13 == 4096)
          {
            uint64_t v17 = *(void *)(v13 + 8);
            v13 += 8;
            uint64_t v14 = v17;
          }
          if (v14 == v16)
          {
            uint64_t v14 = v16;
            break;
          }
        }
      }
    }
    std::deque<HGUserJob *>::insert((void *)this + 53, (char *)v13, v14, (char *)&v20);
    if (*((_DWORD *)this + 17)) {
      printf("EnqueueUserJob: User Queue Size: %lu\n", *v15);
    }
    HGSynchronizable::Unlock(v10);
    uint64_t v19 = (HGSynchronizable *)*((void *)this + 49);
    HGSynchronizable::Lock(v19);
    HGSynchronizable::NotifyAll(v19);
    HGSynchronizable::Unlock(v19);
    return 0;
  }
  return v6;
}

void sub_1B78348A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B78348C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void *std::deque<HGUserJob *>::insert(void *a1, char *a2, uint64_t a3, char *a4)
{
  unint64_t v6 = a1[4];
  uint64_t v7 = a1[1];
  uint64_t v8 = a1[2];
  int v9 = (char *)(v7 + 8 * (v6 >> 9));
  if (v8 == v7)
  {
    uint64_t v10 = 0;
    if (a3)
    {
LABEL_3:
      unint64_t v11 = ((a3 - *(void *)a2) >> 3) + ((a2 - v9) << 6) - ((v10 - *(void *)v9) >> 3);
      unint64_t v12 = a1[5];
      unint64_t v13 = v12 - v11;
      if (v11 < v12 - v11) {
        goto LABEL_4;
      }
LABEL_14:
      if (v8 == v7) {
        uint64_t v22 = 0;
      }
      else {
        uint64_t v22 = ((v8 - v7) << 6) - 1;
      }
      if (v22 == v12 + v6)
      {
        std::deque<HGUserJob *>::__add_back_capacity((uint64_t)a1);
        unint64_t v12 = a1[5];
        unint64_t v13 = v12 - v11;
      }
      if (v12 == v11)
      {
        *(void *)(*(void *)(a1[1] + (((a1[4] + v11) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[4] + v11) & 0x1FF)) = *(void *)a4;
        a1[5] = v11 + 1;
        unint64_t v23 = a1[4];
        uint64_t v24 = a1[1];
        uint64_t result = (void *)(v24 + 8 * (v23 >> 9));
        if (a1[2] != v24) {
          goto LABEL_55;
        }
        goto LABEL_47;
      }
      uint64_t v63 = a4;
      unint64_t v26 = a1[4] + v12;
      uint64_t v27 = a1[1];
      int v28 = (char *)(v27 + 8 * (v26 >> 9));
      uint64_t v29 = *(void *)v28 + 8 * (v26 & 0x1FF);
      if (a1[2] == v27) {
        BOOL v30 = 0;
      }
      else {
        BOOL v30 = (char *)v29;
      }
      uint64_t v31 = (uint64_t)&v30[-*(void *)v28];
      uint64_t v32 = v31 >> 3;
      if (v31 < 9)
      {
        unint64_t v51 = 512 - v32;
        unint64_t v34 = &v28[-8 * (v51 >> 9)];
        uint64_t v35 = (char *)(*(void *)v34 + 8 * (~(_WORD)v51 & 0x1FF));
        if (v35 != a4) {
          goto LABEL_44;
        }
      }
      else
      {
        unint64_t v33 = v32 - 1;
        unint64_t v34 = &v28[8 * (v33 >> 9)];
        uint64_t v35 = (char *)(*(void *)v34 + 8 * (v33 & 0x1FF));
        if (v35 != a4) {
          goto LABEL_44;
        }
      }
      uint64_t v63 = v30;
      a4 = v30;
LABEL_44:
      *(void *)BOOL v30 = *(void *)v35;
      a1[5] = v12 + 1;
      if (v13 >= 2)
      {
        uint64_t v55 = ((uint64_t)&v30[-*(void *)v28] >> 3) - v13;
        if (v55 < 1)
        {
          unint64_t v61 = 511 - v55;
          int16x8_t v56 = &v28[-8 * (v61 >> 9)];
          uint64_t v57 = (char *)(*(void *)v56 + 8 * (~(_WORD)v61 & 0x1FF));
        }
        else
        {
          int16x8_t v56 = &v28[8 * ((unint64_t)v55 >> 9)];
          uint64_t v57 = (char *)(*(void *)v56 + 8 * (v55 & 0x1FF));
        }
        int v28 = std::deque<HGRenderJob *>::__move_backward_and_check((uint64_t)a1, v56, v57, v34, v35, v28, v30, (unint64_t *)&v63);
        BOOL v30 = v62;
        uint64_t v52 = *(void *)v63;
        if (v62 != *(char **)v28)
        {
LABEL_46:
          *((void *)v30 - 1) = v52;
          unint64_t v23 = a1[4];
          uint64_t v53 = a1[1];
          uint64_t result = (void *)(v53 + 8 * (v23 >> 9));
          if (a1[2] != v53) {
            goto LABEL_55;
          }
          goto LABEL_47;
        }
      }
      else
      {
        uint64_t v52 = *(void *)a4;
        if (v30 != *(char **)v28) {
          goto LABEL_46;
        }
      }
      BOOL v30 = (char *)(*((void *)v28 - 1) + 4096);
      goto LABEL_46;
    }
  }
  else
  {
    uint64_t v10 = *(void *)v9 + 8 * (a1[4] & 0x1FFLL);
    if (a3 != v10) {
      goto LABEL_3;
    }
  }
  unint64_t v11 = 0;
  unint64_t v12 = a1[5];
  unint64_t v13 = v12;
  if (!v12) {
    goto LABEL_14;
  }
LABEL_4:
  if (v6)
  {
    if (v11) {
      goto LABEL_6;
    }
  }
  else
  {
    std::deque<HGUserJob *>::__add_front_capacity((uint64_t)a1);
    if (v11)
    {
LABEL_6:
      uint64_t v63 = a4;
      unint64_t v14 = a1[4];
      uint64_t v15 = a1[1];
      uint64_t v16 = (char *)(v15 + 8 * (v14 >> 9));
      uint64_t v17 = *(void *)v16;
      if (a1[2] == v15) {
        uint64_t v18 = 0;
      }
      else {
        uint64_t v18 = (char *)(*(void *)v16 + 8 * (a1[4] & 0x1FFLL));
      }
      uint64_t v19 = (uint64_t)&v18[-v17];
      uint64_t v20 = (uint64_t)&v18[-v17] >> 3;
      if (v19 < 9)
      {
        int v21 = (char *)(*(void *)&v16[-8 * ((unint64_t)(512 - v20) >> 9)] + 8 * (~(512 - (_WORD)v20) & 0x1FF));
        if (v18 != a4) {
          goto LABEL_38;
        }
      }
      else
      {
        int v21 = (char *)(*(void *)&v16[((unint64_t)(v20 - 1) >> 6) & 0x3FFFFFFFFFFFFF8]
                     + 8 * ((v20 - 1) & 0x1FF));
        if (v18 != a4) {
          goto LABEL_38;
        }
      }
      uint64_t v63 = v21;
      a4 = v21;
LABEL_38:
      *(void *)int v21 = *(void *)v18;
      uint64_t v42 = a1[5] + 1;
      a1[4] = v14 - 1;
      a1[5] = v42;
      if (v11 < 2) {
        goto LABEL_54;
      }
      uint64_t v43 = (uint64_t)&v18[-*(void *)v16];
      uint64_t v44 = v43 >> 3;
      if (v43 < -7)
      {
        unsigned long long v45 = &v16[-8 * ((unint64_t)(510 - v44) >> 9)];
        unint64_t v46 = (char *)(*(void *)v45 + 8 * (~(510 - (_WORD)v44) & 0x1FF));
        uint64_t v47 = v44 + v11;
        if (v47 < 1) {
          goto LABEL_41;
        }
      }
      else
      {
        unsigned long long v45 = &v16[8 * ((unint64_t)(v44 + 1) >> 9)];
        unint64_t v46 = (char *)(*(void *)v45 + 8 * ((v44 + 1) & 0x1FF));
        uint64_t v47 = v44 + v11;
        if (v47 < 1)
        {
LABEL_41:
          unint64_t v48 = 511 - v47;
          unsigned long long v49 = &v16[-8 * (v48 >> 9)];
          int v50 = (char *)(*(void *)v49 + 8 * (~(_WORD)v48 & 0x1FF));
LABEL_53:
          std::deque<HGRenderJob *>::__move_and_check((int)a1, v45, v46, v49, v50, v16, v18, (unint64_t *)&v63);
          uint64_t v18 = v58;
          a4 = v63;
LABEL_54:
          *(void *)uint64_t v18 = *(void *)a4;
          unint64_t v23 = a1[4];
          uint64_t v59 = a1[1];
          uint64_t result = (void *)(v59 + 8 * (v23 >> 9));
          if (a1[2] != v59) {
            goto LABEL_55;
          }
          goto LABEL_47;
        }
      }
      unsigned long long v49 = &v16[8 * ((unint64_t)v47 >> 9)];
      int v50 = (char *)(*(void *)v49 + 8 * (v47 & 0x1FF));
      goto LABEL_53;
    }
  }
  unint64_t v36 = a1[4];
  uint64_t v37 = a1[1];
  __int32 v38 = (void *)(v37 + 8 * (v36 >> 9));
  if (a1[2] == v37) {
    uint64_t v39 = 0;
  }
  else {
    uint64_t v39 = *v38 + 8 * (a1[4] & 0x1FFLL);
  }
  if (v39 == *v38) {
    uint64_t v39 = *(v38 - 1) + 4096;
  }
  *(void *)(v39 - 8) = *(void *)a4;
  uint64_t v40 = a1[5] + 1;
  a1[4] = v36 - 1;
  a1[5] = v40;
  unint64_t v23 = a1[4];
  uint64_t v41 = a1[1];
  uint64_t result = (void *)(v41 + 8 * (v23 >> 9));
  if (a1[2] != v41)
  {
LABEL_55:
    uint64_t v54 = *result + 8 * (v23 & 0x1FF);
    if (!v11) {
      return result;
    }
    goto LABEL_56;
  }
LABEL_47:
  uint64_t v54 = 0;
  if (!v11) {
    return result;
  }
LABEL_56:
  uint64_t v60 = v11 + ((v54 - *result) >> 3);
  if (v60 < 1) {
    result -= (unint64_t)(511 - v60) >> 9;
  }
  else {
    result += (unint64_t)v60 >> 9;
  }
  return result;
}

uint64_t HGRenderQueue::CancelUserJobs(HGRenderQueue *this, int a2)
{
  long long v34 = 0u;
  long long v35 = 0u;
  *(_OWORD *)__p = 0u;
  unint64_t v4 = (HGSynchronizable *)*((void *)this + 59);
  __rqtp.tv_sec = (__darwin_time_t)v4;
  LOBYTE(__rqtp.tv_nsec) = 0;
  HGSynchronizable::Lock(v4);
  uint64_t v5 = *((void *)this + 54);
  unint64_t v6 = (char *)(v5 + 8 * (*((void *)this + 57) >> 9));
  if (*((void *)this + 55) == v5)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    goto LABEL_6;
  }
  uint64_t v7 = (uint64_t *)(*(void *)v6 + 8 * (*((void *)this + 57) & 0x1FFLL));
  uint64_t v8 = 0;
  while (1)
  {
    unint64_t v9 = *((void *)this + 58) + *((void *)this + 57);
    if (v7 == (uint64_t *)(*(void *)(v5 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v9 & 0x1FF))) {
      break;
    }
    while (1)
    {
      uint64_t v10 = (HGUserJob *)*v7;
      HGUserJob::SetState(*v7, 4);
      HGUserJob::CallNotifyFunc(v10);
      unint64_t v11 = (char *)__p[1];
      if ((void *)v34 == __p[1]) {
        unint64_t v12 = 0;
      }
      else {
        unint64_t v12 = (((void)v34 - (unint64_t)__p[1]) << 6) - 1;
      }
      uint64_t v13 = *((void *)&v35 + 1);
      unint64_t v14 = *((void *)&v35 + 1) + v35;
      if (v12 == *((void *)&v35 + 1) + (void)v35)
      {
        std::deque<HGUserJob *>::__add_back_capacity((uint64_t)__p);
        uint64_t v13 = *((void *)&v35 + 1);
        unint64_t v11 = (char *)__p[1];
        unint64_t v14 = v35 + *((void *)&v35 + 1);
      }
      *(void *)(*(void *)&v11[(v14 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v14 & 0x1FF)) = v10;
      *((void *)&v35 + 1) = v13 + 1;
      unint64_t v6 = (char *)std::deque<Pipeline *>::erase((int64x2_t *)((char *)this + 424), v6, (char *)v7);
      uint64_t v7 = v15;
      ++v8;
      uint64_t v5 = *((void *)this + 54);
      if (*((void *)this + 55) != v5) {
        break;
      }
LABEL_6:
      if (!v7) {
        goto LABEL_14;
      }
    }
  }
LABEL_14:
  HGSynchronizable::Unlock(v4);
  if (*((void *)&v35 + 1))
  {
    uint64_t v16 = (char *)__p[1] + 8 * ((unint64_t)v35 >> 9);
    if ((void *)v34 == __p[1]) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = (char *)(*(void *)v16 + 8 * (v35 & 0x1FF));
    }
    while (1)
    {
      if ((void *)v34 == __p[1])
      {
        if (!v17) {
          break;
        }
      }
      else if ((char *)(*(void *)((char *)__p[1] {
                                   + (((*((void *)&v35 + 1) + (void)v35) >> 6) & 0x3FFFFFFFFFFFFF8))
      }
                       + 8 * ((*((void *)&v35 + 1) + v35) & 0x1FF)) == v17)
      {
        break;
      }
      (*(void (**)(void))(**(void **)v17 + 24))();
      uint64_t v16 = (char *)std::deque<Pipeline *>::erase((int64x2_t *)__p, v16, v17);
      uint64_t v17 = v18;
    }
  }
  uint64_t v19 = (HGSynchronizable *)*((void *)this + 59);
  __rqtp.tv_sec = (__darwin_time_t)v19;
  LOBYTE(__rqtp.tv_nsec) = 0;
  HGSynchronizable::Lock(v19);
  uint64_t v20 = (char *)this + 400;
  uint64_t v21 = *((void *)this + 51);
  if ((HGRenderQueue *)v21 != (HGRenderQueue *)((char *)this + 400))
  {
    do
    {
      HGUserJob::SetState(*(void *)(v21 + 16), 4);
      ++v8;
      uint64_t v21 = *(void *)(v21 + 8);
    }
    while ((char *)v21 != v20);
  }
  HGSynchronizable::Unlock(v19);
  if (a2)
  {
    while (1)
    {
      uint64_t v22 = (HGSynchronizable *)*((void *)this + 59);
      HGSynchronizable::Lock(v22);
      uint64_t v23 = *((void *)this + 51);
      if ((char *)v23 == v20) {
        break;
      }
      while (*(_DWORD *)(*(void *)(v23 + 16) + 16) != 4)
      {
        uint64_t v23 = *(void *)(v23 + 8);
        if ((char *)v23 == v20) {
          goto LABEL_31;
        }
      }
      HGSynchronizable::Unlock(v22);
      timespec __rqtp = (timespec)xmmword_1B8347EF0;
      nanosleep(&__rqtp, &__rmtp);
    }
LABEL_31:
    HGSynchronizable::Unlock(v22);
  }
  uint64_t v24 = (void **)__p[1];
  uint64_t v25 = (void **)v34;
  *((void *)&v35 + 1) = 0;
  unint64_t v26 = v34 - (unint64_t)__p[1];
  if ((unint64_t)v34 - (unint64_t)__p[1] >= 0x11)
  {
    do
    {
      operator delete(*v24);
      uint64_t v25 = (void **)v34;
      uint64_t v24 = (void **)((char *)__p[1] + 8);
      __p[1] = v24;
      unint64_t v26 = v34 - (void)v24;
    }
    while ((void)v34 - (void)v24 > 0x10uLL);
  }
  unint64_t v27 = v26 >> 3;
  if (v27 == 1)
  {
    uint64_t v28 = 256;
    goto LABEL_38;
  }
  if (v27 == 2)
  {
    uint64_t v28 = 512;
LABEL_38:
    *(void *)&long long v35 = v28;
  }
  if (v24 != v25)
  {
    do
    {
      uint64_t v29 = *v24++;
      operator delete(v29);
    }
    while (v24 != v25);
    if ((void *)v34 != __p[1]) {
      *(void *)&long long v34 = v34 + (((unint64_t)__p[1] - v34 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
  return v8;
}

void sub_1B783517C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B78351B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  unint64_t v6 = va_arg(va1, HGSynchronizable *);
  uint64_t v8 = va_arg(va1, void);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  std::deque<HGNode *>::~deque[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetUserJob(HGRenderQueue *this, HGUserExecUnit *a2, HGUserJob **a3)
{
  unint64_t v6 = (HGSynchronizable *)*((void *)this + 49);
  HGSynchronizable::Lock(v6);
  while ((HGRenderQueue::GetUserJobFromQueue(this, a2, a3) & 1) == 0)
  {
    *((_DWORD *)a2 + 2) = 1;
    HGSynchronizable::Wait(v6);
    uint64_t v7 = (HGSynchronizable *)*((void *)this + 43);
    HGSynchronizable::Lock(v7);
    int v8 = *((_DWORD *)this + 4);
    HGSynchronizable::Unlock(v7);
    if (v8 == 3)
    {
      uint64_t v9 = 0;
      goto LABEL_6;
    }
  }
  uint64_t v9 = 1;
LABEL_6:
  HGSynchronizable::Unlock(v6);
  return v9;
}

void sub_1B7835294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

uint64_t HGRenderQueue::GetUserJobFromQueue(HGRenderQueue *this, HGUserExecUnit *a2, HGUserJob **a3)
{
  unint64_t v6 = (HGSynchronizable *)*((void *)this + 59);
  HGSynchronizable::Lock(v6);
  *a3 = 0;
  if (*((_DWORD *)this + 17)) {
    printf("GetUserJobFromQueue: User Queue Size: %lu\n", *((void *)this + 58));
  }
  if (!*((void *)this + 58)) {
    goto LABEL_13;
  }
  uint64_t v7 = (HGSynchronizable *)*((void *)this + 43);
  HGSynchronizable::Lock(v7);
  int v8 = *((_DWORD *)this + 4);
  HGSynchronizable::Unlock(v7);
  if (v8 == 2) {
    goto LABEL_13;
  }
  if (!*((void *)this + 58))
  {
LABEL_10:
    if (*((_DWORD *)this + 17)) {
      puts("GetUserJobFromQueue: Incompatible user exec unit.");
    }
    unint64_t v27 = (HGSynchronizable *)*((void *)this + 49);
    HGSynchronizable::Lock(v27);
    HGSynchronizable::NotifyAll(v27);
    HGSynchronizable::Unlock(v27);
LABEL_13:
    uint64_t v12 = 0;
    goto LABEL_14;
  }
  uint64_t v9 = 0;
  while (1)
  {
    uint64_t v10 = *(HGGLBlendingInfo **)(*(void *)(*((void *)this + 54)
                                           + (((unint64_t)(v9 + *((void *)this + 57)) >> 6) & 0x3FFFFFFFFFFFFF8))
                               + 8 * ((v9 + *((void *)this + 57)) & 0x1FF));
    int AlphaOperation = HGGLBlendingInfo::GetAlphaOperation(v10);
    if (!AlphaOperation)
    {
      *a3 = v10;
      uint64_t v14 = *((void *)this + 54);
      uint64_t v15 = (char *)(v14 + 8 * (*((void *)this + 57) >> 9));
      if (*((void *)this + 55) == v14)
      {
        uint64_t v16 = 0;
        if (!v9) {
          goto LABEL_32;
        }
      }
      else
      {
        uint64_t v16 = (char *)(*(void *)v15 + 8 * (*((void *)this + 57) & 0x1FFLL));
        if (!v9) {
          goto LABEL_32;
        }
      }
      uint64_t v18 = (uint64_t)&v16[-*(void *)v15] >> 3;
      unint64_t v19 = v18 + v9;
      if (v18 + v9 < 1)
      {
        unint64_t v22 = 511 - v9 - v18;
        LOWORD(v19) = ~(_WORD)v22;
        v15 -= 8 * (v22 >> 9);
      }
      else
      {
        v15 += 8 * (v19 >> 9);
      }
      uint64_t v16 = (char *)(*(void *)v15 + 8 * (v19 & 0x1FF));
      goto LABEL_32;
    }
    if (AlphaOperation == *((_DWORD *)a2 + 6)) {
      break;
    }
    if ((unint64_t)++v9 >= *((void *)this + 58)) {
      goto LABEL_10;
    }
  }
  *a3 = v10;
  uint64_t v17 = *((void *)this + 54);
  uint64_t v15 = (char *)(v17 + 8 * (*((void *)this + 57) >> 9));
  if (*((void *)this + 55) == v17)
  {
    uint64_t v16 = 0;
    if (!v9) {
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v16 = (char *)(*(void *)v15 + 8 * (*((void *)this + 57) & 0x1FFLL));
    if (!v9) {
      goto LABEL_32;
    }
  }
  uint64_t v20 = (uint64_t)&v16[-*(void *)v15] >> 3;
  unint64_t v21 = v20 + v9;
  if (v20 + v9 < 1)
  {
    unint64_t v23 = 511 - v9 - v20;
    LOWORD(v21) = ~(_WORD)v23;
    v15 -= 8 * (v23 >> 9);
  }
  else
  {
    v15 += 8 * (v21 >> 9);
  }
  uint64_t v16 = (char *)(*(void *)v15 + 8 * (v21 & 0x1FF));
LABEL_32:
  std::deque<Pipeline *>::erase((int64x2_t *)((char *)this + 424), v15, v16);
  uint64_t v24 = operator new(0x18uLL);
  uint64_t v25 = (uint64_t)*a3;
  v24[1] = (char *)this + 400;
  v24[2] = v25;
  uint64_t v26 = *((void *)this + 50);
  *uint64_t v24 = v26;
  *(void *)(v26 + 8) = v24;
  *((void *)this + 50) = v24;
  ++*((void *)this + 52);
  uint64_t v12 = 1;
LABEL_14:
  HGSynchronizable::Unlock(v6);
  return v12;
}

void sub_1B7835540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7835554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7835568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7835580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  unint64_t v4 = va_arg(va1, HGSynchronizable *);
  uint64_t v6 = va_arg(va1, void);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va1);
  _Unwind_Resume(a1);
}

void sub_1B783559C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B78355B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B78355CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

HGSynchronizable *HGRenderQueue::EnqueueGPUReadbackJob(HGRenderQueue *this, HGGLContext **a2)
{
  unint64_t v4 = (HGSynchronizable *)*((void *)this + 73);
  HGSynchronizable::Lock(v4);
  uint64_t v5 = *((void *)this + 69);
  uint64_t v6 = *((void *)this + 68);
  if (v5 == v6) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = ((v5 - v6) << 6) - 1;
  }
  uint64_t v8 = *((void *)this + 72);
  unint64_t v9 = v8 + *((void *)this + 71);
  if (v7 == v9)
  {
    std::deque<HGGPUReadbackJob *>::__add_back_capacity((uint64_t)this + 536);
    uint64_t v8 = *((void *)this + 72);
    uint64_t v6 = *((void *)this + 68);
    unint64_t v9 = *((void *)this + 71) + v8;
  }
  *(void *)(*(void *)(v6 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v9 & 0x1FF)) = a2;
  *((void *)this + 72) = v8 + 1;
  (*((void (**)(HGGLContext **))*a2 + 2))(a2);
  int v10 = *((_DWORD *)this + 17);
  if ((v10 & 0x1000) != 0)
  {
    unint64_t v11 = *((void *)this + 72);
LABEL_11:
    printf("EnqueueGPUReadbackJob: GPU Readback Queue Size: %lu\n", v11);
    goto LABEL_12;
  }
  if ((v10 & 0x2000) != 0)
  {
    unint64_t v11 = *((void *)this + 72);
    if (v11 >= 2) {
      goto LABEL_11;
    }
  }
LABEL_12:
  int VirtualScreen = HGGLContext::getVirtualScreen(a2[4]);
  if (*((void *)this + 72))
  {
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      if (HGGLContext::getVirtualScreen(*(HGGLContext **)(*(void *)(*(void *)(*((void *)this + 68)
                                                                                               + (((v14
                                                                                                  + *((void *)this + 71)) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                                                   + 8
                                                                                   * ((v14 + *((void *)this + 71)) & 0x1FF))
                                                                       + 32)) == VirtualScreen)
        ++v13;
      ++v14;
    }
    while (v14 < *((void *)this + 72));
    char v15 = v13 > *((void *)this + 66);
  }
  else
  {
    char v15 = 0;
  }
  HGRenderQueue::SetThrottleFlagOnVirtualScreen(this, VirtualScreen, v15);
  HGSynchronizable::Unlock(v4);
  uint64_t v17 = (HGSynchronizable *)*((void *)this + 63);
  HGSynchronizable::Lock(v17);
  HGSynchronizable::NotifyAll(v17);
  return HGSynchronizable::Unlock(v17);
}

void sub_1B783579C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B78357B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B78357C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B78357DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B78357F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetGPUReadbackJob(HGRenderQueue *this, HGGLContext **a2, HGGPUReadbackJob **a3)
{
  uint64_t v6 = (HGSynchronizable *)*((void *)this + 63);
  HGSynchronizable::Lock(v6);
  while ((HGRenderQueue::GetGPUReadbackJobFromQueue(this, a2, a3) & 1) == 0)
  {
    HGSynchronizable::Wait(v6);
    uint64_t v7 = (HGSynchronizable *)*((void *)this + 43);
    HGSynchronizable::Lock(v7);
    int v8 = *((_DWORD *)this + 4);
    HGSynchronizable::Unlock(v7);
    if (v8 == 3)
    {
      uint64_t v9 = 0;
      goto LABEL_6;
    }
  }
  uint64_t v9 = 1;
LABEL_6:
  HGSynchronizable::Unlock(v6);
  return v9;
}

void sub_1B78358B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, HGSynchronizable *a9)
{
}

uint64_t HGRenderQueue::GetGPUReadbackJobFromQueue(HGRenderQueue *this, HGGLContext **a2, HGGPUReadbackJob **a3)
{
  *a3 = 0;
  if (!*((unsigned char *)this + 76)) {
    goto LABEL_11;
  }
  int VirtualScreen = HGGLContext::getVirtualScreen(a2[6]);
  uint64_t v7 = (HGSynchronizable *)*((void *)this + 73);
  HGSynchronizable::Lock(v7);
  uint64_t v8 = *((void *)this + 75);
  if ((HGRenderQueue *)v8 == (HGRenderQueue *)((char *)this + 592))
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    do
    {
      if (HGGLContext::getVirtualScreen(*(HGGLContext **)(*(void *)(v8 + 16) + 32)) == VirtualScreen) {
        ++v9;
      }
      uint64_t v8 = *(void *)(v8 + 8);
    }
    while ((HGRenderQueue *)v8 != (HGRenderQueue *)((char *)this + 592));
  }
  HGSynchronizable::Unlock(v7);
  if (!v9)
  {
LABEL_11:
    unint64_t v11 = (HGSynchronizable *)*((void *)this + 73);
    HGSynchronizable::Lock(v11);
    if (*((void *)this + 72))
    {
      uint64_t v12 = (HGSynchronizable *)*((void *)this + 43);
      HGSynchronizable::Lock(v12);
      int v13 = *((_DWORD *)this + 4);
      HGSynchronizable::Unlock(v12);
      if (v13 != 2)
      {
        unint64_t v14 = *((void *)this + 72);
        if (v14)
        {
          uint64_t v15 = 0;
          unint64_t v16 = *((void *)this + 71);
          while (1)
          {
            uint64_t v17 = *((void *)this + 68);
            uint64_t v18 = *(void *)(*(void *)(v17 + (((v16 + v15) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v16 + v15) & 0x1FF));
            if (*(HGGLContext **)(v18 + 16) == a2[2]) {
              break;
            }
            if (++v15 >= v14) {
              goto LABEL_23;
            }
          }
          if ((*(unsigned char *)(*(void *)(*(void *)(v18 + 40) + 24) + 12) & 0x10) == 0) {
            goto LABEL_21;
          }
          if (HGRenderQueue::GetPBOFromSharedPool(this, (HGGPUReadbackExecUnit *)a2, *(HGGLContext ***)(*(void *)(v17 + (((v16 + v15) >> 6) & 0x3FFFFFFFFFFFFF8))+ 8 * ((v16 + v15) & 0x1FF))))
          {
            unint64_t v16 = *((void *)this + 71);
LABEL_21:
            *a3 = (HGGPUReadbackJob *)v18;
            uint64_t v19 = *((void *)this + 68);
            uint64_t v20 = (char *)(v19 + 8 * (v16 >> 9));
            if (*((void *)this + 69) == v19) {
              unint64_t v21 = 0;
            }
            else {
              unint64_t v21 = (char *)(*(void *)v20 + 8 * (v16 & 0x1FF));
            }
            if (v15)
            {
              uint64_t v23 = ((uint64_t)&v21[-*(void *)v20] >> 3) + v15;
              if (v23 < 1)
              {
                unint64_t v24 = 511 - v23;
                v20 -= 8 * (v24 >> 9);
                unint64_t v21 = (char *)(*(void *)v20 + 8 * (~(_WORD)v24 & 0x1FF));
              }
              else
              {
                v20 += 8 * ((unint64_t)v23 >> 9);
                unint64_t v21 = (char *)(*(void *)v20 + 8 * (v23 & 0x1FF));
              }
            }
            std::deque<Pipeline *>::erase((int64x2_t *)((char *)this + 536), v20, v21);
            if ((*((unsigned char *)this + 69) & 0x10) != 0) {
              printf("GetGPUReadbackJobFromQueue<%p>: GPU Readback Queue Size: %lu\n", a2, *((void *)this + 72));
            }
            int v25 = HGGLContext::getVirtualScreen(*(HGGLContext **)(v18 + 32));
            if (HGRenderQueue::GetThrottleFlagOnVirtualScreen(this, v25))
            {
              if (!*((void *)this + 72)) {
                goto LABEL_40;
              }
              unint64_t v26 = 0;
              unint64_t v27 = 0;
              do
              {
                if (HGGLContext::getVirtualScreen(*(HGGLContext **)(*(void *)(*(void *)(*((void *)this + 68) + (((v27 + *((void *)this + 71)) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                                                             + 8
                                                                                             * ((v27
                                                                                               + *((void *)this + 71)) & 0x1FF))
                                                                                 + 32)) == v25)
                  ++v26;
                ++v27;
              }
              while (v27 < *((void *)this + 72));
              if (v26 <= *((void *)this + 66)) {
LABEL_40:
              }
                HGRenderQueue::SetThrottleFlagOnVirtualScreen(this, v25, 0);
            }
            uint64_t v28 = operator new(0x18uLL);
            uint64_t v29 = (uint64_t)*a3;
            v28[1] = (char *)this + 592;
            v28[2] = v29;
            uint64_t v30 = *((void *)this + 74);
            *uint64_t v28 = v30;
            *(void *)(v30 + 8) = v28;
            *((void *)this + 74) = v28;
            ++*((void *)this + 76);
            uint64_t v10 = 1;
            goto LABEL_24;
          }
        }
      }
    }
LABEL_23:
    uint64_t v10 = 0;
LABEL_24:
    HGSynchronizable::Unlock(v11);
    return v10;
  }
  return 0;
}

void sub_1B7835BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7835BCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7835BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7835BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7835C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7835C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7835C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

void sub_1B7835C50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGSynchronizer::~HGSynchronizer((HGSynchronizable **)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderQueue::GetPBOFromSharedPool(HGRenderQueue *this, HGGPUReadbackExecUnit *a2, HGGLContext **a3)
{
  int VirtualScreen = HGGLContext::getVirtualScreen(*((HGGLContext **)a2 + 6));
  if (VirtualScreen != HGGLContext::getVirtualScreen(a3[4])) {
    return 0;
  }
  uint64_t v7 = (void *)((char *)a2 + 64);
  if (*((void *)a2 + 8)) {
    return 1;
  }
  int v13 = (HGSynchronizable *)*((void *)this + 80);
  char v14 = 0;
  HGSynchronizable::Lock(v13);
  if ((*((unsigned char *)this + 69) & 0x10) != 0)
  {
    if (*((void *)this + 86))
    {
      v12.unsigned int var0 = *(PC_Sp_counted_base **)(*(void *)(*(void *)(*(void *)(*((void *)this + 82)
                                                                            + ((*((void *)this + 85) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                                + 8 * (*((void *)this + 85) & 0x1FFLL))
                                                    + 16)
                                        + 8);
      HGGLContext::Share();
    }
    printf("GetPBOFromSharedPool<%p>: Getting PBO for virtual screen %d.\n", a2, VirtualScreen);
    printf("GetPBOFromSharedPool<%p>: Num available PBOs : vs0: %d/%d  vs1: %d/%d\n", a2, 0, 0, 0, 0);
  }
  if (*((void *)this + 86))
  {
    v11.unsigned int var0 = *(PC_Sp_counted_base **)(*(void *)(*(void *)(*(void *)(*((void *)this + 82)
                                                                          + ((*((void *)this + 85) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                              + 8 * (*((void *)this + 85) & 0x1FFLL))
                                                  + 16)
                                      + 8);
    HGGLContext::Share();
  }
  if (!*v7 && *((void *)a2 + 9) < *((void *)this + 65))
  {
    HGGLContext::context((uint64_t *)&v10, *((HGGLContext **)a2 + 6));
    HGGLContext::Create();
  }
  if ((*((unsigned char *)this + 69) & 0x30) != 0) {
    printf("GetPBOFromSharedPool<%p>: Warning: Max num PBOs in use (%lu in use: pboUnit for vs-%d).\n", a2, *((void *)a2 + 9), VirtualScreen);
  }
  uint64_t v8 = 0;
  *uint64_t v7 = 0;
  if (!v14) {
    HGSynchronizable::Unlock(v13);
  }
  return v8;
}

void sub_1B7836198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, PCSharedCount a14, char a15, PCSharedCount a16, char a17, uint64_t a18, HGSynchronizable *a19)
{
  PCSharedCount::PCSharedCount(&a14);
  HGObject::operator delete(v19);
  if (a18) {
    (*(void (**)(uint64_t))(*(void *)a18 + 24))(a18);
  }
  HGSynchronizer::~HGSynchronizer(&a19);
  _Unwind_Resume(a1);
}

void std::deque<HGPixelBufferObj *>::push_back(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<HGPixelBufferObj *>::__add_back_capacity((uint64_t)a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

uint64_t std::deque<HGRef<HGGLContext>>::push_back(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<HGRef<HGGLContext>>::__add_back_capacity((uint64_t)a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = v7 + a1[4];
  }
  uint64_t result = *a2;
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
    uint64_t v7 = a1[5];
  }
  a1[5] = v7 + 1;
  return result;
}

double HGTiming::GetMachTimeConversionFactor(HGTiming *this)
{
  if (qword_1EB9A20F8 != -1) {
    dispatch_once(&qword_1EB9A20F8, &__block_literal_global_90);
  }
  return *(double *)&qword_1EB9A20F0;
}

double ___ZN8HGTiming27GetMachTimeConversionFactorEv_block_invoke()
{
  if (!mach_timebase_info(&info))
  {
    LODWORD(result) = info.numer;
    LODWORD(v1) = info.denom;
    double result = (double)*(unint64_t *)&result * 0.000000001 / (double)v1;
    qword_1EB9A20F0 = *(void *)&result;
  }
  return result;
}

uint64_t std::deque<HGRef<HGGLContext>>::~deque[abi:ne180100](uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v3 = *(void ***)(a1 + 8);
    *(void *)(a1 + 40) = 0;
    unint64_t v10 = 0;
  }
  else
  {
    unint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = &v2[v4 >> 9];
    uint64_t v6 = (char *)*v5;
    uint64_t v7 = (char *)*v5 + 8 * (v4 & 0x1FF);
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v4) >> 6) & 0x3FFFFFFFFFFFFF8))
       + 8 * ((*(void *)(a1 + 40) + v4) & 0x1FF);
    if (v7 != (char *)v8)
    {
      do
      {
        if (*(void *)v7)
        {
          (*(void (**)(void))(**(void **)v7 + 24))(*(void *)v7);
          uint64_t v6 = (char *)*v5;
        }
        v7 += 8;
        if (v7 - v6 == 4096)
        {
          uint64_t v9 = (char *)v5[1];
          ++v5;
          uint64_t v6 = v9;
          uint64_t v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      unint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
    *(void *)(a1 + 40) = 0;
    unint64_t v10 = (char *)v3 - (char *)v2;
    if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
    {
      do
      {
        operator delete(*v2);
        uint64_t v3 = *(void ***)(a1 + 16);
        unint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
        *(void *)(a1 + 8) = v2;
        unint64_t v10 = (char *)v3 - (char *)v2;
      }
      while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
    }
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 256;
    goto LABEL_17;
  }
  if (v11 == 2)
  {
    uint64_t v12 = 512;
LABEL_17:
    *(void *)(a1 + 32) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      int v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 != v15) {
      *(void *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::deque<HGRenderJob *>::__add_front_capacity(uint64_t a1)
{
  uint64_t v3 = *(char **)(a1 + 8);
  unint64_t v2 = *(char **)(a1 + 16);
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v2 - v3) << 6) - 1;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if ((unint64_t)(v4 - (*(void *)(a1 + 40) + v5)) >= 0x200)
  {
    *(void *)(a1 + 32) = v5 + 512;
    uint64_t v47 = (void *)*((void *)v2 - 1);
    *(void *)(a1 + 16) = v2 - 8;
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
    return;
  }
  uint64_t v6 = *(char **)(a1 + 24);
  uint64_t v7 = *(char **)a1;
  uint64_t v8 = (uint64_t)&v6[-*(void *)a1];
  if (v2 - v3 < (unint64_t)v8)
  {
    if (v3 == v7)
    {
      uint64_t v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v47);
      uint64_t v17 = *(void *)(a1 + 16);
      uint64_t v47 = *(void **)(v17 - 8);
      *(void *)(a1 + 16) = v17 - 8;
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
        goto LABEL_9;
      }
    }
    else
    {
      uint64_t v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8)
      {
LABEL_9:
        uint64_t v9 = 256;
LABEL_19:
        *(void *)(a1 + 32) = v9;
        return;
      }
    }
    uint64_t v9 = *(void *)(a1 + 32) + 512;
    goto LABEL_19;
  }
  if (v6 == v7) {
    unint64_t v10 = 1;
  }
  else {
    unint64_t v10 = v8 >> 2;
  }
  if (v10 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  unint64_t v11 = (char *)operator new(8 * v10);
  uint64_t v12 = operator new(0x1000uLL);
  int v13 = v12;
  if (v10)
  {
    uint64_t v14 = &v11[8 * v10];
    *(void *)unint64_t v11 = v12;
    uint64_t v15 = v11 + 8;
    unint64_t v16 = v11;
    if (v3 != v2) {
      goto LABEL_29;
    }
    goto LABEL_21;
  }
  uint64_t v18 = (char *)operator new(8uLL);
  uint64_t v14 = v18 + 8;
  operator delete(v11);
  uint64_t v3 = *(char **)(a1 + 8);
  uint64_t v19 = *(char **)(a1 + 16);
  unint64_t v11 = v18;
  *(void *)uint64_t v18 = v13;
  uint64_t v15 = v18 + 8;
  unint64_t v16 = v18;
  if (v3 != v19)
  {
    while (1)
    {
LABEL_29:
      if (v15 == v14)
      {
        if (v11 <= v16)
        {
          if (v15 == v16) {
            unint64_t v31 = 1;
          }
          else {
            unint64_t v31 = (v15 - v16) >> 2;
          }
          if (v31 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v32 = (char *)operator new(8 * v31);
          unint64_t v33 = v32;
          unint64_t v34 = v31 >> 2;
          uint64_t v20 = &v32[8 * (v31 >> 2)];
          uint64_t v23 = v20;
          int64_t v35 = v15 - v11;
          if (v15 != v11)
          {
            uint64_t v23 = &v20[v35 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v36 = v35 - 8;
            if (v36 < 0x38 || (uint64_t v37 = 8 * v34, (unint64_t)(&v32[8 * v34] - v11) < 0x20))
            {
              __int32 v38 = &v32[8 * (v31 >> 2)];
              uint64_t v39 = v11;
              goto LABEL_45;
            }
            uint64_t v41 = (v36 >> 3) + 1;
            uint64_t v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
            __int32 v38 = &v20[v42];
            uint64_t v39 = &v11[v42];
            uint64_t v43 = (long long *)(v11 + 16);
            uint64_t v44 = &v32[v37 + 16];
            uint64_t v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v46 = *v43;
              *((_OWORD *)v44 - 1) = *(v43 - 1);
              *(_OWORD *)uint64_t v44 = v46;
              v43 += 2;
              v44 += 32;
              v45 -= 4;
            }
            while (v45);
            if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_45:
                uint64_t v40 = *(void *)v39;
                v39 += 8;
                *(void *)__int32 v38 = v40;
                v38 += 8;
              }
              while (v38 != v23);
            }
          }
          uint64_t v15 = &v32[8 * v31];
          if (v16) {
            operator delete(v16);
          }
          unint64_t v16 = v33;
          goto LABEL_28;
        }
        uint64_t v25 = (v11 - v16) >> 3;
        if (v25 >= -1) {
          uint64_t v26 = v25 + 1;
        }
        else {
          uint64_t v26 = v25 + 2;
        }
        uint64_t v27 = v26 >> 1;
        uint64_t v28 = &v11[-8 * (v26 >> 1)];
        uint64_t v29 = v15;
        if (v15 != v11)
        {
          memmove(v28, v11, v15 - v11);
          uint64_t v29 = v11;
        }
        uint64_t v30 = -v27;
        uint64_t v23 = &v28[v15 - v11];
        uint64_t v20 = &v29[8 * v30];
      }
      else
      {
        uint64_t v20 = v11;
        uint64_t v23 = v15;
        uint64_t v15 = v14;
      }
LABEL_28:
      uint64_t v14 = v15;
      uint64_t v24 = *(void *)v3;
      v3 += 8;
      *(void *)uint64_t v23 = v24;
      unint64_t v21 = v23 + 8;
      uint64_t v15 = v21;
      unint64_t v11 = v20;
      if (v3 == *(char **)(a1 + 16)) {
        goto LABEL_22;
      }
    }
  }
LABEL_21:
  uint64_t v20 = v11;
  unint64_t v21 = v15;
LABEL_22:
  unint64_t v22 = *(void **)a1;
  *(void *)a1 = v16;
  *(void *)(a1 + 8) = v20;
  *(void *)(a1 + 16) = v21;
  *(void *)(a1 + 24) = v14;
  if (v21 - v20 == 8)
  {
    *(void *)(a1 + 32) = 256;
    if (!v22) {
      return;
    }
  }
  else
  {
    *(void *)(a1 + 32) += 512;
    if (!v22) {
      return;
    }
  }

  operator delete(v22);
}

void sub_1B78369C4(_Unwind_Exception *a1)
{
  operator delete(v1);
  operator delete(v2);
  _Unwind_Resume(a1);
}

char *std::deque<HGRenderJob *>::__move_and_check(int a1, char *a2, char *__src, char *a4, char *a5, char *a6, char *__dst, unint64_t *a8)
{
  if (a5 != __src)
  {
    unint64_t v10 = __src;
    unint64_t v11 = a2;
    uint64_t v12 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - a2) << 6) - ((uint64_t)&__src[-*(void *)a2] >> 3);
    if (v12 >= 1)
    {
      while (1)
      {
        uint64_t v16 = *(void *)v11;
        uint64_t v17 = *(void *)v11 + 4096;
        uint64_t v18 = (v17 - (uint64_t)v10) >> 3;
        if (v18 >= v12) {
          uint64_t v19 = v12;
        }
        else {
          uint64_t v19 = (v17 - (uint64_t)v10) >> 3;
        }
        if (v18 <= v12) {
          unint64_t v20 = *(void *)v11 + 4096;
        }
        else {
          unint64_t v20 = (unint64_t)&v10[8 * v12];
        }
        unint64_t v21 = *a8;
        if ((unint64_t)v10 <= *a8 && v21 < v20)
        {
          if (v10 != __dst)
          {
            uint64_t v23 = ((uint64_t)&__dst[-*(void *)a6] >> 3) - (((uint64_t)&v10[-v16] >> 3) + ((v11 - a6) << 6));
            if (v23)
            {
              uint64_t v24 = v23 + ((uint64_t)(v21 - v16) >> 3);
              if (v24 < 1) {
                unint64_t v21 = *(void *)&v11[-8 * ((unint64_t)(511 - v24) >> 9)] + 8 * (~(511 - (_WORD)v24) & 0x1FF);
              }
              else {
                unint64_t v21 = *(void *)&v11[((unint64_t)v24 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v24 & 0x1FF);
              }
            }
          }
          *a8 = v21;
        }
        if (v10 == (char *)v20) {
          goto LABEL_33;
        }
        uint64_t v26 = *(char **)a6;
        a6 += 8;
        uint64_t v25 = v26;
        uint64_t v27 = v10;
        while (1)
        {
          uint64_t v28 = (v25 - __dst + 4096) >> 3;
          uint64_t v29 = (uint64_t)(v20 - (void)v27) >> 3 >= v28 ? v28 : (uint64_t)(v20 - (void)v27) >> 3;
          if (v29) {
            memmove(__dst, v27, 8 * v29);
          }
          v27 += 8 * v29;
          if (v27 == (char *)v20) {
            break;
          }
          uint64_t v30 = *(char **)a6;
          a6 += 8;
          uint64_t v25 = v30;
          std::string __dst = v30;
        }
        __dst += 8 * v29;
        if ((char *)(*((void *)a6 - 1) + 4096) != __dst) {
          break;
        }
        std::string __dst = *(char **)a6;
        if (v19)
        {
LABEL_34:
          uint64_t v31 = v19 + ((uint64_t)&v10[-*(void *)v11] >> 3);
          if (v31 < 1)
          {
            unint64_t v14 = 511 - v31;
            v11 -= 8 * (v14 >> 9);
            unint64_t v10 = (char *)(*(void *)v11 + 8 * (~(_WORD)v14 & 0x1FF));
          }
          else
          {
            v11 += 8 * ((unint64_t)v31 >> 9);
            unint64_t v10 = (char *)(*(void *)v11 + 8 * (v31 & 0x1FF));
          }
        }
LABEL_5:
        BOOL v15 = v12 <= v19;
        v12 -= v19;
        if (v15) {
          return a6;
        }
      }
      a6 -= 8;
LABEL_33:
      if (v19) {
        goto LABEL_34;
      }
      goto LABEL_5;
    }
  }
  return a6;
}

void std::deque<HGRenderJob *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        unint64_t v34 = (char *)operator new(8 * v31);
        int64_t v35 = &v34[8 * v32];
        unint64_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            unsigned long long v74 = &v34[8 * v32];
            uint64_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v40 = &v35[v76];
              v7 += v76;
              uint64_t v77 = (long long *)(v6 + 3);
              int v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *int v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    BOOL v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      int8x16_t v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    int8x16_t v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        unint64_t v34 = (char *)operator new(8 * v42);
        int64_t v35 = &v34[8 * v43];
        unint64_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            unsigned long long v82 = &v34[8 * v43];
            uint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v47 = &v35[v84];
              v7 += v84;
              unsigned long long v85 = (long long *)(v41 + 3);
              int v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *int v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  uint64_t v26 = operator new(0x1000uLL);
  uint64_t v27 = &v25[8 * v21];
  uint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    PCSharedCount v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unsigned long long v49 = (char *)operator new(8 * v48);
      uint64_t v27 = &v49[8 * (v48 >> 2)];
      uint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v49;
      *(void *)uint64_t v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)uint64_t v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v60 = (char *)operator new(8 * v59);
          uint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          uint64_t v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            uint64_t v64 = &v60[8 * v61];
            unsigned long long v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            uint64_t v64 = &v60[8 * v61];
            unsigned long long v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v64 = &v53[v68];
            unsigned long long v65 = &v27[v68];
            unsigned long long v69 = (long long *)(v27 + 16);
            uint64_t v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)uint64_t v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)uint64_t v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          uint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          uint64_t v57 = &v29[8 * (v56 >> 1)];
          uint64_t v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          uint64_t v25 = v27;
        }
      }
      else
      {
        uint64_t v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      unint64_t v51 = v53 - 8;
      uint64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)uint64_t v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  unint64_t v51 = v27;
LABEL_46:
  uint64_t v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B783717C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B7837198(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78371AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B78371C4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::deque<HGRenderJob *>::__move_backward_and_check(uint64_t a1, char *a2, char *a3, char *a4, char *a5, char *a6, char *a7, unint64_t *a8)
{
  if (a5 != a3)
  {
    uint64_t v10 = a5;
    uint64_t v11 = a4;
    uint64_t v12 = ((uint64_t)&a5[-*(void *)a4] >> 3) + ((a4 - a2) << 6) - ((uint64_t)&a3[-*(void *)a2] >> 3);
    if (v12 >= 1)
    {
      while (1)
      {
        uint64_t v14 = *(char **)v11;
        if (v10 == *(char **)v11)
        {
          BOOL v15 = (char *)*((void *)v11 - 1);
          v11 -= 8;
          uint64_t v14 = v15;
          uint64_t v10 = v15 + 4096;
        }
        int64_t v16 = v10 - 8;
        uint64_t v17 = (v10 - v14) >> 3;
        uint64_t v18 = v17 >= v12 ? v12 : (v10 - v14) >> 3;
        uint64_t v19 = v17 <= v12 ? v14 : &v10[-8 * v12];
        unint64_t v20 = *a8;
        BOOL v21 = *a8 >= (unint64_t)v10 || (unint64_t)v19 > v20;
        if (!v21) {
          break;
        }
        if (v19 == v10) {
          goto LABEL_34;
        }
LABEL_25:
        uint64_t v24 = *(void *)a6;
        while (1)
        {
          uint64_t v25 = (uint64_t)&a7[-v24] >> 3;
          if ((v10 - v19) >> 3 < v25) {
            uint64_t v25 = (v10 - v19) >> 3;
          }
          v10 -= 8 * v25;
          a7 -= 8 * v25;
          if (v25) {
            memmove(a7, v10, 8 * v25);
          }
          if (v10 == v19) {
            break;
          }
          uint64_t v26 = *((void *)a6 - 1);
          a6 -= 8;
          uint64_t v24 = v26;
          a7 = (char *)(v26 + 4096);
        }
        if ((char *)(*(void *)a6 + 4096) == a7)
        {
          uint64_t v29 = (char *)*((void *)a6 + 1);
          a6 += 8;
          a7 = v29;
          uint64_t v27 = v18 - 1;
          if (v18 != 1)
          {
LABEL_35:
            uint64_t v28 = ((uint64_t)&v16[-*(void *)v11] >> 3) - v27;
            if (v28 < 1)
            {
              unint64_t v30 = 511 - v28;
              v11 -= 8 * (v30 >> 9);
              uint64_t v10 = (char *)(*(void *)v11 + 8 * (~(_WORD)v30 & 0x1FF));
            }
            else
            {
              v11 += 8 * ((unint64_t)v28 >> 9);
              uint64_t v10 = (char *)(*(void *)v11 + 8 * (v28 & 0x1FF));
            }
            goto LABEL_5;
          }
        }
        else
        {
LABEL_34:
          uint64_t v27 = v18 - 1;
          if (v18 != 1) {
            goto LABEL_35;
          }
        }
        uint64_t v10 = v16;
LABEL_5:
        BOOL v21 = v12 <= v18;
        v12 -= v18;
        if (v21) {
          return a6;
        }
      }
      if (v16 == a7)
      {
        uint64_t v23 = ((uint64_t)(v20 - (void)v14) >> 3) - 1;
        if (v23 >= 1) {
          goto LABEL_21;
        }
      }
      else
      {
        uint64_t v22 = ~((v16 - v14) >> 3) + ((a6 - v11) << 6) + ((uint64_t)&a7[-*(void *)a6] >> 3);
        if (!v22)
        {
LABEL_24:
          *a8 = v20;
          goto LABEL_25;
        }
        uint64_t v23 = v22 + ((uint64_t)(v20 - (void)v14) >> 3);
        if (v23 >= 1)
        {
LABEL_21:
          unint64_t v20 = *(void *)&v11[((unint64_t)v23 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v23 & 0x1FF);
          goto LABEL_24;
        }
      }
      unint64_t v20 = *(void *)&v11[-8 * ((unint64_t)(511 - v23) >> 9)] + 8 * (~(511 - (_WORD)v23) & 0x1FF);
      goto LABEL_24;
    }
  }
  return a6;
}

void std::deque<HGUserJob *>::__add_front_capacity(uint64_t a1)
{
  BOOL v3 = *(char **)(a1 + 8);
  unint64_t v2 = *(char **)(a1 + 16);
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v2 - v3) << 6) - 1;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if ((unint64_t)(v4 - (*(void *)(a1 + 40) + v5)) >= 0x200)
  {
    *(void *)(a1 + 32) = v5 + 512;
    uint64_t v47 = (void *)*((void *)v2 - 1);
    *(void *)(a1 + 16) = v2 - 8;
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
    return;
  }
  uint64_t v6 = *(char **)(a1 + 24);
  uint64_t v7 = *(char **)a1;
  uint64_t v8 = (uint64_t)&v6[-*(void *)a1];
  if (v2 - v3 < (unint64_t)v8)
  {
    if (v3 == v7)
    {
      uint64_t v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v47);
      uint64_t v17 = *(void *)(a1 + 16);
      uint64_t v47 = *(void **)(v17 - 8);
      *(void *)(a1 + 16) = v17 - 8;
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
        goto LABEL_9;
      }
    }
    else
    {
      uint64_t v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8)
      {
LABEL_9:
        uint64_t v9 = 256;
LABEL_19:
        *(void *)(a1 + 32) = v9;
        return;
      }
    }
    uint64_t v9 = *(void *)(a1 + 32) + 512;
    goto LABEL_19;
  }
  if (v6 == v7) {
    unint64_t v10 = 1;
  }
  else {
    unint64_t v10 = v8 >> 2;
  }
  if (v10 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v11 = (char *)operator new(8 * v10);
  uint64_t v12 = operator new(0x1000uLL);
  uint64_t v13 = v12;
  if (v10)
  {
    uint64_t v14 = &v11[8 * v10];
    *(void *)uint64_t v11 = v12;
    BOOL v15 = v11 + 8;
    int64_t v16 = v11;
    if (v3 != v2) {
      goto LABEL_29;
    }
    goto LABEL_21;
  }
  uint64_t v18 = (char *)operator new(8uLL);
  uint64_t v14 = v18 + 8;
  operator delete(v11);
  BOOL v3 = *(char **)(a1 + 8);
  uint64_t v19 = *(char **)(a1 + 16);
  uint64_t v11 = v18;
  *(void *)uint64_t v18 = v13;
  BOOL v15 = v18 + 8;
  int64_t v16 = v18;
  if (v3 != v19)
  {
    while (1)
    {
LABEL_29:
      if (v15 == v14)
      {
        if (v11 <= v16)
        {
          if (v15 == v16) {
            unint64_t v31 = 1;
          }
          else {
            unint64_t v31 = (v15 - v16) >> 2;
          }
          if (v31 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          unint64_t v32 = (char *)operator new(8 * v31);
          uint64_t v33 = v32;
          unint64_t v34 = v31 >> 2;
          unint64_t v20 = &v32[8 * (v31 >> 2)];
          uint64_t v23 = v20;
          int64_t v35 = v15 - v11;
          if (v15 != v11)
          {
            uint64_t v23 = &v20[v35 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v36 = v35 - 8;
            if (v36 < 0x38 || (uint64_t v37 = 8 * v34, (unint64_t)(&v32[8 * v34] - v11) < 0x20))
            {
              int64_t v38 = &v32[8 * (v31 >> 2)];
              unint64_t v39 = v11;
              goto LABEL_45;
            }
            uint64_t v41 = (v36 >> 3) + 1;
            uint64_t v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
            int64_t v38 = &v20[v42];
            unint64_t v39 = &v11[v42];
            unint64_t v43 = (long long *)(v11 + 16);
            uint64_t v44 = &v32[v37 + 16];
            uint64_t v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v46 = *v43;
              *((_OWORD *)v44 - 1) = *(v43 - 1);
              *(_OWORD *)uint64_t v44 = v46;
              v43 += 2;
              v44 += 32;
              v45 -= 4;
            }
            while (v45);
            if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_45:
                uint64_t v40 = *(void *)v39;
                v39 += 8;
                *(void *)int64_t v38 = v40;
                v38 += 8;
              }
              while (v38 != v23);
            }
          }
          BOOL v15 = &v32[8 * v31];
          if (v16) {
            operator delete(v16);
          }
          int64_t v16 = v33;
          goto LABEL_28;
        }
        uint64_t v25 = (v11 - v16) >> 3;
        if (v25 >= -1) {
          uint64_t v26 = v25 + 1;
        }
        else {
          uint64_t v26 = v25 + 2;
        }
        uint64_t v27 = v26 >> 1;
        uint64_t v28 = &v11[-8 * (v26 >> 1)];
        uint64_t v29 = v15;
        if (v15 != v11)
        {
          memmove(v28, v11, v15 - v11);
          uint64_t v29 = v11;
        }
        uint64_t v30 = -v27;
        uint64_t v23 = &v28[v15 - v11];
        unint64_t v20 = &v29[8 * v30];
      }
      else
      {
        unint64_t v20 = v11;
        uint64_t v23 = v15;
        BOOL v15 = v14;
      }
LABEL_28:
      uint64_t v14 = v15;
      uint64_t v24 = *(void *)v3;
      v3 += 8;
      *(void *)uint64_t v23 = v24;
      BOOL v21 = v23 + 8;
      BOOL v15 = v21;
      uint64_t v11 = v20;
      if (v3 == *(char **)(a1 + 16)) {
        goto LABEL_22;
      }
    }
  }
LABEL_21:
  unint64_t v20 = v11;
  BOOL v21 = v15;
LABEL_22:
  uint64_t v22 = *(void **)a1;
  *(void *)a1 = v16;
  *(void *)(a1 + 8) = v20;
  *(void *)(a1 + 16) = v21;
  *(void *)(a1 + 24) = v14;
  if (v21 - v20 == 8)
  {
    *(void *)(a1 + 32) = 256;
    if (!v22) {
      return;
    }
  }
  else
  {
    *(void *)(a1 + 32) += 512;
    if (!v22) {
      return;
    }
  }

  operator delete(v22);
}

void sub_1B7837794(_Unwind_Exception *a1)
{
  operator delete(v1);
  operator delete(v2);
  _Unwind_Resume(a1);
}

void std::deque<HGUserJob *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        unint64_t v34 = (char *)operator new(8 * v31);
        int64_t v35 = &v34[8 * v32];
        unint64_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            unsigned long long v74 = &v34[8 * v32];
            uint64_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v40 = &v35[v76];
              v7 += v76;
              uint64_t v77 = (long long *)(v6 + 3);
              int v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *int v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    BOOL v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      int8x16_t v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    int8x16_t v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        unint64_t v34 = (char *)operator new(8 * v42);
        int64_t v35 = &v34[8 * v43];
        unint64_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            unsigned long long v82 = &v34[8 * v43];
            uint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v47 = &v35[v84];
              v7 += v84;
              unsigned long long v85 = (long long *)(v41 + 3);
              int v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *int v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  uint64_t v26 = operator new(0x1000uLL);
  uint64_t v27 = &v25[8 * v21];
  uint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    PCSharedCount v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unsigned long long v49 = (char *)operator new(8 * v48);
      uint64_t v27 = &v49[8 * (v48 >> 2)];
      uint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v49;
      *(void *)uint64_t v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)uint64_t v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v60 = (char *)operator new(8 * v59);
          uint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          uint64_t v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            uint64_t v64 = &v60[8 * v61];
            unsigned long long v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            uint64_t v64 = &v60[8 * v61];
            unsigned long long v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v64 = &v53[v68];
            unsigned long long v65 = &v27[v68];
            unsigned long long v69 = (long long *)(v27 + 16);
            uint64_t v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)uint64_t v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)uint64_t v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          uint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          uint64_t v57 = &v29[8 * (v56 >> 1)];
          uint64_t v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          uint64_t v25 = v27;
        }
      }
      else
      {
        uint64_t v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      unint64_t v51 = v53 - 8;
      uint64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)uint64_t v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  unint64_t v51 = v27;
LABEL_46:
  uint64_t v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B7837D40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B7837D5C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7837D70(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7837D88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::deque<HGGPUReadbackJob *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        unint64_t v34 = (char *)operator new(8 * v31);
        int64_t v35 = &v34[8 * v32];
        unint64_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            unsigned long long v74 = &v34[8 * v32];
            uint64_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v40 = &v35[v76];
              v7 += v76;
              uint64_t v77 = (long long *)(v6 + 3);
              int v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *int v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    BOOL v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      int8x16_t v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    int8x16_t v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        unint64_t v34 = (char *)operator new(8 * v42);
        int64_t v35 = &v34[8 * v43];
        unint64_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            unsigned long long v82 = &v34[8 * v43];
            uint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v47 = &v35[v84];
              v7 += v84;
              unsigned long long v85 = (long long *)(v41 + 3);
              int v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *int v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  uint64_t v26 = operator new(0x1000uLL);
  uint64_t v27 = &v25[8 * v21];
  uint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    PCSharedCount v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unsigned long long v49 = (char *)operator new(8 * v48);
      uint64_t v27 = &v49[8 * (v48 >> 2)];
      uint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v49;
      *(void *)uint64_t v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)uint64_t v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v60 = (char *)operator new(8 * v59);
          uint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          uint64_t v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            uint64_t v64 = &v60[8 * v61];
            unsigned long long v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            uint64_t v64 = &v60[8 * v61];
            unsigned long long v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v64 = &v53[v68];
            unsigned long long v65 = &v27[v68];
            unsigned long long v69 = (long long *)(v27 + 16);
            uint64_t v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)uint64_t v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)uint64_t v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          uint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          uint64_t v57 = &v29[8 * (v56 >> 1)];
          uint64_t v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          uint64_t v25 = v27;
        }
      }
      else
      {
        uint64_t v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      unint64_t v51 = v53 - 8;
      uint64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)uint64_t v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  unint64_t v51 = v27;
LABEL_46:
  uint64_t v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B7838310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B783832C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7838340(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7838358(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::deque<HGPixelBufferObj *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        unint64_t v34 = (char *)operator new(8 * v31);
        int64_t v35 = &v34[8 * v32];
        unint64_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            unsigned long long v74 = &v34[8 * v32];
            uint64_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v40 = &v35[v76];
              v7 += v76;
              uint64_t v77 = (long long *)(v6 + 3);
              int v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *int v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    BOOL v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      int8x16_t v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    int8x16_t v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        unint64_t v34 = (char *)operator new(8 * v42);
        int64_t v35 = &v34[8 * v43];
        unint64_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            unsigned long long v82 = &v34[8 * v43];
            uint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v47 = &v35[v84];
              v7 += v84;
              unsigned long long v85 = (long long *)(v41 + 3);
              int v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *int v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  uint64_t v26 = operator new(0x1000uLL);
  uint64_t v27 = &v25[8 * v21];
  uint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    PCSharedCount v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unsigned long long v49 = (char *)operator new(8 * v48);
      uint64_t v27 = &v49[8 * (v48 >> 2)];
      uint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v49;
      *(void *)uint64_t v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)uint64_t v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v60 = (char *)operator new(8 * v59);
          uint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          uint64_t v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            uint64_t v64 = &v60[8 * v61];
            unsigned long long v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            uint64_t v64 = &v60[8 * v61];
            unsigned long long v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v64 = &v53[v68];
            unsigned long long v65 = &v27[v68];
            unsigned long long v69 = (long long *)(v27 + 16);
            uint64_t v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)uint64_t v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)uint64_t v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          uint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          uint64_t v57 = &v29[8 * (v56 >> 1)];
          uint64_t v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          uint64_t v25 = v27;
        }
      }
      else
      {
        uint64_t v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      unint64_t v51 = v53 - 8;
      uint64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)uint64_t v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  unint64_t v51 = v27;
LABEL_46:
  uint64_t v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B78388E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B78388FC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7838910(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7838928(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::deque<HGRef<HGGLContext>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        unint64_t v34 = (char *)operator new(8 * v31);
        int64_t v35 = &v34[8 * v32];
        unint64_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            unsigned long long v74 = &v34[8 * v32];
            uint64_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v40 = &v35[v76];
              v7 += v76;
              uint64_t v77 = (long long *)(v6 + 3);
              int v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *int v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    BOOL v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      int8x16_t v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    int8x16_t v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        unint64_t v34 = (char *)operator new(8 * v42);
        int64_t v35 = &v34[8 * v43];
        unint64_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            unsigned long long v82 = &v34[8 * v43];
            uint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v47 = &v35[v84];
              v7 += v84;
              unsigned long long v85 = (long long *)(v41 + 3);
              int v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *int v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  uint64_t v26 = operator new(0x1000uLL);
  uint64_t v27 = &v25[8 * v21];
  uint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    PCSharedCount v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unsigned long long v49 = (char *)operator new(8 * v48);
      uint64_t v27 = &v49[8 * (v48 >> 2)];
      uint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v49;
      *(void *)uint64_t v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)uint64_t v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v60 = (char *)operator new(8 * v59);
          uint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          uint64_t v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            uint64_t v64 = &v60[8 * v61];
            unsigned long long v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            uint64_t v64 = &v60[8 * v61];
            unsigned long long v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v64 = &v53[v68];
            unsigned long long v65 = &v27[v68];
            unsigned long long v69 = (long long *)(v27 + 16);
            uint64_t v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)uint64_t v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)uint64_t v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          uint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          uint64_t v57 = &v29[8 * (v56 >> 1)];
          uint64_t v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          uint64_t v25 = v27;
        }
      }
      else
      {
        uint64_t v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      unint64_t v51 = v53 - 8;
      uint64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)uint64_t v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  unint64_t v51 = v27;
LABEL_46:
  uint64_t v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B7838EB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B7838ECC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7838EE0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7838EF8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

const char *HGNode::RenderPageDeluxeMetalTextures(uint64_t a1, HGGPURenderer **a2)
{
  uint64_t MetalContext = HGGPURenderer::GetMetalContext(*a2);
  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 520))(a1);
  switch(v5)
  {
    case 2:
      uint64_t v10 = (void *)[*(id *)(MetalContext + 32) commandBuffer];
      (*(void (**)(uint64_t, HGGPURenderer **, void *))(*(void *)a1 + 552))(a1, a2, v10);
      [v10 commit];
      HGGPURenderer::SetLastMetalCmdBuffer((uint64_t)*a2);
    case 3:
      uint64_t v11 = *(void *)(MetalContext + 32);
      uint64_t v12 = *(uint64_t (**)(uint64_t, HGGPURenderer **, uint64_t))(*(void *)a1 + 560);
      return (const char *)v12(a1, a2, v11);
    case 4:
      uint64_t v8 = *(uint64_t (**)(uint64_t, HGGPURenderer **))(*(void *)a1 + 568);
      return (const char *)v8(a1, a2);
    default:
      return HGLogger::warning((HGLogger *)"HGNode::RenderPageDeluxeMetalTextures() could not find a valid rendering path.", v6, v7);
  }
}

void HGComicStroke::HGComicStroke(HGComicStroke *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10E0978;
  *(_OWORD *)(v1 + 408) = xmmword_1B7E734D0;
  *(_DWORD *)(v1 + 16) |= 0x620u;
}

void HGComicStroke::~HGComicStroke(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGComicStroke::SetParameter(HGComicStroke *this, int a2, float a3, float a4, float a5, float a6)
{
  switch(a2)
  {
    case 0:
      if (*((float *)this + 102) == a3) {
        goto LABEL_11;
      }
      *((float *)this + 102) = a3;
      uint64_t result = 1;
      break;
    case 1:
      if (*((float *)this + 103) == a3) {
        goto LABEL_11;
      }
      *((float *)this + 103) = a3;
      uint64_t result = 1;
      break;
    case 2:
      if (*((float *)this + 104) == a3) {
        goto LABEL_11;
      }
      *((float *)this + 104) = a3;
      uint64_t result = 1;
      break;
    case 3:
      if (*((float *)this + 105) == a3)
      {
LABEL_11:
        uint64_t result = 0;
      }
      else
      {
        *((float *)this + 105) = a3;
        uint64_t result = 1;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HGComicStroke::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicStroke::GetDOD(HGComicStroke *this, HGRenderer *a2, int a3, HGRect a4)
{
  HGRect v13 = a4;
  if (a3) {
    return 0;
  }
  if (HGRect::IsInfinite(&v13)) {
    return *(void *)&v13.var0;
  }
  double v6 = *((float *)this + 105);
  HGTransform::HGTransform((HGTransform *)v12);
  HGTransform::Scale((HGTransform *)v12, v6, v6, 1.0);
  uint64_t v7 = *(const HGTransform **)&v13.var0;
  uint64_t v8 = *(void *)&v13.var2;
  float v10 = HGTransformUtils::MinW(v9);
  *(void *)&v14.unsigned int var0 = v8;
  uint64_t DOD = HGTransformUtils::GetDOD((HGTransformUtils *)v12, v7, v14, 0.5, v10);
  HGTransform::~HGTransform((HGTransform *)v12);
  return DOD;
}

void sub_1B78392F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7839308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGComicStroke::GetROI(HGComicStroke *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  unint64_t v5 = *(void *)&a4.var0;
  if (a3 == 1)
  {
    HGRect v19 = a4;
    uint64_t v14 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v16 = v15;
    *(void *)&v22.unsigned int var0 = v14;
    *(void *)&v22.int var2 = v16;
    HGRect::Grow(&v19, v22);
  }
  else if (a3)
  {
    HGRect v19 = (HGRect)HGRectNull;
  }
  else
  {
    double v7 = 1.0 / *((float *)this + 105);
    HGTransform::HGTransform((HGTransform *)v18);
    HGTransform::Scale((HGTransform *)v18, v7, v7, 1.0);
    *(void *)&v19.unsigned int var0 = 0;
    *(void *)&v19.int var2 = 0;
    float v9 = HGTransformUtils::MinW(v8);
    *(void *)&v23.unsigned int var0 = v4;
    *(void *)&v19.unsigned int var0 = HGTransformUtils::GetROI((HGTransformUtils *)v18, v5, v23, 0.5, v9);
    *(void *)&v19.int var2 = *(void *)&v20.var0;
    LODWORD(v10) = vcvtps_s32_f32(*((float *)this + 102) + *((float *)this + 102));
    *(void *)&v20.int var2 = v10 | (v10 << 32);
    v20.unsigned int var0 = -(int)v10;
    v20.uint64_t var1 = -(int)v10;
    HGRect::Grow(&v19, v20);
    uint64_t v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v13 = v12;
    *(void *)&v21.unsigned int var0 = v11;
    *(void *)&v21.int var2 = v13;
    HGRect::Grow(&v19, v21);
    HGTransform::~HGTransform((HGTransform *)v18);
  }
  return *(void *)&v19.var0;
}

void sub_1B7839454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7839468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B783947C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGComicStroke::RenderTile(HGComicStroke *this, HGTile *a2)
{
  float v4 = *((float *)this + 105);
  uint64_t v5 = HGTile::Renderer(a2);
  int v6 = (*(uint64_t (**)(HGComicStroke *, uint64_t))(*(void *)this + 312))(this, v5);
  int32x2_t v8 = *(int32x2_t *)a2;
  int v86 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v86 >= 1)
  {
    uint64_t v90 = (*((_DWORD *)a2 + 2) - v8.i32[0]);
    if ((int)v90 >= 1)
    {
      int v9 = v6;
      int v10 = 0;
      *(float32x2_t *)v11.f32 = vadd_f32(vcvt_f32_s32(v8), (float32x2_t)0x3F0000003F000000);
      v11.i64[1] = 0x3F80000000000000;
      float v12 = *((float *)this + 102);
      float v13 = 1.0 / (float)(v12 * (float)(v12 * 3.0));
      uint64_t v14 = *((void *)a2 + 2);
      int v89 = (int)(float)(v12 + v12);
      int v15 = -v89;
      v7.i64[0] = 0;
      int8x16_t v16 = 0uLL;
      __asm
      {
        FMOV            V7.4S, #-1.0
        FMOV            V16.4S, #1.0
      }
      float v23 = 1.0 / v4;
      float32x4_t v24 = v11;
      float32x4_t v94 = _Q7;
      float32x4_t v95 = v11;
      float v92 = 1.0 / v4;
      float32x4_t v93 = _Q16;
      do
      {
        int v88 = v10;
        uint64_t v25 = 0;
        float32x4_t v87 = v24;
        float32x4_t v26 = v24;
        do
        {
          uint64_t v27 = *((void *)a2 + 10);
          uint64_t v28 = *((int *)a2 + 22);
          float32x4_t v29 = vsubq_f32(vmulq_n_f32(v26, v23), v11);
          if (v9)
          {
            int32x4_t v30 = vaddq_s32(vcvtq_s32_f32(v29), vcltzq_f32(v29));
            float32x2_t v31 = (float32x2_t)vsubq_f32(v29, vcvtq_f32_s32(v30)).u64[0];
            unint64_t v32 = (float32x4_t *)(v27 + 16 * (v30.i32[0] + v30.i32[1] * (int)v28));
            float32x4_t v33 = vaddq_f32(*v32, vmulq_n_f32(vsubq_f32(v32[1], *v32), v31.f32[0]));
            int8x16_t v34 = (int8x16_t)vaddq_f32(v33, vmulq_lane_f32(vsubq_f32(vaddq_f32(v32[v28], vmulq_n_f32(vsubq_f32(v32[(int)v28 + 1], v32[v28]), v31.f32[0])), v33), v31, 1));
          }
          else
          {
            v35.i64[0] = 0x3F0000003F000000;
            v35.i64[1] = 0x3F0000003F000000;
            float32x4_t v36 = vaddq_f32(v29, v35);
            int32x4_t v37 = vcvtq_s32_f32(v36);
            v36.i64[0] = vaddq_s32(v37, vcgtq_f32(vcvtq_f32_s32(v37), v36)).u64[0];
            int8x16_t v34 = *(int8x16_t *)(v27 + 16 * (v36.i32[0] + v36.i32[1] * (int)v28));
          }
          float32x4_t v38 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.i8, 1);
          int8x16_t v39 = v34;
          v39.i32[1] = 0;
          int8x16_t v40 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32((float32x4_t)v7, v38), (int8x16_t)vcgeq_f32(v38, (float32x4_t)v7))), 0), v39, v34);
          float32x4_t v42 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2);
          int8x16_t v41 = v40;
          v41.i32[2] = 0;
          int8x16_t v7 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32((float32x4_t)v7, v42), (int8x16_t)vcgeq_f32(v42, (float32x4_t)v7))), 0), v41, v40);
          v42.i32[3] = v7.i32[3];
          if (*((float *)this + 104) != 0.0)
          {
            uint64_t v43 = *((void *)a2 + 12);
            uint64_t v44 = *((int *)a2 + 26);
            float32x4_t v45 = vsubq_f32(v26, v11);
            if (!v9)
            {
              v69.i64[0] = 0x3F0000003F000000;
              v69.i64[1] = 0x3F0000003F000000;
              int8x16_t v40 = (int8x16_t)vaddq_f32(v45, v69);
              int32x4_t v70 = vcvtq_s32_f32((float32x4_t)v40);
              v40.i64[0] = vaddq_s32(v70, vcgtq_f32(vcvtq_f32_s32(v70), (float32x4_t)v40)).u64[0];
              float v50 = 0.5;
              long long v91 = *(_OWORD *)(v43 + 16 * (v40.i32[0] + v40.i32[1] * (int)v44));
              if (v89 <= 1) {
                goto LABEL_22;
              }
              goto LABEL_14;
            }
            int32x4_t v46 = vaddq_s32(vcvtq_s32_f32(v45), vcltzq_f32(v45));
            float32x2_t v47 = (float32x2_t)vsubq_f32(v45, vcvtq_f32_s32(v46)).u64[0];
            unint64_t v48 = (float32x4_t *)(v43 + 16 * (v46.i32[0] + v46.i32[1] * (int)v44));
            float32x4_t v49 = vaddq_f32(*v48, vmulq_n_f32(vsubq_f32(v48[1], *v48), v47.f32[0]));
            int8x16_t v40 = (int8x16_t)vmulq_lane_f32(vsubq_f32(vaddq_f32(v48[v44], vmulq_n_f32(vsubq_f32(v48[(int)v44 + 1], v48[v44]), v47.f32[0])), v49), v47, 1);
            float32x4_t v42 = vaddq_f32(v49, (float32x4_t)v40);
          }
          float v50 = 0.5;
          HIDWORD(v91) = v42.i32[3];
          if (v89 <= 1) {
            goto LABEL_22;
          }
LABEL_14:
          v51.i64[0] = vextq_s8(v7, v16, 4uLL).u64[0];
          v51.i64[1] = v16.i64[1];
          float32x4_t v52 = vmaxnmq_f32(vminnmq_f32(vaddq_f32(vaddq_f32(v51, v51), _Q7), _Q16), _Q7);
          float32x4_t v53 = vnegq_f32(v52);
          float32x4_t v96 = v26;
          if (v9)
          {
            uint64_t v54 = (int)v28 + 1;
            int v55 = -1;
            do
            {
              float32x4_t v97 = v53;
              float32x4_t v99 = v52;
              int8x16_t v101 = v7;
              float v56 = expf(v13 * (float)v55);
              float32x4_t v26 = v96;
              float v23 = v92;
              _Q16 = v93;
              _Q7 = v94;
              float32x4_t v11 = v95;
              float v50 = v50 + v56;
              float32x4_t v57 = vsubq_f32(vmulq_n_f32(vaddq_f32(v96, v99), v92), v95);
              int32x4_t v58 = vaddq_s32(vcvtq_s32_f32(v57), vcltzq_f32(v57));
              v57.i64[0] = vsubq_f32(v57, vcvtq_f32_s32(v58)).u64[0];
              unint64_t v59 = (float32x4_t *)(v27 + 16 * (v58.i32[0] + v58.i32[1] * (int)v28));
              float32x4_t v60 = vaddq_f32(*v59, vmulq_n_f32(vsubq_f32(v59[1], *v59), v57.f32[0]));
              int8x16_t v61 = (int8x16_t)vaddq_f32(v60, vmulq_lane_f32(vsubq_f32(vaddq_f32(v59[v28], vmulq_n_f32(vsubq_f32(v59[v54], v59[v28]), v57.f32[0])), v60), *(float32x2_t *)v57.f32, 1));
              float32x4_t v62 = vsubq_f32(vmulq_n_f32(vaddq_f32(v96, v97), v92), v95);
              int32x4_t v63 = vaddq_s32(vcvtq_s32_f32(v62), vcltzq_f32(v62));
              v62.i64[0] = vsubq_f32(v62, vcvtq_f32_s32(v63)).u64[0];
              uint64_t v64 = (float32x4_t *)(v27 + 16 * (v63.i32[0] + v63.i32[1] * (int)v28));
              float32x4_t v65 = vaddq_f32(*v64, vmulq_n_f32(vsubq_f32(v64[1], *v64), v62.f32[0]));
              int8x16_t v16 = 0uLL;
              int8x16_t v7 = v101;
              int8x16_t v66 = (int8x16_t)vaddq_f32(v65, vmulq_lane_f32(vsubq_f32(vaddq_f32(v64[v28], vmulq_n_f32(vsubq_f32(v64[v54], v64[v28]), v62.f32[0])), v65), *(float32x2_t *)v62.f32, 1));
              *(float *)v7.i32 = *(float *)v101.i32
                               + (float)(v56 * vaddq_f32((float32x4_t)v61, (float32x4_t)v66).f32[0]);
              unint64_t v67 = vextq_s8(v61, (int8x16_t)0, 4uLL).u64[0];
              float32x4_t v52 = vaddq_f32(v99, vmaxnmq_f32(vminnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v67, (float32x4_t)v67), v94), v93), v94));
              unint64_t v68 = vextq_s8(v66, (int8x16_t)0, 4uLL).u64[0];
              int8x16_t v40 = (int8x16_t)vmaxnmq_f32(vminnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v68, (float32x4_t)v68), v94), v93), v94);
              float32x4_t v53 = vaddq_f32(v97, (float32x4_t)v40);
              --v55;
            }
            while (v15 != v55);
          }
          else
          {
            int v71 = -1;
            do
            {
              float32x4_t v98 = v53;
              float32x4_t v100 = v52;
              int8x16_t v102 = v7;
              float v72 = expf(v13 * (float)v71);
              float32x4_t v26 = v96;
              float v23 = v92;
              _Q16 = v93;
              _Q7 = v94;
              float32x4_t v11 = v95;
              int8x16_t v16 = 0uLL;
              v73.i64[0] = 0x3F0000003F000000;
              v73.i64[1] = 0x3F0000003F000000;
              float32x4_t v74 = vaddq_f32(vsubq_f32(vmulq_n_f32(vaddq_f32(v96, v100), v92), v95), v73);
              int32x4_t v75 = vcvtq_s32_f32(v74);
              v74.i64[0] = vaddq_s32(v75, vcgtq_f32(vcvtq_f32_s32(v75), v74)).u64[0];
              int8x16_t v76 = *(int8x16_t *)(v27 + 16 * (v74.i32[0] + v74.i32[1] * (int)v28));
              float v50 = v50 + v72;
              float32x4_t v77 = vaddq_f32(vsubq_f32(vmulq_n_f32(vaddq_f32(v96, v98), v92), v95), v73);
              int32x4_t v78 = vcvtq_s32_f32(v77);
              int8x16_t v7 = v102;
              v77.i64[0] = vaddq_s32(v78, vcgtq_f32(vcvtq_f32_s32(v78), v77)).u64[0];
              int8x16_t v79 = *(int8x16_t *)(v27 + 16 * (v77.i32[0] + v77.i32[1] * (int)v28));
              *(float *)v7.i32 = *(float *)v102.i32
                               + (float)(v72 * vaddq_f32((float32x4_t)v76, (float32x4_t)v79).f32[0]);
              unint64_t v80 = vextq_s8(v76, (int8x16_t)0, 4uLL).u64[0];
              float32x4_t v52 = vaddq_f32(v100, vmaxnmq_f32(vminnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v80, (float32x4_t)v80), v94), v93), v94));
              unint64_t v81 = vextq_s8(v79, (int8x16_t)0, 4uLL).u64[0];
              int8x16_t v40 = (int8x16_t)vmaxnmq_f32(vminnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v81, (float32x4_t)v81), v94), v93), v94);
              float32x4_t v53 = vaddq_f32(v98, (float32x4_t)v40);
              --v71;
            }
            while (v15 != v71);
          }
LABEL_22:
          *(float *)v40.i32 = (float)((float)(*(float *)v7.i32 * 0.5) / v50) / 0.8;
          v7.i64[0] = 0;
          *(float *)v40.i32 = fminf(fmaxf(*(float *)v40.i32, 0.0), 1.0);
          *(float *)v40.i32 = (float)(*(float *)v40.i32 * *(float *)v40.i32)
                            * (float)(3.0 - (float)(*(float *)v40.i32 + *(float *)v40.i32));
          float32x4_t v82 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.i8, 0);
          v82.i32[3] = HIDWORD(v91);
          float32x4_t v83 = vmaxnmq_f32(vminnmq_f32(v82, _Q16), (float32x4_t)v16);
          if (*((float *)this + 103) == 1.0)
          {
            float32x4_t v84 = vmulq_laneq_f32(v83, v83, 3);
            v84.i32[3] = v83.i32[3];
            float32x4_t v83 = v84;
          }
          *(float32x4_t *)(v14 + 16 * v25) = v83;
          float32x4_t v26 = vaddq_f32(v26, (float32x4_t)xmmword_1B7E736B0);
          ++v25;
        }
        while (v25 != v90);
        float32x4_t v24 = vaddq_f32(v87, (float32x4_t)xmmword_1B7E736C0);
        v14 += 16 * *((int *)a2 + 6);
        int v10 = v88 + 1;
      }
      while (v88 + 1 != v86);
    }
  }
  return 0;
}

HGComicStroke *HGComicStroke::GetOutput(HGComicStroke *this, HGRenderer *a2, char *a3)
{
  HGNode::SetParameter((HGNode *)this, 0, *((float *)this + 102), 0.0, 0.0, 0.0, a3);
  if (*((float *)this + 103) == 1.0) {
    float v5 = 1.0;
  }
  else {
    float v5 = 0.0;
  }
  HGNode::SetParameter((HGNode *)this, 1, v5, 0.0, 0.0, 0.0, v4);
  if (*((float *)this + 104) == 1.0) {
    float v7 = 1.0;
  }
  else {
    float v7 = 0.0;
  }
  HGNode::SetParameter((HGNode *)this, 2, v7, 0.0, 0.0, 0.0, v6);
  if (*((float *)this + 104) == 0.0)
  {
    uint64_t v9 = (*(uint64_t (**)(HGComicStroke *, void))(*(void *)this + 128))(this, 0);
    (*(void (**)(HGComicStroke *, uint64_t, uint64_t))(*(void *)this + 120))(this, 1, v9);
  }
  return this;
}

const char *HGComicStroke::GetProgram(HGComicStroke *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) > 0x60B0F) {
    return "//Metal1.0     \n"
  }
           "//LEN=0000000a29\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],   // color\n"
           "                                  texture2d< half >      hg_Texture1 [[ texture(1) ]],   // alpha replace\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]],\n"
           "                                  sampler                hg_Sampler1 [[ sampler(1) ]])\n"
           "{\n"
           "    const half sigma {static_cast<half>(hg_Params[0].x)};\n"
           "    const BOOL AlphaPremultiplyOutput {static_cast<BOOL>(hg_Params[1].x)};\n"
           "    const BOOL alphaReplaceEnabled {static_cast<BOOL>(hg_Params[2].x)};\n"
           "    \n"
           "    const half4 texel = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "    const float alpha = alphaReplaceEnabled ? hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).a\n"
           "                                            : texel.a;\n"
           "    \n"
           "    // Get the 0'th normal (e0, for an exponent value of 0, so the coeff is 1.0)\n"
           "    float2 pointer = float2(texel.yz) * 2.0f - 1.0f;\n"
           "    float2 pointerRBacuint64_t k = -pointer;\n"
           "    \n"
           "    half acc = texel.x;\n"
           "    half norma = {0.5h};\n"
           "\n"
           "    half sigma3 = 1.0h / (3.0h * sigma * sigma);\n"
           "    half limit = 2.0h * sigma;\n"
           "    for (half uint64_t i = 1.0h; i < limit; i++)\n"
           "    {\n"
           "        half coeff = exp(-i * sigma3);\n"
           "        norma += coeff;\n"
           "        \n"
           "        const float2 uPos = frag._texCoord0.xy + pointer;\n"
           "        const float2 uNeg = frag._texCoord0.xy + pointerRBack;\n"
           "        \n"
           "        const float2 acc_ptrTexCoord = uPos;\n"
           "        const float2 acc_ptrBackTexCoord = uNeg;\n"
           "        \n"
           "        const float2 grad_ptrTexCoord = uPos;\n"
           "        const float2 grad_ptrBackTexCoord = uNeg;\n"
           "\n"
           "    \n"
           "        acc += coeff * (hg_Texture0.sample(hg_Sampler0, acc_ptrTexCoord).x +\n"
           "                        hg_Texture0.sample(hg_Sampler0, acc_ptrBackTexCoord).x);\n"
           "\n"
           "        pointer += float2(hg_Texture0.sample(hg_Sampler0, grad_ptrTexCoord).yz * 2.0f) - 1.0f;\n"
           "        pointerRBack -= float2(hg_Texture0.sample(hg_Sampler0, grad_ptrBackTexCoord).yz * 2.0f) - 1.0f;\n"
           "    }\n"
           "\n"
           "    half result {smoothstep(0.0h, 0.8h, acc * 0.5h / norma)};\n"
           " \n"
           "    if (AlphaPremultiplyOutput)\n"
           "        result *= alpha;\n"
           " \n"
           "    FragmentOut out {float4(result, result, result, alpha)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "\n"
           "    return out;\n"
           "}\n"
           "//MD5=cf23531d:c7d2f03d:785bd60d:1958694a\n"
           "//SIG=00000000:00000000:00000000:00000003:0010:0003:0000:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
    return "//GLfs1.0      \n"
  }
           "//LEN=0000000944\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#define precision\n"
           "#define defaultp mediump\n"
           "#endif\n"
           " \n"
           "precision highp float;\n"
           "precision highp int;\n"
           "\n"
           ""uniform defaultp sampler2DRect hg_Texture0;
           ""uniform defaultp sampler2DRect hg_Texture1;
           "\n"
           "uniform highp vec4 hg_ProgramLocal0;    // {.x == sigma}\n"
           "uniform highp vec4 hg_ProgramLocal1;    // {.x == alpha premultiply output toggle}\n"
           "uniform highp vec4 hg_ProgramLocal2;    // {.x == alpha replace toggle}\n"
           "\n"
           "void main() \n"
           "{\n"
           "    float sigma = hg_ProgramLocal0.x;\n"
           "    float alphaPremultiplyOutput = hg_ProgramLocal1.x;\n"
           "    float alphaReplaceEnabled = hg_ProgramLocal2.x;\n"
           " \n"
           "    vec4 texel = texture2DRect(hg_Texture0, gl_TexCoord[0].xy);\n"
           "    float alpha = (alphaReplaceEnabled != 0.0)  ? texture2DRect(hg_Texture1, gl_TexCoord[1].xy).a\n"
           "                                                : texel.a;\n"
           "    \n"
           "\n"
           "    float acc = texel.x;\n"
           "    float norma = 0.5;\n"
           "    \n"
           "    vec2 gradient = texel.yz;\n"
           "    vec2 vdire = vec2(gradient.x * 2.0 - 1.0, gradient.y * 2.0 - 1.0);\n"
           "    vec2 pointer = vec2(vdire.x, vdire.y);\n"
           "\n"
           "    vdire = vec2(-(gradient.x * 2.0 - 1.0), -(gradient.y * 2.0 - 1.0));\n"
           "    vec2 pointerRBacuint64_t k = vec2(vdire.x, vdire.y);\n"
           "\n"
           "    float sigma3 = 1.0 / (3.0 * sigma * sigma);\n"
           "    float limit = 2.0 * sigma;\n"
           "    for (float uint64_t i = 1.0; i < limit; i++)\n"
           "    {\n"
           "        float coeff = exp(-i * sigma3);\n"
           "        \n"
           "        vec2 uPos = gl_TexCoord[0].xy + pointer;\n"
           "        vec2 uNeg = gl_TexCoord[0].xy + pointerRBack;\n"
           "\n"
           "        acc +=coeff * (texture2DRect(hg_Texture0, uPos).x +\n"
           "                       texture2DRect(hg_Texture0, uNeg).x);\n"
           "\n"
           "        norma += coeff;\n"
           "\n"
           "        gradient = texture2DRect(hg_Texture0, uPos).yz;\n"
           "        vdire = vec2(gradient.x * 2.0 - 1.0, gradient.y * 2.0 - 1.0);\n"
           "        pointer += vdire;\n"
           "\n"
           "        gradient = texture2DRect(hg_Texture0, uNeg).yz;\n"
           "        vdire = vec2(-(gradient.x * 2.0 - 1.0),-(gradient.y * 2.0 - 1.0));\n"
           "        pointerRBack += vdire;\n"
           "    }\n"
           "\n"
           "    float uint64_t result = smoothstep(0.0, 0.8, acc * 0.5 / norma);\n"
           " \n"
           "    if (alphaPremultiplyOutput == 1.0)\n"
           "        result *= alpha;\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    gl_FragColor = clamp(vec4(result, result, result, alpha), 0.0, 1.0);\n"
           "}\n"
           "//MD5=3f28c492:3ede71fa:6537a9ca:f282928b\n"
           "//SIG=00000000:00000000:00000000:00000000:0038:0003:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  return 0;
}

uint64_t HGComicStroke::BindTexture(HGComicStroke *this, HGHandler *a2, uint64_t a3)
{
  if (a3)
  {
    HGHandler::TexCoord(a2, a3, 0, 0, 0);
  }
  else
  {
    float v5 = 1.0 / *((float *)this + 105);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, v5, v5, 1.0);
  }
  (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, 1, 1);
  return 0;
}

uint64_t HGCSolidColor::GetDOD(HGCSolidColor *this, HGRenderer *a2, int a3, HGRect a4)
{
  float v4 = (long long *)((char *)this + 416);
  if (a3) {
    float v4 = &HGRectNull;
  }
  return *(void *)v4;
}

void HGSolidColor::HGSolidColor(HGSolidColor *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10E0BE0;
  unint64_t v2 = (HgcSolidColor *)HGObject::operator new(0x1B0uLL);
  HgcSolidColor::HgcSolidColor(v2);
}

void sub_1B7839E58(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7839E74(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGSolidColor::HGSolidColor(HGSolidColor *this, HGRect a2)
{
  HGNode::HGNode((HGNode *)this);
  void *v2 = &unk_1F10E0BE0;
  BOOL v3 = (HgcSolidColor *)HGObject::operator new(0x1B0uLL);
  HgcSolidColor::HgcSolidColor(v3);
}

void sub_1B7839F10(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B7839F2C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGSolidColor::~HGSolidColor(HGSolidColor *this)
{
  *(void *)this = &unk_1F10E0BE0;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10E0BE0;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));
  HGNode::~HGNode((HGNode *)this);

  HGObject::operator delete(v2);
}

uint64_t HGSolidColor::SetParameter(HGSolidColor *this, float a2, float a3, float a4, float a5)
{
  return (*(uint64_t (**)(float, float, float, float))(**((void **)this + 51) + 96))(a2, a3, a4, a5);
}

uint64_t HGSolidColor::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  return *((void *)this + 51);
}

void HGCSolidColor::~HGCSolidColor(HGNode *this)
{
  HgcSolidColor::~HgcSolidColor(this);

  HGObject::operator delete(v1);
}

void HGCVBufferPairStorage::HGCVBufferPairStorage(HGCVBufferPairStorage *this, HGCVBitmap *a2, __CVBuffer *a3)
{
  HGObject::HGObject(this);
  *int v6 = &unk_1F10E10B0;
  v6[2] = a2;
  uint64_t v6[3] = a3;
  (*(void (**)(HGCVBitmap *))(*(void *)a2 + 16))(a2);
  CFRetain(*((CFTypeRef *)this + 3));
}

void sub_1B783A180(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGCVBufferPairStorage::~HGCVBufferPairStorage(CFTypeRef *this)
{
  *this = &unk_1F10E10B0;
  CFRelease(this[3]);
  (*(void (**)(CFTypeRef))(*(void *)this[2] + 24))(this[2]);

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v2;
  uint64_t vars8;

  *this = &unk_1F10E10B0;
  CFRelease(this[3]);
  (*(void (**)(CFTypeRef))(*(void *)this[2] + 24))(this[2]);
  HGObject::~HGObject((HGObject *)this);

  HGObject::operator delete(v2);
}

uint64_t HGApplyNDLUTInfo::HGApplyNDLUTInfo(uint64_t result, uint64_t a2, unint64_t a3, int a4, float a5, float a6)
{
  *(void *)uint64_t result = &unk_1F10E1100;
  *(void *)(result + 8) = a2;
  *(void *)(result + 16) = a3;
  *(float *)(result + 24) = a5;
  *(float *)(result + 28) = a6;
  *(_DWORD *)(result + 32) = a4;
  if (a3 <= 3)
  {
    if (a3 == 3) {
      return result;
    }
    uint64_t v6 = 1;
  }
  else
  {
    uint64_t v6 = 3;
  }
  *(void *)(result + 16) = v6;
  return result;
}

float HGApplyNDLUTInfo::getRangeOffset(HGApplyNDLUTInfo *this)
{
  return *((float *)this + 7);
}

uint64_t HGApplyNDLUTInfo::getLUTStorageFormat(HGApplyNDLUTInfo *this)
{
  return *((unsigned int *)this + 8);
}

void *HGApplyNDLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (result)
  {
    if (*(void *)(a1 + 8) == *((void *)result + 1)
      && *(void *)(a1 + 16) == *((void *)result + 2)
      && vabds_f32(*(float *)(a1 + 24), *((float *)result + 6)) < 0.0001
      && vabds_f32(*(float *)(a1 + 28), *((float *)result + 7)) < 0.0001)
    {
      return (void *)(*(_DWORD *)(a1 + 32) == *((_DWORD *)result + 8));
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void HGApplyNDLUTInfo::colorAtIndex(HGApplyNDLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  *a5 = 0.0;
  *a6 = 0.0;
  *a7 = 0.0;
  *a8 = 0.0;
}

void *HGApplyNDLUTEntry::HGApplyNDLUTEntry(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (void *)a2;
  float v5 = HGLUTCache::LUTEntry::LUTEntry(a1, a2, a3);
  *float v5 = &unk_1F10E1150;
  v5[3] = 0;
  uint64_t v6 = (HGBitmap **)(v5 + 3);
  v5[4] = 0;
  if (v3) {
  int v7 = *((_DWORD *)v3 + 2);
  }
  if (*((void *)v3 + 2) == 1)
  {
    uint64_t v9 = HGRectMake4i(0, 0, v7 + 1, 1u);
    uint64_t v10 = v8;
    if ((v8 - v9) < 0x801uLL) {
      goto LABEL_8;
    }
    uint64_t v11 = HGRectMake4i(0, 0, 0x800u, ((v8 - v9) >> 11) + 1);
  }
  else
  {
    uint64_t v11 = HGRectMake4i(0, 0, v7 * v7 + 1, v7 + 1);
  }
  uint64_t v9 = v11;
  uint64_t v10 = v12;
LABEL_8:
  int v13 = *((_DWORD *)v3 + 8);
  if (v13 == 1) {
    unsigned int v14 = 27;
  }
  else {
    unsigned int v14 = 28;
  }
  if (v13) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 25;
  }
  int v16 = HGFormatUtils::bytesPerPixel(v15);
  uint64_t v17 = (HGMemory::StorageObject *)HGObject::operator new(0x20uLL);
  HGMemory::StorageObject::StorageObject(v17, ((HIDWORD(v10) - HIDWORD(v9)) * (v10 - v9) * v16));
  uint64_t v18 = *((void *)v17 + 2);
  HGRect v19 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v19, v9, v10, v15, v18);
  HGRect v20 = *v6;
  if (*v6 == v19)
  {
    if (v19)
    {
      (*(void (**)(HGBitmap *))(*(void *)v19 + 24))(v19);
      HGRect v19 = *v6;
    }
  }
  else
  {
    if (v20) {
      (*(void (**)(HGBitmap *))(*(void *)v20 + 24))(v20);
    }
    *uint64_t v6 = v19;
  }
  HGBitmap::SetStorage(v19, v17);
  HGApplyNDLUTEntry::CopyData((uint64_t)a1, (const HGApplyNDLUTInfo *)v3);
  (*(void (**)(HGMemory::StorageObject *))(*(void *)v17 + 24))(v17);
  return a1;
}

void sub_1B783A660(_Unwind_Exception *a1)
{
  uint64_t v4 = *((void *)v1 + 4);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  if (*v2) {
    (*(void (**)(void))(*(void *)*v2 + 24))(*v2);
  }
  HGLUTCache::LUTEntry::~LUTEntry(v1);
  _Unwind_Resume(a1);
}

uint64_t HGApplyNDLUTEntry::CopyData(uint64_t this, const HGApplyNDLUTInfo *a2)
{
  uint64_t v4 = *((void *)a2 + 1);
  uint64_t v3 = *((void *)a2 + 2);
  float v5 = *((float *)a2 + 7);
  float v6 = *((float *)a2 + 6) / (float)(unint64_t)(v4 - 1);
  *(void *)int v55 = 0;
  float v54 = 0.0;
  float v53 = 0.0;
  uint64_t v7 = *(void *)(this + 24);
  int v8 = *(_DWORD *)(v7 + 16);
  if (v3 == 1)
  {
    uint64_t v9 = *(int16x4_t **)(v7 + 80);
    if (v8 == 27)
    {
      if (v4)
      {
        float v10 = 0.0;
        float32x4_t v49 = (float32x4_t)vdupq_n_s32(0x47800000u);
        float32x4_t v51 = (float32x4_t)vdupq_n_s32(0xC7800000);
        int8x16_t v45 = (int8x16_t)vdupq_n_s32(0xF800000u);
        float32x4_t v47 = (float32x4_t)vdupq_n_s32(0x7800000u);
        do
        {
          this = (*(uint64_t (**)(const HGApplyNDLUTInfo *, unsigned int *, unsigned int *, float *, float *, float, double, double))(*(void *)a2 + 32))(a2, &v55[1], v55, &v54, &v53, v5 + (float)(v6 * v10), 0.0, 0.0);
          v11.i64[0] = __PAIR64__(v55[0], v55[1]);
          v11.i64[1] = __PAIR64__(LODWORD(v53), LODWORD(v54));
          float32x4_t v12 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v51, v11), (int8x16_t)v51, (int8x16_t)v11);
          uint32x4_t v13 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v12, v49), v45, (int8x16_t)vmulq_f32(v12, v47));
          *v9++ = vmovn_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1B8347340), (int8x16_t)xmmword_1B8347350), vandq_s8((int8x16_t)vshlq_u32(v13, (uint32x4_t)xmmword_1B8347360), (int8x16_t)xmmword_1B8347370)));
          float v10 = v10 + 1.0;
          --v4;
        }
        while (v4);
      }
      else
      {
        float32x4_t v11 = 0uLL;
      }
      float32x4_t v39 = (float32x4_t)vdupq_n_s32(0xC7800000);
      float32x4_t v40 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v39, v11), (int8x16_t)v39, (int8x16_t)v11);
      uint32x4_t v41 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v40, (float32x4_t)vdupq_n_s32(0x47800000u)), (int8x16_t)vdupq_n_s32(0xF800000u), (int8x16_t)vmulq_f32(v40, (float32x4_t)vdupq_n_s32(0x7800000u)));
      *uint64_t v9 = vmovn_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(v41, (uint32x4_t)xmmword_1B8347340), (int8x16_t)xmmword_1B8347350), vandq_s8((int8x16_t)vshlq_u32(v41, (uint32x4_t)xmmword_1B8347360), (int8x16_t)xmmword_1B8347370)));
    }
    else
    {
      if (v4)
      {
        float v23 = 0.0;
        do
        {
          this = (*(uint64_t (**)(const HGApplyNDLUTInfo *, unsigned int *, unsigned int *, float *, float *, float, double, double))(*(void *)a2 + 32))(a2, &v55[1], v55, &v54, &v53, v5 + (float)(v6 * v23), 0.0, 0.0);
          v9->i32[0] = v55[1];
          v9->i32[1] = v55[0];
          *(float *)v9[1].i32 = v54;
          float32x4_t v24 = v9 + 2;
          *(float *)&v9[1].i32[1] = v53;
          float v23 = v23 + 1.0;
          v9 += 2;
          --v4;
        }
        while (v4);
        __int32 v25 = v55[1];
        uint64_t v9 = v24;
      }
      else
      {
        __int32 v25 = 0;
      }
      v9->i32[0] = v25;
      float v42 = v54;
      v9->i32[1] = v55[0];
      *(float *)v9[1].i32 = v42;
      *(float *)&v9[1].i32[1] = v53;
    }
  }
  else
  {
    uint64_t v14 = this;
    if (v8 == 25)
    {
      if (v4)
      {
        uint64_t v26 = 0;
        uint64_t v27 = *(void *)(v7 + 80);
        do
        {
          uint64_t v28 = 0;
          float32x4_t v29 = (_WORD *)(v27 + *(void *)(*(void *)(v14 + 24) + 64) * v26);
          do
          {
            for (uint64_t i = 0; i != v4; ++i)
            {
              this = (*(uint64_t (**)(const HGApplyNDLUTInfo *, unsigned int *, unsigned int *, float *, float *, float, float, float))(*(void *)a2 + 32))(a2, &v55[1], v55, &v54, &v53, v5 + (float)(v6 * (float)(int)i), v5 + (float)(v6 * (float)(int)v28), v5 + (float)(v6 * (float)(int)v26));
              float v31 = fmaxf(fminf(*(float *)v55, 1.0), 0.0) * 65535.0;
              *(float *)int v55 = v31;
              *(float *)&v55[1] = fmaxf(fminf(*(float *)&v55[1], 1.0), 0.0) * 65535.0;
              float v32 = fmaxf(fminf(v54, 1.0), 0.0) * 65535.0;
              float v54 = v32;
              float v33 = fmaxf(fminf(v53, 1.0), 0.0);
              float v53 = v33 * 65535.0;
              *float32x4_t v29 = (int)*(float *)&v55[1];
              v29[1] = (int)v31;
              v29[2] = (int)v32;
              v29[3] = (int)(float)(v33 * 65535.0);
              v29 += 4;
            }
            ++v28;
          }
          while (v28 != v4);
          ++v26;
        }
        while (v26 != v4);
      }
    }
    else if (v8 == 28)
    {
      if (v4)
      {
        uint64_t v34 = 0;
        uint64_t v35 = *(void *)(v7 + 80);
        do
        {
          uint64_t v36 = 0;
          int32x4_t v37 = (float *)(v35 + *(void *)(*(void *)(v14 + 24) + 64) * v34);
          do
          {
            for (uint64_t j = 0; j != v4; ++j)
            {
              this = (*(uint64_t (**)(const HGApplyNDLUTInfo *, unsigned int *, unsigned int *, float *, float *, float, float, float))(*(void *)a2 + 32))(a2, &v55[1], v55, &v54, &v53, v5 + (float)(v6 * (float)(int)j), v5 + (float)(v6 * (float)(int)v36), v5 + (float)(v6 * (float)(int)v34));
              *int32x4_t v37 = (float)(*(float *)&v55[1] - v5) / v6;
              v37[1] = (float)(*(float *)v55 - v5) / v6;
              v37[2] = (float)(v54 - v5) / v6;
              v37[3] = (float)(v53 - v5) / v6;
              v37 += 4;
            }
            ++v36;
          }
          while (v36 != v4);
          ++v34;
        }
        while (v34 != v4);
      }
    }
    else if (v8 == 27 && v4)
    {
      uint64_t v15 = 0;
      uint64_t v43 = *(void *)(v7 + 80);
      uint64_t v44 = this;
      float32x4_t v50 = (float32x4_t)vdupq_n_s32(0x47800000u);
      float32x4_t v52 = (float32x4_t)vdupq_n_s32(0xC7800000);
      int8x16_t v46 = (int8x16_t)vdupq_n_s32(0xF800000u);
      float32x4_t v48 = (float32x4_t)vdupq_n_s32(0x7800000u);
      do
      {
        uint64_t v16 = 0;
        uint64_t v17 = v43 + *(void *)(*(void *)(v14 + 24) + 64) * v15;
        do
        {
          uint64_t v18 = 0;
          for (uint64_t k = 0; k != v4; ++k)
          {
            this = (*(uint64_t (**)(const HGApplyNDLUTInfo *, unsigned int *, unsigned int *, float *, float *, float, float, float))(*(void *)a2 + 32))(a2, &v55[1], v55, &v54, &v53, v5 + (float)(v6 * (float)(int)k), v5 + (float)(v6 * (float)(int)v16), v5 + (float)(v6 * (float)(int)v15));
            v20.i64[0] = __PAIR64__(v55[0], v55[1]);
            v20.i64[1] = __PAIR64__(LODWORD(v53), LODWORD(v54));
            float32x4_t v21 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v52, v20), (int8x16_t)v52, (int8x16_t)v20);
            uint32x4_t v22 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v21, v50), v46, (int8x16_t)vmulq_f32(v21, v48));
            *(int16x4_t *)(v17 + 8 * k) = vmovn_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(v22, (uint32x4_t)xmmword_1B8347340), (int8x16_t)xmmword_1B8347350), vandq_s8((int8x16_t)vshlq_u32(v22, (uint32x4_t)xmmword_1B8347360), (int8x16_t)xmmword_1B8347370)));
            v18 -= 8;
          }
          ++v16;
          v17 -= v18;
        }
        while (v16 != v4);
        ++v15;
        uint64_t v14 = v44;
      }
      while (v15 != v4);
    }
  }
  return this;
}

void HGApplyNDLUTEntry::~HGApplyNDLUTEntry(HGApplyNDLUTEntry *this)
{
  *(void *)this = &unk_1F10E1150;
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGLUTCache::LUTEntry::~LUTEntry(this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E1150;
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGLUTCache::LUTEntry::~LUTEntry(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t HGApplyNDLUTEntry::GetBitmap(HGApplyNDLUTEntry *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (!v2 {
    || ((*(uint64_t (**)(uint64_t))(*(void *)v2 + 304))(v2) & 1) != 0
  }
    || (uint64_t v3 = (uint64_t *)*((void *)this + 2),
        uint64_t v4 = *v3,
  {
    float v6 = (HGMetalTexture *)*((void *)this + 3);
    uint64_t v7 = (char *)this + 24;
    if (!v6) {
      return *(void *)v7;
    }
    goto LABEL_11;
  }
  uint64_t v7 = (char *)this + 32;
  float v6 = (HGMetalTexture *)*((void *)this + 4);
  if (v6) {
    goto LABEL_11;
  }
  uint64_t MetalContext = HGGPURenderer::GetMetalContext(v5);
  HGMetalTexture::createWithCopy(*(void **)(*(void *)(MetalContext + 16) + 16), 0, *((void *)this + 3), *(void *)(*((void *)this + 3) + 20), *(void *)(*((void *)this + 3) + 28), 0, 0, &v11);
  uint64_t v9 = (HGMetalTexture *)*((void *)this + 4);
  float v6 = v11;
  if (v9 == v11)
  {
    if (!v9) {
      return *(void *)v7;
    }
    (*(void (**)(void))(*(void *)v9 + 24))(*((void *)this + 4));
    float v6 = *(HGMetalTexture **)v7;
    if (!*(void *)v7) {
      return *(void *)v7;
    }
LABEL_11:
    (*(void (**)(HGMetalTexture *))(*(void *)v6 + 16))(v6);
    return *(void *)v7;
  }
  if (v9)
  {
    (*(void (**)(void))(*(void *)v9 + 24))(*((void *)this + 4));
    float v6 = v11;
  }
  *(void *)uint64_t v7 = v6;
  if (v6) {
    goto LABEL_11;
  }
  return *(void *)v7;
}

void sub_1B783B148(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

void HGInvertAlpha::HGInvertAlpha(HGInvertAlpha *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v2 = &unk_1F10E1190;
  uint64_t v3 = (HgcInvertAlpha *)HGObject::operator new(0x1A0uLL);
  HgcInvertAlpha::HgcInvertAlpha(v3);
  *((void *)this + 51) = v3;
}

void sub_1B783B1E4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B783B200(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGInvertAlpha::~HGInvertAlpha(HGInvertAlpha *this)
{
  *(void *)this = &unk_1F10E1190;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10E1190;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));
  HGNode::~HGNode((HGNode *)this);

  HGObject::operator delete(v2);
}

uint64_t HGInvertAlpha::GetOutput(HGInvertAlpha *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  uint64_t v4 = (*(uint64_t (**)(HGInvertAlpha *, void))(*(void *)this + 128))(this, 0);
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v3 + 120))(v3, 0, v4);
  return *((void *)this + 51);
}

const char *HGFractured::GetProgram(HGNode *this, HGRenderer *a2)
{
  int v4 = *((unsigned __int8 *)this + 432);
  Input = HGRenderer::GetInput(a2, this, 1u);
  uint64_t v6 = *((void *)this + 53);
  if (v4)
  {
    if (Input)
    {
      if (*(_DWORD *)(v6 + 140))
      {
        if (*(unsigned char *)(v6 + 144) || *(float *)(v6 + 136) != 0.0)
        {
          if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
            return "//GLfs1.0      \n"
          }
                   "//LEN=000000054d\n"
                   "#extension GL_ARB_texture_rectangle : enable\n"
                   "uniform sampler2DRect hg_Texture0;\n"
                   "uniform sampler2DRect hg_Texture1;\n"
                   "uniform vec4 hg_ProgramLocal0;\n"
                   "uniform vec4 hg_ProgramLocal1;\n"
                   "uniform vec4 hg_ProgramLocal2;\n"
                   "uniform vec4 hg_ProgramLocal3;\n"
                   "uniform vec4 hg_ProgramLocal4;\n"
                   "uniform vec4 hg_ProgramLocal5;\n"
                   "uniform vec4 hg_ProgramLocal6;\n"
                   "void main()\n"
                   "{\n"
                   "    vec3 N = gl_TexCoord[2].xyz*sign(gl_TexCoord[2].z);\n"
                   "    vec4 color;\n"
                   "    if (gl_TexCoord[2].w >= 0.) { color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); color.xyz = m"
                   "ix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w); color.w *= hg_ProgramLocal0.y; } else { color "
                   "= texture2DRect(hg_Texture1, gl_TexCoord[1].xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, -1."
                   " - gl_TexCoord[2].w); color.w *= hg_ProgramLocal0.w; }\n"
                   "    if (color.w == 0.) discard;\n"
                   "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
                   "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
                   "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLoc"
                   "al5.w);\n"
                   "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), "
                   "0., 1.));\n"
                   "    gl_FragColor = color;\n"
                   "}\n"
                   "//MD5=048203a4:140c5dea:13afe2b7:7d78bf90\n"
                   "//SIG=01000000:00000000:00000000:00000000:0008:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
          else {
            return "//GLfs2.0      \n"
          }
                   "//LEN=0000000621\n"
                   "#ifndef GL_ES\n"
                   "#define lowp\n"
                   "#define mediump\n"
                   "#define highp\n"
                   "#endif\n"
                   "#define defaultp mediump\n"
                   "uniform defaultp sampler2D hg_Texture0;\n"
                   "uniform defaultp sampler2D hg_Texture1;\n"
                   "varying highp vec4 hg_TexCoord0;\n"
                   "varying highp vec4 hg_TexCoord1;\n"
                   "varying highp vec4 hg_TexCoord2;\n"
                   "uniform defaultp vec4 hg_ProgramLocal0;\n"
                   "uniform defaultp vec4 hg_ProgramLocal1;\n"
                   "uniform defaultp vec4 hg_ProgramLocal2;\n"
                   "uniform defaultp vec4 hg_ProgramLocal3;\n"
                   "uniform defaultp vec4 hg_ProgramLocal4;\n"
                   "uniform defaultp vec4 hg_ProgramLocal5;\n"
                   "uniform defaultp vec4 hg_ProgramLocal6;\n"
                   "void main()\n"
                   "{\n"
                   "    defaultp vec3 N = hg_TexCoord2.xyz*sign(hg_TexCoord2.z);\n"
                   "    defaultp vec4 color;\n"
                   "    if (hg_TexCoord2.w >= 0.) { color = texture2D(hg_Texture0, hg_TexCoord0.xy); color.xyz = mix(color"
                   ".xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w); color.w *= hg_ProgramLocal0.y; } else { color = texture2"
                   "D(hg_Texture1, hg_TexCoord1.xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, -1. - hg_TexCoord2."
                   "w); color.w *= hg_ProgramLocal0.w; }\n"
                   "    if (color.w == 0.) discard;\n"
                   "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
                   "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
                   "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLoc"
                   "al5.w);\n"
                   "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), "
                   "0., 1.));\n"
                   "    gl_FragColor = color;\n"
                   "}\n"
                   "//MD5=6d683b18:e19499dd:89a80eed:33f6c6d3\n"
                   "//SIG=01000000:00000000:00000000:00000000:0008:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
        else if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
        {
          return "//GLfs1.0      \n"
                 "//LEN=000000053e\n"
                 "uniform sampler2DRect hg_Texture0;\n"
                 "uniform sampler2DRect hg_Texture1;\n"
                 "uniform vec4 hg_ProgramLocal0;\n"
                 "uniform vec4 hg_ProgramLocal1;\n"
                 "uniform vec4 hg_ProgramLocal2;\n"
                 "uniform vec4 hg_ProgramLocal3;\n"
                 "uniform vec4 hg_ProgramLocal4;\n"
                 "uniform vec4 hg_ProgramLocal5;\n"
                 "uniform vec4 hg_ProgramLocal6;\n"
                 "void main()\n"
                 "{\n"
                 "    vec3 N = gl_TexCoord[2].xyz*sign(gl_TexCoord[2].z);\n"
                 "    vec4 color;\n"
                 "    if (gl_TexCoord[2].w >= 0.) { color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); color.xyz = mix"
                 "(color.xyz, hg_ProgramLocal1.xyz, 1. - float(gl_TexCoord[2].z >= 0.)); color.w *= hg_ProgramLocal0.y; }"
                 " else { color = texture2DRect(hg_Texture1, gl_TexCoord[1].xy); color.xyz = mix(color.xyz, hg_ProgramLoc"
                 "al1.xyz, 1. - float(gl_TexCoord[2].z >= 0.)); color.w *= hg_ProgramLocal0.w; }\n"
                 "    if (color.w == 0.) discard;\n"
                 "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
                 "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
                 "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal"
                 "5.w);\n"
                 "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0."
                 ", 1.));\n"
                 "    gl_FragColor = color;\n"
                 "}\n"
                 "//MD5=96f478a4:68ca6376:eca3120a:0382949c\n"
                 "//SIG=01000000:00000000:00000000:00000000:000b:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
        else
        {
          return "//GLfs2.0      \n"
                 "//LEN=0000000640\n"
                 "#ifndef GL_ES\n"
                 "#define lowp\n"
                 "#define mediump\n"
                 "#define highp\n"
                 "#endif\n"
                 "#define defaultp mediump\n"
                 "uniform defaultp sampler2D hg_Texture0;\n"
                 "uniform defaultp sampler2D hg_Texture1;\n"
                 "varying highp vec4 hg_TexCoord0;\n"
                 "varying highp vec4 hg_TexCoord1;\n"
                 "varying highp vec4 hg_TexCoord2;\n"
                 "uniform defaultp vec4 hg_ProgramLocal0;\n"
                 "uniform defaultp vec4 hg_ProgramLocal1;\n"
                 "uniform defaultp vec4 hg_ProgramLocal2;\n"
                 "uniform defaultp vec4 hg_ProgramLocal3;\n"
                 "uniform defaultp vec4 hg_ProgramLocal4;\n"
                 "uniform defaultp vec4 hg_ProgramLocal5;\n"
                 "uniform defaultp vec4 hg_ProgramLocal6;\n"
                 "void main()\n"
                 "{\n"
                 "\n"
                 "    defaultp vec3 N = hg_TexCoord2.xyz*sign(hg_TexCoord2.z);\n"
                 "    defaultp vec4 color;\n"
                 "    if (hg_TexCoord2.w >= 0.) { color = texture2D(hg_Texture0, hg_TexCoord0.xy); color.xyz = mix(color.x"
                 "yz, hg_ProgramLocal1.xyz, 1. - float(hg_TexCoord2.z >= 0.)); color.w *= hg_ProgramLocal0.y; } else { co"
                 "lor = texture2D(hg_Texture1, hg_TexCoord1.xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, 1. - fl"
                 "oat(hg_TexCoord2.z >= 0.)); color.w *= hg_ProgramLocal0.w; }\n"
                 "    if (color.w == 0.) discard;\n"
                 "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
                 "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
                 "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal"
                 "5.w);\n"
                 "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0."
                 ", 1.));\n"
                 "    gl_FragColor = color;\n"
                 "}\n"
                 "//MD5=6512e0e9:9aceb198:492c6c92:460f64b9\n"
                 "//SIG=01000000:00000000:00000000:00000000:000b:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
      }
      else if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
      {
        return "//GLfs1.0      \n"
               "//LEN=00000004b6\n"
               "uniform sampler2DRect hg_Texture0;\n"
               "uniform sampler2DRect hg_Texture1;\n"
               "uniform vec4 hg_ProgramLocal0;\n"
               "uniform vec4 hg_ProgramLocal1;\n"
               "uniform vec4 hg_ProgramLocal2;\n"
               "uniform vec4 hg_ProgramLocal3;\n"
               "uniform vec4 hg_ProgramLocal4;\n"
               "uniform vec4 hg_ProgramLocal5;\n"
               "uniform vec4 hg_ProgramLocal6;\n"
               "void main()\n"
               "{\n"
               "    vec3 N = gl_TexCoord[2].xyz*sign(gl_TexCoord[2].z);\n"
               "    vec4 color;\n"
               "    if (gl_TexCoord[2].z > 0.) color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); else color = texture"
               "2DRect(hg_Texture1, gl_TexCoord[1].xy);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
               "    color.w *= hg_ProgramLocal0.y;\n"
               "    if (color.w == 0.) discard;\n"
               "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
               "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
               "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5."
               "w);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., "
               "1.));\n"
               "    gl_FragColor = color;\n"
               "}\n"
               "//MD5=1ffc5b22:dfce327a:09069485:c32701b3\n"
               "//SIG=01000000:00000000:00000000:00000000:0007:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
      }
      else
      {
        return "//GLfs2.0      \n"
               "//LEN=00000005ba\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "varying highp vec4 hg_TexCoord1;\n"
               "varying highp vec4 hg_TexCoord2;\n"
               "uniform defaultp vec4 hg_ProgramLocal0;\n"
               "uniform defaultp vec4 hg_ProgramLocal1;\n"
               "uniform defaultp vec4 hg_ProgramLocal2;\n"
               "uniform defaultp vec4 hg_ProgramLocal3;\n"
               "uniform defaultp vec4 hg_ProgramLocal4;\n"
               "uniform defaultp vec4 hg_ProgramLocal5;\n"
               "uniform defaultp vec4 hg_ProgramLocal6;\n"
               "void main()\n"
               "{\n"
               "    defaultp vec3 N = hg_TexCoord2.xyz*sign(hg_TexCoord2.z);\n"
               "    defaultp vec4 color;\n"
               "    if (hg_TexCoord2.z >= 0.) color = texture2D(hg_Texture0, hg_TexCoord0.xy); else color = texture2D(hg_T"
               "exture1, hg_TexCoord1.xy);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
               "    color.w *= hg_ProgramLocal0.y;\n"
               "    if (color.w == 0.) discard;\n"
               "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
               "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
               "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5."
               "w);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., "
               "1.));\n"
               "    gl_FragColor = color;\n"
               "}\n"
               "//MD5=730c0ffa:a53248be:33a85183:f0cac4ce\n"
               "//SIG=01000000:00000000:00000000:00000000:0007:0007:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
      }
    }
    int v8 = *(unsigned __int8 *)(v6 + 144);
    int v9 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46);
    float v10 = "//GLfs1.0      \n"
          "//LEN=000000046a\n"
          "#extension GL_ARB_texture_rectangle : enable\n"
          "uniform sampler2DRect hg_Texture0;\n"
          "uniform vec4 hg_ProgramLocal0;\n"
          "uniform vec4 hg_ProgramLocal1;\n"
          "uniform vec4 hg_ProgramLocal2;\n"
          "uniform vec4 hg_ProgramLocal3;\n"
          "uniform vec4 hg_ProgramLocal4;\n"
          "uniform vec4 hg_ProgramLocal5;\n"
          "uniform vec4 hg_ProgramLocal6;\n"
          "void main()\n"
          "{\n"
          "    vec3 N = gl_TexCoord[2].xyz*sign(gl_TexCoord[2].z);\n"
          "    vec4 color;\n"
          "    color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy);\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
          "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
          "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5.w);\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., 1.));"
          "\n"
          "    gl_FragColor = color;\n"
          "}\n"
          "//MD5=50bcc0cd:7bd315ab:4e84c0b7:5357fb32\n"
          "//SIG=01000000:00000000:00000000:00000000:0006:0007:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    BOOL v11 = v9 == 0;
    float32x4_t v12 = "//GLfs1.0      \n"
          "//LEN=00000004aa\n"
          "#extension GL_ARB_texture_rectangle : enable\n"
          "uniform sampler2DRect hg_Texture0;\n"
          "uniform vec4 hg_ProgramLocal0;\n"
          "uniform vec4 hg_ProgramLocal1;\n"
          "uniform vec4 hg_ProgramLocal2;\n"
          "uniform vec4 hg_ProgramLocal3;\n"
          "uniform vec4 hg_ProgramLocal4;\n"
          "uniform vec4 hg_ProgramLocal5;\n"
          "uniform vec4 hg_ProgramLocal6;\n"
          "void main()\n"
          "{\n"
          "    vec3 N = gl_TexCoord[2].xyz*sign(gl_TexCoord[2].z);\n"
          "    vec4 color;\n"
          "    color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy);\n"
          "    if (gl_TexCoord[2].z < 0.) color.xyz = hg_ProgramLocal1.xyz;\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
          "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
          "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5.w);\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., 1.));"
          "\n"
          "    gl_FragColor = color;\n"
          "}\n"
          "//MD5=84c0772d:b3f43045:cf620bf2:2131a68a\n"
          "//SIG=01000000:00000000:00000000:00000000:0007:0007:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    if (!v9) {
      float v10 = "//GLfs2.0      \n"
    }
            "//LEN=0000000522\n"
            "#ifndef GL_ES\n"
            "#define lowp\n"
            "#define mediump\n"
            "#define highp\n"
            "#endif\n"
            "#define defaultp mediump\n"
            "uniform defaultp sampler2D hg_Texture0;\n"
            "varying highp vec4 hg_TexCoord0;\n"
            "varying highp vec4 hg_TexCoord2;\n"
            "uniform defaultp vec4 hg_ProgramLocal0;\n"
            "uniform defaultp vec4 hg_ProgramLocal1;\n"
            "uniform defaultp vec4 hg_ProgramLocal2;\n"
            "uniform defaultp vec4 hg_ProgramLocal3;\n"
            "uniform defaultp vec4 hg_ProgramLocal4;\n"
            "uniform defaultp vec4 hg_ProgramLocal5;\n"
            "uniform defaultp vec4 hg_ProgramLocal6;\n"
            "void main()\n"
            "{\n"
            "    defaultp vec3 N = hg_TexCoord2.xyz*sign(hg_TexCoord2.z);\n"
            "    defaultp vec4 color;\n"
            "    color = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
            "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
            "    color.w *= hg_ProgramLocal0.y;\n"
            "    if (color.w == 0.) discard;\n"
            "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
            "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
            "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5.w);"
            "\n"
            "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., 1.)"
            ");\n"
            "    gl_FragColor = color;\n"
            "}\n"
            "//MD5=3d5aef97:d57d9f0c:eb222e68:4e70c3a7\n"
            "//SIG=01000000:00000000:00000000:00000000:0006:0007:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    uint32x4_t v13 = "//GLfs2.0      \n"
          "//LEN=0000000560\n"
          "#ifndef GL_ES\n"
          "#define lowp\n"
          "#define mediump\n"
          "#define highp\n"
          "#endif\n"
          "#define defaultp mediump\n"
          "uniform defaultp sampler2D hg_Texture0;\n"
          "varying highp vec4 hg_TexCoord0;\n"
          "varying highp vec4 hg_TexCoord2;\n"
          "uniform defaultp vec4 hg_ProgramLocal0;\n"
          "uniform defaultp vec4 hg_ProgramLocal1;\n"
          "uniform defaultp vec4 hg_ProgramLocal2;\n"
          "uniform defaultp vec4 hg_ProgramLocal3;\n"
          "uniform defaultp vec4 hg_ProgramLocal4;\n"
          "uniform defaultp vec4 hg_ProgramLocal5;\n"
          "uniform defaultp vec4 hg_ProgramLocal6;\n"
          "void main()\n"
          "{\n"
          "    defaultp vec3 N = hg_TexCoord2.xyz*sign(hg_TexCoord2.z);\n"
          "    defaultp vec4 color;\n"
          "    color = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
          "    if (hg_TexCoord2.z < 0.) color.xyz = hg_ProgramLocal1.xyz;\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t color.xyz *= hg_ProgramLocal4.w*max(dot(N, hg_ProgramLocal4.xyz), 0.);\n"
          "    color.xyz += hg_ProgramLocal3.w*hg_ProgramLocal3.xyz;\n"
          "    color.xyz += hg_ProgramLocal5.xyz*pow(max(reflect(-hg_ProgramLocal6.xyz, N).z, 0.), hg_ProgramLocal5.w);\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal2.xyz, clamp(hg_ProgramLocal6.w*(1. - gl_FragCoord.w), 0., 1.));"
          "\n"
          "    gl_FragColor = color;\n"
          "}\n"
          "//MD5=db130e93:74ff1d49:d5dadf6b:55aa0d76\n"
          "//SIG=01000000:00000000:00000000:00000000:0007:0007:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
  }
  else
  {
    if (Input)
    {
      if (*(_DWORD *)(v6 + 140))
      {
        if (*(unsigned char *)(v6 + 144) || *(float *)(v6 + 136) != 0.0)
        {
          if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
            return "//GLfs1.0      \n"
          }
                   "//LEN=0000000319\n"
                   "#extension GL_ARB_texture_rectangle : enable\n"
                   "uniform sampler2DRect hg_Texture0;\n"
                   "uniform sampler2DRect hg_Texture1;\n"
                   "uniform vec4 hg_ProgramLocal0;\n"
                   "uniform vec4 hg_ProgramLocal1;\n"
                   "void main()\n"
                   "{\n"
                   "    vec4 color;\n"
                   "    if (gl_TexCoord[2].w >= 0.) { color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); color.xyz = m"
                   "ix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w); color.w *= hg_ProgramLocal0.y; } else { color "
                   "= texture2DRect(hg_Texture1, gl_TexCoord[1].xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, -1."
                   " - gl_TexCoord[2].w); color.w *= hg_ProgramLocal0.w; }\n"
                   "    if (color.w == 0.) discard;\n"
                   "\t gl_FragColor = color;\n"
                   "}\n"
                   "//MD5=f673426c:e4b2910d:9e07361f:3e827073\n"
                   "//SIG=01000000:00000000:00000000:00000000:0003:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
          else {
            return "//GLfs2.0      \n"
          }
                   "//LEN=00000003bc\n"
                   "#ifndef GL_ES\n"
                   "#define lowp\n"
                   "#define mediump\n"
                   "#define highp\n"
                   "#endif\n"
                   "#define defaultp mediump\n"
                   "uniform defaultp sampler2D hg_Texture0;\n"
                   "uniform defaultp sampler2D hg_Texture1;\n"
                   "varying highp vec4 hg_TexCoord0;\n"
                   "varying highp vec4 hg_TexCoord1;\n"
                   "varying highp vec4 hg_TexCoord2;\n"
                   "uniform defaultp vec4 hg_ProgramLocal0;\n"
                   "uniform defaultp vec4 hg_ProgramLocal1;\n"
                   "void main()\n"
                   "{\n"
                   "\n"
                   "    defaultp vec4 color;\n"
                   "    if (hg_TexCoord2.w >= 0.) { color = texture2D(hg_Texture0, hg_TexCoord0.xy); color.xyz = mix(color"
                   ".xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w); color.w *= hg_ProgramLocal0.y; } else { color = texture2"
                   "D(hg_Texture1, hg_TexCoord1.xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, -1. - hg_TexCoord2."
                   "w); color.w *= hg_ProgramLocal0.w; }\n"
                   "    if (color.w == 0.) discard;\n"
                   "\t gl_FragColor = color;\n"
                   "}\n"
                   "//MD5=d7802c70:56f4148a:7de1731f:a6628685\n"
                   "//SIG=01000000:00000000:00000000:00000000:0003:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
        else if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
        {
          return "//GLfs1.0      \n"
                 "//LEN=000000030a\n"
                 "uniform sampler2DRect hg_Texture0;\n"
                 "uniform sampler2DRect hg_Texture1;\n"
                 "uniform vec4 hg_ProgramLocal0;\n"
                 "uniform vec4 hg_ProgramLocal1;\n"
                 "void main()\n"
                 "{\n"
                 "    vec4 color;\n"
                 "    if (gl_TexCoord[2].w >= 0.) { color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); color.xyz = mix"
                 "(color.xyz, hg_ProgramLocal1.xyz, 1. - float(gl_TexCoord[2].z >= 0.)); color.w *= hg_ProgramLocal0.y; }"
                 " else { color = texture2DRect(hg_Texture1, gl_TexCoord[1].xy); color.xyz = mix(color.xyz, hg_ProgramLoc"
                 "al1.xyz, 1. - float(gl_TexCoord[2].z >= 0.)); color.w *= hg_ProgramLocal0.w; }\n"
                 "    if (color.w == 0.) discard;\n"
                 "\t gl_FragColor = color;\n"
                 "}\n"
                 "//MD5=153a8d02:f92fde9d:5699771f:c33d93d6\n"
                 "//SIG=01000000:00000000:00000000:00000000:0006:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
        else
        {
          return "//GLfs2.0      \n"
                 "//LEN=00000003da\n"
                 "#ifndef GL_ES\n"
                 "#define lowp\n"
                 "#define mediump\n"
                 "#define highp\n"
                 "#endif\n"
                 "#define defaultp mediump\n"
                 "uniform defaultp sampler2D hg_Texture0;\n"
                 "uniform defaultp sampler2D hg_Texture1;\n"
                 "varying highp vec4 hg_TexCoord0;\n"
                 "varying highp vec4 hg_TexCoord1;\n"
                 "varying highp vec4 hg_TexCoord2;\n"
                 "uniform defaultp vec4 hg_ProgramLocal0;\n"
                 "uniform defaultp vec4 hg_ProgramLocal1;\n"
                 "void main()\n"
                 "{\n"
                 "\n"
                 "    defaultp vec4 color;\n"
                 "    if (hg_TexCoord2.w >= 0.) { color = texture2D(hg_Texture0, hg_TexCoord0.xy); color.xyz = mix(color.x"
                 "yz, hg_ProgramLocal1.xyz, 1. - float(hg_TexCoord2.z >= 0.)); color.w *= hg_ProgramLocal0.y; } else { co"
                 "lor = texture2D(hg_Texture1, hg_TexCoord1.xy); color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, 1. - fl"
                 "oat(hg_TexCoord2.z >= 0.)); color.w *= hg_ProgramLocal0.w; }\n"
                 "    if (color.w == 0.) discard;\n"
                 "\t gl_FragColor = color;\n"
                 "}\n"
                 "//MD5=b073f2bb:326233fb:1e6214d5:44610998\n"
                 "//SIG=01000000:00000000:00000000:00000000:0006:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
        }
      }
      else if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
      {
        return "//GLfs1.0      \n"
               "//LEN=00000002b0\n"
               "#extension GL_ARB_texture_rectangle : enable\n"
               "uniform sampler2DRect hg_Texture0;\n"
               "uniform sampler2DRect hg_Texture1;\n"
               "uniform vec4 hg_ProgramLocal0;\n"
               "uniform vec4 hg_ProgramLocal1;\n"
               "void main()\n"
               "{\n"
               "    vec4 color;\n"
               "    if (gl_TexCoord[2].z >= 0.) color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy); else color = textur"
               "e2DRect(hg_Texture1, gl_TexCoord[1].xy);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
               "    color.w *= hg_ProgramLocal0.y;\n"
               "    if (color.w == 0.) discard;\n"
               "\t gl_FragColor = color;\n"
               "}\n"
               "//MD5=8e12dae5:052ec9c0:5f3a6a16:1b06dafe\n"
               "//SIG=01000000:00000000:00000000:00000000:0002:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
      }
      else
      {
        return "//GLfs2.0      \n"
               "//LEN=0000000355\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "varying highp vec4 hg_TexCoord1;\n"
               "varying highp vec4 hg_TexCoord2;\n"
               "uniform defaultp vec4 hg_ProgramLocal0;\n"
               "uniform defaultp vec4 hg_ProgramLocal1;\n"
               "void main()\n"
               "{\n"
               "\n"
               "    defaultp vec4 color;\n"
               "    if (hg_TexCoord2.z >= 0.) color = texture2D(hg_Texture0, hg_TexCoord0.xy); else color = texture2D(hg_T"
               "exture1, hg_TexCoord1.xy);\n"
               "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
               "    color.w *= hg_ProgramLocal0.y;\n"
               "    if (color.w == 0.) discard;\n"
               "\t gl_FragColor = color;\n"
               "}\n"
               "//MD5=fb2a20d4:43fc0741:04bdeaa2:d1f82ff2\n"
               "//SIG=01000000:00000000:00000000:00000000:0002:0002:0000:0000:0000:0000:0000:0000:0003:02:0:1:0\n";
      }
    }
    int v8 = *(unsigned __int8 *)(v6 + 144);
    int v14 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46);
    float v10 = "//GLfs1.0      \n"
          "//LEN=0000000236\n"
          "#extension GL_ARB_texture_rectangle : enable\n"
          "uniform sampler2DRect hg_Texture0;\n"
          "uniform vec4 hg_ProgramLocal0;\n"
          "uniform vec4 hg_ProgramLocal1;\n"
          "void main()\n"
          "{\n"
          "    vec4 color;\n"
          "    color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy);\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t gl_FragColor = color;\n"
          "}\n"
          "//MD5=d2fdd930:3bbc72e9:2dad14b9:097199ac\n"
          "//SIG=01000000:00000000:00000000:00000000:0001:0002:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    BOOL v11 = v14 == 0;
    float32x4_t v12 = "//GLfs1.0      \n"
          "//LEN=0000000276\n"
          "#extension GL_ARB_texture_rectangle : enable\n"
          "uniform sampler2DRect hg_Texture0;\n"
          "uniform vec4 hg_ProgramLocal0;\n"
          "uniform vec4 hg_ProgramLocal1;\n"
          "void main()\n"
          "{\n"
          "    vec4 color;\n"
          "    color = texture2DRect(hg_Texture0, gl_TexCoord[0].xy);\n"
          "    if (gl_TexCoord[2].z < 0.) color.xyz = hg_ProgramLocal1.xyz;\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, gl_TexCoord[2].w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t gl_FragColor = color;\n"
          "}\n"
          "//MD5=10e54296:9caf9cc8:d7817b0a:892592fe\n"
          "//SIG=01000000:00000000:00000000:00000000:0002:0002:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    if (!v14) {
      float v10 = "//GLfs2.0      \n"
    }
            "//LEN=00000002bd\n"
            "#ifndef GL_ES\n"
            "#define lowp\n"
            "#define mediump\n"
            "#define highp\n"
            "#endif\n"
            "#define defaultp mediump\n"
            "uniform defaultp sampler2D hg_Texture0;\n"
            "varying highp vec4 hg_TexCoord0;\n"
            "varying highp vec4 hg_TexCoord2;\n"
            "uniform defaultp vec4 hg_ProgramLocal0;\n"
            "uniform defaultp vec4 hg_ProgramLocal1;\n"
            "void main()\n"
            "{\n"
            "\n"
            "    defaultp vec4 color;\n"
            "    color = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
            "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
            "    color.w *= hg_ProgramLocal0.y;\n"
            "    if (color.w == 0.) discard;\n"
            "\t gl_FragColor = color;\n"
            "}\n"
            "//MD5=fdbbe725:fdd32d95:d5c4f9b0:c807ee7e\n"
            "//SIG=01000000:00000000:00000000:00000000:0001:0002:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
    uint32x4_t v13 = "//GLfs2.0      \n"
          "//LEN=00000002fb\n"
          "#ifndef GL_ES\n"
          "#define lowp\n"
          "#define mediump\n"
          "#define highp\n"
          "#endif\n"
          "#define defaultp mediump\n"
          "uniform defaultp sampler2D hg_Texture0;\n"
          "varying highp vec4 hg_TexCoord0;\n"
          "varying highp vec4 hg_TexCoord2;\n"
          "uniform defaultp vec4 hg_ProgramLocal0;\n"
          "uniform defaultp vec4 hg_ProgramLocal1;\n"
          "void main()\n"
          "{\n"
          "\n"
          "    defaultp vec4 color;\n"
          "    color = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
          "    if (hg_TexCoord2.z < 0.) color.xyz = hg_ProgramLocal1.xyz;\n"
          "    color.xyz = mix(color.xyz, hg_ProgramLocal1.xyz, hg_TexCoord2.w);\n"
          "    color.w *= hg_ProgramLocal0.y;\n"
          "    if (color.w == 0.) discard;\n"
          "\t gl_FragColor = color;\n"
          "}\n"
          "//MD5=56c28ca8:08fd1fcd:e3cb6cf8:3365155c\n"
          "//SIG=01000000:00000000:00000000:00000000:0002:0002:0000:0000:0000:0000:0000:0000:0003:01:0:1:0\n";
  }
  if (!v11) {
    uint32x4_t v13 = v12;
  }
  if (v8) {
    return v10;
  }
  else {
    return v13;
  }
}

uint64_t HGFractured::BindTexture(HGFractured::Effect **this, HGHandler *a2, uint64_t a3)
{
  v8[16] = *(double *)MEMORY[0x1E4F143B8];
  HGFractured::Effect::GetTextureMatrix(this[53], v8);
  if (a3 == 1)
  {
    float v5 = a2;
    int v6 = 1;
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    float v5 = a2;
    int v6 = 0;
  }
  HGHandler::TexCoord(v5, v6, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double *))(*(void *)a2 + 112))(a2, v8);
  (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, 1, 1);
  return 0;
}

uint64_t HGFractured::Bind(HGFractured *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 2, 0, 0, 0);
  if (*((unsigned char *)this + 432))
  {
    uint64_t v4 = *((void *)this + 51);
    float v5 = *(void (**)(HGHandler *, void, uint64_t, uint64_t))(*(void *)a2 + 144);
    if (*(unsigned char *)(*((void *)this + 53) + 145))
    {
      v5(a2, 0, v4, 4);
      (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 4, *(float *)(*((void *)this + 51) + 64), -*(float *)(*((void *)this + 51) + 68), *(float *)(*((void *)this + 51) + 72), *(float *)(*((void *)this + 51) + 76));
      (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 144))(a2, 5, *((void *)this + 51) + 80, 1);
      (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 6, *(float *)(*((void *)this + 51) + 96), -*(float *)(*((void *)this + 51) + 100), *(float *)(*((void *)this + 51) + 104), *(float *)(*((void *)this + 51) + 108));
    }
    else
    {
      v5(a2, 0, v4, 7);
    }
    return 0;
  }
  else
  {
    (*(void (**)(HGHandler *, void, void, uint64_t))(*(void *)a2 + 144))(a2, 0, *((void *)this + 51), 2);
    return 0;
  }
}

HGFractured *HGFractured::GetOutput(HGFractured *this, HGRenderer *a2)
{
  uint64_t v3 = (HGFractured::Effect *)*((void *)this + 53);
  if (!v3) {
    return 0;
  }
  if (HGFractured::Effect::isCropped(v3))
  {
    uint64_t Rect = HGFractured::Effect::GetRect(*((HGFractured::Effect **)this + 53));
    uint64_t v7 = v6;
  }
  else
  {
    Input = HGRenderer::GetInput(a2, (HGNode *)this, 0);
    uint64_t Rect = HGRenderer::GetDOD(a2, Input);
    uint64_t v7 = v10;
    *(void *)&v37.unsigned int var0 = Rect;
    *(void *)&v37.int var2 = v7;
    HGFractured::Effect::SetRect(*((void *)this + 53), v37);
  }
  uint64_t v11 = *((void *)this + 51);
  float v12 = *(float *)v11;
  unsigned __int32 v13 = *(_DWORD *)(v11 + 8);
  if ((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2))
  {
    float v19 = (float)(v7 - Rect);
    float v20 = (float)(HIDWORD(v7) - HIDWORD(Rect));
    float v21 = (float)(v12 * (float)((float)(1.0 / fminf(v19, v20)) + -1.0)) + 1.0;
    *(float *)(*((void *)this + 51) + 116) = v21;
    *(float *)(*((void *)this + 51) + 112) = v21;
    *(float *)(*((void *)this + 51) + 128) = (float)(v19 * 0.5) * (float)(1.0 - v21);
    *(float *)(*((void *)this + 51) + 132) = (float)(v20 * 0.5) * (float)(1.0 - v21);
  }
  else
  {
    HGFractured::Effect::init(*((HGFractured::Effect **)this + 53), v14, v15, v16, v17, v18);
    HGFractured::Effect::build(*((HGFractured::Effect **)this + 53));
    v22.n128_f32[0] = v12;
    v23.n128_u32[0] = v13;
    HGFractured::Effect::apply(*((HGFractured::Effect **)this + 53), v22, v23, v31, v32, v33, v34, v35, v36, v24, v25, v26, v27, v28, v29, v30);
  }
  return this;
}

char *HGFractured::RenderPage(HGNode *this, HGPage *a2)
{
  v23[16] = *(double *)MEMORY[0x1E4F143B8];
  float v5 = *(HGRenderer **)a2;
  Buffer = (char *)*((void *)a2 + 1);
  Input = HGRenderer::GetInput(*(HGRenderer **)a2, this, 0);
  uint64_t v7 = HGRenderer::GetInput(v5, this, 1u);
  int v8 = HGRenderer::GetInput(v5, this, 2u);
  if (Input)
  {
    Nodeint Texture = HGGPURenderer::GetNodeTexture(v5, Input, *(HGRect *)((char *)a2 + 36), 0, 1u);
    *((void *)a2 + 21) = NodeTexture;
    if (v7) {
      goto LABEL_3;
    }
LABEL_18:
    *((void *)a2 + 22) = 0;
    if (!Buffer) {
      goto LABEL_19;
    }
    goto LABEL_5;
  }
  Nodeint Texture = 0;
  *((void *)a2 + 21) = 0;
  if (!v7) {
    goto LABEL_18;
  }
LABEL_3:
  if (v7 == Input)
  {
    *((void *)a2 + 22) = NodeTexture;
    (*(void (**)(unsigned int *))(*(void *)NodeTexture + 16))(NodeTexture);
    if (!Buffer) {
      goto LABEL_19;
    }
LABEL_5:
    (*(void (**)(char *))(*(void *)Buffer + 16))(Buffer);
    if (v8) {
      goto LABEL_6;
    }
LABEL_20:
    (*(void (**)(HGRenderer *, char *))(*(void *)v5 + 144))(v5, Buffer);
    HGGPURenderer::Clear(v5, *((HGRect *)a2 + 1), (float *)(*((void *)this + 51) + 32), v19);
    uint64_t v13 = *((void *)a2 + 21);
    if (v13) {
      goto LABEL_14;
    }
LABEL_21:
    char v14 = 0;
    uint64_t v15 = *((void *)a2 + 22);
    if (!v15) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  *((void *)a2 + 22) = HGGPURenderer::GetNodeTexture(v5, v7, *(HGRect *)((char *)a2 + 52), 0, 1u);
  if (Buffer) {
    goto LABEL_5;
  }
LABEL_19:
  Buffer = HGGPURenderer::CreateBuffer((uint64_t)v5, *((HGRect *)a2 + 1), *((unsigned int *)a2 + 8), 0, (*((_DWORD *)this + 4) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
  *((void *)a2 + 1) = Buffer;
  if (!v8) {
    goto LABEL_20;
  }
LABEL_6:
  NodeBitmap = HGGPURenderer::GetNodeBitmap(v5, v8, *((HGRect *)a2 + 1), (HGBuffer *)Buffer, 1u);
  if (NodeBitmap != (HGBitmap *)Buffer)
  {
    uint64_t v11 = HGGPURenderer::ConvertToTexture(v5, *((HGRect *)a2 + 1), NodeBitmap);
    (*(void (**)(HGRenderer *, char *))(*(void *)v5 + 144))(v5, Buffer);
    (*(void (**)(HGRenderer *, void, uint64_t, void, void))(*(void *)v5 + 152))(v5, 0, v11, 0, 0);
    HGGPURenderer::Copy(v5, *((HGRect *)a2 + 1), 0, v12);
    if (v11 && (HGBitmap *)v11 != NodeBitmap) {
      (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
    }
    (*(void (**)(HGRenderer *, void, void, void, void))(*(void *)v5 + 152))(v5, 0, 0, 0, 0);
  }
  if (NodeBitmap) {
    (*(void (**)(HGBitmap *))(*(void *)NodeBitmap + 24))(NodeBitmap);
  }
  uint64_t v13 = *((void *)a2 + 21);
  if (!v13) {
    goto LABEL_21;
  }
LABEL_14:
  (*(void (**)(HGRenderer *, void, uint64_t, void, void))(*(void *)v5 + 152))(v5, 0, v13, 0, 0);
  (*(void (**)(void))(**((void **)a2 + 21) + 24))(*((void *)a2 + 21));
  char v14 = 1;
  uint64_t v15 = *((void *)a2 + 22);
  if (v15)
  {
LABEL_15:
    (*(void (**)(HGRenderer *, uint64_t, uint64_t, void, void))(*(void *)v5 + 152))(v5, 1, v15, 0, 0);
    (*(void (**)(void))(**((void **)a2 + 22) + 24))(*((void *)a2 + 22));
    v14 |= 2u;
  }
LABEL_16:
  HGTransform::HGTransform((HGTransform *)v22);
  ProjectionMatrix = (const HGTransform *)HGGPURenderer::GetProjectionMatrix(v5);
  HGTransform::LoadTransform((HGTransform *)v22, ProjectionMatrix);
  HGTransform::HGTransform((HGTransform *)v21);
  HGFractured::Effect::GetProjectionMatrix(*((void *)this + 53), v23, *((HGRect *)a2 + 1));
  HGTransform::LoadMatrixd((HGTransform *)v21, v23);
  HGTransform::HGTransform((HGTransform *)v20);
  HGFractured::Effect::GetModelviewMatrix(*((HGFractured::Effect **)this + 53), v23);
  HGTransform::LoadMatrixd((HGTransform *)v20, v23);
  HGTransform::PreMultiply((HGTransform *)v21, (const HGTransform *)v20);
  HGGPURenderer::SetProjectionMatrix(v5, (HGTransform *)v21);
  uint64_t v17 = (*(uint64_t (**)(HGRenderer *, void, HGNode *))(*(void *)v5 + 368))(v5, *((void *)this + 8), this);
  (*(void (**)(HGNode *, HGPage *, void, uint64_t))(*(void *)this + 488))(this, a2, 0, v17);
  HGFractured::Effect::Render(*((HGFractured::Effect **)this + 53), v5, *((HGRect *)a2 + 1), *(float *)(*((void *)this + 51) + 4), *(float *)(*((void *)this + 51) + 12), v14);
  (*(void (**)(HGNode *, HGPage *, void, uint64_t))(*(void *)this + 496))(this, a2, 0, v17);
  HGGPURenderer::SetProjectionMatrix(v5, (HGTransform *)v22);
  HGTransform::~HGTransform((HGTransform *)v20);
  HGTransform::~HGTransform((HGTransform *)v21);
  HGTransform::~HGTransform((HGTransform *)v22);
  return Buffer;
}

void sub_1B783C10C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
}

void sub_1B783C144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
}

void sub_1B783C158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
}

uint64_t HGFractured::RenderTile(HGFractured *this, float32x4_t **a2)
{
  uint64_t v4 = HGTile::Renderer((HGTile *)a2);
  int v5 = (*(uint64_t (**)(HGFractured *, uint64_t))(*(void *)this + 312))(this, v4);
  *(float32x2_t *)v6.f32 = vadd_f32(vcvt_f32_s32(*(int32x2_t *)a2), (float32x2_t)0x3F0000003F000000);
  v6.i64[1] = 0x3F80000000000000;
  int v7 = *((_DWORD *)a2 + 2) - *a2;
  int v8 = *((_DWORD *)a2 + 3) - ((unint64_t)*a2 >> 32);
  int v9 = a2[2];
  uint64_t v10 = *((int *)a2 + 6);
  long long v11 = *(_OWORD *)*((void *)this + 51);
  float v12 = a2[14];
  if (!v12)
  {
    if (v8 < 1) {
      return 0;
    }
    int v76 = 0;
    float32x4_t v77 = v9 + 2;
    uint64_t v78 = 16 * v10;
    v79.i64[0] = 0x3F0000003F000000;
    v79.i64[1] = 0x3F0000003F000000;
    float32x4_t v80 = v6;
    while (v7 < 4)
    {
      LODWORD(v126) = 0;
      float32x4_t v83 = v80;
      if (v7 > 0) {
        goto LABEL_31;
      }
LABEL_21:
      float32x4_t v80 = vaddq_f32(v80, (float32x4_t)xmmword_1B7E736C0);
      ++v76;
      float32x4_t v77 = (float32x4_t *)((char *)v77 + v78);
      int v9 = (float32x4_t *)((char *)v9 + v78);
      if (v76 == v8) {
        return 0;
      }
    }
    int v81 = 0;
    float32x4_t v82 = v77;
    float32x4_t v83 = v80;
    do
    {
      float32x4_t v106 = vaddq_f32(v83, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v107 = vaddq_f32(v106, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v108 = vaddq_f32(v107, (float32x4_t)xmmword_1B7E736B0);
      int32x4_t v109 = (float32x4_t *)*((void *)this + 51);
      float32x4_t v111 = v109[7];
      float32x4_t v110 = v109[8];
      float32x4_t v112 = vaddq_f32(v110, vmulq_f32(v106, v111));
      float32x4_t v113 = vaddq_f32(v110, vmulq_f32(v107, v111));
      float32x4_t v114 = vaddq_f32(v110, vmulq_f32(v108, v111));
      int8x16_t v115 = a2[10];
      uint64_t v116 = *((int *)a2 + 22);
      float32x4_t v117 = vsubq_f32(vaddq_f32(v110, vmulq_f32(v83, v111)), v6);
      if (v5)
      {
        int32x4_t v84 = vaddq_s32(vcvtq_s32_f32(v117), vcltzq_f32(v117));
        float32x2_t v85 = (float32x2_t)vsubq_f32(v117, vcvtq_f32_s32(v84)).u64[0];
        int v86 = &v115[v84.i32[0] + v84.i32[1] * (int)v116];
        float32x4_t v87 = vaddq_f32(*v86, vmulq_n_f32(vsubq_f32(v86[1], *v86), v85.f32[0]));
        uint64_t v88 = (int)v116 + 1;
        float32x4_t v89 = vaddq_f32(v87, vmulq_lane_f32(vsubq_f32(vaddq_f32(v86[v116], vmulq_n_f32(vsubq_f32(v86[v88], v86[v116]), v85.f32[0])), v87), v85, 1));
        float32x4_t v90 = vsubq_f32(v112, v6);
        int32x4_t v91 = vaddq_s32(vcvtq_s32_f32(v90), vcltzq_f32(v90));
        v90.i64[0] = vsubq_f32(v90, vcvtq_f32_s32(v91)).u64[0];
        float v92 = &v115[v91.i32[0] + v91.i32[1] * (int)v116];
        float32x4_t v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v90.f32[0]));
        float32x4_t v94 = vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v116], vmulq_n_f32(vsubq_f32(v92[v88], v92[v116]), v90.f32[0])), v93), *(float32x2_t *)v90.f32, 1));
        float32x4_t v95 = vsubq_f32(v113, v6);
        int32x4_t v96 = vaddq_s32(vcvtq_s32_f32(v95), vcltzq_f32(v95));
        v95.i64[0] = vsubq_f32(v95, vcvtq_f32_s32(v96)).u64[0];
        float32x4_t v97 = &v115[v96.i32[0] + v96.i32[1] * (int)v116];
        float32x4_t v98 = vaddq_f32(*v97, vmulq_n_f32(vsubq_f32(v97[1], *v97), v95.f32[0]));
        float32x4_t v99 = vaddq_f32(v98, vmulq_lane_f32(vsubq_f32(vaddq_f32(v97[v116], vmulq_n_f32(vsubq_f32(v97[v88], v97[v116]), v95.f32[0])), v98), *(float32x2_t *)v95.f32, 1));
        float32x4_t v100 = vsubq_f32(v114, v6);
        int32x4_t v101 = vaddq_s32(vcvtq_s32_f32(v100), vcltzq_f32(v100));
        v100.i64[0] = vsubq_f32(v100, vcvtq_f32_s32(v101)).u64[0];
        int8x16_t v102 = &v115[v101.i32[0] + v101.i32[1] * (int)v116];
        float32x4_t v103 = vaddq_f32(*v102, vmulq_n_f32(vsubq_f32(v102[1], *v102), v100.f32[0]));
        float32x4_t v104 = vaddq_f32(v103, vmulq_lane_f32(vsubq_f32(vaddq_f32(v102[v116], vmulq_n_f32(vsubq_f32(v102[v88], v102[v116]), v100.f32[0])), v103), *(float32x2_t *)v100.f32, 1));
      }
      else
      {
        float32x4_t v118 = vaddq_f32(v117, v79);
        int32x4_t v119 = vcvtq_s32_f32(v118);
        v118.i64[0] = vaddq_s32(v119, vcgtq_f32(vcvtq_f32_s32(v119), v118)).u64[0];
        float32x4_t v89 = v115[v118.i32[0] + v118.i32[1] * (int)v116];
        float32x4_t v120 = vaddq_f32(vsubq_f32(v112, v6), v79);
        int32x4_t v121 = vcvtq_s32_f32(v120);
        v120.i64[0] = vaddq_s32(v121, vcgtq_f32(vcvtq_f32_s32(v121), v120)).u64[0];
        float32x4_t v94 = v115[v120.i32[0] + v120.i32[1] * (int)v116];
        float32x4_t v122 = vaddq_f32(vsubq_f32(v113, v6), v79);
        int32x4_t v123 = vcvtq_s32_f32(v122);
        v122.i64[0] = vaddq_s32(v123, vcgtq_f32(vcvtq_f32_s32(v123), v122)).u64[0];
        float32x4_t v99 = v115[v122.i32[0] + v122.i32[1] * (int)v116];
        float32x4_t v124 = vaddq_f32(vsubq_f32(v114, v6), v79);
        int32x4_t v125 = vcvtq_s32_f32(v124);
        v124.i64[0] = vaddq_s32(v125, vcgtq_f32(vcvtq_f32_s32(v125), v124)).u64[0];
        float32x4_t v104 = v115[v124.i32[0] + v124.i32[1] * (int)v116];
      }
      float32x4_t v105 = v109[14];
      v82[-2] = vaddq_f32(v89, vmulq_lane_f32(vsubq_f32(v105, v89), *(float32x2_t *)&v11, 1));
      v82[-1] = vaddq_f32(v94, vmulq_lane_f32(vsubq_f32(v105, v94), *(float32x2_t *)&v11, 1));
      *float32x4_t v82 = vaddq_f32(v99, vmulq_lane_f32(vsubq_f32(v105, v99), *(float32x2_t *)&v11, 1));
      v82[1] = vaddq_f32(v104, vmulq_lane_f32(vsubq_f32(v105, v104), *(float32x2_t *)&v11, 1));
      v82 += 4;
      float32x4_t v83 = vaddq_f32(v108, (float32x4_t)xmmword_1B7E736B0);
      v81 -= 4;
    }
    while (v7 + v81 > 3);
    LODWORD(v126) = -v81;
    if ((int)v126 >= v7) {
      goto LABEL_21;
    }
LABEL_31:
    uint64_t v126 = v126;
    if (v5)
    {
      do
      {
        int16x8_t v127 = (float32x4_t *)*((void *)this + 51);
        uint64_t v128 = *((int *)a2 + 22);
        float32x4_t v129 = vsubq_f32(vaddq_f32(v127[8], vmulq_f32(v83, v127[7])), v6);
        int32x4_t v130 = vaddq_s32(vcvtq_s32_f32(v129), vcltzq_f32(v129));
        v129.i64[0] = vsubq_f32(v129, vcvtq_f32_s32(v130)).u64[0];
        uint64_t v131 = &a2[10][v130.i32[0] + v130.i32[1] * (int)v128];
        float32x4_t v132 = vaddq_f32(*v131, vmulq_n_f32(vsubq_f32(v131[1], *v131), v129.f32[0]));
        float32x4_t v133 = vaddq_f32(v132, vmulq_lane_f32(vsubq_f32(vaddq_f32(v131[v128], vmulq_n_f32(vsubq_f32(v131[(int)v128 + 1], v131[v128]), v129.f32[0])), v132), *(float32x2_t *)v129.f32, 1));
        v9[v126] = vaddq_f32(v133, vmulq_lane_f32(vsubq_f32(v127[14], v133), *(float32x2_t *)&v11, 1));
        float32x4_t v83 = vaddq_f32(v83, (float32x4_t)xmmword_1B7E736B0);
        ++v126;
      }
      while (v126 < v7);
    }
    else
    {
      do
      {
        unsigned __int8 v134 = (float32x4_t *)*((void *)this + 51);
        float32x4_t v135 = vaddq_f32(vsubq_f32(vaddq_f32(v134[8], vmulq_f32(v83, v134[7])), v6), v79);
        int32x4_t v136 = vcvtq_s32_f32(v135);
        v135.i64[0] = vaddq_s32(v136, vcgtq_f32(vcvtq_f32_s32(v136), v135)).u64[0];
        float32x4_t v137 = a2[10][v135.i32[0] + v135.i32[1] * *((_DWORD *)a2 + 22)];
        v9[v126] = vaddq_f32(v137, vmulq_lane_f32(vsubq_f32(v134[14], v137), *(float32x2_t *)&v11, 1));
        float32x4_t v83 = vaddq_f32(v83, (float32x4_t)xmmword_1B7E736B0);
        ++v126;
      }
      while (v126 < v7);
    }
    goto LABEL_21;
  }
  if (v8 >= 1)
  {
    int v13 = 0;
    uint64_t v14 = 16 * *((int *)a2 + 30);
    uint64_t v15 = 16 * v10;
    v16.i64[0] = 0x3F0000003F000000;
    v16.i64[1] = 0x3F0000003F000000;
    float32x4_t v17 = v6;
    while (v7 < 4)
    {
      LODWORD(v66) = 0;
      float32x4_t v20 = v17;
      if (v7 > 0) {
        goto LABEL_14;
      }
LABEL_4:
      float32x4_t v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B7E736C0);
      ++v13;
      float v12 = (float32x4_t *)((char *)v12 + v14);
      int v9 = (float32x4_t *)((char *)v9 + v15);
      if (v13 == v8) {
        return 0;
      }
    }
    int v18 = 0;
    uint64_t v19 = 2;
    float32x4_t v20 = v17;
    do
    {
      float32x4_t v46 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v47 = vaddq_f32(v46, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v48 = vaddq_f32(v47, (float32x4_t)xmmword_1B7E736B0);
      float32x4_t v49 = (float32x4_t *)*((void *)this + 51);
      float32x4_t v51 = v49[7];
      float32x4_t v50 = v49[8];
      float32x4_t v52 = vaddq_f32(v50, vmulq_f32(v46, v51));
      float32x4_t v53 = vaddq_f32(v50, vmulq_f32(v47, v51));
      float32x4_t v54 = vaddq_f32(v50, vmulq_f32(v48, v51));
      int v55 = a2[10];
      uint64_t v56 = *((int *)a2 + 22);
      float32x4_t v57 = vsubq_f32(vaddq_f32(v50, vmulq_f32(v20, v51)), v6);
      if (v5)
      {
        int32x4_t v21 = vaddq_s32(vcvtq_s32_f32(v57), vcltzq_f32(v57));
        float32x2_t v22 = (float32x2_t)vsubq_f32(v57, vcvtq_f32_s32(v21)).u64[0];
        __n128 v23 = &v55[v21.i32[0] + v21.i32[1] * (int)v56];
        float32x4_t v24 = vaddq_f32(*v23, vmulq_n_f32(vsubq_f32(v23[1], *v23), v22.f32[0]));
        uint64_t v25 = (int)v56 + 1;
        float32x4_t v26 = vaddq_f32(v24, vmulq_lane_f32(vsubq_f32(vaddq_f32(v23[v56], vmulq_n_f32(vsubq_f32(v23[v25], v23[v56]), v22.f32[0])), v24), v22, 1));
        float32x4_t v27 = vsubq_f32(v52, v6);
        int32x4_t v28 = vaddq_s32(vcvtq_s32_f32(v27), vcltzq_f32(v27));
        v27.i64[0] = vsubq_f32(v27, vcvtq_f32_s32(v28)).u64[0];
        uint64_t v29 = &v55[v28.i32[0] + v28.i32[1] * (int)v56];
        float32x4_t v30 = vaddq_f32(*v29, vmulq_n_f32(vsubq_f32(v29[1], *v29), v27.f32[0]));
        float32x4_t v31 = vaddq_f32(v30, vmulq_lane_f32(vsubq_f32(vaddq_f32(v29[v56], vmulq_n_f32(vsubq_f32(v29[v25], v29[v56]), v27.f32[0])), v30), *(float32x2_t *)v27.f32, 1));
        float32x4_t v32 = vsubq_f32(v53, v6);
        int32x4_t v33 = vaddq_s32(vcvtq_s32_f32(v32), vcltzq_f32(v32));
        v32.i64[0] = vsubq_f32(v32, vcvtq_f32_s32(v33)).u64[0];
        float32x4_t v34 = &v55[v33.i32[0] + v33.i32[1] * (int)v56];
        float32x4_t v35 = vaddq_f32(*v34, vmulq_n_f32(vsubq_f32(v34[1], *v34), v32.f32[0]));
        float32x4_t v36 = vaddq_f32(v35, vmulq_lane_f32(vsubq_f32(vaddq_f32(v34[v56], vmulq_n_f32(vsubq_f32(v34[v25], v34[v56]), v32.f32[0])), v35), *(float32x2_t *)v32.f32, 1));
        float32x4_t v37 = vsubq_f32(v54, v6);
        int32x4_t v38 = vaddq_s32(vcvtq_s32_f32(v37), vcltzq_f32(v37));
        v37.i64[0] = vsubq_f32(v37, vcvtq_f32_s32(v38)).u64[0];
        float32x4_t v39 = &v55[v38.i32[0] + v38.i32[1] * (int)v56];
        float32x4_t v40 = vaddq_f32(*v39, vmulq_n_f32(vsubq_f32(v39[1], *v39), v37.f32[0]));
        float32x4_t v41 = vaddq_f32(v40, vmulq_lane_f32(vsubq_f32(vaddq_f32(v39[v56], vmulq_n_f32(vsubq_f32(v39[v25], v39[v56]), v37.f32[0])), v40), *(float32x2_t *)v37.f32, 1));
      }
      else
      {
        float32x4_t v58 = vaddq_f32(v57, v16);
        int32x4_t v59 = vcvtq_s32_f32(v58);
        v58.i64[0] = vaddq_s32(v59, vcgtq_f32(vcvtq_f32_s32(v59), v58)).u64[0];
        float32x4_t v26 = v55[v58.i32[0] + v58.i32[1] * (int)v56];
        float32x4_t v60 = vaddq_f32(vsubq_f32(v52, v6), v16);
        int32x4_t v61 = vcvtq_s32_f32(v60);
        v60.i64[0] = vaddq_s32(v61, vcgtq_f32(vcvtq_f32_s32(v61), v60)).u64[0];
        float32x4_t v31 = v55[v60.i32[0] + v60.i32[1] * (int)v56];
        float32x4_t v62 = vaddq_f32(vsubq_f32(v53, v6), v16);
        int32x4_t v63 = vcvtq_s32_f32(v62);
        v62.i64[0] = vaddq_s32(v63, vcgtq_f32(vcvtq_f32_s32(v63), v62)).u64[0];
        float32x4_t v36 = v55[v62.i32[0] + v62.i32[1] * (int)v56];
        float32x4_t v64 = vaddq_f32(vsubq_f32(v54, v6), v16);
        int32x4_t v65 = vcvtq_s32_f32(v64);
        v64.i64[0] = vaddq_s32(v65, vcgtq_f32(vcvtq_f32_s32(v65), v64)).u64[0];
        float32x4_t v41 = v55[v64.i32[0] + v64.i32[1] * (int)v56];
      }
      float32x4_t v42 = vaddq_f32(v31, vmulq_lane_f32(vsubq_f32(v12[v19 - 1], v31), *(float32x2_t *)&v11, 1));
      float32x4_t v43 = vaddq_f32(v36, vmulq_lane_f32(vsubq_f32(v12[v19], v36), *(float32x2_t *)&v11, 1));
      float32x4_t v44 = vaddq_f32(v41, vmulq_lane_f32(vsubq_f32(v12[v19 + 1], v41), *(float32x2_t *)&v11, 1));
      int8x16_t v45 = &v9[v19];
      v45[-2] = vaddq_f32(v26, vmulq_lane_f32(vsubq_f32(v12[v19 - 2], v26), *(float32x2_t *)&v11, 1));
      v45[-1] = v42;
      *int8x16_t v45 = v43;
      v45[1] = v44;
      float32x4_t v20 = vaddq_f32(v48, (float32x4_t)xmmword_1B7E736B0);
      v18 -= 4;
      v19 += 4;
    }
    while (v7 + v18 > 3);
    LODWORD(v66) = -v18;
    if ((int)v66 >= v7) {
      goto LABEL_4;
    }
LABEL_14:
    uint64_t v66 = v66;
    if (v5)
    {
      do
      {
        uint64_t v67 = *((int *)a2 + 22);
        float32x4_t v68 = vsubq_f32(vaddq_f32(*(float32x4_t *)(*((void *)this + 51) + 128), vmulq_f32(v20, *(float32x4_t *)(*((void *)this + 51) + 112))), v6);
        int32x4_t v69 = vaddq_s32(vcvtq_s32_f32(v68), vcltzq_f32(v68));
        v68.i64[0] = vsubq_f32(v68, vcvtq_f32_s32(v69)).u64[0];
        int32x4_t v70 = &a2[10][v69.i32[0] + v69.i32[1] * (int)v67];
        float32x4_t v71 = vaddq_f32(*v70, vmulq_n_f32(vsubq_f32(v70[1], *v70), v68.f32[0]));
        float32x4_t v72 = vaddq_f32(v71, vmulq_lane_f32(vsubq_f32(vaddq_f32(v70[v67], vmulq_n_f32(vsubq_f32(v70[(int)v67 + 1], v70[v67]), v68.f32[0])), v71), *(float32x2_t *)v68.f32, 1));
        v9[v66] = vaddq_f32(v72, vmulq_lane_f32(vsubq_f32(v12[v66], v72), *(float32x2_t *)&v11, 1));
        float32x4_t v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
        ++v66;
      }
      while (v66 < v7);
    }
    else
    {
      do
      {
        float32x4_t v73 = vaddq_f32(vsubq_f32(vaddq_f32(*(float32x4_t *)(*((void *)this + 51) + 128), vmulq_f32(v20, *(float32x4_t *)(*((void *)this + 51) + 112))), v6), v16);
        int32x4_t v74 = vcvtq_s32_f32(v73);
        v73.i64[0] = vaddq_s32(v74, vcgtq_f32(vcvtq_f32_s32(v74), v73)).u64[0];
        float32x4_t v75 = a2[10][v73.i32[0] + v73.i32[1] * *((_DWORD *)a2 + 22)];
        v9[v66] = vaddq_f32(v75, vmulq_lane_f32(vsubq_f32(v12[v66], v75), *(float32x2_t *)&v11, 1));
        float32x4_t v20 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
        ++v66;
      }
      while (v66 < v7);
    }
    goto LABEL_4;
  }
  return 0;
}

uint64_t HGFractured::GetDOD(HGFractured::Effect **this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  switch(a3)
  {
    case 2:
      if ((*((uint64_t (**)(HGFractured::Effect **, uint64_t))*this + 16))(this, 2)) {
        return v5;
      }
      break;
    case 1:
      if (!(*(unsigned int (**)(HGRenderer *))(*(void *)a2 + 304))(a2)
        && (*((uint64_t (**)(HGFractured::Effect **, uint64_t))*this + 16))(this, 1))
      {
        return HGFractured::Effect::GetRect(this[53]);
      }
      break;
    case 0:
      if ((*(unsigned int (**)(HGRenderer *))(*(void *)a2 + 304))(a2))
      {
        uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
        int v8 = HGRectGrow(v5, v4, v7);
        float v9 = HGRectFloat(v8);
        float v13 = HGRectTranslate(v9, v10, v11, v12, -*((float *)this[51] + 32));
        float v17 = HGRectScale(v13, v14, v15, v16, 1.0 / *((float *)this[51] + 28));
        return HGRectIntegral(v18, v17, v19, v20, v21);
      }
      return HGFractured::Effect::GetRect(this[53]);
  }
  return 0;
}

uint64_t HGFractured::GetROI(HGFractured *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var0;
  if (a3 == 2)
  {
    if ((*(uint64_t (**)(HGFractured *, uint64_t))(*(void *)this + 128))(this, 2)) {
      return v4;
    }
    return 0;
  }
  if (a3 != 1)
  {
    if (!a3)
    {
      if ((*(unsigned int (**)(HGRenderer *))(*(void *)a2 + 304))(a2))
      {
        float v7 = HGRectFloat(v4);
        float v11 = HGRectScale(v7, v8, v9, v10, *(float *)(*((void *)this + 51) + 112));
        float v15 = HGRectTranslate(v11, v12, v13, v14, *(float *)(*((void *)this + 51) + 128));
        uint64_t v20 = HGRectIntegral(v16, v15, v17, v18, v19);
        uint64_t v22 = v21;
        uint64_t v23 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
        return HGRectGrow(v20, v22, v23);
      }
      return HGFractured::Effect::GetImageRect(*((HGFractured::Effect **)this + 53));
    }
    return 0;
  }
  if (!(*(uint64_t (**)(HGFractured *, uint64_t))(*(void *)this + 128))(this, 1)
    || (*(unsigned int (**)(HGRenderer *))(*(void *)a2 + 304))(a2))
  {
    return 0;
  }
  return HGFractured::Effect::GetImageRect(*((HGFractured::Effect **)this + 53));
}

void HGFractured::HGFractured(HGFractured *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10E13F8;
  *(_DWORD *)(v1 + 416) = 8;
  *(void *)(v1 + 424) = 0;
  *(unsigned char *)(v1 + 432) = 0;
  *(_DWORD *)(v1 + 436) = 1;
  operator new();
}

void sub_1B783CF30(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGFractured::~HGFractured(HGNode *this)
{
  *(void *)this = &unk_1F10E13F8;
  uint64_t v2 = *((void *)this + 53);
  if (v2)
  {
    HGFractured::Effect::SetState(v2, 0);
    (*(void (**)(void))(**((void **)this + 53) + 24))(*((void *)this + 53));
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3) {
    MEMORY[0x1BA9BFBA0](v3, 0x1000C4019FCA701);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10E13F8;
  uint64_t v2 = *((void *)this + 53);
  if (v2)
  {
    HGFractured::Effect::SetState(v2, 0);
    (*(void (**)(void))(**((void **)this + 53) + 24))(*((void *)this + 53));
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3) {
    MEMORY[0x1BA9BFBA0](v3, 0x1000C4019FCA701);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

uint64_t HGFractured::SetEffect(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t))(*(void *)a2 + 16))(a2);
  }
  uint64_t result = *(void *)(a1 + 424);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
  }
  *(void *)(a1 + 424) = a2;
  return result;
}

uint64_t HGFractured::SetLighting(uint64_t this, char a2)
{
  *(unsigned char *)(this + 432) = a2;
  return this;
}

uint64_t HGFractured::SetParameter(HGFractured *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  switch((int)a2)
  {
    case 0:
      float v7 = (float *)*((void *)this + 51);
      if (v7) {
        goto LABEL_12;
      }
      return 0xFFFFFFFFLL;
    case 1:
      uint64_t v9 = *((void *)this + 51);
      float v10 = *(float *)(v9 + 16);
      float v7 = (float *)(v9 + 16);
      if (v10 == a3) {
        goto LABEL_16;
      }
      goto LABEL_19;
    case 2:
      uint64_t v11 = *((void *)this + 51);
      float v12 = *(float *)(v11 + 32);
      float v7 = (float *)(v11 + 32);
      if (v12 == a3) {
        goto LABEL_16;
      }
      goto LABEL_19;
    case 3:
      uint64_t v13 = *((void *)this + 51);
      float v14 = *(float *)(v13 + 48);
      float v7 = (float *)(v13 + 48);
      if (v14 == a3) {
        goto LABEL_16;
      }
      goto LABEL_19;
    case 4:
      float v7 = (float *)(*((void *)this + 51) + 64);
      goto LABEL_15;
    case 5:
      float v7 = (float *)(*((void *)this + 51) + 80);
LABEL_12:
      if (*v7 == a3) {
        goto LABEL_16;
      }
      goto LABEL_19;
    case 6:
      float v7 = (float *)(*((void *)this + 51) + 96);
LABEL_15:
      float v15 = sqrtf((float)((float)(a3 * a3) + (float)(a4 * a4)) + (float)(a5 * a5));
      a3 = a3 / v15;
      a4 = a4 / v15;
      a5 = a5 / v15;
      if (*v7 != a3) {
        goto LABEL_19;
      }
LABEL_16:
      if (v7[1] == a4 && v7[2] == a5 && v7[3] == a6) {
        return 0;
      }
LABEL_19:
      *float v7 = a3;
      v7[1] = a4;
      v7[2] = a5;
      v7[3] = a6;
      *((_DWORD *)this + 109) = 1;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

uint64_t HGFractured::GetParameter(HGFractured *this, unsigned int a2, float *a3)
{
  if (a2 > 6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

uint64_t HGFractured::SetMultiSampleLevel(HGFractured *this, int a2)
{
  *((_DWORD *)this + 104) = a2;
  return 1;
}

void soKMeansClassifier::soKMeansClassifier(soKMeansClassifier *this)
{
}

uint64_t soKMeansClassifier::DeleteStats(soKMeansClassifier *this)
{
  uint64_t v2 = *((void *)this + 21);
  if (v2)
  {
    MEMORY[0x1BA9BFB70](v2, 0x1000C80451B5BE8);
    *((void *)this + 21) = 0;
  }
  uint64_t v3 = *((void *)this + 22);
  if (v3)
  {
    MEMORY[0x1BA9BFB70](v3, 0x1000C80451B5BE8);
    *((void *)this + 22) = 0;
  }
  uint64_t v4 = *((void *)this + 32);
  if (v4)
  {
    MEMORY[0x1BA9BFB70](v4, 0x1000C80E0EAB150);
    *((void *)this + 32) = 0;
  }
  uint64_t v5 = *((void *)this + 33);
  if (v5)
  {
    MEMORY[0x1BA9BFB70](v5, 0x1000C80E0EAB150);
    *((void *)this + 33) = 0;
  }
  uint64_t v6 = *((void *)this + 34);
  if (v6)
  {
    MEMORY[0x1BA9BFB70](v6, 0x1000C80E0EAB150);
    *((void *)this + 34) = 0;
  }
  uint64_t v7 = *((void *)this + 35);
  if (v7)
  {
    MEMORY[0x1BA9BFB70](v7, 0x1000C80E0EAB150);
    *((void *)this + 35) = 0;
  }
  uint64_t v8 = *((void *)this + 36);
  if (v8)
  {
    MEMORY[0x1BA9BFB70](v8, 0x1000C8000313F17);
    *((void *)this + 36) = 0;
  }
  uint64_t v9 = *((void *)this + 37);
  if (v9)
  {
    MEMORY[0x1BA9BFB70](v9, 0x1000C8000313F17);
    *((void *)this + 37) = 0;
  }
  uint64_t v10 = *((void *)this + 38);
  if (v10)
  {
    MEMORY[0x1BA9BFB70](v10, 0x1000C80E0EAB150);
    *((void *)this + 38) = 0;
  }
  uint64_t v11 = *((void *)this + 39);
  if (v11)
  {
    MEMORY[0x1BA9BFB70](v11, 0x1000C80E0EAB150);
    *((void *)this + 39) = 0;
  }
  uint64_t v12 = *((void *)this + 40);
  if (v12)
  {
    MEMORY[0x1BA9BFB70](v12, 0x1000C80E0EAB150);
    *((void *)this + 40) = 0;
  }
  uint64_t v13 = *((void *)this + 41);
  if (v13)
  {
    MEMORY[0x1BA9BFB70](v13, 0x1000C80E0EAB150);
    *((void *)this + 41) = 0;
  }
  uint64_t v14 = *((void *)this + 25);
  if (v14)
  {
    MEMORY[0x1BA9BFB70](v14, 0x1000C8000313F17);
    *((void *)this + 25) = 0;
  }
  uint64_t v15 = *((void *)this + 26);
  if (v15)
  {
    MEMORY[0x1BA9BFB70](v15, 0x1000C8000313F17);
    *((void *)this + 26) = 0;
  }
  uint64_t v16 = *((void *)this + 23);
  if (v16)
  {
    MEMORY[0x1BA9BFB70](v16, 0x1000C80565EDBD2);
    *((void *)this + 23) = 0;
  }
  uint64_t v17 = *((void *)this + 24);
  if (v17)
  {
    MEMORY[0x1BA9BFB70](v17, 0x1000C80565EDBD2);
    *((void *)this + 24) = 0;
  }
  uint64_t v18 = *((void *)this + 27);
  if (v18)
  {
    MEMORY[0x1BA9BFB70](v18, 0x1000C8000313F17);
    *((void *)this + 27) = 0;
  }
  uint64_t v19 = *((void *)this + 28);
  if (v19)
  {
    MEMORY[0x1BA9BFB70](v19, 0x1000C8000313F17);
    *((void *)this + 28) = 0;
  }
  uint64_t v20 = *((void *)this + 29);
  if (v20)
  {
    MEMORY[0x1BA9BFB70](v20, 0x1000C8000313F17);
    *((void *)this + 29) = 0;
  }
  uint64_t v21 = *((void *)this + 30);
  if (v21)
  {
    MEMORY[0x1BA9BFB70](v21, 0x1000C8000313F17);
    *((void *)this + 30) = 0;
  }
  uint64_t v22 = *((void *)this + 44);
  if (v22)
  {
    MEMORY[0x1BA9BFB70](v22, 0x1000C8000313F17);
    *((void *)this + 44) = 0;
  }
  uint64_t v23 = *((void *)this + 45);
  if (v23)
  {
    MEMORY[0x1BA9BFB70](v23, 0x1000C8000313F17);
    *((void *)this + 45) = 0;
  }
  uint64_t v24 = *((void *)this + 46);
  if (v24)
  {
    MEMORY[0x1BA9BFB70](v24, 0x1000C8000313F17);
    *((void *)this + 46) = 0;
  }
  uint64_t v25 = *((void *)this + 47);
  if (v25)
  {
    MEMORY[0x1BA9BFB70](v25, 0x1000C8000313F17);
    *((void *)this + 47) = 0;
  }
  uint64_t v26 = *((void *)this + 42);
  if (v26)
  {
    MEMORY[0x1BA9BFB70](v26, 0x1000C8000313F17);
    *((void *)this + 42) = 0;
  }
  uint64_t v27 = *((void *)this + 43);
  if (v27)
  {
    MEMORY[0x1BA9BFB70](v27, 0x1000C8000313F17);
    *((void *)this + 43) = 0;
  }
  uint64_t v28 = *((void *)this + 48);
  if (v28)
  {
    MEMORY[0x1BA9BFB70](v28, 0x1000C8000313F17);
    *((void *)this + 48) = 0;
  }
  uint64_t result = *((void *)this + 49);
  if (result)
  {
    uint64_t result = MEMORY[0x1BA9BFB70](result, 0x1000C8000313F17);
    *((void *)this + 49) = 0;
  }
  return result;
}

soKMeansClassifier *soKMeansClassifier::Init(soKMeansClassifier *this, void *a2, unint64_t *a3, unint64_t a4, int a5)
{
  if (*((void *)this + 13) * *((void *)this + 12) < (void)a3 * (void)a2
    || *((unsigned __int8 *)this + 16) != a5)
  {
    *((unsigned char *)this + 24) = 1;
    *((void *)this + 12) = ((unint64_t)a2 + 31) & 0xFFFFFFFFFFFFFFE0;
    *((void *)this + 13) = ((unint64_t)a3 + 31) & 0xFFFFFFFFFFFFFFE0;
  }
  if (*((void *)this + 20) < a4 || *((unsigned __int8 *)this + 16) != a5) {
    *((unsigned char *)this + 25) = 1;
  }
  *((void *)this + 10) = a2;
  *((void *)this + 11) = a3;
  *((void *)this + 14) = (void)a3 * (void)a2;
  *((void *)this + 20) = a4;
  *((unsigned char *)this + 16) = a5;
  soKMeansClassifier::AllocateBuffers((uint64_t)this, a2, a3);

  return soKMeansClassifier::AllocateStats(this);
}

uint64_t soKMeansClassifier::AllocateBuffers(uint64_t this, void *a2, unint64_t *a3)
{
  if (*(unsigned char *)(this + 24))
  {
    uint64_t v3 = this;
    uint64_t v4 = *(HGMemory **)(this + 152);
    if (v4)
    {
      HGMemory::release(v4, a2);
      *(void *)(v3 + 152) = 0;
    }
    uint64_t v5 = *(HGMemory **)(v3 + 48);
    if (v5)
    {
      HGMemory::release(v5, a2);
      *(void *)(v3 + 48) = 0;
    }
    uint64_t v6 = *(HGMemory **)(v3 + 400);
    if (v6)
    {
      HGMemory::release(v6, a2);
      *(void *)(v3 + 400) = 0;
    }
    uint64_t v7 = *(HGMemory **)(v3 + 56);
    if (v7)
    {
      HGMemory::release(v7, a2);
      *(void *)(v3 + 56) = 0;
    }
    uint64_t v8 = *(HGMemory **)(v3 + 64);
    if (v8)
    {
      HGMemory::release(v8, a2);
      *(void *)(v3 + 64) = 0;
    }
    *(void *)(v3 + 152) = HGMemory::allocate((HGMemory *)(16 * *(void *)(v3 + 96) * *(void *)(v3 + 104)), 0, a3);
    *(void *)(v3 + 56) = HGMemory::allocate((HGMemory *)(*(void *)(v3 + 104) * *(void *)(v3 + 96)), 0, v9);
    this = HGMemory::allocate((HGMemory *)(12 * *(void *)(v3 + 96) * *(void *)(v3 + 104)), 0, v10);
    *(void *)(v3 + 400) = this;
    if (*(unsigned char *)(v3 + 16))
    {
      *(void *)(v3 + 48) = HGMemory::allocate((HGMemory *)(*(void *)(v3 + 104) * *(void *)(v3 + 96)), 0, v11);
      this = HGMemory::allocate((HGMemory *)(*(void *)(v3 + 104) * *(void *)(v3 + 96)), 0, v12);
      *(void *)(v3 + 64) = this;
    }
    *(unsigned char *)(v3 + 24) = 0;
  }
  return this;
}

soKMeansClassifier *soKMeansClassifier::AllocateStats(soKMeansClassifier *this)
{
  if (*((unsigned char *)this + 25))
  {
    soKMeansClassifier::DeleteStats(this);
    operator new[]();
  }
  return this;
}

void *soKMeansClassifier::LoadBuffer(void *this, unsigned __int8 *a2, uint64_t a3, double a4, double a5, __n128 a6)
{
  this[5] = a2;
  this[15] = a3;
  unint64_t v6 = this[10];
  if (v6 * this[11])
  {
    unint64_t v7 = 0;
    int8x16_t v8 = (int8x16_t)vdupq_n_s32(0x4B400000u);
    float32x4_t v9 = (float32x4_t)vdupq_n_s32(0xCB400000);
    do
    {
      a6.n128_u32[0] = *(_DWORD *)(this[5] + this[15] * (v7 / v6) + 4 * (v7 % v6));
      a6 = (__n128)vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)a6.n128_u64[0])), v8), v9);
      *(__n128 *)(this[19] + 16 * v7++) = a6;
      unint64_t v6 = this[10];
    }
    while (v6 * this[11] > v7);
  }
  return this;
}

void *soKMeansClassifier::LoadMask(void *result, uint64_t a2, uint64_t a3, int *a4)
{
  *((_DWORD *)result + 5) = 0;
  if (*((unsigned char *)result + 16))
  {
    uint64_t v5 = result;
    if (*((void *)result + 11))
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      unint64_t v10 = 0;
      size_t v11 = *((void *)result + 10);
      int64x2_t v98 = vdupq_n_s64(1uLL);
      while (1)
      {
        uint64_t result = memcpy((void *)(v5[6] + v8 * v11), (const void *)(a2 + v8 * a3), v11);
        unint64_t v12 = v5[10];
        if (v12)
        {
          uint64_t v13 = v5[6];
          if (v12 < 8)
          {
            unint64_t v14 = 0;
LABEL_18:
            int32x4_t v91 = (unsigned __int8 *)(v13 + v14 + v12 * v8);
            unint64_t v92 = v12 - v14;
            do
            {
              int v94 = *v91++;
              int v93 = v94;
              if (v94 == 255) {
                ++v10;
              }
              if (!v93) {
                ++v9;
              }
              --v92;
            }
            while (v92);
            goto LABEL_4;
          }
          v15.i64[0] = -1;
          v15.i64[1] = -1;
          if (v12 >= 0x10)
          {
            unint64_t v14 = v12 & 0xFFFFFFFFFFFFFFF0;
            int64x2_t v42 = 0uLL;
            int64x2_t v43 = (int64x2_t)v9;
            int64x2_t v44 = (int64x2_t)v10;
            int8x16_t v45 = (int8x16_t *)(v13 + v12 * v8);
            unint64_t v46 = v12 & 0xFFFFFFFFFFFFFFF0;
            int64x2_t v47 = 0uLL;
            int64x2_t v48 = 0uLL;
            int64x2_t v49 = 0uLL;
            int64x2_t v50 = 0uLL;
            int64x2_t v51 = 0uLL;
            int64x2_t v52 = 0uLL;
            int64x2_t v53 = 0uLL;
            int64x2_t v54 = 0uLL;
            int64x2_t v55 = 0uLL;
            int64x2_t v56 = 0uLL;
            int64x2_t v57 = 0uLL;
            int64x2_t v58 = 0uLL;
            int64x2_t v59 = 0uLL;
            do
            {
              int8x16_t v60 = *v45++;
              uint8x16_t v61 = (uint8x16_t)vceqq_s8(v60, v15);
              uint16x8_t v62 = vmovl_u8(*(uint8x8_t *)v61.i8);
              uint32x4_t v63 = vmovl_u16(*(uint16x4_t *)v62.i8);
              int8x16_t v64 = (int8x16_t)vdupq_n_s64(1uLL);
              v65.i64[0] = v63.u32[0];
              v65.i64[1] = v63.u32[1];
              int64x2_t v66 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v63.u32[2];
              v65.i64[1] = v63.u32[3];
              int64x2_t v67 = (int64x2_t)vandq_s8(v65, v64);
              uint32x4_t v68 = vmovl_high_u16(v62);
              v65.i64[0] = v68.u32[0];
              v65.i64[1] = v68.u32[1];
              int64x2_t v69 = (int64x2_t)vandq_s8(v65, v64);
              uint16x8_t v70 = vmovl_high_u8(v61);
              uint32x4_t v71 = vmovl_u16(*(uint16x4_t *)v70.i8);
              v65.i64[0] = v71.u32[0];
              v65.i64[1] = v71.u32[1];
              int64x2_t v72 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v68.u32[2];
              v65.i64[1] = v68.u32[3];
              int64x2_t v73 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v71.u32[2];
              v65.i64[1] = v71.u32[3];
              int64x2_t v74 = (int64x2_t)vandq_s8(v65, v64);
              uint32x4_t v75 = vmovl_high_u16(v70);
              v65.i64[0] = v75.u32[0];
              v65.i64[1] = v75.u32[1];
              int64x2_t v76 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v75.u32[2];
              v65.i64[1] = v75.u32[3];
              int64x2_t v59 = vaddq_s64(v59, (int64x2_t)vandq_s8(v65, v64));
              int64x2_t v58 = vaddq_s64(v58, v76);
              int64x2_t v57 = vaddq_s64(v57, v74);
              int64x2_t v55 = vaddq_s64(v55, v73);
              int64x2_t v56 = vaddq_s64(v56, v72);
              int64x2_t v54 = vaddq_s64(v54, v69);
              int64x2_t v53 = vaddq_s64(v53, v67);
              int64x2_t v44 = vaddq_s64(v44, v66);
              uint8x16_t v77 = (uint8x16_t)vceqzq_s8(v60);
              uint16x8_t v78 = vmovl_u8(*(uint8x8_t *)v77.i8);
              uint32x4_t v79 = vmovl_u16(*(uint16x4_t *)v78.i8);
              v65.i64[0] = v79.u32[0];
              v65.i64[1] = v79.u32[1];
              int64x2_t v80 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v79.u32[2];
              v65.i64[1] = v79.u32[3];
              int64x2_t v81 = (int64x2_t)vandq_s8(v65, v64);
              uint32x4_t v82 = vmovl_high_u16(v78);
              v65.i64[0] = v82.u32[0];
              v65.i64[1] = v82.u32[1];
              int64x2_t v83 = (int64x2_t)vandq_s8(v65, v64);
              uint16x8_t v84 = vmovl_high_u8(v77);
              uint32x4_t v85 = vmovl_u16(*(uint16x4_t *)v84.i8);
              v65.i64[0] = v85.u32[0];
              v65.i64[1] = v85.u32[1];
              int64x2_t v86 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v82.u32[2];
              v65.i64[1] = v82.u32[3];
              int64x2_t v87 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v85.u32[2];
              v65.i64[1] = v85.u32[3];
              int64x2_t v88 = (int64x2_t)vandq_s8(v65, v64);
              uint32x4_t v89 = vmovl_high_u16(v84);
              v65.i64[0] = v89.u32[0];
              v65.i64[1] = v89.u32[1];
              int64x2_t v90 = (int64x2_t)vandq_s8(v65, v64);
              v65.i64[0] = v89.u32[2];
              v65.i64[1] = v89.u32[3];
              int64x2_t v52 = vaddq_s64(v52, (int64x2_t)vandq_s8(v65, v64));
              int64x2_t v51 = vaddq_s64(v51, v90);
              int64x2_t v50 = vaddq_s64(v50, v88);
              int64x2_t v48 = vaddq_s64(v48, v87);
              int64x2_t v49 = vaddq_s64(v49, v86);
              int64x2_t v47 = vaddq_s64(v47, v83);
              int64x2_t v42 = vaddq_s64(v42, v81);
              int64x2_t v43 = vaddq_s64(v43, v80);
              v46 -= 16;
            }
            while (v46);
            unint64_t v10 = vaddvq_s64(vaddq_s64(vaddq_s64(vaddq_s64(v44, v56), vaddq_s64(v54, v58)), vaddq_s64(vaddq_s64(v53, v57), vaddq_s64(v55, v59))));
            unint64_t v9 = vaddvq_s64(vaddq_s64(vaddq_s64(vaddq_s64(v43, v49), vaddq_s64(v47, v51)), vaddq_s64(vaddq_s64(v42, v50), vaddq_s64(v48, v52))));
            if (v12 == v14) {
              goto LABEL_4;
            }
            int8x16_t v16 = (int8x16_t)v98;
            if ((v12 & 8) == 0) {
              goto LABEL_18;
            }
          }
          else
          {
            unint64_t v14 = 0;
            int8x16_t v16 = (int8x16_t)v98;
          }
          unint64_t v17 = v14;
          unint64_t v14 = v12 & 0xFFFFFFFFFFFFFFF8;
          int64x2_t v18 = (int64x2_t)v9;
          int64x2_t v19 = 0uLL;
          int64x2_t v20 = (int64x2_t)v10;
          uint64_t v21 = (int8x8_t *)(v13 + v17 + v12 * v8);
          unint64_t v22 = v17 - (v12 & 0xFFFFFFFFFFFFFFF8);
          int64x2_t v23 = 0uLL;
          int64x2_t v24 = 0uLL;
          int64x2_t v25 = 0uLL;
          int64x2_t v26 = 0uLL;
          int64x2_t v27 = 0uLL;
          do
          {
            int8x8_t v28 = *v21++;
            uint16x8_t v29 = vmovl_u8((uint8x8_t)vceq_s8(v28, (int8x8_t)-1));
            uint32x4_t v30 = vmovl_u16(*(uint16x4_t *)v29.i8);
            v31.i64[0] = v30.u32[0];
            v31.i64[1] = v30.u32[1];
            int64x2_t v32 = (int64x2_t)vandq_s8(v31, v16);
            v31.i64[0] = v30.u32[2];
            v31.i64[1] = v30.u32[3];
            int64x2_t v33 = (int64x2_t)vandq_s8(v31, v16);
            uint32x4_t v34 = vmovl_high_u16(v29);
            v31.i64[0] = v34.u32[0];
            v31.i64[1] = v34.u32[1];
            int64x2_t v35 = (int64x2_t)vandq_s8(v31, v16);
            v31.i64[0] = v34.u32[2];
            v31.i64[1] = v34.u32[3];
            int64x2_t v27 = vaddq_s64(v27, (int64x2_t)vandq_s8(v31, v16));
            int64x2_t v26 = vaddq_s64(v26, v35);
            int64x2_t v25 = vaddq_s64(v25, v33);
            int64x2_t v20 = vaddq_s64(v20, v32);
            uint16x8_t v36 = vmovl_u8((uint8x8_t)vceqz_s8(v28));
            uint32x4_t v37 = vmovl_u16(*(uint16x4_t *)v36.i8);
            v31.i64[0] = v37.u32[0];
            v31.i64[1] = v37.u32[1];
            int64x2_t v38 = (int64x2_t)vandq_s8(v31, v16);
            v31.i64[0] = v37.u32[2];
            v31.i64[1] = v37.u32[3];
            int64x2_t v39 = (int64x2_t)vandq_s8(v31, v16);
            uint32x4_t v40 = vmovl_high_u16(v36);
            v31.i64[0] = v40.u32[0];
            v31.i64[1] = v40.u32[1];
            int64x2_t v41 = (int64x2_t)vandq_s8(v31, v16);
            v31.i64[0] = v40.u32[2];
            v31.i64[1] = v40.u32[3];
            int64x2_t v24 = vaddq_s64(v24, (int64x2_t)vandq_s8(v31, v16));
            int64x2_t v23 = vaddq_s64(v23, v41);
            int64x2_t v19 = vaddq_s64(v19, v39);
            int64x2_t v18 = vaddq_s64(v18, v38);
            v22 += 8;
          }
          while (v22);
          unint64_t v10 = vaddvq_s64(vaddq_s64(vaddq_s64(v20, v26), vaddq_s64(v25, v27)));
          unint64_t v9 = vaddvq_s64(vaddq_s64(vaddq_s64(v18, v23), vaddq_s64(v19, v24)));
          if (v12 != v14) {
            goto LABEL_18;
          }
        }
LABEL_4:
        if (v5[11] <= (unint64_t)++v8) {
          goto LABEL_26;
        }
      }
    }
    unint64_t v10 = 0;
    unint64_t v9 = 0;
LABEL_26:
    unint64_t v95 = 10 * v5[20];
    if (v10 < v95) {
      int v96 = 1;
    }
    else {
      int v96 = 3;
    }
    if (v9 >= v95) {
      int v97 = v96;
    }
    else {
      int v97 = 2;
    }
    *((_DWORD *)v5 + 5) = v97;
    *a4 = v97;
  }
  return result;
}

uint64_t GenLLHMap(void *a1)
{
  unint64_t v1 = a1[1];
  unint64_t v69 = a1[2];
  unint64_t v2 = v69 - v1;
  if (v69 > v1)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = *(void *)(*a1 + 80);
    if (v4)
    {
      uint64_t v68 = *(void *)(v3 + 72);
      uint64_t v70 = *(void *)(v3 + 128);
      uint64_t v77 = *(void *)(*a1 + 80);
      if (*(unsigned char *)(v3 + 26))
      {
        uint64_t v67 = *(void *)(v3 + 48);
        __asm { FMOV            V9.2S, #-1.0 }
        while (1)
        {
          uint64_t v10 = 0;
          uint64_t v11 = v68 + v70 * v1;
          unint64_t v71 = v1;
          uint64_t v73 = v4 * v1;
          uint64_t v12 = v67 + v4 * v1;
          uint64_t v75 = v12;
          do
          {
            int v14 = *(unsigned __int8 *)(v12 + v10);
            *(void *)uint64_t v11 = _D9;
            if (v14 == 255)
            {
              *(_DWORD *)uint64_t v11 = *(_DWORD *)(v3 + 32);
              float v13 = *(float *)(v3 + 28);
LABEL_8:
              *(float *)(v11 + 4) = v13;
              goto LABEL_9;
            }
            if (!v14)
            {
              *(_DWORD *)uint64_t v11 = *(_DWORD *)(v3 + 28);
              float v13 = *(float *)(v3 + 32);
              goto LABEL_8;
            }
            if (*(unsigned char *)(v3 + 16))
            {
              uint64_t v15 = *(void *)(v3 + 160);
              if (v15)
              {
                uint64_t v16 = 0;
                uint64_t v17 = 0;
                float32x4_t v78 = *(float32x4_t *)(*(void *)(v3 + 152) + 16 * v73 + 16 * v10);
                uint64_t v18 = *(void *)(v3 + 352);
                uint64_t v19 = *(void *)(v3 + 360);
                double v20 = 0.0;
                double v21 = 0.0;
                do
                {
                  unint64_t v22 = *(void *)(v18 + 8 * v17);
                  double v23 = 0.0;
                  if (v22 >= 0xA)
                  {
                    float32x4_t v24 = vsubq_f32(v78, *(float32x4_t *)(*(void *)(v3 + 168) + 16 * v17));
                    float64x2_t v25 = vcvt_hight_f64_f32(v24);
                    float64x2_t v26 = vcvtq_f64_f32(*(float32x2_t *)v24.f32);
                    int64x2_t v27 = (float64x2_t *)(*(void *)(v3 + 184) + v16);
                    double v23 = *(double *)(*(void *)(v3 + 216) + 8 * v17)
                        * exp((vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v27[1], v26), v27[3], v26, 1), v25, v27[5]), v25).f64[0]+ vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v27, v26.f64[0]), v27[2], v26, 1), v27[4], v25.f64[0]), v26)))* -0.5);
                  }
                  unint64_t v28 = *(void *)(v19 + 8 * v17);
                  double v29 = 0.0;
                  if (v28 >= 0xA)
                  {
                    float32x4_t v30 = vsubq_f32(v78, *(float32x4_t *)(*(void *)(v3 + 176) + 16 * v17));
                    float64x2_t v31 = vcvt_hight_f64_f32(v30);
                    float64x2_t v32 = vcvtq_f64_f32(*(float32x2_t *)v30.f32);
                    int64x2_t v33 = (float64x2_t *)(*(void *)(v3 + 192) + v16);
                    double v29 = *(double *)(*(void *)(v3 + 224) + 8 * v17)
                        * exp((vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v33[1], v32), v33[3], v32, 1), v31, v33[5]), v31).f64[0]+ vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v33, v32.f64[0]), v33[2], v32, 1), v33[4], v31.f64[0]), v32)))* -0.5);
                  }
                  double v21 = v21 + v23 * (double)v22;
                  double v20 = v20 + v29 * (double)v28;
                  ++v17;
                  v16 += 96;
                }
                while (v15 != v17);
              }
              else
              {
                double v21 = 0.0;
                double v20 = 0.0;
              }
              long double v34 = v20 / (double)*(unint64_t *)(v3 + 144);
              float v35 = log(v21 / (double)*(unint64_t *)(v3 + 136));
              *(float *)uint64_t v11 = -v35;
              float v36 = log(v34);
              float v13 = -v36;
              uint64_t v12 = v75;
              uint64_t v4 = v77;
              goto LABEL_8;
            }
LABEL_9:
            v11 += 8;
            ++v10;
          }
          while (v10 != v4);
          unint64_t v1 = v71 + 1;
          if (v71 + 1 == v69) {
            goto LABEL_38;
          }
        }
      }
      if (*(unsigned char *)(v3 + 16))
      {
        uint64_t v37 = *(void *)(v3 + 160);
        uint64_t v74 = *(void *)(v3 + 152);
        double v38 = (double)*(unint64_t *)(v3 + 136);
        double v39 = (double)*(unint64_t *)(v3 + 144);
        __asm { FMOV            V11.2S, #-1.0 }
        do
        {
          uint64_t v41 = 0;
          uint64_t v42 = v68 + v70 * v1;
          unint64_t v72 = v1;
          uint64_t v76 = v74 + 16 * v4 * v1;
          do
          {
            *(void *)uint64_t v42 = _D11;
            if (v37)
            {
              uint64_t v47 = 0;
              uint64_t v48 = 0;
              float32x4_t v79 = *(float32x4_t *)(v76 + 16 * v41);
              double v44 = 0.0;
              double v43 = 0.0;
              uint64_t v50 = *(void *)(v3 + 352);
              uint64_t v49 = *(void *)(v3 + 360);
              do
              {
                unint64_t v51 = *(void *)(v50 + 8 * v48);
                double v52 = 0.0;
                if (v51 >= 0xA)
                {
                  float32x4_t v53 = vsubq_f32(v79, *(float32x4_t *)(*(void *)(v3 + 168) + 16 * v48));
                  float64x2_t v54 = vcvt_hight_f64_f32(v53);
                  float64x2_t v55 = vcvtq_f64_f32(*(float32x2_t *)v53.f32);
                  int64x2_t v56 = (float64x2_t *)(*(void *)(v3 + 184) + v47);
                  double v52 = *(double *)(*(void *)(v3 + 216) + 8 * v48)
                      * exp((vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v56[1], v55), v56[3], v55, 1), v54, v56[5]), v54).f64[0]+ vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v56, v55.f64[0]), v56[2], v55, 1), v56[4], v54.f64[0]), v55)))* -0.5);
                }
                unint64_t v57 = *(void *)(v49 + 8 * v48);
                double v58 = 0.0;
                if (v57 >= 0xA)
                {
                  float32x4_t v59 = vsubq_f32(v79, *(float32x4_t *)(*(void *)(v3 + 176) + 16 * v48));
                  float64x2_t v60 = vcvt_hight_f64_f32(v59);
                  float64x2_t v61 = vcvtq_f64_f32(*(float32x2_t *)v59.f32);
                  uint16x8_t v62 = (float64x2_t *)(*(void *)(v3 + 192) + v47);
                  double v58 = *(double *)(*(void *)(v3 + 224) + 8 * v48)
                      * exp((vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v62[1], v61), v62[3], v61, 1), v60, v62[5]), v60).f64[0]+ vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v62, v61.f64[0]), v62[2], v61, 1), v62[4], v60.f64[0]), v61)))* -0.5);
                }
                double v43 = v43 + v52 * (double)v51;
                double v44 = v44 + v58 * (double)v57;
                ++v48;
                v47 += 96;
              }
              while (v37 != v48);
            }
            else
            {
              double v43 = 0.0;
              double v44 = 0.0;
            }
            float v45 = log(v43 / v38);
            *(float *)uint64_t v42 = -v45;
            float v46 = log(v44 / v39);
            *(float *)(v42 + 4) = -v46;
            v42 += 8;
            ++v41;
            uint64_t v4 = v77;
          }
          while (v41 != v77);
          unint64_t v1 = v72 + 1;
        }
        while (v72 + 1 != v69);
      }
      else
      {
        size_t v63 = 8 * v4;
        int8x16_t v64 = (char *)(v68 + v1 * v70);
        do
        {
          memset_pattern16(v64, &unk_1B8347FF0, v63);
          v64 += v70;
          --v2;
        }
        while (v2);
      }
    }
  }
LABEL_38:
  MEMORY[0x1BA9BFBA0](a1, 0x1020C4024DAA5DELL);
  return 0;
}

uint64_t soKMeansClassifier::GenLikelihoodMap(soKMeansClassifier *this, float *a2, uint64_t a3, char a4, float a5, float a6)
{
  if (*((unsigned char *)this + 16))
  {
    *((unsigned char *)this + 26) = a4;
    *((float *)this + 7) = a5;
    *((float *)this + 8) = a6;
    *((void *)this + 9) = a2;
    *((void *)this + 16) = a3;
    if (*((void *)this + 1) >= 2uLL) {
      operator new[]();
    }
    operator new();
  }
  return 0xFFFFFFFFLL;
}

double soKMeansClassifier::InitClusterMeans(soKMeansClassifier *this, __n128 inited)
{
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    uint64_t v4 = *((void *)this + 11);
    if (v4)
    {
      int v5 = v4 * v2 - 1;
      if (*((unsigned char *)this + 16))
      {
        do
        {
          int v11 = 0;
          int v12 = v5;
          int v6 = std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>((uint64_t)&v11, *(void *)this, &v11);
        }
        while (*(unsigned char *)(*((void *)this + 6) + v6));
        **((void **)this + 48) = v6;
        do
        {
          int v11 = 0;
          int v12 = v5;
          int v7 = std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>((uint64_t)&v11, *(void *)this, &v11);
        }
        while (*(unsigned __int8 *)(*((void *)this + 6) + v7) != 255);
        **((void **)this + 49) = v7;
        *(_OWORD *)*((void *)this + 22) = *(_OWORD *)(*((void *)this + 19) + 16 * v7);
        __n128 v8 = *(__n128 *)(*((void *)this + 19) + 16 * **((void **)this + 48));
        *(__n128 *)*((void *)this + 21) = v8;
        if (*((_DWORD *)this + 9)) {
LABEL_8:
        }
          soKMeansClassifier::InitClusterMeans_PP(this);
      }
      else
      {
        int v11 = 0;
        int v12 = v4 * v2 - 1;
        int v9 = std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>((uint64_t)&v11, *(void *)this, &v11);
        **((void **)this + 48) = v9;
        __n128 v8 = *(__n128 *)(*((void *)this + 19) + 16 * v9);
        *(__n128 *)*((void *)this + 21) = v8;
        if (*((_DWORD *)this + 9)) {
          goto LABEL_8;
        }
      }
      inited = soKMeansClassifier::InitClusterMeans_Random(this, 0, v8);
      if (*((unsigned char *)this + 16)) {
        inited.n128_u64[0] = soKMeansClassifier::InitClusterMeans_Random(this, 1, inited).n128_u64[0];
      }
    }
  }
  return inited.n128_f64[0];
}

__n128 soKMeansClassifier::InitClusterMeans_Random(soKMeansClassifier *this, int a2, __n128 result)
{
  uint64_t v3 = *((void *)this + 10);
  if (v3)
  {
    uint64_t v4 = *((void *)this + 11);
    if (v4)
    {
      if (a2) {
        int v5 = 255;
      }
      else {
        int v5 = 0;
      }
      uint64_t v6 = 392;
      if (!a2) {
        uint64_t v6 = 384;
      }
      if (*((void *)this + 20) >= 2uLL)
      {
        unsigned int v7 = v4 * v3;
        uint64_t v8 = *(void *)((char *)this + v6);
        uint64_t v9 = __clz(v7);
        uint64_t v10 = 31;
        if (((v7 << v9) & 0x7FFFFFFF) != 0) {
          uint64_t v10 = 32;
        }
        unint64_t v11 = v10 - v9;
        unint64_t v12 = v11 >> 5;
        if ((v11 & 0x1F) != 0) {
          ++v12;
        }
        if (*((unsigned char *)this + 16))
        {
          uint64_t v13 = *(void *)this;
          int v14 = (unsigned __int8 *)*((void *)this + 6);
          unint64_t v15 = 1;
          while (1)
          {
LABEL_16:
            if (v7 == 1)
            {
              if (v5 != *v14)
              {
                while (1)
                  ;
              }
              uint64_t v16 = 0;
            }
            else if (v7)
            {
              if (v12 <= v11) {
                unsigned int v17 = 0xFFFFFFFF >> -(v11 / v12);
              }
              else {
                unsigned int v17 = 0;
              }
              unint64_t v18 = *(void *)(v13 + 2496);
              do
              {
                do
                {
                  uint64_t v19 = 4 * v18;
                  unint64_t v20 = v18 + 397;
                  unint64_t v18 = (v18 + 1) % 0x270;
                  unsigned int v21 = *(_DWORD *)(v13 + 4 * (v20 % 0x270)) ^ ((*(_DWORD *)(v13 + 4 * v18) & 0x7FFFFFFE | *(_DWORD *)(v13 + v19) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v13 + 4 * v18) << 31) >> 31) & 0x9908B0DF;
                  *(_DWORD *)(v13 + v19) = v21;
                  unsigned int v22 = ((v21 ^ (v21 >> 11)) << 7) & 0x9D2C5680 ^ v21 ^ (v21 >> 11);
                  LODWORD(v16) = ((v22 << 15) & 0xEFC60000 ^ v22 ^ (((v22 << 15) & 0xEFC60000 ^ v22) >> 18)) & v17;
                }
                while (v16 >= v7);
                *(void *)(v13 + 2496) = v18;
                uint64_t v16 = (int)v16;
              }
              while (v5 != v14[(int)v16]);
            }
            else
            {
              unint64_t v23 = *(void *)(v13 + 2496);
              do
              {
                unint64_t v24 = (v23 + 1) % 0x270;
                unsigned int v25 = *(_DWORD *)(v13 + 4 * ((v23 + 397) % 0x270)) ^ ((*(_DWORD *)(v13 + 4 * v24) & 0x7FFFFFFE | *(_DWORD *)(v13 + 4 * v23) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v13 + 4 * v24) << 31) >> 31) & 0x9908B0DF;
                *(_DWORD *)(v13 + 4 * v23) = v25;
                *(void *)(v13 + 2496) = v24;
                unsigned int v26 = ((v25 ^ (v25 >> 11)) << 7) & 0x9D2C5680 ^ v25 ^ (v25 >> 11);
                uint64_t v16 = (int)((v26 << 15) & 0xEFC60000 ^ v26 ^ (((v26 << 15) & 0xEFC60000 ^ v26) >> 18));
                unint64_t v23 = v24;
              }
              while (v5 != v14[v16]);
            }
            unint64_t v27 = 0;
            uint64_t v28 = *((void *)this + 19);
            uint64_t v29 = v28 + 16 * v15;
            result.n128_u32[0] = *(_DWORD *)v29;
            float v30 = *(float *)(v29 + 4);
            float v31 = *(float *)(v29 + 8);
            char v32 = 1;
            do
            {
              uint64_t v33 = *(void *)(v8 + 8 * v27);
              if (v33 == v16) {
                goto LABEL_16;
              }
              long double v34 = (float *)(v28 + 16 * v33);
              BOOL v35 = result.n128_f32[0] == *v34;
              if (v30 != v34[1]) {
                BOOL v35 = 0;
              }
              int v36 = v35 && v31 == v34[2];
              if (v36) {
                char v32 = 0;
              }
              if (v36) {
                break;
              }
              ++v27;
            }
            while (v27 < v15);
            if (v32)
            {
              *(void *)(v8 + 8 * v15++) = v16;
              unint64_t v37 = *((void *)this + 20);
              if (v37 <= v15) {
                break;
              }
            }
          }
        }
        else if (v7 == 1)
        {
          unint64_t v38 = 1;
          do
          {
            *(void *)(v8 + 8 * v38++) = 0;
            unint64_t v37 = *((void *)this + 20);
          }
          while (v37 > v38);
        }
        else
        {
          uint64_t v40 = *(void *)this;
          uint64_t v41 = *((void *)this + 19);
          unint64_t v42 = 1;
          do
          {
            uint64_t v43 = v41 + 16 * v42;
            do
            {
LABEL_54:
              if (v7)
              {
                unsigned int v44 = 0xFFFFFFFF >> -(v11 / v12);
                if (v12 > v11) {
                  unsigned int v44 = 0;
                }
                unint64_t v45 = *(void *)(v40 + 2496);
                do
                {
                  uint64_t v46 = 4 * v45;
                  unint64_t v47 = v45 + 397;
                  unint64_t v45 = (v45 + 1) % 0x270;
                  unsigned int v48 = *(_DWORD *)(v40 + 4 * (v47 % 0x270)) ^ ((*(_DWORD *)(v40 + 4 * v45) & 0x7FFFFFFE | *(_DWORD *)(v40 + v46) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v40 + 4 * v45) << 31) >> 31) & 0x9908B0DF;
                  *(_DWORD *)(v40 + v46) = v48;
                  unsigned int v49 = ((v48 ^ (v48 >> 11)) << 7) & 0x9D2C5680 ^ v48 ^ (v48 >> 11);
                  unsigned int v50 = ((v49 << 15) & 0xEFC60000 ^ v49 ^ (((v49 << 15) & 0xEFC60000 ^ v49) >> 18)) & v44;
                }
                while (v50 >= v7);
                *(void *)(v40 + 2496) = v45;
              }
              else
              {
                uint64_t v51 = *(void *)(v40 + 2496);
                unint64_t v52 = (v51 + 1) % 0x270uLL;
                uint64_t v53 = 4 * v51;
                LODWORD(v51) = *(_DWORD *)(v40 + 4 * ((v51 + 397) % 0x270uLL)) ^ ((*(_DWORD *)(v40 + 4 * v52) & 0x7FFFFFFE | *(_DWORD *)(v40 + 4 * v51) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v40 + 4 * v52) << 31) >> 31) & 0x9908B0DF;
                *(_DWORD *)(v40 + v53) = v51;
                *(void *)(v40 + 2496) = v52;
                LODWORD(v51) = ((v51 ^ (v51 >> 11)) << 7) & 0x9D2C5680 ^ v51 ^ (v51 >> 11);
                unsigned int v50 = (v51 << 15) & 0xEFC60000 ^ v51 ^ (((v51 << 15) & 0xEFC60000 ^ v51) >> 18);
              }
              unint64_t v54 = 0;
              uint64_t v55 = (int)v50;
              result.n128_u32[0] = *(_DWORD *)v43;
              char v56 = 1;
              do
              {
                uint64_t v57 = *(void *)(v8 + 8 * v54);
                if (v57 == v55) {
                  goto LABEL_54;
                }
                double v58 = (float *)(v41 + 16 * v57);
                BOOL v59 = result.n128_f32[0] == *v58;
                if (*(float *)(v43 + 4) != v58[1]) {
                  BOOL v59 = 0;
                }
                int v60 = v59 && *(float *)(v43 + 8) == v58[2];
                if (v60) {
                  char v56 = 0;
                }
                if (v60) {
                  break;
                }
                ++v54;
              }
              while (v54 < v42);
            }
            while ((v56 & 1) == 0);
            *(void *)(v8 + 8 * v42++) = v55;
            unint64_t v37 = *((void *)this + 20);
          }
          while (v37 > v42);
        }
        if (v37 >= 2)
        {
          unint64_t v39 = 1;
          if (a2)
          {
            do
            {
              uint64_t result = *(__n128 *)(*((void *)this + 19) + 16 * *(void *)(v8 + 8 * v39));
              *(__n128 *)(*((void *)this + 22) + 16 * v39++) = result;
            }
            while (*((void *)this + 20) > v39);
          }
          else
          {
            do
            {
              uint64_t result = *(__n128 *)(*((void *)this + 19) + 16 * *(void *)(v8 + 8 * v39));
              *(__n128 *)(*((void *)this + 21) + 16 * v39++) = result;
            }
            while (*((void *)this + 20) > v39);
          }
        }
      }
    }
  }
  return result;
}

void soKMeansClassifier::InitClusterMeans_PP(soKMeansClassifier *this)
{
  if (*((void *)this + 1) >= 2uLL) {
    operator new[]();
  }
  operator new();
}

uint64_t ComputeD2(void *a1, double a2, double a3, double a4, double a5, int32x4_t a6, float32x4_t a7)
{
  unsigned int v7 = (void *)*a1;
  if (*(unsigned char *)(*a1 + 16))
  {
    uint64_t v8 = v7[14];
    uint64_t v9 = a1[4] * v8;
    uint64_t v10 = a1[7];
    uint64_t v11 = a1[6] * v8;
    uint64_t v12 = v7[50];
    if (v10 == 1)
    {
      unint64_t v14 = a1[1];
      unint64_t v13 = a1[2];
      double v15 = 0.0;
      double v16 = 0.0;
      BOOL v17 = v13 > v14;
      unint64_t v18 = v13 - v14;
      if (v17)
      {
        int8x16_t v19 = *(int8x16_t *)v7[22];
        int8x16_t v20 = *(int8x16_t *)v7[21];
        uint64_t v21 = v12 + 4 * v14;
        unsigned int v22 = (float32x4_t *)(v7[19] + 16 * v14);
        unint64_t v23 = (unsigned __int8 *)(v7[6] + v14);
        do
        {
          unsigned __int32 v25 = *v23++;
          unsigned __int32 v24 = v25;
          if (v25 == 255 || v24 == 0)
          {
            a6.i32[0] = 0;
            a7.i32[0] = v24;
            float32x4_t v27 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)a7, a6), 0), v20, v19);
            BOOL v28 = v24 == 0;
            if (v24) {
              uint64_t v29 = v11;
            }
            else {
              uint64_t v29 = v9;
            }
            float32x4_t v30 = vsubq_f32(*v22, v27);
            float32x4_t v31 = vmulq_f32(v30, v30);
            a7 = vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1));
            a6 = (int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), a7);
            *(_DWORD *)(v21 + 4 * v29) = a6.i32[0];
            *(double *)a6.i64 = *(float *)a6.i32;
            a7.i32[1] = 0x80000000;
            if (v28) {
              double v32 = -0.0;
            }
            else {
              double v32 = *(double *)a6.i64;
            }
            double v15 = v15 + v32;
            if (!v28) {
              *(double *)a6.i64 = -0.0;
            }
            double v16 = v16 + *(double *)a6.i64;
          }
          v21 += 4;
          ++v22;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      unint64_t v51 = a1[1];
      unint64_t v52 = a1[2];
      double v15 = 0.0;
      double v16 = 0.0;
      if (v51 < v52)
      {
        uint64_t v53 = v12 + 4 * v9;
        uint64_t v54 = v12 + 4 * v11;
        uint64_t v55 = a1[5] * v8;
        uint64_t v56 = v12 + 4 * a1[3] * v8;
        uint64_t v57 = v12 + 4 * v55;
        uint64_t v58 = 16 * v10 - 16;
        int8x16_t v59 = *(int8x16_t *)(v7[22] + v58);
        int8x16_t v60 = *(int8x16_t *)(v7[21] + v58);
        uint64_t v61 = v7[19];
        uint64_t v62 = v7[6];
        do
        {
          int v63 = *(unsigned __int8 *)(v62 + v51);
          if (v63 == 255 || v63 == 0)
          {
            a6.i32[0] = 0;
            a7.i32[0] = *(unsigned __int8 *)(v62 + v51);
            float32x4_t v65 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)a7, a6), 0), v60, v59);
            a7 = *(float32x4_t *)(v61 + 16 * v51);
            if (v63 == 255) {
              uint64_t v66 = v57;
            }
            else {
              uint64_t v66 = 0;
            }
            if (v63 == 255) {
              uint64_t v67 = v54;
            }
            else {
              uint64_t v67 = 0;
            }
            if (!*(unsigned char *)(v62 + v51))
            {
              uint64_t v66 = v56;
              uint64_t v67 = v53;
            }
            float32x4_t v68 = vsubq_f32(a7, v65);
            float32x4_t v69 = vmulq_f32(v68, v68);
            a6 = (int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 2), vaddq_f32(v69, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v69.f32, 1)));
            if (*(float *)a6.i32 >= *(float *)(v66 + 4 * v51)) {
              a6.i32[0] = *(_DWORD *)(v66 + 4 * v51);
            }
            *(_DWORD *)(v67 + 4 * v51) = a6.i32[0];
            *(double *)a6.i64 = *(float *)a6.i32;
            if (v63) {
              double v15 = v15 + *(double *)a6.i64;
            }
            else {
              double v16 = v16 + *(double *)a6.i64;
            }
          }
          ++v51;
        }
        while (v52 != v51);
      }
    }
    uint64_t v70 = 8 * a1[8];
    uint64_t v72 = v7[42];
    uint64_t v71 = v7[43];
    *(double *)(v72 + v70) = v16;
    *(double *)(v71 + v70) = v15;
  }
  else
  {
    uint64_t v33 = v7[14];
    uint64_t v34 = a1[3];
    uint64_t v35 = a1[4] * v33;
    uint64_t v36 = v7[42];
    uint64_t v38 = a1[7];
    uint64_t v37 = a1[8];
    *(void *)(v36 + 8 * v37) = 0;
    unint64_t v40 = a1[1];
    unint64_t v39 = a1[2];
    uint64_t v41 = v38 - 1;
    if (v41)
    {
      BOOL v17 = v39 > v40;
      unint64_t v74 = v39 - v40;
      if (v17)
      {
        uint64_t v75 = v33 * v34;
        uint64_t v76 = v7[19];
        uint64_t v77 = v7[21];
        uint64_t v78 = v7[50];
        float32x4_t v79 = (float *)(v78 + 4 * (v40 + v35));
        int64x2_t v80 = (__int32 *)(v78 + 4 * (v40 + v75));
        int64x2_t v81 = (float32x4_t *)(v76 + 16 * v40);
        double v82 = 0.0;
        do
        {
          float32x4_t v83 = *v81++;
          float32x4_t v84 = vsubq_f32(v83, *(float32x4_t *)(v77 + 16 * v41));
          float32x4_t v85 = vmulq_f32(v84, v84);
          float v86 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v85, 2), vaddq_f32(v85, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v85.f32, 1))).f32[0];
          v83.i32[0] = *v80++;
          float v87 = v83.f32[0];
          if (v86 >= v83.f32[0]) {
            float v86 = v87;
          }
          *v79++ = v86;
          double v82 = v82 + v86;
          *(double *)(v36 + 8 * v37) = v82;
          --v74;
        }
        while (v74);
      }
    }
    else
    {
      unint64_t v42 = v39 - v40;
      if (v39 > v40)
      {
        uint64_t v43 = v7[19];
        unsigned int v44 = (float32x4_t *)v7[21];
        unint64_t v45 = (_DWORD *)(v7[50] + 4 * (v40 + v35));
        uint64_t v46 = (float32x4_t *)(v43 + 16 * v40);
        double v47 = 0.0;
        do
        {
          float32x4_t v48 = *v46++;
          float32x4_t v49 = vsubq_f32(v48, *v44);
          float32x4_t v50 = vmulq_f32(v49, v49);
          v50.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).f32[0];
          *v45++ = v50.i32[0];
          double v47 = v47 + v50.f32[0];
          *(double *)(v36 + 8 * v37) = v47;
          --v42;
        }
        while (v42);
      }
    }
  }
  MEMORY[0x1BA9BFBA0]();
  return 0;
}

uint64_t FitToClusters(void *a1)
{
  v63[1] = *MEMORY[0x1E4F143B8];
  size_t v2 = 4 * *(void *)(*a1 + 160);
  uint64_t v3 = ((uint64_t (*)(void))MEMORY[0x1F4188790])();
  uint64_t v4 = (char *)v63 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v3);
  uint64_t v6 = (char *)v63 - v5;
  if (v7)
  {
    memset_pattern16(v4, &unk_1B8347FF0, v2);
    memset_pattern16(v6, &unk_1B8347FF0, v2);
  }
  for (unint64_t i = a1[1]; i < a1[2]; ++i)
  {
    uint64_t v9 = (void *)*a1;
    if (*(unsigned char *)(*a1 + 16))
    {
      float32x4_t v10 = *(float32x4_t *)(v9[19] + 16 * i);
      if (*(unsigned __int8 *)(v9[6] + i) == 255)
      {
        int v13 = 0;
        uint64_t v12 = (float32x4_t **)(v9 + 22);
        int v11 = 1;
        goto LABEL_14;
      }
      if (*(unsigned char *)(v9[6] + i)) {
        continue;
      }
    }
    else
    {
      float32x4_t v10 = *(float32x4_t *)(v9[19] + 16 * i);
    }
    int v11 = 0;
    uint64_t v12 = (float32x4_t **)(v9 + 21);
    int v13 = 1;
LABEL_14:
    float32x4_t v14 = vsubq_f32(v10, **v12);
    float32x4_t v15 = vmulq_f32(v14, v14);
    LODWORD(v16) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).u32[0];
    unint64_t v17 = v9[20];
    if (v17 < 2)
    {
      int v18 = 0;
    }
    else
    {
      int v18 = 0;
      if (v13)
      {
        for (uint64_t j = 1; j != v17; ++j)
        {
          float32x4_t v20 = vsubq_f32(v10, *(float32x4_t *)(v9[21] + 16 * j));
          float32x4_t v21 = vmulq_f32(v20, v20);
          float v22 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0];
          if (v22 < v16)
          {
            int v18 = j;
            float v16 = v22;
          }
        }
      }
      else if (v11)
      {
        for (uint64_t k = 1; k != v17; ++k)
        {
          float32x4_t v57 = vsubq_f32(v10, *(float32x4_t *)(v9[22] + 16 * k));
          float32x4_t v58 = vmulq_f32(v57, v57);
          float v59 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 2), vaddq_f32(v58, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 1))).f32[0];
          if (v59 < v16)
          {
            int v18 = k;
            float v16 = v59;
          }
        }
      }
      else
      {
        for (uint64_t m = 1; m != v17; ++m)
        {
          float32x4_t v15 = vmulq_f32(v15, v15);
          float v61 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0];
          if (v61 < v16)
          {
            int v18 = m;
            float v16 = v61;
          }
        }
      }
    }
    if (v13)
    {
      *(unsigned char *)(v9[7] + i) = v18;
      uint64_t v23 = v18;
      unsigned __int32 v24 = (float64x2_t *)(*(void *)(*a1 + 256) + 32 * (v18 + *(void *)(*a1 + 160) * a1[4]));
      float64x2_t v25 = vaddq_f64(vcvt_hight_f64_f32(v10), v24[1]);
      *unsigned __int32 v24 = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v10.f32), *v24);
      v24[1] = v25;
      uint64_t v26 = *a1;
      uint64_t v27 = 8 * (v18 + *(void *)(*a1 + 160) * a1[4]);
      ++*(void *)(*(void *)(*a1 + 352) + v27);
      if (*((unsigned char *)a1 + 25))
      {
        float32x4_t v28 = vmulq_n_f32(v10, v10.f32[0]);
        float64x2_t v29 = vcvtq_f64_f32(*(float32x2_t *)v28.f32);
        float32x4_t v30 = (float64x2_t *)(*(void *)(v26 + 304) + 96 * (v23 + *(void *)(v26 + 160) * a1[4]));
        float64x2_t v31 = vaddq_f64(vcvt_hight_f64_f32(v28), v30[1]);
        *float32x4_t v30 = vaddq_f64(v29, *v30);
        v30[1] = v31;
        float32x4_t v32 = vmulq_lane_f32(v10, *(float32x2_t *)v10.f32, 1);
        uint64_t v33 = *(void *)(*a1 + 304) + 96 * (v23 + *(void *)(*a1 + 160) * a1[4]);
        float64x2_t v34 = *(float64x2_t *)(v33 + 48);
        *(float64x2_t *)(v33 + 32) = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v32.f32), *(float64x2_t *)(v33 + 32));
        *(float64x2_t *)(v33 + 48) = vaddq_f64(vcvt_hight_f64_f32(v32), v34);
        float32x4_t v35 = vmulq_laneq_f32(v10, v10, 2);
        float64x2_t v36 = vcvtq_f64_f32(*(float32x2_t *)v35.f32);
        uint64_t v37 = (float64x2_t *)(*(void *)(*a1 + 304) + 96 * (v23 + *(void *)(*a1 + 160) * a1[4]));
        float64x2_t v38 = vaddq_f64(vcvt_hight_f64_f32(v35), v37[5]);
        v37[4] = vaddq_f64(v36, v37[4]);
        v37[5] = v38;
      }
      if (v16 <= *(float *)&v4[4 * v23]) {
        continue;
      }
      *(float *)&v4[4 * v23] = v16;
      uint64_t v39 = *a1;
      unint64_t v40 = (void *)(*a1 + 288);
    }
    else
    {
      if (!v11) {
        continue;
      }
      *(unsigned char *)(v9[8] + i) = v18;
      uint64_t v23 = v18;
      uint64_t v41 = (float64x2_t *)(*(void *)(*a1 + 264) + 32 * (v18 + *(void *)(*a1 + 160) * a1[4]));
      float64x2_t v42 = vaddq_f64(vcvt_hight_f64_f32(v10), v41[1]);
      *uint64_t v41 = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v10.f32), *v41);
      v41[1] = v42;
      uint64_t v43 = *a1;
      uint64_t v44 = 8 * (v18 + *(void *)(*a1 + 160) * a1[4]);
      ++*(void *)(*(void *)(*a1 + 360) + v44);
      if (*((unsigned char *)a1 + 25))
      {
        float32x4_t v45 = vmulq_n_f32(v10, v10.f32[0]);
        float64x2_t v46 = vcvtq_f64_f32(*(float32x2_t *)v45.f32);
        double v47 = (float64x2_t *)(*(void *)(v43 + 312) + 96 * (v23 + *(void *)(v43 + 160) * a1[4]));
        float64x2_t v48 = vaddq_f64(vcvt_hight_f64_f32(v45), v47[1]);
        *double v47 = vaddq_f64(v46, *v47);
        v47[1] = v48;
        float32x4_t v49 = vmulq_lane_f32(v10, *(float32x2_t *)v10.f32, 1);
        uint64_t v50 = *(void *)(*a1 + 312) + 96 * (v23 + *(void *)(*a1 + 160) * a1[4]);
        float64x2_t v51 = *(float64x2_t *)(v50 + 48);
        *(float64x2_t *)(v50 + 32) = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v49.f32), *(float64x2_t *)(v50 + 32));
        *(float64x2_t *)(v50 + 48) = vaddq_f64(vcvt_hight_f64_f32(v49), v51);
        float32x4_t v52 = vmulq_laneq_f32(v10, v10, 2);
        float64x2_t v53 = vcvtq_f64_f32(*(float32x2_t *)v52.f32);
        uint64_t v54 = (float64x2_t *)(*(void *)(*a1 + 312) + 96 * (v23 + *(void *)(*a1 + 160) * a1[4]));
        float64x2_t v55 = vaddq_f64(vcvt_hight_f64_f32(v52), v54[5]);
        v54[4] = vaddq_f64(v53, v54[4]);
        v54[5] = v55;
      }
      if (v16 <= *(float *)&v6[4 * v23]) {
        continue;
      }
      *(float *)&v6[4 * v23] = v16;
      uint64_t v39 = *a1;
      unint64_t v40 = (void *)(*a1 + 296);
    }
    *(double *)(*v40 + 8 * (v23 + *(void *)(v39 + 160) * a1[4])) = v16;
  }
  MEMORY[0x1BA9BFBA0](a1, 0x1020C4024F7876ELL);
  return 0;
}

uint64_t RefitToClusters(char *a1)
{
  unint64_t v1 = *((void *)a1 + 1);
  if (v1 < *((void *)a1 + 2))
  {
    uint64_t v2 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + 16))
    {
      do
      {
        if (!*(unsigned char *)(v2 + 16)) {
          goto LABEL_7;
        }
        float32x4_t v25 = *(float32x4_t *)(*(void *)(v2 + 152) + 16 * v1);
        if (*(unsigned char *)(*(void *)(v2 + 48) + v1))
        {
          if (*(unsigned __int8 *)(*(void *)(v2 + 48) + v1) < 0x81u) {
            goto LABEL_7;
          }
          uint64_t v26 = *(void **)(v2 + 360);
          if (*v26 < 0xAuLL)
          {
            unint64_t v27 = *(void *)(v2 + 160);
            if (v27 >= 2)
            {
              double v32 = INFINITY;
              goto LABEL_28;
            }
          }
          else
          {
            unint64_t v27 = *(void *)(v2 + 160);
            if (v27 > 1)
            {
              float32x4_t v28 = vsubq_f32(v25, *(float32x4_t *)*(void *)(v2 + 176));
              float64x2_t v29 = vcvt_hight_f64_f32(v28);
              float64x2_t v30 = vcvtq_f64_f32(*(float32x2_t *)v28.f32);
              float64x2_t v31 = *(float64x2_t **)(v2 + 192);
              double v32 = vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v31[1], v30), v31[3], v30, 1), v29, v31[5]), v29).f64[0]
                  + vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v31, v30.f64[0]), v31[2], v30, 1), v31[4], v29.f64[0]), v30))- **(double **)(v2 + 240);
LABEL_28:
              uint64_t v47 = 0;
              int v48 = 0;
              for (uint64_t i = 1; i != v27; ++i)
              {
                if (v26[i] >= 0xAuLL)
                {
                  float32x4_t v50 = vsubq_f32(v25, *(float32x4_t *)(*(void *)(v2 + 176) + 16 * i));
                  float64x2_t v51 = vcvt_hight_f64_f32(v50);
                  float64x2_t v52 = vcvtq_f64_f32(*(float32x2_t *)v50.f32);
                  float64x2_t v53 = (float64x2_t *)(*(void *)(v2 + 192) + v47);
                  double v54 = vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v53[7], v52), v53[9], v52, 1), v51, v53[11]), v51).f64[0]
                      + vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v53[6], v52.f64[0]), v53[8], v52, 1), v53[10], v51.f64[0]), v52))- *(double *)(*(void *)(v2 + 240) + 8 * i);
                }
                else
                {
                  double v54 = INFINITY;
                }
                if (v54 <= v32)
                {
                  int v48 = i;
                  double v32 = v54;
                }
                v47 += 96;
              }
LABEL_36:
              *(unsigned char *)(*(void *)(v2 + 64) + v1) = v48;
              float64x2_t v4 = vcvt_hight_f64_f32(v25);
              float64x2_t v5 = vcvtq_f64_f32(*(float32x2_t *)v25.f32);
              uint64_t v6 = v48;
              uint64_t v7 = (float64x2_t *)(*((void *)a1 + 7)
                                 + 32 * (v48 + *(void *)(*(void *)a1 + 160) * *((void *)a1 + 3)));
              uint64_t v8 = a1 + 40;
              uint64_t v9 = a1 + 72;
              goto LABEL_6;
            }
          }
          int v48 = 0;
          goto LABEL_36;
        }
        uint64_t v33 = *(void **)(v2 + 352);
        if (*v33 < 0xAuLL)
        {
          unint64_t v34 = *(void *)(v2 + 160);
          if (v34 >= 2)
          {
            double v39 = INFINITY;
LABEL_19:
            uint64_t v40 = 0;
            int v3 = 0;
            for (uint64_t j = 1; j != v34; ++j)
            {
              if (v33[j] >= 0xAuLL)
              {
                float32x4_t v42 = vsubq_f32(v25, *(float32x4_t *)(*(void *)(v2 + 168) + 16 * j));
                float64x2_t v43 = vcvt_hight_f64_f32(v42);
                float64x2_t v44 = vcvtq_f64_f32(*(float32x2_t *)v42.f32);
                float32x4_t v45 = (float64x2_t *)(*(void *)(v2 + 184) + v40);
                double v46 = vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v45[7], v44), v45[9], v44, 1), v43, v45[11]), v43).f64[0]
                    + vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v45[6], v44.f64[0]), v45[8], v44, 1), v45[10], v43.f64[0]), v44))- *(double *)(*(void *)(v2 + 232) + 8 * j);
              }
              else
              {
                double v46 = INFINITY;
              }
              if (v46 <= v39)
              {
                int v3 = j;
                double v39 = v46;
              }
              v40 += 96;
            }
            goto LABEL_5;
          }
        }
        else
        {
          unint64_t v34 = *(void *)(v2 + 160);
          if (v34 > 1)
          {
            float32x4_t v35 = vsubq_f32(v25, *(float32x4_t *)*(void *)(v2 + 168));
            float64x2_t v36 = vcvt_hight_f64_f32(v35);
            float64x2_t v37 = vcvtq_f64_f32(*(float32x2_t *)v35.f32);
            float64x2_t v38 = *(float64x2_t **)(v2 + 184);
            double v39 = vmulq_f64(vmlaq_f64(vmlaq_laneq_f64(vmulq_f64(v38[1], v37), v38[3], v37, 1), v36, v38[5]), v36).f64[0]
                + vaddvq_f64(vmulq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*v38, v37.f64[0]), v38[2], v37, 1), v38[4], v36.f64[0]), v37))- **(double **)(v2 + 232);
            goto LABEL_19;
          }
        }
        int v3 = 0;
LABEL_5:
        *(unsigned char *)(*(void *)(v2 + 56) + v1) = v3;
        float64x2_t v4 = vcvt_hight_f64_f32(v25);
        float64x2_t v5 = vcvtq_f64_f32(*(float32x2_t *)v25.f32);
        uint64_t v6 = v3;
        uint64_t v7 = (float64x2_t *)(*((void *)a1 + 6) + 32 * (v3 + *(void *)(*(void *)a1 + 160) * *((void *)a1 + 3)));
        uint64_t v8 = a1 + 32;
        uint64_t v9 = a1 + 64;
LABEL_6:
        float64x2_t v10 = vaddq_f64(v4, v7[1]);
        *uint64_t v7 = vaddq_f64(v5, *v7);
        v7[1] = v10;
        uint64_t v11 = *(void *)v8;
        uint64_t v12 = *(void *)a1;
        uint64_t v13 = 8 * (v6 + *(void *)(*(void *)a1 + 160) * *((void *)a1 + 3));
        ++*(void *)(v11 + v13);
        float32x4_t v14 = vmulq_n_f32(v25, v25.f32[0]);
        float64x2_t v15 = vcvtq_f64_f32(*(float32x2_t *)v14.f32);
        float v16 = (float64x2_t *)(*(void *)v9 + 96 * (v6 + *(void *)(v12 + 160) * *((void *)a1 + 3)));
        float64x2_t v17 = vaddq_f64(vcvt_hight_f64_f32(v14), v16[1]);
        *float v16 = vaddq_f64(v15, *v16);
        v16[1] = v17;
        float32x4_t v18 = vmulq_lane_f32(v25, *(float32x2_t *)v25.f32, 1);
        uint64_t v19 = *(void *)v9 + 96 * (v6 + *(void *)(*(void *)a1 + 160) * *((void *)a1 + 3));
        float64x2_t v20 = *(float64x2_t *)(v19 + 48);
        *(float64x2_t *)(v19 + 32) = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v18.f32), *(float64x2_t *)(v19 + 32));
        *(float64x2_t *)(v19 + 48) = vaddq_f64(vcvt_hight_f64_f32(v18), v20);
        float32x4_t v21 = vmulq_laneq_f32(v25, v25, 2);
        float64x2_t v22 = vcvtq_f64_f32(*(float32x2_t *)v21.f32);
        uint64_t v23 = (float64x2_t *)(*(void *)v9 + 96 * (v6 + *(void *)(*(void *)a1 + 160) * *((void *)a1 + 3)));
        float64x2_t v24 = vaddq_f64(vcvt_hight_f64_f32(v21), v23[5]);
        v23[4] = vaddq_f64(v22, v23[4]);
        v23[5] = v24;
LABEL_7:
        ++v1;
      }
      while (v1 < *((void *)a1 + 2));
    }
  }
  MEMORY[0x1BA9BFBA0]();
  return 0;
}

uint64_t soKMeansClassifier::Cluster(soKMeansClassifier *this, uint64_t a2, int a3, unsigned char *a4, unsigned char *a5, uint64_t a6, uint64_t a7, char *a8, __n128 a9, char *__dst, uint64_t a11)
{
  if (!*((void *)this + 10) || !*((void *)this + 11)) {
    return 0xFFFFFFFFLL;
  }
  *((_DWORD *)this + 9) = a3;
  soKMeansClassifier::InitClusterMeans(this, a9);
  memset(*((void **)this + 7), 255, *((void *)this + 14));
  if (*((unsigned char *)this + 16)) {
    memset(*((void **)this + 8), 255, *((void *)this + 14));
  }
  int8x16_t v102 = a8;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0;
  if (a2)
  {
    bzero(*((void **)this + 44), 8 * *((void *)this + 20) * *((void *)this + 1));
    bzero(*((void **)this + 32), 32 * *((void *)this + 20) * *((void *)this + 1));
    bzero(*((void **)this + 38), 96 * *((void *)this + 20) * *((void *)this + 1));
    if (*((unsigned char *)this + 16))
    {
      bzero(*((void **)this + 45), 8 * *((void *)this + 20) * *((void *)this + 1));
      bzero(*((void **)this + 33), 32 * *((void *)this + 20) * *((void *)this + 1));
      bzero(*((void **)this + 39), 96 * *((void *)this + 20) * *((void *)this + 1));
    }
    if (*((void *)this + 1) >= 2uLL) {
      operator new[]();
    }
    operator new();
  }
  if (*((void *)this + 20))
  {
    unsigned int v19 = 0;
    uint64_t v20 = 0;
    unint64_t v21 = 0;
    do
    {
      unint64_t v30 = *(void *)(*((void *)this + 44) + 8 * v21);
      if (v30)
      {
        uint64_t v31 = *((void *)this + 38);
        double v32 = (float64x2_t *)(v31 + 32 * v19);
        v16.f64[0] = (double)v30;
        float64x2_t v33 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v30), 0);
        float32x4_t v34 = *(float32x4_t *)(*((void *)this + 21) + 16 * v21);
        float64x2_t v35 = vcvt_hight_f64_f32(v34);
        float64x2_t v36 = vcvtq_f64_f32(*(float32x2_t *)v34.f32);
        v17.f64[0] = v34.f32[0];
        float64x2_t v37 = vmulq_f64(v17, v35);
        int8x16_t v38 = (int8x16_t)vsubq_f64(vdivq_f64(v32[1], v16), v37);
        int8x16_t v39 = (int8x16_t)vsubq_f64(vdivq_f64(*v32, v33), vmulq_n_f64(v36, v34.f32[0]));
        uint64_t v40 = (float64x2_t *)(v31 + 32 * (v19 + 1));
        v37.f64[0] = COERCE_FLOAT(HIDWORD(*(void *)(*((void *)this + 21) + 16 * v21)));
        int8x16_t v41 = (int8x16_t)vsubq_f64(vdivq_f64(v40[1], v16), vmulq_f64(v37, v35));
        float64x2_t v42 = vsubq_f64(vdivq_f64(*v40, v33), vmulq_n_f64(v36, v37.f64[0]));
        float64x2_t v43 = (float64x2_t *)(v31 + 32 * (v19 + 2));
        float64x2_t v44 = vdivq_f64(v43[1], v16);
        v16.f64[0] = COERCE_FLOAT(*(void *)(*((void *)this + 21) + 16 * v21 + 8));
        float64x2_t v45 = vsubq_f64(v44, vmulq_f64(v16, v35));
        int8x16_t v46 = (int8x16_t)vsubq_f64(vdivq_f64(*v43, v33), vmulq_n_f64(v36, v16.f64[0]));
        double v47 = vmuld_lane_f64(*(double *)v41.i64, (float64x2_t)v46, 1);
        double v48 = vmuld_lane_f64(*(double *)v38.i64, (float64x2_t)v46, 1);
        double v49 = vmuld_lane_f64(*(double *)v41.i64, (float64x2_t)v39, 1);
        double v50 = (v49 - vmuld_lane_f64(*(double *)v38.i64, v42, 1)) * *(double *)v46.i64
            + (vmuld_lane_f64(v45.f64[0], v42, 1) - v47) * *(double *)v39.i64
            - (vmuld_lane_f64(v45.f64[0], (float64x2_t)v39, 1) - v48) * v42.f64[0];
        if (v50 <= 2.22044605e-16)
        {
          *(double *)v51.i64 = *(double *)v39.i64 + 0.01;
          v51.i64[1] = vextq_s8(v39, v39, 8uLL).u64[0];
          *(int8x16_t *)&__src.columns[0].f64[2] = v51;
          v52.f64[0] = v45.f64[0] + 0.01;
          v51.i64[0] = v38.i64[0];
          v51.i64[1] = vextq_s8(v38, v38, 8uLL).u64[0];
          v53.f64[0] = v42.f64[0];
          v53.f64[1] = v42.f64[1] + 0.01;
          v41.i64[1] = vextq_s8(v41, v41, 8uLL).u64[0];
          int8x16_t v104 = v41;
          int8x16_t v106 = v51;
          *(void *)&long long v54 = v46.i64[0];
          *((void *)&v54 + 1) = vextq_s8(v46, v46, 8uLL).u64[0];
          v52.f64[1] = v45.f64[1];
          double v50 = *(double *)v46.i64 * (v49 - *(double *)v38.i64 * (v42.f64[1] + 0.01))
              + (*(double *)v39.i64 + 0.01) * ((v42.f64[1] + 0.01) * (v45.f64[0] + 0.01) - v47)
              - v42.f64[0] * (*(double *)&v39.i64[1] * (v45.f64[0] + 0.01) - v48);
          float64x2_t v110 = v53;
          *(_OWORD *)__src.columns[0].f64 = v54;
          float64x2_t v108 = v52;
        }
        else
        {
          *(int8x16_t *)__src.columns[0].f64 = v46;
          *(int8x16_t *)&__src.columns[0].f64[2] = v39;
          int8x16_t v104 = v41;
          int8x16_t v106 = v38;
          float64x2_t v108 = v45;
          float64x2_t v110 = v42;
        }
        *(double *)(*((void *)this + 25) + 8 * v21) = v50;
        long double v55 = 1.0 / sqrt(v50);
        *(long double *)(*((void *)this + 27) + 8 * v21) = v55;
        long double v56 = log(v55);
        *(long double *)(*((void *)this + 29) + 8 * v21) = v56 + v56;
        long long v113 = *(_OWORD *)&__src.columns[0].f64[2];
        int8x16_t v114 = v106;
        float64x2_t v115 = v110;
        int8x16_t v116 = v104;
        long long v117 = *(_OWORD *)__src.columns[0].f64;
        float64x2_t v118 = v108;
        __invert_d3();
        memmove((void *)(*((void *)this + 23) + v20), v112, 0x60uLL);
      }
      if (*((unsigned char *)this + 16))
      {
        unint64_t v57 = *(void *)(*((void *)this + 45) + 8 * v21);
        if (v57)
        {
          uint64_t v58 = *((void *)this + 39);
          float v59 = (float64x2_t *)(v58 + 32 * v19);
          v16.f64[0] = (double)v57;
          float64x2_t v60 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v57), 0);
          float32x4_t v61 = *(float32x4_t *)(*((void *)this + 22) + 16 * v21);
          float64x2_t v62 = vcvt_hight_f64_f32(v61);
          float64x2_t v63 = vcvtq_f64_f32(*(float32x2_t *)v61.f32);
          v17.f64[0] = v61.f32[0];
          float64x2_t v64 = vmulq_f64(v17, v62);
          int8x16_t v65 = (int8x16_t)vsubq_f64(vdivq_f64(v59[1], v16), v64);
          int8x16_t v66 = (int8x16_t)vsubq_f64(vdivq_f64(*v59, v60), vmulq_n_f64(v63, v61.f32[0]));
          uint64_t v67 = (float64x2_t *)(v58 + 32 * (v19 + 1));
          v64.f64[0] = COERCE_FLOAT(HIDWORD(*(void *)(*((void *)this + 22) + 16 * v21)));
          int8x16_t v68 = (int8x16_t)vsubq_f64(vdivq_f64(v67[1], v16), vmulq_f64(v64, v62));
          float64x2_t v69 = vsubq_f64(vdivq_f64(*v67, v60), vmulq_n_f64(v63, v64.f64[0]));
          uint64_t v70 = (float64x2_t *)(v58 + 32 * (v19 + 2));
          float64x2_t v71 = vdivq_f64(v70[1], v16);
          v16.f64[0] = COERCE_FLOAT(*(void *)(*((void *)this + 22) + 16 * v21 + 8));
          float64x2_t v72 = vsubq_f64(v71, vmulq_f64(v16, v62));
          int8x16_t v73 = (int8x16_t)vsubq_f64(vdivq_f64(*v70, v60), vmulq_n_f64(v63, v16.f64[0]));
          double v74 = vmuld_lane_f64(*(double *)v68.i64, (float64x2_t)v73, 1);
          double v75 = vmuld_lane_f64(*(double *)v65.i64, (float64x2_t)v73, 1);
          double v76 = vmuld_lane_f64(*(double *)v68.i64, (float64x2_t)v66, 1);
          double v26 = (v76 - vmuld_lane_f64(*(double *)v65.i64, v69, 1)) * *(double *)v73.i64
              + (vmuld_lane_f64(v72.f64[0], v69, 1) - v74) * *(double *)v66.i64
              - (vmuld_lane_f64(v72.f64[0], (float64x2_t)v66, 1) - v75) * v69.f64[0];
          if (v26 <= 2.22044605e-16)
          {
            *(double *)v22.i64 = *(double *)v66.i64 + 0.01;
            v22.i64[1] = vextq_s8(v66, v66, 8uLL).u64[0];
            *(int8x16_t *)&__src.columns[0].f64[2] = v22;
            v23.f64[0] = v72.f64[0] + 0.01;
            v22.i64[0] = v65.i64[0];
            v22.i64[1] = vextq_s8(v65, v65, 8uLL).u64[0];
            v24.f64[0] = v69.f64[0];
            v24.f64[1] = v69.f64[1] + 0.01;
            v68.i64[1] = vextq_s8(v68, v68, 8uLL).u64[0];
            int8x16_t v103 = v68;
            int8x16_t v105 = v22;
            *(void *)&long long v25 = v73.i64[0];
            *((void *)&v25 + 1) = vextq_s8(v73, v73, 8uLL).u64[0];
            v23.f64[1] = v72.f64[1];
            double v26 = *(double *)v73.i64 * (v76 - *(double *)v65.i64 * (v69.f64[1] + 0.01))
                + (*(double *)v66.i64 + 0.01) * ((v69.f64[1] + 0.01) * (v72.f64[0] + 0.01) - v74)
                - v69.f64[0] * (*(double *)&v66.i64[1] * (v72.f64[0] + 0.01) - v75);
            float64x2_t v109 = v24;
            *(_OWORD *)__src.columns[0].f64 = v25;
            float64x2_t v107 = v23;
          }
          else
          {
            *(int8x16_t *)__src.columns[0].f64 = v73;
            *(int8x16_t *)&__src.columns[0].f64[2] = v66;
            int8x16_t v103 = v68;
            int8x16_t v105 = v65;
            float64x2_t v107 = v72;
            float64x2_t v109 = v69;
          }
          *(double *)(*((void *)this + 26) + 8 * v21) = v26;
          long double v27 = 1.0 / sqrt(v26);
          *(long double *)(*((void *)this + 28) + 8 * v21) = v27;
          long double v28 = log(v27);
          *(long double *)(*((void *)this + 30) + 8 * v21) = v28 + v28;
          long long v113 = *(_OWORD *)&__src.columns[0].f64[2];
          int8x16_t v114 = v105;
          float64x2_t v115 = v109;
          int8x16_t v116 = v103;
          long long v117 = *(_OWORD *)__src.columns[0].f64;
          float64x2_t v118 = v107;
          __invert_d3();
          memmove((void *)(*((void *)this + 24) + v20), &__src.columns[1], 0x60uLL);
        }
      }
      ++v21;
      unint64_t v29 = *((void *)this + 20);
      v20 += 96;
      v19 += 3;
    }
    while (v29 > v21);
    uint64_t v77 = a4;
    if (a4 && v29)
    {
      unint64_t v78 = 0;
      uint64_t v79 = a6;
      int64x2_t v80 = v102;
      do
      {
        float32x4_t v81 = *(float32x4_t *)(*((void *)this + 21) + 16 * v78);
        v81.i32[3] = 0;
        float32x4_t v82 = vmaxnmq_f32(v81, (float32x4_t)0);
        v82.i32[3] = 0;
        int32x4_t v83 = vcvtq_s32_f32(vminnmq_f32(v82, (float32x4_t)xmmword_1B8347FE0));
        v77[1] = v83.i8[4];
        v77[2] = v83.i8[8];
        *uint64_t v77 = v83.i8[0];
        ++v78;
        unint64_t v29 = *((void *)this + 20);
        v77 += 4;
      }
      while (v29 > v78);
      goto LABEL_33;
    }
  }
  else
  {
    unint64_t v29 = 0;
  }
  uint64_t v79 = a6;
  int64x2_t v80 = v102;
LABEL_33:
  if (v79 && v29)
  {
    unint64_t v84 = 0;
    uint64_t v85 = *((void *)this + 44);
    do
    {
      *(void *)(v79 + 8 * v84) = *(void *)(v85 + 8 * v84);
      ++v84;
    }
    while (*((void *)this + 20) > v84);
  }
  if (v80 && *((void *)this + 11))
  {
    uint64_t v86 = 0;
    unint64_t v87 = 0;
    size_t v88 = *((void *)this + 10);
    do
    {
      memcpy(v80, (const void *)(*((void *)this + 7) + v86), v88);
      ++v87;
      v86 += v88;
      v80 += a11;
    }
    while (*((void *)this + 11) > v87);
  }
  if (*((unsigned char *)this + 16))
  {
    uint32x4_t v89 = a5;
    if (a5 && *((void *)this + 20))
    {
      unint64_t v90 = 0;
      do
      {
        float32x4_t v91 = *(float32x4_t *)(*((void *)this + 22) + 16 * v90);
        v91.i32[3] = 0;
        float32x4_t v92 = vmaxnmq_f32(v91, (float32x4_t)0);
        v92.i32[3] = 0;
        int32x4_t v93 = vcvtq_s32_f32(vminnmq_f32(v92, (float32x4_t)xmmword_1B8347FE0));
        v89[1] = v93.i8[4];
        v89[2] = v93.i8[8];
        *uint32x4_t v89 = v93.i8[0];
        ++v90;
        v89 += 4;
      }
      while (*((void *)this + 20) > v90);
    }
    int v94 = __dst;
    if (a7 && *((void *)this + 20))
    {
      unint64_t v95 = 0;
      uint64_t v96 = *((void *)this + 45);
      do
      {
        *(void *)(a7 + 8 * v95) = *(void *)(v96 + 8 * v95);
        ++v95;
      }
      while (*((void *)this + 20) > v95);
    }
    if (__dst && *((void *)this + 11))
    {
      uint64_t v97 = 0;
      unint64_t v98 = 0;
      size_t v99 = *((void *)this + 10);
      do
      {
        memcpy(v94, (const void *)(*((void *)this + 8) + v97), v99);
        ++v98;
        v97 += v99;
        v94 += a11;
      }
      while (*((void *)this + 11) > v98);
    }
  }
  return 0;
}

void soKMeansClassifier::UpdateClusters(soKMeansClassifier *this, unsigned __int8 *__src, uint64_t a3)
{
  size_t v5 = *((void *)this + 10);
  unint64_t v4 = *((void *)this + 11);
  if (v4)
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      memcpy((void *)(*((void *)this + 6) + v8), __src, v5);
      ++v9;
      unint64_t v4 = *((void *)this + 11);
      __src += a3;
      v8 += v5;
    }
    while (v4 > v9);
    size_t v5 = *((void *)this + 10);
  }
  size_t v10 = v5 * v4;
  memset(*((void **)this + 7), 255, v5 * v4);
  memset(*((void **)this + 8), 255, v10);
  bzero(*((void **)this + 46), 8 * *((void *)this + 20) * *((void *)this + 1));
  bzero(*((void **)this + 34), 32 * *((void *)this + 20) * *((void *)this + 1));
  bzero(*((void **)this + 40), 96 * *((void *)this + 20) * *((void *)this + 1));
  if (*((unsigned char *)this + 16))
  {
    bzero(*((void **)this + 47), 8 * *((void *)this + 20) * *((void *)this + 1));
    bzero(*((void **)this + 35), 32 * *((void *)this + 20) * *((void *)this + 1));
    bzero(*((void **)this + 41), 96 * *((void *)this + 20) * *((void *)this + 1));
  }
  if (*((void *)this + 1) >= 2uLL) {
    operator new[]();
  }
  operator new();
}

uint64_t std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = a3[1];
  if (result != *a3)
  {
    unsigned int v4 = result - *a3 + 1;
    if (result - *a3 == -1)
    {
      uint64_t v16 = *(void *)(a2 + 2496);
      unint64_t v17 = (v16 + 1) % 0x270uLL;
      unsigned int v18 = *(_DWORD *)(a2 + 4 * ((v16 + 397) % 0x270uLL)) ^ ((*(_DWORD *)(a2 + 4 * v17) & 0x7FFFFFFE | *(_DWORD *)(a2 + 4 * v16) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(a2 + 4 * v17) << 31) >> 31) & 0x9908B0DF;
      *(_DWORD *)(a2 + 4 * v16) = v18;
      *(void *)(a2 + 2496) = v17;
      unsigned int v19 = ((v18 ^ (v18 >> 11)) << 7) & 0x9D2C5680 ^ v18 ^ (v18 >> 11);
      return (v19 << 15) & 0xEFC60000 ^ v19 ^ (((v19 << 15) & 0xEFC60000 ^ v19) >> 18);
    }
    else
    {
      uint64_t v5 = __clz(v4);
      uint64_t v6 = 31;
      if (((v4 << v5) & 0x7FFFFFFF) != 0) {
        uint64_t v6 = 32;
      }
      unint64_t v7 = v6 - v5;
      unint64_t v8 = v7 >> 5;
      if ((v7 & 0x1F) != 0) {
        ++v8;
      }
      if (v8 <= v7) {
        unsigned int v9 = 0xFFFFFFFF >> -(v7 / v8);
      }
      else {
        unsigned int v9 = 0;
      }
      unint64_t v10 = *(void *)(a2 + 2496);
      do
      {
        uint64_t v11 = 4 * v10;
        unint64_t v12 = v10 + 397;
        unint64_t v10 = (v10 + 1) % 0x270;
        unsigned int v13 = *(_DWORD *)(a2 + 4 * (v12 % 0x270)) ^ ((*(_DWORD *)(a2 + 4 * v10) & 0x7FFFFFFE | *(_DWORD *)(a2 + v11) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(a2 + 4 * v10) << 31) >> 31) & 0x9908B0DF;
        *(_DWORD *)(a2 + v11) = v13;
        unsigned int v14 = ((v13 ^ (v13 >> 11)) << 7) & 0x9D2C5680 ^ v13 ^ (v13 >> 11);
        unsigned int v15 = ((v14 << 15) & 0xEFC60000 ^ v14 ^ (((v14 << 15) & 0xEFC60000 ^ v14) >> 18)) & v9;
      }
      while (v15 >= v4);
      *(void *)(a2 + 2496) = v10;
      return *a3 + v15;
    }
  }
  return result;
}

void HGFractured::Effect::Effect(HGFractured::Effect *this)
{
  HGObject::HGObject(this);
  *(void *)uint64_t v2 = &unk_1F10E1668;
  *(void *)(v2 + 16) = 0;
  *(void *)(v2 + 24) = 0;
  __asm { FMOV            V8.2S, #1.0 }
  *(void *)(v2 + 32) = 0x100000001;
  *(void *)(v2 + 40) = _D8;
  *(_DWORD *)(v2 + 48) = 1065353216;
  *(void *)(v2 + 56) = 0;
  *(void *)(v2 + 64) = 0;
  *(void *)(v2 + 104) = 0;
  *(void *)(v2 + 112) = 0;
  *(void *)(v2 + 96) = 0;
  *((void *)this + 9) = HGRectMake4i(0, 0, 0, 0);
  *((void *)this + 10) = v8;
  *((void *)this + 11) = 0;
  *((void *)this + 15) = 0x400000007;
  *((unsigned char *)this + 128) = 0;
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  *(void *)((char *)this + 132) = 1065353216;
  *((_DWORD *)this + 35) = 0;
  *((_WORD *)this + 72) = 0;
  *(void *)((char *)this + 148) = 0x400000003F800000;
  *((_WORD *)this + 78) = 0;
  *((void *)this + 20) = 0x400000000;
  *((void *)this + 21) = _D8;
  *((_DWORD *)this + 44) = 0;
  *((void *)this + 25) = 0x3F80000000000000;
  *(void *)((char *)this + 180) = HGRectMake4i(0, 0, 0, 0);
  *(void *)((char *)this + 188) = v9;
  *((_DWORD *)this + 49) = 1065353216;
  *((_DWORD *)this + 60) = 0;
  operator new();
}

void sub_1B78424AC(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  MEMORY[0x1BA9BFBA0](v3, 0x10A1C40BBCAB520);
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B78424DC(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B78424F0(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B7842504(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGFractured::Effect::~Effect(HGFractured::Effect *this)
{
  *(void *)this = &unk_1F10E1668;
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 12);
  if (v3) {
    free(v3);
  }
  unsigned int v4 = (void *)*((void *)this + 13);
  if (v4) {
    free(v4);
  }
  uint64_t v5 = *((void *)this + 31);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }

  HGObject::~HGObject(this);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t vars8;

  *(void *)this = &unk_1F10E1668;
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 12);
  if (v3) {
    free(v3);
  }
  unsigned int v4 = (void *)*((void *)this + 13);
  if (v4) {
    free(v4);
  }
  uint64_t v5 = *((void *)this + 31);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v6);
}

uint64_t HGFractured::Effect::SetLeftHand(uint64_t this, int a2)
{
  if (*(unsigned __int8 *)(this + 145) != a2)
  {
    *(unsigned char *)(this + 145) = a2;
    *(_DWORD *)(this + 120) |= 6u;
  }
  return this;
}

uint64_t HGFractured::Effect::SetRect(uint64_t this, HGRect a2)
{
  float v2 = (float)(a2.var3 - a2.var1) / (float)(a2.var2 - a2.var0);
  if (*(float *)(this + 196) != v2)
  {
    *(float *)(this + 196) = v2;
    *(float *)(this + 132) = v2;
    *(_DWORD *)(this + 120) |= 7u;
  }
  *(HGRect *)(this + 72) = a2;
  *(HGRect *)(this + 180) = a2;
  return this;
}

uint64_t HGFractured::Effect::SetImageRect(uint64_t this, HGRect a2)
{
  float v2 = (float)(a2.var3 - a2.var1) / (float)(a2.var2 - a2.var0);
  if (*(float *)(this + 132) != v2)
  {
    *(float *)(this + 44) = v2 / (float)*(unsigned int *)(this + 36);
    *(float *)(this + 132) = v2;
    *(_DWORD *)(this + 120) |= 7u;
  }
  *(HGRect *)(this + 180) = a2;
  return this;
}

float HGFractured::Effect::SetSubdivide(HGFractured::Effect *this, unsigned int a2, unsigned int a3)
{
  if (*((_DWORD *)this + 8) != a2 || *((_DWORD *)this + 9) != a3)
  {
    *((_DWORD *)this + 8) = a2;
    *((_DWORD *)this + 9) = a3;
    float result = 1.0 / (float)a2;
    float v4 = *((float *)this + 33) / (float)a3;
    *((float *)this + 10) = result;
    *((float *)this + 11) = v4;
    *((_DWORD *)this + 30) |= 7u;
  }
  return result;
}

uint64_t HGFractured::Effect::SetShape(uint64_t this, int a2, float a3)
{
  if (*(_DWORD *)(this + 164) != a2 || *(float *)(this + 48) != a3)
  {
    *(_DWORD *)(this + 164) = a2;
    *(unsigned char *)(this + 157) = a2 == 0;
    *(float *)(this + 48) = a3;
    *(_DWORD *)(this + 120) |= 7u;
  }
  return this;
}

uint64_t HGFractured::Effect::SetExtrude(uint64_t this, float a2)
{
  float v2 = fmaxf(a2, 0.0);
  if (*(float *)(this + 136) != v2)
  {
    *(_DWORD *)(this + 120) |= 7u;
    *(float *)(this + 136) = v2;
  }
  return this;
}

uint64_t HGFractured::Effect::SetScale(uint64_t this, float a2, float a3)
{
  if (*(float *)(this + 168) != a2 || *(float *)(this + 172) != a3)
  {
    *(float *)(this + 168) = a2;
    *(float *)(this + 172) = a3;
    *(_DWORD *)(this + 120) |= 7u;
  }
  return this;
}

uint64_t HGFractured::Effect::SetDual(uint64_t this, int a2, int a3)
{
  if (*(_DWORD *)(this + 140) != a2 || *(unsigned __int8 *)(this + 144) != a3)
  {
    *(_DWORD *)(this + 140) = a2;
    *(unsigned char *)(this + 144) = a3;
    *(_DWORD *)(this + 120) |= 6u;
  }
  return this;
}

uint64_t HGFractured::Effect::SetDelay(uint64_t this, float a2)
{
  float v2 = fmaxf(a2, 0.0);
  if (*(float *)(this + 148) != v2)
  {
    *(float *)(this + 148) = v2;
    *(_DWORD *)(this + 120) |= 6u;
  }
  return this;
}

uint64_t HGFractured::Effect::SetOriginPoint(uint64_t this, float a2, float a3)
{
  *(float *)(this + 208) = a2;
  *(float *)(this + 212) = a3;
  *(_DWORD *)(this + 120) |= 7u;
  return this;
}

uint64_t HGFractured::Effect::SetImpulse(uint64_t this, float a2, float a3)
{
  *(float *)(this + 216) = a2;
  *(float *)(this + 220) = a3;
  *(_DWORD *)(this + 120) |= 7u;
  return this;
}

uint64_t HGFractured::Effect::SetMode(uint64_t this, int a2)
{
  switch(a2)
  {
    case 0:
      if (*(uint64_t (**)(HGFractured::Effect *, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::shatter)
      {
        float v2 = HGFractured::Effect::shatter;
        goto LABEL_38;
      }
      break;
    case 1:
      if (*(uint64_t (**)(void **, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::blast)
      {
        float v2 = HGFractured::Effect::blast;
        goto LABEL_38;
      }
      break;
    case 2:
      if (*(uint64_t (**)(void **, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::crumble)
      {
        float v2 = HGFractured::Effect::crumble;
        goto LABEL_38;
      }
      break;
    case 3:
      if (*(uint64_t (**)(void **, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::swipe)
      {
        float v2 = HGFractured::Effect::swipe;
        goto LABEL_38;
      }
      break;
    case 4:
      if (*(float *(*(**)(void **, HGFractured::Effect *, double, double, double, double, int32x2_t))(float *, HGFractured::Effect *, __n128, int, __n128, double, float32x4_t, float32x4_t, float32x4_t, double, double, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(this + 224) != HGFractured::Effect::vortex)
      {
        float v2 = HGFractured::Effect::vortex;
        goto LABEL_38;
      }
      break;
    case 5:
      if (*(uint64_t (**)(HGFractured::Effect *, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::flip)
      {
        float v2 = HGFractured::Effect::flip;
        goto LABEL_38;
      }
      break;
    case 6:
      if (*(float *(*(**)(void **, HGFractured::Effect *, double, double, double, double, int32x2_t))(float *, float, int))(this + 224) != HGFractured::Effect::whirl)
      {
        float v2 = HGFractured::Effect::whirl;
        goto LABEL_38;
      }
      break;
    case 7:
      if (*(uint64_t (**)(HGFractured::Effect *, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::shutter)
      {
        float v2 = HGFractured::Effect::shutter;
        goto LABEL_38;
      }
      break;
    case 8:
      if (*(uint64_t (**)(HGFractured::Effect *, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::evaporate)
      {
        float v2 = HGFractured::Effect::evaporate;
        goto LABEL_38;
      }
      break;
    case 9:
      if (*(uint64_t (**)(void **, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::explode)
      {
        float v2 = HGFractured::Effect::explode;
        goto LABEL_38;
      }
      break;
    case 10:
      if (*(uint64_t (**)(void **, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::pulverize)
      {
        float v2 = HGFractured::Effect::pulverize;
        goto LABEL_38;
      }
      break;
    case 11:
      if (*(float *(*(**)(void **, HGFractured::Effect *, double, double, double, double, int32x2_t))(float *, float, int))(this + 224) != HGFractured::Effect::twirl)
      {
        float v2 = HGFractured::Effect::twirl;
        goto LABEL_38;
      }
      break;
    case 12:
      if (*(uint64_t (**)(HGFractured::Effect *, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::spread)
      {
        float v2 = HGFractured::Effect::spread;
        goto LABEL_38;
      }
      break;
    case 13:
      if (*(uint64_t (**)(void **, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::rotate)
      {
        float v2 = HGFractured::Effect::rotate;
        goto LABEL_38;
      }
      break;
    case 14:
      if (*(uint64_t (**)(void **, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::blocks)
      {
        float v2 = HGFractured::Effect::blocks;
        goto LABEL_38;
      }
      break;
    case 15:
      if (*(uint64_t (**)(HGFractured::Effect *, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::bars)
      {
        float v2 = HGFractured::Effect::bars;
        goto LABEL_38;
      }
      break;
    case 16:
      if (*(uint64_t (**)(HGFractured::Effect *, HGFractured::Effect *, double, double, double, double, int32x2_t))(this + 224) != HGFractured::Effect::cube)
      {
        float v2 = HGFractured::Effect::cube;
        goto LABEL_38;
      }
      break;
    case 17:
      if (*(float *(*(**)(void **, HGFractured::Effect *, double, double, double, double, int32x2_t))(float *, float, int))(this + 224) != HGFractured::Effect::test)
      {
        float v2 = HGFractured::Effect::test;
LABEL_38:
        *(void *)(this + 224) = v2;
        *(_DWORD *)(this + 120) |= 7u;
      }
      break;
    default:
      return this;
  }
  return this;
}

uint64_t HGFractured::Effect::shatter(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  LODWORD(a3) = *((_DWORD *)this + 37);
  if (*(float *)&a3 != 0.0)
  {
    *((_DWORD *)this + 37) = 0;
    *((_DWORD *)this + 30) |= 6u;
  }
  HGFractured::Effect::blast((void **)this, a2, a3, a4, a5, a6, a7);
  return 0;
}

uint64_t HGFractured::Effect::blast(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  uint64_t v8 = (char *)this[8];
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    unint64_t v10 = (float32x2_t *)((char *)this[7] + 36);
    float32x2_t v11 = 0;
    int32x2_t v12 = vdup_n_s32(0xFD43FDu);
    float32x2_t v13 = (float32x2_t)vdup_n_s32(0x33800000u);
    __asm
    {
      FMOV            V6.2D, #0.125
      FMOV            V7.2D, #1.0
    }
    float64x2_t v20 = (float64x2_t)vdupq_n_s64(0x3FB999999999999AuLL);
    float32x2_t v21 = 0;
    do
    {
      float v22 = v10[-5].f32[1] - *((float *)this + 52);
      float v23 = v10[-4].f32[0] - (float)(*((float *)this + 53) * *((float *)this + 33));
      float32x2_t v11 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B084300C39EC3, vcvt_n_s32_f32(v11, 0x18uLL), v12) & 0xFFFFFF00FFFFFFLL)), v13);
      v10[4] = 0;
      v10[5] = 0;
      float32x2_t v21 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x269EC3009E3779, vcvt_n_s32_f32(v21, 0x18uLL), (int32x2_t)0x343FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v13);
      float64x2_t v24 = vmulq_f64(vcvtq_f64_f32(vadd_f32(v21, (float32x2_t)0xBF000000BF000000)), _Q6);
      float32_t v25 = v24.f64[0] + v22;
      v26.f64[1] = *((float64_t *)&_Q7 + 1);
      v26.f64[0] = v23;
      float32x2_t v27 = vcvt_f32_f64(vaddq_f64(v24, v26));
      v10[-3].f32[1] = v25;
      v10[-2] = v27;
      float v28 = (float)(v22 * v22) + (float)(v23 * v23);
      v10[2].f32[0] = (float)(vmuls_lane_f32(0.015625, v11, 1) + (float)(sqrtf(v28) * 0.5)) * *((float *)this + 37);
      v10[2].i32[1] = 1065353216;
      v29.i32[0] = *((_DWORD *)this + 54);
      v29.f32[1] = -*((float *)this + 55);
      v10[3] = vcvt_f32_f64(vmulq_f64(vcvtq_f64_f32(v29), v20));
      v29.f32[0] = vmuls_lane_f32(0.0, v27, 1);
      *(float *)v24.f64 = v29.f32[0] - v27.f32[0];
      v29.f32[0] = v25 - v29.f32[0];
      *(float *)v26.f64 = (float)(0.0 * v27.f32[0]) - (float)(v25 * 0.0);
      float v30 = sqrtf((float)((float)(*(float *)v24.f64 * *(float *)v24.f64) + (float)(v29.f32[0] * v29.f32[0]))+ (float)(*(float *)v26.f64 * *(float *)v26.f64));
      *(float *)v24.f64 = *(float *)v24.f64 / v30;
      v29.f32[0] = v29.f32[0] / v30;
      *(float *)v26.f64 = *(float *)v26.f64 / v30;
      v10[-1].i32[1] = LODWORD(v24.f64[0]);
      v10->i32[0] = v29.i32[0];
      v10->i32[1] = LODWORD(v26.f64[0]);
      float32_t v31 = (vadd_f32(v11, v21).f32[0] * 0.25
           + (float)(1.0
                   - (float)((float)((float)(*(float *)v24.f64 * v25) + (float)(v29.f32[0] * v27.f32[0]))
                           + vmuls_lane_f32(*(float *)v26.f64, v27, 1))))
          * (float)((float)((float)(*((float *)this + 10) * *((float *)this + 11)) / (float)(v10[-4].f32[1] * 3.0))
                  + 0.75);
      v10[1].f32[0] = v31;
      v10[-1].f32[0] = 0.15 / sqrtf(v28 + 0.01);
      unint64_t v10 = (float32x2_t *)((char *)v10 + v9);
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::crumble(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  uint64_t v8 = (char *)this[8];
  if (v8)
  {
    uint64_t v9 = (char *)this[7];
    uint64_t v10 = 8 * *((int *)this + 31) + 84;
    if (*((unsigned char *)this + 145))
    {
      float32x2_t v11 = (float32x2_t *)(v9 + 36);
      float32x2_t v12 = 0;
      float v13 = 0.0;
      float32x2_t v14 = (float32x2_t)vdup_n_s32(0x33800000u);
      float32x2_t v15 = (float32x2_t)vdup_n_s32(0x3E4CCCCDu);
      do
      {
        float v16 = v11[-5].f32[1];
        float v17 = v11[-4].f32[0];
        float v13 = (float)((214013 * vcvts_n_s32_f32(v13, 0x18uLL) + 2531011) & 0xFFFFFF) * 0.000000059605;
        *(float32x2_t *)((char *)&v11[-3] + 4) = 0;
        v11[4] = 0;
        v11[5] = 0;
        v11[-2].i32[1] = 1065353216;
        v11[2].f32[0] = *((float *)this + 37)
                      * (float)((float)((float)(v13 * 0.4)
                                      + (float)(fabsf(v16)
                                              + (float)(*((float *)this + 33)
                                                      - (float)((float)(*((float *)this + 33) * 0.5) - v17))))
                              / (float)(*((float *)this + 33) + 1.1));
        v11[2].i32[1] = 1065353216;
        float32x2_t v12 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32(v12, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v14);
        float32x2_t v18 = vmul_f32(vadd_f32(v12, (float32x2_t)0xBF000000BF000000), v15);
        int32x2_t v19 = (int32x2_t)vmul_f32(v18, v18);
        *(float *)v19.i32 = sqrtf(*(float *)&v19.i32[1] + (float)(*(float *)v19.i32 + 1.0));
        v11[-1].f32[1] = -1.0 / *(float *)v19.i32;
        *float32x2_t v11 = vdiv_f32(v18, (float32x2_t)vdup_lane_s32(v19, 0));
        v11[-1].f32[0] = (float)(*((float *)this + 10) + *((float *)this + 11))
                       + (float)(*((float *)this + 10) + *((float *)this + 11));
        v11[1].i32[0] = 1082130432;
        float32x2_t v11 = (float32x2_t *)((char *)v11 + v10);
        --v8;
      }
      while (v8);
    }
    else
    {
      float64x2_t v20 = (float *)(v9 + 52);
      float v21 = 0.0;
      do
      {
        float v22 = *(v20 - 13);
        float v23 = *(v20 - 12);
        float v21 = (float)((214013 * vcvts_n_s32_f32(v21, 0x18uLL) + 2531011) & 0xFFFFFF) * 0.000000059605;
        *(void *)(v20 - 9) = 0;
        *((void *)v20 + 2) = 0;
        *((void *)v20 + 3) = 0;
        *(v20 - 7) = 1.0;
        *float64x2_t v20 = *((float *)this + 37)
             * (float)((float)((float)(v21 * 0.4)
                             + (float)(fabsf(v22) + (float)((float)(*((float *)this + 33) * 0.5) - v23)))
                     / (float)(*((float *)this + 33) + 1.1));
        v20[1] = 1.0;
        *(v20 - 6) = (float)(*((float *)this + 10) + *((float *)this + 11))
                   + (float)(*((float *)this + 10) + *((float *)this + 11));
        *(_OWORD *)(v20 - 5) = xmmword_1B83480C0;
        float64x2_t v20 = (float *)((char *)v20 + v10);
        --v8;
      }
      while (v8);
    }
  }
  return 0;
}

uint64_t HGFractured::Effect::swipe(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  uint64_t v9 = (char *)this[8];
  if (v9)
  {
    float v10 = -0.5;
    if (!*((unsigned char *)this + 145)) {
      float v10 = 0.5;
    }
    uint64_t v11 = 8 * *((int *)this + 31) + 84;
    uint64_t v12 = (uint64_t)this[7] + 40;
    float32x2_t v13 = 0;
    float32x2_t v14 = (float32x2_t)vdup_n_s32(0x33800000u);
    do
    {
      float v15 = *(float *)(v12 - 40);
      v8.i32[0] = *(_DWORD *)(v12 - 36);
      float32x2_t v13 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B084300269EC3, vcvt_n_s32_f32(v13, 0x18uLL), (int32x2_t)0xFD43FD000343FDLL) & 0xFFFFFF00FFFFFFLL)), v14);
      *(void *)(v12 + 36) = 0;
      *(void *)(v12 + 28) = 0;
      *(_DWORD *)(v12 - 24) = 1065353216;
      *(float *)v8.i32 = *(float *)v8.i32 + v10;
      float v16 = *((float *)this + 10) + *((float *)this + 11);
      float v17 = sqrtf((float)(v16 * v16) + (float)((float)(*(float *)v8.i32 * *(float *)v8.i32) + 1.0));
      *(float *)(v12 - 24) = 1.0 / v17;
      *(_DWORD *)(v12 - 20) = v8.i32[0];
      *(float *)(v12 - 20) = *(float *)v8.i32 / v17;
      *(float *)(v12 - 16) = v16 / v17;
      *(float *)(v12 + 12) = (float)(0.05 * v13.f32[0]) + (float)((float)(v15 + 0.5) * 0.5);
      *(void *)(v12 + 16) = 1065353216;
      *(_DWORD *)(v12 + 24) = 0;
      *(float *)v8.i32 = sqrtf(vmuls_lane_f32(v13.f32[1], v13, 1) + 1.0);
      float v18 = v13.f32[1] / *(float *)v8.i32;
      int32x2_t v8 = (int32x2_t)vdiv_f32((float32x2_t)0x3F80000000000000, (float32x2_t)vdup_lane_s32(v8, 0));
      *(int32x2_t *)(v12 - 8) = v8;
      *(float *)uint64_t v12 = v18;
      float v19 = (float)(*((float *)this + 10) * *((float *)this + 11)) / (float)(*(float *)(v12 - 32) * 4.0);
      *(float *)(v12 - 12) = v19 + 1.0;
      *(float *)(v12 + 4) = v19 + 4.0;
      v12 += v11;
      --v9;
    }
    while (v9);
  }
  return 0;
}

float *(*HGFractured::Effect::vortex(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7))(float *this, HGFractured::Effect *a2, __n128 a3, int a4, __n128 a5, double a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, double a10, double a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1088421888;
  uint64_t v9 = (char *)this[8];
  if (v9)
  {
    uint64_t v10 = 8 * *((int *)this + 31) + 84;
    uint64_t v11 = (uint64_t)this[7] + 36;
    float32x2_t v12 = 0;
    float32x2_t v13 = (float32x2_t)vdup_n_s32(0x33800000u);
    do
    {
      LODWORD(v8) = *(_DWORD *)(v11 - 36);
      float v14 = *(float *)(v11 - 32);
      long long v23 = v8;
      float32x2_t v24 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B084300269EC3, vcvt_n_s32_f32(v12, 0x18uLL), (int32x2_t)0xFD43FD000343FDLL) & 0xFFFFFF00FFFFFFLL)), v13);
      *(void *)(v11 + 32) = 0;
      *(void *)(v11 + 40) = 0;
      float v15 = (float)(*(float *)&v8 * *(float *)&v8) + (float)(v14 * v14);
      float v16 = sqrtf(v15) * 10.0;
      float v17 = atan2f(v14, *(float *)&v8);
      if (v17 < 0.0) {
        float v17 = 6.2832 - v17;
      }
      float v18 = fmodf(v24.f32[0] + v17, 6.2832);
      long long v8 = v23;
      float32x2_t v12 = v24;
      *(float *)(v11 + 16) = vmuls_lane_f32(0.05, v24, 1) + (float)((float)((float)(v16 * 6.2832) + v18) / 62.832);
      *(void *)(v11 - 20) = 0x41200000BE4CCCCDLL;
      *(_DWORD *)(v11 - 12) = -1071644672;
      *(void *)(v11 + 20) = 1065353216;
      *(_DWORD *)(v11 + 28) = 0;
      *(float *)v19.i32 = sqrtf(v15 + 0.01);
      *(float *)(v11 - 4) = v14 / *(float *)v19.i32;
      v20.i32[0] = 1036831949;
      float32x2_t v21 = (float32x2_t)vdup_lane_s32(v20, 0);
      v21.i32[0] = v23;
      *(float32x2_t *)uint64_t v11 = vdiv_f32(v21, (float32x2_t)vdup_lane_s32(v19, 0));
      *(float *)v19.i32 = (float)((float)(*((float *)this + 10) * *((float *)this + 11)) / *(float *)(v11 - 28)) + 0.75;
      *(_DWORD *)(v11 - 8) = v19.i32[0];
      *(_DWORD *)(v11 + 8) = v19.i32[0];
      v11 += v10;
      --v9;
    }
    while (v9);
  }
  return HGFractured::Effect::apply_polar;
}

uint64_t HGFractured::Effect::flip(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  if (*((_DWORD *)this + 41) != 4 || (LODWORD(a3) = *((_DWORD *)this + 12), *(float *)&a3 != 0.0))
  {
    *((_DWORD *)this + 41) = 4;
    *((unsigned char *)this + 157) = 0;
    *((_DWORD *)this + 12) = 0;
    *((_DWORD *)this + 30) |= 7u;
  }
  HGFractured::Effect::build((void **)this, -1, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  uint64_t v8 = *((void *)this + 8);
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    uint64_t v10 = (float *)(*((void *)this + 7) + 68);
    float v11 = 0.0;
    do
    {
      float v12 = *(v10 - 17);
      float v11 = (float)((214013 * vcvts_n_s32_f32(v11, 0x18uLL) + 2531011) & 0xFFFFFF) * 0.000000059605;
      *(void *)(v10 - 11) = 0;
      *(void *)(v10 - 13) = 0;
      *(v10 - 9) = 0.0;
      *(void *)uint64_t v10 = 0;
      *((void *)v10 + 1) = 0;
      *((void *)v10 - 4) = 1065353216;
      *(v10 - 6) = 1.0;
      *(v10 - 4) = (float)(v11 * 0.25) + (float)((float)(v12 + 0.5) * 0.25);
      *(void *)(v10 - 3) = 1056964608;
      *(v10 - 1) = 0.0;
      uint64_t v10 = (float *)((char *)v10 + v9);
      --v8;
    }
    while (v8);
  }
  return 0;
}

float *(*HGFractured::Effect::whirl(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7))(float *result, float a2, int a3)
{
  HGFractured::Effect::build(this, 1, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  uint64_t v8 = (char *)this[8];
  if (v8)
  {
    uint64_t v9 = (char *)this[7];
    uint64_t v10 = 8 * *((int *)this + 31) + 84;
    float v11 = v9 + 44;
    do
    {
      int v12 = *((_DWORD *)v11 - 10);
      if ((*((_DWORD *)v11 - 8) & 4) != 0) {
        float v13 = -1.0;
      }
      else {
        float v13 = 1.0;
      }
      __double2 v14 = __sincos_stret(*((float *)v11 - 11) * 3.14159265);
      float v15 = v14.__sinval * 0.5;
      *((void *)v11 + 3) = 0;
      *((void *)v11 + 4) = 0;
      *((float *)v11 - 7) = v15;
      *((_DWORD *)v11 - 6) = v12;
      float v16 = v14.__cosval * (float)(v13 * 0.5);
      *((float *)v11 - 5) = v16;
      *((_OWORD *)v11 - 1) = xmmword_1B7E77490;
      *(float *)float v11 = v13;
      *(_OWORD *)(v11 + 8) = xmmword_1B7E736C0;
      v11 += v10;
      --v8;
    }
    while (v8);
  }
  return apply_whirl;
}

uint64_t HGFractured::Effect::shutter(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  *((_DWORD *)this + 35) = -1;
  HGFractured::Effect::build((void **)this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  uint64_t v8 = *((void *)this + 8);
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    uint64_t v10 = (float *)(*((void *)this + 7) + 80);
    if (*((unsigned char *)this + 145))
    {
      do
      {
        float v11 = *((float *)this + 11) * -0.5;
        *(void *)(v10 - 3) = 0;
        *(v10 - 1) = v11;
        *uint64_t v10 = 0.0;
        *(_OWORD *)(v10 - 7) = xmmword_1B7E736C0;
        *((_OWORD *)v10 - 4) = xmmword_1B7E736D0;
        *((_OWORD *)v10 - 3) = xmmword_1B83480D0;
        uint64_t v10 = (float *)((char *)v10 + v9);
        --v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        float v12 = *((float *)this + 11) * -0.5;
        *(void *)(v10 - 3) = 0;
        *(v10 - 1) = v12;
        *uint64_t v10 = 0.0;
        *(_OWORD *)(v10 - 7) = xmmword_1B7E736C0;
        *((_OWORD *)v10 - 4) = xmmword_1B7E736D0;
        *((_OWORD *)v10 - 3) = xmmword_1B83480E0;
        uint64_t v10 = (float *)((char *)v10 + v9);
        --v8;
      }
      while (v8);
    }
  }
  return 0;
}

uint64_t HGFractured::Effect::evaporate(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  HGFractured::Effect::build((void **)this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  uint64_t v8 = *((void *)this + 8);
  if (v8)
  {
    int v9 = *((unsigned __int8 *)this + 145);
    uint64_t v10 = 8 * *((int *)this + 31) + 84;
    uint64_t v11 = *((void *)this + 7) + 36;
    float32x4_t v12 = 0uLL;
    float32x4_t v13 = (float32x4_t)vdupq_n_s32(0x33800000u);
    do
    {
      float v17 = *(float *)(v11 - 32);
      float32x4_t v12 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)(*(_OWORD *)&vmlaq_s32((int32x4_t)xmmword_1B8348100, vcvtq_n_s32_f32(v12, 0x18uLL), (int32x4_t)xmmword_1B83480F0) & __PAIR128__(0xFFFFFF00FFFFFFLL, 0xFFFFFF00FFFFFFLL))), v13);
      float v18 = (float)((float)(v12.f32[0] + -0.5) * 0.5) - *(float *)(v11 - 36);
      float v19 = (float)((float)((float)(v12.f32[2] + v12.f32[1]) + -1.0) * 0.25) + v17;
      *(void *)(v11 + 32) = 0;
      *(void *)(v11 + 40) = 0;
      if ((*(_DWORD *)(v11 - 24) & 8) != 0) {
        float v20 = -0.25;
      }
      else {
        float v20 = 0.25;
      }
      float v21 = sqrtf((float)((float)(v18 * v18) + (float)(v19 * v19)) + 0.0625);
      *(float *)(v11 - 20) = v18 / v21;
      *(float *)(v11 - 16) = v19 / v21;
      *(float *)(v11 - 12) = v20 / v21;
      *(_DWORD *)(v11 - 8) = 1065353216;
      *(_DWORD *)(v11 + 20) = 1065353216;
      float v22 = vmuls_lane_f32(0.5, *(float32x2_t *)v12.f32, 1) + 0.0;
      float v23 = vmuls_lane_f32(0.5, v12, 2);
      if (v9)
      {
        float v14 = v17 + 0.5;
        float v15 = -1.0 - v12.f32[0];
      }
      else
      {
        float v14 = 0.5 - v17;
        float v15 = v12.f32[0] + 1.0;
      }
      float v16 = sqrtf((float)(v23 * v23) + (float)((float)(v15 * v15) + (float)(v22 * v22)));
      *(float *)(v11 + 16) = (float)((float)(v14 + vmuls_lane_f32(*((float *)this + 37), v12, 3))
                                   / (float)(*((float *)this + 37) + 1.0))
                           * 0.4;
      *(float *)(v11 - 4) = v15 / v16;
      *(float *)uint64_t v11 = v22 / v16;
      *(float *)(v11 + 4) = v23 / v16;
      *(float *)(v11 + 8) = (float)(v12.f32[3]
                                  + (float)(*(float *)(v11 - 28) / (float)(*((float *)this + 10) * *((float *)this + 11))))
                          * 4.0;
      v11 += v10;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::explode(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1088421888;
  uint64_t v8 = (char *)this[8];
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    uint64_t v10 = (uint64_t)this[7] + 36;
    float32x4_t v11 = 0uLL;
    float32x4_t v27 = (float32x4_t)vdupq_n_s32(0x33800000u);
    do
    {
      float v21 = *(float *)(v10 - 36);
      float v22 = *(float *)(v10 - 32);
      float32x4_t v23 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)(*(_OWORD *)&vmlaq_s32((int32x4_t)xmmword_1B8348100, vcvtq_n_s32_f32(v11, 0x18uLL), (int32x4_t)xmmword_1B83480F0) & __PAIR128__(0xFFFFFF00FFFFFFLL, 0xFFFFFF00FFFFFFLL))), v27);
      *(void *)(v10 + 32) = 0;
      *(void *)(v10 + 40) = 0;
      float v24 = (float)((float)(v23.f32[0] + -0.5) * 0.25) + v21;
      float32x4_t v28 = v23;
      if ((*(unsigned char *)(v10 - 24) & 8) != 0)
      {
        float v24 = v24 * 16.0;
        float v12 = (float)((float)((float)(v23.f32[1] + -0.5) * 0.25) + v22) * 16.0;
        long double v25 = cos(v21 * 3.14159265);
        float32x4_t v11 = v28;
        double v14 = (float)((float)(v28.f32[2] + -0.5) * 0.25) + v25 * -4.0;
      }
      else
      {
        float v12 = (float)((float)(v23.f32[1] + -0.5) * 0.25) + v22;
        long double v13 = cos(v21 * 3.14159265);
        float32x4_t v11 = v28;
        double v14 = v13 + (float)((float)(v28.f32[2] + -0.5) * 0.25);
      }
      float v15 = v14;
      *(float *)(v10 - 20) = v24;
      *(float *)(v10 - 16) = v12;
      *(float *)(v10 - 12) = v15;
      *(_DWORD *)(v10 - 8) = 1069547520;
      *(float *)(v10 + 16) = vmuls_lane_f32(*((float *)this + 37) * 0.5, v11, 3);
      *(void *)(v10 + 20) = 1065353216;
      *(_DWORD *)(v10 + 28) = 0;
      float v16 = v15 * 0.0;
      float v17 = v16 - v12;
      float v18 = v24 - v16;
      float v19 = (float)(v12 * 0.0) - (float)(v24 * 0.0);
      float v20 = sqrtf((float)((float)(v17 * v17) + (float)(v18 * v18)) + (float)(v19 * v19));
      *(float *)(v10 - 4) = v17 / v20;
      *(float *)uint64_t v10 = v18 / v20;
      *(float *)(v10 + 4) = v19 / v20;
      *(float *)(v10 + 8) = (float)((float)(*((float *)this + 10) * *((float *)this + 11)) * 4.0) / *(float *)(v10 - 28);
      v10 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::pulverize(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1084227584;
  uint64_t v8 = (char *)this[8];
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    uint64_t v10 = (uint64_t)this[7] + 36;
    float32x2_t v11 = 0;
    float32x2_t v12 = (float32x2_t)vdup_n_s32(0x33800000u);
    __asm { FMOV            V16.2S, #4.0 }
    float32x2_t v18 = 0;
    do
    {
      float32x2_t v18 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B084300269EC3, vcvt_n_s32_f32(v18, 0x18uLL), (int32x2_t)0xFD43FD000343FDLL) & 0xFFFFFF00FFFFFFLL)), v12);
      float32x2_t v11 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32(v11, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v12);
      float32x2_t v19 = vadd_f32(v11, (float32x2_t)0xBF000000BF000000);
      float32x2_t v20 = vmul_f32(v19, v19);
      v20.f32[0] = sqrtf((float)((float)(v18.f32[0] + -0.5) * (float)(v18.f32[0] + -0.5)) + vaddv_f32(v20));
      *(void *)(v10 + 32) = 0;
      *(void *)(v10 + 40) = 0;
      float32x2_t v21 = vmul_f32(vdiv_f32(v19, (float32x2_t)vdup_lane_s32((int32x2_t)v20, 0)), _D16);
      float v22 = (float)((float)(v18.f32[0] + -0.5) / v20.f32[0]) * 4.0;
      *(float32x2_t *)(v10 - 20) = v21;
      *(float *)(v10 - 12) = v22;
      *(_DWORD *)(v10 - 8) = 1065353216;
      float v23 = v22 * 0.0;
      v20.f32[0] = v23 - v21.f32[1];
      float v24 = v21.f32[0] - v23;
      v21.f32[0] = vmuls_lane_f32(0.0, v21, 1) - (float)(0.0 * v21.f32[0]);
      float v25 = *((float *)this + 37) * 0.5;
      *(void *)(v10 + 20) = 1065353216;
      *(_DWORD *)(v10 + 28) = 0;
      float v26 = sqrtf((float)((float)(v20.f32[0] * v20.f32[0]) + (float)(v24 * v24)) + (float)(v21.f32[0] * v21.f32[0]));
      *(float *)(v10 - 4) = v20.f32[0] / v26;
      *(float *)uint64_t v10 = v24 / v26;
      *(float *)(v10 + 4) = v21.f32[0] / v26;
      v21.f32[0] = *((float *)this + 10) * *((float *)this + 11);
      *(float *)(v10 + 16) = vmuls_lane_f32(v25, v18, 1);
      *(float *)(v10 + 8) = (float)(v21.f32[0] * 4.0) / *(float *)(v10 - 28);
      v10 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

float *(*HGFractured::Effect::twirl(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7))(float *result, float a2, int a3)
{
  HGFractured::Effect::build(this, 1, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  uint64_t v8 = (char *)this[8];
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    uint64_t v10 = (uint64_t)this[7] + 44;
    float v11 = 0.0;
    do
    {
      float v11 = (float)((12268885 * vcvts_n_s32_f32(v11, 0x18uLL) + 10368889) & 0xFFFFFF) * 0.000000059605;
      if ((*(_DWORD *)(v10 - 32) & 8) != 0) {
        float v12 = -1.0;
      }
      else {
        float v12 = 1.0;
      }
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0;
      *(void *)(v10 - 28) = *(void *)(v10 - 44);
      *(float *)(v10 - 20) = v11 * v12;
      *(_OWORD *)(v10 - 16) = xmmword_1B7E77490;
      *(float *)uint64_t v10 = v12;
      *(_OWORD *)(v10 + 8) = xmmword_1B7E736C0;
      v10 += v9;
      --v8;
    }
    while (v8);
  }
  return apply_twirl;
}

uint64_t HGFractured::Effect::spread(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  HGFractured::Effect::build((void **)this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1088421888;
  uint64_t v8 = *((void *)this + 8);
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    uint64_t v10 = *((void *)this + 7) + 52;
    float32x2_t v11 = 0;
    float32x2_t v12 = (float32x2_t)vdup_n_s32(0x33800000u);
    float64x2_t v13 = (float64x2_t)vdupq_n_s64(0x3FB999999999999AuLL);
    int32x2_t v14 = 0;
    do
    {
      while (1)
      {
        float32x2_t v11 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B084300269EC3, vcvt_n_s32_f32(v11, 0x18uLL), (int32x2_t)0xFD43FD000343FDLL) & 0xFFFFFF00FFFFFFLL)), v12);
        *(void *)(v10 + 16) = 0;
        *(void *)(v10 + 24) = 0;
        int32x2_t v14 = (int32x2_t)vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32((float32x2_t)v14, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v12);
        *(float32x2_t *)(v10 - 36) = vcvt_f32_f64(vaddq_f64(vmulq_f64(vcvtq_f64_f32(vadd_f32((float32x2_t)v14, (float32x2_t)0xBF000000BF000000)), v13), vcvtq_f64_f32(*(float32x2_t *)(v10 - 52))));
        *(_DWORD *)(v10 - 28) = 0;
        if (vadd_f32(v11, vadd_f32((float32x2_t)vdup_lane_s32(v14, 1), (float32x2_t)v14)).f32[0] > 1.5) {
          break;
        }
        float v15 = vmuls_lane_f32(*((float *)this + 37), v11, 1);
        *(_DWORD *)(v10 - 28) = v11.i32[0];
        *(float *)(v10 - 24) = v15 + 1.0;
        *(_OWORD *)uint64_t v10 = xmmword_1B7E73450;
        *(_OWORD *)(v10 - 20) = xmmword_1B7E736B0;
        v10 += v9;
        if (!--v8) {
          return 0;
        }
      }
      float v16 = vmuls_lane_f32(*((float *)this + 37), v11, 1);
      *(float *)(v10 - 28) = -v11.f32[0];
      *(float *)(v10 - 24) = (float)(v16 + 1.0) * 4.0;
      *(_OWORD *)uint64_t v10 = xmmword_1B7E73450;
      *(_OWORD *)(v10 - 20) = xmmword_1B7E736B0;
      v10 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::rotate(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  HGFractured::Effect::build(this, 1, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  uint64_t v8 = (char *)this[8];
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    float v10 = 1.0;
    if (!*((unsigned char *)this + 145)) {
      float v10 = -1.0;
    }
    uint64_t v11 = (uint64_t)this[7] + 36;
    float v12 = 0.0;
    do
    {
      float v13 = *(float *)(v11 - 32);
      float v12 = (float)((16598013 * vcvts_n_s32_f32(v12, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      *(void *)(v11 + 32) = 0;
      *(void *)(v11 + 40) = 0;
      *(_OWORD *)(v11 - 20) = xmmword_1B7E736D0;
      *(_DWORD *)(v11 - 4) = 0;
      *(float *)uint64_t v11 = v10;
      *(void *)(v11 + 4) = 0x3F80000000000000;
      float v14 = (float)((float)(v13 / *((float *)this + 33)) + 0.5) * 0.5;
      *(float *)(v11 + 16) = v14 + (float)(*((float *)this + 37) * (float)((float)(v12 * 0.5) - v14));
      *(void *)(v11 + 20) = 1056964608;
      *(_DWORD *)(v11 + 28) = 0;
      v11 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::blocks(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  HGFractured::Effect::build(this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1088421888;
  uint64_t v8 = (char *)this[8];
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    uint64_t v10 = (uint64_t)this[7] + 52;
    float32x2_t v11 = 0;
    float32x2_t v12 = (float32x2_t)vdup_n_s32(0x33800000u);
    do
    {
      float32x2_t v11 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v11, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v12);
      *(void *)(v10 - 36) = 0;
      *(void *)(v10 + 16) = 0;
      *(void *)(v10 + 24) = 0;
      *(_DWORD *)(v10 - 28) = 1065353216;
      *(float *)(v10 - 24) = v11.f32[0] + 2.0;
      *(_OWORD *)(v10 - 20) = xmmword_1B7E736D0;
      *(float *)uint64_t v10 = vmuls_lane_f32(*((float *)this + 37) * 0.5, v11, 1);
      *(void *)(v10 + 4) = 1069547520;
      *(_DWORD *)(v10 + 12) = 0;
      v10 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::bars(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  *((_DWORD *)this + 35) = -1;
  HGFractured::Effect::build((void **)this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  uint64_t v8 = *((void *)this + 8);
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    float v10 = -1.0;
    if (!*((unsigned char *)this + 145)) {
      float v10 = 1.0;
    }
    uint64_t v11 = *((void *)this + 7) + 44;
    float v12 = 0.0;
    do
    {
      float v13 = *(float *)(v11 - 44);
      float v12 = (float)((16598013 * vcvts_n_s32_f32(v12, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      float v14 = (float)(*((float *)this + 33) - *((float *)this + 34)) * -0.5;
      *(void *)(v11 + 24) = 0;
      *(float *)(v11 + 32) = v14;
      *(_DWORD *)(v11 + 36) = 0;
      *(_OWORD *)(v11 - 28) = xmmword_1B7E736D0;
      *(float *)(v11 + 8) = (float)((float)(v13 + 0.5) * 0.5)
                          + (float)((float)((float)(v12 * 0.5) - (float)((float)(v13 + 0.5) * 0.5))
                                  * *((float *)this + 37));
      *(void *)(v11 + 12) = 1056964608;
      *(_DWORD *)(v11 + 20) = 0;
      *(float *)(v11 - 12) = v10;
      *(void *)(v11 - 8) = 0;
      *(_DWORD *)uint64_t v11 = 1056964608;
      v11 += v9;
      --v8;
    }
    while (v8);
  }
  return 0;
}

uint64_t HGFractured::Effect::cube(HGFractured::Effect *this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7)
{
  *((_DWORD *)this + 35) = -1;
  HGFractured::Effect::build((void **)this, 0, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 0x40000000;
  uint64_t v8 = *((void *)this + 8);
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    float v10 = (float *)(*((void *)this + 7) + 80);
    if (*((unsigned char *)this + 145))
    {
      do
      {
        float v11 = (float)(1.0 - *((float *)this + 34)) * -0.5;
        *(void *)(v10 - 3) = 0;
        *(v10 - 1) = v11;
        *float v10 = 0.0;
        *(_OWORD *)(v10 - 7) = xmmword_1B7E736C0;
        *((_OWORD *)v10 - 4) = xmmword_1B7E736D0;
        *((_OWORD *)v10 - 3) = xmmword_1B8348110;
        float v10 = (float *)((char *)v10 + v9);
        --v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        float v12 = (float)(1.0 - *((float *)this + 34)) * -0.5;
        *(void *)(v10 - 3) = 0;
        *(v10 - 1) = v12;
        *float v10 = 0.0;
        *(_OWORD *)(v10 - 7) = xmmword_1B7E736C0;
        *((_OWORD *)v10 - 4) = xmmword_1B7E736D0;
        *((_OWORD *)v10 - 3) = xmmword_1B8348120;
        float v10 = (float *)((char *)v10 + v9);
        --v8;
      }
      while (v8);
    }
  }
  return 0;
}

float *(*HGFractured::Effect::test(void **this, HGFractured::Effect *a2, double a3, double a4, double a5, double a6, int32x2_t a7))(float *result, float a2, int a3)
{
  HGFractured::Effect::build(this, 1, 0, a3, a4, a5, a6, a7);
  *((_DWORD *)this + 38) = 1084227584;
  uint64_t v8 = (char *)this[8];
  if (v8)
  {
    uint64_t v9 = 8 * *((int *)this + 31) + 84;
    float v10 = 1.0;
    if (!*((unsigned char *)this + 145)) {
      float v10 = -1.0;
    }
    uint64_t v11 = (uint64_t)this[7] + 36;
    float v12 = 0.0;
    do
    {
      float v13 = *(float *)(v11 - 32);
      float v12 = (float)((16598013 * vcvts_n_s32_f32(v12, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      *(void *)(v11 + 32) = 0;
      *(void *)(v11 + 40) = 0;
      *(_OWORD *)(v11 - 20) = xmmword_1B7E736D0;
      *(_DWORD *)(v11 - 4) = 0;
      *(float *)uint64_t v11 = v10;
      *(void *)(v11 + 4) = 0x3F80000000000000;
      float v14 = (float)((float)(v13 / *((float *)this + 33)) + 0.5) * 0.5;
      *(float *)(v11 + 16) = v14 + (float)(*((float *)this + 37) * (float)((float)(v12 * 0.5) - v14));
      *(void *)(v11 + 20) = 1056964608;
      *(_DWORD *)(v11 + 28) = 0;
      v11 += v9;
      --v8;
    }
    while (v8);
  }
  return apply_test;
}

HGSynchronizable *HGFractured::Effect::SetState(uint64_t a1, int a2)
{
  float v4 = *(HGSynchronizable **)(a1 + 248);
  HGSynchronizable::Lock(v4);
  *(_DWORD *)(a1 + 240) = a2;
  return HGSynchronizable::Unlock(v4);
}

uint64_t HGFractured::Effect::GetState(HGFractured::Effect *this)
{
  float v2 = (HGSynchronizable *)*((void *)this + 31);
  HGSynchronizable::Lock(v2);
  uint64_t v3 = *((unsigned int *)this + 60);
  HGSynchronizable::Unlock(v2);
  return v3;
}

uint64_t HGFractured::Effect::init(HGFractured::Effect *this, double a2, double a3, double a4, double a5, int32x2_t a6)
{
  int v6 = *((_DWORD *)this + 30);
  if (v6)
  {
    switch(*((_DWORD *)this + 41))
    {
      case 0xFFFFFFFD:
        HGFractured::Effect::gen_brick(this, *((_DWORD *)this + 8), *((_DWORD *)this + 9), *((float *)this + 33), *((float *)this + 12));
        goto LABEL_21;
      case 0xFFFFFFFE:
        float v13 = *((float *)this + 12);
        int v14 = *((_DWORD *)this + 8);
        int v15 = *((_DWORD *)this + 9);
        float v16 = *((float *)this + 33);
        if (v13 == 0.0) {
          HGFractured::Effect::gen_glass(this, v14, v15, v16);
        }
        else {
          HGFractured::Effect::gen_glass(this, v14, v15, v16, v13);
        }
        goto LABEL_21;
      case 0xFFFFFFFF:
        float v17 = *((float *)this + 12);
        int v18 = *((_DWORD *)this + 8);
        int v19 = *((_DWORD *)this + 9);
        float v20 = *((float *)this + 33);
        if (v17 == 0.0) {
          HGFractured::Effect::gen_glass_2(this, v18, v19, v20);
        }
        else {
          HGFractured::Effect::gen_glass_2((uint64_t)this, v18, v19, v20, v17, a4, a5, a6);
        }
        goto LABEL_21;
      case 0:
      case 1:
        float v8 = *((float *)this + 12);
        int v9 = *((_DWORD *)this + 8);
        int v10 = *((_DWORD *)this + 9);
        float v11 = *((float *)this + 33);
        if (v8 == 0.0) {
          HGFractured::Effect::gen_point(this, v9, v10, v11);
        }
        else {
          HGFractured::Effect::gen_point(this, v9, v10, v11, v8);
        }
        int v12 = 1;
        goto LABEL_22;
      case 3:
        float v21 = *((float *)this + 12);
        int v22 = *((_DWORD *)this + 8);
        int v23 = *((_DWORD *)this + 9);
        float v24 = *((float *)this + 33);
        if (v21 == 0.0) {
          HGFractured::Effect::gen_tri(this, v22, v23, v24);
        }
        else {
          HGFractured::Effect::gen_tri(this, v22, v23, v24, v21);
        }
        int v12 = 3;
        goto LABEL_22;
      case 4:
        float v25 = *((float *)this + 12);
        int v26 = *((_DWORD *)this + 8);
        int v27 = *((_DWORD *)this + 9);
        float v28 = *((float *)this + 33);
        if (v25 == 0.0) {
          HGFractured::Effect::gen_quad(this, v26, v27, v28);
        }
        else {
          HGFractured::Effect::gen_quad(this, v26, v27, v28, v25);
        }
LABEL_21:
        int v12 = 4;
LABEL_22:
        *((_DWORD *)this + 31) = v12;
        break;
      default:
        break;
    }
    *((_DWORD *)this + 30) &= ~1u;
  }
  return v6 & 1;
}

void *HGFractured::Effect::gen_point(void *this, int a2, int a3, float a4, float a5)
{
  int v9 = this;
  uint64_t v10 = a3 * (uint64_t)a2;
  size_t v11 = 92 * v10;
  if (this[2] < (unint64_t)(92 * v10))
  {
    int v12 = (void *)this[7];
    v9[2] = v11;
    this = malloc_type_realloc(v12, v11, 0xACDDD8C9uLL);
    v9[7] = this;
  }
  v9[8] = v10;
  if (a3 >= 1 && a2 >= 1)
  {
    int v13 = 0;
    float v14 = 1.0 / (float)a2;
    float v15 = a4 / (float)a3;
    uint64_t v16 = v9[7];
    float32x2_t v17 = 0;
    float v18 = 0.0;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x33800000u);
    do
    {
      int v20 = 0;
      do
      {
        float32x2_t v17 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32(v17, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v19);
        float v18 = (float)((16598013 * vcvts_n_s32_f32(v18, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        *(float *)uint64_t v16 = (float)((float)(v14 * (float)((float)v20 + 0.5)) + -0.5)
                      + (float)((float)(v14 * a5) * (float)(v17.f32[0] + -0.5));
        *(float *)(v16 + 4) = (float)((float)(v15 * (float)((float)v13 + 0.5)) - (float)(a4 * 0.5))
                            + (float)((float)(v15 * a5) * (float)(v17.f32[1] + -0.5));
        *(void *)(v16 + 84) = *(void *)v16;
        *(float *)(v16 + 8) = v14 * v15;
        *(_DWORD *)(v16 + 12) = v20 & 1 | (2 * (v13 & 1)) & 0xFB | (4 * ((v20 ^ v13) & 1)) | (8 * (v18 < 0.5));
        v16 += 92;
        ++v20;
      }
      while (a2 != v20);
      ++v13;
    }
    while (v13 != a3);
  }
  return this;
}

void *HGFractured::Effect::gen_point(void *this, int a2, int a3, float a4)
{
  unint64_t v7 = this;
  uint64_t v8 = a3 * (uint64_t)a2;
  size_t v9 = 92 * v8;
  if (this[2] < (unint64_t)(92 * v8))
  {
    uint64_t v10 = (void *)this[7];
    v7[2] = v9;
    this = malloc_type_realloc(v10, v9, 0x52DE36EEuLL);
    v7[7] = this;
  }
  v7[8] = v8;
  if (a3 >= 1 && a2 >= 1)
  {
    int v11 = 0;
    float v12 = 1.0 / (float)a2;
    float v13 = a4 / (float)a3;
    uint64_t v14 = v7[7];
    float v15 = 0.0;
    do
    {
      int v16 = 0;
      do
      {
        float v15 = (float)((16598013 * vcvts_n_s32_f32(v15, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        *(float *)uint64_t v14 = (float)(v12 * (float)((float)v16 + 0.5)) + -0.5;
        *(float *)(v14 + 4) = (float)(v13 * (float)((float)v11 + 0.5)) - (float)(a4 * 0.5);
        *(void *)(v14 + 84) = *(void *)v14;
        *(float *)(v14 + 8) = v12 * v13;
        *(_DWORD *)(v14 + 12) = v16 & 1 | (2 * (v11 & 1)) & 0xFB | (4 * ((v16 ^ v11) & 1)) | (8 * (v15 < 0.5));
        v14 += 92;
        ++v16;
      }
      while (a2 != v16);
      ++v11;
    }
    while (v11 != a3);
  }
  return this;
}

float *HGFractured::Effect::gen_tri(HGFractured::Effect *this, int a2, int a3, float a4, float a5)
{
  uint64_t v10 = a2 * (uint64_t)a3;
  uint64_t v11 = 2 * v10;
  size_t v12 = 216 * v10;
  size_t v13 = *((void *)this + 2);
  float result = (float *)*((void *)this + 7);
  if (v13 < v12)
  {
    *((void *)this + 2) = v12;
    float result = (float *)malloc_type_realloc(result, v12, 0xBA50F26uLL);
    *((void *)this + 7) = result;
  }
  *((void *)this + 8) = v11;
  float v15 = 1.0 / (float)a2;
  float v16 = a4 * 0.5;
  float v17 = v15 * a5;
  if (a3 >= 2)
  {
    float v18 = a4 / (float)a3;
    float v19 = v18 * a5;
    float v20 = -v16;
    float v21 = v15 + -0.5;
    float v22 = v18 - v16;
    float v23 = (float)(v18 - v16) + (float)((float)(v18 * a5) * 0.26414);
    int v24 = a2 - 1;
    float v25 = (float)-v16 - v16;
    float v26 = v16 - v16;
    if (a2 < 2)
    {
      int v41 = 0;
      float32x2_t v42 = (float32x2_t)0x3D95DBD03CB5F4C0;
      float v40 = 0.35764;
      float v34 = -0.5;
      float v32 = -0.5;
      float32_t v31 = result;
    }
    else
    {
      int v27 = 0;
      float32x2_t v28 = (float32x2_t)0x3E2C210C3F1E3779;
      float32x2_t v29 = (float32x2_t)0x3E1A7B0C3F439EC3;
      float32x2_t v30 = (float32x2_t)vdup_n_s32(0x33800000u);
      float32_t v31 = result;
      float v32 = -0.5;
      float v33 = v15 + -0.5;
      float v34 = -0.5;
      do
      {
        float v35 = v34;
        float v36 = v23;
        float v37 = v32;
        float32x2_t v29 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x269EC300C39EC3, vcvt_n_s32_f32(v29, 0x18uLL), (int32x2_t)0x343FD00FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v30);
        float32x2_t v28 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v28, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v30);
        v31[21] = v32;
        v31[22] = v20;
        float v32 = v33 + (float)(v17 * (float)(v29.f32[1] + -0.5));
        v31[23] = v32;
        v31[24] = v20;
        float v38 = v33 + (float)(v17 * (float)(v28.f32[0] + -0.5));
        float v23 = v22 + (float)(v19 * (float)(v29.f32[0] + -0.5));
        v31[25] = v38;
        v31[26] = v23;
        *float32_t v31 = (float)((float)(v37 + v32) + v38) * 0.33333;
        v31[1] = (float)(v25 + v23) * 0.33333;
        v31[2] = vabds_f32((float)(v32 - v37) * (float)(v23 + v16), v26 * (float)(v38 - v37)) * 0.5;
        *((_DWORD *)v31 + 3) = v27 & 1 | (8 * (v28.f32[1] < 0.5));
        uint64_t v39 = *(void *)(v31 + 25);
        *((void *)v31 + 24) = v39;
        float v34 = *(float *)&v39;
        v31[50] = v35;
        v31[51] = v36;
        v31[52] = v37;
        v31[53] = v20;
        v31[27] = (float)(v37 + (float)(v35 + *(float *)&v39)) * 0.33333;
        v31[28] = (float)((float)(v36 + *((float *)&v39 + 1)) - v16) * 0.33333;
        v31[29] = vabds_f32((float)(v35 - *(float *)&v39) * (float)(v20 - *((float *)&v39 + 1)), (float)(v36 - *((float *)&v39 + 1)) * (float)(v37 - *(float *)&v39))* 0.5;
        *((_DWORD *)v31 + 30) = v27 & 1 | (8 * (v28.f32[1] >= 0.5)) | 4;
        float v33 = (float)(v15 * (float)(v27 + 2)) + -0.5;
        v31 += 54;
        ++v27;
      }
      while (v24 != v27);
      float v40 = (float)((16598013 * vcvts_n_s32_f32(v29.f32[0], 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
      int v41 = v24 & 1;
      float32x2_t v42 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v28, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), (float32x2_t)vdup_n_s32(0x33800000u));
    }
    float v69 = v19 * (float)(v40 + -0.5);
    v31[21] = v32;
    v31[22] = v20;
    v31[23] = 0.5;
    v31[24] = v20;
    v31[25] = 0.5;
    v31[26] = v22 + v69;
    *float32_t v31 = (float)((float)(v32 + 0.5) + 0.5) * 0.33333;
    v31[1] = (float)(v25 + (float)(v22 + v69)) * 0.33333;
    v31[2] = vabds_f32((float)(0.5 - v32) * (float)((float)(v22 + v69) + v16), v26 * (float)(0.5 - v32)) * 0.5;
    *((_DWORD *)v31 + 3) = v41 | (8 * (v42.f32[1] < 0.5));
    uint64_t v70 = *(void *)(v31 + 25);
    *((void *)v31 + 24) = v70;
    v31[50] = v34;
    v31[51] = v23;
    v31[52] = v32;
    v31[53] = v20;
    v31[27] = (float)(v32 + (float)(v34 + *(float *)&v70)) * 0.33333;
    v31[28] = (float)((float)(v23 + *((float *)&v70 + 1)) - v16) * 0.33333;
    v31[29] = vabds_f32((float)(v34 - *(float *)&v70) * (float)(v20 - *((float *)&v70 + 1)), (float)(v23 - *((float *)&v70 + 1)) * (float)(v32 - *(float *)&v70))* 0.5;
    *((_DWORD *)v31 + 30) = v41 | (8 * (v42.f32[1] >= 0.5)) | 4;
    float64x2_t v71 = v31 + 54;
    if (a3 <= 2)
    {
      int v107 = 2;
      if (a2 >= 2)
      {
LABEL_32:
        uint64_t v111 = 0;
        int v112 = 0;
        float32x2_t v113 = (float32x2_t)vdup_n_s32(0x33800000u);
        float v110 = -0.5;
        do
        {
          float v114 = v110;
          float32x2_t v42 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v42, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v113);
          float64x2_t v115 = &v71[v111];
          uint64_t v116 = *(void *)&result[v111 + 50];
          *(void *)(v115 + 21) = v116;
          uint64_t v117 = *(void *)&result[v111 + 48];
          float v118 = v21 + (float)(v17 * (float)(v42.f32[0] + -0.5));
          v115[25] = v118;
          v115[26] = v16;
          *((void *)v115 + 26) = v116;
          *(void *)(v115 + 23) = v117;
          float v119 = (float)(*(float *)&v117 - *(float *)&v116) * (float)(v16 - *((float *)&v116 + 1));
          float v109 = v42.f32[1];
          *float64x2_t v115 = (float)(v118 + (float)(*(float *)&v116 + *(float *)&v117)) * 0.33333;
          v115[1] = (float)((float)(*((float *)&v116 + 1) + *((float *)&v117 + 1)) + v16) * 0.33333;
          LODWORD(v117) = v112 & 1 | v107;
          *((_DWORD *)v115 + 3) = v117 | (8 * (v42.f32[1] < 0.5));
          uint64_t v120 = *(void *)&v71[v111 + 25];
          float v121 = vabds_f32(v119, (float)(*((float *)&v117 + 1) - *((float *)&v116 + 1)) * (float)(v118 - *(float *)&v116));
          *((void *)v115 + 24) = v120;
          v115[50] = v114;
          v115[51] = v16;
          float v110 = *(float *)&v120;
          v115[2] = v121 * 0.5;
          v115[27] = (float)((float)(v114 + *(float *)&v120) + *(float *)&v116) * 0.33333;
          v115[28] = (float)((float)(v16 + *((float *)&v120 + 1)) + *((float *)&v116 + 1)) * 0.33333;
          v115[29] = vabds_f32((float)(v114 - *(float *)&v120) * (float)(*((float *)&v116 + 1) - *((float *)&v120 + 1)), (float)(v16 - *((float *)&v120 + 1)) * (float)(*(float *)&v116 - *(float *)&v120))* 0.5;
          *((_DWORD *)v115 + 30) = v117 | (8 * (v42.f32[1] >= 0.5)) | 4;
          float v21 = (float)(v15 * (float)(v112 + 2)) + -0.5;
          ++v112;
          v111 += 54;
        }
        while (v24 != v112);
        int v108 = v24 & 1;
        float result = (float *)((char *)result + v111 * 4);
        float64x2_t v71 = (float *)((char *)v71 + v111 * 4);
        goto LABEL_35;
      }
    }
    else
    {
      int v72 = a3 - 1;
      int v73 = 1;
      float32x2_t v74 = (float32x2_t)vdup_n_s32(0x33800000u);
      do
      {
        float v82 = (float)(v18 * (float)((float)v73 + 1.0)) - v16;
        float v83 = v69 + v82;
        int v84 = 2 * (v73 & 1);
        if (a2 < 2)
        {
          char v75 = 0;
          float v76 = -0.5;
        }
        else
        {
          uint64_t v85 = 0;
          int v86 = 0;
          float v76 = -0.5;
          float v87 = v15 + -0.5;
          do
          {
            float v88 = v76;
            float v40 = (float)((16598013 * vcvts_n_s32_f32(v40, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
            float32x2_t v42 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v42, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v74);
            float v89 = v83;
            unint64_t v90 = &v71[v85];
            uint64_t v91 = *(void *)&result[v85 + 50];
            *(void *)(v90 + 21) = v91;
            uint64_t v92 = *(void *)&result[v85 + 48];
            float v93 = v87 + (float)(v17 * (float)(v42.f32[0] + -0.5));
            float v83 = v82 + (float)(v19 * (float)(v40 + -0.5));
            *(void *)(v90 + 23) = v92;
            *((void *)v90 + 26) = v91;
            uint64_t v94 = v91;
            float v95 = *((float *)&v91 + 1) - v83;
            if ((float)((float)(v89 - v83) * (float)(*(float *)&v91 - v93)) >= (float)((float)(v88 - v93)
                                                                                      * (float)(*((float *)&v91 + 1)
                                                                                              - v83)))
              float v83 = v89;
            float v96 = *(float *)&v92 - v93;
            if ((float)((float)(*(float *)&v91 - v93) * (float)(*((float *)&v92 + 1) - v83)) <= (float)(v95 * (float)(*(float *)&v92 - v93))) {
              float v93 = *(float *)&v92;
            }
            if ((float)((float)(*((float *)&v92 + 1) - v83) * (float)(v88 - v93)) <= (float)(v96 * (float)(v89 - v83))) {
              float v93 = *(float *)&v92;
            }
            v90[25] = v93;
            v90[26] = v83;
            v90[1] = (float)((float)(*((float *)&v91 + 1) + *((float *)&v92 + 1)) + v83) * 0.33333;
            float v97 = (float)((float)(*(float *)&v91 + *(float *)&v92) + v93) * 0.33333;
            float v98 = (float)(*((float *)&v92 + 1) - *((float *)&v91 + 1)) * (float)(v93 - *(float *)&v91);
            *unint64_t v90 = v97;
            int v99 = v86 & 1 | v84;
            *((_DWORD *)v90 + 3) = v99 | (8 * (v42.f32[1] < 0.5));
            uint64_t v100 = *(void *)(v90 + 25);
            float v101 = vabds_f32((float)(*(float *)&v92 - *(float *)&v94) * (float)(v83 - *((float *)&v94 + 1)), v98);
            *((void *)v90 + 24) = v100;
            v90[50] = v88;
            v90[51] = v89;
            float v76 = *(float *)&v100;
            v90[2] = v101 * 0.5;
            v90[27] = (float)((float)(v88 + *(float *)&v100) + *(float *)&v94) * 0.33333;
            v90[28] = (float)((float)(v89 + *((float *)&v100 + 1)) + *((float *)&v94 + 1)) * 0.33333;
            v90[29] = vabds_f32((float)(v88 - *(float *)&v100) * (float)(*((float *)&v94 + 1) - *((float *)&v100 + 1)), (float)(v89 - *((float *)&v100 + 1)) * (float)(*(float *)&v94 - *(float *)&v100))* 0.5;
            *((_DWORD *)v90 + 30) = v99 | (8 * (v42.f32[1] >= 0.5)) | 4;
            float v87 = (float)(v15 * (float)(v86 + 2)) + -0.5;
            ++v86;
            v85 += 54;
          }
          while (v24 != v86);
          float result = (float *)((char *)result + v85 * 4);
          float64x2_t v71 = (float *)((char *)v71 + v85 * 4);
          char v75 = a2 - 1;
        }
        float v40 = (float)((16598013 * vcvts_n_s32_f32(v40, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
        float v69 = v19 * (float)(v40 + -0.5);
        uint64_t v77 = *((void *)result + 25);
        *(void *)(v71 + 21) = v77;
        uint64_t v78 = *((void *)result + 24);
        *(void *)(v71 + 23) = v78;
        float v79 = v82 + v69;
        v71[25] = 0.5;
        v71[26] = v79;
        *((void *)v71 + 26) = v77;
        *float64x2_t v71 = (float)((float)(*(float *)&v77 + *(float *)&v78) + 0.5) * 0.33333;
        v71[1] = (float)((float)(*((float *)&v77 + 1) + *((float *)&v78 + 1)) + v79) * 0.33333;
        v71[2] = vabds_f32((float)(*(float *)&v78 - *(float *)&v77) * (float)(v79 - *((float *)&v77 + 1)), (float)(*((float *)&v78 + 1) - *((float *)&v77 + 1)) * (float)(0.5 - *(float *)&v77))* 0.5;
        int v80 = v75 & 1 | v84;
        uint64_t v81 = *(void *)(v71 + 25);
        *((void *)v71 + 24) = v81;
        v71[50] = v76;
        v71[51] = v83;
        v71[27] = (float)((float)(v76 + *(float *)&v81) + *(float *)&v77) * 0.33333;
        v71[28] = (float)((float)(v83 + *((float *)&v81 + 1)) + *((float *)&v77 + 1)) * 0.33333;
        v71[29] = vabds_f32((float)(v76 - *(float *)&v81) * (float)(*((float *)&v77 + 1) - *((float *)&v81 + 1)), (float)(v83 - *((float *)&v81 + 1)) * (float)(*(float *)&v77 - *(float *)&v81))* 0.5;
        result += 54;
        ++v73;
        float32x2_t v42 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v42, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v74);
        *((_DWORD *)v71 + 3) = v80 | (8 * (v42.f32[1] < 0.5));
        *((_DWORD *)v71 + 30) = v80 | (8 * (v42.f32[1] >= 0.5)) | 4;
        v71 += 54;
      }
      while (v73 != v72);
      int v107 = 2 * (v72 & 1);
      if (a2 >= 2) {
        goto LABEL_32;
      }
    }
    int v108 = 0;
    float v109 = v42.f32[1];
    float v110 = -0.5;
LABEL_35:
    float v67 = (float)((16598013 * vcvts_n_s32_f32(v109, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    uint64_t v122 = *((void *)result + 25);
    *(void *)(v71 + 21) = v122;
    uint64_t v123 = *((void *)result + 24);
    *(void *)(v71 + 23) = v123;
    v71[25] = 0.5;
    v71[26] = v16;
    *((void *)v71 + 26) = v122;
    uint64_t v124 = v122;
    *float64x2_t v71 = (float)((float)(*(float *)&v122 + *(float *)&v123) + 0.5) * 0.33333;
    v71[1] = (float)((float)(*((float *)&v122 + 1) + *((float *)&v123 + 1)) + v16) * 0.33333;
    v71[2] = vabds_f32((float)(*(float *)&v123 - *(float *)&v122) * (float)(v16 - *((float *)&v122 + 1)), (float)(*((float *)&v123 + 1) - *((float *)&v122 + 1)) * (float)(0.5 - *(float *)&v122))* 0.5;
    int v68 = v108 | v107;
    *((_DWORD *)v71 + 3) = v108 | v107 | (8 * (v67 < 0.5));
    uint64_t v125 = *(void *)(v71 + 25);
    *((void *)v71 + 24) = v125;
    v71[50] = v110;
    v71[51] = v16;
    v71[27] = (float)((float)(v110 + *(float *)&v125) + *(float *)&v124) * 0.33333;
    v71[28] = (float)((float)(v16 + *((float *)&v125 + 1)) + *((float *)&v124 + 1)) * 0.33333;
    float v106 = (float)((float)(v110 - *(float *)&v125) * (float)(*((float *)&v124 + 1) - *((float *)&v125 + 1)))
         - (float)((float)(v16 - *((float *)&v125 + 1)) * (float)(*(float *)&v124 - *(float *)&v125));
    goto LABEL_36;
  }
  float v43 = -v16;
  float v44 = (float)((float)((float)-v16 - v16) + v16) * 0.33333;
  float v45 = v16 - v16;
  float v46 = v16 + v16;
  if (a2 < 2)
  {
    int v68 = 0;
    float v51 = -0.5;
    float v67 = 0.16809;
    float v50 = -0.5;
  }
  else
  {
    int v47 = 0;
    int v48 = a2 - 1;
    float v49 = 0.0;
    float v50 = -0.5;
    float v51 = -0.5;
    float v52 = 1.0 / (float)a2;
    float v53 = 0.0;
    float v54 = 0.0;
    do
    {
      float v55 = v51;
      float v56 = v50;
      float v57 = v52 + -0.5;
      float v49 = (float)((12268885 * vcvts_n_s32_f32(v49, 0x18uLL) + 10368889) & 0xFFFFFF) * 0.000000059605;
      float v53 = (float)((214013 * vcvts_n_s32_f32(v53, 0x18uLL) + 2531011) & 0xFFFFFF) * 0.000000059605;
      float v54 = (float)((16598013 * vcvts_n_s32_f32(v54, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      result[21] = v50;
      result[22] = v43;
      float v50 = v57 + (float)(v17 * (float)(v53 + -0.5));
      result[23] = v50;
      result[24] = v43;
      float v58 = v57 + (float)(v17 * (float)(v49 + -0.5));
      result[25] = v58;
      result[26] = v16;
      float v59 = (float)(v56 + v50) + v58;
      float v60 = v50 - v56;
      float v61 = v58 - v56;
      float v62 = v60 * v46;
      float v63 = v45 * v61;
      *((_DWORD *)result + 3) = v47 & 1 | (8 * (v54 < 0.5));
      unint64_t v64 = *(void *)(result + 25);
      *((void *)result + 24) = v64;
      result[50] = v55;
      result[51] = v16;
      unint64_t v65 = HIDWORD(v64);
      float v51 = *(float *)&v64;
      uint64_t v66 = *(void *)(result + 21);
      *((void *)result + 26) = v66;
      *float result = v59 * 0.33333;
      result[1] = v44;
      result[2] = vabds_f32(v62, v63) * 0.5;
      result[27] = (float)((float)(v55 + v51) + *(float *)&v66) * 0.33333;
      result[28] = (float)((float)(v16 + *(float *)&v65) + *((float *)&v66 + 1)) * 0.33333;
      *((_DWORD *)result + 30) = v47 & 1 | (8 * (v54 >= 0.5)) | 4;
      result[29] = vabds_f32((float)(v55 - v51) * (float)(*((float *)&v66 + 1) - *(float *)&v65), (float)(v16 - *(float *)&v65) * (float)(*(float *)&v66 - v51))* 0.5;
      float v52 = v15 * (float)(v47 + 2);
      result += 54;
      ++v47;
    }
    while (v48 != v47);
    float v67 = (float)((16598013 * vcvts_n_s32_f32(v54, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    int v68 = v48 & 1;
  }
  result[21] = v50;
  result[22] = v43;
  result[23] = 0.5;
  result[24] = v43;
  result[25] = 0.5;
  result[26] = v16;
  *float result = (float)((float)(v50 + 0.5) + 0.5) * 0.33333;
  result[1] = v44;
  result[2] = vabds_f32((float)(0.5 - v50) * v46, v45 * (float)(0.5 - v50)) * 0.5;
  *((_DWORD *)result + 3) = v68 | (8 * (v67 < 0.5));
  unint64_t v102 = *(void *)(result + 25);
  *((void *)result + 24) = v102;
  result[50] = v51;
  result[51] = v16;
  unint64_t v103 = HIDWORD(v102);
  float v104 = *(float *)&v102;
  uint64_t v105 = *(void *)(result + 21);
  *((void *)result + 26) = v105;
  result[27] = (float)((float)(v51 + v104) + *(float *)&v105) * 0.33333;
  result[28] = (float)((float)(v16 + *(float *)&v103) + *((float *)&v105 + 1)) * 0.33333;
  float v106 = (float)((float)(v51 - v104) * (float)(*((float *)&v105 + 1) - *(float *)&v103))
       - (float)((float)(v16 - *(float *)&v103) * (float)(*(float *)&v105 - v104));
  float64x2_t v71 = result;
LABEL_36:
  v71[29] = fabsf(v106) * 0.5;
  *((_DWORD *)v71 + 30) = v68 | (8 * (v67 >= 0.5)) | 4;
  return result;
}

float *HGFractured::Effect::gen_tri(HGFractured::Effect *this, int a2, int a3, float a4)
{
  uint64_t v8 = a2 * (uint64_t)a3;
  uint64_t v9 = 2 * v8;
  size_t v10 = 216 * v8;
  size_t v11 = *((void *)this + 2);
  float result = (float *)*((void *)this + 7);
  if (v11 < v10)
  {
    *((void *)this + 2) = v10;
    float result = (float *)malloc_type_realloc(result, v10, 0x9B0B8F84uLL);
    *((void *)this + 7) = result;
  }
  *((void *)this + 8) = v9;
  float v13 = 1.0 / (float)a2;
  float v14 = a4 / (float)a3;
  float v15 = a4 * 0.5;
  float v16 = (float)(v13 * 0.5) * v14;
  float v17 = -(float)(a4 * 0.5);
  if (a3 >= 2)
  {
    float v18 = -0.5;
    float v19 = v13 + -0.5;
    float v20 = v14 - v15;
    int v21 = a2 - 1;
    float v22 = (float)((float)(v17 - v15) + (float)(v14 - v15)) * 0.33333;
    if (a2 < 2)
    {
      int v32 = 0;
      float v31 = 0.16809;
      float v29 = -0.5;
      float v25 = result;
    }
    else
    {
      int v23 = 0;
      float v24 = 0.0;
      float v25 = result;
      float v26 = -0.5;
      float v27 = v13 + -0.5;
      do
      {
        float v28 = v18;
        float v29 = v27;
        float v24 = (float)((16598013 * vcvts_n_s32_f32(v24, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v25[25] = v27;
        v25[26] = v20;
        *((_DWORD *)v25 + 3) = v23 & 1 | (8 * (v24 < 0.5));
        uint64_t v30 = *(void *)(v25 + 25);
        *((void *)v25 + 24) = v30;
        float v18 = *(float *)&v30;
        v25[21] = v26;
        v25[22] = v17;
        v25[23] = v27;
        v25[24] = v17;
        *float v25 = (float)(v27 + (float)(v27 + v26)) * 0.33333;
        v25[1] = v22;
        v25[2] = v16;
        v25[50] = v28;
        v25[51] = v20;
        v25[52] = v26;
        v25[53] = v17;
        v25[27] = (float)(v26 + (float)(v28 + *(float *)&v30)) * 0.33333;
        v25[28] = (float)((float)(v20 + *((float *)&v30 + 1)) - v15) * 0.33333;
        v25[29] = v16;
        *((_DWORD *)v25 + 30) = v23 & 1 | (8 * (v24 >= 0.5)) | 4;
        float v27 = (float)(v13 * (float)(v23 + 2)) + -0.5;
        v25 += 54;
        ++v23;
        float v26 = v29;
      }
      while (v21 != v23);
      float v31 = (float)((16598013 * vcvts_n_s32_f32(v24, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      int v32 = v21 & 1;
    }
    v25[21] = v29;
    v25[22] = v17;
    v25[23] = 0.5;
    v25[24] = v17;
    v25[25] = 0.5;
    v25[26] = v20;
    *float v25 = (float)((float)(v29 + 0.5) + 0.5) * 0.33333;
    v25[1] = v22;
    v25[2] = v16;
    *((_DWORD *)v25 + 3) = v32 | (8 * (v31 < 0.5));
    uint64_t v47 = *(void *)(v25 + 25);
    *((void *)v25 + 24) = v47;
    v25[50] = v18;
    v25[51] = v20;
    v25[52] = v29;
    v25[53] = v17;
    v25[27] = (float)(v29 + (float)(v18 + *(float *)&v47)) * 0.33333;
    v25[28] = (float)((float)(v20 + *((float *)&v47 + 1)) - v15) * 0.33333;
    v25[29] = v16;
    *((_DWORD *)v25 + 30) = v32 | (8 * (v31 >= 0.5)) | 4;
    int v48 = v25 + 54;
    if (a3 <= 2)
    {
      int v74 = 2;
      if (a2 >= 2)
      {
LABEL_26:
        uint64_t v77 = 0;
        int v78 = 0;
        float v76 = -0.5;
        do
        {
          float v79 = v76;
          int v80 = &v48[v77];
          float v31 = (float)((16598013 * vcvts_n_s32_f32(v31, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
          uint64_t v81 = *(void *)&result[v77 + 50];
          *(void *)(v80 + 21) = v81;
          uint64_t v82 = *(void *)&result[v77 + 48];
          *(void *)(v80 + 23) = v82;
          v80[25] = v19;
          v80[26] = v15;
          *((void *)v80 + 26) = v81;
          *int v80 = (float)(v19 + (float)(*(float *)&v81 + *(float *)&v82)) * 0.33333;
          v80[1] = (float)((float)(*((float *)&v81 + 1) + *((float *)&v82 + 1)) + v15) * 0.33333;
          v80[2] = v16;
          LODWORD(v82) = v78 & 1 | v74;
          *((_DWORD *)v80 + 3) = v82 | (8 * (v31 < 0.5));
          uint64_t v83 = *(void *)&v48[v77 + 25];
          *((void *)v80 + 24) = v83;
          v80[50] = v76;
          v80[51] = v15;
          float v76 = *(float *)&v83;
          v80[27] = (float)((float)(v79 + *(float *)&v83) + *(float *)&v81) * 0.33333;
          v80[28] = (float)((float)(v15 + *((float *)&v83 + 1)) + *((float *)&v81 + 1)) * 0.33333;
          v80[29] = v16;
          *((_DWORD *)v80 + 30) = v82 | (8 * (v31 >= 0.5)) | 4;
          float v19 = (float)(v13 * (float)(v78 + 2)) + -0.5;
          ++v78;
          v77 += 54;
        }
        while (v21 != v78);
        int v75 = v21 & 1;
        float result = (float *)((char *)result + v77 * 4);
        int v48 = (float *)((char *)v48 + v77 * 4);
        goto LABEL_29;
      }
    }
    else
    {
      int v49 = a3 - 1;
      int v50 = 1;
      do
      {
        float v57 = (float)(v14 * (float)((float)v50 + 1.0)) - v15;
        int v58 = 2 * (v50 & 1);
        if (a2 < 2)
        {
          char v51 = 0;
          float v52 = -0.5;
        }
        else
        {
          uint64_t v59 = 0;
          int v60 = 0;
          float v52 = -0.5;
          float v61 = v13 + -0.5;
          do
          {
            float v62 = v52;
            float v63 = &v48[v59];
            float v31 = (float)((16598013 * vcvts_n_s32_f32(v31, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
            uint64_t v64 = *(void *)&result[v59 + 50];
            *(void *)(v63 + 21) = v64;
            uint64_t v65 = *(void *)&result[v59 + 48];
            *(void *)(v63 + 23) = v65;
            v63[25] = v61;
            v63[26] = v57;
            *((void *)v63 + 26) = v64;
            *float v63 = (float)(v61 + (float)(*(float *)&v64 + *(float *)&v65)) * 0.33333;
            v63[1] = (float)((float)(*((float *)&v64 + 1) + *((float *)&v65 + 1)) + v57) * 0.33333;
            void v63[2] = v16;
            LODWORD(v65) = v60 & 1 | v58;
            *((_DWORD *)v63 + 3) = v65 | (8 * (v31 < 0.5));
            uint64_t v66 = *(void *)&v48[v59 + 25];
            *((void *)v63 + 24) = v66;
            v63[50] = v52;
            v63[51] = v57;
            float v52 = *(float *)&v66;
            v63[27] = (float)((float)(v62 + *(float *)&v66) + *(float *)&v64) * 0.33333;
            v63[28] = (float)((float)(v57 + *((float *)&v66 + 1)) + *((float *)&v64 + 1)) * 0.33333;
            v63[29] = v16;
            *((_DWORD *)v63 + 30) = v65 | (8 * (v31 >= 0.5)) | 4;
            float v61 = (float)(v13 * (float)(v60 + 2)) + -0.5;
            ++v60;
            v59 += 54;
          }
          while (v21 != v60);
          float result = (float *)((char *)result + v59 * 4);
          int v48 = (float *)((char *)v48 + v59 * 4);
          char v51 = a2 - 1;
        }
        float v31 = (float)((16598013 * vcvts_n_s32_f32(v31, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        uint64_t v53 = *((void *)result + 25);
        *(void *)(v48 + 21) = v53;
        uint64_t v54 = *((void *)result + 24);
        *(void *)(v48 + 23) = v54;
        v48[25] = 0.5;
        v48[26] = v57;
        *((void *)v48 + 26) = v53;
        *int v48 = (float)((float)(*(float *)&v53 + *(float *)&v54) + 0.5) * 0.33333;
        v48[1] = (float)((float)(*((float *)&v53 + 1) + *((float *)&v54 + 1)) + v57) * 0.33333;
        v48[2] = v16;
        int v55 = v51 & 1 | v58;
        *((_DWORD *)v48 + 3) = v55 | (8 * (v31 < 0.5));
        uint64_t v56 = *(void *)(v48 + 25);
        *((void *)v48 + 24) = v56;
        v48[50] = v52;
        v48[51] = v57;
        v48[27] = (float)((float)(v52 + *(float *)&v56) + *(float *)&v53) * 0.33333;
        v48[28] = (float)((float)(v57 + *((float *)&v56 + 1)) + *((float *)&v53 + 1)) * 0.33333;
        v48[29] = v16;
        *((_DWORD *)v48 + 30) = v55 | (8 * (v31 >= 0.5)) | 4;
        result += 54;
        ++v50;
        v48 += 54;
      }
      while (v50 != v49);
      int v74 = 2 * (v49 & 1);
      if (a2 >= 2) {
        goto LABEL_26;
      }
    }
    int v75 = 0;
    float v76 = -0.5;
LABEL_29:
    float v45 = (float)((16598013 * vcvts_n_s32_f32(v31, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    uint64_t v84 = *((void *)result + 25);
    *(void *)(v48 + 21) = v84;
    uint64_t v85 = *((void *)result + 24);
    *(void *)(v48 + 23) = v85;
    v48[25] = 0.5;
    v48[26] = v15;
    *((void *)v48 + 26) = v84;
    uint64_t v86 = v84;
    *int v48 = (float)((float)(*(float *)&v84 + *(float *)&v85) + 0.5) * 0.33333;
    v48[1] = (float)((float)(*((float *)&v84 + 1) + *((float *)&v85 + 1)) + v15) * 0.33333;
    v48[2] = v16;
    int v46 = v75 | v74;
    *((_DWORD *)v48 + 3) = v75 | v74 | (8 * (v45 < 0.5));
    uint64_t v87 = *(void *)(v48 + 25);
    *((void *)v48 + 24) = v87;
    v48[50] = v76;
    v48[51] = v15;
    float v88 = v76 + *(float *)&v87;
    float v89 = v15 + *((float *)&v87 + 1);
    float v72 = v88 + *(float *)&v86;
    float v73 = v89 + *((float *)&v86 + 1);
    goto LABEL_30;
  }
  float v33 = (float)((float)(v17 - v15) + v15) * 0.33333;
  if (a2 < 2)
  {
    int v46 = 0;
    float v39 = -0.5;
    float v45 = 0.16809;
    float v37 = -0.5;
  }
  else
  {
    int v34 = 0;
    int v35 = a2 - 1;
    float v36 = 0.0;
    float v37 = -0.5;
    float v38 = 1.0 / (float)a2;
    float v39 = -0.5;
    do
    {
      float v40 = v39;
      float v41 = v37;
      float v37 = v38 + -0.5;
      float v36 = (float)((16598013 * vcvts_n_s32_f32(v36, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      result[21] = v41;
      result[22] = v17;
      result[23] = v38 + -0.5;
      result[24] = v17;
      result[25] = v38 + -0.5;
      result[26] = v15;
      *float result = (float)((float)(v38 + -0.5) + (float)(v41 + (float)(v38 + -0.5))) * 0.33333;
      result[1] = v33;
      result[2] = v16;
      *((_DWORD *)result + 3) = v34 & 1 | (8 * (v36 < 0.5));
      unint64_t v42 = *(void *)(result + 25);
      *((void *)result + 24) = v42;
      result[50] = v40;
      result[51] = v15;
      unint64_t v43 = HIDWORD(v42);
      float v39 = *(float *)&v42;
      uint64_t v44 = *(void *)(result + 21);
      *((void *)result + 26) = v44;
      result[27] = (float)((float)(v40 + v39) + *(float *)&v44) * 0.33333;
      result[28] = (float)((float)(v15 + *(float *)&v43) + *((float *)&v44 + 1)) * 0.33333;
      result[29] = v16;
      *((_DWORD *)result + 30) = v34 & 1 | (8 * (v36 >= 0.5)) | 4;
      float v38 = v13 * (float)(v34 + 2);
      result += 54;
      ++v34;
    }
    while (v35 != v34);
    float v45 = (float)((16598013 * vcvts_n_s32_f32(v36, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    int v46 = v35 & 1;
  }
  result[21] = v37;
  result[22] = v17;
  result[23] = 0.5;
  result[24] = v17;
  result[25] = 0.5;
  result[26] = v15;
  *float result = (float)((float)(v37 + 0.5) + 0.5) * 0.33333;
  result[1] = v33;
  result[2] = v16;
  *((_DWORD *)result + 3) = v46 | (8 * (v45 < 0.5));
  unint64_t v67 = *(void *)(result + 25);
  *((void *)result + 24) = v67;
  result[50] = v39;
  result[51] = v15;
  unint64_t v68 = HIDWORD(v67);
  float v69 = *(float *)&v67;
  uint64_t v70 = *(void *)(result + 21);
  *((void *)result + 26) = v70;
  float v71 = v15 + *(float *)&v68;
  float v72 = (float)(v39 + v69) + *(float *)&v70;
  float v73 = v71 + *((float *)&v70 + 1);
  int v48 = result;
LABEL_30:
  v48[27] = v72 * 0.33333;
  v48[28] = v73 * 0.33333;
  v48[29] = v16;
  *((_DWORD *)v48 + 30) = v46 | (8 * (v45 >= 0.5)) | 4;
  return result;
}

float *HGFractured::Effect::gen_quad(HGFractured::Effect *this, int a2, int a3, float a4, float a5)
{
  uint64_t v11 = a3 * (uint64_t)a2;
  size_t v12 = 116 * v11;
  unint64_t v13 = *((void *)this + 2);
  float result = (float *)*((void *)this + 7);
  if (v13 < 116 * v11)
  {
    *((void *)this + 2) = v12;
    float result = (float *)malloc_type_realloc(result, v12, 0xF1CDF0C1uLL);
    *((void *)this + 7) = result;
  }
  *((void *)this + 8) = v11;
  float v15 = 1.0 / (float)a2;
  float v16 = a4 * 0.5;
  float v17 = v15 * a5;
  if (a3 < 2)
  {
    float v42 = -v16;
    float v43 = (float)-v16 - v16;
    float v44 = (float)((float)(v43 + v16) + v16) * 0.25;
    float v45 = v16 - v16;
    float v46 = v16 + v16;
    if (a2 < 2)
    {
      int v55 = 0;
      float32x2_t v54 = (float32x2_t)0xBF000000BF000000;
      int v56 = 8;
    }
    else
    {
      int v47 = 0;
      int v48 = a2 - 1;
      float32x2_t v49 = (float32x2_t)0x3E1A7B0C3F1E3779;
      float v50 = 0.16809;
      float32x2_t v51 = (float32x2_t)vdup_n_s32(0x33800000u);
      float v52 = -0.5;
      v5.f32[0] = 1.0 / (float)a2;
      float v53 = -0.5;
      do
      {
        v5.f32[0] = v5.f32[0] + -0.5;
        float v50 = (float)((16598013 * vcvts_n_s32_f32(v50, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        result[21] = v52;
        result[22] = v42;
        float32x2_t v49 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x269EC3009E3779, vcvt_n_s32_f32(v49, 0x18uLL), (int32x2_t)0x343FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v51);
        float32x2_t v5 = (float32x2_t)vdup_lane_s32((int32x2_t)v5, 0);
        float32x2_t v54 = vadd_f32(v5, vmul_n_f32(vadd_f32(v49, (float32x2_t)0xBF000000BF000000), v17));
        result[23] = v54.f32[1];
        result[24] = v42;
        result[25] = v54.f32[0];
        result[26] = v16;
        result[27] = v53;
        result[28] = v16;
        v5.f32[0] = v15 * (float)(v47 + 2);
        *float result = (float)(v53 + (float)((float)(v52 + v54.f32[1]) + v54.f32[0])) * 0.25;
        result[1] = v44;
        result[2] = (float)(vabds_f32((float)(v54.f32[1] - v52) * v46, v45 * (float)(v54.f32[0] - v52))
                          + vabds_f32(v43 * (float)(v53 - v54.f32[0]), (float)(v52 - v54.f32[0]) * v45))
                  * 0.5;
        *((_DWORD *)result + 3) = (4 * (v47 & 1)) | (8 * (v50 < 0.5)) | v47 & 1;
        result += 29;
        ++v47;
        float v52 = v54.f32[1];
        float v53 = v54.f32[0];
      }
      while (v48 != v47);
      int v55 = v48 & 1;
      int v56 = 8
          * ((float)((float)((16598013 * vcvts_n_s32_f32(v50, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605) < 0.5);
    }
    result[21] = v54.f32[1];
    result[22] = v42;
    result[23] = 0.5;
    result[24] = v42;
    result[25] = 0.5;
    result[26] = v16;
    result[27] = v54.f32[0];
    result[28] = v16;
    *float result = (float)(v54.f32[0] + (float)((float)(v54.f32[1] + 0.5) + 0.5)) * 0.25;
    result[1] = v44;
    result[2] = (float)(vabds_f32((float)(0.5 - v54.f32[1]) * v46, v45 * (float)(0.5 - v54.f32[1]))
                      + vabds_f32(v43 * (float)(v54.f32[0] + -0.5), (float)(v54.f32[1] + -0.5) * v45))
              * 0.5;
    unsigned int v84 = v56 | (4 * v55) | v55;
    int v58 = result;
  }
  else
  {
    float v18 = a4 / (float)a3;
    float v19 = v18 * a5;
    float v20 = -v16;
    float v21 = v15 + -0.5;
    float v22 = v18 - v16;
    float v23 = (float)(v18 - v16) + (float)((float)(v18 * a5) * 0.26414);
    int v24 = a2 - 1;
    float v25 = (float)-v16 - v16;
    float v26 = v16 - v16;
    if (a2 < 2)
    {
      int v40 = 0;
      float32x2_t v41 = (float32x2_t)0x3CB5F4C03D95DBD0;
      float v39 = 0.35764;
      float v35 = -0.5;
      float v33 = -0.5;
      int v32 = result;
    }
    else
    {
      int v27 = 0;
      float32x2_t v28 = (float32x2_t)0x3F1E37793E2C210CLL;
      float v29 = 0.15086;
      float v30 = 0.76414;
      float32x2_t v31 = (float32x2_t)vdup_n_s32(0x33800000u);
      int v32 = result;
      float v33 = -0.5;
      float v34 = v15 + -0.5;
      float v35 = -0.5;
      do
      {
        float v36 = v35;
        float v37 = v23;
        float v38 = v33;
        float v30 = (float)((16598013 * vcvts_n_s32_f32(v30, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
        float v29 = (float)((214013 * vcvts_n_s32_f32(v29, 0x18uLL) + 2531011) & 0xFFFFFF) * 0.000000059605;
        float32x2_t v28 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v28, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v31);
        v32[21] = v33;
        v32[22] = v20;
        float v33 = v34 + (float)(v17 * (float)(v29 + -0.5));
        v32[23] = v33;
        v32[24] = v20;
        float v35 = v34 + (float)(v17 * (float)(v28.f32[1] + -0.5));
        float v23 = v22 + (float)(v19 * (float)(v30 + -0.5));
        v32[25] = v35;
        v32[26] = v23;
        v32[27] = v36;
        v32[28] = v37;
        float v34 = (float)(v15 * (float)(v27 + 2)) + -0.5;
        *int v32 = (float)(v36 + (float)((float)(v38 + v33) + v35)) * 0.25;
        v32[1] = (float)((float)(v25 + v23) + v37) * 0.25;
        v32[2] = (float)(vabds_f32((float)(v33 - v38) * (float)(v23 + v16), v26 * (float)(v35 - v38))
                       + vabds_f32((float)(v20 - v23) * (float)(v36 - v35), (float)(v38 - v35) * (float)(v37 - v23)))
               * 0.5;
        *((_DWORD *)v32 + 3) = (4 * (v27 & 1)) | (8 * (v28.f32[0] < 0.5)) | v27 & 1;
        v32 += 29;
        ++v27;
      }
      while (v24 != v27);
      float v39 = (float)((16598013 * vcvts_n_s32_f32(v30, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
      int v40 = v24 & 1;
      float32x2_t v41 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v28, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), (float32x2_t)vdup_n_s32(0x33800000u));
    }
    v32[21] = v33;
    v32[22] = v20;
    v32[23] = 0.5;
    v32[24] = v20;
    float v57 = v22 + (float)(v19 * (float)(v39 + -0.5));
    v32[25] = 0.5;
    v32[26] = v57;
    v32[27] = v35;
    v32[28] = v23;
    *int v32 = (float)(v35 + (float)((float)(v33 + 0.5) + 0.5)) * 0.25;
    v32[1] = (float)((float)(v25 + v57) + v23) * 0.25;
    v32[2] = (float)(vabds_f32((float)(0.5 - v33) * (float)(v57 + v16), v26 * (float)(0.5 - v33))
                   + vabds_f32((float)(v20 - v57) * (float)(v35 + -0.5), (float)(v33 + -0.5) * (float)(v23 - v57)))
           * 0.5;
    *((_DWORD *)v32 + 3) = (4 * v40) | (8 * (v41.f32[0] < 0.5)) | v40;
    int v58 = v32 + 29;
    if (a3 <= 2)
    {
      LOBYTE(v59) = 1;
    }
    else
    {
      int v59 = a3 - 1;
      int v60 = 1;
      float32x2_t v61 = (float32x2_t)vdup_n_s32(0x33800000u);
      do
      {
        float v69 = (float)((16598013 * vcvts_n_s32_f32(v39, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
        float32x2_t v70 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v41, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v61);
        float v71 = (float)(v18 * (float)((float)v60 + 1.0)) - v16;
        float v72 = v71 + (float)(v19 * (float)(v69 + -0.5));
        int v73 = 2 * (v60 & 1);
        if (a2 < 2)
        {
          unsigned __int8 v62 = 0;
          float v63 = -0.5;
        }
        else
        {
          uint64_t v74 = 0;
          int v75 = 0;
          float v63 = -0.5;
          float v76 = v15 + -0.5;
          do
          {
            float v77 = v63;
            float v69 = (float)((16598013 * vcvts_n_s32_f32(v69, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
            float32x2_t v70 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v70, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v61);
            float v78 = v72;
            float v79 = &v58[v74];
            uint64_t v80 = *(void *)&result[v74 + 27];
            *(void *)(v79 + 21) = v80;
            uint64_t v81 = *(void *)&result[v74 + 25];
            float v82 = v76 + (float)(v17 * (float)(v70.f32[1] + -0.5));
            float v72 = v71 + (float)(v19 * (float)(v69 + -0.5));
            *(void *)(v79 + 23) = v81;
            float v83 = *((float *)&v80 + 1) - v72;
            if ((float)((float)(v78 - v72) * (float)(*(float *)&v80 - v82)) >= (float)((float)(v63 - v82)
                                                                                      * (float)(*((float *)&v80 + 1)
                                                                                              - v72)))
              float v72 = v78;
            if ((float)((float)(*(float *)&v80 - v82) * (float)(*((float *)&v81 + 1) - v72)) <= (float)(v83 * (float)(*(float *)&v81 - v82))) {
              float v63 = *(float *)&v81;
            }
            else {
              float v63 = v82;
            }
            v79[27] = v77;
            v79[28] = v78;
            if ((float)((float)(*((float *)&v81 + 1) - v72) * (float)(v77 - v63)) <= (float)((float)(*(float *)&v81 - v82)
                                                                                            * (float)(v78 - v72)))
              float v63 = *(float *)&v81;
            float v76 = (float)(v15 * (float)(v75 + 2)) + -0.5;
            v79[25] = v63;
            v79[26] = v72;
            *float v79 = (float)(v77 + (float)((float)(*(float *)&v80 + *(float *)&v81) + v63)) * 0.25;
            v79[1] = (float)((float)((float)(*((float *)&v80 + 1) + *((float *)&v81 + 1)) + v72) + v78) * 0.25;
            v79[2] = (float)(vabds_f32((float)(*(float *)&v81 - *(float *)&v80) * (float)(v72 - *((float *)&v80 + 1)), (float)(*((float *)&v81 + 1) - *((float *)&v80 + 1)) * (float)(v63 - *(float *)&v80))+ vabds_f32((float)(*((float *)&v80 + 1) - v72) * (float)(v77 - v63), (float)(*(float *)&v80 - v63) * (float)(v78 - v72)))* 0.5;
            *((_DWORD *)v79 + 3) = v75 & 1 | (4 * ((v75 ^ v60) & 1)) | (8 * (v70.f32[0] < 0.5)) | v73;
            ++v75;
            v74 += 29;
          }
          while (v24 != v75);
          float result = (float *)((char *)result + v74 * 4);
          int v58 = (float *)((char *)v58 + v74 * 4);
          unsigned __int8 v62 = a2 - 1;
        }
        float v39 = (float)((16598013 * vcvts_n_s32_f32(v69, 0x18uLL) + 12820163) & 0xFFFFFF) * 0.000000059605;
        unint64_t v64 = *(void *)(result + 27);
        *(void *)(v58 + 21) = v64;
        unint64_t v65 = HIDWORD(v64);
        float v66 = *(float *)&v64;
        uint64_t v67 = *(void *)(result + 25);
        *(void *)(v58 + 23) = v67;
        float v68 = v71 + (float)(v19 * (float)(v39 + -0.5));
        v58[25] = 0.5;
        v58[26] = v68;
        v58[27] = v63;
        v58[28] = v72;
        *int v58 = (float)(v63 + (float)((float)(v66 + *(float *)&v67) + 0.5)) * 0.25;
        v58[1] = (float)((float)((float)(*(float *)&v65 + *((float *)&v67 + 1)) + v68) + v72) * 0.25;
        v58[2] = (float)(vabds_f32((float)(*(float *)&v67 - v66) * (float)(v68 - *(float *)&v65), (float)(*((float *)&v67 + 1) - *(float *)&v65) * (float)(0.5 - v66))+ vabds_f32((float)(*(float *)&v65 - v68) * (float)(v63 + -0.5), (float)(v66 + -0.5) * (float)(v72 - v68)))* 0.5;
        LODWORD(v67) = v62 & 1 | (4 * ((v62 ^ v60) & 1));
        result += 29;
        ++v60;
        float32x2_t v41 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v70, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v61);
        *((_DWORD *)v58 + 3) = v67 | (8 * (v41.f32[0] < 0.5)) | v73;
        v58 += 29;
      }
      while (v60 != v59);
    }
    v85.f32[0] = (float)((16598013 * vcvts_n_s32_f32(v41.f32[0], 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    if (a2 <= 1)
    {
      LOBYTE(v24) = 0;
      int v88 = 2 * (v59 & 1);
      float v90 = -0.5;
    }
    else
    {
      uint64_t v86 = 0;
      int v87 = 0;
      int v88 = 2 * (v59 & 1);
      v85.f32[1] = (float)((12268885 * vcvts_n_s32_f32(v41.f32[1], 0x18uLL) + 10368889) & 0xFFFFFF) * 0.000000059605;
      float32x2_t v89 = (float32x2_t)vdup_n_s32(0x33800000u);
      float v90 = -0.5;
      do
      {
        uint64_t v91 = &v58[v86];
        float32x2_t v85 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v85, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v89);
        uint64_t v92 = *(void *)&result[v86 + 27];
        *(void *)(v91 + 21) = v92;
        uint64_t v93 = *(void *)&result[v86 + 25];
        float v94 = v90;
        float v90 = v21 + (float)(v17 * (float)(v85.f32[1] + -0.5));
        v91[27] = v94;
        v91[28] = v16;
        *(void *)(v91 + 23) = v93;
        float v21 = (float)(v15 * (float)(v87 + 2)) + -0.5;
        v91[25] = v90;
        v91[26] = v16;
        *uint64_t v91 = (float)(v94 + (float)(v90 + (float)(*(float *)&v92 + *(float *)&v93))) * 0.25;
        v91[1] = (float)((float)((float)(*((float *)&v92 + 1) + *((float *)&v93 + 1)) + v16) + v16) * 0.25;
        v91[2] = (float)(vabds_f32((float)(*(float *)&v93 - *(float *)&v92) * (float)(v16 - *((float *)&v92 + 1)), (float)(*((float *)&v93 + 1) - *((float *)&v92 + 1)) * (float)(v90 - *(float *)&v92))+ vabds_f32((float)(*((float *)&v92 + 1) - v16) * (float)(v94 - v90), (float)(*(float *)&v92 - v90) * v26))* 0.5;
        *((_DWORD *)v91 + 3) = v87 & 1 | (4 * ((v87 ^ v59) & 1)) | (8 * (v85.f32[0] < 0.5)) | v88;
        ++v87;
        v86 += 29;
      }
      while (v24 != v87);
      float result = (float *)((char *)result + v86 * 4);
      int v58 = (float *)((char *)v58 + v86 * 4);
    }
    uint64_t v95 = *(void *)(result + 27);
    *(void *)(v58 + 21) = v95;
    uint64_t v96 = *(void *)(result + 25);
    *(void *)(v58 + 23) = v96;
    v58[25] = 0.5;
    v58[26] = v16;
    v58[27] = v90;
    v58[28] = v16;
    *int v58 = (float)(v90 + (float)((float)(*(float *)&v95 + *(float *)&v96) + 0.5)) * 0.25;
    v58[1] = (float)((float)((float)(*((float *)&v95 + 1) + *((float *)&v96 + 1)) + v16) + v16) * 0.25;
    v58[2] = (float)(vabds_f32((float)(*(float *)&v96 - *(float *)&v95) * (float)(v16 - *((float *)&v95 + 1)), (float)(*((float *)&v96 + 1) - *((float *)&v95 + 1)) * (float)(0.5 - *(float *)&v95))+ vabds_f32((float)(*((float *)&v95 + 1) - v16) * (float)(v90 + -0.5), (float)(*(float *)&v95 + -0.5) * v26))* 0.5;
    unsigned int v84 = v24 & 1 | v88 & 0xFFFFFFFB | (4 * ((v24 ^ v59) & 1)) | (8
                                                                                                  * ((float)((float)((16598013 * vcvts_n_s32_f32(v85.f32[0], 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605) < 0.5));
  }
  *((_DWORD *)v58 + 3) = v84;
  return result;
}

float *HGFractured::Effect::gen_quad(HGFractured::Effect *this, int a2, int a3, float a4)
{
  uint64_t v8 = a3 * (uint64_t)a2;
  size_t v9 = 116 * v8;
  unint64_t v10 = *((void *)this + 2);
  float result = (float *)*((void *)this + 7);
  if (v10 < 116 * v8)
  {
    *((void *)this + 2) = v9;
    float result = (float *)malloc_type_realloc(result, v9, 0x17C5E199uLL);
    *((void *)this + 7) = result;
  }
  *((void *)this + 8) = v8;
  float v12 = 1.0 / (float)a2;
  float v13 = a4 / (float)a3;
  float v14 = a4 * 0.5;
  float v15 = v12 * v13;
  float v16 = -(float)(a4 * 0.5);
  if (a3 < 2)
  {
    float v29 = (float)((float)((float)(v16 - v14) + v14) + v14) * 0.25;
    if (a2 < 2)
    {
      int v36 = 0;
      float v34 = -0.5;
      int v37 = 8;
    }
    else
    {
      int v30 = 0;
      int v31 = a2 - 1;
      float v32 = 0.0;
      float v33 = 1.0 / (float)a2;
      float v34 = -0.5;
      do
      {
        float v35 = v34;
        float v34 = v33 + -0.5;
        float v32 = (float)((16598013 * vcvts_n_s32_f32(v32, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        result[21] = v35;
        result[22] = v16;
        result[23] = v33 + -0.5;
        result[24] = v16;
        result[25] = v33 + -0.5;
        result[26] = v14;
        result[27] = v35;
        result[28] = v14;
        float v33 = v12 * (float)(v30 + 2);
        *float result = (float)(v35 + (float)(v34 + (float)(v35 + v34))) * 0.25;
        result[1] = v29;
        result[2] = v15;
        *((_DWORD *)result + 3) = (4 * (v30 & 1)) | (8 * (v32 < 0.5)) | v30 & 1;
        result += 29;
        ++v30;
      }
      while (v31 != v30);
      int v36 = v31 & 1;
      int v37 = 8
          * ((float)((float)((16598013 * vcvts_n_s32_f32(v32, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605) < 0.5);
    }
    result[21] = v34;
    result[22] = v16;
    result[23] = 0.5;
    result[24] = v16;
    result[25] = 0.5;
    result[26] = v14;
    result[27] = v34;
    result[28] = v14;
    *float result = (float)(v34 + (float)((float)(v34 + 0.5) + 0.5)) * 0.25;
    result[1] = v29;
    result[2] = v15;
    *((_DWORD *)result + 3) = v37 | (4 * v36) | v36;
  }
  else
  {
    float v17 = -0.5;
    float v18 = v12 + -0.5;
    float v19 = v13 - v14;
    int v20 = a2 - 1;
    float v21 = (float)((float)((float)(v16 - v14) + (float)(v13 - v14)) + (float)(v13 - v14)) * 0.25;
    if (a2 < 2)
    {
      int v28 = 0;
      float v27 = 0.16809;
      int v24 = result;
    }
    else
    {
      int v22 = 0;
      float v23 = 0.0;
      int v24 = result;
      float v25 = v12 + -0.5;
      do
      {
        float v26 = v17;
        float v17 = v25;
        float v23 = (float)((16598013 * vcvts_n_s32_f32(v23, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v24[21] = v26;
        v24[22] = v16;
        v24[23] = v25;
        v24[24] = v16;
        v24[25] = v25;
        v24[26] = v19;
        v24[27] = v26;
        v24[28] = v19;
        float v25 = (float)(v12 * (float)(v22 + 2)) + -0.5;
        *int v24 = (float)(v26 + (float)(v17 + (float)(v26 + v17))) * 0.25;
        v24[1] = v21;
        v24[2] = v15;
        *((_DWORD *)v24 + 3) = (4 * (v22 & 1)) | (8 * (v23 < 0.5)) | v22 & 1;
        v24 += 29;
        ++v22;
      }
      while (v20 != v22);
      float v27 = (float)((16598013 * vcvts_n_s32_f32(v23, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      int v28 = v20 & 1;
    }
    v24[21] = v17;
    v24[22] = v16;
    v24[23] = 0.5;
    v24[24] = v16;
    v24[25] = 0.5;
    v24[26] = v19;
    v24[27] = v17;
    v24[28] = v19;
    *int v24 = (float)(v17 + (float)((float)(v17 + 0.5) + 0.5)) * 0.25;
    v24[1] = v21;
    v24[2] = v15;
    *((_DWORD *)v24 + 3) = (4 * v28) | (8 * (v27 < 0.5)) | v28;
    float v38 = v24 + 29;
    if (a3 <= 2)
    {
      int v39 = 1;
    }
    else
    {
      int v39 = a3 - 1;
      int v40 = 1;
      do
      {
        float v47 = (float)(v13 * (float)((float)v40 + 1.0)) - v14;
        int v48 = 2 * (v40 & 1);
        if (a2 < 2)
        {
          unsigned __int8 v41 = 0;
          float v42 = -0.5;
        }
        else
        {
          uint64_t v49 = 0;
          int v50 = 0;
          float v42 = -0.5;
          float v51 = v12 + -0.5;
          do
          {
            float v52 = v42;
            float v42 = v51;
            float v53 = &v38[v49];
            float v27 = (float)((16598013 * vcvts_n_s32_f32(v27, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
            uint64_t v54 = *(void *)&result[v49 + 27];
            *(void *)(v53 + 21) = v54;
            uint64_t v55 = *(void *)&result[v49 + 25];
            *(void *)(v53 + 23) = v55;
            v53[25] = v51;
            v53[26] = v47;
            v53[27] = v52;
            v53[28] = v47;
            float v51 = (float)(v12 * (float)(v50 + 2)) + -0.5;
            *float v53 = (float)(v52 + (float)(v42 + (float)(*(float *)&v54 + *(float *)&v55))) * 0.25;
            v53[1] = (float)((float)((float)(*((float *)&v54 + 1) + *((float *)&v55 + 1)) + v47) + v47) * 0.25;
            v53[2] = v15;
            *((_DWORD *)v53 + 3) = v50 & 1 | (4 * ((v50 ^ v40) & 1)) | (8 * (v27 < 0.5)) | v48;
            ++v50;
            v49 += 29;
          }
          while (v20 != v50);
          float result = (float *)((char *)result + v49 * 4);
          float v38 = (float *)((char *)v38 + v49 * 4);
          unsigned __int8 v41 = a2 - 1;
        }
        float v27 = (float)((16598013 * vcvts_n_s32_f32(v27, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        unint64_t v43 = *(void *)(result + 27);
        *(void *)(v38 + 21) = v43;
        unint64_t v44 = HIDWORD(v43);
        float v45 = *(float *)&v43;
        uint64_t v46 = *(void *)(result + 25);
        *(void *)(v38 + 23) = v46;
        v38[25] = 0.5;
        v38[26] = v47;
        v38[27] = v42;
        v38[28] = v47;
        *float v38 = (float)(v42 + (float)((float)(v45 + *(float *)&v46) + 0.5)) * 0.25;
        v38[1] = (float)((float)((float)(*(float *)&v44 + *((float *)&v46 + 1)) + v47) + v47) * 0.25;
        v38[2] = v15;
        *((_DWORD *)v38 + 3) = v41 & 1 | (4 * ((v41 ^ v40) & 1)) | (8 * (v27 < 0.5)) | v48;
        result += 29;
        ++v40;
        v38 += 29;
      }
      while (v40 != v39);
    }
    int v56 = 2 * (v39 & 1);
    if (a2 < 2)
    {
      LOBYTE(v20) = 0;
      float v59 = -0.5;
    }
    else
    {
      uint64_t v57 = 0;
      int v58 = 0;
      float v59 = -0.5;
      do
      {
        float v60 = v59;
        float v59 = v18;
        float32x2_t v61 = &v38[v57];
        float v27 = (float)((16598013 * vcvts_n_s32_f32(v27, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        uint64_t v62 = *(void *)&result[v57 + 27];
        *(void *)(v61 + 21) = v62;
        uint64_t v63 = *(void *)&result[v57 + 25];
        *(void *)(v61 + 23) = v63;
        v61[25] = v18;
        v61[26] = v14;
        v61[27] = v60;
        v61[28] = v14;
        float v18 = (float)(v12 * (float)(v58 + 2)) + -0.5;
        *float32x2_t v61 = (float)(v60 + (float)(v59 + (float)(*(float *)&v62 + *(float *)&v63))) * 0.25;
        v61[1] = (float)((float)((float)(*((float *)&v62 + 1) + *((float *)&v63 + 1)) + v14) + v14) * 0.25;
        v61[2] = v15;
        *((_DWORD *)v61 + 3) = v58 & 1 | (4 * ((v58 ^ v39) & 1)) | (8 * (v27 < 0.5)) | v56;
        ++v58;
        v57 += 29;
      }
      while (v20 != v58);
      float result = (float *)((char *)result + v57 * 4);
      float v38 = (float *)((char *)v38 + v57 * 4);
    }
    uint64_t v64 = *(void *)(result + 27);
    *(void *)(v38 + 21) = v64;
    uint64_t v65 = *(void *)(result + 25);
    *(void *)(v38 + 23) = v65;
    v38[25] = 0.5;
    v38[26] = v14;
    v38[27] = v59;
    v38[28] = v14;
    *float v38 = (float)(v59 + (float)((float)(*(float *)&v64 + *(float *)&v65) + 0.5)) * 0.25;
    v38[1] = (float)((float)((float)(*((float *)&v64 + 1) + *((float *)&v65 + 1)) + v14) + v14) * 0.25;
    v38[2] = v15;
    *((_DWORD *)v38 + 3) = v20 & 1 | (4 * ((v20 ^ v39) & 1)) | (8
                                                                                                * ((float)((float)((16598013 * vcvts_n_s32_f32(v27, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605) < 0.5)) | v56;
  }
  return result;
}

void HGFractured::Effect::gen_glass(HGFractured::Effect *this, int a2, int a3, float a4, float a5)
{
  int v8 = (int)fmaxf((float)a2, 4.0);
  size_t v9 = 116 * a3 * (uint64_t)v8 + 464;
  unint64_t v10 = (float *)*((void *)this + 7);
  if (*((void *)this + 2) < v9)
  {
    *((void *)this + 2) = v9;
    unint64_t v10 = (float *)malloc_type_realloc(v10, v9, 0x6ADE3286uLL);
    *((void *)this + 7) = v10;
  }
  if ((float)(a4 * 0.5) <= 0.5) {
    float v12 = a4 * 0.5;
  }
  else {
    float v12 = 0.5;
  }
  double v13 = pow(1.5, (double)(a3 - 1));
  uint64_t v95 = v10;
  int v14 = v8 - 1;
  if (v8 >= 1)
  {
    int v15 = 0;
    float v16 = 6.28318531 / (double)v8;
    float v102 = v16;
    float v17 = v12 * 0.99 / v13;
    float v101 = v17;
    float v106 = v17 * a5;
    double v105 = v17;
    float32x2_t v18 = 0;
    float32x2_t v100 = (float32x2_t)vdup_n_s32(0x33800000u);
    float v19 = -0.5;
    float v20 = 0.0;
    float v98 = a4 * 0.5;
    float v99 = a4;
    int v96 = v8 - 1;
    int v97 = v8;
    do
    {
      while (1)
      {
        float32x2_t v23 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x269EC3009E3779, vcvt_n_s32_f32(v18, 0x18uLL), (int32x2_t)0x343FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v100);
        if (v15 == v14) {
          float v24 = 0.61803;
        }
        else {
          float v24 = (float)((12268885 * vcvts_n_s32_f32(v23.f32[0], 0x18uLL) + 10368889) & 0xFFFFFF) * 0.000000059605;
        }
        float v104 = (float)((16598013 * vcvts_n_s32_f32(v20, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        float v25 = v23.f32[1];
        float v26 = (float)(v23.f32[0] + 0.61803) * v19;
        float v27 = (float)(v23.f32[1] + 0.15086) * 0.5;
        float32x2_t v107 = v23;
        __float2 v30 = __sincosf_stret((float)((float)((float)(v23.f32[0] + v19) * a5) + (float)v15) * v102);
        float cosval = v30.__cosval;
        float sinval = v30.__sinval;
        int v103 = v15 + 1;
        __float2 v31 = __sincosf_stret((float)((float)((float)(v24 + -0.5) * a5) + (float)(v15 + 1)) * v102);
        float v19 = -0.5;
        float v33 = v31.__cosval;
        float v32 = v31.__sinval;
        float v34 = (float)((float)((float)(a5 * 0.5) * v26) + 1.0) * v101;
        float v35 = 0.5;
        float v36 = (float)(v106 * (float)((float)(v27 * a5) + -0.5)) + v34;
        float v37 = v34 * v30.__cosval;
        float v38 = v34 * v30.__sinval;
        float v39 = v36 * v31.__cosval;
        float v40 = v36 * v31.__sinval;
        v10[21] = v39;
        v10[22] = v40;
        v10[23] = 0.0;
        v10[24] = 0.0;
        v10[25] = v37;
        v10[26] = v38;
        v10[27] = v39;
        v10[28] = v40;
        *unint64_t v10 = (float)((float)(v37 + 0.0) + v39) / 3.0;
        v10[1] = (float)((float)(v38 + 0.0) + v40) / 3.0;
        v10[2] = vabds_f32((float)(0.0 - v39) * (float)(v38 - v40), (float)(0.0 - v40) * (float)(v37 - v39)) * 0.5;
        int v41 = v15 & 1;
        int v42 = 8 * (v104 < 0.5);
        *((_DWORD *)v10 + 3) = v41 | (4 * (v15 & 1)) & 0xF7 | v42;
        if (a3 < 3)
        {
          float v68 = v10 + 29;
          char v69 = 1;
          float v71 = v98;
          float v70 = v99;
        }
        else
        {
          int v43 = 2;
          int v44 = 1033231312;
          float v45 = 0.15452;
          int v46 = 1052187892;
          float v47 = 0.022211;
          int v48 = 2;
          do
          {
            v49.i64[0] = __PAIR64__(v46, LODWORD(v47));
            v49.i64[1] = __PAIR64__(v44, LODWORD(v45));
            float32x4_t v50 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)(*(_OWORD *)&vmlaq_s32((int32x4_t)xmmword_1B8348100, vcvtq_n_s32_f32(v49, 0x18uLL), (int32x4_t)xmmword_1B83480F0) & __PAIR128__(0xFFFFFF00FFFFFFLL, 0xFFFFFF00FFFFFFLL))), (float32x4_t)vdupq_n_s32(0x33800000u));
            float v110 = v50.f32[0];
            float v51 = v50.f32[2];
            int v108 = v50.i32[1];
            int v109 = v50.i32[3];
            float v52 = (float)(v25 + v45) * 0.5;
            float v53 = v25;
            float v54 = sinval;
            float v55 = v32;
            float v56 = cosval;
            float v57 = v33;
            long double v58 = pow(1.5, (float)((float)v43 + (float)((float)((float)(v107.f32[0] + v47) * v19) * a5)));
            float v33 = v57;
            float cosval = v56;
            float v32 = v55;
            float sinval = v54;
            float v25 = v53;
            float v19 = -0.5;
            *(float *)&long double v58 = v58 * v105;
            float v35 = 0.5;
            float v59 = (float)(v106 * (float)((float)(v52 * a5) + -0.5)) + *(float *)&v58;
            float v60 = v10[27];
            float v61 = v10[25];
            float v62 = v56 * *(float *)&v58;
            float v63 = v33 * v59;
            v10[29] = (float)((float)(v33 * v59) + (float)((float)(v56 * *(float *)&v58) + (float)(v60 + v61))) * 0.25;
            v10 += 29;
            float v64 = *(v10 - 1);
            v10[21] = v60;
            v10[22] = v64;
            float v65 = *(v10 - 3);
            v10[23] = v61;
            v10[24] = v65;
            *(float *)&long double v58 = sinval * *(float *)&v58;
            float v66 = v32 * v59;
            v10[25] = v62;
            v10[26] = *(float *)&v58;
            v10[27] = v63;
            v10[28] = v66;
            float v67 = (float)(v66 + (float)(*(float *)&v58 + (float)(v64 + v65))) * 0.25;
            *(float *)&long double v58 = vabds_f32((float)(v10[23] - v10[21]) * (float)(*(float *)&v58 - v10[22]), (float)(v10[24] - v10[22]) * (float)(v62 - v10[21]))+ vabds_f32((float)(v10[22] - *(float *)&v58) * (float)(v63 - v62), (float)(v10[21] - v62) * (float)(v66 - *(float *)&v58));
            int v46 = v108;
            int v44 = v109;
            v10[1] = v67;
            v10[2] = *(float *)&v58 * 0.5;
            *((_DWORD *)v10 + 3) = v48 & 2 | (4 * (((v43 - 1) ^ v15) & 1)) | v41 | v42;
            v48 += 2;
            ++v43;
            float v47 = v110;
            float v45 = v51;
          }
          while (a3 != v43);
          float v39 = v10[27];
          float v40 = v10[28];
          float v68 = v10 + 29;
          int v8 = v97;
          char v69 = a3 - 1;
          float v37 = v10[25];
          float v38 = v10[26];
          float v71 = v98;
          float v70 = v99;
          int v14 = v96;
        }
        if (cosval >= 0.0) {
          float v72 = cosval;
        }
        else {
          float v72 = -cosval;
        }
        if (sinval >= 0.0) {
          float v73 = sinval;
        }
        else {
          float v73 = -sinval;
        }
        float v74 = 0.5;
        float v75 = v71;
        if (v73 != (float)(v72 * v70))
        {
          if (v73 < (float)(v72 * v70))
          {
            float v75 = (float)(v73 * 0.5) / v72;
          }
          else
          {
            float v75 = v71;
            float v74 = (float)(v71 * v72) / v73;
          }
        }
        if (cosval < 0.0) {
          float v74 = -v74;
        }
        float v76 = -v75;
        if (sinval >= 0.0) {
          float v76 = v75;
        }
        float v77 = -v33;
        if (v33 >= 0.0) {
          float v77 = v33;
        }
        float v78 = -v32;
        if (v32 >= 0.0) {
          float v78 = v32;
        }
        float v79 = v77 * v70;
        float v80 = (float)(v71 * v77) / v78;
        float v81 = (float)(v78 * v35) / v77;
        if (v78 < v79) {
          float v80 = v35;
        }
        else {
          float v81 = v71;
        }
        BOOL v82 = v78 == v79;
        if (v78 == v79) {
          float v83 = v71;
        }
        else {
          float v83 = v81;
        }
        if (v82) {
          float v84 = v35;
        }
        else {
          float v84 = v80;
        }
        if (v33 < 0.0) {
          float v84 = -v84;
        }
        if (v32 < 0.0) {
          float v83 = -v83;
        }
        v10[50] = v39;
        v10[51] = v40;
        v10[52] = v37;
        v10[53] = v38;
        v10[54] = v74;
        v10[55] = v76;
        v10[56] = v84;
        v10[57] = v83;
        float v85 = (float)((float)((float)(v40 + v38) + v76) + v83) * 0.25;
        *float v68 = (float)((float)((float)(v39 + v37) + v74) + v84) * 0.25;
        float v86 = v10[50];
        float v87 = v10[51];
        float v88 = v10[54];
        float v89 = v10[55];
        float v90 = vabds_f32((float)(v10[52] - v86) * (float)(v89 - v87), (float)(v10[53] - v87) * (float)(v88 - v86));
        float v91 = vabds_f32((float)(v87 - v89) * (float)(v10[56] - v88), (float)(v86 - v88) * (float)(v10[57] - v89));
        v10[30] = v85;
        v10[31] = (float)(v90 + v91) * v35;
        int v92 = (4 * ((v69 ^ v15) & 1)) | (2 * (v69 & 1)) | v41 | v42;
        *((_DWORD *)v10 + 32) = v92;
        if (v76 != v83 && v74 != v84) {
          break;
        }
        v10 += 58;
        float32x2_t v18 = v107;
        float v20 = v104;
        ++v15;
        if (v103 == v8) {
          goto LABEL_60;
        }
      }
      if ((float)(v83 * v84) >= 0.0) {
        float v21 = v74;
      }
      else {
        float v21 = v84;
      }
      if ((float)(v83 * v84) >= 0.0) {
        float v22 = v83;
      }
      else {
        float v22 = v76;
      }
      v10[79] = v84;
      v10[80] = v83;
      v10[81] = v74;
      v10[82] = v76;
      v10[83] = v21;
      v10[84] = v22;
      v10[85] = v21;
      v10[86] = v22;
      v10[58] = (float)(v21 + (float)((float)(v74 + v84) + v21)) * 0.25;
      v10[59] = (float)(v22 + (float)((float)(v76 + v83) + v22)) * 0.25;
      v10[60] = (float)(vabds_f32((float)(v74 - v84) * (float)(v22 - v83), (float)(v76 - v83) * (float)(v21 - v84))
                      + vabds_f32((float)(v83 - v22) * (float)(v21 - v21), (float)(v84 - v21) * (float)(v22 - v22)))
              * v35;
      *((_DWORD *)v10 + 61) = v92;
      v10 += 87;
      float32x2_t v18 = v107;
      float v20 = v104;
      ++v15;
    }
    while (v103 != v8);
  }
LABEL_60:
  *((void *)this + 8) = 0x34F72C234F72C235 * (v10 - v95);
}

void HGFractured::Effect::gen_glass(HGFractured::Effect *this, int a2, int a3, float a4)
{
  int v5 = (int)fmaxf((float)a2, 4.0);
  size_t v6 = 116 * a3 * (uint64_t)v5 + 464;
  unint64_t v7 = (void *)*((void *)this + 7);
  float v63 = a4;
  if (*((void *)this + 2) < v6)
  {
    *((void *)this + 2) = v6;
    size_t v9 = malloc_type_realloc(v7, v6, 0xF2EAA3DCuLL);
    a4 = v63;
    unint64_t v7 = v9;
    *((void *)this + 7) = v9;
  }
  float v10 = a4 * 0.5;
  float v62 = v10;
  if (v10 <= 0.5) {
    float v11 = v10;
  }
  else {
    float v11 = 0.5;
  }
  double v12 = pow(1.5, (double)(a3 - 1));
  long double v58 = v7;
  if (v5 >= 1)
  {
    int v13 = 0;
    float v14 = 6.28318531 / (double)v5;
    float v61 = v14;
    float v15 = v11 * 0.99 / v12;
    float v60 = v15;
    double v16 = v15;
    float v17 = (float *)v7;
    float v18 = 0.0;
    int v59 = v5;
    do
    {
      float v18 = (float)((16598013 * vcvts_n_s32_f32(v18, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      __float2 v19 = __sincosf_stret(v61 * (float)v13);
      int v20 = v13 + 1;
      __float2 v21 = __sincosf_stret(v61 * (float)(v13 + 1));
      float v22 = v19.__cosval * v60;
      float v23 = v19.__sinval * v60;
      float v24 = v21.__cosval * v60;
      float v25 = v21.__sinval * v60;
      v17[21] = v21.__cosval * v60;
      v17[22] = v21.__sinval * v60;
      v17[23] = 0.0;
      v17[24] = 0.0;
      v17[25] = v19.__cosval * v60;
      v17[26] = v19.__sinval * v60;
      v17[27] = v21.__cosval * v60;
      v17[28] = v21.__sinval * v60;
      *float v17 = (float)((float)((float)(v19.__cosval * v60) + 0.0) + (float)(v21.__cosval * v60)) / 3.0;
      v17[1] = (float)((float)((float)(v19.__sinval * v60) + 0.0) + (float)(v21.__sinval * v60)) / 3.0;
      v17[2] = vabds_f32((float)(0.0 - (float)(v21.__cosval * v60))* (float)((float)(v19.__sinval * v60) - (float)(v21.__sinval * v60)), (float)(0.0 - (float)(v21.__sinval * v60))* (float)((float)(v19.__cosval * v60) - (float)(v21.__cosval * v60)))* 0.5;
      int v26 = v13 & 1;
      *((_DWORD *)v17 + 3) = (4 * v26) | (8 * (v18 < 0.5)) | v26;
      if (a3 < 3)
      {
        float v38 = v17 + 29;
        char v39 = 1;
        float v41 = v62;
        float v40 = v63;
      }
      else
      {
        int v27 = 2;
        int v28 = 2;
        do
        {
          float v18 = (float)((16598013 * vcvts_n_s32_f32(v18, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
          float v29 = pow(1.5, (double)v27) * v16;
          float v30 = v17[27];
          float v31 = v17[25];
          float v32 = v19.__cosval * v29;
          float v33 = v21.__cosval * v29;
          v17[29] = (float)((float)(v21.__cosval * v29) + (float)((float)(v19.__cosval * v29) + (float)(v30 + v31)))
                  * 0.25;
          v17 += 29;
          float v34 = *(v17 - 1);
          v17[21] = v30;
          v17[22] = v34;
          float v35 = *(v17 - 3);
          v17[23] = v31;
          v17[24] = v35;
          float v36 = v19.__sinval * v29;
          float v37 = v21.__sinval * v29;
          v17[25] = v32;
          v17[26] = v36;
          v17[27] = v33;
          v17[28] = v37;
          v17[1] = (float)(v37 + (float)(v36 + (float)(v34 + v35))) * 0.25;
          v17[2] = (float)(vabds_f32((float)(v17[23] - v17[21]) * (float)(v36 - v17[22]), (float)(v17[24] - v17[22]) * (float)(v32 - v17[21]))+ vabds_f32((float)(v17[22] - v36) * (float)(v33 - v32), (float)(v17[21] - v32) * (float)(v37 - v36)))* 0.5;
          *((_DWORD *)v17 + 3) = v28 & 2 | (4 * (((v27 - 1) ^ v13) & 1)) | (8 * (v18 < 0.5)) | v26;
          v28 += 2;
          ++v27;
        }
        while (a3 != v27);
        float v24 = v17[27];
        float v25 = v17[28];
        float v38 = v17 + 29;
        int v5 = v59;
        char v39 = a3 - 1;
        float v22 = v17[25];
        float v23 = v17[26];
        float v41 = v62;
        float v40 = v63;
        int v20 = v13 + 1;
      }
      float cosval = -v19.__cosval;
      if (v19.__cosval >= 0.0) {
        float cosval = v19.__cosval;
      }
      if (v19.__sinval >= 0.0) {
        float sinval = v19.__sinval;
      }
      else {
        float sinval = -v19.__sinval;
      }
      float v44 = 0.5;
      float v45 = v41;
      float v46 = 0.5;
      if (sinval != (float)(cosval * v40))
      {
        if (sinval < (float)(cosval * v40))
        {
          float v45 = (float)(sinval * 0.5) / cosval;
        }
        else
        {
          float v45 = v41;
          float v46 = (float)(v41 * cosval) / sinval;
        }
      }
      float v47 = -v46;
      if (v19.__cosval >= 0.0) {
        float v47 = v46;
      }
      if (v19.__sinval < 0.0) {
        float v45 = -v45;
      }
      if (v21.__cosval >= 0.0) {
        float v48 = v21.__cosval;
      }
      else {
        float v48 = -v21.__cosval;
      }
      if (v21.__sinval >= 0.0) {
        float v49 = v21.__sinval;
      }
      else {
        float v49 = -v21.__sinval;
      }
      float v50 = v41;
      if (v49 != (float)(v48 * v40))
      {
        if (v49 < (float)(v48 * v40))
        {
          float v50 = (float)(v49 * 0.5) / v48;
        }
        else
        {
          float v50 = v41;
          float v44 = (float)(v41 * v48) / v49;
        }
      }
      if (v21.__cosval < 0.0) {
        float v44 = -v44;
      }
      if (v21.__sinval < 0.0) {
        float v50 = -v50;
      }
      v17[50] = v24;
      v17[51] = v25;
      v17[52] = v22;
      v17[53] = v23;
      v17[54] = v47;
      v17[55] = v45;
      v17[56] = v44;
      v17[57] = v50;
      float v51 = (float)((float)((float)(v25 + v23) + v45) + v50) * 0.25;
      *float v38 = (float)((float)((float)(v24 + v22) + v47) + v44) * 0.25;
      float v52 = v17[50];
      float v53 = (float)(vabds_f32((float)(v17[52] - v52) * (float)(v17[55] - v17[51]), (float)(v17[53] - v17[51]) * (float)(v17[54] - v52))+ vabds_f32((float)(v17[51] - v17[55]) * (float)(v17[56] - v17[54]), (float)(v52 - v17[54]) * (float)(v17[57] - v17[55])))* 0.5;
      v17[30] = v51;
      v17[31] = v53;
      int v54 = (4 * ((v39 ^ v13) & 1)) | (2 * (v39 & 1)) | (8 * (v18 < 0.5)) | v26;
      *((_DWORD *)v17 + 32) = v54;
      unint64_t v7 = v17 + 58;
      if (v45 != v50 && v47 != v44)
      {
        if ((float)(v50 * v44) >= 0.0) {
          float v55 = v47;
        }
        else {
          float v55 = v44;
        }
        if ((float)(v50 * v44) >= 0.0) {
          float v56 = v50;
        }
        else {
          float v56 = v45;
        }
        v17[79] = v44;
        v17[80] = v50;
        v17[81] = v47;
        v17[82] = v45;
        v17[83] = v55;
        v17[84] = v56;
        v17[85] = v55;
        v17[86] = v56;
        v17[58] = (float)(v55 + (float)((float)(v47 + v44) + v55)) * 0.25;
        v17[59] = (float)(v56 + (float)((float)(v45 + v50) + v56)) * 0.25;
        v17[60] = (float)(vabds_f32((float)(v47 - v44) * (float)(v56 - v50), (float)(v45 - v50) * (float)(v55 - v44))
                        + vabds_f32((float)(v50 - v56) * (float)(v55 - v55), (float)(v44 - v55) * (float)(v56 - v56)))
                * 0.5;
        *((_DWORD *)v17 + 61) = v54;
        unint64_t v7 = v17 + 87;
      }
      float v17 = (float *)v7;
      int v13 = v20;
    }
    while (v20 != v5);
  }
  *((void *)this + 8) = 0x34F72C234F72C235 * (((unsigned char *)v7 - v58) >> 2);
}

uint64_t HGFractured::Effect::gen_glass_2(uint64_t this, int a2, int a3, float a4, float a5, double a6, double a7, int32x2_t a8)
{
  uint64_t v8 = this;
  uint64_t v202 = *MEMORY[0x1E4F143B8];
  int v9 = (int)fmaxf((float)a3, 2.0);
  uint64_t v10 = (int)fmaxf((float)a2, 4.0);
  unint64_t v11 = v9 * v10 + 4;
  size_t v12 = 116 * v11;
  if (*(void *)(this + 16) >= 116 * v11)
  {
    unint64_t v11 = *(void *)(this + 16) / 0x74uLL;
    uint64_t v14 = *(void *)(this + 56);
  }
  else
  {
    int v13 = *(void **)(this + 56);
    *(void *)(v8 + 16) = v12;
    this = (uint64_t)malloc_type_realloc(v13, v12, 0xB7B6A059uLL);
    uint64_t v14 = this;
    *(void *)(v8 + 56) = this;
  }
  float v15 = *(float *)(v8 + 208);
  *(float *)a8.i32 = *(float *)(v8 + 212) * a4;
  float v194 = -0.5 - v15;
  float v195 = (float)-(float)(a4 * 0.5) - *(float *)a8.i32;
  float v196 = 0.5 - v15;
  float v197 = v195;
  float v198 = 0.5 - v15;
  float v199 = (float)(a4 * 0.5) - *(float *)a8.i32;
  float v200 = -0.5 - v15;
  float v201 = v199;
  if ((int)v10 >= 1)
  {
    int32x2_t v171 = a8;
    float v16 = 6.28318531 / (double)(int)v10;
    float v158 = v16;
    uint64_t v17 = 0;
    int v18 = 0;
    float v19 = log2((double)(2 * v9));
    float v20 = 0.25 / (double)v9;
    uint64_t v166 = v10 + 1;
    int v157 = v10 - 1;
    double v169 = v19;
    double v170 = v20;
    float v156 = fabsf(a5) * 0.5;
    double v168 = (double)(int)v10 + -1.0;
    uint64_t v160 = v10 + 4;
    uint64_t v163 = v10 + 2;
    uint64_t v164 = v10 + 3;
    uint64_t v21 = 0x3E873D863DF1BBC8;
    float32x2_t v165 = 0;
    float32x2_t v174 = (float32x2_t)vdup_n_s32(0x33800000u);
    int v159 = v10;
    float32x4_t v167 = (float32x4_t)vdupq_lane_s32(v171, 0);
    do
    {
      float32x2_t v178 = (float32x2_t)v21;
      if (v17 + 1 > v11)
      {
        float v22 = *(void **)(v8 + 56);
        unint64_t v11 = v166 + v17;
        size_t v23 = 116 * (v166 + v17);
        *(void *)(v8 + 16) = v23;
        float v24 = malloc_type_realloc(v22, v23, 0x31085643uLL);
        *(void *)(v8 + 56) = v24;
        uint64_t v14 = (uint64_t)v24 + 116 * v17;
      }
      float32x2_t v25 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x2B0843009E3779, vcvt_n_s32_f32(v165, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v174);
      if (v18 == v157) {
        float v26 = 0.61803;
      }
      else {
        float v26 = (float)((12268885 * vcvts_n_s32_f32(v25.f32[0], 0x18uLL) + 10368889) & 0xFFFFFF) * 0.000000059605;
      }
      float32x2_t v165 = v25;
      __float2 v27 = __sincosf_stret((float)((float)((float)(v25.f32[0] + -0.5) * a5) + (float)v18) * v158);
      int v162 = v18 + 1;
      __float2 v28 = __sincosf_stret((float)((float)((float)(v26 + -0.5) * a5) + (float)(v18 + 1)) * v158);
      float v29 = exp2((float)((float)(v156 * v178.f32[0]) + 0.0) / v168 * v169) * v170;
      float v30 = exp2((float)(vmuls_lane_f32(v156, v178, 1) + 0.0) / v168 * v169) * v170;
      float v31 = v28.__cosval * v30;
      float v32 = v28.__sinval * v30;
      *(float *)(v14 + 84) = v28.__cosval * v30;
      *(float *)(v14 + 88) = v28.__sinval * v30;
      *(void *)(v14 + 92) = 0;
      *(float *)(v14 + 100) = v27.__cosval * v29;
      *(float *)(v14 + 104) = v27.__sinval * v29;
      *(float *)(v14 + 108) = v28.__cosval * v30;
      *(float *)(v14 + 112) = v28.__sinval * v30;
      unsigned int v33 = clip((uint64_t)&v194, (float *)(v14 + 84), (uint64_t)v190, a4);
      if (!v33) {
        goto LABEL_20;
      }
      v34.i32[0] = *(_DWORD *)(v8 + 208);
      if (v33 >= 8)
      {
        uint64_t v35 = v33 & 0xFFFFFFF8;
        float32x4_t v36 = (float32x4_t)vdupq_lane_s32(v34, 0);
        uint64_t v37 = v35;
        float v38 = (float *)&v193;
        do
        {
          char v39 = v38 - 8;
          float32x4x2_t v203 = vld2q_f32(v39);
          float32x4x2_t v205 = vld2q_f32(v38);
          v207.val[0] = vaddq_f32(v36, v203.val[0]);
          v207.val[1] = vaddq_f32(v167, v203.val[1]);
          v203.val[0] = vaddq_f32(v36, v205.val[0]);
          v203.val[1] = vaddq_f32(v167, v205.val[1]);
          vst2q_f32(v39, v207);
          vst2q_f32(v38, v203);
          v38 += 16;
          v37 -= 8;
        }
        while (v37);
        if (v35 == v33) {
          goto LABEL_20;
        }
      }
      else
      {
        uint64_t v35 = 0;
      }
      float v40 = (float *)&v190[v35] + 1;
      uint64_t v41 = v33 - v35;
      do
      {
        float v42 = *(float *)v171.i32 + *v40;
        *(v40 - 1) = *(float *)v34.i32 + *(v40 - 1);
        *float v40 = v42;
        v40 += 2;
        --v41;
      }
      while (v41);
LABEL_20:
      float v176 = v27.__sinval * v29;
      float v177 = v27.__cosval * v29;
      float32x2_t v43 = v178;
      float32x2_t v161 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32(vadd_f32(v178, (float32x2_t)0x3F0000003F000000), 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v174);
      unint64_t v44 = v190[0];
      uint64_t v45 = v190[1];
      *(void *)(v14 + 84) = v190[0];
      *(void *)(v14 + 92) = v45;
      unint64_t v46 = HIDWORD(v44);
      float v47 = *(float *)&v44;
      uint64_t v48 = v191;
      uint64_t v49 = v192;
      *(void *)(v14 + 100) = v191;
      *(void *)(v14 + 108) = v49;
      *(float *)uint64_t v14 = (float)((float)((float)(v47 + *(float *)&v45) + *(float *)&v48) + *(float *)&v49) * 0.25;
      *(float *)(v14 + 4) = (float)((float)((float)(*(float *)&v46 + *((float *)&v45 + 1)) + *((float *)&v48 + 1))
                                  + *((float *)&v49 + 1))
                          * 0.25;
      *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v45 - v47) * (float)(*((float *)&v48 + 1) - *(float *)&v46), (float)(*((float *)&v45 + 1) - *(float *)&v46) * (float)(*(float *)&v48 - v47))+ vabds_f32((float)(*(float *)&v46 - *((float *)&v48 + 1))* (float)(*(float *)&v49 - *(float *)&v48), (float)(v47 - *(float *)&v48)* (float)(*((float *)&v49 + 1) - *((float *)&v48 + 1))))* 0.5;
      int v50 = v18 & 1;
      int v51 = 8 * (v165.f32[1] < 0.5);
      *(_DWORD *)(v14 + 12) = v50 | (4 * (v18 & 1)) & 0xF7 | v51;
      v14 += 116;
      int v52 = 1;
      ++v17;
      while (1)
      {
        float v175 = v32;
        float v59 = v31;
        float32x2_t v179 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0xC39EC3009E3779, vcvt_n_s32_f32(v43, 0x18uLL), (int32x2_t)0xFD43FD00BB3555) & 0xFFFFFF00FFFFFFLL)), v174);
        float v60 = exp2((float)((float)((float)(v179.f32[0] + -0.5) * a5) + (float)v52) / v168 * v169) * v170;
        float v61 = exp2((float)((float)((float)(v179.f32[1] + -0.5) * a5) + (float)v52) / v168 * v169) * v170;
        v189[0] = v177;
        v189[1] = v176;
        float v62 = v27.__cosval * v60;
        float v63 = v27.__sinval * v60;
        v189[2] = v27.__cosval * v60;
        v189[3] = v27.__sinval * v60;
        float v31 = v28.__cosval * v61;
        float v32 = v28.__sinval * v61;
        v189[4] = v28.__cosval * v61;
        v189[5] = v28.__sinval * v61;
        v189[6] = v59;
        v189[7] = v175;
        this = clip((uint64_t)&v194, v189, (uint64_t)&v180, a4);
        if (!this) {
          break;
        }
        v64.i32[0] = *(_DWORD *)(v8 + 208);
        if (this < 8)
        {
          uint64_t v65 = 0;
LABEL_31:
          float v70 = (float *)&v180 + 2 * v65 + 1;
          uint64_t v71 = this - v65;
          do
          {
            float v72 = *(float *)v171.i32 + *v70;
            *(v70 - 1) = *(float *)v64.i32 + *(v70 - 1);
            *float v70 = v72;
            v70 += 2;
            --v71;
          }
          while (v71);
          goto LABEL_33;
        }
        uint64_t v65 = this & 0xFFFFFFF8;
        float32x4_t v66 = (float32x4_t)vdupq_lane_s32(v64, 0);
        uint64_t v67 = v65;
        float v68 = (float *)&v184;
        do
        {
          char v69 = v68 - 8;
          float32x4x2_t v204 = vld2q_f32(v69);
          float32x4x2_t v206 = vld2q_f32(v68);
          v208.val[0] = vaddq_f32(v66, v204.val[0]);
          v208.val[1] = vaddq_f32(v167, v204.val[1]);
          v204.val[0] = vaddq_f32(v66, v206.val[0]);
          v204.val[1] = vaddq_f32(v167, v206.val[1]);
          vst2q_f32(v69, v208);
          vst2q_f32(v68, v204);
          v68 += 16;
          v67 -= 8;
        }
        while (v67);
        if (v65 != this) {
          goto LABEL_31;
        }
LABEL_33:
        switch((int)this)
        {
          case 0:
          case 1:
          case 2:
            goto LABEL_6;
          case 3:
            uint64_t v73 = v17 + 1;
            if (v17 + 1 > v11)
            {
              float v74 = *(void **)(v8 + 56);
              unint64_t v11 = v166 + v17;
              size_t v75 = 116 * (v166 + v17);
              *(void *)(v8 + 16) = v75;
              float v76 = malloc_type_realloc(v74, v75, 0x7DA7290FuLL);
              *(void *)(v8 + 56) = v76;
              uint64_t v14 = (uint64_t)v76 + 116 * v17;
            }
            unint64_t v53 = v180;
            uint64_t v54 = v181;
            *(void *)(v14 + 84) = v180;
            *(void *)(v14 + 92) = v54;
            *(void *)(v14 + 108) = v53;
            unint64_t v55 = HIDWORD(v53);
            float v56 = *(float *)&v53;
            uint64_t v57 = v182;
            *(void *)(v14 + 100) = v182;
            *(float *)uint64_t v14 = (float)((float)(v56 + *(float *)&v54) + *(float *)&v57) / 3.0;
            *(float *)(v14 + 4) = (float)((float)(*(float *)&v55 + *((float *)&v54 + 1)) + *((float *)&v57 + 1)) / 3.0;
            float v58 = vabds_f32((float)(*(float *)&v54 - v56) * (float)(*((float *)&v57 + 1) - *(float *)&v55), (float)(*((float *)&v54 + 1) - *(float *)&v55) * (float)(*(float *)&v57 - v56));
            goto LABEL_22;
          case 4:
            uint64_t v73 = v17 + 1;
            if (v17 + 1 > v11)
            {
              float v77 = *(void **)(v8 + 56);
              unint64_t v11 = v166 + v17;
              size_t v78 = 116 * (v166 + v17);
              *(void *)(v8 + 16) = v78;
              float v79 = malloc_type_realloc(v77, v78, 0xA0564FA1uLL);
              *(void *)(v8 + 56) = v79;
              uint64_t v14 = (uint64_t)v79 + 116 * v17;
            }
            unint64_t v80 = v180;
            uint64_t v81 = v181;
            *(void *)(v14 + 84) = v180;
            *(void *)(v14 + 92) = v81;
            unint64_t v82 = HIDWORD(v80);
            float v83 = *(float *)&v80;
            uint64_t v84 = v182;
            uint64_t v85 = v183;
            *(void *)(v14 + 100) = v182;
            *(void *)(v14 + 108) = v85;
            *(float *)uint64_t v14 = (float)((float)((float)(v83 + *(float *)&v81) + *(float *)&v84) + *(float *)&v85) * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*(float *)&v82 + *((float *)&v81 + 1)) + *((float *)&v84 + 1))
                                        + *((float *)&v85 + 1))
                                * 0.25;
            float v58 = vabds_f32((float)(*(float *)&v81 - v83) * (float)(*((float *)&v84 + 1) - *(float *)&v82), (float)(*((float *)&v81 + 1) - *(float *)&v82) * (float)(*(float *)&v84 - v83))+ vabds_f32((float)(*(float *)&v82 - *((float *)&v84 + 1)) * (float)(*(float *)&v85 - *(float *)&v84), (float)(v83 - *(float *)&v84) * (float)(*((float *)&v85 + 1) - *((float *)&v84 + 1)));
LABEL_22:
            *(float *)(v14 + 8) = v58 * 0.5;
            *(_DWORD *)(v14 + 12) = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            v14 += 116;
            goto LABEL_23;
          case 5:
            uint64_t v73 = v17 + 2;
            if (v17 + 2 > v11)
            {
              float v86 = *(void **)(v8 + 56);
              unint64_t v11 = v163 + v17;
              size_t v87 = 116 * (v163 + v17);
              *(void *)(v8 + 16) = v87;
              float v88 = malloc_type_realloc(v86, v87, 0x4E4C189CuLL);
              *(void *)(v8 + 56) = v88;
              uint64_t v14 = (uint64_t)v88 + 116 * v17;
            }
            unint64_t v89 = v180;
            uint64_t v90 = v181;
            *(void *)(v14 + 84) = v180;
            *(void *)(v14 + 92) = v90;
            uint64_t v91 = v182;
            uint64_t v92 = v183;
            *(void *)(v14 + 100) = v182;
            *(void *)(v14 + 108) = v92;
            *(float *)uint64_t v14 = (float)((float)((float)(*(float *)&v89 + *(float *)&v90) + *(float *)&v91) + *(float *)&v92)
                          * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*((float *)&v89 + 1) + *((float *)&v90 + 1))
                                                + *((float *)&v91 + 1))
                                        + *((float *)&v92 + 1))
                                * 0.25;
            *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v90 - *(float *)&v89)* (float)(*((float *)&v91 + 1) - *((float *)&v89 + 1)), (float)(*((float *)&v90 + 1) - *((float *)&v89 + 1))* (float)(*(float *)&v91 - *(float *)&v89))+ vabds_f32((float)(*((float *)&v89 + 1) - *((float *)&v91 + 1))* (float)(*(float *)&v92 - *(float *)&v91), (float)(*(float *)&v89 - *(float *)&v91)* (float)(*((float *)&v92 + 1) - *((float *)&v91 + 1))))* 0.5;
            int v93 = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            *(_DWORD *)(v14 + 12) = v93;
            unint64_t v94 = v180;
            uint64_t v95 = v183;
            uint64_t v96 = v184;
            *(void *)(v14 + 216) = v184;
            *(void *)(v14 + 224) = v94;
            *(void *)(v14 + 200) = v94;
            *(void *)(v14 + 208) = v95;
            *(float *)(v14 + 116) = (float)((float)(*(float *)&v94 + *(float *)&v95) + *(float *)&v96) / 3.0;
            *(float *)(v14 + 120) = (float)((float)(*((float *)&v94 + 1) + *((float *)&v95 + 1)) + *((float *)&v96 + 1))
                                  / 3.0;
            float v97 = vabds_f32((float)(*(float *)&v95 - *(float *)&v94) * (float)(*((float *)&v96 + 1) - *((float *)&v94 + 1)), (float)(*((float *)&v95 + 1) - *((float *)&v94 + 1)) * (float)(*(float *)&v96 - *(float *)&v94))* 0.5;
            goto LABEL_45;
          case 6:
            uint64_t v73 = v17 + 2;
            if (v17 + 2 > v11)
            {
              float v98 = *(void **)(v8 + 56);
              unint64_t v11 = v163 + v17;
              size_t v99 = 116 * (v163 + v17);
              *(void *)(v8 + 16) = v99;
              float32x2_t v100 = malloc_type_realloc(v98, v99, 0x5134492BuLL);
              *(void *)(v8 + 56) = v100;
              uint64_t v14 = (uint64_t)v100 + 116 * v17;
            }
            unint64_t v101 = v180;
            uint64_t v102 = v181;
            *(void *)(v14 + 84) = v180;
            *(void *)(v14 + 92) = v102;
            uint64_t v103 = v182;
            uint64_t v104 = v183;
            *(void *)(v14 + 100) = v182;
            *(void *)(v14 + 108) = v104;
            *(float *)uint64_t v14 = (float)((float)((float)(*(float *)&v101 + *(float *)&v102) + *(float *)&v103)
                                  + *(float *)&v104)
                          * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*((float *)&v101 + 1) + *((float *)&v102 + 1))
                                                + *((float *)&v103 + 1))
                                        + *((float *)&v104 + 1))
                                * 0.25;
            *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v102 - *(float *)&v101)* (float)(*((float *)&v103 + 1) - *((float *)&v101 + 1)), (float)(*((float *)&v102 + 1) - *((float *)&v101 + 1))* (float)(*(float *)&v103 - *(float *)&v101))+ vabds_f32((float)(*((float *)&v101 + 1) - *((float *)&v103 + 1))* (float)(*(float *)&v104 - *(float *)&v103), (float)(*(float *)&v101 - *(float *)&v103)* (float)(*((float *)&v104 + 1) - *((float *)&v103 + 1))))* 0.5;
            int v93 = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            *(_DWORD *)(v14 + 12) = v93;
            unint64_t v105 = v180;
            uint64_t v106 = v183;
            *(void *)(v14 + 200) = v180;
            *(void *)(v14 + 208) = v106;
            unint64_t v107 = HIDWORD(v105);
            float v108 = *(float *)&v105;
            uint64_t v109 = v184;
            uint64_t v110 = v185;
            *(void *)(v14 + 216) = v184;
            *(void *)(v14 + 224) = v110;
            *(float *)(v14 + 116) = (float)((float)((float)(v108 + *(float *)&v106) + *(float *)&v109) + *(float *)&v110)
                                  * 0.25;
            *(float *)(v14 + 120) = (float)((float)((float)(*(float *)&v107 + *((float *)&v106 + 1))
                                                  + *((float *)&v109 + 1))
                                          + *((float *)&v110 + 1))
                                  * 0.25;
            float v97 = (float)(vabds_f32((float)(*(float *)&v106 - v108) * (float)(*((float *)&v109 + 1) - *(float *)&v107), (float)(*((float *)&v106 + 1) - *(float *)&v107) * (float)(*(float *)&v109 - v108))+ vabds_f32((float)(*(float *)&v107 - *((float *)&v109 + 1))* (float)(*(float *)&v110 - *(float *)&v109), (float)(v108 - *(float *)&v109) * (float)(*((float *)&v110 + 1) - *((float *)&v109 + 1))))* 0.5;
LABEL_45:
            *(float *)(v14 + 124) = v97;
            *(_DWORD *)(v14 + 128) = v93;
            v14 += 232;
            goto LABEL_23;
          case 7:
            uint64_t v73 = v17 + 3;
            if (v17 + 3 > v11)
            {
              uint64_t v111 = *(void **)(v8 + 56);
              unint64_t v11 = v164 + v17;
              size_t v112 = 116 * (v164 + v17);
              *(void *)(v8 + 16) = v112;
              float32x2_t v113 = malloc_type_realloc(v111, v112, 0x83FFC6ABuLL);
              *(void *)(v8 + 56) = v113;
              uint64_t v14 = (uint64_t)v113 + 116 * v17;
            }
            unint64_t v114 = v180;
            uint64_t v115 = v181;
            *(void *)(v14 + 84) = v180;
            *(void *)(v14 + 92) = v115;
            uint64_t v116 = v182;
            uint64_t v117 = v183;
            *(void *)(v14 + 100) = v182;
            *(void *)(v14 + 108) = v117;
            *(float *)uint64_t v14 = (float)((float)((float)(*(float *)&v114 + *(float *)&v115) + *(float *)&v116)
                                  + *(float *)&v117)
                          * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*((float *)&v114 + 1) + *((float *)&v115 + 1))
                                                + *((float *)&v116 + 1))
                                        + *((float *)&v117 + 1))
                                * 0.25;
            *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v115 - *(float *)&v114)* (float)(*((float *)&v116 + 1) - *((float *)&v114 + 1)), (float)(*((float *)&v115 + 1) - *((float *)&v114 + 1))* (float)(*(float *)&v116 - *(float *)&v114))+ vabds_f32((float)(*((float *)&v114 + 1) - *((float *)&v116 + 1))* (float)(*(float *)&v117 - *(float *)&v116), (float)(*(float *)&v114 - *(float *)&v116)* (float)(*((float *)&v117 + 1) - *((float *)&v116 + 1))))* 0.5;
            int v118 = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            *(_DWORD *)(v14 + 12) = v118;
            unint64_t v119 = v180;
            uint64_t v120 = v183;
            uint64_t v121 = v186;
            *(void *)(v14 + 216) = v186;
            *(void *)(v14 + 224) = v119;
            *(void *)(v14 + 200) = v119;
            *(void *)(v14 + 208) = v120;
            *(void *)(v14 + 316) = v121;
            *(void *)(v14 + 324) = v120;
            uint64_t v122 = v120;
            *(float *)(v14 + 116) = (float)((float)(*(float *)&v119 + *(float *)&v120) + *(float *)&v121) / 3.0;
            *(float *)(v14 + 120) = (float)((float)(*((float *)&v119 + 1) + *((float *)&v120 + 1))
                                          + *((float *)&v121 + 1))
                                  / 3.0;
            *(float *)(v14 + 124) = vabds_f32((float)(*(float *)&v120 - *(float *)&v119)* (float)(*((float *)&v121 + 1) - *((float *)&v119 + 1)), (float)(*((float *)&v120 + 1) - *((float *)&v119 + 1))* (float)(*(float *)&v121 - *(float *)&v119))* 0.5;
            *(_DWORD *)(v14 + 128) = v118;
            uint64_t v123 = v184;
            *(void *)(v14 + 332) = v184;
            uint64_t v124 = v185;
            *(void *)(v14 + 340) = v185;
            *(float *)(v14 + 232) = (float)((float)((float)(*(float *)&v121 + *(float *)&v122) + *(float *)&v123)
                                          + *(float *)&v124)
                                  * 0.25;
            *(float *)(v14 + 236) = (float)((float)((float)(*((float *)&v121 + 1) + *((float *)&v122 + 1))
                                                  + *((float *)&v123 + 1))
                                          + *((float *)&v124 + 1))
                                  * 0.25;
            float v125 = (float)(vabds_f32((float)(*(float *)&v122 - *(float *)&v121)* (float)(*((float *)&v123 + 1) - *((float *)&v121 + 1)), (float)(*((float *)&v122 + 1) - *((float *)&v121 + 1))* (float)(*(float *)&v123 - *(float *)&v121))+ vabds_f32((float)(*((float *)&v121 + 1) - *((float *)&v123 + 1))* (float)(*(float *)&v124 - *(float *)&v123), (float)(*(float *)&v121 - *(float *)&v123)* (float)(*((float *)&v124 + 1) - *((float *)&v123 + 1))))* 0.5;
            goto LABEL_52;
          case 8:
            uint64_t v73 = v17 + 3;
            if (v17 + 3 > v11)
            {
              uint64_t v126 = *(void **)(v8 + 56);
              unint64_t v11 = v164 + v17;
              size_t v127 = 116 * (v164 + v17);
              *(void *)(v8 + 16) = v127;
              uint64_t v128 = malloc_type_realloc(v126, v127, 0x9148B6F5uLL);
              *(void *)(v8 + 56) = v128;
              uint64_t v14 = (uint64_t)v128 + 116 * v17;
            }
            unint64_t v129 = v180;
            uint64_t v130 = v181;
            *(void *)(v14 + 84) = v180;
            *(void *)(v14 + 92) = v130;
            uint64_t v131 = v182;
            uint64_t v132 = v183;
            *(void *)(v14 + 100) = v182;
            *(void *)(v14 + 108) = v132;
            *(float *)uint64_t v14 = (float)((float)((float)(*(float *)&v129 + *(float *)&v130) + *(float *)&v131)
                                  + *(float *)&v132)
                          * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*((float *)&v129 + 1) + *((float *)&v130 + 1))
                                                + *((float *)&v131 + 1))
                                        + *((float *)&v132 + 1))
                                * 0.25;
            *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v130 - *(float *)&v129)* (float)(*((float *)&v131 + 1) - *((float *)&v129 + 1)), (float)(*((float *)&v130 + 1) - *((float *)&v129 + 1))* (float)(*(float *)&v131 - *(float *)&v129))+ vabds_f32((float)(*((float *)&v129 + 1) - *((float *)&v131 + 1))* (float)(*(float *)&v132 - *(float *)&v131), (float)(*(float *)&v129 - *(float *)&v131)* (float)(*((float *)&v132 + 1) - *((float *)&v131 + 1))))* 0.5;
            int v118 = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            *(_DWORD *)(v14 + 12) = v118;
            unint64_t v133 = v180;
            uint64_t v134 = v183;
            *(void *)(v14 + 200) = v180;
            *(void *)(v14 + 208) = v134;
            unint64_t v135 = HIDWORD(v133);
            float v136 = *(float *)&v133;
            uint64_t v137 = v184;
            uint64_t v138 = v187;
            *(void *)(v14 + 216) = v184;
            *(void *)(v14 + 224) = v138;
            *(void *)(v14 + 316) = v138;
            *(void *)(v14 + 324) = v137;
            uint64_t v139 = v137;
            *(float *)(v14 + 116) = (float)((float)((float)(v136 + *(float *)&v134) + *(float *)&v137) + *(float *)&v138)
                                  * 0.25;
            *(float *)(v14 + 120) = (float)((float)((float)(*(float *)&v135 + *((float *)&v134 + 1))
                                                  + *((float *)&v137 + 1))
                                          + *((float *)&v138 + 1))
                                  * 0.25;
            *(float *)(v14 + 124) = (float)(vabds_f32((float)(*(float *)&v134 - v136)* (float)(*((float *)&v137 + 1) - *(float *)&v135), (float)(*((float *)&v134 + 1) - *(float *)&v135)* (float)(*(float *)&v137 - v136))+ vabds_f32((float)(*(float *)&v135 - *((float *)&v137 + 1))* (float)(*(float *)&v138 - *(float *)&v137), (float)(v136 - *(float *)&v137)* (float)(*((float *)&v138 + 1) - *((float *)&v137 + 1))))* 0.5;
            *(_DWORD *)(v14 + 128) = v118;
            uint64_t v140 = v185;
            *(void *)(v14 + 332) = v185;
            uint64_t v141 = v186;
            *(void *)(v14 + 340) = v186;
            *(float *)(v14 + 232) = (float)((float)((float)(*(float *)&v138 + *(float *)&v139) + *(float *)&v140)
                                          + *(float *)&v141)
                                  * 0.25;
            *(float *)(v14 + 236) = (float)((float)((float)(*((float *)&v138 + 1) + *((float *)&v139 + 1))
                                                  + *((float *)&v140 + 1))
                                          + *((float *)&v141 + 1))
                                  * 0.25;
            float v125 = (float)(vabds_f32((float)(*(float *)&v139 - *(float *)&v138)* (float)(*((float *)&v140 + 1) - *((float *)&v138 + 1)), (float)(*((float *)&v139 + 1) - *((float *)&v138 + 1))* (float)(*(float *)&v140 - *(float *)&v138))+ vabds_f32((float)(*((float *)&v138 + 1) - *((float *)&v140 + 1))* (float)(*(float *)&v141 - *(float *)&v140), (float)(*(float *)&v138 - *(float *)&v140)* (float)(*((float *)&v141 + 1) - *((float *)&v140 + 1))))* 0.5;
LABEL_52:
            *(float *)(v14 + 240) = v125;
            *(_DWORD *)(v14 + 244) = v118;
            v14 += 348;
            goto LABEL_23;
          case 9:
            uint64_t v73 = v17 + 4;
            if (v17 + 4 > v11)
            {
              unsigned long long v142 = *(void **)(v8 + 56);
              unint64_t v11 = v160 + v17;
              size_t v143 = 116 * (v160 + v17);
              *(void *)(v8 + 16) = v143;
              char v144 = malloc_type_realloc(v142, v143, 0x4A1BFCC3uLL);
              *(void *)(v8 + 56) = v144;
              uint64_t v14 = (uint64_t)v144 + 116 * v17;
            }
            unint64_t v145 = v180;
            uint64_t v146 = v181;
            *(void *)(v14 + 84) = v180;
            *(void *)(v14 + 92) = v146;
            uint64_t v147 = v182;
            uint64_t v148 = v183;
            *(void *)(v14 + 100) = v182;
            *(void *)(v14 + 108) = v148;
            *(float *)uint64_t v14 = (float)((float)((float)(*(float *)&v145 + *(float *)&v146) + *(float *)&v147)
                                  + *(float *)&v148)
                          * 0.25;
            *(float *)(v14 + 4) = (float)((float)((float)(*((float *)&v145 + 1) + *((float *)&v146 + 1))
                                                + *((float *)&v147 + 1))
                                        + *((float *)&v148 + 1))
                                * 0.25;
            *(float *)(v14 + 8) = (float)(vabds_f32((float)(*(float *)&v146 - *(float *)&v145)* (float)(*((float *)&v147 + 1) - *((float *)&v145 + 1)), (float)(*((float *)&v146 + 1) - *((float *)&v145 + 1))* (float)(*(float *)&v147 - *(float *)&v145))+ vabds_f32((float)(*((float *)&v145 + 1) - *((float *)&v147 + 1))* (float)(*(float *)&v148 - *(float *)&v147), (float)(*(float *)&v145 - *(float *)&v147)* (float)(*((float *)&v148 + 1) - *((float *)&v147 + 1))))* 0.5;
            LODWORD(v145) = (4 * ((v52 ^ v18) & 1)) | (2 * (v52 & 1)) | v50 | v51;
            *(_DWORD *)(v14 + 12) = v145;
            unint64_t v149 = v180;
            uint64_t v150 = v183;
            *(void *)(v14 + 200) = v180;
            *(void *)(v14 + 208) = v150;
            uint64_t v151 = v185;
            uint64_t v152 = v188;
            *(void *)(v14 + 316) = v150;
            uint64_t v153 = v184;
            *(void *)(v14 + 332) = v151;
            *(void *)(v14 + 340) = v150;
            *(void *)(v14 + 216) = v151;
            *(void *)(v14 + 224) = v152;
            *(void *)(v14 + 324) = v153;
            *(float *)(v14 + 116) = (float)((float)((float)(*(float *)&v149 + *(float *)&v150) + *(float *)&v151)
                                          + *(float *)&v152)
                                  * 0.25;
            *(float *)(v14 + 120) = (float)((float)((float)(*((float *)&v149 + 1) + *((float *)&v150 + 1))
                                                  + *((float *)&v151 + 1))
                                          + *((float *)&v152 + 1))
                                  * 0.25;
            *(float *)(v14 + 124) = (float)(vabds_f32((float)(*(float *)&v150 - *(float *)&v149)* (float)(*((float *)&v151 + 1) - *((float *)&v149 + 1)), (float)(*((float *)&v150 + 1) - *((float *)&v149 + 1))* (float)(*(float *)&v151 - *(float *)&v149))+ vabds_f32((float)(*((float *)&v149 + 1) - *((float *)&v151 + 1))* (float)(*(float *)&v152 - *(float *)&v151), (float)(*(float *)&v149 - *(float *)&v151)* (float)(*((float *)&v152 + 1) - *((float *)&v151 + 1))))* 0.5;
            *(_DWORD *)(v14 + 128) = v145;
            uint64_t v155 = v186;
            uint64_t v154 = v187;
            *(void *)(v14 + 432) = v187;
            *(void *)(v14 + 440) = v153;
            *(float *)(v14 + 232) = (float)((float)(*(float *)&v150 + *(float *)&v153) + *(float *)&v151) / 3.0;
            *(float *)(v14 + 236) = (float)((float)(*((float *)&v150 + 1) + *((float *)&v153 + 1))
                                          + *((float *)&v151 + 1))
                                  / 3.0;
            *(float *)(v14 + 240) = vabds_f32((float)(*(float *)&v153 - *(float *)&v150)* (float)(*((float *)&v151 + 1) - *((float *)&v150 + 1)), (float)(*((float *)&v153 + 1) - *((float *)&v150 + 1))* (float)(*(float *)&v151 - *(float *)&v150))* 0.5;
            *(_DWORD *)(v14 + 244) = v145;
            *(void *)(v14 + 448) = v151;
            *(void *)(v14 + 456) = v155;
            *(float *)(v14 + 348) = (float)((float)((float)(*(float *)&v154 + *(float *)&v153) + *(float *)&v151)
                                          + *(float *)&v155)
                                  * 0.25;
            *(float *)(v14 + 352) = (float)((float)((float)(*((float *)&v154 + 1) + *((float *)&v153 + 1))
                                                  + *((float *)&v151 + 1))
                                          + *((float *)&v155 + 1))
                                  * 0.25;
            *(float *)(v14 + 356) = (float)(vabds_f32((float)(*(float *)&v153 - *(float *)&v154)* (float)(*((float *)&v151 + 1) - *((float *)&v154 + 1)), (float)(*((float *)&v153 + 1) - *((float *)&v154 + 1))* (float)(*(float *)&v151 - *(float *)&v154))+ vabds_f32((float)(*((float *)&v154 + 1) - *((float *)&v151 + 1))* (float)(*(float *)&v155 - *(float *)&v151), (float)(*(float *)&v154 - *(float *)&v151)* (float)(*((float *)&v155 + 1) - *((float *)&v151 + 1))))* 0.5;
            *(_DWORD *)(v14 + 360) = v145;
            v14 += 464;
LABEL_23:
            uint64_t v17 = v73;
            break;
          default:
            break;
        }
        float v176 = v63;
        float v177 = v62;
        ++v52;
        float32x2_t v43 = v179;
      }
LABEL_6:
      ++v18;
      uint64_t v21 = (uint64_t)v161;
    }
    while (v162 != v159);
  }
  *(void *)(v8 + 64) = 0x34F72C234F72C235 * ((v14 - *(void *)(v8 + 56)) >> 2);
  return this;
}

void HGFractured::Effect::gen_glass_2(HGFractured::Effect *this, int a2, int a3, float a4)
{
  uint64_t v165 = *MEMORY[0x1E4F143B8];
  int v5 = (int)fmaxf((float)a3, 2.0);
  uint64_t v6 = (int)fmaxf((float)a2, 4.0);
  unint64_t v7 = v5 * v6 + 4;
  size_t v8 = 116 * v7;
  if (*((void *)this + 2) >= 116 * v7)
  {
    unint64_t v7 = *((void *)this + 2) / 0x74uLL;
    uint64_t v10 = (char *)*((void *)this + 7);
  }
  else
  {
    int v9 = (void *)*((void *)this + 7);
    *((void *)this + 2) = v8;
    uint64_t v10 = (char *)malloc_type_realloc(v9, v8, 0x70B54298uLL);
    *((void *)this + 7) = v10;
  }
  uint64_t v134 = this;
  double v11 = log2((double)(2 * v5));
  int v157 = -1090519040;
  float v158 = -(float)(a4 * 0.5);
  int v159 = 1056964608;
  float v160 = v158;
  int v161 = 1056964608;
  float v162 = a4 * 0.5;
  int v163 = -1090519040;
  float v164 = a4 * 0.5;
  if ((int)v6 >= 1)
  {
    uint64_t v12 = 0;
    int v136 = 0;
    float v13 = 6.28318531 / (double)(int)v6;
    float v14 = 0.25 / (double)v5;
    float v15 = v11;
    float v138 = v15;
    float v126 = v14;
    float v127 = v13;
    double v137 = v14;
    double v16 = (double)(int)v6 + -1.0;
    uint64_t v132 = v6 + 3;
    uint64_t v133 = v6 + 1;
    uint64_t v130 = v6 + 4;
    uint64_t v131 = v6 + 2;
    float v17 = 0.0;
    int v128 = v6;
LABEL_7:
    if (v12 + 1 > v7)
    {
      int v18 = (void *)*((void *)v134 + 7);
      unint64_t v7 = v133 + v12;
      size_t v19 = 116 * (v133 + v12);
      *((void *)v134 + 2) = v19;
      float v20 = (char *)malloc_type_realloc(v18, v19, 0x19A1A0CEuLL);
      *((void *)v134 + 7) = v20;
      uint64_t v10 = &v20[116 * v12];
    }
    float v17 = (float)((16598013 * vcvts_n_s32_f32(v17, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
    __float2 v21 = __sincosf_stret(v127 * (float)v136);
    int v129 = v136 + 1;
    __float2 v22 = __sincosf_stret(v127 * (float)(v136 + 1));
    float v23 = v22.__cosval * v126;
    *((float *)v10 + 21) = v22.__cosval * v126;
    *((float *)v10 + 22) = v22.__sinval * v126;
    *((float *)v10 + 27) = v22.__cosval * v126;
    *((float *)v10 + 28) = v22.__sinval * v126;
    float v24 = v21.__cosval * v126;
    *((float *)v10 + 25) = v21.__cosval * v126;
    *((float *)v10 + 26) = v21.__sinval * v126;
    uint64_t v25 = COERCE_UNSIGNED_INT(v21.__sinval * v126);
    *((_DWORD *)v10 + 23) = 0;
    *((_DWORD *)v10 + 24) = 0;
    *(float *)uint64_t v10 = (float)((float)((float)(v21.__cosval * v126) + 0.0) + (float)(v22.__cosval * v126)) / 3.0;
    *((float *)v10 + 1) = (float)((float)((float)(v21.__sinval * v126) + 0.0) + (float)(v22.__sinval * v126)) / 3.0;
    int v135 = v136 & 1;
    *((float *)v10 + 2) = vabds_f32((float)(0.0 - (float)(v22.__cosval * v126))* (float)((float)(v21.__sinval * v126) - (float)(v22.__sinval * v126)), (float)(0.0 - (float)(v22.__sinval * v126))* (float)((float)(v21.__cosval * v126) - (float)(v22.__cosval * v126)))* 0.5;
    *((_DWORD *)v10 + 3) = (4 * v135) | (8 * (v17 < 0.5)) | v135;
    v10 += 116;
    int v26 = 1;
    char v27 = 2;
    ++v12;
    uint64_t v28 = COERCE_UNSIGNED_INT(v22.__sinval * v126);
    while (1)
    {
      float v17 = (float)((16598013 * vcvts_n_s32_f32(v17, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
      float v38 = exp2((float)(v138 * (float)v26) / v16) * v137;
      unint64_t v151 = LODWORD(v24) | (unint64_t)(v25 << 32);
      float v152 = v21.__cosval * v38;
      float v153 = v21.__sinval * v38;
      float v154 = v22.__cosval * v38;
      float v155 = v22.__sinval * v38;
      unint64_t v156 = LODWORD(v23) | (unint64_t)(v28 << 32);
      float v23 = v22.__cosval * v38;
      uint64_t v28 = COERCE_UNSIGNED_INT(v22.__sinval * v38);
      float v24 = v21.__cosval * v38;
      uint64_t v25 = COERCE_UNSIGNED_INT(v21.__sinval * v38);
      switch(clip((uint64_t)&v157, (float *)&v151, (uint64_t)&v142, a4))
      {
        case 0u:
        case 1u:
        case 2u:
          ++v136;
          if (v129 != v128) {
            goto LABEL_7;
          }
          goto LABEL_37;
        case 3u:
          float v140 = v24;
          uint64_t v39 = v25;
          float v40 = v23;
          uint64_t v41 = v28;
          uint64_t v42 = v12 + 1;
          if (v12 + 1 > v7)
          {
            float32x2_t v43 = (void *)*((void *)v134 + 7);
            unint64_t v7 = v133 + v12;
            size_t v44 = 116 * (v133 + v12);
            *((void *)v134 + 2) = v44;
            uint64_t v45 = (char *)malloc_type_realloc(v43, v44, 0x81342ADBuLL);
            *((void *)v134 + 7) = v45;
            uint64_t v10 = &v45[116 * v12];
          }
          unint64_t v46 = v142;
          uint64_t v47 = v143;
          *(void *)(v10 + 84) = v142;
          *(void *)(v10 + 92) = v47;
          *(void *)(v10 + 108) = v46;
          unint64_t v48 = HIDWORD(v46);
          float v49 = *(float *)&v46;
          uint64_t v50 = v144;
          *(void *)(v10 + 100) = v144;
          *(float *)uint64_t v10 = (float)((float)(v49 + *(float *)&v47) + *(float *)&v50) / 3.0;
          *((float *)v10 + 1) = (float)((float)(*(float *)&v48 + *((float *)&v47 + 1)) + *((float *)&v50 + 1)) / 3.0;
          float v51 = vabds_f32((float)(*(float *)&v47 - v49) * (float)(*((float *)&v50 + 1) - *(float *)&v48), (float)(*((float *)&v47 + 1) - *(float *)&v48) * (float)(*(float *)&v50 - v49));
          goto LABEL_21;
        case 4u:
          float v140 = v24;
          uint64_t v39 = v25;
          float v40 = v23;
          uint64_t v41 = v28;
          uint64_t v42 = v12 + 1;
          if (v12 + 1 > v7)
          {
            int v52 = (void *)*((void *)v134 + 7);
            size_t v53 = 116 * (v133 + v12);
            *((void *)v134 + 2) = v53;
            uint64_t v54 = (char *)malloc_type_realloc(v52, v53, 0x45C63B28uLL);
            *((void *)v134 + 7) = v54;
            uint64_t v10 = &v54[116 * v12];
            unint64_t v7 = v133 + v12;
          }
          unint64_t v55 = v142;
          uint64_t v56 = v143;
          *(void *)(v10 + 84) = v142;
          *(void *)(v10 + 92) = v56;
          unint64_t v57 = HIDWORD(v55);
          float v58 = *(float *)&v55;
          uint64_t v59 = v144;
          uint64_t v60 = v145;
          *(void *)(v10 + 100) = v144;
          *(void *)(v10 + 108) = v60;
          *(float *)uint64_t v10 = (float)((float)((float)(v58 + *(float *)&v56) + *(float *)&v59) + *(float *)&v60) * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*(float *)&v57 + *((float *)&v56 + 1)) + *((float *)&v59 + 1))
                                      + *((float *)&v60 + 1))
                              * 0.25;
          float v51 = vabds_f32((float)(*(float *)&v56 - v58) * (float)(*((float *)&v59 + 1) - *(float *)&v57), (float)(*((float *)&v56 + 1) - *(float *)&v57) * (float)(*(float *)&v59 - v58))+ vabds_f32((float)(*(float *)&v57 - *((float *)&v59 + 1)) * (float)(*(float *)&v60 - *(float *)&v59), (float)(v58 - *(float *)&v59) * (float)(*((float *)&v60 + 1) - *((float *)&v59 + 1)));
LABEL_21:
          *((float *)v10 + 2) = v51 * 0.5;
          *((_DWORD *)v10 + 3) = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          v10 += 116;
          uint64_t v12 = v42;
          uint64_t v28 = v41;
          float v23 = v40;
          uint64_t v25 = v39;
          float v24 = v140;
          break;
        case 5u:
          uint64_t v141 = v28;
          uint64_t v61 = v12 + 2;
          if (v12 + 2 > v7)
          {
            unint64_t v80 = (void *)*((void *)v134 + 7);
            size_t v81 = 116 * (v131 + v12);
            *((void *)v134 + 2) = v81;
            unint64_t v82 = (char *)malloc_type_realloc(v80, v81, 0xEC1F2C52uLL);
            *((void *)v134 + 7) = v82;
            uint64_t v10 = &v82[116 * v12];
            unint64_t v7 = v131 + v12;
          }
          unint64_t v29 = v142;
          uint64_t v30 = v143;
          *(void *)(v10 + 84) = v142;
          *(void *)(v10 + 92) = v30;
          uint64_t v31 = v144;
          uint64_t v32 = v145;
          *(void *)(v10 + 100) = v144;
          *(void *)(v10 + 108) = v32;
          *(float *)uint64_t v10 = (float)((float)((float)(*(float *)&v29 + *(float *)&v30) + *(float *)&v31) + *(float *)&v32)
                        * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*((float *)&v29 + 1) + *((float *)&v30 + 1))
                                              + *((float *)&v31 + 1))
                                      + *((float *)&v32 + 1))
                              * 0.25;
          *((float *)v10 + 2) = (float)(vabds_f32((float)(*(float *)&v30 - *(float *)&v29)* (float)(*((float *)&v31 + 1) - *((float *)&v29 + 1)), (float)(*((float *)&v30 + 1) - *((float *)&v29 + 1))* (float)(*(float *)&v31 - *(float *)&v29))+ vabds_f32((float)(*((float *)&v29 + 1) - *((float *)&v31 + 1))* (float)(*(float *)&v32 - *(float *)&v31), (float)(*(float *)&v29 - *(float *)&v31)* (float)(*((float *)&v32 + 1) - *((float *)&v31 + 1))))* 0.5;
          int v33 = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          *((_DWORD *)v10 + 3) = v33;
          unint64_t v34 = v142;
          uint64_t v35 = v145;
          uint64_t v36 = v146;
          *((void *)v10 + 27) = v146;
          *((void *)v10 + 28) = v34;
          *((void *)v10 + 25) = v34;
          *((void *)v10 + 26) = v35;
          *((float *)v10 + 29) = (float)((float)(*(float *)&v34 + *(float *)&v35) + *(float *)&v36) / 3.0;
          *((float *)v10 + 30) = (float)((float)(*((float *)&v34 + 1) + *((float *)&v35 + 1)) + *((float *)&v36 + 1))
                               / 3.0;
          float v37 = vabds_f32((float)(*(float *)&v35 - *(float *)&v34) * (float)(*((float *)&v36 + 1) - *((float *)&v34 + 1)), (float)(*((float *)&v35 + 1) - *((float *)&v34 + 1)) * (float)(*(float *)&v36 - *(float *)&v34));
          goto LABEL_11;
        case 6u:
          uint64_t v141 = v28;
          uint64_t v61 = v12 + 2;
          if (v12 + 2 > v7)
          {
            float v83 = (void *)*((void *)v134 + 7);
            size_t v84 = 116 * (v131 + v12);
            *((void *)v134 + 2) = v84;
            uint64_t v85 = (char *)malloc_type_realloc(v83, v84, 0xCE099756uLL);
            *((void *)v134 + 7) = v85;
            uint64_t v10 = &v85[116 * v12];
            unint64_t v7 = v131 + v12;
          }
          unint64_t v86 = v142;
          uint64_t v87 = v143;
          *(void *)(v10 + 84) = v142;
          *(void *)(v10 + 92) = v87;
          uint64_t v88 = v144;
          uint64_t v89 = v145;
          *(void *)(v10 + 100) = v144;
          *(void *)(v10 + 108) = v89;
          *(float *)uint64_t v10 = (float)((float)((float)(*(float *)&v86 + *(float *)&v87) + *(float *)&v88) + *(float *)&v89)
                        * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*((float *)&v86 + 1) + *((float *)&v87 + 1))
                                              + *((float *)&v88 + 1))
                                      + *((float *)&v89 + 1))
                              * 0.25;
          *((float *)v10 + 2) = (float)(vabds_f32((float)(*(float *)&v87 - *(float *)&v86)* (float)(*((float *)&v88 + 1) - *((float *)&v86 + 1)), (float)(*((float *)&v87 + 1) - *((float *)&v86 + 1))* (float)(*(float *)&v88 - *(float *)&v86))+ vabds_f32((float)(*((float *)&v86 + 1) - *((float *)&v88 + 1))* (float)(*(float *)&v89 - *(float *)&v88), (float)(*(float *)&v86 - *(float *)&v88)* (float)(*((float *)&v89 + 1) - *((float *)&v88 + 1))))* 0.5;
          int v33 = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          *((_DWORD *)v10 + 3) = v33;
          unint64_t v90 = v142;
          uint64_t v91 = v145;
          *((void *)v10 + 25) = v142;
          *((void *)v10 + 26) = v91;
          unint64_t v92 = HIDWORD(v90);
          float v93 = *(float *)&v90;
          uint64_t v94 = v146;
          uint64_t v95 = v147;
          *((void *)v10 + 27) = v146;
          *((void *)v10 + 28) = v95;
          *((float *)v10 + 29) = (float)((float)((float)(v93 + *(float *)&v91) + *(float *)&v94) + *(float *)&v95)
                               * 0.25;
          *((float *)v10 + 30) = (float)((float)((float)(*(float *)&v92 + *((float *)&v91 + 1)) + *((float *)&v94 + 1))
                                       + *((float *)&v95 + 1))
                               * 0.25;
          float v37 = vabds_f32((float)(*(float *)&v91 - v93) * (float)(*((float *)&v94 + 1) - *(float *)&v92), (float)(*((float *)&v91 + 1) - *(float *)&v92) * (float)(*(float *)&v94 - v93))+ vabds_f32((float)(*(float *)&v92 - *((float *)&v94 + 1)) * (float)(*(float *)&v95 - *(float *)&v94), (float)(v93 - *(float *)&v94) * (float)(*((float *)&v95 + 1) - *((float *)&v94 + 1)));
LABEL_11:
          *((float *)v10 + 31) = v37 * 0.5;
          *((_DWORD *)v10 + 32) = v33;
          v10 += 232;
          goto LABEL_12;
        case 7u:
          uint64_t v141 = v28;
          uint64_t v61 = v12 + 3;
          if (v12 + 3 > v7)
          {
            float v62 = (void *)*((void *)v134 + 7);
            size_t v63 = 116 * (v132 + v12);
            *((void *)v134 + 2) = v63;
            int32x2_t v64 = (char *)malloc_type_realloc(v62, v63, 0x975870BCuLL);
            *((void *)v134 + 7) = v64;
            uint64_t v10 = &v64[116 * v12];
            unint64_t v7 = v132 + v12;
          }
          unint64_t v65 = v142;
          uint64_t v66 = v143;
          *(void *)(v10 + 84) = v142;
          *(void *)(v10 + 92) = v66;
          uint64_t v67 = v144;
          uint64_t v68 = v145;
          *(void *)(v10 + 100) = v144;
          *(void *)(v10 + 108) = v68;
          *(float *)uint64_t v10 = (float)((float)((float)(*(float *)&v65 + *(float *)&v66) + *(float *)&v67) + *(float *)&v68)
                        * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*((float *)&v65 + 1) + *((float *)&v66 + 1))
                                              + *((float *)&v67 + 1))
                                      + *((float *)&v68 + 1))
                              * 0.25;
          *((float *)v10 + 2) = (float)(vabds_f32((float)(*(float *)&v66 - *(float *)&v65)* (float)(*((float *)&v67 + 1) - *((float *)&v65 + 1)), (float)(*((float *)&v66 + 1) - *((float *)&v65 + 1))* (float)(*(float *)&v67 - *(float *)&v65))+ vabds_f32((float)(*((float *)&v65 + 1) - *((float *)&v67 + 1))* (float)(*(float *)&v68 - *(float *)&v67), (float)(*(float *)&v65 - *(float *)&v67)* (float)(*((float *)&v68 + 1) - *((float *)&v67 + 1))))* 0.5;
          int v69 = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          *((_DWORD *)v10 + 3) = v69;
          unint64_t v70 = v142;
          uint64_t v71 = v145;
          uint64_t v72 = v148;
          *((void *)v10 + 27) = v148;
          *((void *)v10 + 28) = v70;
          *((void *)v10 + 25) = v70;
          *((void *)v10 + 26) = v71;
          *(void *)(v10 + 316) = v72;
          *(void *)(v10 + 324) = v71;
          float v74 = *((float *)&v71 + 1);
          float v73 = *(float *)&v71;
          *((float *)v10 + 29) = (float)((float)(*(float *)&v70 + *(float *)&v71) + *(float *)&v72) / 3.0;
          *((float *)v10 + 30) = (float)((float)(*((float *)&v70 + 1) + *((float *)&v71 + 1)) + *((float *)&v72 + 1))
                               / 3.0;
          *((float *)v10 + 31) = vabds_f32((float)(*(float *)&v71 - *(float *)&v70)* (float)(*((float *)&v72 + 1) - *((float *)&v70 + 1)), (float)(*((float *)&v71 + 1) - *((float *)&v70 + 1))* (float)(*(float *)&v72 - *(float *)&v70))* 0.5;
          *((_DWORD *)v10 + 32) = v69;
          uint64_t v75 = v146;
          *(void *)(v10 + 332) = v146;
          uint64_t v76 = v147;
          *(void *)(v10 + 340) = v147;
          *((float *)v10 + 58) = (float)((float)((float)(*(float *)&v72 + v73) + *(float *)&v75) + *(float *)&v76)
                               * 0.25;
          *((float *)v10 + 59) = (float)((float)((float)(*((float *)&v72 + 1) + v74) + *((float *)&v75 + 1))
                                       + *((float *)&v76 + 1))
                               * 0.25;
          float v77 = vabds_f32((float)(v73 - *(float *)&v72) * (float)(*((float *)&v75 + 1) - *((float *)&v72 + 1)), (float)(v74 - *((float *)&v72 + 1)) * (float)(*(float *)&v75 - *(float *)&v72));
          float v78 = (float)(*((float *)&v72 + 1) - *((float *)&v75 + 1)) * (float)(*(float *)&v76 - *(float *)&v75);
          float v79 = (float)(*(float *)&v72 - *(float *)&v75) * (float)(*((float *)&v76 + 1) - *((float *)&v75 + 1));
          goto LABEL_33;
        case 8u:
          uint64_t v141 = v28;
          uint64_t v61 = v12 + 3;
          if (v12 + 3 > v7)
          {
            uint64_t v96 = (void *)*((void *)v134 + 7);
            size_t v97 = 116 * (v132 + v12);
            *((void *)v134 + 2) = v97;
            float v98 = (char *)malloc_type_realloc(v96, v97, 0x8B4ABC86uLL);
            *((void *)v134 + 7) = v98;
            uint64_t v10 = &v98[116 * v12];
            unint64_t v7 = v132 + v12;
          }
          unint64_t v99 = v142;
          uint64_t v100 = v143;
          *(void *)(v10 + 84) = v142;
          *(void *)(v10 + 92) = v100;
          uint64_t v101 = v144;
          uint64_t v102 = v145;
          *(void *)(v10 + 100) = v144;
          *(void *)(v10 + 108) = v102;
          *(float *)uint64_t v10 = (float)((float)((float)(*(float *)&v99 + *(float *)&v100) + *(float *)&v101) + *(float *)&v102)
                        * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*((float *)&v99 + 1) + *((float *)&v100 + 1))
                                              + *((float *)&v101 + 1))
                                      + *((float *)&v102 + 1))
                              * 0.25;
          *((float *)v10 + 2) = (float)(vabds_f32((float)(*(float *)&v100 - *(float *)&v99)* (float)(*((float *)&v101 + 1) - *((float *)&v99 + 1)), (float)(*((float *)&v100 + 1) - *((float *)&v99 + 1))* (float)(*(float *)&v101 - *(float *)&v99))+ vabds_f32((float)(*((float *)&v99 + 1) - *((float *)&v101 + 1))* (float)(*(float *)&v102 - *(float *)&v101), (float)(*(float *)&v99 - *(float *)&v101)* (float)(*((float *)&v102 + 1) - *((float *)&v101 + 1))))* 0.5;
          int v69 = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          *((_DWORD *)v10 + 3) = v69;
          unint64_t v103 = v142;
          uint64_t v104 = v145;
          *((void *)v10 + 25) = v142;
          *((void *)v10 + 26) = v104;
          unint64_t v105 = HIDWORD(v103);
          float v106 = *(float *)&v103;
          uint64_t v107 = v146;
          uint64_t v108 = v149;
          *((void *)v10 + 27) = v146;
          *((void *)v10 + 28) = v108;
          *(void *)(v10 + 316) = v108;
          *(void *)(v10 + 324) = v107;
          uint64_t v109 = v107;
          *((float *)v10 + 29) = (float)((float)((float)(v106 + *(float *)&v104) + *(float *)&v107) + *(float *)&v108)
                               * 0.25;
          *((float *)v10 + 30) = (float)((float)((float)(*(float *)&v105 + *((float *)&v104 + 1)) + *((float *)&v107 + 1))
                                       + *((float *)&v108 + 1))
                               * 0.25;
          *((float *)v10 + 31) = (float)(vabds_f32((float)(*(float *)&v104 - v106)* (float)(*((float *)&v107 + 1) - *(float *)&v105), (float)(*((float *)&v104 + 1) - *(float *)&v105)* (float)(*(float *)&v107 - v106))+ vabds_f32((float)(*(float *)&v105 - *((float *)&v107 + 1))* (float)(*(float *)&v108 - *(float *)&v107), (float)(v106 - *(float *)&v107)* (float)(*((float *)&v108 + 1) - *((float *)&v107 + 1))))* 0.5;
          *((_DWORD *)v10 + 32) = v69;
          uint64_t v110 = v147;
          *(void *)(v10 + 332) = v147;
          uint64_t v111 = v148;
          *(void *)(v10 + 340) = v148;
          *((float *)v10 + 58) = (float)((float)((float)(*(float *)&v108 + *(float *)&v109) + *(float *)&v110)
                                       + *(float *)&v111)
                               * 0.25;
          *((float *)v10 + 59) = (float)((float)((float)(*((float *)&v108 + 1) + *((float *)&v109 + 1))
                                               + *((float *)&v110 + 1))
                                       + *((float *)&v111 + 1))
                               * 0.25;
          float v77 = vabds_f32((float)(*(float *)&v109 - *(float *)&v108) * (float)(*((float *)&v110 + 1) - *((float *)&v108 + 1)), (float)(*((float *)&v109 + 1) - *((float *)&v108 + 1)) * (float)(*(float *)&v110 - *(float *)&v108));
          float v78 = (float)(*((float *)&v108 + 1) - *((float *)&v110 + 1)) * (float)(*(float *)&v111 - *(float *)&v110);
          float v79 = (float)(*(float *)&v108 - *(float *)&v110) * (float)(*((float *)&v111 + 1) - *((float *)&v110 + 1));
LABEL_33:
          *((float *)v10 + 60) = (float)(v77 + vabds_f32(v78, v79)) * 0.5;
          *((_DWORD *)v10 + 61) = v69;
          v10 += 348;
          goto LABEL_12;
        case 9u:
          uint64_t v141 = v28;
          uint64_t v61 = v12 + 4;
          if (v12 + 4 > v7)
          {
            size_t v112 = (void *)*((void *)v134 + 7);
            size_t v113 = 116 * (v130 + v12);
            *((void *)v134 + 2) = v113;
            unint64_t v114 = (char *)malloc_type_realloc(v112, v113, 0xFEBABAD4uLL);
            *((void *)v134 + 7) = v114;
            uint64_t v10 = &v114[116 * v12];
            unint64_t v7 = v130 + v12;
          }
          unint64_t v115 = v142;
          uint64_t v116 = v143;
          *(void *)(v10 + 84) = v142;
          *(void *)(v10 + 92) = v116;
          uint64_t v117 = v144;
          uint64_t v118 = v145;
          *(void *)(v10 + 100) = v144;
          *(void *)(v10 + 108) = v118;
          *(float *)uint64_t v10 = (float)((float)((float)(*(float *)&v115 + *(float *)&v116) + *(float *)&v117) + *(float *)&v118)
                        * 0.25;
          *((float *)v10 + 1) = (float)((float)((float)(*((float *)&v115 + 1) + *((float *)&v116 + 1))
                                              + *((float *)&v117 + 1))
                                      + *((float *)&v118 + 1))
                              * 0.25;
          *((float *)v10 + 2) = (float)(vabds_f32((float)(*(float *)&v116 - *(float *)&v115)* (float)(*((float *)&v117 + 1) - *((float *)&v115 + 1)), (float)(*((float *)&v116 + 1) - *((float *)&v115 + 1))* (float)(*(float *)&v117 - *(float *)&v115))+ vabds_f32((float)(*((float *)&v115 + 1) - *((float *)&v117 + 1))* (float)(*(float *)&v118 - *(float *)&v117), (float)(*(float *)&v115 - *(float *)&v117)* (float)(*((float *)&v118 + 1) - *((float *)&v117 + 1))))* 0.5;
          LODWORD(v115) = v27 & 2 | (4 * ((v26 ^ v136) & 1)) | (8 * (v17 < 0.5)) | v135;
          *((_DWORD *)v10 + 3) = v115;
          unint64_t v119 = v142;
          uint64_t v120 = v145;
          *((void *)v10 + 25) = v142;
          *((void *)v10 + 26) = v120;
          uint64_t v121 = v147;
          uint64_t v122 = v150;
          *(void *)(v10 + 316) = v120;
          uint64_t v123 = v146;
          *(void *)(v10 + 332) = v121;
          *(void *)(v10 + 340) = v120;
          *((void *)v10 + 27) = v121;
          *((void *)v10 + 28) = v122;
          *(void *)(v10 + 324) = v123;
          *((float *)v10 + 29) = (float)((float)((float)(*(float *)&v119 + *(float *)&v120) + *(float *)&v121)
                                       + *(float *)&v122)
                               * 0.25;
          *((float *)v10 + 30) = (float)((float)((float)(*((float *)&v119 + 1) + *((float *)&v120 + 1))
                                               + *((float *)&v121 + 1))
                                       + *((float *)&v122 + 1))
                               * 0.25;
          *((float *)v10 + 31) = (float)(vabds_f32((float)(*(float *)&v120 - *(float *)&v119)* (float)(*((float *)&v121 + 1) - *((float *)&v119 + 1)), (float)(*((float *)&v120 + 1) - *((float *)&v119 + 1))* (float)(*(float *)&v121 - *(float *)&v119))+ vabds_f32((float)(*((float *)&v119 + 1) - *((float *)&v121 + 1))* (float)(*(float *)&v122 - *(float *)&v121), (float)(*(float *)&v119 - *(float *)&v121)* (float)(*((float *)&v122 + 1) - *((float *)&v121 + 1))))* 0.5;
          *((_DWORD *)v10 + 32) = v115;
          uint64_t v125 = v148;
          uint64_t v124 = v149;
          *((void *)v10 + 54) = v149;
          *((void *)v10 + 55) = v123;
          *((float *)v10 + 58) = (float)((float)(*(float *)&v120 + *(float *)&v123) + *(float *)&v121) / 3.0;
          *((float *)v10 + 59) = (float)((float)(*((float *)&v120 + 1) + *((float *)&v123 + 1)) + *((float *)&v121 + 1))
                               / 3.0;
          *((float *)v10 + 60) = vabds_f32((float)(*(float *)&v123 - *(float *)&v120)* (float)(*((float *)&v121 + 1) - *((float *)&v120 + 1)), (float)(*((float *)&v123 + 1) - *((float *)&v120 + 1))* (float)(*(float *)&v121 - *(float *)&v120))* 0.5;
          *((_DWORD *)v10 + 61) = v115;
          *((void *)v10 + 56) = v121;
          *((void *)v10 + 57) = v125;
          *((float *)v10 + 87) = (float)((float)((float)(*(float *)&v124 + *(float *)&v123) + *(float *)&v121)
                                       + *(float *)&v125)
                               * 0.25;
          *((float *)v10 + 88) = (float)((float)((float)(*((float *)&v124 + 1) + *((float *)&v123 + 1))
                                               + *((float *)&v121 + 1))
                                       + *((float *)&v125 + 1))
                               * 0.25;
          *((float *)v10 + 89) = (float)(vabds_f32((float)(*(float *)&v123 - *(float *)&v124)* (float)(*((float *)&v121 + 1) - *((float *)&v124 + 1)), (float)(*((float *)&v123 + 1) - *((float *)&v124 + 1))* (float)(*(float *)&v121 - *(float *)&v124))+ vabds_f32((float)(*((float *)&v124 + 1) - *((float *)&v121 + 1))* (float)(*(float *)&v125 - *(float *)&v121), (float)(*(float *)&v124 - *(float *)&v121)* (float)(*((float *)&v125 + 1) - *((float *)&v121 + 1))))* 0.5;
          *((_DWORD *)v10 + 90) = v115;
          v10 += 464;
LABEL_12:
          uint64_t v12 = v61;
          uint64_t v28 = v141;
          break;
        default:
          break;
      }
      ++v26;
      v27 += 2;
    }
  }
LABEL_37:
  *((void *)v134 + 8) = 0x34F72C234F72C235 * ((uint64_t)&v10[-*((void *)v134 + 7)] >> 2);
}

void *HGFractured::Effect::gen_brick(HGFractured::Effect *this, int a2, int a3, float a4, float a5)
{
  uint64_t v10 = (a2 + 1) * (uint64_t)a3;
  size_t v11 = 116 * v10;
  unint64_t v12 = *((void *)this + 2);
  float result = (void *)*((void *)this + 7);
  if (v12 < 116 * v10)
  {
    *((void *)this + 2) = v11;
    float result = malloc_type_realloc(result, v11, 0x413E0218uLL);
    *((void *)this + 7) = result;
  }
  *((void *)this + 8) = v10;
  float v14 = 1.0 / (float)a2;
  float v15 = a4 / (float)a3;
  float v16 = a4 * 0.5;
  float v17 = v14 * v15;
  float v18 = -(float)(a4 * 0.5);
  if (a3 <= 1)
  {
    float v32 = -0.5;
    float v33 = (float)((float)((float)(v18 - v16) + v16) + v16) * 0.25;
    if (a2 < 1)
    {
      int v39 = 0;
      int v40 = 8;
      float v37 = (float *)result;
    }
    else
    {
      int v34 = 0;
      float v35 = 0.0;
      float v36 = 1.0;
      float v37 = (float *)result;
      do
      {
        float v38 = v32;
        float v32 = (float)(v14 * (float)((float)((float)(a5 * -0.5) + -0.5) + v36)) + -0.5;
        float v35 = (float)((16598013 * vcvts_n_s32_f32(v35, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v37[21] = v38;
        v37[22] = v18;
        v37[23] = v32;
        v37[24] = v18;
        v37[25] = v32;
        v37[26] = v16;
        v37[27] = v38;
        v37[28] = v16;
        float v36 = (float)(v34 + 2);
        *float v37 = (float)(v38 + (float)(v32 + (float)(v38 + v32))) * 0.25;
        v37[1] = v33;
        v37[2] = v17;
        *((_DWORD *)v37 + 3) = (4 * (v34 & 1)) | (8 * (v35 < 0.5)) | v34 & 1;
        v37 += 29;
        ++v34;
      }
      while (a2 != v34);
      int v39 = a2 & 1;
      int v40 = 8
          * ((float)((float)((16598013 * vcvts_n_s32_f32(v35, 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605) < 0.5);
    }
    v37[21] = v32;
    v37[22] = v18;
    v37[23] = 0.5;
    v37[24] = v18;
    v37[25] = 0.5;
    v37[26] = v16;
    v37[27] = v32;
    v37[28] = v16;
    *float v37 = (float)(v32 + (float)((float)(v32 + 0.5) + 0.5)) * 0.25;
    v37[1] = v33;
    v37[2] = v17;
    int v74 = v40 | (4 * v39) | v39;
  }
  else
  {
    float v19 = -0.5;
    float v20 = (float)(a5 * 0.11803) + -0.5;
    float v21 = v15 - v16;
    int v22 = a2 - (v20 == 0.0);
    float v23 = (float)((float)((float)(v18 - v16) + v21) + v21) * 0.25;
    if (v22 < 1)
    {
      int v30 = 0;
      float32x2_t v31 = (float32x2_t)0x3CB5F4C03D95DBD0;
      uint64_t v28 = (float *)result;
    }
    else
    {
      int v24 = 0;
      float32x2_t v25 = (float32x2_t)0x3F1E37793E2C210CLL;
      float v26 = 1.0;
      float32x2_t v27 = (float32x2_t)vdup_n_s32(0x33800000u);
      uint64_t v28 = (float *)result;
      do
      {
        float v29 = v19;
        float v19 = (float)(v14 * (float)(v20 + v26)) + -0.5;
        float32x2_t v25 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v25, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v27);
        v28[21] = v29;
        v28[22] = v18;
        v28[23] = v19;
        v28[24] = v18;
        v28[25] = v19;
        v28[26] = v21;
        float v26 = (float)(v24 + 2);
        v28[27] = v29;
        v28[28] = v21;
        *uint64_t v28 = (float)(v29 + (float)(v19 + (float)(v29 + v19))) * 0.25;
        v28[1] = v23;
        v28[2] = v17;
        *((_DWORD *)v28 + 3) = (4 * (v24 & 1)) | (8 * (v25.f32[0] < 0.5)) | v24 & 1;
        v28 += 29;
        ++v24;
      }
      while (v22 != v24);
      int v30 = v22 & 1;
      float32x2_t v31 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v25, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), (float32x2_t)vdup_n_s32(0x33800000u));
    }
    v28[21] = v19;
    v28[22] = v18;
    v28[23] = 0.5;
    v28[24] = v18;
    v28[25] = 0.5;
    v28[26] = v21;
    v28[27] = v19;
    v28[28] = v21;
    *uint64_t v28 = (float)(v19 + (float)((float)(v19 + 0.5) + 0.5)) * 0.25;
    v28[1] = v23;
    v28[2] = v17;
    *((_DWORD *)v28 + 3) = (4 * v30) | (8 * (v31.f32[0] < 0.5)) | v30;
    if (a3 <= 2) {
      int v41 = 2;
    }
    else {
      int v41 = a3;
    }
    int v42 = v41 - 1;
    float32x2_t v43 = v28 + 29;
    if (v42 == 1)
    {
      float v37 = v43;
    }
    else
    {
      int v58 = 1;
      float32x2_t v59 = (float32x2_t)vdup_n_s32(0x33800000u);
      do
      {
        int v65 = v58 & 1;
        if (v58) {
          float v66 = 0.0;
        }
        else {
          float v66 = -0.5;
        }
        float v67 = v66 + (float)((float)(v31.f32[1] + -0.5) * a5);
        float v68 = (float)(v15 * (float)((float)v58 + 1.0)) - v16;
        int v60 = a2 - (v67 == 0.0);
        float v69 = (float)(v14 * (float)(v67 + 1.0)) + -0.5;
        float v70 = v68 - v15;
        if (v60 <= 0)
        {
          LOBYTE(v60) = 0;
          float v61 = (float)((float)((float)(v70 + v70) + v68) + v68) * 0.25;
          int v62 = 2 * v65;
          float v63 = -0.5;
        }
        else
        {
          int v71 = 0;
          int v62 = 2 * v65;
          float v61 = (float)((float)((float)(v70 + v70) + v68) + v68) * 0.25;
          float v63 = -0.5;
          do
          {
            float v72 = v63;
            float v63 = v69;
            float32x2_t v31 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v31, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v59);
            v43[21] = v72;
            v43[22] = v70;
            v43[23] = v69;
            v43[24] = v70;
            v43[25] = v69;
            v43[26] = v68;
            v43[27] = v72;
            v43[28] = v68;
            float v73 = v67 + (float)(v71 + 2);
            *float32x2_t v43 = (float)(v72 + (float)(v63 + (float)(v72 + v63))) * 0.25;
            v43[1] = v61;
            v43[2] = v17;
            *((_DWORD *)v43 + 3) = v71 & 1 | (4 * ((v71 ^ v58) & 1)) | (8 * (v31.f32[0] < 0.5)) | v62;
            v43 += 29;
            ++v71;
            float v69 = (float)(v14 * v73) + -0.5;
          }
          while (v60 != v71);
        }
        v43[21] = v63;
        v43[22] = v70;
        v43[23] = v69;
        v43[24] = v70;
        v43[25] = 0.5;
        v43[26] = v68;
        v43[27] = v63;
        v43[28] = v68;
        *float32x2_t v43 = (float)(v63 + (float)((float)(v63 + v69) + 0.5)) * 0.25;
        v43[1] = v61;
        v43[2] = v17;
        int v64 = (4 * ((v60 ^ v58++) & 1)) | v60 & 1 | v62;
        float v37 = v43 + 29;
        float32x2_t v31 = vmul_f32(vcvt_f32_u32((uint32x2_t)(*(void *)&vmla_s32((int32x2_t)0x9E3779002B0843, vcvt_n_s32_f32(v31, 0x18uLL), (int32x2_t)0xBB355500FD43FDLL) & 0xFFFFFF00FFFFFFLL)), v59);
        *((_DWORD *)v43 + 3) = v64 | (8 * (v31.f32[0] < 0.5));
        v43 += 29;
      }
      while (v58 != v42);
    }
    int v44 = v42 & 1;
    float v45 = 0.0;
    float v46 = -0.5;
    if ((v42 & 1) == 0) {
      float v45 = -0.5;
    }
    float v47 = v45 + (float)((float)(v31.f32[1] + -0.5) * a5);
    float v48 = (float)(v14 * (float)(v47 + 1.0)) + -0.5;
    float v49 = v16 - v15;
    int v50 = a2 - v44;
    if (a2 <= v44)
    {
      unsigned __int8 v57 = 0;
      float v52 = (float)((float)((float)(v49 + v49) + v16) + v16) * 0.25;
      int v51 = 2 * v44;
    }
    else
    {
      int v51 = 2 * v44;
      float v52 = (float)((float)((float)(v49 + v49) + v16) + v16) * 0.25;
      int v53 = 2;
      float v46 = -0.5;
      do
      {
        float v54 = v46;
        float v46 = v48;
        v31.f32[0] = (float)((16598013 * vcvts_n_s32_f32(v31.f32[0], 0x18uLL) + 2820163) & 0xFFFFFF) * 0.000000059605;
        v37[21] = v54;
        v37[22] = v49;
        v37[23] = v48;
        v37[24] = v49;
        v37[25] = v48;
        v37[26] = v16;
        v37[27] = v54;
        v37[28] = v16;
        *float v37 = (float)(v54 + (float)(v48 + (float)(v54 + v48))) * 0.25;
        v37[1] = v52;
        v37[2] = v17;
        *((_DWORD *)v37 + 3) = ((_BYTE)v53 - 2) & 1 | (4 * (((v53 - 2) ^ v42) & 1)) | (8 * (v31.f32[0] < 0.5)) | v51;
        v37 += 29;
        float v48 = (float)(v14 * (float)(v47 + (float)v53)) + -0.5;
        char v55 = v53 + 1;
        int v56 = v53++ - 1;
      }
      while (v56 < v50);
      unsigned __int8 v57 = v55 - 2;
    }
    v37[21] = v46;
    v37[22] = v49;
    v37[23] = v48;
    v37[24] = v49;
    v37[25] = 0.5;
    v37[26] = v16;
    v37[27] = v46;
    v37[28] = v16;
    *float v37 = (float)(v46 + (float)((float)(v46 + v48) + 0.5)) * 0.25;
    v37[1] = v52;
    v37[2] = v17;
    int v74 = (4 * ((v57 ^ v42) & 1)) | v57 & 1 | v51 | (8
                                                                    * ((float)((float)((16598013
                                                                                      * vcvts_n_s32_f32(v31.f32[0], 0x18uLL)+ 2820163) & 0xFFFFFF)* 0.000000059605) < 0.5));
  }
  *((_DWORD *)v37 + 3) = v74;
  *((void *)this + 8) = 0x34F72C234F72C235 * (((char *)v37 - (unsigned char *)result) >> 2);
  return result;
}

uint64_t HGFractured::Effect::build(HGFractured::Effect *this)
{
  if ((*((unsigned char *)this + 120) & 2) == 0) {
    return 1;
  }
  float v2 = (uint64_t (*)(HGFractured::Effect *))*((void *)this + 28);
  if (v2)
  {
    *((void *)this + 29) = v2(this);
    *((_DWORD *)this + 30) &= ~2u;
    return 1;
  }
  return 0;
}

uint64_t HGFractured::Effect::apply(HGFractured::Effect *this, __n128 a2, __n128 a3, double a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, double a8, double a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int v17 = *((_DWORD *)this + 30);
  if ((v17 & 4) != 0 || *((float *)this + 22) != a2.n128_f32[0] || *((float *)this + 23) != a3.n128_f32[0])
  {
    float v18 = fabsf(a2.n128_f32[0]);
    if (a2.n128_f32[0] >= 0.0) {
      float v18 = a2.n128_f32[0];
    }
    float v19 = fabsf(a3.n128_f32[0]);
    if (a3.n128_f32[0] >= 0.0) {
      float v19 = a3.n128_f32[0];
    }
    float v20 = *((float *)this + 50);
    if (v18 >= v20)
    {
      float v22 = *((float *)this + 51);
      if (v18 > v22)
      {
        *(float *)&a9 = 1.0 - v22;
        float v23 = fminf(fmaxf((float)(v18 - v22) / (float)(1.0 - v22), 0.0), 1.0);
        *(float *)&a8 = v23 * v23;
        float v18 = v22 + (float)((float)(1.0 - v22) * (float)((float)(v23 * v23) * (float)(3.0 - (float)(v23 + v23))));
      }
    }
    else
    {
      a7.i32[1] = 0;
      float v21 = fminf(fmaxf(v18 / v20, 0.0), 1.0);
      LODWORD(a8) = 3.0;
      float v18 = v20 * (float)((float)(v21 * v21) * (float)(3.0 - (float)(v21 + v21)));
    }
    if (v19 >= v20)
    {
      float v25 = *((float *)this + 51);
      if (v19 > v25)
      {
        *(float *)&a8 = 1.0 - v25;
        float v26 = fminf(fmaxf((float)(v19 - v25) / (float)(1.0 - v25), 0.0), 1.0);
        *(void *)&a9 = COERCE_UNSIGNED_INT(3.0);
        float v19 = v25 + (float)((float)(1.0 - v25) * (float)((float)(v26 * v26) * (float)(3.0 - (float)(v26 + v26))));
      }
    }
    else
    {
      a7.i32[1] = 0;
      float v24 = fminf(fmaxf(v19 / v20, 0.0), 1.0);
      LODWORD(a8) = 3.0;
      float v19 = v20 * (float)((float)(v24 * v24) * (float)(3.0 - (float)(v24 + v24)));
    }
    if (a2.n128_f32[0] >= 0.0) {
      float v27 = v18;
    }
    else {
      float v27 = -v18;
    }
    if (a3.n128_f32[0] >= 0.0) {
      float v28 = v19;
    }
    else {
      float v28 = -v19;
    }
    float v29 = (void (*)(HGFractured::Effect *, void, float))*((void *)this + 29);
    if (v29)
    {
      if ((v17 & 4) == 0)
      {
        if (*((float *)this + 22) != v27) {
          v29(this, 0, v27);
        }
        if (!*((_DWORD *)this + 35) || *((float *)this + 23) == v28) {
          goto LABEL_39;
        }
        goto LABEL_35;
      }
      v29(this, 0, v27);
      if (*((_DWORD *)this + 35)) {
LABEL_35:
      }
        (*((void (**)(HGFractured::Effect *, float))this + 29))(this, v28);
LABEL_39:
      *((float *)this + 22) = v27;
      *((float *)this + 23) = v28;
      *((_DWORD *)this + 30) &= ~4u;
      return 1;
    }
    if ((v17 & 4) == 0 && *((float *)this + 22) == v27)
    {
      int v30 = *((_DWORD *)this + 35);
      if (!v30) {
        goto LABEL_39;
      }
    }
    else
    {
      a2.n128_u32[0] = *((_DWORD *)this + 34);
      a5.i64[0] = 0;
      a6.i64[0] = 0;
      a7.i32[0] = 1.0;
      a3.n128_f32[0] = v27;
      emit((uint64_t)this, *((float **)this + 12), *((float **)this + 7), *((void *)this + 8), *((_DWORD *)this + 31), 0, a2, a3, 0.0, a5, a6, a7, a15, a16, a8, a9, 0.0, 0, 0,
        0x3F800000u);
      int v30 = *((_DWORD *)this + 35);
      if (!v30) {
        goto LABEL_39;
      }
      if ((v17 & 4) != 0)
      {
LABEL_38:
        a2.n128_u32[0] = *((_DWORD *)this + 34);
        a5.i64[0] = 0;
        a6.i64[0] = 0;
        a7.i32[0] = 1.0;
        a3.n128_f32[0] = v28;
        emit((uint64_t)this, *((float **)this + 13), *((float **)this + 7), *((void *)this + 8), *((_DWORD *)this + 31), v30, a2, a3, 0.0, a5, a6, a7, a15, a16, a8, a9, 0.0, 0, 0,
          0x3F800000u);
        goto LABEL_39;
      }
    }
    if (*((float *)this + 23) == v28) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
  return 1;
}

BOOL HGFractured::Effect::isCropped(HGFractured::Effect *this)
{
  return *((_DWORD *)this + 20) > *((_DWORD *)this + 18) && *((_DWORD *)this + 21) > *((_DWORD *)this + 19);
}

uint64_t HGFractured::Effect::GetRect(HGFractured::Effect *this)
{
  return *((void *)this + 9);
}

uint64_t HGFractured::Effect::GetImageRect(HGFractured::Effect *this)
{
  return *(void *)((char *)this + 180);
}

uint64_t HGFractured::Effect::GetProjectionMatrix(uint64_t this, double *a2, HGRect a3)
{
  double v3 = (double)(*(_DWORD *)(this + 80) - *(_DWORD *)(this + 72));
  double v4 = (double)(*(_DWORD *)(this + 84) - *(_DWORD *)(this + 76));
  double v5 = v3 * 0.5 / (double)(*(_DWORD *)(this + 188) - *(_DWORD *)(this + 180));
  double v6 = v4 * 0.5 / (double)(*(_DWORD *)(this + 192) - *(_DWORD *)(this + 184));
  double v7 = (v5 + v5) * (double)a3.var0 / v3 - v5;
  double v8 = (v5 + v5) * (double)a3.var2 / v3 - v5;
  double v9 = *(float *)(this + 196);
  double v10 = ((v6 + v6) * (double)a3.var1 / v4 - v6) * v9;
  double v11 = ((v6 + v6) * (double)a3.var3 / v4 - v6) * v9;
  double v12 = *(float *)(this + 152) + 0.0000305175781;
  int v13 = *(unsigned __int8 *)(this + 128);
  *(float *)&double v4 = v8 - v7;
  *(float *)&double v9 = v11 - v10;
  float v14 = v12 + -0.0000305175781;
  double v15 = *(float *)&v4;
  *a2 = 2.0 / *(float *)&v4;
  double v16 = *(float *)&v9;
  _Q2 = 0uLL;
  *(_OWORD *)(a2 + 1) = 0u;
  *(_OWORD *)(a2 + 3) = 0u;
  a2[5] = 2.0 / v16;
  float v18 = a2 + 6;
  if (v13)
  {
    double v19 = v14;
    *(_OWORD *)float v18 = 0uLL;
    *((_OWORD *)a2 + 4) = 0uLL;
    a2[10] = -2.0 / v19;
    a2[11] = 0.0;
    __asm { FMOV            V2.2D, #1.0 }
    *(double *)&_Q2 = -(v12 + 0.0000305175781) / v19;
    a2[12] = -(v8 + v7) / v15;
    a2[13] = -(v11 + v10) / v16;
  }
  else
  {
    *float v18 = 0.0;
    a2[7] = 0.0;
    a2[8] = (v8 + v7) / v15;
    a2[9] = (v11 + v10) / v16;
    a2[10] = -(v12 + 0.0000305175781) / v14;
    a2[11] = -1.0;
    *(double *)&_Q2 = v12 * -2.0 * 0.0000305175781 / v14;
    a2[12] = 0.0;
    a2[13] = 0.0;
  }
  *((_OWORD *)a2 + 7) = _Q2;
  return this;
}

double HGFractured::Effect::GetModelviewMatrix(HGFractured::Effect *this, double *a2)
{
  *a2 = 1.0;
  *(_OWORD *)(a2 + 1) = 0u;
  *(_OWORD *)(a2 + 3) = 0u;
  a2[5] = 1.0;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  a2[10] = 1.0;
  a2[11] = 0.0;
  a2[12] = 0.0;
  a2[13] = 0.0;
  double result = *((float *)this + 44) + -1.0 + (float)(*((float *)this + 34) * -0.5);
  a2[14] = result;
  a2[15] = 1.0;
  return result;
}

double HGFractured::Effect::GetTextureMatrix(HGFractured::Effect *this, double *a2)
{
  int v2 = *((_DWORD *)this + 45);
  float v3 = (float)(*((_DWORD *)this + 47) - v2);
  *a2 = v3;
  *(_OWORD *)(a2 + 1) = 0u;
  *(_OWORD *)(a2 + 3) = 0u;
  a2[5] = v3;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  *((_OWORD *)a2 + 5) = xmmword_1B7E733D0;
  float v4 = v3 * 0.5;
  a2[12] = (float)(v4 + (float)v2);
  a2[13] = (float)((float)(v4 * *((float *)this + 33)) + (float)*((int *)this + 46));
  double result = 0.0;
  *((_OWORD *)a2 + 7) = xmmword_1B7E733E0;
  return result;
}

void HGFractured::Effect::Render(HGFractured::Effect *this, HGGPURenderer *a2, HGRect a3, float a4, float a5, char a6)
{
  float v7 = a5;
  float v8 = a4;
  if (*((_DWORD *)this + 35))
  {
    BOOL v10 = fabsf(*((float *)this + 23)) < fabsf(*((float *)this + 22));
    if (*((unsigned char *)this + 156)) {
      goto LABEL_20;
    }
  }
  else
  {
    BOOL v10 = 0;
    if (*((unsigned char *)this + 156)) {
      goto LABEL_20;
    }
  }
  if (v10) {
    a4 = a5;
  }
  if (a4 >= 1.0)
  {
    if (v10) {
      float v11 = a5;
    }
    else {
      float v11 = v8;
    }
    if (v11 <= 0.0) {
      goto LABEL_12;
    }
    goto LABEL_24;
  }
LABEL_20:
  glBlendFunc(0x302u, 0x303u);
  glEnable(0xBE2u);
  if (v10) {
    float v11 = v7;
  }
  else {
    float v11 = v8;
  }
  if (v11 <= 0.0)
  {
LABEL_12:
    if (*((float *)this + 34) == 0.0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_24:
  double v12 = (char *)this + 8 * v10;
  float v14 = (const GLvoid *)*((void *)v12 + 12);
  int v13 = v12 + 96;
  glVertexAttribPointer(0, 3, 0x1406u, 0, 48, v14);
  glEnableVertexAttribArray(0);
  if (a6)
  {
    glVertexAttribPointer(8u, 2, 0x1406u, 0, 48, (const GLvoid *)(*((void *)this + 12) + 32));
    glEnableVertexAttribArray(8u);
  }
  if ((a6 & 2) != 0)
  {
    glVertexAttribPointer(9u, 2, 0x1406u, 0, 48, (const GLvoid *)(*((void *)this + 12) + 40));
    glEnableVertexAttribArray(9u);
  }
  glVertexAttribPointer(0xAu, 4, 0x1406u, 0, 48, (const GLvoid *)(*(void *)v13 + 16));
  glEnableVertexAttribArray(0xAu);
  if (*((float *)this + 34) != 0.0)
  {
LABEL_13:
    glCullFace(0x405u);
    glEnable(0xB44u);
  }
LABEL_14:
  glDrawArrays(4 * (*((_DWORD *)this + 31) != 1), 0, *((_DWORD *)this + 28));
  if (*((_DWORD *)this + 35))
  {
    if (v10) {
      float v7 = v8;
    }
    if (v7 < 1.0 || *((unsigned char *)this + 156))
    {
      glBlendFunc(0x302u, 0x303u);
      glEnable(0xBE2u);
    }
    else
    {
      glDisable(0xBE2u);
    }
    BOOL v15 = *((_DWORD *)this + 31) != 1;
    double v16 = (const GLvoid **)((char *)this + 8 * !v10);
    glVertexAttribPointer(0, 3, 0x1406u, 0, 48, v16[12]);
    glVertexAttribPointer(0xAu, 4, 0x1406u, 0, 48, (char *)v16[12] + 16);
    glDrawArrays(4 * v15, 0, *((_DWORD *)this + 28));
    if (v7 < 1.0 || *((unsigned char *)this + 156)) {
      goto LABEL_36;
    }
  }
  else if (v11 < 1.0 || *((unsigned char *)this + 156))
  {
LABEL_36:
    glDisable(0xBE2u);
  }
  if (*((float *)this + 34) != 0.0) {
    glDisable(0xB44u);
  }
  glDisableVertexAttribArray(0xAu);
  if ((a6 & 2) != 0) {
    glDisableVertexAttribArray(9u);
  }
  if (a6) {
    glDisableVertexAttribArray(8u);
  }

  glDisableVertexAttribArray(0);
}

uint64_t clip(uint64_t a1, float *a2, uint64_t a3, float a4)
{
  uint64_t v130 = *MEMORY[0x1E4F143B8];
  float v4 = a4 * 0.5;
  float v6 = *a2;
  float v5 = a2[1];
  BOOL v7 = fabsf(*a2) <= 0.5;
  BOOL v8 = fabsf(v5) <= (float)(a4 * 0.5) && v7;
  float v9 = a2[2];
  float v10 = a2[3];
  float v11 = fabsf(v9);
  if (fabsf(v10) > v4 || v11 > 0.5) {
    int v13 = 0;
  }
  else {
    int v13 = 2;
  }
  float v14 = a2[4];
  float v15 = a2[5];
  float v16 = fabsf(v14);
  if (fabsf(v15) > v4 || v16 > 0.5) {
    int v18 = 0;
  }
  else {
    int v18 = 4;
  }
  float v19 = fabsf(a2[6]);
  if (fabsf(a2[7]) > v4 || v19 > 0.5) {
    int v21 = 0;
  }
  else {
    int v21 = 8;
  }
  int v22 = v13 | v8;
  int v23 = v18 | v21;
  float v24 = -(float)(v9 * a4);
  unsigned int v25 = 2 * (v10 > (float)(v9 * a4));
  BOOL v26 = v10 >= v24;
  if (v10 > 0.0)
  {
    BOOL v26 = v10 > v24;
    unsigned int v25 = 2 * (v10 >= (float)(v9 * a4));
  }
  unsigned int v27 = (v25 | v26) ^ (v25 >> 1);
  float v28 = v14 * a4;
  float v29 = -(float)(v14 * a4);
  unsigned int v30 = 2 * (v15 >= v28);
  BOOL v31 = v15 > v29;
  if (v15 > 0.0)
  {
    BOOL v31 = v15 >= v29;
    unsigned int v30 = 2 * (v15 > v28);
  }
  unsigned int v32 = (v30 | v31) ^ (v30 >> 1);
  v127[1] = v27;
  unsigned int v128 = v32;
  if (v27 == v32)
  {
    unsigned int v32 = v27;
    if ((float)((float)((float)(v6 - v14) * (float)(v10 - v15)) - (float)((float)(v9 - v14) * (float)(v5 - v15))) >= 0.0) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if (v32 < v27)
  {
LABEL_30:
    v32 |= 4u;
    unsigned int v128 = v32;
  }
LABEL_31:
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  unsigned int v35 = v22 | v23;
  unsigned int v129 = v32;
  v127[0] = v27;
  do
  {
    uint64_t v36 = v33 + 1;
    int v37 = v127[v33];
    int v38 = (v33 + 1) & 3;
    uint64_t v39 = (v33 + 1) & 3;
    int v40 = v127[v39];
    int v41 = (1 << v33) & v35;
    if (v41)
    {
      int v42 = &a2[2 * v33];
      uint64_t v43 = (v34 + 1);
      *(void *)(a3 + 8 * (int)v34) = *(void *)v42;
      if ((v35 >> v38)) {
        goto LABEL_32;
      }
      if (v37 == v40)
      {
        if (v37)
        {
          BOOL v125 = *v42 == *(float *)(a1 + 8 * (v37 & 3));
          int v44 = v37;
          uint64_t v34 = (v34 + 1);
          if (v125) {
            goto LABEL_33;
          }
        }
        else
        {
          int v44 = v37;
          uint64_t v34 = (v34 + 1);
          if (a2[2 * v33 + 1] == *(float *)(a1 + 8 * (v37 & 3) + 4)) {
            goto LABEL_33;
          }
        }
      }
      else
      {
        int v44 = v37 + 1;
      }
    }
    else if (v37 == v40)
    {
      int v44 = v127[v33];
      uint64_t v43 = v34;
      if (((v35 >> v38) & 1) == 0) {
        goto LABEL_33;
      }
    }
    else
    {
      int v44 = v127[v33];
      uint64_t v43 = v34;
    }
    if (v38)
    {
      int v45 = (1 << v38) & v35;
      uint64_t v46 = ((_BYTE)v33 + 2) & 3;
      uint64_t v47 = ((_BYTE)v33 - 1) & 3;
      uint64_t v34 = v43;
      float v48 = &a2[2 * v33];
      float v49 = &a2[2 * v39];
      do
      {
        if (v40 == v44 && v37 != v40 && v45) {
          break;
        }
        int v50 = v44 + 1;
        float32x2_t v51 = *(float32x2_t *)(a1 + 8 * ((v44 + 1) & 3));
        float v52 = (float *)(a1 + 8 * (v44 & 3));
        float v53 = *v52;
        float v54 = v52[1];
        float v55 = v48[1];
        float v56 = v49[1];
        unsigned __int8 v57 = (float *)(a3 + 8 * (int)v34);
        float v58 = *v48 - *v49;
        float v59 = v55 - v56;
        float v60 = (float)((float)(v54 - v51.f32[1]) * v58) - (float)((float)(v53 - v51.f32[0]) * (float)(v55 - v56));
        float v61 = (float)(*v48 * v56) - (float)(v55 * *v49);
        float v62 = vmuls_lane_f32(v53, v51, 1) - (float)(v54 * v51.f32[0]);
        float v63 = (float)((float)((float)(v53 - v51.f32[0]) * v61) - (float)(v62 * v58)) / v60;
        float v64 = (float)((float)((float)(v54 - v51.f32[1]) * v61) - (float)(v62 * v59)) / v60;
        *unsigned __int8 v57 = v63;
        v57[1] = v64;
        float v65 = vabds_f32(v51.f32[0], v53);
        float v66 = vabds_f32(v51.f32[1], v54);
        float v67 = (float)(v64 - v54) / (float)(v51.f32[1] - v54);
        float v68 = (float)(v63 - v53) / (float)(v51.f32[0] - v53);
        if (v65 <= v66) {
          float v68 = v67;
        }
        if (v68 < 0.0 || v68 > 1.0)
        {
          if (v44 < v40)
          {
            float32x2_t v70 = vmul_f32((float32x2_t)vrev64_s32((int32x2_t)vsub_f32(v51, *(float32x2_t *)&a2[2 * v46])), vsub_f32(*(float32x2_t *)&a2[2 * v47], *(float32x2_t *)&a2[2 * v46]));
            if (vsub_f32(v70, (float32x2_t)vdup_lane_s32((int32x2_t)v70, 1)).f32[0] > 0.0)
            {
              uint64_t v34 = (v34 + 1);
              *(float32x2_t *)unsigned __int8 v57 = v51;
            }
          }
        }
        else
        {
          uint64_t v34 = (v34 + 1);
        }
        ++v44;
      }
      while (v40 + 1 != v50);
    }
    else
    {
      if (v41)
      {
        if (v8) {
          goto LABEL_32;
        }
      }
      else
      {
        int v71 = (float *)(a1 + 8 * (v44 & 3));
        float v72 = *v71;
        float v73 = v71[1];
        int v74 = (float *)(a1 + 8 * (((_BYTE)v44 + 1) & 3));
        float v75 = *v74;
        float v76 = v74[1];
        float v77 = &a2[2 * v33];
        float v78 = *v77;
        float v79 = v77[1];
        unint64_t v80 = &a2[2 * v39];
        float v81 = *v80;
        float v82 = v80[1];
        float v83 = (float *)(a3 + 8 * (int)v43);
        float v84 = v78 - v81;
        float v85 = v79 - v82;
        float v86 = (float)((float)(v73 - v76) * (float)(v78 - v81)) - (float)((float)(v72 - v75) * (float)(v79 - v82));
        float v87 = (float)(v78 * v82) - (float)(v79 * v81);
        float v88 = (float)(v72 * v76) - (float)(v73 * v75);
        float v89 = (float)((float)((float)(v72 - v75) * v87) - (float)(v88 * v84)) / v86;
        float v90 = (float)((float)((float)(v73 - v76) * v87) - (float)(v88 * v85)) / v86;
        *float v83 = v89;
        v83[1] = v90;
        float v91 = v75 - v72;
        float v92 = vabds_f32(v75, v72);
        float v93 = v76 - v73;
        float v94 = vabds_f32(v76, v73);
        float v95 = (float)(v90 - v73) / v93;
        float v96 = (float)(v89 - v72) / v91;
        if (v92 <= v94) {
          float v96 = v95;
        }
        BOOL v97 = v96 >= 0.0;
        if (v96 > 1.0) {
          BOOL v97 = 0;
        }
        uint64_t v43 = (v43 + v97);
        if (v8)
        {
LABEL_32:
          uint64_t v34 = v43;
          goto LABEL_33;
        }
      }
      float v98 = (float *)(a1 + 8 * (v40 & 3));
      float v99 = *v98;
      float v100 = v98[1];
      uint64_t v101 = (float *)(a1 + 8 * (((_BYTE)v40 + 1) & 3));
      float v102 = *v101;
      float v103 = v101[1];
      uint64_t v104 = &a2[2 * v33];
      float v105 = *v104;
      float v106 = v104[1];
      uint64_t v107 = &a2[2 * v39];
      float v108 = *v107;
      float v109 = v107[1];
      uint64_t v110 = (float *)(a3 + 8 * (int)v43);
      float v111 = v105 - v108;
      float v112 = v106 - v109;
      float v113 = (float)((float)(v100 - v103) * (float)(v105 - v108)) - (float)((float)(v99 - v102) * (float)(v106 - v109));
      float v114 = (float)(v105 * v109) - (float)(v106 * v108);
      float v115 = (float)(v99 * v103) - (float)(v100 * v102);
      float v116 = (float)((float)((float)(v99 - v102) * v114) - (float)(v115 * v111)) / v113;
      float v117 = (float)((float)((float)(v100 - v103) * v114) - (float)(v115 * v112)) / v113;
      *uint64_t v110 = v116;
      v110[1] = v117;
      float v118 = v102 - v99;
      float v119 = vabds_f32(v102, v99);
      float v120 = v103 - v100;
      float v121 = vabds_f32(v103, v100);
      float v122 = (float)(v117 - v100) / v120;
      float v123 = (float)(v116 - v99) / v118;
      if (v119 <= v121) {
        float v123 = v122;
      }
      BOOL v124 = v123 >= 0.0;
      if (v123 > 1.0) {
        BOOL v124 = 0;
      }
      uint64_t v34 = (v43 + v124);
    }
LABEL_33:
    uint64_t v33 = v36;
  }
  while (v36 != 4);
  return v34;
}

void HGFractured::Effect::build(void **this, int a2, int a3, double a4, double a5, double a6, double a7, int32x2_t a8)
{
  HGFractured::Effect::init((HGFractured::Effect *)this, a4, a5, a6, a7, a8);
  double v12 = (char *)this[7];
  float v11 = this[8];
  int v13 = *((_DWORD *)this + 31);
  if (v13 != 4)
  {
    if (v13 != 3)
    {
      if (v13 == 1)
      {
        size_t v14 = (size_t)this[3];
        if (v14 >= 48 * (uint64_t)v11)
        {
          if (!*((_DWORD *)this + 35) || this[13]) {
            goto LABEL_41;
          }
          float v16 = 0;
          malloc_type_id_t v17 = 1253900132;
        }
        else
        {
          float v15 = this[12];
          this[3] = (void *)(48 * (void)v11);
          this[12] = malloc_type_realloc(v15, 48 * (void)v11, 0x9C946008uLL);
          float v16 = this[13];
          if (!*((_DWORD *)this + 35))
          {
            if (v16)
            {
              free(v16);
              this[13] = 0;
            }
            goto LABEL_41;
          }
          size_t v14 = (size_t)this[3];
          malloc_type_id_t v17 = 897561819;
        }
        this[13] = malloc_type_realloc(v16, v14, v17);
LABEL_41:
        bzero(this[12], 48 * (void)v11);
        if (*((_DWORD *)this + 35)) {
          bzero(this[13], 48 * (void)v11);
        }
        this[14] = v11;
        int v40 = (float *)((char *)this[12] + 44);
        for (uint64_t i = (float *)(v12 + 88); ; i += 23)
        {
          *(void *)(v40 - 3) = *(void *)(i - 1);
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              *(v40 - 1) = (float)(*(i - 22) + *(i - 22)) - *(i - 1);
              if (a3 < 1)
              {
LABEL_53:
                if (a3 < 0) {
                  float v42 = (float)(*(i - 21) + *(i - 21)) - *i;
                }
                else {
                  float v42 = *i;
                }
                goto LABEL_45;
              }
            }
            else
            {
              *(v40 - 1) = *(i - 1);
              if (a3 < 1) {
                goto LABEL_53;
              }
            }
          }
          else
          {
            *(v40 - 1) = -*(i - 1);
            if (a3 < 1) {
              goto LABEL_53;
            }
          }
          float v42 = -*i;
LABEL_45:
          *int v40 = v42;
          v40 += 12;
          float v11 = (char *)v11 - 1;
          if (!v11) {
            return;
          }
        }
      }
      if (*((float *)this + 34) == 0.0) {
        int v34 = 3;
      }
      else {
        int v34 = 12;
      }
      unsigned int v35 = (void *)((void)v11 * (v34 * v13));
      size_t v36 = (size_t)this[3];
      if (v36 >= 48 * (uint64_t)v35)
      {
        if (!*((_DWORD *)this + 35) || this[13]) {
          goto LABEL_770;
        }
        int v38 = 0;
        malloc_type_id_t v39 = 2311274053;
      }
      else
      {
        int v37 = this[12];
        this[3] = (void *)(48 * (void)v35);
        this[12] = malloc_type_realloc(v37, 48 * (void)v35, 0xC3F04B7DuLL);
        int v38 = this[13];
        if (!*((_DWORD *)this + 35))
        {
          if (v38)
          {
            free(v38);
            this[13] = 0;
          }
          goto LABEL_770;
        }
        size_t v36 = (size_t)this[3];
        malloc_type_id_t v39 = 1055899342;
      }
      this[13] = malloc_type_realloc(v38, v36, v39);
LABEL_770:
      bzero(this[12], 48 * (void)v35);
      if (*((_DWORD *)this + 35)) {
        bzero(this[13], 48 * (void)v35);
      }
      this[14] = v35;
      float v55 = (char *)this[12];
      while (1)
      {
        *((void *)v55 + 4) = *(void *)v12;
        float v56 = *(float *)v12;
        if (a2 < 1)
        {
          if (a2 < 0)
          {
            *((float *)v55 + 10) = (float)(v56 + v56) - v56;
            float v57 = *((float *)v12 + 1);
            if (a3 >= 1)
            {
LABEL_779:
              *((float *)v55 + 11) = -v57;
              *((void *)v55 + 10) = *(void *)(v12 + 84);
              if (a2 >= 1) {
                goto LABEL_784;
              }
              goto LABEL_787;
            }
          }
          else
          {
            *((float *)v55 + 10) = v56;
            float v57 = *((float *)v12 + 1);
            if (a3 >= 1) {
              goto LABEL_779;
            }
          }
        }
        else
        {
          *((float *)v55 + 10) = -v56;
          float v57 = *((float *)v12 + 1);
          if (a3 >= 1) {
            goto LABEL_779;
          }
        }
        if (a3 < 0)
        {
          *((float *)v55 + 11) = (float)(v57 + v57) - v57;
          *((void *)v55 + 10) = *(void *)(v12 + 84);
          if (a2 >= 1)
          {
LABEL_784:
            *((float *)v55 + 22) = -*((float *)v12 + 21);
            if (a3 >= 1) {
              goto LABEL_789;
            }
            goto LABEL_792;
          }
        }
        else
        {
          *((float *)v55 + 11) = v57;
          *((void *)v55 + 10) = *(void *)(v12 + 84);
          if (a2 >= 1) {
            goto LABEL_784;
          }
        }
LABEL_787:
        if (a2 < 0)
        {
          *((float *)v55 + 22) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
          if (a3 >= 1)
          {
LABEL_789:
            *((float *)v55 + 23) = -*((float *)v12 + 22);
            *((void *)v55 + 16) = *(void *)(v12 + 92);
            if (a2 >= 1) {
              goto LABEL_794;
            }
            goto LABEL_797;
          }
        }
        else
        {
          *((_DWORD *)v55 + 22) = *((_DWORD *)v12 + 21);
          if (a3 >= 1) {
            goto LABEL_789;
          }
        }
LABEL_792:
        if (a3 < 0)
        {
          *((float *)v55 + 23) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
          *((void *)v55 + 16) = *(void *)(v12 + 92);
          if (a2 >= 1)
          {
LABEL_794:
            *((float *)v55 + 34) = -*((float *)v12 + 23);
            if (a3 >= 1) {
              goto LABEL_799;
            }
            goto LABEL_802;
          }
        }
        else
        {
          *((_DWORD *)v55 + 23) = *((_DWORD *)v12 + 22);
          *((void *)v55 + 16) = *(void *)(v12 + 92);
          if (a2 >= 1) {
            goto LABEL_794;
          }
        }
LABEL_797:
        if (a2 < 0)
        {
          *((float *)v55 + 34) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
          if (a3 >= 1)
          {
LABEL_799:
            *((float *)v55 + 35) = -*((float *)v12 + 24);
            if ((*((_DWORD *)this + 31) - 3) <= 0xFFFFFFFD) {
              goto LABEL_804;
            }
            goto LABEL_837;
          }
        }
        else
        {
          *((_DWORD *)v55 + 34) = *((_DWORD *)v12 + 23);
          if (a3 >= 1) {
            goto LABEL_799;
          }
        }
LABEL_802:
        if (a3 < 0)
        {
          *((float *)v55 + 35) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
          if ((*((_DWORD *)this + 31) - 3) > 0xFFFFFFFD) {
            goto LABEL_837;
          }
LABEL_804:
          float v58 = (float *)(v12 + 104);
          unsigned int v59 = 5;
          unint64_t v60 = 1;
          while (2)
          {
            unsigned int v62 = v59 - 2;
            *(void *)&v55[48 * v59 - 64] = *(void *)v12;
            float v63 = *(float *)v12;
            if (a2 < 1)
            {
              if (a2 < 0)
              {
                *(float *)&v55[48 * v62 + 40] = (float)(v63 + v63) - v63;
                float v64 = *((float *)v12 + 1);
                if (a3 >= 1) {
                  goto LABEL_812;
                }
              }
              else
              {
                *(float *)&v55[48 * v62 + 40] = v63;
                float v64 = *((float *)v12 + 1);
                if (a3 >= 1) {
                  goto LABEL_812;
                }
              }
LABEL_814:
              if (a3 < 0) {
                float v64 = (float)(v64 + v64) - v64;
              }
            }
            else
            {
              *(float *)&v55[48 * v62 + 40] = -v63;
              float v64 = *((float *)v12 + 1);
              if (a3 < 1) {
                goto LABEL_814;
              }
LABEL_812:
              float v64 = -v64;
            }
            *(float *)&v55[48 * v62 + 44] = v64;
            unsigned int v65 = v59 - 1;
            *(void *)&v55[48 * v59 - 16] = *(void *)(v58 - 3);
            if (a2 < 1)
            {
              if (a2 < 0)
              {
                *(float *)&v55[48 * v65 + 40] = (float)(*(float *)v12 + *(float *)v12) - *(v58 - 3);
                if (a3 >= 1) {
                  goto LABEL_821;
                }
              }
              else
              {
                *(float *)&v55[48 * v65 + 40] = *(v58 - 3);
                if (a3 >= 1) {
                  goto LABEL_821;
                }
              }
LABEL_823:
              if (a3 < 0) {
                float v66 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *(v58 - 2);
              }
              else {
                float v66 = *(v58 - 2);
              }
            }
            else
            {
              *(float *)&v55[48 * v65 + 40] = -*(v58 - 3);
              if (a3 < 1) {
                goto LABEL_823;
              }
LABEL_821:
              float v66 = -*(v58 - 2);
            }
            *(float *)&v55[48 * v65 + 44] = v66;
            *(void *)&v55[48 * v59 + 32] = *(void *)(v58 - 1);
            if (a2 < 1)
            {
              if ((a2 & 0x80000000) == 0)
              {
                unsigned int v67 = v59;
                *(float *)&v55[48 * v59 + 40] = *(v58 - 1);
                if (a3 < 1) {
                  goto LABEL_833;
                }
                goto LABEL_805;
              }
              unsigned int v67 = v59;
              *(float *)&v55[48 * v59 + 40] = (float)(*(float *)v12 + *(float *)v12) - *(v58 - 1);
              if (a3 >= 1) {
                goto LABEL_805;
              }
LABEL_833:
              if (a3 < 0) {
                float v61 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *v58;
              }
              else {
                float v61 = *v58;
              }
            }
            else
            {
              unsigned int v67 = v59;
              *(float *)&v55[48 * v59 + 40] = -*(v58 - 1);
              if (a3 < 1) {
                goto LABEL_833;
              }
LABEL_805:
              float v61 = -*v58;
            }
            ++v60;
            *(float *)&v55[48 * v67 + 44] = v61;
            v58 += 2;
            v59 += 3;
            if (v60 >= (*((_DWORD *)this + 31) - 1)) {
              goto LABEL_838;
            }
            continue;
          }
        }
        *((_DWORD *)v55 + 35) = *((_DWORD *)v12 + 24);
        if ((*((_DWORD *)this + 31) - 3) <= 0xFFFFFFFD) {
          goto LABEL_804;
        }
LABEL_837:
        LODWORD(v60) = 1;
LABEL_838:
        int v68 = 3 * v60;
        *(void *)&v55[48 * (3 * v60) + 32] = *(void *)v12;
        float v69 = *(float *)v12;
        if (a2 < 1)
        {
          if (a2 < 0)
          {
            *(float *)&v55[48 * v68 + 40] = (float)(v69 + v69) - v69;
            float v70 = *((float *)v12 + 1);
            if (a3 >= 1)
            {
LABEL_843:
              float v70 = -v70;
              goto LABEL_847;
            }
          }
          else
          {
            *(float *)&v55[48 * v68 + 40] = v69;
            float v70 = *((float *)v12 + 1);
            if (a3 >= 1) {
              goto LABEL_843;
            }
          }
        }
        else
        {
          *(float *)&v55[48 * v68 + 40] = -v69;
          float v70 = *((float *)v12 + 1);
          if (a3 >= 1) {
            goto LABEL_843;
          }
        }
        if (a3 < 0) {
          float v70 = (float)(v70 + v70) - v70;
        }
LABEL_847:
        *(float *)&v55[48 * v68 + 44] = v70;
        int v71 = v68 + 1;
        float v72 = &v12[8 * v60];
        uint64_t v74 = *(void *)(v72 + 84);
        float v73 = (float *)(v72 + 84);
        *(void *)&v55[48 * (v68 + 1) + 32] = v74;
        if (a2 < 1)
        {
          if (a2 < 0)
          {
            unint64_t v60 = v60;
            *(float *)&v55[48 * v71 + 40] = (float)(*(float *)v12 + *(float *)v12) - *v73;
            if (a3 >= 1)
            {
LABEL_852:
              float v75 = -*(float *)&v12[8 * v60 + 88];
              goto LABEL_857;
            }
          }
          else
          {
            unint64_t v60 = v60;
            *(float *)&v55[48 * v71 + 40] = *v73;
            if (a3 >= 1) {
              goto LABEL_852;
            }
          }
        }
        else
        {
          unint64_t v60 = v60;
          *(float *)&v55[48 * v71 + 40] = -*v73;
          if (a3 >= 1) {
            goto LABEL_852;
          }
        }
        if (a3 < 0) {
          float v75 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *(float *)&v12[8 * v60 + 88];
        }
        else {
          float v75 = *(float *)&v12[8 * v60 + 88];
        }
LABEL_857:
        *(float *)&v55[48 * v71 + 44] = v75;
        int v76 = v68 + 2;
        *(void *)&v55[48 * (v68 + 2) + 32] = *(void *)(v12 + 84);
        if (a2 < 1)
        {
          if (a2 < 0)
          {
            *(float *)&v55[48 * v76 + 40] = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
            if (a3 < 1)
            {
LABEL_864:
              if (a3 < 0) {
                float v77 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
              }
              else {
                float v77 = *((float *)v12 + 22);
              }
              goto LABEL_867;
            }
          }
          else
          {
            *(_DWORD *)&v55[48 * v76 + 40] = *((_DWORD *)v12 + 21);
            if (a3 < 1) {
              goto LABEL_864;
            }
          }
        }
        else
        {
          *(float *)&v55[48 * v76 + 40] = -*((float *)v12 + 21);
          if (a3 < 1) {
            goto LABEL_864;
          }
        }
        float v77 = -*((float *)v12 + 22);
LABEL_867:
        *(float *)&v55[48 * v76 + 44] = v77;
        int v78 = *((_DWORD *)this + 31);
        float v79 = &v55[144 * v78];
        if (*((float *)this + 34) == 0.0)
        {
          v55 += 48 * (3 * v78);
          v12 += 8 * v78 + 84;
          float v11 = (char *)v11 - 1;
          if (!v11) {
            return;
          }
        }
        else
        {
          int v80 = v68 + 3;
          *(void *)&v55[48 * (v68 + 3) + 32] = *(void *)v12;
          float v81 = *(float *)v12;
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              *(float *)&v55[48 * v80 + 40] = (float)(v81 + v81) - v81;
              float v82 = *((float *)v12 + 1);
              if (a3 >= 1)
              {
LABEL_873:
                float v82 = -v82;
                goto LABEL_877;
              }
            }
            else
            {
              *(float *)&v55[48 * v80 + 40] = v81;
              float v82 = *((float *)v12 + 1);
              if (a3 >= 1) {
                goto LABEL_873;
              }
            }
          }
          else
          {
            *(float *)&v55[48 * v80 + 40] = -v81;
            float v82 = *((float *)v12 + 1);
            if (a3 >= 1) {
              goto LABEL_873;
            }
          }
          if (a3 < 0) {
            float v82 = (float)(v82 + v82) - v82;
          }
LABEL_877:
          float v83 = (float *)&v55[48 * v80];
          v83[11] = v82;
          *((void *)v83 + 10) = *(void *)(v12 + 92);
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              v83[22] = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
              if (a3 >= 1)
              {
LABEL_882:
                v83[23] = -*((float *)v12 + 24);
                *((void *)v83 + 16) = *(void *)(v12 + 84);
                if (a2 >= 1) {
                  goto LABEL_887;
                }
                goto LABEL_890;
              }
            }
            else
            {
              v83[22] = *((float *)v12 + 23);
              if (a3 >= 1) {
                goto LABEL_882;
              }
            }
          }
          else
          {
            v83[22] = -*((float *)v12 + 23);
            if (a3 >= 1) {
              goto LABEL_882;
            }
          }
          if (a3 < 0)
          {
            v83[23] = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
            *((void *)v83 + 16) = *(void *)(v12 + 84);
            if (a2 >= 1)
            {
LABEL_887:
              v83[34] = -*((float *)v12 + 21);
              if (a3 >= 1) {
                goto LABEL_892;
              }
              goto LABEL_895;
            }
          }
          else
          {
            v83[23] = *((float *)v12 + 24);
            *((void *)v83 + 16) = *(void *)(v12 + 84);
            if (a2 >= 1) {
              goto LABEL_887;
            }
          }
LABEL_890:
          if (a2 < 0)
          {
            v83[34] = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
            if (a3 >= 1)
            {
LABEL_892:
              v83[35] = -*((float *)v12 + 22);
              if ((*((_DWORD *)this + 31) - 3) <= 0xFFFFFFFD) {
                goto LABEL_897;
              }
              goto LABEL_930;
            }
          }
          else
          {
            v83[34] = *((float *)v12 + 21);
            if (a3 >= 1) {
              goto LABEL_892;
            }
          }
LABEL_895:
          if (a3 < 0)
          {
            v83[35] = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
            if ((*((_DWORD *)this + 31) - 3) > 0xFFFFFFFD) {
              goto LABEL_930;
            }
LABEL_897:
            float v84 = (float *)(v12 + 104);
            unsigned int v85 = 5;
            unint64_t v86 = 1;
            while (2)
            {
              unsigned int v88 = v85 - 2;
              *(void *)&v83[12 * v85 - 16] = *(void *)v12;
              float v89 = *(float *)v12;
              if (a2 < 1)
              {
                if (a2 < 0)
                {
                  v83[12 * v88 + 10] = (float)(v89 + v89) - v89;
                  float v90 = *((float *)v12 + 1);
                  if (a3 >= 1) {
                    goto LABEL_905;
                  }
                }
                else
                {
                  v83[12 * v88 + 10] = v89;
                  float v90 = *((float *)v12 + 1);
                  if (a3 >= 1) {
                    goto LABEL_905;
                  }
                }
LABEL_907:
                if (a3 < 0) {
                  float v90 = (float)(v90 + v90) - v90;
                }
              }
              else
              {
                v83[12 * v88 + 10] = -v89;
                float v90 = *((float *)v12 + 1);
                if (a3 < 1) {
                  goto LABEL_907;
                }
LABEL_905:
                float v90 = -v90;
              }
              v83[12 * v88 + 11] = v90;
              unsigned int v91 = v85 - 1;
              *(void *)&v83[12 * v85 - 4] = *(void *)(v84 - 1);
              if (a2 < 1)
              {
                if (a2 < 0)
                {
                  v83[12 * v91 + 10] = (float)(*(float *)v12 + *(float *)v12) - *(v84 - 1);
                  if (a3 >= 1) {
                    goto LABEL_914;
                  }
                }
                else
                {
                  v83[12 * v91 + 10] = *(v84 - 1);
                  if (a3 >= 1) {
                    goto LABEL_914;
                  }
                }
LABEL_916:
                if (a3 < 0) {
                  float v92 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *v84;
                }
                else {
                  float v92 = *v84;
                }
              }
              else
              {
                v83[12 * v91 + 10] = -*(v84 - 1);
                if (a3 < 1) {
                  goto LABEL_916;
                }
LABEL_914:
                float v92 = -*v84;
              }
              v83[12 * v91 + 11] = v92;
              *(void *)&v83[12 * v85 + 8] = *(void *)(v84 - 3);
              if (a2 < 1)
              {
                if ((a2 & 0x80000000) == 0)
                {
                  unsigned int v93 = v85;
                  v83[12 * v85 + 10] = *(v84 - 3);
                  if (a3 < 1) {
                    goto LABEL_926;
                  }
                  goto LABEL_898;
                }
                unsigned int v93 = v85;
                v83[12 * v85 + 10] = (float)(*(float *)v12 + *(float *)v12) - *(v84 - 3);
                if (a3 >= 1) {
                  goto LABEL_898;
                }
LABEL_926:
                if (a3 < 0) {
                  float v87 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *(v84 - 2);
                }
                else {
                  float v87 = *(v84 - 2);
                }
              }
              else
              {
                unsigned int v93 = v85;
                v83[12 * v85 + 10] = -*(v84 - 3);
                if (a3 < 1) {
                  goto LABEL_926;
                }
LABEL_898:
                float v87 = -*(v84 - 2);
              }
              ++v86;
              v83[12 * v93 + 11] = v87;
              v84 += 2;
              v85 += 3;
              if (v86 >= (*((_DWORD *)this + 31) - 1)) {
                goto LABEL_931;
              }
              continue;
            }
          }
          v83[35] = *((float *)v12 + 22);
          if ((*((_DWORD *)this + 31) - 3) <= 0xFFFFFFFD) {
            goto LABEL_897;
          }
LABEL_930:
          LODWORD(v86) = 1;
LABEL_931:
          int v94 = 3 * v86;
          *(void *)&v83[12 * (3 * v86) + 8] = *(void *)v12;
          float v95 = *(float *)v12;
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              v83[12 * v94 + 10] = (float)(v95 + v95) - v95;
              float v96 = *((float *)v12 + 1);
              if (a3 >= 1)
              {
LABEL_936:
                float v96 = -v96;
                goto LABEL_940;
              }
            }
            else
            {
              v83[12 * v94 + 10] = v95;
              float v96 = *((float *)v12 + 1);
              if (a3 >= 1) {
                goto LABEL_936;
              }
            }
          }
          else
          {
            v83[12 * v94 + 10] = -v95;
            float v96 = *((float *)v12 + 1);
            if (a3 >= 1) {
              goto LABEL_936;
            }
          }
          if (a3 < 0) {
            float v96 = (float)(v96 + v96) - v96;
          }
LABEL_940:
          v83[12 * v94 + 11] = v96;
          int v97 = v94 + 1;
          *(void *)&v83[12 * (v94 + 1) + 8] = *(void *)(v12 + 84);
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              v83[12 * v97 + 10] = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
              if (a3 >= 1)
              {
LABEL_945:
                float v98 = -*((float *)v12 + 22);
                goto LABEL_950;
              }
            }
            else
            {
              v83[12 * v97 + 10] = *((float *)v12 + 21);
              if (a3 >= 1) {
                goto LABEL_945;
              }
            }
          }
          else
          {
            v83[12 * v97 + 10] = -*((float *)v12 + 21);
            if (a3 >= 1) {
              goto LABEL_945;
            }
          }
          if (a3 < 0) {
            float v98 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
          }
          else {
            float v98 = *((float *)v12 + 22);
          }
LABEL_950:
          v83[12 * v97 + 11] = v98;
          int v99 = v94 + 2;
          float v100 = &v12[8 * v86];
          uint64_t v102 = *(void *)(v100 + 84);
          uint64_t v101 = (float *)(v100 + 84);
          *(void *)&v83[12 * v99 + 8] = v102;
          if (a2 < 1)
          {
            if (a2 < 0)
            {
              unint64_t v86 = v86;
              v83[12 * v99 + 10] = (float)(*(float *)v12 + *(float *)v12) - *v101;
              if (a3 < 1)
              {
LABEL_957:
                if (a3 < 0) {
                  float v103 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *(float *)&v12[8 * v86 + 88];
                }
                else {
                  float v103 = *(float *)&v12[8 * v86 + 88];
                }
                goto LABEL_960;
              }
            }
            else
            {
              unint64_t v86 = v86;
              v83[12 * v99 + 10] = *v101;
              if (a3 < 1) {
                goto LABEL_957;
              }
            }
          }
          else
          {
            unint64_t v86 = v86;
            v83[12 * v99 + 10] = -*v101;
            if (a3 < 1) {
              goto LABEL_957;
            }
          }
          float v103 = -*(float *)&v12[8 * v86 + 88];
LABEL_960:
          v83[12 * v99 + 11] = v103;
          int v104 = *((_DWORD *)this + 31);
          float v55 = &v79[144 * v104];
          v12 += 8 * v104 + 84;
          float v11 = (char *)v11 - 1;
          if (!v11) {
            return;
          }
        }
      }
    }
    uint64_t v26 = 24;
    if (*((float *)this + 34) == 0.0) {
      uint64_t v26 = 3;
    }
    uint64_t v27 = v26 * (void)v11;
    uint64_t v28 = 3 * v26 * (void)v11;
    size_t v29 = 16 * v28;
    size_t v30 = (size_t)this[3];
    if (v30 >= 16 * v28)
    {
      if (!*((_DWORD *)this + 35) || this[13]) {
        goto LABEL_489;
      }
      unsigned int v32 = 0;
      malloc_type_id_t v33 = 2644485375;
    }
    else
    {
      BOOL v31 = this[12];
      this[3] = (void *)v29;
      this[12] = malloc_type_realloc(v31, 16 * v28, 0x227C306EuLL);
      unsigned int v32 = this[13];
      if (!*((_DWORD *)this + 35))
      {
        if (v32)
        {
          free(v32);
          this[13] = 0;
        }
        goto LABEL_489;
      }
      size_t v30 = (size_t)this[3];
      malloc_type_id_t v33 = 3462485609;
    }
    this[13] = malloc_type_realloc(v32, v30, v33);
LABEL_489:
    bzero(this[12], v29);
    if (*((_DWORD *)this + 35)) {
      bzero(this[13], v29);
    }
    this[14] = (void *)v27;
    float v49 = this[12];
    if (*((float *)this + 34) == 0.0)
    {
      int v50 = (char *)(v49 + 10);
      for (uint64_t j = (float *)(v12 + 104); ; j += 27)
      {
        *((void *)v50 - 6) = *(void *)(j - 5);
        if (a2 < 1)
        {
          if (a2 < 0)
          {
            *((float *)v50 - 10) = (float)(*(j - 26) + *(j - 26)) - *(j - 5);
            if (a3 >= 1)
            {
LABEL_500:
              *((float *)v50 - 9) = -*(j - 4);
              *(void *)int v50 = *(void *)(j - 3);
              if (a2 >= 1) {
                goto LABEL_505;
              }
              goto LABEL_508;
            }
          }
          else
          {
            *((float *)v50 - 10) = *(j - 5);
            if (a3 >= 1) {
              goto LABEL_500;
            }
          }
        }
        else
        {
          *((float *)v50 - 10) = -*(j - 5);
          if (a3 >= 1) {
            goto LABEL_500;
          }
        }
        if (a3 < 0)
        {
          *((float *)v50 - 9) = (float)(*(j - 25) + *(j - 25)) - *(j - 4);
          *(void *)int v50 = *(void *)(j - 3);
          if (a2 >= 1)
          {
LABEL_505:
            *((float *)v50 + 2) = -*(j - 3);
            if (a3 >= 1) {
              goto LABEL_510;
            }
            goto LABEL_513;
          }
        }
        else
        {
          *((float *)v50 - 9) = *(j - 4);
          *(void *)int v50 = *(void *)(j - 3);
          if (a2 >= 1) {
            goto LABEL_505;
          }
        }
LABEL_508:
        if (a2 < 0)
        {
          *((float *)v50 + 2) = (float)(*(j - 26) + *(j - 26)) - *(j - 3);
          if (a3 >= 1)
          {
LABEL_510:
            *((float *)v50 + 3) = -*(j - 2);
            *((void *)v50 + 6) = *(void *)(j - 1);
            if (a2 >= 1) {
              goto LABEL_515;
            }
            goto LABEL_518;
          }
        }
        else
        {
          *((float *)v50 + 2) = *(j - 3);
          if (a3 >= 1) {
            goto LABEL_510;
          }
        }
LABEL_513:
        if (a3 < 0)
        {
          *((float *)v50 + 3) = (float)(*(j - 25) + *(j - 25)) - *(j - 2);
          *((void *)v50 + 6) = *(void *)(j - 1);
          if (a2 >= 1)
          {
LABEL_515:
            *((float *)v50 + 14) = -*(j - 1);
            if (a3 < 1) {
              goto LABEL_522;
            }
            goto LABEL_493;
          }
        }
        else
        {
          *((float *)v50 + 3) = *(j - 2);
          *((void *)v50 + 6) = *(void *)(j - 1);
          if (a2 >= 1) {
            goto LABEL_515;
          }
        }
LABEL_518:
        if (a2 < 0)
        {
          *((float *)v50 + 14) = (float)(*(j - 26) + *(j - 26)) - *(j - 1);
          if (a3 < 1)
          {
LABEL_522:
            if (a3 < 0) {
              float v52 = (float)(*(j - 25) + *(j - 25)) - *j;
            }
            else {
              float v52 = *j;
            }
            goto LABEL_494;
          }
        }
        else
        {
          *((float *)v50 + 14) = *(j - 1);
          if (a3 < 1) {
            goto LABEL_522;
          }
        }
LABEL_493:
        float v52 = -*j;
LABEL_494:
        *((float *)v50 + 15) = v52;
        v50 += 144;
        float v11 = (char *)v11 - 1;
        if (!v11) {
          return;
        }
      }
    }
    float v53 = (char *)&v49[36 * (void)v11];
    while (1)
    {
      v49[4] = *(void *)(v12 + 84);
      if (a2 < 1)
      {
        if (a2 < 0)
        {
          *((float *)v49 + 10) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
          if (a3 >= 1)
          {
LABEL_533:
            *((float *)v49 + 11) = -*((float *)v12 + 22);
            v49[10] = *(void *)(v12 + 92);
            if (a2 >= 1) {
              goto LABEL_538;
            }
            goto LABEL_541;
          }
        }
        else
        {
          *((_DWORD *)v49 + 10) = *((_DWORD *)v12 + 21);
          if (a3 >= 1) {
            goto LABEL_533;
          }
        }
      }
      else
      {
        *((float *)v49 + 10) = -*((float *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_533;
        }
      }
      if (a3 < 0)
      {
        *((float *)v49 + 11) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        v49[10] = *(void *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_538:
          *((float *)v49 + 22) = -*((float *)v12 + 23);
          if (a3 >= 1) {
            goto LABEL_543;
          }
          goto LABEL_546;
        }
      }
      else
      {
        *((_DWORD *)v49 + 11) = *((_DWORD *)v12 + 22);
        v49[10] = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_538;
        }
      }
LABEL_541:
      if (a2 < 0)
      {
        *((float *)v49 + 22) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_543:
          *((float *)v49 + 23) = -*((float *)v12 + 24);
          v49[16] = *(void *)(v12 + 100);
          if (a2 >= 1) {
            goto LABEL_548;
          }
          goto LABEL_551;
        }
      }
      else
      {
        *((_DWORD *)v49 + 22) = *((_DWORD *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_543;
        }
      }
LABEL_546:
      if (a3 < 0)
      {
        *((float *)v49 + 23) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        v49[16] = *(void *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_548:
          *((float *)v49 + 34) = -*((float *)v12 + 25);
          if (a3 >= 1) {
            goto LABEL_553;
          }
          goto LABEL_556;
        }
      }
      else
      {
        *((_DWORD *)v49 + 23) = *((_DWORD *)v12 + 24);
        v49[16] = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_548;
        }
      }
LABEL_551:
      if (a2 < 0)
      {
        *((float *)v49 + 34) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_553:
          *((float *)v49 + 35) = -*((float *)v12 + 26);
          v49[22] = *(void *)(v12 + 84);
          if (a2 >= 1) {
            goto LABEL_558;
          }
          goto LABEL_561;
        }
      }
      else
      {
        *((_DWORD *)v49 + 34) = *((_DWORD *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_553;
        }
      }
LABEL_556:
      if (a3 < 0)
      {
        *((float *)v49 + 35) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        v49[22] = *(void *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_558:
          *((float *)v49 + 46) = -*((float *)v12 + 21);
          if (a3 >= 1) {
            goto LABEL_563;
          }
          goto LABEL_566;
        }
      }
      else
      {
        *((_DWORD *)v49 + 35) = *((_DWORD *)v12 + 26);
        v49[22] = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_558;
        }
      }
LABEL_561:
      if (a2 < 0)
      {
        *((float *)v49 + 46) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_563:
          *((float *)v49 + 47) = -*((float *)v12 + 22);
          v49[28] = *(void *)(v12 + 100);
          if (a2 >= 1) {
            goto LABEL_568;
          }
          goto LABEL_571;
        }
      }
      else
      {
        *((_DWORD *)v49 + 46) = *((_DWORD *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_563;
        }
      }
LABEL_566:
      if (a3 < 0)
      {
        *((float *)v49 + 47) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        v49[28] = *(void *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_568:
          *((float *)v49 + 58) = -*((float *)v12 + 25);
          if (a3 >= 1) {
            goto LABEL_573;
          }
          goto LABEL_576;
        }
      }
      else
      {
        *((_DWORD *)v49 + 47) = *((_DWORD *)v12 + 22);
        v49[28] = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_568;
        }
      }
LABEL_571:
      if (a2 < 0)
      {
        *((float *)v49 + 58) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_573:
          *((float *)v49 + 59) = -*((float *)v12 + 26);
          v49[34] = *(void *)(v12 + 92);
          if (a2 >= 1) {
            goto LABEL_578;
          }
          goto LABEL_581;
        }
      }
      else
      {
        *((_DWORD *)v49 + 58) = *((_DWORD *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_573;
        }
      }
LABEL_576:
      if (a3 < 0)
      {
        *((float *)v49 + 59) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        v49[34] = *(void *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_578:
          *((float *)v49 + 70) = -*((float *)v12 + 23);
          if (a3 >= 1) {
            goto LABEL_583;
          }
          goto LABEL_586;
        }
      }
      else
      {
        *((_DWORD *)v49 + 59) = *((_DWORD *)v12 + 26);
        v49[34] = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_578;
        }
      }
LABEL_581:
      if (a2 < 0)
      {
        *((float *)v49 + 70) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_583:
          *((float *)v49 + 71) = -*((float *)v12 + 24);
          *((void *)v53 + 4) = *(void *)(v12 + 92);
          if (a2 >= 1) {
            goto LABEL_588;
          }
          goto LABEL_591;
        }
      }
      else
      {
        *((_DWORD *)v49 + 70) = *((_DWORD *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_583;
        }
      }
LABEL_586:
      if (a3 < 0)
      {
        *((float *)v49 + 71) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((void *)v53 + 4) = *(void *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_588:
          *((float *)v53 + 10) = -*((float *)v12 + 23);
          if (a3 >= 1) {
            goto LABEL_593;
          }
          goto LABEL_596;
        }
      }
      else
      {
        *((_DWORD *)v49 + 71) = *((_DWORD *)v12 + 24);
        *((void *)v53 + 4) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_588;
        }
      }
LABEL_591:
      if (a2 < 0)
      {
        *((float *)v53 + 10) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_593:
          *((float *)v53 + 11) = -*((float *)v12 + 24);
          *((void *)v53 + 10) = *(void *)(v12 + 84);
          if (a2 >= 1) {
            goto LABEL_598;
          }
          goto LABEL_601;
        }
      }
      else
      {
        *((_DWORD *)v53 + 10) = *((_DWORD *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_593;
        }
      }
LABEL_596:
      if (a3 < 0)
      {
        *((float *)v53 + 11) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((void *)v53 + 10) = *(void *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_598:
          *((float *)v53 + 22) = -*((float *)v12 + 21);
          if (a3 >= 1) {
            goto LABEL_603;
          }
          goto LABEL_606;
        }
      }
      else
      {
        *((_DWORD *)v53 + 11) = *((_DWORD *)v12 + 24);
        *((void *)v53 + 10) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_598;
        }
      }
LABEL_601:
      if (a2 < 0)
      {
        *((float *)v53 + 22) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_603:
          *((float *)v53 + 23) = -*((float *)v12 + 22);
          *((void *)v53 + 16) = *(void *)(v12 + 84);
          if (a2 >= 1) {
            goto LABEL_608;
          }
          goto LABEL_611;
        }
      }
      else
      {
        *((_DWORD *)v53 + 22) = *((_DWORD *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_603;
        }
      }
LABEL_606:
      if (a3 < 0)
      {
        *((float *)v53 + 23) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        *((void *)v53 + 16) = *(void *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_608:
          *((float *)v53 + 34) = -*((float *)v12 + 21);
          if (a3 >= 1) {
            goto LABEL_613;
          }
          goto LABEL_616;
        }
      }
      else
      {
        *((_DWORD *)v53 + 23) = *((_DWORD *)v12 + 22);
        *((void *)v53 + 16) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_608;
        }
      }
LABEL_611:
      if (a2 < 0)
      {
        *((float *)v53 + 34) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_613:
          *((float *)v53 + 35) = -*((float *)v12 + 22);
          *((void *)v53 + 22) = *(void *)(v12 + 84);
          if (a2 >= 1) {
            goto LABEL_618;
          }
          goto LABEL_621;
        }
      }
      else
      {
        *((_DWORD *)v53 + 34) = *((_DWORD *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_613;
        }
      }
LABEL_616:
      if (a3 < 0)
      {
        *((float *)v53 + 35) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        *((void *)v53 + 22) = *(void *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_618:
          *((float *)v53 + 46) = -*((float *)v12 + 21);
          if (a3 >= 1) {
            goto LABEL_623;
          }
          goto LABEL_626;
        }
      }
      else
      {
        *((_DWORD *)v53 + 35) = *((_DWORD *)v12 + 22);
        *((void *)v53 + 22) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_618;
        }
      }
LABEL_621:
      if (a2 < 0)
      {
        *((float *)v53 + 46) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_623:
          *((float *)v53 + 47) = -*((float *)v12 + 22);
          *((void *)v53 + 28) = *(void *)(v12 + 92);
          if (a2 >= 1) {
            goto LABEL_628;
          }
          goto LABEL_631;
        }
      }
      else
      {
        *((_DWORD *)v53 + 46) = *((_DWORD *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_623;
        }
      }
LABEL_626:
      if (a3 < 0)
      {
        *((float *)v53 + 47) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        *((void *)v53 + 28) = *(void *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_628:
          *((float *)v53 + 58) = -*((float *)v12 + 23);
          if (a3 >= 1) {
            goto LABEL_633;
          }
          goto LABEL_636;
        }
      }
      else
      {
        *((_DWORD *)v53 + 47) = *((_DWORD *)v12 + 22);
        *((void *)v53 + 28) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_628;
        }
      }
LABEL_631:
      if (a2 < 0)
      {
        *((float *)v53 + 58) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_633:
          *((float *)v53 + 59) = -*((float *)v12 + 24);
          *((void *)v53 + 34) = *(void *)(v12 + 92);
          if (a2 >= 1) {
            goto LABEL_638;
          }
          goto LABEL_641;
        }
      }
      else
      {
        *((_DWORD *)v53 + 58) = *((_DWORD *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_633;
        }
      }
LABEL_636:
      if (a3 < 0)
      {
        *((float *)v53 + 59) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((void *)v53 + 34) = *(void *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_638:
          *((float *)v53 + 70) = -*((float *)v12 + 23);
          if (a3 >= 1) {
            goto LABEL_643;
          }
          goto LABEL_646;
        }
      }
      else
      {
        *((_DWORD *)v53 + 59) = *((_DWORD *)v12 + 24);
        *((void *)v53 + 34) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_638;
        }
      }
LABEL_641:
      if (a2 < 0)
      {
        *((float *)v53 + 70) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_643:
          *((float *)v53 + 71) = -*((float *)v12 + 24);
          *((void *)v53 + 40) = *(void *)(v12 + 100);
          if (a2 >= 1) {
            goto LABEL_648;
          }
          goto LABEL_651;
        }
      }
      else
      {
        *((_DWORD *)v53 + 70) = *((_DWORD *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_643;
        }
      }
LABEL_646:
      if (a3 < 0)
      {
        *((float *)v53 + 71) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((void *)v53 + 40) = *(void *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_648:
          *((float *)v53 + 82) = -*((float *)v12 + 25);
          if (a3 >= 1) {
            goto LABEL_653;
          }
          goto LABEL_656;
        }
      }
      else
      {
        *((_DWORD *)v53 + 71) = *((_DWORD *)v12 + 24);
        *((void *)v53 + 40) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_648;
        }
      }
LABEL_651:
      if (a2 < 0)
      {
        *((float *)v53 + 82) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_653:
          *((float *)v53 + 83) = -*((float *)v12 + 26);
          *((void *)v53 + 46) = *(void *)(v12 + 92);
          if (a2 >= 1) {
            goto LABEL_658;
          }
          goto LABEL_661;
        }
      }
      else
      {
        *((_DWORD *)v53 + 82) = *((_DWORD *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_653;
        }
      }
LABEL_656:
      if (a3 < 0)
      {
        *((float *)v53 + 83) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((void *)v53 + 46) = *(void *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_658:
          *((float *)v53 + 94) = -*((float *)v12 + 23);
          if (a3 >= 1) {
            goto LABEL_663;
          }
          goto LABEL_666;
        }
      }
      else
      {
        *((_DWORD *)v53 + 83) = *((_DWORD *)v12 + 26);
        *((void *)v53 + 46) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_658;
        }
      }
LABEL_661:
      if (a2 < 0)
      {
        *((float *)v53 + 94) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_663:
          *((float *)v53 + 95) = -*((float *)v12 + 24);
          *((void *)v53 + 52) = *(void *)(v12 + 92);
          if (a2 >= 1) {
            goto LABEL_668;
          }
          goto LABEL_671;
        }
      }
      else
      {
        *((_DWORD *)v53 + 94) = *((_DWORD *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_663;
        }
      }
LABEL_666:
      if (a3 < 0)
      {
        *((float *)v53 + 95) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((void *)v53 + 52) = *(void *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_668:
          *((float *)v53 + 106) = -*((float *)v12 + 23);
          if (a3 >= 1) {
            goto LABEL_673;
          }
          goto LABEL_676;
        }
      }
      else
      {
        *((_DWORD *)v53 + 95) = *((_DWORD *)v12 + 24);
        *((void *)v53 + 52) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_668;
        }
      }
LABEL_671:
      if (a2 < 0)
      {
        *((float *)v53 + 106) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_673:
          *((float *)v53 + 107) = -*((float *)v12 + 24);
          *((void *)v53 + 58) = *(void *)(v12 + 92);
          if (a2 >= 1) {
            goto LABEL_678;
          }
          goto LABEL_681;
        }
      }
      else
      {
        *((_DWORD *)v53 + 106) = *((_DWORD *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_673;
        }
      }
LABEL_676:
      if (a3 < 0)
      {
        *((float *)v53 + 107) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((void *)v53 + 58) = *(void *)(v12 + 92);
        if (a2 >= 1)
        {
LABEL_678:
          *((float *)v53 + 118) = -*((float *)v12 + 23);
          if (a3 >= 1) {
            goto LABEL_683;
          }
          goto LABEL_686;
        }
      }
      else
      {
        *((_DWORD *)v53 + 107) = *((_DWORD *)v12 + 24);
        *((void *)v53 + 58) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_678;
        }
      }
LABEL_681:
      if (a2 < 0)
      {
        *((float *)v53 + 118) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
        if (a3 >= 1)
        {
LABEL_683:
          *((float *)v53 + 119) = -*((float *)v12 + 24);
          *((void *)v53 + 64) = *(void *)(v12 + 100);
          if (a2 >= 1) {
            goto LABEL_688;
          }
          goto LABEL_691;
        }
      }
      else
      {
        *((_DWORD *)v53 + 118) = *((_DWORD *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_683;
        }
      }
LABEL_686:
      if (a3 < 0)
      {
        *((float *)v53 + 119) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
        *((void *)v53 + 64) = *(void *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_688:
          *((float *)v53 + 130) = -*((float *)v12 + 25);
          if (a3 >= 1) {
            goto LABEL_693;
          }
          goto LABEL_696;
        }
      }
      else
      {
        *((_DWORD *)v53 + 119) = *((_DWORD *)v12 + 24);
        *((void *)v53 + 64) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_688;
        }
      }
LABEL_691:
      if (a2 < 0)
      {
        *((float *)v53 + 130) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_693:
          *((float *)v53 + 131) = -*((float *)v12 + 26);
          *((void *)v53 + 70) = *(void *)(v12 + 100);
          if (a2 >= 1) {
            goto LABEL_698;
          }
          goto LABEL_701;
        }
      }
      else
      {
        *((_DWORD *)v53 + 130) = *((_DWORD *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_693;
        }
      }
LABEL_696:
      if (a3 < 0)
      {
        *((float *)v53 + 131) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((void *)v53 + 70) = *(void *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_698:
          *((float *)v53 + 142) = -*((float *)v12 + 25);
          if (a3 >= 1) {
            goto LABEL_703;
          }
          goto LABEL_706;
        }
      }
      else
      {
        *((_DWORD *)v53 + 131) = *((_DWORD *)v12 + 26);
        *((void *)v53 + 70) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_698;
        }
      }
LABEL_701:
      if (a2 < 0)
      {
        *((float *)v53 + 142) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_703:
          *((float *)v53 + 143) = -*((float *)v12 + 26);
          *((void *)v53 + 76) = *(void *)(v12 + 84);
          if (a2 >= 1) {
            goto LABEL_708;
          }
          goto LABEL_711;
        }
      }
      else
      {
        *((_DWORD *)v53 + 142) = *((_DWORD *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_703;
        }
      }
LABEL_706:
      if (a3 < 0)
      {
        *((float *)v53 + 143) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((void *)v53 + 76) = *(void *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_708:
          *((float *)v53 + 154) = -*((float *)v12 + 21);
          if (a3 >= 1) {
            goto LABEL_713;
          }
          goto LABEL_716;
        }
      }
      else
      {
        *((_DWORD *)v53 + 143) = *((_DWORD *)v12 + 26);
        *((void *)v53 + 76) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_708;
        }
      }
LABEL_711:
      if (a2 < 0)
      {
        *((float *)v53 + 154) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_713:
          *((float *)v53 + 155) = -*((float *)v12 + 22);
          *((void *)v53 + 82) = *(void *)(v12 + 100);
          if (a2 >= 1) {
            goto LABEL_718;
          }
          goto LABEL_721;
        }
      }
      else
      {
        *((_DWORD *)v53 + 154) = *((_DWORD *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_713;
        }
      }
LABEL_716:
      if (a3 < 0)
      {
        *((float *)v53 + 155) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        *((void *)v53 + 82) = *(void *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_718:
          *((float *)v53 + 166) = -*((float *)v12 + 25);
          if (a3 >= 1) {
            goto LABEL_723;
          }
          goto LABEL_726;
        }
      }
      else
      {
        *((_DWORD *)v53 + 155) = *((_DWORD *)v12 + 22);
        *((void *)v53 + 82) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_718;
        }
      }
LABEL_721:
      if (a2 < 0)
      {
        *((float *)v53 + 166) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_723:
          *((float *)v53 + 167) = -*((float *)v12 + 26);
          *((void *)v53 + 88) = *(void *)(v12 + 100);
          if (a2 >= 1) {
            goto LABEL_728;
          }
          goto LABEL_731;
        }
      }
      else
      {
        *((_DWORD *)v53 + 166) = *((_DWORD *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_723;
        }
      }
LABEL_726:
      if (a3 < 0)
      {
        *((float *)v53 + 167) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((void *)v53 + 88) = *(void *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_728:
          *((float *)v53 + 178) = -*((float *)v12 + 25);
          if (a3 >= 1) {
            goto LABEL_733;
          }
          goto LABEL_736;
        }
      }
      else
      {
        *((_DWORD *)v53 + 167) = *((_DWORD *)v12 + 26);
        *((void *)v53 + 88) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_728;
        }
      }
LABEL_731:
      if (a2 < 0)
      {
        *((float *)v53 + 178) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_733:
          *((float *)v53 + 179) = -*((float *)v12 + 26);
          *((void *)v53 + 94) = *(void *)(v12 + 100);
          if (a2 >= 1) {
            goto LABEL_738;
          }
          goto LABEL_741;
        }
      }
      else
      {
        *((_DWORD *)v53 + 178) = *((_DWORD *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_733;
        }
      }
LABEL_736:
      if (a3 < 0)
      {
        *((float *)v53 + 179) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((void *)v53 + 94) = *(void *)(v12 + 100);
        if (a2 >= 1)
        {
LABEL_738:
          *((float *)v53 + 190) = -*((float *)v12 + 25);
          if (a3 >= 1) {
            goto LABEL_743;
          }
          goto LABEL_746;
        }
      }
      else
      {
        *((_DWORD *)v53 + 179) = *((_DWORD *)v12 + 26);
        *((void *)v53 + 94) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_738;
        }
      }
LABEL_741:
      if (a2 < 0)
      {
        *((float *)v53 + 190) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
        if (a3 >= 1)
        {
LABEL_743:
          *((float *)v53 + 191) = -*((float *)v12 + 26);
          *((void *)v53 + 100) = *(void *)(v12 + 84);
          if (a2 >= 1) {
            goto LABEL_748;
          }
          goto LABEL_751;
        }
      }
      else
      {
        *((_DWORD *)v53 + 190) = *((_DWORD *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_743;
        }
      }
LABEL_746:
      if (a3 < 0)
      {
        *((float *)v53 + 191) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
        *((void *)v53 + 100) = *(void *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_748:
          *((float *)v53 + 202) = -*((float *)v12 + 21);
          if (a3 >= 1) {
            goto LABEL_753;
          }
          goto LABEL_756;
        }
      }
      else
      {
        *((_DWORD *)v53 + 191) = *((_DWORD *)v12 + 26);
        *((void *)v53 + 100) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_748;
        }
      }
LABEL_751:
      if (a2 < 0)
      {
        *((float *)v53 + 202) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_753:
          *((float *)v53 + 203) = -*((float *)v12 + 22);
          *((void *)v53 + 106) = *(void *)(v12 + 84);
          if (a2 >= 1) {
            goto LABEL_758;
          }
          goto LABEL_761;
        }
      }
      else
      {
        *((_DWORD *)v53 + 202) = *((_DWORD *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_753;
        }
      }
LABEL_756:
      if (a3 < 0)
      {
        *((float *)v53 + 203) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
        *((void *)v53 + 106) = *(void *)(v12 + 84);
        if (a2 >= 1)
        {
LABEL_758:
          *((float *)v53 + 214) = -*((float *)v12 + 21);
          if (a3 < 1) {
            goto LABEL_765;
          }
          goto LABEL_526;
        }
      }
      else
      {
        *((_DWORD *)v53 + 203) = *((_DWORD *)v12 + 22);
        *((void *)v53 + 106) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_758;
        }
      }
LABEL_761:
      if (a2 < 0)
      {
        *((float *)v53 + 214) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 < 1)
        {
LABEL_765:
          if (a3 < 0) {
            float v54 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
          }
          else {
            float v54 = *((float *)v12 + 22);
          }
          goto LABEL_527;
        }
      }
      else
      {
        *((_DWORD *)v53 + 214) = *((_DWORD *)v12 + 21);
        if (a3 < 1) {
          goto LABEL_765;
        }
      }
LABEL_526:
      float v54 = -*((float *)v12 + 22);
LABEL_527:
      *((float *)v53 + 215) = v54;
      v49 += 36;
      v53 += 864;
      v12 += 108;
      float v11 = (char *)v11 - 1;
      if (!v11) {
        return;
      }
    }
  }
  uint64_t v18 = 36;
  if (*((float *)this + 34) == 0.0) {
    uint64_t v18 = 6;
  }
  uint64_t v19 = v18 * (void)v11;
  uint64_t v20 = 3 * v18 * (void)v11;
  size_t v21 = 16 * v20;
  size_t v22 = (size_t)this[3];
  if (v22 >= 16 * v20)
  {
    if (!*((_DWORD *)this + 35) || this[13]) {
      goto LABEL_58;
    }
    float v24 = 0;
    malloc_type_id_t v25 = 2743976168;
  }
  else
  {
    int v23 = this[12];
    this[3] = (void *)v21;
    this[12] = malloc_type_realloc(v23, 16 * v20, 0x4704CCD1uLL);
    float v24 = this[13];
    if (!*((_DWORD *)this + 35))
    {
      if (v24)
      {
        free(v24);
        this[13] = 0;
      }
      goto LABEL_58;
    }
    size_t v22 = (size_t)this[3];
    malloc_type_id_t v25 = 1948624706;
  }
  this[13] = malloc_type_realloc(v24, v22, v25);
LABEL_58:
  bzero(this[12], v21);
  if (*((_DWORD *)this + 35)) {
    bzero(this[13], v21);
  }
  this[14] = (void *)v19;
  uint64_t v43 = this[12];
  if (*((float *)this + 34) == 0.0)
  {
    int v44 = (char *)(v43 + 22);
    for (uint64_t k = (float *)(v12 + 84); ; k += 29)
    {
      *((void *)v44 - 18) = *(void *)k;
      if (a2 < 1)
      {
        if (a2 < 0)
        {
          *((float *)v44 - 34) = (float)(*(k - 21) + *(k - 21)) - *k;
          if (a3 >= 1)
          {
LABEL_69:
            *((float *)v44 - 33) = -k[1];
            *((void *)v44 - 12) = *((void *)k + 1);
            if (a2 >= 1) {
              goto LABEL_74;
            }
            goto LABEL_77;
          }
        }
        else
        {
          *((float *)v44 - 34) = *k;
          if (a3 >= 1) {
            goto LABEL_69;
          }
        }
      }
      else
      {
        *((float *)v44 - 34) = -*k;
        if (a3 >= 1) {
          goto LABEL_69;
        }
      }
      if (a3 < 0)
      {
        *((float *)v44 - 33) = (float)(*(k - 20) + *(k - 20)) - k[1];
        *((void *)v44 - 12) = *((void *)k + 1);
        if (a2 >= 1)
        {
LABEL_74:
          *((float *)v44 - 22) = -k[2];
          if (a3 >= 1) {
            goto LABEL_79;
          }
          goto LABEL_82;
        }
      }
      else
      {
        *((float *)v44 - 33) = k[1];
        *((void *)v44 - 12) = *((void *)k + 1);
        if (a2 >= 1) {
          goto LABEL_74;
        }
      }
LABEL_77:
      if (a2 < 0)
      {
        *((float *)v44 - 22) = (float)(*(k - 21) + *(k - 21)) - k[2];
        if (a3 >= 1)
        {
LABEL_79:
          *((float *)v44 - 21) = -k[3];
          *((void *)v44 - 6) = *((void *)k + 2);
          if (a2 >= 1) {
            goto LABEL_84;
          }
          goto LABEL_87;
        }
      }
      else
      {
        *((float *)v44 - 22) = k[2];
        if (a3 >= 1) {
          goto LABEL_79;
        }
      }
LABEL_82:
      if (a3 < 0)
      {
        *((float *)v44 - 21) = (float)(*(k - 20) + *(k - 20)) - k[3];
        *((void *)v44 - 6) = *((void *)k + 2);
        if (a2 >= 1)
        {
LABEL_84:
          *((float *)v44 - 10) = -k[4];
          if (a3 >= 1) {
            goto LABEL_89;
          }
          goto LABEL_92;
        }
      }
      else
      {
        *((float *)v44 - 21) = k[3];
        *((void *)v44 - 6) = *((void *)k + 2);
        if (a2 >= 1) {
          goto LABEL_84;
        }
      }
LABEL_87:
      if (a2 < 0)
      {
        *((float *)v44 - 10) = (float)(*(k - 21) + *(k - 21)) - k[4];
        if (a3 >= 1)
        {
LABEL_89:
          *((float *)v44 - 9) = -k[5];
          *(void *)int v44 = *((void *)k + 2);
          if (a2 >= 1) {
            goto LABEL_94;
          }
          goto LABEL_97;
        }
      }
      else
      {
        *((float *)v44 - 10) = k[4];
        if (a3 >= 1) {
          goto LABEL_89;
        }
      }
LABEL_92:
      if (a3 < 0)
      {
        *((float *)v44 - 9) = (float)(*(k - 20) + *(k - 20)) - k[5];
        *(void *)int v44 = *((void *)k + 2);
        if (a2 >= 1)
        {
LABEL_94:
          *((float *)v44 + 2) = -k[4];
          if (a3 >= 1) {
            goto LABEL_99;
          }
          goto LABEL_102;
        }
      }
      else
      {
        *((float *)v44 - 9) = k[5];
        *(void *)int v44 = *((void *)k + 2);
        if (a2 >= 1) {
          goto LABEL_94;
        }
      }
LABEL_97:
      if (a2 < 0)
      {
        *((float *)v44 + 2) = (float)(*(k - 21) + *(k - 21)) - k[4];
        if (a3 >= 1)
        {
LABEL_99:
          *((float *)v44 + 3) = -k[5];
          *((void *)v44 + 6) = *((void *)k + 3);
          if (a2 >= 1) {
            goto LABEL_104;
          }
          goto LABEL_107;
        }
      }
      else
      {
        *((float *)v44 + 2) = k[4];
        if (a3 >= 1) {
          goto LABEL_99;
        }
      }
LABEL_102:
      if (a3 < 0)
      {
        *((float *)v44 + 3) = (float)(*(k - 20) + *(k - 20)) - k[5];
        *((void *)v44 + 6) = *((void *)k + 3);
        if (a2 >= 1)
        {
LABEL_104:
          *((float *)v44 + 14) = -k[6];
          if (a3 >= 1) {
            goto LABEL_109;
          }
          goto LABEL_112;
        }
      }
      else
      {
        *((float *)v44 + 3) = k[5];
        *((void *)v44 + 6) = *((void *)k + 3);
        if (a2 >= 1) {
          goto LABEL_104;
        }
      }
LABEL_107:
      if (a2 < 0)
      {
        *((float *)v44 + 14) = (float)(*(k - 21) + *(k - 21)) - k[6];
        if (a3 >= 1)
        {
LABEL_109:
          *((float *)v44 + 15) = -k[7];
          *((void *)v44 + 12) = *(void *)k;
          if (a2 >= 1) {
            goto LABEL_114;
          }
          goto LABEL_117;
        }
      }
      else
      {
        *((float *)v44 + 14) = k[6];
        if (a3 >= 1) {
          goto LABEL_109;
        }
      }
LABEL_112:
      if (a3 < 0)
      {
        *((float *)v44 + 15) = (float)(*(k - 20) + *(k - 20)) - k[7];
        *((void *)v44 + 12) = *(void *)k;
        if (a2 >= 1)
        {
LABEL_114:
          *((float *)v44 + 26) = -*k;
          if (a3 < 1) {
            goto LABEL_121;
          }
          goto LABEL_62;
        }
      }
      else
      {
        *((float *)v44 + 15) = k[7];
        *((void *)v44 + 12) = *(void *)k;
        if (a2 >= 1) {
          goto LABEL_114;
        }
      }
LABEL_117:
      if (a2 < 0)
      {
        *((float *)v44 + 26) = (float)(*(k - 21) + *(k - 21)) - *k;
        if (a3 < 1)
        {
LABEL_121:
          if (a3 < 0) {
            float v46 = (float)(*(k - 20) + *(k - 20)) - k[1];
          }
          else {
            float v46 = k[1];
          }
          goto LABEL_63;
        }
      }
      else
      {
        *((float *)v44 + 26) = *k;
        if (a3 < 1) {
          goto LABEL_121;
        }
      }
LABEL_62:
      float v46 = -k[1];
LABEL_63:
      *((float *)v44 + 27) = v46;
      v44 += 288;
      float v11 = (char *)v11 - 1;
      if (!v11) {
        return;
      }
    }
  }
  uint64_t v47 = (char *)&v43[72 * (void)v11];
  do
  {
    v43[4] = *(void *)(v12 + 84);
    if (a2 < 1)
    {
      if (a2 < 0)
      {
        *((float *)v43 + 10) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
        if (a3 >= 1)
        {
LABEL_132:
          *((float *)v43 + 11) = -*((float *)v12 + 22);
          v43[10] = *(void *)(v12 + 92);
          if (a2 >= 1) {
            goto LABEL_137;
          }
          goto LABEL_140;
        }
      }
      else
      {
        *((_DWORD *)v43 + 10) = *((_DWORD *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_132;
        }
      }
    }
    else
    {
      *((float *)v43 + 10) = -*((float *)v12 + 21);
      if (a3 >= 1) {
        goto LABEL_132;
      }
    }
    if (a3 < 0)
    {
      *((float *)v43 + 11) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      v43[10] = *(void *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_137:
        *((float *)v43 + 22) = -*((float *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_142;
        }
        goto LABEL_145;
      }
    }
    else
    {
      *((_DWORD *)v43 + 11) = *((_DWORD *)v12 + 22);
      v43[10] = *(void *)(v12 + 92);
      if (a2 >= 1) {
        goto LABEL_137;
      }
    }
LABEL_140:
    if (a2 < 0)
    {
      *((float *)v43 + 22) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_142:
        *((float *)v43 + 23) = -*((float *)v12 + 24);
        v43[16] = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_147;
        }
        goto LABEL_150;
      }
    }
    else
    {
      *((_DWORD *)v43 + 22) = *((_DWORD *)v12 + 23);
      if (a3 >= 1) {
        goto LABEL_142;
      }
    }
LABEL_145:
    if (a3 < 0)
    {
      *((float *)v43 + 23) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      v43[16] = *(void *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_147:
        *((float *)v43 + 34) = -*((float *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_152;
        }
        goto LABEL_155;
      }
    }
    else
    {
      *((_DWORD *)v43 + 23) = *((_DWORD *)v12 + 24);
      v43[16] = *(void *)(v12 + 100);
      if (a2 >= 1) {
        goto LABEL_147;
      }
    }
LABEL_150:
    if (a2 < 0)
    {
      *((float *)v43 + 34) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_152:
        *((float *)v43 + 35) = -*((float *)v12 + 26);
        v43[22] = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_157;
        }
        goto LABEL_160;
      }
    }
    else
    {
      *((_DWORD *)v43 + 34) = *((_DWORD *)v12 + 25);
      if (a3 >= 1) {
        goto LABEL_152;
      }
    }
LABEL_155:
    if (a3 < 0)
    {
      *((float *)v43 + 35) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      v43[22] = *(void *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_157:
        *((float *)v43 + 46) = -*((float *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_162;
        }
        goto LABEL_165;
      }
    }
    else
    {
      *((_DWORD *)v43 + 35) = *((_DWORD *)v12 + 26);
      v43[22] = *(void *)(v12 + 100);
      if (a2 >= 1) {
        goto LABEL_157;
      }
    }
LABEL_160:
    if (a2 < 0)
    {
      *((float *)v43 + 46) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_162:
        *((float *)v43 + 47) = -*((float *)v12 + 26);
        v43[28] = *(void *)(v12 + 108);
        if (a2 >= 1) {
          goto LABEL_167;
        }
        goto LABEL_170;
      }
    }
    else
    {
      *((_DWORD *)v43 + 46) = *((_DWORD *)v12 + 25);
      if (a3 >= 1) {
        goto LABEL_162;
      }
    }
LABEL_165:
    if (a3 < 0)
    {
      *((float *)v43 + 47) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      v43[28] = *(void *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_167:
        *((float *)v43 + 58) = -*((float *)v12 + 27);
        if (a3 >= 1) {
          goto LABEL_172;
        }
        goto LABEL_175;
      }
    }
    else
    {
      *((_DWORD *)v43 + 47) = *((_DWORD *)v12 + 26);
      v43[28] = *(void *)(v12 + 108);
      if (a2 >= 1) {
        goto LABEL_167;
      }
    }
LABEL_170:
    if (a2 < 0)
    {
      *((float *)v43 + 58) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_172:
        *((float *)v43 + 59) = -*((float *)v12 + 28);
        v43[34] = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_177;
        }
        goto LABEL_180;
      }
    }
    else
    {
      *((_DWORD *)v43 + 58) = *((_DWORD *)v12 + 27);
      if (a3 >= 1) {
        goto LABEL_172;
      }
    }
LABEL_175:
    if (a3 < 0)
    {
      *((float *)v43 + 59) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      v43[34] = *(void *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_177:
        *((float *)v43 + 70) = -*((float *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_182;
        }
        goto LABEL_185;
      }
    }
    else
    {
      *((_DWORD *)v43 + 59) = *((_DWORD *)v12 + 28);
      v43[34] = *(void *)(v12 + 84);
      if (a2 >= 1) {
        goto LABEL_177;
      }
    }
LABEL_180:
    if (a2 < 0)
    {
      *((float *)v43 + 70) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_182:
        *((float *)v43 + 71) = -*((float *)v12 + 22);
        v43[40] = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_187;
        }
        goto LABEL_190;
      }
    }
    else
    {
      *((_DWORD *)v43 + 70) = *((_DWORD *)v12 + 21);
      if (a3 >= 1) {
        goto LABEL_182;
      }
    }
LABEL_185:
    if (a3 < 0)
    {
      *((float *)v43 + 71) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      v43[40] = *(void *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_187:
        *((float *)v43 + 82) = -*((float *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_192;
        }
        goto LABEL_195;
      }
    }
    else
    {
      *((_DWORD *)v43 + 71) = *((_DWORD *)v12 + 22);
      v43[40] = *(void *)(v12 + 84);
      if (a2 >= 1) {
        goto LABEL_187;
      }
    }
LABEL_190:
    if (a2 < 0)
    {
      *((float *)v43 + 82) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_192:
        *((float *)v43 + 83) = -*((float *)v12 + 22);
        v43[46] = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_197;
        }
        goto LABEL_200;
      }
    }
    else
    {
      *((_DWORD *)v43 + 82) = *((_DWORD *)v12 + 21);
      if (a3 >= 1) {
        goto LABEL_192;
      }
    }
LABEL_195:
    if (a3 < 0)
    {
      *((float *)v43 + 83) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      v43[46] = *(void *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_197:
        *((float *)v43 + 94) = -*((float *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_202;
        }
        goto LABEL_205;
      }
    }
    else
    {
      *((_DWORD *)v43 + 83) = *((_DWORD *)v12 + 22);
      v43[46] = *(void *)(v12 + 100);
      if (a2 >= 1) {
        goto LABEL_197;
      }
    }
LABEL_200:
    if (a2 < 0)
    {
      *((float *)v43 + 94) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_202:
        *((float *)v43 + 95) = -*((float *)v12 + 26);
        v43[52] = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_207;
        }
        goto LABEL_210;
      }
    }
    else
    {
      *((_DWORD *)v43 + 94) = *((_DWORD *)v12 + 25);
      if (a3 >= 1) {
        goto LABEL_202;
      }
    }
LABEL_205:
    if (a3 < 0)
    {
      *((float *)v43 + 95) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      v43[52] = *(void *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_207:
        *((float *)v43 + 106) = -*((float *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_212;
        }
        goto LABEL_215;
      }
    }
    else
    {
      *((_DWORD *)v43 + 95) = *((_DWORD *)v12 + 26);
      v43[52] = *(void *)(v12 + 92);
      if (a2 >= 1) {
        goto LABEL_207;
      }
    }
LABEL_210:
    if (a2 < 0)
    {
      *((float *)v43 + 106) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_212:
        *((float *)v43 + 107) = -*((float *)v12 + 24);
        v43[58] = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_217;
        }
        goto LABEL_220;
      }
    }
    else
    {
      *((_DWORD *)v43 + 106) = *((_DWORD *)v12 + 23);
      if (a3 >= 1) {
        goto LABEL_212;
      }
    }
LABEL_215:
    if (a3 < 0)
    {
      *((float *)v43 + 107) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      v43[58] = *(void *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_217:
        *((float *)v43 + 118) = -*((float *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_222;
        }
        goto LABEL_225;
      }
    }
    else
    {
      *((_DWORD *)v43 + 107) = *((_DWORD *)v12 + 24);
      v43[58] = *(void *)(v12 + 100);
      if (a2 >= 1) {
        goto LABEL_217;
      }
    }
LABEL_220:
    if (a2 < 0)
    {
      *((float *)v43 + 118) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_222:
        *((float *)v43 + 119) = -*((float *)v12 + 26);
        v43[64] = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_227;
        }
        goto LABEL_230;
      }
    }
    else
    {
      *((_DWORD *)v43 + 118) = *((_DWORD *)v12 + 25);
      if (a3 >= 1) {
        goto LABEL_222;
      }
    }
LABEL_225:
    if (a3 < 0)
    {
      *((float *)v43 + 119) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      v43[64] = *(void *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_227:
        *((float *)v43 + 130) = -*((float *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_232;
        }
        goto LABEL_235;
      }
    }
    else
    {
      *((_DWORD *)v43 + 119) = *((_DWORD *)v12 + 26);
      v43[64] = *(void *)(v12 + 84);
      if (a2 >= 1) {
        goto LABEL_227;
      }
    }
LABEL_230:
    if (a2 < 0)
    {
      *((float *)v43 + 130) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_232:
        *((float *)v43 + 131) = -*((float *)v12 + 22);
        v43[70] = *(void *)(v12 + 108);
        if (a2 >= 1) {
          goto LABEL_237;
        }
        goto LABEL_240;
      }
    }
    else
    {
      *((_DWORD *)v43 + 130) = *((_DWORD *)v12 + 21);
      if (a3 >= 1) {
        goto LABEL_232;
      }
    }
LABEL_235:
    if (a3 < 0)
    {
      *((float *)v43 + 131) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      v43[70] = *(void *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_237:
        *((float *)v43 + 142) = -*((float *)v12 + 27);
        if (a3 >= 1) {
          goto LABEL_242;
        }
        goto LABEL_245;
      }
    }
    else
    {
      *((_DWORD *)v43 + 131) = *((_DWORD *)v12 + 22);
      v43[70] = *(void *)(v12 + 108);
      if (a2 >= 1) {
        goto LABEL_237;
      }
    }
LABEL_240:
    if (a2 < 0)
    {
      *((float *)v43 + 142) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_242:
        *((float *)v43 + 143) = -*((float *)v12 + 28);
        *((void *)v47 + 4) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_247;
        }
        goto LABEL_250;
      }
    }
    else
    {
      *((_DWORD *)v43 + 142) = *((_DWORD *)v12 + 27);
      if (a3 >= 1) {
        goto LABEL_242;
      }
    }
LABEL_245:
    if (a3 < 0)
    {
      *((float *)v43 + 143) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((void *)v47 + 4) = *(void *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_247:
        *((float *)v47 + 10) = -*((float *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_252;
        }
        goto LABEL_255;
      }
    }
    else
    {
      *((_DWORD *)v43 + 143) = *((_DWORD *)v12 + 28);
      *((void *)v47 + 4) = *(void *)(v12 + 92);
      if (a2 >= 1) {
        goto LABEL_247;
      }
    }
LABEL_250:
    if (a2 < 0)
    {
      *((float *)v47 + 10) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_252:
        *((float *)v47 + 11) = -*((float *)v12 + 24);
        *((void *)v47 + 10) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_257;
        }
        goto LABEL_260;
      }
    }
    else
    {
      *((_DWORD *)v47 + 10) = *((_DWORD *)v12 + 23);
      if (a3 >= 1) {
        goto LABEL_252;
      }
    }
LABEL_255:
    if (a3 < 0)
    {
      *((float *)v47 + 11) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((void *)v47 + 10) = *(void *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_257:
        *((float *)v47 + 22) = -*((float *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_262;
        }
        goto LABEL_265;
      }
    }
    else
    {
      *((_DWORD *)v47 + 11) = *((_DWORD *)v12 + 24);
      *((void *)v47 + 10) = *(void *)(v12 + 84);
      if (a2 >= 1) {
        goto LABEL_257;
      }
    }
LABEL_260:
    if (a2 < 0)
    {
      *((float *)v47 + 22) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_262:
        *((float *)v47 + 23) = -*((float *)v12 + 22);
        *((void *)v47 + 16) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_267;
        }
        goto LABEL_270;
      }
    }
    else
    {
      *((_DWORD *)v47 + 22) = *((_DWORD *)v12 + 21);
      if (a3 >= 1) {
        goto LABEL_262;
      }
    }
LABEL_265:
    if (a3 < 0)
    {
      *((float *)v47 + 23) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      *((void *)v47 + 16) = *(void *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_267:
        *((float *)v47 + 34) = -*((float *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_272;
        }
        goto LABEL_275;
      }
    }
    else
    {
      *((_DWORD *)v47 + 23) = *((_DWORD *)v12 + 22);
      *((void *)v47 + 16) = *(void *)(v12 + 84);
      if (a2 >= 1) {
        goto LABEL_267;
      }
    }
LABEL_270:
    if (a2 < 0)
    {
      *((float *)v47 + 34) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_272:
        *((float *)v47 + 35) = -*((float *)v12 + 22);
        *((void *)v47 + 22) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_277;
        }
        goto LABEL_280;
      }
    }
    else
    {
      *((_DWORD *)v47 + 34) = *((_DWORD *)v12 + 21);
      if (a3 >= 1) {
        goto LABEL_272;
      }
    }
LABEL_275:
    if (a3 < 0)
    {
      *((float *)v47 + 35) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      *((void *)v47 + 22) = *(void *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_277:
        *((float *)v47 + 46) = -*((float *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_282;
        }
        goto LABEL_285;
      }
    }
    else
    {
      *((_DWORD *)v47 + 35) = *((_DWORD *)v12 + 22);
      *((void *)v47 + 22) = *(void *)(v12 + 84);
      if (a2 >= 1) {
        goto LABEL_277;
      }
    }
LABEL_280:
    if (a2 < 0)
    {
      *((float *)v47 + 46) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_282:
        *((float *)v47 + 47) = -*((float *)v12 + 22);
        *((void *)v47 + 28) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_287;
        }
        goto LABEL_290;
      }
    }
    else
    {
      *((_DWORD *)v47 + 46) = *((_DWORD *)v12 + 21);
      if (a3 >= 1) {
        goto LABEL_282;
      }
    }
LABEL_285:
    if (a3 < 0)
    {
      *((float *)v47 + 47) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      *((void *)v47 + 28) = *(void *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_287:
        *((float *)v47 + 58) = -*((float *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_292;
        }
        goto LABEL_295;
      }
    }
    else
    {
      *((_DWORD *)v47 + 47) = *((_DWORD *)v12 + 22);
      *((void *)v47 + 28) = *(void *)(v12 + 92);
      if (a2 >= 1) {
        goto LABEL_287;
      }
    }
LABEL_290:
    if (a2 < 0)
    {
      *((float *)v47 + 58) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_292:
        *((float *)v47 + 59) = -*((float *)v12 + 24);
        *((void *)v47 + 34) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_297;
        }
        goto LABEL_300;
      }
    }
    else
    {
      *((_DWORD *)v47 + 58) = *((_DWORD *)v12 + 23);
      if (a3 >= 1) {
        goto LABEL_292;
      }
    }
LABEL_295:
    if (a3 < 0)
    {
      *((float *)v47 + 59) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((void *)v47 + 34) = *(void *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_297:
        *((float *)v47 + 70) = -*((float *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_302;
        }
        goto LABEL_305;
      }
    }
    else
    {
      *((_DWORD *)v47 + 59) = *((_DWORD *)v12 + 24);
      *((void *)v47 + 34) = *(void *)(v12 + 92);
      if (a2 >= 1) {
        goto LABEL_297;
      }
    }
LABEL_300:
    if (a2 < 0)
    {
      *((float *)v47 + 70) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_302:
        *((float *)v47 + 71) = -*((float *)v12 + 24);
        *((void *)v47 + 40) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_307;
        }
        goto LABEL_310;
      }
    }
    else
    {
      *((_DWORD *)v47 + 70) = *((_DWORD *)v12 + 23);
      if (a3 >= 1) {
        goto LABEL_302;
      }
    }
LABEL_305:
    if (a3 < 0)
    {
      *((float *)v47 + 71) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((void *)v47 + 40) = *(void *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_307:
        *((float *)v47 + 82) = -*((float *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_312;
        }
        goto LABEL_315;
      }
    }
    else
    {
      *((_DWORD *)v47 + 71) = *((_DWORD *)v12 + 24);
      *((void *)v47 + 40) = *(void *)(v12 + 100);
      if (a2 >= 1) {
        goto LABEL_307;
      }
    }
LABEL_310:
    if (a2 < 0)
    {
      *((float *)v47 + 82) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_312:
        *((float *)v47 + 83) = -*((float *)v12 + 26);
        *((void *)v47 + 46) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_317;
        }
        goto LABEL_320;
      }
    }
    else
    {
      *((_DWORD *)v47 + 82) = *((_DWORD *)v12 + 25);
      if (a3 >= 1) {
        goto LABEL_312;
      }
    }
LABEL_315:
    if (a3 < 0)
    {
      *((float *)v47 + 83) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((void *)v47 + 46) = *(void *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_317:
        *((float *)v47 + 94) = -*((float *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_322;
        }
        goto LABEL_325;
      }
    }
    else
    {
      *((_DWORD *)v47 + 83) = *((_DWORD *)v12 + 26);
      *((void *)v47 + 46) = *(void *)(v12 + 92);
      if (a2 >= 1) {
        goto LABEL_317;
      }
    }
LABEL_320:
    if (a2 < 0)
    {
      *((float *)v47 + 94) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_322:
        *((float *)v47 + 95) = -*((float *)v12 + 24);
        *((void *)v47 + 52) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_327;
        }
        goto LABEL_330;
      }
    }
    else
    {
      *((_DWORD *)v47 + 94) = *((_DWORD *)v12 + 23);
      if (a3 >= 1) {
        goto LABEL_322;
      }
    }
LABEL_325:
    if (a3 < 0)
    {
      *((float *)v47 + 95) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((void *)v47 + 52) = *(void *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_327:
        *((float *)v47 + 106) = -*((float *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_332;
        }
        goto LABEL_335;
      }
    }
    else
    {
      *((_DWORD *)v47 + 95) = *((_DWORD *)v12 + 24);
      *((void *)v47 + 52) = *(void *)(v12 + 92);
      if (a2 >= 1) {
        goto LABEL_327;
      }
    }
LABEL_330:
    if (a2 < 0)
    {
      *((float *)v47 + 106) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_332:
        *((float *)v47 + 107) = -*((float *)v12 + 24);
        *((void *)v47 + 58) = *(void *)(v12 + 92);
        if (a2 >= 1) {
          goto LABEL_337;
        }
        goto LABEL_340;
      }
    }
    else
    {
      *((_DWORD *)v47 + 106) = *((_DWORD *)v12 + 23);
      if (a3 >= 1) {
        goto LABEL_332;
      }
    }
LABEL_335:
    if (a3 < 0)
    {
      *((float *)v47 + 107) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((void *)v47 + 58) = *(void *)(v12 + 92);
      if (a2 >= 1)
      {
LABEL_337:
        *((float *)v47 + 118) = -*((float *)v12 + 23);
        if (a3 >= 1) {
          goto LABEL_342;
        }
        goto LABEL_345;
      }
    }
    else
    {
      *((_DWORD *)v47 + 107) = *((_DWORD *)v12 + 24);
      *((void *)v47 + 58) = *(void *)(v12 + 92);
      if (a2 >= 1) {
        goto LABEL_337;
      }
    }
LABEL_340:
    if (a2 < 0)
    {
      *((float *)v47 + 118) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 23);
      if (a3 >= 1)
      {
LABEL_342:
        *((float *)v47 + 119) = -*((float *)v12 + 24);
        *((void *)v47 + 64) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_347;
        }
        goto LABEL_350;
      }
    }
    else
    {
      *((_DWORD *)v47 + 118) = *((_DWORD *)v12 + 23);
      if (a3 >= 1) {
        goto LABEL_342;
      }
    }
LABEL_345:
    if (a3 < 0)
    {
      *((float *)v47 + 119) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 24);
      *((void *)v47 + 64) = *(void *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_347:
        *((float *)v47 + 130) = -*((float *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_352;
        }
        goto LABEL_355;
      }
    }
    else
    {
      *((_DWORD *)v47 + 119) = *((_DWORD *)v12 + 24);
      *((void *)v47 + 64) = *(void *)(v12 + 100);
      if (a2 >= 1) {
        goto LABEL_347;
      }
    }
LABEL_350:
    if (a2 < 0)
    {
      *((float *)v47 + 130) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_352:
        *((float *)v47 + 131) = -*((float *)v12 + 26);
        *((void *)v47 + 70) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_357;
        }
        goto LABEL_360;
      }
    }
    else
    {
      *((_DWORD *)v47 + 130) = *((_DWORD *)v12 + 25);
      if (a3 >= 1) {
        goto LABEL_352;
      }
    }
LABEL_355:
    if (a3 < 0)
    {
      *((float *)v47 + 131) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((void *)v47 + 70) = *(void *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_357:
        *((float *)v47 + 142) = -*((float *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_362;
        }
        goto LABEL_365;
      }
    }
    else
    {
      *((_DWORD *)v47 + 131) = *((_DWORD *)v12 + 26);
      *((void *)v47 + 70) = *(void *)(v12 + 100);
      if (a2 >= 1) {
        goto LABEL_357;
      }
    }
LABEL_360:
    if (a2 < 0)
    {
      *((float *)v47 + 142) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_362:
        *((float *)v47 + 143) = -*((float *)v12 + 26);
        *((void *)v47 + 76) = *(void *)(v12 + 108);
        if (a2 >= 1) {
          goto LABEL_367;
        }
        goto LABEL_370;
      }
    }
    else
    {
      *((_DWORD *)v47 + 142) = *((_DWORD *)v12 + 25);
      if (a3 >= 1) {
        goto LABEL_362;
      }
    }
LABEL_365:
    if (a3 < 0)
    {
      *((float *)v47 + 143) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((void *)v47 + 76) = *(void *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_367:
        *((float *)v47 + 154) = -*((float *)v12 + 27);
        if (a3 >= 1) {
          goto LABEL_372;
        }
        goto LABEL_375;
      }
    }
    else
    {
      *((_DWORD *)v47 + 143) = *((_DWORD *)v12 + 26);
      *((void *)v47 + 76) = *(void *)(v12 + 108);
      if (a2 >= 1) {
        goto LABEL_367;
      }
    }
LABEL_370:
    if (a2 < 0)
    {
      *((float *)v47 + 154) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_372:
        *((float *)v47 + 155) = -*((float *)v12 + 28);
        *((void *)v47 + 82) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_377;
        }
        goto LABEL_380;
      }
    }
    else
    {
      *((_DWORD *)v47 + 154) = *((_DWORD *)v12 + 27);
      if (a3 >= 1) {
        goto LABEL_372;
      }
    }
LABEL_375:
    if (a3 < 0)
    {
      *((float *)v47 + 155) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((void *)v47 + 82) = *(void *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_377:
        *((float *)v47 + 166) = -*((float *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_382;
        }
        goto LABEL_385;
      }
    }
    else
    {
      *((_DWORD *)v47 + 155) = *((_DWORD *)v12 + 28);
      *((void *)v47 + 82) = *(void *)(v12 + 100);
      if (a2 >= 1) {
        goto LABEL_377;
      }
    }
LABEL_380:
    if (a2 < 0)
    {
      *((float *)v47 + 166) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_382:
        *((float *)v47 + 167) = -*((float *)v12 + 26);
        *((void *)v47 + 88) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_387;
        }
        goto LABEL_390;
      }
    }
    else
    {
      *((_DWORD *)v47 + 166) = *((_DWORD *)v12 + 25);
      if (a3 >= 1) {
        goto LABEL_382;
      }
    }
LABEL_385:
    if (a3 < 0)
    {
      *((float *)v47 + 167) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((void *)v47 + 88) = *(void *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_387:
        *((float *)v47 + 178) = -*((float *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_392;
        }
        goto LABEL_395;
      }
    }
    else
    {
      *((_DWORD *)v47 + 167) = *((_DWORD *)v12 + 26);
      *((void *)v47 + 88) = *(void *)(v12 + 100);
      if (a2 >= 1) {
        goto LABEL_387;
      }
    }
LABEL_390:
    if (a2 < 0)
    {
      *((float *)v47 + 178) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_392:
        *((float *)v47 + 179) = -*((float *)v12 + 26);
        *((void *)v47 + 94) = *(void *)(v12 + 100);
        if (a2 >= 1) {
          goto LABEL_397;
        }
        goto LABEL_400;
      }
    }
    else
    {
      *((_DWORD *)v47 + 178) = *((_DWORD *)v12 + 25);
      if (a3 >= 1) {
        goto LABEL_392;
      }
    }
LABEL_395:
    if (a3 < 0)
    {
      *((float *)v47 + 179) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((void *)v47 + 94) = *(void *)(v12 + 100);
      if (a2 >= 1)
      {
LABEL_397:
        *((float *)v47 + 190) = -*((float *)v12 + 25);
        if (a3 >= 1) {
          goto LABEL_402;
        }
        goto LABEL_405;
      }
    }
    else
    {
      *((_DWORD *)v47 + 179) = *((_DWORD *)v12 + 26);
      *((void *)v47 + 94) = *(void *)(v12 + 100);
      if (a2 >= 1) {
        goto LABEL_397;
      }
    }
LABEL_400:
    if (a2 < 0)
    {
      *((float *)v47 + 190) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 25);
      if (a3 >= 1)
      {
LABEL_402:
        *((float *)v47 + 191) = -*((float *)v12 + 26);
        *((void *)v47 + 100) = *(void *)(v12 + 108);
        if (a2 >= 1) {
          goto LABEL_407;
        }
        goto LABEL_410;
      }
    }
    else
    {
      *((_DWORD *)v47 + 190) = *((_DWORD *)v12 + 25);
      if (a3 >= 1) {
        goto LABEL_402;
      }
    }
LABEL_405:
    if (a3 < 0)
    {
      *((float *)v47 + 191) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 26);
      *((void *)v47 + 100) = *(void *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_407:
        *((float *)v47 + 202) = -*((float *)v12 + 27);
        if (a3 >= 1) {
          goto LABEL_412;
        }
        goto LABEL_415;
      }
    }
    else
    {
      *((_DWORD *)v47 + 191) = *((_DWORD *)v12 + 26);
      *((void *)v47 + 100) = *(void *)(v12 + 108);
      if (a2 >= 1) {
        goto LABEL_407;
      }
    }
LABEL_410:
    if (a2 < 0)
    {
      *((float *)v47 + 202) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_412:
        *((float *)v47 + 203) = -*((float *)v12 + 28);
        *((void *)v47 + 106) = *(void *)(v12 + 108);
        if (a2 >= 1) {
          goto LABEL_417;
        }
        goto LABEL_420;
      }
    }
    else
    {
      *((_DWORD *)v47 + 202) = *((_DWORD *)v12 + 27);
      if (a3 >= 1) {
        goto LABEL_412;
      }
    }
LABEL_415:
    if (a3 < 0)
    {
      *((float *)v47 + 203) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((void *)v47 + 106) = *(void *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_417:
        *((float *)v47 + 214) = -*((float *)v12 + 27);
        if (a3 >= 1) {
          goto LABEL_422;
        }
        goto LABEL_425;
      }
    }
    else
    {
      *((_DWORD *)v47 + 203) = *((_DWORD *)v12 + 28);
      *((void *)v47 + 106) = *(void *)(v12 + 108);
      if (a2 >= 1) {
        goto LABEL_417;
      }
    }
LABEL_420:
    if (a2 < 0)
    {
      *((float *)v47 + 214) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_422:
        *((float *)v47 + 215) = -*((float *)v12 + 28);
        *((void *)v47 + 112) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_427;
        }
        goto LABEL_430;
      }
    }
    else
    {
      *((_DWORD *)v47 + 214) = *((_DWORD *)v12 + 27);
      if (a3 >= 1) {
        goto LABEL_422;
      }
    }
LABEL_425:
    if (a3 < 0)
    {
      *((float *)v47 + 215) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((void *)v47 + 112) = *(void *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_427:
        *((float *)v47 + 226) = -*((float *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_432;
        }
        goto LABEL_435;
      }
    }
    else
    {
      *((_DWORD *)v47 + 215) = *((_DWORD *)v12 + 28);
      *((void *)v47 + 112) = *(void *)(v12 + 84);
      if (a2 >= 1) {
        goto LABEL_427;
      }
    }
LABEL_430:
    if (a2 < 0)
    {
      *((float *)v47 + 226) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_432:
        *((float *)v47 + 227) = -*((float *)v12 + 22);
        *((void *)v47 + 118) = *(void *)(v12 + 108);
        if (a2 >= 1) {
          goto LABEL_437;
        }
        goto LABEL_440;
      }
    }
    else
    {
      *((_DWORD *)v47 + 226) = *((_DWORD *)v12 + 21);
      if (a3 >= 1) {
        goto LABEL_432;
      }
    }
LABEL_435:
    if (a3 < 0)
    {
      *((float *)v47 + 227) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      *((void *)v47 + 118) = *(void *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_437:
        *((float *)v47 + 238) = -*((float *)v12 + 27);
        if (a3 >= 1) {
          goto LABEL_442;
        }
        goto LABEL_445;
      }
    }
    else
    {
      *((_DWORD *)v47 + 227) = *((_DWORD *)v12 + 22);
      *((void *)v47 + 118) = *(void *)(v12 + 108);
      if (a2 >= 1) {
        goto LABEL_437;
      }
    }
LABEL_440:
    if (a2 < 0)
    {
      *((float *)v47 + 238) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_442:
        *((float *)v47 + 239) = -*((float *)v12 + 28);
        *((void *)v47 + 124) = *(void *)(v12 + 108);
        if (a2 >= 1) {
          goto LABEL_447;
        }
        goto LABEL_450;
      }
    }
    else
    {
      *((_DWORD *)v47 + 238) = *((_DWORD *)v12 + 27);
      if (a3 >= 1) {
        goto LABEL_442;
      }
    }
LABEL_445:
    if (a3 < 0)
    {
      *((float *)v47 + 239) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((void *)v47 + 124) = *(void *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_447:
        *((float *)v47 + 250) = -*((float *)v12 + 27);
        if (a3 >= 1) {
          goto LABEL_452;
        }
        goto LABEL_455;
      }
    }
    else
    {
      *((_DWORD *)v47 + 239) = *((_DWORD *)v12 + 28);
      *((void *)v47 + 124) = *(void *)(v12 + 108);
      if (a2 >= 1) {
        goto LABEL_447;
      }
    }
LABEL_450:
    if (a2 < 0)
    {
      *((float *)v47 + 250) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_452:
        *((float *)v47 + 251) = -*((float *)v12 + 28);
        *((void *)v47 + 130) = *(void *)(v12 + 108);
        if (a2 >= 1) {
          goto LABEL_457;
        }
        goto LABEL_460;
      }
    }
    else
    {
      *((_DWORD *)v47 + 250) = *((_DWORD *)v12 + 27);
      if (a3 >= 1) {
        goto LABEL_452;
      }
    }
LABEL_455:
    if (a3 < 0)
    {
      *((float *)v47 + 251) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((void *)v47 + 130) = *(void *)(v12 + 108);
      if (a2 >= 1)
      {
LABEL_457:
        *((float *)v47 + 262) = -*((float *)v12 + 27);
        if (a3 >= 1) {
          goto LABEL_462;
        }
        goto LABEL_465;
      }
    }
    else
    {
      *((_DWORD *)v47 + 251) = *((_DWORD *)v12 + 28);
      *((void *)v47 + 130) = *(void *)(v12 + 108);
      if (a2 >= 1) {
        goto LABEL_457;
      }
    }
LABEL_460:
    if (a2 < 0)
    {
      *((float *)v47 + 262) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 27);
      if (a3 >= 1)
      {
LABEL_462:
        *((float *)v47 + 263) = -*((float *)v12 + 28);
        *((void *)v47 + 136) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_467;
        }
        goto LABEL_470;
      }
    }
    else
    {
      *((_DWORD *)v47 + 262) = *((_DWORD *)v12 + 27);
      if (a3 >= 1) {
        goto LABEL_462;
      }
    }
LABEL_465:
    if (a3 < 0)
    {
      *((float *)v47 + 263) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 28);
      *((void *)v47 + 136) = *(void *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_467:
        *((float *)v47 + 274) = -*((float *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_472;
        }
        goto LABEL_475;
      }
    }
    else
    {
      *((_DWORD *)v47 + 263) = *((_DWORD *)v12 + 28);
      *((void *)v47 + 136) = *(void *)(v12 + 84);
      if (a2 >= 1) {
        goto LABEL_467;
      }
    }
LABEL_470:
    if (a2 < 0)
    {
      *((float *)v47 + 274) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_472:
        *((float *)v47 + 275) = -*((float *)v12 + 22);
        *((void *)v47 + 142) = *(void *)(v12 + 84);
        if (a2 >= 1) {
          goto LABEL_477;
        }
        goto LABEL_480;
      }
    }
    else
    {
      *((_DWORD *)v47 + 274) = *((_DWORD *)v12 + 21);
      if (a3 >= 1) {
        goto LABEL_472;
      }
    }
LABEL_475:
    if (a3 < 0)
    {
      *((float *)v47 + 275) = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
      *((void *)v47 + 142) = *(void *)(v12 + 84);
      if (a2 >= 1)
      {
LABEL_477:
        *((float *)v47 + 286) = -*((float *)v12 + 21);
        if (a3 >= 1) {
          goto LABEL_125;
        }
        goto LABEL_484;
      }
    }
    else
    {
      *((_DWORD *)v47 + 275) = *((_DWORD *)v12 + 22);
      *((void *)v47 + 142) = *(void *)(v12 + 84);
      if (a2 >= 1) {
        goto LABEL_477;
      }
    }
LABEL_480:
    if (a2 < 0)
    {
      *((float *)v47 + 286) = (float)(*(float *)v12 + *(float *)v12) - *((float *)v12 + 21);
      if (a3 >= 1)
      {
LABEL_125:
        float v48 = -*((float *)v12 + 22);
        goto LABEL_126;
      }
    }
    else
    {
      *((_DWORD *)v47 + 286) = *((_DWORD *)v12 + 21);
      if (a3 >= 1) {
        goto LABEL_125;
      }
    }
LABEL_484:
    if (a3 < 0) {
      float v48 = (float)(*((float *)v12 + 1) + *((float *)v12 + 1)) - *((float *)v12 + 22);
    }
    else {
      float v48 = *((float *)v12 + 22);
    }
LABEL_126:
    *((float *)v47 + 287) = v48;
    v43 += 72;
    v47 += 1152;
    v12 += 116;
    float v11 = (char *)v11 - 1;
  }
  while (v11);
}

float *emit(uint64_t a1, float *a2, float *a3, unint64_t a4, unsigned int a5, int a6, __n128 a7, __n128 a8, double a9, float32x4_t a10, float32x4_t a11, float32x4_t a12, uint64_t a13, uint64_t a14, double a15, double a16, float a17, __int32 a18, unsigned __int32 a19, unsigned __int32 a20)
{
  uint64_t v28 = a3;
  float v447 = a7.n128_f32[0];
  unsigned __int32 v448 = a12.u32[0];
  LODWORD(v25) = a11.i32[0];
  v20.i32[0] = LODWORD(a9);
  float v29 = a8.n128_f32[0];
  size_t v30 = a2;
  uint64_t v31 = a1;
  uint64_t v32 = a1 + 8 * (a6 != 0);
  if (a6)
  {
    BOOL v33 = *(unsigned char *)(a1 + 144) == 0;
    a8.n128_u32[0] = -1.0;
    float v34 = -2.0;
    float v35 = -1.0;
    goto LABEL_5;
  }
  if (*(_DWORD *)(a1 + 140))
  {
    BOOL v33 = *(unsigned char *)(a1 + 144) == 0;
    a8.n128_u64[0] = 0;
    float v34 = 1.0;
    float v35 = 0.0;
LABEL_5:
    float v452 = v35;
    if (v33) {
      float v36 = v34;
    }
    else {
      float v36 = a8.n128_f32[0];
    }
    uint64_t v37 = *(void *)(v32 + 96);
    float v38 = a3[15];
    if (v38 == 0.0) {
      goto LABEL_33;
    }
    goto LABEL_9;
  }
  float v34 = 1.0;
  float v36 = 0.0;
  float v452 = 0.0;
  uint64_t v37 = *(void *)(v32 + 96);
  float v38 = a3[15];
  if (v38 == 0.0) {
    goto LABEL_33;
  }
LABEL_9:
  float v39 = a3[16];
  if (v39 != 0.0)
  {
    float v41 = a3[13];
    float v40 = a3[14];
    if (v29 >= 0.0)
    {
      float v45 = fminf(fmaxf(v29 - v41, 0.0), v40);
    }
    else
    {
      float v42 = fminf(fmaxf((float)(v29 + 1.0) - v41, 0.0), v40) - v40;
      float v43 = v41 - (float)(v40 + -1.0);
      if (v43 <= v29) {
        float v44 = 0.0;
      }
      else {
        float v44 = v29 - v43;
      }
      if (v40 > 1.0) {
        float v45 = v44;
      }
      else {
        float v45 = v42;
      }
    }
    float v46 = 1.0 / (float)(v45 * v45);
    float v47 = v38 + v46;
    if ((float)(v38 + v46) > 0.0) {
      float v47 = 0.0;
    }
    float v48 = v38 - v46;
    if ((float)(v38 - v46) < 0.0) {
      float v48 = 0.0;
    }
    if (v38 >= 0.0) {
      float v49 = v48;
    }
    else {
      float v49 = v47;
    }
    a3[15] = v49;
    float v50 = v39 + v46;
    if ((float)(v39 + v46) > 0.0) {
      float v50 = 0.0;
    }
    float v51 = v39 - v46;
    if (v51 < 0.0) {
      float v51 = 0.0;
    }
    if (v39 >= 0.0) {
      float v52 = v51;
    }
    else {
      float v52 = v50;
    }
    a3[16] = v52;
  }
LABEL_33:
  v54.i32[0] = a18;
  a7.n128_u32[0] = a19;
  a8.n128_u32[0] = a20;
  float v445 = v36;
  float v446 = v29;
  if (a5 == 4)
  {
    uint64_t v95 = v37 + 48 * (0x5555555555555556 * (((uint64_t)a2 - v37) >> 4) + 12 * *(void *)(a1 + 64));
    float v96 = 1.0;
    v20.i32[1] = a10.i32[0];
    v54.i32[1] = a19;
    float v443 = v29 + 1.0;
    for (uint64_t i = a3 + 14; ; i += 29)
    {
      float v98 = *(i - 1);
      float v99 = fminf(fmaxf(v29 - v98, 0.0), *i);
      float v100 = fminf(fmaxf(v443 - v98, 0.0), *i) - *i;
      float v101 = v98 - (float)(*i + -1.0);
      if (v101 <= v29) {
        float v102 = 0.0;
      }
      else {
        float v102 = v29 - v101;
      }
      if (*i <= v96) {
        float v102 = v100;
      }
      if (v29 < 0.0) {
        a12.f32[0] = v102;
      }
      else {
        a12.f32[0] = v99;
      }
      float v103 = *(float *)(v31 + 168) + (float)(fabsf(a12.f32[0]) * (float)(*(float *)(v31 + 172) - *(float *)(v31 + 168)));
      float v104 = v103 * v447;
      a11.f32[0] = (float)(v103 * v447) * 0.5;
      if (a4 && a12.f32[0] == 0.0)
      {
        v105.i64[0] = *((void *)i - 7);
        v105.i64[1] = v105.i64[0];
        a10 = vmulq_n_f32(vsubq_f32(*(float32x4_t *)(i + 11), v105), v103);
        int8x16_t v22 = (int8x16_t)vaddq_f32(v105, a10);
        float32x4_t v106 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a11.f32, 0);
        int8x16_t v107 = (int8x16_t)vaddq_f32(v105, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(i + 7), v105), v103));
        float v108 = 1.0;
        float v109 = 0.0;
        float v110 = 0.0;
        float v111 = 0.0;
        float v112 = 1.0;
      }
      else
      {
        v24.f32[0] = *(i - 14);
        if (a4)
        {
          float v453 = v103;
          float32_t v449 = (float)(v103 * v447) * 0.5;
          unint64_t v438 = a12.i64[0];
          uint64_t v440 = v24.i64[0];
          __float2 v113 = __sincosf_stret((float)(a12.f32[0] * (float)(*(i - 3) * 6.2832)) * 0.5);
          a8.n128_f32[0] = v113.__cosval;
          a12.i32[1] = HIDWORD(v438);
          v24.i64[0] = v440;
          float v103 = v453;
          a10.f32[0] = *(i - 7);
          a17 = *(i - 6) * v113.__sinval;
          v114.f32[0] = *(i - 10);
          v22.i32[0] = *(__int32 *)(i - 13);
          *(float *)&long long v25 = *(float *)&v438 * (float)(a10.f32[0] * *(i - 8));
          v114.i32[1] = a10.i32[0];
          a10.f32[1] = *(i - 9);
          float32x2_t v54 = vmul_n_f32(*(float32x2_t *)(i - 5), v113.__sinval);
          a11.f32[0] = v449;
          float32x2_t v115 = vmul_f32(v114, *(float32x2_t *)a10.f32);
          a10.i32[1] = HIDWORD(v438);
          a9 = COERCE_DOUBLE(vmul_n_f32(vmul_n_f32(*(float32x2_t *)(i + 1), *(float *)&v438), *(float *)&v438));
          *(float32x2_t *)v20.f32 = vadd_f32(vadd_f32((float32x2_t)__PAIR64__(v22.u32[0], v440), vmul_n_f32(v115, *(float *)&v438)), *(float32x2_t *)&a9);
          float v116 = 1.0;
        }
        else
        {
          v22.i32[0] = *(__int32 *)(i - 13);
          float v116 = *(float *)&v448;
        }
        *(float32x2_t *)v117.f32 = v54;
        *(float32x2_t *)&v117.u32[2] = v54;
        v118.i64[0] = v20.i64[0];
        v118.i64[1] = v20.i64[0];
        a10.f32[0] = i[5];
        *(float *)&a9 = a11.f32[0] - a10.f32[0];
        a12.f32[0] = (float)(a11.f32[0] - a10.f32[0]) * v54.f32[0];
        v23.f32[0] = a17 * (float)(a11.f32[0] - a10.f32[0]);
        *(float *)&unsigned __int32 v448 = v116;
        float v112 = i[6] + (float)(v116 + (float)((float)(a8.n128_f32[0] * 0.0) + (float)(0.0 - i[6])));
        v119.f32[0] = i[13];
        v120.f32[0] = i[14];
        v119.f32[1] = i[11];
        v119.f32[2] = i[9];
        v119.f32[3] = i[7];
        v120.f32[1] = i[12];
        v120.f32[2] = i[10];
        v120.f32[3] = i[8];
        v121.i32[0] = vdupq_lane_s32((int32x2_t)v54, 1).u32[0];
        float32x4_t v122 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 0);
        float32x4_t v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
        float32x4_t v123 = vsubq_f32(v120, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.i8, 0));
        v120.i64[0] = *(void *)(i + 3);
        v120.i64[1] = v120.i64[0];
        float32x4_t v124 = vsubq_f32(vmulq_n_f32(vsubq_f32(v119, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0)), v103), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v120.f32, 0));
        float32x4_t v125 = vsubq_f32(vmulq_n_f32(v123, v103), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v120.f32, 1));
        float32x4_t v126 = vsubq_f32(vmulq_n_f32(v125, a17), vmulq_n_f32(v124, v54.f32[0]));
        float32x4_t v24 = vaddq_f32(v126, v126);
        float32x4_t v127 = vsubq_f32(vmulq_lane_f32(v124, v54, 1), v122);
        float32x4_t v128 = vaddq_f32(v127, v127);
        float32x4_t v129 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a12.f32, 0), vmulq_lane_f32(v125, v54, 1));
        float32x4_t v130 = vaddq_f32(v129, v129);
        int8x16_t v131 = (int8x16_t)vzip1q_s32((int32x4_t)v24, (int32x4_t)v130);
        int8x16_t v132 = (int8x16_t)vzip2q_s32((int32x4_t)v24, (int32x4_t)v130);
        float32x4_t v133 = vmulq_f32(v117, (float32x4_t)vextq_s8(v132, v132, 8uLL));
        float32x4_t v134 = vmulq_f32(v117, (float32x4_t)vextq_s8(v131, v131, 8uLL));
        v121.f32[1] = a17;
        v121.i64[1] = v121.i64[0];
        int8x16_t v135 = (int8x16_t)vzip1q_s32((int32x4_t)v128, (int32x4_t)v24);
        int8x16_t v136 = (int8x16_t)vzip2q_s32((int32x4_t)v128, (int32x4_t)v24);
        float32x4_t v137 = vsubq_f32(v134, vmulq_f32(v121, (float32x4_t)vextq_s8(v135, v135, 8uLL)));
        int8x16_t v138 = (int8x16_t)vzip1q_s32((int32x4_t)v124, (int32x4_t)v125);
        int8x16_t v139 = (int8x16_t)vzip2q_s32((int32x4_t)v124, (int32x4_t)v125);
        float32x4_t v140 = vaddq_f32((float32x4_t)vextq_s8(v139, v139, 8uLL), vsubq_f32(v133, vmulq_f32(v121, (float32x4_t)vextq_s8(v136, v136, 8uLL))));
        float32x4_t v141 = vaddq_f32((float32x4_t)vextq_s8(v138, v138, 8uLL), v137);
        int8x16_t v142 = (int8x16_t)vzip1q_s32((int32x4_t)v130, (int32x4_t)v128);
        int8x16_t v143 = (int8x16_t)vzip2q_s32((int32x4_t)v130, (int32x4_t)v128);
        a12 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v25, 0), vaddq_f32(vmulq_n_f32(v24, a8.n128_f32[0]), vaddq_f32(v23, vsubq_f32(vmulq_n_f32(v128, a17), vmulq_n_f32(v130, v54.f32[0])))));
        int8x16_t v22 = (int8x16_t)vaddq_f32(v120, vaddq_f32(v118, vaddq_f32(vmulq_n_f32((float32x4_t)vextq_s8(v142, v142, 8uLL), a8.n128_f32[0]), v141)));
        a11 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a10.f32, 0);
        int8x16_t v107 = (int8x16_t)vaddq_f32(v120, vaddq_f32(v118, vaddq_f32(vmulq_n_f32((float32x4_t)vextq_s8(v143, v143, 8uLL), a8.n128_f32[0]), v140)));
        float32x4_t v106 = vaddq_f32(a11, a12);
        v140.f32[0] = vmuls_lane_f32(0.0, v54, 1);
        a11.f32[0] = (float)(v54.f32[0] - v140.f32[0]) + (float)(v54.f32[0] - v140.f32[0]);
        v140.f32[0] = (float)(v140.f32[0] - a17) + (float)(v140.f32[0] - a17);
        a12.f32[0] = (float)((float)(a17 * 0.0) - (float)(0.0 * v54.f32[0]))
                   + (float)((float)(a17 * 0.0) - (float)(0.0 * v54.f32[0]));
        float v109 = (float)(a8.n128_f32[0] * a11.f32[0])
             + (float)((float)((float)(a12.f32[0] * v54.f32[0]) - vmuls_lane_f32(v140.f32[0], v54, 1)) + 0.0);
        float v110 = (float)(a8.n128_f32[0] * v140.f32[0])
             + (float)((float)(vmuls_lane_f32(a11.f32[0], v54, 1) - (float)(a17 * a12.f32[0])) + 0.0);
        float v108 = (float)(a8.n128_f32[0] * a12.f32[0])
             + (float)((float)((float)(a17 * v140.f32[0]) - (float)(a11.f32[0] * v54.f32[0])) + v96);
        float v111 = (float)(a8.n128_f32[0] * 0.0) + 0.0;
      }
      *(void *)size_t v30 = v107.i64[0];
      v30[2] = v106.f32[3];
      v30[3] = v112;
      v30[4] = v109;
      v30[5] = v110;
      v30[6] = v108;
      v30[7] = v452;
      *((void *)v30 + 6) = vextq_s8(v107, v107, 8uLL).u64[0];
      v30[14] = v106.f32[2];
      v30[15] = v112;
      v30[16] = v109;
      v30[17] = v110;
      v30[18] = v108;
      v30[19] = v452;
      *((void *)v30 + 12) = v22.i64[0];
      v30[26] = v106.f32[1];
      v30[27] = v112;
      v30[28] = v109;
      v30[29] = v110;
      v30[30] = v108;
      v30[31] = v452;
      *((void *)v30 + 18) = v22.i64[0];
      v30[38] = v106.f32[1];
      v30[39] = v112;
      v30[40] = v109;
      v30[41] = v110;
      v30[42] = v108;
      v30[43] = v452;
      *(void *)&a9 = vextq_s8(v22, v22, 8uLL).u64[0];
      *((double *)v30 + 24) = a9;
      v30[50] = v106.f32[0];
      v30[51] = v112;
      v30[52] = v109;
      v30[53] = v110;
      v30[54] = v108;
      v30[55] = v452;
      *((void *)v30 + 30) = v107.i64[0];
      v30[62] = v106.f32[3];
      v30[63] = v112;
      v30[64] = v109;
      uint64_t v144 = (float32x4_t *)(v30 + 72);
      v30[65] = v110;
      v30[66] = v108;
      v30[67] = v452;
      if (v104 <= 0.0)
      {
        v30 += 72;
        if (a4 < 2) {
          return v30;
        }
      }
      else
      {
        float v145 = v104 * v109;
        float v146 = v104 * v110;
        float v147 = v104 * v108;
        float v148 = v104 * v111;
        long long v454 = v25;
        float v149 = *(float *)v107.i32 - (float)(v104 * v109);
        float v150 = *(float *)&v107.i32[1] - (float)(v104 * v110);
        float v151 = v106.f32[3] - (float)(v104 * v108);
        float v152 = v112 - v148;
        v30[72] = v149;
        v30[73] = v150;
        v30[74] = v151;
        v30[75] = v152;
        v30[76] = v109;
        v30[77] = v110;
        v30[78] = v108;
        v30[79] = v36;
        a10.i32[1] = v20.i32[1];
        v30[84] = *(float *)v22.i32 - v145;
        v30[85] = *(float *)&v22.i32[1] - v146;
        v30[86] = v106.f32[1] - v147;
        v30[87] = v152;
        v30[88] = v109;
        v30[89] = v110;
        v30[90] = v108;
        v30[91] = v445;
        v30[96] = *(float *)&v107.i32[2] - v145;
        v30[97] = *(float *)&v107.i32[3] - v146;
        float v96 = 1.0;
        v30[98] = v106.f32[2] - v147;
        float v36 = v445;
        v30[99] = v152;
        v30[100] = v109;
        v30[101] = v110;
        v30[102] = v108;
        v30[103] = v445;
        *((_OWORD *)v30 + 27) = *((_OWORD *)v30 + 21);
        v30[112] = v109;
        v30[113] = v110;
        v30[114] = v108;
        v30[115] = v445;
        *((float32x4_t *)v30 + 30) = *v144;
        v30[124] = v109;
        v30[125] = v110;
        v30[126] = v108;
        v30[127] = v445;
        v30[132] = *(float *)&v22.i32[2] - v145;
        v30[133] = *(float *)&v22.i32[3] - v146;
        v30[134] = v106.f32[0] - v147;
        v30[135] = v152;
        v30[136] = v109;
        v30[137] = v110;
        v30[138] = v108;
        v30[139] = v445;
        float v153 = v150 - *(float *)&v107.i32[3];
        float v29 = v446;
        float v154 = (float)((float)(*(float *)&v107.i32[1] - *(float *)&v107.i32[3]) * (float)(v151 - v106.f32[2]))
             - (float)((float)(v106.f32[3] - v106.f32[2]) * v153);
        float v155 = (float)((float)(v149 - *(float *)&v107.i32[2]) * (float)(v106.f32[3] - v106.f32[2]))
             - (float)((float)(*(float *)v107.i32 - *(float *)&v107.i32[2]) * (float)(v151 - v106.f32[2]));
        float v156 = (float)((float)(*(float *)v107.i32 - *(float *)&v107.i32[2]) * v153)
             - (float)((float)(*(float *)&v107.i32[1] - *(float *)&v107.i32[3]) * (float)(v149 - *(float *)&v107.i32[2]));
        float v157 = sqrtf((float)(v156 * v156) + (float)((float)(v154 * v154) + (float)(v155 * v155)));
        float v158 = v155 / v157;
        float v159 = v156 / v157;
        *(void *)uint64_t v95 = v107.i64[1];
        *(_DWORD *)(v95 + 8) = v106.i32[2];
        *(float *)(v95 + 12) = v112;
        *(float *)(v95 + 16) = v154 / v157;
        *(float *)(v95 + 20) = v158;
        *(float *)(v95 + 24) = v159;
        *(float *)(v95 + 28) = v34;
        *(void *)(v95 + 48) = v107.i64[0];
        *(_DWORD *)(v95 + 56) = v106.i32[3];
        *(float *)(v95 + 60) = v112;
        *(float *)(v95 + 64) = v154 / v157;
        *(float *)(v95 + 68) = v158;
        *(float *)(v95 + 72) = v159;
        *(float *)(v95 + 76) = v34;
        *(float32x4_t *)(v95 + 96) = *v144;
        *(float *)(v95 + 112) = v154 / v157;
        *(float *)(v95 + 116) = v158;
        *(float *)(v95 + 120) = v159;
        *(float *)(v95 + 124) = v34;
        *(float32x4_t *)(v95 + 144) = *v144;
        *(float *)(v95 + 160) = v154 / v157;
        *(float *)(v95 + 164) = v158;
        *(float *)(v95 + 168) = v159;
        *(float *)(v95 + 172) = v34;
        *(_OWORD *)(v95 + 192) = *((_OWORD *)v30 + 24);
        *(float *)(v95 + 208) = v154 / v157;
        *(float *)(v95 + 212) = v158;
        *(float *)(v95 + 216) = v159;
        *(float *)(v95 + 220) = v34;
        *(void *)(v95 + 240) = v107.i64[1];
        *(_DWORD *)(v95 + 248) = v106.i32[2];
        *(float *)(v95 + 252) = v112;
        *(float *)(v95 + 256) = v154 / v157;
        *(float *)(v95 + 260) = v158;
        *(float *)(v95 + 264) = v159;
        *(float *)(v95 + 268) = v34;
        float v160 = v30[96] - *(float *)v22.i32;
        float v161 = v30[97] - *(float *)&v22.i32[1];
        float v162 = v30[98] - v106.f32[1];
        float v163 = (float)((float)(*(float *)&v107.i32[3] - *(float *)&v22.i32[1]) * v162)
             - (float)((float)(v106.f32[2] - v106.f32[1]) * v161);
        long long v25 = v454;
        float v164 = (float)((float)(v106.f32[2] - v106.f32[1]) * v160)
             - (float)((float)(*(float *)&v107.i32[2] - *(float *)v22.i32) * v162);
        float v165 = (float)((float)(*(float *)&v107.i32[2] - *(float *)v22.i32) * v161)
             - (float)((float)(*(float *)&v107.i32[3] - *(float *)&v22.i32[1]) * v160);
        float v166 = sqrtf((float)(v165 * v165) + (float)((float)(v163 * v163) + (float)(v164 * v164)));
        float v167 = v164 / v166;
        float v168 = v165 / v166;
        *(void *)(v95 + 288) = v22.i64[0];
        *(_DWORD *)(v95 + 296) = v106.i32[1];
        *(float *)(v95 + 300) = v112;
        *(float *)(v95 + 304) = v163 / v166;
        *(float *)(v95 + 308) = v167;
        *(float *)(v95 + 312) = v168;
        *(float *)(v95 + 316) = v34;
        *(void *)(v95 + 336) = v107.i64[1];
        *(_DWORD *)(v95 + 344) = v106.i32[2];
        *(float *)(v95 + 348) = v112;
        *(float *)(v95 + 352) = v163 / v166;
        *(float *)(v95 + 356) = v167;
        *(float *)(v95 + 360) = v168;
        *(float *)(v95 + 364) = v34;
        *(_OWORD *)(v95 + 384) = *((_OWORD *)v30 + 24);
        *(float *)(v95 + 400) = v163 / v166;
        *(float *)(v95 + 404) = v167;
        *(float *)(v95 + 408) = v168;
        *(float *)(v95 + 412) = v34;
        *(_OWORD *)(v95 + 432) = *((_OWORD *)v30 + 24);
        *(float *)(v95 + 448) = v163 / v166;
        *(float *)(v95 + 452) = v167;
        *(float *)(v95 + 456) = v168;
        *(float *)(v95 + 460) = v34;
        *(_OWORD *)(v95 + 480) = *((_OWORD *)v30 + 21);
        *(float *)(v95 + 496) = v163 / v166;
        *(float *)(v95 + 500) = v167;
        *(float *)(v95 + 504) = v168;
        *(float *)(v95 + 508) = v34;
        *(void *)(v95 + 528) = v22.i64[0];
        *(_DWORD *)(v95 + 536) = v106.i32[1];
        *(float *)(v95 + 540) = v112;
        *(float *)(v95 + 544) = v163 / v166;
        *(float *)(v95 + 548) = v167;
        *(float *)(v95 + 552) = v168;
        *(float *)(v95 + 556) = v34;
        float v169 = v30[84] - *(float *)&v22.i32[2];
        float v170 = v30[85] - *(float *)&v22.i32[3];
        float v171 = v30[86] - v106.f32[0];
        float v172 = (float)((float)(*(float *)&v22.i32[1] - *(float *)&v22.i32[3]) * v171)
             - (float)((float)(v106.f32[1] - v106.f32[0]) * v170);
        float v173 = (float)((float)(v106.f32[1] - v106.f32[0]) * v169)
             - (float)((float)(*(float *)v22.i32 - *(float *)&v22.i32[2]) * v171);
        float v174 = (float)((float)(*(float *)v22.i32 - *(float *)&v22.i32[2]) * v170)
             - (float)((float)(*(float *)&v22.i32[1] - *(float *)&v22.i32[3]) * v169);
        float v175 = sqrtf((float)(v174 * v174) + (float)((float)(v172 * v172) + (float)(v173 * v173)));
        float v176 = v173 / v175;
        float v177 = v174 / v175;
        *(_DWORD *)(v95 + 576) = v22.i32[2];
        *(_DWORD *)(v95 + 580) = v22.i32[3];
        *(_DWORD *)(v95 + 584) = v106.i32[0];
        *(float *)(v95 + 588) = v112;
        *(float *)(v95 + 592) = v172 / v175;
        *(float *)(v95 + 596) = v176;
        *(float *)(v95 + 600) = v177;
        *(float *)(v95 + 604) = v34;
        *(void *)(v95 + 624) = v22.i64[0];
        *(_DWORD *)(v95 + 632) = v106.i32[1];
        *(float *)(v95 + 636) = v112;
        *(float *)(v95 + 640) = v172 / v175;
        *(float *)(v95 + 644) = v176;
        *(float *)(v95 + 648) = v177;
        *(float *)(v95 + 652) = v34;
        *(_OWORD *)(v95 + 672) = *((_OWORD *)v30 + 21);
        *(float *)(v95 + 688) = v172 / v175;
        *(float *)(v95 + 692) = v176;
        *(float *)(v95 + 696) = v177;
        *(float *)(v95 + 700) = v34;
        *(_OWORD *)(v95 + 720) = *((_OWORD *)v30 + 21);
        *(float *)(v95 + 736) = v172 / v175;
        *(float *)(v95 + 740) = v176;
        *(float *)(v95 + 744) = v177;
        *(float *)(v95 + 748) = v34;
        *(_OWORD *)(v95 + 768) = *((_OWORD *)v30 + 33);
        *(float *)(v95 + 784) = v172 / v175;
        *(float *)(v95 + 788) = v176;
        *(float *)(v95 + 792) = v177;
        *(float *)(v95 + 796) = v34;
        *(_DWORD *)(v95 + 816) = v22.i32[2];
        *(_DWORD *)(v95 + 820) = v22.i32[3];
        *(_DWORD *)(v95 + 824) = v106.i32[0];
        *(float *)(v95 + 828) = v112;
        *(float *)(v95 + 832) = v172 / v175;
        *(float *)(v95 + 836) = v176;
        *(float *)(v95 + 840) = v177;
        *(float *)(v95 + 844) = v34;
        *(float *)v22.i32 = v30[132] - *(float *)v107.i32;
        float v178 = v30[133] - *(float *)&v107.i32[1];
        float v179 = v30[134] - v106.f32[3];
        float v180 = (float)((float)(*(float *)&v22.i32[3] - *(float *)&v107.i32[1]) * v179)
             - (float)((float)(v106.f32[0] - v106.f32[3]) * v178);
        float v181 = (float)((float)(v106.f32[0] - v106.f32[3]) * *(float *)v22.i32)
             - (float)((float)(*(float *)&v22.i32[2] - *(float *)v107.i32) * v179);
        float v182 = (float)((float)(*(float *)&v22.i32[2] - *(float *)v107.i32) * v178)
             - (float)((float)(*(float *)&v22.i32[3] - *(float *)&v107.i32[1]) * *(float *)v22.i32);
        float v183 = sqrtf((float)(v182 * v182) + (float)((float)(v180 * v180) + (float)(v181 * v181)));
        *(float *)v22.i32 = v180 / v183;
        float v184 = v181 / v183;
        *(void *)(v95 + 864) = v107.i64[0];
        *(_DWORD *)(v95 + 872) = v106.i32[3];
        *(float *)(v95 + 876) = v112;
        *(float *)(v95 + 880) = v180 / v183;
        *(float *)(v95 + 884) = v184;
        float v185 = v182 / v183;
        *(float *)(v95 + 888) = v185;
        *(float *)(v95 + 892) = v34;
        *(_DWORD *)(v95 + 912) = v22.i32[2];
        *(_DWORD *)(v95 + 916) = v22.i32[3];
        *(_DWORD *)(v95 + 920) = v106.i32[0];
        *(float *)(v95 + 924) = v112;
        *(float *)(v95 + 928) = v180 / v183;
        *(float *)(v95 + 932) = v184;
        *(float *)(v95 + 936) = v185;
        *(float *)(v95 + 940) = v34;
        *(_OWORD *)(v95 + 960) = *((_OWORD *)v30 + 33);
        *(float *)(v95 + 976) = v180 / v183;
        *(float *)(v95 + 980) = v184;
        *(float *)(v95 + 984) = v185;
        *(float *)(v95 + 988) = v34;
        *(_OWORD *)(v95 + 1008) = *((_OWORD *)v30 + 33);
        *(float *)(v95 + 1024) = v180 / v183;
        *(float *)(v95 + 1028) = v184;
        *(float *)(v95 + 1032) = v185;
        *(float *)(v95 + 1036) = v34;
        a11 = *v144;
        *(float32x4_t *)(v95 + 1056) = *v144;
        *(_DWORD *)(v95 + 1072) = v22.i32[0];
        *(float *)(v95 + 1076) = v184;
        *(float *)(v95 + 1080) = v185;
        *(float *)(v95 + 1084) = v34;
        *(void *)(v95 + 1104) = v107.i64[0];
        *(_DWORD *)(v95 + 1112) = v106.i32[3];
        *(float *)(v95 + 1116) = v112;
        *(_DWORD *)(v95 + 1120) = v22.i32[0];
        *(float *)(v95 + 1124) = v184;
        *(float *)(v95 + 1128) = v185;
        *(float *)(v95 + 1132) = v34;
        v30 += 144;
        v95 += 1152;
        if (a4 < 2) {
          return v30;
        }
      }
      --a4;
    }
  }
  if (a5 == 3)
  {
    float32x4_t v441 = v20;
    uint64_t v186 = v37 + 48 * (6 * *(void *)(a1 + 64) + (((uint64_t)a2 - v37) >> 4));
    float v444 = v29 + 1.0;
    uint64_t v187 = a3 + 26;
    float v188 = -1.0;
    while (1)
    {
      float v189 = *(v187 - 13);
      float v190 = *(v187 - 12);
      float v191 = fminf(fmaxf(v29 - v189, 0.0), v190);
      float v192 = fminf(fmaxf(v444 - v189, 0.0), v190) - v190;
      float v193 = v189 - (float)(v190 + v188);
      if (v193 <= v29) {
        float v194 = 0.0;
      }
      else {
        float v194 = v29 - v193;
      }
      if (v190 <= 1.0) {
        float v194 = v192;
      }
      if (v29 < 0.0) {
        float v195 = v194;
      }
      else {
        float v195 = v191;
      }
      float v196 = *(float *)(v31 + 168) + (float)(fabsf(v195) * (float)(*(float *)(v31 + 172) - *(float *)(v31 + 168)));
      float v197 = v196 * v447;
      float v198 = (float)(v196 * v447) * 0.5;
      if (a4 && v195 == 0.0)
      {
        float v199 = *(v187 - 26);
        float v200 = *(v187 - 25);
        float v201 = v199 + (float)(v196 * (float)(*(v187 - 5) - v199));
        float v202 = v200 + (float)(v196 * (float)(*(v187 - 4) - v200));
        float v203 = v199 + (float)(v196 * (float)(*(v187 - 3) - v199));
        float v204 = v200 + (float)(v196 * (float)(*(v187 - 2) - v200));
        float v205 = v199 + (float)(v196 * (float)(*(v187 - 1) - v199));
        float v206 = v200 + (float)(v196 * (float)(*v187 - v200));
        float v207 = 1.0;
        float v208 = 0.0;
        float v209 = 0.0;
        float v210 = 0.0;
        float v211 = 1.0;
        float v212 = (float)(v196 * v447) * 0.5;
        float v213 = v212;
      }
      else
      {
        float v214 = *(v187 - 26);
        if (a4)
        {
          __float2 v215 = __sincosf_stret((float)(v195 * (float)(*(v187 - 15) * 6.2832)) * 0.5);
          a8.n128_f32[0] = v215.__cosval;
          a17 = *(v187 - 18) * v215.__sinval;
          v54.f32[0] = *(v187 - 17) * v215.__sinval;
          a7.n128_f32[0] = *(v187 - 16) * v215.__sinval;
          float v216 = *(v187 - 19);
          v19.f32[0] = (float)(v214 + (float)(v195 * (float)(*(v187 - 22) * v216)))
                     + (float)(v195 * (float)(v195 * *(v187 - 11)));
          float v217 = *(v187 - 25);
          *(float *)&long long v218 = v195 * (float)(v216 * *(v187 - 20));
          long long v455 = v218;
          a10.f32[0] = (float)(v217 + (float)(v195 * (float)(v216 * *(v187 - 21))))
                     + (float)(v195 * (float)(v195 * *(v187 - 10)));
          float v219 = 1.0;
        }
        else
        {
          float v217 = *(v187 - 25);
          long long v455 = v25;
          float32x4_t v19 = v441;
          float v219 = *(float *)&v448;
        }
        float v220 = *(v187 - 9);
        float v221 = *(v187 - 8);
        float v222 = (float)(v196 * (float)(*(v187 - 5) - v214)) - v220;
        float v223 = (float)(v196 * (float)(*(v187 - 4) - v217)) - v221;
        float v224 = *(v187 - 7);
        float v225 = v198 - v224;
        float v226 = v54.f32[0] * (float)(v198 - v224);
        float v227 = a17 * (float)(v198 - v224);
        float v228 = (float)(v226 - (float)(a7.n128_f32[0] * v223)) + (float)(v226 - (float)(a7.n128_f32[0] * v223));
        float v229 = (float)((float)(a7.n128_f32[0] * v222) - v227) + (float)((float)(a7.n128_f32[0] * v222) - v227);
        float v230 = (float)((float)(a17 * v223) - (float)(v54.f32[0] * v222))
             + (float)((float)(a17 * v223) - (float)(v54.f32[0] * v222));
        float v231 = (float)(v198 - v224) + (float)((float)(a17 * v229) - (float)(v54.f32[0] * v228));
        float v232 = (float)(a8.n128_f32[0] * v228)
             + (float)(v222 + (float)((float)(v54.f32[0] * v230) - (float)(a7.n128_f32[0] * v229)));
        float v233 = (float)(a8.n128_f32[0] * v229)
             + (float)(v223 + (float)((float)(a7.n128_f32[0] * v228) - (float)(a17 * v230)));
        float v234 = (float)(a8.n128_f32[0] * v230) + v231;
        *(float *)&unsigned __int32 v448 = v219;
        float v211 = *(v187 - 6) + (float)(v219 + (float)((float)(a8.n128_f32[0] * 0.0) + (float)(0.0 - *(v187 - 6))));
        float v235 = (float)(v196 * (float)(*(v187 - 3) - v214)) - v220;
        float v236 = (float)(v196 * (float)(*(v187 - 2) - v217)) - v221;
        float v237 = (float)(v226 - (float)(a7.n128_f32[0] * v236)) + (float)(v226 - (float)(a7.n128_f32[0] * v236));
        float v238 = (float)((float)(a7.n128_f32[0] * v235) - v227) + (float)((float)(a7.n128_f32[0] * v235) - v227);
        float v239 = (float)((float)(a17 * v236) - (float)(v54.f32[0] * v235))
             + (float)((float)(a17 * v236) - (float)(v54.f32[0] * v235));
        float v240 = (float)(a8.n128_f32[0] * v237)
             + (float)(v235 + (float)((float)(v54.f32[0] * v239) - (float)(a7.n128_f32[0] * v238)));
        float v241 = (float)(a8.n128_f32[0] * v238)
             + (float)(v236 + (float)((float)(a7.n128_f32[0] * v237) - (float)(a17 * v239)));
        float v242 = (float)(a8.n128_f32[0] * v239)
             + (float)((float)(v198 - v224) + (float)((float)(a17 * v238) - (float)(v54.f32[0] * v237)));
        float v243 = (float)(v196 * (float)(*(v187 - 1) - v214)) - v220;
        float v244 = (float)(v196 * (float)(*v187 - v217)) - v221;
        float v245 = (float)(v226 - (float)(a7.n128_f32[0] * v244)) + (float)(v226 - (float)(a7.n128_f32[0] * v244));
        float v246 = (float)((float)(a7.n128_f32[0] * v243) - v227) + (float)((float)(a7.n128_f32[0] * v243) - v227);
        float v247 = (float)((float)(a17 * v244) - (float)(v54.f32[0] * v243))
             + (float)((float)(a17 * v244) - (float)(v54.f32[0] * v243));
        float v248 = v244 + (float)((float)(a7.n128_f32[0] * v245) - (float)(a17 * v247));
        float v201 = v220 + (float)(v19.f32[0] + v232);
        float v202 = v221 + (float)(a10.f32[0] + v233);
        float v213 = v224 + (float)(*(float *)&v455 + v234);
        float v203 = v220 + (float)(v19.f32[0] + v240);
        float v204 = v221 + (float)(a10.f32[0] + v241);
        float v212 = v224 + (float)(*(float *)&v455 + v242);
        float32x4_t v441 = v19;
        float v205 = v220
             + (float)(v19.f32[0]
                     + (float)((float)(a8.n128_f32[0] * v245)
                             + (float)(v243 + (float)((float)(v54.f32[0] * v247) - (float)(a7.n128_f32[0] * v246)))));
        float v206 = v221 + (float)(a10.f32[0] + (float)((float)(a8.n128_f32[0] * v246) + v248));
        float v198 = v224
             + (float)(*(float *)&v455
                     + (float)((float)(a8.n128_f32[0] * v247)
                             + (float)(v225 + (float)((float)(a17 * v246) - (float)(v54.f32[0] * v245)))));
        float v249 = (float)(v54.f32[0] - (float)(a7.n128_f32[0] * 0.0)) + (float)(v54.f32[0] - (float)(a7.n128_f32[0] * 0.0));
        float v250 = (float)((float)(a7.n128_f32[0] * 0.0) - a17) + (float)((float)(a7.n128_f32[0] * 0.0) - a17);
        float v251 = (float)((float)(a17 * 0.0) - (float)(v54.f32[0] * 0.0))
             + (float)((float)(a17 * 0.0) - (float)(v54.f32[0] * 0.0));
        float v208 = (float)(a8.n128_f32[0] * v249)
             + (float)((float)((float)(v54.f32[0] * v251) - (float)(a7.n128_f32[0] * v250)) + 0.0);
        float v209 = (float)(a8.n128_f32[0] * v250)
             + (float)((float)((float)(a7.n128_f32[0] * v249) - (float)(a17 * v251)) + 0.0);
        float v207 = (float)(a8.n128_f32[0] * v251) + (float)((float)((float)(a17 * v250) - (float)(v54.f32[0] * v249)) + 1.0);
        float v210 = (float)(a8.n128_f32[0] * 0.0) + 0.0;
        long long v25 = v455;
        float v36 = v445;
        float v188 = -1.0;
      }
      *size_t v30 = v201;
      v30[1] = v202;
      v30[2] = v213;
      v30[3] = v211;
      v30[4] = v208;
      v30[5] = v209;
      v30[6] = v207;
      v30[7] = v452;
      v30[12] = v203;
      v30[13] = v204;
      v30[14] = v212;
      v30[15] = v211;
      v30[16] = v208;
      v30[17] = v209;
      v30[18] = v207;
      v30[19] = v452;
      v30[24] = v205;
      v30[25] = v206;
      v30[26] = v198;
      v30[27] = v211;
      v30[28] = v208;
      v30[29] = v209;
      v252 = v30 + 36;
      v30[30] = v207;
      v30[31] = v452;
      if (v197 <= 0.0)
      {
        v30 += 36;
        float v29 = v446;
        if (a4 < 2) {
          return v30;
        }
      }
      else
      {
        float v253 = v201 - (float)(v197 * v208);
        float v254 = v202 - (float)(v197 * v209);
        float32x4_t v19 = (float32x4_t)v25;
        float v255 = v213 - (float)(v197 * v207);
        float v256 = v211 - (float)(v197 * v210);
        v30[36] = v253;
        v30[37] = v254;
        v30[38] = v255;
        v30[39] = v256;
        v30[40] = v208;
        v30[41] = v209;
        v30[42] = v207;
        v30[43] = v36;
        v30[48] = v205 - (float)(v197 * v208);
        v30[49] = v206 - (float)(v197 * v209);
        v30[50] = v198 - (float)(v197 * v207);
        v30[51] = v256;
        v30[52] = v208;
        v30[53] = v209;
        v30[54] = v207;
        v30[55] = v36;
        v30[60] = v203 - (float)(v197 * v208);
        v30[61] = v204 - (float)(v197 * v209);
        v30[62] = v212 - (float)(v197 * v207);
        v30[63] = v256;
        v30[64] = v208;
        v30[65] = v209;
        v30[66] = v207;
        v30[67] = v36;
        float v257 = v255 - v212;
        long long v25 = (__int128)v19;
        float v258 = (float)((float)(v202 - v204) * v257) - (float)((float)(v213 - v212) * (float)(v254 - v204));
        float v259 = (float)((float)(v253 - v203) * (float)(v213 - v212)) - (float)((float)(v201 - v203) * v257);
        float v260 = (float)((float)(v201 - v203) * (float)(v254 - v204))
             - (float)((float)(v202 - v204) * (float)(v253 - v203));
        float v261 = sqrtf((float)(v260 * v260) + (float)((float)(v258 * v258) + (float)(v259 * v259)));
        float v262 = v259 / v261;
        float v263 = v260 / v261;
        *(float *)uint64_t v186 = v203;
        *(float *)(v186 + 4) = v204;
        *(float *)(v186 + 8) = v212;
        *(float *)(v186 + 12) = v211;
        *(float *)(v186 + 16) = v258 / v261;
        *(float *)(v186 + 20) = v262;
        *(float *)(v186 + 24) = v263;
        *(float *)(v186 + 28) = v34;
        *(float *)(v186 + 48) = v201;
        *(float *)(v186 + 52) = v202;
        *(float *)(v186 + 56) = v213;
        *(float *)(v186 + 60) = v211;
        *(float *)(v186 + 64) = v258 / v261;
        *(float *)(v186 + 68) = v262;
        *(float *)(v186 + 72) = v263;
        *(float *)(v186 + 76) = v34;
        *(_OWORD *)(v186 + 96) = *v252;
        *(float *)(v186 + 112) = v258 / v261;
        *(float *)(v186 + 116) = v262;
        *(float *)(v186 + 120) = v263;
        *(float *)(v186 + 124) = v34;
        *(_OWORD *)(v186 + 144) = *v252;
        *(float *)(v186 + 160) = v258 / v261;
        *(float *)(v186 + 164) = v262;
        *(float *)(v186 + 168) = v263;
        *(float *)(v186 + 172) = v34;
        *(_OWORD *)(v186 + 192) = *((_OWORD *)v30 + 15);
        *(float *)(v186 + 208) = v258 / v261;
        *(float *)(v186 + 212) = v262;
        *(float *)(v186 + 216) = v263;
        *(float *)(v186 + 220) = v34;
        *(float *)(v186 + 240) = v203;
        *(float *)(v186 + 244) = v204;
        *(float *)(v186 + 248) = v212;
        *(float *)(v186 + 252) = v211;
        *(float *)(v186 + 256) = v258 / v261;
        *(float *)(v186 + 260) = v262;
        *(float *)(v186 + 264) = v263;
        *(float *)(v186 + 268) = v34;
        float v264 = v30[60] - v205;
        float v265 = v30[61] - v206;
        float v266 = v30[62] - v198;
        float v267 = (float)((float)(v204 - v206) * v266) - (float)((float)(v212 - v198) * v265);
        float v268 = (float)((float)(v212 - v198) * v264) - (float)((float)(v203 - v205) * v266);
        float v269 = (float)((float)(v203 - v205) * v265) - (float)((float)(v204 - v206) * v264);
        float v270 = sqrtf((float)(v269 * v269) + (float)((float)(v267 * v267) + (float)(v268 * v268)));
        float v271 = v268 / v270;
        float v272 = v269 / v270;
        *(float *)(v186 + 288) = v205;
        *(float *)(v186 + 292) = v206;
        *(float *)(v186 + 296) = v198;
        *(float *)(v186 + 300) = v211;
        *(float *)(v186 + 304) = v267 / v270;
        *(float *)(v186 + 308) = v271;
        *(float *)(v186 + 312) = v272;
        *(float *)(v186 + 316) = v34;
        *(float *)(v186 + 336) = v203;
        *(float *)(v186 + 340) = v204;
        *(float *)(v186 + 344) = v212;
        *(float *)(v186 + 348) = v211;
        *(float *)(v186 + 352) = v267 / v270;
        *(float *)(v186 + 356) = v271;
        *(float *)(v186 + 360) = v272;
        *(float *)(v186 + 364) = v34;
        *(_OWORD *)(v186 + 384) = *((_OWORD *)v30 + 15);
        *(float *)(v186 + 400) = v267 / v270;
        *(float *)(v186 + 404) = v271;
        *(float *)(v186 + 408) = v272;
        *(float *)(v186 + 412) = v34;
        *(_OWORD *)(v186 + 432) = *((_OWORD *)v30 + 15);
        *(float *)(v186 + 448) = v267 / v270;
        *(float *)(v186 + 452) = v271;
        *(float *)(v186 + 456) = v272;
        *(float *)(v186 + 460) = v34;
        *(_OWORD *)(v186 + 480) = *((_OWORD *)v30 + 12);
        *(float *)(v186 + 496) = v267 / v270;
        *(float *)(v186 + 500) = v271;
        *(float *)(v186 + 504) = v272;
        *(float *)(v186 + 508) = v34;
        *(float *)(v186 + 528) = v205;
        *(float *)(v186 + 532) = v206;
        *(float *)(v186 + 536) = v198;
        *(float *)(v186 + 540) = v211;
        *(float *)(v186 + 544) = v267 / v270;
        *(float *)(v186 + 548) = v271;
        *(float *)(v186 + 552) = v272;
        *(float *)(v186 + 556) = v34;
        float v273 = v30[48] - v201;
        float v274 = v30[49] - v202;
        float v275 = v30[50] - v213;
        float v276 = (float)((float)(v206 - v202) * v275) - (float)((float)(v198 - v213) * v274);
        float v277 = (float)((float)(v198 - v213) * v273) - (float)((float)(v205 - v201) * v275);
        float v278 = (float)((float)(v205 - v201) * v274) - (float)((float)(v206 - v202) * v273);
        float v279 = sqrtf((float)(v278 * v278) + (float)((float)(v276 * v276) + (float)(v277 * v277)));
        float v280 = v277 / v279;
        *(float *)(v186 + 576) = v201;
        *(float *)(v186 + 580) = v202;
        *(float *)(v186 + 584) = v213;
        *(float *)(v186 + 588) = v211;
        *(float *)(v186 + 592) = v276 / v279;
        *(float *)(v186 + 596) = v280;
        float v281 = v278 / v279;
        *(float *)(v186 + 600) = v281;
        *(float *)(v186 + 604) = v34;
        *(float *)(v186 + 624) = v205;
        *(float *)(v186 + 628) = v206;
        *(float *)(v186 + 632) = v198;
        *(float *)(v186 + 636) = v211;
        *(float *)(v186 + 640) = v276 / v279;
        *(float *)(v186 + 644) = v280;
        *(float *)(v186 + 648) = v281;
        *(float *)(v186 + 652) = v34;
        *(_OWORD *)(v186 + 672) = *((_OWORD *)v30 + 12);
        *(float *)(v186 + 688) = v276 / v279;
        *(float *)(v186 + 692) = v280;
        *(float *)(v186 + 696) = v281;
        *(float *)(v186 + 700) = v34;
        *(_OWORD *)(v186 + 720) = *((_OWORD *)v30 + 12);
        *(float *)(v186 + 736) = v276 / v279;
        *(float *)(v186 + 740) = v280;
        *(float *)(v186 + 744) = v281;
        *(float *)(v186 + 748) = v34;
        *(_OWORD *)(v186 + 768) = *v252;
        *(float *)(v186 + 784) = v276 / v279;
        *(float *)(v186 + 788) = v280;
        *(float *)(v186 + 792) = v281;
        *(float *)(v186 + 796) = v34;
        *(float *)(v186 + 816) = v201;
        *(float *)(v186 + 820) = v202;
        *(float *)(v186 + 824) = v213;
        *(float *)(v186 + 828) = v211;
        *(float *)(v186 + 832) = v276 / v279;
        *(float *)(v186 + 836) = v280;
        *(float *)(v186 + 840) = v281;
        *(float *)(v186 + 844) = v34;
        v30 += 72;
        v186 += 864;
        float v29 = v446;
        if (a4 < 2) {
          return v30;
        }
      }
      v187 += 27;
      --a4;
    }
  }
  uint64_t v55 = a5 - 1;
  if (a5 != 1)
  {
    unsigned int v282 = 3 * a5;
    uint64_t v283 = 6 * a5;
    uint64_t v284 = v37 + 48 * (0xAAAAAAAAAAAAAAABLL * (((uint64_t)a2 - v37) >> 4) + *(void *)(v31 + 64) * v283);
    float v434 = v34;
    float v435 = v29 + 1.0;
    uint64_t v285 = 8 * (int)(a5 - 4) + 116;
    uint64_t v286 = v55 - 1;
    v287 = v28 + 26;
    uint64_t v288 = 6 * a5;
    float v289 = a12.f32[0];
    uint64_t v432 = v55 - 1;
    uint64_t v433 = v31;
    unsigned int v430 = a5 - 1;
    uint64_t v431 = v288;
    while (1)
    {
      float v290 = v28[13];
      float v291 = v28[14];
      float v292 = fminf(fmaxf(v29 - v290, 0.0), v291);
      float v293 = fminf(fmaxf(v435 - v290, 0.0), v291) - v291;
      float v294 = v290 - (float)(v291 + -1.0);
      if (v294 <= v29) {
        float v295 = 0.0;
      }
      else {
        float v295 = v29 - v294;
      }
      if (v291 <= 1.0) {
        float v295 = v293;
      }
      if (v29 < 0.0) {
        float v296 = v295;
      }
      else {
        float v296 = v292;
      }
      float v297 = *(float *)(v31 + 168) + (float)(fabsf(v296) * (float)(*(float *)(v31 + 172) - *(float *)(v31 + 168)));
      float v298 = (float)(v297 * v447) * 0.5;
      unint64_t v299 = a4 - 1;
      if (a4 && v296 == 0.0)
      {
        float v300 = *v28 + (float)(v297 * (float)(v28[21] - *v28));
        float v301 = v28[1] + (float)(v297 * (float)(v28[22] - v28[1]));
        float v302 = 1.0;
        float v303 = 0.0;
        float v304 = 0.0;
        float v436 = 0.0;
        float v305 = (float)(v297 * v447) * 0.5;
        float v306 = 1.0;
        a17 = 0.0;
        v54.i32[0] = 0;
        a7.n128_u32[0] = 0;
        v18.i32[0] = 1.0;
        v24.i64[0] = 0;
        a10.i64[0] = 0;
        *(void *)&long long v21 = 0;
        float v450 = 1.0;
      }
      else
      {
        if (a4)
        {
          unint64_t v451 = a4;
          uint64_t v307 = v283;
          v308 = v287;
          __float2 v309 = __sincosf_stret((float)(v296 * (float)(v28[11] * 6.2832)) * 0.5);
          a8.n128_f32[0] = v309.__cosval;
          uint64_t v288 = v431;
          uint64_t v286 = v432;
          v287 = v308;
          uint64_t v283 = v307;
          uint64_t v31 = v433;
          a4 = v451;
          LODWORD(v55) = v430;
          a17 = v28[8] * v309.__sinval;
          v54.f32[0] = v28[9] * v309.__sinval;
          a7.n128_f32[0] = v28[10] * v309.__sinval;
          float v310 = v28[7];
          v20.f32[0] = (float)(*v28 + (float)(v296 * (float)(v28[4] * v310))) + (float)(v296 * (float)(v296 * v28[15]));
          *(float *)&long long v25 = v296 * (float)(v310 * v28[6]);
          a10.f32[0] = (float)(v28[1] + (float)(v296 * (float)(v310 * v28[5])))
                     + (float)(v296 * (float)(v296 * v28[16]));
          float v289 = 1.0;
        }
        float v450 = v289;
        float v311 = v28[17];
        float v312 = v28[18];
        float v313 = v28[19];
        float v314 = (float)(v54.f32[0] * (float)(v298 - v313)) - (float)(a7.n128_f32[0] * (float)(0.0 - v312));
        float v315 = (float)(a7.n128_f32[0] * (float)(0.0 - v311)) - (float)(a17 * (float)(v298 - v313));
        float v316 = (float)(a17 * (float)(0.0 - v312)) - (float)(v54.f32[0] * (float)(0.0 - v311));
        float v317 = v314 + v314;
        float v318 = v315 + v315;
        float v319 = v316 + v316;
        float v300 = v311
             + (float)(v20.f32[0]
                     + (float)((float)(a8.n128_f32[0] * v317)
                             + (float)((float)(0.0 - v311)
                                     + (float)((float)(v54.f32[0] * v319) - (float)(a7.n128_f32[0] * v318)))));
        float v301 = v312
             + (float)(a10.f32[0]
                     + (float)((float)(a8.n128_f32[0] * v318)
                             + (float)((float)(0.0 - v312)
                                     + (float)((float)(a7.n128_f32[0] * v317) - (float)(a17 * v319)))));
        float v305 = v313
             + (float)(*(float *)&v25
                     + (float)((float)(a8.n128_f32[0] * v319)
                             + (float)((float)(v298 - v313) + (float)((float)(a17 * v318) - (float)(v54.f32[0] * v317)))));
        float v306 = v28[20] + (float)(v289 + (float)((float)(a8.n128_f32[0] * 0.0) + (float)(0.0 - v28[20])));
        float v320 = (float)(v54.f32[0] - (float)(a7.n128_f32[0] * 0.0)) + (float)(v54.f32[0] - (float)(a7.n128_f32[0] * 0.0));
        float v321 = (float)((float)(a7.n128_f32[0] * 0.0) - a17) + (float)((float)(a7.n128_f32[0] * 0.0) - a17);
        float v322 = (float)((float)(a17 * 0.0) - (float)(v54.f32[0] * 0.0))
             + (float)((float)(a17 * 0.0) - (float)(v54.f32[0] * 0.0));
        float v303 = (float)(a8.n128_f32[0] * v320)
             + (float)((float)((float)(v54.f32[0] * v322) - (float)(a7.n128_f32[0] * v321)) + 0.0);
        float v304 = (float)(a8.n128_f32[0] * v321)
             + (float)((float)((float)(a7.n128_f32[0] * v320) - (float)(a17 * v322)) + 0.0);
        float v302 = (float)(a8.n128_f32[0] * v322) + (float)((float)((float)(a17 * v321) - (float)(v54.f32[0] * v320)) + 1.0);
        float v436 = (float)(a8.n128_f32[0] * 0.0) + 0.0;
        float32x4_t v18 = (float32x4_t)a8;
        long long v21 = v25;
        float32x4_t v24 = v20;
      }
      float v456 = v300;
      *size_t v30 = v300;
      float v442 = v301;
      v30[1] = v301;
      float v437 = v305;
      float v439 = v306;
      v30[2] = v305;
      v30[3] = v306;
      v30[4] = v303;
      v30[5] = v304;
      v30[6] = v302;
      v30[7] = v452;
      float v323 = v28[17];
      float v324 = v28[18];
      float v325 = (float)(v297 * (float)(v28[21] - *v28)) - v323;
      float v326 = (float)(v297 * (float)(v28[22] - v28[1])) - v324;
      float v327 = v28[19];
      float v328 = v28[20];
      float v329 = (float)((float)(v54.f32[0] * (float)(v298 - v327)) - (float)(a7.n128_f32[0] * v326))
           + (float)((float)(v54.f32[0] * (float)(v298 - v327)) - (float)(a7.n128_f32[0] * v326));
      float v330 = (float)((float)(a7.n128_f32[0] * v325) - (float)(a17 * (float)(v298 - v327)))
           + (float)((float)(a7.n128_f32[0] * v325) - (float)(a17 * (float)(v298 - v327)));
      float v331 = (float)((float)(a17 * v326) - (float)(v54.f32[0] * v325))
           + (float)((float)(a17 * v326) - (float)(v54.f32[0] * v325));
      float v332 = (float)(v297 * v447) * 0.5;
      float v333 = v18.f32[0] * 0.0;
      v30[12] = v323
              + (float)(v24.f32[0]
                      + (float)((float)(v18.f32[0] * v329)
                              + (float)(v325 + (float)((float)(v54.f32[0] * v331) - (float)(a7.n128_f32[0] * v330)))));
      v30[13] = v324
              + (float)(a10.f32[0]
                      + (float)((float)(v18.f32[0] * v330)
                              + (float)(v326 + (float)((float)(a7.n128_f32[0] * v329) - (float)(a17 * v331)))));
      v30[14] = v327
              + (float)(*(float *)&v21
                      + (float)((float)(v18.f32[0] * v331)
                              + (float)((float)(v298 - v327) + (float)((float)(a17 * v330) - (float)(v54.f32[0] * v329)))));
      v30[15] = v328 + (float)(v450 + (float)((float)(v18.f32[0] * 0.0) + (float)(0.0 - v328)));
      v30[16] = v303;
      v30[17] = v304;
      v30[18] = v302;
      v30[19] = v452;
      float v334 = v28[17];
      float v335 = v28[18];
      float v336 = (float)(v297 * (float)(v28[23] - *v28)) - v334;
      float v337 = (float)(v297 * (float)(v28[24] - v28[1])) - v335;
      float v338 = v28[19];
      float v339 = v28[20];
      float v340 = (float)((float)(v54.f32[0] * (float)(v332 - v338)) - (float)(a7.n128_f32[0] * v337))
           + (float)((float)(v54.f32[0] * (float)(v332 - v338)) - (float)(a7.n128_f32[0] * v337));
      float v341 = (float)((float)(a7.n128_f32[0] * v336) - (float)(a17 * (float)(v332 - v338)))
           + (float)((float)(a7.n128_f32[0] * v336) - (float)(a17 * (float)(v332 - v338)));
      float v342 = (float)((float)(a17 * v337) - (float)(v54.f32[0] * v336))
           + (float)((float)(a17 * v337) - (float)(v54.f32[0] * v336));
      long long v343 = v21;
      *((void *)&v21 + 1) = a7.n128_u64[1];
      v30[24] = v334
              + (float)(v24.f32[0]
                      + (float)((float)(v18.f32[0] * v340)
                              + (float)(v336 + (float)((float)(v54.f32[0] * v342) - (float)(a7.n128_f32[0] * v341)))));
      v30[25] = v335
              + (float)(a10.f32[0]
                      + (float)((float)(v18.f32[0] * v341)
                              + (float)(v337 + (float)((float)(a7.n128_f32[0] * v340) - (float)(a17 * v342)))));
      v30[26] = v338
              + (float)(*(float *)&v343
                      + (float)((float)(v18.f32[0] * v342)
                              + (float)((float)(v298 - v338) + (float)((float)(a17 * v341) - (float)(v54.f32[0] * v340)))));
      v30[27] = v339 + (float)(v450 + (float)((float)(v18.f32[0] * 0.0) + (float)(0.0 - v339)));
      v30[28] = v303;
      v30[29] = v304;
      v30[30] = v302;
      v30[31] = v452;
      long long v25 = v343;
      float32x4_t v20 = v24;
      if (v55 < 2)
      {
        int v362 = 1;
        float v363 = v445;
        float v29 = v446;
        float v289 = v450;
        a8 = (__n128)v18;
        float v364 = v297 * v447;
        float v365 = v456;
        float v347 = v442;
        float v366 = v437;
        float v348 = v439;
      }
      else
      {
        unsigned int v344 = 2;
        v345 = v287;
        uint64_t v346 = v286;
        a8 = (__n128)v18;
        float v347 = v442;
        float v348 = v439;
        do
        {
          v349 = &v30[12 * v344 + 12];
          float *v349 = v456;
          v349[1] = v442;
          v349[2] = v437;
          v349[3] = v439;
          v349[4] = v303;
          v349[5] = v304;
          v349[6] = v302;
          long long v350 = *(_OWORD *)&v30[12 * v344];
          v351 = &v30[12 * v344 + 24];
          v349[7] = v452;
          *(_OWORD *)v351 = v350;
          v351[4] = v303;
          v351[5] = v304;
          v351[6] = v302;
          v351[7] = v452;
          *(float *)&long long v350 = *(v345 - 1) - *v28;
          float v352 = *v345;
          v345 += 2;
          float v353 = v28[17];
          float v354 = v28[18];
          *(float *)&long long v350 = (float)(v297 * *(float *)&v350) - v353;
          float v355 = v28[19];
          float v356 = (float)(v297 * (float)(v352 - v28[1])) - v354;
          float32x4_t v18 = a10;
          *((void *)&v21 + 1) = *((void *)&v25 + 1);
          float v357 = (float)((float)(v54.f32[0] * (float)(v332 - v355)) - (float)(a7.n128_f32[0] * v356))
               + (float)((float)(v54.f32[0] * (float)(v332 - v355)) - (float)(a7.n128_f32[0] * v356));
          float v358 = (float)((float)(a7.n128_f32[0] * *(float *)&v350) - (float)(a17 * (float)(v332 - v355)))
               + (float)((float)(a7.n128_f32[0] * *(float *)&v350) - (float)(a17 * (float)(v332 - v355)));
          float v359 = (float)((float)(a17 * v356) - (float)(v54.f32[0] * *(float *)&v350))
               + (float)((float)(a17 * v356) - (float)(v54.f32[0] * *(float *)&v350));
          *(float *)&long long v350 = v353
                          + (float)(v20.f32[0]
                                  + (float)((float)(a8.n128_f32[0] * v357)
                                          + (float)(*(float *)&v350
                                                  + (float)((float)(v54.f32[0] * v359) - (float)(a7.n128_f32[0] * v358)))));
          float v360 = v28[20] + (float)(v450 + (float)(v333 + (float)(0.0 - v28[20])));
          v344 += 3;
          v361 = &v30[12 * v344];
          *(_DWORD *)v361 = v350;
          v361[1] = v354
                  + (float)(a10.f32[0]
                          + (float)((float)(a8.n128_f32[0] * v358)
                                  + (float)(v356 + (float)((float)(a7.n128_f32[0] * v357) - (float)(a17 * v359)))));
          v361[3] = v360;
          v361[2] = v355
                  + (float)(*(float *)&v25
                          + (float)((float)(a8.n128_f32[0] * v359)
                                  + (float)((float)(v332 - v355)
                                          + (float)((float)(a17 * v358) - (float)(v54.f32[0] * v357)))));
          v361[4] = v303;
          v361[5] = v304;
          v361[6] = v302;
          v361[7] = v452;
          --v346;
        }
        while (v346);
        int v362 = v55;
        float v363 = v445;
        float v29 = v446;
        float v289 = v450;
        float v34 = v434;
        float v364 = v297 * v447;
        float v365 = v456;
        float v366 = v437;
      }
      unsigned int v367 = 3 * v362;
      v368 = &v30[12 * v367];
      float *v368 = v365;
      v368[1] = v347;
      v368[2] = v366;
      v368[3] = v348;
      v368[4] = v303;
      v368[5] = v304;
      v368[6] = v302;
      v368[7] = v452;
      v369 = &v30[12 * v367 + 12];
      *(_OWORD *)v369 = *(_OWORD *)&v30[12 * v367 - 12];
      v369[4] = v303;
      v369[5] = v304;
      v369[6] = v302;
      v369[7] = v452;
      v370 = &v30[12 * v367 + 24];
      *(_OWORD *)v370 = *((_OWORD *)v30 + 3);
      v370[4] = v303;
      v370[5] = v304;
      v370[6] = v302;
      v370[7] = v452;
      v371 = &v30[12 * v282];
      if (v364 == 0.0)
      {
        v30 += 12 * v282;
        if (a4 < 2) {
          return v30;
        }
      }
      else
      {
        float v372 = v364 * v303;
        float v373 = v364 * v304;
        float v374 = v364 * v302;
        float v375 = v364 * v436;
        float *v371 = v365 - (float)(v364 * v303);
        v371[1] = v347 - (float)(v364 * v304);
        v371[2] = v366 - (float)(v364 * v302);
        v371[3] = v348 - (float)(v364 * v436);
        v376 = &v30[12 * v282];
        v376[4] = v303;
        v376[5] = v304;
        v376[6] = v302;
        v376[7] = v363;
        float v377 = v30[24] - (float)(v364 * v303);
        float v378 = v30[25] - (float)(v364 * v304);
        float v379 = v30[26] - (float)(v364 * v302);
        float v380 = v30[27] - v375;
        v371[12] = v377;
        v371[13] = v378;
        v371[14] = v379;
        v371[15] = v380;
        v371[16] = v303;
        v371[17] = v304;
        v371[18] = v302;
        v371[19] = v363;
        float v381 = v30[13] - v373;
        float v382 = v30[14] - v374;
        float v383 = v30[15] - v375;
        v371[24] = v30[12] - v372;
        v371[25] = v381;
        v371[26] = v382;
        v371[27] = v383;
        v371[28] = v303;
        v371[29] = v304;
        v371[30] = v302;
        v371[31] = v363;
        if (v55 < 2)
        {
          int v394 = 1;
        }
        else
        {
          unsigned int v384 = 5;
          uint64_t v385 = v286;
          do
          {
            v386 = &v371[12 * v384 - 24];
            *(_OWORD *)v386 = *(_OWORD *)v371;
            v386[4] = v303;
            v386[5] = v304;
            v386[6] = v302;
            v386[7] = v363;
            v387 = &v30[12 * v384];
            float v388 = *v387 - v372;
            float v389 = v387[1] - v373;
            float v390 = v387[2] - v374;
            float v391 = v387[3] - v375;
            v392 = &v371[12 * v384 - 12];
            float *v392 = v388;
            v392[1] = v389;
            v392[2] = v390;
            v392[3] = v391;
            v392[4] = v303;
            v392[5] = v304;
            v392[6] = v302;
            v392[7] = v363;
            v393 = &v371[12 * v384];
            *(_OWORD *)v393 = *(_OWORD *)&v371[12 * v384 - 48];
            v393[4] = v303;
            v393[5] = v304;
            v393[6] = v302;
            v393[7] = v363;
            v384 += 3;
            --v385;
          }
          while (v385);
          int v394 = v55;
        }
        unsigned int v395 = 3 * v394;
        v396 = &v371[12 * v395];
        *(_OWORD *)v396 = *(_OWORD *)v371;
        v396[4] = v303;
        v396[5] = v304;
        v396[6] = v302;
        v396[7] = v363;
        v397 = &v371[12 * v395 + 12];
        *(_OWORD *)v397 = *((_OWORD *)v371 + 6);
        v397[4] = v303;
        v397[5] = v304;
        v397[6] = v302;
        v397[7] = v363;
        v398 = &v371[12 * v395 + 24];
        *(_OWORD *)v398 = *(_OWORD *)&v371[12 * v395 - 24];
        v398[4] = v303;
        v398[5] = v304;
        v398[6] = v302;
        v398[7] = v363;
        if (a5)
        {
          uint64_t v399 = 0;
          unsigned int v400 = 2;
          do
          {
            v401 = &v30[12 * v400 - 12];
            v402 = &v30[12 * v400];
            float v403 = v402[1];
            float v404 = *v401 - *v402;
            float v405 = v402[2];
            float v406 = v401[1] - v403;
            v407 = &v371[12 * v400];
            float v408 = *v407 - *v402;
            float v409 = v407[1] - v403;
            float v410 = v401[2] - v405;
            float v411 = v407[2] - v405;
            float v412 = (float)(v406 * v411) - (float)(v410 * v409);
            float v413 = (float)(v410 * v408) - (float)(v404 * v411);
            float v414 = (float)(v404 * v409) - (float)(v406 * v408);
            float v415 = sqrtf((float)(v414 * v414) + (float)((float)(v412 * v412) + (float)(v413 * v413)));
            float v416 = v412 / v415;
            float v417 = v413 / v415;
            float v418 = v414 / v415;
            uint64_t v419 = v284 + 48 * v399;
            *(_OWORD *)uint64_t v419 = *(_OWORD *)v402;
            *(float *)(v419 + 16) = v412 / v415;
            *(float *)(v419 + 20) = v417;
            *(float *)(v419 + 24) = v418;
            *(float *)(v419 + 28) = v34;
            uint64_t v420 = v284 + 48 * (v399 + 1);
            long long v421 = *(_OWORD *)v401;
            *(float *)(v420 + 16) = v416;
            *(float *)(v420 + 20) = v417;
            *(float *)(v420 + 24) = v418;
            *(float *)(v420 + 28) = v34;
            *(_OWORD *)uint64_t v420 = v421;
            uint64_t v422 = v284 + 48 * (v399 + 2);
            long long v423 = *(_OWORD *)v407;
            *(float *)(v422 + 16) = v416;
            *(float *)(v422 + 20) = v417;
            *(_OWORD *)uint64_t v422 = v423;
            *(float *)(v422 + 24) = v418;
            *(float *)(v422 + 28) = v34;
            uint64_t v424 = v284 + 48 * (v399 + 3);
            *(_OWORD *)uint64_t v424 = *(_OWORD *)v407;
            *(float *)(v424 + 16) = v416;
            *(float *)(v424 + 20) = v417;
            *(float *)(v424 + 24) = v418;
            *(float *)(v424 + 28) = v34;
            uint64_t v425 = v284 + 48 * (v399 + 4);
            long long v426 = *(_OWORD *)&v371[12 * v400 - 12];
            *(float *)(v425 + 16) = v416;
            *(float *)(v425 + 20) = v417;
            *(float *)(v425 + 24) = v418;
            *(float *)(v425 + 28) = v34;
            *(_OWORD *)uint64_t v425 = v426;
            long long v427 = *(_OWORD *)v402;
            uint64_t v428 = v284 + 48 * (v399 + 5);
            *(float *)(v428 + 16) = v416;
            *(float *)(v428 + 20) = v417;
            *(_OWORD *)uint64_t v428 = v427;
            *(float *)(v428 + 24) = v418;
            *(float *)(v428 + 28) = v34;
            v399 += 6;
            v400 += 3;
          }
          while (v288 != v399);
        }
        size_t v30 = &v371[12 * v282];
        v284 += 48 * v283;
        if (a4 < 2) {
          return v30;
        }
      }
      uint64_t v28 = (float *)((char *)v28 + v285);
      v287 = (float *)((char *)v287 + v285);
      a4 = v299;
    }
  }
  float v56 = v29 + 1.0;
  size_t v30 = a2 + 12;
  for (uint64_t j = a3 + 11; ; j += 23)
  {
    float v58 = j[2];
    float v59 = j[3];
    float v60 = fminf(fmaxf(v446 - v58, 0.0), v59);
    float v61 = fminf(fmaxf(v56 - v58, 0.0), v59) - v59;
    float v62 = v58 - (float)(v59 + -1.0);
    if (v62 <= v446) {
      float v63 = 0.0;
    }
    else {
      float v63 = v446 - v62;
    }
    if (v59 <= 1.0) {
      float v63 = v61;
    }
    float v64 = v446 < 0.0 ? v63 : v60;
    float v65 = (float)((float)(*(float *)(v31 + 168)
                        + (float)(fabsf(v64) * (float)(*(float *)(v31 + 172) - *(float *)(v31 + 168))))
                * v447)
        * 0.5;
    if (a4 && v64 == 0.0)
    {
      float v66 = j[10];
      float v67 = j[11];
      float v68 = 1.0;
      float v69 = 0.0;
      float v70 = 0.0;
      float v71 = 1.0;
    }
    else
    {
      float32x4_t v72 = v20;
      float v73 = *(j - 11);
      if (a4)
      {
        __float2 v74 = __sincosf_stret((float)(v64 * (float)(*j * 6.2832)) * 0.5);
        a8.n128_f32[0] = v74.__cosval;
        a17 = *(j - 3) * v74.__sinval;
        v54.f32[0] = *(j - 2) * v74.__sinval;
        a7.n128_f32[0] = *(j - 1) * v74.__sinval;
        float v75 = *(j - 4);
        v72.f32[0] = (float)(v73 + (float)(v64 * (float)(*(j - 7) * v75))) + (float)(v64 * (float)(v64 * j[4]));
        float v76 = *(j - 10);
        *(float *)&long long v25 = v64 * (float)(v75 * *(j - 5));
        a10.f32[0] = (float)(v76 + (float)(v64 * (float)(v75 * *(j - 6)))) + (float)(v64 * (float)(v64 * j[5]));
        float v77 = 1.0;
      }
      else
      {
        float v76 = *(j - 10);
        float v77 = *(float *)&v448;
      }
      float v78 = j[6];
      float v79 = j[7];
      float v80 = (float)(j[10] - v73) - v78;
      float v81 = (float)(j[11] - v76) - v79;
      float v82 = j[8];
      float v83 = (float)((float)(v54.f32[0] * (float)(v65 - v82)) - (float)(a7.n128_f32[0] * v81))
          + (float)((float)(v54.f32[0] * (float)(v65 - v82)) - (float)(a7.n128_f32[0] * v81));
      float v84 = (float)((float)(a7.n128_f32[0] * v80) - (float)(a17 * (float)(v65 - v82)))
          + (float)((float)(a7.n128_f32[0] * v80) - (float)(a17 * (float)(v65 - v82)));
      float v85 = (float)((float)(a17 * v81) - (float)(v54.f32[0] * v80))
          + (float)((float)(a17 * v81) - (float)(v54.f32[0] * v80));
      float v86 = (float)(a17 * v84) - (float)(v54.f32[0] * v83);
      float v87 = v72.f32[0]
          + (float)((float)(a8.n128_f32[0] * v83)
                  + (float)(v80 + (float)((float)(v54.f32[0] * v85) - (float)(a7.n128_f32[0] * v84))));
      float v88 = a10.f32[0]
          + (float)((float)(a8.n128_f32[0] * v84)
                  + (float)(v81 + (float)((float)(a7.n128_f32[0] * v83) - (float)(a17 * v85))));
      *(float *)&unsigned __int32 v448 = v77;
      float v66 = v78 + v87;
      float v67 = v79 + v88;
      float v65 = v82 + (float)(*(float *)&v25 + (float)((float)(a8.n128_f32[0] * v85) + (float)((float)(v65 - v82) + v86)));
      float v71 = j[9] + (float)(v77 + (float)((float)(a8.n128_f32[0] * 0.0) + (float)(0.0 - j[9])));
      float v89 = (float)(v54.f32[0] - (float)(a7.n128_f32[0] * 0.0)) + (float)(v54.f32[0] - (float)(a7.n128_f32[0] * 0.0));
      float v90 = (float)((float)(a7.n128_f32[0] * 0.0) - a17) + (float)((float)(a7.n128_f32[0] * 0.0) - a17);
      float v91 = (float)((float)(a17 * 0.0) - (float)(v54.f32[0] * 0.0))
          + (float)((float)(a17 * 0.0) - (float)(v54.f32[0] * 0.0));
      float v92 = (float)((float)(a7.n128_f32[0] * v89) - (float)(a17 * v91)) + 0.0;
      float v93 = (float)((float)(a17 * v90) - (float)(v54.f32[0] * v89)) + 1.0;
      float v94 = a8.n128_f32[0] * v91;
      float v69 = (float)(a8.n128_f32[0] * v89)
          + (float)((float)((float)(v54.f32[0] * v91) - (float)(a7.n128_f32[0] * v90)) + 0.0);
      float v70 = (float)(a8.n128_f32[0] * v90) + v92;
      float v68 = v94 + v93;
      float32x4_t v20 = v72;
    }
    *(v30 - 12) = v66;
    *(v30 - 11) = v67;
    *(v30 - 10) = v65;
    *(v30 - 9) = v71;
    *(v30 - 8) = v69;
    *(v30 - 7) = v70;
    *(v30 - 6) = v68;
    *(v30 - 5) = v452;
    if (a4 < 2) {
      break;
    }
    v30 += 12;
    --a4;
  }
  return v30;
}

float *HGFractured::Effect::apply_polar(float *this, HGFractured::Effect *a2, __n128 a3, int a4, __n128 a5, double a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, double a10, double a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (*((void *)this + 8))
  {
    int v16 = (int)a2;
    float v17 = a3.n128_f32[0];
    uint64_t v18 = (uint64_t)this;
    unint64_t v19 = 0;
    float32x4_t v20 = *(float **)&this[2 * (a2 != 0) + 24];
    long long v21 = (float *)*((void *)this + 7);
    float v39 = a3.n128_f32[0] + 1.0;
    do
    {
      float v24 = *v21;
      float v25 = v21[1];
      float v27 = v21[13];
      float v26 = v21[14];
      if (v17 >= 0.0)
      {
        float v29 = fminf(fmaxf(v17 - v27, 0.0), v26);
        if (v29 != 0.0) {
          goto LABEL_13;
        }
      }
      else if (v26 <= 1.0)
      {
        float v29 = fminf(fmaxf(v39 - v27, 0.0), v26) - v26;
        if (v29 != 0.0) {
          goto LABEL_13;
        }
      }
      else
      {
        float v28 = v27 - (float)(v26 + -1.0);
        if (v28 > v17)
        {
          float v29 = v17 - v28;
          if ((float)(v17 - v28) != 0.0)
          {
LABEL_13:
            float v30 = v21[7];
            float v31 = sqrtf((float)(v24 * v24) + (float)(v25 * v25)) + (float)(v29 * (float)(v21[4] * v30));
            float v32 = atan2f(v21[1], *v21);
            __float2 v33 = __sincosf_stret(v32 + (float)(v29 * (float)(v30 * v21[5])));
            float v23 = v29 * (float)(v30 * v21[6]);
            float v24 = (float)(v29 * (float)(v29 * v21[15])) + (float)(v31 * v33.__cosval);
            float v25 = (float)(v31 * v33.__sinval) + (float)(v29 * (float)(v29 * v21[16]));
            __float2 v34 = __sincosf_stret((float)(v29 * (float)(v21[11] * 6.2832)) * 0.5);
            a5.n128_f32[0] = v34.__cosval;
            *(float *)&double v22 = v21[8] * v34.__sinval;
            a7.f32[0] = v21[9] * v34.__sinval;
            a8.f32[0] = v21[10] * v34.__sinval;
            goto LABEL_4;
          }
        }
      }
      a5.n128_u32[0] = 1.0;
      double v22 = 0.0;
      a7.i64[0] = 0;
      a8.i64[0] = 0;
      float v23 = 0.0;
LABEL_4:
      a3.n128_u32[0] = *(_DWORD *)(v18 + 136);
      unsigned __int32 v37 = a8.i32[0];
      unsigned __int32 v38 = a5.n128_u32[0];
      a5.n128_u64[0] = 0;
      a9.i32[0] = 1.0;
      float v35 = *(float *)&v22;
      __int32 v36 = a7.i32[0];
      *(float *)&double v22 = v24;
      a7.f32[0] = v25;
      a8.f32[0] = v23;
      this = emit(v18, v20, v21, 0, *(_DWORD *)(v18 + 124), v16, a3, a5, v22, a7, a8, a9, a15, a16, a10, a11, v35, v36, v37,
               v38);
      float32x4_t v20 = this;
      v21 += 2 * *(int *)(v18 + 124) + 21;
      ++v19;
    }
    while (v19 < *(void *)(v18 + 64));
  }
  return this;
}

float *apply_whirl(float *result, float a2, int a3)
{
  if (*((void *)result + 8))
  {
    uint64_t v4 = (uint64_t)result;
    unint64_t v5 = 0;
    float v6 = *(float **)&result[2 * (a3 != 0) + 24];
    uint64_t v7 = *((void *)result + 7);
    float v8 = 1.0;
    float v9 = 0.5;
    float v10 = 0.25;
    do
    {
      float v41 = *(float *)v7;
      unsigned int v66 = *(_DWORD *)(v7 + 4);
      float v42 = *(float *)(v7 + 52);
      float v43 = *(float *)(v7 + 56);
      float v44 = fminf(fmaxf(a2 - v42, 0.0), v43);
      float v45 = fminf(fmaxf((float)(a2 + 1.0) - v42, 0.0), v43) - v43;
      float v46 = v42 - (float)(v43 + -1.0);
      BOOL v47 = v46 > a2;
      float v48 = a2 - v46;
      if (!v47) {
        float v48 = 0.0;
      }
      if (v43 <= v8) {
        float v48 = v45;
      }
      if (a2 < 0.0) {
        float v49 = v48;
      }
      else {
        float v49 = v44;
      }
      double v50 = -(*(float *)(v7 + 28) * -3.14159265 * v49);
      if (a3 >= 0) {
        double v50 = *(float *)(v7 + 28) * -3.14159265 * v49;
      }
      float v51 = v50;
      __float2 v52 = __sincosf_stret(v51 * v9);
      float v53 = *(float *)(v7 + 16);
      float32x2_t v54 = *(float32x2_t *)(v7 + 20);
      if (v49 < v10)
      {
        float v11 = v10 - v49;
        if (v49 < 0.125) {
          float v11 = v49;
        }
        float v12 = (float)(v11 * 0.1) * 8.0;
        float v13 = fminf(fmaxf(v49 * 4.0, 0.0), v8);
        float v14 = (float)(v13 * v13) * (float)(3.0 - (float)(v13 + v13));
        float v64 = v14 + (float)(v8 - v14);
        float v15 = v14 * v10;
        float v16 = (float)((float)(v53 * v14) + (float)(v41 * (float)(v8 - v14)))
            - (float)(v12 + (float)((float)(v14 * v10) * (float)((float)(v53 * v14) + (float)(v41 * (float)(v8 - v14)))));
        float32x2_t v17 = vadd_f32(vmul_n_f32(v54, v14), vmul_n_f32((float32x2_t)v66, v8 - v14));
      }
      else
      {
        if (v49 < 0.75)
        {
          float v16 = v53 + (float)(v53 * -0.25);
          __asm { FMOV            V1.2S, #-0.25 }
          float32x2_t v65 = vadd_f32(v54, vmul_f32(v54, _D1));
          double v18 = v41 * 3.14159265;
          float v64 = 1.0;
          goto LABEL_7;
        }
        float v60 = v8 - v49;
        if (v49 < 0.875) {
          float v60 = v49 + -0.75;
        }
        float v61 = fminf(fmaxf((float)(v49 + -0.75) * 4.0, 0.0), v8);
        float v62 = (float)(v61 * v61) * (float)(3.0 - (float)(v61 + v61));
        float v64 = v62 + (float)(v8 - v62);
        float v15 = (float)(v8 - v62) * v10;
        float v16 = (float)((float)(v41 * v62) + (float)(v53 * (float)(v8 - v62)))
            - (float)((float)((float)(v60 * 0.1) * 8.0)
                    + (float)(v15 * (float)((float)(v41 * v62) + (float)(v53 * (float)(v8 - v62)))));
        float32x2_t v17 = vadd_f32(vmul_n_f32((float32x2_t)v66, v62), vmul_n_f32(v54, v8 - v62));
      }
      float32x2_t v65 = vsub_f32(v17, vmul_n_f32(v17, v15));
      double v18 = v41 * 3.14159265 * *(float *)(v7 + 44);
LABEL_7:
      float v20 = *(float *)(v7 + 32);
      float v19 = *(float *)(v7 + 36);
      float v21 = *(float *)(v7 + 40);
      float v22 = v21 * v52.__sinval;
      float v23 = v18 * v52.__cosval;
      __float2 v24 = __sincosf_stret(v23 * 0.5);
      *(float *)&double v25 = v21 * v24.__sinval;
      *(float *)&double v26 = v19 * v24.__sinval;
      float v27 = vmuls_lane_f32(v19 * v52.__sinval, v65, 1);
      float v28 = vmuls_lane_f32(v20 * v52.__sinval, v65, 1);
      float v29 = (float)(v27 - (float)(v22 * v65.f32[0])) + (float)(v27 - (float)(v22 * v65.f32[0]));
      float v30 = (float)((float)(v22 * v16) - v28) + (float)((float)(v22 * v16) - v28);
      float v31 = (float)((float)((float)(v20 * v52.__sinval) * v65.f32[0]) - (float)((float)(v19 * v52.__sinval) * v16))
          + (float)((float)((float)(v20 * v52.__sinval) * v65.f32[0]) - (float)((float)(v19 * v52.__sinval) * v16));
      float v32 = v65.f32[1]
          + (float)((float)((float)(v20 * v52.__sinval) * v30) - (float)((float)(v19 * v52.__sinval) * v29));
      v33.i32[1] = 0;
      *(float *)&double v34 = (float)(v52.__cosval * v29)
                     + (float)(v16
                             + (float)((float)((float)(v19 * v52.__sinval) * v31)
                                     - (float)((float)(v21 * v52.__sinval) * v30)));
      v35.f32[0] = (float)(v52.__cosval * v30)
                 + (float)(v65.f32[0]
                         + (float)((float)((float)(v21 * v52.__sinval) * v29)
                                 - (float)((float)(v20 * v52.__sinval) * v31)));
      v36.f32[0] = (float)(v52.__cosval * v31) + v32;
      v33.f32[0] = (float)(v52.__cosval * 0.0) + v64;
      v37.n128_u32[0] = *(_DWORD *)(v4 + 136);
      v38.n128_u64[0] = 0;
      double result = emit(v4, v6, (float *)v7, 0, *(_DWORD *)(v4 + 124), a3, v37, v38, v34, v35, v36, v33, v39, v40, v26, v25, (float)((float)((float)(v20 * v52.__sinval) * v24.__cosval)+ (float)((float)((float)(v19 * v52.__sinval) * (float)(v21 * v24.__sinval))+ (float)(v52.__cosval * (float)(v20 * v24.__sinval))))
               - (float)((float)(v21 * v52.__sinval) * (float)(v19 * v24.__sinval)),
                 COERCE__INT32((float)((float)((float)(v21 * v52.__sinval) * (float)(v20 * v24.__sinval))+ (float)((float)((float)(v19 * v52.__sinval) * v24.__cosval)+ (float)(v52.__cosval * (float)(v19 * v24.__sinval))))- (float)((float)(v20 * v52.__sinval) * (float)(v21 * v24.__sinval))), COERCE_UNSIGNED_INT32((float)((float)(v52.__cosval * (float)(v21 * v24.__sinval))+ (float)((float)((float)(v21 * v52.__sinval) * v24.__cosval)+ (float)((float)(v20 * v52.__sinval) * (float)(v19 * v24.__sinval))))- (float)((float)(v19 * v52.__sinval) * (float)(v20 * v24.__sinval))), COERCE_UNSIGNED_INT32((float)((float)((float)(v52.__cosval * v24.__cosval)- (float)((float)(v20 * v52.__sinval) * (float)(v20 * v24.__sinval)))- (float)((float)(v21 * v52.__sinval) * (float)(v21 * v24.__sinval)))- (float)((float)(v19 * v52.__sinval) * (float)(v19 * v24.__sinval))));
      float v9 = 0.5;
      float v6 = result;
      v7 += 8 * *(int *)(v4 + 124) + 84;
      ++v5;
      float v8 = 1.0;
      float v10 = 0.25;
    }
    while (v5 < *(void *)(v4 + 64));
  }
  return result;
}

float *apply_twirl(float *result, float a2, int a3)
{
  if (*((void *)result + 8))
  {
    uint64_t v4 = (uint64_t)result;
    unint64_t v5 = 0;
    float v6 = *(float **)&result[2 * (a3 != 0) + 24];
    float v7 = 1.0;
    float v8 = (float32x2_t *)*((void *)result + 7);
    float v9 = 0.5;
    do
    {
      float32x2_t v57 = *v8;
      float v40 = v8[6].f32[1];
      float v41 = v8[7].f32[0];
      float v42 = fminf(fmaxf(a2 - v40, 0.0), v41);
      float v43 = fminf(fmaxf((float)(a2 + 1.0) - v40, 0.0), v41) - v41;
      float v44 = v40 - (float)(v41 + -1.0);
      BOOL v45 = v44 > a2;
      float v46 = a2 - v44;
      if (!v45) {
        float v46 = 0.0;
      }
      if (v41 <= v7) {
        float v46 = v43;
      }
      if (a2 < 0.0) {
        float v47 = v46;
      }
      else {
        float v47 = v42;
      }
      double v48 = -(v8[3].f32[1] * -3.14159265 * v47);
      if (a3 >= 0) {
        double v48 = v8[3].f32[1] * -3.14159265 * v47;
      }
      float v49 = v48;
      __float2 v50 = __sincosf_stret(v49 * v9);
      float32x2_t v51 = v8[2];
      float v13 = v8[3].f32[0];
      if (v47 < 0.25)
      {
        float v10 = fminf(fmaxf(v47 * 4.0, 0.0), v7);
        float v11 = (float)(v10 * v10) * (float)(3.0 - (float)(v10 + v10));
        float v12 = v57.f32[0];
        float32x2_t v55 = vadd_f32(vmul_n_f32(v51, v11), vmul_n_f32(v57, v7 - v11));
        float v13 = (float)(v13 * v11) + (float)((float)(v7 - v11) * 0.0);
        float v14 = v11 + (float)(v7 - v11);
      }
      else
      {
        if (v47 < 0.75)
        {
          double v15 = v57.f32[0] * 3.14159265;
          float v56 = 1.0;
          float v16 = 0.5;
          float32x2_t v55 = v8[2];
          goto LABEL_5;
        }
        float v52 = fminf(fmaxf((float)(v47 + -0.75) * 4.0, 0.0), v7);
        float v53 = (float)(v52 * v52) * (float)(3.0 - (float)(v52 + v52));
        float v12 = v57.f32[0];
        float32x2_t v55 = vadd_f32(vmul_n_f32(v57, v53), vmul_n_f32(v51, v7 - v53));
        float v13 = (float)(v53 * 0.0) + (float)(v13 * (float)(v7 - v53));
        float v14 = v53 + (float)(v7 - v53);
      }
      float v56 = v14;
      double v15 = v12 * 3.14159265 * v8[5].f32[1];
      float v16 = 0.5;
LABEL_5:
      float v18 = v8[4].f32[0];
      float v17 = v8[4].f32[1];
      float v19 = v17 * v50.__sinval;
      float v20 = v8[5].f32[0];
      float v21 = v15 * v50.__cosval;
      __float2 v22 = __sincosf_stret(v21 * v16);
      *(float *)&double v23 = v20 * v22.__sinval;
      *(float *)&double v24 = v17 * v22.__sinval;
      float v25 = vmuls_lane_f32(v20 * v50.__sinval, v55, 1);
      float v26 = vmuls_lane_f32(v18 * v50.__sinval, v55, 1);
      float v27 = (float)((float)(v19 * v13) - v25) + (float)((float)(v19 * v13) - v25);
      float v28 = (float)((float)((float)(v20 * v50.__sinval) * v55.f32[0]) - (float)((float)(v18 * v50.__sinval) * v13))
          + (float)((float)((float)(v20 * v50.__sinval) * v55.f32[0]) - (float)((float)(v18 * v50.__sinval) * v13));
      float v29 = (float)(v26 - (float)(v19 * v55.f32[0])) + (float)(v26 - (float)(v19 * v55.f32[0]));
      float v30 = v55.f32[1]
          + (float)((float)((float)(v20 * v50.__sinval) * v27) - (float)((float)(v18 * v50.__sinval) * v29));
      float v31 = v13 + (float)((float)((float)(v18 * v50.__sinval) * v28) - (float)((float)(v17 * v50.__sinval) * v27));
      *(float *)&double v32 = (float)(v50.__cosval * v27)
                     + (float)(v55.f32[0]
                             + (float)((float)((float)(v17 * v50.__sinval) * v29)
                                     - (float)((float)(v20 * v50.__sinval) * v28)));
      v33.f32[0] = (float)(v50.__cosval * v28) + v30;
      v34.f32[0] = (float)(v50.__cosval * v29) + v31;
      v35.f32[0] = (float)(v50.__cosval * 0.0) + v56;
      v36.n128_u32[0] = *(_DWORD *)(v4 + 136);
      v37.n128_u64[0] = 0;
      double result = emit(v4, v6, (float *)v8, 0, *(_DWORD *)(v4 + 124), a3, v36, v37, v32, v33, v34, v35, v38, v39, v24, v23, (float)((float)((float)(v18 * v50.__sinval) * v22.__cosval)+ (float)((float)((float)(v17 * v50.__sinval) * (float)(v20 * v22.__sinval))+ (float)(v50.__cosval * (float)(v18 * v22.__sinval))))
               - (float)((float)(v20 * v50.__sinval) * (float)(v17 * v22.__sinval)),
                 COERCE__INT32((float)((float)((float)(v20 * v50.__sinval) * (float)(v18 * v22.__sinval))+ (float)((float)((float)(v17 * v50.__sinval) * v22.__cosval)+ (float)(v50.__cosval * (float)(v17 * v22.__sinval))))- (float)((float)(v18 * v50.__sinval) * (float)(v20 * v22.__sinval))), COERCE_UNSIGNED_INT32((float)((float)(v50.__cosval * (float)(v20 * v22.__sinval))+ (float)((float)((float)(v20 * v50.__sinval) * v22.__cosval)+ (float)((float)(v18 * v50.__sinval) * (float)(v17 * v22.__sinval))))- (float)((float)(v17 * v50.__sinval) * (float)(v18 * v22.__sinval))), COERCE_UNSIGNED_INT32((float)((float)((float)(v50.__cosval * v22.__cosval)- (float)((float)(v18 * v50.__sinval) * (float)(v18 * v22.__sinval)))- (float)((float)(v20 * v50.__sinval) * (float)(v20 * v22.__sinval)))- (float)((float)(v17 * v50.__sinval) * (float)(v17 * v22.__sinval))));
      float v9 = 0.5;
      float v6 = result;
      float v8 = (float32x2_t *)((char *)v8 + 8 * *(int *)(v4 + 124) + 84);
      ++v5;
      float v7 = 1.0;
    }
    while (v5 < *(void *)(v4 + 64));
  }
  return result;
}

float *apply_test(float *result, float a2, int a3)
{
  if (*((void *)result + 8))
  {
    uint64_t v5 = (uint64_t)result;
    unint64_t v6 = 0;
    float v7 = *(float **)&result[2 * (a3 != 0) + 24];
    float v8 = (float *)*((void *)result + 7);
    float v33 = a2 + 1.0;
    do
    {
      float v9 = v8[1];
      float v34 = *v8;
      float v10 = v8[13];
      float v11 = v8[14];
      float v12 = fminf(fmaxf(a2 - v10, 0.0), v11);
      float v13 = fminf(fmaxf(v33 - v10, 0.0), v11) - v11;
      float v14 = v10 - (float)(v11 + -1.0);
      if (v14 <= a2) {
        float v15 = 0.0;
      }
      else {
        float v15 = a2 - v14;
      }
      if (v11 <= 1.0) {
        float v15 = v13;
      }
      if (a2 < 0.0) {
        float v16 = v15;
      }
      else {
        float v16 = v12;
      }
      double v17 = -(v8[11] * 6.28318531 * v16);
      if (a3 >= 0) {
        double v17 = v8[11] * 6.28318531 * v16;
      }
      float v18 = v17;
      __float2 v19 = __sincosf_stret(v18 * 0.5);
      float v20 = v8[8] * v19.__sinval;
      *(float *)&__int32 v21 = v8[9] * v19.__sinval;
      *(float *)&unsigned __int32 v22 = v8[10] * v19.__sinval;
      v23.n128_f64[0] = sin((float)(v16 + v16) * 3.14159265);
      v23.n128_f32[0] = v23.n128_f64[0];
      v24.f32[0] = v9 * (float)((float)(v23.n128_f32[0] * 0.35) + 1.0);
      v25.f32[0] = 0.0 - v23.n128_f32[0];
      v23.n128_u32[0] = *(_DWORD *)(v5 + 136);
      v26.n128_u64[0] = 0;
      v27.i32[0] = 1.0;
      *(float *)&double v28 = v34;
      double result = emit(v5, v7, v8, 0, *(_DWORD *)(v5 + 124), a3, v23, v26, v28, v24, v25, v27, v29, v30, v31, v32, v20, v21, v22,
                 LODWORD(v19.__cosval));
      float v7 = result;
      v8 += 2 * *(int *)(v5 + 124) + 21;
      ++v6;
    }
    while (v6 < *(void *)(v5 + 64));
  }
  return result;
}

int8x16_t HGColorGammaLUTInfo::HGColorGammaLUTInfo(uint64_t a1, uint64_t a2, int a3, int a4, float a5, float a6, __n128 a7, int8x16_t a8, int8x16_t a9, int8x16_t a10, __n128 a11, int8x16_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int8x16_t a17)
{
  uint64_t v18 = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *(void *)uint64_t v18 = &unk_1F10E16B8;
  __n128 v19 = a7;
  v19.n128_u32[3] = a8.i32[0];
  *(_DWORD *)(v18 + 36) = a3;
  *(__n128 *)(v18 + 40) = v19;
  *(int8x16_t *)(v18 + 56) = vextq_s8(vextq_s8(a8, a8, 0xCuLL), a9, 8uLL);
  *(int8x16_t *)(v18 + 72) = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a9, (int32x4_t)a9), a10, 0xCuLL);
  __n128 v20 = a11;
  v20.n128_u32[3] = a12.i32[0];
  *(__n128 *)(v18 + 88) = v20;
  int8x16_t result = vextq_s8(vextq_s8(a12, a12, 0xCuLL), a17, 8uLL);
  *(int8x16_t *)(v18 + 104) = result;
  *(_DWORD *)(v18 + 120) = a17.i32[2];
  return result;
}

float *HGColorGammaLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (result)
  {
    uint64_t v4 = result;
    int8x16_t result = (float *)HGApplyNDLUTInfo::isEqual(a1, result);
    if (result)
    {
      if (*(_DWORD *)(a1 + 36) == *((_DWORD *)v4 + 9))
      {
        if (*(float *)(a1 + 40) == v4[10]
          && *(float *)(a1 + 44) == v4[11]
          && *(float *)(a1 + 48) == v4[12]
          && *(float *)(a1 + 52) == v4[13]
          && *(float *)(a1 + 56) == v4[14]
          && *(float *)(a1 + 60) == v4[15]
          && *(float *)(a1 + 64) == v4[16]
          && *(float *)(a1 + 68) == v4[17]
          && *(float *)(a1 + 72) == v4[18]
          && *(float *)(a1 + 76) == v4[19]
          && *(float *)(a1 + 80) == v4[20]
          && *(float *)(a1 + 84) == v4[21]
          && *(float *)(a1 + 88) == v4[22]
          && *(float *)(a1 + 92) == v4[23]
          && *(float *)(a1 + 96) == v4[24]
          && *(float *)(a1 + 100) == v4[25]
          && *(float *)(a1 + 104) == v4[26]
          && *(float *)(a1 + 108) == v4[27]
          && *(float *)(a1 + 112) == v4[28]
          && *(float *)(a1 + 116) == v4[29])
        {
          return (float *)(*(float *)(a1 + 120) == v4[30]);
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void HGColorGammaLUTInfo::colorAtIndex(HGColorGammaLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  switch(*((_DWORD *)this + 9))
  {
    case 0:
      if (a2 >= 0.0)
      {
        *a5 = powf(a2, *((float *)this + 10));
        *a6 = powf(a2, *((float *)this + 11));
        float v15 = powf(a2, *((float *)this + 12));
      }
      else
      {
        float v14 = -a2;
        *a5 = -powf(-a2, *((float *)this + 10));
        *a6 = -powf(v14, *((float *)this + 11));
        float v15 = -powf(v14, *((float *)this + 12));
      }
      goto LABEL_36;
    case 1:
      double v16 = a2;
      float v17 = *((float *)this + 16);
      float v18 = *((float *)this + 13);
      float v19 = 0.0;
      float v20 = 0.0;
      if (-v17 / v18 <= a2) {
        float v20 = powf(v17 + (float)(v18 * a2), *((float *)this + 10));
      }
      *a5 = v20;
      float v21 = *((float *)this + 17);
      float v22 = *((float *)this + 14);
      if (-v21 / v22 <= v16) {
        float v19 = powf(v21 + (float)(v22 * a2), *((float *)this + 11));
      }
      *a6 = v19;
      float v23 = *((float *)this + 18);
      float v24 = *((float *)this + 15);
      float v15 = 0.0;
      if (-v23 / v24 > v16) {
        goto LABEL_36;
      }
      float v25 = v23 + (float)(v24 * a2);
      goto LABEL_16;
    case 2:
      double v26 = a2;
      float v27 = *((float *)this + 16);
      float v28 = *((float *)this + 13);
      if (-v27 / v28 <= a2) {
        float v29 = powf(v27 + (float)(v28 * a2), *((float *)this + 10)) + *((float *)this + 19);
      }
      else {
        float v29 = *((float *)this + 19);
      }
      *a5 = v29;
      float v32 = *((float *)this + 17);
      float v33 = *((float *)this + 14);
      if (-v32 / v33 <= v26) {
        float v34 = powf(v32 + (float)(v33 * a2), *((float *)this + 11)) + *((float *)this + 20);
      }
      else {
        float v34 = *((float *)this + 20);
      }
      *a6 = v34;
      float v35 = *((float *)this + 18);
      float v36 = *((float *)this + 15);
      if (-v35 / v36 > v26)
      {
        float v15 = *((float *)this + 21);
        goto LABEL_36;
      }
      float v30 = powf(v35 + (float)(v36 * a2), *((float *)this + 12));
      float v31 = *((float *)this + 21);
      goto LABEL_35;
    case 3:
      if (*((float *)this + 22) <= a2)
      {
        *a5 = powf((float)(*((float *)this + 13) * a2) + *((float *)this + 16), *((float *)this + 10));
        if (*((float *)this + 23) <= a2)
        {
LABEL_14:
          *a6 = powf((float)(*((float *)this + 14) * a2) + *((float *)this + 17), *((float *)this + 11));
          if (*((float *)this + 24) <= a2) {
            goto LABEL_15;
          }
          goto LABEL_27;
        }
      }
      else
      {
        *a5 = *((float *)this + 19) * a2;
        if (*((float *)this + 23) <= a2) {
          goto LABEL_14;
        }
      }
      *a6 = *((float *)this + 20) * a2;
      if (*((float *)this + 24) <= a2)
      {
LABEL_15:
        float v25 = (float)(*((float *)this + 15) * a2) + *((float *)this + 18);
LABEL_16:
        float v15 = powf(v25, *((float *)this + 12));
        goto LABEL_36;
      }
LABEL_27:
      float v15 = *((float *)this + 21) * a2;
      goto LABEL_36;
    case 4:
      if (*((float *)this + 22) > a2)
      {
        *a5 = (float)(*((float *)this + 19) * a2) + *((float *)this + 28);
        if (*((float *)this + 23) <= a2) {
          goto LABEL_19;
        }
LABEL_29:
        *a6 = (float)(*((float *)this + 20) * a2) + *((float *)this + 29);
        if (*((float *)this + 24) <= a2) {
          goto LABEL_20;
        }
        goto LABEL_30;
      }
      *a5 = powf((float)(*((float *)this + 13) * a2) + *((float *)this + 16), *((float *)this + 10))
          + *((float *)this + 25);
      if (*((float *)this + 23) > a2) {
        goto LABEL_29;
      }
LABEL_19:
      *a6 = powf((float)(*((float *)this + 14) * a2) + *((float *)this + 17), *((float *)this + 11))
          + *((float *)this + 26);
      if (*((float *)this + 24) <= a2)
      {
LABEL_20:
        float v30 = powf((float)(*((float *)this + 15) * a2) + *((float *)this + 18), *((float *)this + 12));
        float v31 = *((float *)this + 27);
        goto LABEL_35;
      }
LABEL_30:
      float v30 = *((float *)this + 21) * a2;
      float v31 = *((float *)this + 30);
LABEL_35:
      float v15 = v30 + v31;
LABEL_36:
      *a7 = v15;
LABEL_37:
      *a8 = 1.0;
      return;
    default:
      goto LABEL_37;
  }
}

double HGArriLogCDefaultToneCurveLUTInfo::HGArriLogCDefaultToneCurveLUTInfo(uint64_t a1, uint64_t a2, char a3, int a4, float a5, float a6)
{
  uint64_t v7 = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *(void *)uint64_t v7 = &unk_1F10E1708;
  *(unsigned char *)(v7 + 120) = a3;
  *(_OWORD *)(v7 + 40) = xmmword_1B8348150;
  *(_OWORD *)(v7 + 88) = xmmword_1B8348160;
  *(_OWORD *)(v7 + 56) = xmmword_1B8348170;
  *(_OWORD *)(v7 + 104) = xmmword_1B8348180;
  double result = -4.04163265;
  *(_OWORD *)(v7 + 72) = xmmword_1B8348190;
  return result;
}

unsigned __int8 *HGArriLogCDefaultToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (result)
  {
    uint64_t v4 = result;
    double result = (unsigned __int8 *)HGApplyNDLUTInfo::isEqual(a1, result);
    if (result) {
      return (unsigned __int8 *)(*(unsigned __int8 *)(a1 + 120) == v4[120]);
    }
  }
  return result;
}

void HGArriLogCDefaultToneCurveLUTInfo::colorAtIndex(HGArriLogCDefaultToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  float v12 = 0.0;
  if (a2 > 0.0)
  {
    float v12 = 1.0;
    if (a2 < 1.0)
    {
      double v13 = a2;
      if (a2 >= 0.256)
      {
        if (v13 >= 0.391)
        {
          if (v13 >= 0.57)
          {
            if (v13 >= 0.65)
            {
              uint64_t v14 = 4;
              if (a2 >= 1.0) {
                uint64_t v14 = 5;
              }
            }
            else
            {
              uint64_t v14 = 3;
            }
          }
          else
          {
            uint64_t v14 = 2;
          }
        }
        else
        {
          uint64_t v14 = 1;
        }
      }
      else
      {
        uint64_t v14 = 0;
      }
      uint64_t v15 = v14;
      double v16 = *(double *)&HGArriLogCDefaultToneCurveLUTInfo::a0[v15]
          + (v13 - *(double *)&HGArriLogCDefaultToneCurveLUTInfo::xi[v15])
          * (*(double *)&HGArriLogCDefaultToneCurveLUTInfo::a1[v15]
           + (v13 - *(double *)&HGArriLogCDefaultToneCurveLUTInfo::xi[v15])
           * (*(double *)((char *)this + v15 * 8 + 80) * (v13 - *(double *)&HGArriLogCDefaultToneCurveLUTInfo::xi[v15])
            + *(double *)((char *)this + v15 * 8 + 40)));
      if (*((unsigned char *)this + 120))
      {
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2108, memory_order_acquire) & 1) == 0)
        {
          double v20 = v16;
          int v19 = __cxa_guard_acquire(&qword_1EB9A2108);
          double v16 = v20;
          if (v19)
          {
            _MergedGlobals_17 = 0x3F732E5BF55474D3;
            __cxa_guard_release(&qword_1EB9A2108);
            double v16 = v20;
          }
        }
        if (v16 > 0.0562318841)
        {
          double v16 = (v16 + 0.097) / 1.097;
          long double v17 = 2.725;
LABEL_21:
          double v18 = pow(v16, v17);
          goto LABEL_22;
        }
        double v18 = v16 / 0.0562318841 * *(double *)&_MergedGlobals_17;
      }
      else
      {
        if (v16 >= 0.0)
        {
          long double v17 = 2.4;
          goto LABEL_21;
        }
        double v18 = -pow(-v16, 2.4);
      }
LABEL_22:
      float v12 = v18;
    }
  }
  *a5 = v12;
  *a6 = v12;
  *a7 = v12;
  *a8 = 1.0;
}

uint64_t HGArriLogCLinearizationLUTInfo::HGArriLogCLinearizationLUTInfo(uint64_t a1, uint64_t a2, unsigned int a3, int a4, float a5, float a6)
{
  uint64_t v8 = 1;
  uint64_t v9 = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *(void *)uint64_t v9 = &unk_1F10E1758;
  *(_DWORD *)(v9 + 36) = 0;
  if (a3 >= 0xB4)
  {
    *(_DWORD *)(a1 + 36) = 1;
    if (a3 >= 0xE1)
    {
      uint64_t v8 = 2;
      *(_DWORD *)(a1 + 36) = 2;
      if (a3 >= 0x11D)
      {
        uint64_t v8 = 3;
        *(_DWORD *)(a1 + 36) = 3;
        if (a3 >= 0x168)
        {
          uint64_t v8 = 4;
          *(_DWORD *)(a1 + 36) = 4;
          if (a3 >= 0x1C2)
          {
            uint64_t v8 = 5;
            *(_DWORD *)(a1 + 36) = 5;
            if (a3 >= 0x23A)
            {
              uint64_t v8 = 6;
              *(_DWORD *)(a1 + 36) = 6;
              if (a3 >= 0x2D0)
              {
                uint64_t v8 = 7;
                *(_DWORD *)(a1 + 36) = 7;
                if (a3 >= 0x384)
                {
                  uint64_t v8 = 8;
                  *(_DWORD *)(a1 + 36) = 8;
                  if (a3 >= 0x474)
                  {
                    if (a3 < 0x5A0) {
                      int v10 = 9;
                    }
                    else {
                      int v10 = 10;
                    }
                    *(_DWORD *)(a1 + 36) = v10;
                    if (a3 < 0x5A0) {
                      uint64_t v8 = 9;
                    }
                    else {
                      uint64_t v8 = 10;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  float v11 = (double *)((char *)&HGArriLogCLinearizationLUTInfo::linearizationParameters + 56 * v8);
  double v12 = v11[1];
  double v13 = v11[3];
  double v14 = v11[4];
  double v15 = v11[5];
  double v16 = v11[6];
  *(long double *)(a1 + 40) = (v14 + v13 * log10(v12 * 5.55555556 + v11[2]) + v12 * v15 + v16) * 0.5;
  *(double *)(a1 + 48) = 2.30258509 / v13;
  return a1;
}

_DWORD *HGArriLogCLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (result)
  {
    uint64_t v4 = result;
    double result = HGApplyNDLUTInfo::isEqual(a1, result);
    if (result) {
      return (_DWORD *)(*(_DWORD *)(a1 + 36) == v4[9]);
    }
  }
  return result;
}

float HGArriLogCLinearizationLUTInfo::colorAtIndex(HGArriLogCLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  double v12 = a2;
  if (a2 > 1.0) {
    double v12 = 1.0;
  }
  if (a2 >= 0.0) {
    double v13 = v12;
  }
  else {
    double v13 = 0.0;
  }
  unsigned int v14 = *((_DWORD *)this + 9);
  if (v13 <= *((double *)this + 5))
  {
    double v17 = (v13 - HGArriLogCLinearizationLUTInfo::linearizationParameters[7 * v14 + 6])
        / HGArriLogCLinearizationLUTInfo::linearizationParameters[7 * v14 + 5];
  }
  else
  {
    double v15 = &HGArriLogCLinearizationLUTInfo::linearizationParameters[7 * v14];
    double v16 = v15[2];
    double v17 = (exp((v13 - v15[4]) * *((double *)this + 6)) - v16) / 5.55555556;
  }
  float result = v17 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGArriLogC4LinearizationLUTInfo::HGArriLogC4LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E17A8;
  return result;
}

void *HGArriLogC4LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGArriLogC4LinearizationLUTInfo::colorAtIndex(HGArriLogC4LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2118, memory_order_acquire) & 1) == 0)
  {
    float v17 = a2;
    int v15 = __cxa_guard_acquire(&qword_1EB9A2118);
    a2 = v17;
    if (v15)
    {
      qword_1EB9A2110 = 0x3FBD14B4E7E63D19;
      __cxa_guard_release(&qword_1EB9A2118);
      a2 = v17;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2128, memory_order_acquire) & 1) == 0)
  {
    float v18 = a2;
    int v16 = __cxa_guard_acquire(&qword_1EB9A2128);
    a2 = v18;
    if (v16)
    {
      qword_1EB9A2120 = 0xBF927D887F3231C4;
      __cxa_guard_release(&qword_1EB9A2128);
      a2 = v18;
    }
  }
  double v12 = 0.0;
  if (a2 < 0.0 || (double v12 = 1.0, a2 > 1.0) || (double v12 = a2, a2 >= 0.0)) {
    double v13 = (exp2((v12 + -0.0928641251) * 14.0 / 0.907135875 + 6.0) + -64.0) / 2231.82631;
  }
  else {
    double v13 = *(double *)&qword_1EB9A2110 * v12 + *(double *)&qword_1EB9A2120;
  }
  float result = v13 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

double HGCanonLogToneCurveLUTInfo::kMinLogGamma(HGCanonLogToneCurveLUTInfo *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2138, memory_order_acquire) & 1) != 0
    || !__cxa_guard_acquire(&qword_1EB9A2138))
  {
    return *(double *)&qword_1EB9A2130;
  }
  qword_1EB9A2130 = 0x3FA371775C883CCDLL;
  __cxa_guard_release(&qword_1EB9A2138);
  return *(double *)&qword_1EB9A2130;
}

double HGCanonLogToneCurveLUTInfo::kMaxLogGamma(HGCanonLogToneCurveLUTInfo *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2148, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A2148))
  {
    qword_1EB9A2140 = 0x3FF33A573B3EED8ALL;
    __cxa_guard_release(&qword_1EB9A2148);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2158, memory_order_acquire) & 1) != 0
    || !__cxa_guard_acquire(&qword_1EB9A2158))
  {
    return *(double *)&qword_1EB9A2150;
  }
  *(double *)&qword_1EB9A2150 = log10(*(double *)&qword_1EB9A2140 * 10.1596 + 1.0) * 0.529136 + 0.0730597;
  __cxa_guard_release(&qword_1EB9A2158);
  return *(double *)&qword_1EB9A2150;
}

void *HGCanonLogToneCurveLUTInfo::HGCanonLogToneCurveLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E17F8;
  return result;
}

void *HGCanonLogToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGCanonLogToneCurveLUTInfo::colorAtIndex(HGCanonLogToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2168, memory_order_acquire) & 1) == 0)
  {
    float v25 = a2;
    int v24 = __cxa_guard_acquire(&qword_1EB9A2168);
    a2 = v25;
    if (v24)
    {
      qword_1EB9A2160 = 0x40116808484C167BLL;
      __cxa_guard_release(&qword_1EB9A2168);
      a2 = v25;
    }
  }
  double v12 = a2;
  BOOL v13 = v12 < 0.0730597;
  BOOL v14 = v12 < 0.0730597;
  double v15 = 0.0730597 - v12;
  double v16 = v12 + -0.0730597;
  if (v13) {
    double v16 = v15;
  }
  double v17 = dbl_1B83481A0[v14];
  long double v18 = (exp(v16 * *(double *)&qword_1EB9A2160) + -1.0) / v17;
  if (v18 >= 0.018)
  {
    double v20 = pow(v18, 0.45) * 1.099 + -0.099;
    long double v21 = 1.09474886;
    if (v20 > 1.09474886)
    {
LABEL_11:
      double v22 = pow(v21, 1.956);
      goto LABEL_12;
    }
  }
  else
  {
    double v19 = -0.0730593607;
    if (v18 <= -0.018) {
      goto LABEL_10;
    }
    double v20 = v18 * 4.5;
    if (v18 * 4.5 < -0.0730593607) {
      goto LABEL_10;
    }
  }
  long double v21 = v20;
  double v19 = v20;
  if (v20 >= 0.0) {
    goto LABEL_11;
  }
LABEL_10:
  double v22 = -pow(-v19, 1.956);
LABEL_12:
  float result = v22;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGCanonLogLinearizationLUTInfo::HGCanonLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1848;
  return result;
}

void *HGCanonLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGCanonLogLinearizationLUTInfo::colorAtIndex(HGCanonLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  double v12 = a2;
  double v13 = -0.0730593607;
  if (v12 >= -0.0730593607)
  {
    double v13 = v12;
    if (v12 > 1.09474886) {
      double v13 = 1.09474886;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2178, memory_order_acquire) & 1) == 0)
  {
    double v21 = v13;
    int v20 = __cxa_guard_acquire(&qword_1EB9A2178);
    double v13 = v21;
    if (v20)
    {
      qword_1EB9A2170 = 0x40116808484C167BLL;
      __cxa_guard_release(&qword_1EB9A2178);
      double v13 = v21;
    }
  }
  BOOL v14 = v13 < 0.0730597;
  BOOL v15 = v13 < 0.0730597;
  double v16 = 0.0730597 - v13;
  double v17 = v13 + -0.0730597;
  if (v14) {
    double v17 = v16;
  }
  double v18 = dbl_1B83481A0[v15];
  float result = (exp(v17 * *(double *)&qword_1EB9A2170) + -1.0) / v18;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGCanonLog2LinearizationLUTInfo::HGCanonLog2LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1898;
  return result;
}

void *HGCanonLog2LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGCanonLog2LinearizationLUTInfo::colorAtIndex(HGCanonLog2LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  double v12 = a2;
  double v13 = -0.0730593607;
  if (v12 >= -0.0730593607 && ((v14 = 1.09474886, v12 > 1.09474886) || (v14 = v12, double v13 = v12, v12 >= 0.035388128)))
  {
    double v15 = v14 + -0.035388128;
    double v16 = 87.0993755;
  }
  else
  {
    double v15 = 0.035388128 - v13;
    double v16 = -87.0993755;
  }
  float result = (exp(v15 / 0.122411586) + -1.0) / v16;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGCanonLog3LinearizationLUTInfo::HGCanonLog3LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E18E8;
  return result;
}

void *HGCanonLog3LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGCanonLog3LinearizationLUTInfo::colorAtIndex(HGCanonLog3LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2188, memory_order_acquire) & 1) == 0)
  {
    float v20 = a2;
    int v17 = __cxa_guard_acquire(&qword_1EB9A2188);
    a2 = v20;
    if (v17)
    {
      qword_1EB9A2180 = 0x3FA4DEB50262DEBFLL;
      __cxa_guard_release(&qword_1EB9A2188);
      a2 = v20;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2198, memory_order_acquire) & 1) == 0)
  {
    float v21 = a2;
    int v18 = __cxa_guard_acquire(&qword_1EB9A2198);
    a2 = v21;
    if (v18)
    {
      qword_1EB9A2190 = 0x3FBAF8AEDB215573;
      __cxa_guard_release(&qword_1EB9A2198);
      a2 = v21;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A21A8, memory_order_acquire) & 1) == 0)
  {
    float v22 = a2;
    int v19 = __cxa_guard_acquire(&qword_1EB9A21A8);
    a2 = v22;
    if (v19)
    {
      qword_1EB9A21A0 = 0x401579709D43F5C0;
      __cxa_guard_release(&qword_1EB9A21A8);
      a2 = v22;
    }
  }
  double v12 = a2;
  double v13 = -0.0730593607;
  if (v12 >= -0.0730593607)
  {
    double v13 = v12;
    if (v12 > 1.09474886) {
      double v13 = 1.09474886;
    }
  }
  if (v13 >= *(double *)&qword_1EB9A2180)
  {
    if (v13 <= *(double *)&qword_1EB9A2190)
    {
      double v14 = v13 + -0.073059361;
      double v15 = 2.3069815;
    }
    else
    {
      double v14 = exp((v13 + -0.069886632) * *(double *)&qword_1EB9A21A0) + -1.0;
      double v15 = 14.98325;
    }
  }
  else
  {
    double v14 = exp((0.07623209 - v13) * *(double *)&qword_1EB9A21A0) + -1.0;
    double v15 = -14.98325;
  }
  float result = v14 / v15;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGSonySLog2LinearizationLUTInfo::HGSonySLog2LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1938;
  return result;
}

void *HGSonySLog2LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGSonySLog2LinearizationLUTInfo::colorAtIndex(HGSonySLog2LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  double v12 = a2;
  double v13 = -0.0730593607;
  if (v12 >= -0.0730593607)
  {
    double v13 = v12;
    if (v12 > 1.09474886) {
      double v13 = 1.09474886;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A21B8, memory_order_acquire) & 1) == 0)
  {
    double v19 = v13;
    int v17 = __cxa_guard_acquire(&qword_1EB9A21B8);
    double v13 = v19;
    if (v17)
    {
      qword_1EB9A21B0 = 0x3F9EB8A3FBF49AE0;
      __cxa_guard_release(&qword_1EB9A21B8);
      double v13 = v19;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A21C8, memory_order_acquire) & 1) == 0)
  {
    double v20 = v13;
    int v18 = __cxa_guard_acquire(&qword_1EB9A21C8);
    double v13 = v20;
    if (v18)
    {
      qword_1EB9A21C0 = 0x4015492995272697;
      __cxa_guard_release(&qword_1EB9A21C8);
      double v13 = v20;
    }
  }
  if (v13 >= *(double *)&qword_1EB9A21B0)
  {
    double v14 = exp((v13 + -0.646596) * *(double *)&qword_1EB9A21C0) + -0.037584;
    double v15 = 1.41290323;
  }
  else
  {
    double v14 = v13 - *(double *)&qword_1EB9A21B0;
    double v15 = 0.282580645;
  }
  float result = v14 * v15;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGSonySLog3LinearizationLUTInfo::HGSonySLog3LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1988;
  return result;
}

void *HGSonySLog3LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGSonySLog3LinearizationLUTInfo::colorAtIndex(HGSonySLog3LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A21D8, memory_order_acquire) & 1) == 0)
  {
    float v19 = a2;
    int v16 = __cxa_guard_acquire(&qword_1EB9A21D8);
    a2 = v19;
    if (v16)
    {
      qword_1EB9A21D0 = 0x406566BABBEF8B7ALL;
      __cxa_guard_release(&qword_1EB9A21D8);
      a2 = v19;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A21E8, memory_order_acquire) & 1) == 0)
  {
    float v20 = a2;
    int v17 = __cxa_guard_acquire(&qword_1EB9A21E8);
    a2 = v20;
    if (v17)
    {
      *(double *)&qword_1EB9A21E0 = *(double *)&qword_1EB9A21D0 + -95.0;
      __cxa_guard_release(&qword_1EB9A21E8);
      a2 = v20;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A21F8, memory_order_acquire) & 1) == 0)
  {
    float v21 = a2;
    int v18 = __cxa_guard_acquire(&qword_1EB9A21F8);
    a2 = v21;
    if (v18)
    {
      qword_1EB9A21F0 = 0x3F820882EBA5480ALL;
      __cxa_guard_release(&qword_1EB9A21F8);
      a2 = v21;
    }
  }
  double v12 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0) {
      double v12 = a2;
    }
    else {
      double v12 = 1.0;
    }
  }
  double v13 = v12 * 1023.0;
  if (v12 * 1023.0 >= *(double *)&qword_1EB9A21D0) {
    double v14 = exp((v13 + -420.0) * *(double *)&qword_1EB9A21F0) * 0.19 + -0.01;
  }
  else {
    double v14 = (v13 + -95.0) / *(double *)&qword_1EB9A21E0 * 0.01125;
  }
  float result = v14 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGPanasonicVLogLinearizationLUTInfo::HGPanasonicVLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E19D8;
  return result;
}

void *HGPanasonicVLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGPanasonicVLogLinearizationLUTInfo::colorAtIndex(HGPanasonicVLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2208, memory_order_acquire) & 1) == 0)
  {
    float v17 = a2;
    int v15 = __cxa_guard_acquire(&qword_1EB9A2208);
    a2 = v17;
    if (v15)
    {
      qword_1EB9A2200 = 0x3FC72B00BE1A1A7DLL;
      __cxa_guard_release(&qword_1EB9A2208);
      a2 = v17;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2218, memory_order_acquire) & 1) == 0)
  {
    float v18 = a2;
    int v16 = __cxa_guard_acquire(&qword_1EB9A2218);
    a2 = v18;
    if (v16)
    {
      qword_1EB9A2210 = 0x402311635B128422;
      __cxa_guard_release(&qword_1EB9A2218);
      a2 = v18;
    }
  }
  double v12 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      double v12 = a2;
      if (a2 < *(double *)&qword_1EB9A2200) {
        goto LABEL_7;
      }
LABEL_9:
      double v13 = exp((v12 + -0.598206) * *(double *)&qword_1EB9A2210) + -0.00873;
      goto LABEL_10;
    }
    double v12 = 1.0;
  }
  if (v12 >= *(double *)&qword_1EB9A2200) {
    goto LABEL_9;
  }
LABEL_7:
  double v13 = (v12 + -0.125) / 5.6;
LABEL_10:
  float result = v13 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGNikonNLogLinearizationLUTInfo::HGNikonNLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1A28;
  return result;
}

void *HGNikonNLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGNikonNLogLinearizationLUTInfo::colorAtIndex(HGNikonNLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2228, memory_order_acquire) & 1) == 0)
  {
    float v16 = a2;
    int v15 = __cxa_guard_acquire(&qword_1EB9A2228);
    a2 = v16;
    if (v15)
    {
      qword_1EB9A2220 = 0x3FDC42A6121F81AALL;
      __cxa_guard_release(&qword_1EB9A2228);
      a2 = v16;
    }
  }
  double v12 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      double v12 = a2;
      if (a2 < *(double *)&qword_1EB9A2220) {
        goto LABEL_6;
      }
LABEL_8:
      double v13 = exp((v12 + -0.605083089) / 0.146627566);
      goto LABEL_9;
    }
    double v12 = 1.0;
  }
  if (v12 >= *(double *)&qword_1EB9A2220) {
    goto LABEL_8;
  }
LABEL_6:
  double v13 = v12 / 0.635386119 * (v12 / 0.635386119 * (v12 / 0.635386119)) + -0.0075;
LABEL_9:
  float result = v13 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

uint64_t HGBMDFilmLinearizationLUTInfo::HGBMDFilmLinearizationLUTInfo(uint64_t a1, uint64_t a2, char a3, int a4, float a5, float a6)
{
  uint64_t result = HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a4, a5, a6);
  *(void *)uint64_t result = &unk_1F10E1A78;
  *(unsigned char *)(result + 36) = a3;
  return result;
}

unsigned __int8 *HGBMDFilmLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (result)
  {
    uint64_t v4 = result;
    uint64_t result = (unsigned __int8 *)HGApplyNDLUTInfo::isEqual(a1, result);
    if (result) {
      return (unsigned __int8 *)(*(unsigned __int8 *)(a1 + 36) == v4[36]);
    }
  }
  return result;
}

float HGBMDFilmLinearizationLUTInfo::colorAtIndex(HGBMDFilmLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  double v12 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      double v12 = a2;
      if (*((unsigned char *)this + 36)) {
        goto LABEL_5;
      }
LABEL_11:
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2238, memory_order_acquire) & 1) == 0)
      {
        double v25 = v12;
        int v21 = __cxa_guard_acquire(&qword_1EB9A2238);
        double v12 = v25;
        if (v21)
        {
          qword_1EB9A2230 = 0x3FBD384ED1A78752;
          __cxa_guard_release(&qword_1EB9A2238);
          double v12 = v25;
        }
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2248, memory_order_acquire) & 1) == 0)
      {
        double v26 = v12;
        int v22 = __cxa_guard_acquire(&qword_1EB9A2248);
        double v12 = v26;
        if (v22)
        {
          qword_1EB9A2240 = 0x40190DFAF2EFA06ALL;
          __cxa_guard_release(&qword_1EB9A2248);
          double v12 = v26;
        }
      }
      if (v12 < *(double *)&qword_1EB9A2230)
      {
        double v13 = v12 + -0.0928641251;
        double v14 = 0.7659482;
        goto LABEL_15;
      }
      double v15 = exp((v12 + -0.3644932) * *(double *)&qword_1EB9A2240);
      double v16 = -0.1806583;
LABEL_17:
      double v17 = v15 + v16;
      goto LABEL_18;
    }
    double v12 = 1.0;
  }
  if (!*((unsigned char *)this + 36)) {
    goto LABEL_11;
  }
LABEL_5:
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2258, memory_order_acquire) & 1) == 0)
  {
    double v23 = v12;
    int v19 = __cxa_guard_acquire(&qword_1EB9A2258);
    double v12 = v23;
    if (v19)
    {
      qword_1EB9A2250 = 0x3FBB97B1767A8EEALL;
      __cxa_guard_release(&qword_1EB9A2258);
      double v12 = v23;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2268, memory_order_acquire) & 1) == 0)
  {
    double v24 = v12;
    int v20 = __cxa_guard_acquire(&qword_1EB9A2268);
    double v12 = v24;
    if (v20)
    {
      qword_1EB9A2260 = 0x400FA32D714B55AELL;
      __cxa_guard_release(&qword_1EB9A2268);
      double v12 = v24;
    }
  }
  if (v12 >= *(double *)&qword_1EB9A2250)
  {
    double v15 = exp((v12 + -0.2982706) * *(double *)&qword_1EB9A2260);
    double v16 = -0.4430254;
    goto LABEL_17;
  }
  double v13 = v12 + -0.0928641251;
  double v14 = 0.5370933;
LABEL_15:
  double v17 = v13 / v14;
LABEL_18:
  float result = v17 * 0.200222469;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGAppleLogLinearizationLUTInfo::HGAppleLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1AC8;
  return result;
}

void *HGAppleLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGAppleLogLinearizationLUTInfo::colorAtIndex(HGAppleLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2278, memory_order_acquire) & 1) == 0)
  {
    float v20 = a2;
    int v18 = __cxa_guard_acquire(&qword_1EB9A2278);
    a2 = v20;
    if (v18)
    {
      qword_1EB9A2270 = 0x3FCAB1F0CDAACC3ELL;
      __cxa_guard_release(&qword_1EB9A2278);
      a2 = v20;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2288, memory_order_acquire) & 1) == 0)
  {
    float v21 = a2;
    int v19 = __cxa_guard_acquire(&qword_1EB9A2288);
    a2 = v21;
    if (v19)
    {
      qword_1EB9A2280 = 0x4020368B277C7D96;
      __cxa_guard_release(&qword_1EB9A2288);
      a2 = v21;
    }
  }
  double v12 = a2;
  if (a2 > 1.0) {
    double v12 = 1.0;
  }
  if (a2 >= 0.0) {
    double v13 = v12;
  }
  else {
    double v13 = 0.0;
  }
  if (v13 >= *(double *)&qword_1EB9A2270)
  {
    double v15 = exp((v13 + -0.69336945) * *(double *)&qword_1EB9A2280);
    double v16 = -0.00964052;
LABEL_13:
    double v14 = v15 + v16;
    goto LABEL_14;
  }
  if (v13 >= 0.0)
  {
    double v15 = sqrt(v13 / 47.2871124);
    double v16 = -0.05641088;
    goto LABEL_13;
  }
  double v14 = -0.05641088;
LABEL_14:
  float result = v14 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGDJIDLogLinearizationLUTInfo::HGDJIDLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1B18;
  return result;
}

void *HGDJIDLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGDJIDLogLinearizationLUTInfo::colorAtIndex(HGDJIDLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2298, memory_order_acquire) & 1) == 0)
  {
    float v18 = a2;
    int v16 = __cxa_guard_acquire(&qword_1EB9A2298);
    a2 = v18;
    if (v16)
    {
      qword_1EB9A2290 = 0x3FC1E81CC48A70B5;
      __cxa_guard_release(&qword_1EB9A2298);
      a2 = v18;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A22A8, memory_order_acquire) & 1) == 0)
  {
    float v19 = a2;
    int v17 = __cxa_guard_acquire(&qword_1EB9A22A8);
    a2 = v19;
    if (v17)
    {
      qword_1EB9A22A0 = 0x4021F1463A0B6A33;
      __cxa_guard_release(&qword_1EB9A22A8);
      a2 = v19;
    }
  }
  double v12 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      double v12 = a2;
      if (a2 > *(double *)&qword_1EB9A2290) {
        goto LABEL_7;
      }
LABEL_9:
      double v13 = v12 + -0.0929;
      double v14 = 6.025;
      goto LABEL_10;
    }
    double v12 = 1.0;
  }
  if (v12 <= *(double *)&qword_1EB9A2290) {
    goto LABEL_9;
  }
LABEL_7:
  double v13 = exp((v12 + -0.584555) * *(double *)&qword_1EB9A22A0) + -0.0108;
  double v14 = 0.9892;
LABEL_10:
  float result = v13 / v14 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGFujifilmFLogLinearizationLUTInfo::HGFujifilmFLogLinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1B68;
  return result;
}

void *HGFujifilmFLogLinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGFujifilmFLogLinearizationLUTInfo::colorAtIndex(HGFujifilmFLogLinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A22B8, memory_order_acquire) & 1) == 0)
  {
    float v18 = a2;
    int v16 = __cxa_guard_acquire(&qword_1EB9A22B8);
    a2 = v18;
    if (v16)
    {
      qword_1EB9A22B0 = 0x3FB9C026A3080D26;
      __cxa_guard_release(&qword_1EB9A22B8);
      a2 = v18;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A22C8, memory_order_acquire) & 1) == 0)
  {
    float v19 = a2;
    int v17 = __cxa_guard_acquire(&qword_1EB9A22C8);
    a2 = v19;
    if (v17)
    {
      qword_1EB9A22C0 = 0x401AB8C38E6C7294;
      __cxa_guard_release(&qword_1EB9A22C8);
      a2 = v19;
    }
  }
  double v12 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      double v12 = a2;
      if (a2 < *(double *)&qword_1EB9A22B0) {
        goto LABEL_7;
      }
LABEL_9:
      double v13 = exp((v12 + -0.790453) * *(double *)&qword_1EB9A22C0) + -0.009468;
      double v14 = 0.555555556;
      goto LABEL_10;
    }
    double v12 = 1.0;
  }
  if (v12 >= *(double *)&qword_1EB9A22B0) {
    goto LABEL_9;
  }
LABEL_7:
  double v13 = v12 + -0.092864;
  double v14 = 8.735631;
LABEL_10:
  float result = v13 / v14 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGFujifilmFLog2LinearizationLUTInfo::HGFujifilmFLog2LinearizationLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1BB8;
  return result;
}

void *HGFujifilmFLog2LinearizationLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

float HGFujifilmFLog2LinearizationLUTInfo::colorAtIndex(HGFujifilmFLog2LinearizationLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A22D8, memory_order_acquire) & 1) == 0)
  {
    float v18 = a2;
    int v16 = __cxa_guard_acquire(&qword_1EB9A22D8);
    a2 = v18;
    if (v16)
    {
      qword_1EB9A22D0 = 0x3FB9C69A8FA91FF2;
      __cxa_guard_release(&qword_1EB9A22D8);
      a2 = v18;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A22E8, memory_order_acquire) & 1) == 0)
  {
    float v19 = a2;
    int v17 = __cxa_guard_acquire(&qword_1EB9A22E8);
    a2 = v19;
    if (v17)
    {
      qword_1EB9A22E0 = 0x4022C66B961C7A0CLL;
      __cxa_guard_release(&qword_1EB9A22E8);
      a2 = v19;
    }
  }
  double v12 = 0.0;
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0)
    {
      double v12 = a2;
      if (a2 < *(double *)&qword_1EB9A22D0) {
        goto LABEL_7;
      }
LABEL_9:
      double v13 = exp((v12 + -0.384316) * *(double *)&qword_1EB9A22E0) + -0.064829;
      double v14 = 5.55555556;
      goto LABEL_10;
    }
    double v12 = 1.0;
  }
  if (v12 >= *(double *)&qword_1EB9A22D0) {
    goto LABEL_9;
  }
LABEL_7:
  double v13 = v12 + -0.092864;
  double v14 = 8.799461;
LABEL_10:
  float result = v13 / v14 / 0.9;
  *a5 = result;
  *a6 = result;
  *a7 = result;
  *a8 = 1.0;
  return result;
}

void *HGAYCCToneCurveToLinearLUTInfo::HGAYCCToneCurveToLinearLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1C08;
  return result;
}

void *HGAYCCToneCurveToLinearLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

void HGAYCCToneCurveToLinearLUTInfo::colorAtIndex(HGAYCCToneCurveToLinearLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0) {
      float v12 = powf(a2, 1.956);
    }
    else {
      float v12 = (float)((float)((float)(a2 + -1.0) * 0.225) / 0.08) + 1.0;
    }
  }
  else
  {
    float v12 = powf(a2 / -0.08, 2.2) * -0.225;
  }
  *a5 = v12;
  *a6 = v12;
  *a7 = v12;
  *a8 = 1.0;
}

void *HGLinearToAYCCToneCurveLUTInfo::HGLinearToAYCCToneCurveLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1C58;
  return result;
}

void *HGLinearToAYCCToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

void HGLinearToAYCCToneCurveLUTInfo::colorAtIndex(HGLinearToAYCCToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  if (a2 >= 0.0)
  {
    if (a2 <= 1.0) {
      float v12 = powf(a2, 0.51125);
    }
    else {
      float v12 = (float)((float)((float)(a2 + -1.0) * 0.08) / 0.225) + 1.0;
    }
  }
  else
  {
    float v12 = powf(a2 / -0.225, 0.45455) * -0.08;
  }
  *a5 = v12;
  *a6 = v12;
  *a7 = v12;
  *a8 = 1.0;
}

void *HG_ERsRGBToneCurveToLinearLUTInfo::HG_ERsRGBToneCurveToLinearLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1CA8;
  return result;
}

void *HG_ERsRGBToneCurveToLinearLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

void HG_ERsRGBToneCurveToLinearLUTInfo::colorAtIndex(HG_ERsRGBToneCurveToLinearLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  float v13 = fabsf(a2);
  if (v13 >= 0.04045) {
    float v14 = powf((float)(v13 * 0.94787) + 0.05213, 2.4);
  }
  else {
    float v14 = v13 * 0.07734;
  }
  if (a2 < 0.0) {
    float v14 = -v14;
  }
  *a5 = v14;
  *a6 = v14;
  *a7 = v14;
  *a8 = 1.0;
}

void *HGLinearToERsRGBToneCurveLUTInfo::HGLinearToERsRGBToneCurveLUTInfo(uint64_t a1, uint64_t a2, int a3, float a4, float a5)
{
  float result = (void *)HGApplyNDLUTInfo::HGApplyNDLUTInfo(a1, a2, 1uLL, a3, a4, a5);
  *float result = &unk_1F10E1CF8;
  return result;
}

void *HGLinearToERsRGBToneCurveLUTInfo::isEqual(uint64_t a1, void *lpsrc)
{
  if (!lpsrc) {
    return 0;
  }
  if (!v3) {
    return 0;
  }

  return HGApplyNDLUTInfo::isEqual(a1, v3);
}

void HGLinearToERsRGBToneCurveLUTInfo::colorAtIndex(HGLinearToERsRGBToneCurveLUTInfo *this, float a2, float a3, float a4, float *a5, float *a6, float *a7, float *a8)
{
  float v13 = fabsf(a2);
  if (v13 >= 0.0031308) {
    float v14 = powf(v13 * 1.1371, 0.41667) + -0.055;
  }
  else {
    float v14 = v13 * 12.92;
  }
  if (a2 < 0.0) {
    float v14 = -v14;
  }
  *a5 = v14;
  *a6 = v14;
  *a7 = v14;
  *a8 = 1.0;
}

void HGColorGammaLUTInfo::~HGColorGammaLUTInfo(HGColorGammaLUTInfo *this)
{
}

void HGColorGammaLUTInfo::duplicate(HGColorGammaLUTInfo *this)
{
}

void HGArriLogCDefaultToneCurveLUTInfo::~HGArriLogCDefaultToneCurveLUTInfo(HGArriLogCDefaultToneCurveLUTInfo *this)
{
}

void HGArriLogCDefaultToneCurveLUTInfo::duplicate(HGArriLogCDefaultToneCurveLUTInfo *this)
{
}

void HGArriLogCLinearizationLUTInfo::~HGArriLogCLinearizationLUTInfo(HGArriLogCLinearizationLUTInfo *this)
{
}

void HGArriLogCLinearizationLUTInfo::duplicate(HGArriLogCLinearizationLUTInfo *this)
{
}

void HGArriLogC4LinearizationLUTInfo::~HGArriLogC4LinearizationLUTInfo(HGArriLogC4LinearizationLUTInfo *this)
{
}

void HGArriLogC4LinearizationLUTInfo::duplicate(HGArriLogC4LinearizationLUTInfo *this)
{
}

void HGCanonLogToneCurveLUTInfo::~HGCanonLogToneCurveLUTInfo(HGCanonLogToneCurveLUTInfo *this)
{
}

void HGCanonLogToneCurveLUTInfo::duplicate(HGCanonLogToneCurveLUTInfo *this)
{
}

void HGCanonLogLinearizationLUTInfo::~HGCanonLogLinearizationLUTInfo(HGCanonLogLinearizationLUTInfo *this)
{
}

void HGCanonLogLinearizationLUTInfo::duplicate(HGCanonLogLinearizationLUTInfo *this)
{
}

void HGCanonLog2LinearizationLUTInfo::~HGCanonLog2LinearizationLUTInfo(HGCanonLog2LinearizationLUTInfo *this)
{
}

void HGCanonLog2LinearizationLUTInfo::duplicate(HGCanonLog2LinearizationLUTInfo *this)
{
}

void HGCanonLog3LinearizationLUTInfo::~HGCanonLog3LinearizationLUTInfo(HGCanonLog3LinearizationLUTInfo *this)
{
}

void HGCanonLog3LinearizationLUTInfo::duplicate(HGCanonLog3LinearizationLUTInfo *this)
{
}

void HGSonySLog2LinearizationLUTInfo::~HGSonySLog2LinearizationLUTInfo(HGSonySLog2LinearizationLUTInfo *this)
{
}

void HGSonySLog2LinearizationLUTInfo::duplicate(HGSonySLog2LinearizationLUTInfo *this)
{
}

void HGSonySLog3LinearizationLUTInfo::~HGSonySLog3LinearizationLUTInfo(HGSonySLog3LinearizationLUTInfo *this)
{
}

void HGSonySLog3LinearizationLUTInfo::duplicate(HGSonySLog3LinearizationLUTInfo *this)
{
}

void HGPanasonicVLogLinearizationLUTInfo::~HGPanasonicVLogLinearizationLUTInfo(HGPanasonicVLogLinearizationLUTInfo *this)
{
}

void HGPanasonicVLogLinearizationLUTInfo::duplicate(HGPanasonicVLogLinearizationLUTInfo *this)
{
}

void HGNikonNLogLinearizationLUTInfo::~HGNikonNLogLinearizationLUTInfo(HGNikonNLogLinearizationLUTInfo *this)
{
}

void HGNikonNLogLinearizationLUTInfo::duplicate(HGNikonNLogLinearizationLUTInfo *this)
{
}

void HGBMDFilmLinearizationLUTInfo::~HGBMDFilmLinearizationLUTInfo(HGBMDFilmLinearizationLUTInfo *this)
{
}

void HGBMDFilmLinearizationLUTInfo::duplicate(HGBMDFilmLinearizationLUTInfo *this)
{
}

void HGAppleLogLinearizationLUTInfo::~HGAppleLogLinearizationLUTInfo(HGAppleLogLinearizationLUTInfo *this)
{
}

void HGAppleLogLinearizationLUTInfo::duplicate(HGAppleLogLinearizationLUTInfo *this)
{
}

void HGDJIDLogLinearizationLUTInfo::~HGDJIDLogLinearizationLUTInfo(HGDJIDLogLinearizationLUTInfo *this)
{
}

void HGDJIDLogLinearizationLUTInfo::duplicate(HGDJIDLogLinearizationLUTInfo *this)
{
}

void HGFujifilmFLogLinearizationLUTInfo::~HGFujifilmFLogLinearizationLUTInfo(HGFujifilmFLogLinearizationLUTInfo *this)
{
}

void HGFujifilmFLogLinearizationLUTInfo::duplicate(HGFujifilmFLogLinearizationLUTInfo *this)
{
}

void HGFujifilmFLog2LinearizationLUTInfo::~HGFujifilmFLog2LinearizationLUTInfo(HGFujifilmFLog2LinearizationLUTInfo *this)
{
}

void HGFujifilmFLog2LinearizationLUTInfo::duplicate(HGFujifilmFLog2LinearizationLUTInfo *this)
{
}

void HGAYCCToneCurveToLinearLUTInfo::~HGAYCCToneCurveToLinearLUTInfo(HGAYCCToneCurveToLinearLUTInfo *this)
{
}

void HGAYCCToneCurveToLinearLUTInfo::duplicate(HGAYCCToneCurveToLinearLUTInfo *this)
{
}

void HGLinearToAYCCToneCurveLUTInfo::~HGLinearToAYCCToneCurveLUTInfo(HGLinearToAYCCToneCurveLUTInfo *this)
{
}

void HGLinearToAYCCToneCurveLUTInfo::duplicate(HGLinearToAYCCToneCurveLUTInfo *this)
{
}

void HG_ERsRGBToneCurveToLinearLUTInfo::~HG_ERsRGBToneCurveToLinearLUTInfo(HG_ERsRGBToneCurveToLinearLUTInfo *this)
{
}

void HG_ERsRGBToneCurveToLinearLUTInfo::duplicate(HG_ERsRGBToneCurveToLinearLUTInfo *this)
{
}

void HGLinearToERsRGBToneCurveLUTInfo::~HGLinearToERsRGBToneCurveLUTInfo(HGLinearToERsRGBToneCurveLUTInfo *this)
{
}

void HGLinearToERsRGBToneCurveLUTInfo::duplicate(HGLinearToERsRGBToneCurveLUTInfo *this)
{
}

void HGColorClamp::HGColorClamp(HGColorClamp *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10E1D48;
  int v2 = (HgcColorClamp *)HGObject::operator new(0x1A0uLL);
  HgcColorClamp::HgcColorClamp(v2);
}

void sub_1B78566F0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B785670C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGColorClamp::HGColorClamp(HGColorClamp *this, float a2, float a3)
{
  HGNode::HGNode((HGNode *)this);
  *float v3 = &unk_1F10E1D48;
  uint64_t v4 = (HgcColorClamp *)HGObject::operator new(0x1A0uLL);
  HgcColorClamp::HgcColorClamp(v4);
}

void sub_1B78567A0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B78567BC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGColorClamp::~HGColorClamp(HGColorClamp *this)
{
  *(void *)this = &unk_1F10E1D48;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10E1D48;
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));
  HGNode::~HGNode((HGNode *)this);

  HGObject::operator delete(v2);
}

uint64_t HGColorClamp::SetParameter(HGColorClamp *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 == 1)
  {
    *((float *)this + 108) = a3;
    *((float *)this + 109) = a4;
    *((float *)this + 110) = a5;
    *((float *)this + 111) = a6;
    HGNode::ClearBits((HGNode *)this, a2, a7);
    return 1;
  }
  else if (a2)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    *((float *)this + 104) = a3;
    *((float *)this + 105) = a4;
    *((float *)this + 106) = a5;
    *((float *)this + 107) = a6;
    HGNode::ClearBits((HGNode *)this, a2, a7);
    return 1;
  }
}

float *HGColorClamp::SetClampMaxValues(float *this, float a2, float a3, float a4, float a5)
{
  this[104] = a2;
  this[105] = a3;
  this[106] = a4;
  this[107] = a5;
  return this;
}

float *HGColorClamp::SetClampMinValues(float *this, float a2, float a3, float a4, float a5)
{
  this[108] = a2;
  this[109] = a3;
  this[110] = a4;
  this[111] = a5;
  return this;
}

uint64_t HGColorClamp::GetOutput(HGColorClamp *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  uint64_t v4 = (*(uint64_t (**)(HGColorClamp *, void))(*(void *)this + 128))(this, 0);
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v3 + 120))(v3, 0, v4);
  (*(void (**)(void, void, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, *((float *)this + 104), *((float *)this + 105), *((float *)this + 106), *((float *)this + 107));
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, *((float *)this + 108), *((float *)this + 109), *((float *)this + 110), *((float *)this + 111));
  return *((void *)this + 51);
}

void HFDenseCRFInterface::HFDenseCRFInterface(HFDenseCRFInterface *this, const __CFUUID *a2)
{
  *(void *)this = &unk_1F10E1FB0;
  operator new();
}

void sub_1B7856ACC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x81C40B8603338);
  _Unwind_Resume(a1);
}

void HFDenseCRFInterface::~HFDenseCRFInterface(HFDenseCRFInterface *this)
{
  *(void *)this = &unk_1F10E1FB0;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1F10E1FB0;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t HFDenseCRFInterface::GenerateMask(HFDenseCRF **this, HGBitmap *a2, HGBitmap *a3, HGBitmap *a4, float a5, float a6, float a7, float a8, float a9, float a10, uint64_t a11)
{
  return HFDenseCRF::GenerateMask(this[1], a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

void HgcSampler::Create(HgcSampler *this)
{
}

uint64_t HgcSampler::Destroy(uint64_t result)
{
  if (result) {
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t (*HgcSampler::Init(uint64_t a1, uint64_t a2, int a3))(int32x4_t *a1, float32x4_t *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t, float64x2_t *))(*(void *)a2 + 48))(a2, v15);
  int32x4_t v5 = (int32x4_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v15[0]), v15[1]);
  int32x4_t v6 = (int32x4_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v15[2]), v15[3]);
  *(int32x4_t *)a1 = v5;
  *(int32x4_t *)(a1 + 16) = v6;
  float32x2_t v7 = vcvt_f32_f64(v16);
  float32x4_t v8 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v17), v18);
  float32x2_t v9 = vcvt_f32_f64(v18);
  *(float32x4_t *)(a1 + 32) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v15[4]), v16);
  *(float32x4_t *)(a1 + 48) = v8;
  v10.i64[0] = vuzp2q_s32(vuzp2q_s32(v6, v5), v6).u64[0];
  v10.i64[1] = __PAIR64__(v9.u32[1], v7.u32[1]);
  char v11 = vaddvq_s32((int32x4_t)vbicq_s8((int8x16_t)xmmword_1B7E78240, (int8x16_t)vceqq_f32(v10, (float32x4_t)xmmword_1B7E734D0)));
  if (a3 <= 0) {
    float v12 = GetAffineNearestTile;
  }
  else {
    float v12 = GetAffineLinearTile;
  }
  float v13 = GetPerspNearestTile;
  if (a3 > 0) {
    float v13 = GetPerspLinearTile;
  }
  if ((v11 & 0xF) != 0) {
    return v13;
  }
  else {
    return v12;
  }
}

uint64_t GetAffineLinearTile(int32x4_t *a1, float32x4_t *a2)
{
  int v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    int v3 = 0;
    float32x4_t v4 = (float32x4_t)vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    int64x2_t v5 = (int64x2_t)vsubq_f32(vcvtq_f32_s32(a1[13]), v4);
    float32x4_t v6 = (float32x4_t)vdupq_lane_s64(v5.i64[0], 0);
    int v7 = a1->i32[2] - a1->i32[0];
    float32x4_t v8 = vsubq_f32((float32x4_t)vdupq_laneq_s64(v5, 1), a2[6]);
    uint64_t v9 = a1[5].i64[0];
    uint64_t v10 = a1[5].i32[2];
    i64 = (const double *)a2[1].i64;
    float32x4_t v12 = (float32x4_t)vld1q_dup_f64(i64);
    float32x4_t v13 = (float32x4_t)vdupq_lane_s64(vaddq_f32(*a2, *a2).i64[0], 0);
    v14.i64[0] = a2[4].i64[0];
    v14.i64[1] = a2->i64[0];
    float32x4_t v15 = vaddq_f32(a2[7], v4);
    float64x2_t v16 = (const double *)a2[3].i64;
    float32x4_t v17 = (float32x4_t)vld1q_dup_f64(v16);
    float32x4_t v18 = vaddq_f32(v14, vsubq_f32(vaddq_f32(vmulq_f32(v12, (float32x4_t)vsriq_n_s64((int64x2_t)v15, (int64x2_t)v15, 0x20uLL)), vaddq_f32(v17, vmulq_f32((float32x4_t)vdupq_lane_s64(a2->i64[0], 0), (float32x4_t)vsliq_n_s64((int64x2_t)v15, (int64x2_t)v15, 0x20uLL)))), v15));
    uint64_t v19 = a1[1].i64[0];
    int32x2_t v20 = vdup_n_s32(v10);
    uint64_t v21 = 16 * a1[1].i32[2];
    while (v7 < 2)
    {
      uint64_t v22 = 0;
      float32x4_t v24 = v18;
      if (v7 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v18 = vaddq_f32(v12, v18);
      ++v3;
      v19 += v21;
      if (v3 == v2) {
        return 0;
      }
    }
    uint64_t v22 = 0;
    int v23 = v7;
    float32x4_t v24 = v18;
    do
    {
      float32x4_t v25 = vmaxq_f32(v24, v6);
      float32x4_t v26 = vminq_f32(v25, v8);
      float32x4_t v27 = vcvtq_f32_s32(vcvtq_s32_f32(v26));
      float32x4_t v28 = vaddq_f32(v27, vcvtq_f32_s32(vcgtq_f32(v27, v26)));
      int8x16_t v29 = (int8x16_t)vshlq_n_s32(vcvtq_s32_f32(v28), 2uLL);
      int32x2_t v30 = (int32x2_t)vextq_s8(v29, v29, 8uLL).u64[0];
      *(int32x2_t *)v29.i8 = vmla_s32(vzip1_s32(*(int32x2_t *)v29.i8, v30), vzip2_s32(*(int32x2_t *)v29.i8, v30), v20);
      float v31 = (float32x4_t *)(v9 + 4 * v29.i32[0]);
      float32x4_t v32 = vminq_f32(vsubq_f32(v25, v28), a2[5]);
      float32x4_t v33 = vaddq_f32(*v31, vmulq_n_f32(vsubq_f32(v31[1], *v31), v32.f32[0]));
      float32x4_t v34 = vaddq_f32(v31[v10], vmulq_n_f32(vsubq_f32(v31[v10 + 1], v31[v10]), v32.f32[0]));
      float v35 = (float32x4_t *)(v19 + 16 * v22);
      *float v35 = vaddq_f32(v33, vmulq_lane_f32(vsubq_f32(v34, v33), *(float32x2_t *)v32.f32, 1));
      float v36 = (float32x4_t *)(v9 + 4 * v29.i32[1]);
      float32x4_t v37 = vaddq_f32(*v36, vmulq_laneq_f32(vsubq_f32(v36[1], *v36), v32, 2));
      v35[1] = vaddq_f32(v37, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v36[v10], vmulq_laneq_f32(vsubq_f32(v36[v10 + 1], v36[v10]), v32, 2)), v37), v32, 3));
      float32x4_t v24 = vaddq_f32(v13, v24);
      v22 += 2;
      v23 -= 2;
    }
    while (v23 > 1);
    uint64_t v22 = v22;
    if ((int)v22 >= v7) {
      goto LABEL_3;
    }
    do
    {
LABEL_10:
      float32x4_t v38 = vmaxq_f32(v24, v6);
      float32x4_t v39 = vminq_f32(v38, v8);
      float32x4_t v40 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
      float32x4_t v41 = vaddq_f32(v40, vcvtq_f32_s32(vcgtq_f32(v40, v39)));
      float32x4_t v42 = vsubq_f32(v38, v41);
      v41.i64[0] = vshlq_n_s32(vcvtq_s32_f32(v41), 2uLL).u64[0];
      v42.i64[0] = vminq_f32(v42, a2[5]).u64[0];
      float v43 = (float32x4_t *)(v9 + 4 * (v41.i32[0] + v41.i32[1] * (int)v10));
      float32x4_t v44 = vaddq_f32(*v43, vmulq_n_f32(vsubq_f32(v43[1], *v43), v42.f32[0]));
      *(float32x4_t *)(v19 + 16 * v22) = vaddq_f32(v44, vmulq_lane_f32(vsubq_f32(vaddq_f32(v43[v10], vmulq_n_f32(vsubq_f32(v43[v10 + 1], v43[v10]), v42.f32[0])), v44), *(float32x2_t *)v42.f32, 1));
      float32x4_t v24 = vaddq_f32(v24, *a2);
      ++v22;
    }
    while (v22 < v7);
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetAffineNearestTile(int32x4_t *a1, float32x4_t *a2)
{
  int v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    unint64_t v3 = (a1->i32[2] - a1->i32[0]);
    float32x4_t v4 = (float32x4_t)vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    float32x4_t v5 = vaddq_f32(a2[7], v4);
    int64x2_t v6 = (int64x2_t)vaddq_f32(a2[8], vsubq_f32(vcvtq_f32_s32(a1[13]), v4));
    float32x4_t v7 = (float32x4_t)vdupq_lane_s64(v6.i64[0], 0);
    float32x4_t v8 = (float32x4_t)vdupq_laneq_s64(v6, 1);
    uint64_t v9 = a1[5].i64[0];
    unsigned int v10 = a1[5].u32[2];
    i64 = (const double *)a2[1].i64;
    float32x4_t v12 = (float32x4_t)vld1q_dup_f64(i64);
    uint64_t v13 = a1[1].i64[0];
    float32x4_t v14 = (const double *)a2[3].i64;
    float32x4_t v15 = (float32x4_t)vld1q_dup_f64(v14);
    float32x4_t v16 = vsubq_f32(vaddq_f32(vmulq_f32(v12, (float32x4_t)vsriq_n_s64((int64x2_t)v5, (int64x2_t)v5, 0x20uLL)), vaddq_f32(v15, vmulq_f32((float32x4_t)vdupq_lane_s64(a2->i64[0], 0), (float32x4_t)vsliq_n_s64((int64x2_t)v5, (int64x2_t)v5, 0x20uLL)))), v4);
    v5.i64[0] = a2[4].i64[0];
    v5.i64[1] = a2->i64[0];
    float32x4_t v17 = vaddq_f32(v5, v16);
    uint64_t v18 = a1[1].i32[2];
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v41 = 0;
        uint64_t v42 = 16 * (a1->i32[2] - a1->i32[0]);
        do
        {
          uint64_t v43 = 0;
          float32x4_t v44 = v17;
          do
          {
            float32x4_t v45 = vminq_f32(vmaxq_f32(v44, v7), v8);
            int32x4_t v46 = vcvtq_s32_f32(v45);
            v45.i64[0] = vshlq_n_s32(vaddq_s32(v46, vcgtq_f32(vcvtq_f32_s32(v46), v45)), 2uLL).u64[0];
            *(_OWORD *)(v13 + v43) = *(_OWORD *)(v9 + 4 * (int)(v45.i32[0] + v45.i32[1] * v10));
            float32x4_t v44 = vaddq_f32(v44, *a2);
            v43 += 16;
          }
          while (v42 != v43);
          float32x4_t v17 = vaddq_f32(v12, v17);
          ++v41;
          v13 += 16 * v18;
        }
        while (v41 != v2);
      }
    }
    else
    {
      int v19 = 0;
      float32x4_t v20 = vaddq_f32(*a2, *a2);
      float32x4_t v21 = (float32x4_t)vdupq_lane_s64(v20.i64[0], 0);
      float32x4_t v22 = (float32x4_t)vdupq_lane_s64(vaddq_f32(v20, v20).i64[0], 0);
      int32x4_t v23 = vdupq_n_s32(v10);
      float32x4_t v24 = (_OWORD *)(v13 + 32);
      uint64_t v25 = 16 * v18;
      float32x4_t v26 = (_OWORD *)(v13 + 64);
      do
      {
        unint64_t v27 = 0;
        float32x4_t v28 = v26;
        int8x16_t v29 = v24;
        float32x4_t v30 = v17;
        do
        {
          float32x4_t v31 = vminq_f32(vmaxq_f32(v30, v7), v8);
          float32x4_t v32 = vminq_f32(vmaxq_f32(vaddq_f32(v21, v30), v7), v8);
          int32x4_t v33 = vcvtq_s32_f32(v31);
          int32x4_t v34 = vcvtq_s32_f32(v32);
          int32x4_t v35 = vshlq_n_s32(vaddq_s32(v33, vcgtq_f32(vcvtq_f32_s32(v33), v31)), 2uLL);
          int32x4_t v36 = vshlq_n_s32(vaddq_s32(v34, vcgtq_f32(vcvtq_f32_s32(v34), v32)), 2uLL);
          int32x4_t v37 = vmlaq_s32(vuzp1q_s32(v35, v36), vuzp2q_s32(v35, v36), v23);
          *(v29 - 2) = *(_OWORD *)(v9 + 4 * v37.i32[0]);
          *(v29 - 1) = *(_OWORD *)(v9 + 4 * v37.i32[1]);
          float32x4_t v38 = v28;
          *int8x16_t v29 = *(_OWORD *)(v9 + 4 * v37.i32[2]);
          v29[1] = *(_OWORD *)(v9 + 4 * v37.i32[3]);
          float32x4_t v30 = vaddq_f32(v22, v30);
          v27 += 4;
          v29 += 4;
          v28 += 4;
        }
        while ((uint64_t)v27 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v27)
        {
          do
          {
            float32x4_t v39 = vminq_f32(vmaxq_f32(v30, v7), v8);
            int32x4_t v40 = vcvtq_s32_f32(v39);
            v39.i64[0] = vshlq_n_s32(vaddq_s32(v40, vcgtq_f32(vcvtq_f32_s32(v40), v39)), 2uLL).u64[0];
            *v38++ = *(_OWORD *)(v9 + 4 * (int)(v39.i32[0] + v39.i32[1] * v10));
            float32x4_t v30 = vaddq_f32(v30, *a2);
            ++v27;
          }
          while (v27 < v3);
        }
        float32x4_t v17 = vaddq_f32(v12, v17);
        ++v19;
        float32x4_t v24 = (_OWORD *)((char *)v24 + v25);
        float32x4_t v26 = (_OWORD *)((char *)v26 + v25);
      }
      while (v19 != v2);
    }
  }
  return 0;
}

uint64_t GetPerspLinearTile(int32x4_t *a1, float32x4_t *a2)
{
  int v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    int v3 = 0;
    float32x4_t v4 = (float32x4_t)vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    int v5 = a1->i32[2] - a1->i32[0];
    float32x4_t v6 = vaddq_f32(a2[7], v4);
    int64x2_t v7 = (int64x2_t)vsubq_f32(vcvtq_f32_s32(a1[13]), v4);
    float32x4_t v8 = (float32x4_t)vdupq_lane_s64(v7.i64[0], 0);
    float32x4_t v9 = vsubq_f32((float32x4_t)vdupq_laneq_s64(v7, 1), a2[6]);
    uint64_t v10 = a1[5].i64[0];
    float32x4_t v11 = a2[1];
    int32x4_t v12 = (int32x4_t)vaddq_f32(*a2, *a2);
    float32x4_t v13 = (float32x4_t)vdupq_lane_s64(v11.i64[0], 0);
    float32x4_t v14 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3);
    float32x4_t v15 = (float32x4_t)vdupq_lane_s64(v12.i64[0], 0);
    float32x4_t v16 = (float32x4_t)vdupq_laneq_s32(v12, 3);
    uint64_t v17 = a1[5].i32[2];
    float32x4_t v19 = vaddq_f32(vaddq_f32(a2[3], vmulq_n_f32(*a2, v6.f32[0])), vmulq_lane_f32(v11, *(float32x2_t *)v6.f32, 1));
    int32x4_t v18 = (int32x4_t)vaddq_f32(*a2, v19);
    *(int32x2_t *)v20.f32 = vdup_laneq_s32((int32x4_t)v19, 3);
    v19.i64[1] = v18.i64[0];
    *(int32x2_t *)&v20.u32[2] = vdup_laneq_s32(v18, 3);
    uint64_t v21 = a1[1].i64[0];
    int32x2_t v22 = vdup_n_s32(v17);
    uint64_t v23 = 16 * a1[1].i32[2];
    while (v5 < 2)
    {
      uint64_t v24 = 0;
      float32x4_t v27 = v20;
      float32x4_t v26 = v19;
      if (v5 > 0) {
        goto LABEL_10;
      }
LABEL_3:
      float32x4_t v19 = vaddq_f32(v13, v19);
      float32x4_t v20 = vaddq_f32(v14, v20);
      ++v3;
      v21 += v23;
      if (v3 == v2) {
        return 0;
      }
    }
    uint64_t v24 = 0;
    int v25 = v5;
    float32x4_t v26 = v19;
    float32x4_t v27 = v20;
    do
    {
      float32x4_t v28 = vrecpeq_f32(v27);
      float32x4_t v29 = vmulq_f32(v28, vrecpsq_f32(v27, v28));
      float32x4_t v30 = vmaxq_f32(vsubq_f32(vmulq_f32(v26, vmulq_f32(v29, vrecpsq_f32(v27, v29))), v6), v8);
      float32x4_t v31 = vminq_f32(v30, v9);
      float32x4_t v32 = vcvtq_f32_s32(vcvtq_s32_f32(v31));
      float32x4_t v33 = vaddq_f32(v32, vcvtq_f32_s32(vcgtq_f32(v32, v31)));
      int8x16_t v34 = (int8x16_t)vshlq_n_s32(vcvtq_s32_f32(v33), 2uLL);
      int32x2_t v35 = (int32x2_t)vextq_s8(v34, v34, 8uLL).u64[0];
      *(int32x2_t *)v34.i8 = vmla_s32(vzip1_s32(*(int32x2_t *)v34.i8, v35), vzip2_s32(*(int32x2_t *)v34.i8, v35), v22);
      __int32 v36 = v34.i32[1];
      int32x4_t v37 = (float32x4_t *)(v10 + 4 * v34.i32[0]);
      float32x4_t v38 = vminq_f32(vsubq_f32(v30, v33), a2[5]);
      float32x4_t v39 = vaddq_f32(*v37, vmulq_n_f32(vsubq_f32(v37[1], *v37), v38.f32[0]));
      float32x4_t v40 = vsubq_f32(vaddq_f32(v37[v17], vmulq_n_f32(vsubq_f32(v37[v17 + 1], v37[v17]), v38.f32[0])), v39);
      int v41 = (float32x4_t *)(v21 + 16 * v24);
      *int v41 = vaddq_f32(v39, vmulq_lane_f32(v40, *(float32x2_t *)v38.f32, 1));
      uint64_t v42 = (float32x4_t *)(v10 + 4 * v36);
      float32x4_t v43 = vaddq_f32(*v42, vmulq_laneq_f32(vsubq_f32(v42[1], *v42), v38, 2));
      v41[1] = vaddq_f32(v43, vmulq_laneq_f32(vsubq_f32(vaddq_f32(v42[v17], vmulq_laneq_f32(vsubq_f32(v42[v17 + 1], v42[v17]), v38, 2)), v43), v38, 3));
      float32x4_t v26 = vaddq_f32(v15, v26);
      float32x4_t v27 = vaddq_f32(v16, v27);
      v24 += 2;
      v25 -= 2;
    }
    while (v25 > 1);
    uint64_t v24 = v24;
    if ((int)v24 >= v5) {
      goto LABEL_3;
    }
    do
    {
LABEL_10:
      float32x4_t v44 = vrecpeq_f32(v27);
      float32x4_t v45 = vmulq_f32(v44, vrecpsq_f32(v27, v44));
      float32x4_t v46 = vmaxq_f32(vsubq_f32(vmulq_f32(v26, vmulq_f32(v45, vrecpsq_f32(v27, v45))), v6), v8);
      float32x4_t v47 = vminq_f32(v46, v9);
      float32x4_t v48 = vcvtq_f32_s32(vcvtq_s32_f32(v47));
      float32x4_t v49 = vaddq_f32(v48, vcvtq_f32_s32(vcgtq_f32(v48, v47)));
      v46.i64[0] = vminq_f32(vsubq_f32(v46, v49), a2[5]).u64[0];
      v49.i64[0] = vshlq_n_s32(vcvtq_s32_f32(v49), 2uLL).u64[0];
      __float2 v50 = (float32x4_t *)(v10 + 4 * (v49.i32[0] + v49.i32[1] * (int)v17));
      float32x4_t v51 = vaddq_f32(*v50, vmulq_n_f32(vsubq_f32(v50[1], *v50), v46.f32[0]));
      *(float32x4_t *)(v21 + 16 * v24) = vaddq_f32(v51, vmulq_lane_f32(vsubq_f32(vaddq_f32(v50[v17], vmulq_n_f32(vsubq_f32(v50[v17 + 1], v50[v17]), v46.f32[0])), v51), *(float32x2_t *)v46.f32, 1));
      float32x4_t v26 = vaddq_f32(v26, *a2);
      float32x4_t v27 = vaddq_f32(v27, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 3));
      ++v24;
    }
    while (v24 < v5);
    goto LABEL_3;
  }
  return 0;
}

uint64_t GetPerspNearestTile(int32x4_t *a1, float32x4_t *a2)
{
  int v2 = a1->i32[3] - a1->i32[1];
  if (v2 >= 1)
  {
    unint64_t v3 = (a1->i32[2] - a1->i32[0]);
    float32x4_t v4 = (float32x4_t)vdupq_lane_s64(vcvtq_f32_s32(*a1).i64[0], 0);
    int64x2_t v5 = (int64x2_t)vsubq_f32(vcvtq_f32_s32(a1[13]), v4);
    float32x4_t v6 = (float32x4_t)vdupq_lane_s64(v5.i64[0], 0);
    float32x4_t v7 = vaddq_f32(a2[7], v4);
    float32x4_t v8 = vsubq_f32((float32x4_t)vdupq_laneq_s64(v5, 1), a2[5]);
    uint64_t v9 = a1[5].i64[0];
    unsigned int v10 = a1[5].u32[2];
    float32x4_t v11 = (_OWORD *)a1[1].i64[0];
    float32x4_t v12 = a2[1];
    float32x4_t v15 = vaddq_f32(vaddq_f32(a2[3], vmulq_n_f32(*a2, v7.f32[0])), vmulq_lane_f32(v12, *(float32x2_t *)v7.f32, 1));
    int32x4_t v13 = (int32x4_t)vaddq_f32(*a2, v15);
    *(int32x2_t *)v14.f32 = vdup_laneq_s32((int32x4_t)v15, 3);
    *(int32x2_t *)&v14.u32[2] = vdup_laneq_s32(v13, 3);
    v15.i64[1] = v13.i64[0];
    float32x4_t v16 = (float32x4_t)vdupq_lane_s64(v12.i64[0], 0);
    float32x4_t v17 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3);
    uint64_t v18 = a1[1].i32[2];
    if ((int)v3 < 2)
    {
      if (v3 == 1)
      {
        do
        {
          float32x4_t v42 = vrecpeq_f32(v14);
          float32x4_t v43 = vmulq_f32(v42, vrecpsq_f32(v14, v42));
          float32x4_t v44 = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v15, vmulq_f32(v43, vrecpsq_f32(v14, v43))), v7), v6), v8), a2[7]);
          int32x4_t v45 = vcvtq_s32_f32(v44);
          v44.i64[0] = vshlq_n_s32(vaddq_s32(v45, vcgtq_f32(vcvtq_f32_s32(v45), v44)), 2uLL).u64[0];
          *float32x4_t v11 = *(_OWORD *)(v9 + 4 * (int)(v44.i32[0] + v44.i32[1] * v10));
          float32x4_t v15 = vaddq_f32(v16, v15);
          float32x4_t v14 = vaddq_f32(v17, v14);
          v11 += v18;
          --v2;
        }
        while (v2);
      }
    }
    else
    {
      int v19 = 0;
      int32x4_t v20 = (int32x4_t)vaddq_f32(*a2, *a2);
      float32x4_t v21 = (float32x4_t)vdupq_lane_s64(v20.i64[0], 0);
      float32x4_t v22 = (float32x4_t)vdupq_laneq_s32(v20, 3);
      int32x2_t v23 = vdup_n_s32(v10);
      uint64_t v24 = 16 * v18;
      int v25 = v11 + 2;
      do
      {
        unint64_t v26 = 0;
        float32x4_t v27 = v25;
        int v28 = v3;
        float32x4_t v29 = v15;
        float32x4_t v30 = v14;
        do
        {
          float32x4_t v31 = v27;
          float32x4_t v32 = vrecpeq_f32(v30);
          float32x4_t v33 = vmulq_f32(v32, vrecpsq_f32(v30, v32));
          float32x4_t v34 = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v29, vmulq_f32(v33, vrecpsq_f32(v30, v33))), v7), v6), v8), a2[7]);
          int32x4_t v35 = vcvtq_s32_f32(v34);
          int8x16_t v36 = (int8x16_t)vshlq_n_s32(vaddq_s32(v35, vcgtq_f32(vcvtq_f32_s32(v35), v34)), 2uLL);
          v35.i64[0] = vextq_s8(v36, v36, 8uLL).u64[0];
          *(int32x2_t *)v36.i8 = vmla_s32(vzip1_s32(*(int32x2_t *)v36.i8, *(int32x2_t *)v35.i8), vzip2_s32(*(int32x2_t *)v36.i8, *(int32x2_t *)v35.i8), v23);
          int32x4_t v37 = &v11[v26];
          *int32x4_t v37 = *(_OWORD *)(v9 + 4 * v36.i32[0]);
          v37[1] = *(_OWORD *)(v9 + 4 * v36.i32[1]);
          float32x4_t v29 = vaddq_f32(v21, v29);
          float32x4_t v30 = vaddq_f32(v22, v30);
          v26 += 2;
          v28 -= 2;
          v27 += 2;
        }
        while (v28 > 1);
        if ((int)v3 > (int)v26)
        {
          do
          {
            float32x4_t v38 = vrecpeq_f32(v30);
            float32x4_t v39 = vmulq_f32(v38, vrecpsq_f32(v30, v38));
            float32x4_t v40 = vaddq_f32(vminq_f32(vmaxq_f32(vsubq_f32(vmulq_f32(v29, vmulq_f32(v39, vrecpsq_f32(v30, v39))), v7), v6), v8), a2[7]);
            int32x4_t v41 = vcvtq_s32_f32(v40);
            v40.i64[0] = vshlq_n_s32(vaddq_s32(v41, vcgtq_f32(vcvtq_f32_s32(v41), v40)), 2uLL).u64[0];
            *v31++ = *(_OWORD *)(v9 + 4 * (int)(v40.i32[0] + v40.i32[1] * v10));
            float32x4_t v29 = vaddq_f32(v29, *a2);
            float32x4_t v30 = vaddq_f32(v30, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)a2, 3));
            ++v26;
          }
          while (v26 < v3);
        }
        float32x4_t v15 = vaddq_f32(v16, v15);
        float32x4_t v14 = vaddq_f32(v17, v14);
        ++v19;
        float32x4_t v11 = (_OWORD *)((char *)v11 + v24);
        int v25 = (_OWORD *)((char *)v25 + v24);
      }
      while (v19 != v2);
    }
  }
  return 0;
}

const char *GetApply1DProgram(HGRenderer *a1, int a2, int a3)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (a3)
  {
    if (a2)
    {
      if (Target == 396048)
      {
        if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
          return "//Metal1.0     \n"
        }
                 "//LEN=0000000695\n"
                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                 "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
                 "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
                 "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
                 "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
                 "{\n"
                 "    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
                 "    half4 r0, r1, r2, r3;\n"
                 "    FragmentOut output;\n"
                 "\n"
                 "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
                 "    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n"
                 "    r1 = fmax(r1, c0.xxxx);\n"
                 "    r1 = fmin(r1, half4(hg_Params[1]));\n"
                 "    r2.xyz = r1.xyz*half3(hg_Params[0].www);\n"
                 "    r2.xyz = floor(r2.xyz);\n"
                 "    r2.xyz = r2.xyz + c0.yyy;\n"
                 "    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n"
                 "    r1 = r1 + c0.yyyy;\n"
                 "    r3.x = r1.x;\n"
                 "    r3.y = r2.x;\n"
                 "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
                 "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
                 "    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n"
                 "    r3.x = r1.y;\n"
                 "    r3.y = r2.y;\n"
                 "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
                 "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
                 "    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n"
                 "    r3.x = r1.z;\n"
                 "    r3.y = r2.z;\n"
                 "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
                 "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
                 "    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n"
                 "    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n"
                 "    return output;\n"
                 "}\n"
                 "//MD5=088a2ea0:e59dd2d6:fba2ff6e:81cad2ec\n"
                 "//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
        else {
          return "//Metal1.0     \n"
        }
                 "//LEN=0000000601\n"
                 "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
                 "    const constant float4* hg_Params [[ buffer(0) ]], \n"
                 "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
                 "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
                 "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
                 "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
                 "{\n"
                 "    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
                 "    float4 r0, r1, r2, r3;\n"
                 "    FragmentOut output;\n"
                 "\n"
                 "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
                 "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
                 "    r1 = fmax(r1, c0.xxxx);\n"
                 "    r1 = fmin(r1, hg_Params[1]);\n"
                 "    r2.xyz = r1.xyz*hg_Params[0].www;\n"
                 "    r2.xyz = floor(r2.xyz);\n"
                 "    r2.xyz = r2.xyz + c0.yyy;\n"
                 "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
                 "    r1 = r1 + c0.yyyy;\n"
                 "    r3.x = r1.x;\n"
                 "    r3.y = r2.x;\n"
                 "    r3.xy = r3.xy + hg_Params[3].xy;\n"
                 "    r3.xy = r3.xy*hg_Params[3].zw;\n"
                 "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
                 "    r3.x = r1.y;\n"
                 "    r3.y = r2.y;\n"
                 "    r3.xy = r3.xy + hg_Params[3].xy;\n"
                 "    r3.xy = r3.xy*hg_Params[3].zw;\n"
                 "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
                 "    r3.x = r1.z;\n"
                 "    r3.y = r2.z;\n"
                 "    r3.xy = r3.xy + hg_Params[3].xy;\n"
                 "    r3.xy = r3.xy*hg_Params[3].zw;\n"
                 "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
                 "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
                 "    return output;\n"
                 "}\n"
                 "//MD5=9263a2c0:8288b26d:8fbddfa1:77a5bd13\n"
                 "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
      }
      if (Target > 0x6060F
        && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n"
               "//LEN=000000068d\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "uniform mediump vec4 hg_ProgramLocal0;\n"
               "uniform mediump vec4 hg_ProgramLocal1;\n"
               "uniform mediump vec4 hg_ProgramLocal2;\n"
               "uniform mediump vec4 hg_ProgramLocal3;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "void main()\n"
               "{\n"
               "    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
               "    mediump vec4 r0, r1, r2, r3;\n"
               "\n"
               "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
               "    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n"
               "    r1 = max(r1, c0.xxxx);\n"
               "    r1 = min(r1, hg_ProgramLocal1);\n"
               "    r2.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
               "    r2.xyz = floor(r2.xyz);\n"
               "    r2.xyz = r2.xyz + c0.yyy;\n"
               "    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n"
               "    r1 = r1 + c0.yyyy;\n"
               "    r3.x = r1.x;\n"
               "    r3.y = r2.x;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.x = texture2D(hg_Texture1, r3.xy).x;\n"
               "    r3.x = r1.y;\n"
               "    r3.y = r2.y;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.y = texture2D(hg_Texture1, r3.xy).y;\n"
               "    r3.x = r1.z;\n"
               "    r3.y = r2.z;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.z = texture2D(hg_Texture1, r3.xy).z;\n"
               "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y :"
               " r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n"
               "}\n"
               "//MD5=a5cfaee8:157e3765:82b70125:1b812651\n"
               "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }
      return 0;
    }
    if (Target != 396048)
    {
      if (Target > 0x6060F
        && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n"
               "//LEN=0000000715\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "uniform mediump vec4 hg_ProgramLocal0;\n"
               "uniform mediump vec4 hg_ProgramLocal1;\n"
               "uniform mediump vec4 hg_ProgramLocal2;\n"
               "uniform mediump vec4 hg_ProgramLocal3;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "void main()\n"
               "{\n"
               "    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
               "    mediump vec4 r0, r1, r2, r3;\n"
               "\n"
               "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
               "    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n"
               "    r1 = max(r1, c0.xxxx);\n"
               "    r1 = min(r1, hg_ProgramLocal1);\n"
               "    r2 = r1*hg_ProgramLocal0.wwww;\n"
               "    r2 = floor(r2);\n"
               "    r2 = r2 + c0.yyyy;\n"
               "    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n"
               "    r1 = r1 + c0.yyyy;\n"
               "    r3.x = r1.x;\n"
               "    r3.y = r2.x;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.x = texture2D(hg_Texture1, r3.xy).x;\n"
               "    r3.x = r1.y;\n"
               "    r3.y = r2.y;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.y = texture2D(hg_Texture1, r3.xy).y;\n"
               "    r3.x = r1.z;\n"
               "    r3.y = r2.z;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.z = texture2D(hg_Texture1, r3.xy).z;\n"
               "    r3.x = r1.w;\n"
               "    r3.y = r2.w;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.w = texture2D(hg_Texture1, r3.xy).w;\n"
               "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y :"
               " r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n"
               "}\n"
               "//MD5=7949d19f:647deb0d:606cf61d:25a04486\n"
               "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }
      return 0;
    }
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000073b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, half4(hg_Params[1]));\n"
             "    r2 = r1*half4(hg_Params[0].wwww);\n"
             "    r2 = floor(r2);\n"
             "    r2 = r2 + c0.yyyy;\n"
             "    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n"
             "    r3.x = r1.w;\n"
             "    r3.y = r2.w;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.w = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).w;\n"
             "    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b5146dd3:d04f9178:3aab6ef7:97b6a091\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000068a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, hg_Params[1]);\n"
             "    r2 = r1*hg_Params[0].wwww;\n"
             "    r2 = floor(r2);\n"
             "    r2 = r2 + c0.yyyy;\n"
             "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
             "    r3.x = r1.w;\n"
             "    r3.y = r2.w;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n"
             "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=aa6d9d69:00cc6589:b7bb52c4:fb672a48\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (a2)
  {
    if (Target != 396048)
    {
      if (Target > 0x6060F
        && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n"
               "//LEN=00000006b2\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "uniform mediump vec4 hg_ProgramLocal0;\n"
               "uniform mediump vec4 hg_ProgramLocal1;\n"
               "uniform mediump vec4 hg_ProgramLocal2;\n"
               "uniform mediump vec4 hg_ProgramLocal3;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "void main()\n"
               "{\n"
               "    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
               "    mediump vec4 r0, r1, r2, r3;\n"
               "\n"
               "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
               "    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n"
               "    r1 = max(r1, c0.xxxx);\n"
               "    r1 = min(r1, hg_ProgramLocal1);\n"
               "    r1 = floor(r1 + vec4(0.500000));\n"
               "    r2.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
               "    r2.xyz = floor(r2.xyz);\n"
               "    r2.xyz = r2.xyz + c0.yyy;\n"
               "    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n"
               "    r1 = r1 + c0.yyyy;\n"
               "    r3.x = r1.x;\n"
               "    r3.y = r2.x;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.x = texture2D(hg_Texture1, r3.xy).x;\n"
               "    r3.x = r1.y;\n"
               "    r3.y = r2.y;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.y = texture2D(hg_Texture1, r3.xy).y;\n"
               "    r3.x = r1.z;\n"
               "    r3.y = r2.z;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.z = texture2D(hg_Texture1, r3.xy).z;\n"
               "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y :"
               " r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n"
               "}\n"
               "//MD5=fe9c2870:f4fd6520:781b2d50:b5800b8f\n"
               "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }
      return 0;
    }
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000006a9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, half4(hg_Params[1]));\n"
             "    r1 = round(r1);\n"
             "    r2.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = floor(r2.xyz);\n"
             "    r2.xyz = r2.xyz + c0.yyy;\n"
             "    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n"
             "    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ba2b5020:e21a8fc7:4195c0d3:4952a624\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000615\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, hg_Params[1]);\n"
             "    r1 = round(r1);\n"
             "    r2.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r2.xyz = floor(r2.xyz);\n"
             "    r2.xyz = r2.xyz + c0.yyy;\n"
             "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
             "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=3489e71d:d8b87767:07e113d5:dac13266\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else
  {
    if (Target != 396048)
    {
      if (Target > 0x6060F
        && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
      {
        return "//GLfs2.0      \n"
               "//LEN=000000073a\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "uniform defaultp sampler2D hg_Texture0;\n"
               "uniform defaultp sampler2D hg_Texture1;\n"
               "uniform mediump vec4 hg_ProgramLocal0;\n"
               "uniform mediump vec4 hg_ProgramLocal1;\n"
               "uniform mediump vec4 hg_ProgramLocal2;\n"
               "uniform mediump vec4 hg_ProgramLocal3;\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "void main()\n"
               "{\n"
               "    const mediump vec4 c0 = vec4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
               "    mediump vec4 r0, r1, r2, r3;\n"
               "\n"
               "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
               "    r1 = r0*hg_ProgramLocal0.xxxx + hg_ProgramLocal0.yyyy;\n"
               "    r1 = max(r1, c0.xxxx);\n"
               "    r1 = min(r1, hg_ProgramLocal1);\n"
               "    r1 = floor(r1 + vec4(0.500000));\n"
               "    r2 = r1*hg_ProgramLocal0.wwww;\n"
               "    r2 = floor(r2);\n"
               "    r2 = r2 + c0.yyyy;\n"
               "    r1 = mod(r1, hg_ProgramLocal0.zzzz);\n"
               "    r1 = r1 + c0.yyyy;\n"
               "    r3.x = r1.x;\n"
               "    r3.y = r2.x;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.x = texture2D(hg_Texture1, r3.xy).x;\n"
               "    r3.x = r1.y;\n"
               "    r3.y = r2.y;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.y = texture2D(hg_Texture1, r3.xy).y;\n"
               "    r3.x = r1.z;\n"
               "    r3.y = r2.z;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.z = texture2D(hg_Texture1, r3.xy).z;\n"
               "    r3.x = r1.w;\n"
               "    r3.y = r2.w;\n"
               "    r3.xy = r3.xy + hg_ProgramLocal3.xy;\n"
               "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
               "    r1.w = texture2D(hg_Texture1, r3.xy).w;\n"
               "    gl_FragColor = vec4(hg_ProgramLocal2.x < 0.00000 ? r0.x : r1.x, hg_ProgramLocal2.y < 0.00000 ? r0.y :"
               " r1.y, hg_ProgramLocal2.z < 0.00000 ? r0.z : r1.z, hg_ProgramLocal2.w < 0.00000 ? r0.w : r1.w);\n"
               "}\n"
               "//MD5=cf4b61f8:5234da11:e8d20cae:98f38ab4\n"
               "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
      }
      return 0;
    }
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000074f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*half4(hg_Params[0].xxxx) + half4(hg_Params[0].yyyy);\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, half4(hg_Params[1]));\n"
             "    r1 = round(r1);\n"
             "    r2 = r1*half4(hg_Params[0].wwww);\n"
             "    r2 = floor(r2);\n"
             "    r2 = r2 + c0.yyyy;\n"
             "    r1 = r1 - half4(hg_Params[0].zzzz)*floor(r1/half4(hg_Params[0].zzzz));\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.x = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.z = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).z;\n"
             "    r3.x = r1.w;\n"
             "    r3.y = r2.w;\n"
             "    r3.xy = r3.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r1.w = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).w;\n"
             "    output.color0 = select(float4(r1), float4(r0), hg_Params[2] < 0.00000h);\n"
             "    return output;\n"
             "}\n"
             "//MD5=131ada21:fe61a7dd:c3645ed8:df8b231e\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000069e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
             "    r1 = fmax(r1, c0.xxxx);\n"
             "    r1 = fmin(r1, hg_Params[1]);\n"
             "    r1 = round(r1);\n"
             "    r2 = r1*hg_Params[0].wwww;\n"
             "    r2 = floor(r2);\n"
             "    r2 = r2 + c0.yyyy;\n"
             "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
             "    r1 = r1 + c0.yyyy;\n"
             "    r3.x = r1.x;\n"
             "    r3.y = r2.x;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
             "    r3.x = r1.y;\n"
             "    r3.y = r2.y;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
             "    r3.x = r1.z;\n"
             "    r3.y = r2.z;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
             "    r3.x = r1.w;\n"
             "    r3.y = r2.w;\n"
             "    r3.xy = r3.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n"
             "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
             "    return output;\n"
             "}\n"
             "//MD5=52ea6efa:ae1d09bb:5ff0d6c3:c1f69c84\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
}

void InitApply1DProgramDescriptor(HGProgramDescriptor *this, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx3LUTLinear_hgc_visible", "//Metal1.0     \n//LEN=00000004bb\n[[ visible ]] FragmentOut Apply1Dx3LUTLinear_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
        "    float4 r0, r1, r2, r3;\n"
        "    FragmentOut output;\n"
        "\n"
        "    r0 = color0;\n"
        "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
        "    r1 = fmax(r1, c0.xxxx);\n"
        "    r1 = fmin(r1, hg_Params[1]);\n"
        "    r2.xyz = r1.xyz*hg_Params[0].www;\n"
        "    r2.xyz = floor(r2.xyz);\n"
        "    r2.xyz = r2.xyz + c0.yyy;\n"
        "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
        "    r1 = r1 + c0.yyyy;\n"
        "    r3.x = r1.x;\n"
        "    r3.y = r2.x;\n"
        "    r3.xy = r3.xy + hg_Params[3].xy;\n"
        "    r3.xy = r3.xy*hg_Params[3].zw;\n"
        "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
        "    r3.x = r1.y;\n"
        "    r3.y = r2.y;\n"
        "    r3.xy = r3.xy + hg_Params[3].xy;\n"
        "    r3.xy = r3.xy*hg_Params[3].zw;\n"
        "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
        "    r3.x = r1.z;\n"
        "    r3.y = r2.z;\n"
        "    r3.xy = r3.xy + hg_Params[3].xy;\n"
        "    r3.xy = r3.xy*hg_Params[3].zw;\n"
        "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
        "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
        "    return output;\n"
        "}\n");
      HGProgramDescriptor::SetFragmentFunctionName(this, "Apply1Dx3LUTLinear");
    }
    HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx4LUTLinear_hgc_visible", "//Metal1.0     \n//LEN=0000000544\n[[ visible ]] FragmentOut Apply1Dx4LUTLinear_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
      "    float4 r0, r1, r2, r3;\n"
      "    FragmentOut output;\n"
      "\n"
      "    r0 = color0;\n"
      "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
      "    r1 = fmax(r1, c0.xxxx);\n"
      "    r1 = fmin(r1, hg_Params[1]);\n"
      "    r2 = r1*hg_Params[0].wwww;\n"
      "    r2 = floor(r2);\n"
      "    r2 = r2 + c0.yyyy;\n"
      "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
      "    r1 = r1 + c0.yyyy;\n"
      "    r3.x = r1.x;\n"
      "    r3.y = r2.x;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
      "    r3.x = r1.y;\n"
      "    r3.y = r2.y;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
      "    r3.x = r1.z;\n"
      "    r3.y = r2.z;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
      "    r3.x = r1.w;\n"
      "    r3.y = r2.w;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n"
      "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
      "    return output;\n"
      "}\n");
    HGProgramDescriptor::SetFragmentFunctionName(this, "Apply1Dx4LUTLinear");
  }
  if (a2)
  {
    HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx3LUTNearest_hgc_visible", "//Metal1.0     \n//LEN=00000004d0\n[[ visible ]] FragmentOut Apply1Dx3LUTNearest_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
      "    float4 r0, r1, r2, r3;\n"
      "    FragmentOut output;\n"
      "\n"
      "    r0 = color0;\n"
      "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
      "    r1 = fmax(r1, c0.xxxx);\n"
      "    r1 = fmin(r1, hg_Params[1]);\n"
      "    r1 = round(r1);\n"
      "    r2.xyz = r1.xyz*hg_Params[0].www;\n"
      "    r2.xyz = floor(r2.xyz);\n"
      "    r2.xyz = r2.xyz + c0.yyy;\n"
      "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
      "    r1 = r1 + c0.yyyy;\n"
      "    r3.x = r1.x;\n"
      "    r3.y = r2.x;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
      "    r3.x = r1.y;\n"
      "    r3.y = r2.y;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
      "    r3.x = r1.z;\n"
      "    r3.y = r2.z;\n"
      "    r3.xy = r3.xy + hg_Params[3].xy;\n"
      "    r3.xy = r3.xy*hg_Params[3].zw;\n"
      "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
      "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
      "    return output;\n"
      "}\n");
    HGProgramDescriptor::SetFragmentFunctionName(this, "Apply1Dx3LUTNearest");
  }
  HGProgramDescriptor::SetVisibleShaderWithSource(this, "Apply1Dx4LUTNearest_hgc_visible", "//Metal1.0     \n//LEN=0000000559\n[[ visible ]] FragmentOut Apply1Dx4LUTNearest_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = r0*hg_Params[0].xxxx + hg_Params[0].yyyy;\n"
    "    r1 = fmax(r1, c0.xxxx);\n"
    "    r1 = fmin(r1, hg_Params[1]);\n"
    "    r1 = round(r1);\n"
    "    r2 = r1*hg_Params[0].wwww;\n"
    "    r2 = floor(r2);\n"
    "    r2 = r2 + c0.yyyy;\n"
    "    r1 = r1 - hg_Params[0].zzzz*floor(r1/hg_Params[0].zzzz);\n"
    "    r1 = r1 + c0.yyyy;\n"
    "    r3.x = r1.x;\n"
    "    r3.y = r2.x;\n"
    "    r3.xy = r3.xy + hg_Params[3].xy;\n"
    "    r3.xy = r3.xy*hg_Params[3].zw;\n"
    "    r1.x = hg_Texture1.sample(hg_Sampler1, r3.xy).x;\n"
    "    r3.x = r1.y;\n"
    "    r3.y = r2.y;\n"
    "    r3.xy = r3.xy + hg_Params[3].xy;\n"
    "    r3.xy = r3.xy*hg_Params[3].zw;\n"
    "    r1.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
    "    r3.x = r1.z;\n"
    "    r3.y = r2.z;\n"
    "    r3.xy = r3.xy + hg_Params[3].xy;\n"
    "    r3.xy = r3.xy*hg_Params[3].zw;\n"
    "    r1.z = hg_Texture1.sample(hg_Sampler1, r3.xy).z;\n"
    "    r3.x = r1.w;\n"
    "    r3.y = r2.w;\n"
    "    r3.xy = r3.xy + hg_Params[3].xy;\n"
    "    r3.xy = r3.xy*hg_Params[3].zw;\n"
    "    r1.w = hg_Texture1.sample(hg_Sampler1, r3.xy).w;\n"
    "    output.color0 = select(r1, r0, hg_Params[2] < 0.00000f);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(this, "Apply1Dx4LUTNearest");
}

void sub_1B78586E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void **a21,void **a22)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a21)
  {
    int32x2_t v23 = a22;
    uint64_t v24 = a21;
    if (a22 != a21)
    {
      do
      {
        if (*((char *)v23 - 17) < 0) {
          operator delete(*(v23 - 5));
        }
        v23 -= 6;
      }
      while (v23 != a21);
      uint64_t v24 = a21;
    }
    operator delete(v24);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Get1DLUTLinearTile(HGTile *a1, const float *a2, float32x4_t *a3, float32x4_t *a4, int a5)
{
  int v7 = *((_DWORD *)a1 + 2) - *(_DWORD *)a1;
  float v8 = a4->f32[3];
  int v9 = *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 1);
  long long v10 = *(_OWORD *)a2;
  float32x4_t v11 = *a3;
  float32x4_t v12 = *a4;
  float32x4_t v13 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 1);
  uint64_t v14 = *((void *)a1 + 12);
  if (a5)
  {
    if (v8 >= 0.0)
    {
      if (v9 >= 1 && v7 >= 1)
      {
        int v47 = 0;
        uint64_t v48 = *((void *)a1 + 10);
        uint64_t v49 = *((void *)a1 + 2);
        uint64_t v50 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
        uint64_t v51 = 16 * *((int *)a1 + 6);
        uint64_t v52 = 16 * *((int *)a1 + 22);
        int8x16_t v53 = (int8x16_t)vcltzq_f32(v12);
        do
        {
          uint64_t v54 = 0;
          do
          {
            float32x4_t v55 = *(float32x4_t *)(v48 + v54);
            float32x4_t v56 = vminq_f32(vmaxq_f32(vaddq_f32(v13, vmulq_n_f32(v55, *(float *)&v10)), (float32x4_t)0), v11);
            int32x4_t v57 = vcvtq_s32_f32(v56);
            float32x4_t v58 = vcvtq_f32_s32(v57);
            int32x4_t v59 = vshlq_n_s32(v57, 2uLL);
            float32x4_t v60 = vsubq_f32(v56, v58);
            uint64_t v61 = v59.i32[2];
            v58.i64[1] = v59.i32[3];
            v59.i64[1] = v59.i32[1];
            float v62 = (uint64_t *)(v14 + 4 * v59.i32[0]);
            float v63 = (uint64_t *)(v14 + 4 * v59.i32[1]);
            uint64_t v64 = v14 + 4 * v61;
            uint64_t v65 = v14 + 4 * v58.i64[1];
            v59.i64[0] = vslid_n_s64(*v62, *(void *)(v64 + 8), 0x20uLL);
            v58.i64[0] = vsrid_n_s64(*(void *)(v65 + 8), *v63, 0x20uLL);
            float32x4_t v66 = (float32x4_t)vzip1q_s32(v59, (int32x4_t)v58);
            v58.i64[0] = vslid_n_s64(v62[2], *(void *)(v64 + 24), 0x20uLL);
            v5.i64[0] = vsrid_n_s64(*(void *)(v65 + 24), v63[2], 0x20uLL);
            *(int8x16_t *)(v49 + v54) = vbslq_s8(v53, (int8x16_t)v55, (int8x16_t)vaddq_f32(v66, vmulq_f32(v60, vsubq_f32((float32x4_t)vzip1q_s32((int32x4_t)v58, v5), v66))));
            v54 += 16;
          }
          while (v50 != v54);
          ++v47;
          v49 += v51;
          v48 += v52;
        }
        while (v47 != v9);
      }
    }
    else if (v9 >= 1 && v7 >= 1)
    {
      int v15 = 0;
      uint64_t v16 = *((void *)a1 + 10);
      uint64_t v17 = *((void *)a1 + 2);
      uint64_t v18 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
      uint64_t v19 = 16 * *((int *)a1 + 6);
      uint64_t v20 = 16 * *((int *)a1 + 22);
      int8x16_t v21 = (int8x16_t)vcltzq_f32(v12);
      do
      {
        uint64_t v22 = 0;
        do
        {
          float32x4_t v23 = *(float32x4_t *)(v16 + v22);
          float32x4_t v24 = vminq_f32(vmaxq_f32(vaddq_f32(v13, vmulq_n_f32(v23, *(float *)&v10)), (float32x4_t)0), v11);
          int32x4_t v25 = vcvtq_s32_f32(v24);
          float32x4_t v26 = vcvtq_f32_s32(v25);
          int32x4_t v27 = vshlq_n_s32(v25, 2uLL);
          float32x4_t v28 = vsubq_f32(v24, v26);
          v26.i64[0] = vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL).u64[0];
          float32x4_t v29 = (uint64_t *)(v14 + 4 * v27.i32[0]);
          v27.i64[1] = v26.i32[1];
          float32x4_t v30 = (uint64_t *)(v14 + 4 * v26.i32[0]);
          uint64_t v31 = v14 + 4 * v26.i32[1];
          v27.i64[0] = vslid_n_s64(*v29, *(void *)(v31 + 8), 0x20uLL);
          int32x4_t v32 = (int32x4_t)vextq_s8((int8x16_t)v23, (int8x16_t)v23, 8uLL);
          v6.i64[0] = vsrid_n_s64(v32.i64[0], *v30, 0x20uLL);
          float32x4_t v33 = (float32x4_t)vzip1q_s32(v27, v6);
          v5.i64[0] = vslid_n_s64(v29[2], *(void *)(v31 + 24), 0x20uLL);
          v32.i64[0] = vsrid_n_s64(v32.i64[0], v30[2], 0x20uLL);
          *(int8x16_t *)(v17 + v22) = vbslq_s8(v21, (int8x16_t)v23, (int8x16_t)vaddq_f32(v33, vmulq_f32(v28, vsubq_f32((float32x4_t)vzip1q_s32(v5, v32), v33))));
          v22 += 16;
        }
        while (v18 != v22);
        ++v15;
        v17 += v19;
        v16 += v20;
      }
      while (v15 != v9);
    }
  }
  else if (v8 >= 0.0)
  {
    if (v9 >= 1 && v7 >= 1)
    {
      int v67 = 0;
      uint64_t v68 = v14 + 8;
      uint64_t v69 = *((void *)a1 + 10);
      uint64_t v70 = *((void *)a1 + 2);
      uint64_t v71 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
      uint64_t v72 = 16 * *((int *)a1 + 6);
      uint64_t v73 = 16 * *((int *)a1 + 22);
      int8x16_t v74 = (int8x16_t)vcltzq_f32(v12);
      v75.i64[0] = 0x3F0000003F000000;
      v75.i64[1] = 0x3F0000003F000000;
      do
      {
        uint64_t v76 = 0;
        do
        {
          float32x4_t v77 = *(float32x4_t *)(v69 + v76);
          int32x4_t v78 = vshlq_n_s32(vcvtq_s32_f32(vaddq_f32(vminq_f32(vmaxq_f32(vaddq_f32(v13, vmulq_n_f32(v77, *(float *)&v10)), (float32x4_t)0), v11), v75)), 2uLL);
          v79.i64[1] = v78.i32[3];
          uint64_t v80 = 4 * v78.i32[1];
          v78.i64[0] = vslid_n_s64(*(void *)(v14 + 4 * v78.i32[0]), *(void *)(v68 + 4 * v78.i32[2]), 0x20uLL);
          v79.i64[0] = vsrid_n_s64(*(void *)(v68 + 4 * v78.i32[3]), *(void *)(v14 + v80), 0x20uLL);
          *(int8x16_t *)(v70 + v76) = vbslq_s8(v74, (int8x16_t)v77, (int8x16_t)vzip1q_s32(v78, v79));
          v76 += 16;
        }
        while (v71 != v76);
        ++v67;
        v70 += v72;
        v69 += v73;
      }
      while (v67 != v9);
    }
  }
  else if (v9 >= 1 && v7 >= 1)
  {
    int v34 = 0;
    uint64_t v35 = *((void *)a1 + 10);
    uint64_t v36 = *((void *)a1 + 2);
    uint64_t v37 = 16 * (*((_DWORD *)a1 + 2) - *(_DWORD *)a1);
    uint64_t v38 = 16 * *((int *)a1 + 6);
    uint64_t v39 = 16 * *((int *)a1 + 22);
    int8x16_t v40 = (int8x16_t)vcltzq_f32(v12);
    v41.i64[0] = 0x3F0000003F000000;
    v41.i64[1] = 0x3F0000003F000000;
    do
    {
      uint64_t v42 = 0;
      do
      {
        float32x4_t v43 = *(float32x4_t *)(v35 + v42);
        int32x4_t v44 = vshlq_n_s32(vcvtq_s32_f32(vaddq_f32(vminq_f32(vmaxq_f32(vaddq_f32(v13, vmulq_n_f32(v43, *(float *)&v10)), (float32x4_t)0), v11), v41)), 2uLL);
        uint64_t v45 = 4 * v44.i32[1];
        v44.i64[0] = vslid_n_s64(*(void *)(v14 + 4 * v44.i32[0]), *(void *)(v14 + 8 + 4 * v44.i32[2]), 0x20uLL);
        int32x4_t v46 = (int32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 8uLL);
        v46.i64[0] = vsrid_n_s64(v46.i64[0], *(void *)(v14 + v45), 0x20uLL);
        *(int8x16_t *)(v36 + v42) = vbslq_s8(v40, (int8x16_t)v43, (int8x16_t)vzip1q_s32(v44, v46));
        v42 += 16;
      }
      while (v37 != v42);
      ++v34;
      v36 += v38;
      v35 += v39;
    }
    while (v34 != v9);
  }
  return 0;
}

void HGLegacyBlend::HGLegacyBlend(HGLegacyBlend *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10E1FE0;
  v1[51] = 0;
  operator new();
}

void sub_1B7858D10(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 408);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

uint64_t HGLegacyBlend::SetParameter(HGLegacyBlend *this, uint64_t a2, double a3, double a4, float a5, float a6, char *a7)
{
  uint64_t v7 = 0xFFFFFFFFLL;
  switch((int)a2)
  {
    case 0:
      unsigned int v8 = vcvtms_s32_f32(*(float *)&a3);
      if (v8 > 8) {
        goto LABEL_7;
      }
      if (*((_DWORD *)this + 106) == v8)
      {
        uint64_t v7 = 0;
        goto LABEL_5;
      }
      *((_DWORD *)this + 106) = v8;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      uint64_t result = 1;
      break;
    case 1:
      *((_DWORD *)this + 104) = LODWORD(a3);
      *(int32x4_t *)*((void *)this + 55) = vdupq_lane_s32(*(int32x2_t *)&a3, 0);
      HGNode::ClearBits((HGNode *)this, a2, a7);
      uint64_t result = 1;
      break;
    case 2:
      unsigned int v10 = vcvtms_s32_f32(*(float *)&a3);
      int v11 = v10 != 0;
      if (*((_DWORD *)this + 107) == v11)
      {
LABEL_7:
        uint64_t result = 0xFFFFFFFFLL;
      }
      else
      {
        *((_DWORD *)this + 107) = v11;
        *((_DWORD *)this + 108) = v10 == 0;
        HGNode::ClearBits((HGNode *)this, a2, a7);
        uint64_t result = 1;
      }
      break;
    case 5:
      *((_DWORD *)this + 105) = LODWORD(a3);
      *(float *)&a4 = 1.0 / *(float *)&a3;
      *(int32x4_t *)(*((void *)this + 55) + 16) = vdupq_lane_s32(*(int32x2_t *)&a4, 0);
      *(int32x4_t *)(*((void *)this + 55) + 32) = vdupq_lane_s32(*(int32x2_t *)&a3, 0);
      HGNode::ClearBits((HGNode *)this, a2, a7);
      uint64_t result = 1;
      break;
    default:
LABEL_5:
      uint64_t result = v7;
      break;
  }
  return result;
}

void HGLegacyBlend::~HGLegacyBlend(HGNode *this)
{
  *(void *)this = &unk_1F10E1FE0;
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E1FE0;
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10E1FE0;
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404247E4FDLL);
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

uint64_t HGLegacyBlend::GetParameter(HGLegacyBlend *this, int a2, float *a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  switch(a2)
  {
    case 0:
      int v5 = *((_DWORD *)this + 106);
      goto LABEL_5;
    case 1:
      uint64_t v6 = *((void *)this + 55);
      *a3 = *(float *)v6;
      a3[1] = *(float *)(v6 + 4);
      a3[2] = *(float *)(v6 + 8);
      int v7 = *(_DWORD *)(v6 + 12);
      goto LABEL_7;
    case 2:
      int v5 = *((_DWORD *)this + 107);
LABEL_5:
      *a3 = (float)v5;
      a3[1] = 0.0;
      a3[2] = 0.0;
      int v7 = 0;
      goto LABEL_7;
    case 5:
      uint64_t v8 = *((void *)this + 55);
      *a3 = *(float *)(v8 + 32);
      a3[1] = *(float *)(v8 + 36);
      a3[2] = *(float *)(v8 + 40);
      int v7 = *(_DWORD *)(v8 + 44);
LABEL_7:
      uint64_t result = 0;
      *((_DWORD *)a3 + 3) = v7;
      break;
    default:
      return result;
  }
  return result;
}

void HGLegacyBlend::Clone(HGLegacyBlend *this)
{
  uint64_t v1 = (HGLegacyBlend *)HGObject::operator new(0x1C0uLL);
  HGLegacyBlend::HGLegacyBlend(v1);
}

void sub_1B7859218(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

HGNode *HGLegacyBlend::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, *((_DWORD *)this + 107));
  int v5 = HGRenderer::GetInput(a2, this, *((_DWORD *)this + 108));
  uint64_t v6 = v5;
  if (!Input) {
    return v6;
  }
  if (!v5) {
    return Input;
  }
  float v7 = *((float *)this + 104);
  if (v7 == 0.0) {
    return Input;
  }
  if (v7 == 1.0 && *((_DWORD *)this + 106) == 8) {
    return v6;
  }
  if (!*((_DWORD *)this + 107)) {
    return this;
  }
  uint64_t v9 = (*(uint64_t (**)(HGNode *))(*(void *)this + 576))(this);
  uint64_t v10 = *((void *)this + 51);
  if (v10 == v9)
  {
    if (v9)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
      uint64_t v9 = *((void *)this + 51);
    }
  }
  else
  {
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
    }
    *((void *)this + 51) = v9;
  }
  (*(void (**)(uint64_t, uint64_t, double, double, double, double))(*(void *)v9 + 96))(v9, 2, 0.0, 0.0, 0.0, 0.0);
  (*(void (**)(void, void, HGNode *))(**((void **)this + 51) + 120))(*((void *)this + 51), 0, Input);
  (*(void (**)(void, uint64_t, HGNode *))(**((void **)this + 51) + 120))(*((void *)this + 51), 1, v6);
  uint64_t v11 = *((void *)this + 51);
  uint64_t v12 = (*(uint64_t (**)(HGNode *, uint64_t))(*(void *)this + 152))(this, 1);
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v11 + 136))(v11, 0, v12);
  uint64_t v13 = *((void *)this + 51);
  uint64_t v14 = (*(uint64_t (**)(HGNode *, void))(*(void *)this + 152))(this, 0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v13 + 136))(v13, 1, v14);
  uint64_t v15 = *((void *)this + 51);
  uint64_t v16 = (*(uint64_t (**)(HGNode *, uint64_t))(*(void *)this + 152))(this, 0xFFFFFFFFLL);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 136))(v15, 0xFFFFFFFFLL, v16);
  return (HGNode *)*((void *)this + 51);
}

void sub_1B7859564(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGLegacyBlend::GetDOD(HGLegacyBlend *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HGLegacyBlend::GetROI(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 > 1) {
    return 0;
  }
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  Input = HGRenderer::GetInput(a2, this, a3);
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v10 = HGRectIntersection(DOD, v9, v5, v4);
  if (HGRectIsNull(v10, v11)) {
    return 0;
  }
  return v5;
}

uint64_t HGLegacyBlend::RenderTile(HGLegacyBlend *this, HGTile *a2, int a3, float *a4)
{
  if (!a4) {
    return 1;
  }
  uint64_t v4 = (_OWORD *)*((void *)this + 55);
  v105[0] = *v4;
  long long v5 = v4[4];
  v105[3] = v4[3];
  v105[4] = v5;
  *(float *)&long long v5 = *a4;
  v105[0] = vdupq_lane_s32(*(int32x2_t *)&v5, 0);
  uint64_t v6 = a4 + 4;
  float32x4_t v7 = vld1q_dup_f32(v6);
  v105[1] = v7;
  uint64_t v8 = a4 + 8;
  float32x4_t v9 = vld1q_dup_f32(v8);
  v105[2] = v9;
  uint64_t v10 = (float32x4_t *)*((void *)a2 + 10);
  uint64_t v11 = (float32x4_t *)*((void *)a2 + 12);
  if (v10)
  {
    if (v11)
    {
      ((void (*)(HGTile *, _OWORD *, HGLegacyBlend *))s_func_blend_table[a3])(a2, v105, this);
    }
    else if (a3 == 8)
    {
      int v34 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
      if (v34 >= 1)
      {
        unint64_t v35 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        uint64_t v36 = (float32x4_t *)*((void *)a2 + 2);
        uint64_t v37 = *((int *)a2 + 6);
        uint64_t v38 = *((int *)a2 + 22);
        if ((int)v35 < 4)
        {
          if ((int)v35 >= 1)
          {
            int v95 = 0;
            uint64_t v96 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
            uint64_t v97 = 16 * v37;
            uint64_t v98 = 16 * v38;
            do
            {
              unint64_t v99 = 0;
              do
              {
                v36[v99 / 0x10] = vsubq_f32(v10[v99 / 0x10], vmulq_n_f32(v10[v99 / 0x10], *(float *)&v5));
                v99 += 16;
              }
              while (v96 != v99);
              ++v95;
              uint64_t v36 = (float32x4_t *)((char *)v36 + v97);
              uint64_t v10 = (float32x4_t *)((char *)v10 + v98);
            }
            while (v95 != v34);
          }
        }
        else
        {
          int v39 = 0;
          uint64_t v40 = 16 * v38;
          uint64_t v41 = 16 * v37;
          uint64_t v42 = v36 + 4;
          float32x4_t v43 = v10 + 4;
          do
          {
            unint64_t v44 = 0;
            uint64_t v45 = v43;
            int32x4_t v46 = v42;
            uint64_t v47 = 3;
            do
            {
              uint64_t v48 = v46;
              uint64_t v49 = v45;
              float32x4_t v50 = vsubq_f32(v10[v47 - 2], vmulq_n_f32(v10[v47 - 2], *(float *)&v5));
              float32x4_t v51 = vsubq_f32(v10[v47 - 1], vmulq_n_f32(v10[v47 - 1], *(float *)&v5));
              float32x4_t v52 = vsubq_f32(v10[v47], vmulq_n_f32(v10[v47], *(float *)&v5));
              int8x16_t v53 = &v36[v47];
              v53[-3] = vsubq_f32(v10[v47 - 3], vmulq_n_f32(v10[v47 - 3], *(float *)&v5));
              v53[-2] = v50;
              v44 += 4;
              v53[-1] = v51;
              *int8x16_t v53 = v52;
              v47 += 4;
              v46 += 4;
              uint64_t v45 = v49 + 4;
            }
            while ((uint64_t)v44 < (uint64_t)(v35 - 3));
            if ((int)v35 > (int)v44)
            {
              do
              {
                float32x4_t v54 = *v49++;
                *v48++ = vsubq_f32(v54, vmulq_n_f32(v54, *(float *)&v5));
                ++v44;
              }
              while (v44 < v35);
            }
            ++v39;
            uint64_t v10 = (float32x4_t *)((char *)v10 + v40);
            uint64_t v36 = (float32x4_t *)((char *)v36 + v41);
            uint64_t v42 = (float32x4_t *)((char *)v42 + v41);
            float32x4_t v43 = (float32x4_t *)((char *)v43 + v40);
          }
          while (v39 != v34);
        }
      }
    }
    else
    {
      uint64_t v67 = *((void *)a2 + 2);
      if ((float32x4_t *)v67 != v10)
      {
        int v68 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
        if (v68 >= 1)
        {
          unint64_t v69 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
          uint64_t v70 = *((int *)a2 + 6);
          uint64_t v71 = *((int *)a2 + 22);
          if ((int)v69 < 4)
          {
            if ((int)v69 >= 1)
            {
              int v100 = 0;
              uint64_t v101 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
              uint64_t v102 = 16 * v70;
              uint64_t v103 = 16 * v71;
              do
              {
                unint64_t v104 = 0;
                do
                {
                  *(float32x4_t *)(v67 + v104) = v10[v104 / 0x10];
                  v104 += 16;
                }
                while (v101 != v104);
                ++v100;
                v67 += v102;
                uint64_t v10 = (float32x4_t *)((char *)v10 + v103);
              }
              while (v100 != v68);
            }
          }
          else
          {
            int v72 = 0;
            uint64_t v73 = 16 * v71;
            uint64_t v74 = 16 * v70;
            float32x4_t v75 = (_OWORD *)(v67 + 64);
            uint64_t v76 = (long long *)&v10[4];
            do
            {
              unint64_t v77 = 0;
              int32x4_t v78 = v76;
              int32x4_t v79 = v75;
              uint64_t v80 = 3;
              do
              {
                float v81 = v79;
                float v82 = v78;
                float32x4_t v83 = v10[v80 - 2];
                float32x4_t v84 = v10[v80 - 1];
                float32x4_t v85 = v10[v80];
                float v86 = (float32x4_t *)(v67 + v80 * 16);
                v86[-3] = v10[v80 - 3];
                v86[-2] = v83;
                v77 += 4;
                v86[-1] = v84;
                *float v86 = v85;
                v80 += 4;
                v79 += 4;
                int32x4_t v78 = v82 + 4;
              }
              while ((uint64_t)v77 < (uint64_t)(v69 - 3));
              if ((int)v69 > (int)v77)
              {
                do
                {
                  long long v87 = *v82++;
                  *v81++ = v87;
                  ++v77;
                }
                while (v77 < v69);
              }
              ++v72;
              uint64_t v10 = (float32x4_t *)((char *)v10 + v73);
              v67 += v74;
              float32x4_t v75 = (_OWORD *)((char *)v75 + v74);
              uint64_t v76 = (long long *)((char *)v76 + v73);
            }
            while (v72 != v68);
          }
        }
      }
    }
  }
  else if (v11)
  {
    uint64_t v13 = (float32x4_t *)*((void *)a2 + 2);
    if (*(float *)&v5 != 1.0 || v13 != v11)
    {
      int v14 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
      if (v14 >= 1)
      {
        unint64_t v15 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
        uint64_t v16 = *((int *)a2 + 6);
        uint64_t v17 = *((int *)a2 + 26);
        if ((int)v15 < 4)
        {
          if ((int)v15 >= 1)
          {
            int v90 = 0;
            uint64_t v91 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
            uint64_t v92 = 16 * v16;
            uint64_t v93 = 16 * v17;
            do
            {
              unint64_t v94 = 0;
              do
              {
                v13[v94 / 0x10] = vmulq_n_f32(v11[v94 / 0x10], *(float *)&v5);
                v94 += 16;
              }
              while (v91 != v94);
              ++v90;
              uint64_t v13 = (float32x4_t *)((char *)v13 + v92);
              uint64_t v11 = (float32x4_t *)((char *)v11 + v93);
            }
            while (v90 != v14);
          }
        }
        else
        {
          int v18 = 0;
          uint64_t v19 = 16 * v17;
          uint64_t v20 = 16 * v16;
          int8x16_t v21 = v13 + 4;
          uint64_t v22 = v11 + 4;
          do
          {
            unint64_t v23 = 0;
            float32x4_t v24 = v22;
            int32x4_t v25 = v21;
            uint64_t v26 = 3;
            do
            {
              int32x4_t v27 = v25;
              float32x4_t v28 = v24;
              float32x4_t v29 = vmulq_n_f32(v11[v26 - 2], *(float *)&v5);
              float32x4_t v30 = vmulq_n_f32(v11[v26 - 1], *(float *)&v5);
              float32x4_t v31 = vmulq_n_f32(v11[v26], *(float *)&v5);
              int32x4_t v32 = &v13[v26];
              v32[-3] = vmulq_n_f32(v11[v26 - 3], *(float *)&v5);
              v32[-2] = v29;
              v23 += 4;
              v32[-1] = v30;
              *int32x4_t v32 = v31;
              v26 += 4;
              v25 += 4;
              float32x4_t v24 = v28 + 4;
            }
            while ((uint64_t)v23 < (uint64_t)(v15 - 3));
            if ((int)v15 > (int)v23)
            {
              do
              {
                float32x4_t v33 = *v28++;
                *v27++ = vmulq_n_f32(v33, *(float *)&v5);
                ++v23;
              }
              while (v23 < v15);
            }
            ++v18;
            uint64_t v11 = (float32x4_t *)((char *)v11 + v19);
            uint64_t v13 = (float32x4_t *)((char *)v13 + v20);
            int8x16_t v21 = (float32x4_t *)((char *)v21 + v20);
            uint64_t v22 = (float32x4_t *)((char *)v22 + v19);
          }
          while (v18 != v14);
        }
      }
    }
  }
  else
  {
    uint64_t v55 = (*((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1));
    if ((int)v55 >= 1)
    {
      int v56 = *((_DWORD *)a2 + 2);
      int v57 = v56 - *(_DWORD *)a2;
      float32x4_t v58 = (char *)*((void *)a2 + 2);
      uint64_t v59 = *((int *)a2 + 6);
      unsigned int v60 = v57 - 4;
      if (v57 < 4)
      {
        if (v57 >= 1)
        {
          size_t v88 = 16 * (v56 + ~*(_DWORD *)a2) + 16;
          uint64_t v89 = 16 * v59;
          do
          {
            bzero(v58, v88);
            v58 += v89;
            LODWORD(v55) = v55 - 1;
          }
          while (v55);
        }
      }
      else
      {
        size_t v61 = ((unint64_t)(v60 >> 2) << 6) + 64;
        uint64_t v62 = 16 * v59;
        unsigned int v63 = v60 & 0xFFFFFFFC;
        signed int v64 = (v60 & 0xFFFFFFFC) + 5;
        if (v57 > v64) {
          signed int v64 = v57;
        }
        size_t v65 = 16 * (v64 - v63 - 5) + 16;
        int v66 = v63 + 4;
        do
        {
          bzero(v58, v61);
          if (v57 > v66) {
            bzero(&v58[v61], v65);
          }
          v58 += v62;
          --v55;
        }
        while (v55);
      }
    }
  }
  return 0;
}

uint64_t HGLegacyBlend::RenderTile(HGLegacyBlend *this, HGTile *a2)
{
  return (*(uint64_t (**)(HGLegacyBlend *, HGTile *, void, void))(*(void *)this + 584))(this, a2, *((unsigned int *)this + 106), *((void *)this + 55));
}

HGBitmap *HGLegacyBlend::RenderPageDispatcher<(HGGPURenderAPI)0>(HGNode *a1, HGRect *a2)
{
  uint64_t v4 = *(HGRenderer **)&a2->var0;
  uint64_t v5 = (*(uint64_t (**)(HGNode *, void, void, void, void))(*(void *)a1 + 400))(a1, *(void *)&a2->var0, *((unsigned int *)a1 + 108), *(void *)&a2[1].var0, *(void *)&a2[1].var2);
  if (HGRectIsNull(v5, v6))
  {
    unsigned int v7 = *((_DWORD *)a1 + 107);
LABEL_6:
    Input = HGRenderer::GetInput(v4, a1, v7);
    HGRect v11 = a2[1];
    uint64_t v12 = *(HGBuffer **)&a2->var2;
    return HGGPURenderer::GetNodeBitmap(v4, Input, v11, v12, 1u);
  }
  if (*((float *)a1 + 104) == 1.0)
  {
    uint64_t v8 = (*(uint64_t (**)(HGNode *, HGRenderer *, void, void, void))(*(void *)a1 + 400))(a1, v4, *((unsigned int *)a1 + 107), *(void *)&a2[1].var0, *(void *)&a2[1].var2);
    if (HGRectIsNull(v8, v9))
    {
      unsigned int v7 = *((_DWORD *)a1 + 108);
      goto LABEL_6;
    }
  }

  return (HGBitmap *)HGNode::RenderPage(a1, a2);
}

HGBitmap *HGLegacyBlend::RenderPageDispatcher<(HGGPURenderAPI)1>(HGNode *a1, HGPage *a2)
{
  uint64_t v4 = *(HGRenderer **)a2;
  uint64_t v5 = (*(uint64_t (**)(HGNode *, void, void, void, void))(*(void *)a1 + 400))(a1, *(void *)a2, *((unsigned int *)a1 + 108), *((void *)a2 + 2), *((void *)a2 + 3));
  if (HGRectIsNull(v5, v6))
  {
    unsigned int v7 = *((_DWORD *)a1 + 107);
LABEL_6:
    Input = HGRenderer::GetInput(v4, a1, v7);
    HGRect v11 = (HGRect)*((_OWORD *)a2 + 1);
    uint64_t v12 = (HGBuffer *)*((void *)a2 + 1);
    return HGGPURenderer::GetNodeBitmap(v4, Input, v11, v12, 1u);
  }
  if (*((float *)a1 + 104) == 1.0)
  {
    uint64_t v8 = (*(uint64_t (**)(HGNode *, HGRenderer *, void, void, void))(*(void *)a1 + 400))(a1, v4, *((unsigned int *)a1 + 107), *((void *)a2 + 2), *((void *)a2 + 3));
    if (HGRectIsNull(v8, v9))
    {
      unsigned int v7 = *((_DWORD *)a1 + 108);
      goto LABEL_6;
    }
  }

  return (HGBitmap *)HGNode::RenderPageMetal(a1, a2);
}

uint64_t HGLegacyBlend::GetProgram(HGLegacyBlend *this, HGRenderer *a2)
{
  return s_arb_blend_table[*((int *)this + 106)](a2);
}

uint64_t HGLegacyBlend::InitProgramDescriptor(HGNode *this, HGProgramDescriptor *a2)
{
  uint64_t v2 = *((int *)this + 106);
  if ((int)v2 < 9) {
    s_programdesc_blend_table[v2](a2);
  }
  return HGNode::InitProgramDescriptor(this, a2);
}

uint64_t HGLegacyBlend::BindTexture(HGLegacyBlend *this, HGHandler *a2, int a3)
{
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  return 0;
}

uint64_t HGLegacyBlend::Bind(HGLegacyBlend *this, HGHandler *a2)
{
  return 0;
}

uint64_t GetHGBlendNormalTile(uint64_t a1, float32x4_t *a2)
{
  int v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    unint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    uint64_t v4 = *(float32x4_t **)(a1 + 80);
    uint64_t v5 = *(float32x4_t **)(a1 + 96);
    uint64_t v6 = *(float32x4_t **)(a1 + 16);
    uint64_t v7 = *(int *)(a1 + 24);
    uint64_t v8 = *(int *)(a1 + 104);
    uint64_t v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v38 = 0;
        uint64_t v39 = 16 * v9;
        uint64_t v40 = 16 * v8;
        uint64_t v41 = 16 * v7;
        uint64_t v42 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          unint64_t v43 = 0;
          do
          {
            float32x4_t v44 = vmulq_f32(v5[v43 / 0x10], *a2);
            v6[v43 / 0x10] = vaddq_f32(v44, vmulq_f32(v4[v43 / 0x10], vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 3))));
            v43 += 16;
          }
          while (v42 != v43);
          ++v38;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v39);
          uint64_t v5 = (float32x4_t *)((char *)v5 + v40);
          uint64_t v6 = (float32x4_t *)((char *)v6 + v41);
        }
        while (v38 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      int v14 = v4 + 4;
      unint64_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        unint64_t v17 = 0;
        unint64_t v18 = 0;
        uint64_t v19 = v16;
        uint64_t v20 = v15;
        int8x16_t v21 = v14;
        do
        {
          uint64_t v22 = v21;
          unint64_t v23 = v20;
          float32x4_t v24 = v19;
          float32x4_t v25 = vmulq_f32(v5[v17], *a2);
          float32x4_t v26 = vmulq_f32(v5[v17 + 1], *a2);
          float32x4_t v27 = vmulq_f32(v5[v17 + 2], *a2);
          float32x4_t v28 = vmulq_f32(v5[v17 + 3], *a2);
          float32x4_t v29 = a2[3];
          float32x4_t v30 = vaddq_f32(v26, vmulq_f32(v4[v17 + 1], vsubq_f32(v29, (float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 3))));
          float32x4_t v31 = vaddq_f32(v27, vmulq_f32(v4[v17 + 2], vsubq_f32(v29, (float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 3))));
          float32x4_t v32 = vaddq_f32(v28, vmulq_f32(v4[v17 + 3], vsubq_f32(v29, (float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 3))));
          float32x4_t v33 = &v6[v17];
          *float32x4_t v33 = vaddq_f32(v25, vmulq_f32(v4[v17], vsubq_f32(v29, (float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 3))));
          v33[1] = v30;
          v18 += 4;
          v17 += 4;
          v33[2] = v31;
          v33[3] = v32;
          v21 += 4;
          v20 += 4;
          uint64_t v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v34 = *v22++;
            float32x4_t v35 = v34;
            float32x4_t v36 = *v23++;
            float32x4_t v37 = vmulq_f32(v36, *a2);
            *v24++ = vaddq_f32(v37, vmulq_f32(v35, vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 3))));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        uint64_t v5 = (float32x4_t *)((char *)v5 + v11);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        int v14 = (float32x4_t *)((char *)v14 + v13);
        unint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendAddTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    unint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    uint64_t v4 = *(float32x4_t **)(a1 + 80);
    uint64_t v5 = *(float32x4_t **)(a1 + 96);
    uint64_t v6 = *(int8x16_t **)(a1 + 16);
    uint64_t v7 = *(int *)(a1 + 24);
    uint64_t v8 = *(int *)(a1 + 104);
    uint64_t v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v45 = 0;
        uint64_t v46 = 16 * v9;
        uint64_t v47 = 16 * v8;
        uint64_t v48 = 16 * v7;
        uint64_t v49 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          unint64_t v50 = 0;
          do
          {
            float32x4_t v51 = v4[v50 / 0x10];
            float32x4_t v52 = vmulq_f32(v5[v50 / 0x10], *(float32x4_t *)a2);
            float32x4_t v53 = vaddq_f32(v51, v52);
            v6[v50 / 0x10] = vbslq_s8(*(int8x16_t *)(a2 + 64), (int8x16_t)vsubq_f32(v53, vmulq_f32(v51, v52)), (int8x16_t)v53);
            v50 += 16;
          }
          while (v49 != v50);
          ++v45;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v46);
          uint64_t v5 = (float32x4_t *)((char *)v5 + v47);
          uint64_t v6 = (int8x16_t *)((char *)v6 + v48);
        }
        while (v45 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      int v14 = v4 + 4;
      unint64_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        unint64_t v17 = 0;
        unint64_t v18 = 0;
        uint64_t v19 = v16;
        uint64_t v20 = v15;
        int8x16_t v21 = v14;
        do
        {
          uint64_t v22 = v21;
          unint64_t v23 = v20;
          float32x4_t v24 = v19;
          float32x4_t v25 = v4[v17];
          float32x4_t v26 = v4[v17 + 1];
          float32x4_t v27 = v4[v17 + 2];
          float32x4_t v28 = v4[v17 + 3];
          float32x4_t v29 = vmulq_f32(v5[v17], *(float32x4_t *)a2);
          float32x4_t v30 = vmulq_f32(v5[v17 + 1], *(float32x4_t *)a2);
          float32x4_t v31 = vmulq_f32(v5[v17 + 2], *(float32x4_t *)a2);
          float32x4_t v32 = vmulq_f32(v5[v17 + 3], *(float32x4_t *)a2);
          float32x4_t v33 = vaddq_f32(v25, v29);
          float32x4_t v34 = vaddq_f32(v26, v30);
          float32x4_t v35 = vaddq_f32(v27, v31);
          float32x4_t v36 = vaddq_f32(v28, v32);
          int8x16_t v37 = (int8x16_t)vsubq_f32(v33, vmulq_f32(v25, v29));
          int8x16_t v38 = *(int8x16_t *)(a2 + 64);
          uint64_t v39 = &v6[v17];
          *uint64_t v39 = vbslq_s8(v38, v37, (int8x16_t)v33);
          v39[1] = vbslq_s8(v38, (int8x16_t)vsubq_f32(v34, vmulq_f32(v26, v30)), (int8x16_t)v34);
          v18 += 4;
          v17 += 4;
          v39[2] = vbslq_s8(v38, (int8x16_t)vsubq_f32(v35, vmulq_f32(v27, v31)), (int8x16_t)v35);
          v39[3] = vbslq_s8(v38, (int8x16_t)vsubq_f32(v36, vmulq_f32(v28, v32)), (int8x16_t)v36);
          v21 += 4;
          v20 += 4;
          uint64_t v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v40 = *v22++;
            float32x4_t v41 = v40;
            float32x4_t v42 = *v23++;
            float32x4_t v43 = vmulq_f32(v42, *(float32x4_t *)a2);
            float32x4_t v44 = vaddq_f32(v41, v43);
            *v24++ = vbslq_s8(*(int8x16_t *)(a2 + 64), (int8x16_t)vsubq_f32(v44, vmulq_f32(v41, v43)), (int8x16_t)v44);
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        uint64_t v5 = (float32x4_t *)((char *)v5 + v11);
        uint64_t v6 = (int8x16_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        int v14 = (float32x4_t *)((char *)v14 + v13);
        unint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (int8x16_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendBehindTile(uint64_t a1, float32x4_t *a2)
{
  int v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    unint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    uint64_t v4 = *(float32x4_t **)(a1 + 80);
    uint64_t v5 = *(float32x4_t **)(a1 + 96);
    uint64_t v6 = *(float32x4_t **)(a1 + 16);
    uint64_t v7 = *(int *)(a1 + 24);
    uint64_t v8 = *(int *)(a1 + 104);
    uint64_t v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v33 = 0;
        uint64_t v34 = 16 * v9;
        uint64_t v35 = 16 * v8;
        uint64_t v36 = 16 * v7;
        uint64_t v37 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          unint64_t v38 = 0;
          do
          {
            v6[v38 / 0x10] = vaddq_f32(v4[v38 / 0x10], vmulq_f32(vmulq_f32(v5[v38 / 0x10], *a2), vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v4[v38 / 0x10], 3))));
            v38 += 16;
          }
          while (v37 != v38);
          ++v33;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v34);
          uint64_t v5 = (float32x4_t *)((char *)v5 + v35);
          uint64_t v6 = (float32x4_t *)((char *)v6 + v36);
        }
        while (v33 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      int v14 = v4 + 4;
      unint64_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        unint64_t v17 = 0;
        unint64_t v18 = 0;
        uint64_t v19 = v16;
        uint64_t v20 = v15;
        int8x16_t v21 = v14;
        do
        {
          uint64_t v22 = v21;
          unint64_t v23 = v20;
          float32x4_t v24 = v19;
          float32x4_t v25 = a2[3];
          float32x4_t v26 = vaddq_f32(v4[v17 + 1], vmulq_f32(vmulq_f32(v5[v17 + 1], *a2), vsubq_f32(v25, (float32x4_t)vdupq_laneq_s32((int32x4_t)v4[v17 + 1], 3))));
          float32x4_t v27 = vaddq_f32(v4[v17 + 2], vmulq_f32(vmulq_f32(v5[v17 + 2], *a2), vsubq_f32(v25, (float32x4_t)vdupq_laneq_s32((int32x4_t)v4[v17 + 2], 3))));
          float32x4_t v28 = vaddq_f32(v4[v17 + 3], vmulq_f32(vmulq_f32(v5[v17 + 3], *a2), vsubq_f32(v25, (float32x4_t)vdupq_laneq_s32((int32x4_t)v4[v17 + 3], 3))));
          float32x4_t v29 = &v6[v17];
          *float32x4_t v29 = vaddq_f32(v4[v17], vmulq_f32(vmulq_f32(v5[v17], *a2), vsubq_f32(v25, (float32x4_t)vdupq_laneq_s32((int32x4_t)v4[v17], 3))));
          v29[1] = v26;
          v18 += 4;
          v17 += 4;
          v29[2] = v27;
          v29[3] = v28;
          v21 += 4;
          v20 += 4;
          uint64_t v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v30 = *v22++;
            float32x4_t v31 = v30;
            float32x4_t v32 = *v23++;
            *v24++ = vaddq_f32(v31, vmulq_f32(vmulq_f32(v32, *a2), vsubq_f32(a2[3], (float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 3))));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        uint64_t v5 = (float32x4_t *)((char *)v5 + v11);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        int v14 = (float32x4_t *)((char *)v14 + v13);
        unint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendDarkenTile(uint64_t a1, float32x4_t *a2)
{
  int v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    uint64_t v4 = *(float32x4_t **)(a1 + 80);
    uint64_t v5 = *(float32x4_t **)(a1 + 96);
    uint64_t v6 = *(float32x4_t **)(a1 + 16);
    uint64_t v7 = *(int *)(a1 + 24);
    uint64_t v8 = *(int *)(a1 + 104);
    uint64_t v9 = *(int *)(a1 + 88);
    if ((int)v3 < 3)
    {
      if ((int)v3 >= 1)
      {
        int v46 = 0;
        uint64_t v47 = 16 * v9;
        uint64_t v48 = 16 * v8;
        uint64_t v49 = 16 * v7;
        uint64_t v50 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          unint64_t v51 = 0;
          do
          {
            float32x4_t v52 = v4[v51 / 0x10];
            float32x4_t v53 = vmulq_f32(v5[v51 / 0x10], *a2);
            float32x4_t v54 = vmulq_laneq_f32(v53, v52, 3);
            float32x4_t v55 = vmulq_laneq_f32(v52, v53, 3);
            v6[v51 / 0x10] = vaddq_f32(vminq_f32(v54, v55), vsubq_f32(vsubq_f32(vaddq_f32(v52, v53), v54), v55));
            v51 += 16;
          }
          while (v50 != v51);
          ++v46;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v47);
          uint64_t v5 = (float32x4_t *)((char *)v5 + v48);
          uint64_t v6 = (float32x4_t *)((char *)v6 + v49);
        }
        while (v46 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      int v14 = v4 + 3;
      unint64_t v15 = v5 + 3;
      uint64_t v16 = v6 + 3;
      do
      {
        unint64_t v17 = 0;
        uint64_t v18 = 0;
        int v19 = 3;
        uint64_t v20 = v16;
        int8x16_t v21 = v15;
        uint64_t v22 = v14;
        do
        {
          unint64_t v23 = v22;
          float32x4_t v24 = v21;
          float32x4_t v25 = v20;
          int v26 = v19;
          float32x4_t v27 = v4[v17];
          float32x4_t v28 = v4[v17 + 1];
          float32x4_t v29 = v4[v17 + 2];
          float32x4_t v30 = vmulq_f32(v5[v17], *a2);
          float32x4_t v31 = vmulq_f32(v5[v17 + 1], *a2);
          float32x4_t v32 = vmulq_f32(v5[v17 + 2], *a2);
          float32x4_t v33 = vmulq_laneq_f32(v30, v27, 3);
          float32x4_t v34 = vmulq_laneq_f32(v31, v28, 3);
          float32x4_t v35 = vmulq_laneq_f32(v32, v29, 3);
          float32x4_t v36 = vmulq_laneq_f32(v27, v30, 3);
          float32x4_t v37 = vmulq_laneq_f32(v28, v31, 3);
          float32x4_t v38 = vmulq_laneq_f32(v29, v32, 3);
          uint64_t v39 = &v6[v17];
          v18 += 3;
          v17 += 3;
          v22 += 3;
          *uint64_t v39 = vaddq_f32(vminq_f32(v33, v36), vsubq_f32(vsubq_f32(vaddq_f32(v27, v30), v33), v36));
          v39[1] = vaddq_f32(vminq_f32(v34, v37), vsubq_f32(vsubq_f32(vaddq_f32(v28, v31), v34), v37));
          v39[2] = vaddq_f32(vminq_f32(v35, v38), vsubq_f32(vsubq_f32(vaddq_f32(v29, v32), v35), v38));
          v21 += 3;
          v20 += 3;
          int v19 = v26 + 3;
        }
        while (v18 < v3 - 2);
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v40 = *v23++;
            float32x4_t v41 = v40;
            float32x4_t v42 = *v24++;
            float32x4_t v43 = vmulq_f32(v42, *a2);
            float32x4_t v44 = vmulq_laneq_f32(v43, v41, 3);
            float32x4_t v45 = vmulq_laneq_f32(v41, v43, 3);
            *v25++ = vaddq_f32(vminq_f32(v44, v45), vsubq_f32(vsubq_f32(vaddq_f32(v41, v43), v44), v45));
            ++v26;
          }
          while ((int)v3 > v26);
        }
        ++v10;
        uint64_t v5 = (float32x4_t *)((char *)v5 + v11);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        int v14 = (float32x4_t *)((char *)v14 + v13);
        unint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendDifferenceTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    unint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    uint64_t v4 = *(float32x4_t **)(a1 + 80);
    uint64_t v5 = *(float32x4_t **)(a1 + 96);
    uint64_t v6 = *(float32x4_t **)(a1 + 16);
    uint64_t v7 = *(int *)(a1 + 24);
    uint64_t v8 = *(int *)(a1 + 104);
    uint64_t v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v54 = 0;
        uint64_t v55 = 16 * v9;
        uint64_t v56 = 16 * v8;
        uint64_t v57 = 16 * v7;
        uint64_t v58 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          unint64_t v59 = 0;
          do
          {
            float32x4_t v60 = v4[v59 / 0x10];
            float32x4_t v61 = vmulq_f32(v5[v59 / 0x10], *(float32x4_t *)a2);
            float32x4_t v62 = vmulq_laneq_f32(v61, v60, 3);
            float32x4_t v63 = vmulq_laneq_f32(v60, v61, 3);
            float32x4_t v64 = vsubq_f32(vaddq_f32(v60, v61), v62);
            v6[v59 / 0x10] = vaddq_f32(vabdq_f32(v62, v63), (float32x4_t)vbslq_s8(*(int8x16_t *)(a2 + 64), (int8x16_t)v64, (int8x16_t)vsubq_f32(v64, v63)));
            v59 += 16;
          }
          while (v58 != v59);
          ++v54;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v55);
          uint64_t v5 = (float32x4_t *)((char *)v5 + v56);
          uint64_t v6 = (float32x4_t *)((char *)v6 + v57);
        }
        while (v54 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      int v14 = v4 + 4;
      unint64_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        unint64_t v17 = 0;
        unint64_t v18 = 0;
        int v19 = v16;
        uint64_t v20 = v15;
        int8x16_t v21 = v14;
        do
        {
          uint64_t v22 = v21;
          unint64_t v23 = v20;
          float32x4_t v24 = v19;
          float32x4_t v25 = v4[v17];
          float32x4_t v26 = v4[v17 + 1];
          float32x4_t v27 = v4[v17 + 2];
          float32x4_t v28 = v4[v17 + 3];
          float32x4_t v29 = vmulq_f32(v5[v17], *(float32x4_t *)a2);
          float32x4_t v30 = vmulq_f32(v5[v17 + 1], *(float32x4_t *)a2);
          float32x4_t v31 = vmulq_f32(v5[v17 + 2], *(float32x4_t *)a2);
          float32x4_t v32 = vmulq_f32(v5[v17 + 3], *(float32x4_t *)a2);
          float32x4_t v33 = vmulq_laneq_f32(v29, v25, 3);
          float32x4_t v34 = vmulq_laneq_f32(v30, v26, 3);
          float32x4_t v35 = vmulq_laneq_f32(v31, v27, 3);
          float32x4_t v36 = vmulq_laneq_f32(v32, v28, 3);
          float32x4_t v37 = vmulq_laneq_f32(v25, v29, 3);
          float32x4_t v38 = vmulq_laneq_f32(v26, v30, 3);
          float32x4_t v39 = vmulq_laneq_f32(v27, v31, 3);
          float32x4_t v40 = vmulq_laneq_f32(v28, v32, 3);
          float32x4_t v41 = vsubq_f32(vaddq_f32(v25, v29), v33);
          float32x4_t v42 = vsubq_f32(vaddq_f32(v26, v30), v34);
          float32x4_t v43 = vsubq_f32(vaddq_f32(v27, v31), v35);
          float32x4_t v44 = vsubq_f32(vaddq_f32(v28, v32), v36);
          int8x16_t v45 = *(int8x16_t *)(a2 + 64);
          int v46 = &v6[v17];
          *int v46 = vaddq_f32(vabdq_f32(v33, v37), (float32x4_t)vbslq_s8(v45, (int8x16_t)v41, (int8x16_t)vsubq_f32(v41, v37)));
          v46[1] = vaddq_f32(vabdq_f32(v34, v38), (float32x4_t)vbslq_s8(v45, (int8x16_t)v42, (int8x16_t)vsubq_f32(v42, v38)));
          v18 += 4;
          v17 += 4;
          v46[2] = vaddq_f32(vabdq_f32(v35, v39), (float32x4_t)vbslq_s8(v45, (int8x16_t)v43, (int8x16_t)vsubq_f32(v43, v39)));
          v46[3] = vaddq_f32(vabdq_f32(v36, v40), (float32x4_t)vbslq_s8(v45, (int8x16_t)v44, (int8x16_t)vsubq_f32(v44, v40)));
          v21 += 4;
          v20 += 4;
          int v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v47 = *v22++;
            float32x4_t v48 = v47;
            float32x4_t v49 = *v23++;
            float32x4_t v50 = vmulq_f32(v49, *(float32x4_t *)a2);
            float32x4_t v51 = vmulq_laneq_f32(v50, v48, 3);
            float32x4_t v52 = vmulq_laneq_f32(v48, v50, 3);
            float32x4_t v53 = vsubq_f32(vaddq_f32(v48, v50), v51);
            *v24++ = vaddq_f32(vabdq_f32(v51, v52), (float32x4_t)vbslq_s8(*(int8x16_t *)(a2 + 64), (int8x16_t)v53, (int8x16_t)vsubq_f32(v53, v52)));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        uint64_t v5 = (float32x4_t *)((char *)v5 + v11);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        int v14 = (float32x4_t *)((char *)v14 + v13);
        unint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendLightenTile(uint64_t a1, float32x4_t *a2)
{
  int v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    uint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    uint64_t v4 = *(float32x4_t **)(a1 + 80);
    uint64_t v5 = *(float32x4_t **)(a1 + 96);
    uint64_t v6 = *(float32x4_t **)(a1 + 16);
    uint64_t v7 = *(int *)(a1 + 24);
    uint64_t v8 = *(int *)(a1 + 104);
    uint64_t v9 = *(int *)(a1 + 88);
    if ((int)v3 < 3)
    {
      if ((int)v3 >= 1)
      {
        int v46 = 0;
        uint64_t v47 = 16 * v9;
        uint64_t v48 = 16 * v8;
        uint64_t v49 = 16 * v7;
        uint64_t v50 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          unint64_t v51 = 0;
          do
          {
            float32x4_t v52 = v4[v51 / 0x10];
            float32x4_t v53 = vmulq_f32(v5[v51 / 0x10], *a2);
            float32x4_t v54 = vmulq_laneq_f32(v53, v52, 3);
            float32x4_t v55 = vmulq_laneq_f32(v52, v53, 3);
            v6[v51 / 0x10] = vaddq_f32(vmaxq_f32(v54, v55), vsubq_f32(vsubq_f32(vaddq_f32(v52, v53), v54), v55));
            v51 += 16;
          }
          while (v50 != v51);
          ++v46;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v47);
          uint64_t v5 = (float32x4_t *)((char *)v5 + v48);
          uint64_t v6 = (float32x4_t *)((char *)v6 + v49);
        }
        while (v46 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      int v14 = v4 + 3;
      unint64_t v15 = v5 + 3;
      uint64_t v16 = v6 + 3;
      do
      {
        unint64_t v17 = 0;
        uint64_t v18 = 0;
        int v19 = 3;
        uint64_t v20 = v16;
        int8x16_t v21 = v15;
        uint64_t v22 = v14;
        do
        {
          unint64_t v23 = v22;
          float32x4_t v24 = v21;
          float32x4_t v25 = v20;
          int v26 = v19;
          float32x4_t v27 = v4[v17];
          float32x4_t v28 = v4[v17 + 1];
          float32x4_t v29 = v4[v17 + 2];
          float32x4_t v30 = vmulq_f32(v5[v17], *a2);
          float32x4_t v31 = vmulq_f32(v5[v17 + 1], *a2);
          float32x4_t v32 = vmulq_f32(v5[v17 + 2], *a2);
          float32x4_t v33 = vmulq_laneq_f32(v30, v27, 3);
          float32x4_t v34 = vmulq_laneq_f32(v31, v28, 3);
          float32x4_t v35 = vmulq_laneq_f32(v32, v29, 3);
          float32x4_t v36 = vmulq_laneq_f32(v27, v30, 3);
          float32x4_t v37 = vmulq_laneq_f32(v28, v31, 3);
          float32x4_t v38 = vmulq_laneq_f32(v29, v32, 3);
          float32x4_t v39 = &v6[v17];
          v18 += 3;
          v17 += 3;
          v22 += 3;
          *float32x4_t v39 = vaddq_f32(vmaxq_f32(v33, v36), vsubq_f32(vsubq_f32(vaddq_f32(v27, v30), v33), v36));
          v39[1] = vaddq_f32(vmaxq_f32(v34, v37), vsubq_f32(vsubq_f32(vaddq_f32(v28, v31), v34), v37));
          v39[2] = vaddq_f32(vmaxq_f32(v35, v38), vsubq_f32(vsubq_f32(vaddq_f32(v29, v32), v35), v38));
          v21 += 3;
          v20 += 3;
          int v19 = v26 + 3;
        }
        while (v18 < v3 - 2);
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v40 = *v23++;
            float32x4_t v41 = v40;
            float32x4_t v42 = *v24++;
            float32x4_t v43 = vmulq_f32(v42, *a2);
            float32x4_t v44 = vmulq_laneq_f32(v43, v41, 3);
            float32x4_t v45 = vmulq_laneq_f32(v41, v43, 3);
            *v25++ = vaddq_f32(vmaxq_f32(v44, v45), vsubq_f32(vsubq_f32(vaddq_f32(v41, v43), v44), v45));
            ++v26;
          }
          while ((int)v3 > v26);
        }
        ++v10;
        uint64_t v5 = (float32x4_t *)((char *)v5 + v11);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        int v14 = (float32x4_t *)((char *)v14 + v13);
        unint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendMultiplyTile(uint64_t a1, float32x4_t *a2)
{
  int v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    unint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    uint64_t v4 = *(float32x4_t **)(a1 + 80);
    uint64_t v5 = *(float32x4_t **)(a1 + 96);
    uint64_t v6 = *(float32x4_t **)(a1 + 16);
    uint64_t v7 = *(int *)(a1 + 24);
    uint64_t v8 = *(int *)(a1 + 104);
    uint64_t v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v37 = 0;
        uint64_t v38 = 16 * v9;
        uint64_t v39 = 16 * v8;
        uint64_t v40 = 16 * v7;
        uint64_t v41 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          unint64_t v42 = 0;
          do
          {
            float32x4_t v43 = vmulq_f32(v5[v42 / 0x10], *a2);
            v6[v42 / 0x10] = vaddq_f32(vaddq_f32(vmulq_f32(v4[v42 / 0x10], v43), vsubq_f32(v43, vmulq_laneq_f32(v43, v4[v42 / 0x10], 3))), vsubq_f32(v4[v42 / 0x10], vmulq_laneq_f32(v4[v42 / 0x10], v43, 3)));
            v42 += 16;
          }
          while (v41 != v42);
          ++v37;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v38);
          uint64_t v5 = (float32x4_t *)((char *)v5 + v39);
          uint64_t v6 = (float32x4_t *)((char *)v6 + v40);
        }
        while (v37 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      int v14 = v4 + 4;
      unint64_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        unint64_t v17 = 0;
        unint64_t v18 = 0;
        int v19 = v16;
        uint64_t v20 = v15;
        int8x16_t v21 = v14;
        do
        {
          uint64_t v22 = v21;
          unint64_t v23 = v20;
          float32x4_t v24 = v19;
          float32x4_t v25 = vmulq_f32(v5[v17], *a2);
          float32x4_t v26 = vmulq_f32(v5[v17 + 1], *a2);
          float32x4_t v27 = vmulq_f32(v5[v17 + 2], *a2);
          float32x4_t v28 = vmulq_f32(v5[v17 + 3], *a2);
          float32x4_t v29 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17 + 1], v26), vsubq_f32(v26, vmulq_laneq_f32(v26, v4[v17 + 1], 3))), vsubq_f32(v4[v17 + 1], vmulq_laneq_f32(v4[v17 + 1], v26, 3)));
          float32x4_t v30 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17 + 2], v27), vsubq_f32(v27, vmulq_laneq_f32(v27, v4[v17 + 2], 3))), vsubq_f32(v4[v17 + 2], vmulq_laneq_f32(v4[v17 + 2], v27, 3)));
          float32x4_t v31 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17 + 3], v28), vsubq_f32(v28, vmulq_laneq_f32(v28, v4[v17 + 3], 3))), vsubq_f32(v4[v17 + 3], vmulq_laneq_f32(v4[v17 + 3], v28, 3)));
          float32x4_t v32 = &v6[v17];
          *float32x4_t v32 = vaddq_f32(vaddq_f32(vmulq_f32(v4[v17], v25), vsubq_f32(v25, vmulq_laneq_f32(v25, v4[v17], 3))), vsubq_f32(v4[v17], vmulq_laneq_f32(v4[v17], v25, 3)));
          v32[1] = v29;
          v18 += 4;
          v17 += 4;
          v32[2] = v30;
          v32[3] = v31;
          v21 += 4;
          v20 += 4;
          int v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v33 = *v22++;
            float32x4_t v34 = v33;
            float32x4_t v35 = *v23++;
            float32x4_t v36 = vmulq_f32(v35, *a2);
            *v24++ = vaddq_f32(vaddq_f32(vmulq_f32(v34, v36), vsubq_f32(v36, vmulq_laneq_f32(v36, v34, 3))), vsubq_f32(v34, vmulq_laneq_f32(v34, v36, 3)));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        uint64_t v5 = (float32x4_t *)((char *)v5 + v11);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        int v14 = (float32x4_t *)((char *)v14 + v13);
        unint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendScreenTile(uint64_t a1, float32x4_t *a2)
{
  int v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    unint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    uint64_t v4 = *(float32x4_t **)(a1 + 80);
    uint64_t v5 = *(float32x4_t **)(a1 + 96);
    uint64_t v6 = *(float32x4_t **)(a1 + 16);
    uint64_t v7 = *(int *)(a1 + 24);
    uint64_t v8 = *(int *)(a1 + 104);
    uint64_t v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v37 = 0;
        uint64_t v38 = 16 * v9;
        uint64_t v39 = 16 * v8;
        uint64_t v40 = 16 * v7;
        uint64_t v41 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          unint64_t v42 = 0;
          do
          {
            float32x4_t v43 = vmulq_f32(v5[v42 / 0x10], *a2);
            v6[v42 / 0x10] = vsubq_f32(vaddq_f32(v4[v42 / 0x10], v43), vminq_f32(vminq_f32(vmulq_f32(v4[v42 / 0x10], v43), v43), v4[v42 / 0x10]));
            v42 += 16;
          }
          while (v41 != v42);
          ++v37;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v38);
          uint64_t v5 = (float32x4_t *)((char *)v5 + v39);
          uint64_t v6 = (float32x4_t *)((char *)v6 + v40);
        }
        while (v37 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      int v14 = v4 + 4;
      unint64_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        unint64_t v17 = 0;
        unint64_t v18 = 0;
        int v19 = v16;
        uint64_t v20 = v15;
        int8x16_t v21 = v14;
        do
        {
          uint64_t v22 = v21;
          unint64_t v23 = v20;
          float32x4_t v24 = v19;
          float32x4_t v25 = vmulq_f32(v5[v17], *a2);
          float32x4_t v26 = vmulq_f32(v5[v17 + 1], *a2);
          float32x4_t v27 = vmulq_f32(v5[v17 + 2], *a2);
          float32x4_t v28 = vmulq_f32(v5[v17 + 3], *a2);
          float32x4_t v29 = vsubq_f32(vaddq_f32(v4[v17 + 1], v26), vminq_f32(vminq_f32(vmulq_f32(v4[v17 + 1], v26), v26), v4[v17 + 1]));
          float32x4_t v30 = vsubq_f32(vaddq_f32(v4[v17 + 2], v27), vminq_f32(vminq_f32(vmulq_f32(v4[v17 + 2], v27), v27), v4[v17 + 2]));
          float32x4_t v31 = vsubq_f32(vaddq_f32(v4[v17 + 3], v28), vminq_f32(vminq_f32(vmulq_f32(v4[v17 + 3], v28), v28), v4[v17 + 3]));
          float32x4_t v32 = &v6[v17];
          *float32x4_t v32 = vsubq_f32(vaddq_f32(v4[v17], v25), vminq_f32(vminq_f32(vmulq_f32(v4[v17], v25), v25), v4[v17]));
          v32[1] = v29;
          v18 += 4;
          v17 += 4;
          v32[2] = v30;
          v32[3] = v31;
          v21 += 4;
          v20 += 4;
          int v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v33 = *v22++;
            float32x4_t v34 = v33;
            float32x4_t v35 = *v23++;
            float32x4_t v36 = vmulq_f32(v35, *a2);
            *v24++ = vsubq_f32(vaddq_f32(v34, v36), vminq_f32(vminq_f32(vmulq_f32(v34, v36), v36), v34));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        uint64_t v5 = (float32x4_t *)((char *)v5 + v11);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        int v14 = (float32x4_t *)((char *)v14 + v13);
        unint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

uint64_t GetHGBlendDissolveTile(uint64_t a1, float32x4_t *a2)
{
  int v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    unint64_t v3 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
    uint64_t v4 = *(float32x4_t **)(a1 + 80);
    uint64_t v5 = *(float32x4_t **)(a1 + 96);
    uint64_t v6 = *(float32x4_t **)(a1 + 16);
    uint64_t v7 = *(int *)(a1 + 24);
    uint64_t v8 = *(int *)(a1 + 104);
    uint64_t v9 = *(int *)(a1 + 88);
    if ((int)v3 < 4)
    {
      if ((int)v3 >= 1)
      {
        int v32 = 0;
        uint64_t v33 = 16 * v9;
        uint64_t v34 = 16 * v8;
        uint64_t v35 = 16 * v7;
        uint64_t v36 = 16 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1);
        do
        {
          unint64_t v37 = 0;
          do
          {
            v6[v37 / 0x10] = vaddq_f32(v4[v37 / 0x10], vmulq_f32(*a2, vsubq_f32(v5[v37 / 0x10], v4[v37 / 0x10])));
            v37 += 16;
          }
          while (v36 != v37);
          ++v32;
          uint64_t v4 = (float32x4_t *)((char *)v4 + v33);
          uint64_t v5 = (float32x4_t *)((char *)v5 + v34);
          uint64_t v6 = (float32x4_t *)((char *)v6 + v35);
        }
        while (v32 != v2);
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v11 = 16 * v8;
      uint64_t v12 = 16 * v7;
      uint64_t v13 = 16 * v9;
      int v14 = v4 + 4;
      unint64_t v15 = v5 + 4;
      uint64_t v16 = v6 + 4;
      do
      {
        unint64_t v17 = 0;
        unint64_t v18 = 0;
        int v19 = v16;
        uint64_t v20 = v15;
        int8x16_t v21 = v14;
        do
        {
          uint64_t v22 = v21;
          unint64_t v23 = v20;
          float32x4_t v24 = v19;
          float32x4_t v25 = vaddq_f32(v4[v17 + 1], vmulq_f32(vsubq_f32(v5[v17 + 1], v4[v17 + 1]), *a2));
          float32x4_t v26 = vaddq_f32(v4[v17 + 2], vmulq_f32(vsubq_f32(v5[v17 + 2], v4[v17 + 2]), *a2));
          float32x4_t v27 = vaddq_f32(v4[v17 + 3], vmulq_f32(*a2, vsubq_f32(v5[v17 + 3], v4[v17 + 3])));
          float32x4_t v28 = &v6[v17];
          *float32x4_t v28 = vaddq_f32(v4[v17], vmulq_f32(vsubq_f32(v5[v17], v4[v17]), *a2));
          v28[1] = v25;
          v18 += 4;
          v17 += 4;
          v28[2] = v26;
          v28[3] = v27;
          v21 += 4;
          v20 += 4;
          int v19 = v24 + 4;
        }
        while ((uint64_t)v18 < (uint64_t)(v3 - 3));
        if ((int)v3 > (int)v18)
        {
          do
          {
            float32x4_t v29 = *v22++;
            float32x4_t v30 = v29;
            float32x4_t v31 = *v23++;
            *v24++ = vaddq_f32(v30, vmulq_f32(*a2, vsubq_f32(v31, v30)));
            ++v18;
          }
          while (v18 < v3);
        }
        ++v10;
        uint64_t v5 = (float32x4_t *)((char *)v5 + v11);
        uint64_t v6 = (float32x4_t *)((char *)v6 + v12);
        uint64_t v4 = (float32x4_t *)((char *)v4 + v13);
        int v14 = (float32x4_t *)((char *)v14 + v13);
        unint64_t v15 = (float32x4_t *)((char *)v15 + v11);
        uint64_t v16 = (float32x4_t *)((char *)v16 + v12);
      }
      while (v10 != v2);
    }
  }
  return 0;
}

const char *GetHGBlendNormalProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000037c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = c0.xxxx - r1.wwww;\n"
             "    output.color0 = float4(r0)*float4(r2) + float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a17166cb:4ae482ef:781fc3b7:6143d1a9\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000352\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = c0.xxxx - r1.wwww;\n"
             "    output.color0 = r0*r2 + r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=72391b35:a8654f9f:aaa4f0df:bd71ee76\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000301\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = c0.xxxx - r1.wwww;\n"
           "    gl_FragColor = r0*r2 + r1;\n"
           "}\n"
           "//MD5=542a3d1f:8a8f31c6:53e2357c:1b7afc62\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendAddProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000328\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1 + r0;\n"
             "    r2.w = -r1.w*r0.w + r2.w;\n"
             "    output.color0 = float4(r2);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d59c4393:5faec818:b66c0166:a5b8df3a\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000030c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1 + r0;\n"
             "    r2.w = -r1.w*r0.w + r2.w;\n"
             "    output.color0 = r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2ed547af:707bae93:26dfb645:16dfb2b5\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002b6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1 + r0;\n"
           "    r2.w = -r1.w*r0.w + r2.w;\n"
           "    gl_FragColor = r2;\n"
           "}\n"
           "//MD5=c7321b02:0ada01d2:252b971a:900e277b\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendBehindProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000037c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = c0.xxxx - r0.wwww;\n"
             "    output.color0 = float4(r1)*float4(r2) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c58d73cf:5abaf669:0ed24989:47f4d1f7\n"
             "//SIG=00400000:00000003:00000003:00000003:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000352\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = c0.xxxx - r0.wwww;\n"
             "    output.color0 = r1*r2 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=02fd7083:75fd7153:81b391cd:51351952\n"
             "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000301\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = c0.xxxx - r0.wwww;\n"
           "    gl_FragColor = r1*r2 + r0;\n"
           "}\n"
           "//MD5=82fdf0d8:1de86e49:9e296160:488420c6\n"
           "//SIG=00000000:00000003:00000003:00000000:0001:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendDarkenProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000384\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmin(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = float4(r1) + float4(r4);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c27f10d4:1c0c8ccb:86556908:22917918\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000360\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmin(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = r1 + r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=fdd9d0ee:dddc8b61:10b27a4f:f7a7aa8e\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000309\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r4 = min(r2, r3);\n"
           "    r1 = r1 + r0;\n"
           "    r1 = r1 - r2;\n"
           "    r1 = r1 - r3;\n"
           "    gl_FragColor = r1 + r4;\n"
           "}\n"
           "//MD5=c6b1e65f:1950bd8f:9345f58d:ea3a6afc\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendDifferenceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000038d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r1 = r1 + r0;\n"
             "    r0 = r2 - r3;\n"
             "    r1 = r1 - r2;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    output.color0 = float4(r1) + float4(fabs(r0));\n"
             "    return output;\n"
             "}\n"
             "//MD5=28640d6b:a7f4cbd7:1398d5ad:4f2b97e5\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000369\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r1 = r1 + r0;\n"
             "    r0 = r2 - r3;\n"
             "    r1 = r1 - r2;\n"
             "    r1.xyz = r1.xyz - r3.xyz;\n"
             "    output.color0 = r1 + fabs(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=78eeb002:cd99131f:366f4560:2b2f0811\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000312\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r1 = r1 + r0;\n"
           "    r0 = r2 - r3;\n"
           "    r1 = r1 - r2;\n"
           "    r1.xyz = r1.xyz - r3.xyz;\n"
           "    gl_FragColor = r1 + abs(r0);\n"
           "}\n"
           "//MD5=167e3881:cda035d5:2b7bb7d9:07a634d1\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendLightenProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000384\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmax(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = float4(r1) + float4(r4);\n"
             "    return output;\n"
             "}\n"
             "//MD5=255abd10:393d4261:149de1f9:66e2ba1d\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000360\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0.wwww;\n"
             "    r3 = r0*r1.wwww;\n"
             "    r4 = fmax(r2, r3);\n"
             "    r1 = r1 + r0;\n"
             "    r1 = r1 - r2;\n"
             "    r1 = r1 - r3;\n"
             "    output.color0 = r1 + r4;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a08d3b39:c090c511:0017968a:c922b48e\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000309\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0.wwww;\n"
           "    r3 = r0*r1.wwww;\n"
           "    r4 = max(r2, r3);\n"
           "    r1 = r1 + r0;\n"
           "    r1 = r1 - r2;\n"
           "    r1 = r1 - r3;\n"
           "    gl_FragColor = r1 + r4;\n"
           "}\n"
           "//MD5=10f025ae:65373697:69030409:e5173d3b\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0005:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendMultiplyProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000354\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = -r1*r0.wwww + r1;\n"
             "    r3 = -r0*r1.wwww + r0;\n"
             "    r1 = r1*r0 + r2;\n"
             "    output.color0 = float4(r1) + float4(r3);\n"
             "    return output;\n"
             "}\n"
             "//MD5=7ab80faf:802a2960:6882b435:6d1cc9dc\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000330\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = -r1*r0.wwww + r1;\n"
             "    r3 = -r0*r1.wwww + r0;\n"
             "    r1 = r1*r0 + r2;\n"
             "    output.color0 = r1 + r3;\n"
             "    return output;\n"
             "}\n"
             "//MD5=d348d950:6657c859:55f8ae41:7b9824a8\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002da\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = -r1*r0.wwww + r1;\n"
           "    r3 = -r0*r1.wwww + r0;\n"
           "    r1 = r1*r0 + r2;\n"
           "    gl_FragColor = r1 + r3;\n"
           "}\n"
           "//MD5=f723a021:2cc26bfb:5b7402aa:6e437a60\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0004:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendScreenProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000355\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*half4(hg_Params[0]);\n"
             "    r2 = r1*r0;\n"
             "    r2 = fmin(r2, r1);\n"
             "    r2 = fmin(r2, r0);\n"
             "    r1 = r1 + r0;\n"
             "    output.color0 = float4(r1) - float4(r2);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9771d01d:626a2747:a548b6f1:28e1d417\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000331\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r1 = r1*hg_Params[0];\n"
             "    r2 = r1*r0;\n"
             "    r2 = fmin(r2, r1);\n"
             "    r2 = fmin(r2, r0);\n"
             "    r1 = r1 + r0;\n"
             "    output.color0 = r1 - r2;\n"
             "    return output;\n"
             "}\n"
             "//MD5=31490d41:d9f1dc14:0dca0a9a:b384361c\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r1 = r1*hg_ProgramLocal0;\n"
           "    r2 = r1*r0;\n"
           "    r2 = min(r2, r1);\n"
           "    r2 = min(r2, r0);\n"
           "    r1 = r1 + r0;\n"
           "    gl_FragColor = r1 - r2;\n"
           "}\n"
           "//MD5=8190ca66:f656822d:4e06b98f:6e1ba269\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0003:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

const char *GetHGBlendDissolveProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002f2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = mix(float4(r0), float4(r1), hg_Params[0]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=71e089ca:82dc604d:921d323b:8c63d522\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002d5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = mix(r0, r1, hg_Params[0]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=19049a07:c1b7d36e:88d051c2:edb06ce9\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000027f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    gl_FragColor = mix(r0, r1, hg_ProgramLocal0);\n"
           "}\n"
           "//MD5=e59d54b8:dcfffceb:e9177f14:9c43910d\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0001:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void InitHGBlendNormalProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendNormal_hgc_visible", "//Metal1.0     \n//LEN=00000001ae\n[[ visible ]] FragmentOut HGBlendNormal_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = c0.xxxx - r1.wwww;\n"
    "    output.color0 = r0*r2 + r1;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a1, "HGBlendNormal");
}

void sub_1B785BC74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B785BCA8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B785BCA0);
}

void InitHGBlendAddProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendAdd_hgc_visible", "//Metal1.0     \n//LEN=0000000165\n[[ visible ]] FragmentOut HGBlendAdd_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1 + r0;\n"
    "    r2.w = -r1.w*r0.w + r2.w;\n"
    "    output.color0 = r2;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a1, "HGBlendAdd");
}

void sub_1B785BF4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B785BF80(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B785BF78);
}

void InitHGBlendBehindProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendBehind_hgc_visible", "//Metal1.0     \n//LEN=00000001ae\n[[ visible ]] FragmentOut HGBlendBehind_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = c0.xxxx - r0.wwww;\n"
    "    output.color0 = r1*r2 + r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a1, "HGBlendBehind");
}

void sub_1B785C224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B785C258(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B785C250);
}

void InitHGBlendDarkenProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendDarken_hgc_visible", "//Metal1.0     \n//LEN=00000001bc\n[[ visible ]] FragmentOut HGBlendDarken_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r4 = fmin(r2, r3);\n"
    "    r1 = r1 + r0;\n"
    "    r1 = r1 - r2;\n"
    "    r1 = r1 - r3;\n"
    "    output.color0 = r1 + r4;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a1, "HGBlendDarken");
}

void sub_1B785C4FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B785C530(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B785C528);
}

void InitHGBlendDifferenceProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendDifference_hgc_visible", "//Metal1.0     \n//LEN=00000001c9\n[[ visible ]] FragmentOut HGBlendDifference_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r1 = r1 + r0;\n"
    "    r0 = r2 - r3;\n"
    "    r1 = r1 - r2;\n"
    "    r1.xyz = r1.xyz - r3.xyz;\n"
    "    output.color0 = r1 + fabs(r0);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a1, "HGBlendDifference");
}

void sub_1B785C7D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B785C808(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B785C800);
}

void InitHGBlendLightenProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendLighten_hgc_visible", "//Metal1.0     \n//LEN=00000001bd\n[[ visible ]] FragmentOut HGBlendLighten_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0.wwww;\n"
    "    r3 = r0*r1.wwww;\n"
    "    r4 = fmax(r2, r3);\n"
    "    r1 = r1 + r0;\n"
    "    r1 = r1 - r2;\n"
    "    r1 = r1 - r3;\n"
    "    output.color0 = r1 + r4;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a1, "HGBlendLighten");
}

void sub_1B785CAAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B785CAE0(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B785CAD8);
}

void InitHGBlendMultiplyProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendMultiply_hgc_visible", "//Metal1.0     \n//LEN=000000018e\n[[ visible ]] FragmentOut HGBlendMultiply_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = -r1*r0.wwww + r1;\n"
    "    r3 = -r0*r1.wwww + r0;\n"
    "    r1 = r1*r0 + r2;\n"
    "    output.color0 = r1 + r3;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a1, "HGBlendMultiply");
}

void sub_1B785CD84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B785CDB8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B785CDB0);
}

void InitHGBlendScreenProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendScreen_hgc_visible", "//Metal1.0     \n//LEN=000000018d\n[[ visible ]] FragmentOut HGBlendScreen_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r1 = r1*hg_Params[0];\n"
    "    r2 = r1*r0;\n"
    "    r2 = fmin(r2, r1);\n"
    "    r2 = fmin(r2, r0);\n"
    "    r1 = r1 + r0;\n"
    "    output.color0 = r1 - r2;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a1, "HGBlendScreen");
}

void sub_1B785D05C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B785D090(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B785D088);
}

void InitHGBlendDissolveProgramDescriptor(HGProgramDescriptor *a1)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a1, "HGBlendDissolve_hgc_visible", "//Metal1.0     \n//LEN=0000000133\n[[ visible ]] FragmentOut HGBlendDissolve_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    output.color0 = mix(r0, r1, hg_Params[0]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a1, "HGBlendDissolve");
}

void sub_1B785D334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B785D368(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B785D360);
}

uint64_t HGColorMatrix::RenderTile(HGColorMatrix *this, HGTile *a2)
{
  uint64_t v4 = HGGetTBC();
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(*((void *)a2 + 42) + 152) + 128))(*(void *)(*((void *)a2 + 42) + 152), 28))
  {
    int v6 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
    if (v6 >= 1)
    {
      uint64_t v7 = (float32x4_t *)*((void *)this + 52);
      unint64_t v8 = (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
      uint64_t v9 = (float32x4_t *)*((void *)a2 + 10);
      int v10 = (float32x4_t *)*((void *)a2 + 2);
      uint64_t v11 = *((int *)a2 + 6);
      uint64_t v12 = *((int *)a2 + 22);
      if ((int)v8 < 4)
      {
        if ((int)v8 >= 1)
        {
          int v37 = 0;
          uint64_t v38 = 16 * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2);
          uint64_t v39 = 16 * v11;
          uint64_t v40 = 16 * v12;
          do
          {
            unint64_t v41 = 0;
            do
            {
              v10[v41 / 0x10] = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*v7, COERCE_FLOAT(*(_OWORD *)&v9[v41 / 0x10])), vmulq_lane_f32(v7[1], *(float32x2_t *)v9[v41 / 0x10].f32, 1)), vmulq_laneq_f32(v7[2], v9[v41 / 0x10], 2)), vmulq_laneq_f32(v7[3], v9[v41 / 0x10], 3));
              v41 += 16;
            }
            while (v38 != v41);
            ++v37;
            int v10 = (float32x4_t *)((char *)v10 + v39);
            uint64_t v9 = (float32x4_t *)((char *)v9 + v40);
          }
          while (v37 != v6);
        }
      }
      else
      {
        int v13 = 0;
        uint64_t v14 = 16 * v12;
        uint64_t v15 = 16 * v11;
        uint64_t v16 = v10 + 4;
        unint64_t v17 = v9 + 4;
        do
        {
          unint64_t v18 = 0;
          int v19 = v17;
          uint64_t v20 = v16;
          uint64_t v21 = 3;
          do
          {
            float32x4_t v22 = v9[v21 - 3];
            float32x4_t v23 = v9[v21 - 2];
            float32x4_t v24 = v9[v21 - 1];
            float32x4_t v25 = v9[v21];
            float32x4_t v26 = v7[1];
            float32x4_t v27 = vaddq_f32(vmulq_n_f32(*v7, v22.f32[0]), vmulq_lane_f32(v26, *(float32x2_t *)v22.f32, 1));
            float32x4_t v28 = vaddq_f32(vmulq_n_f32(*v7, v23.f32[0]), vmulq_lane_f32(v26, *(float32x2_t *)v23.f32, 1));
            float32x4_t v29 = vaddq_f32(vmulq_n_f32(*v7, v24.f32[0]), vmulq_lane_f32(v26, *(float32x2_t *)v24.f32, 1));
            float32x4_t v30 = vaddq_f32(vmulq_n_f32(*v7, v25.f32[0]), vmulq_lane_f32(v26, *(float32x2_t *)v25.f32, 1));
            float32x4_t v31 = v7[2];
            float32x4_t v32 = v7[3];
            uint64_t v33 = v20;
            uint64_t v34 = v19;
            uint64_t v35 = &v10[v21];
            v35[-3] = vaddq_f32(vaddq_f32(v27, vmulq_laneq_f32(v31, v22, 2)), vmulq_laneq_f32(v32, v22, 3));
            v35[-2] = vaddq_f32(vaddq_f32(v28, vmulq_laneq_f32(v31, v23, 2)), vmulq_laneq_f32(v32, v23, 3));
            v18 += 4;
            v35[-1] = vaddq_f32(vaddq_f32(v29, vmulq_laneq_f32(v31, v24, 2)), vmulq_laneq_f32(v32, v24, 3));
            *uint64_t v35 = vaddq_f32(vaddq_f32(v30, vmulq_laneq_f32(v31, v25, 2)), vmulq_laneq_f32(v32, v25, 3));
            v21 += 4;
            uint64_t v20 = v33 + 4;
            v19 += 4;
          }
          while ((uint64_t)v18 < (uint64_t)(v8 - 3));
          if ((int)v8 > (int)v18)
          {
            do
            {
              float32x4_t v36 = *v34++;
              *v33++ = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*v7, v36.f32[0]), vmulq_lane_f32(v7[1], *(float32x2_t *)v36.f32, 1)), vmulq_laneq_f32(v7[2], v36, 2)), vmulq_laneq_f32(v7[3], v36, 3));
              ++v18;
            }
            while (v18 < v8);
          }
          ++v13;
          uint64_t v9 = (float32x4_t *)((char *)v9 + v14);
          int v10 = (float32x4_t *)((char *)v10 + v15);
          uint64_t v16 = (float32x4_t *)((char *)v16 + v15);
          unint64_t v17 = (float32x4_t *)((char *)v17 + v14);
        }
        while (v13 != v6);
      }
    }
  }
  *(void *)(*(void *)(*((void *)a2 + 42) + 416) + 80) += HGGetTBC() - v4;
  return 0;
}

const char *HGColorMatrix::GetProgram(HGColorMatrix *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002dd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0.x = dot(hg_Params[0], float4(r0));\n"
             "    output.color0.y = dot(hg_Params[1], float4(r0));\n"
             "    output.color0.z = dot(hg_Params[2], float4(r0));\n"
             "    output.color0.w = dot(hg_Params[3], float4(r0));\n"
             "    return output;\n"
             "}\n"
             "//MD5=72217420:491e0715:a85d6da8:94aef8d2\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0004:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002b7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0.x = dot(hg_Params[0], r0);\n"
             "    output.color0.y = dot(hg_Params[1], r0);\n"
             "    output.color0.z = dot(hg_Params[2], r0);\n"
             "    output.color0.w = dot(hg_Params[3], r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f59a11f6:3c3dcb91:f1061cc0:3190f271\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0004:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000306\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "uniform defaultp vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor.x = dot(hg_ProgramLocal0, r0);\n"
           "    gl_FragColor.y = dot(hg_ProgramLocal1, r0);\n"
           "    gl_FragColor.z = dot(hg_ProgramLocal2, r0);\n"
           "    gl_FragColor.w = dot(hg_ProgramLocal3, r0);\n"
           "}\n"
           "//MD5=8fc18786:e8a829e3:4774e200:4d62edae\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0004:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HGColorMatrix::InitProgramDescriptor(HGColorMatrix *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HGColorMatrix_hgc_visible", "//Metal1.0     \n//LEN=000000018e\n[[ visible ]] FragmentOut HGColorMatrix_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0.x = dot(hg_Params[0], r0);\n"
    "    output.color0.y = dot(hg_Params[1], r0);\n"
    "    output.color0.z = dot(hg_Params[2], r0);\n"
    "    output.color0.w = dot(hg_Params[3], r0);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HGColorMatrix");
}

void sub_1B785D8CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void **a21,void **a22)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a21)
  {
    float32x4_t v23 = a22;
    float32x4_t v24 = a21;
    if (a22 != a21)
    {
      do
      {
        if (*((char *)v23 - 17) < 0) {
          operator delete(*(v23 - 5));
        }
        v23 -= 6;
      }
      while (v23 != a21);
      float32x4_t v24 = a21;
    }
    operator delete(v24);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGColorMatrix::RenderFragment(float32x4_t *a1, float32x4_t *a2, HGTile *this)
{
  uint64_t v6 = HGTile::Renderer(this);
  int v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 128))(v6, 23);
  *(float32x2_t *)v8.f32 = vadd_f32(vcvt_f32_s32(*(int32x2_t *)this), (float32x2_t)0x3F0000003F000000);
  v8.i64[1] = 0x3F80000000000000;
  uint64_t v9 = *((void *)this + 10);
  uint64_t v10 = *((int *)this + 22);
  float32x4_t v11 = vsubq_f32(a2[1], v8);
  if (v7)
  {
    int32x4_t v12 = vaddq_s32(vcvtq_s32_f32(v11), vcltzq_f32(v11));
    float32x2_t v13 = (float32x2_t)vsubq_f32(v11, vcvtq_f32_s32(v12)).u64[0];
    uint64_t v14 = (float32x4_t *)(v9 + 16 * (v12.i32[0] + v12.i32[1] * (int)v10));
    float32x4_t v15 = vaddq_f32(*v14, vmulq_n_f32(vsubq_f32(v14[1], *v14), v13.f32[0]));
    float32x4_t v16 = vaddq_f32(v15, vmulq_lane_f32(vsubq_f32(vaddq_f32(v14[v10], vmulq_n_f32(vsubq_f32(v14[(int)v10 + 1], v14[v10]), v13.f32[0])), v15), v13, 1));
  }
  else
  {
    v17.i64[0] = 0x3F0000003F000000;
    v17.i64[1] = 0x3F0000003F000000;
    float32x4_t v18 = vaddq_f32(v11, v17);
    int32x4_t v19 = vcvtq_s32_f32(v18);
    v18.i64[0] = vaddq_s32(v19, vcgtq_f32(vcvtq_f32_s32(v19), v18)).u64[0];
    float32x4_t v16 = *(float32x4_t *)(v9 + 16 * (v18.i32[0] + v18.i32[1] * (int)v10));
  }
  *(float32x4_t *)*((void *)this + 2) = vaddq_f32(vmulq_laneq_f32(a1[30], v16, 3), vaddq_f32(vmulq_laneq_f32(a1[29], v16, 2), vaddq_f32(vmulq_n_f32(a1[27], v16.f32[0]), vmulq_lane_f32(a1[28], *(float32x2_t *)v16.f32, 1))));
  return 0;
}

uint64_t HGColorMatrix::Bind(HGColorMatrix *this, HGHandler *a2)
{
  return 0;
}

uint64_t HGColorMatrix::BindTexture(HGColorMatrix *this, HGHandler *a2, int a3)
{
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  return 0;
}

void HGColorMatrix::HGColorMatrix(HGColorMatrix *this)
{
  HGNode3D::HGNode3D(this);
  void *v1 = &unk_1F10E2330;
  operator new();
}

{
  void *v1;

  HGNode3D::HGNode3D(this);
  void *v1 = &unk_1F10E2330;
  operator new();
}

void sub_1B785DCF8(_Unwind_Exception *a1)
{
  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void sub_1B785DDB4(_Unwind_Exception *a1)
{
  HGMipmapLevel::~HGMipmapLevel(v1);
  _Unwind_Resume(a1);
}

void HGColorMatrix::~HGColorMatrix(HGColorMatrix *this)
{
  *(void *)this = &unk_1F10E2330;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    MEMORY[0x1BA9BFBA0](v3, 0x1000C40FA0F61DDLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E2330;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    MEMORY[0x1BA9BFBA0](v3, 0x1000C40FA0F61DDLL);
  }

  HGMipmapLevel::~HGMipmapLevel(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10E2330;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 52);
  if (v3) {
    MEMORY[0x1BA9BFBA0](v3, 0x1000C40FA0F61DDLL);
  }
  HGMipmapLevel::~HGMipmapLevel(this);

  HGObject::operator delete(v4);
}

__n128 HGColorMatrix::ParameterizeMatrix(__n128 *this, HGRenderer *a2)
{
  *(__n128 *)this[26].n128_u64[0] = this[27];
  *(__n128 *)(this[26].n128_u64[0] + 16) = this[28];
  *(__n128 *)(this[26].n128_u64[0] + 32) = this[29];
  __n128 result = this[30];
  *(__n128 *)(this[26].n128_u64[0] + 48) = result;
  return result;
}

const char *HgcCropShaderBlend::GetProgram(HgcCropShaderBlend *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000037c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s0.xy = frag._texCoord1.xy - hg_Params[0].xy;\n"
             "    s0.zw = hg_Params[0].zw - frag._texCoord1.xy;\n"
             "    s0 = float4(s0 < float4(c0.xxxx));\n"
             "    s0 = float4(dot(s0, 1.00000f));\n"
             "    s0 = float4(s0 <= float4(c0.xxxx));\n"
             "    s0 = float4(r0)*s0;\n"
             "    output.color0 = s0*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=f9b56c77:153e25ee:692c907c:ff332280\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000355\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = frag._texCoord1.xy - hg_Params[0].xy;\n"
             "    r1.zw = hg_Params[0].zw - frag._texCoord1.xy;\n"
             "    r1 = float4(r1 < c0.xxxx);\n"
             "    r1 = float4(dot(r1, 1.00000f));\n"
             "    r1 = float4(r1 <= c0.xxxx);\n"
             "    r0 = r0*r1;\n"
             "    output.color0 = r0*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=71c0cb25:36879384:725a4797:f8967426\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000037c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xy = hg_TexCoord1.xy - hg_ProgramLocal0.xy;\n"
           "    r1.zw = hg_ProgramLocal0.zw - hg_TexCoord1.xy;\n"
           "    r1 = vec4(lessThan(r1, c0.xxxx));\n"
           "    r1 = vec4(dot(r1, vec4(1.00000)));\n"
           "    r1 = vec4(lessThanEqual(r1, c0.xxxx));\n"
           "    r0 = r0*r1;\n"
           "    gl_FragColor = r0*hg_ProgramLocal1;\n"
           "}\n"
           "//MD5=87b4563c:a08283dd:e21ff672:445d5bf6\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcCropShaderBlend::InitProgramDescriptor(HgcCropShaderBlend *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcCropShaderBlend_hgc_visible", "//Metal1.0     \n//LEN=000000023b\n[[ visible ]] FragmentOut HgcCropShaderBlend_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xy = texCoord1.xy - hg_Params[0].xy;\n"
    "    r1.zw = hg_Params[0].zw - texCoord1.xy;\n"
    "    r1 = float4(r1 < c0.xxxx);\n"
    "    r1 = float4(dot(r1, 1.00000f));\n"
    "    r1 = float4(r1 <= c0.xxxx);\n"
    "    r0 = r0*r1;\n"
    "    output.color0 = r0*hg_Params[1];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcCropShaderBlend");
}

void sub_1B785E340(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void sub_1B785E374(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 33) < 0)
  {
    operator delete(*(void **)(v1 - 56));
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1B785E36CLL);
}

double HgcCropShaderBlend::shaderDescription@<D0>(uint64_t a1@<X8>)
{
  uint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1B8348B90;
  strcpy(v3, "HgcCropShaderBlend [hgc1]");
  return *(double *)"aderBlend [hgc1]";
}

uint64_t HgcCropShaderBlend::BindTexture(HgcCropShaderBlend *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcCropShaderBlend::Bind(HgcCropShaderBlend *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcCropShaderBlend::GetDOD(HgcCropShaderBlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcCropShaderBlend::GetROI(HgcCropShaderBlend *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcCropShaderBlend::~HgcCropShaderBlend(HGNode *this)
{
  *(void *)this = &unk_1F10E25A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E25A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HgcCropShaderBlend::SetParameter(HgcCropShaderBlend *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  float32x4_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  *float32x4_t v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcCropShaderBlend::GetParameter(HgcCropShaderBlend *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

uint64_t HGCropNode::SupportsInplaceHardwareBlending(HGCropNode *this, float a2)
{
  return 1;
}

uint64_t HGCropNode::SetParameter@<X0>(HGCropNode *this@<X0>, float a2@<S0>, float a3@<S1>, float a4@<S2>, float a5@<S3>, int a6@<W1>, uint64_t a7@<X8>)
{
  if (a6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = HGRectMake4f(a7, a2, a3, a4, a5);
  uint64_t v11 = v10;
  if (HGRectIsEqual(v9, v10, *((void *)this + 52), *((void *)this + 53))) {
    return 0;
  }
  *((void *)this + 52) = v9;
  *((void *)this + 53) = v11;
  HGNode::ClearBits((HGNode *)this, v12, v13);
  return 1;
}

uint64_t HGCropNode::BindTexture(HGCropNode *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HGCropNode::Bind(HGCropNode *this, HGHandler *a2)
{
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  (*(void (**)(HGHandler *, void, float, float, float, float))(*(void *)a2 + 136))(a2, 0, (float)*((int *)this + 104), (float)*((int *)this + 105), (float)*((int *)this + 106), (float)*((int *)this + 107));
  double v4 = (*(double (**)(HGCropNode *))(*(void *)this + 288))(this);
  (*(void (**)(HGHandler *, uint64_t, double, float, float, float))(*(void *)a2 + 136))(a2, 1, v4, *(float *)&v4, *(float *)&v4, *(float *)&v4);
  return 0;
}

uint64_t HGCropNode::GetDOD(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  return HGRectIntersection(DOD, v9, *((void *)this + 52), *((void *)this + 53));
}

HGNode *HGCropNode::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v3 = this;
  Input = HGRenderer::GetInput(a2, this, 0);
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v7 = v6;
  uint64_t v8 = HGRectIntersection(DOD, v6, *((void *)v3 + 52), *((void *)v3 + 53));
  if (Input && HGRectIsEqual(DOD, v7, v8, v9))
  {
    (*(void (**)(HGNode *, uint64_t, uint64_t))(*(void *)Input + 136))(Input, 0xFFFFFFFFLL, 32);
    return Input;
  }
  return v3;
}

uint64_t HGCropNode::RenderPage(HGNode *this, HGPage *a2)
{
  int v4 = (*(uint64_t (**)(HGNode *, uint64_t, void))(*(void *)this + 168))(this, 23, 0);
  HGPagePullTexturesGuard::HGPagePullTexturesGuard((HGPagePullTexturesGuard *)&v8, this, a2);
  uint64_t v5 = *((void *)a2 + 21);
  if (!v5
    || !HGRectIsEqual(*(void *)(v5 + 20), *(void *)(v5 + 28), *((void *)a2 + 2), *((void *)a2 + 3))
    || *((void *)a2 + 1)
    || v4)
  {
    uint64_t v6 = HGNode::RenderPage(this, (HGRect *)a2);
  }
  else
  {
    (*(void (**)(void))(**((void **)a2 + 21) + 16))(*((void *)a2 + 21));
    uint64_t v6 = *((void *)a2 + 21);
  }
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard(&v8);
  return v6;
}

void sub_1B785EC54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPagePullTexturesGuard::~HGPagePullTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

uint64_t HGCropNode::RenderPageMetal(HGNode *this, HGPage *a2)
{
  int v4 = (*(uint64_t (**)(HGNode *, uint64_t, void))(*(void *)this + 168))(this, 23, 0);
  HGPagePullMetalTexturesGuard::HGPagePullMetalTexturesGuard((HGPagePullMetalTexturesGuard *)&v8, this, a2);
  uint64_t v5 = *((void *)a2 + 21);
  if (!v5
    || !HGRectIsEqual(*(void *)(v5 + 20), *(void *)(v5 + 28), *((void *)a2 + 2), *((void *)a2 + 3))
    || *((void *)a2 + 1)
    || v4)
  {
    uint64_t v6 = HGNode::RenderPageMetal(this, a2);
  }
  else
  {
    (*(void (**)(void))(**((void **)a2 + 21) + 16))(*((void *)a2 + 21));
    uint64_t v6 = *((void *)a2 + 21);
  }
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(&v8);
  return v6;
}

void sub_1B785ED50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard((HGPage **)va);
  _Unwind_Resume(a1);
}

const char *HGCropNode::GetProgram(HGCropNode *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000037c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s0.xy = frag._texCoord1.xy - hg_Params[0].xy;\n"
             "    s0.zw = hg_Params[0].zw - frag._texCoord1.xy;\n"
             "    s0 = float4(s0 < float4(c0.xxxx));\n"
             "    s0 = float4(dot(s0, 1.00000f));\n"
             "    s0 = float4(s0 <= float4(c0.xxxx));\n"
             "    s0 = float4(r0)*s0;\n"
             "    output.color0 = s0*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=f9b56c77:153e25ee:692c907c:ff332280\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000355\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = frag._texCoord1.xy - hg_Params[0].xy;\n"
             "    r1.zw = hg_Params[0].zw - frag._texCoord1.xy;\n"
             "    r1 = float4(r1 < c0.xxxx);\n"
             "    r1 = float4(dot(r1, 1.00000f));\n"
             "    r1 = float4(r1 <= c0.xxxx);\n"
             "    r0 = r0*r1;\n"
             "    output.color0 = r0*hg_Params[1];\n"
             "    return output;\n"
             "}\n"
             "//MD5=71c0cb25:36879384:725a4797:f8967426\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000037c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xy = hg_TexCoord1.xy - hg_ProgramLocal0.xy;\n"
           "    r1.zw = hg_ProgramLocal0.zw - hg_TexCoord1.xy;\n"
           "    r1 = vec4(lessThan(r1, c0.xxxx));\n"
           "    r1 = vec4(dot(r1, vec4(1.00000)));\n"
           "    r1 = vec4(lessThanEqual(r1, c0.xxxx));\n"
           "    r0 = r0*r1;\n"
           "    gl_FragColor = r0*hg_ProgramLocal1;\n"
           "}\n"
           "//MD5=87b4563c:a08283dd:e21ff672:445d5bf6\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0002:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HGCrop::HGCrop(HGCrop *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10E27F8;
  v1[51] = 0;
  uint64_t v2 = (HGNode *)HGObject::operator new(0x1B0uLL);
  HGNode::HGNode(v2);
  *(void *)uint64_t v2 = &unk_1F10E25A8;
  operator new();
}

void sub_1B785EF7C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  uint64_t v4 = *(void *)(v1 + 408);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

uint64_t HGCrop::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v3 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v3 + 120))(v3, 0, Input);
  uint64_t v5 = *((void *)this + 51);
  uint64_t v6 = (*(uint64_t (**)(HGNode *, void))(*(void *)this + 152))(this, 0);
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v5 + 136))(v5, 0, v6);
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (*(uint64_t (**)(HGNode *, uint64_t))(*(void *)this + 152))(this, 0xFFFFFFFFLL);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 136))(v7, 0xFFFFFFFFLL, v8);
  return *((void *)this + 51);
}

uint64_t HGCrop::SetParameter(HGCrop *this, float a2, float a3, float a4, float a5)
{
  return (*(uint64_t (**)(float, float, float, float))(**((void **)this + 51) + 96))(a2, a3, a4, a5);
}

void HGCrop::~HGCrop(HGNode *this)
{
  *(void *)this = &unk_1F10E27F8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E27F8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

void HGCropNode::~HGCropNode(HGNode *this)
{
  *(void *)this = &unk_1F10E25A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E25A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

const char *HGFlipAndOffset::GetProgram(HGFlipAndOffset *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  BOOL v4 = Target != 396048 && Target > 0x6060F;
  if (v4
    && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)
    && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 21))
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003a8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.5000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r1.xy = hg_TexCoord0.xy + hg_ProgramLocal1.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal1.zw;\n"
           "    r2.xy = r1.xy - c0.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal2.zw;\n"
           "    r2.xy = clamp(hg_ProgramLocal2.xy - abs(r2.xy), vec2(0.00000), vec2(1.00000));\n"
           "    r2.x = r2.x*r2.y;\n"
           "    r1 = texture2D(hg_Texture0, r1.xy);\n"
           "    r0 = r1*r2.xxxx;\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=42327dac:13de7175:fffb9b2f:8f6d6d8c\n"
           "//SIG=00000000:00000000:00000000:00000000:000c:0003:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
  unsigned int v5 = HGRenderer::GetTarget(a2, 393216);
  if (v5 == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000236\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = float4(r0)*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=5499c239:9891868e:bd9ea6d3:bd30d467\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000228\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    output.color0 = r0*hg_Params[0];\n"
             "    return output;\n"
             "}\n"
             "//MD5=6eae314a:ee581af3:fdfce447:74b07bd6\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (v5 <= 0x6060F || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000001f6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "}\n"
           "//MD5=78149511:5c47b7fc:9d3dfb0a:c601ba4b\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0001:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HGFlipAndOffset::InitProgramDescriptor(HGFlipAndOffset *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HGFlipAndOffset_hgc_visible", "//Metal1.0     \n//LEN=0000000101\n[[ visible ]] FragmentOut HGFlipAndOffset_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    output.color0 = r0*hg_Params[0];\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HGFlipAndOffset");
}

void sub_1B785F6C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void **a21,void **a22)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a21)
  {
    float32x4_t v23 = a22;
    float32x4_t v24 = a21;
    if (a22 != a21)
    {
      do
      {
        if (*((char *)v23 - 17) < 0) {
          operator delete(*(v23 - 5));
        }
        v23 -= 6;
      }
      while (v23 != a21);
      float32x4_t v24 = a21;
    }
    operator delete(v24);
  }
  _Unwind_Resume(exception_object);
}

void HGToneCurve::HGToneCurve(HGToneCurve *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10E2CE0;
  *(_DWORD *)(v1 + 16) |= 0x400u;
  *(void *)(v1 + 408) = 0;
  *(unsigned char *)(v1 + 416) = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(v1 + 440) = _D0;
  *(_DWORD *)(v1 + 424) = 0;
  *(void *)(v1 + 448) = 0;
  *(void *)(v1 + 456) = 0;
  *(_DWORD *)(v1 + 464) = 0;
  operator new();
}

void sub_1B785F7DC(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  MEMORY[0x1BA9BFBA0](v3, 0x1000C40BF75E1D5);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B785F80C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGToneCurve::~HGToneCurve(HGNode *this)
{
  *(void *)this = &unk_1F10E2CE0;
  uint64_t v2 = *((void *)this + 54);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40BF75E1D5);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10E2CE0;
  uint64_t v2 = *((void *)this + 54);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40BF75E1D5);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGToneCurve::GetDOD(HGToneCurve *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HGToneCurve::GetROI(HGToneCurve *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HGToneCurve::SetParameter(HGNode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  switch(a2)
  {
    case 2:
      *((float *)this + 114) = a3;
      *((float *)this + 115) = a4;
      *((float *)this + 116) = a5;
LABEL_20:
      HGNode::ClearBits(this, a2, a7);
      *((_DWORD *)this + 106) = HGToneCurve::AcceleratedState(*((_DWORD *)this + 102), *((float *)this + 110), *((float *)this + 111), *((float *)this + 112), *((float *)this + 113), *((float *)this + 114), *((float *)this + 115), *((float *)this + 116));
      return 1;
    case 1:
      *((float *)this + 110) = a3;
      *((float *)this + 111) = a4;
      *((float *)this + 112) = a5;
      *((float *)this + 113) = a6;
      goto LABEL_20;
    case 0:
      BOOL v8 = a3 > 4.0 || a3 < 0.0;
      unsigned int v9 = a3;
      if (v8) {
        unsigned int v9 = 0;
      }
      float v10 = 7.0;
      if (a4 <= 7.0) {
        float v10 = a4;
      }
      if (a4 < 0.0) {
        float v10 = 0.0;
      }
      unsigned int v11 = v10;
      float v12 = 1.0;
      if (a5 <= 1.0) {
        float v12 = a5;
      }
      if (a5 < 0.0) {
        float v12 = 0.0;
      }
      *((_DWORD *)this + 102) = v9;
      *((_DWORD *)this + 103) = v11;
      *((unsigned char *)this + 416) = (int)v12 != 0;
      goto LABEL_20;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HGToneCurve::AcceleratedState(int a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  if (a1 != 4)
  {
    if (a1 != 3)
    {
      if (!a1)
      {
        if (a8 == 0.0 && a7 == 0.0 && a6 == 0.0 && a5 == 0.0 && a4 == 0.0 && a3 == 0.0 && fabsf(a2 + -1.956) < 0.01) {
          return 7;
        }
        BOOL v15 = fabsf(a2 + -0.51125) < 0.01 && a3 == 0.0 && a4 == 0.0 && a5 == 0.0 && a6 == 0.0 && a7 == 0.0 && a8 == 0.0;
        unsigned int v16 = 8;
        goto LABEL_73;
      }
      return 0;
    }
    float v17 = fabsf(a3 + -0.909);
    BOOL v18 = fabsf(a2 + -2.22) < 0.01 && v17 < 0.001;
    float v19 = fabsf(a4 + -0.09);
    BOOL v20 = v18 && v19 < 0.01;
    float v21 = fabsf(a5 + -0.222);
    BOOL v22 = v20 && v21 < 0.001;
    if (v22 && a8 == 0.0 && a7 == 0.0 && fabsf(a6 + -0.0809) < 0.001) {
      return 1;
    }
    if (fabsf(a2 + -2.4) >= 0.01
      || fabsf(a3 + -0.94787) >= 0.001
      || fabsf(a4 + -0.052133) >= 0.001
      || fabsf(a5 + -0.077399) >= 0.0001)
    {
      return 0;
    }
    BOOL v15 = fabsf(a6 + -0.04045) < 0.0001 && a7 == 0.0 && a8 == 0.0;
    unsigned int v16 = 5;
LABEL_73:
    if (v15) {
      return v16;
    }
    else {
      return 0;
    }
  }
  if (fabsf(a2 + -0.45) < 0.01)
  {
    float v9 = fabsf(a3 + -1.23);
    BOOL v10 = a4 == 0.0 && v9 < 0.01;
    float v11 = fabsf(a5 + -4.5);
    BOOL v12 = v10 && v11 < 0.1;
    float v13 = fabsf(a6 + -0.018);
    BOOL v14 = v12 && v13 < 0.001;
    if (v14 && a8 == 0.0 && fabsf(a7 + 0.099) < 0.001) {
      return 2;
    }
  }
  uint64_t result = 0;
  if (fabsf(a2 + -0.41667) < 0.01 && a4 == 0.0 && fabsf(a3 + -1.1371) < 0.01)
  {
    if (fabsf(a5 + -12.92) >= 0.1 || fabsf(a6 + -0.0031308) >= 0.0001) {
      return 0;
    }
    BOOL v15 = fabsf(a7 + 0.055) < 0.0005 && a8 == 0.0;
    unsigned int v16 = 6;
    goto LABEL_73;
  }
  return result;
}

uint64_t HGToneCurve::GetParameter(HGToneCurve *this, int a2, float *a3)
{
  if (a2 == 2)
  {
    *a3 = *((float *)this + 114);
    a3[1] = *((float *)this + 115);
    int v6 = *((_DWORD *)this + 116);
    uint64_t result = 0;
    *((_DWORD *)a3 + 2) = v6;
    a3[3] = 0.0;
  }
  else if (a2 == 1)
  {
    *a3 = *((float *)this + 110);
    a3[1] = *((float *)this + 111);
    a3[2] = *((float *)this + 112);
    int v7 = *((_DWORD *)this + 113);
    uint64_t result = 0;
    *((_DWORD *)a3 + 3) = v7;
  }
  else if (a2)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    *(float32x2_t *)a3 = vcvt_f32_u32(*(uint32x2_t *)((char *)this + 408));
    float v3 = 0.0;
    if (*((unsigned char *)this + 416)) {
      float v3 = 1.0;
    }
    a3[2] = v3;
    float v4 = (float)*((unsigned int *)this + 106);
    uint64_t result = 0;
    a3[3] = v4;
  }
  return result;
}

double HGToneCurve::SetShaderParams(HGToneCurve *this, double result)
{
  uint64_t v3 = *((void *)this + 54);
  switch(*((_DWORD *)this + 102))
  {
    case 0:
      *(_DWORD *)uint64_t v3 = *((_DWORD *)this + 110);
      unsigned int v4 = *((_DWORD *)this + 105) - 4;
      *(_OWORD *)(v3 + 4) = xmmword_1B7E736D0;
      *(_DWORD *)(v3 + 20) = 0;
      if (v4 > 2)
      {
        uint64_t result = 0.0078125;
        *(void *)(v3 + 24) = 0x3F80000000000000;
      }
      else
      {
        uint64_t result = 2.00000047;
        *(void *)(v3 + 24) = 0x400000003F800000;
      }
      return result;
    case 1:
      *(_DWORD *)uint64_t v3 = *((_DWORD *)this + 110);
      *(float *)(v3 + 4) = *((float *)this + 112) / *((float *)this + 111);
      *(_DWORD *)(v3 + 8) = 0;
      *(float *)(v3 + 12) = powf(*((float *)this + 111), *((float *)this + 110));
      unsigned int v8 = *((_DWORD *)this + 105) - 11;
      *(_DWORD *)(v3 + 16) = 0;
      *(float *)&uint64_t result = (float)-*((float *)this + 112) / *((float *)this + 111);
      *(_DWORD *)(v3 + 20) = LODWORD(result);
      *(_DWORD *)(v3 + 24) = 0;
      if (v8 <= 2) {
        goto LABEL_15;
      }
      goto LABEL_13;
    case 2:
      *(_DWORD *)uint64_t v3 = *((_DWORD *)this + 110);
      *(float *)(v3 + 4) = *((float *)this + 112) / *((float *)this + 111);
      *(_DWORD *)(v3 + 8) = 0;
      *(float *)(v3 + 12) = powf(*((float *)this + 111), *((float *)this + 110));
      unsigned int v5 = *((_DWORD *)this + 105);
      if (v5 > 0x1B || (LODWORD(result) = 2.0, ((1 << v5) & 0x80C0000) == 0)) {
        LODWORD(result) = 1.0;
      }
      *(_DWORD *)(v3 + 16) = 0;
      float v6 = (float)-*((float *)this + 112) / *((float *)this + 111);
      goto LABEL_11;
    case 3:
      *(_DWORD *)uint64_t v3 = *((_DWORD *)this + 110);
      *(float *)(v3 + 4) = *((float *)this + 112) / *((float *)this + 111);
      *(_DWORD *)(v3 + 8) = 0;
      *(float *)(v3 + 12) = powf(*((float *)this + 111), *((float *)this + 110));
      unsigned int v9 = *((_DWORD *)this + 105) - 25;
      *(_DWORD *)(v3 + 16) = *((_DWORD *)this + 113);
      LODWORD(result) = *((_DWORD *)this + 114);
      *(_DWORD *)(v3 + 20) = LODWORD(result);
      *(_DWORD *)(v3 + 24) = 0;
      if (v9 > 2) {
LABEL_13:
      }
        *(_DWORD *)(v3 + 28) = 1065353216;
      else {
LABEL_15:
      }
        *(_DWORD *)(v3 + 28) = 0x40000000;
      return result;
    case 4:
      *(_DWORD *)uint64_t v3 = *((_DWORD *)this + 110);
      *(float *)(v3 + 4) = *((float *)this + 112) / *((float *)this + 111);
      *(float *)(v3 + 8) = *((float *)this + 115) - *((float *)this + 116);
      *(float *)(v3 + 12) = powf(*((float *)this + 111), *((float *)this + 110));
      unsigned int v7 = *((_DWORD *)this + 105) - 32;
      *(_DWORD *)(v3 + 16) = *((_DWORD *)this + 113);
      LODWORD(result) = 1.0;
      if (v7 < 3) {
        *(float *)&uint64_t result = 2.0;
      }
      float v6 = *((float *)this + 114);
LABEL_11:
      *(float *)(v3 + 20) = v6;
      *(_DWORD *)(v3 + 24) = 0;
      *(_DWORD *)(v3 + 28) = LODWORD(result);
      *(_DWORD *)(v3 + 32) = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t HGToneCurve::BindTexture(HGToneCurve *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HGToneCurve::Bind(HGToneCurve *this, HGHandler *a2)
{
  if (*((_DWORD *)this + 106)) {
    return 0;
  }
  switch(*((_DWORD *)this + 102))
  {
    case 1:
    case 3:
      goto LABEL_5;
    case 2:
    case 4:
      (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 144))(a2, 2, *((void *)this + 54) + 32, 1);
LABEL_5:
      (*(void (**)(HGHandler *, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 144))(a2, 1, *((void *)this + 54) + 16, 1);
      break;
    default:
      break;
  }
  (*(void (**)(HGHandler *, void, void, uint64_t))(*(void *)a2 + 144))(a2, 0, *((void *)this + 54), 1);
  return 0;
}

uint64_t HGToneCurve::GetProgram(HGToneCurve *this, HGRenderer *a2)
{
  if (*((unsigned char *)this + 416)) {
    uint64_t v2 = hgtonecurve_getprogram;
  }
  else {
    uint64_t v2 = hgtonecurve_getprogram_unpremult;
  }
  return v2[*((unsigned int *)this + 105)](a2);
}

uint64_t HGToneCurve::InitProgramDescriptor(HGToneCurve *this, HGProgramDescriptor *a2)
{
  if (*((unsigned char *)this + 416)) {
    uint64_t v2 = hgtonecurve_initprogramdesc;
  }
  else {
    uint64_t v2 = hgtonecurve_initprogramdesc_unpremult;
  }
  return v2[*((unsigned int *)this + 105)](a2);
}

uint64_t HGToneCurve::RenderTile(HGToneCurve *this, HGTile *a2)
{
  if (*((unsigned char *)this + 416)) {
    uint64_t v2 = hgtonecurve_rendertile;
  }
  else {
    uint64_t v2 = hgtonecurve_rendertile_unpremult;
  }
  return v2[*((unsigned int *)this + 105)](a2, *((HGToneCurve::State **)this + 54), (HGNode *)this);
}

uint64_t HGToneCurve::SetToneCurveParams(uint64_t a1, uint64_t a2, char *a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10)
{
  int v17 = a2;
  HGNode::ClearBits((HGNode *)a1, a2, a3);
  if ((v17 & ~(v17 >> 31)) >= 4) {
    int v19 = 4;
  }
  else {
    int v19 = v17 & ~(v17 >> 31);
  }
  *(_DWORD *)(a1 + 408) = v19;
  *(float *)(a1 + 440) = a4;
  *(float *)(a1 + 444) = a5;
  *(float *)(a1 + 448) = a6;
  *(float *)(a1 + 452) = a7;
  *(float *)(a1 + 456) = a8;
  *(float *)(a1 + 460) = a9;
  *(float *)(a1 + 464) = a10;
  uint64_t result = HGToneCurve::AcceleratedState(v19, a4, a5, a6, a7, a8, a9, a10);
  *(_DWORD *)(a1 + 424) = result;
  return result;
}

HGNode *HGToneCurve::SetToneCurveQuality(uint64_t a1, uint64_t a2, char *a3)
{
  int v3 = a2;
  uint64_t result = HGNode::ClearBits((HGNode *)a1, a2, a3);
  unsigned int v6 = v3 & ~(v3 >> 31);
  if (v6 >= 7) {
    unsigned int v6 = 7;
  }
  *(_DWORD *)(a1 + 412) = v6;
  return result;
}

HGNode *HGToneCurve::SetPremultiplyState(HGNode *this, uint64_t a2, char *a3)
{
  char v3 = a2;
  uint64_t result = HGNode::ClearBits(this, a2, a3);
  *((unsigned char *)this + 416) = v3;
  return result;
}

BOOL HGToneCurve::CanProcess(HGToneCurve *this)
{
  switch(*((_DWORD *)this + 106))
  {
    case 1:
      BOOL v1 = 1;
      int v2 = 41;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          int v2 = 42;
          goto LABEL_107;
        case 2:
          int v2 = 44;
          goto LABEL_107;
        case 3:
        case 4:
          int v2 = 43;
          goto LABEL_107;
        case 5:
          int v2 = 45;
          goto LABEL_107;
        case 6:
        case 7:
          int v2 = 46;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 2:
      BOOL v1 = 1;
      int v2 = 35;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          int v2 = 36;
          goto LABEL_107;
        case 2:
          int v2 = 38;
          goto LABEL_107;
        case 3:
        case 4:
          int v2 = 37;
          goto LABEL_107;
        case 5:
          int v2 = 39;
          goto LABEL_107;
        case 6:
        case 7:
          int v2 = 40;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 3:
      BOOL v1 = 1;
      int v2 = 53;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          int v2 = 54;
          goto LABEL_107;
        case 2:
          int v2 = 56;
          goto LABEL_107;
        case 3:
        case 4:
          int v2 = 55;
          goto LABEL_107;
        case 5:
          int v2 = 57;
          goto LABEL_107;
        case 6:
        case 7:
          int v2 = 58;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 4:
      BOOL v1 = 1;
      int v2 = 47;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          int v2 = 48;
          goto LABEL_107;
        case 2:
          int v2 = 50;
          goto LABEL_107;
        case 3:
        case 4:
          int v2 = 49;
          goto LABEL_107;
        case 5:
          int v2 = 51;
          goto LABEL_107;
        case 6:
        case 7:
          int v2 = 52;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 5:
      BOOL v1 = 1;
      int v2 = 65;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          int v2 = 66;
          goto LABEL_107;
        case 2:
          int v2 = 68;
          goto LABEL_107;
        case 3:
        case 4:
          int v2 = 67;
          goto LABEL_107;
        case 5:
          int v2 = 69;
          goto LABEL_107;
        case 6:
        case 7:
          int v2 = 70;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 6:
      BOOL v1 = 1;
      int v2 = 59;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          int v2 = 60;
          goto LABEL_107;
        case 2:
          int v2 = 62;
          goto LABEL_107;
        case 3:
        case 4:
          int v2 = 61;
          goto LABEL_107;
        case 5:
          int v2 = 63;
          goto LABEL_107;
        case 6:
        case 7:
          int v2 = 64;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 7:
      BOOL v1 = 1;
      int v2 = 77;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          goto LABEL_107;
        case 1:
          int v2 = 78;
          goto LABEL_107;
        case 2:
          int v2 = 80;
          goto LABEL_107;
        case 3:
        case 4:
          int v2 = 79;
          goto LABEL_107;
        case 5:
          int v2 = 81;
          goto LABEL_107;
        case 6:
        case 7:
          int v2 = 82;
          goto LABEL_107;
        default:
          goto LABEL_18;
      }
    case 8:
      BOOL v1 = 1;
      int v2 = 71;
      switch(*((_DWORD *)this + 103))
      {
        case 0:
          break;
        case 1:
          int v2 = 72;
          break;
        case 2:
          int v2 = 74;
          break;
        case 3:
        case 4:
          int v2 = 73;
          break;
        case 5:
          int v2 = 75;
          break;
        case 6:
        case 7:
          int v2 = 76;
          break;
        default:
          goto LABEL_18;
      }
LABEL_107:
      *((_DWORD *)this + 105) = v2;
LABEL_108:
      BOOL result = v1;
      break;
    default:
LABEL_18:
      switch(*((_DWORD *)this + 102))
      {
        case 0:
          BOOL v1 = *((float *)this + 110) != 1.0;
          int v2 = *((_DWORD *)this + 103);
          switch(v2)
          {
            case 0:
              goto LABEL_107;
            case 1:
              int v2 = 1;
              goto LABEL_107;
            case 2:
              int v2 = 3;
              goto LABEL_107;
            case 3:
            case 4:
              int v2 = 2;
              goto LABEL_107;
            case 5:
              int v2 = 4;
              goto LABEL_107;
            case 6:
              int v2 = 5;
              goto LABEL_107;
            case 7:
              int v2 = 6;
              goto LABEL_107;
            default:
              goto LABEL_108;
          }
          goto LABEL_108;
        case 1:
          BOOL v1 = *((float *)this + 110) != 1.0 || *((float *)this + 112) != 0.0 || *((float *)this + 111) != 1.0;
          int v2 = 7;
          switch(*((_DWORD *)this + 103))
          {
            case 0:
              goto LABEL_107;
            case 1:
              int v2 = 8;
              goto LABEL_107;
            case 2:
              int v2 = 10;
              goto LABEL_107;
            case 3:
            case 4:
              int v2 = 9;
              goto LABEL_107;
            case 5:
              int v2 = 11;
              goto LABEL_107;
            case 6:
              int v2 = 12;
              goto LABEL_107;
            case 7:
              int v2 = 13;
              goto LABEL_107;
            default:
              goto LABEL_108;
          }
          goto LABEL_108;
        case 2:
          BOOL v1 = *((float *)this + 110) != 1.0
            || *((float *)this + 112) != 0.0
            || *((float *)this + 111) != 1.0
            || *((float *)this + 113) != 0.0;
          int v2 = 14;
          switch(*((_DWORD *)this + 103))
          {
            case 0:
              goto LABEL_107;
            case 1:
              int v2 = 15;
              goto LABEL_107;
            case 2:
              int v2 = 17;
              goto LABEL_107;
            case 3:
            case 4:
              int v2 = 16;
              goto LABEL_107;
            case 5:
              int v2 = 18;
              goto LABEL_107;
            case 6:
              int v2 = 19;
              goto LABEL_107;
            case 7:
              int v2 = 20;
              goto LABEL_107;
            default:
              goto LABEL_108;
          }
          goto LABEL_108;
        case 3:
          BOOL v1 = *((float *)this + 110) != 1.0
            || *((float *)this + 112) != 0.0
            || *((float *)this + 111) != 1.0
            || *((float *)this + 113) != 1.0;
          int v2 = 21;
          switch(*((_DWORD *)this + 103))
          {
            case 0:
              goto LABEL_107;
            case 1:
              int v2 = 22;
              goto LABEL_107;
            case 2:
              int v2 = 24;
              goto LABEL_107;
            case 3:
            case 4:
              int v2 = 23;
              goto LABEL_107;
            case 5:
              int v2 = 25;
              goto LABEL_107;
            case 6:
              int v2 = 26;
              goto LABEL_107;
            case 7:
              int v2 = 27;
              goto LABEL_107;
            default:
              goto LABEL_108;
          }
          goto LABEL_108;
        case 4:
          BOOL v1 = *((float *)this + 110) != 1.0
            || *((float *)this + 111) != 1.0
            || (float)(*((float *)this + 112) + *((float *)this + 115)) != 0.0
            || *((float *)this + 113) != 1.0
            || *((float *)this + 116) != 0.0;
          int v2 = 28;
          switch(*((_DWORD *)this + 103))
          {
            case 0:
              goto LABEL_107;
            case 1:
              int v2 = 29;
              goto LABEL_107;
            case 2:
              int v2 = 31;
              goto LABEL_107;
            case 3:
            case 4:
              int v2 = 30;
              goto LABEL_107;
            case 5:
              int v2 = 32;
              goto LABEL_107;
            case 6:
              int v2 = 33;
              goto LABEL_107;
            case 7:
              int v2 = 34;
              goto LABEL_107;
            default:
              goto LABEL_108;
          }
          goto LABEL_108;
        default:
          BOOL result = 1;
          break;
      }
      break;
  }
  return result;
}

HGNode *HGToneCurve::GetOutput(HGNode *this, HGRenderer *a2)
{
  if (HGRenderer::IsMergeable(a2, this, 0, 0))
  {
    Input = HGRenderer::GetInput(a2, this, 0);
    if (Input)
    {
      if (v5)
      {
        unsigned int v6 = (HGNode *)v5;
        if (HGToneCurve::CanBypass((HGToneCurve *)this, v5))
        {
          unsigned int v7 = a2;
          unsigned int v8 = v6;
          return HGRenderer::GetInput(v7, v8, 0);
        }
      }
    }
  }
  if (!HGToneCurve::CanProcess((HGToneCurve *)this))
  {
    unsigned int v7 = a2;
    unsigned int v8 = this;
    return HGRenderer::GetInput(v7, v8, 0);
  }
  HGToneCurve::SetShaderParams((HGToneCurve *)this, v10);
  return this;
}

BOOL HGToneCurve::CanBypass(HGToneCurve *this, HGToneCurve *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  (*(void (**)(HGToneCurve *, void, float *))(*(void *)a2 + 104))(a2, 0, v9);
  BOOL result = 0;
  if (v9[1] == (float)*((int *)this + 103))
  {
    v4.n128_f32[0] = v10;
    int v6 = *((_DWORD *)this + 106);
    if (v6 == 2 && v10 == 1.0) {
      return 1;
    }
    BOOL v8 = v6 == 1 && v10 == 2.0;
    if (v8
      || v6 == 4 && v10 == 3.0
      || v6 == 3 && v10 == 4.0
      || v6 == 6 && v10 == 5.0
      || v6 == 5 && v10 == 6.0
      || v6 == 8 && v10 == 7.0
      || v6 == 7 && v10 == 8.0)
    {
      return 1;
    }
    else
    {
      (*(void (**)(HGToneCurve *, uint64_t, float *, __n128))(*(void *)a2 + 104))(a2, 1, v9, v4);
      return !*((_DWORD *)this + 102) && fabsf((float)(v9[0] * *((float *)this + 110)) + -1.0) < 0.000001;
    }
  }
  return result;
}

char *HGToneCurve::label_B(HGToneCurve *this)
{
  if (*((unsigned char *)this + 416)) {
    BOOL v1 = hgtonecurve_read_label;
  }
  else {
    BOOL v1 = hgtonecurve_unpremult_read_label;
  }
  return v1[*((unsigned int *)this + 105)];
}

double HGToneCurve::State::State(HGToneCurve::State *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = xmmword_1B7E734D0;
  *((_OWORD *)this + 4) = xmmword_1B7E751A0;
  *((_OWORD *)this + 5) = xmmword_1B7E75890;
  *((_OWORD *)this + 6) = xmmword_1B8348BD0;
  *((_OWORD *)this + 7) = xmmword_1B8348BE0;
  *((_OWORD *)this + 8) = xmmword_1B8348BF0;
  *((_OWORD *)this + 9) = xmmword_1B8348C00;
  *((_OWORD *)this + 10) = xmmword_1B8348C10;
  *((_OWORD *)this + 11) = xmmword_1B8348C20;
  *((_OWORD *)this + 12) = xmmword_1B8348C30;
  *((_OWORD *)this + 13) = xmmword_1B8347FE0;
  *((_OWORD *)this + 14) = xmmword_1B8348C40;
  *((_OWORD *)this + 15) = xmmword_1B7E752F0;
  *((int32x4_t *)this + 16) = vdupq_n_s32(0x358637BDu);
  *((_OWORD *)this + 17) = xmmword_1B7E75810;
  *((int32x4_t *)this + 18) = vdupq_n_s32(0x3F804020u);
  *((_OWORD *)this + 19) = xmmword_1B7E75900;
  *((_OWORD *)this + 20) = xmmword_1B7E75910;
  *((int32x4_t *)this + 21) = vdupq_n_s32(0x7F800000u);
  *((_OWORD *)this + 22) = xmmword_1B7E75930;
  *((_OWORD *)this + 23) = xmmword_1B7E75940;
  *((_OWORD *)this + 24) = xmmword_1B7E75840;
  *((_OWORD *)this + 25) = xmmword_1B7E75950;
  *((_OWORD *)this + 26) = xmmword_1B7E75960;
  *((_OWORD *)this + 27) = xmmword_1B7E75970;
  *((_OWORD *)this + 28) = xmmword_1B7E75980;
  *((_OWORD *)this + 29) = xmmword_1B7E75990;
  *((_OWORD *)this + 30) = xmmword_1B7E759A0;
  *((_OWORD *)this + 31) = xmmword_1B7E759B0;
  *((_OWORD *)this + 32) = xmmword_1B7E759C0;
  *((_OWORD *)this + 33) = xmmword_1B7E759D0;
  *((_OWORD *)this + 34) = xmmword_1B7E76340;
  *((_OWORD *)this + 35) = xmmword_1B7E75850;
  *((_OWORD *)this + 36) = xmmword_1B7E775E0;
  *((_OWORD *)this + 37) = xmmword_1B8348C50;
  *((_OWORD *)this + 38) = xmmword_1B8348C60;
  *((_OWORD *)this + 39) = xmmword_1B8348C70;
  *((_OWORD *)this + 40) = xmmword_1B8348C80;
  *((_OWORD *)this + 41) = xmmword_1B8348C90;
  *((_OWORD *)this + 42) = xmmword_1B8348CA0;
  *((_OWORD *)this + 43) = xmmword_1B8348CB0;
  *((_OWORD *)this + 44) = xmmword_1B8348CC0;
  *((_OWORD *)this + 45) = xmmword_1B8348CD0;
  *((_OWORD *)this + 46) = xmmword_1B8348CE0;
  *((_OWORD *)this + 47) = xmmword_1B8348CF0;
  *((_OWORD *)this + 48) = xmmword_1B8348D00;
  *((_OWORD *)this + 49) = xmmword_1B8348D10;
  *(void *)&long long v1 = 0x3F0000003FLL;
  *((void *)&v1 + 1) = 0x3F0000003FLL;
  *((_OWORD *)this + 50) = 0u;
  *((_OWORD *)this + 51) = v1;
  *((_OWORD *)this + 52) = xmmword_1B8348D20;
  *((_OWORD *)this + 53) = xmmword_1B8348D30;
  *((_OWORD *)this + 54) = xmmword_1B8348D40;
  *((_OWORD *)this + 55) = xmmword_1B8348D50;
  *((_OWORD *)this + 56) = xmmword_1B8348D60;
  *((_OWORD *)this + 57) = xmmword_1B8348D70;
  *((_OWORD *)this + 58) = xmmword_1B8348D80;
  *((_OWORD *)this + 59) = xmmword_1B8348D90;
  *((_OWORD *)this + 60) = xmmword_1B8348DA0;
  *((_OWORD *)this + 61) = xmmword_1B8348DB0;
  *((_OWORD *)this + 62) = xmmword_1B8348DC0;
  *((_OWORD *)this + 63) = xmmword_1B8348DD0;
  *((_OWORD *)this + 64) = xmmword_1B8348DE0;
  *((_OWORD *)this + 65) = xmmword_1B8348DF0;
  *((_OWORD *)this + 66) = xmmword_1B8348E00;
  *((_OWORD *)this + 67) = xmmword_1B8348E10;
  *((_OWORD *)this + 68) = xmmword_1B8348E20;
  *((_OWORD *)this + 69) = xmmword_1B8348E30;
  *((_OWORD *)this + 70) = xmmword_1B8348E40;
  *((_OWORD *)this + 71) = xmmword_1B8348E50;
  *((_OWORD *)this + 72) = xmmword_1B8348E60;
  *((int32x4_t *)this + 73) = vdupq_n_s32(0x7F7FFFFFu);
  *((_OWORD *)this + 74) = xmmword_1B7E75360;
  *((_OWORD *)this + 75) = xmmword_1B7E73460;
  *((_OWORD *)this + 76) = xmmword_1B7E75300;
  *((_OWORD *)this + 77) = xmmword_1B8348E70;
  *((_OWORD *)this + 78) = xmmword_1B8348E80;
  *((_OWORD *)this + 79) = xmmword_1B8348E90;
  *((_OWORD *)this + 80) = xmmword_1B8348EA0;
  *((_OWORD *)this + 81) = xmmword_1B8348EB0;
  *((_OWORD *)this + 82) = xmmword_1B8348EC0;
  *((_OWORD *)this + 83) = xmmword_1B8348ED0;
  *((_OWORD *)this + 84) = xmmword_1B8348EE0;
  *((_OWORD *)this + 85) = xmmword_1B8348EF0;
  *((_OWORD *)this + 86) = xmmword_1B8348F00;
  *((_OWORD *)this + 87) = xmmword_1B8348F10;
  *((_OWORD *)this + 88) = xmmword_1B8348F20;
  *((_OWORD *)this + 89) = xmmword_1B8348F30;
  *((_OWORD *)this + 90) = xmmword_1B8348F40;
  *((_OWORD *)this + 91) = xmmword_1B8348F50;
  *((_OWORD *)this + 92) = xmmword_1B8348F60;
  *((_OWORD *)this + 93) = xmmword_1B7E76AB0;
  *((_OWORD *)this + 94) = xmmword_1B8348F70;
  *((_OWORD *)this + 95) = xmmword_1B8348F80;
  *((_OWORD *)this + 96) = xmmword_1B8348F90;
  *((_OWORD *)this + 97) = xmmword_1B8348FA0;
  *((_OWORD *)this + 98) = xmmword_1B8348FB0;
  *((_OWORD *)this + 99) = xmmword_1B8348FC0;
  *((_OWORD *)this + 100) = xmmword_1B8348FD0;
  *((_OWORD *)this + 101) = xmmword_1B7EC1F10;
  *((_OWORD *)this + 102) = xmmword_1B8348FE0;
  *((_OWORD *)this + 103) = xmmword_1B7EC1EF0;
  *((_OWORD *)this + 104) = xmmword_1B7EC1F00;
  *((_OWORD *)this + 105) = xmmword_1B8348FF0;
  *((_OWORD *)this + 106) = xmmword_1B8349000;
  *((_OWORD *)this + 107) = xmmword_1B8349010;
  *((_OWORD *)this + 108) = xmmword_1B8349020;
  *((_OWORD *)this + 109) = xmmword_1B7E7CD40;
  *((_OWORD *)this + 110) = xmmword_1B8349030;
  *((_OWORD *)this + 111) = xmmword_1B8349040;
  *((_OWORD *)this + 112) = xmmword_1B7EC1EC0;
  *((_OWORD *)this + 113) = xmmword_1B8349050;
  *((_OWORD *)this + 114) = xmmword_1B8349060;
  *((_OWORD *)this + 115) = xmmword_1B8349070;
  double result = 1.648;
  *((_OWORD *)this + 116) = xmmword_1B7E7CD80;
  return result;
}

const char *Gettype0_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=20f42ccd:177bb552:78dd23af:883d5aab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4e9a049b:521821a9:74d35da9:00427891\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000312\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=182b38ea:7b2646c3:313af2b3:04cb7251\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=20f42ccd:177bb552:78dd23af:883d5aab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4e9a049b:521821a9:74d35da9:00427891\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000312\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=182b38ea:7b2646c3:313af2b3:04cb7251\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=20f42ccd:177bb552:78dd23af:883d5aab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4e9a049b:521821a9:74d35da9:00427891\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000030b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f0461501:6e89cdbc:ed292272:68967d2e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000035c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=20f42ccd:177bb552:78dd23af:883d5aab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4e9a049b:521821a9:74d35da9:00427891\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000314\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=de1f5717:17783782:771374af:c557d8f4\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8c2fbc56:4cc55537:fad67de0:f0bc16ab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003a0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd3502b5:2cd7db74:213aeca0:faa23b85\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=59f9aeda:d6ff3300:fea98945:87997e82\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8c2fbc56:4cc55537:fad67de0:f0bc16ab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003a0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd3502b5:2cd7db74:213aeca0:faa23b85\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5d43e82d:f82cb0c1:2fc25041:d7c8c18e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_floatProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8c2fbc56:4cc55537:fad67de0:f0bc16ab\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003a0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd3502b5:2cd7db74:213aeca0:faa23b85\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003d0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5d43e82d:f82cb0c1:2fc25041:d7c8c18e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000453\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=08bef2cc:3b362180:b8b760c8:d704e1c6\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000042c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=65455e26:aae30178:80df69f1:b13cc037\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000466\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=aa7fe365:857e3a79:b6d0a374:223504aa\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000453\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=08bef2cc:3b362180:b8b760c8:d704e1c6\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000042c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=65455e26:aae30178:80df69f1:b13cc037\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000466\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=aa7fe365:857e3a79:b6d0a374:223504aa\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000453\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=08bef2cc:3b362180:b8b760c8:d704e1c6\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000042c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=65455e26:aae30178:80df69f1:b13cc037\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000045d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f91b4dd8:c404bfa1:760fd8af:74430a58\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000453\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=08bef2cc:3b362180:b8b760c8:d704e1c6\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000042c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=65455e26:aae30178:80df69f1:b13cc037\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000468\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3c23f051:eaf48604:aa8f339c:ce73b350\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000043a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0a959b1e:d3ecfb63:3d2c0792:3dbf9f3f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000413\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7903a5a3:029dca7a:2f3f8e86:e6cc37c7\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000445\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f560df30:4974ef6f:2fcd2fb5:ff40bbe7\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000043a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0a959b1e:d3ecfb63:3d2c0792:3dbf9f3f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000413\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7903a5a3:029dca7a:2f3f8e86:e6cc37c7\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000043a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=8f80d0db:676786df:896dbbd8:ca818ca5\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_floatProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000043a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0a959b1e:d3ecfb63:3d2c0792:3dbf9f3f\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000413\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=7903a5a3:029dca7a:2f3f8e86:e6cc37c7\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000043a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=8f80d0db:676786df:896dbbd8:ca818ca5\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000049d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=92fb4533:04bac7c8:6cb1b762:ee971088\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=87250ca9:031b0571:234dcae3:a5c89a4d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004de\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=ffd33e53:70c1c4af:3f0c646d:9681734f\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000049d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=92fb4533:04bac7c8:6cb1b762:ee971088\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=87250ca9:031b0571:234dcae3:a5c89a4d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004de\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=ffd33e53:70c1c4af:3f0c646d:9681734f\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000049d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=92fb4533:04bac7c8:6cb1b762:ee971088\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=87250ca9:031b0571:234dcae3:a5c89a4d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004d3\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=749828b3:4f049c36:34a00297:da68786b\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000049d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=92fb4533:04bac7c8:6cb1b762:ee971088\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=87250ca9:031b0571:234dcae3:a5c89a4d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004e0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=a9f5d177:5f5d6b08:dc77a778:411aa2c8\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000469\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1b4311bc:39a0fa86:9605b790:112f1020\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000043b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=32abf88e:f2b51ba2:fd50cf48:61df2131\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000498\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=174a2ca1:24a9601e:20dabf3d:efeb373c\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000469\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1b4311bc:39a0fa86:9605b790:112f1020\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000043b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=32abf88e:f2b51ba2:fd50cf48:61df2131\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000048b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c914f1c4:1280ed09:be9bcd06:19f12018\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_floatProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000469\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=1b4311bc:39a0fa86:9605b790:112f1020\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000043b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=32abf88e:f2b51ba2:fd50cf48:61df2131\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000048b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c914f1c4:1280ed09:be9bcd06:19f12018\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=de17ce8a:72a40e6a:fdb14397:674a3b9e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4224cc02:5b0987c8:78bb097e:49047380\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000047f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=80099d45:b30fce8c:8e93ad4a:38bd9a40\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=de17ce8a:72a40e6a:fdb14397:674a3b9e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4224cc02:5b0987c8:78bb097e:49047380\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000047f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=80099d45:b30fce8c:8e93ad4a:38bd9a40\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=de17ce8a:72a40e6a:fdb14397:674a3b9e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4224cc02:5b0987c8:78bb097e:49047380\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000476\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=682ccd8d:64d8c659:5538c6fb:cf213a17\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000046f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=de17ce8a:72a40e6a:fdb14397:674a3b9e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=4224cc02:5b0987c8:78bb097e:49047380\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000481\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3e26abbf:b51e934a:0eaea483:a61051d9\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000465\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0b5d8c63:af3d6b84:d7956f5f:4dac39cc\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f39de0cd:9e76e5bc:5803465d:9943c9ca\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000046d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=7e1f0376:dccb70f7:f4141705:8081beb7\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000465\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0b5d8c63:af3d6b84:d7956f5f:4dac39cc\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f39de0cd:9e76e5bc:5803465d:9943c9ca\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000462\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=81f81d5d:db456118:feabd803:f7c376a4\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_floatProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000465\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=0b5d8c63:af3d6b84:d7956f5f:4dac39cc\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f39de0cd:9e76e5bc:5803465d:9943c9ca\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000462\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=81f81d5d:db456118:feabd803:f7c376a4\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000050e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0b3015a:c4c77f90:f8e66018:3a2a1487\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000497\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91df01b2:ab4291da:8ec16055:5c19d880\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000050e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=20859c2d:6233ef7a:90bde4e6:3bf84cdb\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000050e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0b3015a:c4c77f90:f8e66018:3a2a1487\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000497\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91df01b2:ab4291da:8ec16055:5c19d880\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000050e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=20859c2d:6233ef7a:90bde4e6:3bf84cdb\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000050e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0b3015a:c4c77f90:f8e66018:3a2a1487\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000497\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91df01b2:ab4291da:8ec16055:5c19d880\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000503\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f5b63af9:48536670:cfb336fb:139fd5b1\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000050e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0b3015a:c4c77f90:f8e66018:3a2a1487\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000497\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=91df01b2:ab4291da:8ec16055:5c19d880\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000510\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=70dcc2bc:d1658f7f:081f4c58:d4fbcac9\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004d8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a2c3c908:016206be:67d56c9c:9c001e7d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000472\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.w;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=16aeb384:4247f51a:d777a509:76109a61\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004d7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.w;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=97daefca:65fccb97:c63a820c:f94ab701\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004d8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a2c3c908:016206be:67d56c9c:9c001e7d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000472\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.w;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=16aeb384:4247f51a:d777a509:76109a61\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004ca\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.w;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=95311b7e:8028d7fe:9fcf7f0c:7737fcfe\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_floatProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004d8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a2c3c908:016206be:67d56c9c:9c001e7d\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000472\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.w = c0.w;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=16aeb384:4247f51a:d777a509:76109a61\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004ca\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.w = c0.w;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=95311b7e:8028d7fe:9fcf7f0c:7737fcfe\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000032f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=7dc0dfbc:c836a038:13cdd6d9:c60d7e3e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000324\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bdfaf4f0:4a68472f:e4ce4c4c:69bdede1\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = sqrt(r1.xyz);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=28efafef:fde41fd4:7dc2b893:64d224c6\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000440\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const half4 c1 = half4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=880f0614:cc8cb34f:d8f516f4:2fef1ed2\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f18124a9:bf474d14:474143e7:2c5831a1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
           "    const mediump vec4 c1 = vec4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3919ff3c:0a650753:cfe62bc5:50f25c9b\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000440\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const half4 c1 = half4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=880f0614:cc8cb34f:d8f516f4:2fef1ed2\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f18124a9:bf474d14:474143e7:2c5831a1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000406\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
           "    const highp vec4 c1 = vec4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0a584153:9bd953c5:863c9b66:c29b89c1\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000440\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const half4 c1 = half4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=880f0614:cc8cb34f:d8f516f4:2fef1ed2\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000437\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
             "    const float4 c1 = float4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=f18124a9:bf474d14:474143e7:2c5831a1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.098999977);\n"
           "    const mediump vec4 c1 = vec4(-0.09899999946, 4.500000000, 0.01799999923, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=4e704514:44ec5fc8:a83e7283:d1311c23\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000542\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const half4 c2 = half4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b9cc7239:53c07d97:6516f562:857552eb\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000053b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const float4 c2 = float4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=615b58db:20b8ac2f:c4df9b5f:d051b98f\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000581\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const mediump vec4 c1 = vec4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
           "    const mediump vec4 c2 = vec4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=532ea0ea:1b8a64cc:6df0891e:5451cc3a\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec709_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000542\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const half4 c2 = half4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b9cc7239:53c07d97:6516f562:857552eb\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000053b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
             "    const float4 c2 = float4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=615b58db:20b8ac2f:c4df9b5f:d051b98f\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000576\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const highp vec4 c1 = vec4(0.4499999881, 1.098999977, -0.09899999946, 4.500000000);\n"
           "    const highp vec4 c2 = vec4(0.01799999923, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5436f98d:da033e02:e56c36e4:4d4486b6\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000330\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=aa266737:ced8974d:678b2327:1590d25a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000325\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5c2db76f:f3872933:3b70ed57:2d3f143f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = r1.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=fdba60fd:9f8e713f:a1e88db5:b74ecef0\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000455\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const half4 c1 = half4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9c547199:95409cef:755c552e:ad150c39\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e31de786:5e047bee:e7a2bde8:154760dd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000422\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=622dff9d:420f8d79:759459b7:9d82fc32\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000455\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const half4 c1 = half4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9c547199:95409cef:755c552e:ad150c39\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e31de786:5e047bee:e7a2bde8:154760dd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000041b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
           "    const highp vec4 c1 = vec4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=7ed9badc:f8fd08b3:59cc3168:821c417c\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000455\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const half4 c1 = half4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9c547199:95409cef:755c552e:ad150c39\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
             "    const float4 c1 = float4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=e31de786:5e047bee:e7a2bde8:154760dd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000424\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.09899999946, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.8108000159, 0.2220000029, 0.08120000362, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=44a6b46f:44bdd250:cb929530:c15d0619\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000557\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const half4 c2 = half4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c5ec1c4f:dfe08d64:ee57c69c:a27502b1\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000550\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const float4 c2 = float4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6ca877ba:5f861024:45a23c29:a6357148\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000596\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const mediump vec4 c1 = vec4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
           "    const mediump vec4 c2 = vec4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c5df66d8:fd0ad819:9e10e85c:e9f2f9ed\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec709_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000557\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const half4 c2 = half4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c5ec1c4f:dfe08d64:ee57c69c:a27502b1\n"
             "//SIG=00400000:00000001:00000001:00000001:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000550\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
             "    const float4 c2 = float4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.www;\n"
             "    r1.xyz = r1.xyz - c2.xxx;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6ca877ba:5f861024:45a23c29:a6357148\n"
             "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000058b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const highp vec4 c1 = vec4(0.09899999946, 2.220000029, 0.8108000159, 0.2220000029);\n"
           "    const highp vec4 c2 = vec4(0.08120000362, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.www;\n"
           "    r1.xyz = r1.xyz - c2.xxx;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=24afdb36:4e250bda:6c16f24c:0c8880bc\n"
           "//SIG=00000000:00000001:00000001:00000000:0003:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000032f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=7dc0dfbc:c836a038:13cdd6d9:c60d7e3e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000324\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bdfaf4f0:4a68472f:e4ce4c4c:69bdede1\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = sqrt(r1.xyz);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=28efafef:fde41fd4:7dc2b893:64d224c6\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000043f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const half4 c1 = half4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ded8d455:606b3774:cf46c232:f7f8dd1f\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000436\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=13c96d46:6c5686ac:da7b737c:3948a744\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
           "    const mediump vec4 c1 = vec4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=2d0114da:730d4c56:a024c116:44fda0bb\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000043f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const half4 c1 = half4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ded8d455:606b3774:cf46c232:f7f8dd1f\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000436\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=13c96d46:6c5686ac:da7b737c:3948a744\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000405\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
           "    const highp vec4 c1 = vec4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=fce4fe11:ffecb27c:df22a65c:797977c8\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000043f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const half4 c1 = half4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ded8d455:606b3774:cf46c232:f7f8dd1f\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000436\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
             "    const float4 c1 = float4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=13c96d46:6c5686ac:da7b737c:3948a744\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4499999881, 1.111500025);\n"
           "    const mediump vec4 c1 = vec4(-0.1115000024, 4.000000000, 0.02280000038, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=8678ec2f:24669b7f:e182efb9:7f6972b5\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004f2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f7e4207f:da26c069:1cfb1c75:e27e6221\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=98092e7c:08315962:ca7a98d8:a90c2dc3\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000052b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const mediump vec4 c1 = vec4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.yyy;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=210dfebd:abe83807:6c7bd68f:5e48b109\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getrec601_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004f2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const half4 c1 = half4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f7e4207f:da26c069:1cfb1c75:e27e6221\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
             "    const float4 c1 = float4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.yyy;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=98092e7c:08315962:ca7a98d8:a90c2dc3\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000522\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.330000043);\n"
           "    const highp vec4 c1 = vec4(0.4499999881, 1.111500025, -0.1115000024, 0.02280000038);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy + c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.yyy;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f9786a5a:b9f8a78e:99cf8eb9:bb98dc64\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000330\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=aa266737:ced8974d:678b2327:1590d25a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000325\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5c2db76f:f3872933:3b70ed57:2d3f143f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = r1.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=fdba60fd:9f8e713f:a1e88db5:b74ecef0\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000454\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const half4 c1 = half4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a6aa203c:cce763d8:235b7d77:c93b9aff\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bc23966e:14be2697:71ada8fa:a9af29fd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000421\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=cb3c7562:84299991:09fbdc07:2ec2d025\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000454\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const half4 c1 = half4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a6aa203c:cce763d8:235b7d77:c93b9aff\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bc23966e:14be2697:71ada8fa:a9af29fd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000041a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
           "    const highp vec4 c1 = vec4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=7dc09eea:0930a865:2a70a43d:67ba2dca\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000454\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const half4 c1 = half4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a6aa203c:cce763d8:235b7d77:c93b9aff\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
             "    const float4 c1 = float4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bc23966e:14be2697:71ada8fa:a9af29fd\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000423\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.1115000024, 2.220000029);\n"
           "    const mediump vec4 c1 = vec4(0.7906000018, 0.2500000000, 0.09130000323, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=67d90621:f4dc58de:8e6454fb:a7c0c93b\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000506\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d582d28b:3fc6a911:6b763ef9:6ae7cb33\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004fd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5a07b771:f2b95122:2bf87a50:0dc832df\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000053f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const mediump vec4 c1 = vec4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.xxx;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c4b6b6d2:9c9c7d5d:24dbd61e:e21dbd00\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_rec601_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000506\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const half4 c1 = half4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d582d28b:3fc6a911:6b763ef9:6ae7cb33\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004fd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
             "    const float4 c1 = float4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(c0.zzz, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz + c1.xxx;\n"
             "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
             "    r2.xyz = r2.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*-c0.xxx;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r1.xyz = select(c0.zzz, c0.xxx, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5a07b771:f2b95122:2bf87a50:0dc832df\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000536\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -4.000000000, 1.000000000, 1.149999976);\n"
           "    const highp vec4 c1 = vec4(0.1115000024, 2.220000029, 0.7906000018, 0.09130000323);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : c0.z, r0.y < 0.00000 ? c0.y : c0.z, r0.z < 0.00000 ? c0.y : c0.z);\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz + c1.xxx;\n"
           "    r2.xyz = pow(r2.xyz, c1.yyy);\n"
           "    r2.xyz = r2.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*-c0.xxx;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.x : c0.z, r0.y < 0.00000 ? c0.x : c0.z, r0.z < 0.00000 ? c0.x : c0.z);\n"
           "    r0.xyz = r2.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=05733f29:0676d724:10f32f1c:eabc05d1\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000379\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.200000048, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = sqrt(r2.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=338d6991:bb8c35f4:c24065b6:e2ddd0bf\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000036e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.200000048, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = sqrt(r2.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=8ca817c7:ae13bb8c:2ccf5dfd:18976027\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000030b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 1.200000048, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz*c0.zzz;\n"
           "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
           "    r0.xyz = sqrt(r2.xyz);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0beefa58:f2d5d814:e230ba8a:c1014acf\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const half4 c1 = half4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d3b643c1:058374be:1a7b730c:64a7f017\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000438\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bf3fc1c7:5a610b84:ee2623c1:37dbc3f1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
           "    const mediump vec4 c1 = vec4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=04dc4171:e48201e2:5b166dbe:11bf1513\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const half4 c1 = half4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d3b643c1:058374be:1a7b730c:64a7f017\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000438\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bf3fc1c7:5a610b84:ee2623c1:37dbc3f1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000407\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
           "    const highp vec4 c1 = vec4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=bd46d998:a485ec56:c2e9088e:c10d0cd5\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000441\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const half4 c1 = half4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d3b643c1:058374be:1a7b730c:64a7f017\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000438\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
             "    const float4 c1 = float4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bf3fc1c7:5a610b84:ee2623c1:37dbc3f1\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000410\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.4165999889, 1.054999948);\n"
           "    const mediump vec4 c1 = vec4(-0.05499999970, 12.92000008, 0.003130800091, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz*c0.www + c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=a177af96:6455671a:a5ff5333:2ae7cf93\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004d9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const half4 c1 = half4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e2f46501:6eaf47b9:17674bda:304195a8\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004d0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const float4 c1 = float4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2c805bad:1968a6b1:420de9b1:d3d0cefa\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000516\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
           "    const mediump vec4 c1 = vec4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=52ffc3ca:de6717e7:9ced0b9c:d6e81a3b\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getsrgb_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004d9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const half4 c1 = half4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e2f46501:6eaf47b9:17674bda:304195a8\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004d0\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
             "    const float4 c1 = float4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2c805bad:1968a6b1:420de9b1:d3d0cefa\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000050d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.5299999714, -1.000000000, 1.679999948, 0.4165999889);\n"
           "    const highp vec4 c1 = vec4(1.054999948, -0.05499999970, 12.92000008, 0.003130800091);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx + c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0b24d80b:1241119b:9bc872ae:27374f1e\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000037b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.8600000143, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = r2.xyz*r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cff72616:949f2683:7b17f44a:3ba0ce15\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000370\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.8600000143, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz*c0.zzz;\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
             "    r0.xyz = r2.xyz*r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=de2ecf3a:ce74014d:1a29904c:4cc7a8ce\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000030d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.8600000143, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz*c0.zzz;\n"
           "    r2.xyz = mix(r2.xyz, r1.xyz, r1.xyz);\n"
           "    r0.xyz = r2.xyz*r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=bb90a585:c52419c2:c07b9004:5b6745c0\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000456\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const half4 c1 = half4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ce7d29de:9f899a0d:f3fde93a:57d945e7\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=177e913d:55f303a1:e1f32632:f0623a5f\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000423\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
           "    const mediump vec4 c1 = vec4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=4af6312b:82e53e55:f354a5e6:3ba91fd2\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000456\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const half4 c1 = half4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ce7d29de:9f899a0d:f3fde93a:57d945e7\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=177e913d:55f303a1:e1f32632:f0623a5f\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000041c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
           "    const highp vec4 c1 = vec4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=b4eb37d1:a0806a0e:93ab5e34:02169094\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000456\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const half4 c1 = half4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ce7d29de:9f899a0d:f3fde93a:57d945e7\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
             "    const float4 c1 = float4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r2.xyz = r1.xyz + c0.zzz;\n"
             "    r2.xyz = pow(r2.xyz, c0.www);\n"
             "    r2.xyz = r2.xyz*c1.xxx;\n"
             "    r3.xyz = r1.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz - c1.zzz;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = r2.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=177e913d:55f303a1:e1f32632:f0623a5f\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000425\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.05499999970, 2.400000095);\n"
           "    const mediump vec4 c1 = vec4(0.8790000081, 0.07739999890, 0.04044999927, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r2.xyz = r1.xyz + c0.zzz;\n"
           "    r2.xyz = pow(r2.xyz, c0.www);\n"
           "    r2.xyz = r2.xyz*c1.xxx;\n"
           "    r3.xyz = r1.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz - c1.zzz;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = r2.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f39927a8:61485a10:77aa981d:cfbbc277\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004ee\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const half4 c1 = half4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=55a7b763:ef436294:d41e9d72:fef2dc04\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const float4 c1 = float4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=57b92c9c:5efdf1ca:047b5786:039d0b00\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000052b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
           "    const mediump vec4 c1 = vec4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz + c0.www;\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=8b50fb71:31f2eb5b:279044cd:79fc7ef6\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_srgb_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004ee\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const half4 c1 = half4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=55a7b763:ef436294:d41e9d72:fef2dc04\n"
             "//SIG=00400000:00000001:00000001:00000001:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
             "    const float4 c1 = float4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz*r0.xyz;\n"
             "    r2.xyz = fmin(r2.xyz, c0.zzz);\n"
             "    r2.xyz = r2.xyz + c0.www;\n"
             "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
             "    r2.xyz = r2.xyz*c1.yyy;\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r3.xyz = r1.xyz*c1.zzz;\n"
             "    r1.xyz = r1.xyz - c1.www;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = select(r2.xyz, -r2.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=57b92c9c:5efdf1ca:047b5786:039d0b00\n"
             "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000522\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.7500000000, -1.000000000, 1.250000000, 0.05499999970);\n"
           "    const highp vec4 c1 = vec4(2.400000095, 0.8790000081, 0.07739999890, 0.04044999927);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r2.xyz = r1.xyz*r0.xyz;\n"
           "    r2.xyz = min(r2.xyz, c0.zzz);\n"
           "    r2.xyz = r2.xyz + c0.www;\n"
           "    r2.xyz = pow(r2.xyz, c1.xxx);\n"
           "    r2.xyz = r2.xyz*c1.yyy;\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r3.xyz = r1.xyz*c1.zzz;\n"
           "    r1.xyz = r1.xyz - c1.www;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r2.x : r2.x, r0.y < 0.00000 ? -r2.y : r2.y, r0.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9d48d462:3dda019d:3f5f5e4d:a4a4071a\n"
           "//SIG=00000000:00000001:00000001:00000000:0002:0000:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000032f\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=7dc0dfbc:c836a038:13cdd6d9:c60d7e3e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000324\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = sqrt(r1.xyz);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=bdfaf4f0:4a68472f:e4ce4c4c:69bdede1\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = sqrt(r1.xyz);\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=28efafef:fde41fd4:7dc2b893:64d224c6\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fd9779b0:d5481997:6b539481:f13c6247\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000341\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=248d6794:088dc7a4:fdccd0f2:7e6548ba\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002de\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=1b02cad7:918f5fdd:c7dcec0f:03dcbb10\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fd9779b0:d5481997:6b539481:f13c6247\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000341\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=248d6794:088dc7a4:fdccd0f2:7e6548ba\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002d9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=8351c2f2:f318a08e:679a221c:79c8467d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=fd9779b0:d5481997:6b539481:f13c6247\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000341\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=248d6794:088dc7a4:fdccd0f2:7e6548ba\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002e0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.5112500191, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3eda5271:afae211d:2169fd04:426d0611\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003c8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a8311cfb:0d23b169:af678cc5:257482af\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=199c1d45:cf63353c:dd5f426e:fd0991df\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003ca\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9608204f:1cc57ea4:ff41515d:d7512eef\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getquicktime_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003c8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a8311cfb:0d23b169:af678cc5:257482af\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=199c1d45:cf63353c:dd5f426e:fd0991df\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003c3\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.330000043, 0.5112500191);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=2c4024ce:67153cca:87b9a761:7ffe77da\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_fast_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000330\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=aa266737:ced8974d:678b2327:1590d25a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000325\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r0.xyz = r1.xyz*r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5c2db76f:f3872933:3b70ed57:2d3f143f\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r0.xyz = r1.xyz*r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=fdba60fd:9f8e713f:a1e88db5:b74ecef0\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_fixed_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd40d21d:dab71443:51d03ff0:e52c3982\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000340\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=527ccfe4:b046ff73:8804104e:07e80862\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002dd\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5ad6b64c:affe4652:e992c066:f99ad317\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_nice_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd40d21d:dab71443:51d03ff0:e52c3982\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000340\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=527ccfe4:b046ff73:8804104e:07e80862\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002d8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9e854b3b:85ccb2c9:213ad91f:b1d9d3f7\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_half_satProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd40d21d:dab71443:51d03ff0:e52c3982\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000340\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=527ccfe4:b046ff73:8804104e:07e80862\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002df\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 1.000000000, 1.955999970, 0.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = pow(r1.xyz, c0.zzz);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=7ec4e723:27ed6654:3da6727a:724fddba\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_halfProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003c7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=83c2463f:fa694f71:8ff44add:0192f495\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003bc\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=03b68525:edecc26f:4d549a48:c381d609\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003c9\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=bf273443:85988f7a:19b07f24:0301cc15\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Getinv_quicktime_niceProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003c7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / half4(fmax(r0.www, 6.10350e-05h), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=83c2463f:fa694f71:8ff44add:0192f495\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003bc\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = r0 / float4(fmax(r0.www, 1.00000e-06f), 1.);\n"
             "    r0.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = select(-c0.yyy, c0.yyy, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = pow(r1.xyz, c0.www);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    r0.xyz = r0.xyz*r0.www;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=03b68525:edecc26f:4d549a48:c381d609\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(-0.2500000000, -1.000000000, 1.149999976, 1.955999970);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = r0 / vec4(max(r0.www, 1.00000e-06), 1.);\n"
           "    r0.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? c0.y : -c0.y, r0.y < 0.00000 ? c0.y : -c0.y, r0.z < 0.00000 ? c0.y : -c0.y"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = pow(r1.xyz, c0.www);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    r0.xyz = r0.xyz*r0.www;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=86f46bb1:e801a3df:b0549fd7:b4cd404d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000030b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ecb5a4d8:6d113e3b:887319ce:2b54e8c9\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002f8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=717fe78e:89a0702a:b5e17bb3:7157bcda\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=e2288d14:dc4b95f4:fcf12f2e:579df0f1\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000030b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ecb5a4d8:6d113e3b:887319ce:2b54e8c9\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002f8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=717fe78e:89a0702a:b5e17bb3:7157bcda\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=e2288d14:dc4b95f4:fcf12f2e:579df0f1\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000039c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r0.xyz = clamp(r1.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c9ce60be:37897859:81914f65:4df56f2a\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000374\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.xxx);\n"
             "    r1.xyz = fmin(r1.xyz, c0.yyy);\n"
             "    r1.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r0.xyz = clamp(r1.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dc32e146:6db579ac:9035a6cb:ec835062\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000034f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 1.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.xxx);\n"
           "    r1.xyz = min(r1.xyz, c0.yyy);\n"
           "    r1.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r0.xyz = clamp(r1.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c8823dc8:62aa0672:c3a00abc:4de48ee3\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000030b\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=ecb5a4d8:6d113e3b:887319ce:2b54e8c9\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002f8\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.yyy);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=717fe78e:89a0702a:b5e17bb3:7157bcda\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002c6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.yyy);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=011ce114:9bbfbc57:d68136d7:ba86e401\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000361\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bd6cb7db:0b59aed5:92893bd5:f825a780\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0d0f87f:883a4f14:52f52ed2:8913ba88\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000038b\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=b01d9920:fa7ac92f:4716ea80:29eb1b7c\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000361\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bd6cb7db:0b59aed5:92893bd5:f825a780\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0d0f87f:883a4f14:52f52ed2:8913ba88\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000382\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=d984d409:03d5ce14:47226e6c:ea97b670\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype0_float_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000361\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000h);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bd6cb7db:0b59aed5:92893bd5:f825a780\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000034e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = select(c0.www, -c0.www, r0.xyz < 0.00000f);\n"
             "    r1.xyz = r1.xyz*r0.xyz;\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r0.xyz = select(r1.xyz, -r1.xyz, r0.xyz < 0.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0d0f87f:883a4f14:52f52ed2:8913ba88\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000382\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = vec3(r0.x < 0.00000 ? -c0.w : c0.w, r0.y < 0.00000 ? -c0.w : c0.w, r0.z < 0.00000 ? -c0.w : c0.w"
           ");\n"
           "    r1.xyz = r1.xyz*r0.xyz;\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r0.xyz = vec3(r0.x < 0.00000 ? -r1.x : r1.x, r0.y < 0.00000 ? -r1.y : r1.y, r0.z < 0.00000 ? -r1.z : r1.z"
           ");\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=d984d409:03d5ce14:47226e6c:ea97b670\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0001:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000402\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9ff8c4d8:3d404847:33a9945a:e75086f8\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003da\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2870cdbc:eb23a8aa:8cdd93e8:994b02dc\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000418\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=48f9e48c:460bd827:86d7dbf2:fc50cc9c\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000402\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9ff8c4d8:3d404847:33a9945a:e75086f8\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003da\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2870cdbc:eb23a8aa:8cdd93e8:994b02dc\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000418\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=48f9e48c:460bd827:86d7dbf2:fc50cc9c\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000402\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9ff8c4d8:3d404847:33a9945a:e75086f8\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003da\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2870cdbc:eb23a8aa:8cdd93e8:994b02dc\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000040f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=a34d64de:9e3622d9:55b8e806:bc930502\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000402\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=9ff8c4d8:3d404847:33a9945a:e75086f8\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003da\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2870cdbc:eb23a8aa:8cdd93e8:994b02dc\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000041a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=77401a0b:de98840e:9e1bad14:0cab13ab\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=54b7fecc:600d8d5c:eacce70e:72781265\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003c1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=39ea7276:db4cd5bc:f0f9b1c5:f49422ee\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003f7\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3214c698:18a61d1f:775e57af:ef012fc7\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=54b7fecc:600d8d5c:eacce70e:72781265\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003c1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=39ea7276:db4cd5bc:f0f9b1c5:f49422ee\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003ec\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0303ed48:c8358667:5495ed57:fa121da3\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype1_float_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=54b7fecc:600d8d5c:eacce70e:72781265\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003c1\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=39ea7276:db4cd5bc:f0f9b1c5:f49422ee\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000003ec\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=0303ed48:c8358667:5495ed57:fa121da3\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b581bd41:54e6f9c8:e1ede332:875c59b4\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000041d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b4173fac:44680a48:870cd096:fdc9532d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000490\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3e2dbb18:684ec807:9d15a9eb:1614305e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b581bd41:54e6f9c8:e1ede332:875c59b4\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000041d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b4173fac:44680a48:870cd096:fdc9532d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000490\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=3e2dbb18:684ec807:9d15a9eb:1614305e\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b581bd41:54e6f9c8:e1ede332:875c59b4\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000041d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b4173fac:44680a48:870cd096:fdc9532d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000485\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9ce8dddd:3d077154:86cfe60a:39d7e855\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000044c\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b581bd41:54e6f9c8:e1ede332:875c59b4\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000041d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = c0.z;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.xxx);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b4173fac:44680a48:870cd096:fdc9532d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000492\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = c0.z;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, c0.xxx);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = clamp(r3.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=622d4d1a:a7f48af3:efe2021a:bb14221d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000418\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=60b986cb:2fee582f:7e05d15d:628c4b59\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=521478db:3e1f61f9:f01db1b9:77e3589d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000044a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=541b9209:5f74838a:ec435af4:b838fbe5\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000418\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=60b986cb:2fee582f:7e05d15d:628c4b59\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=521478db:3e1f61f9:f01db1b9:77e3589d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000043d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=01b3d752:40bcd325:f774cf1d:a16e8652\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype2_float_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000418\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=60b986cb:2fee582f:7e05d15d:628c4b59\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003e9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xw = c0.zx;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r3.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r3.xyz = pow(r3.xyz, hg_Params[0].xxx);\n"
             "    r3.xyz = r3.xyz*hg_Params[0].www;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r3.xyz = select(r3.xyz, r1.xxx, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=521478db:3e1f61f9:f01db1b9:77e3589d\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000043d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xw = c0.zx;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r3.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r3.xyz = pow(r3.xyz, hg_ProgramLocal0.xxx);\n"
           "    r3.xyz = r3.xyz*hg_ProgramLocal0.www;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r3.xyz = vec3(r2.x < 0.00000 ? r1.x : r3.x, r2.y < 0.00000 ? r1.x : r3.y, r2.z < 0.00000 ? r1.x : r3.z);\n"
           "    r0.xyz = r3.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=01b3d752:40bcd325:f774cf1d:a16e8652\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000041e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=56118e12:e38b95a3:d687869e:291134db\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab45c72e:2f5e0967:e1912c31:64a08ba6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000431\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f238f58b:9bad5cb9:febff045:ccc83075\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000041e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=56118e12:e38b95a3:d687869e:291134db\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab45c72e:2f5e0967:e1912c31:64a08ba6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000431\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=f238f58b:9bad5cb9:febff045:ccc83075\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000041e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=56118e12:e38b95a3:d687869e:291134db\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab45c72e:2f5e0967:e1912c31:64a08ba6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000428\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=bf6b9381:6a7e9595:993d8c0c:939fa7d9\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000041e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + half3(hg_Params[0].yyy);\n"
             "    r2.xyz = pow(r2.xyz, half3(hg_Params[0].xxx));\n"
             "    r2.xyz = r2.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r1.xyz*half3(hg_Params[1].xxx);\n"
             "    r1.xyz = r1.xyz - half3(hg_Params[1].yyy);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=56118e12:e38b95a3:d687869e:291134db\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003ef\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.xxx);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=ab45c72e:2f5e0967:e1912c31:64a08ba6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000433\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.xxx);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=1b1522ad:d240fa36:56c2b10c:5af9114d\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000414\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c020226d:07c2fa1c:0f843aa7:96573d96\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b9b7eb5d:231d6b87:b0cbc1f3:077ea789\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000041f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=5bc35c6f:5f483a78:e4ac0130:5872675f\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_nice_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000414\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c020226d:07c2fa1c:0f843aa7:96573d96\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b9b7eb5d:231d6b87:b0cbc1f3:077ea789\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000414\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=e30a931e:9daacbf9:a2d71229:2a8b9bfa\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype3_float_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000414\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[0].xxx));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].www);\n"
             "    r3.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c020226d:07c2fa1c:0f843aa7:96573d96\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003e5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.x;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=b9b7eb5d:231d6b87:b0cbc1f3:077ea789\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000414\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = c0.x;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=e30a931e:9daacbf9:a2d71229:2a8b9bfa\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_fast_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e60093f7:17e4e59c:044c6dd4:0dd6e9ce\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000445\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=10153cf1:e229017a:404233ac:ad355c06\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004c0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c92b533d:2946e6ca:1ffa015a:10d26966\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_fixed_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e60093f7:17e4e59c:044c6dd4:0dd6e9ce\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000445\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=10153cf1:e229017a:404233ac:ad355c06\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004c0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp lowp   \n"
           "uniform lowp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying mediump vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=c92b533d:2946e6ca:1ffa015a:10d26966\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_nice_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e60093f7:17e4e59c:044c6dd4:0dd6e9ce\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000445\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=10153cf1:e229017a:404233ac:ad355c06\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004b5\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp highp  \n"
           "uniform highp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=aef7f055:834bb867:7b1b3ff8:8e3614e9\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_half_sat_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004bd\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, c0.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = clamp(r3.xyz, 0.00000h, 1.00000h);\n"
             "    r0.xyz = clamp(r0.xyz + half3(hg_Params[2].xxx), 0.00000h, 1.00000h);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e60093f7:17e4e59c:044c6dd4:0dd6e9ce\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000445\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r1.xyz = fmin(r1.xyz, c0.www);\n"
             "    r2.xyz = r1.xyz + hg_Params[0].yyy;\n"
             "    r2.xyz = pow(r2.xyz, hg_Params[0].xxx);\n"
             "    r2.xyz = r2.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r1.xyz*hg_Params[1].xxx;\n"
             "    r1.xyz = r1.xyz - hg_Params[1].yyy;\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, r1.xyz < 0.00000f);\n"
             "    r0.xyz = clamp(r2.xyz, 0.00000f, 1.00000f);\n"
             "    r0.xyz = clamp(r0.xyz + hg_Params[2].xxx, 0.00000f, 1.00000f);\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=10153cf1:e229017a:404233ac:ad355c06\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004c2\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = max(r0.xyz, c0.zzz);\n"
           "    r1.xyz = min(r1.xyz, c0.www);\n"
           "    r2.xyz = r1.xyz + hg_ProgramLocal0.yyy;\n"
           "    r2.xyz = pow(r2.xyz, hg_ProgramLocal0.xxx);\n"
           "    r2.xyz = r2.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r1.xyz*hg_ProgramLocal1.xxx;\n"
           "    r1.xyz = r1.xyz - hg_ProgramLocal1.yyy;\n"
           "    r2.xyz = vec3(r1.x < 0.00000 ? r3.x : r2.x, r1.y < 0.00000 ? r3.y : r2.y, r1.z < 0.00000 ? r3.z : r2.z);\n"
           "    r0.xyz = clamp(r2.xyz, vec3(0.00000), vec3(1.00000));\n"
           "    r0.xyz = clamp(r0.xyz + hg_ProgramLocal2.xxx, vec3(0.00000), vec3(1.00000));\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=9a3b51bd:4960a7f2:6719ad26:91d186ea\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

const char *Gettype4_half_unpremultProgram(HGRenderer *a1)
{
  unsigned int Target = HGRenderer::GetTarget(a1, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000487\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    half4 r0, r1, r2, r3, r4;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xy = half2(hg_Params[1].xy);\n"
             "    r1.zw = c0.zw;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r2.www);\n"
             "    r3.xyz = r2.xyz + half3(hg_Params[0].yyy);\n"
             "    r3.xyz = pow(r3.xyz, half3(hg_Params[0].xxx));\n"
             "    r3.xyz = r3.xyz*half3(hg_Params[0].www) + half3(hg_Params[0].zzz);\n"
             "    r4.xyz = r2.xyz*half3(hg_Params[1].xxx);\n"
             "    r2.xyz = r2.xyz - half3(hg_Params[1].yyy);\n"
             "    r3.xyz = select(r3.xyz, r4.xyz, r2.xyz < 0.00000h);\n"
             "    r0.xyz = r3.xyz;\n"
             "    r0.xyz = r0.xyz + half3(hg_Params[2].xxx);\n"
             "    output.color0 = float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=62c5fdab:7fc3593f:783cebb6:5506e6ba\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0003:0005:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000420\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.w = c0.w;\n"
             "    r2.xyz = fmax(r0.xyz, c0.zzz);\n"
             "    r2.xyz = fmin(r2.xyz, r1.www);\n"
             "    r1.xyz = r2.xyz + hg_Params[0].yyy;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].www + hg_Params[0].zzz;\n"
             "    r3.xyz = r2.xyz*hg_Params[1].xxx;\n"
             "    r2.xyz = r2.xyz - hg_Params[1].yyy;\n"
             "    r1.xyz = select(r1.xyz, r3.xyz, r2.xyz < 0.00000f);\n"
             "    r0.xyz = r1.xyz;\n"
             "    r0.xyz = r0.xyz + hg_Params[2].xxx;\n"
             "    output.color0 = r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=95965de2:ec2450ed:740ba24d:a0be43a6\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a1 + 128))(a1, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000489\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 2.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.w = c0.w;\n"
           "    r2.xyz = max(r0.xyz, c0.zzz);\n"
           "    r2.xyz = min(r2.xyz, r1.www);\n"
           "    r1.xyz = r2.xyz + hg_ProgramLocal0.yyy;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal0.xxx);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.www + hg_ProgramLocal0.zzz;\n"
           "    r3.xyz = r2.xyz*hg_ProgramLocal1.xxx;\n"
           "    r2.xyz = r2.xyz - hg_ProgramLocal1.yyy;\n"
           "    r1.xyz = vec3(r2.x < 0.00000 ? r3.x : r1.x, r2.y < 0.00000 ? r3.y : r1.y, r2.z < 0.00000 ? r3.z : r1.z);\n"
           "    r0.xyz = r1.xyz;\n"
           "    r0.xyz = r0.xyz + hg_ProgramLocal2.xxx;\n"
           "    gl_FragColor = r0;\n"
           "}\n"
           "//MD5=baa41f52:35394ac5:31a0fd40:ee61628f\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0003:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}