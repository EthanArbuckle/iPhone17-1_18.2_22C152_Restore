@interface HMMTRAccessoryServer
+ (BOOL)certificateSubjectHasCATs:(id)a3;
+ (id)logCategory;
+ (id)shortDescription;
- (BOOL)_controllerIsOnWiFiNetworkWhichSupportsBothBands;
- (BOOL)_delegateRespondsToSelector:(SEL)a3;
- (BOOL)_handleUnmappedAttributeReport:(id)a3;
- (BOOL)_ignoreAttributeReport:(id)a3;
- (BOOL)_isBridgedBasicInformation:(id)a3 reportClusterID:(id)a4;
- (BOOL)_pairingInProgressForMatterSupportFallback;
- (BOOL)_populateCommissioningParameterCountryCode:(id)a3;
- (BOOL)_shouldUpdateUnreachableState;
- (BOOL)accessoryLinkLayerTypeIsWifiOrEthernet;
- (BOOL)bleScanPending;
- (BOOL)blockInvalidation;
- (BOOL)commissioneeHasActiveNetwork;
- (BOOL)commissioningCompleted;
- (BOOL)commissioningSessionEstablished;
- (BOOL)controllerRevokeHandlerRegistered;
- (BOOL)defaultThreadOperationalDatasetRetrieved;
- (BOOL)deferStartThreadForPairing;
- (BOOL)delayDiscovery;
- (BOOL)discoveredOverBLE;
- (BOOL)discriminatorIsOriginatedFromShort;
- (BOOL)doesMatchDiscriminator:(id)a3;
- (BOOL)doesPeriodicSessionChecks;
- (BOOL)fullServiceEnumerationPendingCachePrimedEvent;
- (BOOL)hasNetworkProvisioningFailed:(unsigned int)a3;
- (BOOL)hasPreferredLocalLink;
- (BOOL)hasPriorSuccessfulPairing;
- (BOOL)isCertified;
- (BOOL)isDisabled;
- (BOOL)isEqual:(id)a3;
- (BOOL)isPaired;
- (BOOL)isPairedInStorage;
- (BOOL)isPairingInProgress;
- (BOOL)isReadyToReadFromMTRDevice;
- (BOOL)isStaged;
- (BOOL)isWEDDevice;
- (BOOL)knownToSystemCommissioner;
- (BOOL)locallyDiscovered;
- (BOOL)matchesSetupID:(id)a3;
- (BOOL)matchesSetupID:(id)a3 serverIdentifier:(id)a4;
- (BOOL)mtrDeviceConnected;
- (BOOL)mtrDeviceStateReported;
- (BOOL)operationDisabled;
- (BOOL)pairingUsingMatterSupport;
- (BOOL)pingSupported;
- (BOOL)removalInProgress;
- (BOOL)removePairingForCurrentControllerOnQueue:(id)a3 completion:(id)a4;
- (BOOL)requiresThreadRouter;
- (BOOL)serviceEnumerationFailed;
- (BOOL)serviceEnumerationInProgress;
- (BOOL)servicesEnumerated;
- (BOOL)shouldPairWithoutResident;
- (BOOL)stageNetworkScanRequested;
- (BOOL)stopPairingWithError:(id *)a3;
- (BOOL)storageUpdatePending;
- (BOOL)tryPairingPassword:(id)a3 onboardingSetupPayloadString:(id)a4 error:(id *)a5;
- (BOOL)updateProductAttributes;
- (HAPAccessory)primaryAccessory;
- (HMFActivity)activity;
- (HMFFuture)doorLockClusterFuture;
- (HMFTimer)pairingTimer;
- (HMFTimer)residentReachabilityUpdateWaitTimer;
- (HMFTimer)stateCaptureConfigChangeTimer;
- (HMFTimer)stateCaptureDeviceConnectedTimer;
- (HMMTRAccessoryPairingEndContext)pairingEndContextWhenRemove;
- (HMMTRAccessoryReachabilityManager)reachabilityManager;
- (HMMTRAccessoryServer)initWithKeystore:(id)a3 browser:(id)a4;
- (HMMTRAccessoryServerBrowser)browser;
- (HMMTRAccessoryServerDelegate)chipDelegate;
- (HMMTRAccessoryServerDiagnosticsEventDelegate)diagnosticsEventDelegate;
- (HMMTRAttributeReportDistributor)reportDistributor;
- (HMMTRControllerWrapper)controllerWrapper;
- (HMMTRDuration)maxMetricDuration;
- (HMMTRFabric)pairingTargetFabric;
- (HMMTRFirmwareUpdateStatus)matterFirmwareUpdateStatus;
- (HMMTRHAPEnumerator)hapEnumerator;
- (HMMTRHMDHAPAccessoryDelegate)hmdHAPAccessoryDelegate;
- (HMMTRMetricBundle)currentMetricBundle;
- (HMMTROTAAnnounceTimer)otaAnnounceTimer;
- (HMMTROTAApplyUpdateRequestTimer)otaApplyUpdateRequestTimer;
- (HMMTROTAApplyUpdateTimer)otaUpdateTimer;
- (HMMTRPairing)currentPairing;
- (HMMTRPairing)currentPairingInfo;
- (HMMTRStorage)storage;
- (HMMTRSyncClusterDoorLock)doorLockCluster;
- (MTRDevice)matterDevice;
- (MTRDeviceController)deviceController;
- (NSArray)commissioneeNetworks;
- (NSArray)lastPendingFabricLabel;
- (NSData)defaultThreadOperationalDataset;
- (NSData)originalPairingAttemptOperationalCert;
- (NSData)originalPairingAttemptRootCert;
- (NSData)otaUpdateToken;
- (NSData)rootPublicKey;
- (NSData)topology;
- (NSError)commissioningFailureOverridingError;
- (NSError)lastFabricLabelUpdateError;
- (NSError)removeReason;
- (NSFileHandle)otaFileHandle;
- (NSMutableArray)serviceEnumerationFromDeviceCompletionHandlers;
- (NSMutableDictionary)attributeTimers;
- (NSMutableDictionary)characteristicProtocolMappingStates;
- (NSMutableDictionary)clusterIDCharacteristicMap;
- (NSMutableDictionary)pairingDurationDictionary;
- (NSMutableDictionary)pendingMTRDeviceReadReadyHandlers;
- (NSNumber)bridgedAccessoryReachabilityReaderTimeoutNSecs;
- (NSNumber)commissioneeNetworkCommissioningClusterEndpoint;
- (NSNumber)discriminator;
- (NSNumber)fabricID;
- (NSNumber)nodeID;
- (NSNumber)objectID;
- (NSNumber)otaFileOffset;
- (NSNumber)productID;
- (NSNumber)setUpPINCode;
- (NSNumber)softwareVersionNumber;
- (NSNumber)supportedLinkLayerTypes;
- (NSNumber)vendorID;
- (NSString)deviceConnectedStateCaptureInformation;
- (NSString)eMACAddress;
- (NSString)onboardingSetupPayloadString;
- (NSString)partsListStateCaptureInformation;
- (NSString)productNameFromDcl;
- (NSString)setupPayloadString;
- (NSString)softwareVersionString;
- (NSString)vendorNameFromDcl;
- (NSUUID)commissioningID;
- (NSUUID)initialMTRDeviceStateTimeoutId;
- (NSUUID)pairingTargetHomeUUID;
- (id)_categoryFromAccessoryInfo:(id)a3 endpoint:(id)a4;
- (id)_categoryFromTopology:(id)a3 endpoint:(id)a4;
- (id)_convertFetchedCredentials:(id)a3;
- (id)_distinctEndpointsHavingHapServicesForTopology:(id)a3;
- (id)_endCurrentMetricTimeWithName:(id)a3;
- (id)_getFirstNonOtherCategory:(id)a3;
- (id)_getOperationalHardwareAddressFromReadValue:(id)a3;
- (id)_getOperationalNetworkAddressForAccessory:(id)a3;
- (id)_getSupportedLinkLayerTypesForAccessory:(id)a3;
- (id)_hapAccessoryAtEndpoint:(id)a3;
- (id)_matterCredentialsFromTHCredentials:(id)a3;
- (id)_pairingSetupPayload;
- (id)_populateHandlingForCharacteristics:(id)a3;
- (id)_processEvent:(id)a3;
- (id)_progressStateToString:(int64_t)a3;
- (id)_readFixedCharacteristicValue:(id)a3;
- (id)_readLocallyMaintainedCharacteristicValue:(id)a3;
- (id)_readPastEventsFromAccessory:(id)a3 forClusters:(id)a4;
- (id)accessoryProductID;
- (id)accessoryVendorID;
- (id)attributeDescriptions;
- (id)chipReportHandler;
- (id)collectDiagnosticsForAccessory:(id)a3;
- (id)connectedNetworkIDFromReadValue:(id)a3;
- (id)createDoorLockClusterObjectWithFlow:(id)a3;
- (id)currentWiFiNetworkInfo;
- (id)dataOfReadValue:(id)a3;
- (id)defaultThreadOperationalDatasetReceiveBlock;
- (id)descriptorClusterManager;
- (id)deviceID;
- (id)deviceTopology;
- (id)dumpState:(id)a3;
- (id)endPointForHapAccessory:(id)a3;
- (id)endpointForDiagnosticCluster:(id)a3 clusterName:(id)a4 amongEndpoints:(id)a5 topology:(id)a6 device:(id)a7 definitelyUnsupported:(BOOL *)a8;
- (id)endpointsForHAPAccessory:(id)a3 topology:(id)a4;
- (id)errorCountOfThreadNetworkDiagnostics:(id)a3;
- (id)errorCountOfWiFiNetworkDiagnostics:(id)a3;
- (id)generalDiagnosticsClusterFromEndpoints:(id)a3 topology:(id)a4 device:(id)a5 definitelyUnsupported:(BOOL *)a6;
- (id)getConnectNetworkIDForAccessory:(id)a3;
- (id)getOperationalNetworkAddressForAccessory:(id)a3;
- (id)getSupportedLinkLayerTypesForAccessory:(id)a3;
- (id)getSupportedLinkLayerTypesFromNetworkCommissioningClusterFeatureMap:(id)a3;
- (id)getThreadNetworkLinkQualityForAccessory:(id)a3;
- (id)getWiFiNetworkLinkQualityForAccessory:(id)a3;
- (id)highestRSSIofThreadNetworkDiagnostics:(id)a3;
- (id)logIdentifier;
- (id)mergeExistingAclEntries:(id)a3 withAdminNodes:(id)a4 regularUserNodes:(id)a5;
- (id)mergeExistingAclEntries:(id)a3 withNewNodes:(id)a4 withPrivilege:(unsigned __int8)a5;
- (id)mtrDeviceWithNodeID:(id)a3 controller:(id)a4;
- (id)networkCommissioningClusterFromEndpoints:(id)a3 topology:(id)a4 device:(id)a5 definitelyUnsupported:(BOOL *)a6;
- (id)numberOfReadValue:(id)a3;
- (id)packetCountOfThreadNetworkDiagnostics:(id)a3;
- (id)packetCountOfWiFiNetworkDiagnostics:(id)a3;
- (id)populateACLEntriesAfterPairing;
- (id)populateACLEntriesForPairing;
- (id)privateDescription;
- (id)protocolMappingStateForCharacteristic:(id)a3;
- (id)reachabilityChangedReason;
- (id)readPastDiagnosticEventsFromAccessory:(id)a3 fromEventNumber:(id)a4;
- (id)removeNode:(id)a3 withPrivilge:(unsigned __int8)a4 fromExistingAclEntries:(id)a5;
- (id)stageCompletion;
- (id)stageDeviceCredentialHandler;
- (id)stageProgressUpdateHandler;
- (id)stageThreadScanResultsHandler;
- (id)stageWiFiScanResultsHandler;
- (id)stringOfReadValue:(id)a3;
- (id)threadNetworkDiagnosticsClusterFromEndpoints:(id)a3 topology:(id)a4 device:(id)a5 definitelyUnsupported:(BOOL *)a6;
- (id)wifiNetworkDiagnosticsClusterFromEndpoints:(id)a3 topology:(id)a4 device:(id)a5 definitelyUnsupported:(BOOL *)a6;
- (id)wifiNetworkInfoForSSID:(id)a3;
- (int64_t)_getLinkLayerTypeForAccessory:(id)a3;
- (int64_t)communicationProtocol;
- (int64_t)getLinkLayerTypeForAccessory:(id)a3;
- (int64_t)linkLayerType;
- (int64_t)linkType;
- (int64_t)pairedState;
- (os_state_data_s)createStateData:(id)a3 data:(id)a4;
- (unint64_t)_registerStateCaptureHandlerWithStateCaptureInformation:(id)a3;
- (unint64_t)deviceConnectedStateHandle;
- (unint64_t)hash;
- (unint64_t)numActiveSessionClients;
- (unint64_t)operationDisabledReason;
- (unint64_t)pairingProgress;
- (unint64_t)partsListStateCaptureHandle;
- (unint64_t)sessionCheckInterval;
- (unsigned)networkProvisioningFailures;
- (void)_buildHAPCategoriesFromCHIPWithCompletionHandler:(id)a3;
- (void)_clearCommissioneeInfoAfterPairingCompletion;
- (void)_collectNetworkCredentials:(id)a3;
- (void)_commissionWithParams:(id)a3;
- (void)_continueNetworkProvisioning;
- (void)_controller:(id)a3 commissioningComplete:(id)a4 nodeID:(id)a5 abstractMetrics:(id)a6;
- (void)_createFirmwareUpdateServiceWithInstanceID:(int64_t)a3 device:(id)a4 completionHandler:(id)a5;
- (void)_deleteAccessoryServerData;
- (void)_deregisterDeviceConnectedStateCaptureHandler;
- (void)_deregisterPartsListStateCaptureHandler;
- (void)_deregisterStateCaptureHandlerWithHandle:(unint64_t)a3;
- (void)_deregisterStateCaptureHandlers;
- (void)_deviceInternalStateChanged:(id)a3;
- (void)_disconnectWithError:(id)a3;
- (void)_endpointForOTARequestorWithTopology:(id)a3 mtrDevice:(id)a4 callbackQueue:(id)a5 completionHandler:(id)a6;
- (void)_fetchAdditionalThreadNetworkInformationFromDevice:(id)a3 completion:(id)a4;
- (void)_fetchAdditionalThreadNetworkInformationWithCompletion:(id)a3;
- (void)_fetchCurrentPairingWithCompletionHandler:(id)a3;
- (void)_fetchSerialNumberWithCompletionHandler:(id)a3;
- (void)_finalizePairing;
- (void)_findSystemCommissionerPairingMatchingSetupPayload:(id)a3 systemCommissionerPairings:(id)a4 pairingManager:(id)a5;
- (void)_finishMaximumDurationCollection;
- (void)_flushMTRDeviceReadReadyHandlers;
- (void)_getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster:(id)a3 completion:(id)a4;
- (void)_getCommissioneeNetworkCommissioningClusterEndpointWithDevice:(id)a3 completion:(id)a4;
- (void)_handleAddNocCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)a3 fabricID:(id)a4 rootCACert:(id)a5 ipk:(id)a6 controllerNodeID:(id)a7 commissioneeNodeID:(id)a8 error:(id)a9;
- (void)_handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)a3 fabricID:(id)a4 rootCACert:(id)a5 operationalPublicKey:(__SecKey *)a6 ipk:(id)a7 controllerNodeID:(id)a8;
- (void)_handleArmFailSafeResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)a3 error:(id)a4;
- (void)_handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)a3 responseParams:(id)a4 error:(id)a5;
- (void)_handleDiagnosticsEvent:(id)a3;
- (void)_handleNewSystemCommissionerFabricNodeID:(id)a3 dispatchGroup:(id)a4 fabricID:(id)a5 rootCACert:(id)a6 operationalPublicKey:(__SecKey *)a7 ipk:(id)a8 controllerNodeID:(id)a9 device:(id)a10;
- (void)_handlePairingFailureWithError:(id)a3 context:(id)a4;
- (void)_handleSystemCommissionerRootCertificate:(id)a3 fabricID:(id)a4 ipk:(id)a5 controllerNodeID:(id)a6 dispatchGroup:(id)a7 csrResponseParams:(id)a8 device:(id)a9;
- (void)_handleThreadRadioStateChanged;
- (void)_handleUnreachableStateWithError:(id)a3;
- (void)_initAccessoriesForServer;
- (void)_metricCollectionWithError:(id)a3 description:(id)a4 progressState:(int64_t)a5;
- (void)_notifyDelegateOfMTRMetrics:(id)a3;
- (void)_notifyDelegateOfPairingProgress:(int64_t)a3;
- (void)_notifyDelegateOfPairingProgress:(int64_t)a3 error:(id)a4;
- (void)_notifyDelegateOfPairingStep:(unint64_t)a3;
- (void)_onNetworkScanResults:(id)a3;
- (void)_onThreadScanResults:(id)a3;
- (void)_onUnpairFinishedWithError:(id)a3 queue:(id)a4 completion:(id)a5;
- (void)_onWiFiScanResults:(id)a3;
- (void)_openPairingWindowForDuration:(double)a3 completionHandler:(id)a4;
- (void)_openPairingWindowWithPINForDuration:(double)a3 completionHandler:(id)a4;
- (void)_pairOnSystemCommissionerFabric;
- (void)_pairOnSystemCommissionerFabricUnlessAlreadyPairedWithRootPublicKey:(id)a3;
- (void)_pairingComplete:(id)a3 context:(id)a4;
- (void)_persistAccessoryServerData;
- (void)_populateServiceForCharacteristic:(id)a3;
- (void)_populateThreadCredentials:(id)a3 completion:(id)a4;
- (void)_populateWifiCredentials:(id)a3 scanResults:(id)a4 completion:(id)a5;
- (void)_prepareThreadCredentials;
- (void)_queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic:(id)a3 completion:(id)a4;
- (void)_readCharacteristicValueFromCacheAfterConfirmingBridgedAccessroyReachabilityWithCharacteristic:(id)a3 responseHandler:(id)a4;
- (void)_readCharacteristicValueFromCacheWithCharacteristic:(id)a3 responseHandler:(id)a4;
- (void)_readCharacteristicValues:(id)a3 timeout:(double)a4 skipCache:(BOOL)a5 sendNotification:(BOOL)a6 completionQueue:(id)a7 completionHandler:(id)a8;
- (void)_rebuildHAPServicesFromCHIPWithCompletionHandler:(id)a3;
- (void)_removeSharedAdminControllerNodeIDFromACLWithCompletion:(id)a3;
- (void)_reportPairingComplete;
- (void)_requestAccessoryNetworkScanWithCompletionHandler:(id)a3;
- (void)_restoreCommissioneeInfoBeforeNextPairingAttempt;
- (void)_retryPairing;
- (void)_returnMatterSupportPairingAsStagedPairing;
- (void)_setCategoryForPrimaryAccessory:(id)a3;
- (void)_setSupportedLinkLayerTypes:(id)a3;
- (void)_setupMatterDevice;
- (void)_setupPairingProperties;
- (void)_startCurrentMetricTimeWithName:(id)a3;
- (void)_startInitialReachableStateTimerWithCompletion:(id)a3;
- (void)_startLocallyDiscoveredAccessoryServerPairingWithRequest:(id)a3 fabricID:(id)a4;
- (void)_startPairingWithError:(id *)a3 pairingEndContext:(id *)a4;
- (void)_startPairingWithReadyToCancelHandler:(id)a3 error:(id *)a4 pairingEndContext:(id *)a5;
- (void)_tryPairingUsingMatterSupport;
- (void)_tryPairingWithOnboardingPayload:(id)a3 systemCommissionerPairings:(id)a4 pairingManager:(id)a5;
- (void)_unpair:(id)a3 completion:(id)a4;
- (void)_updateAdditionalCharacteristicsFromCharacteristicUpdate:(id)a3 service:(id)a4 path:(id)a5 completionHandler:(id)a6;
- (void)_updateAttributeTimer:(id)a3 report:(id)a4 timeout:(double)a5 server:(id)a6;
- (void)_updateDefaultEntriesForBridgedClusterIDCharacteristicMap:(id)a3;
- (void)_updateDefaultEntriesForClusterIDCharacteristicMap:(id)a3;
- (void)_updateDelegateOfConnectionStatus:(BOOL)a3 withError:(id)a4;
- (void)_updateMetricWithProgressState:(int64_t)a3 error:(id)a4;
- (void)_updateMetrics;
- (void)_updatedCharacteristicsForAttributeReport:(id)a3 completionHandler:(id)a4;
- (void)_updatedCharacteristicsForEventReport:(id)a3 completionHandler:(id)a4;
- (void)_writeCharacteristicValues:(id)a3 responseTuples:(id)a4 completionQueue:(id)a5 completionHandler:(id)a6;
- (void)abortStagingWithError:(id)a3 context:(id)a4;
- (void)addMetricsWithDuration:(id)a3 metricsKey:(id)a4;
- (void)addPairing:(id)a3 completionQueue:(id)a4 completionHandler:(id)a5;
- (void)announceOtaProvider:(id)a3 providerEndpoint:(id)a4 immediateAnnouncement:(BOOL)a5 completionHandler:(id)a6;
- (void)commitStagedPairing;
- (void)controller:(id)a3 commissioningSessionEstablishmentDone:(id)a4;
- (void)dealloc;
- (void)device:(id)a3 receivedAttributeReport:(id)a4;
- (void)device:(id)a3 receivedEventReport:(id)a4;
- (void)device:(id)a3 stateChanged:(unint64_t)a4;
- (void)deviceCachePrimed:(id)a3;
- (void)deviceConfigurationChanged:(id)a3;
- (void)didUpdateReachability:(BOOL)a3;
- (void)disable;
- (void)disconnect;
- (void)disconnectWithError:(id)a3;
- (void)discoverAccessories;
- (void)dispatchAfter:(unint64_t)a3 block:(id)a4;
- (void)dispatchBlock:(id)a3;
- (void)enableEvents:(BOOL)a3 forCharacteristics:(id)a4 withCompletionHandler:(id)a5 queue:(id)a6;
- (void)enumerateHAPServices:(id)a3;
- (void)fetchAndNotifyCharacteristics:(id)a3 timeout:(double)a4 completionQueue:(id)a5 completionHandler:(id)a6;
- (void)fetchColorControlClusterForHapAccessory:(id)a3 completionHandler:(id)a4;
- (void)fetchExtendedMACAddressFromDevice:(id)a3 completion:(id)a4;
- (void)fetchPairingsWithCompletionHandler:(id)a3;
- (void)fetchSoftwareVersion:(BOOL)a3 completionHandler:(id)a4;
- (void)fetchWEDSupportInformationFromDevice:(id)a3 completion:(id)a4;
- (void)findSystemCommissionerPairingMatchingSetupPayload:(id)a3 systemCommissionerPairings:(id)a4 pairingManager:(id)a5;
- (void)finishPairing;
- (void)generateStateCaptureInformationForReason:(id)a3 completionHandler:(id)a4;
- (void)handleCHIPRemoteRequest:(id)a3 completion:(id)a4;
- (void)handleCHIPRemoteRequest:(id)a3 device:(id)a4 completion:(id)a5;
- (void)handleDownloadLogCommand:(id)a3 device:(id)a4 completion:(id)a5;
- (void)handleEventReportForNotification:(id)a3;
- (void)handleFirmwareUpdateStatusChange:(int64_t)a3;
- (void)handleThreadDirectConnectionSleepyTypeChange:(BOOL)a3;
- (void)handleThreadNetworkStateChangedNotification:(id)a3;
- (void)handleUpdatesForCharacteristics:(id)a3 stateNumber:(id)a4;
- (void)handleWEDDisconnectedWhileNotPairing;
- (void)identifyWithCompletion:(id)a3;
- (void)isDiscoverableWithCompletion:(id)a3;
- (void)listPairingsWithCompletionQueue:(id)a3 completionHandler:(id)a4;
- (void)notifyMatterFirmwareRevisionNumberCharacteristicChanged;
- (void)openPairingWindowForDuration:(double)a3 completionHandler:(id)a4;
- (void)openPairingWindowWithPINForDuration:(double)a3 completionHandler:(id)a4;
- (void)processAttributeReport:(id)a3;
- (void)queueAccessoryOperation:(id)a3 highPriority:(BOOL)a4 completion:(id)a5;
- (void)readCharacteristicValues:(id)a3 timeout:(double)a4 completionQueue:(id)a5 completionHandler:(id)a6;
- (void)readPairingWindowStatusWithCompletionHandler:(id)a3;
- (void)refreshThreadCapabilitiesWithCompletion:(id)a3;
- (void)removeAllPairingsWithCompletionHandler:(id)a3;
- (void)removePairing:(id)a3 completionHandler:(id)a4;
- (void)removePairing:(id)a3 completionQueue:(id)a4 completionHandler:(id)a5;
- (void)resetThreadNetworkDiagnosticsCountForAccessory:(id)a3;
- (void)resetWiFiNetworkDiagnosticsCountForAccessory:(id)a3;
- (void)setAttributeTimers:(id)a3;
- (void)setBleScanPending:(BOOL)a3;
- (void)setBlockInvalidation:(BOOL)a3;
- (void)setBridgedAccessoryReachabilityReaderTimeoutNSecs:(id)a3;
- (void)setBrowser:(id)a3;
- (void)setCertified:(BOOL)a3;
- (void)setChipDelegate:(id)a3;
- (void)setChipReportHandler:(id)a3;
- (void)setClusterIDCharacteristicMap:(id)a3;
- (void)setClusterIDForCharacteristic:(id)a3 endpointID:(id)a4 clusterID:(id)a5;
- (void)setCommissioneeHasActiveNetwork:(BOOL)a3;
- (void)setCommissioneeNetworkCommissioningClusterEndpoint:(id)a3;
- (void)setCommissioneeNetworks:(id)a3;
- (void)setCommissioningCompleted:(BOOL)a3;
- (void)setCommissioningFailureOverridingError:(id)a3;
- (void)setCommissioningID:(id)a3;
- (void)setCommissioningSessionEstablished:(BOOL)a3;
- (void)setControllerRevokeHandlerRegistered:(BOOL)a3;
- (void)setControllerWrapper:(id)a3;
- (void)setCurrentMetricBundle:(id)a3;
- (void)setCurrentPairingInfo:(id)a3;
- (void)setDefaultThreadOperationalDataset:(id)a3;
- (void)setDefaultThreadOperationalDatasetReceiveBlock:(id)a3;
- (void)setDefaultThreadOperationalDatasetRetrieved:(BOOL)a3;
- (void)setDeferStartThreadForPairing:(BOOL)a3;
- (void)setDelayDiscovery:(BOOL)a3;
- (void)setDescriptorClusterManager:(id)a3;
- (void)setDeviceConnectedStateCaptureInformation:(id)a3;
- (void)setDeviceConnectedStateHandle:(unint64_t)a3;
- (void)setDiagnosticsEventDelegate:(id)a3;
- (void)setDiscoveredOverBLE:(BOOL)a3;
- (void)setDiscriminator:(id)a3;
- (void)setDiscriminatorIsOriginatedFromShort:(BOOL)a3;
- (void)setDoorLockCluster:(id)a3;
- (void)setDoorLockClusterFuture:(id)a3;
- (void)setEMACAddress:(id)a3;
- (void)setFabricID:(id)a3;
- (void)setFullServiceEnumerationPendingCachePrimedEvent:(BOOL)a3;
- (void)setHasPriorSuccessfulPairing:(BOOL)a3;
- (void)setHmdHAPAccessoryDelegate:(id)a3;
- (void)setInitialMTRDeviceStateTimeoutId:(id)a3;
- (void)setKnownToSystemCommissioner:(BOOL)a3;
- (void)setLastFabricLabelUpdateError:(id)a3;
- (void)setLastPendingFabricLabel:(id)a3;
- (void)setLinkLayerType:(int64_t)a3;
- (void)setLocallyDiscovered:(BOOL)a3;
- (void)setMatterDevice:(id)a3;
- (void)setMatterFirmwareUpdateStatus:(id)a3;
- (void)setMaxMetricDuration:(id)a3;
- (void)setMtrDeviceConnected:(BOOL)a3;
- (void)setMtrDeviceStateReported:(BOOL)a3;
- (void)setNetworkProvisioningFailures:(unsigned int)a3;
- (void)setNodeID:(id)a3;
- (void)setOnboardingSetupPayloadString:(id)a3;
- (void)setOperationDisabled:(BOOL)a3;
- (void)setOperationDisabledReason:(unint64_t)a3;
- (void)setOriginalPairingAttemptOperationalCert:(id)a3;
- (void)setOriginalPairingAttemptRootCert:(id)a3;
- (void)setOtaAnnounceTimer:(id)a3;
- (void)setOtaApplyUpdateRequestTimer:(id)a3;
- (void)setOtaFileHandle:(id)a3;
- (void)setOtaFileOffset:(id)a3;
- (void)setOtaUpdateTimer:(id)a3;
- (void)setOtaUpdateToken:(id)a3;
- (void)setPairedState:(int64_t)a3;
- (void)setPairingDurationDictionary:(id)a3;
- (void)setPairingProgress:(unint64_t)a3;
- (void)setPairingTargetFabric:(id)a3;
- (void)setPairingTargetHomeUUID:(id)a3;
- (void)setPairingTimer:(id)a3;
- (void)setPairingUsingMatterSupport:(BOOL)a3;
- (void)setPartsListStateCaptureHandle:(unint64_t)a3;
- (void)setPartsListStateCaptureInformation:(id)a3;
- (void)setPrimaryAccessory:(id)a3;
- (void)setProductID:(id)a3;
- (void)setProductNameFromDcl:(id)a3;
- (void)setReachabilityManager:(id)a3;
- (void)setRemovalInProgress:(BOOL)a3;
- (void)setRemoveReason:(id)a3 pairingEndContextWhenRemove:(id)a4;
- (void)setRequiresThreadRouter:(BOOL)a3;
- (void)setResidentReachabilityUpdateWaitTimer:(id)a3;
- (void)setServiceEnumerationFailed:(BOOL)a3;
- (void)setServiceEnumerationInProgress:(BOOL)a3;
- (void)setServicesEnumerated:(BOOL)a3;
- (void)setSetUpPINCode:(id)a3;
- (void)setSetupPayloadString:(id)a3;
- (void)setShouldPairWithoutResident:(BOOL)a3;
- (void)setSoftwareVersionNumber:(id)a3;
- (void)setSoftwareVersionString:(id)a3;
- (void)setStageCompletion:(id)a3;
- (void)setStageDeviceCredentialHandler:(id)a3;
- (void)setStageNetworkScanRequested:(BOOL)a3;
- (void)setStageProgressUpdateHandler:(id)a3;
- (void)setStageThreadScanResultsHandler:(id)a3;
- (void)setStageWiFiScanResultsHandler:(id)a3;
- (void)setStateCaptureConfigChangeTimer:(id)a3;
- (void)setStateCaptureDeviceConnectedTimer:(id)a3;
- (void)setStorage:(id)a3;
- (void)setStorageUpdatePending:(BOOL)a3;
- (void)setSupportedLinkLayerTypes:(id)a3;
- (void)setTopology:(id)a3;
- (void)setVendorID:(id)a3;
- (void)setVendorNameFromDcl:(id)a3;
- (void)setWedDevice:(BOOL)a3;
- (void)setupReporting;
- (void)setupThreadPairing;
- (void)startPairingMetricWithActivity:(id)a3;
- (void)startPairingWithRequest:(id)a3;
- (void)startStagedPairingWithCompletion:(id)a3;
- (void)startStagedPairingWithDeviceCredentialHandler:(id)a3 wifiScanResultsHandler:(id)a4 threadScanResultsHandler:(id)a5 readyToCancelHandler:(id)a6 progressUpdateHandler:(id)a7 scanningNetworks:(BOOL)a8 completion:(id)a9;
- (void)timerDidFire:(id)a3;
- (void)triggerEstablishingMatterSubscription;
- (void)tryPairingWithOnboardingPayload:(id)a3 systemCommissionerPairings:(id)a4 pairingManager:(id)a5;
- (void)updateAccessoryControlToAdministratorNodes:(id)a3 sharedUserNodes:(id)a4 completion:(id)a5;
- (void)updateAccessoryControlToIncludeAdministratorNodes:(id)a3 sharedUserNodes:(id)a4 completion:(id)a5;
- (void)updateAccessoryControlToRemoveAdministratorNode:(id)a3 completion:(id)a4;
- (void)updateAccessoryName:(id)a3;
- (void)updateAllCharacteristicValuesPostHAPServiceEnumeration:(id)a3;
- (void)updateDefaultOtaProvider:(id)a3 providerEndpoint:(id)a4 completionHandler:(id)a5;
- (void)updateFabricLabel:(id)a3 completionHandler:(id)a4;
- (void)updateSoftwareVersion:(id)a3;
- (void)updateVidPidWithAttestationDeviceInfo:(id)a3;
- (void)validateAttestationDeviceInfo:(id)a3 error:(id)a4 completion:(id)a5;
- (void)writeCharacteristicValues:(id)a3 timeout:(double)a4 completionQueue:(id)a5 completionHandler:(id)a6;
@end

@implementation HMMTRAccessoryServer

- (id)endPointForHapAccessory:(id)a3
{
  v3 = [a3 services];
  v4 = objc_msgSend(v3, "hmf_objectPassingTest:", &__block_literal_global_46);

  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    v5 = v4;
  }
  else {
    v5 = 0;
  }
  id v6 = v5;

  v7 = [v6 endpoint];

  return v7;
}

uint64_t __62__HMMTRAccessoryServer_HAPAccessory__endPointForHapAccessory___block_invoke(uint64_t a1, void *a2)
{
  v2 = [a2 type];
  uint64_t v3 = [v2 isEqual:@"0000003E-0000-1000-8000-0026BB765291"];

  return v3;
}

- (id)_hapAccessoryAtEndpoint:(id)a3
{
  id v4 = a3;
  v5 = [(HAPAccessoryServer *)self accessories];
  uint64_t v6 = [v5 count];

  if (v6 == 1)
  {
    v7 = [(HMMTRAccessoryServer *)self primaryAccessory];
  }
  else
  {
    v8 = [(HMMTRAccessoryServer *)self deviceTopology];
    v9 = [(HAPAccessoryServer *)self accessories];
    v12[0] = MEMORY[0x263EF8330];
    v12[1] = 3221225472;
    v12[2] = __62__HMMTRAccessoryServer_HAPAccessory___hapAccessoryAtEndpoint___block_invoke;
    v12[3] = &unk_265374978;
    id v13 = v8;
    id v14 = v4;
    id v10 = v8;
    v7 = objc_msgSend(v9, "hmf_objectPassingTest:", v12);
  }
  return v7;
}

uint64_t __62__HMMTRAccessoryServer_HAPAccessory___hapAccessoryAtEndpoint___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 services];
  id v4 = objc_msgSend(v3, "hmf_objectPassingTest:", &__block_literal_global_106);

  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    v5 = v4;
  }
  else {
    v5 = 0;
  }
  id v6 = v5;

  v7 = *(void **)(a1 + 32);
  v8 = [v6 endpoint];
  v9 = [v7 getPartsListAtEndpoint:v8];

  id v10 = [v6 endpoint];

  if ([v10 isEqual:*(void *)(a1 + 40)]) {
    uint64_t v11 = 1;
  }
  else {
    uint64_t v11 = [v9 containsObject:*(void *)(a1 + 40)];
  }

  return v11;
}

uint64_t __62__HMMTRAccessoryServer_HAPAccessory___hapAccessoryAtEndpoint___block_invoke_2(uint64_t a1, void *a2)
{
  v2 = [a2 type];
  uint64_t v3 = [v2 isEqual:@"0000003E-0000-1000-8000-0026BB765291"];

  return v3;
}

- (void)handleCHIPRemoteRequest:(id)a3 completion:(id)a4
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = random();
  v9 = (void *)MEMORY[0x2533B64D0]();
  id v10 = self;
  uint64_t v11 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    v12 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    v23 = v12;
    __int16 v24 = 2048;
    uint64_t v25 = v8;
    _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_INFO, "%{public}@Accessory Operation Queue: remote request job(%lu) queued.", buf, 0x16u);
  }
  v18[0] = MEMORY[0x263EF8330];
  v18[1] = 3221225472;
  v18[2] = __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke;
  v18[3] = &unk_265377408;
  uint64_t v21 = v8;
  v18[4] = v10;
  id v19 = v6;
  id v20 = v7;
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke_21;
  v15[3] = &unk_265375750;
  id v16 = v20;
  uint64_t v17 = v8;
  v15[4] = v10;
  id v13 = v6;
  id v14 = v20;
  [(HMMTRAccessoryServer *)v10 queueAccessoryOperation:v18 highPriority:0 completion:v15];
}

void __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 56);
    *(_DWORD *)buf = 138543618;
    v30 = v5;
    __int16 v31 = 2048;
    uint64_t v32 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Accessory Operation Queue: remote request job(%lu) started.", buf, 0x16u);
  }
  id v7 = [*(id *)(a1 + 32) deviceController];
  if (v7
    && (uint64_t v8 = (void *)MEMORY[0x263F10CA8],
        [*(id *)(a1 + 32) nodeID],
        v9 = objc_claimAutoreleasedReturnValue(),
        [v8 deviceWithNodeID:v9 controller:v7],
        id v10 = objc_claimAutoreleasedReturnValue(),
        v9,
        v10))
  {
    uint64_t v11 = *(void **)(a1 + 32);
    uint64_t v12 = *(void *)(a1 + 40);
    v26[0] = MEMORY[0x263EF8330];
    v26[1] = 3221225472;
    v26[2] = __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke_18;
    v26[3] = &unk_265375728;
    id v14 = *(void **)(a1 + 48);
    uint64_t v13 = *(void *)(a1 + 56);
    v26[4] = v11;
    uint64_t v28 = v13;
    id v27 = v14;
    [v11 handleCHIPRemoteRequest:v12 device:v10 completion:v26];
  }
  else
  {
    v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = *(id *)(a1 + 32);
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18 = HMFGetLogIdentifier();
      uint64_t v19 = *(void *)(a1 + 56);
      *(_DWORD *)buf = 138543618;
      v30 = v18;
      __int16 v31 = 2048;
      uint64_t v32 = v19;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@Device not found to handle remote request job(%lu)", buf, 0x16u);
    }
    id v20 = (void *)MEMORY[0x2533B64D0]();
    id v21 = *(id *)(a1 + 32);
    v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v23 = HMFGetLogIdentifier();
      uint64_t v24 = *(void *)(a1 + 56);
      *(_DWORD *)buf = 138543618;
      v30 = v23;
      __int16 v31 = 2048;
      uint64_t v32 = v24;
      _os_log_impl(&dword_252495000, v22, OS_LOG_TYPE_INFO, "%{public}@Accessory Operation Queue: remote request job(%lu) complete.", buf, 0x16u);
    }
    uint64_t v25 = *(void *)(a1 + 48);
    id v10 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F41FD8] code:2 userInfo:0];
    (*(void (**)(uint64_t, void, void *))(v25 + 16))(v25, 0, v10);
  }
}

void __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke_21(uint64_t a1, void *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    uint64_t v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      id v7 = HMFGetLogIdentifier();
      uint64_t v8 = *(void *)(a1 + 48);
      int v9 = 138543618;
      id v10 = v7;
      __int16 v11 = 2048;
      uint64_t v12 = v8;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Accessory Operation Queue: remote request job(%lu) unscheduled.", (uint8_t *)&v9, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void __73__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_completion___block_invoke_18(uint64_t a1, void *a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id v7 = (void *)MEMORY[0x2533B64D0]();
  id v8 = *(id *)(a1 + 32);
  int v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    id v10 = HMFGetLogIdentifier();
    uint64_t v11 = *(void *)(a1 + 48);
    int v12 = 138543618;
    uint64_t v13 = v10;
    __int16 v14 = 2048;
    uint64_t v15 = v11;
    _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_INFO, "%{public}@Accessory Operation Queue: remote request job(%lu) complete.", (uint8_t *)&v12, 0x16u);
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

- (void)handleDownloadLogCommand:(id)a3 device:(id)a4 completion:(id)a5
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  uint64_t v11 = [v8 CHIPDownloadLogType];
  uint64_t v12 = [v8 CHIPDownloadTimeout];
  uint64_t v13 = (void *)v12;
  if (v11 && v12)
  {
    uint64_t v14 = [v11 integerValue];
    [v13 doubleValue];
    double v16 = v15;
    uint64_t v17 = [(HAPAccessoryServer *)self clientQueue];
    v23[0] = MEMORY[0x263EF8330];
    v23[1] = 3221225472;
    v23[2] = __81__HMMTRAccessoryServer_RemoteAccess__handleDownloadLogCommand_device_completion___block_invoke;
    v23[3] = &unk_265375700;
    v23[4] = self;
    id v24 = v10;
    [v9 downloadLogOfType:v14 timeout:v17 queue:v23 completion:v16];
  }
  else
  {
    v18 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v19 = self;
    id v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      id v21 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v26 = v21;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_ERROR, "%{public}@Download log command w/o valid log type/timeout", buf, 0xCu);
    }
    v22 = [MEMORY[0x263F087E8] hapErrorWithCode:9];
    (*((void (**)(id, void, void *))v10 + 2))(v10, 0, v22);
  }
}

void __81__HMMTRAccessoryServer_RemoteAccess__handleDownloadLogCommand_device_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id v7 = [v5 lastPathComponent];
  id v8 = (void *)MEMORY[0x2533B64D0]();
  id v9 = *(id *)(a1 + 32);
  id v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    uint64_t v11 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543874;
    v37 = v11;
    __int16 v38 = 2112;
    id v39 = v5;
    __int16 v40 = 2112;
    id v41 = v6;
    _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Did download to URL: %@. Error: %@", buf, 0x20u);
  }
  if (v5 && !v6 && v7)
  {
    uint64_t v12 = [MEMORY[0x263F42608] sharedPreferences];
    uint64_t v13 = [v12 preferenceForKey:@"maxAccessoryLogSize"];
    uint64_t v14 = [v13 numberValue];
    unint64_t v15 = [v14 unsignedIntegerValue];

    double v16 = [MEMORY[0x263F08850] defaultManager];
    uint64_t v17 = [v5 path];
    id v33 = 0;
    v18 = [v16 attributesOfItemAtPath:v17 error:&v33];
    id v19 = v33;

    unint64_t v20 = [v18 fileSize];
    unint64_t v21 = v20;
    if (v19 || v20 > v15)
    {
      uint64_t v25 = (void *)MEMORY[0x2533B64D0]();
      id v26 = *(id *)(a1 + 32);
      uint64_t v27 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        HMFGetLogIdentifier();
        uint64_t v28 = v31 = v25;
        v29 = [NSNumber numberWithUnsignedInteger:v21];
        *(_DWORD *)buf = 138543874;
        v37 = v28;
        __int16 v38 = 2112;
        id v39 = v29;
        __int16 v40 = 2112;
        id v41 = v19;
        _os_log_impl(&dword_252495000, v27, OS_LOG_TYPE_ERROR, "%{public}@Invalid log file with size %@. Error: %@", buf, 0x20u);

        uint64_t v25 = v31;
      }

      uint64_t v30 = *(void *)(a1 + 40);
      if (!v19)
      {
        id v19 = [MEMORY[0x263F087E8] hapErrorWithCode:12];
      }
      (*(void (**)(uint64_t, void, id))(v30 + 16))(v30, 0, v19);
    }
    else
    {
      id v32 = 0;
      v22 = [MEMORY[0x263EFF8F8] dataWithContentsOfURL:v5 options:0 error:&v32];
      id v19 = v32;
      if (v22)
      {
        v34[0] = @"fileData";
        v34[1] = @"fileName";
        v35[0] = v22;
        v35[1] = v7;
        v23 = [NSDictionary dictionaryWithObjects:v35 forKeys:v34 count:2];
      }
      else
      {
        v23 = 0;
      }
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
    goto LABEL_21;
  }
  uint64_t v24 = *(void *)(a1 + 40);
  if (!v6)
  {
    v18 = [MEMORY[0x263F087E8] hapErrorWithCode:12];
    (*(void (**)(uint64_t, void, void *))(v24 + 16))(v24, 0, v18);
LABEL_21:

    goto LABEL_22;
  }
  (*(void (**)(uint64_t, void, id))(v24 + 16))(v24, 0, v6);
LABEL_22:
}

- (void)handleCHIPRemoteRequest:(id)a3 device:(id)a4 completion:(id)a5
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  uint64_t v11 = [v8 objectForKeyedSubscript:@"command"];
  if (v11)
  {
    uint64_t v12 = [v8 CHIPEndpointID];
    v55 = [v8 CHIPClusterID];
    v54 = [v8 CHIPAttributeID];
    v53 = [v8 CHIPCommandID];
    if ([v11 isEqualToString:@"read"])
    {
      objc_initWeak((id *)location, self);
      uint64_t v13 = [v8 CHIPReadParams];
      uint64_t v14 = [(HAPAccessoryServer *)self clientQueue];
      v64[0] = MEMORY[0x263EF8330];
      v64[1] = 3221225472;
      v64[2] = __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke;
      v64[3] = &unk_2653756D8;
      objc_copyWeak(&v67, (id *)location);
      id v65 = v11;
      id v66 = v10;
      [v9 readAttributeWithEndpointId:v12 clusterId:v55 attributeId:v54 params:v13 clientQueue:v14 completion:v64];

      objc_destroyWeak(&v67);
      objc_destroyWeak((id *)location);
    }
    else if ([v11 isEqualToString:@"write"])
    {
      id v19 = [v8 objectForKeyedSubscript:@"data"];
      if (v19)
      {
        objc_initWeak((id *)location, self);
        unint64_t v20 = [v8 CHIPTimedWriteTimeout];
        unint64_t v21 = [(HAPAccessoryServer *)self clientQueue];
        v60[0] = MEMORY[0x263EF8330];
        v60[1] = 3221225472;
        v60[2] = __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke_9;
        v60[3] = &unk_2653756D8;
        objc_copyWeak(&v63, (id *)location);
        id v61 = v11;
        id v62 = v10;
        [v9 writeAttributeWithEndpointId:v12 clusterId:v55 attributeId:v54 value:v19 timedWriteTimeout:v20 clientQueue:v21 completion:v60];

        objc_destroyWeak(&v63);
        objc_destroyWeak((id *)location);
      }
      else
      {
        id v32 = (void *)MEMORY[0x2533B64D0]();
        id v33 = self;
        v34 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          v35 = HMFGetLogIdentifier();
          *(_DWORD *)location = 138543618;
          *(void *)&location[4] = v35;
          __int16 v71 = 2112;
          id v72 = v8;
          _os_log_impl(&dword_252495000, v34, OS_LOG_TYPE_ERROR, "%{public}@\"data\" field missing from CHIP remote request message payload: %@", location, 0x16u);
        }
        v36 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F41FD8] code:2 userInfo:0];
        (*((void (**)(id, void, void *))v10 + 2))(v10, 0, v36);
      }
    }
    else if ([v11 isEqualToString:@"command"])
    {
      if (v53 && v55)
      {
        v22 = [v8 CHIPCommandFields];
        if (!v22)
        {
          uint64_t v23 = *MEMORY[0x263F10C10];
          uint64_t v24 = *MEMORY[0x263F10C30];
          v68[0] = *MEMORY[0x263F10C18];
          v68[1] = v24;
          v69[0] = v23;
          v69[1] = MEMORY[0x263EFFA68];
          v22 = [NSDictionary dictionaryWithObjects:v69 forKeys:v68 count:2];
        }
        objc_initWeak((id *)location, self);
        uint64_t v25 = [v8 CHIPTimedInvokeTimeout];
        id v26 = [(HAPAccessoryServer *)self clientQueue];
        v56[0] = MEMORY[0x263EF8330];
        v56[1] = 3221225472;
        v56[2] = __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke_11;
        v56[3] = &unk_2653756D8;
        objc_copyWeak(&v59, (id *)location);
        id v57 = v11;
        id v58 = v10;
        [v9 invokeCommandWithEndpointId:v12 clusterId:v55 commandId:v53 commandFields:v22 timedInvokeTimeout:v25 clientQueue:v26 completion:v56];

        objc_destroyWeak(&v59);
        objc_destroyWeak((id *)location);
      }
      else
      {
        v37 = (void *)MEMORY[0x2533B64D0]();
        __int16 v38 = self;
        id v39 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          __int16 v40 = HMFGetLogIdentifier();
          *(_DWORD *)location = 138543362;
          *(void *)&location[4] = v40;
          _os_log_impl(&dword_252495000, v39, OS_LOG_TYPE_ERROR, "%{public}@Invoke CHIP command with no specific command path", location, 0xCu);
        }
        id v41 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:9 userInfo:0];
        (*((void (**)(id, void, void *))v10 + 2))(v10, 0, v41);
      }
    }
    else if ([v11 isEqualToString:@"subscribe"])
    {
      v52 = [v8 CHIPMinInterval];
      v51 = [v8 CHIPMaxInterval];
      if (v52 && v51)
      {
        id v27 = objc_alloc_init(MEMORY[0x263EFF9A0]);
        uint64_t v28 = (void *)MEMORY[0x2533B64D0]([v27 setCHIPRemoteCommand:v11]);
        v29 = self;
        uint64_t v30 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          __int16 v31 = HMFGetLogIdentifier();
          *(_DWORD *)location = 138543618;
          *(void *)&location[4] = v31;
          __int16 v71 = 2112;
          id v72 = v27;
          _os_log_impl(&dword_252495000, v30, OS_LOG_TYPE_DEBUG, "%{public}@Subscribe CHIP attribute responded with %@", location, 0x16u);
        }
        (*((void (**)(id, id, void))v10 + 2))(v10, v27, 0);
      }
      else
      {
        v47 = (void *)MEMORY[0x2533B64D0]();
        v48 = self;
        v49 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          v50 = HMFGetLogIdentifier();
          *(_DWORD *)location = 138543362;
          *(void *)&location[4] = v50;
          _os_log_impl(&dword_252495000, v49, OS_LOG_TYPE_ERROR, "%{public}@Subscribe CHIP attribute with no specific min/max interval", location, 0xCu);
        }
        id v27 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:9 userInfo:0];
        (*((void (**)(id, void, id))v10 + 2))(v10, 0, v27);
      }
    }
    else if ([v11 isEqualToString:@"downloadLog"])
    {
      [(HMMTRAccessoryServer *)self handleDownloadLogCommand:v8 device:v9 completion:v10];
    }
    else
    {
      uint64_t v42 = (void *)MEMORY[0x2533B64D0]();
      v43 = self;
      v44 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        v45 = HMFGetLogIdentifier();
        *(_DWORD *)location = 138543362;
        *(void *)&location[4] = v45;
        _os_log_impl(&dword_252495000, v44, OS_LOG_TYPE_ERROR, "%{public}@Unsupported manufacturer extension control command", location, 0xCu);
      }
      v46 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:3 userInfo:0];
      (*((void (**)(id, void, void *))v10 + 2))(v10, 0, v46);
    }
  }
  else
  {
    unint64_t v15 = (void *)MEMORY[0x2533B64D0]();
    double v16 = self;
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18 = HMFGetLogIdentifier();
      *(_DWORD *)location = 138543618;
      *(void *)&location[4] = v18;
      __int16 v71 = 2112;
      id v72 = v8;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@\"command\" field missing from CHIP remote request message payload: %@", location, 0x16u);
    }
    uint64_t v12 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F41FD8] code:2 userInfo:0];
    (*((void (**)(id, void, void *))v10 + 2))(v10, 0, v12);
  }
}

void __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    id v9 = (void *)MEMORY[0x2533B64D0]();
    id v10 = WeakRetained;
    uint64_t v11 = HMFGetOSLogHandle();
    uint64_t v12 = v11;
    if (v6)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = HMFGetLogIdentifier();
        int v23 = 138543618;
        uint64_t v24 = v13;
        __int16 v25 = 2112;
        id v26 = v6;
        uint64_t v14 = "%{public}@Read CHIP attribute completed with an error: %@";
        unint64_t v15 = v12;
        os_log_type_t v16 = OS_LOG_TYPE_ERROR;
LABEL_7:
        _os_log_impl(&dword_252495000, v15, v16, v14, (uint8_t *)&v23, 0x16u);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v13 = HMFGetLogIdentifier();
      int v23 = 138543618;
      uint64_t v24 = v13;
      __int16 v25 = 2112;
      id v26 = v5;
      uint64_t v14 = "%{public}@Read CHIP attribute completed with value: %@";
      unint64_t v15 = v12;
      os_log_type_t v16 = OS_LOG_TYPE_DEBUG;
      goto LABEL_7;
    }
  }
  if (v5)
  {
    id v17 = objc_alloc_init(MEMORY[0x263EFF9A0]);
    [v17 setCHIPRemoteCommand:*(void *)(a1 + 32)];
    uint64_t v18 = [v17 setCHIPRemoteResults:v5];
    if (WeakRetained)
    {
      id v19 = (void *)MEMORY[0x2533B64D0](v18);
      id v20 = WeakRetained;
      unint64_t v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        v22 = HMFGetLogIdentifier();
        int v23 = 138543618;
        uint64_t v24 = v22;
        __int16 v25 = 2112;
        id v26 = v17;
        _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_DEBUG, "%{public}@Read CHIP attribute responded with %@", (uint8_t *)&v23, 0x16u);
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    (*(void (**)(void, void, id, uint64_t))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, v6, v7);
  }
}

void __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke_9(uint64_t a1, void *a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    id v9 = (void *)MEMORY[0x2533B64D0]();
    id v10 = WeakRetained;
    uint64_t v11 = HMFGetOSLogHandle();
    uint64_t v12 = v11;
    if (v6)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = HMFGetLogIdentifier();
        int v23 = 138543618;
        uint64_t v24 = v13;
        __int16 v25 = 2112;
        id v26 = v6;
        uint64_t v14 = "%{public}@Write CHIP attribute completed with an error: %@";
        unint64_t v15 = v12;
        os_log_type_t v16 = OS_LOG_TYPE_ERROR;
LABEL_7:
        _os_log_impl(&dword_252495000, v15, v16, v14, (uint8_t *)&v23, 0x16u);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v13 = HMFGetLogIdentifier();
      int v23 = 138543618;
      uint64_t v24 = v13;
      __int16 v25 = 2112;
      id v26 = v5;
      uint64_t v14 = "%{public}@Write CHIP attribute completed with values: %@";
      unint64_t v15 = v12;
      os_log_type_t v16 = OS_LOG_TYPE_DEBUG;
      goto LABEL_7;
    }
  }
  if (v5)
  {
    id v17 = objc_alloc_init(MEMORY[0x263EFF9A0]);
    [v17 setCHIPRemoteCommand:*(void *)(a1 + 32)];
    uint64_t v18 = [v17 setCHIPRemoteResults:v5];
    if (WeakRetained)
    {
      id v19 = (void *)MEMORY[0x2533B64D0](v18);
      id v20 = WeakRetained;
      unint64_t v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        v22 = HMFGetLogIdentifier();
        int v23 = 138543618;
        uint64_t v24 = v22;
        __int16 v25 = 2112;
        id v26 = v17;
        _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_DEBUG, "%{public}@Write CHIP attribute responded with %@", (uint8_t *)&v23, 0x16u);
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    (*(void (**)(void, void, id, uint64_t))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, v6, v7);
  }
}

void __80__HMMTRAccessoryServer_RemoteAccess__handleCHIPRemoteRequest_device_completion___block_invoke_11(uint64_t a1, void *a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    id v9 = (void *)MEMORY[0x2533B64D0]();
    id v10 = WeakRetained;
    uint64_t v11 = HMFGetOSLogHandle();
    uint64_t v12 = v11;
    if (v6)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = HMFGetLogIdentifier();
        int v23 = 138543618;
        uint64_t v24 = v13;
        __int16 v25 = 2112;
        id v26 = v6;
        uint64_t v14 = "%{public}@Invoke CHIP command completed with an error: %@";
        unint64_t v15 = v12;
        os_log_type_t v16 = OS_LOG_TYPE_ERROR;
LABEL_7:
        _os_log_impl(&dword_252495000, v15, v16, v14, (uint8_t *)&v23, 0x16u);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v13 = HMFGetLogIdentifier();
      int v23 = 138543618;
      uint64_t v24 = v13;
      __int16 v25 = 2112;
      id v26 = v5;
      uint64_t v14 = "%{public}@Invoke CHIP command completed with response: %@";
      unint64_t v15 = v12;
      os_log_type_t v16 = OS_LOG_TYPE_DEBUG;
      goto LABEL_7;
    }
  }
  if (v5)
  {
    id v17 = objc_alloc_init(MEMORY[0x263EFF9A0]);
    [v17 setCHIPRemoteCommand:*(void *)(a1 + 32)];
    uint64_t v18 = [v17 setCHIPRemoteResults:v5];
    if (WeakRetained)
    {
      id v19 = (void *)MEMORY[0x2533B64D0](v18);
      id v20 = WeakRetained;
      unint64_t v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        v22 = HMFGetLogIdentifier();
        int v23 = 138543618;
        uint64_t v24 = v22;
        __int16 v25 = 2112;
        id v26 = v17;
        _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_DEBUG, "%{public}@Invoke CHIP command responded with %@", (uint8_t *)&v23, 0x16u);
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    (*(void (**)(void, void, id, uint64_t))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, v6, v7);
  }
}

- (id)_getOperationalHardwareAddressFromReadValue:(id)a3
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = v4;
  if (v4)
  {
    uint64_t v6 = *MEMORY[0x263F10C18];
    uint64_t v7 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10C18]];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      id v8 = v7;
    }
    else {
      id v8 = 0;
    }
    id v9 = v8;

    int v10 = [v9 isEqual:*MEMORY[0x263F10B68]];
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    if (v10)
    {
      id v52 = v9;
      id v63 = self;
      v53 = v5;
      uint64_t v56 = *MEMORY[0x263F10C30];
      uint64_t v13 = objc_msgSend(v5, "objectForKeyedSubscript:");
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = 0;
      }
      id v15 = v14;

      long long v73 = 0u;
      long long v74 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      id obj = v15;
      uint64_t v16 = [obj countByEnumeratingWithState:&v71 objects:v76 count:16];
      if (v16)
      {
        uint64_t v17 = v16;
        char v18 = 0;
        v64 = 0;
        uint64_t v19 = *(void *)v72;
        uint64_t v66 = *MEMORY[0x263F10B90];
        uint64_t v61 = *MEMORY[0x263F10C10];
        uint64_t v20 = *MEMORY[0x263F10B88];
        unint64_t v21 = v63;
        uint64_t v54 = *(void *)v72;
        uint64_t v55 = v6;
        while (1)
        {
          uint64_t v22 = 0;
          uint64_t v57 = v17;
          do
          {
            if (*(void *)v72 != v19) {
              objc_enumerationMutation(obj);
            }
            if (v18) {
              goto LABEL_54;
            }
            int v23 = [*(id *)(*((void *)&v71 + 1) + 8 * v22) objectForKeyedSubscript:v66];
            objc_opt_class();
            if (objc_opt_isKindOfClass()) {
              uint64_t v24 = v23;
            }
            else {
              uint64_t v24 = 0;
            }
            id v25 = v24;

            id v26 = [v25 objectForKeyedSubscript:v6];
            objc_opt_class();
            if (objc_opt_isKindOfClass()) {
              uint64_t v27 = v26;
            }
            else {
              uint64_t v27 = 0;
            }
            uint64_t v28 = v6;
            id v29 = v27;

            id v62 = v29;
            if ([v29 isEqual:v61])
            {
              id v59 = v25;
              uint64_t v60 = v22;
              uint64_t v30 = [v25 objectForKeyedSubscript:v56];
              objc_opt_class();
              if (objc_opt_isKindOfClass()) {
                __int16 v31 = v30;
              }
              else {
                __int16 v31 = 0;
              }
              id v32 = v31;

              long long v69 = 0u;
              long long v70 = 0u;
              long long v67 = 0u;
              long long v68 = 0u;
              id v65 = v32;
              uint64_t v33 = [v65 countByEnumeratingWithState:&v67 objects:v75 count:16];
              if (v33)
              {
                uint64_t v34 = v33;
                uint64_t v35 = *(void *)v68;
                do
                {
                  for (uint64_t i = 0; i != v34; ++i)
                  {
                    if (*(void *)v68 != v35) {
                      objc_enumerationMutation(v65);
                    }
                    v37 = *(void **)(*((void *)&v67 + 1) + 8 * i);
                    __int16 v38 = [v37 objectForKeyedSubscript:v20];
                    objc_opt_class();
                    if (objc_opt_isKindOfClass()) {
                      id v39 = v38;
                    }
                    else {
                      id v39 = 0;
                    }
                    id v40 = v39;

                    if ([v40 isEqual:&unk_2702B5208])
                    {
                      id v41 = [v37 objectForKeyedSubscript:v66];
                      objc_opt_class();
                      if (objc_opt_isKindOfClass()) {
                        uint64_t v42 = v41;
                      }
                      else {
                        uint64_t v42 = 0;
                      }
                      id v43 = v42;

                      v44 = [(HMMTRAccessoryServer *)v21 numberOfReadValue:v43];

                      if ([v44 BOOLValue]) {
                        char v18 = 1;
                      }
                    }
                    else
                    {
                      if (![v40 isEqual:&unk_2702B5250]) {
                        goto LABEL_45;
                      }
                      v45 = [v37 objectForKeyedSubscript:v66];
                      objc_opt_class();
                      if (objc_opt_isKindOfClass()) {
                        v46 = v45;
                      }
                      else {
                        v46 = 0;
                      }
                      id v47 = v46;

                      v44 = [(HMMTRAccessoryServer *)v21 dataOfReadValue:v47];
                      v48 = (void *)[objc_alloc(MEMORY[0x263F42540]) initWithAddressData:v44];
                      uint64_t v49 = [v48 formattedString];

                      v64 = (void *)v49;
                      unint64_t v21 = v63;
                    }

LABEL_45:
                  }
                  uint64_t v34 = [v65 countByEnumeratingWithState:&v67 objects:v75 count:16];
                }
                while (v34);
              }

              uint64_t v19 = v54;
              uint64_t v6 = v55;
              uint64_t v17 = v57;
              id v25 = v59;
              uint64_t v22 = v60;
            }
            else
            {
              uint64_t v6 = v28;
            }

            ++v22;
          }
          while (v22 != v17);
          uint64_t v17 = [obj countByEnumeratingWithState:&v71 objects:v76 count:16];
          if (!v17) {
            goto LABEL_54;
          }
        }
      }
      char v18 = 0;
      v64 = 0;
LABEL_54:

      uint64_t v12 = v64;
      if (v18) {
        uint64_t v11 = v64;
      }
      else {
        uint64_t v11 = 0;
      }
      id v9 = v52;
      id v5 = v53;
    }
    id v50 = v11;
  }
  else
  {
    id v50 = 0;
  }

  return v50;
}

- (id)_getOperationalNetworkAddressForAccessory:(id)a3
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [(HMMTRAccessoryServer *)self matterDevice];

  if (v5)
  {
    uint64_t v6 = [HMMTRDeviceTopology alloc];
    uint64_t v7 = [(HMMTRAccessoryServer *)self nodeID];
    id v8 = [(HMMTRDeviceTopology *)v6 initWithNodeId:v7 server:self];

    if (v8)
    {
      id v9 = [MEMORY[0x263EFF9A0] dictionary];
      int v10 = [(HMMTRAccessoryServer *)self endpointsForHAPAccessory:v4 topology:v8];
      char v33 = 0;
      if ([v10 count])
      {

        int v10 = &unk_2702B6180;
      }
      uint64_t v11 = [(HMMTRAccessoryServer *)self matterDevice];
      uint64_t v12 = [(HMMTRAccessoryServer *)self generalDiagnosticsClusterFromEndpoints:v10 topology:v8 device:v11 definitelyUnsupported:&v33];

      if (v12)
      {
        uint64_t v13 = [v12 readAttributeNetworkInterfacesWithParams:0];
        uint64_t v14 = [(HMMTRAccessoryServer *)self _getOperationalHardwareAddressFromReadValue:v13];

        id v15 = (void *)MEMORY[0x2533B64D0]();
        uint64_t v16 = self;
        uint64_t v17 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          char v18 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          uint64_t v35 = v18;
          __int16 v36 = 2112;
          v37 = v14;
          _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_DEBUG, "%{public}@Found operational hardware address: %@", buf, 0x16u);
        }
        [v9 setObject:v14 forKeyedSubscript:@"hardware_address"];

        id v19 = 0;
      }
      else
      {
        uint64_t v28 = (void *)MEMORY[0x2533B64D0]();
        id v29 = self;
        uint64_t v30 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          __int16 v31 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543362;
          uint64_t v35 = v31;
          _os_log_impl(&dword_252495000, v30, OS_LOG_TYPE_ERROR, "%{public}@Matter device doesn't have general diagnostic cluster", buf, 0xCu);
        }
        id v19 = v9;
      }
    }
    else
    {
      uint64_t v24 = (void *)MEMORY[0x2533B64D0]();
      id v25 = self;
      id v26 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        uint64_t v27 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v35 = v27;
        _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_ERROR, "%{public}@Matter topology is nil", buf, 0xCu);
      }
      id v19 = 0;
    }
  }
  else
  {
    uint64_t v20 = (void *)MEMORY[0x2533B64D0]();
    unint64_t v21 = self;
    uint64_t v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      int v23 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v35 = v23;
      _os_log_impl(&dword_252495000, v22, OS_LOG_TYPE_ERROR, "%{public}@Matter device is nil", buf, 0xCu);
    }
    id v19 = 0;
  }

  return v19;
}

- (void)_handleDiagnosticsEvent:(id)a3
{
  uint64_t v301 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10BD0]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  id v7 = v6;

  id v8 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10BC8]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v9 = v8;
  }
  else {
    id v9 = 0;
  }
  id v10 = v9;

  uint64_t v11 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10BD8]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  id v13 = v12;

  uint64_t v14 = [v7 cluster];
  int v15 = [v14 isEqual:&unk_2702B5160];

  if (v15)
  {
    uint64_t v16 = [v7 event];
    int v17 = [v16 isEqual:&unk_2702B51F0];

    if (v17)
    {
      dispatch_time_t v18 = dispatch_time(0, 10000000000);
      id v19 = [(HAPAccessoryServer *)self clientQueue];
      block[0] = MEMORY[0x263EF8330];
      block[1] = 3221225472;
      block[2] = __69__HMMTRAccessoryServer_DiagnosticsInternal___handleDiagnosticsEvent___block_invoke;
      block[3] = &unk_265376EE8;
      block[4] = self;
      id v268 = v10;
      id v269 = v13;
      id v270 = v4;
      dispatch_after(v18, v19, block);
    }
    goto LABEL_165;
  }
  uint64_t v20 = [v7 cluster];
  int v21 = [v20 isEqual:&unk_2702B51C0];

  if (v21)
  {
    uint64_t v22 = [v7 event];
    int v23 = [v22 isEqual:&unk_2702B51F0];

    if (v23)
    {
      uint64_t v24 = *MEMORY[0x263F10B90];
      id v25 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10B90]];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        id v26 = v25;
      }
      else {
        id v26 = 0;
      }
      id v27 = v26;

      if (v27)
      {
        uint64_t v28 = [v27 objectForKeyedSubscript:*MEMORY[0x263F10C18]];
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          id v29 = v28;
        }
        else {
          id v29 = 0;
        }
        id v30 = v29;

        v234 = v30;
        if ([v30 isEqual:*MEMORY[0x263F10C10]])
        {
          v240 = self;
          id v225 = v10;
          id v227 = v13;
          id v229 = v7;
          id v221 = v4;
          v218 = v27;
          __int16 v31 = [v27 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
          objc_opt_class();
          if (objc_opt_isKindOfClass()) {
            id v32 = v31;
          }
          else {
            id v32 = 0;
          }
          id v33 = v32;

          if (v33)
          {
            long long v265 = 0u;
            long long v266 = 0u;
            long long v263 = 0u;
            long long v264 = 0u;
            id obj = v33;
            uint64_t v34 = [obj countByEnumeratingWithState:&v263 objects:v300 count:16];
            if (v34)
            {
              uint64_t v35 = v34;
              uint64_t v36 = *(void *)v264;
              uint64_t v37 = *MEMORY[0x263F10B88];
LABEL_29:
              uint64_t v38 = 0;
              while (1)
              {
                if (*(void *)v264 != v36) {
                  objc_enumerationMutation(obj);
                }
                id v39 = *(void **)(*((void *)&v263 + 1) + 8 * v38);
                id v40 = [v39 objectForKeyedSubscript:v37];
                objc_opt_class();
                id v41 = (objc_opt_isKindOfClass() & 1) != 0 ? v40 : 0;
                id v42 = v41;

                id v43 = [v39 objectForKeyedSubscript:v24];
                objc_opt_class();
                v44 = (objc_opt_isKindOfClass() & 1) != 0 ? v43 : 0;
                id v45 = v44;

                if ([v42 isEqual:&unk_2702B51F0]) {
                  break;
                }

                if (v35 == ++v38)
                {
                  uint64_t v35 = [obj countByEnumeratingWithState:&v263 objects:v300 count:16];
                  if (v35) {
                    goto LABEL_29;
                  }
                  goto LABEL_41;
                }
              }
              v46 = v240;
              v118 = [(HMMTRAccessoryServer *)v240 numberOfReadValue:v45];

              if (!v118) {
                goto LABEL_114;
              }
              v119 = (void *)MEMORY[0x2533B64D0]();
              v120 = v240;
              v121 = HMFGetOSLogHandle();
              id v7 = v229;
              if (os_log_type_enabled(v121, OS_LOG_TYPE_INFO))
              {
                v122 = HMFGetLogIdentifier();
                v123 = [(HMMTRAccessoryServer *)v120 primaryAccessory];
                v124 = [v123 shortDescription];
                *(_DWORD *)buf = 138544386;
                v285 = v122;
                __int16 v286 = 2112;
                id v287 = v124;
                __int16 v288 = 2112;
                id v289 = v225;
                __int16 v290 = 2112;
                id v291 = v227;
                __int16 v292 = 2112;
                v293 = v118;
                _os_log_impl(&dword_252495000, v121, OS_LOG_TYPE_INFO, "%{public}@%@ [Event no. %@, UpTime %@] Thread connection status %@", buf, 0x34u);
              }
              v298 = @"threadNetwork_ConnectionStatus";
              v125 = [HMMTRAccessoryServerDiagnosticsEvent alloc];
              v297 = v118;
              v126 = [MEMORY[0x263EFF8C0] arrayWithObjects:&v297 count:1];
              v127 = [(HMMTRAccessoryServerDiagnosticsEvent *)v125 initWithValues:v126];
              v299 = v127;
              v88 = [NSDictionary dictionaryWithObjects:&v299 forKeys:&v298 count:1];
              id v4 = v221;
              goto LABEL_172;
            }
LABEL_41:

            v46 = v240;
LABEL_114:
            v128 = (void *)MEMORY[0x2533B64D0]();
            v129 = v46;
            v130 = HMFGetOSLogHandle();
            id v4 = v221;
            id v7 = v229;
            if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
            {
              v131 = HMFGetLogIdentifier();
              *(_DWORD *)buf = 138543618;
              v285 = v131;
              __int16 v286 = 2112;
              id v287 = v221;
              _os_log_impl(&dword_252495000, v130, OS_LOG_TYPE_ERROR, "%{public}@ThreadNetworkDiagnostics ConnectionStatus event data has unexpected structure: %@", buf, 0x16u);
            }

            goto LABEL_200;
          }
          goto LABEL_203;
        }
        id v54 = v27;
        v114 = (void *)MEMORY[0x2533B64D0]();
        v115 = self;
        v116 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR))
        {
          v117 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          v285 = v117;
          __int16 v286 = 2112;
          id v287 = v234;
          _os_log_impl(&dword_252495000, v116, OS_LOG_TYPE_ERROR, "%{public}@ThreadNetworkDiagnostics ConnectionStatus event data type is unexpected: %@", buf, 0x16u);
        }

        goto LABEL_145;
      }
LABEL_202:
      _HMFPreconditionFailure();
      goto LABEL_203;
    }
LABEL_165:
    v88 = 0;
    goto LABEL_166;
  }
  id v47 = [v7 cluster];
  int v48 = [v47 isEqual:&unk_2702B51D8];

  if (!v48) {
    goto LABEL_165;
  }
  uint64_t v49 = [v7 event];
  int v50 = [v49 isEqual:&unk_2702B5208];

  if (!v50)
  {
    v89 = [v7 event];
    int v90 = [v89 isEqual:&unk_2702B5220];

    if (v90)
    {
      v242 = self;
      uint64_t v91 = *MEMORY[0x263F10B90];
      v92 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10B90]];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        v93 = v92;
      }
      else {
        v93 = 0;
      }
      id v94 = v93;

      if (!v94) {
        goto LABEL_202;
      }
      v95 = [v94 objectForKeyedSubscript:*MEMORY[0x263F10C18]];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        v96 = v95;
      }
      else {
        v96 = 0;
      }
      id v97 = v96;

      v234 = v97;
      if ([v97 isEqual:*MEMORY[0x263F10C10]])
      {
        id v225 = v10;
        id v227 = v13;
        id v231 = v7;
        id v223 = v4;
        v218 = v94;
        v98 = [v94 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          v99 = v98;
        }
        else {
          v99 = 0;
        }
        id v100 = v99;

        if (v100)
        {
          long long v257 = 0u;
          long long v258 = 0u;
          long long v255 = 0u;
          long long v256 = 0u;
          id obj = v100;
          uint64_t v101 = [obj countByEnumeratingWithState:&v255 objects:v280 count:16];
          if (!v101) {
            goto LABEL_106;
          }
          uint64_t v102 = v101;
          uint64_t v103 = *(void *)v256;
          uint64_t v104 = *MEMORY[0x263F10B88];
          while (1)
          {
            for (uint64_t i = 0; i != v102; ++i)
            {
              if (*(void *)v256 != v103) {
                objc_enumerationMutation(obj);
              }
              v106 = *(void **)(*((void *)&v255 + 1) + 8 * i);
              v107 = [v106 objectForKeyedSubscript:v104];
              objc_opt_class();
              if (objc_opt_isKindOfClass()) {
                v108 = v107;
              }
              else {
                v108 = 0;
              }
              id v109 = v108;

              v110 = [v106 objectForKeyedSubscript:v91];
              objc_opt_class();
              if (objc_opt_isKindOfClass()) {
                v111 = v110;
              }
              else {
                v111 = 0;
              }
              id v112 = v111;

              if ([v109 isEqual:&unk_2702B51F0])
              {
                v113 = v242;
                v118 = [(HMMTRAccessoryServer *)v242 numberOfReadValue:v112];

                if (v118)
                {
                  v171 = (void *)MEMORY[0x2533B64D0]();
                  v172 = v242;
                  v173 = HMFGetOSLogHandle();
                  id v7 = v231;
                  if (os_log_type_enabled(v173, OS_LOG_TYPE_INFO))
                  {
                    v174 = HMFGetLogIdentifier();
                    v175 = [(HMMTRAccessoryServer *)v172 primaryAccessory];
                    v176 = [v175 shortDescription];
                    *(_DWORD *)buf = 138544386;
                    v285 = v174;
                    __int16 v286 = 2112;
                    id v287 = v176;
                    __int16 v288 = 2112;
                    id v289 = v225;
                    __int16 v290 = 2112;
                    id v291 = v227;
                    __int16 v292 = 2112;
                    v293 = v118;
                    _os_log_impl(&dword_252495000, v173, OS_LOG_TYPE_INFO, "%{public}@%@ [Event no. %@, UpTime %@] WiFi Connection Status event with status %@", buf, 0x34u);
                  }
                  v278 = @"wifiNetwork_ConnectionStatus";
                  v177 = [HMMTRAccessoryServerDiagnosticsEvent alloc];
                  v277 = v118;
                  v126 = [MEMORY[0x263EFF8C0] arrayWithObjects:&v277 count:1];
                  v127 = [(HMMTRAccessoryServerDiagnosticsEvent *)v177 initWithValues:v126];
                  v279 = v127;
                  v178 = NSDictionary;
                  v179 = &v279;
                  v180 = &v278;
                  goto LABEL_171;
                }
LABEL_159:
                v181 = (void *)MEMORY[0x2533B64D0]();
                v182 = v113;
                v183 = HMFGetOSLogHandle();
                id v4 = v223;
                id v7 = v231;
                v184 = v234;
                if (os_log_type_enabled(v183, OS_LOG_TYPE_ERROR))
                {
                  v185 = HMFGetLogIdentifier();
                  *(_DWORD *)buf = 138543618;
                  v285 = v185;
                  __int16 v286 = 2112;
                  id v287 = v223;
                  v186 = "%{public}@WiFiNetworkDiagnostics ConnectionStatus event data has unexpected structure: %@";
                  goto LABEL_198;
                }
                goto LABEL_199;
              }
            }
            uint64_t v102 = [obj countByEnumeratingWithState:&v255 objects:v280 count:16];
            if (!v102)
            {
LABEL_106:

              v113 = v242;
              goto LABEL_159;
            }
          }
        }
        goto LABEL_203;
      }
      v160 = v94;
      v161 = (void *)MEMORY[0x2533B64D0]();
      v162 = self;
      v163 = HMFGetOSLogHandle();
      v164 = v234;
      if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR))
      {
        v165 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        v285 = v165;
        __int16 v286 = 2112;
        id v287 = v234;
        v166 = "%{public}@WiFiNetworkDiagnostics ConnectionStatus event data type is unexpected: %@";
LABEL_163:
        _os_log_impl(&dword_252495000, v163, OS_LOG_TYPE_ERROR, v166, buf, 0x16u);
      }
    }
    else
    {
      v132 = [v7 event];
      int v133 = [v132 isEqual:&unk_2702B51F0];

      if (!v133) {
        goto LABEL_165;
      }
      v242 = self;
      uint64_t v134 = *MEMORY[0x263F10B90];
      v135 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10B90]];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        v136 = v135;
      }
      else {
        v136 = 0;
      }
      id v137 = v136;

      if (!v137) {
        goto LABEL_202;
      }
      v138 = [v137 objectForKeyedSubscript:*MEMORY[0x263F10C18]];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        v139 = v138;
      }
      else {
        v139 = 0;
      }
      id v140 = v139;

      v234 = v140;
      if ([v140 isEqual:*MEMORY[0x263F10C10]])
      {
        id v225 = v10;
        id v227 = v13;
        id v232 = v7;
        id v223 = v4;
        v218 = v137;
        v141 = [v137 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          v142 = v141;
        }
        else {
          v142 = 0;
        }
        id v143 = v142;

        if (v143)
        {
          long long v253 = 0u;
          long long v254 = 0u;
          long long v251 = 0u;
          long long v252 = 0u;
          id obj = v143;
          uint64_t v144 = [obj countByEnumeratingWithState:&v251 objects:v276 count:16];
          if (!v144) {
            goto LABEL_141;
          }
          uint64_t v145 = v144;
          uint64_t v146 = *(void *)v252;
          uint64_t v147 = *MEMORY[0x263F10B88];
          while (1)
          {
            for (uint64_t j = 0; j != v145; ++j)
            {
              if (*(void *)v252 != v146) {
                objc_enumerationMutation(obj);
              }
              v149 = *(void **)(*((void *)&v251 + 1) + 8 * j);
              v150 = objc_msgSend(v149, "hmf_numberForKey:", v147);
              v151 = [v149 objectForKeyedSubscript:v134];
              objc_opt_class();
              if (objc_opt_isKindOfClass()) {
                v152 = v151;
              }
              else {
                v152 = 0;
              }
              id v153 = v152;

              if ([v150 isEqual:&unk_2702B51F0])
              {
                v154 = v242;
                v118 = [(HMMTRAccessoryServer *)v242 numberOfReadValue:v153];

                if (v118)
                {
                  v187 = (void *)MEMORY[0x2533B64D0]();
                  v188 = v242;
                  v189 = HMFGetOSLogHandle();
                  id v7 = v232;
                  if (os_log_type_enabled(v189, OS_LOG_TYPE_INFO))
                  {
                    v190 = HMFGetLogIdentifier();
                    v191 = [(HMMTRAccessoryServer *)v188 primaryAccessory];
                    v192 = [v191 shortDescription];
                    *(_DWORD *)buf = 138544386;
                    v285 = v190;
                    __int16 v286 = 2112;
                    id v287 = v192;
                    __int16 v288 = 2112;
                    id v289 = v225;
                    __int16 v290 = 2112;
                    id v291 = v227;
                    __int16 v292 = 2112;
                    v293 = v118;
                    _os_log_impl(&dword_252495000, v189, OS_LOG_TYPE_INFO, "%{public}@%@ [Event no. %@, UpTime %@] WiFi Disconnection event with reason %@", buf, 0x34u);
                  }
                  v274 = @"wifiNetwork_ConnectionStatus";
                  v193 = [HMMTRAccessoryServerDiagnosticsEvent alloc];
                  v273 = v118;
                  v126 = [MEMORY[0x263EFF8C0] arrayWithObjects:&v273 count:1];
                  v127 = [(HMMTRAccessoryServerDiagnosticsEvent *)v193 initWithValues:v126];
                  v275 = v127;
                  v178 = NSDictionary;
                  v179 = &v275;
                  v180 = &v274;
LABEL_171:
                  v88 = [v178 dictionaryWithObjects:v179 forKeys:v180 count:1];
                  id v4 = v223;
                  v46 = v242;
LABEL_172:

                  id v10 = v225;
                  id v13 = v227;
                  goto LABEL_173;
                }
LABEL_196:
                v181 = (void *)MEMORY[0x2533B64D0]();
                v182 = v154;
                v183 = HMFGetOSLogHandle();
                id v4 = v223;
                id v7 = v232;
                v184 = v234;
                if (os_log_type_enabled(v183, OS_LOG_TYPE_ERROR))
                {
                  v185 = HMFGetLogIdentifier();
                  *(_DWORD *)buf = 138543618;
                  v285 = v185;
                  __int16 v286 = 2112;
                  id v287 = v223;
                  v186 = "%{public}@WiFiNetworkDiagnostics Disconnection event data has unexpected structure: %@";
LABEL_198:
                  _os_log_impl(&dword_252495000, v183, OS_LOG_TYPE_ERROR, v186, buf, 0x16u);
                }
LABEL_199:

LABEL_200:

                v88 = 0;
LABEL_201:
                id v10 = v225;
                id v13 = v227;
                goto LABEL_166;
              }
            }
            uint64_t v145 = [obj countByEnumeratingWithState:&v251 objects:v276 count:16];
            if (!v145)
            {
LABEL_141:

              v154 = v242;
              goto LABEL_196;
            }
          }
        }
LABEL_203:
        _HMFPreconditionFailure();
      }
      v160 = v137;
      v161 = (void *)MEMORY[0x2533B64D0]();
      v162 = self;
      v163 = HMFGetOSLogHandle();
      v164 = v234;
      if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR))
      {
        v165 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        v285 = v165;
        __int16 v286 = 2112;
        id v287 = v234;
        v166 = "%{public}@WiFiNetworkDiagnostics Disconnection event data type is unexpected: %@";
        goto LABEL_163;
      }
    }

    goto LABEL_165;
  }
  uint64_t v51 = *MEMORY[0x263F10B90];
  id v52 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10B90]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    v53 = v52;
  }
  else {
    v53 = 0;
  }
  id v54 = v53;

  if (!v54) {
    goto LABEL_202;
  }
  uint64_t v55 = [v54 objectForKeyedSubscript:*MEMORY[0x263F10C18]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v56 = v55;
  }
  else {
    uint64_t v56 = 0;
  }
  id v57 = v56;

  if (([v57 isEqual:*MEMORY[0x263F10C10]] & 1) == 0)
  {
    v155 = (void *)MEMORY[0x2533B64D0]();
    v156 = self;
    v157 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
    {
      HMFGetLogIdentifier();
      v159 = id v158 = v57;
      *(_DWORD *)buf = 138543618;
      v285 = v159;
      __int16 v286 = 2112;
      id v287 = v158;
      _os_log_impl(&dword_252495000, v157, OS_LOG_TYPE_ERROR, "%{public}@WiFiNetworkDiagnostics AssociationFailure event data type is unexpected: %@", buf, 0x16u);

      id v57 = v158;
    }

LABEL_145:

    goto LABEL_165;
  }
  id v228 = v13;
  id v58 = [v54 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v59 = v58;
  }
  else {
    id v59 = 0;
  }
  id v60 = v59;

  if (!v60) {
    goto LABEL_203;
  }
  v216 = v57;
  v219 = v54;
  v241 = self;
  long long v261 = 0u;
  long long v262 = 0u;
  long long v259 = 0u;
  long long v260 = 0u;
  id v61 = v60;
  uint64_t v62 = [v61 countByEnumeratingWithState:&v259 objects:v296 count:16];
  id obja = v61;
  if (!v62)
  {

    v64 = 0;
    v235 = 0;
    goto LABEL_149;
  }
  uint64_t v63 = v62;
  id v222 = v4;
  id v226 = v10;
  id v230 = v7;
  v235 = 0;
  v64 = 0;
  uint64_t v65 = *(void *)v260;
  uint64_t v66 = *MEMORY[0x263F10B88];
  do
  {
    for (uint64_t k = 0; k != v63; ++k)
    {
      if (*(void *)v260 != v65) {
        objc_enumerationMutation(obja);
      }
      long long v68 = *(void **)(*((void *)&v259 + 1) + 8 * k);
      long long v69 = [v68 objectForKeyedSubscript:v66];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        long long v70 = v69;
      }
      else {
        long long v70 = 0;
      }
      id v71 = v70;

      long long v72 = [v68 objectForKeyedSubscript:v51];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        long long v73 = v72;
      }
      else {
        long long v73 = 0;
      }
      id v74 = v73;

      if ([v71 isEqual:&unk_2702B51F0])
      {
        uint64_t v75 = [(HMMTRAccessoryServer *)v241 numberOfReadValue:v74];
        v76 = v64;
        v64 = (void *)v75;
      }
      else
      {
        if (![v71 isEqual:&unk_2702B5208]) {
          goto LABEL_72;
        }
        uint64_t v77 = [(HMMTRAccessoryServer *)v241 numberOfReadValue:v74];
        v76 = v235;
        v235 = (void *)v77;
      }

LABEL_72:
    }
    uint64_t v63 = [obja countByEnumeratingWithState:&v259 objects:v296 count:16];
  }
  while (v63);

  id v10 = v226;
  id v7 = v230;
  if (!v64)
  {
LABEL_149:
    id v13 = v228;
    goto LABEL_150;
  }
  id v13 = v228;
  if (v235)
  {
    v78 = (void *)MEMORY[0x2533B64D0]();
    v79 = v241;
    v80 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v80, OS_LOG_TYPE_INFO))
    {
      v81 = HMFGetLogIdentifier();
      v82 = [(HMMTRAccessoryServer *)v79 primaryAccessory];
      v83 = [v82 shortDescription];
      *(_DWORD *)buf = 138544642;
      v285 = v81;
      __int16 v286 = 2112;
      id v287 = v83;
      __int16 v288 = 2112;
      id v289 = v226;
      __int16 v290 = 2112;
      id v291 = v228;
      __int16 v292 = 2112;
      v293 = v64;
      __int16 v294 = 2112;
      v295 = v235;
      _os_log_impl(&dword_252495000, v80, OS_LOG_TYPE_INFO, "%{public}@%@ [Event no. %@, UpTime %@] WiFi Association Failure event with cause %@, status %@", buf, 0x3Eu);

      id v10 = v226;
    }

    v282 = @"wifiNetwork_AssociationFailure";
    v84 = [HMMTRAccessoryServerDiagnosticsEvent alloc];
    v281[0] = v64;
    v281[1] = v235;
    v85 = [MEMORY[0x263EFF8C0] arrayWithObjects:v281 count:2];
    v86 = [(HMMTRAccessoryServerDiagnosticsEvent *)v84 initWithValues:v85];
    v283 = v86;
    char v87 = 1;
    v88 = [NSDictionary dictionaryWithObjects:&v283 forKeys:&v282 count:1];

    id v4 = v222;
    goto LABEL_153;
  }
LABEL_150:
  v167 = (void *)MEMORY[0x2533B64D0]();
  v168 = v241;
  v169 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR))
  {
    v170 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    v285 = v170;
    __int16 v286 = 2112;
    id v287 = v4;
    _os_log_impl(&dword_252495000, v169, OS_LOG_TYPE_ERROR, "%{public}@WiFiNetworkDiagnostics AssociationFailure event data has unexpected structure: %@", buf, 0x16u);
  }
  char v87 = 0;
  v88 = 0;
LABEL_153:

  v46 = v241;
  if (v87)
  {
LABEL_173:
    if (v88)
    {
      long long v249 = 0u;
      long long v250 = 0u;
      long long v247 = 0u;
      long long v248 = 0u;
      v194 = [(HAPAccessoryServer *)v46 accessories];
      uint64_t v220 = [v194 countByEnumeratingWithState:&v247 objects:v272 count:16];
      if (v220)
      {
        uint64_t v195 = *(void *)v248;
        id v224 = v4;
        id v225 = v10;
        id v227 = v13;
        v233 = v7;
        id objb = v194;
        uint64_t v217 = *(void *)v248;
        do
        {
          uint64_t v196 = 0;
          do
          {
            if (*(void *)v248 != v195) {
              objc_enumerationMutation(v194);
            }
            v197 = *(void **)(*((void *)&v247 + 1) + 8 * v196);
            long long v243 = 0u;
            long long v244 = 0u;
            long long v245 = 0u;
            long long v246 = 0u;
            v236 = v197;
            v198 = [v197 services];
            uint64_t v199 = [v198 countByEnumeratingWithState:&v243 objects:v271 count:16];
            if (v199)
            {
              uint64_t v200 = v199;
              uint64_t v201 = *(void *)v244;
              while (2)
              {
                for (uint64_t m = 0; m != v200; ++m)
                {
                  if (*(void *)v244 != v201) {
                    objc_enumerationMutation(v198);
                  }
                  v203 = *(void **)(*((void *)&v243 + 1) + 8 * m);
                  objc_opt_class();
                  if (objc_opt_isKindOfClass())
                  {
                    v204 = [v203 endpoint];
                    v205 = [v233 endpoint];
                    int v206 = [v204 isEqualToNumber:v205];

                    if (v206)
                    {
                      v211 = (void *)MEMORY[0x2533B64D0]();
                      v212 = v46;
                      v213 = HMFGetOSLogHandle();
                      if (os_log_type_enabled(v213, OS_LOG_TYPE_INFO))
                      {
                        v214 = HMFGetLogIdentifier();
                        *(_DWORD *)buf = 138543874;
                        v285 = v214;
                        __int16 v286 = 2112;
                        id v287 = v88;
                        __int16 v288 = 2112;
                        id v289 = v236;
                        _os_log_impl(&dword_252495000, v213, OS_LOG_TYPE_INFO, "%{public}@Calling delegate to handle diagnostics event: %@ for accessory: %@", buf, 0x20u);
                      }
                      v215 = [(HMMTRAccessoryServer *)v212 diagnosticsEventDelegate];
                      [v215 handleDiagnosticsEvents:v88 forAccessory:v236];

                      id v4 = v224;
                      id v7 = v233;
                      goto LABEL_201;
                    }
                  }
                }
                uint64_t v200 = [v198 countByEnumeratingWithState:&v243 objects:v271 count:16];
                if (v200) {
                  continue;
                }
                break;
              }
            }

            ++v196;
            uint64_t v195 = v217;
            id v13 = v227;
            id v7 = v233;
            id v10 = v225;
            v194 = objb;
          }
          while (v196 != v220);
          id v4 = v224;
          uint64_t v220 = [objb countByEnumeratingWithState:&v247 objects:v272 count:16];
        }
        while (v220);
      }

      v207 = (void *)MEMORY[0x2533B64D0]();
      v208 = v46;
      v209 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v209, OS_LOG_TYPE_ERROR))
      {
        v210 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        v285 = v210;
        __int16 v286 = 2112;
        id v287 = v88;
        _os_log_impl(&dword_252495000, v209, OS_LOG_TYPE_ERROR, "%{public}@Diagnostic event did not find any destination accessory: %@", buf, 0x16u);
      }
    }
  }
LABEL_166:
}

void __69__HMMTRAccessoryServer_DiagnosticsInternal___handleDiagnosticsEvent___block_invoke(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    id v13 = [*(id *)(a1 + 32) primaryAccessory];
    uint64_t v6 = [v13 shortDescription];
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v9 = *(void *)(a1 + 40);
    id v10 = [*(id *)(a1 + 32) hmdHAPAccessoryDelegate];
    *(_DWORD *)buf = 138544642;
    uint64_t v11 = @"Yes";
    int v15 = v5;
    if (!v10) {
      uint64_t v11 = @"No";
    }
    __int16 v16 = 2112;
    int v17 = v6;
    __int16 v18 = 2112;
    uint64_t v19 = v9;
    __int16 v20 = 2112;
    uint64_t v21 = v7;
    __int16 v22 = 2112;
    uint64_t v23 = v8;
    __int16 v24 = 2112;
    id v25 = v11;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@%@ [Event no. %@, UpTime %@] Startup Event %@, delegated: %@", buf, 0x3Eu);
  }
  uint64_t v12 = [*(id *)(a1 + 32) hmdHAPAccessoryDelegate];
  [v12 handleStartUpWithEventNumber:*(void *)(a1 + 40)];
}

- (id)errorCountOfWiFiNetworkDiagnostics:(id)a3
{
  id v4 = [a3 readAttributeOverrunCountWithParams:0];
  id v5 = [(HMMTRAccessoryServer *)self numberOfReadValue:v4];

  return v5;
}

- (id)packetCountOfWiFiNetworkDiagnostics:(id)a3
{
  id v4 = a3;
  id v5 = [v4 readAttributePacketUnicastTxCountWithParams:0];
  uint64_t v6 = [(HMMTRAccessoryServer *)self numberOfReadValue:v5];

  if (!v6) {
    goto LABEL_6;
  }
  int v7 = [v6 unsignedLongValue];
  uint64_t v8 = [v4 readAttributePacketMulticastTxCountWithParams:0];
  uint64_t v9 = [(HMMTRAccessoryServer *)self numberOfReadValue:v8];

  if (!v9) {
    goto LABEL_6;
  }
  int v10 = [v9 unsignedLongValue];
  uint64_t v11 = [v4 readAttributePacketUnicastRxCountWithParams:0];
  uint64_t v12 = [(HMMTRAccessoryServer *)self numberOfReadValue:v11];

  if (!v12) {
    goto LABEL_6;
  }
  int v13 = [v12 unsignedLongValue];
  uint64_t v14 = [v4 readAttributePacketMulticastRxCountWithParams:0];
  int v15 = [(HMMTRAccessoryServer *)self numberOfReadValue:v14];

  if (v15)
  {
    int v16 = [v15 unsignedLongValue];
    int v17 = [NSNumber numberWithUnsignedInt:(v10 + v7 + v13 + v16)];
  }
  else
  {
LABEL_6:
    int v17 = 0;
  }

  return v17;
}

- (id)highestRSSIofThreadNetworkDiagnostics:(id)a3
{
  uint64_t v88 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [v4 readAttributeNeighborTableWithParams:0];
  uint64_t v6 = v5;
  if (v5)
  {
    uint64_t v70 = *MEMORY[0x263F10C18];
    int v7 = objc_msgSend(v5, "objectForKeyedSubscript:");
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    id v9 = v8;

    if ([v9 isEqual:*MEMORY[0x263F10B68]])
    {
      uint64_t v66 = *MEMORY[0x263F10C30];
      int v10 = objc_msgSend(v6, "objectForKeyedSubscript:");
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 0;
      }
      id v12 = v11;

      if (!v12) {
        goto LABEL_75;
      }
      id v60 = v6;
      id v61 = v4;
      long long v80 = 0u;
      long long v81 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      id v13 = v12;
      uint64_t v69 = [v13 countByEnumeratingWithState:&v78 objects:v83 count:16];
      if (!v69)
      {
        v64 = 0;
        goto LABEL_66;
      }
      v64 = 0;
      uint64_t v68 = *(void *)v79;
      uint64_t v72 = *MEMORY[0x263F10B90];
      uint64_t v67 = *MEMORY[0x263F10C10];
      uint64_t v14 = *MEMORY[0x263F10B88];
      uint64_t v65 = self;
      id obj = v13;
LABEL_12:
      uint64_t v15 = 0;
      while (1)
      {
        int v16 = v9;
        if (*(void *)v79 != v68) {
          objc_enumerationMutation(obj);
        }
        int v17 = objc_msgSend(*(id *)(*((void *)&v78 + 1) + 8 * v15), "objectForKeyedSubscript:", v72, v60, v61);
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          __int16 v18 = v17;
        }
        else {
          __int16 v18 = 0;
        }
        id v19 = v18;

        if (!v19)
        {
LABEL_73:
          _HMFPreconditionFailure();
LABEL_74:
          _HMFPreconditionFailure();
LABEL_75:
          _HMFPreconditionFailure();
        }
        __int16 v20 = [v19 objectForKeyedSubscript:v70];
        objc_opt_class();
        uint64_t v21 = (objc_opt_isKindOfClass() & 1) != 0 ? v20 : 0;
        id v9 = v21;

        if (([v9 isEqual:v67] & 1) == 0) {
          break;
        }
        __int16 v22 = [v19 objectForKeyedSubscript:v66];
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          uint64_t v23 = v22;
        }
        else {
          uint64_t v23 = 0;
        }
        id v24 = v23;

        if (!v24) {
          goto LABEL_74;
        }
        uint64_t v73 = v15;
        long long v76 = 0u;
        long long v77 = 0u;
        long long v74 = 0u;
        long long v75 = 0u;
        id v25 = v24;
        uint64_t v26 = [v25 countByEnumeratingWithState:&v74 objects:v82 count:16];
        if (v26)
        {
          uint64_t v27 = v26;
          id v71 = v9;
          uint64_t v28 = *(void *)v75;
LABEL_29:
          uint64_t v29 = 0;
          while (1)
          {
            if (*(void *)v75 != v28) {
              objc_enumerationMutation(v25);
            }
            id v30 = *(void **)(*((void *)&v74 + 1) + 8 * v29);
            __int16 v31 = [v30 objectForKeyedSubscript:v14];
            objc_opt_class();
            if (objc_opt_isKindOfClass()) {
              id v32 = v31;
            }
            else {
              id v32 = 0;
            }
            id v33 = v32;

            if (!v33)
            {
              _HMFPreconditionFailure();
              goto LABEL_73;
            }
            if ([v33 isEqual:&unk_2702B5238]) {
              break;
            }

            if (v27 == ++v29)
            {
              uint64_t v27 = [v25 countByEnumeratingWithState:&v74 objects:v82 count:16];
              if (!v27)
              {
                id v9 = v71;
                self = v65;
                goto LABEL_53;
              }
              goto LABEL_29;
            }
          }
          uint64_t v34 = [v30 objectForKeyedSubscript:v72];
          objc_opt_class();
          if (objc_opt_isKindOfClass()) {
            uint64_t v35 = v34;
          }
          else {
            uint64_t v35 = 0;
          }
          id v36 = v35;

          if (!v36) {
            goto LABEL_73;
          }
          self = v65;
          uint64_t v37 = [(HMMTRAccessoryServer *)v65 numberOfReadValue:v36];
          uint64_t v38 = v37;
          if (v37)
          {
            id v9 = v71;
            if (!v64 || (uint64_t v39 = [v37 integerValue], v39 > objc_msgSend(v64, "integerValue")))
            {
              id v40 = v38;

              v64 = v40;
            }
          }
          else
          {
            context = (void *)MEMORY[0x2533B64D0]();
            id v41 = v65;
            id v42 = HMFGetOSLogHandle();
            id v9 = v71;
            if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
            {
              uint64_t v43 = HMFGetLogIdentifier();
              *(_DWORD *)buf = 138543362;
              uint64_t v85 = v43;
              v44 = (void *)v43;
              _os_log_impl(&dword_252495000, v42, OS_LOG_TYPE_ERROR, "%{public}@ThreadNetworkDiagnostics NeighborTable AverageRssi entry is not a number", buf, 0xCu);

              self = v65;
            }
          }

          int v17 = v34;
        }
        else
        {
          int v17 = v19;
        }
LABEL_53:

        uint64_t v15 = v73 + 1;
        if (v73 + 1 == v69)
        {
          id v13 = obj;
          uint64_t v69 = [obj countByEnumeratingWithState:&v78 objects:v83 count:16];
          if (!v69)
          {
LABEL_66:

            id v58 = v64;
            uint64_t v49 = v58;
            uint64_t v6 = v60;
            id v4 = v61;
            goto LABEL_67;
          }
          goto LABEL_12;
        }
      }
      id v54 = (void *)MEMORY[0x2533B64D0]();
      uint64_t v55 = self;
      uint64_t v56 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        id v57 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        uint64_t v85 = (uint64_t)v57;
        __int16 v86 = 2112;
        id v87 = v9;
        _os_log_impl(&dword_252495000, v56, OS_LOG_TYPE_ERROR, "%{public}@ThreadNetworkDiagnostics NeighborTable entry is not a structure but a %@", buf, 0x16u);
      }

      id v13 = obj;
      uint64_t v49 = 0;
      uint64_t v6 = v60;
      id v4 = v61;
      id v58 = v64;
LABEL_67:
    }
    else
    {
      int v50 = (void *)MEMORY[0x2533B64D0]();
      uint64_t v51 = self;
      id v52 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        v53 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        uint64_t v85 = (uint64_t)v53;
        __int16 v86 = 2112;
        id v87 = v9;
        _os_log_impl(&dword_252495000, v52, OS_LOG_TYPE_ERROR, "%{public}@ThreadNetworkDiagnostics NeighborTable attribute is not an array but a %@", buf, 0x16u);
      }
      uint64_t v49 = 0;
    }
  }
  else
  {
    id v45 = (void *)MEMORY[0x2533B64D0]();
    v46 = self;
    id v47 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      int v48 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v85 = (uint64_t)v48;
      _os_log_impl(&dword_252495000, v47, OS_LOG_TYPE_ERROR, "%{public}@NeighborTable missing from ThreadNetworkDiagnostics", buf, 0xCu);
    }
    uint64_t v49 = 0;
  }

  return v49;
}

- (id)errorCountOfThreadNetworkDiagnostics:(id)a3
{
  id v4 = a3;
  id v5 = [v4 readAttributeTxDirectMaxRetryExpiryCountWithParams:0];
  uint64_t v6 = [(HMMTRAccessoryServer *)self numberOfReadValue:v5];

  if (!v6) {
    goto LABEL_13;
  }
  int v7 = [v6 unsignedLongValue];
  uint64_t v8 = [v4 readAttributeTxIndirectMaxRetryExpiryCountWithParams:0];
  id v9 = [(HMMTRAccessoryServer *)self numberOfReadValue:v8];

  if (!v9) {
    goto LABEL_13;
  }
  int v10 = [v9 unsignedLongValue];
  uint64_t v11 = [v4 readAttributeTxErrCcaCountWithParams:0];
  id v12 = [(HMMTRAccessoryServer *)self numberOfReadValue:v11];

  if (!v12) {
    goto LABEL_13;
  }
  int v13 = [v12 unsignedLongValue];
  uint64_t v14 = [v4 readAttributeTxErrAbortCountWithParams:0];
  uint64_t v15 = [(HMMTRAccessoryServer *)self numberOfReadValue:v14];

  if (!v15) {
    goto LABEL_13;
  }
  int v16 = [v15 unsignedLongValue];
  int v17 = [v4 readAttributeTxErrBusyChannelCountWithParams:0];
  __int16 v18 = [(HMMTRAccessoryServer *)self numberOfReadValue:v17];

  if (!v18) {
    goto LABEL_13;
  }
  int v19 = [v18 unsignedLongValue];
  __int16 v20 = [v4 readAttributeRxErrNoFrameCountWithParams:0];
  uint64_t v21 = [(HMMTRAccessoryServer *)self numberOfReadValue:v20];

  if (!v21) {
    goto LABEL_13;
  }
  int v39 = [v21 unsignedLongValue];
  __int16 v22 = [v4 readAttributeRxErrUnknownNeighborCountWithParams:0];
  uint64_t v23 = [(HMMTRAccessoryServer *)self numberOfReadValue:v22];

  if (!v23) {
    goto LABEL_13;
  }
  int v38 = [v23 unsignedLongValue];
  id v24 = [v4 readAttributeRxErrInvalidSrcAddrCountWithParams:0];
  id v25 = [(HMMTRAccessoryServer *)self numberOfReadValue:v24];

  if (!v25) {
    goto LABEL_13;
  }
  int v37 = [v25 unsignedLongValue];
  uint64_t v26 = [v4 readAttributeRxErrSecCountWithParams:0];
  uint64_t v27 = [(HMMTRAccessoryServer *)self numberOfReadValue:v26];

  if (!v27) {
    goto LABEL_13;
  }
  int v36 = [v27 unsignedLongValue];
  uint64_t v28 = [v4 readAttributeRxErrFcsCountWithParams:0];
  uint64_t v29 = [(HMMTRAccessoryServer *)self numberOfReadValue:v28];

  if (!v29) {
    goto LABEL_13;
  }
  int v30 = [v29 unsignedLongValue];
  __int16 v31 = [v4 readAttributeRxErrOtherCountWithParams:0];
  id v32 = [(HMMTRAccessoryServer *)self numberOfReadValue:v31];

  if (v32)
  {
    int v33 = [v32 unsignedLongValue];
    uint64_t v34 = [NSNumber numberWithUnsignedInt:(v10 + v7 + v13 + v16 + v19 + v39 + v38 + v37 + v36 + v30 + v33)];
  }
  else
  {
LABEL_13:
    uint64_t v34 = 0;
  }

  return v34;
}

- (id)packetCountOfThreadNetworkDiagnostics:(id)a3
{
  id v4 = a3;
  id v5 = [v4 readAttributeTxTotalCountWithParams:0];
  uint64_t v6 = [(HMMTRAccessoryServer *)self numberOfReadValue:v5];

  if (v6
    && (int v7 = [v6 unsignedLongValue],
        [v4 readAttributeRxTotalCountWithParams:0],
        uint64_t v8 = objc_claimAutoreleasedReturnValue(),
        [(HMMTRAccessoryServer *)self numberOfReadValue:v8],
        id v9 = objc_claimAutoreleasedReturnValue(),
        v6,
        v8,
        v9))
  {
    int v10 = [v9 unsignedLongValue];
    uint64_t v11 = [NSNumber numberWithUnsignedInt:(v10 + v7)];
  }
  else
  {
    uint64_t v11 = 0;
  }

  return v11;
}

- (id)connectedNetworkIDFromReadValue:(id)a3
{
  uint64_t v78 = *MEMORY[0x263EF8340];
  id v3 = a3;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = *MEMORY[0x263F10C18];
    uint64_t v6 = [v3 objectForKeyedSubscript:*MEMORY[0x263F10C18]];
    unint64_t v7 = 0x263F08000uLL;
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = 0;
    }
    id v9 = v8;

    int v10 = [v9 isEqual:*MEMORY[0x263F10B68]];
    uint64_t v11 = 0;
    id v12 = 0;
    if (v10)
    {
      id v54 = v9;
      uint64_t v55 = v4;
      uint64_t v59 = *MEMORY[0x263F10C30];
      int v13 = objc_msgSend(v4, "objectForKeyedSubscript:");
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = 0;
      }
      id v15 = v14;

      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      id obj = v15;
      uint64_t v16 = [obj countByEnumeratingWithState:&v72 objects:v77 count:16];
      if (v16)
      {
        uint64_t v17 = v16;
        char v18 = 0;
        uint64_t v65 = 0;
        uint64_t v19 = *(void *)v73;
        uint64_t v67 = *MEMORY[0x263F10B90];
        uint64_t v20 = *MEMORY[0x263F10C10];
        uint64_t v21 = *MEMORY[0x263F10B88];
        uint64_t v57 = *(void *)v73;
        uint64_t v58 = v5;
        uint64_t v56 = *MEMORY[0x263F10C10];
        while (1)
        {
          uint64_t v22 = 0;
          uint64_t v63 = v17;
          do
          {
            if (*(void *)v73 != v19) {
              objc_enumerationMutation(obj);
            }
            if (v18) {
              goto LABEL_54;
            }
            [*(id *)(*((void *)&v72 + 1) + 8 * v22) objectForKeyedSubscript:v67];
            id v24 = v23 = v20;
            objc_opt_class();
            if (objc_opt_isKindOfClass()) {
              id v25 = v24;
            }
            else {
              id v25 = 0;
            }
            id v26 = v25;

            uint64_t v27 = [v26 objectForKeyedSubscript:v5];
            unint64_t v28 = v7;
            objc_opt_class();
            if (objc_opt_isKindOfClass()) {
              uint64_t v29 = v27;
            }
            else {
              uint64_t v29 = 0;
            }
            uint64_t v30 = v5;
            id v31 = v29;

            uint64_t v20 = v23;
            v64 = v31;
            if ([v31 isEqual:v23])
            {
              id v61 = v26;
              uint64_t v62 = v22;
              id v32 = [v26 objectForKeyedSubscript:v59];
              objc_opt_class();
              if (objc_opt_isKindOfClass()) {
                int v33 = v32;
              }
              else {
                int v33 = 0;
              }
              id v34 = v33;

              long long v70 = 0u;
              long long v71 = 0u;
              long long v68 = 0u;
              long long v69 = 0u;
              id v35 = v34;
              uint64_t v36 = [v35 countByEnumeratingWithState:&v68 objects:v76 count:16];
              if (v36)
              {
                uint64_t v37 = v36;
                uint64_t v38 = *(void *)v69;
                do
                {
                  for (uint64_t i = 0; i != v37; ++i)
                  {
                    if (*(void *)v69 != v38) {
                      objc_enumerationMutation(v35);
                    }
                    id v40 = *(void **)(*((void *)&v68 + 1) + 8 * i);
                    id v41 = [v40 objectForKeyedSubscript:v21];
                    objc_opt_class();
                    if (objc_opt_isKindOfClass()) {
                      id v42 = v41;
                    }
                    else {
                      id v42 = 0;
                    }
                    id v43 = v42;

                    if ([v43 isEqual:&unk_2702B5208])
                    {
                      v44 = [v40 objectForKeyedSubscript:v67];
                      objc_opt_class();
                      if (objc_opt_isKindOfClass()) {
                        id v45 = v44;
                      }
                      else {
                        id v45 = 0;
                      }
                      id v46 = v45;

                      id v47 = [(HMMTRAccessoryServer *)self numberOfReadValue:v46];

                      if ([v47 BOOLValue]) {
                        char v18 = 1;
                      }
                    }
                    else
                    {
                      if (![v43 isEqual:&unk_2702B51F0]) {
                        goto LABEL_45;
                      }
                      int v48 = [v40 objectForKeyedSubscript:v67];
                      objc_opt_class();
                      if (objc_opt_isKindOfClass()) {
                        uint64_t v49 = v48;
                      }
                      else {
                        uint64_t v49 = 0;
                      }
                      id v47 = v49;

                      uint64_t v50 = [(HMMTRAccessoryServer *)self stringOfReadValue:v47];

                      uint64_t v65 = (void *)v50;
                    }

LABEL_45:
                  }
                  uint64_t v37 = [v35 countByEnumeratingWithState:&v68 objects:v76 count:16];
                }
                while (v37);
              }

              uint64_t v19 = v57;
              uint64_t v5 = v58;
              unint64_t v7 = 0x263F08000;
              uint64_t v22 = v62;
              uint64_t v51 = v63;
              uint64_t v20 = v56;
              id v26 = v61;
            }
            else
            {
              uint64_t v5 = v30;
              unint64_t v7 = v28;
              uint64_t v51 = v63;
            }

            ++v22;
          }
          while (v22 != v51);
          uint64_t v17 = [obj countByEnumeratingWithState:&v72 objects:v77 count:16];
          if (!v17) {
            goto LABEL_54;
          }
        }
      }
      char v18 = 0;
      uint64_t v65 = 0;
LABEL_54:

      id v12 = v65;
      if (v18) {
        uint64_t v11 = v65;
      }
      else {
        uint64_t v11 = 0;
      }
      id v9 = v54;
      id v4 = v55;
    }
    id v52 = v11;
  }
  else
  {
    id v52 = 0;
  }

  return v52;
}

- (id)stringOfReadValue:(id)a3
{
  id v3 = a3;
  id v4 = v3;
  if (!v3)
  {
    char v18 = 0;
    goto LABEL_24;
  }
  uint64_t v5 = [v3 objectForKeyedSubscript:*MEMORY[0x263F10C18]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  id v7 = v6;

  if ([v7 isEqual:*MEMORY[0x263F10BF8]])
  {
    uint64_t v8 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      id v9 = v8;
    }
    else {
      id v9 = 0;
    }
    id v10 = v9;

    id v11 = [NSString alloc];
    id v12 = v10;
    int v13 = (__CFString *)objc_msgSend(v11, "initWithBytes:length:encoding:", objc_msgSend(v12, "bytes"), objc_msgSend(v12, "length"), 4);
    if (!v13)
    {
      id v12 = v12;
      uint64_t v14 = [v12 bytes];
      if ([v12 length])
      {
        unint64_t v15 = 0;
        uint64_t v16 = &stru_2702A0B38;
        do
        {
          uint64_t v17 = v16;
          uint64_t v16 = [(__CFString *)v16 stringByAppendingFormat:@"%X", *(unsigned __int8 *)(v14 + v15)];

          ++v15;
        }
        while ([v12 length] > v15);
      }
      else
      {
        uint64_t v16 = &stru_2702A0B38;
      }
      goto LABEL_21;
    }
  }
  else
  {
    if (![v7 isEqual:*MEMORY[0x263F10C20]])
    {
      uint64_t v16 = 0;
      goto LABEL_23;
    }
    id v12 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v19 = v12;
    }
    else {
      uint64_t v19 = 0;
    }
    int v13 = v19;
  }
  uint64_t v16 = v13;
LABEL_21:

LABEL_23:
  char v18 = v16;

LABEL_24:
  return v18;
}

- (id)dataOfReadValue:(id)a3
{
  id v3 = a3;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = [v3 objectForKeyedSubscript:*MEMORY[0x263F10C18]];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    id v7 = v6;

    int v8 = [v7 isEqual:*MEMORY[0x263F10BF8]];
    id v9 = 0;
    if (v8)
    {
      id v10 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        id v11 = v10;
      }
      else {
        id v11 = 0;
      }
      id v9 = v11;
    }
    id v12 = v9;
  }
  else
  {
    id v12 = 0;
  }

  return v12;
}

- (id)numberOfReadValue:(id)a3
{
  id v3 = a3;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = [v3 objectForKeyedSubscript:*MEMORY[0x263F10C18]];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    id v7 = v6;

    if (([v7 isEqual:*MEMORY[0x263F10C08]] & 1) != 0
      || ([v7 isEqual:*MEMORY[0x263F10C28]] & 1) != 0
      || ([v7 isEqual:*MEMORY[0x263F10B78]] & 1) != 0
      || ([v7 isEqual:*MEMORY[0x263F10BE0]] & 1) != 0
      || [v7 isEqual:*MEMORY[0x263F10BA8]])
    {
      int v8 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        id v9 = v8;
      }
      else {
        id v9 = 0;
      }
      id v10 = v9;
    }
    else
    {
      id v10 = 0;
    }
  }
  else
  {
    id v10 = 0;
  }

  return v10;
}

- (id)networkCommissioningClusterFromEndpoints:(id)a3 topology:(id)a4 device:(id)a5 definitelyUnsupported:(BOOL *)a6
{
  id v10 = a5;
  id v11 = [(HMMTRAccessoryServer *)self endpointForDiagnosticCluster:&unk_2702B5178 clusterName:@"NetworkCommissioningCluster" amongEndpoints:a3 topology:a4 device:v10 definitelyUnsupported:a6];
  if (v11)
  {
    id v12 = objc_alloc(MEMORY[0x263F10D10]);
    uint64_t v13 = [v11 unsignedShortValue];
    uint64_t v14 = [(HAPAccessoryServer *)self clientQueue];
    unint64_t v15 = (void *)[v12 initWithDevice:v10 endpoint:v13 queue:v14];
  }
  else
  {
    unint64_t v15 = 0;
  }

  return v15;
}

- (id)wifiNetworkDiagnosticsClusterFromEndpoints:(id)a3 topology:(id)a4 device:(id)a5 definitelyUnsupported:(BOOL *)a6
{
  id v10 = a5;
  id v11 = [(HMMTRAccessoryServer *)self endpointForDiagnosticCluster:&unk_2702B51D8 clusterName:@"WiFiNetworkDiagnostics" amongEndpoints:a3 topology:a4 device:v10 definitelyUnsupported:a6];
  if (v11)
  {
    id v12 = objc_alloc(MEMORY[0x263F10D60]);
    uint64_t v13 = [(HAPAccessoryServer *)self clientQueue];
    uint64_t v14 = (void *)[v12 initWithDevice:v10 endpointID:v11 queue:v13];
  }
  else
  {
    uint64_t v14 = 0;
  }

  return v14;
}

- (id)threadNetworkDiagnosticsClusterFromEndpoints:(id)a3 topology:(id)a4 device:(id)a5 definitelyUnsupported:(BOOL *)a6
{
  id v10 = a5;
  id v11 = [(HMMTRAccessoryServer *)self endpointForDiagnosticCluster:&unk_2702B51C0 clusterName:@"ThreadNetworkDiagnostics" amongEndpoints:a3 topology:a4 device:v10 definitelyUnsupported:a6];
  if (v11)
  {
    id v12 = objc_alloc(MEMORY[0x263F10D58]);
    uint64_t v13 = [(HAPAccessoryServer *)self clientQueue];
    uint64_t v14 = (void *)[v12 initWithDevice:v10 endpointID:v11 queue:v13];
  }
  else
  {
    uint64_t v14 = 0;
  }

  return v14;
}

- (id)generalDiagnosticsClusterFromEndpoints:(id)a3 topology:(id)a4 device:(id)a5 definitelyUnsupported:(BOOL *)a6
{
  id v10 = a5;
  id v11 = [(HMMTRAccessoryServer *)self endpointForDiagnosticCluster:&unk_2702B5190 clusterName:@"GeneralDiagnostics" amongEndpoints:a3 topology:a4 device:v10 definitelyUnsupported:a6];
  if (v11)
  {
    id v12 = objc_alloc(MEMORY[0x263F10CF8]);
    uint64_t v13 = [(HAPAccessoryServer *)self clientQueue];
    uint64_t v14 = (void *)[v12 initWithDevice:v10 endpointID:v11 queue:v13];
  }
  else
  {
    uint64_t v14 = 0;
  }

  return v14;
}

- (id)endpointForDiagnosticCluster:(id)a3 clusterName:(id)a4 amongEndpoints:(id)a5 topology:(id)a6 device:(id)a7 definitelyUnsupported:(BOOL *)a8
{
  uint64_t v104 = *MEMORY[0x263EF8340];
  id v13 = a3;
  id v14 = a4;
  id v15 = a5;
  id v16 = a6;
  id v17 = a7;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  id v18 = v15;
  uint64_t v19 = [v18 countByEnumeratingWithState:&v92 objects:v103 count:16];
  if (!v19)
  {

LABEL_40:
    id v60 = (void *)MEMORY[0x2533B64D0]();
    id v61 = self;
    uint64_t v62 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v63 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543874;
      v98 = v63;
      __int16 v99 = 2112;
      id v100 = v14;
      __int16 v101 = 2112;
      id v102 = v18;
      _os_log_impl(&dword_252495000, v62, OS_LOG_TYPE_DEBUG, "%{public}@No %@ cluster in any endpoints %@.", buf, 0x20u);
    }
    id v54 = 0;
    *a8 = 1;
    goto LABEL_43;
  }
  uint64_t v20 = v19;
  v83 = self;
  id v85 = v17;
  id v86 = v14;
  int v21 = 0;
  uint64_t v22 = *(void *)v93;
  while (2)
  {
    for (uint64_t i = 0; i != v20; ++i)
    {
      if (*(void *)v93 != v22) {
        objc_enumerationMutation(v18);
      }
      id v24 = *(void **)(*((void *)&v92 + 1) + 8 * i);
      id v25 = [v16 getClustersInUseAtEndpoint:v24];
      if ([v25 containsObject:v13])
      {
        uint64_t v56 = (void *)MEMORY[0x2533B64D0]();
        uint64_t v57 = v83;
        uint64_t v58 = HMFGetOSLogHandle();
        id v14 = v86;
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v59 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543874;
          v98 = v59;
          __int16 v99 = 2112;
          id v100 = v86;
          __int16 v101 = 2112;
          id v102 = v24;
          _os_log_impl(&dword_252495000, v58, OS_LOG_TYPE_DEBUG, "%{public}@%@ cluster found in endpoint %@", buf, 0x20u);
        }
        id v54 = v24;

        id v17 = v85;
        goto LABEL_43;
      }
      v21 |= [v24 isEqual:&unk_2702B51F0];
    }
    uint64_t v20 = [v18 countByEnumeratingWithState:&v92 objects:v103 count:16];
    if (v20) {
      continue;
    }
    break;
  }

  id v17 = v85;
  id v14 = v86;
  self = v83;
  if ((v21 & 1) == 0) {
    goto LABEL_40;
  }
  id v26 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v27 = v83;
  unint64_t v28 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v29 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    v98 = v29;
    __int16 v99 = 2112;
    id v100 = v86;
    _os_log_impl(&dword_252495000, v28, OS_LOG_TYPE_DEBUG, "%{public}@Checking endpoint 0 for %@ cluster", buf, 0x16u);
  }
  id v30 = objc_alloc(MEMORY[0x263F10CE8]);
  id v31 = [(HAPAccessoryServer *)v27 clientQueue];
  id v32 = (void *)[v30 initWithDevice:v85 endpointID:&unk_2702B51F0 queue:v31];

  int v33 = [v32 readAttributeServerListWithParams:0];
  long long v81 = v33;
  if (v33)
  {
    id v34 = v33;
    v84 = v27;
    id v35 = [v33 objectForKeyedSubscript:*MEMORY[0x263F10C18]];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v36 = v35;
    }
    else {
      uint64_t v36 = 0;
    }
    id v37 = v36;

    long long v80 = v37;
    if ([v37 isEqual:*MEMORY[0x263F10B68]])
    {
      long long v79 = v32;
      uint64_t v38 = [v34 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        int v39 = v38;
      }
      else {
        int v39 = 0;
      }
      id v40 = v39;

      if (!v40) {
LABEL_59:
      }
        _HMFPreconditionFailure();
      long long v90 = 0u;
      long long v91 = 0u;
      long long v88 = 0u;
      long long v89 = 0u;
      id obj = v40;
      uint64_t v41 = [obj countByEnumeratingWithState:&v88 objects:v96 count:16];
      if (!v41) {
        goto LABEL_33;
      }
      uint64_t v42 = v41;
      uint64_t v43 = *(void *)v89;
      uint64_t v44 = *MEMORY[0x263F10B90];
LABEL_23:
      uint64_t v45 = 0;
      while (1)
      {
        if (*(void *)v89 != v43) {
          objc_enumerationMutation(obj);
        }
        id v46 = [*(id *)(*((void *)&v88 + 1) + 8 * v45) objectForKeyedSubscript:v44];
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          id v47 = v46;
        }
        else {
          id v47 = 0;
        }
        id v48 = v47;

        if (!v48)
        {
          _HMFPreconditionFailure();
          goto LABEL_59;
        }
        uint64_t v49 = [(HMMTRAccessoryServer *)v84 numberOfReadValue:v48];
        if ([v49 isEqual:v13]) {
          break;
        }

        if (v42 == ++v45)
        {
          uint64_t v42 = [obj countByEnumeratingWithState:&v88 objects:v96 count:16];
          if (!v42)
          {
LABEL_33:

            uint64_t v50 = (void *)MEMORY[0x2533B64D0]();
            uint64_t v51 = v84;
            id v52 = HMFGetOSLogHandle();
            id v14 = v86;
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
            {
              v53 = HMFGetLogIdentifier();
              *(_DWORD *)buf = 138543618;
              v98 = v53;
              __int16 v99 = 2112;
              id v100 = v86;
              _os_log_impl(&dword_252495000, v52, OS_LOG_TYPE_DEBUG, "%{public}@Endpoint 0 does not have cluster %@", buf, 0x16u);
            }
            id v54 = 0;
            *a8 = 1;
            id v17 = v85;
            uint64_t v55 = obj;
            goto LABEL_55;
          }
          goto LABEL_23;
        }
      }
      long long v75 = (void *)MEMORY[0x2533B64D0]();
      long long v76 = v84;
      long long v77 = HMFGetOSLogHandle();
      id v14 = v86;
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v78 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        v98 = v78;
        __int16 v99 = 2112;
        id v100 = v86;
        _os_log_impl(&dword_252495000, v77, OS_LOG_TYPE_DEBUG, "%{public}@Endpoint 0 has cluster %@", buf, 0x16u);
      }

      uint64_t v55 = obj;
      id v54 = &unk_2702B51F0;
      id v17 = v85;
LABEL_55:

      uint64_t v65 = v79;
    }
    else
    {
      uint64_t v65 = v32;
      long long v71 = (void *)MEMORY[0x2533B64D0]();
      long long v72 = v84;
      long long v73 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
      {
        long long v74 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        v98 = v74;
        __int16 v99 = 2112;
        id v100 = v80;
        _os_log_impl(&dword_252495000, v73, OS_LOG_TYPE_ERROR, "%{public}@Unexpected ServerList value type: %@", buf, 0x16u);
      }
      id v54 = 0;
      *a8 = 0;
    }
    long long v70 = v81;
  }
  else
  {
    uint64_t v65 = v32;
    uint64_t v66 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v67 = v27;
    long long v68 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
    {
      long long v69 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      v98 = v69;
      _os_log_impl(&dword_252495000, v68, OS_LOG_TYPE_ERROR, "%{public}@ServerList couldn't be read from endpoint 0", buf, 0xCu);
    }
    id v54 = 0;
    *a8 = 0;
    long long v70 = 0;
  }

LABEL_43:
  return v54;
}

- (id)endpointsForHAPAccessory:(id)a3 topology:(id)a4
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  id v5 = a3;
  id v33 = a4;
  uint64_t v6 = [MEMORY[0x263EFF980] array];
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  id v34 = v5;
  id v7 = [v5 services];
  uint64_t v8 = [v7 countByEnumeratingWithState:&v35 objects:v47 count:16];
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t v10 = *(void *)v36;
    while (2)
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (*(void *)v36 != v10) {
          objc_enumerationMutation(v7);
        }
        id v12 = *(id *)(*((void *)&v35 + 1) + 8 * i);
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          id v13 = v12;
        }
        else {
          id v13 = 0;
        }
        id v14 = v13;

        id v15 = [v14 type];
        int v16 = [v15 isEqual:@"0000003E-0000-1000-8000-0026BB765291"];

        if (v16)
        {
          uint64_t v23 = [v14 endpoint];
          [v6 addObject:v23];

          id v24 = [v14 endpoint];
          uint64_t v22 = v33;
          id v25 = [v33 getPartsListAtEndpoint:v24];

          id v26 = (void *)MEMORY[0x2533B64D0]([v6 addObjectsFromArray:v25]);
          uint64_t v27 = self;
          unint64_t v28 = HMFGetOSLogHandle();
          uint64_t v20 = v34;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v29 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138544130;
            id v40 = v29;
            __int16 v41 = 2112;
            id v42 = v34;
            __int16 v43 = 2112;
            id v44 = v14;
            __int16 v45 = 2112;
            id v46 = v6;
            _os_log_impl(&dword_252495000, v28, OS_LOG_TYPE_DEBUG, "%{public}@HAPAccessory %@ service: %@, endpoints: %@", buf, 0x2Au);
          }
          id v30 = v6;

          goto LABEL_18;
        }
      }
      uint64_t v9 = [v7 countByEnumeratingWithState:&v35 objects:v47 count:16];
      if (v9) {
        continue;
      }
      break;
    }
  }

  id v17 = (void *)MEMORY[0x2533B64D0]();
  id v18 = self;
  uint64_t v19 = HMFGetOSLogHandle();
  uint64_t v20 = v34;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    int v21 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    id v40 = v21;
    __int16 v41 = 2112;
    id v42 = v34;
    _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_ERROR, "%{public}@No endpoints available for diagnostic clusters for HAPAccessory: %@", buf, 0x16u);
  }
  uint64_t v22 = v33;
LABEL_18:

  return v6;
}

- (void)resetWiFiNetworkDiagnosticsCountForAccessory:(id)a3
{
  id v4 = a3;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  v7[2] = __82__HMMTRAccessoryServer_Diagnostics__resetWiFiNetworkDiagnosticsCountForAccessory___block_invoke;
  v7[3] = &unk_265376E98;
  v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __82__HMMTRAccessoryServer_Diagnostics__resetWiFiNetworkDiagnosticsCountForAccessory___block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    int v16 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Resetting WiFiNetworkDiagnostics counters", buf, 0xCu);
  }
  id v6 = [*(id *)(a1 + 32) matterDevice];

  if (v6)
  {
    id v7 = [HMMTRDeviceTopology alloc];
    id v8 = [*(id *)(a1 + 32) nodeID];
    uint64_t v9 = [(HMMTRDeviceTopology *)v7 initWithNodeId:v8 server:*(void *)(a1 + 32)];

    if (v9)
    {
      uint64_t v10 = [*(id *)(a1 + 32) endpointsForHAPAccessory:*(void *)(a1 + 40) topology:v9];
      buf[0] = 0;
      id v11 = *(void **)(a1 + 32);
      id v12 = [v11 matterDevice];
      id v13 = [v11 wifiNetworkDiagnosticsClusterFromEndpoints:v10 topology:v9 device:v12 definitelyUnsupported:buf];

      v14[0] = MEMORY[0x263EF8330];
      v14[1] = 3221225472;
      v14[2] = __82__HMMTRAccessoryServer_Diagnostics__resetWiFiNetworkDiagnosticsCountForAccessory___block_invoke_212;
      v14[3] = &unk_265376E00;
      v14[4] = *(void *)(a1 + 32);
      [v13 resetCountsWithExpectedValues:MEMORY[0x263EFFA68] expectedValueInterval:&unk_2702B51F0 completion:v14];
    }
  }
}

void __82__HMMTRAccessoryServer_Diagnostics__resetWiFiNetworkDiagnosticsCountForAccessory___block_invoke_212(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    int v8 = 138543618;
    uint64_t v9 = v7;
    __int16 v10 = 2112;
    id v11 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Reset WiFiNetworkDiagnostics counters with error: %@", (uint8_t *)&v8, 0x16u);
  }
}

- (void)resetThreadNetworkDiagnosticsCountForAccessory:(id)a3
{
  id v4 = a3;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  v7[2] = __84__HMMTRAccessoryServer_Diagnostics__resetThreadNetworkDiagnosticsCountForAccessory___block_invoke;
  v7[3] = &unk_265376E98;
  v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __84__HMMTRAccessoryServer_Diagnostics__resetThreadNetworkDiagnosticsCountForAccessory___block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    int v16 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Resetting ThreadNetworkDiagnostics counters", buf, 0xCu);
  }
  id v6 = [*(id *)(a1 + 32) matterDevice];

  if (v6)
  {
    id v7 = [HMMTRDeviceTopology alloc];
    id v8 = [*(id *)(a1 + 32) nodeID];
    uint64_t v9 = [(HMMTRDeviceTopology *)v7 initWithNodeId:v8 server:*(void *)(a1 + 32)];

    if (v9)
    {
      __int16 v10 = [*(id *)(a1 + 32) endpointsForHAPAccessory:*(void *)(a1 + 40) topology:v9];
      buf[0] = 0;
      id v11 = *(void **)(a1 + 32);
      uint64_t v12 = [v11 matterDevice];
      id v13 = [v11 threadNetworkDiagnosticsClusterFromEndpoints:v10 topology:v9 device:v12 definitelyUnsupported:buf];

      v14[0] = MEMORY[0x263EF8330];
      v14[1] = 3221225472;
      v14[2] = __84__HMMTRAccessoryServer_Diagnostics__resetThreadNetworkDiagnosticsCountForAccessory___block_invoke_210;
      v14[3] = &unk_265376E00;
      v14[4] = *(void *)(a1 + 32);
      [v13 resetCountsWithExpectedValues:MEMORY[0x263EFFA68] expectedValueInterval:&unk_2702B51F0 completion:v14];
    }
  }
}

void __84__HMMTRAccessoryServer_Diagnostics__resetThreadNetworkDiagnosticsCountForAccessory___block_invoke_210(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    int v8 = 138543618;
    uint64_t v9 = v7;
    __int16 v10 = 2112;
    id v11 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Reset ThreadNetworkDiagnostics counters with error: %@", (uint8_t *)&v8, 0x16u);
  }
}

- (id)getThreadNetworkLinkQualityForAccessory:(id)a3
{
  id v4 = a3;
  uint64_t v12 = 0;
  id v13 = &v12;
  uint64_t v14 = 0x3032000000;
  id v15 = __Block_byref_object_copy_;
  int v16 = __Block_byref_object_dispose_;
  id v17 = 0;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __77__HMMTRAccessoryServer_Diagnostics__getThreadNetworkLinkQualityForAccessory___block_invoke;
  block[3] = &unk_265377F50;
  id v10 = v4;
  id v11 = &v12;
  block[4] = self;
  id v6 = v4;
  dispatch_sync(v5, block);

  id v7 = (id)v13[5];
  _Block_object_dispose(&v12, 8);

  return v7;
}

void __77__HMMTRAccessoryServer_Diagnostics__getThreadNetworkLinkQualityForAccessory___block_invoke(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  v2 = [*(id *)(a1 + 32) matterDevice];

  if (v2)
  {
    id v3 = [HMMTRDeviceTopology alloc];
    id v4 = [*(id *)(a1 + 32) nodeID];
    id v5 = [(HMMTRDeviceTopology *)v3 initWithNodeId:v4 server:*(void *)(a1 + 32)];

    if (v5)
    {
      uint64_t v6 = [MEMORY[0x263EFF9A0] dictionary];
      uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
      int v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = v6;

      uint64_t v9 = [*(id *)(a1 + 32) endpointsForHAPAccessory:*(void *)(a1 + 40) topology:v5];
      char v26 = 0;
      id v10 = *(void **)(a1 + 32);
      id v11 = [v10 matterDevice];
      uint64_t v12 = [v10 threadNetworkDiagnosticsClusterFromEndpoints:v9 topology:v5 device:v11 definitelyUnsupported:&v26];

      if (v12)
      {
        [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:MEMORY[0x263EFFA88] forKeyedSubscript:@"threadNetwork_DiagnosticsSupported"];
        id v13 = [*(id *)(a1 + 32) highestRSSIofThreadNetworkDiagnostics:v12];
        uint64_t v14 = [*(id *)(a1 + 32) highestRSSIofThreadNetworkDiagnostics:v12];

        if (v14)
        {
          id v15 = (void *)MEMORY[0x2533B64D0]();
          id v16 = *(id *)(a1 + 32);
          id v17 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            id v18 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543618;
            unint64_t v28 = v18;
            __int16 v29 = 2112;
            id v30 = v14;
            _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - RSSI: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v14 forKeyedSubscript:@"threadNetwork_RSSI"];
        }
        uint64_t v19 = *(void **)(a1 + 32);
        uint64_t v20 = [v12 readAttributeNetworkNameWithParams:0];
        int v21 = [v19 stringOfReadValue:v20];

        if (v21)
        {
          uint64_t v22 = (void *)MEMORY[0x2533B64D0]();
          id v23 = *(id *)(a1 + 32);
          id v24 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
          {
            id v25 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543618;
            unint64_t v28 = v25;
            __int16 v29 = 2112;
            id v30 = v21;
            _os_log_impl(&dword_252495000, v24, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - Network Name: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v21 forKeyedSubscript:@"threadNetwork_Name"];
        }
      }
    }
  }
}

- (id)getWiFiNetworkLinkQualityForAccessory:(id)a3
{
  id v4 = a3;
  uint64_t v12 = 0;
  id v13 = &v12;
  uint64_t v14 = 0x3032000000;
  id v15 = __Block_byref_object_copy_;
  id v16 = __Block_byref_object_dispose_;
  id v17 = 0;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __75__HMMTRAccessoryServer_Diagnostics__getWiFiNetworkLinkQualityForAccessory___block_invoke;
  block[3] = &unk_265377F50;
  id v10 = v4;
  id v11 = &v12;
  block[4] = self;
  id v6 = v4;
  dispatch_sync(v5, block);

  id v7 = (id)v13[5];
  _Block_object_dispose(&v12, 8);

  return v7;
}

void __75__HMMTRAccessoryServer_Diagnostics__getWiFiNetworkLinkQualityForAccessory___block_invoke(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  v2 = [*(id *)(a1 + 32) matterDevice];

  if (v2)
  {
    id v3 = [HMMTRDeviceTopology alloc];
    id v4 = [*(id *)(a1 + 32) nodeID];
    id v5 = [(HMMTRDeviceTopology *)v3 initWithNodeId:v4 server:*(void *)(a1 + 32)];

    if (v5)
    {
      uint64_t v6 = [MEMORY[0x263EFF9A0] dictionary];
      uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
      int v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = v6;

      uint64_t v9 = [*(id *)(a1 + 32) endpointsForHAPAccessory:*(void *)(a1 + 40) topology:v5];
      char v20 = 0;
      id v10 = *(void **)(a1 + 32);
      id v11 = [v10 matterDevice];
      uint64_t v12 = [v10 wifiNetworkDiagnosticsClusterFromEndpoints:v9 topology:v5 device:v11 definitelyUnsupported:&v20];

      if (v12)
      {
        [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:MEMORY[0x263EFFA88] forKeyedSubscript:@"wifiNetwork_DiagnosticsSupported"];
        id v13 = *(void **)(a1 + 32);
        uint64_t v14 = [v12 readAttributeRSSIWithParams:0];
        id v15 = [v13 numberOfReadValue:v14];

        if (v15)
        {
          id v16 = (void *)MEMORY[0x2533B64D0]();
          id v17 = *(id *)(a1 + 32);
          id v18 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v19 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543618;
            uint64_t v22 = v19;
            __int16 v23 = 2112;
            id v24 = v15;
            _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - RSSI: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v15 forKeyedSubscript:@"wifiNetwork_RSSI"];
        }
      }
    }
  }
}

- (id)getConnectNetworkIDForAccessory:(id)a3
{
  id v4 = a3;
  uint64_t v12 = 0;
  id v13 = &v12;
  uint64_t v14 = 0x3032000000;
  id v15 = __Block_byref_object_copy_;
  id v16 = __Block_byref_object_dispose_;
  id v17 = 0;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __69__HMMTRAccessoryServer_Diagnostics__getConnectNetworkIDForAccessory___block_invoke;
  block[3] = &unk_265377F50;
  id v10 = v4;
  id v11 = &v12;
  block[4] = self;
  id v6 = v4;
  dispatch_sync(v5, block);

  id v7 = (id)v13[5];
  _Block_object_dispose(&v12, 8);

  return v7;
}

void __69__HMMTRAccessoryServer_Diagnostics__getConnectNetworkIDForAccessory___block_invoke(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  v2 = [*(id *)(a1 + 32) matterDevice];

  if (v2)
  {
    id v3 = [HMMTRDeviceTopology alloc];
    id v4 = [*(id *)(a1 + 32) nodeID];
    id v5 = [(HMMTRDeviceTopology *)v3 initWithNodeId:v4 server:*(void *)(a1 + 32)];

    if (v5)
    {
      uint64_t v6 = [MEMORY[0x263EFF9A0] dictionary];
      uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
      int v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = v6;

      uint64_t v9 = [*(id *)(a1 + 32) endpointsForHAPAccessory:*(void *)(a1 + 40) topology:v5];
      char v20 = 0;
      id v10 = *(void **)(a1 + 32);
      id v11 = [v10 matterDevice];
      uint64_t v12 = [v10 networkCommissioningClusterFromEndpoints:v9 topology:v5 device:v11 definitelyUnsupported:&v20];

      if (v12)
      {
        id v13 = *(void **)(a1 + 32);
        uint64_t v14 = [v12 readAttributeNetworksWithParams:0];
        id v15 = [v13 connectedNetworkIDFromReadValue:v14];

        id v16 = (void *)MEMORY[0x2533B64D0]();
        id v17 = *(id *)(a1 + 32);
        id v18 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v19 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          uint64_t v22 = v19;
          __int16 v23 = 2112;
          id v24 = v15;
          _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_DEBUG, "%{public}@Found connected network ID: %@", buf, 0x16u);
        }
        [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v15 forKeyedSubscript:@"network_ID"];
      }
    }
  }
}

- (id)getOperationalNetworkAddressForAccessory:(id)a3
{
  id v4 = a3;
  uint64_t v12 = 0;
  id v13 = &v12;
  uint64_t v14 = 0x3032000000;
  id v15 = __Block_byref_object_copy_;
  id v16 = __Block_byref_object_dispose_;
  id v17 = 0;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __78__HMMTRAccessoryServer_Diagnostics__getOperationalNetworkAddressForAccessory___block_invoke;
  block[3] = &unk_265377F50;
  id v10 = v4;
  id v11 = &v12;
  block[4] = self;
  id v6 = v4;
  dispatch_sync(v5, block);

  id v7 = (id)v13[5];
  _Block_object_dispose(&v12, 8);

  return v7;
}

uint64_t __78__HMMTRAccessoryServer_Diagnostics__getOperationalNetworkAddressForAccessory___block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) = [*(id *)(a1 + 32) _getOperationalNetworkAddressForAccessory:*(void *)(a1 + 40)];
  return MEMORY[0x270F9A758]();
}

- (id)getSupportedLinkLayerTypesForAccessory:(id)a3
{
  id v4 = a3;
  uint64_t v12 = 0;
  id v13 = &v12;
  uint64_t v14 = 0x3032000000;
  id v15 = __Block_byref_object_copy_;
  id v16 = __Block_byref_object_dispose_;
  id v17 = 0;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __76__HMMTRAccessoryServer_Diagnostics__getSupportedLinkLayerTypesForAccessory___block_invoke;
  block[3] = &unk_265377F50;
  id v10 = v4;
  id v11 = &v12;
  block[4] = self;
  id v6 = v4;
  dispatch_sync(v5, block);

  id v7 = (id)v13[5];
  _Block_object_dispose(&v12, 8);

  return v7;
}

uint64_t __76__HMMTRAccessoryServer_Diagnostics__getSupportedLinkLayerTypesForAccessory___block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) = [*(id *)(a1 + 32) _getSupportedLinkLayerTypesForAccessory:*(void *)(a1 + 40)];
  return MEMORY[0x270F9A758]();
}

- (id)_getSupportedLinkLayerTypesForAccessory:(id)a3
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  dispatch_assert_queue_V2(v5);

  id v6 = [(HMMTRAccessoryServer *)self matterDevice];

  if (v6)
  {
    id v7 = [HMMTRDeviceTopology alloc];
    int v8 = [(HMMTRAccessoryServer *)self nodeID];
    uint64_t v9 = [(HMMTRDeviceTopology *)v7 initWithNodeId:v8 server:self];

    if (v9)
    {
      id v10 = [(HMMTRAccessoryServer *)self endpointsForHAPAccessory:v4 topology:v9];
      char v29 = 0;
      id v11 = [(HMMTRAccessoryServer *)self matterDevice];
      uint64_t v12 = [(HMMTRAccessoryServer *)self networkCommissioningClusterFromEndpoints:v10 topology:v9 device:v11 definitelyUnsupported:&v29];

      if (v12)
      {
        id v13 = [v12 readAttributeFeatureMapWithParams:0];
        uint64_t v14 = [(HMMTRAccessoryServer *)self numberOfReadValue:v13];

        id v15 = [(HMMTRAccessoryServer *)self getSupportedLinkLayerTypesFromNetworkCommissioningClusterFeatureMap:v14];
      }
      else
      {
        id v24 = (void *)MEMORY[0x2533B64D0]();
        uint64_t v25 = self;
        char v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          uint64_t v27 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543362;
          uint64_t v31 = v27;
          _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_ERROR, "%{public}@Error retrieving supported link layers - no network commissioning cluster", buf, 0xCu);
        }
        id v15 = 0;
      }
    }
    else
    {
      char v20 = (void *)MEMORY[0x2533B64D0]();
      int v21 = self;
      uint64_t v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        __int16 v23 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v31 = v23;
        _os_log_impl(&dword_252495000, v22, OS_LOG_TYPE_ERROR, "%{public}@Error retrieving supported link layers - no topology", buf, 0xCu);
      }
      id v15 = 0;
    }
  }
  else
  {
    id v16 = (void *)MEMORY[0x2533B64D0]();
    id v17 = self;
    id v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v31 = v19;
      _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_ERROR, "%{public}@Error retrieving supported link layers - matter device not available", buf, 0xCu);
    }
    id v15 = 0;
  }

  return v15;
}

- (id)getSupportedLinkLayerTypesFromNetworkCommissioningClusterFeatureMap:(id)a3
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = v4;
  if (v4)
  {
    char v6 = [v4 unsignedIntegerValue];
    uint64_t v7 = (8 * [v5 unsignedIntegerValue]) & 0x10 | (2 * (v6 & 1));
    int v8 = (void *)(v7 | [v5 unsignedIntegerValue] & 4);
    uint64_t v9 = (void *)MEMORY[0x2533B64D0]();
    id v10 = self;
    id v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v12 = HMFGetLogIdentifier();
      int v14 = 138543874;
      id v15 = v12;
      __int16 v16 = 2112;
      id v17 = v5;
      __int16 v18 = 2048;
      uint64_t v19 = v8;
      _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_DEBUG, "%{public}@NetworkCommissioningCluster featureMap: %@, supportedLinkLayerTypes = %ld", (uint8_t *)&v14, 0x20u);
    }
    if (v8)
    {
      int v8 = [NSNumber numberWithUnsignedLong:v8];
    }
  }
  else
  {
    int v8 = 0;
  }

  return v8;
}

- (int64_t)getLinkLayerTypeForAccessory:(id)a3
{
  id v4 = a3;
  uint64_t v12 = 0;
  id v13 = &v12;
  uint64_t v14 = 0x2020000000;
  uint64_t v15 = 0;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __66__HMMTRAccessoryServer_Diagnostics__getLinkLayerTypeForAccessory___block_invoke;
  block[3] = &unk_265377F50;
  id v10 = v4;
  id v11 = &v12;
  block[4] = self;
  id v6 = v4;
  dispatch_sync(v5, block);

  int64_t v7 = v13[3];
  _Block_object_dispose(&v12, 8);
  return v7;
}

uint64_t __66__HMMTRAccessoryServer_Diagnostics__getLinkLayerTypeForAccessory___block_invoke(uint64_t a1)
{
  uint64_t result = [*(id *)(a1 + 32) _getLinkLayerTypeForAccessory:*(void *)(a1 + 40)];
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = result;
  return result;
}

- (int64_t)_getLinkLayerTypeForAccessory:(id)a3
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [(HMMTRAccessoryServer *)self matterDevice];

  if (v5)
  {
    id v6 = [HMMTRDeviceTopology alloc];
    int64_t v7 = [(HMMTRAccessoryServer *)self nodeID];
    int v8 = [(HMMTRDeviceTopology *)v6 initWithNodeId:v7 server:self];

    if (v8)
    {
      uint64_t v9 = [(HMMTRAccessoryServer *)self endpointsForHAPAccessory:v4 topology:v8];
      char v20 = 0;
      id v10 = [(HMMTRAccessoryServer *)self matterDevice];
      id v11 = [(HMMTRAccessoryServer *)self networkCommissioningClusterFromEndpoints:v9 topology:v8 device:v10 definitelyUnsupported:&v20];

      if (v11)
      {
        uint64_t v12 = [v11 readAttributeFeatureMapWithParams:0];
        id v13 = [(HMMTRAccessoryServer *)self numberOfReadValue:v12];

        if (v13)
        {
          uint64_t v14 = (void *)MEMORY[0x2533B64D0]();
          uint64_t v15 = self;
          __int16 v16 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            id v17 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543618;
            uint64_t v22 = v17;
            __int16 v23 = 2112;
            id v24 = v13;
            _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_DEBUG, "%{public}@NetworkCommissioningCluster featureMap: %@", buf, 0x16u);
          }
          if ([v13 unsignedIntegerValue])
          {
            unint64_t v18 = 1;
          }
          else if (([v13 unsignedIntegerValue] & 2) != 0)
          {
            unint64_t v18 = 4;
          }
          else
          {
            unint64_t v18 = ((unint64_t)[v13 unsignedIntegerValue] >> 1) & 2;
          }
        }
        else
        {
          unint64_t v18 = 0;
        }
      }
      else
      {
        unint64_t v18 = 0;
      }
    }
    else
    {
      unint64_t v18 = 0;
    }
  }
  else
  {
    unint64_t v18 = 0;
  }

  return v18;
}

- (id)_processEvent:(id)a3
{
  v22[4] = *MEMORY[0x263EF8340];
  uint64_t v3 = *MEMORY[0x263F10BD0];
  id v4 = a3;
  id v5 = [v4 objectForKeyedSubscript:v3];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v6 = v5;
  }
  else {
    id v6 = 0;
  }
  id v7 = v6;

  int v8 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10BC8]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  id v10 = v9;

  id v11 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10BD8]];

  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  id v13 = v12;

  if (v13) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = &unk_2702B51F0;
  }
  v21[0] = @"UpTime";
  v21[1] = @"EventNumber";
  if (v10) {
    uint64_t v15 = v10;
  }
  else {
    uint64_t v15 = &unk_2702B51F0;
  }
  v22[0] = v14;
  v22[1] = v15;
  v21[2] = @"Cluster";
  __int16 v16 = [v7 cluster];
  v22[2] = v16;
  v21[3] = @"Event";
  id v17 = [v7 event];

  if (v17) {
    unint64_t v18 = v17;
  }
  else {
    unint64_t v18 = &unk_2702B51F0;
  }
  v22[3] = v18;
  uint64_t v19 = [NSDictionary dictionaryWithObjects:v22 forKeys:v21 count:4];

  return v19;
}

- (id)_readPastEventsFromAccessory:(id)a3 forClusters:(id)a4
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  id v32 = a3;
  id v30 = a4;
  uint64_t v47 = 0;
  uint64_t v48 = &v47;
  uint64_t v49 = 0x3032000000;
  uint64_t v50 = __Block_byref_object_copy_;
  uint64_t v51 = __Block_byref_object_dispose_;
  id v52 = [MEMORY[0x263EFF980] array];
  id v6 = [(HMMTRAccessoryServer *)self matterDevice];
  LODWORD(a4) = v6 == 0;

  if (a4)
  {
    int v21 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v22 = self;
    HMFGetOSLogHandle();
    __int16 v23 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      id v24 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v55 = v24;
      _os_log_impl(&dword_252495000, v23, OS_LOG_TYPE_ERROR, "%{public}@Matter device is nil", buf, 0xCu);
    }
    id v20 = 0;
  }
  else
  {
    id v7 = [HMMTRDeviceTopology alloc];
    int v8 = [(HMMTRAccessoryServer *)self nodeID];
    long long v35 = [(HMMTRDeviceTopology *)v7 initWithNodeId:v8 server:self];

    if (v35)
    {
      uint64_t v9 = -[HMMTRAccessoryServer endpointsForHAPAccessory:topology:](self, "endpointsForHAPAccessory:topology:", v32);
      buf[0] = 0;
      if (![v9 count])
      {

        uint64_t v9 = &unk_2702B6168;
      }
      id v34 = v9;
      group = dispatch_group_create();
      long long v43 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      id obj = v30;
      uint64_t v10 = [obj countByEnumeratingWithState:&v43 objects:v53 count:16];
      if (v10)
      {
        uint64_t v11 = *(void *)v44;
        do
        {
          for (uint64_t i = 0; i != v10; ++i)
          {
            if (*(void *)v44 != v11) {
              objc_enumerationMutation(obj);
            }
            uint64_t v13 = *(void *)(*((void *)&v43 + 1) + 8 * i);
            uint64_t v14 = [(HMMTRAccessoryServer *)self matterDevice];
            uint64_t v15 = [(HMMTRAccessoryServer *)self endpointForDiagnosticCluster:v13 clusterName:&stru_2702A0B38 amongEndpoints:v34 topology:v35 device:v14 definitelyUnsupported:buf];

            if (!buf[0])
            {
              __int16 v16 = [(HMMTRAccessoryServer *)self deviceController];
              id v17 = [(HMMTRAccessoryServer *)self nodeID];
              uint64_t v18 = [v17 unsignedLongLongValue];
              uint64_t v19 = [(HAPAccessoryServer *)self clientQueue];
              v36[0] = MEMORY[0x263EF8330];
              v36[1] = 3221225472;
              v36[2] = __78__HMMTRAccessoryServer_Diagnostics___readPastEventsFromAccessory_forClusters___block_invoke;
              v36[3] = &unk_2653758F8;
              long long v37 = group;
              id v38 = v15;
              uint64_t v39 = v13;
              id v40 = self;
              id v41 = v32;
              id v42 = &v47;
              [v16 getBaseDevice:v18 queue:v19 completionHandler:v36];
            }
          }
          uint64_t v10 = [obj countByEnumeratingWithState:&v43 objects:v53 count:16];
        }
        while (v10);
      }

      dispatch_group_wait(group, 0xFFFFFFFFFFFFFFFFLL);
      id v20 = (id)v48[5];
    }
    else
    {
      uint64_t v25 = (void *)MEMORY[0x2533B64D0]();
      char v26 = self;
      HMFGetOSLogHandle();
      uint64_t v27 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        unint64_t v28 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v55 = v28;
        _os_log_impl(&dword_252495000, v27, OS_LOG_TYPE_ERROR, "%{public}@Matter topology is nil", buf, 0xCu);
      }
      id v20 = 0;
    }
  }
  _Block_object_dispose(&v47, 8);

  return v20;
}

void __78__HMMTRAccessoryServer_Diagnostics___readPastEventsFromAccessory_forClusters___block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  if (!a3)
  {
    uint64_t v20 = v3;
    uint64_t v21 = v4;
    id v6 = (objc_class *)MEMORY[0x263F10FA0];
    id v7 = a2;
    id v8 = objc_alloc_init(v6);
    [v8 setFilterByFabric:1];
    [v8 setMinEventNumber:0];
    dispatch_group_enter(*(dispatch_group_t *)(a1 + 32));
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = [*(id *)(a1 + 56) clientQueue];
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 3221225472;
    v15[2] = __78__HMMTRAccessoryServer_Diagnostics___readPastEventsFromAccessory_forClusters___block_invoke_2;
    v15[3] = &unk_2653758D0;
    uint64_t v12 = *(void **)(a1 + 64);
    v15[4] = *(void *)(a1 + 56);
    id v13 = v12;
    uint64_t v14 = *(void *)(a1 + 48);
    id v16 = v13;
    uint64_t v17 = v14;
    uint64_t v19 = *(void *)(a1 + 72);
    id v18 = *(id *)(a1 + 32);
    [v7 readEventsWithEndpointID:v9 clusterID:v10 eventID:0 params:v8 queue:v11 completion:v15];
  }
}

void __78__HMMTRAccessoryServer_Diagnostics___readPastEventsFromAccessory_forClusters___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id v7 = (void *)MEMORY[0x2533B64D0]();
  id v8 = *(id *)(a1 + 32);
  uint64_t v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = HMFGetLogIdentifier();
    uint64_t v11 = [*(id *)(a1 + 40) shortDescription];
    uint64_t v12 = [*(id *)(a1 + 48) integerValue];
    *(_DWORD *)buf = 138544130;
    id v33 = v10;
    __int16 v34 = 2112;
    long long v35 = v11;
    __int16 v36 = 2048;
    uint64_t v37 = v12;
    __int16 v38 = 2112;
    id v39 = v6;
    _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_DEBUG, "%{public}@[%@] Read diagnostic events for cluster ID 0x%lX, error: %@", buf, 0x2Au);
  }
  uint64_t v25 = v6;

  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  id obj = v5;
  uint64_t v13 = [obj countByEnumeratingWithState:&v27 objects:v31 count:16];
  if (v13)
  {
    uint64_t v14 = v13;
    uint64_t v15 = *(void *)v28;
    do
    {
      for (uint64_t i = 0; i != v14; ++i)
      {
        if (*(void *)v28 != v15) {
          objc_enumerationMutation(obj);
        }
        uint64_t v17 = *(void *)(*((void *)&v27 + 1) + 8 * i);
        id v18 = (void *)MEMORY[0x2533B64D0]();
        id v19 = *(id *)(a1 + 32);
        uint64_t v20 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
        {
          uint64_t v21 = HMFGetLogIdentifier();
          uint64_t v22 = [*(id *)(a1 + 40) shortDescription];
          *(_DWORD *)buf = 138543874;
          id v33 = v21;
          __int16 v34 = 2112;
          long long v35 = v22;
          __int16 v36 = 2112;
          uint64_t v37 = v17;
          _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_INFO, "%{public}@[%@] Received diagnostic event %@", buf, 0x20u);
        }
        __int16 v23 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
        id v24 = [*(id *)(a1 + 32) _processEvent:v17];
        [v23 addObject:v24];
      }
      uint64_t v14 = [obj countByEnumeratingWithState:&v27 objects:v31 count:16];
    }
    while (v14);
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 56));
}

- (id)readPastDiagnosticEventsFromAccessory:(id)a3 fromEventNumber:(id)a4
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v10 = &unk_2702B5160;
  uint64_t v11 = &unk_2702B5190;
  uint64_t v12 = &unk_2702B51A8;
  uint64_t v13 = &unk_2702B51C0;
  uint64_t v14 = &unk_2702B51D8;
  id v5 = (void *)MEMORY[0x263EFF8C0];
  id v6 = a3;
  id v7 = [v5 arrayWithObjects:&v10 count:5];
  id v8 = -[HMMTRAccessoryServer _readPastEventsFromAccessory:forClusters:](self, "_readPastEventsFromAccessory:forClusters:", v6, v7, v10, v11, v12, v13, v14, v15);

  return v8;
}

- (id)collectDiagnosticsForAccessory:(id)a3
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  id v4 = a3;
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x3032000000;
  id v19 = __Block_byref_object_copy_;
  uint64_t v20 = __Block_byref_object_dispose_;
  id v21 = 0;
  id v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = self;
  HMFGetOSLogHandle();
  id v7 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    __int16 v23 = v8;
    __int16 v24 = 2112;
    id v25 = v4;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Collecting accessory diagnostics for %@", buf, 0x16u);
  }
  uint64_t v9 = [(HAPAccessoryServer *)v6 clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __68__HMMTRAccessoryServer_Diagnostics__collectDiagnosticsForAccessory___block_invoke;
  block[3] = &unk_265377F50;
  id v14 = v4;
  uint64_t v15 = &v16;
  block[4] = v6;
  id v10 = v4;
  dispatch_sync(v9, block);

  id v11 = (id)v17[5];
  _Block_object_dispose(&v16, 8);

  return v11;
}

void __68__HMMTRAccessoryServer_Diagnostics__collectDiagnosticsForAccessory___block_invoke(uint64_t a1)
{
  uint64_t v197 = *MEMORY[0x263EF8340];
  v2 = [*(id *)(a1 + 32) matterDevice];

  if (v2)
  {
    uint64_t v3 = [HMMTRDeviceTopology alloc];
    id v4 = [*(id *)(a1 + 32) nodeID];
    id v5 = [(HMMTRDeviceTopology *)v3 initWithNodeId:v4 server:*(void *)(a1 + 32)];

    if (v5)
    {
      uint64_t v6 = [MEMORY[0x263EFF9A0] dictionary];
      uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
      id v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = v6;

      uint64_t v9 = [*(id *)(a1 + 32) endpointsForHAPAccessory:*(void *)(a1 + 40) topology:v5];
      char v192 = 0;
      id v10 = *(void **)(a1 + 32);
      id v11 = [v10 matterDevice];
      uint64_t v12 = [v10 generalDiagnosticsClusterFromEndpoints:v9 topology:v5 device:v11 definitelyUnsupported:&v192];

      if (v12)
      {
        [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:MEMORY[0x263EFFA88] forKeyedSubscript:@"general_DiagnosticsSupported"];
        uint64_t v13 = *(void **)(a1 + 32);
        id v14 = [v12 readAttributeRebootCountWithParams:0];
        uint64_t v15 = [v13 numberOfReadValue:v14];

        if (v15)
        {
          uint64_t v16 = (void *)MEMORY[0x2533B64D0]();
          id v17 = *(id *)(a1 + 32);
          HMFGetOSLogHandle();
          uint64_t v18 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            HMFGetLogIdentifier();
            id v19 = (id)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            id v194 = v19;
            __int16 v195 = 2112;
            uint64_t v196 = v15;
            _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_DEBUG, "%{public}@GeneralDiagnostics - RebootCount: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v15 forKeyedSubscript:@"general_RebootCount"];
        }
        uint64_t v20 = *(void **)(a1 + 32);
        id v21 = [v12 readAttributeUpTimeWithParams:0];
        uint64_t v22 = [v20 numberOfReadValue:v21];

        if (v22)
        {
          __int16 v23 = (void *)MEMORY[0x2533B64D0]();
          id v24 = *(id *)(a1 + 32);
          HMFGetOSLogHandle();
          id v25 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
          {
            HMFGetLogIdentifier();
            id v26 = (id)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            id v194 = v26;
            __int16 v195 = 2112;
            uint64_t v196 = v22;
            _os_log_impl(&dword_252495000, v25, OS_LOG_TYPE_DEBUG, "%{public}@GeneralDiagnostics - UpTime: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v22 forKeyedSubscript:@"general_UpTime"];
          id v27 = objc_alloc_init(MEMORY[0x263F08790]);
          long long v28 = [MEMORY[0x263EFF960] localeWithLocaleIdentifier:@"en_US_POSIX"];
          [v27 setLocale:v28];

          [v27 setDateFormat:@"yyyy-MM-dd' 'HH:mm:ss-ZZZZZ"];
          long long v29 = [MEMORY[0x263EFFA18] timeZoneForSecondsFromGMT:-28800];
          [v27 setTimeZone:v29];

          long long v30 = [MEMORY[0x263EFF910] date];
          [v22 doubleValue];
          id v32 = [v30 addTimeInterval:-v31];

          id v33 = [v27 stringFromDate:v32];
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v33 forKeyedSubscript:@"general_LastRebootTime"];
        }
        __int16 v34 = *(void **)(a1 + 32);
        long long v35 = [v12 readAttributeTotalOperationalHoursWithParams:0];
        __int16 v36 = [v34 numberOfReadValue:v35];

        if (v36)
        {
          uint64_t v37 = (void *)MEMORY[0x2533B64D0]();
          id v38 = *(id *)(a1 + 32);
          HMFGetOSLogHandle();
          id v39 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
          {
            HMFGetLogIdentifier();
            id v40 = (id)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            id v194 = v40;
            __int16 v195 = 2112;
            uint64_t v196 = v36;
            _os_log_impl(&dword_252495000, v39, OS_LOG_TYPE_DEBUG, "%{public}@GeneralDiagnostics - TotalOperationalHours: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v36 forKeyedSubscript:@"general_TotalOperationalHours"];
        }
        id v41 = *(void **)(a1 + 32);
        id v42 = [v12 readAttributeBootReasonWithParams:0];
        long long v43 = [v41 numberOfReadValue:v42];

        if (v43)
        {
          long long v44 = (void *)MEMORY[0x2533B64D0]();
          id v45 = *(id *)(a1 + 32);
          HMFGetOSLogHandle();
          long long v46 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          {
            HMFGetLogIdentifier();
            id v47 = (id)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            id v194 = v47;
            __int16 v195 = 2112;
            uint64_t v196 = v43;
            _os_log_impl(&dword_252495000, v46, OS_LOG_TYPE_DEBUG, "%{public}@GeneralDiagnostics - BootReason: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v43 forKeyedSubscript:@"general_BootReason"];
        }
      }
      else if (v192)
      {
        [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:MEMORY[0x263EFFA80] forKeyedSubscript:@"general_DiagnosticsSupported"];
      }
      uint64_t v48 = *(void **)(a1 + 32);
      uint64_t v49 = [v48 matterDevice];
      uint64_t v50 = [v48 threadNetworkDiagnosticsClusterFromEndpoints:v9 topology:v5 device:v49 definitelyUnsupported:&v192];

      v191 = v12;
      if (v50)
      {
        [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:MEMORY[0x263EFFA88] forKeyedSubscript:@"threadNetwork_DiagnosticsSupported"];
        uint64_t v51 = *(void **)(a1 + 32);
        id v52 = [v50 readAttributeFeatureMapWithParams:0];
        v53 = [v51 numberOfReadValue:v52];

        if (v53)
        {
          id v54 = (void *)MEMORY[0x2533B64D0]();
          id v55 = *(id *)(a1 + 32);
          HMFGetOSLogHandle();
          uint64_t v56 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
          {
            HMFGetLogIdentifier();
            id v57 = (id)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            id v194 = v57;
            __int16 v195 = 2112;
            uint64_t v196 = v53;
            _os_log_impl(&dword_252495000, v56, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - FeatureMap: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v53 forKeyedSubscript:@"threadNetwork_DiagnosticsFeatureMap"];
        }
        if (([v53 unsignedIntegerValue] & 8) != 0)
        {
          uint64_t v59 = [*(id *)(a1 + 32) packetCountOfThreadNetworkDiagnostics:v50];
          if (v59)
          {
            id v60 = (void *)MEMORY[0x2533B64D0]();
            id v61 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            uint64_t v62 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v63 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v63;
              __int16 v195 = 2112;
              uint64_t v196 = v59;
              _os_log_impl(&dword_252495000, v62, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - PacketCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v59 forKeyedSubscript:@"threadNetwork_PacketCount"];
          }
          v64 = *(void **)(a1 + 32);
          uint64_t v65 = [v50 readAttributeTxUnicastCountWithParams:0];
          uint64_t v66 = [v64 numberOfReadValue:v65];

          if (v66)
          {
            uint64_t v67 = (void *)MEMORY[0x2533B64D0]();
            id v68 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            long long v69 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v70 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v70;
              __int16 v195 = 2112;
              uint64_t v196 = v66;
              _os_log_impl(&dword_252495000, v69, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - TxUnicastCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v66 forKeyedSubscript:@"threadNetwork_PacketTxUnicastCount"];
          }
          long long v71 = *(void **)(a1 + 32);
          long long v72 = [v50 readAttributeTxBroadcastCountWithParams:0];
          long long v73 = [v71 numberOfReadValue:v72];

          if (v73)
          {
            long long v74 = (void *)MEMORY[0x2533B64D0]();
            id v75 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            long long v76 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v77 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v77;
              __int16 v195 = 2112;
              uint64_t v196 = v73;
              _os_log_impl(&dword_252495000, v76, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - TxBroadcastCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v73 forKeyedSubscript:@"threadNetwork_PacketTxBroadcastCount"];
          }
          uint64_t v78 = *(void **)(a1 + 32);
          long long v79 = [v50 readAttributeRxUnicastCountWithParams:0];
          long long v80 = [v78 numberOfReadValue:v79];

          if (v80)
          {
            long long v81 = (void *)MEMORY[0x2533B64D0]();
            id v82 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            v83 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v84 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v84;
              __int16 v195 = 2112;
              uint64_t v196 = v80;
              _os_log_impl(&dword_252495000, v83, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - RxUnicastCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v80 forKeyedSubscript:@"threadNetwork_PacketRxUnicastCount"];
          }
          id v85 = *(void **)(a1 + 32);
          id v86 = [v50 readAttributeRxBroadcastCountWithParams:0];
          id v87 = [v85 numberOfReadValue:v86];

          if (v87)
          {
            long long v88 = (void *)MEMORY[0x2533B64D0]();
            id v89 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            long long v90 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v91 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v91;
              __int16 v195 = 2112;
              uint64_t v196 = v87;
              _os_log_impl(&dword_252495000, v90, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - RxBroadcastCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v87 forKeyedSubscript:@"threadNetwork_PacketRxBroadcastCount"];
          }
          uint64_t v58 = [*(id *)(a1 + 32) errorCountOfThreadNetworkDiagnostics:v50];

          if (v58)
          {
            long long v92 = (void *)MEMORY[0x2533B64D0]();
            id v93 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            long long v94 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v95 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v95;
              __int16 v195 = 2112;
              uint64_t v196 = v58;
              _os_log_impl(&dword_252495000, v94, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - ErrorCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v58 forKeyedSubscript:@"threadNetwork_ErrorCount"];
          }
        }
        else
        {
          uint64_t v58 = 0;
        }
        if (([v53 unsignedIntegerValue] & 2) != 0)
        {
          id v97 = *(void **)(a1 + 32);
          v98 = [v50 readAttributeOverrunCountWithParams:0];
          v96 = [v97 numberOfReadValue:v98];

          if (v96)
          {
            __int16 v99 = (void *)MEMORY[0x2533B64D0]();
            id v100 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            __int16 v101 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v102 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v102;
              __int16 v195 = 2112;
              uint64_t v196 = v96;
              _os_log_impl(&dword_252495000, v101, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - OverrunCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v96 forKeyedSubscript:@"threadNetwork_OverrunCount"];
          }
        }
        else
        {
          v96 = v58;
        }
        uint64_t v103 = *(void **)(a1 + 32);
        uint64_t v104 = [v50 readAttributeChannelWithParams:0];
        v105 = [v103 numberOfReadValue:v104];

        if (v105)
        {
          v106 = (void *)MEMORY[0x2533B64D0]();
          id v107 = *(id *)(a1 + 32);
          HMFGetOSLogHandle();
          v108 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
          {
            HMFGetLogIdentifier();
            id v109 = (id)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            id v194 = v109;
            __int16 v195 = 2112;
            uint64_t v196 = v105;
            _os_log_impl(&dword_252495000, v108, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - ChannelNumber: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v105 forKeyedSubscript:@"threadNetwork_ChannelNumber"];
        }
        v110 = [*(id *)(a1 + 32) highestRSSIofThreadNetworkDiagnostics:v50];

        if (v110)
        {
          v111 = (void *)MEMORY[0x2533B64D0]();
          id v112 = *(id *)(a1 + 32);
          HMFGetOSLogHandle();
          v113 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v113, OS_LOG_TYPE_DEBUG))
          {
            HMFGetLogIdentifier();
            id v114 = (id)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            id v194 = v114;
            __int16 v195 = 2112;
            uint64_t v196 = v110;
            _os_log_impl(&dword_252495000, v113, OS_LOG_TYPE_DEBUG, "%{public}@ThreadNetworkDiagnostics - RSSI: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v110 forKeyedSubscript:@"threadNetwork_RSSI"];
        }

        uint64_t v12 = v191;
      }
      else if (v192)
      {
        [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:MEMORY[0x263EFFA80] forKeyedSubscript:@"threadNetwork_DiagnosticsSupported"];
      }
      v115 = *(void **)(a1 + 32);
      v116 = [v115 matterDevice];
      v117 = [v115 wifiNetworkDiagnosticsClusterFromEndpoints:v9 topology:v5 device:v116 definitelyUnsupported:&v192];

      if (v117)
      {
        [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:MEMORY[0x263EFFA88] forKeyedSubscript:@"wifiNetwork_DiagnosticsSupported"];
        v118 = *(void **)(a1 + 32);
        v119 = [v117 readAttributeFeatureMapWithParams:0];
        v120 = [v118 numberOfReadValue:v119];

        if (v120)
        {
          v121 = (void *)MEMORY[0x2533B64D0]();
          id v122 = *(id *)(a1 + 32);
          HMFGetOSLogHandle();
          v123 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v123, OS_LOG_TYPE_DEBUG))
          {
            HMFGetLogIdentifier();
            id v124 = (id)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            id v194 = v124;
            __int16 v195 = 2112;
            uint64_t v196 = v120;
            _os_log_impl(&dword_252495000, v123, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - FeatureMap: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v120 forKeyedSubscript:@"wifiNetwork_DiagnosticsFeatureMap"];
        }
        v190 = v9;
        if ([v120 unsignedIntegerValue])
        {
          v126 = [*(id *)(a1 + 32) packetCountOfWiFiNetworkDiagnostics:v117];
          if (v126)
          {
            v127 = (void *)MEMORY[0x2533B64D0]();
            id v128 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            v129 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v129, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v130 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v130;
              __int16 v195 = 2112;
              uint64_t v196 = v126;
              _os_log_impl(&dword_252495000, v129, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - PacketCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v126 forKeyedSubscript:@"wifiNetwork_PacketCount"];
          }
          v131 = *(void **)(a1 + 32);
          v132 = [v117 readAttributePacketUnicastTxCountWithParams:0];
          int v133 = [v131 numberOfReadValue:v132];

          if (v133)
          {
            uint64_t v134 = (void *)MEMORY[0x2533B64D0]();
            id v135 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            v136 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v137 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v137;
              __int16 v195 = 2112;
              uint64_t v196 = v133;
              _os_log_impl(&dword_252495000, v136, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - PacketTxUnicastCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v133 forKeyedSubscript:@"wifiNetwork_PacketTxUnicastCount"];
          }
          v138 = *(void **)(a1 + 32);
          v139 = [v117 readAttributePacketMulticastTxCountWithParams:0];
          id v140 = [v138 numberOfReadValue:v139];

          if (v140)
          {
            v141 = (void *)MEMORY[0x2533B64D0]();
            id v142 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            id v143 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v144 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v144;
              __int16 v195 = 2112;
              uint64_t v196 = v140;
              _os_log_impl(&dword_252495000, v143, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - PacketTxMulticastCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v140 forKeyedSubscript:@"wifiNetwork_PacketTxMulticastCount"];
          }
          uint64_t v145 = *(void **)(a1 + 32);
          uint64_t v146 = [v117 readAttributePacketUnicastRxCountWithParams:0];
          uint64_t v147 = [v145 numberOfReadValue:v146];

          if (v147)
          {
            v148 = (void *)MEMORY[0x2533B64D0]();
            id v149 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            v150 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v150, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v151 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v151;
              __int16 v195 = 2112;
              uint64_t v196 = v147;
              _os_log_impl(&dword_252495000, v150, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - PacketRxUnicastCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v147 forKeyedSubscript:@"wifiNetwork_PacketRxUnicastCount"];
          }
          v152 = *(void **)(a1 + 32);
          id v153 = [v117 readAttributePacketMulticastRxCountWithParams:0];
          v154 = [v152 numberOfReadValue:v153];

          if (v154)
          {
            v155 = (void *)MEMORY[0x2533B64D0]();
            id v156 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            v157 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v157, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v158 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v158;
              __int16 v195 = 2112;
              uint64_t v196 = v154;
              _os_log_impl(&dword_252495000, v157, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - PacketRxMulticastCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v154 forKeyedSubscript:@"wifiNetwork_PacketRxMulticastCount"];
          }
          v159 = *(void **)(a1 + 32);
          v160 = [v117 readAttributeBeaconRxCountWithParams:0];
          v125 = [v159 numberOfReadValue:v160];

          if (v125)
          {
            v161 = (void *)MEMORY[0x2533B64D0]();
            id v162 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            v163 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v164 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v164;
              __int16 v195 = 2112;
              uint64_t v196 = v125;
              _os_log_impl(&dword_252495000, v163, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - BeaconRxCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v125 forKeyedSubscript:@"wifiNetwork_BeaconRxCount"];
          }
        }
        else
        {
          v125 = 0;
        }
        if (([v120 unsignedIntegerValue] & 2) != 0)
        {
          v165 = [*(id *)(a1 + 32) errorCountOfWiFiNetworkDiagnostics:v117];

          if (v165)
          {
            v166 = (void *)MEMORY[0x2533B64D0]();
            id v167 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            v168 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v168, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v169 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v169;
              __int16 v195 = 2112;
              uint64_t v196 = v165;
              _os_log_impl(&dword_252495000, v168, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - ErrorCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v165 forKeyedSubscript:@"wifiNetwork_ErrorCount"];
          }
          v170 = *(void **)(a1 + 32);
          v171 = [v117 readAttributeBeaconLostCountWithParams:0];
          v125 = [v170 numberOfReadValue:v171];

          if (v125)
          {
            v172 = (void *)MEMORY[0x2533B64D0]();
            id v173 = *(id *)(a1 + 32);
            HMFGetOSLogHandle();
            v174 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
            {
              HMFGetLogIdentifier();
              id v175 = (id)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              id v194 = v175;
              __int16 v195 = 2112;
              uint64_t v196 = v125;
              _os_log_impl(&dword_252495000, v174, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - BeaconLostCount: %@", buf, 0x16u);
            }
            [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v125 forKeyedSubscript:@"wifiNetwork_BeaconLostCount"];
          }
        }
        v176 = *(void **)(a1 + 32);
        v177 = [v117 readAttributeChannelNumberWithParams:0];
        v178 = [v176 numberOfReadValue:v177];

        if (v178)
        {
          v179 = (void *)MEMORY[0x2533B64D0]();
          id v180 = *(id *)(a1 + 32);
          HMFGetOSLogHandle();
          v181 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v181, OS_LOG_TYPE_DEBUG))
          {
            HMFGetLogIdentifier();
            id v182 = (id)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            id v194 = v182;
            __int16 v195 = 2112;
            uint64_t v196 = v178;
            _os_log_impl(&dword_252495000, v181, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - ChannelNumber: %@", buf, 0x16u);
          }
          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v178 forKeyedSubscript:@"wifiNetwork_ChannelNumber"];
        }
        v183 = *(void **)(a1 + 32);
        v184 = [v117 readAttributeRSSIWithParams:0];
        v185 = [v183 numberOfReadValue:v184];

        uint64_t v9 = v190;
        if (v185)
        {
          v186 = (void *)MEMORY[0x2533B64D0]();
          id v187 = *(id *)(a1 + 32);
          HMFGetOSLogHandle();
          v188 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v188, OS_LOG_TYPE_DEBUG))
          {
            HMFGetLogIdentifier();
            id v189 = (id)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 138543618;
            id v194 = v189;
            __int16 v195 = 2112;
            uint64_t v196 = v185;
            _os_log_impl(&dword_252495000, v188, OS_LOG_TYPE_DEBUG, "%{public}@WiFiNetworkDiagnostics - RSSI: %@", buf, 0x16u);

            uint64_t v9 = v190;
          }

          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:v185 forKeyedSubscript:@"wifiNetwork_RSSI"];
        }

        uint64_t v12 = v191;
      }
      else if (v192)
      {
        [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setObject:MEMORY[0x263EFFA80] forKeyedSubscript:@"wifiNetwork_DiagnosticsSupported"];
      }
    }
  }
}

- (void)_handleAddNocCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)a3 fabricID:(id)a4 rootCACert:(id)a5 ipk:(id)a6 controllerNodeID:(id)a7 commissioneeNodeID:(id)a8 error:(id)a9
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v15 = a3;
  id v42 = a4;
  id v16 = a5;
  id v17 = a6;
  id v18 = a7;
  id v19 = a8;
  id v20 = a9;
  id v21 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v22 = self;
  __int16 v23 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    id v24 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    uint64_t v49 = v24;
    _os_log_impl(&dword_252495000, v23, OS_LOG_TYPE_INFO, "%{public}@Handling Add NOC response", buf, 0xCu);
  }
  if (v20)
  {
    id v25 = (void *)MEMORY[0x2533B64D0]();
    id v26 = v22;
    id v27 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      long long v28 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      uint64_t v49 = v28;
      __int16 v50 = 2112;
      id v51 = v20;
      _os_log_impl(&dword_252495000, v27, OS_LOG_TYPE_ERROR, "%{public}@Failed to add noc with error: %@", buf, 0x16u);
    }
    dispatch_group_leave(v15);
    id v29 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:19 error:v20];
    [(HMMTRAccessoryServer *)v26 _handlePairingFailureWithError:v20 context:v29];
  }
  else
  {
    [(HMMTRAccessoryServer *)v22 _notifyDelegateOfPairingStep:20];
    long long v30 = [(HMMTRAccessoryServer *)v22 storage];
    [v30 endLocalStorageModeByPersistingAppleFabricData];

    double v31 = [(HMMTRAccessoryServer *)v22 browser];
    id v32 = (void *)MEMORY[0x2533B64D0]();
    id v33 = v22;
    __int16 v34 = HMFGetOSLogHandle();
    long long v35 = v34;
    if (v31)
    {
      id v41 = v16;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
      {
        __int16 v36 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v49 = v36;
        _os_log_impl(&dword_252495000, v35, OS_LOG_TYPE_INFO, "%{public}@Switching to System Commissioner Fabric to complete commissioning...", buf, 0xCu);
      }
      uint64_t v37 = [(HAPAccessoryServer *)v33 clientQueue];
      v43[0] = MEMORY[0x263EF8330];
      v43[1] = 3221225472;
      v43[2] = __201__HMMTRAccessoryServer_SystemCommissionerPairing___handleAddNocCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup_fabricID_rootCACert_ipk_controllerNodeID_commissioneeNodeID_error___block_invoke;
      v43[3] = &unk_265375AD8;
      v43[4] = v33;
      id v29 = v31;
      id v44 = v29;
      id v45 = v15;
      id v46 = v42;
      id v47 = v19;
      id v16 = v41;
      [v29 finishSystemCommissionerFabricCommissioningWithFabricID:v46 rootCACert:v41 ipk:v17 controllerNodeID:v18 commissioneeNodeID:v47 queue:v37 completion:v43];
    }
    else
    {
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        id v38 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v49 = v38;
        _os_log_impl(&dword_252495000, v35, OS_LOG_TYPE_ERROR, "%{public}@Accessory Server Browser disappeared. Aborting pairing", buf, 0xCu);
      }
      dispatch_group_leave(v15);
      id v39 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:1 userInfo:0];
      id v40 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:20 error:v39];
      [(HMMTRAccessoryServer *)v33 _handlePairingFailureWithError:v39 context:v40];

      id v29 = 0;
    }
  }
}

void __201__HMMTRAccessoryServer_SystemCommissionerPairing___handleAddNocCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup_fabricID_rootCACert_ipk_controllerNodeID_commissioneeNodeID_error___block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v8)
  {
    id v10 = (void *)MEMORY[0x2533B64D0]();
    id v11 = *(id *)(a1 + 32);
    uint64_t v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = HMFGetLogIdentifier();
      int v77 = 138543618;
      uint64_t v78 = v13;
      __int16 v79 = 2112;
      id v80 = v8;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_ERROR, "%{public}@Failed to finish commissioning for System Commissioner with error: %@", (uint8_t *)&v77, 0x16u);
    }
    id v14 = [*(id *)(a1 + 32) storage];
    [v14 endLocalStorageModeBySyncingToRemote:0];

    uint64_t v15 = *(void **)(a1 + 40);
    id v16 = [*(id *)(a1 + 32) fabricID];
    [v15 setupStorageStateForHomeFabricID:v16];

    dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
    [*(id *)(a1 + 32) _handlePairingFailureWithError:v8 context:v9];
    goto LABEL_29;
  }
  id v17 = (void *)MEMORY[0x2533B64D0]([*(id *)(a1 + 32) _notifyDelegateOfPairingStep:22]);
  id v18 = *(id *)(a1 + 32);
  id v19 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
  {
    id v20 = HMFGetLogIdentifier();
    id v21 = *(void **)(a1 + 56);
    int v77 = 138543618;
    uint64_t v78 = v20;
    __int16 v79 = 2112;
    id v80 = v21;
    _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_INFO, "%{public}@Successfully commissioned accessory to System Commissioner Fabric (%@), updating storage", (uint8_t *)&v77, 0x16u);
  }
  uint64_t v22 = [*(id *)(a1 + 32) storage];
  [v22 addPairedNodeID:*(void *)(a1 + 64) toSystemCommissionerFabric:1];

  __int16 v23 = [*(id *)(a1 + 32) storage];
  id v24 = +[HMMTRStorage formatKeyForNodeId:*(void *)(a1 + 64) key:@"HMD.MTRPlugin.VendorID."];
  id v25 = [*(id *)(a1 + 32) vendorID];
  [v23 setValueForKey:v24 value:v25 systemCommissionerFabric:1];

  id v26 = [*(id *)(a1 + 32) storage];
  id v27 = +[HMMTRStorage formatKeyForNodeId:*(void *)(a1 + 64) key:@"HMD.MTRPlugin.FabricIndex."];
  [v26 setValueForKey:v27 value:*(void *)(a1 + 56) systemCommissionerFabric:1];

  long long v28 = [*(id *)(a1 + 32) storage];
  id v29 = +[HMMTRStorage formatKeyForNodeId:*(void *)(a1 + 64) key:@"HMD.MTRPlugin.ProductID."];
  long long v30 = [*(id *)(a1 + 32) productID];
  [v28 setValueForKey:v29 value:v30 systemCommissionerFabric:1];

  double v31 = [*(id *)(a1 + 32) storage];
  id v32 = +[HMMTRStorage formatKeyForNodeId:*(void *)(a1 + 64) key:@"HMD.MTRPlugin.Category."];
  id v33 = [*(id *)(a1 + 32) category];
  [v31 setValueForKey:v32 value:v33 systemCommissionerFabric:1];

  __int16 v34 = [*(id *)(a1 + 32) storage];
  long long v35 = +[HMMTRStorage formatKeyForNodeId:*(void *)(a1 + 64) key:@"HMD.MTRPlugin.ConfigNumber."];
  __int16 v36 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 32), "configNumber"));
  [v34 setValueForKey:v35 value:v36 systemCommissionerFabric:1];

  uint64_t v37 = [*(id *)(a1 + 32) storage];
  id v38 = +[HMMTRStorage formatKeyForNodeId:*(void *)(a1 + 64) key:@"HMD.MTRPlugin.Staged."];
  [v37 setValueForKey:v38 value:MEMORY[0x263EFFA80] systemCommissionerFabric:1];

  id v39 = [*(id *)(a1 + 32) topology];

  if (v39)
  {
    id v40 = [*(id *)(a1 + 32) storage];
    id v41 = +[HMMTRStorage formatKeyForNodeId:*(void *)(a1 + 64) key:@"HMD.MTRPlugin.Topology."];
    id v42 = [*(id *)(a1 + 32) topology];
    long long v43 = [v42 base64EncodedStringWithOptions:0];
    [v40 setValueForKey:v41 value:v43 systemCommissionerFabric:1];
  }
  id v44 = [MEMORY[0x263F08C38] UUID];
  id v45 = [*(id *)(a1 + 32) storage];
  id v46 = [v44 UUIDString];
  id v47 = [@"HMD.MTRPlugin.MTS.NodeIDForUUID." stringByAppendingString:v46];
  [v45 setValueForKey:v47 value:*(void *)(a1 + 64) systemCommissionerFabric:1];

  uint64_t v48 = [*(id *)(a1 + 32) storage];
  [v48 setUuid:v44 forSystemCommissionerFabricNode:*(void *)(a1 + 64)];

  if (v7)
  {
    uint64_t v49 = [*(id *)(a1 + 32) storage];
    [v49 setSerialNumber:v7 forSystemCommissionerFabricNode:*(void *)(a1 + 64)];
  }
  __int16 v50 = [*(id *)(a1 + 32) storage];
  id v51 = [*(id *)(a1 + 32) name];
  [v50 setDeviceName:v51 forSystemCommissionerFabricNode:*(void *)(a1 + 64)];

  uint64_t v52 = [*(id *)(a1 + 32) setupPayloadString];
  if (v52
    && (v53 = (void *)v52,
        [*(id *)(a1 + 32) setupPayloadString],
        id v54 = objc_claimAutoreleasedReturnValue(),
        char v55 = [v54 isEqual:&stru_2702A0B38],
        v54,
        v53,
        (v55 & 1) == 0))
  {
    id v60 = [*(id *)(a1 + 32) storage];
    uint64_t v61 = [*(id *)(a1 + 32) setupPayloadString];
  }
  else
  {
    uint64_t v56 = [*(id *)(a1 + 32) onboardingSetupPayloadString];
    if (!v56) {
      goto LABEL_18;
    }
    id v57 = (void *)v56;
    uint64_t v58 = [*(id *)(a1 + 32) onboardingSetupPayloadString];
    char v59 = [v58 isEqual:&stru_2702A0B38];

    if (v59) {
      goto LABEL_18;
    }
    id v60 = [*(id *)(a1 + 32) storage];
    uint64_t v61 = [*(id *)(a1 + 32) onboardingSetupPayloadString];
  }
  uint64_t v62 = (void *)v61;
  [v60 setSetupPayload:v61 forSystemCommissionerFabricNode:*(void *)(a1 + 64)];

LABEL_18:
  if (isFeatureMatterLocalFabricConfigEnabled())
  {
    id v63 = [*(id *)(a1 + 32) storage];
    objc_msgSend(v63, "setWEDSupported:forSystemCommissionerFabricNode:", objc_msgSend(*(id *)(a1 + 32), "isWEDDevice"), *(void *)(a1 + 64));

    if ([*(id *)(a1 + 32) isWEDDevice])
    {
      v64 = [*(id *)(a1 + 32) storage];
      uint64_t v65 = [*(id *)(a1 + 32) eMACAddress];
      [v64 setExtendedMACAddress:v65 forSystemCommissionerFabricNode:*(void *)(a1 + 64)];
    }
  }
  uint64_t v66 = *(void **)(a1 + 40);
  uint64_t v67 = [*(id *)(a1 + 32) vendorID];
  id v68 = [*(id *)(a1 + 32) productID];
  long long v69 = [*(id *)(a1 + 32) setupPayloadString];
  if ([v69 isEqual:&stru_2702A0B38])
  {
    [v66 cleanUpStaleSystemCommissionerPairingsWithNewlyPairedUUID:v44 vendorID:v67 productID:v68 serialNumber:v7 setupPayload:0];
  }
  else
  {
    id v70 = [*(id *)(a1 + 32) setupPayloadString];
    [v66 cleanUpStaleSystemCommissionerPairingsWithNewlyPairedUUID:v44 vendorID:v67 productID:v68 serialNumber:v7 setupPayload:v70];
  }
  long long v71 = (void *)MEMORY[0x2533B64D0]();
  id v72 = *(id *)(a1 + 32);
  long long v73 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
  {
    long long v74 = HMFGetLogIdentifier();
    int v77 = 138543362;
    uint64_t v78 = v74;
    _os_log_impl(&dword_252495000, v73, OS_LOG_TYPE_INFO, "%{public}@Successfully paired accessory into System Commissioner", (uint8_t *)&v77, 0xCu);
  }

  id v75 = *(void **)(a1 + 40);
  long long v76 = [*(id *)(a1 + 32) fabricID];
  [v75 setupStorageStateForHomeFabricID:v76];

  if ((isFeatureMatteriPhoneOnlyPairingControlEnabled() & 1) == 0)
  {
    [*(id *)(a1 + 32) setOperationDisabled:1];
    [*(id *)(a1 + 32) setOperationDisabledReason:1];
  }
  [*(id *)(a1 + 32) _handlePairOnSystemCommissionerFabricSuccess];
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
LABEL_29:
}

- (void)_handleNewSystemCommissionerFabricNodeID:(id)a3 dispatchGroup:(id)a4 fabricID:(id)a5 rootCACert:(id)a6 operationalPublicKey:(__SecKey *)a7 ipk:(id)a8 controllerNodeID:(id)a9 device:(id)a10
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  id v16 = a3;
  group = a4;
  id v17 = a5;
  id v18 = a6;
  id v50 = a8;
  id v49 = a9;
  id v19 = a10;
  id v20 = objc_alloc(MEMORY[0x263F10CA0]);
  id v21 = [(HAPAccessoryServer *)self clientQueue];
  id v47 = v19;
  id v46 = (void *)[v20 initWithDevice:v19 endpointID:&unk_2702B5388 queue:v21];

  id v22 = objc_alloc_init(MEMORY[0x263F10F10]);
  __int16 v23 = [(HMMTRAccessoryServer *)self browser];
  id v58 = 0;
  id v24 = [v23 createSystemCommissionerFabricNOCWithSigningCertificate:v18 operationalPublicKey:a7 fabricID:v17 nodeID:v16 caseAuthenticatedTags:0 error:&v58];
  id v25 = v58;

  if (!v24)
  {
    __int16 v36 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v37 = self;
    id v38 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      id v39 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v60 = v39;
      __int16 v61 = 2112;
      id v62 = v25;
      _os_log_impl(&dword_252495000, v38, OS_LOG_TYPE_ERROR, "%{public}@Failed to create system fabric NOC: %@", buf, 0x16u);
    }
    id v32 = group;
    dispatch_group_leave(group);
    id v40 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:18 error:v25];
    [(HMMTRAccessoryServer *)v37 _handlePairingFailureWithError:v25 context:v40];
    goto LABEL_12;
  }
  id v26 = [MEMORY[0x263F10CC0] convertX509Certificate:v24];
  [v22 setNocValue:v26];

  id v27 = [v22 nocValue];

  if (!v27)
  {
    id v41 = (void *)MEMORY[0x2533B64D0]();
    id v42 = self;
    long long v43 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      id v44 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v60 = v44;
      _os_log_impl(&dword_252495000, v43, OS_LOG_TYPE_ERROR, "%{public}@Failed to convert NOC to TLV format", buf, 0xCu);
    }
    id v32 = group;
    dispatch_group_leave(group);
    id v40 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:1 userInfo:0];
    id v45 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:18 error:v40];
    [(HMMTRAccessoryServer *)v42 _handlePairingFailureWithError:v40 context:v45];

LABEL_12:
    __int16 v34 = v49;
    id v33 = v50;
    long long v35 = v46;
    goto LABEL_13;
  }
  [v22 setIpkValue:v50];
  [v22 setCaseAdminSubject:v49];
  [v22 setAdminVendorId:&unk_2702B53B8];
  long long v28 = (void *)MEMORY[0x2533B64D0]([(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:19]);
  id v29 = self;
  long long v30 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
  {
    double v31 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    id v60 = v31;
    __int16 v61 = 2112;
    id v62 = v16;
    _os_log_impl(&dword_252495000, v30, OS_LOG_TYPE_INFO, "%{public}@Adding NOC for System Commissioner with node ID %@", buf, 0x16u);
  }
  v51[0] = MEMORY[0x263EF8330];
  v51[1] = 3221225472;
  v51[2] = __175__HMMTRAccessoryServer_SystemCommissionerPairing___handleNewSystemCommissionerFabricNodeID_dispatchGroup_fabricID_rootCACert_operationalPublicKey_ipk_controllerNodeID_device___block_invoke;
  v51[3] = &unk_265375AB0;
  v51[4] = v29;
  id v32 = group;
  uint64_t v52 = group;
  id v53 = v17;
  id v54 = v18;
  id v33 = v50;
  id v55 = v50;
  __int16 v34 = v49;
  id v56 = v49;
  id v57 = v16;
  long long v35 = v46;
  [v46 addNOCWithParams:v22 completion:v51];

LABEL_13:
}

uint64_t __175__HMMTRAccessoryServer_SystemCommissionerPairing___handleNewSystemCommissionerFabricNodeID_dispatchGroup_fabricID_rootCACert_operationalPublicKey_ipk_controllerNodeID_device___block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) _handleAddNocCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup:*(void *)(a1 + 40) fabricID:*(void *)(a1 + 48) rootCACert:*(void *)(a1 + 56) ipk:*(void *)(a1 + 64) controllerNodeID:*(void *)(a1 + 72) commissioneeNodeID:*(void *)(a1 + 80) error:a3];
}

- (void)_handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)a3 fabricID:(id)a4 rootCACert:(id)a5 operationalPublicKey:(__SecKey *)a6 ipk:(id)a7 controllerNodeID:(id)a8
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  id v14 = a3;
  id v15 = a4;
  id v16 = a5;
  id v17 = a7;
  id v18 = a8;
  id v19 = (void *)MEMORY[0x2533B64D0]();
  id v20 = self;
  id v21 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
  {
    id v22 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    id v49 = v22;
    _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_INFO, "%{public}@Handling AddTrustedRootCert response", buf, 0xCu);
  }
  __int16 v23 = [(HMMTRAccessoryServer *)v20 deviceController];
  if (v23)
  {
    id v24 = (void *)MEMORY[0x263F10CA8];
    id v25 = [(HMMTRAccessoryServer *)v20 nodeID];
    id v26 = [v24 deviceWithNodeID:v25 controller:v23];

    if (v26)
    {
      [(HMMTRAccessoryServer *)v20 _notifyDelegateOfPairingStep:18];
      id v27 = [(HMMTRAccessoryServer *)v20 browser];
      v40[0] = MEMORY[0x263EF8330];
      v40[1] = 3221225472;
      v40[2] = __216__HMMTRAccessoryServer_SystemCommissionerPairing___handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup_fabricID_rootCACert_operationalPublicKey_ipk_controllerNodeID___block_invoke;
      v40[3] = &unk_265375A88;
      v40[4] = v20;
      id v41 = v14;
      id v42 = v15;
      id v43 = v16;
      id v47 = a6;
      id v44 = v17;
      id v45 = v18;
      id v28 = v26;
      id v46 = v28;
      [v27 createNewSystemCommissionerFabricNodeIDWithCompletion:v40];
    }
    else
    {
      __int16 v34 = (void *)MEMORY[0x2533B64D0]();
      long long v35 = v20;
      __int16 v36 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        uint64_t v37 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v49 = v37;
        _os_log_impl(&dword_252495000, v36, OS_LOG_TYPE_ERROR, "%{public}@Could not commission system commissioner fabric because no device was paired", buf, 0xCu);
      }
      dispatch_group_leave(v14);
      id v38 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:1 userInfo:0];
      id v39 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:17 error:v38];
      [(HMMTRAccessoryServer *)v35 _handlePairingFailureWithError:v38 context:v39];

      id v28 = 0;
    }
  }
  else
  {
    id v29 = (void *)MEMORY[0x2533B64D0]();
    long long v30 = v20;
    double v31 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      id v32 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v49 = v32;
      _os_log_impl(&dword_252495000, v31, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled. Aborting system commissioner fabric commissioning.", buf, 0xCu);
    }
    dispatch_group_leave(v14);
    id v28 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
    id v33 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:17 error:v28];
    [(HMMTRAccessoryServer *)v30 _handlePairingFailureWithError:v28 context:v33];
  }
}

void __216__HMMTRAccessoryServer_SystemCommissionerPairing___handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup_fabricID_rootCACert_operationalPublicKey_ipk_controllerNodeID___block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __216__HMMTRAccessoryServer_SystemCommissionerPairing___handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup_fabricID_rootCACert_operationalPublicKey_ipk_controllerNodeID___block_invoke_2;
  block[3] = &unk_265375A60;
  id v5 = *(void **)(a1 + 40);
  block[4] = *(void *)(a1 + 32);
  id v10 = v3;
  id v11 = v5;
  id v12 = *(id *)(a1 + 48);
  id v6 = *(id *)(a1 + 56);
  uint64_t v7 = *(void *)(a1 + 88);
  id v13 = v6;
  uint64_t v17 = v7;
  id v14 = *(id *)(a1 + 64);
  id v15 = *(id *)(a1 + 72);
  id v16 = *(id *)(a1 + 80);
  id v8 = v3;
  dispatch_async(v4, block);
}

uint64_t __216__HMMTRAccessoryServer_SystemCommissionerPairing___handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup_fabricID_rootCACert_operationalPublicKey_ipk_controllerNodeID___block_invoke_2(uint64_t a1)
{
  return [*(id *)(a1 + 32) _handleNewSystemCommissionerFabricNodeID:*(void *)(a1 + 40) dispatchGroup:*(void *)(a1 + 48) fabricID:*(void *)(a1 + 56) rootCACert:*(void *)(a1 + 64) operationalPublicKey:*(void *)(a1 + 96) ipk:*(void *)(a1 + 72) controllerNodeID:*(void *)(a1 + 80) device:*(void *)(a1 + 88)];
}

- (void)_handleSystemCommissionerRootCertificate:(id)a3 fabricID:(id)a4 ipk:(id)a5 controllerNodeID:(id)a6 dispatchGroup:(id)a7 csrResponseParams:(id)a8 device:(id)a9
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  id v15 = a3;
  id v48 = a4;
  id v47 = a5;
  id v16 = a6;
  uint64_t v17 = a7;
  id v18 = a8;
  id v19 = a9;
  id v20 = objc_alloc(MEMORY[0x263F10CA0]);
  id v21 = [(HAPAccessoryServer *)self clientQueue];
  id v22 = (void *)[v20 initWithDevice:v19 endpointID:&unk_2702B5388 queue:v21];

  id v23 = objc_alloc_init(MEMORY[0x263F10F18]);
  id v24 = [MEMORY[0x263F10CC0] convertX509Certificate:v15];
  [v23 setRootCertificate:v24];

  id v25 = [v23 rootCertificate];

  if (v25)
  {
    id v26 = (void *)MEMORY[0x2533B64D0]([(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:17]);
    id v27 = self;
    id v28 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
    {
      HMFGetLogIdentifier();
      id v45 = v15;
      id v29 = v19;
      long long v30 = v17;
      double v31 = v22;
      id v32 = v18;
      v34 = id v33 = v16;
      *(_DWORD *)buf = 138543362;
      id v57 = v34;
      _os_log_impl(&dword_252495000, v28, OS_LOG_TYPE_INFO, "%{public}@Adding trusted root certificate", buf, 0xCu);

      id v16 = v33;
      id v18 = v32;
      id v22 = v31;
      uint64_t v17 = v30;
      id v19 = v29;
      id v15 = v45;
    }

    v49[0] = MEMORY[0x263EF8330];
    v49[1] = 3221225472;
    v49[2] = __161__HMMTRAccessoryServer_SystemCommissionerPairing___handleSystemCommissionerRootCertificate_fabricID_ipk_controllerNodeID_dispatchGroup_csrResponseParams_device___block_invoke;
    v49[3] = &unk_265375A38;
    v49[4] = v27;
    uint64_t v50 = v17;
    id v51 = v18;
    long long v35 = v48;
    id v52 = v48;
    id v53 = v15;
    __int16 v36 = v47;
    id v54 = v47;
    id v55 = v16;
    [v22 addTrustedRootCertificateWithParams:v23 completion:v49];
  }
  else
  {
    uint64_t v37 = (void *)MEMORY[0x2533B64D0]();
    id v38 = self;
    id v39 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      HMFGetLogIdentifier();
      id v46 = v22;
      id v40 = v18;
      v42 = id v41 = v16;
      *(_DWORD *)buf = 138543362;
      id v57 = v42;
      _os_log_impl(&dword_252495000, v39, OS_LOG_TYPE_ERROR, "%{public}@Failed to convert root CA cert to Matter certificate", buf, 0xCu);

      id v16 = v41;
      id v18 = v40;
      id v22 = v46;
    }

    dispatch_group_leave(v17);
    id v43 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:1 userInfo:0];
    id v44 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:16 error:v43];
    [(HMMTRAccessoryServer *)v38 _handlePairingFailureWithError:v43 context:v44];

    __int16 v36 = v47;
    long long v35 = v48;
  }
}

void __161__HMMTRAccessoryServer_SystemCommissionerPairing___handleSystemCommissionerRootCertificate_fabricID_ipk_controllerNodeID_dispatchGroup_csrResponseParams_device___block_invoke(uint64_t a1, void *a2)
{
  v41[2] = *MEMORY[0x263EF8340];
  CFDataRef v3 = a2;
  if (v3)
  {
    CFDataRef v4 = v3;
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = *(id *)(a1 + 32);
    uint64_t v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v8 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      long long v35 = v8;
      __int16 v36 = 2112;
      CFDataRef v37 = v4;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to add trusted root certificate with error: %@", buf, 0x16u);
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    id v9 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:16 error:v4];
    [*(id *)(a1 + 32) _handlePairingFailureWithError:v4 context:v9];
  }
  else
  {
    id v10 = [*(id *)(a1 + 48) nocsrElements];
    id v9 = +[HMMTRTLVParser csrFromNOCSRElements:v10];

    if (v9)
    {
      id v33 = 0;
      CFDataRef v11 = [MEMORY[0x263F10CC0] publicKeyFromCSR:v9 error:&v33];
      CFDataRef v4 = (const __CFData *)v33;
      if (v11)
      {
        uint64_t v12 = *MEMORY[0x263F16FB8];
        uint64_t v13 = *MEMORY[0x263F16F68];
        v40[0] = *MEMORY[0x263F16FA8];
        v40[1] = v13;
        uint64_t v14 = *MEMORY[0x263F16F80];
        v41[0] = v12;
        v41[1] = v14;
        CFDictionaryRef v15 = [NSDictionary dictionaryWithObjects:v41 forKeys:v40 count:2];
        CFErrorRef v32 = 0;
        SecKeyRef v16 = SecKeyCreateWithData(v11, v15, &v32);
        if (v16)
        {
          [*(id *)(a1 + 32) _handleAddTrustedRootCertificateCompletionDuringSystemCommissionerFabricCommissioningWithDispatchGroup:*(void *)(a1 + 40) fabricID:*(void *)(a1 + 56) rootCACert:*(void *)(a1 + 64) operationalPublicKey:v16 ipk:*(void *)(a1 + 72) controllerNodeID:*(void *)(a1 + 80)];
        }
        else
        {
          id v26 = (void *)MEMORY[0x2533B64D0]();
          id v27 = *(id *)(a1 + 32);
          id v28 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            id v29 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543874;
            long long v35 = v29;
            __int16 v36 = 2112;
            CFDataRef v37 = v11;
            __int16 v38 = 2112;
            CFErrorRef v39 = v32;
            _os_log_impl(&dword_252495000, v28, OS_LOG_TYPE_ERROR, "%{public}@Failed to create SecKey from %@: %@", buf, 0x20u);
          }
          dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
          long long v30 = v32;
          double v31 = +[HMMTRAccessoryPairingEndContext otherContextWithStep:16 error:v30];
          [*(id *)(a1 + 32) _handlePairingFailureWithError:v30 context:v31];
        }
      }
      else
      {
        id v22 = (void *)MEMORY[0x2533B64D0]();
        id v23 = *(id *)(a1 + 32);
        id v24 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          id v25 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          long long v35 = v25;
          __int16 v36 = 2112;
          CFDataRef v37 = v4;
          _os_log_impl(&dword_252495000, v24, OS_LOG_TYPE_ERROR, "%{public}@Failed to extract public key from CSR: %@", buf, 0x16u);
        }
        dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
        CFDictionaryRef v15 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:16 error:v4];
        [*(id *)(a1 + 32) _handlePairingFailureWithError:v4 context:v15];
        CFDataRef v11 = 0;
      }
    }
    else
    {
      uint64_t v17 = (void *)MEMORY[0x2533B64D0]();
      id v18 = *(id *)(a1 + 32);
      id v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        id v20 = HMFGetLogIdentifier();
        CFDataRef v21 = [*(id *)(a1 + 48) nocsrElements];
        *(_DWORD *)buf = 138543618;
        long long v35 = v20;
        __int16 v36 = 2112;
        CFDataRef v37 = v21;
        _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_ERROR, "%{public}@Failed to extract CSR from nocsr_elements: %@", buf, 0x16u);
      }
      dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
      CFDataRef v11 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:1 userInfo:0];
      CFDictionaryRef v15 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:16 error:v11];
      [*(id *)(a1 + 32) _handlePairingFailureWithError:v11 context:v15];
      CFDataRef v4 = 0;
    }
  }
}

- (void)_handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)a3 responseParams:(id)a4 error:(id)a5
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  CFDataRef v11 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v12 = self;
  uint64_t v13 = HMFGetOSLogHandle();
  uint64_t v14 = v13;
  if (v10)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v15 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      CFErrorRef v39 = v15;
      __int16 v40 = 2112;
      id v41 = v10;
      _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_ERROR, "%{public}@Failed CSR request with error: %@", buf, 0x16u);
    }
    dispatch_group_leave(v8);
    SecKeyRef v16 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:15 error:v10];
    [(HMMTRAccessoryServer *)v12 _handlePairingFailureWithError:v10 context:v16];
  }
  else
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      uint64_t v17 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      CFErrorRef v39 = v17;
      _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_INFO, "%{public}@Handling CSRResponse", buf, 0xCu);
    }
    SecKeyRef v16 = [(HMMTRAccessoryServer *)v12 deviceController];
    if (v16)
    {
      id v18 = (void *)MEMORY[0x263F10CA8];
      id v19 = [(HMMTRAccessoryServer *)v12 nodeID];
      id v20 = [v18 deviceWithNodeID:v19 controller:v16];

      if (v20)
      {
        [(HMMTRAccessoryServer *)v12 _notifyDelegateOfPairingStep:16];
        CFDataRef v21 = [(HMMTRAccessoryServer *)v12 browser];
        v34[0] = MEMORY[0x263EF8330];
        v34[1] = 3221225472;
        void v34[2] = __151__HMMTRAccessoryServer_SystemCommissionerPairing___handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup_responseParams_error___block_invoke;
        v34[3] = &unk_265375A10;
        v34[4] = v12;
        long long v35 = v8;
        id v36 = v9;
        id v22 = v20;
        id v37 = v22;
        [v21 fetchSystemCommissionerRootCertificateWithCompletion:v34];
      }
      else
      {
        id v28 = (void *)MEMORY[0x2533B64D0]();
        id v29 = v12;
        long long v30 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          double v31 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          CFErrorRef v39 = v31;
          __int16 v40 = 2112;
          id v41 = 0;
          _os_log_impl(&dword_252495000, v30, OS_LOG_TYPE_ERROR, "%{public}@Could not commission system commissioner fabric because no device was paired: %@", buf, 0x16u);
        }
        dispatch_group_leave(v8);
        CFErrorRef v32 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:1 userInfo:0];
        id v33 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:15 error:v32];
        [(HMMTRAccessoryServer *)v29 _handlePairingFailureWithError:v32 context:v33];

        id v22 = 0;
      }
    }
    else
    {
      id v23 = (void *)MEMORY[0x2533B64D0]();
      id v24 = v12;
      id v25 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        id v26 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        CFErrorRef v39 = v26;
        _os_log_impl(&dword_252495000, v25, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled. Aborting system commissioner fabric commissioning.", buf, 0xCu);
      }
      dispatch_group_leave(v8);
      id v22 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
      id v27 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:15 error:v22];
      [(HMMTRAccessoryServer *)v24 _handlePairingFailureWithError:v22 context:v27];
    }
  }
}

void __151__HMMTRAccessoryServer_SystemCommissionerPairing___handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup_responseParams_error___block_invoke(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  SecKeyRef v16 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __151__HMMTRAccessoryServer_SystemCommissionerPairing___handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup_responseParams_error___block_invoke_2;
  block[3] = &unk_2653759E8;
  id v24 = v11;
  id v25 = v15;
  uint64_t v17 = *(void **)(a1 + 40);
  uint64_t v26 = *(void *)(a1 + 32);
  id v27 = v17;
  id v28 = v12;
  id v29 = v13;
  id v30 = v14;
  id v31 = *(id *)(a1 + 48);
  id v32 = *(id *)(a1 + 56);
  id v18 = v14;
  id v19 = v13;
  id v20 = v12;
  id v21 = v15;
  id v22 = v11;
  dispatch_async(v16, block);
}

void __151__HMMTRAccessoryServer_SystemCommissionerPairing___handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup_responseParams_error___block_invoke_2(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 32) && !*(void *)(a1 + 40))
  {
    objc_msgSend(*(id *)(a1 + 48), "_handleSystemCommissionerRootCertificate:fabricID:ipk:controllerNodeID:dispatchGroup:csrResponseParams:device:", *(void *)(a1 + 96));
  }
  else
  {
    v2 = (void *)MEMORY[0x2533B64D0]();
    id v3 = *(id *)(a1 + 48);
    CFDataRef v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v5 = HMFGetLogIdentifier();
      uint64_t v6 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138543618;
      id v9 = v5;
      __int16 v10 = 2112;
      uint64_t v11 = v6;
      _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch root certificate: %@", buf, 0x16u);
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 56));
    uint64_t v7 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:16 error:*(void *)(a1 + 40)];
    [*(id *)(a1 + 48) _handlePairingFailureWithError:*(void *)(a1 + 40) context:v7];
  }
}

- (void)_handleArmFailSafeResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup:(id)a3 error:(id)a4
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  uint64_t v6 = a3;
  id v7 = a4;
  id v8 = (void *)MEMORY[0x2533B64D0]();
  id v9 = self;
  __int16 v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    uint64_t v11 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    uint64_t v42 = v11;
    _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Handling Arm fail safe response", buf, 0xCu);
  }
  if (v7)
  {
    uint64_t v12 = (void *)MEMORY[0x2533B64D0]();
    id v13 = v9;
    id v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      id v15 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      uint64_t v42 = v15;
      __int16 v43 = 2112;
      id v44 = v7;
      _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_ERROR, "%{public}@Failed to arm fail safe with error: %@", buf, 0x16u);
    }
    dispatch_group_leave(v6);
    SecKeyRef v16 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:14 error:v7];
    [(HMMTRAccessoryServer *)v13 _handlePairingFailureWithError:v7 context:v16];
  }
  else
  {
    SecKeyRef v16 = [(HMMTRAccessoryServer *)v9 deviceController];
    if (v16)
    {
      uint64_t v17 = (void *)MEMORY[0x263F10CA8];
      id v18 = [(HMMTRAccessoryServer *)v9 nodeID];
      id v19 = [v17 deviceWithNodeID:v18 controller:v16];

      if (v19)
      {
        [(HMMTRAccessoryServer *)v9 _notifyDelegateOfPairingStep:15];
        id v20 = objc_alloc(MEMORY[0x263F10CA0]);
        id v21 = [(HAPAccessoryServer *)v9 clientQueue];
        id v22 = (void *)[v20 initWithDevice:v19 endpointID:&unk_2702B5388 queue:v21];

        id v23 = objc_alloc_init(MEMORY[0x263F10F20]);
        id v24 = [MEMORY[0x263EFF990] dataWithCapacity:32];
        int v25 = 8;
        do
        {
          *(_DWORD *)buf = 0;
          *(_DWORD *)buf = arc4random();
          [v24 appendBytes:buf length:4];
          --v25;
        }
        while (v25);
        uint64_t v26 = (void *)MEMORY[0x2533B64D0]([v23 setCsrNonce:v24]);
        id v27 = v9;
        id v28 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          HMFGetLogIdentifier();
          v29 = __int16 v38 = v26;
          *(_DWORD *)buf = 138543362;
          uint64_t v42 = v29;
          _os_log_impl(&dword_252495000, v28, OS_LOG_TYPE_INFO, "%{public}@Sending CSRRequest", buf, 0xCu);

          uint64_t v26 = v38;
        }

        v39[0] = MEMORY[0x263EF8330];
        v39[1] = 3221225472;
        v39[2] = __144__HMMTRAccessoryServer_SystemCommissionerPairing___handleArmFailSafeResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup_error___block_invoke;
        v39[3] = &unk_2653759C0;
        v39[4] = v27;
        __int16 v40 = v6;
        [v22 CSRRequestWithParams:v23 completion:v39];
      }
      else
      {
        __int16 v34 = (void *)MEMORY[0x2533B64D0]();
        long long v35 = v9;
        id v36 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          id v37 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543362;
          uint64_t v42 = v37;
          _os_log_impl(&dword_252495000, v36, OS_LOG_TYPE_ERROR, "%{public}@Could not commission system commissioner fabric because no device was paired", buf, 0xCu);
        }
        dispatch_group_leave(v6);
        id v22 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:1 userInfo:0];
        id v23 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:14 error:v22];
        [(HMMTRAccessoryServer *)v35 _handlePairingFailureWithError:v22 context:v23];
      }
    }
    else
    {
      id v30 = (void *)MEMORY[0x2533B64D0]();
      id v31 = v9;
      id v32 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        id v33 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v42 = v33;
        _os_log_impl(&dword_252495000, v32, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled. Aborting system commissioner fabric commissioning.", buf, 0xCu);
      }
      dispatch_group_leave(v6);
      id v19 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
      id v22 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:14 error:v19];
      [(HMMTRAccessoryServer *)v31 _handlePairingFailureWithError:v19 context:v22];
    }
  }
}

uint64_t __144__HMMTRAccessoryServer_SystemCommissionerPairing___handleArmFailSafeResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup_error___block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) _handleCSRResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup:*(void *)(a1 + 40) responseParams:a2 error:a3];
}

- (void)_pairOnSystemCommissionerFabric
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  id v3 = (void *)MEMORY[0x2533B64D0]([(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:13]);
  CFDataRef v4 = self;
  id v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    id v44 = v6;
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@Pairing with system commissioner fabric after successful Apple Home pairing", buf, 0xCu);
  }
  [(HMMTRAccessoryServer *)v4 setBlockInvalidation:1];
  uint64_t v7 = random();
  id v8 = (void *)MEMORY[0x2533B64D0]();
  id v9 = v4;
  __int16 v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    uint64_t v11 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    id v44 = v11;
    __int16 v45 = 2048;
    uint64_t v46 = v7;
    _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Commissioning with system commissioner fabric job(%lu) queued.", buf, 0x16u);
  }
  uint64_t v12 = (void *)MEMORY[0x2533B64D0]();
  id v13 = v9;
  id v14 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    id v15 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    id v44 = v15;
    __int16 v45 = 2048;
    uint64_t v46 = v7;
    _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Commissioning with system commissioner fabric job(%lu) started.", buf, 0x16u);
  }
  SecKeyRef v16 = dispatch_group_create();
  dispatch_group_enter(v16);
  uint64_t v17 = [(HMMTRAccessoryServer *)v13 deviceController];
  if (v17)
  {
    id v18 = (void *)MEMORY[0x263F10CA8];
    id v19 = [(HMMTRAccessoryServer *)v13 nodeID];
    id v20 = [v18 deviceWithNodeID:v19 controller:v17];

    if (v20)
    {
      uint64_t v39 = v7;
      [(HMMTRAccessoryServer *)v13 _notifyDelegateOfPairingStep:14];
      id v21 = objc_alloc(MEMORY[0x263F10C90]);
      id v22 = [(HAPAccessoryServer *)v13 clientQueue];
      id v23 = (void *)[v21 initWithDevice:v20 endpointID:&unk_2702B5388 queue:v22];

      id v24 = objc_alloc_init(MEMORY[0x263F10EB0]);
      [v24 setExpiryLengthSeconds:&unk_2702B53A0];
      int v25 = (void *)MEMORY[0x2533B64D0]([v24 setBreadcrumb:&unk_2702B5388]);
      uint64_t v26 = v13;
      id v27 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
      {
        id v28 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v44 = v28;
        _os_log_impl(&dword_252495000, v27, OS_LOG_TYPE_INFO, "%{public}@Arming fail safe", buf, 0xCu);
      }
      v41[0] = MEMORY[0x263EF8330];
      v41[1] = 3221225472;
      v41[2] = __82__HMMTRAccessoryServer_SystemCommissionerPairing___pairOnSystemCommissionerFabric__block_invoke;
      void v41[3] = &unk_265375998;
      v41[4] = v26;
      uint64_t v42 = v16;
      [v23 armFailSafeWithParams:v24 completion:v41];

      uint64_t v7 = v39;
    }
    else
    {
      __int16 v34 = (void *)MEMORY[0x2533B64D0]();
      long long v35 = v13;
      id v36 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        id v37 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v44 = v37;
        _os_log_impl(&dword_252495000, v36, OS_LOG_TYPE_ERROR, "%{public}@Could not commission system commissioner fabric because no device was paired", buf, 0xCu);
      }
      dispatch_group_leave(v16);
      id v23 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:1 userInfo:0];
      id v24 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:13 error:v23];
      [(HMMTRAccessoryServer *)v35 _handlePairingFailureWithError:v23 context:v24];
    }

    __int16 v38 = [(HAPAccessoryServer *)v13 clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __82__HMMTRAccessoryServer_SystemCommissionerPairing___pairOnSystemCommissionerFabric__block_invoke_13;
    block[3] = &unk_265377168;
    void block[4] = v13;
    void block[5] = v7;
    dispatch_group_notify(v16, v38, block);
  }
  else
  {
    id v29 = (void *)MEMORY[0x2533B64D0]();
    id v30 = v13;
    id v31 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      id v32 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v44 = v32;
      _os_log_impl(&dword_252495000, v31, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to commission with system commissioner fabric", buf, 0xCu);
    }
    dispatch_group_leave(v16);
    id v20 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:1 userInfo:0];
    id v33 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:13 error:v20];
    [(HMMTRAccessoryServer *)v30 _handlePairingFailureWithError:v20 context:v33];
  }
}

uint64_t __82__HMMTRAccessoryServer_SystemCommissionerPairing___pairOnSystemCommissionerFabric__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) _handleArmFailSafeResponseDuringSystemCommissionerFabricCommissioningWithDispatchGroup:*(void *)(a1 + 40) error:a3];
}

uint64_t __82__HMMTRAccessoryServer_SystemCommissionerPairing___pairOnSystemCommissionerFabric__block_invoke_13(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  CFDataRef v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v8 = 138543618;
    id v9 = v5;
    __int16 v10 = 2048;
    uint64_t v11 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Commissioning with system commissioner fabric job(%lu) completed.", (uint8_t *)&v8, 0x16u);
  }
  return [*(id *)(a1 + 32) setBlockInvalidation:0];
}

- (void)_pairOnSystemCommissionerFabricUnlessAlreadyPairedWithRootPublicKey:(id)a3
{
  id v4 = a3;
  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:10];
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = __119__HMMTRAccessoryServer_SystemCommissionerPairing___pairOnSystemCommissionerFabricUnlessAlreadyPairedWithRootPublicKey___block_invoke;
  v6[3] = &unk_2653778A0;
  v6[4] = self;
  id v7 = v4;
  id v5 = v4;
  [(HMMTRAccessoryServer *)self fetchPairingsWithCompletionHandler:v6];
}

void __119__HMMTRAccessoryServer_SystemCommissionerPairing___pairOnSystemCommissionerFabricUnlessAlreadyPairedWithRootPublicKey___block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v7)
  {
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    id v10 = v7;
    uint64_t v11 = [v10 countByEnumeratingWithState:&v25 objects:v29 count:16];
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)v26;
      while (2)
      {
        uint64_t v14 = 0;
        do
        {
          if (*(void *)v26 != v13) {
            objc_enumerationMutation(v10);
          }
          id v15 = objc_msgSend(*(id *)(*((void *)&v25 + 1) + 8 * v14), "rootPublicKey", (void)v25);
          int v16 = [v15 isEqual:*(void *)(a1 + 40)];

          if (v16)
          {
            uint64_t v17 = (void *)MEMORY[0x2533B64D0]();
            id v18 = *(id *)(a1 + 32);
            id v19 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
            {
              id v20 = HMFGetLogIdentifier();
              *(_DWORD *)buf = 138543362;
              id v31 = v20;
              _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_INFO, "%{public}@Accessory is already paired to system commissioner fabric. Completing Apple Home pairing.", buf, 0xCu);
            }
            if ((isFeatureMatteriPhoneOnlyPairingControlEnabled() & 1) == 0)
            {
              [*(id *)(a1 + 32) setOperationDisabled:1];
              [*(id *)(a1 + 32) setOperationDisabledReason:1];
            }
            [*(id *)(a1 + 32) _handlePairOnSystemCommissionerFabricSuccess];

            goto LABEL_19;
          }
          ++v14;
        }
        while (v12 != v14);
        uint64_t v12 = [v10 countByEnumeratingWithState:&v25 objects:v29 count:16];
        if (v12) {
          continue;
        }
        break;
      }
    }

    [*(id *)(a1 + 32) _pairOnSystemCommissionerFabric];
  }
  else
  {
    id v21 = (void *)MEMORY[0x2533B64D0]();
    id v22 = *(id *)(a1 + 32);
    id v23 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      id v24 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v31 = v24;
      __int16 v32 = 2112;
      id v33 = v8;
      _os_log_impl(&dword_252495000, v23, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch pairings from newly paired accessory: %@", buf, 0x16u);
    }
    [*(id *)(a1 + 32) _handlePairingFailureWithError:v8 context:v9];
  }
LABEL_19:
}

- (void).cxx_destruct
{
  objc_storeStrong(&self->_descriptorClusterManager, 0);
  objc_storeStrong((id *)&self->_reportDistributor, 0);
  objc_storeStrong((id *)&self->_bridgedAccessoryReachabilityReaderTimeoutNSecs, 0);
  objc_storeStrong((id *)&self->_residentReachabilityUpdateWaitTimer, 0);
  objc_storeStrong((id *)&self->_commissioningFailureOverridingError, 0);
  objc_storeStrong((id *)&self->_characteristicProtocolMappingStates, 0);
  objc_storeStrong(&self->_chipReportHandler, 0);
  objc_storeStrong((id *)&self->_matterDevice, 0);
  objc_destroyWeak((id *)&self->_diagnosticsEventDelegate);
  objc_storeStrong((id *)&self->_matterFirmwareUpdateStatus, 0);
  objc_storeStrong((id *)&self->_otaApplyUpdateRequestTimer, 0);
  objc_storeStrong((id *)&self->_otaAnnounceTimer, 0);
  objc_storeStrong((id *)&self->_otaUpdateTimer, 0);
  objc_storeStrong((id *)&self->_otaFileOffset, 0);
  objc_storeStrong((id *)&self->_otaFileHandle, 0);
  objc_storeStrong((id *)&self->_otaUpdateToken, 0);
  objc_storeStrong((id *)&self->_topology, 0);
  objc_storeStrong((id *)&self->_onboardingSetupPayloadString, 0);
  objc_storeStrong((id *)&self->_setupPayloadString, 0);
  objc_storeStrong((id *)&self->_setUpPINCode, 0);
  objc_storeStrong((id *)&self->_discriminator, 0);
  objc_storeStrong((id *)&self->_pendingMTRDeviceReadReadyHandlers, 0);
  objc_storeStrong((id *)&self->_objectID, 0);
  objc_storeStrong((id *)&self->_commissioneeNetworks, 0);
  objc_storeStrong((id *)&self->_commissioneeNetworkCommissioningClusterEndpoint, 0);
  objc_storeStrong((id *)&self->_initialMTRDeviceStateTimeoutId, 0);
  objc_storeStrong((id *)&self->_doorLockClusterFuture, 0);
  objc_storeStrong((id *)&self->_doorLockCluster, 0);
  objc_storeStrong((id *)&self->_serviceEnumerationFromDeviceCompletionHandlers, 0);
  objc_storeStrong((id *)&self->_hapEnumerator, 0);
  objc_storeStrong((id *)&self->_pairingDurationDictionary, 0);
  objc_storeStrong((id *)&self->_currentMetricBundle, 0);
  objc_storeStrong(&self->_defaultThreadOperationalDatasetReceiveBlock, 0);
  objc_storeStrong((id *)&self->_defaultThreadOperationalDataset, 0);
  objc_storeStrong((id *)&self->_lastFabricLabelUpdateError, 0);
  objc_storeStrong((id *)&self->_lastPendingFabricLabel, 0);
  objc_storeStrong((id *)&self->_originalPairingAttemptOperationalCert, 0);
  objc_storeStrong((id *)&self->_originalPairingAttemptRootCert, 0);
  objc_storeStrong((id *)&self->_currentPairingInfo, 0);
  objc_storeStrong((id *)&self->_stateCaptureDeviceConnectedTimer, 0);
  objc_storeStrong((id *)&self->_stateCaptureConfigChangeTimer, 0);
  objc_storeStrong((id *)&self->_pairingTimer, 0);
  objc_storeStrong(&self->_stageCompletion, 0);
  objc_storeStrong(&self->_stageProgressUpdateHandler, 0);
  objc_storeStrong(&self->_stageThreadScanResultsHandler, 0);
  objc_storeStrong(&self->_stageWiFiScanResultsHandler, 0);
  objc_storeStrong(&self->_stageDeviceCredentialHandler, 0);
  objc_storeStrong((id *)&self->_reachabilityManager, 0);
  objc_destroyWeak((id *)&self->_storage);
  objc_destroyWeak((id *)&self->_browser);
  objc_storeStrong((id *)&self->_attributeTimers, 0);
  objc_storeStrong((id *)&self->_controllerWrapper, 0);
  objc_storeStrong((id *)&self->_eMACAddress, 0);
  objc_storeStrong((id *)&self->_productNameFromDcl, 0);
  objc_storeStrong((id *)&self->_vendorNameFromDcl, 0);
  objc_storeStrong((id *)&self->_clusterIDCharacteristicMap, 0);
  objc_storeStrong((id *)&self->_softwareVersionString, 0);
  objc_storeStrong((id *)&self->_softwareVersionNumber, 0);
  objc_storeStrong((id *)&self->_pairingTargetFabric, 0);
  objc_storeStrong((id *)&self->_pairingTargetHomeUUID, 0);
  objc_storeStrong((id *)&self->_fabricID, 0);
  objc_destroyWeak((id *)&self->_hmdHAPAccessoryDelegate);
  objc_destroyWeak((id *)&self->_chipDelegate);
  objc_storeStrong((id *)&self->_deviceConnectedStateCaptureInformation, 0);
  objc_storeStrong((id *)&self->_partsListStateCaptureInformation, 0);
  objc_storeStrong((id *)&self->_maxMetricDuration, 0);
  objc_storeStrong((id *)&self->_activity, 0);
  objc_storeStrong((id *)&self->_supportedLinkLayerTypes, 0);
  objc_storeStrong((id *)&self->_nodeID, 0);
  objc_storeStrong((id *)&self->_productID, 0);
  objc_storeStrong((id *)&self->_vendorID, 0);
  objc_storeStrong((id *)&self->_commissioningID, 0);
  objc_storeStrong((id *)&self->_primaryAccessory, 0);
  objc_storeStrong((id *)&self->_pairingEndContextWhenRemove, 0);
  objc_storeStrong((id *)&self->_removeReason, 0);
}

- (void)setOperationDisabled:(BOOL)a3
{
  self->_operationDisabled = a3;
}

- (BOOL)operationDisabled
{
  return self->_operationDisabled;
}

- (void)setDescriptorClusterManager:(id)a3
{
}

- (id)descriptorClusterManager
{
  return objc_getProperty(self, a2, 1024, 1);
}

- (HMMTRAttributeReportDistributor)reportDistributor
{
  return self->_reportDistributor;
}

- (void)setBridgedAccessoryReachabilityReaderTimeoutNSecs:(id)a3
{
}

- (NSNumber)bridgedAccessoryReachabilityReaderTimeoutNSecs
{
  return self->_bridgedAccessoryReachabilityReaderTimeoutNSecs;
}

- (void)setMtrDeviceConnected:(BOOL)a3
{
  self->_mtrDeviceConnected = a3;
}

- (BOOL)mtrDeviceConnected
{
  return self->_mtrDeviceConnected;
}

- (void)setMtrDeviceStateReported:(BOOL)a3
{
  self->_mtrDeviceStateReported = a3;
}

- (BOOL)mtrDeviceStateReported
{
  return self->_mtrDeviceStateReported;
}

- (void)setResidentReachabilityUpdateWaitTimer:(id)a3
{
}

- (HMFTimer)residentReachabilityUpdateWaitTimer
{
  return self->_residentReachabilityUpdateWaitTimer;
}

- (void)setCommissioningFailureOverridingError:(id)a3
{
}

- (NSError)commissioningFailureOverridingError
{
  return self->_commissioningFailureOverridingError;
}

- (NSMutableDictionary)characteristicProtocolMappingStates
{
  return self->_characteristicProtocolMappingStates;
}

- (void)setDeferStartThreadForPairing:(BOOL)a3
{
  self->_deferStartThreadForPairing = a3;
}

- (BOOL)deferStartThreadForPairing
{
  return self->_deferStartThreadForPairing;
}

- (void)setBlockInvalidation:(BOOL)a3
{
  self->_blockInvalidation = a3;
}

- (BOOL)blockInvalidation
{
  return self->_blockInvalidation;
}

- (void)setRemovalInProgress:(BOOL)a3
{
  self->_removalInProgress = a3;
}

- (BOOL)removalInProgress
{
  return self->_removalInProgress;
}

- (void)setChipReportHandler:(id)a3
{
}

- (id)chipReportHandler
{
  return objc_getProperty(self, a2, 976, 1);
}

- (void)setMatterDevice:(id)a3
{
}

- (MTRDevice)matterDevice
{
  return (MTRDevice *)objc_getProperty(self, a2, 968, 1);
}

- (void)setDelayDiscovery:(BOOL)a3
{
  self->_delayDiscovery = a3;
}

- (BOOL)delayDiscovery
{
  return self->_delayDiscovery;
}

- (void)setDiagnosticsEventDelegate:(id)a3
{
}

- (HMMTRAccessoryServerDiagnosticsEventDelegate)diagnosticsEventDelegate
{
  id WeakRetained = objc_loadWeakRetained((id *)&self->_diagnosticsEventDelegate);
  return (HMMTRAccessoryServerDiagnosticsEventDelegate *)WeakRetained;
}

- (void)setServiceEnumerationFailed:(BOOL)a3
{
  self->_serviceEnumerationFailed = a3;
}

- (BOOL)serviceEnumerationFailed
{
  return self->_serviceEnumerationFailed;
}

- (void)setHasPriorSuccessfulPairing:(BOOL)a3
{
  self->_hasPriorSuccessfulPairing = a3;
}

- (BOOL)hasPriorSuccessfulPairing
{
  return self->_hasPriorSuccessfulPairing;
}

- (void)setStorageUpdatePending:(BOOL)a3
{
  self->_storageUpdatePending = a3;
}

- (BOOL)storageUpdatePending
{
  return self->_storageUpdatePending;
}

- (void)setMatterFirmwareUpdateStatus:(id)a3
{
}

- (HMMTRFirmwareUpdateStatus)matterFirmwareUpdateStatus
{
  return self->_matterFirmwareUpdateStatus;
}

- (void)setOtaApplyUpdateRequestTimer:(id)a3
{
}

- (HMMTROTAApplyUpdateRequestTimer)otaApplyUpdateRequestTimer
{
  return self->_otaApplyUpdateRequestTimer;
}

- (void)setOtaAnnounceTimer:(id)a3
{
}

- (HMMTROTAAnnounceTimer)otaAnnounceTimer
{
  return self->_otaAnnounceTimer;
}

- (void)setOtaUpdateTimer:(id)a3
{
}

- (HMMTROTAApplyUpdateTimer)otaUpdateTimer
{
  return self->_otaUpdateTimer;
}

- (void)setOtaFileOffset:(id)a3
{
}

- (NSNumber)otaFileOffset
{
  return (NSNumber *)objc_getProperty(self, a2, 920, 1);
}

- (void)setOtaFileHandle:(id)a3
{
}

- (NSFileHandle)otaFileHandle
{
  return (NSFileHandle *)objc_getProperty(self, a2, 912, 1);
}

- (void)setOtaUpdateToken:(id)a3
{
}

- (NSData)otaUpdateToken
{
  return (NSData *)objc_getProperty(self, a2, 904, 1);
}

- (void)setTopology:(id)a3
{
}

- (NSData)topology
{
  return self->_topology;
}

- (void)setOnboardingSetupPayloadString:(id)a3
{
}

- (NSString)onboardingSetupPayloadString
{
  return self->_onboardingSetupPayloadString;
}

- (void)setSetupPayloadString:(id)a3
{
}

- (NSString)setupPayloadString
{
  return self->_setupPayloadString;
}

- (void)setSetUpPINCode:(id)a3
{
}

- (NSNumber)setUpPINCode
{
  return self->_setUpPINCode;
}

- (void)setDiscriminatorIsOriginatedFromShort:(BOOL)a3
{
  self->_discriminatorIsOriginatedFromShort = a3;
}

- (BOOL)discriminatorIsOriginatedFromShort
{
  return self->_discriminatorIsOriginatedFromShort;
}

- (void)setDiscriminator:(id)a3
{
}

- (NSNumber)discriminator
{
  return self->_discriminator;
}

- (NSMutableDictionary)pendingMTRDeviceReadReadyHandlers
{
  return self->_pendingMTRDeviceReadReadyHandlers;
}

- (NSNumber)objectID
{
  return self->_objectID;
}

- (void)setCommissioneeHasActiveNetwork:(BOOL)a3
{
  self->_commissioneeHasActiveNetworuint64_t k = a3;
}

- (BOOL)commissioneeHasActiveNetwork
{
  return self->_commissioneeHasActiveNetwork;
}

- (void)setCommissioneeNetworks:(id)a3
{
}

- (NSArray)commissioneeNetworks
{
  return self->_commissioneeNetworks;
}

- (void)setCommissioneeNetworkCommissioningClusterEndpoint:(id)a3
{
}

- (NSNumber)commissioneeNetworkCommissioningClusterEndpoint
{
  return self->_commissioneeNetworkCommissioningClusterEndpoint;
}

- (void)setControllerRevokeHandlerRegistered:(BOOL)a3
{
  self->_controllerRevokeHandlerRegistered = a3;
}

- (BOOL)controllerRevokeHandlerRegistered
{
  return self->_controllerRevokeHandlerRegistered;
}

- (void)setInitialMTRDeviceStateTimeoutId:(id)a3
{
}

- (NSUUID)initialMTRDeviceStateTimeoutId
{
  return (NSUUID *)objc_getProperty(self, a2, 824, 1);
}

- (void)setDoorLockClusterFuture:(id)a3
{
}

- (HMFFuture)doorLockClusterFuture
{
  return (HMFFuture *)objc_getProperty(self, a2, 816, 1);
}

- (void)setDoorLockCluster:(id)a3
{
}

- (HMMTRSyncClusterDoorLock)doorLockCluster
{
  return (HMMTRSyncClusterDoorLock *)objc_getProperty(self, a2, 808, 1);
}

- (void)setFullServiceEnumerationPendingCachePrimedEvent:(BOOL)a3
{
  self->_fullServiceEnumerationPendingCachePrimedEvent = a3;
}

- (BOOL)fullServiceEnumerationPendingCachePrimedEvent
{
  return self->_fullServiceEnumerationPendingCachePrimedEvent;
}

- (NSMutableArray)serviceEnumerationFromDeviceCompletionHandlers
{
  return (NSMutableArray *)objc_getProperty(self, a2, 800, 1);
}

- (void)setServiceEnumerationInProgress:(BOOL)a3
{
  self->_serviceEnumerationInProgress = a3;
}

- (BOOL)serviceEnumerationInProgress
{
  return self->_serviceEnumerationInProgress;
}

- (void)setServicesEnumerated:(BOOL)a3
{
  self->_servicesEnumerated = a3;
}

- (BOOL)servicesEnumerated
{
  return self->_servicesEnumerated;
}

- (HMMTRHAPEnumerator)hapEnumerator
{
  return self->_hapEnumerator;
}

- (void)setPairingDurationDictionary:(id)a3
{
}

- (NSMutableDictionary)pairingDurationDictionary
{
  return self->_pairingDurationDictionary;
}

- (void)setCurrentMetricBundle:(id)a3
{
}

- (HMMTRMetricBundle)currentMetricBundle
{
  return self->_currentMetricBundle;
}

- (void)setDefaultThreadOperationalDatasetReceiveBlock:(id)a3
{
}

- (id)defaultThreadOperationalDatasetReceiveBlock
{
  return self->_defaultThreadOperationalDatasetReceiveBlock;
}

- (void)setDefaultThreadOperationalDatasetRetrieved:(BOOL)a3
{
  self->_defaultThreadOperationalDatasetRetrieved = a3;
}

- (BOOL)defaultThreadOperationalDatasetRetrieved
{
  return self->_defaultThreadOperationalDatasetRetrieved;
}

- (void)setDefaultThreadOperationalDataset:(id)a3
{
}

- (NSData)defaultThreadOperationalDataset
{
  return self->_defaultThreadOperationalDataset;
}

- (void)setLastFabricLabelUpdateError:(id)a3
{
}

- (NSError)lastFabricLabelUpdateError
{
  return self->_lastFabricLabelUpdateError;
}

- (void)setLastPendingFabricLabel:(id)a3
{
}

- (NSArray)lastPendingFabricLabel
{
  return self->_lastPendingFabricLabel;
}

- (void)setOperationDisabledReason:(unint64_t)a3
{
  self->_operationDisabledReason = a3;
}

- (unint64_t)operationDisabledReason
{
  return self->_operationDisabledReason;
}

- (void)setShouldPairWithoutResident:(BOOL)a3
{
  self->_shouldPairWithoutResident = a3;
}

- (BOOL)shouldPairWithoutResident
{
  return self->_shouldPairWithoutResident;
}

- (void)setOriginalPairingAttemptOperationalCert:(id)a3
{
}

- (NSData)originalPairingAttemptOperationalCert
{
  return self->_originalPairingAttemptOperationalCert;
}

- (void)setOriginalPairingAttemptRootCert:(id)a3
{
}

- (NSData)originalPairingAttemptRootCert
{
  return self->_originalPairingAttemptRootCert;
}

- (void)setPairingUsingMatterSupport:(BOOL)a3
{
  self->_pairingUsingMatterSupport = a3;
}

- (BOOL)pairingUsingMatterSupport
{
  return self->_pairingUsingMatterSupport;
}

- (void)setDeviceConnectedStateHandle:(unint64_t)a3
{
  self->_deviceConnectedStateHandle = a3;
}

- (unint64_t)deviceConnectedStateHandle
{
  return self->_deviceConnectedStateHandle;
}

- (void)setPartsListStateCaptureHandle:(unint64_t)a3
{
  self->_partsListStateCaptureHandle = a3;
}

- (unint64_t)partsListStateCaptureHandle
{
  return self->_partsListStateCaptureHandle;
}

- (void)setCurrentPairingInfo:(id)a3
{
}

- (HMMTRPairing)currentPairingInfo
{
  return self->_currentPairingInfo;
}

- (void)setNetworkProvisioningFailures:(unsigned int)a3
{
  self->_networkProvisioningFailures = a3;
}

- (unsigned)networkProvisioningFailures
{
  return self->_networkProvisioningFailures;
}

- (void)setCommissioningCompleted:(BOOL)a3
{
  self->_commissioningCompleted = a3;
}

- (BOOL)commissioningCompleted
{
  return self->_commissioningCompleted;
}

- (void)setCommissioningSessionEstablished:(BOOL)a3
{
  self->_commissioningSessionEstablished = a3;
}

- (BOOL)commissioningSessionEstablished
{
  return self->_commissioningSessionEstablished;
}

- (void)setStateCaptureDeviceConnectedTimer:(id)a3
{
}

- (HMFTimer)stateCaptureDeviceConnectedTimer
{
  return self->_stateCaptureDeviceConnectedTimer;
}

- (void)setStateCaptureConfigChangeTimer:(id)a3
{
}

- (HMFTimer)stateCaptureConfigChangeTimer
{
  return self->_stateCaptureConfigChangeTimer;
}

- (void)setPairingTimer:(id)a3
{
}

- (HMFTimer)pairingTimer
{
  return self->_pairingTimer;
}

- (void)setStageCompletion:(id)a3
{
}

- (id)stageCompletion
{
  return self->_stageCompletion;
}

- (void)setStageNetworkScanRequested:(BOOL)a3
{
  self->_stageNetworkScanRequested = a3;
}

- (BOOL)stageNetworkScanRequested
{
  return self->_stageNetworkScanRequested;
}

- (void)setStageProgressUpdateHandler:(id)a3
{
}

- (id)stageProgressUpdateHandler
{
  return self->_stageProgressUpdateHandler;
}

- (void)setStageThreadScanResultsHandler:(id)a3
{
}

- (id)stageThreadScanResultsHandler
{
  return self->_stageThreadScanResultsHandler;
}

- (void)setStageWiFiScanResultsHandler:(id)a3
{
}

- (id)stageWiFiScanResultsHandler
{
  return self->_stageWiFiScanResultsHandler;
}

- (void)setStageDeviceCredentialHandler:(id)a3
{
}

- (id)stageDeviceCredentialHandler
{
  return self->_stageDeviceCredentialHandler;
}

- (void)setReachabilityManager:(id)a3
{
}

- (HMMTRAccessoryReachabilityManager)reachabilityManager
{
  return self->_reachabilityManager;
}

- (void)setStorage:(id)a3
{
}

- (HMMTRStorage)storage
{
  id WeakRetained = objc_loadWeakRetained((id *)&self->_storage);
  return (HMMTRStorage *)WeakRetained;
}

- (void)setBrowser:(id)a3
{
}

- (HMMTRAccessoryServerBrowser)browser
{
  id WeakRetained = objc_loadWeakRetained((id *)&self->_browser);
  return (HMMTRAccessoryServerBrowser *)WeakRetained;
}

- (void)setAttributeTimers:(id)a3
{
}

- (NSMutableDictionary)attributeTimers
{
  return self->_attributeTimers;
}

- (void)setControllerWrapper:(id)a3
{
}

- (HMMTRControllerWrapper)controllerWrapper
{
  return (HMMTRControllerWrapper *)objc_getProperty(self, a2, 592, 1);
}

- (void)setEMACAddress:(id)a3
{
}

- (NSString)eMACAddress
{
  return self->_eMACAddress;
}

- (void)setWedDevice:(BOOL)a3
{
  self->_wedDevice = a3;
}

- (BOOL)isWEDDevice
{
  return self->_wedDevice;
}

- (void)setCertified:(BOOL)a3
{
  self->_certified = a3;
}

- (BOOL)isCertified
{
  return self->_certified;
}

- (void)setProductNameFromDcl:(id)a3
{
}

- (NSString)productNameFromDcl
{
  return self->_productNameFromDcl;
}

- (void)setVendorNameFromDcl:(id)a3
{
}

- (NSString)vendorNameFromDcl
{
  return self->_vendorNameFromDcl;
}

- (void)setClusterIDCharacteristicMap:(id)a3
{
}

- (void)setSoftwareVersionString:(id)a3
{
}

- (void)setSoftwareVersionNumber:(id)a3
{
}

- (void)setPairingTargetFabric:(id)a3
{
}

- (HMMTRFabric)pairingTargetFabric
{
  return (HMMTRFabric *)objc_getProperty(self, a2, 536, 1);
}

- (void)setPairingTargetHomeUUID:(id)a3
{
}

- (NSUUID)pairingTargetHomeUUID
{
  return (NSUUID *)objc_getProperty(self, a2, 528, 1);
}

- (void)setFabricID:(id)a3
{
}

- (NSNumber)fabricID
{
  return self->_fabricID;
}

- (void)setHmdHAPAccessoryDelegate:(id)a3
{
}

- (HMMTRHMDHAPAccessoryDelegate)hmdHAPAccessoryDelegate
{
  id WeakRetained = objc_loadWeakRetained((id *)&self->_hmdHAPAccessoryDelegate);
  return (HMMTRHMDHAPAccessoryDelegate *)WeakRetained;
}

- (void)setChipDelegate:(id)a3
{
}

- (HMMTRAccessoryServerDelegate)chipDelegate
{
  id WeakRetained = objc_loadWeakRetained((id *)&self->_chipDelegate);
  return (HMMTRAccessoryServerDelegate *)WeakRetained;
}

- (void)setDeviceConnectedStateCaptureInformation:(id)a3
{
}

- (NSString)deviceConnectedStateCaptureInformation
{
  return self->_deviceConnectedStateCaptureInformation;
}

- (void)setPartsListStateCaptureInformation:(id)a3
{
}

- (NSString)partsListStateCaptureInformation
{
  return self->_partsListStateCaptureInformation;
}

- (void)setMaxMetricDuration:(id)a3
{
}

- (HMMTRDuration)maxMetricDuration
{
  return self->_maxMetricDuration;
}

- (HMFActivity)activity
{
  return self->_activity;
}

- (void)setRequiresThreadRouter:(BOOL)a3
{
  self->_requiresThreadRouter = a3;
}

- (BOOL)requiresThreadRouter
{
  return self->_requiresThreadRouter;
}

- (void)setNodeID:(id)a3
{
}

- (NSNumber)nodeID
{
  return self->_nodeID;
}

- (void)setProductID:(id)a3
{
}

- (NSNumber)productID
{
  return self->_productID;
}

- (void)setVendorID:(id)a3
{
}

- (NSNumber)vendorID
{
  return self->_vendorID;
}

- (void)setCommissioningID:(id)a3
{
}

- (NSUUID)commissioningID
{
  return self->_commissioningID;
}

- (void)setKnownToSystemCommissioner:(BOOL)a3
{
  self->_knownToSystemCommissioner = a3;
}

- (BOOL)knownToSystemCommissioner
{
  return self->_knownToSystemCommissioner;
}

- (void)setBleScanPending:(BOOL)a3
{
  self->_bleScanPending = a3;
}

- (BOOL)bleScanPending
{
  return self->_bleScanPending;
}

- (void)setDiscoveredOverBLE:(BOOL)a3
{
  self->_discoveredOverBLE = a3;
}

- (BOOL)discoveredOverBLE
{
  return self->_discoveredOverBLE;
}

- (void)setLocallyDiscovered:(BOOL)a3
{
  self->_locallyDiscovered = a3;
}

- (BOOL)locallyDiscovered
{
  return self->_locallyDiscovered;
}

- (unint64_t)hash
{
  id v3 = [(HAPAccessoryServer *)self identifier];
  uint64_t v4 = [v3 hash];

  id v5 = [(HMMTRAccessoryServer *)self nodeID];
  unint64_t v6 = [v5 hash] ^ v4;

  return v6;
}

- (BOOL)isEqual:(id)a3
{
  uint64_t v4 = (HMMTRAccessoryServer *)a3;
  id v5 = v4;
  if (!v4) {
    goto LABEL_6;
  }
  if (self == v4)
  {
    char v12 = 1;
    goto LABEL_10;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    unint64_t v6 = v5;
    id v7 = [(HAPAccessoryServer *)v6 identifier];
    id v8 = [(HAPAccessoryServer *)self identifier];
    int v9 = [v7 isEqual:v8];

    if (v9)
    {
      id v10 = [(HMMTRAccessoryServer *)v6 nodeID];
      uint64_t v11 = [(HMMTRAccessoryServer *)self nodeID];
      char v12 = [v10 isEqual:v11];
    }
    else
    {
      char v12 = 0;
    }
  }
  else
  {
LABEL_6:
    char v12 = 0;
  }
LABEL_10:

  return v12;
}

- (id)attributeDescriptions
{
  v31[8] = *MEMORY[0x263EF8340];
  id v3 = objc_alloc(MEMORY[0x263F424F8]);
  id v30 = [(HAPAccessoryServer *)self name];
  id v29 = (void *)[v3 initWithName:@"Name" value:v30];
  v31[0] = v29;
  id v4 = objc_alloc(MEMORY[0x263F424F8]);
  long long v28 = [(HAPAccessoryServer *)self identifier];
  long long v27 = (void *)[v4 initWithName:@"Identifier" value:v28];
  v31[1] = v27;
  id v5 = objc_alloc(MEMORY[0x263F424F8]);
  unint64_t v6 = NSNumber;
  long long v26 = [(HMMTRAccessoryServer *)self rootPublicKey];
  long long v25 = objc_msgSend(v6, "numberWithUnsignedInteger:", objc_msgSend(v26, "hash"));
  id v24 = (void *)[v5 initWithName:@"Root Public Key Hash" value:v25];
  v31[2] = v24;
  id v7 = objc_alloc(MEMORY[0x263F424F8]);
  id v23 = [(HMMTRAccessoryServer *)self nodeID];
  id v8 = (void *)[v7 initWithName:@"NodeID" value:v23];
  v31[3] = v8;
  id v9 = objc_alloc(MEMORY[0x263F424F8]);
  id v10 = [(HAPAccessoryServer *)self category];
  uint64_t v11 = (void *)[v9 initWithName:@"Category" value:v10];
  v31[4] = v11;
  id v12 = objc_alloc(MEMORY[0x263F424F8]);
  uint64_t v13 = [(HMMTRAccessoryServer *)self vendorID];
  uint64_t v14 = (void *)[v12 initWithName:@"VID" value:v13];
  v31[5] = v14;
  id v15 = objc_alloc(MEMORY[0x263F424F8]);
  int v16 = [(HMMTRAccessoryServer *)self productID];
  uint64_t v17 = (void *)[v15 initWithName:@"PID" value:v16];
  v31[6] = v17;
  id v18 = objc_alloc(MEMORY[0x263F424F8]);
  id v19 = [(HMMTRAccessoryServer *)self controllerWrapper];
  id v20 = (void *)[v18 initWithName:@"Controller" value:v19];
  v31[7] = v20;
  id v21 = [MEMORY[0x263EFF8C0] arrayWithObjects:v31 count:8];

  return v21;
}

- (id)privateDescription
{
  id v3 = NSString;
  id v4 = [(id)objc_opt_class() shortDescription];
  id v5 = [(HAPAccessoryServer *)self identifier];
  unint64_t v6 = [v3 stringWithFormat:@"%@ %@", v4, v5];

  return v6;
}

- (id)logIdentifier
{
  id v3 = NSString;
  id v4 = [(HMMTRAccessoryServer *)self nodeID];
  id v5 = [(HMMTRAccessoryServer *)self fabricID];
  unint64_t v6 = [(HMMTRAccessoryServer *)self objectID];
  id v7 = [v3 stringWithFormat:@"%@/%@(%@)", v4, v5, v6];

  return v7;
}

- (id)mtrDeviceWithNodeID:(id)a3 controller:(id)a4
{
  return (id)[MEMORY[0x263F10DA8] deviceWithNodeID:a3 controller:a4];
}

- (void)dispatchAfter:(unint64_t)a3 block:(id)a4
{
  id v6 = a4;
  id v7 = [(HAPAccessoryServer *)self clientQueue];
  dispatch_after(a3, v7, v6);
}

- (void)_notifyDelegateOfMTRMetrics:(id)a3
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    int v12 = 138543618;
    uint64_t v13 = v8;
    __int16 v14 = 2048;
    id v15 = v4;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Notifying delegate of mtr metrics %p", (uint8_t *)&v12, 0x16u);
  }
  id v9 = [(HAPAccessoryServer *)v6 delegate];
  if ([v9 conformsToProtocol:&unk_2702F5258]) {
    id v10 = v9;
  }
  else {
    id v10 = 0;
  }
  id v11 = v10;

  [v11 notifyMTRMetrics:v4];
}

- (void)_notifyDelegateOfPairingStep:(unint64_t)a3
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v5 = (void *)MEMORY[0x2533B64D0](self, a2);
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    id v9 = HMMTRAccessoryPairingStepAsString(a3);
    int v13 = 138543618;
    __int16 v14 = v8;
    __int16 v15 = 2112;
    uint64_t v16 = v9;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Notifying matter metric pairing step %@", (uint8_t *)&v13, 0x16u);
  }
  id v10 = [(HAPAccessoryServer *)v6 delegate];
  if ([v10 conformsToProtocol:&unk_2702F5258]) {
    id v11 = v10;
  }
  else {
    id v11 = 0;
  }
  id v12 = v11;

  [v12 notifyMatterAccessoryPairingStep:a3];
}

- (void)deviceConfigurationChanged:(id)a3
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    long long v25 = v8;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@MTRDevice configuration changed", buf, 0xCu);
  }
  if (![(HMMTRAccessoryServer *)v6 isPaired]
    || [(HMMTRAccessoryServer *)v6 isKnownToSystemCommissioner])
  {
    id v9 = (void *)MEMORY[0x2533B64D0]();
    id v10 = v6;
    id v11 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
LABEL_10:

      goto LABEL_11;
    }
    id v12 = HMFGetLogIdentifier();
    BOOL v13 = [(HMMTRAccessoryServer *)v10 isPaired];
    __int16 v14 = "is not paired yet";
    if (v13) {
      __int16 v14 = "is for system commissioner";
    }
    *(_DWORD *)buf = 138543618;
    long long v25 = v12;
    __int16 v26 = 2080;
    long long v27 = v14;
    _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_INFO, "%{public}@No enumeration because server %s", buf, 0x16u);
LABEL_9:

    goto LABEL_10;
  }
  v23[0] = MEMORY[0x263EF8330];
  v23[1] = 3221225472;
  v23[2] = __51__HMMTRAccessoryServer_deviceConfigurationChanged___block_invoke;
  v23[3] = &unk_265376E00;
  v23[4] = v6;
  [(HMMTRAccessoryServer *)v6 enumerateHAPServices:v23];
  if (HAPIsInternalBuild())
  {
    __int16 v15 = [(HMMTRAccessoryServer *)v6 browser];
    if (([v15 isCurrentDevicePrimaryResident] & 1) == 0)
    {

      goto LABEL_11;
    }
    uint64_t v16 = [(HMMTRAccessoryServer *)v6 stateCaptureConfigChangeTimer];

    if (!v16)
    {
      uint64_t v17 = (void *)[objc_alloc(MEMORY[0x263F42658]) initWithTimeInterval:0 options:600.0];
      [(HMMTRAccessoryServer *)v6 setStateCaptureConfigChangeTimer:v17];

      id v18 = [(HAPAccessoryServer *)v6 clientQueue];
      id v19 = [(HMMTRAccessoryServer *)v6 stateCaptureConfigChangeTimer];
      [v19 setDelegateQueue:v18];

      id v20 = [(HMMTRAccessoryServer *)v6 stateCaptureConfigChangeTimer];
      [v20 setDelegate:v6];

      id v21 = [(HMMTRAccessoryServer *)v6 stateCaptureConfigChangeTimer];
      [v21 resume];

      id v9 = (void *)MEMORY[0x2533B64D0]();
      id v10 = v6;
      id v11 = HMFGetOSLogHandle();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_INFO)) {
        goto LABEL_10;
      }
      id v12 = HMFGetLogIdentifier();
      id v22 = [(HAPAccessoryServer *)v10 name];
      *(_DWORD *)buf = 138543874;
      long long v25 = v12;
      __int16 v26 = 2112;
      long long v27 = v22;
      __int16 v28 = 2112;
      id v29 = &unk_2702B5C58;
      _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_INFO, "%{public}@State Capture: Setting timer to capture state information due to configuration change for accessory %@, timeout is %@", buf, 0x20u);

      goto LABEL_9;
    }
  }
LABEL_11:
}

void __51__HMMTRAccessoryServer_deviceConfigurationChanged___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    int v8 = 138543362;
    id v9 = v7;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Enumeration per configuration change complete", (uint8_t *)&v8, 0xCu);
  }
}

- (void)deviceCachePrimed:(id)a3
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    int v8 = HMFGetLogIdentifier();
    int v14 = 138543362;
    __int16 v15 = v8;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@MTRDevice cache primed", (uint8_t *)&v14, 0xCu);
  }
  id v9 = [(HMMTRAccessoryServer *)v6 reportDistributor];
  [v9 allAttributesReady];

  if (![(HMMTRAccessoryServer *)v6 serviceEnumerationInProgress]
    && [(HMMTRAccessoryServer *)v6 fullServiceEnumerationPendingCachePrimedEvent])
  {
    uint64_t v10 = (void *)MEMORY[0x2533B64D0]();
    id v11 = v6;
    id v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      BOOL v13 = HMFGetLogIdentifier();
      int v14 = 138543362;
      __int16 v15 = v13;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_INFO, "%{public}@Triggering service enumeration upon cache primed event", (uint8_t *)&v14, 0xCu);
    }
    [(HMMTRAccessoryServer *)v11 setFullServiceEnumerationPendingCachePrimedEvent:0];
    [(HMMTRAccessoryServer *)v11 _rebuildHAPServicesFromCHIPWithCompletionHandler:0];
  }
}

- (void)handleEventReportForNotification:(id)a3
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  id obj = a3;
  uint64_t v4 = [obj countByEnumeratingWithState:&v50 objects:v60 count:16];
  if (v4)
  {
    uint64_t v6 = v4;
    uint64_t v7 = *(void *)v51;
    uint64_t v8 = *MEMORY[0x263F10BC0];
    uint64_t v42 = *MEMORY[0x263F10BD0];
    *(void *)&long long v5 = 138543874;
    long long v40 = v5;
    uint64_t v43 = *(void *)v51;
    uint64_t v44 = *MEMORY[0x263F10BC0];
    do
    {
      uint64_t v9 = 0;
      uint64_t v45 = v6;
      do
      {
        if (*(void *)v51 != v7) {
          objc_enumerationMutation(obj);
        }
        uint64_t v10 = *(void **)(*((void *)&v50 + 1) + 8 * v9);
        id v11 = objc_msgSend(v10, "objectForKeyedSubscript:", v8, v40);
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          id v12 = v11;
        }
        else {
          id v12 = 0;
        }
        id v13 = v12;

        int v14 = [v13 isEqual:MEMORY[0x263EFFA88]];
        if (v14)
        {
          __int16 v15 = (void *)MEMORY[0x2533B64D0]();
          uint64_t v16 = self;
          uint64_t v17 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
          {
            id v18 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543618;
            id v55 = v18;
            __int16 v56 = 2112;
            id v57 = v10;
            _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_INFO, "%{public}@HMMTRAccessoryServer handleEventReportForNotification: Ignoring event report, this is an outdated report. event report=%@", buf, 0x16u);
          }
        }
        else
        {
          id v19 = objc_alloc(MEMORY[0x263F10EA8]);
          id v49 = 0;
          id v20 = (void *)[v19 initWithResponseValue:v10 error:&v49];
          id v21 = v49;
          id v22 = v21;
          if (v20)
          {
            id v48 = v21;
            id v23 = [v10 objectForKeyedSubscript:v42];
            objc_opt_class();
            if (objc_opt_isKindOfClass()) {
              id v24 = v23;
            }
            else {
              id v24 = 0;
            }
            id v25 = v24;

            uint64_t v47 = v25;
            __int16 v26 = [v25 endpoint];
            long long v27 = [(HMMTRAccessoryServer *)self _hapAccessoryAtEndpoint:v26];

            __int16 v28 = [MEMORY[0x263F42530] internalOnlyInitializer];
            id v29 = (void *)MEMORY[0x2533B64D0]();
            uint64_t v30 = self;
            id v31 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
            {
              HMFGetLogIdentifier();
              __int16 v32 = v41 = v29;
              [v28 UUID];
              v34 = id v33 = self;
              *(_DWORD *)buf = v40;
              id v55 = v32;
              __int16 v56 = 2112;
              id v57 = v34;
              __int16 v58 = 2112;
              char v59 = v10;
              _os_log_impl(&dword_252495000, v31, OS_LOG_TYPE_INFO, "%{public}@[NewFlow: %@] HMMTRAccessoryServer Handling parsed event report=%@", buf, 0x20u);

              self = v33;
              id v29 = v41;
            }

            long long v35 = [(HMMTRAccessoryServer *)v30 hmdHAPAccessoryDelegate];
            [v35 handleEventReport:v20 dictionary:v10 flow:v28 hapAccessory:v27];

            uint64_t v7 = v43;
            uint64_t v8 = v44;
            id v22 = v48;
          }
          else
          {
            id v36 = (void *)MEMORY[0x2533B64D0]();
            id v37 = self;
            __int16 v38 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
            {
              uint64_t v39 = HMFGetLogIdentifier();
              *(_DWORD *)buf = v40;
              id v55 = v39;
              __int16 v56 = 2112;
              id v57 = v10;
              __int16 v58 = 2112;
              char v59 = v22;
              _os_log_impl(&dword_252495000, v38, OS_LOG_TYPE_INFO, "%{public}@Received event %@ is not parsed: %@", buf, 0x20u);

              uint64_t v8 = v44;
            }
          }

          uint64_t v6 = v45;
        }
        ++v9;
      }
      while (v6 != v9);
      uint64_t v6 = [obj countByEnumeratingWithState:&v50 objects:v60 count:16];
    }
    while (v6);
  }
}

- (void)device:(id)a3 receivedEventReport:(id)a4
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  id v22 = a3;
  id v5 = a4;
  group = dispatch_group_create();
  v42[0] = 0;
  v42[1] = v42;
  v42[2] = 0x3032000000;
  v42[3] = __Block_byref_object_copy__8456;
  v42[4] = __Block_byref_object_dispose__8457;
  id v43 = objc_alloc_init(MEMORY[0x263EFF980]);
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  id obj = v5;
  uint64_t v6 = [obj countByEnumeratingWithState:&v38 objects:v54 count:16];
  if (v6)
  {
    uint64_t v27 = *(void *)v39;
    uint64_t v26 = *MEMORY[0x263F10BD0];
    uint64_t v23 = *MEMORY[0x263F10B90];
    do
    {
      uint64_t v7 = 0;
      uint64_t v24 = v6;
      do
      {
        if (*(void *)v39 != v27) {
          objc_enumerationMutation(obj);
        }
        uint64_t v8 = *(void **)(*((void *)&v38 + 1) + 8 * v7);
        uint64_t v9 = [v8 objectForKeyedSubscript:v26];
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = 0;
        }
        id v11 = v10;

        dispatch_group_enter(group);
        context = (void *)MEMORY[0x2533B64D0]();
        id v12 = self;
        HMFGetOSLogHandle();
        id v13 = (id)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
        {
          HMFGetLogIdentifier();
          id v14 = (id)objc_claimAutoreleasedReturnValue();
          __int16 v15 = [v11 endpoint];
          uint64_t v16 = [v11 cluster];
          uint64_t v17 = [v11 event];
          id v18 = [v8 objectForKeyedSubscript:v23];
          *(_DWORD *)buf = 138544386;
          id v45 = v14;
          __int16 v46 = 2112;
          uint64_t v47 = v15;
          __int16 v48 = 2112;
          id v49 = v16;
          __int16 v50 = 2112;
          long long v51 = v17;
          __int16 v52 = 2112;
          long long v53 = v18;
          _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Handling Event Report: endpoint:%@ cluster:%@ event:%@ value:%@", buf, 0x34u);

          uint64_t v6 = v24;
        }

        v34[0] = MEMORY[0x263EF8330];
        v34[1] = 3221225472;
        void v34[2] = __51__HMMTRAccessoryServer_device_receivedEventReport___block_invoke;
        v34[3] = &unk_265377F00;
        v34[4] = v12;
        id v19 = v11;
        id v35 = v19;
        id v37 = v42;
        id v36 = group;
        [(HMMTRAccessoryServer *)v12 _updatedCharacteristicsForEventReport:v8 completionHandler:v34];
        [(HMMTRAccessoryServer *)v12 _handleDiagnosticsEvent:v8];

        ++v7;
      }
      while (v6 != v7);
      uint64_t v6 = [obj countByEnumeratingWithState:&v38 objects:v54 count:16];
    }
    while (v6);
  }

  id v20 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __51__HMMTRAccessoryServer_device_receivedEventReport___block_invoke_906;
  block[3] = &unk_265377F50;
  id v33 = v42;
  void block[4] = self;
  id v32 = obj;
  id v21 = obj;
  dispatch_group_notify(group, v20, block);

  _Block_object_dispose(v42, 8);
}

void __51__HMMTRAccessoryServer_device_receivedEventReport___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (![v3 count])
  {
    uint64_t v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    uint64_t v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = HMFGetLogIdentifier();
      uint64_t v8 = [*(id *)(a1 + 40) endpoint];
      uint64_t v9 = [*(id *)(a1 + 40) cluster];
      int v10 = 138543874;
      id v11 = v7;
      __int16 v12 = 2112;
      id v13 = v8;
      __int16 v14 = 2112;
      __int16 v15 = v9;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_DEBUG, "%{public}@No characteristic found for event report: endpoint:%@ cluster:%@", (uint8_t *)&v10, 0x20u);
    }
  }
  [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) addObjectsFromArray:v3];
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

uint64_t __51__HMMTRAccessoryServer_device_receivedEventReport___block_invoke_906(uint64_t a1)
{
  v2 = [*(id *)(a1 + 32) delegate];
  [v2 accessoryServer:*(void *)(a1 + 32) didUpdateValuesForCharacteristics:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) stateNumber:0 broadcast:0];

  if ((_os_feature_enabled_impl() & 1) != 0
    || (_os_feature_enabled_impl() & 1) != 0
    || HM_FEATURE_RVC_DEFAULTS_ENABLED()
    || (_os_feature_enabled_impl() & 1) != 0
    || (uint64_t result = CFPreferencesGetAppBooleanValue(@"MatterTTU", @"/Library/Managed Preferences/mobile/com.apple.homed.plist", 0), result))
  {
    uint64_t v4 = *(void **)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    return [v4 handleEventReportForNotification:v5];
  }
  return result;
}

- (void)processAttributeReport:(id)a3
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  id v4 = a3;
  uint64_t v5 = dispatch_group_create();
  v38[0] = 0;
  v38[1] = v38;
  v38[2] = 0x3032000000;
  v38[3] = __Block_byref_object_copy__8456;
  v38[4] = __Block_byref_object_dispose__8457;
  id v39 = objc_alloc_init(MEMORY[0x263EFF980]);
  dispatch_group_enter(v5);
  uint64_t v6 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v7 = self;
  HMFGetOSLogHandle();
  uint64_t v8 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v9 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    id v42 = v9;
    __int16 v43 = 2112;
    id v44 = v4;
    _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Processing Attribute Report: %@", buf, 0x16u);
  }
  id v37 = 0;
  int v10 = (void *)[objc_alloc(MEMORY[0x263F10C58]) initWithResponseValue:v4 error:&v37];
  id v11 = v37;
  __int16 v12 = (void *)MEMORY[0x263F10B70];
  if (!v10)
  {
    context = (void *)MEMORY[0x2533B64D0]();
    id v13 = v7;
    HMFGetOSLogHandle();
    __int16 v14 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      id v15 = v11;
      HMFGetLogIdentifier();
      id v16 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v17 = [v4 objectForKeyedSubscript:*v12];
      *(_DWORD *)buf = 138543874;
      id v42 = v16;
      __int16 v43 = 2112;
      id v44 = v17;
      __int16 v45 = 2112;
      id v46 = v15;
      _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_INFO, "%{public}@Attribute report %@ is not parsed into a known struct: %@", buf, 0x20u);

      id v11 = v15;
    }
  }
  id v18 = [v4 objectForKeyedSubscript:*v12];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v19 = v18;
  }
  else {
    id v19 = 0;
  }
  id v20 = v19;

  id v21 = [v20 endpoint];
  id v22 = [(HMMTRAccessoryServer *)v7 _hapAccessoryAtEndpoint:v21];

  uint64_t v23 = [(HMMTRAccessoryServer *)v7 hmdHAPAccessoryDelegate];
  [v23 handleAttributeReport:v10 dictionary:v4 hapAccessory:v22];

  v32[0] = MEMORY[0x263EF8330];
  v32[1] = 3221225472;
  v32[2] = __47__HMMTRAccessoryServer_processAttributeReport___block_invoke;
  v32[3] = &unk_265377F00;
  id v24 = v4;
  id v33 = v24;
  uint64_t v34 = v7;
  id v36 = v38;
  id v25 = v5;
  id v35 = v25;
  [(HMMTRAccessoryServer *)v7 _updatedCharacteristicsForAttributeReport:v24 completionHandler:v32];
  uint64_t v26 = [(HAPAccessoryServer *)v7 clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __47__HMMTRAccessoryServer_processAttributeReport___block_invoke_905;
  block[3] = &unk_265377F28;
  void block[4] = v7;
  void block[5] = v38;
  dispatch_group_notify(v25, v26, block);

  id v40 = v24;
  uint64_t v27 = [MEMORY[0x263EFF8C0] arrayWithObjects:&v40 count:1];
  __int16 v28 = [(HMMTRAccessoryServer *)v7 chipReportHandler];
  if (v28)
  {
    id v29 = [v27 encodedCHIPReports];
    ((void (**)(void, void *))v28)[2](v28, v29);
  }
  _Block_object_dispose(v38, 8);
}

void __47__HMMTRAccessoryServer_processAttributeReport___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (![v3 count])
  {
    id v4 = [*(id *)(a1 + 32) objectForKeyedSubscript:*MEMORY[0x263F10B70]];
    uint64_t v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = *(id *)(a1 + 40);
    uint64_t v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = HMFGetLogIdentifier();
      uint64_t v9 = [v4 endpoint];
      int v10 = [v4 cluster];
      int v11 = 138543874;
      __int16 v12 = v8;
      __int16 v13 = 2112;
      __int16 v14 = v9;
      __int16 v15 = 2112;
      id v16 = v10;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_DEBUG, "%{public}@No characteristic found for attribute report: endpoint:%@ cluster:%@", (uint8_t *)&v11, 0x20u);
    }
  }
  [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) addObjectsFromArray:v3];
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

void __47__HMMTRAccessoryServer_processAttributeReport___block_invoke_905(uint64_t a1)
{
  if ((objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), "hmf_isEmpty") & 1) == 0)
  {
    id v2 = [*(id *)(a1 + 32) delegate];
    [v2 accessoryServer:*(void *)(a1 + 32) didUpdateValuesForCharacteristics:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) stateNumber:0 broadcast:0];
  }
}

- (void)device:(id)a3 receivedAttributeReport:(id)a4
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  id v51 = a3;
  id v5 = a4;
  id v6 = dispatch_group_create();
  v70[0] = 0;
  v70[1] = v70;
  v70[2] = 0x3032000000;
  v70[3] = __Block_byref_object_copy__8456;
  v70[4] = __Block_byref_object_dispose__8457;
  id v71 = objc_alloc_init(MEMORY[0x263EFF980]);
  long long v66 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  id obj = v5;
  uint64_t v7 = [obj countByEnumeratingWithState:&v66 objects:v78 count:16];
  if (v7)
  {
    __int16 v52 = v62;
    uint64_t v56 = *(void *)v67;
    uint64_t v59 = *MEMORY[0x263F10B70];
    uint64_t v54 = *MEMORY[0x263F10B90];
    do
    {
      uint64_t v58 = v7;
      for (uint64_t i = 0; i != v58; ++i)
      {
        if (*(void *)v67 != v56) {
          objc_enumerationMutation(obj);
        }
        uint64_t v9 = *(void **)(*((void *)&v66 + 1) + 8 * i);
        dispatch_group_enter(v6);
        __int16 v12 = (void *)MEMORY[0x2533B64D0](v10, v11);
        __int16 v13 = self;
        HMFGetOSLogHandle();
        __int16 v14 = (id)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          __int16 v15 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          id v73 = v15;
          __int16 v74 = 2112;
          id v75 = v9;
          _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_DEBUG, "%{public}@Handling Attribute Report: %@", buf, 0x16u);
        }
        id v16 = objc_msgSend(v9, "objectForKeyedSubscript:", v59, v51, v52);
        if (v16)
        {
          uint64_t v17 = [v9 objectForKeyedSubscript:v54];
          BOOL v18 = v17 == 0;

          if (!v18)
          {
            id v19 = [(HMMTRAccessoryServer *)v13 reportDistributor];
            [v19 distributeAttributeReport:v9];

            id v20 = objc_alloc(MEMORY[0x263F10C58]);
            id v65 = 0;
            id v21 = (void *)[v20 initWithResponseValue:v9 error:&v65];
            id v55 = v65;
            if (!v21)
            {
              id v22 = (void *)MEMORY[0x2533B64D0]();
              uint64_t v23 = v13;
              HMFGetOSLogHandle();
              id v24 = (id)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
              {
                HMFGetLogIdentifier();
                id v25 = (id)objc_claimAutoreleasedReturnValue();
                uint64_t v26 = [v9 objectForKeyedSubscript:v59];
                *(_DWORD *)buf = 138543874;
                id v73 = v25;
                __int16 v74 = 2112;
                id v75 = v26;
                __int16 v76 = 2112;
                id v77 = v55;
                _os_log_impl(&dword_252495000, v24, OS_LOG_TYPE_INFO, "%{public}@Attribute report %@ is not parsed into a known struct: %@", buf, 0x20u);
              }
            }
            uint64_t v27 = [v9 objectForKeyedSubscript:v59];
            objc_opt_class();
            if (objc_opt_isKindOfClass()) {
              __int16 v28 = v27;
            }
            else {
              __int16 v28 = 0;
            }
            id v29 = v28;

            uint64_t v30 = [v29 cluster];
            if ([v30 isEqualToNumber:&unk_2702B5CB8])
            {
              id v31 = [v29 attribute];
              int v32 = [v31 isEqualToNumber:&unk_2702B5CD0];

              if (v32)
              {
                id v33 = (void *)MEMORY[0x2533B64D0]([(HMMTRAccessoryServer *)v13 _updateAttributeTimer:v29 report:v9 timeout:v13 server:1.5]);
                uint64_t v34 = v13;
                HMFGetOSLogHandle();
                id v35 = (id)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
                {
                  id v36 = HMFGetLogIdentifier();
                  *(_DWORD *)buf = 138543618;
                  id v73 = v36;
                  __int16 v74 = 2112;
                  id v75 = v9;
                  _os_log_impl(&dword_252495000, v35, OS_LOG_TYPE_DEBUG, "%{public}@Skip handling of report: %@", buf, 0x16u);
                }
                dispatch_group_leave(v6);
                goto LABEL_34;
              }
            }
            else
            {
            }
            long long v41 = [v29 endpoint];
            id v42 = [(HMMTRAccessoryServer *)v13 _hapAccessoryAtEndpoint:v41];

            __int16 v43 = [(HMMTRAccessoryServer *)v13 hmdHAPAccessoryDelegate];
            [v43 handleAttributeReport:v21 dictionary:v9 hapAccessory:v42];

            if ([(HMMTRAccessoryServer *)v13 _handleUnmappedAttributeReport:v9])
            {
LABEL_31:
              dispatch_group_leave(v6);
            }
            else
            {
              if ([(HMMTRAccessoryServer *)v13 _ignoreAttributeReport:v9])
              {
                id v44 = (void *)MEMORY[0x2533B64D0]();
                __int16 v45 = v13;
                HMFGetOSLogHandle();
                id v46 = (id)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
                {
                  uint64_t v47 = HMFGetLogIdentifier();
                  *(_DWORD *)buf = 138543618;
                  id v73 = v47;
                  __int16 v74 = 2112;
                  id v75 = v9;
                  _os_log_impl(&dword_252495000, v46, OS_LOG_TYPE_INFO, "%{public}@Ignoring report: %@", buf, 0x16u);
                }
                goto LABEL_31;
              }
              v61[0] = MEMORY[0x263EF8330];
              v61[1] = 3221225472;
              v62[0] = __55__HMMTRAccessoryServer_device_receivedAttributeReport___block_invoke;
              v62[1] = &unk_265377F00;
              v62[2] = v9;
              v62[3] = v13;
              v64 = v70;
              uint64_t v63 = v6;
              [(HMMTRAccessoryServer *)v13 _updatedCharacteristicsForAttributeReport:v9 completionHandler:v61];
            }
LABEL_34:

            continue;
          }
        }
        id v37 = (void *)MEMORY[0x2533B64D0]();
        long long v38 = v13;
        HMFGetOSLogHandle();
        id v39 = (id)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          id v40 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          id v73 = v40;
          __int16 v74 = 2112;
          id v75 = v9;
          _os_log_impl(&dword_252495000, v39, OS_LOG_TYPE_ERROR, "%{public}@Malformed attribute report. Ignoring report: %@", buf, 0x16u);
        }
        dispatch_group_leave(v6);
      }
      uint64_t v7 = [obj countByEnumeratingWithState:&v66 objects:v78 count:16];
    }
    while (v7);
  }

  __int16 v48 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __55__HMMTRAccessoryServer_device_receivedAttributeReport___block_invoke_904;
  block[3] = &unk_265377F28;
  void block[4] = self;
  void block[5] = v70;
  dispatch_group_notify(v6, v48, block);

  id v49 = [(HMMTRAccessoryServer *)self chipReportHandler];
  if (v49)
  {
    __int16 v50 = [obj encodedCHIPReports];
    ((void (**)(void, void *))v49)[2](v49, v50);
  }
  _Block_object_dispose(v70, 8);
}

void __55__HMMTRAccessoryServer_device_receivedAttributeReport___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (![v3 count])
  {
    id v4 = [*(id *)(a1 + 32) objectForKeyedSubscript:*MEMORY[0x263F10B70]];
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = *(id *)(a1 + 40);
    uint64_t v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = HMFGetLogIdentifier();
      uint64_t v9 = [v4 endpoint];
      uint64_t v10 = [v4 cluster];
      int v11 = 138543874;
      __int16 v12 = v8;
      __int16 v13 = 2112;
      __int16 v14 = v9;
      __int16 v15 = 2112;
      id v16 = v10;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_DEBUG, "%{public}@No characteristic found for attribute report: endpoint:%@ cluster:%@", (uint8_t *)&v11, 0x20u);
    }
  }
  [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) addObjectsFromArray:v3];
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

void __55__HMMTRAccessoryServer_device_receivedAttributeReport___block_invoke_904(uint64_t a1)
{
  if ((objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), "hmf_isEmpty") & 1) == 0)
  {
    id v2 = [*(id *)(a1 + 32) delegate];
    [v2 accessoryServer:*(void *)(a1 + 32) didUpdateValuesForCharacteristics:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) stateNumber:0 broadcast:0];
  }
}

- (BOOL)_ignoreAttributeReport:(id)a3
{
  uint64_t v3 = *MEMORY[0x263F10B70];
  id v4 = a3;
  id v5 = [v4 objectForKeyedSubscript:v3];
  id v6 = +[HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:v4];

  uint64_t v7 = [v5 cluster];
  if ([v7 isEqualToNumber:&unk_2702B5A60])
  {
    uint64_t v8 = [v5 attribute];
    int v9 = [v8 isEqualToNumber:&unk_2702B5988];

    if (v9) {
      BOOL v10 = v6 == 0;
    }
    else {
      BOOL v10 = 0;
    }
    if (v10) {
      goto LABEL_21;
    }
  }
  else
  {
  }
  int v11 = [v5 cluster];
  if ([v11 isEqualToNumber:&unk_2702B5C70])
  {
    __int16 v12 = [v5 attribute];
    int v13 = [v12 isEqualToNumber:&unk_2702B5988];

    if (v13) {
      BOOL v14 = v6 == 0;
    }
    else {
      BOOL v14 = 0;
    }
    if (v14) {
      goto LABEL_21;
    }
  }
  else
  {
  }
  __int16 v15 = [v5 cluster];
  if (([v15 isEqualToNumber:&unk_2702B5C88] & 1) == 0)
  {

LABEL_23:
    BOOL v18 = 0;
    goto LABEL_24;
  }
  id v16 = [v5 attribute];
  int v17 = [v16 isEqualToNumber:&unk_2702B5AC0];

  if (!v17 || !v6 || ([v6 isEqualToNumber:&unk_2702B5CA0] & 1) == 0) {
    goto LABEL_23;
  }
LABEL_21:
  BOOL v18 = 1;
LABEL_24:

  return v18;
}

- (void)_updateDelegateOfConnectionStatus:(BOOL)a3 withError:(id)a4
{
  id v6 = a4;
  if ([(HMMTRAccessoryServer *)self _delegateRespondsToSelector:sel_accessoryServer_didUpdateConnectionState_linkLayerType_withError_])
  {
    uint64_t v7 = [(HAPAccessoryServer *)self delegateQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __68__HMMTRAccessoryServer__updateDelegateOfConnectionStatus_withError___block_invoke;
    block[3] = &unk_265377ED8;
    BOOL v10 = a3;
    void block[4] = self;
    id v9 = v6;
    dispatch_async(v7, block);
  }
}

void __68__HMMTRAccessoryServer__updateDelegateOfConnectionStatus_withError___block_invoke(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = [*(id *)(a1 + 32) linkLayerType];
    uint64_t v3 = [*(id *)(a1 + 32) primaryAccessory];
    [v3 setLinkLayerType:v2];

    id v4 = *(void **)(a1 + 32);
    id v5 = [v4 primaryAccessory];
    id v6 = [v4 getSupportedLinkLayerTypesForAccessory:v5];
    [v4 _setSupportedLinkLayerTypes:v6];
  }
  else
  {
    uint64_t v2 = 0;
  }
  id v7 = [*(id *)(a1 + 32) delegate];
  [v7 accessoryServer:*(void *)(a1 + 32) didUpdateConnectionState:*(unsigned __int8 *)(a1 + 48) linkLayerType:v2 withError:*(void *)(a1 + 40)];
}

- (void)_deviceInternalStateChanged:(id)a3
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [(HMMTRAccessoryServer *)self matterDevice];

  if (v5 == v4 && [(HMMTRAccessoryServer *)self isReadyToReadFromMTRDevice])
  {
    id v6 = [(HMMTRAccessoryServer *)self pendingMTRDeviceReadReadyHandlers];
    id v7 = [v6 allValues];

    uint64_t v8 = [(HMMTRAccessoryServer *)self pendingMTRDeviceReadReadyHandlers];
    [v8 removeAllObjects];

    if ((objc_msgSend(v7, "hmf_isEmpty") & 1) == 0)
    {
      id v9 = (void *)MEMORY[0x2533B64D0]();
      BOOL v10 = self;
      int v11 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        __int16 v12 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v24 = v12;
        _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_INFO, "%{public}@MTRDevice is ready to read from. Triggering pending MTRDevice read-ready handlers", buf, 0xCu);
      }
    }
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    id v13 = v7;
    uint64_t v14 = [v13 countByEnumeratingWithState:&v18 objects:v22 count:16];
    if (v14)
    {
      uint64_t v15 = v14;
      uint64_t v16 = *(void *)v19;
      do
      {
        uint64_t v17 = 0;
        do
        {
          if (*(void *)v19 != v16) {
            objc_enumerationMutation(v13);
          }
          (*(void (**)(void))(*(void *)(*((void *)&v18 + 1) + 8 * v17) + 16))(*(void *)(*((void *)&v18 + 1) + 8 * v17));
          ++v17;
        }
        while (v15 != v17);
        uint64_t v15 = [v13 countByEnumeratingWithState:&v18 objects:v22 count:16];
      }
      while (v15);
    }
  }
}

- (BOOL)isReadyToReadFromMTRDevice
{
  if (!isFeatureMatteriPhoneOnlyPairingControlEnabled()) {
    return 1;
  }
  uint64_t v3 = [(HMMTRAccessoryServer *)self matterDevice];
  char v4 = objc_opt_respondsToSelector();

  if ((v4 & 1) == 0) {
    return 1;
  }
  id v5 = [(HMMTRAccessoryServer *)self matterDevice];
  char v6 = [v5 _deviceHasActiveSubscription];

  return v6;
}

- (void)device:(id)a3 stateChanged:(unint64_t)a4
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = [(HMMTRAccessoryServer *)self matterDevice];

  if (v7 != v6) {
    goto LABEL_26;
  }
  uint64_t v8 = [(HMMTRAccessoryServer *)self setMtrDeviceStateReported:1];
  if (!a4)
  {
    uint64_t v15 = [MEMORY[0x263F087E8] hapErrorWithCode:19 description:@"MTRDevice state changed to MTRDeviceStateUnknown" reason:0 suggestion:0 underlyingError:0];
    uint64_t v27 = (void *)MEMORY[0x2533B64D0]();
    __int16 v28 = self;
    id v29 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v36 = v30;
      _os_log_impl(&dword_252495000, v29, OS_LOG_TYPE_ERROR, "%{public}@Matter device state unknown", buf, 0xCu);
    }
    goto LABEL_23;
  }
  if (a4 == 2)
  {
    id v31 = (void *)MEMORY[0x2533B64D0](v8);
    __int16 v28 = self;
    int v32 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      id v33 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v36 = v33;
      _os_log_impl(&dword_252495000, v32, OS_LOG_TYPE_ERROR, "%{public}@Matter device unreachable & disconnected", buf, 0xCu);
    }
    uint64_t v15 = [MEMORY[0x263F087E8] hapErrorWithCode:19 description:@"MTRDevice state changed to MTRDeviceStateUnreachable" reason:0 suggestion:0 underlyingError:0];
LABEL_23:
    [(HMMTRAccessoryServer *)v28 _handleUnreachableStateWithError:v15];
    goto LABEL_24;
  }
  if (a4 != 1)
  {
    [(HMMTRAccessoryServer *)self setMtrDeviceStateReported:0];
    goto LABEL_26;
  }
  id v9 = (void *)MEMORY[0x2533B64D0](v8);
  BOOL v10 = self;
  int v11 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    __int16 v12 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    id v36 = v12;
    _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_INFO, "%{public}@Matter device reachable & connected", buf, 0xCu);
  }
  [(HMMTRAccessoryServer *)v10 didUpdateReachability:1];
  [(HMMTRAccessoryServer *)v10 setMtrDeviceConnected:1];
  if (![(HMMTRAccessoryServer *)v10 serviceEnumerationFailed]) {
    [(HMMTRAccessoryServer *)v10 _updateDelegateOfConnectionStatus:1 withError:0];
  }
  id v13 = [(HMMTRAccessoryServer *)v10 browser];
  int v14 = [v13 isCurrentDevicePrimaryResident];

  if (v14)
  {
    v34[0] = MEMORY[0x263EF8330];
    v34[1] = 3221225472;
    void v34[2] = __44__HMMTRAccessoryServer_device_stateChanged___block_invoke;
    v34[3] = &unk_265376E00;
    v34[4] = v10;
    [(HMMTRAccessoryServer *)v10 enumerateHAPServices:v34];
  }
  if (HAPIsInternalBuild())
  {
    uint64_t v15 = [(HMMTRAccessoryServer *)v10 browser];
    if ([v15 isCurrentDevicePrimaryResident])
    {
      uint64_t v16 = [(HMMTRAccessoryServer *)v10 stateCaptureDeviceConnectedTimer];

      if (!v16)
      {
        uint64_t v17 = (void *)[objc_alloc(MEMORY[0x263F42658]) initWithTimeInterval:0 options:600.0];
        [(HMMTRAccessoryServer *)v10 setStateCaptureDeviceConnectedTimer:v17];

        long long v18 = [(HAPAccessoryServer *)v10 clientQueue];
        long long v19 = [(HMMTRAccessoryServer *)v10 stateCaptureDeviceConnectedTimer];
        [v19 setDelegateQueue:v18];

        long long v20 = [(HMMTRAccessoryServer *)v10 stateCaptureDeviceConnectedTimer];
        [v20 setDelegate:v10];

        long long v21 = [(HMMTRAccessoryServer *)v10 stateCaptureDeviceConnectedTimer];
        [v21 resume];

        id v22 = (void *)MEMORY[0x2533B64D0]();
        uint64_t v23 = v10;
        id v24 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
        {
          uint64_t v25 = HMFGetLogIdentifier();
          uint64_t v26 = [(HAPAccessoryServer *)v23 name];
          *(_DWORD *)buf = 138543874;
          id v36 = v25;
          __int16 v37 = 2112;
          long long v38 = v26;
          __int16 v39 = 2112;
          id v40 = &unk_2702B5C58;
          _os_log_impl(&dword_252495000, v24, OS_LOG_TYPE_INFO, "%{public}@State Capture: Setting timer to capture state information for %@ due to matter device reachable notification, timeout is %@", buf, 0x20u);
        }
      }
      goto LABEL_26;
    }
LABEL_24:
  }
LABEL_26:
}

void __44__HMMTRAccessoryServer_device_stateChanged___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v3 = a2;
  char v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    int v13 = 138543618;
    int v14 = v7;
    __int16 v15 = 2112;
    id v16 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Enumeration per reachable device complete: %@", (uint8_t *)&v13, 0x16u);
  }
  if (!v3)
  {
    uint64_t v8 = (void *)MEMORY[0x2533B64D0]();
    id v9 = *(id *)(a1 + 32);
    BOOL v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      int v11 = HMFGetLogIdentifier();
      __int16 v12 = [*(id *)(a1 + 32) clusterIDCharacteristicMap];
      int v13 = 138543618;
      int v14 = v11;
      __int16 v15 = 2112;
      id v16 = v12;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@clusterIDCharacteristicMap : %@", (uint8_t *)&v13, 0x16u);
    }
  }
}

- (void)_deregisterStateCaptureHandlers
{
  [(HMMTRAccessoryServer *)self _deregisterPartsListStateCaptureHandler];
  [(HMMTRAccessoryServer *)self _deregisterDeviceConnectedStateCaptureHandler];
}

- (void)_deregisterDeviceConnectedStateCaptureHandler
{
  if ([(HMMTRAccessoryServer *)self deviceConnectedStateHandle])
  {
    [(HMMTRAccessoryServer *)self _deregisterStateCaptureHandlerWithHandle:[(HMMTRAccessoryServer *)self deviceConnectedStateHandle]];
    [(HMMTRAccessoryServer *)self setDeviceConnectedStateHandle:0];
  }
}

- (void)_deregisterPartsListStateCaptureHandler
{
  if ([(HMMTRAccessoryServer *)self partsListStateCaptureHandle])
  {
    [(HMMTRAccessoryServer *)self _deregisterStateCaptureHandlerWithHandle:[(HMMTRAccessoryServer *)self partsListStateCaptureHandle]];
    [(HMMTRAccessoryServer *)self setPartsListStateCaptureHandle:0];
  }
}

- (void)_deregisterStateCaptureHandlerWithHandle:(unint64_t)a3
{
}

- (unint64_t)_registerStateCaptureHandlerWithStateCaptureInformation:(id)a3
{
  id v4 = a3;
  if (HAPIsInternalBuild())
  {
    objc_initWeak(&location, self);
    id v5 = [(HAPAccessoryServer *)self clientQueue];
    objc_copyWeak(&v9, &location);
    id v8 = v4;
    unint64_t v6 = os_state_add_handler();

    objc_destroyWeak(&v9);
    objc_destroyWeak(&location);
  }
  else
  {
    unint64_t v6 = 0;
  }

  return v6;
}

uint64_t __80__HMMTRAccessoryServer__registerStateCaptureHandlerWithStateCaptureInformation___block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 16) != 3) {
    return 0;
  }
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v4 = (void *)[objc_alloc(MEMORY[0x263F425C0]) initWithName:@"os-state-HMMTRAccessoryServer"];
    id v5 = [WeakRetained dumpState:*(void *)(a1 + 32)];
    unint64_t v6 = NSString;
    id v7 = [WeakRetained nodeID];
    id v8 = [WeakRetained fabricID];
    id v9 = [WeakRetained objectID];
    BOOL v10 = [v6 stringWithFormat:@"HMMTRAccessoryServer State for %@/%@(%@)", v7, v8, v9];

    uint64_t v11 = [WeakRetained createStateData:v10 data:v5];
  }
  else
  {
    uint64_t v11 = 0;
  }

  return v11;
}

- (os_state_data_s)createStateData:(id)a3 data:(id)a4
{
  id v5 = a3;
  unint64_t v6 = [MEMORY[0x263F08AC0] dataWithPropertyList:a4 format:200 options:0 error:0];
  id v7 = v6;
  if (v6)
  {
    size_t v8 = [v6 length];
    id v9 = (os_state_data_s *)malloc_type_calloc(1uLL, v8 + 200, 0xED5F819AuLL);
    v9->var0 = 1;
    v9->var1.var1 = v8;
    [v5 UTF8String];
    __strlcpy_chk();
    memcpy(v9->var4, (const void *)[v7 bytes], v8);
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

- (id)dumpState:(id)a3
{
  id v4 = a3;
  id v5 = [MEMORY[0x263EFF9A0] dictionaryWithCapacity:12];
  unint64_t v6 = NSString;
  id v7 = [(HAPAccessoryServer *)self name];
  size_t v8 = [(HMMTRAccessoryServer *)self nodeID];
  id v9 = [(HMMTRAccessoryServer *)self fabricID];
  BOOL v10 = [(HAPAccessoryServer *)self category];
  uint64_t v11 = [(HMMTRAccessoryServer *)self objectID];
  __int16 v12 = (void *)v11;
  if (v4) {
    [v6 stringWithFormat:@"Name: %@, NodeID: %@, FabricID: %@, Category: %@, ObjectID: %@, State capture information: %@", v7, v8, v9, v10, v11, v4];
  }
  else {
  int v13 = [v6 stringWithFormat:@"Name: %@, NodeID: %@, FabricID: %@, Category %@, ObjectID: %@, No state capture information available.", v7, v8, v9, v10, v11, v15];
  }

  [v5 setObject:v13 forKeyedSubscript:*MEMORY[0x263F41FA8]];
  return v5;
}

- (void)_fetchAdditionalThreadNetworkInformationFromDevice:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (isFeatureMatterLocalFabricConfigEnabled())
  {
    size_t v8 = dispatch_group_create();
    dispatch_group_enter(v8);
    v16[0] = MEMORY[0x263EF8330];
    v16[1] = 3221225472;
    v16[2] = __86__HMMTRAccessoryServer__fetchAdditionalThreadNetworkInformationFromDevice_completion___block_invoke;
    v16[3] = &unk_2653778C8;
    v16[4] = self;
    id v9 = v8;
    uint64_t v17 = v9;
    [(HMMTRAccessoryServer *)self fetchWEDSupportInformationFromDevice:v6 completion:v16];
    dispatch_group_enter(v9);
    v14[0] = MEMORY[0x263EF8330];
    v14[1] = 3221225472;
    v14[2] = __86__HMMTRAccessoryServer__fetchAdditionalThreadNetworkInformationFromDevice_completion___block_invoke_865;
    v14[3] = &unk_2653778C8;
    v14[4] = self;
    uint64_t v15 = v9;
    BOOL v10 = v9;
    [(HMMTRAccessoryServer *)self fetchExtendedMACAddressFromDevice:v6 completion:v14];
    uint64_t v11 = [(HAPAccessoryServer *)self delegateQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __86__HMMTRAccessoryServer__fetchAdditionalThreadNetworkInformationFromDevice_completion___block_invoke_866;
    block[3] = &unk_265377430;
    id v13 = v7;
    dispatch_group_notify(v10, v11, block);
  }
  else
  {
    (*((void (**)(id, void))v7 + 2))(v7, 0);
  }
}

void __86__HMMTRAccessoryServer__fetchAdditionalThreadNetworkInformationFromDevice_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      BOOL v10 = HMFGetLogIdentifier();
      int v11 = 138543618;
      __int16 v12 = v10;
      __int16 v13 = 2112;
      id v14 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch software version string of CHIP Accessory with error %@", (uint8_t *)&v11, 0x16u);
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void __86__HMMTRAccessoryServer__fetchAdditionalThreadNetworkInformationFromDevice_completion___block_invoke_865(uint64_t a1, void *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      BOOL v10 = HMFGetLogIdentifier();
      int v11 = 138543618;
      __int16 v12 = v10;
      __int16 v13 = 2112;
      id v14 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch eMAC address of CHIP Accessory with error %@", (uint8_t *)&v11, 0x16u);
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

uint64_t __86__HMMTRAccessoryServer__fetchAdditionalThreadNetworkInformationFromDevice_completion___block_invoke_866(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

- (void)handleWEDDisconnectedWhileNotPairing
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v3 = (void *)MEMORY[0x2533B64D0](self, a2);
  id v4 = self;
  id v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    int v9 = 138543362;
    BOOL v10 = v6;
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@WED disconnected while not pairing", (uint8_t *)&v9, 0xCu);
  }
  if (![(HMMTRAccessoryServer *)v4 servicesEnumerated]
    && ![(HMMTRAccessoryServer *)v4 serviceEnumerationFailed])
  {
    [(HMMTRAccessoryServer *)v4 disable];
    id v7 = [(HMMTRAccessoryServer *)v4 browser];
    id v8 = [MEMORY[0x263F087E8] hmmtrErrorWithCode:15];
    [v7 invalidateAccessoryServer:v4 reason:v8];
  }
}

- (void)handleThreadNetworkStateChangedNotification:(id)a3
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [(HAPAccessoryServer *)self clientQueue];

  if (v5)
  {
    id v6 = [(HAPAccessoryServer *)self clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __68__HMMTRAccessoryServer_handleThreadNetworkStateChangedNotification___block_invoke;
    block[3] = &unk_265378638;
    void block[4] = self;
    dispatch_async(v6, block);
  }
  else
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = self;
    int v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      BOOL v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v13 = v10;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@handleThreadNetworkStateChangedNotification - clientQueue not available", buf, 0xCu);
    }
  }
}

uint64_t __68__HMMTRAccessoryServer_handleThreadNetworkStateChangedNotification___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _handleThreadRadioStateChanged];
}

- (void)_handleThreadRadioStateChanged
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  id v3 = [(HMMTRAccessoryServer *)self browser];
  id v4 = [(HMMTRAccessoryServer *)self fabricID];
  id v5 = [v3 appleHomeFabricWithID:v4];

  id v6 = [(HMMTRAccessoryServer *)self browser];
  int v7 = [v6 isCurrentDeviceMobileAndResidentReachableAndThreadCapableForFabric:v5];

  id v8 = [(HMMTRAccessoryServer *)self browser];
  int v9 = [v8 threadRadioManager];
  int v10 = [v9 isReadyToEstablishWEDConnection];

  uint64_t v11 = [(HMMTRAccessoryServer *)self browser];
  int v12 = [v11 connectionRequestSuspended];

  if ([(HMMTRAccessoryServer *)self pairedState]
    && ![(HMMTRAccessoryServer *)self isDisabled])
  {
    int v13 = ![(HMMTRAccessoryServer *)self removalInProgress];
  }
  else
  {
    int v13 = 0;
  }
  uint64_t v14 = [(HMMTRAccessoryServer *)self supportedLinkLayerTypes];
  char v15 = [v14 unsignedIntValue];

  if (((v12 | v13 ^ 1) & 1) != 0 || (v15 & 0x10) == 0)
  {
    uint64_t v17 = (void *)MEMORY[0x2533B64D0]();
    long long v18 = self;
    long long v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      long long v20 = HMFGetLogIdentifier();
      long long v21 = HMFBooleanToString();
      id v22 = HMFBooleanToString();
      uint64_t v23 = HMFBooleanToString();
      *(_DWORD *)buf = 138544130;
      __int16 v39 = v20;
      __int16 v40 = 2112;
      uint64_t v41 = v21;
      __int16 v42 = 2112;
      __int16 v43 = v22;
      __int16 v44 = 2112;
      __int16 v45 = v23;
      _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_DEBUG, "%{public}@_handleThreadRadioStateChanged: ignoring thread radio state change - isBrowserInPairingState = %@, isAccessoryServerValid = %@, isAccessoryServerThreadCapable = %@ ", buf, 0x2Au);
    }
    goto LABEL_20;
  }
  BOOL v16 = ((v10 ^ 1 | v7) & 1) == 0 && ![(HMMTRAccessoryServer *)self isWEDDevice];
  id v24 = (void *)MEMORY[0x2533B64D0]([(HMMTRAccessoryServer *)self setRequiresThreadRouter:v16]);
  uint64_t v25 = self;
  uint64_t v26 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
  {
    uint64_t v27 = HMFGetLogIdentifier();
    [(HMMTRAccessoryServer *)v25 requiresThreadRouter];
    __int16 v28 = HMFBooleanToString();
    [(HMMTRAccessoryServer *)v25 isWEDDevice];
    id v29 = HMFBooleanToString();
    uint64_t v30 = HMFBooleanToString();
    id v31 = HMFBooleanToString();
    *(_DWORD *)buf = 138544386;
    __int16 v39 = v27;
    __int16 v40 = 2112;
    uint64_t v41 = v28;
    __int16 v42 = 2112;
    __int16 v43 = v29;
    __int16 v44 = 2112;
    __int16 v45 = v30;
    __int16 v46 = 2112;
    uint64_t v47 = v31;
    _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_INFO, "%{public}@_handleThreadRadioStateChanged - requiresThreadRouter = %@ (isWED = %@, isControllerInSleepyRouterState = %@, primaryReachableAndThreadCapable = %@)", buf, 0x34u);
  }
  uint64_t v32 = [(HMMTRAccessoryServer *)v25 chipDelegate];
  if (!v32
    || (id v33 = (void *)v32,
        [(HAPAccessoryServer *)v25 delegateQueue],
        uint64_t v34 = objc_claimAutoreleasedReturnValue(),
        v34,
        v33,
        !v34))
  {
    uint64_t v17 = (void *)MEMORY[0x2533B64D0]();
    long long v18 = v25;
    long long v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      id v36 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v39 = v36;
      _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_ERROR, "%{public}@_handleThreadRadioStateChanged - chipDelegate not available", buf, 0xCu);
    }
LABEL_20:

    goto LABEL_21;
  }
  id v35 = [(HAPAccessoryServer *)v25 delegateQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __54__HMMTRAccessoryServer__handleThreadRadioStateChanged__block_invoke;
  block[3] = &unk_265378638;
  void block[4] = v25;
  dispatch_async(v35, block);

LABEL_21:
}

void __54__HMMTRAccessoryServer__handleThreadRadioStateChanged__block_invoke(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) chipDelegate];
  [v2 didUpdateRequiresThreadRouterForAccessoryServer:*(void *)(a1 + 32)];
}

- (void)handleThreadDirectConnectionSleepyTypeChange:(BOOL)a3
{
  BOOL v3 = a3;
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v5 = [(HMMTRAccessoryServer *)self browser];
  id v6 = [(HMMTRAccessoryServer *)self fabricID];
  int v7 = [v5 appleHomeFabricWithID:v6];

  id v8 = [(HMMTRAccessoryServer *)self browser];
  char v9 = [v8 isCurrentDeviceMobileAndResidentReachableAndThreadCapableForFabric:v7];

  BOOL v10 = v3 && (v9 & 1) == 0 && ![(HMMTRAccessoryServer *)self isWEDDevice];
  uint64_t v11 = (void *)MEMORY[0x2533B64D0]([(HMMTRAccessoryServer *)self setRequiresThreadRouter:v10]);
  int v12 = self;
  int v13 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    uint64_t v14 = HMFGetLogIdentifier();
    [(HMMTRAccessoryServer *)v12 requiresThreadRouter];
    char v15 = HMFBooleanToString();
    BOOL v16 = [(HMMTRAccessoryServer *)v12 nodeID];
    [(HMMTRAccessoryServer *)v12 isWEDDevice];
    uint64_t v17 = HMFBooleanToString();
    long long v18 = HMFBooleanToString();
    long long v19 = HMFBooleanToString();
    *(_DWORD *)buf = 138544642;
    uint64_t v23 = v14;
    __int16 v24 = 2112;
    uint64_t v25 = v15;
    __int16 v26 = 2112;
    uint64_t v27 = v16;
    __int16 v28 = 2112;
    id v29 = v17;
    __int16 v30 = 2112;
    id v31 = v18;
    __int16 v32 = 2112;
    id v33 = v19;
    _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@handleThreadDirectConnectionSleepyTypeChange - requiresThreadRouter = %@ for accessory with nodeID %@ (isWED = %@, isSleepyLinuint64_t k = %@, primaryReachableAndThreadCapable = %@)", buf, 0x3Eu);
  }
  long long v20 = [(HAPAccessoryServer *)v12 delegateQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __69__HMMTRAccessoryServer_handleThreadDirectConnectionSleepyTypeChange___block_invoke;
  block[3] = &unk_265378638;
  void block[4] = v12;
  dispatch_async(v20, block);
}

void __69__HMMTRAccessoryServer_handleThreadDirectConnectionSleepyTypeChange___block_invoke(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) chipDelegate];
  [v2 didUpdateRequiresThreadRouterForAccessoryServer:*(void *)(a1 + 32)];
}

- (void)_fetchAdditionalThreadNetworkInformationWithCompletion:(id)a3
{
  id v4 = (void (**)(id, void))a3;
  if (isFeatureMatterLocalFabricConfigEnabled() && self->_linkLayerType == 4)
  {
    id v5 = [(HMMTRAccessoryServer *)self deviceController];
    id v6 = [(HMMTRAccessoryServer *)self nodeID];
    uint64_t v8 = 0;
    int v7 = objc_msgSend(v5, "getDeviceBeingCommissioned:error:", objc_msgSend(v6, "unsignedLongLongValue"), &v8);

    if (v7) {
      [(HMMTRAccessoryServer *)self _fetchAdditionalThreadNetworkInformationFromDevice:v7 completion:v4];
    }
    else {
      v4[2](v4, 0);
    }
  }
  else
  {
    v4[2](v4, 0);
  }
}

- (void)refreshThreadCapabilitiesWithCompletion:(id)a3
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  id v4 = (void (**)(id, void))a3;
  if (isFeatureMatterLocalFabricConfigEnabled() && self->_linkLayerType == 4)
  {
    if ([(HMMTRAccessoryServer *)self isWEDDevice])
    {
      id v5 = (void *)MEMORY[0x2533B64D0]();
      id v6 = self;
      int v7 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        uint64_t v8 = HMFGetLogIdentifier();
        char v9 = [(HMMTRAccessoryServer *)v6 nodeID];
        *(_DWORD *)buf = 138543618;
        *(void *)&uint8_t buf[4] = v8;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v9;
        _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory is already WED capable, will not try to refresh information for accessory with nodeID %@", buf, 0x16u);
      }
      v4[2](v4, 0);
    }
    else
    {
      BOOL v10 = [(HMMTRAccessoryServer *)self storage];
      uint64_t v11 = [v10 fabricDataSource];
      int v12 = [(HMMTRAccessoryServer *)self nodeID];
      int v13 = [v11 storageDataSourceForDeviceWithNodeID:v12];

      v23[0] = 0;
      v23[1] = v23;
      v23[2] = 0x2020000000;
      BOOL v24 = 0;
      BOOL v24 = [(HMMTRAccessoryServer *)self isWEDDevice];
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      __int16 v26 = __Block_byref_object_copy__8456;
      uint64_t v27 = __Block_byref_object_dispose__8457;
      id v28 = [(HMMTRAccessoryServer *)self eMACAddress];
      uint64_t v14 = [(HMMTRAccessoryServer *)self deviceController];
      if (v14)
      {
        char v15 = [(HMMTRAccessoryServer *)self nodeID];
        uint64_t v16 = [v15 unsignedLongLongValue];
        uint64_t v17 = [(HAPAccessoryServer *)self clientQueue];
        v18[0] = MEMORY[0x263EF8330];
        v18[1] = 3221225472;
        v18[2] = __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke;
        v18[3] = &unk_265377E88;
        v18[4] = self;
        long long v20 = v4;
        long long v21 = v23;
        id v19 = v13;
        id v22 = buf;
        [v14 getBaseDevice:v16 queue:v17 completionHandler:v18];
      }
      else
      {
        v4[2](v4, 0);
      }

      _Block_object_dispose(buf, 8);
      _Block_object_dispose(v23, 8);
    }
  }
  else
  {
    v4[2](v4, 0);
  }
}

void __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    int v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    char v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      BOOL v10 = HMFGetLogIdentifier();
      uint64_t v11 = [*(id *)(a1 + 32) nodeID];
      *(_DWORD *)buf = 138543874;
      uint64_t v23 = v10;
      __int16 v24 = 2112;
      uint64_t v25 = v11;
      __int16 v26 = 2112;
      id v27 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Unable to get additional thread information from accessory after firmware update for nodeID %@, error: %@", buf, 0x20u);
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    int v12 = *(void **)(a1 + 32);
    v17[0] = MEMORY[0x263EF8330];
    v17[1] = 3221225472;
    v17[2] = __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_861;
    v17[3] = &unk_265377E60;
    v17[4] = v12;
    id v13 = *(id *)(a1 + 48);
    uint64_t v14 = *(void *)(a1 + 56);
    id v19 = v13;
    uint64_t v20 = v14;
    id v15 = *(id *)(a1 + 40);
    uint64_t v16 = *(void *)(a1 + 64);
    id v18 = v15;
    uint64_t v21 = v16;
    [v12 _fetchAdditionalThreadNetworkInformationFromDevice:v5 completion:v17];
  }
}

void __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_861(uint64_t a1, void *a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  int v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v8 = HMFGetLogIdentifier();
      char v9 = [*(id *)(a1 + 32) nodeID];
      *(_DWORD *)buf = 138543874;
      id v33 = v8;
      __int16 v34 = 2112;
      id v35 = v9;
      __int16 v36 = 2112;
      id v37 = v3;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to refresh thread capabilities from accessory nodeID %@, error: %@", buf, 0x20u);
    }
    BOOL v10 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
    goto LABEL_15;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v11 = HMFGetLogIdentifier();
    int v12 = [*(id *)(a1 + 32) nodeID];
    id v13 = [*(id *)(a1 + 32) softwareVersionNumber];
    [*(id *)(a1 + 32) isWEDDevice];
    uint64_t v14 = HMFBooleanToString();
    id v15 = [*(id *)(a1 + 32) eMACAddress];
    *(_DWORD *)buf = 138544386;
    id v33 = v11;
    __int16 v34 = 2112;
    id v35 = v12;
    __int16 v36 = 2112;
    id v37 = v13;
    __int16 v38 = 2112;
    __int16 v39 = v14;
    __int16 v40 = 2112;
    uint64_t v41 = v15;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Refreshed thread capabilities for accessory with nodeID: %@, firmwareVersion = %@ WED: %@ eMAC: %@", buf, 0x34u);
  }
  if (![*(id *)(a1 + 32) isWEDDevice]
    || ([*(id *)(a1 + 32) eMACAddress],
        uint64_t v16 = objc_claimAutoreleasedReturnValue(),
        v16,
        !v16))
  {
    BOOL v10 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
LABEL_15:
    v10();
    goto LABEL_16;
  }
  uint64_t v17 = dispatch_group_create();
  int v18 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
  if (v18 != [*(id *)(a1 + 32) isWEDDevice])
  {
    dispatch_group_enter(v17);
    id v19 = *(void **)(a1 + 40);
    uint64_t v20 = [*(id *)(a1 + 32) isWEDDevice];
    v30[0] = MEMORY[0x263EF8330];
    v30[1] = 3221225472;
    v30[2] = __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_862;
    v30[3] = &unk_265378660;
    v30[4] = *(void *)(a1 + 32);
    id v31 = v17;
    [v19 updateWedSupport:v20 completion:v30];
  }
  uint64_t v21 = [*(id *)(a1 + 32) eMACAddress];
  char v22 = HMFEqualObjects();

  if ((v22 & 1) == 0)
  {
    dispatch_group_enter(v17);
    uint64_t v23 = *(void **)(a1 + 40);
    __int16 v24 = [*(id *)(a1 + 32) eMACAddress];
    v28[0] = MEMORY[0x263EF8330];
    v28[1] = 3221225472;
    v28[2] = __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_863;
    v28[3] = &unk_265378660;
    v28[4] = *(void *)(a1 + 32);
    uint64_t v29 = v17;
    [v23 updateExtendedMACAddress:v24 completion:v28];
  }
  uint64_t v25 = [*(id *)(a1 + 32) delegateQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_864;
  block[3] = &unk_265377430;
  id v27 = *(id *)(a1 + 48);
  dispatch_group_notify(v17, v25, block);

LABEL_16:
}

void __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_862(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = HMFGetLogIdentifier();
      int v8 = 138543618;
      char v9 = v7;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to WED support version after firmware update error: %@", (uint8_t *)&v8, 0x16u);
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_863(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = HMFGetLogIdentifier();
      int v8 = 138543618;
      char v9 = v7;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to Wed support version after firmware update error: %@", (uint8_t *)&v8, 0x16u);
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

uint64_t __64__HMMTRAccessoryServer_refreshThreadCapabilitiesWithCompletion___block_invoke_864(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

- (void)_continueNetworkProvisioning
{
  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:3];
  [(HMMTRAccessoryServer *)self _startCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameNetworkScan"];
  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingProgress:17];
  v3[0] = MEMORY[0x263EF8330];
  v3[1] = 3221225472;
  v3[2] = __52__HMMTRAccessoryServer__continueNetworkProvisioning__block_invoke;
  v3[3] = &unk_265377E38;
  v3[4] = self;
  [(HMMTRAccessoryServer *)self _requestAccessoryNetworkScanWithCompletionHandler:v3];
}

void __52__HMMTRAccessoryServer__continueNetworkProvisioning__block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  __int16 v10 = *(void **)(a1 + 32);
  if (!v7 || v8)
  {
    [v10 _notifyDelegateOfPairingProgress:19 error:v8];
    [*(id *)(a1 + 32) _pairingComplete:v8 context:v9];
  }
  else
  {
    id v11 = (void *)MEMORY[0x2533B64D0]([v10 _notifyDelegateOfPairingProgress:18]);
    id v12 = *(id *)(a1 + 32);
    id v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      uint64_t v14 = HMFGetLogIdentifier();
      int v17 = 138543618;
      int v18 = v14;
      __int16 v19 = 2112;
      id v20 = v7;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Scanned networks: %@", (uint8_t *)&v17, 0x16u);
    }
    id v15 = [*(id *)(a1 + 32) stageWiFiScanResultsHandler];
    if (v15)
    {
    }
    else
    {
      uint64_t v16 = [*(id *)(a1 + 32) stageThreadScanResultsHandler];

      if (!v16)
      {
        [*(id *)(a1 + 32) _collectNetworkCredentials:v7];
        goto LABEL_10;
      }
    }
    [*(id *)(a1 + 32) _onNetworkScanResults:v7];
  }
LABEL_10:
}

- (void)_controller:(id)a3 commissioningComplete:(id)a4 nodeID:(id)a5 abstractMetrics:(id)a6
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = a6;
  uint64_t v14 = (void *)MEMORY[0x2533B64D0]();
  id v15 = self;
  uint64_t v16 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    int v17 = HMFGetLogIdentifier();
    *(_DWORD *)__int16 v44 = 138543618;
    *(void *)&v44[4] = v17;
    *(_WORD *)&v44[12] = 2112;
    *(void *)&v44[14] = v11;
    _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@Accessory commissioning complete. %@", v44, 0x16u);
  }
  int v18 = (void *)MEMORY[0x2533B64D0]();
  __int16 v19 = v15;
  id v20 = HMFGetOSLogHandle();
  BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_INFO);
  if (v13)
  {
    if (v21)
    {
      char v22 = HMFGetLogIdentifier();
      *(_DWORD *)__int16 v44 = 138543618;
      *(void *)&v44[4] = v22;
      *(_WORD *)&v44[12] = 2112;
      *(void *)&v44[14] = @"com.apple.matter.pairing-event";
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_INFO, "%{public}@Submitting Matter metric after commissioning complete: %@", v44, 0x16u);
    }
    uint64_t v23 = @"com.apple.matter.pairing-event";
    id v24 = v13;
    if (submitMatterMetrics_onceToken != -1) {
      dispatch_once(&submitMatterMetrics_onceToken, &__block_literal_global_6208);
    }
    uint64_t v25 = submitMatterMetrics_metricsQueue;
    *(void *)__int16 v44 = MEMORY[0x263EF8330];
    *(void *)&v44[8] = 3221225472;
    *(void *)&v44[16] = __submitMatterMetrics_block_invoke_2;
    __int16 v45 = &unk_265376E98;
    id v26 = v24;
    id v46 = v26;
    id v27 = @"com.apple.matter.pairing-event";
    uint64_t v47 = @"com.apple.matter.pairing-event";
    dispatch_async(v25, v44);

    uint64_t v28 = dictionaryFromMatterMetrics(v26);
  }
  else
  {
    if (v21)
    {
      uint64_t v29 = HMFGetLogIdentifier();
      *(_DWORD *)__int16 v44 = 138543362;
      *(void *)&v44[4] = v29;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_INFO, "%{public}@Notifying delegate with empty mtr metrics", v44, 0xCu);
    }
    uint64_t v28 = [NSDictionary dictionary];
  }
  __int16 v30 = (void *)v28;
  [(HMMTRAccessoryServer *)v19 _notifyDelegateOfMTRMetrics:v28];

  if (!v11)
  {
    [(HMMTRAccessoryServer *)v19 _notifyDelegateOfPairingProgress:28];
    [(HMMTRAccessoryServer *)v19 _notifyDelegateOfPairingStep:7];
    [(HMMTRAccessoryServer *)v19 _notifyDelegateOfPairingProgress:33];
    id v31 = [(HMMTRAccessoryServer *)v19 deviceController];
    if (v31)
    {
      [(HMMTRAccessoryServer *)v19 _notifyDelegateOfPairingProgress:34];
      [(HMMTRAccessoryServer *)v19 setCommissioningCompleted:1];
      [(HMMTRAccessoryServer *)v19 _pairingComplete:0 context:0];
      id v11 = 0;
    }
    else
    {
      __int16 v39 = (void *)MEMORY[0x2533B64D0]();
      __int16 v40 = v19;
      uint64_t v41 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        uint64_t v42 = HMFGetLogIdentifier();
        *(_DWORD *)__int16 v44 = 138543362;
        *(void *)&v44[4] = v42;
        _os_log_impl(&dword_252495000, v41, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to handle commissioning completion", v44, 0xCu);
      }
      id v11 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
      [(HMMTRAccessoryServer *)v40 _notifyDelegateOfPairingProgress:29 error:v11];
      __int16 v43 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:7 error:v11];
      [(HMMTRAccessoryServer *)v40 _pairingComplete:v11 context:v43];
    }
    goto LABEL_26;
  }
  if ([(HMMTRAccessoryServer *)v19 commissioningSessionEstablished])
  {
    id v31 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:6 error:v11];
    __int16 v32 = [(HMMTRAccessoryServer *)v19 commissioningFailureOverridingError];

    if (v32)
    {
      uint64_t v33 = [(HMMTRAccessoryServer *)v19 commissioningFailureOverridingError];

      id v11 = (id)v33;
    }
    [(HMMTRAccessoryServer *)v19 _notifyDelegateOfPairingProgress:29 error:v11];
    __int16 v34 = (os_unfair_lock_s *)((char *)v19 + (int)*MEMORY[0x263F35B30]);
    os_unfair_lock_lock_with_options();
    int64_t linkLayerType = v19->_linkLayerType;
    os_unfair_lock_unlock(v34);
    if ([v11 code] == 9 && linkLayerType == 1)
    {
      __int16 v36 = (void *)MEMORY[0x263F087E8];
      id v37 = [v11 localizedFailureReason];
      uint64_t v38 = [v36 hapErrorWithCode:25 description:@"WiFi Commissioning failed with error" reason:v37 suggestion:0 underlyingError:v11];

      id v11 = (id)v38;
    }
    [(HMMTRAccessoryServer *)v19 _pairingComplete:v11 context:v31];
LABEL_26:

    goto LABEL_27;
  }
  [(HMMTRAccessoryServer *)v19 _retryPairing];
LABEL_27:
}

- (void)controller:(id)a3 commissioningSessionEstablishmentDone:(id)a4
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  if ([(HMMTRAccessoryServer *)self pairingProgress] != 1)
  {
    uint64_t v14 = MEMORY[0x2533B64D0]();
    id v15 = self;
    uint64_t v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      int v17 = HMFGetLogIdentifier();
      int v26 = 138543362;
      id v27 = v17;
      _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@Ignoring unexpected call to pairing complete", (uint8_t *)&v26, 0xCu);
    }
    id v13 = (void *)v14;
    goto LABEL_9;
  }
  id v8 = (void *)MEMORY[0x2533B64D0]();
  id v9 = self;
  id v10 = HMFGetOSLogHandle();
  id v11 = v10;
  if (v7)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v12 = HMFGetLogIdentifier();
      int v26 = 138543618;
      id v27 = v12;
      __int16 v28 = 2112;
      id v29 = v7;
      _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed before network provisioning: %@", (uint8_t *)&v26, 0x16u);
    }
    id v13 = v8;
LABEL_9:
    goto LABEL_10;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    int v18 = HMFGetLogIdentifier();
    int v26 = 138543362;
    id v27 = v18;
    _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory ready for network provisioning", (uint8_t *)&v26, 0xCu);
  }
  [(HMMTRAccessoryServer *)v9 setCommissioningSessionEstablished:1];
  if ([(HMMTRAccessoryServer *)v9 hasPriorSuccessfulPairing])
  {
    __int16 v19 = (void *)MEMORY[0x2533B64D0]();
    id v20 = v9;
    BOOL v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      char v22 = HMFGetLogIdentifier();
      int v26 = 138543362;
      id v27 = v22;
      _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_INFO, "%{public}@not reading thread network prerequisites", (uint8_t *)&v26, 0xCu);
    }
    id v23 = objc_alloc_init(MEMORY[0x263F10D98]);
    id v24 = [(HMMTRAccessoryServer *)v20 browser];
    uint64_t v25 = [v24 attestationStatus];
    [v25 populateDelegate:v23];

    [(HMMTRAccessoryServer *)v20 _commissionWithParams:v23];
  }
  else
  {
    [(HMMTRAccessoryServer *)v9 _continueNetworkProvisioning];
  }
LABEL_10:
}

- (void)_queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic:(id)a3 completion:(id)a4
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = (void (**)(id, void))a4;
  id v8 = [(HAPAccessoryServer *)self category];
  if (([v8 isEqual:&unk_2702B5B68] & 1) == 0)
  {

LABEL_17:
    v7[2](v7, 0);
    goto LABEL_18;
  }
  id v9 = [v6 service];
  id v10 = [v9 accessory];
  id v11 = [v10 category];
  int v12 = [v11 isEqual:&unk_2702B5B68];

  if (v12) {
    goto LABEL_17;
  }
  id v13 = [(HMMTRAccessoryServer *)self matterDevice];

  if (!v13) {
    goto LABEL_17;
  }
  uint64_t v14 = +[HMMTRHAPService chipPluginServiceForCharacteristic:v6];
  id v15 = v14;
  if (v14 && ([v14 endpoint], uint64_t v16 = objc_claimAutoreleasedReturnValue(), v16, v16))
  {
    uint64_t v47 = v15;
    id v44 = v6;
    __int16 v45 = self;
    int v17 = [v6 service];
    int v18 = [v17 accessory];

    long long v53 = 0u;
    long long v54 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    id v46 = v18;
    __int16 v19 = [v18 services];
    uint64_t v20 = [v19 countByEnumeratingWithState:&v51 objects:v63 count:16];
    if (v20)
    {
      uint64_t v21 = v20;
      uint64_t v22 = *(void *)v52;
      uint64_t v23 = *MEMORY[0x263F356A0];
LABEL_8:
      uint64_t v24 = 0;
      while (1)
      {
        if (*(void *)v52 != v22) {
          objc_enumerationMutation(v19);
        }
        uint64_t v25 = *(void **)(*((void *)&v51 + 1) + 8 * v24);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          int v26 = [v25 type];
          char v27 = [v26 isEqualToString:v23];

          if (v27) {
            break;
          }
        }
        if (v21 == ++v24)
        {
          uint64_t v21 = [v19 countByEnumeratingWithState:&v51 objects:v63 count:16];
          if (v21) {
            goto LABEL_8;
          }
          goto LABEL_15;
        }
      }
      id v29 = v25;

      uint64_t v30 = v29;
      id v6 = v44;
      __int16 v28 = v45;
      if (v29) {
        goto LABEL_24;
      }
    }
    else
    {
LABEL_15:

      id v6 = v44;
      __int16 v28 = v45;
    }
    id v31 = (void *)MEMORY[0x2533B64D0]();
    __int16 v32 = v28;
    uint64_t v33 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
    {
      __int16 v34 = HMFGetLogIdentifier();
      id v35 = [v47 endpoint];
      *(_DWORD *)buf = 138544130;
      uint64_t v56 = v34;
      __int16 v57 = 2112;
      uint64_t v58 = v35;
      __int16 v59 = 2112;
      id v60 = v6;
      __int16 v61 = 2112;
      id v62 = v46;
      __int16 v28 = v45;
      _os_log_impl(&dword_252495000, v33, OS_LOG_TYPE_INFO, "%{public}@Unable to locate Accessory Information Service on accessory %@, defaulting to service endpoint %@ for characteristic: %@", buf, 0x2Au);
    }
    uint64_t v30 = 0;
    id v29 = v47;
LABEL_24:
    __int16 v36 = [v29 endpoint];
    id v37 = [HMMTRDeviceReader alloc];
    uint64_t v38 = [(HAPAccessoryServer *)v28 clientQueue];
    __int16 v39 = [(HMMTRAccessoryServer *)v28 reportDistributor];
    __int16 v40 = [(HMMTRAccessoryServer *)v28 matterDevice];
    uint64_t v41 = [(HMMTRDeviceReader *)v37 initWithClientQueue:v38 distributor:v39 device:v40 endpointID:v36 clusterID:&unk_2702B5A48 attributeID:&unk_2702B5C40];

    uint64_t v42 = [(HMMTRAccessoryServer *)v28 bridgedAccessoryReachabilityReaderTimeoutNSecs];

    if (v42)
    {
      __int16 v43 = [(HMMTRAccessoryServer *)v28 bridgedAccessoryReachabilityReaderTimeoutNSecs];
      -[HMMTRDeviceReader setReportTimeoutNSecs:](v41, "setReportTimeoutNSecs:", [v43 longLongValue]);
    }
    v48[0] = MEMORY[0x263EF8330];
    v48[1] = 3221225472;
    v48[2] = __97__HMMTRAccessoryServer__queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic_completion___block_invoke;
    v48[3] = &unk_265377E10;
    __int16 v50 = v7;
    v48[4] = v28;
    id v15 = v47;
    id v49 = v47;
    [(HMMTRDeviceReader *)v41 readAttributeWithCompletion:v48];
  }
  else
  {
    v7[2](v7, 0);
  }

LABEL_18:
}

void __97__HMMTRAccessoryServer__queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic_completion___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = v3;
  if (v3
    && ([v3 objectForKeyedSubscript:*MEMORY[0x263F10C18]],
        id v5 = objc_claimAutoreleasedReturnValue(),
        char v6 = [v5 isEqual:*MEMORY[0x263F10B78]],
        v5,
        (v6 & 1) != 0))
  {
    id v7 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      id v8 = v7;
    }
    else {
      id v8 = 0;
    }
    id v9 = v8;

    if ([v9 isEqual:MEMORY[0x263EFFA80]])
    {
      id v10 = (void *)MEMORY[0x2533B64D0]();
      id v11 = *(id *)(a1 + 32);
      int v12 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        id v13 = HMFGetLogIdentifier();
        uint64_t v14 = [*(id *)(a1 + 40) endpoint];
        int v15 = 138543618;
        uint64_t v16 = v13;
        __int16 v17 = 2112;
        int v18 = v14;
        _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_ERROR, "%{public}@Bridged accessory for endpoint %@ is unreachable", (uint8_t *)&v15, 0x16u);
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

- (void)fetchColorControlClusterForHapAccessory:(id)a3 completionHandler:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  id v8 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke;
  block[3] = &unk_265378900;
  void block[4] = self;
  id v12 = v6;
  id v13 = v7;
  id v9 = v7;
  id v10 = v6;
  dispatch_async(v8, block);
}

void __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke(id *a1)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  id v2 = [a1[4] deviceController];
  if (v2)
  {
    id v3 = [a1[4] nodeID];
    uint64_t v4 = [v3 unsignedLongLongValue];
    id v5 = [a1[4] clientQueue];
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 3221225472;
    v15[2] = __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke_850;
    v15[3] = &unk_265377250;
    id v6 = a1[5];
    id v7 = a1[4];
    id v16 = v6;
    id v17 = v7;
    id v18 = a1[6];
    [v2 getBaseDevice:v4 queue:v5 completionHandler:v15];

    id v8 = v16;
  }
  else
  {
    id v9 = (void *)MEMORY[0x2533B64D0]();
    id v10 = a1[4];
    id v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      id v12 = HMFGetLogIdentifier();
      id v13 = a1[5];
      *(_DWORD *)buf = 138543618;
      uint64_t v20 = v12;
      __int16 v21 = 2112;
      id v22 = v13;
      _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to fetch color control cluster, hapAccessory: %@", buf, 0x16u);
    }
    uint64_t v14 = (void (**)(id, void, void *))a1[6];
    id v8 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
    v14[2](v14, 0, v8);
  }
}

void __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke_850(id *a1, void *a2, void *a3)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (!v5)
  {
    id v9 = (void *)MEMORY[0x2533B64D0]();
    id v10 = a1[5];
    id v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      id v12 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v32 = v12;
      _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to fetch color control cluster", buf, 0xCu);
    }
    id v13 = (void (**)(id, void, void *))a1[6];
    uint64_t v14 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
    v13[2](v13, 0, v14);
    goto LABEL_12;
  }
  if (![a1[4] isPrimary])
  {
    uint64_t v14 = [a1[5] endPointForHapAccessory:a1[4]];
    if (v14)
    {
      int v15 = +[HMMTRDescriptorClusterManager sharedManager];
      id v16 = [a1[5] clientQueue];
      v24[0] = MEMORY[0x263EF8330];
      v24[1] = 3221225472;
      v24[2] = __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke_852;
      v24[3] = &unk_265377DE8;
      v24[4] = a1[5];
      id v25 = v14;
      id v26 = v5;
      id v27 = a1[6];
      [v15 queryEndpointForClusterID:&unk_2702B5AA8 endpoint:v25 device:v26 callbackQueue:v16 completionHandler:v24];
    }
    else
    {
      id v17 = (void *)MEMORY[0x2533B64D0]();
      id v18 = a1[5];
      uint64_t v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        uint64_t v20 = HMFGetLogIdentifier();
        id v21 = a1[4];
        *(_DWORD *)buf = 138543618;
        __int16 v32 = v20;
        __int16 v33 = 2112;
        id v34 = v21;
        _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_ERROR, "%{public}@Nil endpoint to fetch color control cluster for hapAccessory: %@", buf, 0x16u);
      }
      id v22 = (void (**)(id, void, void *))a1[6];
      uint64_t v23 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:4 userInfo:0];
      v22[2](v22, 0, v23);
    }
LABEL_12:

    goto LABEL_13;
  }
  id v7 = +[HMMTRDescriptorClusterManager sharedManager];
  id v8 = [a1[5] clientQueue];
  v28[0] = MEMORY[0x263EF8330];
  v28[1] = 3221225472;
  v28[2] = __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke_2;
  v28[3] = &unk_265378978;
  v28[4] = a1[5];
  id v29 = v5;
  id v30 = a1[6];
  [v7 endpointForClusterID:&unk_2702B5AA8 device:v29 callbackQueue:v8 completionHandler:v28];

LABEL_13:
}

void __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      id v10 = HMFGetLogIdentifier();
      int v18 = 138543618;
      uint64_t v19 = v10;
      __int16 v20 = 2112;
      id v21 = v5;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_DEBUG, "%{public}@Primary: Found color control cluster at endpoint: %@", (uint8_t *)&v18, 0x16u);
    }
    id v11 = [HMMTRColorControl alloc];
    uint64_t v12 = *(void *)(a1 + 40);
    uint64_t v13 = [v5 unsignedShortValue];
    uint64_t v14 = [*(id *)(a1 + 32) clientQueue];
    int v15 = [(MTRBaseClusterColorControl *)v11 initWithDevice:v12 endpoint:v13 queue:v14];

    id v16 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
  }
  else
  {
    uint64_t v17 = *(void *)(a1 + 48);
    int v15 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
    id v16 = *(void (**)(void))(v17 + 16);
  }
  v16();
}

void __82__HMMTRAccessoryServer_fetchColorControlClusterForHapAccessory_completionHandler___block_invoke_852(uint64_t a1, int a2, void *a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  id v5 = a3;
  id v6 = (void *)MEMORY[0x2533B64D0]();
  id v7 = *(id *)(a1 + 32);
  id v8 = HMFGetOSLogHandle();
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG);
  if (a2)
  {
    if (v9)
    {
      id v10 = HMFGetLogIdentifier();
      uint64_t v11 = *(void *)(a1 + 40);
      int v21 = 138543618;
      uint64_t v22 = v10;
      __int16 v23 = 2112;
      uint64_t v24 = v11;
      _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Found color control cluster at endpoint: %@", (uint8_t *)&v21, 0x16u);
    }
    uint64_t v12 = [HMMTRColorControl alloc];
    uint64_t v13 = *(void *)(a1 + 48);
    uint64_t v14 = [*(id *)(a1 + 40) unsignedShortValue];
    int v15 = [*(id *)(a1 + 32) clientQueue];
    id v16 = [(MTRBaseClusterColorControl *)v12 initWithDevice:v13 endpoint:v14 queue:v15];

    uint64_t v17 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
  }
  else
  {
    if (v9)
    {
      int v18 = HMFGetLogIdentifier();
      uint64_t v19 = *(void *)(a1 + 40);
      int v21 = 138543618;
      uint64_t v22 = v18;
      __int16 v23 = 2112;
      uint64_t v24 = v19;
      _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Did not find color control cluster at endpoint: %@ ", (uint8_t *)&v21, 0x16u);
    }
    uint64_t v20 = *(void *)(a1 + 56);
    id v16 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
    uint64_t v17 = *(void (**)(void))(v20 + 16);
  }
  v17();
}

- (BOOL)doesMatchDiscriminator:(id)a3
{
  id v4 = a3;
  BOOL v5 = [(HMMTRAccessoryServer *)self discriminatorIsOriginatedFromShort];
  id v6 = [(HMMTRAccessoryServer *)self discriminator];
  id v7 = v6;
  if (v5)
  {
    unsigned int v8 = [v6 unsignedShortValue];

    int v9 = [v4 unsignedShortValue];
    return (v9 ^ v8) < 0x100;
  }
  else
  {
    int v11 = [v6 isEqual:v4];

    return v11;
  }
}

- (id)createDoorLockClusterObjectWithFlow:(id)a3
{
  id v4 = a3;
  id v16 = 0;
  BOOL v5 = [MEMORY[0x263F42538] futureWithPromise:&v16];
  id v6 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke;
  block[3] = &unk_265376EE8;
  void block[4] = self;
  id v13 = v4;
  id v14 = v16;
  id v7 = v5;
  id v15 = v7;
  id v8 = v4;
  dispatch_async(v6, block);

  int v9 = v15;
  id v10 = v7;

  return v10;
}

void __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke(uint64_t a1)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    BOOL v5 = HMFGetLogIdentifier();
    id v6 = [*(id *)(a1 + 40) UUID];
    *(_DWORD *)buf = 138543618;
    long long v53 = v5;
    __int16 v54 = 2112;
    id v55 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Getting door lock cluster object", buf, 0x16u);
  }
  id v7 = [*(id *)(a1 + 32) doorLockCluster];

  if (v7)
  {
    id v8 = (void *)MEMORY[0x2533B64D0]();
    id v9 = *(id *)(a1 + 32);
    id v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      int v11 = HMFGetLogIdentifier();
      uint64_t v12 = [*(id *)(a1 + 40) UUID];
      *(_DWORD *)buf = 138543618;
      long long v53 = v11;
      __int16 v54 = 2112;
      id v55 = v12;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Found existing door lock cluster object", buf, 0x16u);
    }
    id v13 = *(void **)(a1 + 48);
    id v14 = [*(id *)(a1 + 32) doorLockCluster];
    [v13 fulfillWithValue:v14];
    goto LABEL_16;
  }
  id v15 = [*(id *)(a1 + 32) doorLockClusterFuture];

  if (v15)
  {
    id v16 = (void *)MEMORY[0x2533B64D0]();
    id v17 = *(id *)(a1 + 32);
    int v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      uint64_t v19 = HMFGetLogIdentifier();
      uint64_t v20 = [*(id *)(a1 + 40) UUID];
      *(_DWORD *)buf = 138543618;
      long long v53 = v19;
      __int16 v54 = 2112;
      id v55 = v20;
      _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Creation is already in progress", buf, 0x16u);
    }
    id v21 = objc_alloc(MEMORY[0x263F42520]);
    uint64_t v22 = [*(id *)(a1 + 32) clientQueue];
    id v14 = (void *)[v21 initWithQueue:v22];

    __int16 v23 = [*(id *)(a1 + 32) doorLockClusterFuture];
    v49[0] = MEMORY[0x263EF8330];
    v49[1] = 3221225472;
    v49[2] = __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_843;
    v49[3] = &unk_265377D48;
    uint64_t v24 = *(void **)(a1 + 40);
    v49[4] = *(void *)(a1 + 32);
    id v50 = v24;
    id v51 = *(id *)(a1 + 48);
    v46[0] = MEMORY[0x263EF8330];
    v46[1] = 3221225472;
    v46[2] = __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_845;
    v46[3] = &unk_265377D70;
    uint64_t v25 = *(void **)(a1 + 40);
    v46[4] = *(void *)(a1 + 32);
    id v47 = v25;
    id v48 = *(id *)(a1 + 48);
    id v26 = (id)[v23 inContext:v14 then:v49 orRecover:v46];

    id v27 = v50;
LABEL_15:

    goto LABEL_16;
  }
  [*(id *)(a1 + 32) setDoorLockClusterFuture:*(void *)(a1 + 56)];
  id v14 = [*(id *)(a1 + 32) deviceController];
  __int16 v28 = (void *)MEMORY[0x2533B64D0]();
  id v29 = *(id *)(a1 + 32);
  id v30 = HMFGetOSLogHandle();
  id v31 = v30;
  if (v14)
  {
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      __int16 v32 = HMFGetLogIdentifier();
      __int16 v33 = [*(id *)(a1 + 40) UUID];
      id v34 = [*(id *)(a1 + 32) nodeID];
      *(_DWORD *)buf = 138543874;
      long long v53 = v32;
      __int16 v54 = 2112;
      id v55 = v33;
      __int16 v56 = 2112;
      __int16 v57 = v34;
      _os_log_impl(&dword_252495000, v31, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Getting base device with nodeID: %@", buf, 0x20u);
    }
    uint64_t v35 = [*(id *)(a1 + 32) nodeID];
    uint64_t v36 = [v35 unsignedLongLongValue];
    id v37 = [*(id *)(a1 + 32) clientQueue];
    v43[0] = MEMORY[0x263EF8330];
    v43[1] = 3221225472;
    v43[2] = __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_847;
    v43[3] = &unk_265377DC0;
    uint64_t v38 = *(void **)(a1 + 40);
    v43[4] = *(void *)(a1 + 32);
    id v44 = v38;
    id v45 = *(id *)(a1 + 48);
    [v14 getBaseDevice:v36 queue:v37 completionHandler:v43];

    id v27 = v44;
    goto LABEL_15;
  }
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    __int16 v39 = HMFGetLogIdentifier();
    __int16 v40 = [*(id *)(a1 + 40) UUID];
    *(_DWORD *)buf = 138543618;
    long long v53 = v39;
    __int16 v54 = 2112;
    id v55 = v40;
    _os_log_impl(&dword_252495000, v31, OS_LOG_TYPE_ERROR, "%{public}@[Flow: %@] No Matter device controller available", buf, 0x16u);
  }
  uint64_t v41 = *(void **)(a1 + 48);
  uint64_t v42 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
  [v41 rejectWithError:v42];

  id v14 = 0;
LABEL_16:
}

uint64_t __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_843(id *a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = a1[4];
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    id v8 = [a1[5] UUID];
    int v10 = 138543874;
    int v11 = v7;
    __int16 v12 = 2112;
    id v13 = v8;
    __int16 v14 = 2112;
    id v15 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Returning doorLockCluster: %@", (uint8_t *)&v10, 0x20u);
  }
  [a1[6] fulfillWithValue:v3];

  return 1;
}

uint64_t __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_845(id *a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = a1[4];
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    id v7 = HMFGetLogIdentifier();
    id v8 = [a1[5] UUID];
    id v9 = a1[4];
    int v11 = 138543874;
    __int16 v12 = v7;
    __int16 v13 = 2112;
    __int16 v14 = v8;
    __int16 v15 = 2048;
    id v16 = v9;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_ERROR, "%{public}@[Flow: %@] Failed to create door lock cluster object. Removing door lock cluster future from accessory server: %p", (uint8_t *)&v11, 0x20u);
  }
  [a1[4] setDoorLockClusterFuture:0];
  [a1[6] rejectWithError:v3];

  return 1;
}

void __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_847(id *a1, void *a2, void *a3)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  unint64_t v5 = a2;
  id v6 = a3;
  uint64_t v7 = [a1[4] matterDevice];
  unint64_t v8 = v5 | v7;

  id v9 = (void *)MEMORY[0x2533B64D0]();
  id v10 = a1[4];
  int v11 = HMFGetOSLogHandle();
  __int16 v12 = v11;
  if (v8)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      uint64_t v17 = HMFGetLogIdentifier();
      int v18 = [a1[5] UUID];
      uint64_t v19 = [a1[4] matterDevice];
      *(_DWORD *)buf = 138544130;
      id v34 = v17;
      __int16 v35 = 2112;
      uint64_t v36 = v18;
      __int16 v37 = 2112;
      uint64_t v38 = (void *)v5;
      __int16 v39 = 2112;
      unint64_t v40 = (unint64_t)v19;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Found base device: %@. matterDevice: %@", buf, 0x2Au);
    }
    uint64_t v20 = (void *)MEMORY[0x2533B64D0]();
    id v21 = a1[4];
    uint64_t v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      __int16 v23 = HMFGetLogIdentifier();
      uint64_t v24 = [a1[5] UUID];
      *(_DWORD *)buf = 138544130;
      id v34 = v23;
      __int16 v35 = 2112;
      uint64_t v36 = v24;
      __int16 v37 = 2112;
      uint64_t v38 = &unk_2702B59A0;
      __int16 v39 = 2112;
      unint64_t v40 = v5;
      _os_log_impl(&dword_252495000, v22, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Looking up endpoint for clusterID: %@, device: %@, ", buf, 0x2Au);
    }
    uint64_t v25 = +[HMMTRDescriptorClusterManager sharedManager];
    id v26 = [a1[4] clientQueue];
    v29[0] = MEMORY[0x263EF8330];
    v29[1] = 3221225472;
    v29[2] = __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_848;
    v29[3] = &unk_265377D98;
    id v27 = a1[5];
    v29[4] = a1[4];
    id v30 = v27;
    id v31 = a1[6];
    id v32 = (id)v5;
    [v25 endpointForClusterID:&unk_2702B59A0 device:v32 callbackQueue:v26 completionHandler:v29];
  }
  else
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      __int16 v13 = HMFGetLogIdentifier();
      __int16 v14 = [a1[5] UUID];
      __int16 v15 = [a1[4] matterDevice];
      *(_DWORD *)buf = 138544386;
      id v34 = v13;
      __int16 v35 = 2112;
      uint64_t v36 = v14;
      __int16 v37 = 2112;
      uint64_t v38 = v15;
      __int16 v39 = 2112;
      unint64_t v40 = 0;
      __int16 v41 = 2112;
      id v42 = v6;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_ERROR, "%{public}@[Flow: %@] Failed to get base device. matter device: %@, base device: %@, getBaseDeviceError: %@", buf, 0x34u);
    }
    if (v6)
    {
      id v16 = v6;
    }
    else
    {
      id v16 = [MEMORY[0x263F087E8] hmfErrorWithCode:2];
    }
    __int16 v28 = v16;
    [a1[6] rejectWithError:v16];
  }
}

void __60__HMMTRAccessoryServer_createDoorLockClusterObjectWithFlow___block_invoke_848(uint64_t a1, void *a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = [*(id *)(a1 + 32) clientQueue];
  dispatch_assert_queue_V2(v7);

  if (v5)
  {
    unint64_t v8 = [HMMTRSyncClusterDoorLock alloc];
    id v9 = [*(id *)(a1 + 32) matterDevice];
    uint64_t v10 = *(void *)(a1 + 56);
    uint64_t v11 = [v5 unsignedShortValue];
    __int16 v12 = [*(id *)(a1 + 32) clientQueue];
    __int16 v13 = [(HMMTRSyncClusterDoorLock *)v8 initWithDevice:v9 baseDevice:v10 endpoint:v11 queue:v12 accessoryServer:*(void *)(a1 + 32)];

    __int16 v14 = (void *)MEMORY[0x2533B64D0]([*(id *)(a1 + 32) setDoorLockCluster:v13]);
    id v15 = *(id *)(a1 + 32);
    id v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      uint64_t v17 = HMFGetLogIdentifier();
      int v18 = [*(id *)(a1 + 40) UUID];
      int v25 = 138543874;
      id v26 = v17;
      __int16 v27 = 2112;
      __int16 v28 = v18;
      __int16 v29 = 2112;
      id v30 = v13;
      _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Created door lock cluster object: %@", (uint8_t *)&v25, 0x20u);
    }
    [*(id *)(a1 + 48) fulfillWithValue:v13];
  }
  else
  {
    uint64_t v19 = (void *)MEMORY[0x2533B64D0]();
    id v20 = *(id *)(a1 + 32);
    id v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = HMFGetLogIdentifier();
      __int16 v23 = [*(id *)(a1 + 40) UUID];
      int v25 = 138543874;
      id v26 = v22;
      __int16 v27 = 2112;
      __int16 v28 = v23;
      __int16 v29 = 2112;
      id v30 = v6;
      _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_ERROR, "%{public}@[Flow: %@] Did not find endpoint for door lock with error: %@", (uint8_t *)&v25, 0x20u);
    }
    if (v6)
    {
      uint64_t v24 = v6;
    }
    else
    {
      uint64_t v24 = [MEMORY[0x263F087E8] hmfErrorWithCode:2];
    }
    __int16 v13 = v24;
    [*(id *)(a1 + 48) rejectWithError:v24];
  }
}

- (void)handleFirmwareUpdateStatusChange:(int64_t)a3
{
  id v6 = [(HMMTRAccessoryServer *)self browser];
  id v5 = [v6 threadSoftwareUpdateController];
  [v5 handleFirmwareUpdateStatusChangeForAccessoryServer:self state:a3];
}

- (id)accessoryProductID
{
  id v2 = [(HMMTRAccessoryServer *)self productID];
  id v3 = (void *)[v2 copy];

  return v3;
}

- (id)accessoryVendorID
{
  id v2 = [(HMMTRAccessoryServer *)self vendorID];
  id v3 = (void *)[v2 copy];

  return v3;
}

- (unint64_t)numActiveSessionClients
{
  return 1;
}

- (unint64_t)sessionCheckInterval
{
  return 0;
}

- (BOOL)doesPeriodicSessionChecks
{
  return 1;
}

- (void)fetchAndNotifyCharacteristics:(id)a3 timeout:(double)a4 completionQueue:(id)a5 completionHandler:(id)a6
{
}

- (void)announceOtaProvider:(id)a3 providerEndpoint:(id)a4 immediateAnnouncement:(BOOL)a5 completionHandler:(id)a6
{
  BOOL v7 = a5;
  uint64_t v53 = *MEMORY[0x263EF8340];
  id v10 = a3;
  id v11 = a4;
  id v12 = a6;
  __int16 v13 = (void *)MEMORY[0x2533B64D0]();
  __int16 v14 = self;
  id v15 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
  {
    id v16 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    id v50 = v16;
    __int16 v51 = 2112;
    long long v52 = v14;
    _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_INFO, "%{public}@announceOtaProvider for %@", buf, 0x16u);
  }
  uint64_t v17 = [HMMTRDeviceTopology alloc];
  int v18 = [(HMMTRAccessoryServer *)v14 nodeID];
  uint64_t v19 = [(HMMTRDeviceTopology *)v17 initWithNodeId:v18 server:v14];

  id v20 = [(HMMTRDeviceTopology *)v19 getEnabledOTARequestorEndpoint];
  if (v20)
  {

LABEL_9:
    __int16 v28 = (void *)MEMORY[0x263F10DA8];
    __int16 v29 = [(HMMTRAccessoryServer *)v14 nodeID];
    uint64_t v30 = [v29 unsignedLongLongValue];
    uint64_t v31 = [(HMMTRAccessoryServer *)v14 deviceController];
    __int16 v27 = [v28 deviceWithNodeID:v30 deviceController:v31];

    id v32 = objc_alloc(MEMORY[0x263F10D28]);
    __int16 v33 = [(HAPAccessoryServer *)v14 clientQueue];
    id v34 = (void *)[v32 initWithDevice:v27 endpoint:0 queue:v33];

    id v35 = objc_alloc_init(MEMORY[0x263F10F38]);
    [v35 setProviderNodeId:v10];
    [v35 setEndpoint:v11];
    [v35 setVendorId:&unk_2702B5C10];
    uint64_t v36 = [v35 setAnnouncementReason:&unk_2702B5BB0];
    if (v34)
    {
      if (v7)
      {
        v47[0] = MEMORY[0x263EF8330];
        v47[1] = 3221225472;
        v47[2] = __101__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_completionHandler___block_invoke;
        v47[3] = &unk_265378578;
        v47[4] = v14;
        id v48 = v12;
        [v34 announceOtaProviderWithParams:v35 expectedValues:0 expectedValueInterval:0 completionHandler:v47];
      }
      v43[0] = MEMORY[0x263EF8330];
      v43[1] = 3221225472;
      v43[2] = __101__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_completionHandler___block_invoke_839;
      v43[3] = &unk_265377458;
      v43[4] = v14;
      id v44 = v34;
      id v45 = v35;
      id v46 = v12;
      [(HMMTRAccessoryServer *)v14 updateDefaultOtaProvider:v10 providerEndpoint:v11 completionHandler:v43];
    }
    else
    {
      id v42 = v10;
      __int16 v37 = (void *)MEMORY[0x2533B64D0](v36);
      uint64_t v38 = v14;
      __int16 v39 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        unint64_t v40 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v50 = v40;
        _os_log_impl(&dword_252495000, v39, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to announce OTA provider", buf, 0xCu);
      }
      __int16 v41 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
      (*((void (**)(id, void *))v12 + 2))(v12, v41);

      id v10 = v42;
    }

    goto LABEL_17;
  }
  id v21 = [(HMMTRDeviceTopology *)v19 getVersionForKey:@"EnumeratedProtocolMap"];
  int v22 = [v21 intValue];

  if (v22 < 101) {
    goto LABEL_9;
  }
  __int16 v23 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v24 = v14;
  int v25 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
  {
    id v26 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    id v50 = v26;
    _os_log_impl(&dword_252495000, v25, OS_LOG_TYPE_INFO, "%{public}@Ignoring OTA announcement, OTA requestor cluster not supported on this accessory", buf, 0xCu);
  }
  __int16 v27 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F41FD8] code:5 userInfo:0];
  (*((void (**)(id, void *))v12 + 2))(v12, v27);
LABEL_17:
}

void __101__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  BOOL v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      unint64_t v8 = HMFGetLogIdentifier();
      uint64_t v9 = *(void *)(a1 + 32);
      int v17 = 138543874;
      int v18 = v8;
      __int16 v19 = 2112;
      uint64_t v20 = v9;
      __int16 v21 = 2112;
      id v22 = v3;
      id v10 = "%{public}@Failed to announce ota provider to %@ with error %@";
      id v11 = v7;
      os_log_type_t v12 = OS_LOG_TYPE_ERROR;
      uint32_t v13 = 32;
LABEL_6:
      _os_log_impl(&dword_252495000, v11, v12, v10, (uint8_t *)&v17, v13);
    }
  }
  else if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    unint64_t v8 = HMFGetLogIdentifier();
    uint64_t v14 = *(void *)(a1 + 32);
    int v17 = 138543618;
    int v18 = v8;
    __int16 v19 = 2112;
    uint64_t v20 = v14;
    id v10 = "%{public}@Successfully announced ota provider to %@";
    id v11 = v7;
    os_log_type_t v12 = OS_LOG_TYPE_INFO;
    uint32_t v13 = 22;
    goto LABEL_6;
  }

  (*(void (**)(void, id, uint64_t, uint64_t))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v3, v15, v16);
}

void __101__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_completionHandler___block_invoke_839(uint64_t a1, void *a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    BOOL v7 = HMFGetLogIdentifier();
    double v8 = *(double *)(a1 + 32);
    *(_DWORD *)buf = 138543874;
    __int16 v37 = v7;
    __int16 v38 = 2112;
    double v39 = v8;
    __int16 v40 = 2112;
    id v41 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Update default OTA provider completed for server:%@ with error: %@", buf, 0x20u);
  }
  id v9 = objc_alloc_init(MEMORY[0x263F10FA0]);
  id v10 = [*(id *)(a1 + 40) readAttributeUpdateStateWithParams:v9];
  double v11 = 0.0;
  if (!v10)
  {
    os_log_type_t v12 = (void *)MEMORY[0x2533B64D0]();
    id v13 = *(id *)(a1 + 32);
    uint64_t v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v37 = v15;
      _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_ERROR, "%{public}@An error occurred while trying to read the OTA requestor update state", buf, 0xCu);
    }
    double v11 = 120.0;
  }
  uint64_t v16 = [v10 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    int v17 = v16;
  }
  else {
    int v17 = 0;
  }
  double v18 = COERCE_DOUBLE(v17);

  __int16 v19 = (void *)MEMORY[0x2533B64D0]();
  id v20 = *(id *)(a1 + 32);
  __int16 v21 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
  {
    id v22 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    __int16 v37 = v22;
    __int16 v38 = 2112;
    double v39 = v18;
    _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_INFO, "%{public}@OTA Requestor update state:%@", buf, 0x16u);
  }
  if (![*(id *)&v18 isEqualToNumber:&unk_2702B5C28]) {
    double v11 = 120.0;
  }
  uint64_t v23 = (void *)MEMORY[0x2533B64D0]();
  id v24 = *(id *)(a1 + 32);
  int v25 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
  {
    id v26 = HMFGetLogIdentifier();
    __int16 v27 = *(void **)(a1 + 32);
    *(_DWORD *)buf = 138543874;
    __int16 v37 = v26;
    __int16 v38 = 2048;
    double v39 = v11;
    __int16 v40 = 2112;
    id v41 = v27;
    _os_log_impl(&dword_252495000, v25, OS_LOG_TYPE_INFO, "%{public}@Sending announcement after %f secs for %@", buf, 0x20u);
  }
  dispatch_time_t v28 = dispatch_time(0, (uint64_t)(v11 * 1000000000.0));
  __int16 v29 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __101__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_completionHandler___block_invoke_842;
  block[3] = &unk_265376F38;
  id v33 = *(id *)(a1 + 40);
  id v30 = *(id *)(a1 + 48);
  uint64_t v31 = *(void *)(a1 + 32);
  id v34 = v30;
  uint64_t v35 = v31;
  dispatch_after(v28, v29, block);

  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

uint64_t __101__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_completionHandler___block_invoke_842(void *a1)
{
  id v2 = (void *)a1[4];
  uint64_t v1 = a1[5];
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 3221225472;
  v4[2] = __101__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_completionHandler___block_invoke_2;
  v4[3] = &unk_265376E00;
  v4[4] = a1[6];
  return [v2 announceOtaProviderWithParams:v1 expectedValues:0 expectedValueInterval:0 completionHandler:v4];
}

void __101__HMMTRAccessoryServer_announceOtaProvider_providerEndpoint_immediateAnnouncement_completionHandler___block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  BOOL v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      double v8 = HMFGetLogIdentifier();
      uint64_t v9 = *(void *)(a1 + 32);
      int v15 = 138543874;
      uint64_t v16 = v8;
      __int16 v17 = 2112;
      uint64_t v18 = v9;
      __int16 v19 = 2112;
      id v20 = v3;
      id v10 = "%{public}@Failed to announce ota provider to %@ with error %@";
      double v11 = v7;
      os_log_type_t v12 = OS_LOG_TYPE_ERROR;
      uint32_t v13 = 32;
LABEL_6:
      _os_log_impl(&dword_252495000, v11, v12, v10, (uint8_t *)&v15, v13);
    }
  }
  else if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    double v8 = HMFGetLogIdentifier();
    uint64_t v14 = *(void *)(a1 + 32);
    int v15 = 138543618;
    uint64_t v16 = v8;
    __int16 v17 = 2112;
    uint64_t v18 = v14;
    id v10 = "%{public}@Successfully announced ota provider to %@";
    double v11 = v7;
    os_log_type_t v12 = OS_LOG_TYPE_INFO;
    uint32_t v13 = 22;
    goto LABEL_6;
  }
}

- (void)updateDefaultOtaProvider:(id)a3 providerEndpoint:(id)a4 completionHandler:(id)a5
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    double v11 = (void *)MEMORY[0x2533B64D0]();
    os_log_type_t v12 = self;
    uint32_t v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      uint64_t v14 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v32 = v14;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting updating default OTA provider.", buf, 0xCu);
    }
    int v15 = [(HAPAccessoryServer *)v12 clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke;
    block[3] = &unk_265377430;
    id v30 = v10;
    dispatch_async(v15, block);

    uint64_t v16 = v30;
  }
  else
  {
    uint64_t v17 = random();
    uint64_t v18 = (void *)MEMORY[0x2533B64D0]();
    __int16 v19 = self;
    id v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      uint64_t v21 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v32 = v21;
      __int16 v33 = 2048;
      uint64_t v34 = v17;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update default ota provider job(%lu) queued.", buf, 0x16u);
    }
    v24[0] = MEMORY[0x263EF8330];
    v24[1] = 3221225472;
    v24[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_827;
    v24[3] = &unk_265377D20;
    v24[4] = v19;
    uint64_t v28 = v17;
    id v25 = v8;
    id v27 = v10;
    id v26 = v9;
    v22[0] = MEMORY[0x263EF8330];
    v22[1] = 3221225472;
    v22[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_835;
    v22[3] = &unk_2653787C8;
    id v23 = v27;
    [(HMMTRAccessoryServer *)v19 queueAccessoryOperation:v24 highPriority:0 completion:v22];

    uint64_t v16 = v25;
  }
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_827(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 64);
    *(_DWORD *)buf = 138543618;
    id v20 = v5;
    __int16 v21 = 2048;
    uint64_t v22 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update default ota provider job(%lu) started.", buf, 0x16u);
  }
  BOOL v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_828;
  block[3] = &unk_265377CF8;
  id v9 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  id v15 = v9;
  id v18 = *(id *)(a1 + 56);
  id v16 = *(id *)(a1 + 48);
  uint64_t v17 = v7;
  id v10 = v7;
  dispatch_async(v8, block);

  double v11 = [*(id *)(a1 + 32) clientQueue];
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  v13[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_834;
  v13[3] = &unk_265377168;
  uint64_t v12 = *(void *)(a1 + 64);
  v13[4] = *(void *)(a1 + 32);
  v13[5] = v12;
  dispatch_group_notify(v10, v11, v13);
}

uint64_t __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_835(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_828(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 138543618;
    uint64_t v23 = v5;
    __int16 v24 = 2112;
    uint64_t v25 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to update default ota provider to %@", buf, 0x16u);
  }
  v20[0] = MEMORY[0x263EF8330];
  v20[1] = 3221225472;
  v20[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_829;
  v20[3] = &unk_2653787C8;
  id v21 = *(id *)(a1 + 64);
  BOOL v7 = (void *)MEMORY[0x2533B66E0](v20);
  id v8 = *(void **)(a1 + 32);
  id v9 = [HMMTRDeviceTopology alloc];
  id v10 = [*(id *)(a1 + 32) nodeID];
  double v11 = [(HMMTRDeviceTopology *)v9 initWithNodeId:v10 server:*(void *)(a1 + 32)];
  uint64_t v12 = [*(id *)(a1 + 32) matterDevice];
  uint32_t v13 = [*(id *)(a1 + 32) clientQueue];
  v16[0] = MEMORY[0x263EF8330];
  v16[1] = 3221225472;
  v16[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_2;
  v16[3] = &unk_265378A68;
  uint64_t v14 = *(void **)(a1 + 40);
  v16[4] = *(void *)(a1 + 32);
  id v19 = v7;
  id v17 = v14;
  id v18 = *(id *)(a1 + 48);
  id v15 = v7;
  [v8 _endpointForOTARequestorWithTopology:v11 mtrDevice:v12 callbackQueue:v13 completionHandler:v16];

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 56));
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_834(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update default ota provider job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

uint64_t __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_829(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    int v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    __int16 v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      __int16 v61 = v10;
      __int16 v62 = 2112;
      id v63 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to query endpoints for ota requestor cluster : %@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  uint64_t v11 = [*(id *)(a1 + 32) matterDevice];

  if (v11)
  {
    id v12 = objc_alloc(MEMORY[0x263F10D28]);
    uint32_t v13 = [*(id *)(a1 + 32) matterDevice];
    uint64_t v14 = [*(id *)(a1 + 32) clientQueue];
    double v39 = (void *)[v12 initWithDevice:v13 endpointID:v5 queue:v14];

    uint64_t v15 = *MEMORY[0x263F10B88];
    v58[0] = &unk_2702B59D0;
    id v41 = v5;
    uint64_t v16 = *MEMORY[0x263F10B90];
    v57[0] = v15;
    v57[1] = v16;
    id v40 = v6;
    uint64_t v18 = *MEMORY[0x263F10C28];
    uint64_t v19 = *MEMORY[0x263F10C30];
    v55[0] = *MEMORY[0x263F10C18];
    uint64_t v17 = v55[0];
    v55[1] = v19;
    uint64_t v20 = *(void *)(a1 + 40);
    v56[0] = v18;
    v56[1] = v20;
    id v21 = [NSDictionary dictionaryWithObjects:v56 forKeys:v55 count:2];
    v58[1] = v21;
    uint64_t v22 = [NSDictionary dictionaryWithObjects:v58 forKeys:v57 count:2];
    v59[0] = v22;
    v53[1] = v16;
    v54[0] = &unk_2702B5BF8;
    v51[0] = v17;
    v51[1] = v19;
    uint64_t v23 = *(void *)(a1 + 48);
    v52[0] = v18;
    v52[1] = v23;
    v53[0] = v15;
    __int16 v24 = [NSDictionary dictionaryWithObjects:v52 forKeys:v51 count:2];
    v54[1] = v24;
    uint64_t v25 = [NSDictionary dictionaryWithObjects:v54 forKeys:v53 count:2];
    v59[1] = v25;
    uint64_t v26 = [MEMORY[0x263EFF8C0] arrayWithObjects:v59 count:2];

    uint64_t v27 = *MEMORY[0x263F10B68];
    v49[1] = v19;
    v50[0] = v27;
    v49[0] = v17;
    uint64_t v46 = v16;
    uint64_t v28 = *MEMORY[0x263F10C10];
    v44[0] = v17;
    v44[1] = v19;
    id v6 = v40;
    id v5 = v41;
    __int16 v29 = v39;
    v45[0] = v28;
    v45[1] = v26;
    id v30 = [NSDictionary dictionaryWithObjects:v45 forKeys:v44 count:2];
    id v47 = v30;
    uint64_t v31 = [NSDictionary dictionaryWithObjects:&v47 forKeys:&v46 count:1];
    id v48 = v31;
    id v32 = [MEMORY[0x263EFF8C0] arrayWithObjects:&v48 count:1];
    v50[1] = v32;
    __int16 v33 = [NSDictionary dictionaryWithObjects:v50 forKeys:v49 count:2];

    [v39 writeAttributeDefaultOTAProvidersWithValue:v33 expectedValueInterval:&unk_2702B5B38];
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  else
  {
    uint64_t v34 = (void *)MEMORY[0x2533B64D0]();
    id v35 = *(id *)(a1 + 32);
    uint64_t v36 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      __int16 v37 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v61 = v37;
      _os_log_impl(&dword_252495000, v36, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to update default OTA provider", buf, 0xCu);
    }
    __int16 v38 = [*(id *)(a1 + 32) clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_830;
    block[3] = &unk_265377430;
    id v43 = *(id *)(a1 + 56);
    dispatch_async(v38, block);

    __int16 v29 = v43;
  }
}

void __84__HMMTRAccessoryServer_updateDefaultOtaProvider_providerEndpoint_completionHandler___block_invoke_830(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

- (void)_handleUnreachableStateWithError:(id)a3
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v4 = a3;
  [(HMMTRAccessoryServer *)self setMtrDeviceConnected:0];
  if ([(HMMTRAccessoryServer *)self _shouldUpdateUnreachableState])
  {
    [(HMMTRAccessoryServer *)self didUpdateReachability:0];
    [(HMMTRAccessoryServer *)self _updateDelegateOfConnectionStatus:0 withError:v4];
  }
  else
  {
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = self;
    int v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = HMFGetLogIdentifier();
      int v9 = 138543362;
      uint64_t v10 = v8;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Ignored unreachable state for WED accessory", (uint8_t *)&v9, 0xCu);
    }
  }
}

- (BOOL)_shouldUpdateUnreachableState
{
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    id v3 = [(HMMTRAccessoryServer *)self browser];
    BOOL v4 = ([v3 isCurrentDevicePrimaryResident] & 1) == 0
      && [(HMMTRAccessoryServer *)self isWEDDevice];
  }
  else
  {
    BOOL v4 = 0;
  }
  return !v4;
}

- (void)generateStateCaptureInformationForReason:(id)a3 completionHandler:(id)a4
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    id v8 = (void *)MEMORY[0x2533B64D0]();
    int v9 = self;
    uint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v28 = v11;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting generating state capture information.", buf, 0xCu);
    }
    id v12 = [(HAPAccessoryServer *)v9 clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke;
    block[3] = &unk_265377430;
    id v26 = v7;
    dispatch_async(v12, block);

    id v13 = v26;
  }
  else
  {
    uint64_t v14 = random();
    uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v16 = self;
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      uint64_t v18 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      uint64_t v28 = v18;
      __int16 v29 = 2048;
      uint64_t v30 = v14;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: generate state capture information job(%lu) queued.", buf, 0x16u);
    }
    v21[0] = MEMORY[0x263EF8330];
    v21[1] = 3221225472;
    v21[2] = __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_817;
    v21[3] = &unk_265377408;
    void v21[4] = v16;
    uint64_t v24 = v14;
    id v23 = v7;
    id v22 = v6;
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_826;
    v19[3] = &unk_2653787C8;
    id v20 = v23;
    [(HMMTRAccessoryServer *)v16 queueAccessoryOperation:v21 highPriority:0 completion:v19];

    id v13 = v23;
  }
}

void __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
  (*(void (**)(uint64_t, void, id))(v1 + 16))(v1, 0, v2);
}

void __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_817(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  BOOL v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 56);
    *(_DWORD *)buf = 138543618;
    id v21 = v5;
    __int16 v22 = 2048;
    uint64_t v23 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: generate state capture information job(%lu) started.", buf, 0x16u);
  }
  id v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_818;
  block[3] = &unk_265377D20;
  void block[4] = *(void *)(a1 + 32);
  id v9 = *(id *)(a1 + 48);
  uint64_t v16 = v7;
  uint64_t v10 = *(void *)(a1 + 56);
  id v18 = v9;
  uint64_t v19 = v10;
  id v17 = *(id *)(a1 + 40);
  uint64_t v11 = v7;
  dispatch_async(v8, block);

  id v12 = [*(id *)(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x263EF8330];
  v14[1] = 3221225472;
  v14[2] = __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_825;
  v14[3] = &unk_265377168;
  uint64_t v13 = *(void *)(a1 + 56);
  v14[4] = *(void *)(a1 + 32);
  void v14[5] = v13;
  dispatch_group_notify(v11, v12, v14);
}

uint64_t __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_826(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_818(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  BOOL v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    __int16 v38 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to generate state capture information", buf, 0xCu);
  }
  v35[0] = MEMORY[0x263EF8330];
  v35[1] = 3221225472;
  void v35[2] = __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_819;
  v35[3] = &unk_265377CA8;
  id v36 = *(id *)(a1 + 56);
  uint64_t v6 = (void (**)(void, void, void))MEMORY[0x2533B66E0](v35);
  id v7 = [*(id *)(a1 + 32) deviceController];
  id v8 = v7;
  if (v7 && ([v7 isRunning] & 1) != 0)
  {
    id v9 = (void *)MEMORY[0x263F10DA8];
    uint64_t v10 = [*(id *)(a1 + 32) nodeID];
    uint64_t v11 = [v10 unsignedLongLongValue];
    id v12 = [*(id *)(a1 + 32) deviceController];
    uint64_t v13 = [v9 deviceWithNodeID:v11 deviceController:v12];

    uint64_t v14 = [MEMORY[0x263EFF910] now];
    uint64_t v15 = +[HMMTRDescriptorClusterManager sharedManager];
    uint64_t v16 = [*(id *)(a1 + 32) nodeID];
    id v17 = *(void **)(a1 + 32);
    id v18 = [v17 clientQueue];
    v30[0] = MEMORY[0x263EF8330];
    v30[1] = 3221225472;
    v30[2] = __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_820;
    v30[3] = &unk_265377CD0;
    id v31 = *(id *)(a1 + 48);
    id v32 = v14;
    uint64_t v33 = *(void *)(a1 + 32);
    uint64_t v34 = v6;
    id v19 = v14;
    [v15 fetchStateCaptureInformationForDevice:v13 nodeId:v16 server:v17 callbackQueue:v18 completionHandler:v30];

    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
  else
  {
    id v20 = (void *)MEMORY[0x2533B64D0]();
    id v21 = *(id *)(a1 + 32);
    __int16 v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      uint64_t v23 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v38 = v23;
      _os_log_impl(&dword_252495000, v22, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to generate state capture information", buf, 0xCu);
    }
    uint64_t v24 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
    ((void (**)(void, void, void *))v6)[2](v6, 0, v24);

    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    uint64_t v25 = (void *)MEMORY[0x2533B64D0]();
    id v26 = *(id *)(a1 + 32);
    uint64_t v27 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
    {
      uint64_t v28 = HMFGetLogIdentifier();
      uint64_t v29 = *(void *)(a1 + 64);
      *(_DWORD *)buf = 138543618;
      __int16 v38 = v28;
      __int16 v39 = 2048;
      uint64_t v40 = v29;
      _os_log_impl(&dword_252495000, v27, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: generate state capture information job(%lu) complete.", buf, 0x16u);
    }
  }
}

void __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_825(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  BOOL v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: generate state capture information job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

uint64_t __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_819(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __83__HMMTRAccessoryServer_generateStateCaptureInformationForReason_completionHandler___block_invoke_820(uint64_t a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  id v3 = a2;
  BOOL v4 = [NSString stringWithFormat:@"Reason: %@, Time: %@, Data: %@", *(void *)(a1 + 32), *(void *)(a1 + 40), v3];
  id v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = *(id *)(a1 + 48);
  int v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    id v8 = HMFGetLogIdentifier();
    __int16 v9 = [*(id *)(a1 + 48) name];
    uint64_t v10 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138544130;
    id v12 = v8;
    __int16 v13 = 2112;
    uint64_t v14 = v9;
    __int16 v15 = 2112;
    uint64_t v16 = v10;
    __int16 v17 = 2112;
    id v18 = v4;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_DEBUG, "%{public}@State Capture: Information generated for %@, triggered by reason %@ : %@", buf, 0x2Au);
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

- (id)protocolMappingStateForCharacteristic:(id)a3
{
  id v4 = a3;
  id v5 = [(HMMTRAccessoryServer *)self characteristicProtocolMappingStates];
  id v6 = [v4 instanceID];
  int v7 = [v5 objectForKeyedSubscript:v6];

  if (!v7)
  {
    int v7 = objc_alloc_init(HMMTRProtocolMappingState);
    id v8 = [(HMMTRAccessoryServer *)self characteristicProtocolMappingStates];
    __int16 v9 = [v4 instanceID];
    [v8 setObject:v7 forKeyedSubscript:v9];
  }
  return v7;
}

- (void)_onThreadScanResults:(id)a3
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v3 = a3;
  id v20 = objc_msgSend(MEMORY[0x263EFF980], "arrayWithCapacity:", objc_msgSend(v3, "count"));
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  id obj = v3;
  uint64_t v21 = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (v21)
  {
    uint64_t v19 = *(void *)v24;
    do
    {
      uint64_t v4 = 0;
      do
      {
        if (*(void *)v24 != v19) {
          objc_enumerationMutation(obj);
        }
        id v5 = *(void **)(*((void *)&v23 + 1) + 8 * v4);
        id v6 = objc_alloc(MEMORY[0x263F11078]);
        int v7 = [v5 networkName];
        id v8 = [v5 panId];
        __int16 v9 = [v5 extendedPanId];
        uint64_t v10 = [v5 channel];
        uint64_t v11 = [v5 extendedAddress];
        id v12 = [v5 rssi];
        __int16 v13 = [v5 version];
        uint64_t v14 = [v5 lqi];
        __int16 v15 = (void *)[v6 initWithNetworkName:v7 panID:v8 extendedPANID:v9 channel:v10 extendedAddress:v11 rssi:v12 version:v13 lqi:v14];
        [v20 addObject:v15];

        ++v4;
      }
      while (v21 != v4);
      uint64_t v21 = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
    }
    while (v21);
  }

  uint64_t v16 = [(HMMTRAccessoryServer *)self stageThreadScanResultsHandler];
  v22[0] = MEMORY[0x263EF8330];
  v22[1] = 3221225472;
  v22[2] = __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke;
  v22[3] = &unk_265377C80;
  void v22[4] = self;
  ((void (**)(void, void *, void *))v16)[2](v16, v20, v22);
}

void __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) clientQueue];
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  v7[2] = __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_2;
  v7[3] = &unk_265376E98;
  uint64_t v5 = *(void *)(a1 + 32);
  id v8 = v3;
  uint64_t v9 = v5;
  id v6 = v3;
  dispatch_async(v4, v7);
}

void __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_2(uint64_t a1)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 32))
  {
    id v2 = objc_alloc_init(MEMORY[0x263F10D98]);
    id v3 = [*(id *)(a1 + 40) browser];
    uint64_t v4 = [v3 attestationStatus];
    [v4 populateDelegate:v2];

    if ([*(id *)(a1 + 40) _populateCommissioningParameterCountryCode:v2])
    {
      uint64_t v5 = (void *)[objc_alloc(MEMORY[0x263F1BF88]) initWithKeychainAccessGroup:@"com.apple.thread.network"];
      id v6 = [*(id *)(a1 + 32) extendedPANID];
      unint64_t v7 = bswap64([v6 unsignedLongLongValue]);

      unint64_t v31 = v7;
      id v8 = [MEMORY[0x263EFF8F8] dataWithBytes:&v31 length:8];
      objc_initWeak(&location, *(id *)(a1 + 40));
      uint64_t v22 = MEMORY[0x263EF8330];
      uint64_t v23 = 3221225472;
      long long v24 = __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_813;
      long long v25 = &unk_265377C58;
      objc_copyWeak(&v29, &location);
      id v26 = v2;
      id v27 = *(id *)(a1 + 32);
      id v9 = v5;
      id v28 = v9;
      uint64_t v10 = (void *)MEMORY[0x2533B66E0](&v22);
      uint64_t v14 = (void *)MEMORY[0x2533B64D0](v10, v11, v12, v13);
      id v15 = *(id *)(a1 + 40);
      HMFGetOSLogHandle();
      uint64_t v16 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        __int16 v17 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        uint64_t v33 = v17;
        __int16 v34 = 2112;
        id v35 = v8;
        _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@Retrieving Thread credentials for extended PANID: %@", buf, 0x16u);
      }
      objc_msgSend(v9, "retrieveActiveDataSetRecordInternallyForExtendedPANID:completion:", v8, v10, v22, v23, v24, v25);

      objc_destroyWeak(&v29);
      objc_destroyWeak(&location);
    }
  }
  else
  {
    id v18 = (void *)MEMORY[0x2533B64D0]();
    id v19 = *(id *)(a1 + 40);
    id v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      uint64_t v21 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v33 = v21;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_INFO, "%{public}@No network selection from Thread scan result. Falling back to default network credentials collection.", buf, 0xCu);
    }
    [*(id *)(a1 + 40) _collectNetworkCredentials:0];
  }
}

void __45__HMMTRAccessoryServer__onThreadScanResults___block_invoke_813(id *a1, void *a2, void *a3)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained(a1 + 7);
  id v8 = (void *)MEMORY[0x2533B64D0]();
  id v9 = WeakRetained;
  if (v5 && !v6 && WeakRetained)
  {
    uint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v38 = v11;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Populating Thread credentials from extended PAN ID", buf, 0xCu);
    }
    uint64_t v12 = [v5 activeOperationalDataSet];
    [a1[4] setThreadOperationalDataset:v12];

    uint64_t v13 = (void *)MEMORY[0x2533B64D0]();
    id v14 = v9;
    id v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v16 = HMFGetLogIdentifier();
      __int16 v17 = [a1[4] threadOperationalDataset];
      *(_DWORD *)buf = 138543618;
      __int16 v38 = v16;
      __int16 v39 = 2112;
      id v40 = v17;
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_DEBUG, "%{public}@Using activeOperationalDataset buffer %@", buf, 0x16u);
    }
    id v18 = (void *)MEMORY[0x2533B64D0]();
    id v19 = v14;
    id v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      uint64_t v21 = HMFGetLogIdentifier();
      uint64_t v22 = [v19 nodeID];
      uint64_t v23 = [a1[5] extendedPANID];
      *(_DWORD *)buf = 138543874;
      __int16 v38 = v21;
      __int16 v39 = 2112;
      id v40 = v22;
      __int16 v41 = 2112;
      uint64_t v42 = v23;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_INFO, "%{public}@Requesting to commission device(%@) with selected network:%@", buf, 0x20u);
    }
    long long v24 = [v19 deviceController];
    if (v24)
    {
      long long v25 = [v19 nodeID];
      uint64_t v26 = [v25 unsignedLongLongValue];
      id v27 = a1[4];
      id v36 = 0;
      [v24 commissionDevice:v26 commissioningParams:v27 error:&v36];
      id v6 = v36;

      uint64_t v28 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:6 error:v6];
    }
    else
    {
      id v6 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
      uint64_t v28 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:6 error:v6];
    }
    unint64_t v31 = (void *)v28;
    if (v6)
    {
      id v32 = (void *)MEMORY[0x2533B64D0]();
      id v33 = v19;
      __int16 v34 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        id v35 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        __int16 v38 = v35;
        __int16 v39 = 2112;
        id v40 = v6;
        _os_log_impl(&dword_252495000, v34, OS_LOG_TYPE_ERROR, "%{public}@Commissioning failed: %@", buf, 0x16u);
      }
      [v33 _pairingComplete:v6 context:v31];
    }
  }
  else
  {
    id v29 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      __int16 v38 = v30;
      __int16 v39 = 2112;
      id v40 = v6;
      _os_log_impl(&dword_252495000, v29, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory Server failed to obtain Thread credentials for selected extended PAN ID... Error: %@", buf, 0x16u);
    }
    unint64_t v31 = +[HMMTRAccessoryPairingEndContext otherContextWithStep:4 error:v6];
    [v9 _pairingComplete:v6 context:v31];
  }

  [a1[6] invalidate];
}

- (void)_onWiFiScanResults:(id)a3
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  id v3 = a3;
  uint64_t v4 = objc_msgSend(MEMORY[0x263EFF980], "arrayWithCapacity:", objc_msgSend(v3, "count"));
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  id obj = v3;
  uint64_t v5 = [obj countByEnumeratingWithState:&v26 objects:v34 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v27;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v27 != v7) {
          objc_enumerationMutation(obj);
        }
        id v9 = *(void **)(*((void *)&v26 + 1) + 8 * v8);
        id v10 = objc_alloc(MEMORY[0x263F11088]);
        uint64_t v11 = [v9 ssid];
        uint64_t v12 = [v9 rssi];
        uint64_t v13 = [v9 security];
        uint64_t v14 = [v13 unsignedCharValue];
        id v15 = [v9 wiFiBand];
        uint64_t v16 = objc_msgSend(v10, "initWithSSID:rssi:security:band:", v11, v12, v14, objc_msgSend(v15, "unsignedCharValue"));
        [v4 addObject:v16];

        ++v8;
      }
      while (v6 != v8);
      uint64_t v6 = [obj countByEnumeratingWithState:&v26 objects:v34 count:16];
    }
    while (v6);
  }

  __int16 v17 = (void *)MEMORY[0x2533B64D0]();
  id v18 = self;
  id v19 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
  {
    id v20 = HMFGetLogIdentifier();
    uint64_t v21 = [v4 count];
    *(_DWORD *)buf = 138543618;
    unint64_t v31 = v20;
    __int16 v32 = 2048;
    uint64_t v33 = v21;
    _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_INFO, "%{public}@Calling scan results handler with %lu scan results", buf, 0x16u);
  }
  uint64_t v22 = [(HMMTRAccessoryServer *)v18 stageWiFiScanResultsHandler];
  v25[0] = MEMORY[0x263EF8330];
  v25[1] = 3221225472;
  v25[2] = __43__HMMTRAccessoryServer__onWiFiScanResults___block_invoke;
  v25[3] = &unk_265377C30;
  v25[4] = v18;
  ((void (**)(void, void *, void *))v22)[2](v22, v4, v25);
}

void __43__HMMTRAccessoryServer__onWiFiScanResults___block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) clientQueue];
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  v7[2] = __43__HMMTRAccessoryServer__onWiFiScanResults___block_invoke_2;
  v7[3] = &unk_265376E98;
  uint64_t v5 = *(void *)(a1 + 32);
  id v8 = v3;
  uint64_t v9 = v5;
  id v6 = v3;
  dispatch_async(v4, v7);
}

void __43__HMMTRAccessoryServer__onWiFiScanResults___block_invoke_2(uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 32))
  {
    id v2 = objc_alloc_init(MEMORY[0x263F10D98]);
    id v3 = [*(id *)(a1 + 40) browser];
    uint64_t v4 = [v3 attestationStatus];
    [v4 populateDelegate:v2];

    if (![*(id *)(a1 + 40) _populateCommissioningParameterCountryCode:v2])
    {
LABEL_18:

      return;
    }
    uint64_t v5 = [*(id *)(a1 + 32) ssid];
    [v2 setWifiSSID:v5];

    id v6 = [*(id *)(a1 + 32) credentials];
    [v2 setWifiCredentials:v6];

    uint64_t v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 40);
    uint64_t v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      id v10 = HMFGetLogIdentifier();
      uint64_t v11 = [*(id *)(a1 + 40) nodeID];
      uint64_t v12 = [*(id *)(a1 + 32) ssid];
      *(_DWORD *)buf = 138543874;
      __int16 v32 = v10;
      __int16 v33 = 2112;
      id v34 = v11;
      __int16 v35 = 2112;
      id v36 = v12;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_INFO, "%{public}@Requesting to commission device(%@) with selected network:%@", buf, 0x20u);
    }
    uint64_t v13 = [*(id *)(a1 + 40) deviceController];
    if (v13)
    {
      uint64_t v14 = [*(id *)(a1 + 40) nodeID];
      id v30 = 0;
      objc_msgSend(v13, "commissionDevice:commissioningParams:error:", objc_msgSend(v14, "unsignedLongLongValue"), v2, &v30);
      id v15 = v30;

      if (!v15)
      {
LABEL_17:

        goto LABEL_18;
      }
      uint64_t v16 = (void *)MEMORY[0x2533B64D0]();
      id v17 = *(id *)(a1 + 40);
      id v18 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        id v19 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        __int16 v32 = v19;
        __int16 v33 = 2112;
        id v34 = v15;
        _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_ERROR, "%{public}@Commissioning failed: %@", buf, 0x16u);
      }
      uint64_t v20 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:6 error:v15];
    }
    else
    {
      long long v25 = (void *)MEMORY[0x2533B64D0]();
      id v26 = *(id *)(a1 + 40);
      long long v27 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        long long v28 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        __int16 v32 = v28;
        _os_log_impl(&dword_252495000, v27, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to commission", buf, 0xCu);
      }
      id v15 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
      uint64_t v20 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:5 error:v15];
    }
    long long v29 = (void *)v20;
    [*(id *)(a1 + 40) _pairingComplete:v15 context:v20];

    goto LABEL_17;
  }
  uint64_t v21 = (void *)MEMORY[0x2533B64D0]();
  id v22 = *(id *)(a1 + 40);
  uint64_t v23 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    long long v24 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    __int16 v32 = v24;
    _os_log_impl(&dword_252495000, v23, OS_LOG_TYPE_INFO, "%{public}@No network selection from WiFi scan result. Falling back to default network credentials collection.", buf, 0xCu);
  }
  [*(id *)(a1 + 40) _collectNetworkCredentials:0];
}

- (void)_onNetworkScanResults:(id)a3
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v4 = a3;
  uint64_t v5 = [v4 wiFiScanResults];
  if (v5)
  {

    goto LABEL_4;
  }
  id v6 = [v4 threadScanResults];

  if (v6)
  {
LABEL_4:
    uint64_t v7 = [v4 wiFiScanResults];

    if (v7)
    {
      id v8 = [v4 wiFiScanResults];
      [(HMMTRAccessoryServer *)self _onWiFiScanResults:v8];
    }
    else
    {
      uint64_t v9 = [v4 threadScanResults];

      if (!v9) {
        _HMFPreconditionFailure();
      }
      id v8 = [v4 threadScanResults];
      [(HMMTRAccessoryServer *)self _onThreadScanResults:v8];
    }
    goto LABEL_11;
  }
  id v10 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v11 = self;
  uint64_t v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    uint64_t v13 = HMFGetLogIdentifier();
    int v15 = 138543362;
    uint64_t v16 = v13;
    _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_ERROR, "%{public}@Neither WiFi nor Thread scan results present in scan response", (uint8_t *)&v15, 0xCu);
  }
  id v8 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F41FD8] code:11 userInfo:0];
  uint64_t v14 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:3 error:v8];
  [(HMMTRAccessoryServer *)v11 _pairingComplete:v8 context:v14];

LABEL_11:
}

- (void)_requestAccessoryNetworkScanWithCompletionHandler:(id)a3
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v4 = a3;
  uint64_t v5 = [(HMMTRAccessoryServer *)self deviceController];
  id v6 = [(HMMTRAccessoryServer *)self nodeID];
  id v17 = 0;
  uint64_t v7 = objc_msgSend(v5, "getDeviceBeingCommissioned:error:", objc_msgSend(v6, "unsignedLongLongValue"), &v17);
  id v8 = v17;

  if (v7)
  {
    v14[0] = MEMORY[0x263EF8330];
    v14[1] = 3221225472;
    v14[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke;
    v14[3] = &unk_265378978;
    v14[4] = self;
    id v16 = v4;
    id v15 = v7;
    [(HMMTRAccessoryServer *)self _getCommissioneeNetworkCommissioningClusterEndpointWithDevice:v15 completion:v14];
  }
  else
  {
    uint64_t v9 = (void *)MEMORY[0x2533B64D0]();
    id v10 = self;
    uint64_t v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v19 = v12;
      __int16 v20 = 2112;
      id v21 = v8;
      _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_ERROR, "%{public}@Couldn't get device being commissioned for network scanning: %@", buf, 0x16u);
    }
    if (!v8)
    {
      id v8 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:1 userInfo:0];
    }
    uint64_t v13 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v8];
    (*((void (**)(id, void, id, void *))v4 + 2))(v4, 0, v8, v13);
  }
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    id v7 = objc_alloc(MEMORY[0x263F10C98]);
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = [v5 unsignedShortValue];
    id v10 = [*(id *)(a1 + 32) clientQueue];
    uint64_t v11 = (void *)[v7 initWithDevice:v8 endpoint:v9 queue:v10];

    if (v11)
    {
      v23[0] = MEMORY[0x263EF8330];
      v23[1] = 3221225472;
      v23[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_797;
      void v23[3] = &unk_265378978;
      v23[4] = *(void *)(a1 + 32);
      id v25 = *(id *)(a1 + 48);
      id v12 = v11;
      id v24 = v12;
      [v12 readAttributeFeatureMapWithCompletionHandler:v23];
    }
    else
    {
      id v17 = (void *)MEMORY[0x2533B64D0]();
      id v18 = *(id *)(a1 + 32);
      id v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        __int16 v20 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        long long v27 = v20;
        _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_ERROR, "%{public}@Network commissioning cluster init failed for scanning", buf, 0xCu);
      }
      id v21 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F41FD8] code:11 userInfo:0];
      uint64_t v22 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:3 error:v21];
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();

      id v12 = 0;
    }
  }
  else
  {
    uint64_t v13 = (void *)MEMORY[0x2533B64D0]();
    id v14 = *(id *)(a1 + 32);
    id v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      id v16 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      long long v27 = v16;
      __int16 v28 = 2112;
      id v29 = v6;
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_INFO, "%{public}@Network commissioning cluster not found for scanning: %@. Returning empty scan results.", buf, 0x16u);
    }
    id v12 = objc_alloc_init(MEMORY[0x263F10EF0]);
    [v12 setWiFiScanResults:MEMORY[0x263EFFA68]];
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_797(id *a1, void *a2, void *a3)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (!v5)
  {
    id v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = a1[4];
    id v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      id v18 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      uint64_t v66 = (uint64_t)v18;
      __int16 v67 = 2112;
      long long v68 = v6;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@Couldn't get network commissioning cluster features for scanning: %@", buf, 0x16u);
    }
    id v19 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v6];
    __int16 v20 = (void (*)(void))*((void *)a1[6] + 2);
    goto LABEL_39;
  }
  char v7 = [v5 unsignedIntegerValue];
  uint64_t v8 = v7 & 1;
  char v9 = [v5 unsignedIntegerValue];
  char v10 = v9;
  if ((v7 & 1) == 0 || (v9 & 2) != 0)
  {
    if ((v9 & 2) != 0)
    {
      id v21 = (void *)MEMORY[0x2533B64D0]();
      id v22 = a1[4];
      uint64_t v23 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
      {
        id v24 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v66 = (uint64_t)v24;
        _os_log_impl(&dword_252495000, v23, OS_LOG_TYPE_INFO, "%{public}@Setting linkLayerType to Thread", buf, 0xCu);
      }
      [a1[4] setLinkLayerType:4];
      if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
      {
        id v25 = [a1[4] defaultThreadOperationalDataset];

        id v26 = (void *)MEMORY[0x2533B64D0]();
        id v27 = a1[4];
        __int16 v28 = HMFGetOSLogHandle();
        BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_INFO);
        if (!v25)
        {
          if (v29)
          {
            __int16 v56 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543362;
            uint64_t v66 = (uint64_t)v56;
            _os_log_impl(&dword_252495000, v28, OS_LOG_TYPE_INFO, "%{public}@Default thread operational dataset is not available. Will inform browser later to start thread if needed when operational dataset is available", buf, 0xCu);
          }
          [a1[4] setDeferStartThreadForPairing:1];
          if (!v8) {
            goto LABEL_21;
          }
          goto LABEL_19;
        }
        if (v29)
        {
          uint64_t v30 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543362;
          uint64_t v66 = (uint64_t)v30;
          _os_log_impl(&dword_252495000, v28, OS_LOG_TYPE_INFO, "%{public}@Default thread operational dataset is available. Proceed with informing browser to start thread if needed", buf, 0xCu);
        }
        unint64_t v31 = [a1[4] browser];
        __int16 v32 = [a1[4] fabricID];
        __int16 v33 = [a1[4] nodeID];
        [v31 handlePairingForThreadAccessoryWithFabricID:v32 nodeID:v33];
      }
    }
    if (!v8) {
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v11 = (void *)MEMORY[0x2533B64D0]();
    id v12 = a1[4];
    uint64_t v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      id v14 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v66 = (uint64_t)v14;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Setting linkLayerType to WiFi", buf, 0xCu);
    }
    [a1[4] setLinkLayerType:1];
  }
LABEL_19:
  id v34 = [a1[4] stageWiFiScanResultsHandler];
  if (v34 || ![a1[4] _controllerIsOnWiFiNetworkWhichSupportsBothBands])
  {

    goto LABEL_27;
  }
LABEL_21:
  __int16 v35 = [a1[4] stageThreadScanResultsHandler];

  if (!v35 || (v10 & 2) == 0)
  {
    id v36 = (void *)MEMORY[0x2533B64D0]();
    id v37 = a1[4];
    __int16 v38 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
    {
      __int16 v39 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      uint64_t v66 = (uint64_t)v39;
      __int16 v67 = 2112;
      long long v68 = (const char *)v5;
      _os_log_impl(&dword_252495000, v38, OS_LOG_TYPE_INFO, "%{public}@Network commissioning cluster feature (featureMap: %@) doesn't require scanning for current request. Returning empty scan results.", buf, 0x16u);
    }
    id v40 = objc_alloc_init(MEMORY[0x263F10EF0]);
    id v19 = v40;
    uint64_t v41 = MEMORY[0x263EFFA68];
LABEL_37:
    [v40 setWiFiScanResults:v41];
    goto LABEL_38;
  }
LABEL_27:
  if ([a1[4] stageNetworkScanRequested])
  {
    v61[0] = MEMORY[0x263EF8330];
    v61[1] = 3221225472;
    void v61[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_798;
    v61[3] = &unk_265378900;
    id v42 = a1[5];
    id v43 = a1[4];
    id v62 = v42;
    id v63 = v43;
    id v64 = a1[6];
    id v44 = (void (**)(void))MEMORY[0x2533B66E0](v61);
    id v45 = [a1[4] stageWiFiScanResultsHandler];
    uint64_t v46 = v45;
    if (v45 && v8)
    {
    }
    else
    {
      uint64_t v53 = [a1[4] stageThreadScanResultsHandler];

      if (!v53 || (v10 & 2) == 0)
      {
        id v54 = a1[4];
        id v55 = a1[5];
        v57[0] = MEMORY[0x263EF8330];
        v57[1] = 3221225472;
        void v57[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_2_804;
        v57[3] = &unk_265377C08;
        v57[4] = v54;
        char v60 = v8;
        id v58 = a1[6];
        __int16 v59 = v44;
        [v54 _getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster:v55 completion:v57];

        goto LABEL_44;
      }
    }
    v44[2](v44);
LABEL_44:

    id v19 = v62;
    goto LABEL_45;
  }
  id v47 = (void *)MEMORY[0x2533B64D0]();
  id v48 = a1[4];
  id v49 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
  {
    uint64_t v50 = HMFGetLogIdentifier();
    __int16 v51 = (void *)v50;
    long long v52 = "WiFi";
    if (!v8) {
      long long v52 = "Thread";
    }
    *(_DWORD *)buf = 138543618;
    uint64_t v66 = v50;
    __int16 v67 = 2080;
    long long v68 = v52;
    _os_log_impl(&dword_252495000, v49, OS_LOG_TYPE_INFO, "%{public}@Network scanning was not requested by upper layer. Returning empty scan results for %s.", buf, 0x16u);
  }
  id v40 = objc_alloc_init(MEMORY[0x263F10EF0]);
  id v19 = v40;
  uint64_t v41 = MEMORY[0x263EFFA68];
  if (v8) {
    goto LABEL_37;
  }
  [v40 setThreadScanResults:MEMORY[0x263EFFA68]];
LABEL_38:
  __int16 v20 = (void (*)(void))*((void *)a1[6] + 2);
LABEL_39:
  v20();
LABEL_45:
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_798(uint64_t a1)
{
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 3221225472;
  v4[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_2;
  v4[3] = &unk_265378978;
  int8x16_t v3 = *(int8x16_t *)(a1 + 32);
  id v2 = (id)v3.i64[0];
  int8x16_t v5 = vextq_s8(v3, v3, 8uLL);
  id v6 = *(id *)(a1 + 48);
  [v2 readAttributeScanMaxTimeSecondsWithCompletionHandler:v4];
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_2_804(uint64_t a1, int a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  id v5 = a3;
  if (v5 || !a2)
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    id v6 = (void *)MEMORY[0x2533B64D0]();
    id v7 = *(id *)(a1 + 32);
    uint64_t v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      char v9 = HMFGetLogIdentifier();
      int v12 = 138543362;
      uint64_t v13 = v9;
      _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_INFO, "%{public}@Commissionee already has a commissioned network. Skip network scanning.", (uint8_t *)&v12, 0xCu);
    }
    id v10 = objc_alloc_init(MEMORY[0x263F10EF0]);
    uint64_t v11 = v10;
    if (*(unsigned char *)(a1 + 56)) {
      [v10 setWiFiScanResults:MEMORY[0x263EFFA68]];
    }
    else {
      [v10 setThreadScanResults:MEMORY[0x263EFFA68]];
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    id v7 = v5;
  }
  else
  {
    uint64_t v8 = (void *)MEMORY[0x2533B64D0]();
    id v9 = *(id *)(a1 + 32);
    id v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v21 = v11;
      __int16 v22 = 2112;
      id v23 = v6;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_ERROR, "%{public}@Couldn't get scan max time from device: %@", buf, 0x16u);
    }
    id v7 = &unk_2702B5BE0;
  }
  id v12 = objc_alloc_init(MEMORY[0x263F10EE8]);
  uint64_t v13 = (void *)MEMORY[0x2533B64D0]([v12 setServerSideProcessingTimeout:v7]);
  id v14 = *(id *)(a1 + 32);
  id v15 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    id v16 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    id v21 = v16;
    __int16 v22 = 2112;
    id v23 = v7;
    _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_DEBUG, "%{public}@Sending scan network command with timeout: %@", buf, 0x16u);
  }
  v18[0] = MEMORY[0x263EF8330];
  v18[1] = 3221225472;
  v18[2] = __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_802;
  v18[3] = &unk_265377BE0;
  id v17 = *(void **)(a1 + 40);
  id v19 = *(id *)(a1 + 48);
  [v17 scanNetworksWithParams:v12 completionHandler:v18];
  [*(id *)(a1 + 32) _notifyDelegateOfPairingProgress:17];
}

void __74__HMMTRAccessoryServer__requestAccessoryNetworkScanWithCompletionHandler___block_invoke_802(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  id v7 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v5];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

- (id)_convertFetchedCredentials:(id)a3
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = objc_alloc(MEMORY[0x263F10FF0]);
  id v6 = [v4 name];
  id v7 = [v4 extendedPANID];
  uint64_t v8 = [v4 masterKey];
  id v9 = [v4 PSKc];
  uint64_t v10 = [v4 channel];
  uint64_t v11 = [v4 PANID];
  id v12 = (void *)[v5 initWithNetworkName:v6 extendedPANID:v7 masterKey:v8 PSKc:v9 channel:v10 panID:v11];

  uint64_t v13 = (void *)MEMORY[0x2533B64D0]();
  id v14 = self;
  id v15 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
  {
    id v16 = HMFGetLogIdentifier();
    id v17 = [v12 networkName];
    id v18 = [v12 panID];
    int v20 = 138543874;
    id v21 = v16;
    __int16 v22 = 2112;
    id v23 = v17;
    __int16 v24 = 2112;
    id v25 = v18;
    _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_INFO, "%{public}@Converted HAPThreadNetworkMetadata to MTRThreadOperationalDataset. Got network with Name:%@ and PanID:%@", (uint8_t *)&v20, 0x20u);
  }

  return v12;
}

- (id)_matterCredentialsFromTHCredentials:(id)a3
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = objc_alloc(MEMORY[0x263F10FF0]);
  id v6 = [v4 activeOperationalDataSet];
  id v7 = (void *)[v5 initWithData:v6];

  uint64_t v8 = (void *)MEMORY[0x2533B64D0]();
  id v9 = self;
  uint64_t v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    uint64_t v11 = HMFGetLogIdentifier();
    id v12 = [v7 networkName];
    uint64_t v13 = [v7 panID];
    int v15 = 138543874;
    id v16 = v11;
    __int16 v17 = 2112;
    id v18 = v12;
    __int16 v19 = 2112;
    int v20 = v13;
    _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Converted THCredentials to MTRThreadOperationalDataset. Got network with Name:%@ and PanID:%@", (uint8_t *)&v15, 0x20u);
  }

  return v7;
}

- (void)_populateThreadCredentials:(id)a3 completion:(id)a4
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = (void (**)(id, void, void *, void *))a4;
  uint64_t v8 = [(HMMTRAccessoryServer *)self defaultThreadOperationalDatasetReceiveBlock];

  if (v8)
  {
    id v9 = [(HMMTRAccessoryServer *)self defaultThreadOperationalDatasetReceiveBlock];
    uint64_t v10 = [MEMORY[0x263F087E8] hapErrorWithCode:2];
    ((void (**)(void, void, void *))v9)[2](v9, 0, v10);

    [(HMMTRAccessoryServer *)self setDefaultThreadOperationalDatasetReceiveBlock:0];
  }
  if ([(HMMTRAccessoryServer *)self defaultThreadOperationalDatasetRetrieved])
  {
    uint64_t v11 = [(HMMTRAccessoryServer *)self defaultThreadOperationalDataset];

    BOOL v12 = v11 == 0;
    uint64_t v13 = (void *)MEMORY[0x2533B64D0]();
    id v14 = self;
    int v15 = HMFGetOSLogHandle();
    id v16 = v15;
    if (v12)
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        BOOL v29 = v21;
        _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_ERROR, "%{public}@Populating Thread credential collection error", buf, 0xCu);
      }
      __int16 v22 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:30 userInfo:0];
      id v23 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:4 error:v22];
      v7[2](v7, 0, v22, v23);
    }
    else
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        __int16 v17 = HMFGetLogIdentifier();
        id v18 = [(HMMTRAccessoryServer *)v14 defaultThreadOperationalDataset];
        __int16 v19 = objc_msgSend(v18, "hmf_hexadecimalRepresentation");
        *(_DWORD *)buf = 138543618;
        BOOL v29 = v17;
        __int16 v30 = 2112;
        unint64_t v31 = v19;
        _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@Populating Thread credentials - dataset: %@", buf, 0x16u);
      }
      int v20 = [(HMMTRAccessoryServer *)v14 defaultThreadOperationalDataset];
      [v6 setThreadOperationalDataset:v20];

      ((void (**)(id, id, void *, void *))v7)[2](v7, v6, 0, 0);
    }
  }
  else
  {
    objc_initWeak((id *)buf, self);
    v24[0] = MEMORY[0x263EF8330];
    v24[1] = 3221225472;
    v24[2] = __62__HMMTRAccessoryServer__populateThreadCredentials_completion___block_invoke;
    v24[3] = &unk_265377BB8;
    objc_copyWeak(&v27, (id *)buf);
    id v25 = v6;
    uint64_t v26 = v7;
    [(HMMTRAccessoryServer *)self setDefaultThreadOperationalDatasetReceiveBlock:v24];

    objc_destroyWeak(&v27);
    objc_destroyWeak((id *)buf);
  }
}

void __62__HMMTRAccessoryServer__populateThreadCredentials_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v8 = (void *)MEMORY[0x2533B64D0]();
  id v9 = WeakRetained;
  uint64_t v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    uint64_t v11 = HMFGetLogIdentifier();
    int v14 = 138543362;
    int v15 = v11;
    _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Populating Thread credentials", (uint8_t *)&v14, 0xCu);
  }
  if (v5) {
    [*(id *)(a1 + 32) setThreadOperationalDataset:v5];
  }
  if (v6)
  {
    BOOL v12 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:4 error:v6];
  }
  else
  {
    BOOL v12 = 0;
  }
  if (v5) {
    uint64_t v13 = *(void *)(a1 + 32);
  }
  else {
    uint64_t v13 = 0;
  }
  (*(void (**)(void, uint64_t, id, void *))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v13, v6, v12);
}

- (void)_prepareThreadCredentials
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  int8x16_t v3 = (void *)MEMORY[0x2533B64D0](self, a2);
  id v4 = self;
  id v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    uint64_t v16 = v6;
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@Collecting Thread Credentials...", buf, 0xCu);
  }
  [(HMMTRAccessoryServer *)v4 setDefaultThreadOperationalDataset:0];
  [(HMMTRAccessoryServer *)v4 setDefaultThreadOperationalDatasetRetrieved:0];
  [(HMMTRAccessoryServer *)v4 setDeferStartThreadForPairing:0];
  [(HMMTRAccessoryServer *)v4 _startCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameRetrieveThreadCredentials"];
  [(HMMTRAccessoryServer *)v4 _notifyDelegateOfPairingProgress:30];
  if ([(HMMTRAccessoryServer *)v4 pairedState] == 1)
  {
    id v7 = (void *)[objc_alloc(MEMORY[0x263F1BF88]) initWithKeychainAccessGroup:@"com.apple.thread.network"];
    objc_initWeak((id *)buf, v4);
    v10[0] = MEMORY[0x263EF8330];
    v10[1] = 3221225472;
    v10[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_790;
    v10[3] = &unk_265377B90;
    objc_copyWeak(&v12, (id *)buf);
    id v8 = v7;
    id v11 = v8;
    [v8 retrievePreferredCredentialsInternally:v10];

    objc_destroyWeak(&v12);
    objc_destroyWeak((id *)buf);
  }
  else
  {
    objc_initWeak((id *)buf, v4);
    id v9 = [(HMMTRAccessoryServer *)v4 browser];
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 3221225472;
    v13[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke;
    v13[3] = &unk_265377B68;
    objc_copyWeak(&v14, (id *)buf);
    [v9 fetchPreferredThreadCredentialsForServer:v4 withCompletion:v13];

    objc_destroyWeak(&v14);
    objc_destroyWeak((id *)buf);
  }
}

void __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v8 = WeakRetained;
  if (v5 && !v6 && WeakRetained)
  {
    if (isFeatureMatteriPhoneOnlyPairingControlEnabled()
      && ([v5 activeOperationalDataSet],
          id v9 = objc_claimAutoreleasedReturnValue(),
          v9,
          v9))
    {
      uint64_t v10 = [v5 activeOperationalDataSet];
      id v11 = (void *)MEMORY[0x2533B64D0]();
      id v12 = v8;
      uint64_t v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        id v14 = HMFGetLogIdentifier();
        int v15 = objc_msgSend(v10, "hmf_hexadecimalRepresentation");
        *(_DWORD *)buf = 138543618;
        id v25 = v14;
        __int16 v26 = 2112;
        id v27 = v15;
        uint64_t v16 = "%{public}@Retrieved Thread operational dataset (unpaired,activeOperationalDataSet): %@";
LABEL_12:
        _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, v16, buf, 0x16u);
      }
    }
    else
    {
      id v18 = [v8 _convertFetchedCredentials:v5];
      uint64_t v10 = [v18 data];

      id v11 = (void *)MEMORY[0x2533B64D0]();
      id v19 = v8;
      uint64_t v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        id v14 = HMFGetLogIdentifier();
        int v15 = objc_msgSend(v10, "hmf_hexadecimalRepresentation");
        *(_DWORD *)buf = 138543618;
        id v25 = v14;
        __int16 v26 = 2112;
        id v27 = v15;
        uint64_t v16 = "%{public}@Retrieved Thread operational dataset (unpaired,HAPThreadNetworkMetadata): %@";
        goto LABEL_12;
      }
    }

    int v20 = [v8 clientQueue];
    v21[0] = MEMORY[0x263EF8330];
    v21[1] = 3221225472;
    v21[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_787;
    v21[3] = &unk_265376E98;
    void v21[4] = v8;
    id v22 = v10;
    uint64_t v17 = v10;
    dispatch_async(v20, v21);

    goto LABEL_14;
  }
  [WeakRetained _notifyDelegateOfPairingProgress:32 error:v6];
  if (v8)
  {
    uint64_t v17 = [v8 clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_2;
    block[3] = &unk_265378638;
    void block[4] = v8;
    dispatch_async(v17, block);
LABEL_14:
  }
}

void __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_790(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v11 = WeakRetained;
  if (v7 && !v9 && WeakRetained)
  {
    id v12 = [WeakRetained _matterCredentialsFromTHCredentials:v7];
    uint64_t v13 = [v12 data];

    id v14 = (void *)MEMORY[0x2533B64D0]();
    id v15 = v11;
    uint64_t v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      HMFGetLogIdentifier();
      uint64_t v17 = v21 = v8;
      id v18 = objc_msgSend(v13, "hmf_hexadecimalRepresentation");
      *(_DWORD *)buf = 138543618;
      __int16 v26 = v17;
      __int16 v27 = 2112;
      uint64_t v28 = v18;
      _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@Retrieved Thread operational dataset (staging): %@", buf, 0x16u);

      id v8 = v21;
    }

    id v19 = [v15 clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_792;
    block[3] = &unk_265376E98;
    void block[4] = v15;
    id v23 = v13;
    int v20 = v13;
    dispatch_async(v19, block);

    goto LABEL_9;
  }
  [WeakRetained _notifyDelegateOfPairingProgress:32 error:v9];
  if (v11)
  {
    int v20 = [v11 clientQueue];
    v24[0] = MEMORY[0x263EF8330];
    v24[1] = 3221225472;
    v24[2] = __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_2_791;
    v24[3] = &unk_265378638;
    void v24[4] = v11;
    dispatch_async(v20, v24);
LABEL_9:
  }
  [*(id *)(a1 + 32) invalidate];
}

void __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_2_791(uint64_t a1)
{
  [*(id *)(a1 + 32) setDefaultThreadOperationalDataset:0];
  [*(id *)(a1 + 32) setDefaultThreadOperationalDatasetRetrieved:1];
  id v2 = [*(id *)(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];

  if (v2)
  {
    id v4 = [*(id *)(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];
    [*(id *)(a1 + 32) setDefaultThreadOperationalDatasetReceiveBlock:0];
    int8x16_t v3 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:30 userInfo:0];
    v4[2](v4, 0, v3);
  }
}

void __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_792(uint64_t a1)
{
  [*(id *)(a1 + 32) _notifyDelegateOfPairingProgress:31];
  [*(id *)(a1 + 32) setDefaultThreadOperationalDataset:*(void *)(a1 + 40)];
  [*(id *)(a1 + 32) setDefaultThreadOperationalDatasetRetrieved:1];
  id v2 = [*(id *)(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];

  if (v2)
  {
    id v3 = [*(id *)(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];
    [*(id *)(a1 + 32) setDefaultThreadOperationalDatasetReceiveBlock:0];
    (*((void (**)(id, void, void))v3 + 2))(v3, *(void *)(a1 + 40), 0);
  }
}

void __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_2(uint64_t a1)
{
  [*(id *)(a1 + 32) setDefaultThreadOperationalDataset:0];
  [*(id *)(a1 + 32) setDefaultThreadOperationalDatasetRetrieved:1];
  id v2 = [*(id *)(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];

  if (v2)
  {
    id v4 = [*(id *)(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];
    [*(id *)(a1 + 32) setDefaultThreadOperationalDatasetReceiveBlock:0];
    id v3 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:30 userInfo:0];
    v4[2](v4, 0, v3);
  }
}

uint64_t __49__HMMTRAccessoryServer__prepareThreadCredentials__block_invoke_787(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  [*(id *)(a1 + 32) _notifyDelegateOfPairingProgress:31];
  [*(id *)(a1 + 32) setDefaultThreadOperationalDataset:*(void *)(a1 + 40)];
  [*(id *)(a1 + 32) setDefaultThreadOperationalDatasetRetrieved:1];
  id v2 = [*(id *)(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];

  if (v2)
  {
    id v3 = [*(id *)(a1 + 32) defaultThreadOperationalDatasetReceiveBlock];
    [*(id *)(a1 + 32) setDefaultThreadOperationalDatasetReceiveBlock:0];
    v3[2](v3, *(void *)(a1 + 40), 0);
  }
  uint64_t result = isFeatureMatteriPhoneOnlyPairingControlEnabled();
  if (result)
  {
    uint64_t result = [*(id *)(a1 + 32) deferStartThreadForPairing];
    if (result)
    {
      id v5 = (void *)MEMORY[0x2533B64D0]();
      id v6 = *(id *)(a1 + 32);
      id v7 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        id v8 = HMFGetLogIdentifier();
        int v12 = 138543362;
        uint64_t v13 = v8;
        _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Proceed to inform browser to start thread if needed since operational dataset is now available", (uint8_t *)&v12, 0xCu);
      }
      id v9 = [*(id *)(a1 + 32) browser];
      uint64_t v10 = [*(id *)(a1 + 32) fabricID];
      id v11 = [*(id *)(a1 + 32) nodeID];
      [v9 handlePairingForThreadAccessoryWithFabricID:v10 nodeID:v11];

      return [*(id *)(a1 + 32) setDeferStartThreadForPairing:0];
    }
  }
  return result;
}

- (id)_endCurrentMetricTimeWithName:(id)a3
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  id v6 = [(HMMTRAccessoryServer *)self pairingDurationDictionary];
  id v7 = [v6 objectForKey:v4];

  if (v7)
  {
    id v8 = [(HMMTRAccessoryServer *)self pairingDurationDictionary];
    [v8 removeObjectForKey:v4];

    id v9 = NSNumber;
    uint64_t v10 = [MEMORY[0x263EFF910] date];
    [v7 durationWithDate:v10];
    id v11 = objc_msgSend(v9, "numberWithDouble:");

    [v11 doubleValue];
    double v13 = v12;
    uint64_t v14 = [(HMMTRAccessoryServer *)self maxMetricDuration];
    id v15 = [v14 duration];
    [v15 doubleValue];
    double v17 = v16;

    if (v13 > v17)
    {
      id v18 = [HMMTRDuration alloc];
      id v19 = [v7 name];
      int v20 = [(HMMTRDuration *)v18 initWithName:v19 duration:v11];
      [(HMMTRAccessoryServer *)self setMaxMetricDuration:v20];

      id v21 = [(HMMTRAccessoryServer *)self maxMetricDuration];
      id v22 = [v21 name];
      [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventMaxDurationName" value:v22];

      id v23 = [(HMMTRAccessoryServer *)self maxMetricDuration];
      __int16 v24 = [v23 duration];
      [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventMaxDurationTimeInSeconds" value:v24];
    }
    os_unfair_lock_unlock(v5);
  }
  else
  {
    id v25 = (void *)MEMORY[0x2533B64D0]();
    __int16 v26 = self;
    HMFGetOSLogHandle();
    __int16 v27 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = HMFGetLogIdentifier();
      int v30 = 138543618;
      unint64_t v31 = v28;
      __int16 v32 = 2112;
      id v33 = v4;
      _os_log_impl(&dword_252495000, v27, OS_LOG_TYPE_ERROR, "%{public}@failed to find metric %@ to complete", (uint8_t *)&v30, 0x16u);
    }
    os_unfair_lock_unlock(v5);
    id v11 = 0;
  }

  return v11;
}

- (void)_startCurrentMetricTimeWithName:(id)a3
{
  id v9 = a3;
  id v4 = [HMMTRMetricBundle alloc];
  id v5 = [MEMORY[0x263EFF910] date];
  id v6 = [(HMMTRMetricBundle *)v4 initWithTime:v5 name:v9];

  id v7 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  id v8 = [(HMMTRAccessoryServer *)self pairingDurationDictionary];
  [v8 setObject:v6 forKeyedSubscript:v9];

  os_unfair_lock_unlock(v7);
}

- (void)_populateWifiCredentials:(id)a3 scanResults:(id)a4 completion:(id)a5
{
  uint64_t v119 = *MEMORY[0x263EF8340];
  id v8 = a3;
  id v9 = a4;
  id v90 = a5;
  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:5];
  id v91 = [(HMMTRAccessoryServer *)self currentWiFiNetworkInfo];
  uint64_t v10 = (void *)MEMORY[0x2533B64D0]();
  id v11 = self;
  double v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    double v13 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    v113 = v13;
    _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_INFO, "%{public}@Collecting WiFi credentials for the accessory", buf, 0xCu);
  }
  [(HMMTRAccessoryServer *)v11 _notifyDelegateOfPairingProgress:14];
  uint64_t v14 = [v91 objectForKey:@"ssid"];

  if (v14)
  {
    id v87 = v8;
    id v15 = (void *)MEMORY[0x263EFF980];
    double v16 = [v9 wiFiScanResults];
    double v17 = objc_msgSend(v15, "arrayWithCapacity:", objc_msgSend(v16, "count"));

    long long v108 = 0u;
    long long v109 = 0u;
    long long v106 = 0u;
    long long v107 = 0u;
    id v88 = v9;
    id obj = [v9 wiFiScanResults];
    uint64_t v18 = [obj countByEnumeratingWithState:&v106 objects:v118 count:16];
    id v93 = v17;
    if (v18)
    {
      uint64_t v19 = v18;
      uint64_t v20 = *(void *)v107;
      unint64_t v21 = 0x263F08000uLL;
      do
      {
        uint64_t v22 = 0;
        id v94 = (id)v19;
        do
        {
          if (*(void *)v107 != v20) {
            objc_enumerationMutation(obj);
          }
          id v23 = *(void **)(*((void *)&v106 + 1) + 8 * v22);
          id v24 = objc_alloc(*(Class *)(v21 + 2880));
          id v25 = [v23 ssid];
          __int16 v26 = (void *)[v24 initWithData:v25 encoding:4];

          if (v26)
          {
            [v17 addObject:v26];
          }
          else
          {
            unint64_t v27 = v21;
            uint64_t v28 = (void *)MEMORY[0x2533B64D0]();
            uint64_t v29 = v11;
            int v30 = v11;
            unint64_t v31 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              __int16 v32 = HMFGetLogIdentifier();
              id v33 = [v23 ssid];
              *(_DWORD *)buf = 138543618;
              v113 = v32;
              __int16 v114 = 2112;
              v115 = v33;
              _os_log_impl(&dword_252495000, v31, OS_LOG_TYPE_ERROR, "%{public}@Unexpected non-UTF8 SSID was skipped: %@", buf, 0x16u);

              double v17 = v93;
            }

            id v11 = v29;
            unint64_t v21 = v27;
            uint64_t v19 = (uint64_t)v94;
          }

          ++v22;
        }
        while (v19 != v22);
        uint64_t v19 = [obj countByEnumeratingWithState:&v106 objects:v118 count:16];
      }
      while (v19);
    }

    uint64_t v34 = [v91 objectForKeyedSubscript:@"ssid"];
    __int16 v35 = (void *)MEMORY[0x2533B64D0]();
    id v36 = v11;
    id v37 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
    {
      __int16 v38 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543874;
      v113 = v38;
      __int16 v114 = 2112;
      v115 = v34;
      __int16 v116 = 2112;
      v117 = v17;
      _os_log_impl(&dword_252495000, v37, OS_LOG_TYPE_INFO, "%{public}@Current network: %@, scanned networks: %@", buf, 0x20u);
    }
    id v89 = v36;

    if (([v17 containsObject:v34] & 1) != 0 || !objc_msgSend(v17, "count"))
    {
      id v53 = v91;
      id v8 = v87;
    }
    else
    {
      __int16 v39 = objc_msgSend(MEMORY[0x263EFF980], "arrayWithCapacity:", objc_msgSend(v17, "count"));
      long long v102 = 0u;
      long long v103 = 0u;
      long long v104 = 0u;
      long long v105 = 0u;
      id v40 = v17;
      uint64_t v41 = [v40 countByEnumeratingWithState:&v102 objects:v111 count:16];
      if (v41)
      {
        uint64_t v42 = v41;
        uint64_t v43 = *(void *)v103;
        do
        {
          for (uint64_t i = 0; i != v42; ++i)
          {
            if (*(void *)v103 != v43) {
              objc_enumerationMutation(v40);
            }
            uint64_t v45 = *(void *)(*((void *)&v102 + 1) + 8 * i);
            uint64_t v46 = [v34 commonPrefixWithString:v45 options:10];
            if ([v46 length]) {
              [v39 addObject:v45];
            }
          }
          uint64_t v42 = [v40 countByEnumeratingWithState:&v102 objects:v111 count:16];
        }
        while (v42);
      }

      id v47 = (void *)MEMORY[0x2533B64D0]();
      id v48 = v89;
      id v49 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
      {
        uint64_t v50 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        v113 = v50;
        __int16 v114 = 2112;
        v115 = v39;
        _os_log_impl(&dword_252495000, v49, OS_LOG_TYPE_INFO, "%{public}@Possible compatible results: %@", buf, 0x16u);
      }
      long long v100 = 0u;
      long long v101 = 0u;
      long long v98 = 0u;
      long long v99 = 0u;
      id v95 = v39;
      uint64_t v51 = [v95 countByEnumeratingWithState:&v98 objects:v110 count:16];
      if (v51)
      {
        uint64_t v52 = v51;
        id v53 = 0;
        uint64_t v54 = *(void *)v99;
        while (2)
        {
          uint64_t v55 = 0;
          uint64_t v92 = v52;
          do
          {
            if (*(void *)v99 != v54) {
              objc_enumerationMutation(v95);
            }
            __int16 v56 = [(HMMTRAccessoryServer *)v48 wifiNetworkInfoForSSID:*(void *)(*((void *)&v98 + 1) + 8 * v55)];
            if (v56)
            {
              __int16 v57 = (void *)MEMORY[0x2533B64D0]();
              id v58 = v48;
              __int16 v59 = HMFGetOSLogHandle();
              if (os_log_type_enabled(v59, OS_LOG_TYPE_INFO))
              {
                HMFGetLogIdentifier();
                char v60 = obja = v57;
                [v56 objectForKeyedSubscript:@"ssid"];
                uint64_t v61 = v54;
                id v62 = v48;
                v64 = id v63 = v53;
                *(_DWORD *)buf = 138543618;
                v113 = v60;
                __int16 v114 = 2112;
                v115 = v64;
                _os_log_impl(&dword_252495000, v59, OS_LOG_TYPE_INFO, "%{public}@Matched : %@", buf, 0x16u);

                id v53 = v63;
                id v48 = v62;
                uint64_t v54 = v61;
                uint64_t v52 = v92;

                __int16 v57 = obja;
              }

              if (v53)
              {

                goto LABEL_49;
              }
              id v53 = v56;
            }

            ++v55;
          }
          while (v52 != v55);
          uint64_t v52 = [v95 countByEnumeratingWithState:&v98 objects:v110 count:16];
          if (v52) {
            continue;
          }
          break;
        }
      }
      else
      {
LABEL_49:
        id v53 = 0;
      }

      id v8 = v87;
      double v17 = v93;
    }
    id v9 = v88;
    if (v53) {
      goto LABEL_55;
    }
    id v70 = (void *)MEMORY[0x2533B64D0]();
    id v71 = v89;
    id v72 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v72, OS_LOG_TYPE_INFO))
    {
      id v73 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      v113 = v73;
      _os_log_impl(&dword_252495000, v72, OS_LOG_TYPE_INFO, "%{public}@No matching SSID among scan results", buf, 0xCu);
    }
    id v53 = v91;
    uint64_t v74 = *MEMORY[0x263F355F0];
    id v75 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:20 userInfo:0];
    [(HMMTRAccessoryServer *)v71 setCommissioningFailureOverridingError:v75];

    if (v53)
    {
LABEL_55:
      __int16 v76 = (void *)MEMORY[0x2533B64D0]();
      id v77 = v89;
      uint64_t v78 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v78, OS_LOG_TYPE_INFO))
      {
        uint64_t v79 = HMFGetLogIdentifier();
        id v80 = [v53 objectForKeyedSubscript:@"ssid"];
        *(_DWORD *)buf = 138543618;
        v113 = v79;
        __int16 v114 = 2112;
        v115 = v80;
        _os_log_impl(&dword_252495000, v78, OS_LOG_TYPE_INFO, "%{public}@Configuring with wifi ssid %@", buf, 0x16u);

        id v9 = v88;
      }

      uint64_t v81 = [v53 objectForKeyedSubscript:@"ssid"];
      id v82 = [v81 dataUsingEncoding:4];
      [v8 setWifiSSID:v82];

      v83 = [v53 objectForKeyedSubscript:@"password"];
      id v84 = [v83 dataUsingEncoding:4];
      [v8 setWifiCredentials:v84];

      [(HMMTRAccessoryServer *)v77 _notifyDelegateOfPairingProgress:15];
      uint64_t v69 = v90;
      (*((void (**)(id, id, void, void))v90 + 2))(v90, v8, 0, 0);
    }
    else
    {
      id v85 = [MEMORY[0x263F087E8] errorWithDomain:v74 code:20 userInfo:0];
      [(HMMTRAccessoryServer *)v71 _notifyDelegateOfPairingProgress:16 error:v85];
      id v86 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:5 error:v85];
      uint64_t v69 = v90;
      (*((void (**)(id, void, void *, void *))v90 + 2))(v90, 0, v85, v86);
    }
  }
  else
  {
    id v65 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v66 = v11;
    __int16 v67 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      long long v68 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      v113 = v68;
      _os_log_impl(&dword_252495000, v67, OS_LOG_TYPE_ERROR, "%{public}@Unable to send WiFi Credentials. No SSID available. Is WiFi connected?", buf, 0xCu);
    }
    double v17 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:21 userInfo:0];
    [(HMMTRAccessoryServer *)v66 _notifyDelegateOfPairingProgress:16 error:v17];
    uint64_t v34 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:5 error:v17];
    uint64_t v69 = v90;
    (*((void (**)(id, void, void *, void *))v90 + 2))(v90, 0, v17, v34);
    id v53 = 0;
  }
}

- (id)wifiNetworkInfoForSSID:(id)a3
{
  v8[1] = *MEMORY[0x263EF8340];
  id v7 = @"ssid";
  v8[0] = a3;
  id v3 = NSDictionary;
  id v4 = a3;
  [v3 dictionaryWithObjects:v8 forKeys:&v7 count:1];

  id v5 = (void *)WiFiCopyNetworkInfo();
  return v5;
}

- (id)currentWiFiNetworkInfo
{
  id v2 = (void *)WiFiCopyCurrentNetworkInfoEx();
  return v2;
}

- (BOOL)_controllerIsOnWiFiNetworkWhichSupportsBothBands
{
  id v24 = self;
  uint64_t v40 = *MEMORY[0x263EF8340];
  int v30 = 0;
  id v2 = (void *)WiFiCopyCurrentNetworkInfoEx();
  id v25 = [v2 objectForKeyedSubscript:@"ssid"];
  id v3 = [v2 objectForKeyedSubscript:@"rawRecord"];
  id v4 = [v3 objectForKeyedSubscript:@"networkKnownBSSListKey"];

  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  id v5 = v4;
  uint64_t v6 = [v5 countByEnumeratingWithState:&v26 objects:v39 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    int v8 = 0;
    int v9 = 0;
    uint64_t v10 = *(void *)v27;
    while (2)
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v27 != v10) {
          objc_enumerationMutation(v5);
        }
        double v12 = objc_msgSend(*(id *)(*((void *)&v26 + 1) + 8 * i), "objectForKeyedSubscript:", @"CHANNEL_FLAGS", v24);
        unint64_t v13 = [v12 unsignedIntegerValue];

        v9 |= (v13 >> 3) & 1;
        v8 |= (v13 >> 4) & 1;
        if (v9 & 1) != 0 && (v8)
        {
          LOBYTE(v8) = 1;
          LOBYTE(v9) = 1;
          goto LABEL_13;
        }
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v26 objects:v39 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }
  else
  {
    LOBYTE(v8) = 0;
    LOBYTE(v9) = 0;
  }
LABEL_13:

  uint64_t v14 = (void *)MEMORY[0x2533B64D0]();
  id v15 = v24;
  double v16 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    uint64_t v17 = HMFGetLogIdentifier();
    uint64_t v18 = (void *)v17;
    uint64_t v19 = &stru_2702A0B38;
    uint64_t v20 = @" 2.4GHz";
    if ((v9 & 1) == 0) {
      uint64_t v20 = &stru_2702A0B38;
    }
    *(_DWORD *)buf = 138544130;
    uint64_t v32 = v17;
    if (v8) {
      uint64_t v19 = @" 5GHz";
    }
    __int16 v33 = 2112;
    uint64_t v34 = v25;
    __int16 v35 = 2112;
    id v36 = v20;
    __int16 v37 = 2112;
    __int16 v38 = v19;
    _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@Current WiFi network(%@) bands%@%@", buf, 0x2Au);
  }
  if (v30) {
    BOOL v21 = 1;
  }
  else {
    BOOL v21 = v25 == 0;
  }
  char v22 = v21;

  return (v22 | v9 & v8) & 1;
}

- (id)removeNode:(id)a3 withPrivilge:(unsigned __int8)a4 fromExistingAclEntries:(id)a5
{
  int v6 = a4;
  uint64_t v41 = *MEMORY[0x263EF8340];
  id v8 = a3;
  id v9 = a5;
  if (!v8 || [v8 isEqualToNumber:&unk_2702B5988]) {
    goto LABEL_11;
  }
  if (v6 != 5)
  {
    uint64_t v10 = (void *)MEMORY[0x2533B64D0]();
    id v11 = self;
    double v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      unint64_t v13 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v40 = v13;
      uint64_t v14 = "%{public}@Current implementation is restricted to removal of admin nodes only";
      goto LABEL_9;
    }
LABEL_10:

LABEL_11:
    id v15 = v9;
    goto LABEL_12;
  }
  if (+[HMMTRUtilities isValidCATSubject:v8])
  {
    uint64_t v10 = (void *)MEMORY[0x2533B64D0]();
    id v11 = self;
    double v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      unint64_t v13 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v40 = v13;
      uint64_t v14 = "%{public}@Current implementation doesn't support removal of CAT IDs";
LABEL_9:
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_INFO, v14, buf, 0xCu);

      goto LABEL_10;
    }
    goto LABEL_10;
  }
  id v33 = v8;
  uint64_t v17 = [MEMORY[0x263EFF980] array];
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  id v32 = v9;
  id v18 = v9;
  uint64_t v19 = [v18 countByEnumeratingWithState:&v34 objects:v38 count:16];
  if (v19)
  {
    uint64_t v20 = v19;
    uint64_t v21 = *(void *)v35;
    do
    {
      for (uint64_t i = 0; i != v20; ++i)
      {
        if (*(void *)v35 != v21) {
          objc_enumerationMutation(v18);
        }
        id v23 = *(void **)(*((void *)&v34 + 1) + 8 * i);
        id v24 = (void *)MEMORY[0x263EFF9C0];
        id v25 = objc_msgSend(v23, "subjects", v32);
        long long v26 = [v24 setWithArray:v25];

        long long v27 = [v23 privilege];
        uint64_t v28 = [v27 integerValue];

        if (v28 == 5) {
          [v26 removeObject:v33];
        }
        long long v29 = [v26 allObjects];
        [v23 setSubjects:v29];

        int v30 = [v23 subjects];
        uint64_t v31 = [v30 count];

        if (v31) {
          [v17 addObject:v23];
        }
      }
      uint64_t v20 = [v18 countByEnumeratingWithState:&v34 objects:v38 count:16];
    }
    while (v20);
  }

  id v15 = (id)[v17 copy];
  id v9 = v32;
  id v8 = v33;
LABEL_12:

  return v15;
}

- (id)mergeExistingAclEntries:(id)a3 withNewNodes:(id)a4 withPrivilege:(unsigned __int8)a5
{
  unsigned int v44 = a5;
  uint64_t v76 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  if ([v7 count])
  {
    id v8 = [MEMORY[0x263EFF980] array];
    long long v68 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    id obj = v7;
    uint64_t v49 = [obj countByEnumeratingWithState:&v68 objects:v75 count:16];
    if (!v49) {
      goto LABEL_47;
    }
    id v47 = v7;
    uint64_t v48 = *(void *)v69;
    uint64_t v9 = v44;
    uint64_t v46 = v8;
    while (1)
    {
      for (uint64_t i = 0; i != v49; ++i)
      {
        if (*(void *)v69 != v48) {
          objc_enumerationMutation(obj);
        }
        uint64_t v11 = *(void *)(*((void *)&v68 + 1) + 8 * i);
        BOOL v12 = +[HMMTRUtilities isValidCATSubject:v11];
        long long v64 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        id v13 = v6;
        uint64_t v57 = [v13 countByEnumeratingWithState:&v64 objects:v74 count:16];
        if (!v57)
        {

          [v8 addObjectsFromArray:v13];
LABEL_38:
          id v33 = objc_alloc_init(MEMORY[0x263F10C38]);
          long long v34 = [NSNumber numberWithUnsignedChar:v44];
          [v33 setPrivilege:v34];

          [v33 setAuthMode:&unk_2702B5BB0];
          uint64_t v72 = v11;
          long long v35 = [MEMORY[0x263EFF8C0] arrayWithObjects:&v72 count:1];
          [v33 setSubjects:v35];

          [v8 addObject:v33];
          goto LABEL_45;
        }
        uint64_t v53 = i;
        char v54 = 0;
        uint64_t v50 = 0;
        uint64_t v14 = 0;
        uint64_t v15 = *(void *)v65;
        __int16 v56 = v13;
        do
        {
          uint64_t v16 = 0;
          uint64_t v52 = v14 + v57;
          do
          {
            if (*(void *)v65 != v15) {
              objc_enumerationMutation(v13);
            }
            uint64_t v17 = *(void **)(*((void *)&v64 + 1) + 8 * v16);
            id v18 = [v17 privilege];
            if ([v18 integerValue] != v9) {
              goto LABEL_15;
            }
            uint64_t v19 = [v17 targets];
            if ([v19 count])
            {

LABEL_15:
              goto LABEL_16;
            }
            uint64_t v20 = [v17 authMode];
            uint64_t v21 = [v20 integerValue];

            id v13 = v56;
            BOOL v22 = v21 == 2;
            uint64_t v9 = v44;
            if (v22)
            {
              long long v62 = 0u;
              long long v63 = 0u;
              long long v60 = 0u;
              long long v61 = 0u;
              id v18 = [v17 subjects];
              uint64_t v23 = [v18 countByEnumeratingWithState:&v60 objects:v73 count:16];
              if (v23)
              {
                uint64_t v24 = v23;
                uint64_t v25 = 0;
                uint64_t v26 = *(void *)v61;
                while (2)
                {
                  uint64_t v27 = 0;
                  uint64_t v51 = v25;
                  uint64_t v55 = v25 + v24;
                  do
                  {
                    if (*(void *)v61 != v26) {
                      objc_enumerationMutation(v18);
                    }
                    uint64_t v28 = *(void **)(*((void *)&v60 + 1) + 8 * v27);
                    if ([v28 isEqualToNumber:v11])
                    {

                      id v13 = v56;
                      id v8 = v46;
                      [v46 addObjectsFromArray:v56];
                      id v7 = v47;
                      uint64_t v9 = v44;
                      goto LABEL_44;
                    }
                    if (v12)
                    {
                      if (+[HMMTRUtilities isValidCATSubject:v28])
                      {
                        int v59 = 0;
                        +[HMMTRUtilities parseCaseAuthenticatedTag:v11 identifier:(char *)&v59 + 2 version:&v59];
                        int v58 = 0;
                        +[HMMTRUtilities parseCaseAuthenticatedTag:v28 identifier:(char *)&v58 + 2 version:&v58];
                        if (HIWORD(v59) == HIWORD(v58))
                        {
                          uint64_t v30 = v51 + v27;

                          uint64_t v31 = v56;
                          id v8 = v46;
                          [v46 addObjectsFromArray:v56];
                          int v32 = 1;
                          id v7 = v47;
                          goto LABEL_40;
                        }
                      }
                    }
                    ++v27;
                  }
                  while (v24 != v27);
                  uint64_t v24 = [v18 countByEnumeratingWithState:&v60 objects:v73 count:16];
                  uint64_t v25 = v55;
                  if (v24) {
                    continue;
                  }
                  break;
                }
                char v54 = 1;
                uint64_t v50 = v14;
                uint64_t v9 = v44;
                id v13 = v56;
              }
              else
              {
                char v54 = 1;
                uint64_t v50 = v14;
              }
              goto LABEL_15;
            }
LABEL_16:
            ++v14;
            ++v16;
          }
          while (v16 != v57);
          uint64_t v29 = [v13 countByEnumeratingWithState:&v64 objects:v74 count:16];
          uint64_t v14 = v52;
          uint64_t v57 = v29;
        }
        while (v29);

        id v8 = v46;
        [v46 addObjectsFromArray:v13];
        id v7 = v47;
        uint64_t i = v53;
        if ((v54 & 1) == 0) {
          goto LABEL_38;
        }
        uint64_t v30 = 0;
        uint64_t v31 = v13;
        int v32 = 0;
        uint64_t v14 = v50;
LABEL_40:
        long long v36 = (void *)MEMORY[0x263EFF980];
        long long v37 = [v31 objectAtIndexedSubscript:v14];
        __int16 v38 = [v37 subjects];
        __int16 v39 = [v36 arrayWithArray:v38];

        if ((v12 & v32) == 1) {
          [v39 setObject:v11 atIndexedSubscript:v30];
        }
        else {
          [v39 addObject:v11];
        }
        uint64_t v40 = (void *)[v39 copy];
        uint64_t v41 = [v8 objectAtIndexedSubscript:v14];
        [v41 setSubjects:v40];

        uint64_t v9 = v44;
        id v13 = v56;
LABEL_44:
        uint64_t i = v53;
LABEL_45:
        id v6 = (id)[v8 copy];

        [v8 removeAllObjects];
      }
      uint64_t v49 = [obj countByEnumeratingWithState:&v68 objects:v75 count:16];
      if (!v49)
      {
LABEL_47:

        uint64_t v42 = (void *)[v6 copy];
        goto LABEL_49;
      }
    }
  }
  id v6 = v6;
  uint64_t v42 = v6;
LABEL_49:

  return v42;
}

- (id)mergeExistingAclEntries:(id)a3 withAdminNodes:(id)a4 regularUserNodes:(id)a5
{
  id v8 = a5;
  uint64_t v9 = [(HMMTRAccessoryServer *)self mergeExistingAclEntries:a3 withNewNodes:a4 withPrivilege:5];
  uint64_t v10 = [(HMMTRAccessoryServer *)self mergeExistingAclEntries:v9 withNewNodes:v8 withPrivilege:3];

  return v10;
}

- (void)_removeSharedAdminControllerNodeIDFromACLWithCompletion:(id)a3
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [(HMMTRAccessoryServer *)self storage];
  char v6 = [v5 isSharedAdmin];

  if (v6)
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = self;
    uint64_t v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v16 = v10;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_INFO, "%{public}@Removing shared admin controller device's node ID from ACL", buf, 0xCu);
    }
    uint64_t v11 = [(HMMTRAccessoryServer *)v8 deviceController];
    BOOL v12 = [v11 controllerNodeID];
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 3221225472;
    v13[2] = __80__HMMTRAccessoryServer__removeSharedAdminControllerNodeIDFromACLWithCompletion___block_invoke;
    v13[3] = &unk_2653787C8;
    id v14 = v4;
    [(HMMTRAccessoryServer *)v8 updateAccessoryControlToRemoveAdministratorNode:v12 completion:v13];
  }
  else
  {
    (*((void (**)(id, void))v4 + 2))(v4, 0);
  }
}

uint64_t __80__HMMTRAccessoryServer__removeSharedAdminControllerNodeIDFromACLWithCompletion___block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

- (void)updateAccessoryControlToRemoveAdministratorNode:(id)a3 completion:(id)a4
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  id v8 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v9 = self;
  uint64_t v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    uint64_t v11 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    int v32 = v11;
    __int16 v33 = 2112;
    id v34 = v6;
    _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Updating accessory ACL to remove administrative access to %@", buf, 0x16u);
  }
  BOOL v12 = [(HMMTRAccessoryServer *)v9 storage];
  char v13 = [v12 isSharedAdmin];

  if (v13)
  {
    id v14 = (void *)MEMORY[0x263F10CA8];
    uint64_t v15 = [(HMMTRAccessoryServer *)v9 nodeID];
    uint64_t v16 = [(HMMTRAccessoryServer *)v9 deviceController];
    uint64_t v17 = [v14 deviceWithNodeID:v15 controller:v16];

    if (v17)
    {
      id v18 = objc_alloc(MEMORY[0x263F10C68]);
      uint64_t v19 = [(HAPAccessoryServer *)v9 clientQueue];
      uint64_t v20 = (void *)[v18 initWithDevice:v17 endpointID:&unk_2702B5988 queue:v19];

      id v21 = objc_alloc_init(MEMORY[0x263F10FA0]);
      v27[0] = MEMORY[0x263EF8330];
      v27[1] = 3221225472;
      v27[2] = __83__HMMTRAccessoryServer_updateAccessoryControlToRemoveAdministratorNode_completion___block_invoke;
      v27[3] = &unk_265377B40;
      v27[4] = v9;
      id v30 = v7;
      id v28 = v6;
      id v29 = v20;
      id v22 = v20;
      [v22 readAttributeACLWithParams:v21 completion:v27];
    }
    else
    {
      uint64_t v23 = (void *)MEMORY[0x2533B64D0]();
      uint64_t v24 = v9;
      uint64_t v25 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        uint64_t v26 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        int v32 = v26;
        _os_log_impl(&dword_252495000, v25, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. No device found", buf, 0xCu);
      }
      id v21 = [MEMORY[0x263F087E8] hmfErrorWithCode:2];
      (*((void (**)(id, id))v7 + 2))(v7, v21);
    }
  }
  else
  {
    (*((void (**)(id, void))v7 + 2))(v7, 0);
  }
}

void __83__HMMTRAccessoryServer_updateAccessoryControlToRemoveAdministratorNode_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id v7 = (void *)MEMORY[0x2533B64D0]();
  id v8 = *(id *)(a1 + 32);
  uint64_t v9 = HMFGetOSLogHandle();
  uint64_t v10 = v9;
  if (v6)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v29 = v11;
      __int16 v30 = 2112;
      id v31 = v6;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. Error: %@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      BOOL v12 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v29 = v12;
      __int16 v30 = 2112;
      id v31 = v5;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Successfully read ACL as %@", buf, 0x16u);
    }
    +[HMMTRUtilities printAccessControlList:v5];
    id v13 = v5;
    id v14 = [*(id *)(a1 + 32) removeNode:*(void *)(a1 + 40) withPrivilge:5 fromExistingAclEntries:v13];
    uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = *(id *)(a1 + 32);
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      id v18 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v29 = v18;
      __int16 v30 = 2112;
      id v31 = v14;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_INFO, "%{public}@New ACL entries %@", buf, 0x16u);
    }
    if (![v14 count])
    {
      uint64_t v19 = (void *)MEMORY[0x2533B64D0]();
      id v20 = *(id *)(a1 + 32);
      id v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        id v22 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v29 = v22;
        _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_INFO, "%{public}@Unexpected ACL remove operation", buf, 0xCu);
      }
      (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    }
    v25[0] = MEMORY[0x263EF8330];
    v25[1] = 3221225472;
    v25[2] = __83__HMMTRAccessoryServer_updateAccessoryControlToRemoveAdministratorNode_completion___block_invoke_764;
    v25[3] = &unk_265377368;
    v25[4] = *(void *)(a1 + 32);
    id v26 = v14;
    uint64_t v23 = *(void **)(a1 + 48);
    id v27 = *(id *)(a1 + 56);
    id v24 = v14;
    [v23 writeAttributeACLWithValue:v24 completion:v25];
  }
}

void __83__HMMTRAccessoryServer_updateAccessoryControlToRemoveAdministratorNode_completion___block_invoke_764(uint64_t a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  id v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v8 = HMFGetLogIdentifier();
      int v10 = 138543618;
      uint64_t v11 = v8;
      __int16 v12 = 2112;
      id v13 = v3;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to update ACL. Error: %@", (uint8_t *)&v10, 0x16u);
    }
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = HMFGetLogIdentifier();
      int v10 = 138543362;
      uint64_t v11 = v9;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Successfully updated ACL to", (uint8_t *)&v10, 0xCu);
    }
    +[HMMTRUtilities printAccessControlList:*(void *)(a1 + 40)];
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

- (void)updateAccessoryControlToIncludeAdministratorNodes:(id)a3 sharedUserNodes:(id)a4 completion:(id)a5
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  id v8 = a3;
  id v9 = a4;
  int v10 = (void (**)(id, void))a5;
  BOOL v11 = [(HMMTRAccessoryServer *)self isKnownToSystemCommissioner];
  __int16 v12 = (void *)MEMORY[0x2533B64D0]();
  id v13 = self;
  uint64_t v14 = HMFGetOSLogHandle();
  uint64_t v15 = v14;
  if (v11)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      id v16 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v45 = v16;
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_DEBUG, "%{public}@Skipping ACL update for System Commissioner pairing", buf, 0xCu);
    }
    goto LABEL_5;
  }
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    uint64_t v17 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543874;
    uint64_t v45 = v17;
    __int16 v46 = 2112;
    id v47 = v8;
    __int16 v48 = 2112;
    id v49 = v9;
    _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_INFO, "%{public}@Updating accessory ACL to include administrative access to %@ and view access to %@", buf, 0x20u);
  }
  id v18 = [(HMMTRAccessoryServer *)v13 storage];
  if ([v18 isSharedAdmin])
  {
  }
  else
  {
    uint64_t v19 = [(HMMTRAccessoryServer *)v13 browser];
    char v20 = [v19 isCurrentDevicePrimaryResident];

    if ((v20 & 1) == 0 && (isFeatureMatteriPhoneOnlyPairingControlEnabled() & 1) == 0)
    {
LABEL_5:
      v10[2](v10, 0);
      goto LABEL_20;
    }
  }
  if ([v8 count] || objc_msgSend(v9, "count"))
  {
    id v21 = (void *)MEMORY[0x263F10CA8];
    id v22 = [(HMMTRAccessoryServer *)v13 nodeID];
    uint64_t v23 = [(HMMTRAccessoryServer *)v13 deviceController];
    id v24 = [v21 deviceWithNodeID:v22 controller:v23];

    if (v24)
    {
      id v25 = objc_alloc(MEMORY[0x263F10C68]);
      id v26 = [(HAPAccessoryServer *)v13 clientQueue];
      id v27 = (void *)[v25 initWithDevice:v24 endpointID:&unk_2702B5988 queue:v26];

      id v28 = objc_alloc_init(MEMORY[0x263F10FA0]);
      v39[0] = MEMORY[0x263EF8330];
      v39[1] = 3221225472;
      v39[2] = __101__HMMTRAccessoryServer_updateAccessoryControlToIncludeAdministratorNodes_sharedUserNodes_completion___block_invoke;
      v39[3] = &unk_265378928;
      v39[4] = v13;
      uint64_t v43 = v10;
      id v40 = v8;
      id v41 = v9;
      id v42 = v27;
      id v29 = v27;
      [v29 readAttributeACLWithParams:v28 completion:v39];
    }
    else
    {
      __int16 v30 = (void *)MEMORY[0x2533B64D0]();
      id v31 = v13;
      uint64_t v32 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        __int16 v33 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v45 = v33;
        _os_log_impl(&dword_252495000, v32, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. No device found", buf, 0xCu);
      }
      id v28 = [MEMORY[0x263F087E8] hmfErrorWithCode:2];
      ((void (**)(id, id))v10)[2](v10, v28);
    }
  }
  else
  {
    id v34 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v35 = v13;
    long long v36 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      long long v37 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v45 = v37;
      _os_log_impl(&dword_252495000, v36, OS_LOG_TYPE_ERROR, "%{public}@Invalid list of allowed nodes", buf, 0xCu);
    }
    __int16 v38 = [MEMORY[0x263F087E8] hmfErrorWithCode:3];
    ((void (**)(id, void *))v10)[2](v10, v38);
  }
LABEL_20:
}

void __101__HMMTRAccessoryServer_updateAccessoryControlToIncludeAdministratorNodes_sharedUserNodes_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id v7 = (void *)MEMORY[0x2533B64D0]();
  id v8 = *(id *)(a1 + 32);
  id v9 = HMFGetOSLogHandle();
  int v10 = v9;
  if (v6)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      BOOL v11 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v25 = v11;
      __int16 v26 = 2112;
      id v27 = v6;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. Error: %@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      __int16 v12 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v25 = v12;
      __int16 v26 = 2112;
      id v27 = v5;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Successfully read ACL as %@", buf, 0x16u);
    }
    +[HMMTRUtilities printAccessControlList:v5];
    id v13 = v5;
    uint64_t v14 = [*(id *)(a1 + 32) mergeExistingAclEntries:v13 withAdminNodes:*(void *)(a1 + 40) regularUserNodes:*(void *)(a1 + 48)];
    uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = *(id *)(a1 + 32);
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      id v18 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v25 = v18;
      __int16 v26 = 2112;
      id v27 = v14;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_INFO, "%{public}@New ACL entries %@", buf, 0x16u);
    }
    v21[0] = MEMORY[0x263EF8330];
    v21[1] = 3221225472;
    v21[2] = __101__HMMTRAccessoryServer_updateAccessoryControlToIncludeAdministratorNodes_sharedUserNodes_completion___block_invoke_763;
    v21[3] = &unk_265377368;
    void v21[4] = *(void *)(a1 + 32);
    id v22 = v14;
    uint64_t v19 = *(void **)(a1 + 56);
    id v23 = *(id *)(a1 + 64);
    id v20 = v14;
    [v19 writeAttributeACLWithValue:v20 completion:v21];
  }
}

void __101__HMMTRAccessoryServer_updateAccessoryControlToIncludeAdministratorNodes_sharedUserNodes_completion___block_invoke_763(uint64_t a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  id v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v8 = HMFGetLogIdentifier();
      int v10 = 138543618;
      BOOL v11 = v8;
      __int16 v12 = 2112;
      id v13 = v3;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to update ACL. Error: %@", (uint8_t *)&v10, 0x16u);
    }
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      int v10 = 138543362;
      BOOL v11 = v9;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Successfully updated ACL to", (uint8_t *)&v10, 0xCu);
    }
    +[HMMTRUtilities printAccessControlList:*(void *)(a1 + 40)];
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

- (void)updateAccessoryControlToAdministratorNodes:(id)a3 sharedUserNodes:(id)a4 completion:(id)a5
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  id v8 = a3;
  id v9 = a4;
  int v10 = (void (**)(id, void))a5;
  if ([(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    BOOL v11 = (void *)MEMORY[0x2533B64D0]();
    __int16 v12 = self;
    id v13 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
LABEL_5:

      v10[2](v10, 0);
      goto LABEL_20;
    }
    uint64_t v14 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    id v41 = v14;
    uint64_t v15 = "%{public}@Skipping ACL update for System Commissioner pairing";
    id v16 = v13;
    os_log_type_t v17 = OS_LOG_TYPE_DEBUG;
LABEL_4:
    _os_log_impl(&dword_252495000, v16, v17, v15, buf, 0xCu);

    goto LABEL_5;
  }
  if (![v8 count] && !objc_msgSend(v9, "count"))
  {
    BOOL v11 = (void *)MEMORY[0x2533B64D0]();
    __int16 v12 = self;
    id v13 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_INFO)) {
      goto LABEL_5;
    }
    uint64_t v14 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    id v41 = v14;
    uint64_t v15 = "%{public}@No ACL nodes to update on accessory";
    id v16 = v13;
    os_log_type_t v17 = OS_LOG_TYPE_INFO;
    goto LABEL_4;
  }
  id v18 = (void *)MEMORY[0x263F10CA8];
  uint64_t v19 = [(HMMTRAccessoryServer *)self nodeID];
  id v20 = [(HMMTRAccessoryServer *)self deviceController];
  id v21 = [v18 deviceWithNodeID:v19 controller:v20];

  if (v21)
  {
    id v22 = objc_alloc(MEMORY[0x263F10C68]);
    id v23 = [(HAPAccessoryServer *)self clientQueue];
    id v24 = (void *)[v22 initWithDevice:v21 endpointID:&unk_2702B5988 queue:v23];

    id v25 = [MEMORY[0x263EFF980] array];
    if ([v8 count])
    {
      id v26 = objc_alloc_init(MEMORY[0x263F10C38]);
      [v26 setPrivilege:&unk_2702B5B98];
      [v26 setAuthMode:&unk_2702B5BB0];
      [v26 setSubjects:v8];
      [v25 addObject:v26];
    }
    if ([v9 count])
    {
      id v27 = objc_alloc_init(MEMORY[0x263F10C38]);
      [v27 setPrivilege:&unk_2702B5BC8];
      [v27 setAuthMode:&unk_2702B5BB0];
      [v27 setSubjects:v9];
      [v25 addObject:v27];
    }
    uint64_t v28 = (void *)MEMORY[0x2533B64D0]();
    id v29 = self;
    __int16 v30 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      id v31 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v41 = v31;
      _os_log_impl(&dword_252495000, v30, OS_LOG_TYPE_INFO, "%{public}@Updating accessory ACL to", buf, 0xCu);
    }
    +[HMMTRUtilities printAccessControlList:v25];
    v37[0] = MEMORY[0x263EF8330];
    v37[1] = 3221225472;
    v37[2] = __94__HMMTRAccessoryServer_updateAccessoryControlToAdministratorNodes_sharedUserNodes_completion___block_invoke;
    v37[3] = &unk_265377368;
    v37[4] = v29;
    id v38 = v24;
    __int16 v39 = v10;
    id v32 = v24;
    [v32 writeAttributeACLWithValue:v25 completion:v37];
  }
  else
  {
    __int16 v33 = (void *)MEMORY[0x2533B64D0]();
    id v34 = self;
    uint64_t v35 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      long long v36 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v41 = v36;
      _os_log_impl(&dword_252495000, v35, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. No device found", buf, 0xCu);
    }
    id v25 = [MEMORY[0x263F087E8] hmfErrorWithCode:2];
    ((void (**)(id, void *))v10)[2](v10, v25);
  }

LABEL_20:
}

void __94__HMMTRAccessoryServer_updateAccessoryControlToAdministratorNodes_sharedUserNodes_completion___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  id v7 = v6;
  if (v3)
  {
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    os_log_type_t v17 = v8;
    __int16 v18 = 2112;
    id v19 = v3;
    id v9 = "%{public}@Failed to update ACL. Error: %@";
    int v10 = v7;
    os_log_type_t v11 = OS_LOG_TYPE_ERROR;
    uint32_t v12 = 22;
  }
  else
  {
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_INFO)) {
      goto LABEL_7;
    }
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    os_log_type_t v17 = v8;
    id v9 = "%{public}@Successfully updated ACL";
    int v10 = v7;
    os_log_type_t v11 = OS_LOG_TYPE_INFO;
    uint32_t v12 = 12;
  }
  _os_log_impl(&dword_252495000, v10, v11, v9, buf, v12);

LABEL_7:
  if (HAPIsInternalBuild())
  {
    id v13 = objc_alloc_init(MEMORY[0x263F10FA0]);
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 3221225472;
    v15[2] = __94__HMMTRAccessoryServer_updateAccessoryControlToAdministratorNodes_sharedUserNodes_completion___block_invoke_762;
    v15[3] = &unk_265377B18;
    uint64_t v14 = *(void **)(a1 + 40);
    void v15[4] = *(void *)(a1 + 32);
    [v14 readAttributeACLWithParams:v13 completion:v15];
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void __94__HMMTRAccessoryServer_updateAccessoryControlToAdministratorNodes_sharedUserNodes_completion___block_invoke_762(uint64_t a1, void *a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id v7 = (void *)MEMORY[0x2533B64D0]();
  id v8 = *(id *)(a1 + 32);
  id v9 = HMFGetOSLogHandle();
  int v10 = v9;
  if (v6)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v11 = HMFGetLogIdentifier();
      int v13 = 138543618;
      uint64_t v14 = v11;
      __int16 v15 = 2112;
      id v16 = v6;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to read ACL. Error: %@", (uint8_t *)&v13, 0x16u);
    }
  }
  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint32_t v12 = HMFGetLogIdentifier();
      int v13 = 138543618;
      uint64_t v14 = v12;
      __int16 v15 = 2112;
      id v16 = v5;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Successfully read ACL as %@", (uint8_t *)&v13, 0x16u);
    }
    +[HMMTRUtilities printAccessControlList:v5];
  }
}

- (void)_getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, BOOL, void))a4;
  id v8 = [(HMMTRAccessoryServer *)self commissioneeNetworks];

  if (v8)
  {
    v7[2](v7, [(HMMTRAccessoryServer *)self commissioneeHasActiveNetwork], 0);
  }
  else
  {
    v9[0] = MEMORY[0x263EF8330];
    v9[1] = 3221225472;
    v9[2] = __99__HMMTRAccessoryServer__getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster_completion___block_invoke;
    v9[3] = &unk_2653775C8;
    v9[4] = self;
    int v10 = v7;
    [v6 readAttributeNetworksWithCompletion:v9];
  }
}

void __99__HMMTRAccessoryServer__getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v25 = v10;
      __int16 v26 = 2112;
      id v27 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to read networks attribute from commissionee: %@", buf, 0x16u);
    }
  }
  [*(id *)(a1 + 32) setCommissioneeNetworks:v5];
  [*(id *)(a1 + 32) setCommissioneeHasActiveNetwork:0];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v11 = v5;
  uint64_t v12 = [v11 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v12)
  {
    uint64_t v13 = v12;
    uint64_t v14 = *(void *)v20;
    uint64_t v15 = MEMORY[0x263EFFA88];
    do
    {
      uint64_t v16 = 0;
      do
      {
        if (*(void *)v20 != v14) {
          objc_enumerationMutation(v11);
        }
        uint64_t v17 = objc_msgSend(*(id *)(*((void *)&v19 + 1) + 8 * v16), "connected", (void)v19);
        int v18 = [v17 isEqual:v15];

        if (v18) {
          [*(id *)(a1 + 32) setCommissioneeHasActiveNetwork:1];
        }
        ++v16;
      }
      while (v13 != v16);
      uint64_t v13 = [v11 countByEnumeratingWithState:&v19 objects:v23 count:16];
    }
    while (v13);
  }

  (*(void (**)(void, uint64_t, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), [*(id *)(a1 + 32) commissioneeHasActiveNetwork], v6);
}

- (void)_getCommissioneeNetworkCommissioningClusterEndpointWithDevice:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *, void))a4;
  id v8 = [(HMMTRAccessoryServer *)self commissioneeNetworkCommissioningClusterEndpoint];

  if (v8)
  {
    id v9 = [(HMMTRAccessoryServer *)self commissioneeNetworkCommissioningClusterEndpoint];
    v7[2](v7, v9, 0);
  }
  else
  {
    int v10 = +[HMMTRDescriptorClusterManager sharedManager];
    id v11 = [(HAPAccessoryServer *)self clientQueue];
    v12[0] = MEMORY[0x263EF8330];
    v12[1] = 3221225472;
    v12[2] = __97__HMMTRAccessoryServer__getCommissioneeNetworkCommissioningClusterEndpointWithDevice_completion___block_invoke;
    v12[3] = &unk_2653789A0;
    void v12[4] = self;
    uint64_t v13 = v7;
    [v10 endpointForClusterID:&unk_2702B5B80 device:v6 callbackQueue:v11 completionHandler:v12];
  }
}

void __97__HMMTRAccessoryServer__getCommissioneeNetworkCommissioningClusterEndpointWithDevice_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = *(void **)(a1 + 32);
  id v6 = a3;
  id v7 = a2;
  [v5 setCommissioneeNetworkCommissioningClusterEndpoint:v7];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

- (void)_collectNetworkCredentials:(id)a3
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    __int16 v30 = v8;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Checking what network technology is supported for the accessory.", buf, 0xCu);
  }
  [(HMMTRAccessoryServer *)v6 setPairingProgress:2];
  id v9 = [(HMMTRAccessoryServer *)v6 deviceController];
  int v10 = [(HMMTRAccessoryServer *)v6 nodeID];
  id v28 = 0;
  id v11 = objc_msgSend(v9, "getDeviceBeingCommissioned:error:", objc_msgSend(v10, "unsignedLongLongValue"), &v28);
  id v12 = v28;

  if (v11)
  {
    BOOL v13 = [v11 sessionTransportType] == 2;
    v26[0] = MEMORY[0x263EF8330];
    v26[1] = 3221225472;
    v26[2] = __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke;
    v26[3] = &unk_265377A78;
    v26[4] = v6;
    id v27 = v9;
    uint64_t v14 = (void *)MEMORY[0x2533B66E0](v26);
    v21[0] = MEMORY[0x263EF8330];
    v21[1] = 3221225472;
    v21[2] = __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_2;
    v21[3] = &unk_265377AF0;
    void v21[4] = v6;
    id v24 = v14;
    id v22 = v11;
    BOOL v25 = v13;
    id v23 = v4;
    id v15 = v14;
    [(HMMTRAccessoryServer *)v6 _getCommissioneeNetworkCommissioningClusterEndpointWithDevice:v22 completion:v21];
  }
  else
  {
    uint64_t v16 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v17 = v6;
    int v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      long long v19 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      __int16 v30 = v19;
      __int16 v31 = 2112;
      id v32 = v12;
      _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_INFO, "%{public}@Failed to check supported network technologies for server. Error: %@...", buf, 0x16u);
    }
    long long v20 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v12];
    [(HMMTRAccessoryServer *)v17 _pairingComplete:v12 context:v20];
  }
}

void __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v8)
  {
    int v10 = (void *)MEMORY[0x2533B64D0]();
    id v11 = *(id *)(a1 + 32);
    id v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      BOOL v13 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      long long v20 = v13;
      __int16 v21 = 2112;
      id v22 = v8;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_ERROR, "%{public}@Failed to collect required credentials for accessory. Error: %@", buf, 0x16u);
    }
    uint64_t v14 = *(void **)(a1 + 40);
    id v15 = [*(id *)(a1 + 32) nodeID];
    objc_msgSend(v14, "stopDevicePairing:error:", objc_msgSend(v15, "unsignedLongLongValue"), 0);

    [*(id *)(a1 + 32) _pairingComplete:v8 context:v9];
  }
  else
  {
    uint64_t v16 = *(void **)(a1 + 32);
    v17[0] = MEMORY[0x263EF8330];
    v17[1] = 3221225472;
    v17[2] = __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_744;
    v17[3] = &unk_265378660;
    v17[4] = v16;
    id v18 = v7;
    [v16 _fetchAdditionalThreadNetworkInformationWithCompletion:v17];
  }
}

void __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      uint64_t v35 = v10;
      __int16 v36 = 2112;
      id v37 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to query endpoints for network commissioning cluster : %@", buf, 0x16u);
    }
    id v11 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v6];
    [*(id *)(a1 + 32) _pairingComplete:v6 context:v11];
  }
  else
  {
    id v11 = objc_alloc_init(MEMORY[0x263F10D98]);
    id v12 = [*(id *)(a1 + 32) browser];
    BOOL v13 = [v12 attestationStatus];
    [v13 populateDelegate:v11];

    if ([*(id *)(a1 + 32) _populateCommissioningParameterCountryCode:v11])
    {
      uint64_t v14 = (void *)MEMORY[0x2533B64D0]();
      id v15 = *(id *)(a1 + 32);
      uint64_t v16 = HMFGetOSLogHandle();
      uint64_t v17 = v16;
      if (v5)
      {
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          id v18 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          uint64_t v35 = v18;
          __int16 v36 = 2112;
          id v37 = v5;
          _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_DEBUG, "%{public}@Found network commissioning cluster at endpoint: %@", buf, 0x16u);
        }
        id v19 = objc_alloc(MEMORY[0x263F10C98]);
        uint64_t v20 = *(void *)(a1 + 40);
        unsigned __int16 v21 = [v5 unsignedIntValue];
        id v22 = [*(id *)(a1 + 32) clientQueue];
        uint64_t v23 = (void *)[v19 initWithDevice:v20 endpoint:v21 queue:v22];

        objc_initWeak((id *)buf, *(id *)(a1 + 32));
        id v24 = *(void **)(a1 + 32);
        v27[0] = MEMORY[0x263EF8330];
        v27[1] = 3221225472;
        v27[2] = __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_748;
        v27[3] = &unk_265377AC8;
        v27[4] = v24;
        char v33 = *(unsigned char *)(a1 + 64);
        id v25 = v23;
        id v28 = v25;
        objc_copyWeak(&v32, (id *)buf);
        id v31 = *(id *)(a1 + 56);
        id v11 = v11;
        id v29 = v11;
        id v30 = *(id *)(a1 + 48);
        [v24 _getCommissioneeHasActiveNetworkWithNetworkCommissioningCluster:v25 completion:v27];

        objc_destroyWeak(&v32);
        objc_destroyWeak((id *)buf);
      }
      else
      {
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          __int16 v26 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543362;
          uint64_t v35 = v26;
          _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_INFO, "%{public}@Network commissioning cluster not found. Proceeding with on-network commissioning", buf, 0xCu);
        }
        (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
      }
    }
  }
}

void __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_748(uint64_t a1, int a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v5 = a3;
  id v6 = (void *)MEMORY[0x2533B64D0]();
  id v7 = *(id *)(a1 + 32);
  id v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    id v9 = HMFGetLogIdentifier();
    int v10 = HMFBooleanToString();
    id v11 = HMFBooleanToString();
    *(_DWORD *)buf = 138543874;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v10;
    *(_WORD *)&buf[22] = 2112;
    __int16 v26 = v11;
    _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_INFO, "%{public}@Commissionee over BLE: %@, has active network: %@", buf, 0x20u);
  }
  *(void *)buf = 0;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000;
  LOBYTE(v26) = 0;
  if (!v5 && a2 && !*(unsigned char *)(a1 + 80))
  {
    id v12 = (void *)MEMORY[0x2533B64D0]();
    id v13 = *(id *)(a1 + 32);
    HMFGetOSLogHandle();
    uint64_t v14 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      id v15 = HMFGetLogIdentifier();
      *(_DWORD *)uint64_t v23 = 138543362;
      id v24 = v15;
      _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_INFO, "%{public}@Commissionee was already network commissioned. Skip network commissioning parameters.", v23, 0xCu);
    }
    *(unsigned char *)(*(void *)&buf[8] + 24) = 1;
  }
  uint64_t v16 = *(void **)(a1 + 40);
  v17[0] = MEMORY[0x263EF8330];
  v17[1] = 3221225472;
  v17[2] = __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_749;
  v17[3] = &unk_265377AA0;
  objc_copyWeak(&v22, (id *)(a1 + 72));
  unsigned __int16 v21 = buf;
  id v20 = *(id *)(a1 + 64);
  id v18 = *(id *)(a1 + 48);
  id v19 = *(id *)(a1 + 56);
  [v16 readAttributeFeatureMapWithCompletionHandler:v17];

  objc_destroyWeak(&v22);
  _Block_object_dispose(buf, 8);
}

void __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_749(uint64_t a1, void *a2, void *a3)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  id v8 = WeakRetained;
  if (!v6)
  {
    id v15 = [WeakRetained getSupportedLinkLayerTypesFromNetworkCommissioningClusterFeatureMap:v5];
    [v8 _setSupportedLinkLayerTypes:v15];

    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24))
    {
LABEL_7:
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      goto LABEL_36;
    }
    char v18 = [v5 integerValue];
    if ((v18 & 1) == 0)
    {
      if ((v18 & 2) != 0)
      {
        [v8 setLinkLayerType:4];
        if ((isFeatureMatteriPhoneOnlyPairingControlForThreadEnabled() & 1) != 0
          || ![v8 shouldPairWithoutResident])
        {
          [v8 _populateThreadCredentials:*(void *)(a1 + 32) completion:*(void *)(a1 + 48)];
          goto LABEL_36;
        }
        uint64_t v23 = [MEMORY[0x263F087E8] hapErrorWithCode:30];
        id v24 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:4 error:v23];
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      }
      else
      {
        if ((v18 & 4) != 0)
        {
          [v8 setLinkLayerType:2];
          goto LABEL_7;
        }
        id v19 = (void *)MEMORY[0x2533B64D0]();
        id v20 = v8;
        unsigned __int16 v21 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          id v22 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          __int16 v36 = v22;
          __int16 v37 = 2112;
          id v38 = v5;
          _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_ERROR, "%{public}@Accessory NetworkCommissioning cluster feature map has unsupported value: %@", buf, 0x16u);
        }
        uint64_t v23 = [MEMORY[0x263F087E8] hapErrorWithCode:15];
        id v24 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:3 error:v23];
        [v20 _pairingComplete:v23 context:v24];
      }
      goto LABEL_27;
    }
    [v8 setLinkLayerType:1];
    if (isFeatureMatterLocalFabricConfigEnabled())
    {
      id v25 = [v8 browser];
      __int16 v26 = [v25 currentFabricID];

      uint64_t v27 = [v8 pairingTargetHomeUUID];
      if (v27)
      {
        id v28 = [v8 storage];
        id v29 = [v28 dataSource];
        id v30 = [v8 pairingTargetHomeUUID];
        uint64_t v23 = [v29 appleHomeFabricWithUUID:v30];
LABEL_20:

        if (v23)
        {
          if ((isFeatureMatteriPhoneOnlyPairingControlForIPEnabled() & 1) == 0)
          {
            id v31 = [v23 delegate];
            char v32 = [v31 requiresRemoteFabricDataUpdate];

            if ((v32 & 1) == 0)
            {
              id v24 = [MEMORY[0x263F087E8] hapErrorWithCode:35];
              char v33 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:5 error:v24];
              (*(void (**)(void))(*(void *)(a1 + 48) + 16))();

LABEL_27:
LABEL_35:

              goto LABEL_36;
            }
          }
        }
LABEL_34:
        [v8 _populateWifiCredentials:*(void *)(a1 + 32) scanResults:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
        goto LABEL_35;
      }
      if (v26 && ([v26 isEqual:&unk_2702B5988] & 1) == 0)
      {
        id v28 = [v8 storage];
        id v29 = [v28 dataSource];
        id v30 = [v8 browser];
        id v34 = [v30 currentFabricID];
        uint64_t v23 = [v29 appleHomeFabricWithID:v34];

        goto LABEL_20;
      }
    }
    uint64_t v23 = 0;
    goto LABEL_34;
  }
  int v9 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
  int v10 = (void *)MEMORY[0x2533B64D0]();
  id v11 = v8;
  id v12 = HMFGetOSLogHandle();
  id v13 = v12;
  if (v9)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      __int16 v36 = v14;
      __int16 v37 = 2112;
      id v38 = v6;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_ERROR, "%{public}@Failed to check supported network technologies for server, but commissionee was already network commissioned. Ignoring error and continuing with pairing. Error: %@", buf, 0x16u);
    }
    goto LABEL_7;
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    uint64_t v16 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    __int16 v36 = v16;
    __int16 v37 = 2112;
    id v38 = v6;
    _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Failed to check supported network technologies for server. Error: %@...", buf, 0x16u);
  }
  uint64_t v17 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:3 error:v6];
  [v11 _pairingComplete:v6 context:v17];

LABEL_36:
}

uint64_t __51__HMMTRAccessoryServer__collectNetworkCredentials___block_invoke_744(uint64_t a1)
{
  return [*(id *)(a1 + 32) _commissionWithParams:*(void *)(a1 + 40)];
}

- (void)_setSupportedLinkLayerTypes:(id)a3
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = v4;
  if (!v4)
  {
    id v6 = (void *)MEMORY[0x2533B64D0]();
    id v7 = self;
    id v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v9 = HMFGetLogIdentifier();
      int v10 = [(HMMTRAccessoryServer *)v7 nodeID];
      *(_DWORD *)buf = 138543618;
      __int16 v26 = v9;
      __int16 v27 = 2112;
      id v28 = v10;
      id v11 = "%{public}@Nil supported link layer types - cannot determine supported link layer for accessory with nodeID %@";
      goto LABEL_7;
    }
LABEL_8:

    goto LABEL_12;
  }
  if ([v4 isEqualToValue:&unk_2702B5988])
  {
    id v6 = (void *)MEMORY[0x2533B64D0]();
    id v7 = self;
    id v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v9 = HMFGetLogIdentifier();
      int v10 = [(HMMTRAccessoryServer *)v7 nodeID];
      *(_DWORD *)buf = 138543618;
      __int16 v26 = v9;
      __int16 v27 = 2112;
      id v28 = v10;
      id v11 = "%{public}@No supported link layer types - cannot determine supported link layer for accessory with nodeID %@";
LABEL_7:
      _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_ERROR, v11, buf, 0x16u);

      goto LABEL_8;
    }
    goto LABEL_8;
  }
  [v5 unsignedIntValue];
  [v5 unsignedIntValue];
  [v5 unsignedIntValue];
  id v12 = (void *)MEMORY[0x2533B64D0]();
  id v13 = self;
  uint64_t v14 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    id v15 = HMFGetLogIdentifier();
    uint64_t v16 = HMFBooleanToString();
    uint64_t v17 = HMFBooleanToString();
    char v18 = HMFBooleanToString();
    *(_DWORD *)buf = 138544386;
    __int16 v26 = v15;
    __int16 v27 = 2112;
    id v28 = v5;
    __int16 v29 = 2112;
    id v30 = v16;
    __int16 v31 = 2112;
    char v32 = v17;
    __int16 v33 = 2112;
    id v34 = v18;
    _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_INFO, "%{public}@Accessory supported link layer types: %@ [WiFi:%@, Ethernet:%@, Thread:%@]", buf, 0x34u);
  }
  [(HMMTRAccessoryServer *)v13 setSupportedLinkLayerTypes:v5];
  id v19 = [(HMMTRAccessoryServer *)v13 storage];
  id v20 = [v19 fabricDataSource];
  unsigned __int16 v21 = [(HMMTRAccessoryServer *)v13 nodeID];
  id v22 = [v20 storageDataSourceForDeviceWithNodeID:v21];
  uint64_t v23 = [(HMMTRAccessoryServer *)v13 supportedLinkLayerTypes];
  v24[0] = MEMORY[0x263EF8330];
  v24[1] = 3221225472;
  v24[2] = __52__HMMTRAccessoryServer__setSupportedLinkLayerTypes___block_invoke;
  v24[3] = &unk_265376E00;
  void v24[4] = v13;
  [v22 updateSupportedLinkLayerTypes:v23 completion:v24];

LABEL_12:
}

void __52__HMMTRAccessoryServer__setSupportedLinkLayerTypes___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = HMFGetLogIdentifier();
      id v8 = [*(id *)(a1 + 32) supportedLinkLayerTypes];
      int v9 = 138543874;
      int v10 = v7;
      __int16 v11 = 2112;
      id v12 = v8;
      __int16 v13 = 2112;
      id v14 = v3;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to update supported link layer types in storage to %@ with error: %@", (uint8_t *)&v9, 0x20u);
    }
  }
}

- (void)setSupportedLinkLayerTypes:(id)a3
{
  id v4 = (NSNumber *)a3;
  id v5 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  supportedLinkLayerTypes = self->_supportedLinkLayerTypes;
  self->_supportedLinkLayerTypes = v4;

  os_unfair_lock_unlock(v5);
}

- (NSNumber)supportedLinkLayerTypes
{
  id v3 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  id v4 = self->_supportedLinkLayerTypes;
  os_unfair_lock_unlock(v3);
  return v4;
}

- (BOOL)_populateCommissioningParameterCountryCode:(id)a3
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [(HMMTRAccessoryServer *)self browser];
  id v6 = [v5 regulatoryInfo];
  id v7 = [v6 countryCode];
  [v4 setCountryCode:v7];

  id v8 = [v4 countryCode];

  if (!v8)
  {
    int v9 = (void *)MEMORY[0x2533B64D0]();
    int v10 = self;
    __int16 v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      id v12 = HMFGetLogIdentifier();
      int v14 = 138543362;
      uint64_t v15 = v12;
      _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_ERROR, "%{public}@Country code could not be estimated. Moving on with pairing without country code.", (uint8_t *)&v14, 0xCu);
    }
  }

  return 1;
}

- (void)_commissionWithParams:(id)a3
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    int v9 = [(HMMTRAccessoryServer *)v6 nodeID];
    *(_DWORD *)buf = 138543618;
    uint64_t v15 = v8;
    __int16 v16 = 2112;
    uint64_t v17 = v9;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Requesting to commission device(%@).", buf, 0x16u);
  }
  [(HMMTRAccessoryServer *)v6 _startCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameCommissioningAccessory"];
  [(HMMTRAccessoryServer *)v6 _notifyDelegateOfPairingProgress:27];
  [(HMMTRAccessoryServer *)v6 _notifyDelegateOfPairingStep:6];
  int v10 = [(HMMTRAccessoryServer *)v6 deviceController];
  __int16 v11 = [(HMMTRAccessoryServer *)v6 nodeID];
  id v13 = 0;
  objc_msgSend(v10, "commissionDevice:commissioningParams:error:", objc_msgSend(v11, "unsignedLongLongValue"), v4, &v13);
  id v12 = v13;

  if (v12) {
    [(HMMTRAccessoryServer *)v6 _notifyDelegateOfPairingProgress:29 error:v12];
  }
}

- (void)_handlePairingFailureWithError:(id)a3 context:(id)a4
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  id v6 = (HMMTRAccessoryServer *)a3;
  id v7 = a4;
  id v8 = (void *)MEMORY[0x2533B64D0]();
  int v9 = self;
  int v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    __int16 v11 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543874;
    uint64_t v57 = v11;
    __int16 v58 = 2112;
    int v59 = v6;
    __int16 v60 = 2112;
    id v61 = v7;
    _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_ERROR, "%{public}@Cleaning up state due to pairing failure error %@ context %@", buf, 0x20u);
  }
  [(HMMTRAccessoryServer *)v9 _clearCommissioneeInfoAfterPairingCompletion];
  id v12 = [(HMMTRAccessoryServer *)v6 domain];
  int v13 = [v12 isEqualToString:*MEMORY[0x263F10BB0]];

  if (v13)
  {
    if ([(HMMTRAccessoryServer *)v6 code] == 11) {
      uint64_t v14 = 18;
    }
    else {
      uint64_t v14 = 15;
    }
    uint64_t v15 = [MEMORY[0x263F087E8] hapErrorWithCode:v14 description:0 reason:0 suggestion:0 underlyingError:v6];

    id v6 = (HMMTRAccessoryServer *)v15;
  }
  if ([(HMMTRAccessoryServer *)v6 isHMFError]
    && [(HMMTRAccessoryServer *)v6 code] == 11)
  {
    uint64_t v16 = [MEMORY[0x263F087E8] hapErrorWithCode:15 description:0 reason:0 suggestion:0 underlyingError:v6];

    id v6 = (HMMTRAccessoryServer *)v16;
  }
  [(HMMTRAccessoryServer *)v9 setPairingProgress:3];
  if ([(HMMTRAccessoryServer *)v9 pairedState] == 1)
  {
    uint64_t v17 = [(HMMTRAccessoryServer *)v9 stageCompletion];

    if (v17)
    {
      uint64_t v18 = [(HMMTRAccessoryServer *)v9 stageCompletion];
      ((void (**)(void, void, void, HMMTRAccessoryServer *))v18)[2](v18, 0, 0, v6);

      [(HMMTRAccessoryServer *)v9 setStageCompletion:0];
    }
    else
    {
      id v19 = (void *)MEMORY[0x2533B64D0]();
      id v20 = v9;
      unsigned __int16 v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        id v22 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v57 = v22;
        _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory is staged but has no stage completion handler set!", buf, 0xCu);
      }
    }
  }
  [(HMMTRAccessoryServer *)v9 setRemoveReason:v6 pairingEndContextWhenRemove:v7];
  uint64_t v23 = [(HMMTRAccessoryServer *)v9 storage];
  [v23 endLocalStorageModeBySyncingToRemote:0];

  id v24 = [(HAPAccessoryServer *)v9 clientQueue];
  [(HMMTRAccessoryServer *)v9 _unpair:v24 completion:0];

  id v25 = [(HAPAccessoryServer *)v9 delegateQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke;
  block[3] = &unk_265376F38;
  void block[4] = v9;
  __int16 v26 = v6;
  char v54 = v26;
  id v27 = v7;
  id v55 = v27;
  dispatch_async(v25, block);

  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    id v28 = (void *)MEMORY[0x2533B64D0]();
    __int16 v29 = v9;
    id v30 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      __int16 v31 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v57 = v31;
      _os_log_impl(&dword_252495000, v30, OS_LOG_TYPE_DEBUG, "%{public}@Resetting storage state after pairing failure", buf, 0xCu);
    }
    char v32 = [(HMMTRAccessoryServer *)v29 browser];
    [v32 setupStorageStateAndRediscoverAccessoriesForHomeFabricID:0];

    __int16 v33 = [(HMMTRAccessoryServer *)v29 browser];
    [v33 disableUnrestrictedOperationsForAccessoryServer:v29];

    id v34 = [(HMMTRAccessoryServer *)v29 browser];
    [v34 resumeAllOperations];

    uint64_t v35 = [(HMMTRAccessoryServer *)v29 fabricID];
    if (v35)
    {
      __int16 v36 = [(HMMTRAccessoryServer *)v29 storage];
      __int16 v37 = [v36 dataSource];
      id v38 = [(HMMTRAccessoryServer *)v29 fabricID];
      uint64_t v39 = [v37 appleHomeFabricWithID:v38];
    }
    else
    {
      uint64_t v39 = 0;
    }

    id v40 = [(HMMTRAccessoryServer *)v29 browser];
    int v41 = [v40 isCurrentDeviceAllowedAccessoryControlDespiteReachableResidentForFabric:v39];

    if (v41)
    {
      uint64_t v42 = [(HMMTRAccessoryServer *)v29 browser];
      uint64_t v43 = [v42 threadRadioManager];
      v52[0] = MEMORY[0x263EF8330];
      v52[1] = 3221225472;
      void v52[2] = __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke_742;
      v52[3] = &unk_265376E00;
      v52[4] = v29;
      [v43 stopAccessoryPairingWithCompletion:v52];

      if ([(HMMTRAccessoryServer *)v29 isWEDDevice])
      {
        unsigned int v44 = [(HMMTRAccessoryServer *)v29 eMACAddress];

        if (v44)
        {
          uint64_t v45 = (void *)MEMORY[0x2533B64D0]();
          __int16 v46 = v29;
          id v47 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
          {
            __int16 v48 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543618;
            uint64_t v57 = v48;
            __int16 v58 = 2112;
            int v59 = v46;
            _os_log_impl(&dword_252495000, v47, OS_LOG_TYPE_INFO, "%{public}@Disconnecting from WED accessory %@", buf, 0x16u);
          }
          id v49 = [(HMMTRAccessoryServer *)v46 browser];
          uint64_t v50 = [v49 threadRadioManager];
          v51[0] = MEMORY[0x263EF8330];
          v51[1] = 3221225472;
          void v51[2] = __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke_743;
          v51[3] = &unk_265376E00;
          v51[4] = v46;
          [v50 connectToAccessoryWithExtendedMACAddress:0 completion:v51];
        }
      }
    }
  }
}

void __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = [*(id *)(a1 + 32) delegate];
  if ([v2 conformsToProtocol:&unk_2702F5258]) {
    id v3 = v2;
  }
  else {
    id v3 = 0;
  }
  id v4 = v3;

  if (v4)
  {
    [v4 accessoryServer:*(void *)(a1 + 32) didStopPairingWithError:*(void *)(a1 + 40) matterPairingEndContext:*(void *)(a1 + 48)];
  }
  else
  {
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = *(id *)(a1 + 32);
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v8 = HMFGetLogIdentifier();
      int v9 = 138543362;
      int v10 = v8;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_ERROR, "%{public}@Unable to find delegate confirming to HAPAccessoryServerMTRDelegatePrivate", (uint8_t *)&v9, 0xCu);
    }
  }
}

void __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke_742(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    int v8 = 138543618;
    int v9 = v7;
    __int16 v10 = 2112;
    id v11 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Thread StopAccessoryPairing completed, error: %@", (uint8_t *)&v8, 0x16u);
  }
}

void __63__HMMTRAccessoryServer__handlePairingFailureWithError_context___block_invoke_743(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    int v8 = *(void **)(a1 + 32);
    int v9 = [v8 eMACAddress];
    int v10 = 138544130;
    id v11 = v7;
    __int16 v12 = 2112;
    int v13 = v8;
    __int16 v14 = 2112;
    uint64_t v15 = v9;
    __int16 v16 = 2112;
    id v17 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Disconnect from WED accessory %@ with emac %@ completed, error %@", (uint8_t *)&v10, 0x2Au);
  }
}

- (void)_buildHAPCategoriesFromCHIPWithCompletionHandler:(id)a3
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  id v4 = (void (**)(id, void *))a3;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = self;
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      int v8 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      unsigned __int16 v21 = v8;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting building HAP categories.", buf, 0xCu);
    }
    int v9 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
    v4[2](v4, v9);
  }
  else
  {
    uint64_t v10 = random();
    id v11 = (void *)MEMORY[0x2533B64D0]();
    __int16 v12 = self;
    int v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      __int16 v14 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      unsigned __int16 v21 = v14;
      __int16 v22 = 2048;
      uint64_t v23 = v10;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Category build job(%lu) queued.", buf, 0x16u);
    }
    v17[0] = MEMORY[0x263EF8330];
    v17[1] = 3221225472;
    v17[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke;
    v17[3] = &unk_265377A50;
    void v17[4] = v12;
    uint64_t v19 = v10;
    uint64_t v18 = v4;
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 3221225472;
    v15[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_741;
    v15[3] = &unk_2653787C8;
    __int16 v16 = v18;
    [(HMMTRAccessoryServer *)v12 queueAccessoryOperation:v17 highPriority:0 completion:v15];
  }
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke(uint64_t a1)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 138543618;
    char v32 = v5;
    __int16 v33 = 2048;
    uint64_t v34 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Category build job(%lu) started.", buf, 0x16u);
  }
  id v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  v28[0] = MEMORY[0x263EF8330];
  v28[1] = 3221225472;
  v28[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_737;
  v28[3] = &unk_265378578;
  id v30 = *(id *)(a1 + 40);
  int v8 = v7;
  __int16 v29 = v8;
  int v9 = (void *)MEMORY[0x2533B66E0](v28);
  uint64_t v10 = [*(id *)(a1 + 32) deviceController];
  char v11 = [v10 isRunning];
  __int16 v12 = *(void **)(a1 + 32);
  if (v11)
  {
    int v13 = [v12 nodeID];
    uint64_t v14 = [v13 unsignedLongLongValue];
    uint64_t v15 = [*(id *)(a1 + 32) clientQueue];
    v23[0] = MEMORY[0x263EF8330];
    v23[1] = 3221225472;
    v23[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_738;
    void v23[3] = &unk_265377520;
    uint8_t v23[4] = *(void *)(a1 + 32);
    uint64_t v24 = v9;
    id v16 = v9;
    [v10 getBaseDevice:v14 queue:v15 completionHandler:v23];

    id v17 = [*(id *)(a1 + 32) clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_740;
    block[3] = &unk_265377168;
    uint64_t v18 = *(void *)(a1 + 48);
    void block[4] = *(void *)(a1 + 32);
    void block[5] = v18;
    dispatch_group_notify(v8, v17, block);

    uint64_t v19 = v24;
  }
  else
  {
    id v20 = [v12 clientQueue];
    v25[0] = MEMORY[0x263EF8330];
    v25[1] = 3221225472;
    v25[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_2;
    v25[3] = &unk_265377A50;
    v25[4] = *(void *)(a1 + 32);
    __int16 v26 = v9;
    uint64_t v27 = *(void *)(a1 + 48);
    id v21 = v9;
    dispatch_async(v20, v25);

    uint64_t v19 = v26;
  }
}

uint64_t __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_741(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_737(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v2);
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_2(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v3);

  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    uint64_t v8 = *(void *)(a1 + 48);
    int v9 = 138543618;
    uint64_t v10 = v7;
    __int16 v11 = 2048;
    uint64_t v12 = v8;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Category build job(%lu) complete.", (uint8_t *)&v9, 0x16u);
  }
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_738(uint64_t a1, void *a2, void *a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    id v7 = [*(id *)(a1 + 32) descriptorClusterManager];
    uint64_t v8 = v7[2]();
    int v9 = [*(id *)(a1 + 32) nodeID];
    uint64_t v10 = *(void **)(a1 + 32);
    __int16 v11 = [v10 clientQueue];
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_2_739;
    v19[3] = &unk_2653789A0;
    uint64_t v12 = *(void **)(a1 + 40);
    void v19[4] = *(void *)(a1 + 32);
    id v20 = v12;
    [v8 fetchHAPCategoryForCHIPDevice:v5 nodeId:v9 server:v10 callbackQueue:v11 completionHandler:v19];
  }
  else
  {
    uint64_t v13 = (void *)MEMORY[0x2533B64D0]();
    id v14 = *(id *)(a1 + 32);
    uint64_t v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      id v16 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      __int16 v22 = v16;
      __int16 v23 = 2112;
      id v24 = v6;
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_ERROR, "%{public}@Could not retrieve hap category: %@", buf, 0x16u);
    }
    uint64_t v17 = *(void *)(a1 + 40);
    uint64_t v18 = [MEMORY[0x263F087E8] errorWithDomain:@"HMMTRProtocolOperationErrorDomain" code:0 userInfo:0];
    (*(void (**)(uint64_t, void *))(v17 + 16))(v17, v18);
  }
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_740(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    uint64_t v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Category build job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __73__HMMTRAccessoryServer__buildHAPCategoriesFromCHIPWithCompletionHandler___block_invoke_2_739(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (a2) {
    [*(id *)(a1 + 32) _setCategoryForPrimaryAccessory:a2];
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

- (void)_rebuildHAPServicesFromCHIPWithCompletionHandler:(id)a3
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  id v4 = (void (**)(id, void *))a3;
  BOOL v5 = [(HMMTRAccessoryServer *)self operationDisabled];
  uint64_t v6 = (void *)MEMORY[0x2533B64D0]();
  int v7 = self;
  uint64_t v8 = HMFGetOSLogHandle();
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_INFO);
  if (v5)
  {
    if (v9)
    {
      uint64_t v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v35 = v10;
      _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting rebuilding HAP services.", buf, 0xCu);
    }
    if (v4)
    {
      uint64_t v11 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
      v4[2](v4, v11);
    }
  }
  else
  {
    if (v9)
    {
      uint64_t v12 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v35 = v12;
      _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_INFO, "%{public}@Rebuilding HAP Services from MTRDevice cache", buf, 0xCu);
    }
    v32[0] = MEMORY[0x263EF8330];
    v32[1] = 3221225472;
    v32[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke;
    v32[3] = &unk_265378578;
    void v32[4] = v7;
    uint64_t v13 = v4;
    __int16 v33 = v13;
    id v14 = (void *)MEMORY[0x2533B66E0](v32);
    [(HMMTRAccessoryServer *)v7 _setupMatterDevice];
    uint64_t v15 = [(HMMTRAccessoryServer *)v7 matterDevice];
    int v16 = [v15 deviceCachePrimed];

    if (v16)
    {
      [(HMMTRAccessoryServer *)v7 setServiceEnumerationInProgress:1];
      uint64_t v17 = [(HMMTRAccessoryServer *)v7 descriptorClusterManager];
      uint64_t v18 = v17[2]();
      uint64_t v19 = [(HMMTRAccessoryServer *)v7 matterDevice];
      id v20 = [(HMMTRAccessoryServer *)v7 nodeID];
      id v21 = [(HAPAccessoryServer *)v7 clientQueue];
      v30[0] = MEMORY[0x263EF8330];
      v30[1] = 3221225472;
      v30[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_723;
      v30[3] = &unk_265377A28;
      void v30[4] = v7;
      id v31 = v14;
      [v18 fetchHAPServicesWithMTRDevice:v19 nodeId:v20 server:v7 callbackQueue:v21 completionHandler:v30];
    }
    else
    {
      __int16 v22 = (void *)MEMORY[0x2533B64D0]();
      __int16 v23 = v7;
      id v24 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
      {
        uint64_t v25 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v35 = v25;
        _os_log_impl(&dword_252495000, v24, OS_LOG_TYPE_INFO, "%{public}@Could not retrieve hap services because MTRDevice cache is not ready", buf, 0xCu);
      }
      [(HMMTRAccessoryServer *)v23 setFullServiceEnumerationPendingCachePrimedEvent:1];
      if (v13)
      {
        __int16 v26 = [(HMMTRAccessoryServer *)v23 serviceEnumerationFromDeviceCompletionHandlers];
        uint64_t v27 = (void *)MEMORY[0x2533B66E0](v13);
        [v26 addObject:v27];
      }
      void v28[4] = v23;
      v29[0] = MEMORY[0x263EF8330];
      v29[1] = 3221225472;
      v29[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_735;
      v29[3] = &unk_265378638;
      v29[4] = v23;
      v28[0] = MEMORY[0x263EF8330];
      v28[1] = 3221225472;
      v28[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_736;
      v28[3] = &unk_265376E00;
      [(HMMTRAccessoryServer *)v23 queueAccessoryOperation:v29 highPriority:0 completion:v28];
    }
  }
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  if (!v3)
  {
    [v4 setServicesEnumerated:1];
    goto LABEL_5;
  }
  if (([v4 servicesEnumerated] & 1) == 0) {
LABEL_5:
  }
    [*(id *)(a1 + 32) setServiceEnumerationFailed:v3 != 0];
  BOOL v5 = (void *)MEMORY[0x2533B64D0]([*(id *)(a1 + 32) setFullServiceEnumerationPendingCachePrimedEvent:0]);
  id v6 = *(id *)(a1 + 32);
  int v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    uint64_t v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    __int16 v29 = v8;
    __int16 v30 = 2112;
    id v31 = v3;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Completed rebuilding HAP services from MTRDevice cache with error: %@", buf, 0x16u);
  }
  BOOL v9 = [*(id *)(a1 + 32) serviceEnumerationFromDeviceCompletionHandlers];
  uint64_t v10 = (void *)[v9 copy];

  uint64_t v11 = [*(id *)(a1 + 32) serviceEnumerationFromDeviceCompletionHandlers];
  [v11 removeAllObjects];

  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v12 = v10;
  uint64_t v13 = [v12 countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (v13)
  {
    uint64_t v14 = v13;
    uint64_t v15 = *(void *)v24;
    do
    {
      uint64_t v16 = 0;
      do
      {
        if (*(void *)v24 != v15) {
          objc_enumerationMutation(v12);
        }
        (*(void (**)(void))(*(void *)(*((void *)&v23 + 1) + 8 * v16++) + 16))();
      }
      while (v14 != v16);
      uint64_t v14 = [v12 countByEnumeratingWithState:&v23 objects:v27 count:16];
    }
    while (v14);
  }

  uint64_t v17 = *(void **)(a1 + 32);
  v20[0] = MEMORY[0x263EF8330];
  v20[1] = 3221225472;
  v20[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_722;
  v20[3] = &unk_265377368;
  void v20[4] = v17;
  id v18 = *(id *)(a1 + 40);
  id v21 = v3;
  id v22 = v18;
  id v19 = v3;
  [v17 updateAllCharacteristicValuesPostHAPServiceEnumeration:v20];
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_723(uint64_t a1, void *a2, int a3, void *a4, void *a5)
{
  uint64_t v135 = *MEMORY[0x263EF8340];
  id v8 = a2;
  id v81 = a4;
  id v80 = a5;
  id v88 = objc_alloc_init(MEMORY[0x263EFF9A0]);
  id v84 = objc_alloc_init(MEMORY[0x263EFF9A0]);
  BOOL v9 = (void *)MEMORY[0x263EFF980];
  uint64_t v10 = [v8 accessoryInfoDictionary];
  uint64_t v11 = [v10 allKeys];
  id v12 = [v9 arrayWithArray:v11];

  [v12 sortUsingComparator:&__block_literal_global_725];
  id v94 = objc_alloc_init(MEMORY[0x263EFF980]);
  long long v119 = 0u;
  long long v120 = 0u;
  long long v121 = 0u;
  long long v122 = 0u;
  id obj = v12;
  id v92 = v8;
  uint64_t v86 = [obj countByEnumeratingWithState:&v119 objects:v134 count:16];
  if (v86)
  {
    uint64_t v85 = *(void *)v120;
    do
    {
      uint64_t v13 = 0;
      do
      {
        if (*(void *)v120 != v85) {
          objc_enumerationMutation(obj);
        }
        uint64_t v14 = *(void **)(*((void *)&v119 + 1) + 8 * v13);
        id v15 = objc_alloc_init(MEMORY[0x263EFF980]);
        uint64_t v16 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(v14, "integerValue"));
        uint64_t v17 = [v8 partsListForEndpoint:v16];
        id v18 = [v8 nameForEndpoint:v16];
        id v19 = v18;
        uint64_t v91 = v13;
        if (v18 && ![v18 isEqual:&stru_2702A0B38]
          || ([NSString stringWithFormat:@"%@,%@", @"Matter Accessory", v14],
              uint64_t v20 = objc_claimAutoreleasedReturnValue(),
              v19,
              (id v19 = (void *)v20) != 0))
        {
          [v84 setObject:v19 forKey:v14];
        }
        id v87 = v14;
        uint64_t v21 = [v8 serviceDescriptionsForEndpoint:v16];
        id v22 = (void *)MEMORY[0x2533B64D0]();
        id v23 = *(id *)(a1 + 32);
        long long v24 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
        {
          long long v25 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543874;
          v129 = v25;
          __int16 v130 = 2112;
          uint64_t v131 = v21;
          __int16 v132 = 2112;
          uint64_t v133 = v16;
          _os_log_impl(&dword_252495000, v24, OS_LOG_TYPE_INFO, "%{public}@Retrieved service description @%@ at endpoint %@", buf, 0x20u);
        }
        id v90 = (void *)v16;

        if (v21) {
          [v15 addObjectsFromArray:v21];
        }
        id v89 = (void *)v21;
        v96 = v15;
        long long v117 = 0u;
        long long v118 = 0u;
        long long v115 = 0u;
        long long v116 = 0u;
        id v93 = v17;
        uint64_t v26 = [v93 countByEnumeratingWithState:&v115 objects:v127 count:16];
        if (v26)
        {
          uint64_t v27 = v26;
          uint64_t v28 = *(void *)v116;
          do
          {
            for (uint64_t i = 0; i != v27; ++i)
            {
              if (*(void *)v116 != v28) {
                objc_enumerationMutation(v93);
              }
              __int16 v30 = *(void **)(*((void *)&v115 + 1) + 8 * i);
              id v31 = [v8 serviceDescriptionsForEndpoint:v30];
              uint64_t v32 = (void *)MEMORY[0x2533B64D0]();
              uint64_t v33 = a1;
              id v34 = *(id *)(a1 + 32);
              uint64_t v35 = HMFGetOSLogHandle();
              if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
              {
                uint64_t v36 = HMFGetLogIdentifier();
                *(_DWORD *)buf = 138543874;
                v129 = v36;
                __int16 v130 = 2112;
                uint64_t v131 = (uint64_t)v31;
                __int16 v132 = 2112;
                uint64_t v133 = (uint64_t)v30;
                _os_log_impl(&dword_252495000, v35, OS_LOG_TYPE_INFO, "%{public}@Retrieved service description @%@ at endpoint %@", buf, 0x20u);

                id v8 = v92;
              }

              if (v31)
              {
                [v96 addObjectsFromArray:v31];
                __int16 v37 = [v30 stringValue];
                [v94 addObject:v37];
              }
              a1 = v33;
            }
            uint64_t v27 = [v93 countByEnumeratingWithState:&v115 objects:v127 count:16];
          }
          while (v27);
        }

        if (v96) {
          [v88 setObject:v96 forKey:v87];
        }

        uint64_t v13 = v91 + 1;
      }
      while (v91 + 1 != v86);
      uint64_t v86 = [obj countByEnumeratingWithState:&v119 objects:v134 count:16];
    }
    while (v86);
  }

  long long v113 = 0u;
  long long v114 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  id v38 = v94;
  uint64_t v39 = [v38 countByEnumeratingWithState:&v111 objects:v126 count:16];
  if (v39)
  {
    uint64_t v40 = v39;
    uint64_t v41 = *(void *)v112;
    do
    {
      for (uint64_t j = 0; j != v40; ++j)
      {
        if (*(void *)v112 != v41) {
          objc_enumerationMutation(v38);
        }
        [v88 removeObjectForKey:*(void *)(*((void *)&v111 + 1) + 8 * j)];
      }
      uint64_t v40 = [v38 countByEnumeratingWithState:&v111 objects:v126 count:16];
    }
    while (v40);
  }

  if ([v88 count] || a3)
  {
    __int16 v48 = [HMMTRDeviceTopology alloc];
    id v49 = [*(id *)(a1 + 32) nodeID];
    uint64_t v50 = [(HMMTRDeviceTopology *)v48 initWithNodeId:v49 server:*(void *)(a1 + 32)];

    uint64_t v51 = *(void **)(a1 + 32);
    if (a3)
    {
      uint64_t v52 = [v51 hapEnumerator];
      uint64_t v53 = [*(id *)(a1 + 32) primaryAccessory];
      v125 = v53;
      char v54 = [MEMORY[0x263EFF8C0] arrayWithObjects:&v125 count:1];
      id v55 = [v52 enumerateBridgedAccessoriesFromAccessories:v54 serviceDescriptionsDictionary:v88 namesDictionary:v84 topology:v50 server:*(void *)(a1 + 32) legacyInstanceIDAssignment:0];

      [*(id *)(a1 + 32) setAccessories:v55];
      id v56 = [*(id *)(a1 + 32) _distinctEndpointsHavingHapServicesForTopology:v50];
      long long v107 = 0u;
      long long v108 = 0u;
      long long v109 = 0u;
      long long v110 = 0u;
      uint64_t v57 = [v56 countByEnumeratingWithState:&v107 objects:v124 count:16];
      if (v57)
      {
        uint64_t v58 = v57;
        uint64_t v59 = *(void *)v108;
        id v60 = &unk_2702B5B68;
        id v8 = v92;
        do
        {
          for (uint64_t k = 0; k != v58; ++k)
          {
            if (*(void *)v108 != v59) {
              objc_enumerationMutation(v56);
            }
            [*(id *)(a1 + 32) _updateDefaultEntriesForBridgedClusterIDCharacteristicMap:*(void *)(*((void *)&v107 + 1) + 8 * k)];
          }
          uint64_t v58 = [v56 countByEnumeratingWithState:&v107 objects:v124 count:16];
        }
        while (v58);
      }
      else
      {
        id v60 = &unk_2702B5B68;
        id v8 = v92;
      }
    }
    else
    {
      [v51 _initAccessoriesForServer];
      uint64_t v62 = [*(id *)(a1 + 32) hapEnumerator];
      long long v63 = [*(id *)(a1 + 32) primaryAccessory];
      long long v64 = [v63 services];
      long long v65 = [*(id *)(a1 + 32) nodeID];
      long long v66 = [*(id *)(a1 + 32) primaryAccessory];
      id v55 = [v62 enumerateServicesFromServices:v64 serviceDescriptionsDictionary:v88 topology:v50 nodeID:v65 primaryAccessory:v66 legacyInstanceIDAssignment:0];

      if (v55)
      {
        long long v67 = [*(id *)(a1 + 32) primaryAccessory];
        [v67 setServices:v55];
      }
      long long v105 = 0u;
      long long v106 = 0u;
      long long v103 = 0u;
      long long v104 = 0u;
      id v56 = obj;
      uint64_t v68 = [v56 countByEnumeratingWithState:&v103 objects:v123 count:16];
      id v8 = v92;
      if (v68)
      {
        uint64_t v69 = v68;
        id v95 = v55;
        id v97 = v50;
        uint64_t v70 = a1;
        long long v71 = 0;
        uint64_t v72 = *(void *)v104;
        while (2)
        {
          for (uint64_t m = 0; m != v69; ++m)
          {
            if (*(void *)v104 != v72) {
              objc_enumerationMutation(v56);
            }
            uint64_t v74 = *(void **)(v70 + 32);
            id v75 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(*(id *)(*((void *)&v103 + 1) + 8 * m), "integerValue"));
            uint64_t v76 = [v74 _categoryFromAccessoryInfo:v92 endpoint:v75];

            if (v76)
            {
              id v60 = v76;

              if (([v60 isEqual:&unk_2702B59D0] & 1) == 0)
              {

                id v8 = v92;
                goto LABEL_62;
              }
              long long v71 = v60;
            }
            id v8 = v92;
          }
          uint64_t v69 = [v56 countByEnumeratingWithState:&v103 objects:v123 count:16];
          if (v69) {
            continue;
          }
          break;
        }
        id v60 = v71;
LABEL_62:
        a1 = v70;
        id v55 = v95;
        uint64_t v50 = v97;
      }
      else
      {
        id v60 = 0;
      }
    }

    [*(id *)(a1 + 32) _setCategoryForPrimaryAccessory:v60];
    id v77 = *(void **)(a1 + 32);
    uint64_t v78 = [v77 matterDevice];
    v101[0] = MEMORY[0x263EF8330];
    v101[1] = 3221225472;
    v101[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_732;
    v101[3] = &unk_265378578;
    uint64_t v79 = *(void **)(a1 + 40);
    v101[4] = *(void *)(a1 + 32);
    id v102 = v79;
    [v77 _createFirmwareUpdateServiceWithInstanceID:10 device:v78 completionHandler:v101];

    __int16 v46 = v80;
    id v47 = v81;
  }
  else
  {
    uint64_t v43 = *(void **)(a1 + 32);
    unsigned int v44 = [v43 matterDevice];
    v98[0] = MEMORY[0x263EF8330];
    v98[1] = 3221225472;
    v98[2] = __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_733;
    v98[3] = &unk_265377368;
    uint64_t v45 = *(void **)(a1 + 40);
    v98[4] = *(void *)(a1 + 32);
    id v100 = v45;
    __int16 v46 = v80;
    id v99 = v80;
    [v43 _createFirmwareUpdateServiceWithInstanceID:10 device:v44 completionHandler:v98];

    id v47 = v81;
  }
  [*(id *)(a1 + 32) setServiceEnumerationInProgress:0];
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_735(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    BOOL v5 = HMFGetLogIdentifier();
    int v6 = 138543362;
    int v7 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Queued accessory operation for MTRDevice caching for deferred full service enumeration is executed", (uint8_t *)&v6, 0xCu);
  }
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_736(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  int v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    int v7 = HMFGetLogIdentifier();
    int v8 = 138543618;
    BOOL v9 = v7;
    __int16 v10 = 2112;
    id v11 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Accessory operation for MTRDevice caching for deferred full service enumeration completes with error: %@", (uint8_t *)&v8, 0x16u);
  }
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_732(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    int v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v7 = HMFGetLogIdentifier();
      int v8 = 138543618;
      BOOL v9 = v7;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Firmware update service not created: %@", (uint8_t *)&v8, 0x16u);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_733(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    int v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v7 = HMFGetLogIdentifier();
      int v8 = 138543618;
      BOOL v9 = v7;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Firmware update service not created: %@", (uint8_t *)&v8, 0x16u);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

uint64_t __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v4 = NSNumber;
  id v5 = a3;
  int v6 = objc_msgSend(v4, "numberWithInteger:", objc_msgSend(a2, "integerValue"));
  int v7 = NSNumber;
  uint64_t v8 = [v5 integerValue];

  BOOL v9 = [v7 numberWithInteger:v8];
  uint64_t v10 = [v6 compare:v9];

  return v10;
}

void __73__HMMTRAccessoryServer__rebuildHAPServicesFromCHIPWithCompletionHandler___block_invoke_722(uint64_t a1, void *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  int v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    int v7 = HMFGetLogIdentifier();
    int v9 = 138543618;
    uint64_t v10 = v7;
    __int16 v11 = 2112;
    id v12 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Characteristic values updated, error: %@", (uint8_t *)&v9, 0x16u);
  }
  uint64_t v8 = *(void *)(a1 + 48);
  if (v8) {
    (*(void (**)(uint64_t, void))(v8 + 16))(v8, *(void *)(a1 + 40));
  }
}

- (void)updateAllCharacteristicValuesPostHAPServiceEnumeration:(id)a3
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  id v20 = a3;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = self;
  int v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    int v7 = HMFGetLogIdentifier();
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Updating all characteristic values from MTRDevice cache", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v8 = dispatch_group_create();
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v42 = 0x3032000000;
  uint64_t v43 = __Block_byref_object_copy__8456;
  unsigned int v44 = __Block_byref_object_dispose__8457;
  id v45 = 0;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  int v9 = [(HMMTRAccessoryServer *)v5 primaryAccessory];
  id obj = [v9 services];

  uint64_t v10 = [obj countByEnumeratingWithState:&v35 objects:v40 count:16];
  if (v10)
  {
    uint64_t v22 = *(void *)v36;
    do
    {
      uint64_t v11 = 0;
      uint64_t v23 = v10;
      do
      {
        if (*(void *)v36 != v22) {
          objc_enumerationMutation(obj);
        }
        id v12 = *(void **)(*((void *)&v35 + 1) + 8 * v11);
        long long v31 = 0u;
        long long v32 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        uint64_t v13 = [v12 characteristics];
        uint64_t v14 = [v13 countByEnumeratingWithState:&v31 objects:v39 count:16];
        uint64_t v24 = v11;
        if (v14)
        {
          uint64_t v15 = *(void *)v32;
          do
          {
            uint64_t v16 = 0;
            do
            {
              if (*(void *)v32 != v15) {
                objc_enumerationMutation(v13);
              }
              uint64_t v17 = *(void *)(*((void *)&v31 + 1) + 8 * v16);
              dispatch_group_enter(v8);
              v28[0] = MEMORY[0x263EF8330];
              v28[1] = 3221225472;
              v28[2] = __79__HMMTRAccessoryServer_updateAllCharacteristicValuesPostHAPServiceEnumeration___block_invoke;
              v28[3] = &unk_265377A00;
              void v28[4] = v5;
              void v28[5] = v17;
              p_long long buf = &buf;
              __int16 v29 = v8;
              [(HMMTRAccessoryServer *)v5 _readCharacteristicValueFromCacheWithCharacteristic:v17 responseHandler:v28];

              ++v16;
            }
            while (v14 != v16);
            uint64_t v14 = [v13 countByEnumeratingWithState:&v31 objects:v39 count:16];
          }
          while (v14);
        }

        uint64_t v11 = v24 + 1;
      }
      while (v24 + 1 != v23);
      uint64_t v10 = [obj countByEnumeratingWithState:&v35 objects:v40 count:16];
    }
    while (v10);
  }

  id v18 = [(HAPAccessoryServer *)v5 clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __79__HMMTRAccessoryServer_updateAllCharacteristicValuesPostHAPServiceEnumeration___block_invoke_721;
  block[3] = &unk_2653784B0;
  id v26 = v20;
  uint64_t v27 = &buf;
  id v19 = v20;
  dispatch_group_notify(v8, v18, block);

  _Block_object_dispose(&buf, 8);
}

void __79__HMMTRAccessoryServer_updateAllCharacteristicValuesPostHAPServiceEnumeration___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    id v5 = [v3 error];

    if (!v5)
    {
      uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
      id v16 = *(id *)(a1 + 32);
      uint64_t v17 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        id v18 = HMFGetLogIdentifier();
        id v19 = [*(id *)(a1 + 40) type];
        id v20 = [v4 value];
        int v21 = 138543874;
        uint64_t v22 = v18;
        __int16 v23 = 2112;
        uint64_t v24 = v19;
        __int16 v25 = 2112;
        id v26 = v20;
        _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_DEBUG, "%{public}@Updated value for characteristic type: %@, value: %@", (uint8_t *)&v21, 0x20u);
      }
      uint64_t v14 = [v4 value];
      [*(id *)(a1 + 40) setValue:v14];
      goto LABEL_11;
    }
  }
  int v6 = (void *)MEMORY[0x2533B64D0]();
  id v7 = *(id *)(a1 + 32);
  uint64_t v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    int v9 = HMFGetLogIdentifier();
    uint64_t v10 = [*(id *)(a1 + 40) type];
    int v21 = 138543618;
    uint64_t v22 = v9;
    __int16 v23 = 2112;
    uint64_t v24 = v10;
    _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Value update failed for characteristic type: %@", (uint8_t *)&v21, 0x16u);
  }
  if (v4)
  {
    uint64_t v11 = [v4 error];

    if (v11)
    {
      uint64_t v12 = [v4 error];
      uint64_t v13 = *(void *)(*(void *)(a1 + 56) + 8);
      uint64_t v14 = *(void **)(v13 + 40);
      *(void *)(v13 + 40) = v12;
LABEL_11:
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

uint64_t __79__HMMTRAccessoryServer_updateAllCharacteristicValuesPostHAPServiceEnumeration___block_invoke_721(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
}

- (void)enumerateHAPServices:(id)a3
{
  id v4 = a3;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  v7[2] = __45__HMMTRAccessoryServer_enumerateHAPServices___block_invoke;
  v7[3] = &unk_2653770F0;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __45__HMMTRAccessoryServer_enumerateHAPServices___block_invoke(uint64_t a1)
{
  int v2 = [*(id *)(a1 + 32) fullServiceEnumerationPendingCachePrimedEvent];
  id v3 = *(void **)(a1 + 32);
  if (v2)
  {
    id v5 = [*(id *)(a1 + 32) serviceEnumerationFromDeviceCompletionHandlers];
    id v4 = (void *)MEMORY[0x2533B66E0](*(void *)(a1 + 40));
    [v5 addObject:v4];
  }
  else
  {
    v6[0] = MEMORY[0x263EF8330];
    v6[1] = 3221225472;
    v6[2] = __45__HMMTRAccessoryServer_enumerateHAPServices___block_invoke_2;
    v6[3] = &unk_265378578;
    v6[4] = v3;
    id v7 = *(id *)(a1 + 40);
    [v3 _rebuildHAPServicesFromCHIPWithCompletionHandler:v6];
  }
}

void __45__HMMTRAccessoryServer_enumerateHAPServices___block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  id v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v8 = HMFGetLogIdentifier();
      int v15 = 138543618;
      id v16 = v8;
      __int16 v17 = 2112;
      id v18 = v3;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to rebuild HAP services of CHIP Accessory with error %@", (uint8_t *)&v15, 0x16u);
    }
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v9 = HMFGetLogIdentifier();
      int v15 = 138543362;
      id v16 = v9;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Triggering a discovery for Accessory server after enumerating...", (uint8_t *)&v15, 0xCu);
    }
    uint64_t v10 = (void *)MEMORY[0x2533B64D0]();
    id v11 = *(id *)(a1 + 32);
    uint64_t v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      uint64_t v13 = HMFGetLogIdentifier();
      uint64_t v14 = [*(id *)(a1 + 32) clusterIDCharacteristicMap];
      int v15 = 138543618;
      id v16 = v13;
      __int16 v17 = 2112;
      id v18 = v14;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_INFO, "%{public}@clusterIDCharacteristicMap : %@", (uint8_t *)&v15, 0x16u);
    }
    [*(id *)(a1 + 32) discoverAccessories];
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

- (id)_distinctEndpointsHavingHapServicesForTopology:(id)a3
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  id v3 = [a3 hapServiceTypes];
  id v4 = (void *)MEMORY[0x263EFF980];
  id v5 = [v3 allKeys];
  id v6 = [v4 arrayWithArray:v5];

  id v7 = objc_alloc_init(MEMORY[0x263EFF980]);
  [v6 sortUsingComparator:&__block_literal_global_720];
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v8 = v6;
  uint64_t v9 = [v8 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = *(void *)v16;
    do
    {
      for (uint64_t i = 0; i != v10; ++i)
      {
        if (*(void *)v16 != v11) {
          objc_enumerationMutation(v8);
        }
        uint64_t v13 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(*(id *)(*((void *)&v15 + 1) + 8 * i), "integerValue", (void)v15));
        if (([v7 containsObject:v13] & 1) == 0) {
          [v7 addObject:v13];
        }
      }
      uint64_t v10 = [v8 countByEnumeratingWithState:&v15 objects:v19 count:16];
    }
    while (v10);
  }

  return v7;
}

uint64_t __71__HMMTRAccessoryServer__distinctEndpointsHavingHapServicesForTopology___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4 = NSNumber;
  id v5 = a3;
  id v6 = objc_msgSend(v4, "numberWithInteger:", objc_msgSend(a2, "integerValue"));
  id v7 = NSNumber;
  uint64_t v8 = [v5 integerValue];

  uint64_t v9 = [v7 numberWithInteger:v8];
  uint64_t v10 = [v6 compare:v9];

  return v10;
}

- (void)_createFirmwareUpdateServiceWithInstanceID:(int64_t)a3 device:(id)a4 completionHandler:(id)a5
{
  id v8 = a4;
  id v9 = a5;
  v19[0] = 0;
  v19[1] = v19;
  v19[2] = 0x2020000000;
  v19[3] = a3;
  uint64_t v10 = [HMMTRDeviceTopology alloc];
  uint64_t v11 = [(HMMTRAccessoryServer *)self nodeID];
  uint64_t v12 = [(HMMTRDeviceTopology *)v10 initWithNodeId:v11 server:self];

  uint64_t v13 = [(HAPAccessoryServer *)self clientQueue];
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = __92__HMMTRAccessoryServer__createFirmwareUpdateServiceWithInstanceID_device_completionHandler___block_invoke;
  v15[3] = &unk_2653779B8;
  id v14 = v9;
  void v15[4] = self;
  id v16 = v14;
  long long v17 = v19;
  int64_t v18 = a3;
  [(HMMTRAccessoryServer *)self _endpointForOTARequestorWithTopology:v12 mtrDevice:v8 callbackQueue:v13 completionHandler:v15];

  _Block_object_dispose(v19, 8);
}

void __92__HMMTRAccessoryServer__createFirmwareUpdateServiceWithInstanceID_device_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else if (v5)
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = HMFGetLogIdentifier();
      uint64_t v11 = *(void *)(a1 + 56);
      *(_DWORD *)long long buf = 138543874;
      long long v64 = v10;
      __int16 v65 = 2048;
      uint64_t v66 = v11;
      __int16 v67 = 2112;
      id v68 = v5;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_INFO, "%{public}@Create firmware update service using instanceID: %lu for endpoint: %@", buf, 0x20u);
    }
    uint64_t v12 = [MEMORY[0x263F359E8] getSharedInstance];
    uint64_t v13 = [v12 getDefaultCharacteristicMetadata:@"00000234-0000-1000-8000-0026BB765291"];
    id v14 = [v12 getDefaultCharacteristicProperties:@"00000234-0000-1000-8000-0026BB765291"];
    uint64_t v15 = [v14 integerValue];

    uint64_t v53 = *(void *)(a1 + 56);
    id v57 = objc_alloc_init(MEMORY[0x263F359A8]);
    id v62 = 0;
    id v55 = [v57 serializeWithError:&v62];
    id v56 = v5;
    id v16 = v62;
    id v17 = objc_alloc(MEMORY[0x263F358C8]);
    int64_t v18 = NSNumber;
    ++*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    uint64_t v19 = objc_msgSend(v18, "numberWithInteger:");
    uint64_t v59 = (void *)[v17 initWithType:@"00000234-0000-1000-8000-0026BB765291" instanceID:v19 value:v55 stateNumber:0 properties:v15 eventNotificationsEnabled:1 metadata:v13];

    uint64_t v58 = v12;
    uint64_t v20 = [v12 getDefaultCharacteristicMetadata:@"00000235-0000-1000-8000-0026BB765291"];

    int v21 = [v12 getDefaultCharacteristicProperties:@"00000235-0000-1000-8000-0026BB765291"];
    uint64_t v22 = [v21 integerValue];

    id v54 = objc_alloc_init(MEMORY[0x263F359B0]);
    id v61 = v16;
    uint64_t v52 = [v54 serializeWithError:&v61];
    id v23 = v61;

    id v24 = objc_alloc(MEMORY[0x263F358C8]);
    __int16 v25 = NSNumber;
    ++*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    id v26 = objc_msgSend(v25, "numberWithInteger:");
    uint64_t v27 = (void *)[v24 initWithType:@"00000235-0000-1000-8000-0026BB765291" instanceID:v26 value:v52 stateNumber:0 properties:v22 eventNotificationsEnabled:1 metadata:v20];

    uint64_t v50 = [v58 getDefaultCharacteristicMetadata:@"0000026E-0000-1000-8000-0026BB765291"];

    uint64_t v28 = [v58 getDefaultCharacteristicProperties:@"0000026E-0000-1000-8000-0026BB765291"];
    uint64_t v29 = [v28 integerValue];

    id v51 = objc_alloc_init(MEMORY[0x263F359E0]);
    id v60 = v23;
    uint64_t v30 = [v51 serializeWithError:&v60];
    id v49 = v60;

    id v31 = objc_alloc(MEMORY[0x263F358C8]);
    long long v32 = NSNumber;
    ++*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    long long v33 = objc_msgSend(v32, "numberWithInteger:");
    long long v34 = (void *)v30;
    long long v35 = (void *)[v31 initWithType:@"0000026E-0000-1000-8000-0026BB765291" instanceID:v33 value:v30 stateNumber:0 properties:v29 eventNotificationsEnabled:1 metadata:v50];

    long long v36 = objc_msgSend(MEMORY[0x263EFF8C0], "arrayWithObjects:", v59, v27, v35, 0);
    long long v37 = [v58 getDefaultServiceProperties:@"00000236-0000-1000-8000-0026BB765291"];
    uint64_t v38 = [v37 integerValue];

    id v39 = objc_alloc(MEMORY[0x263F35A98]);
    uint64_t v40 = [NSNumber numberWithInteger:v53];
    uint64_t v41 = (void *)[v39 initWithType:@"00000236-0000-1000-8000-0026BB765291" instanceID:v40 parsedCharacteristics:v36 serviceProperties:v38 linkedServices:0];

    uint64_t v42 = [*(id *)(a1 + 32) primaryAccessory];
    [v41 setAccessory:v42];

    uint64_t v43 = [*(id *)(a1 + 32) primaryAccessory];
    unsigned int v44 = [v43 services];

    id v45 = [MEMORY[0x263EFF980] arrayWithObject:v41];
    [v45 addObjectsFromArray:v44];
    uint64_t v46 = [*(id *)(a1 + 32) primaryAccessory];
    [v46 setServices:v45];

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    id v5 = v56;
  }
  else
  {
    uint64_t v47 = *(void *)(a1 + 40);
    __int16 v48 = [MEMORY[0x263F087E8] hmfErrorWithCode:2];
    (*(void (**)(uint64_t, void *))(v47 + 16))(v47, v48);
  }
}

- (void)_endpointForOTARequestorWithTopology:(id)a3 mtrDevice:(id)a4 callbackQueue:(id)a5 completionHandler:(id)a6
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  uint64_t v13 = (void (**)(id, void *, void))a6;
  id v14 = [v10 getOTARequestorEndpoints];
  if (v14)
  {
    uint64_t v15 = [v10 getVersionForKey:@"EnumeratedProtocolMap"];
    int v16 = [v15 intValue];

    if (v16 > 100)
    {
      int64_t v18 = [v10 getEnabledOTARequestorEndpoint];
      if (v18)
      {
        v13[2](v13, v18, 0);
      }
      else
      {
        id v23 = [MEMORY[0x263F087E8] hmfErrorWithCode:2];
        ((void (**)(id, void *, void *))v13)[2](v13, 0, v23);
      }
LABEL_11:

      goto LABEL_12;
    }
  }
  if (!v11)
  {
    uint64_t v19 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v20 = self;
    int v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v27 = v22;
      _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to get the OTA requestor endpoint", buf, 0xCu);
    }
    int64_t v18 = [MEMORY[0x263F087E8] hmfErrorWithCode:8];
    ((void (**)(id, void *, void *))v13)[2](v13, 0, v18);
    goto LABEL_11;
  }
  id v17 = +[HMMTRDescriptorClusterManager sharedManager];
  v24[0] = MEMORY[0x263EF8330];
  v24[1] = 3221225472;
  v24[2] = __103__HMMTRAccessoryServer__endpointForOTARequestorWithTopology_mtrDevice_callbackQueue_completionHandler___block_invoke;
  v24[3] = &unk_265377990;
  __int16 v25 = v13;
  [v17 endpointForClusterID:&unk_2702B5A30 mtrDevice:v11 callbackQueue:v12 completionHandler:v24];

LABEL_12:
}

uint64_t __103__HMMTRAccessoryServer__endpointForOTARequestorWithTopology_mtrDevice_callbackQueue_completionHandler___block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

- (id)_categoryFromTopology:(id)a3 endpoint:(id)a4
{
  id v5 = [a3 getHAPCategoriesAtEndpoint:a4];
  id v6 = [(HMMTRAccessoryServer *)self _getFirstNonOtherCategory:v5];

  return v6;
}

- (id)_categoryFromAccessoryInfo:(id)a3 endpoint:(id)a4
{
  id v5 = [a3 categoriesForEndpoint:a4];
  id v6 = [(HMMTRAccessoryServer *)self _getFirstNonOtherCategory:v5];

  return v6;
}

- (id)_getFirstNonOtherCategory:(id)a3
{
  v21[1] = *MEMORY[0x263EF8340];
  id v3 = a3;
  id v4 = v3;
  if (v3)
  {
    if ([v3 count] == 1)
    {
      id v5 = [v4 objectAtIndexedSubscript:0];
    }
    else
    {
      id v6 = [MEMORY[0x263F08B30] sortDescriptorWithKey:@"self" ascending:1];
      v21[0] = v6;
      id v7 = [MEMORY[0x263EFF8C0] arrayWithObjects:v21 count:1];
      id v8 = [v4 sortedArrayUsingDescriptors:v7];

      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      id v9 = v8;
      uint64_t v10 = [v9 countByEnumeratingWithState:&v16 objects:v20 count:16];
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v12 = *(void *)v17;
        while (2)
        {
          for (uint64_t i = 0; i != v11; ++i)
          {
            if (*(void *)v17 != v12) {
              objc_enumerationMutation(v9);
            }
            id v14 = *(void **)(*((void *)&v16 + 1) + 8 * i);
            if (objc_msgSend(v14, "integerValue", (void)v16) > 1)
            {
              id v5 = v14;

              goto LABEL_15;
            }
          }
          uint64_t v11 = [v9 countByEnumeratingWithState:&v16 objects:v20 count:16];
          if (v11) {
            continue;
          }
          break;
        }
      }

      id v5 = [NSNumber numberWithInt:1];
LABEL_15:
    }
  }
  else
  {
    id v5 = 0;
  }

  return v5;
}

- (void)_setCategoryForPrimaryAccessory:(id)a3
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  id v4 = a3;
  if (v4)
  {
    id v5 = (void *)MEMORY[0x2533B64D0]([(HAPAccessoryServer *)self setCategory:v4]);
    id v6 = self;
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = HMFGetLogIdentifier();
      int v9 = 138543618;
      uint64_t v10 = v8;
      __int16 v11 = 2112;
      id v12 = v4;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Set category to %@ for primary accessory", (uint8_t *)&v9, 0x16u);
    }
  }
}

- (void)disconnectWithError:(id)a3
{
  id v4 = a3;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  v7[2] = __44__HMMTRAccessoryServer_disconnectWithError___block_invoke;
  v7[3] = &unk_265376E98;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

uint64_t __44__HMMTRAccessoryServer_disconnectWithError___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _disconnectWithError:*(void *)(a1 + 40)];
}

- (void)disconnect
{
}

- (void)_disconnectWithError:(id)a3
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  id v4 = a3;
  if ([(HMMTRAccessoryServer *)self isPaired])
  {
    if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
    {
      id v5 = (void *)MEMORY[0x2533B64D0]();
      id v6 = self;
      id v7 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        id v8 = HMFGetLogIdentifier();
        int v16 = 138543618;
        long long v17 = v8;
        __int16 v18 = 2112;
        long long v19 = v6;
        _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Keeping CHIP link alive for accessory:%@ till invalidated", (uint8_t *)&v16, 0x16u);
      }
    }
    else
    {
      int v9 = [(HMMTRAccessoryServer *)self browser];
      char v10 = [v9 isCurrentDevicePrimaryResident];

      if ((v10 & 1) == 0)
      {
        __int16 v11 = (void *)MEMORY[0x2533B64D0]();
        id v12 = self;
        uint64_t v13 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
        {
          id v14 = HMFGetLogIdentifier();
          int v16 = 138543618;
          long long v17 = v14;
          __int16 v18 = 2112;
          long long v19 = v12;
          _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Terminating CHIP link for accessory:%@. Only the Primary Resident may communicate with it now.", (uint8_t *)&v16, 0x16u);
        }
        uint64_t v15 = [(HMMTRAccessoryServer *)v12 controllerWrapper];
        [(HMMTRAccessoryServer *)v12 disable];
        [v15 suspendOrShutdown];
      }
    }
  }
}

- (void)finishPairing
{
  id v3 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __37__HMMTRAccessoryServer_finishPairing__block_invoke;
  block[3] = &unk_265378638;
  void block[4] = self;
  dispatch_async(v3, block);
}

void __37__HMMTRAccessoryServer_finishPairing__block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    uint64_t v15 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Finishing pairing now", buf, 0xCu);
  }
  [*(id *)(a1 + 32) _persistAccessoryServerData];
  [*(id *)(a1 + 32) _disconnectWithError:0];
  [*(id *)(a1 + 32) _finishMaximumDurationCollection];
  if ([*(id *)(a1 + 32) shouldPairWithoutResident])
  {
    id v6 = [*(id *)(a1 + 32) storage];
    id v7 = [v6 fabricDataSource];
    id v8 = [*(id *)(a1 + 32) nodeID];
    int v9 = [v7 storageDataSourceForDeviceWithNodeID:v8];
    char v10 = [*(id *)(a1 + 32) vendorID];
    __int16 v11 = [*(id *)(a1 + 32) productID];
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 3221225472;
    v13[2] = __37__HMMTRAccessoryServer_finishPairing__block_invoke_705;
    v13[3] = &unk_265376E00;
    void v13[4] = *(void *)(a1 + 32);
    [v9 updateVendorID:v10 productID:v11 completion:v13];
  }
  [*(id *)(a1 + 32) setDelayDiscovery:0];
  id v12 = [*(id *)(a1 + 32) browser];
  objc_msgSend(v12, "didFinishPairingAccessoryServer:operationDisabled:", *(void *)(a1 + 32), objc_msgSend(*(id *)(a1 + 32), "operationDisabled"));
}

void __37__HMMTRAccessoryServer_finishPairing__block_invoke_705(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = HMFGetLogIdentifier();
      id v8 = [*(id *)(a1 + 32) vendorID];
      int v9 = [*(id *)(a1 + 32) productID];
      int v10 = 138544386;
      __int16 v11 = v7;
      __int16 v12 = 2080;
      uint64_t v13 = "-[HMMTRAccessoryServer finishPairing]_block_invoke";
      __int16 v14 = 2112;
      uint64_t v15 = v8;
      __int16 v16 = 2112;
      long long v17 = v9;
      __int16 v18 = 2112;
      id v19 = v3;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_ERROR, "%{public}@%s: Failed to update vendorID to %@ and productID to %@ with error: %@", (uint8_t *)&v10, 0x34u);
    }
  }
}

- (void)_finishMaximumDurationCollection
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v3 = (void *)MEMORY[0x2533B64D0](self, a2);
  id v4 = self;
  id v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    id v7 = [(HMMTRAccessoryServer *)v4 maxMetricDuration];
    id v8 = [v7 name];
    int v9 = [(HMMTRAccessoryServer *)v4 maxMetricDuration];
    int v10 = [v9 duration];
    *(_DWORD *)long long buf = 138544898;
    int v21 = v6;
    __int16 v22 = 2114;
    id v23 = @"hmmtrAccessoryServerPairingMaximumDuration";
    __int16 v24 = 2112;
    __int16 v25 = @"Maximum time segment of pairing";
    __int16 v26 = 2114;
    uint64_t v27 = @"hmmtrAccessoryPairingEventMaxDurationName";
    __int16 v28 = 2112;
    uint64_t v29 = v8;
    __int16 v30 = 2114;
    id v31 = @"hmmtrAccessoryPairingEventMaxDurationTimeInSeconds";
    __int16 v32 = 2112;
    long long v33 = v10;
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\"", buf, 0x48u);
  }
  __int16 v11 = [MEMORY[0x263F499E0] sharedInstance];
  id v12 = objc_alloc(MEMORY[0x263F499F0]);
  uint64_t v13 = [(HMMTRAccessoryServer *)v4 maxMetricDuration];
  __int16 v14 = [v13 name];
  uint64_t v15 = [(HMMTRAccessoryServer *)v4 maxMetricDuration];
  __int16 v16 = [v15 duration];
  long long v17 = HMDTaggedLoggingCreateDictionary();
  __int16 v18 = objc_msgSend(v12, "initWithTag:data:", @"hmmtrAccessoryServerPairingMaximumDuration", v17, @"hmmtrAccessoryPairingEventMaxDurationName", v14, @"hmmtrAccessoryPairingEventMaxDurationTimeInSeconds", v16);
  id v19 = [(HMFActivity *)v4->_activity tagProcessorList];
  [v11 submitTaggedEvent:v18 processorList:v19];

  [(HMMTRAccessoryServer *)v4 setMaxMetricDuration:0];
}

- (void)_reportPairingComplete
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  id v3 = (void *)MEMORY[0x2533B64D0](self, a2);
  id v4 = self;
  id v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543874;
    uint64_t v20 = v6;
    __int16 v21 = 2080;
    __int16 v22 = "-[HMMTRAccessoryServer _reportPairingComplete]";
    __int16 v23 = 1024;
    BOOL v24 = [(HMMTRAccessoryServer *)v4 operationDisabled];
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@%s operationDisabled = %d", buf, 0x1Cu);
  }
  if (![(HMMTRAccessoryServer *)v4 operationDisabled]) {
    [(HMMTRAccessoryServer *)v4 setDelayDiscovery:1];
  }
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled()
    && ![(HMMTRAccessoryServer *)v4 operationDisabled]
    && ![(HMMTRAccessoryServer *)v4 knownToSystemCommissioner])
  {
    id v7 = (void *)[objc_alloc(MEMORY[0x263F42658]) initWithTimeInterval:0 options:60.0];
    [(HMMTRAccessoryServer *)v4 setResidentReachabilityUpdateWaitTimer:v7];

    id v8 = [(HAPAccessoryServer *)v4 clientQueue];
    int v9 = [(HMMTRAccessoryServer *)v4 residentReachabilityUpdateWaitTimer];
    [v9 setDelegateQueue:v8];

    int v10 = [(HMMTRAccessoryServer *)v4 residentReachabilityUpdateWaitTimer];
    [v10 setDelegate:v4];

    __int16 v11 = [(HMMTRAccessoryServer *)v4 residentReachabilityUpdateWaitTimer];
    [v11 resume];

    id v12 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v13 = v4;
    __int16 v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      uint64_t v15 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v20 = v15;
      _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_INFO, "%{public}@Kicked off timer to stay active while resident updates reachability state", buf, 0xCu);
    }
  }
  [(HMMTRAccessoryServer *)v4 setPairingProgress:4];
  __int16 v16 = [(HAPAccessoryServer *)v4 delegateQueue];

  if (v16)
  {
    long long v17 = [(HAPAccessoryServer *)v4 delegateQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __46__HMMTRAccessoryServer__reportPairingComplete__block_invoke;
    block[3] = &unk_265378638;
    void block[4] = v4;
    dispatch_async(v17, block);
  }
}

void __46__HMMTRAccessoryServer__reportPairingComplete__block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  int v2 = [*(id *)(a1 + 32) delegate];
  if ([v2 conformsToProtocol:&unk_2702F5258]) {
    id v3 = v2;
  }
  else {
    id v3 = 0;
  }
  id v4 = v3;

  if (v4)
  {
    [v4 accessoryServer:*(void *)(a1 + 32) didStopPairingWithError:0 matterPairingEndContext:0];
  }
  else
  {
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = *(id *)(a1 + 32);
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v8 = HMFGetLogIdentifier();
      int v9 = 138543362;
      int v10 = v8;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_ERROR, "%{public}@Unable to find delegate confirming to HMMTRHAPAccessoryServerPairingDelegate", (uint8_t *)&v9, 0xCu);
    }
  }
}

- (void)_finalizePairing
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  v29[0] = MEMORY[0x263EF8330];
  v29[1] = 3221225472;
  v29[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke;
  v29[3] = &unk_265378638;
  v29[4] = self;
  id v3 = (void (**)(void))MEMORY[0x2533B66E0](v29, a2);
  v27[0] = 0;
  v27[1] = v27;
  v27[2] = 0x2020000000;
  char v28 = 0;
  v25[0] = 0;
  v25[1] = v25;
  v25[2] = 0x3032000000;
  v25[3] = __Block_byref_object_copy__8456;
  v25[4] = __Block_byref_object_dispose__8457;
  id v26 = 0;
  id v4 = dispatch_group_create();
  [(HMMTRAccessoryServer *)self setBlockInvalidation:1];
  if ([(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    dispatch_group_enter(v4);
    v23[0] = MEMORY[0x263EF8330];
    v23[1] = 3221225472;
    v23[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2;
    void v23[3] = &unk_265378660;
    uint8_t v23[4] = self;
    BOOL v24 = v4;
    [(HMMTRAccessoryServer *)self _fetchSerialNumberWithCompletionHandler:v23];
  }
  [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:9];
  dispatch_group_enter(v4);
  id v5 = [(HMMTRAccessoryServer *)self populateACLEntriesForPairing];
  id v6 = [v5 objectForKeyedSubscript:@"adminNodesForPairing"];
  id v7 = [v5 objectForKeyedSubscript:@"regularNodesForPairing"];
  v19[0] = MEMORY[0x263EF8330];
  v19[1] = 3221225472;
  v19[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_597;
  v19[3] = &unk_265377940;
  void v19[4] = self;
  __int16 v21 = v27;
  __int16 v22 = v25;
  id v8 = v4;
  uint64_t v20 = v8;
  [(HMMTRAccessoryServer *)self updateAccessoryControlToAdministratorNodes:v6 sharedUserNodes:v7 completion:v19];
  int v9 = [(HAPAccessoryServer *)self delegateQueue];

  if (v9)
  {
    int v10 = [(HAPAccessoryServer *)self delegateQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_604;
    block[3] = &unk_265377968;
    void block[4] = self;
    long long v17 = v27;
    __int16 v18 = v25;
    __int16 v16 = v3;
    dispatch_group_notify(v8, v10, block);
  }
  else
  {
    uint64_t v11 = (void *)MEMORY[0x2533B64D0]();
    id v12 = self;
    HMFGetOSLogHandle();
    uint64_t v13 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      __int16 v14 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v31 = v14;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_ERROR, "%{public}@Browser died. Updating paired state but the accessory server must be removed soon.", buf, 0xCu);
    }
    v3[2](v3);
  }

  _Block_object_dispose(v25, 8);
  _Block_object_dispose(v27, 8);
}

uint64_t __40__HMMTRAccessoryServer__finalizePairing__block_invoke(uint64_t a1)
{
  [*(id *)(a1 + 32) setStorageUpdatePending:1];
  [*(id *)(a1 + 32) setPairedState:3];
  int v2 = *(void **)(a1 + 32);
  return [v2 setSecuritySessionOpen:1];
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = HMFGetLogIdentifier();
      int v8 = 138543618;
      int v9 = v7;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch serial number of CHIP Accessory with error %@", (uint8_t *)&v8, 0x16u);
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_597(uint64_t a1, void *a2)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v3;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to update Access control List on device %@", buf, 0x16u);
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
    if (objc_msgSend(v3, "hmmtr_isMatterError")) {
      +[HMMTRAccessoryPairingEndContext mtrContextWithStep:9 error:v3];
    }
    else {
    uint64_t v8 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:9 error:v3];
    }
    uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8);
    __int16 v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;
  }
  dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
  id v11 = *(void **)(a1 + 32);
  v36[0] = MEMORY[0x263EF8330];
  v36[1] = 3221225472;
  v36[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_598;
  v36[3] = &unk_2653778A0;
  void v36[4] = v11;
  id v37 = *(id *)(a1 + 40);
  [v11 _fetchCurrentPairingWithCompletionHandler:v36];
  int v12 = [*(id *)(a1 + 32) knownToSystemCommissioner];
  uint64_t v13 = *(void **)(a1 + 32);
  if (v12)
  {
    __int16 v14 = [v13 category];
    BOOL v15 = v14 == 0;

    if (v15)
    {
      [*(id *)(a1 + 32) _notifyDelegateOfPairingStep:11];
      dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
      id v26 = *(void **)(a1 + 32);
      v34[0] = MEMORY[0x263EF8330];
      v34[1] = 3221225472;
      void v34[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_599;
      v34[3] = &unk_265378660;
      v34[4] = v26;
      id v35 = *(id *)(a1 + 40);
      [v26 _buildHAPCategoriesFromCHIPWithCompletionHandler:v34];
    }
    else
    {
      __int16 v16 = (void *)MEMORY[0x2533B64D0]();
      id v17 = *(id *)(a1 + 32);
      __int16 v18 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        id v19 = HMFGetLogIdentifier();
        uint64_t v20 = [*(id *)(a1 + 32) category];
        *(_DWORD *)long long buf = 138543618;
        *(void *)&uint8_t buf[4] = v19;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v20;
        _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_INFO, "%{public}@Inherited accessory category: %@", buf, 0x16u);
      }
    }
  }
  else
  {
    [v13 _notifyDelegateOfPairingStep:12];
    dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
    *(void *)long long buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v39 = 0;
    v30[0] = MEMORY[0x263EF8330];
    v30[1] = 3221225472;
    v30[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_600;
    v30[3] = &unk_2653778F0;
    uint64_t v21 = *(void *)(a1 + 32);
    uint64_t v32 = buf;
    void v30[4] = v21;
    id v31 = *(id *)(a1 + 40);
    long long v33 = *(_OWORD *)(a1 + 48);
    __int16 v22 = (void *)MEMORY[0x2533B66E0](v30);
    [*(id *)(a1 + 32) _rebuildHAPServicesFromCHIPWithCompletionHandler:v22];
    dispatch_time_t v23 = dispatch_time(0, 180000000000);
    BOOL v24 = [*(id *)(a1 + 32) clientQueue];
    v27[0] = MEMORY[0x263EF8330];
    v27[1] = 3221225472;
    v27[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_603;
    void v27[3] = &unk_265377918;
    id v28 = v22;
    uint64_t v29 = buf;
    v27[4] = *(void *)(a1 + 32);
    id v25 = v22;
    dispatch_after(v23, v24, v27);

    _Block_object_dispose(buf, 8);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_604(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  [*(id *)(a1 + 32) setBlockInvalidation:0];
  if (![*(id *)(a1 + 32) pairingProgress] || objc_msgSend(*(id *)(a1 + 32), "pairingProgress") == 3)
  {
    int v2 = (void *)MEMORY[0x2533B64D0]();
    id v3 = *(id *)(a1 + 32);
    id v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      id v5 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v25 = v5;
      _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Pairing already failed or stopped when accessory information collection completed", buf, 0xCu);
    }
    return;
  }
  id v6 = *(void **)(a1 + 32);
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24))
  {
    int v7 = [*(id *)(a1 + 32) knownToSystemCommissioner];
    uint64_t v8 = *(void **)(a1 + 32);
    if (v7)
    {
      uint64_t v9 = [v8 clientQueue];
      block[0] = MEMORY[0x263EF8330];
      block[1] = 3221225472;
      block[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_605;
      block[3] = &unk_2653770F0;
      id v10 = *(id *)(a1 + 40);
      void block[4] = *(void *)(a1 + 32);
      id v23 = v10;
      dispatch_async(v9, block);

      return;
    }
    id v11 = [v8 browser];
    if ([v11 isSystemCommissionerFeatureEnabled])
    {
      int v12 = [*(id *)(a1 + 32) browser];
      char v13 = [v12 isCurrentDevicePrimaryResident];

      if (v13)
      {
        __int16 v14 = 0;
LABEL_18:
        BOOL v15 = [*(id *)(a1 + 32) clientQueue];
        v19[0] = MEMORY[0x263EF8330];
        v19[1] = 3221225472;
        v19[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2_606;
        v19[3] = &unk_265378900;
        id v16 = *(id *)(a1 + 40);
        id v20 = v14;
        id v21 = v16;
        void v19[4] = *(void *)(a1 + 32);
        id v17 = v14;
        dispatch_async(v15, v19);

        return;
      }
      id v11 = [*(id *)(a1 + 32) browser];
      __int16 v14 = [v11 systemCommissionerFabricRootPublicKey];
    }
    else
    {
      __int16 v14 = 0;
    }

    goto LABEL_18;
  }
  id v18 = [MEMORY[0x263F087E8] hmfErrorWithCode:11];
  objc_msgSend(v6, "_handlePairingFailureWithError:context:");
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_605(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  [*(id *)(a1 + 32) setPairingProgress:4];
  [*(id *)(a1 + 32) _finishMaximumDurationCollection];
  [*(id *)(a1 + 32) _persistAccessoryServerData];
  int v2 = [*(id *)(a1 + 32) stageCompletion];

  if (v2)
  {
    id v3 = [*(id *)(a1 + 32) stageCompletion];
    (*((void (**)(id, uint64_t, void, void))v3 + 2))(v3, 1, *(void *)(a1 + 32), 0);
  }
}

uint64_t __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2_606(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  if ([*(id *)(a1 + 32) isKnownToSystemCommissioner])
  {
    int v2 = *(void **)(a1 + 32);
    return [v2 _reportPairingComplete];
  }
  else
  {
    id v4 = *(void **)(a1 + 32);
    if (*(void *)(a1 + 40))
    {
      return objc_msgSend(v4, "_pairOnSystemCommissionerFabricUnlessAlreadyPairedWithRootPublicKey:");
    }
    else
    {
      return [v4 _pairOnSystemCommissionerFabric];
    }
  }
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_598(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v7 && !v8 && [v7 count])
  {
    id v28 = v9;
    id v10 = [v7 firstObject];
    id v11 = [HMMTRPairing alloc];
    int v12 = [v10 nodeID];
    char v13 = [v10 fabricID];
    __int16 v14 = [v10 fabricLabel];
    BOOL v15 = [v10 rootPublicKey];
    id v16 = [v10 vendorID];
    id v17 = [v10 vendorName];
    id v18 = [(HMMTRPairing *)v11 initWithNodeID:v12 fabricID:v13 fabricLabel:v14 rootPublicKey:v15 vendorID:v16 vendorName:v17];
    [*(id *)(a1 + 32) setCurrentPairingInfo:v18];

    id v19 = (void *)MEMORY[0x2533B64D0]();
    id v20 = *(id *)(a1 + 32);
    id v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      __int16 v22 = HMFGetLogIdentifier();
      id v23 = [*(id *)(a1 + 32) currentPairingInfo];
      *(_DWORD *)long long buf = 138543618;
      __int16 v30 = v22;
      __int16 v31 = 2112;
      id v32 = v23;
      _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_INFO, "%{public}@Obtained current pairing info %@", buf, 0x16u);
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));

    id v9 = v28;
    id v8 = 0;
  }
  else
  {
    BOOL v24 = (void *)MEMORY[0x2533B64D0]();
    id v25 = *(id *)(a1 + 32);
    uint64_t v26 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      uint64_t v27 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      __int16 v30 = v27;
      __int16 v31 = 2112;
      id v32 = v8;
      _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch current pairing information %@", buf, 0x16u);
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_599(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = HMFGetLogIdentifier();
      int v8 = 138543618;
      id v9 = v7;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to build HAP categories of CHIP accessory with error %@", (uint8_t *)&v8, 0x16u);
    }
    [*(id *)(a1 + 32) _setCategoryForPrimaryAccessory:&unk_2702B59D0];
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_600(uint64_t a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v3 = a2;
  uint64_t v4 = *(void *)(*(void *)(a1 + 48) + 8);
  if (*(unsigned char *)(v4 + 24)) {
    goto LABEL_13;
  }
  *(unsigned char *)(v4 + 24) = 1;
  id v5 = [*(id *)(a1 + 32) browser];
  if ([v5 isCurrentDevicePrimaryResident])
  {

LABEL_5:
    dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
    int v8 = *(void **)(a1 + 32);
    v28[0] = MEMORY[0x263EF8330];
    v28[1] = 3221225472;
    v28[2] = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2_601;
    v28[3] = &unk_2653778C8;
    void v28[4] = v8;
    id v29 = *(id *)(a1 + 40);
    [v8 fetchSoftwareVersion:1 completionHandler:v28];

    goto LABEL_6;
  }
  id v6 = [*(id *)(a1 + 32) browser];
  int v7 = [v6 isCurrentDeviceAllowedAccessoryControlDespiteReachableResident];

  if (v7) {
    goto LABEL_5;
  }
LABEL_6:
  dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
  id v9 = *(void **)(a1 + 32);
  uint64_t v22 = MEMORY[0x263EF8330];
  uint64_t v23 = 3221225472;
  BOOL v24 = __40__HMMTRAccessoryServer__finalizePairing__block_invoke_602;
  id v25 = &unk_2653778C8;
  uint64_t v26 = v9;
  id v27 = *(id *)(a1 + 40);
  [v9 fetchSoftwareVersion:0 completionHandler:&v22];

  if (v3)
  {
    BOOL v15 = (void *)MEMORY[0x2533B64D0](v10, v11, v12, v13, v14);
    id v16 = *(id *)(a1 + 32);
    id v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      id v18 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      __int16 v31 = v18;
      __int16 v32 = 2112;
      id v33 = v3;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@Failed to rebuild HAP services of CHIP Accessory with error %@", buf, 0x16u);
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
    uint64_t v19 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:error:](HMMTRAccessoryPairingEndContext, "hmmtrContextWithStep:error:", 12, v3, v22, v23, v24, v25, v26);
    uint64_t v20 = *(void *)(*(void *)(a1 + 64) + 8);
    id v21 = *(void **)(v20 + 40);
    *(void *)(v20 + 40) = v19;
  }
  else if (objc_msgSend(*(id *)(a1 + 32), "pairedState", v22, v23, v24, v25, v26) == 2)
  {
    [*(id *)(a1 + 32) setPairedState:3];
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
LABEL_13:
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_603(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24))
  {
    int v2 = (void *)MEMORY[0x2533B64D0]();
    id v3 = *(id *)(a1 + 32);
    uint64_t v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v5 = HMFGetLogIdentifier();
      int v8 = 138543362;
      id v9 = v5;
      _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_ERROR, "%{public}@Enumerating HAPServices timed out", (uint8_t *)&v8, 0xCu);
    }
  }
  uint64_t v6 = *(void *)(a1 + 40);
  int v7 = [MEMORY[0x263F087E8] hapErrorWithCode:24];
  (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v7);
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_2_601(uint64_t a1, void *a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    int v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = HMFGetLogIdentifier();
      int v14 = 138543618;
      BOOL v15 = v10;
      __int16 v16 = 2112;
      id v17 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch software version number of CHIP Accessory with error %@", (uint8_t *)&v14, 0x16u);
    }
  }
  else if ([*(id *)(a1 + 32) pairingProgress] && objc_msgSend(*(id *)(a1 + 32), "pairingProgress") != 3)
  {
    id v11 = v5;
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0;
    }
    id v13 = v12;

    if (v13) {
      [*(id *)(a1 + 32) updateSoftwareVersion:v13];
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void __40__HMMTRAccessoryServer__finalizePairing__block_invoke_602(uint64_t a1, void *a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    int v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = HMFGetLogIdentifier();
      int v13 = 138543618;
      int v14 = v10;
      __int16 v15 = 2112;
      id v16 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch software version string of CHIP Accessory with error %@", (uint8_t *)&v13, 0x16u);
    }
  }
  else
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      id v11 = v5;
    }
    else {
      id v11 = 0;
    }
    id v12 = v11;
    [*(id *)(a1 + 32) setSoftwareVersionString:v12];
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

- (id)populateACLEntriesForPairing
{
  uint64_t v119 = *MEMORY[0x263EF8340];
  if ([(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    id v3 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v4 = self;
    id v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      id v6 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      long long v114 = v6;
      _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_DEBUG, "%{public}@Not populating ACL entries for System Commissioner pairing", buf, 0xCu);
    }
    int v7 = [NSDictionary dictionary];
  }
  else
  {
    id v8 = [MEMORY[0x263EFF980] array];
    id v9 = [MEMORY[0x263EFF980] array];
    if (isFeatureMatterLocalFabricConfigEnabled())
    {
      long long v109 = v9;
      uint64_t v10 = (void *)MEMORY[0x263F10CC0];
      id v11 = [(HMMTRAccessoryServer *)self controllerWrapper];
      id v12 = [v11 startupParams];
      int v13 = [v12 operationalCertificate];
      uint64_t v14 = [v10 convertX509Certificate:v13];

      long long v107 = (void *)v14;
      __int16 v15 = (void *)[objc_alloc(MEMORY[0x263F10CB8]) initWithTLVBytes:v14];
      id v16 = [(HMMTRAccessoryServer *)self browser];
      uint64_t v17 = [(HMMTRAccessoryServer *)self fabricID];
      uint64_t v18 = [v16 appleHomeFabricWithID:v17];

      uint64_t v19 = [v18 delegate];
      uint64_t v20 = [v19 accessoryAdministerPrivilegeCATID:0];

      long long v108 = v20;
      if (v20)
      {
        unsigned int v21 = [v20 integerValue];
        uint64_t v22 = [NSNumber numberWithUnsignedLongLong:v21 | 0xFFFFFFFD00000000];
        [v8 addObject:v22];

        uint64_t v23 = (void *)MEMORY[0x2533B64D0]();
        BOOL v24 = self;
        id v25 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
        {
          uint64_t v26 = HMFGetLogIdentifier();
          *(_DWORD *)long long buf = 138543874;
          long long v114 = v26;
          __int16 v115 = 2112;
          long long v116 = v108;
          __int16 v117 = 2048;
          uint64_t v118 = [v108 integerValue];
          _os_log_impl(&dword_252495000, v25, OS_LOG_TYPE_INFO, "%{public}@ACL: adding admin CAT %@ (0x%lX)", buf, 0x20u);
        }
      }
      id v27 = [v18 delegate];
      id v28 = [v27 accessoryOperatePrivilegeCATID:0];

      if (v28)
      {
        unsigned int v29 = [v28 integerValue];
        __int16 v30 = [NSNumber numberWithUnsignedLongLong:v29 | 0xFFFFFFFD00000000];
        [v109 addObject:v30];

        __int16 v31 = (void *)MEMORY[0x2533B64D0]();
        __int16 v32 = self;
        id v33 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
        {
          uint64_t v34 = HMFGetLogIdentifier();
          uint64_t v35 = [v28 integerValue];
          *(_DWORD *)long long buf = 138543874;
          long long v114 = v34;
          __int16 v115 = 2112;
          long long v116 = v28;
          __int16 v117 = 2048;
          uint64_t v118 = v35;
          _os_log_impl(&dword_252495000, v33, OS_LOG_TYPE_INFO, "%{public}@ACL: adding operate CAT %@ (0x%lX)", buf, 0x20u);
        }
      }
      long long v36 = [v18 delegate];
      int v37 = [v36 isCurrentUserOwner];

      if (v37 && v15)
      {
        uint64_t v38 = [v15 subject];
        char v39 = [v38 caseAuthenticatedTags];
        uint64_t v40 = [v39 allObjects];
        v112[0] = MEMORY[0x263EF8330];
        v112[1] = 3221225472;
        v112[2] = __52__HMMTRAccessoryServer_populateACLEntriesForPairing__block_invoke;
        v112[3] = &unk_265377878;
        v112[4] = self;
        uint64_t v41 = objc_msgSend(v40, "na_map:", v112);
        [v8 addObjectsFromArray:v41];
      }
      uint64_t v42 = [(HMMTRAccessoryServer *)self storage];
      int v43 = [v42 isSharedAdmin];

      if (v43)
      {
        if (v15)
        {
          unsigned int v44 = [v15 subject];
          id v45 = [v44 caseAuthenticatedTags];
          uint64_t v46 = [v45 allObjects];
          v111[0] = MEMORY[0x263EF8330];
          v111[1] = 3221225472;
          v111[2] = __52__HMMTRAccessoryServer_populateACLEntriesForPairing__block_invoke_595;
          v111[3] = &unk_265377878;
          v111[4] = self;
          uint64_t v47 = objc_msgSend(v46, "na_map:", v111);
          [v109 addObjectsFromArray:v47];
        }
        __int16 v48 = [(HMMTRAccessoryServer *)self deviceController];
        id v49 = [v48 controllerNodeID];

        if (v49)
        {
          uint64_t v50 = (void *)MEMORY[0x2533B64D0]();
          id v51 = self;
          uint64_t v52 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
          {
            uint64_t v53 = HMFGetLogIdentifier();
            uint64_t v54 = [v49 integerValue];
            *(_DWORD *)long long buf = 138543874;
            long long v114 = v53;
            __int16 v115 = 2112;
            long long v116 = v49;
            __int16 v117 = 2048;
            uint64_t v118 = v54;
            _os_log_impl(&dword_252495000, v52, OS_LOG_TYPE_INFO, "%{public}@ACL: adding current controller's NodeID %@ (0x%lX)", buf, 0x20u);
          }
          [v8 addObject:v49];
        }
      }
      id v55 = [(HMMTRAccessoryServer *)self fabricID];

      if (v55)
      {
        id v56 = [(HMMTRAccessoryServer *)self storage];
        id v57 = [v56 dataSource];
        uint64_t v58 = [(HMMTRAccessoryServer *)self pairingTargetHomeUUID];
        uint64_t v59 = [v57 appleHomeFabricWithUUID:v58];

        id v60 = [v59 fabricData];
        id v61 = [v60 residentNodeID];

        if (v61) {
          goto LABEL_28;
        }
      }
      id v62 = [(HMMTRAccessoryServer *)self storage];
      id v61 = [v62 legacyNodeIDForCurrentFabric];

      if (v61)
      {
LABEL_28:
        long long v63 = (void *)MEMORY[0x2533B64D0]();
        long long v64 = self;
        __int16 v65 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
        {
          uint64_t v66 = HMFGetLogIdentifier();
          uint64_t v67 = [v61 integerValue];
          *(_DWORD *)long long buf = 138543874;
          long long v114 = v66;
          __int16 v115 = 2112;
          long long v116 = v61;
          __int16 v117 = 2048;
          uint64_t v118 = v67;
          _os_log_impl(&dword_252495000, v65, OS_LOG_TYPE_INFO, "%{public}@ACL: adding resident's NodeID %@ (0x%lX)", buf, 0x20u);
        }
        [v8 addObject:v61];
      }
      id v68 = [(HMMTRAccessoryServer *)self controllerWrapper];
      uint64_t v69 = [v68 startupParams];
      uint64_t v70 = [v69 operationalCertificate];
      BOOL v71 = +[HMMTRAccessoryServer certificateSubjectHasCATs:v70];

      if (!v71)
      {
        uint64_t v72 = [(HMMTRAccessoryServer *)self deviceController];
        id v73 = [v72 controllerNodeID];

        if (v73 && ([v73 isEqual:v61] & 1) == 0)
        {
          uint64_t v74 = (void *)MEMORY[0x2533B64D0]();
          id v75 = self;
          uint64_t v76 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
          {
            id v77 = HMFGetLogIdentifier();
            uint64_t v78 = [v73 integerValue];
            *(_DWORD *)long long buf = 138543874;
            long long v114 = v77;
            __int16 v115 = 2112;
            long long v116 = v73;
            __int16 v117 = 2048;
            uint64_t v118 = v78;
            _os_log_impl(&dword_252495000, v76, OS_LOG_TYPE_INFO, "%{public}@ACL: adding current controller's NodeID %@ (0x%lX) because it couldn't find any CAT in NOC", buf, 0x20u);
          }
          [v8 addObject:v73];
        }
      }
      id v9 = v109;
    }
    else
    {
      uint64_t v79 = [(HMMTRAccessoryServer *)self storage];
      id v80 = [v79 ownerNodeID];

      if (v80)
      {
        id v81 = (void *)MEMORY[0x2533B64D0]();
        id v82 = self;
        v83 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_INFO))
        {
          id v84 = HMFGetLogIdentifier();
          [(HMMTRAccessoryServer *)v82 storage];
          long long v110 = v8;
          v86 = uint64_t v85 = v9;
          id v87 = [v86 ownerNodeID];
          id v88 = [(HMMTRAccessoryServer *)v82 storage];
          id v89 = [v88 ownerNodeID];
          *(_DWORD *)long long buf = 138543874;
          long long v114 = v84;
          __int16 v115 = 2112;
          long long v116 = v87;
          __int16 v117 = 2048;
          uint64_t v118 = [v89 integerValue];
          _os_log_impl(&dword_252495000, v83, OS_LOG_TYPE_INFO, "%{public}@ACL: adding resident's NodeID %@ (0x%lX)", buf, 0x20u);

          id v9 = v85;
          id v8 = v110;
        }
        id v90 = [(HMMTRAccessoryServer *)v82 storage];
        uint64_t v91 = [v90 ownerNodeID];
        [v8 addObject:v91];
      }
      id v92 = [(HMMTRAccessoryServer *)self deviceController];
      uint64_t v18 = [v92 controllerNodeID];

      if (v18)
      {
        id v93 = (void *)MEMORY[0x2533B64D0]();
        id v94 = self;
        id v95 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v95, OS_LOG_TYPE_INFO))
        {
          v96 = HMFGetLogIdentifier();
          uint64_t v97 = [v18 integerValue];
          *(_DWORD *)long long buf = 138543874;
          long long v114 = v96;
          __int16 v115 = 2112;
          long long v116 = v18;
          __int16 v117 = 2048;
          uint64_t v118 = v97;
          _os_log_impl(&dword_252495000, v95, OS_LOG_TYPE_INFO, "%{public}@ACL: adding current controller's NodeID %@ (0x%lX)", buf, 0x20u);
        }
        [v8 addObject:v18];
      }
    }

    int v7 = [MEMORY[0x263EFF9A0] dictionary];
    long long v98 = (void *)MEMORY[0x263EFFA08];
    id v99 = (void *)[v8 copy];
    id v100 = [v98 setWithArray:v99];
    long long v101 = [v100 allObjects];
    [v7 setObject:v101 forKeyedSubscript:@"adminNodesForPairing"];

    id v102 = (void *)MEMORY[0x263EFFA08];
    long long v103 = (void *)[v9 copy];
    long long v104 = [v102 setWithArray:v103];
    long long v105 = [v104 allObjects];
    [v7 setObject:v105 forKeyedSubscript:@"regularNodesForPairing"];
  }
  return v7;
}

id __52__HMMTRAccessoryServer_populateACLEntriesForPairing__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  id v3 = a2;
  uint64_t v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    int v7 = HMFGetLogIdentifier();
    int v10 = 138543874;
    id v11 = v7;
    __int16 v12 = 2112;
    id v13 = v3;
    __int16 v14 = 2048;
    uint64_t v15 = [v3 integerValue];
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@ACL: adding admin CAT %@ (0x%lX) from NOC", (uint8_t *)&v10, 0x20u);
  }
  id v8 = objc_msgSend(NSNumber, "numberWithUnsignedLong:", objc_msgSend(v3, "integerValue") | 0xFFFFFFFD00000000);

  return v8;
}

id __52__HMMTRAccessoryServer_populateACLEntriesForPairing__block_invoke_595(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  id v3 = a2;
  uint64_t v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    int v7 = HMFGetLogIdentifier();
    int v10 = 138543874;
    id v11 = v7;
    __int16 v12 = 2112;
    id v13 = v3;
    __int16 v14 = 2048;
    uint64_t v15 = [v3 integerValue];
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@ACL: adding operate CAT %@ (0x%lX) from NOC", (uint8_t *)&v10, 0x20u);
  }
  id v8 = objc_msgSend(NSNumber, "numberWithUnsignedLong:", objc_msgSend(v3, "integerValue") | 0xFFFFFFFD00000000);

  return v8;
}

- (id)populateACLEntriesAfterPairing
{
  uint64_t v88 = *MEMORY[0x263EF8340];
  id v3 = [MEMORY[0x263EFF980] array];
  uint64_t v4 = [MEMORY[0x263EFF980] array];
  if (!isFeatureMatterLocalFabricConfigEnabled())
  {
    uint64_t v34 = [(HMMTRAccessoryServer *)self deviceController];
    uint64_t v35 = [v34 controllerNodeID];
    [v3 addObject:v35];

LABEL_19:
    uint64_t v18 = 0;
    int v10 = 0;
    goto LABEL_30;
  }
  id v5 = [(HMMTRAccessoryServer *)self browser];
  id v6 = [(HMMTRAccessoryServer *)self fabricID];
  int v7 = [v5 appleHomeFabricWithID:v6];

  id v8 = [v7 delegate];
  LODWORD(v6) = [v8 isCurrentUserOwner];

  if (!v6)
  {
    long long v36 = (void *)MEMORY[0x2533B64D0]();
    int v37 = self;
    uint64_t v38 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      char v39 = HMFGetLogIdentifier();
      uint64_t v40 = [(HMMTRAccessoryServer *)v37 storage];
      uint64_t v41 = [v40 fabricID];
      *(_DWORD *)long long buf = 138543618;
      id v77 = v39;
      __int16 v78 = 2112;
      uint64_t v79 = v41;
      _os_log_impl(&dword_252495000, v38, OS_LOG_TYPE_DEBUG, "%{public}@Not owner for home with fabric %@ - Not updating ACLs and blocking invalidation", buf, 0x16u);
    }
    [(HMMTRAccessoryServer *)v37 setBlockInvalidation:1];

    goto LABEL_19;
  }
  id v9 = [v7 delegate];
  int v10 = [v9 accessoryAdministerPrivilegeCATID:0];

  id v75 = v7;
  if (v10)
  {
    unsigned int v11 = [v10 integerValue];
    __int16 v12 = [NSNumber numberWithUnsignedLongLong:v11 | 0xFFFFFFFD00000000];
    [v3 addObject:v12];

    id v13 = (void *)MEMORY[0x2533B64D0]();
    __int16 v14 = self;
    uint64_t v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      uint64_t v16 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543874;
      id v77 = v16;
      __int16 v78 = 2112;
      uint64_t v79 = v10;
      __int16 v80 = 2048;
      uint64_t v81 = [v10 integerValue];
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_INFO, "%{public}@ACL: adding admin CAT %@ (0x%lX)", buf, 0x20u);

      int v7 = v75;
    }
  }
  uint64_t v17 = [v7 delegate];
  uint64_t v18 = [v17 accessoryOperatePrivilegeCATID:0];

  if (v18)
  {
    unsigned int v19 = [v18 integerValue];
    uint64_t v20 = [NSNumber numberWithUnsignedLongLong:v19 | 0xFFFFFFFD00000000];
    [v4 addObject:v20];

    unsigned int v21 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v22 = self;
    uint64_t v23 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      BOOL v24 = HMFGetLogIdentifier();
      uint64_t v25 = [v18 integerValue];
      *(_DWORD *)long long buf = 138543874;
      id v77 = v24;
      __int16 v78 = 2112;
      uint64_t v79 = v18;
      __int16 v80 = 2048;
      uint64_t v81 = v25;
      _os_log_impl(&dword_252495000, v23, OS_LOG_TYPE_INFO, "%{public}@ACL: adding operate CAT %@ (0x%lX)", buf, 0x20u);
    }
    int v7 = v75;
  }
  uint64_t v26 = [v7 fabricData];
  id v27 = [v26 residentNodeID];

  if (v27)
  {
    id v28 = (void *)MEMORY[0x2533B64D0]();
    unsigned int v29 = self;
    __int16 v30 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      __int16 v31 = HMFGetLogIdentifier();
      uint64_t v32 = [v27 integerValue];
      *(_DWORD *)long long buf = 138543874;
      id v77 = v31;
      __int16 v78 = 2112;
      uint64_t v79 = v27;
      __int16 v80 = 2048;
      uint64_t v81 = v32;
      _os_log_impl(&dword_252495000, v30, OS_LOG_TYPE_INFO, "%{public}@ACL: adding resident's NodeID %@ (0x%lX)", buf, 0x20u);
    }
    uint64_t v33 = [v3 addObject:v27];
LABEL_26:
    int v7 = v75;
    goto LABEL_27;
  }
  uint64_t v42 = [MEMORY[0x263F42620] productInfo];
  uint64_t v43 = [v42 productPlatform];

  if (v43 == 4)
  {
    unsigned int v44 = [(HMMTRAccessoryServer *)self deviceController];
    id v45 = [v44 controllerNodeID];

    if (v45)
    {
      uint64_t v46 = (void *)MEMORY[0x2533B64D0]();
      uint64_t v47 = self;
      __int16 v48 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
      {
        HMFGetLogIdentifier();
        v50 = id v49 = v4;
        uint64_t v51 = [v45 integerValue];
        *(_DWORD *)long long buf = 138543874;
        id v77 = v50;
        __int16 v78 = 2112;
        uint64_t v79 = v45;
        __int16 v80 = 2048;
        uint64_t v81 = v51;
        _os_log_impl(&dword_252495000, v48, OS_LOG_TYPE_INFO, "%{public}@ACL: adding current device's NodeID %@ (0x%lX)", buf, 0x20u);

        uint64_t v4 = v49;
        id v27 = 0;
      }

      [v3 addObject:v45];
    }

    goto LABEL_26;
  }
LABEL_27:
  uint64_t v52 = (void *)MEMORY[0x2533B64D0](v33);
  uint64_t v53 = self;
  uint64_t v54 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
  {
    HMFGetLogIdentifier();
    v55 = uint64_t v72 = v3;
    BOOL v71 = [(HMMTRAccessoryServer *)v53 browser];
    [v71 currentFabricID];
    v56 = id v73 = v52;
    [(HMMTRAccessoryServer *)v53 fabricID];
    id v57 = v74 = v27;
    uint64_t v58 = [(HMMTRAccessoryServer *)v53 storage];
    [v58 fabricID];
    v60 = uint64_t v59 = v4;
    *(_DWORD *)long long buf = 138544642;
    id v77 = v55;
    __int16 v78 = 2112;
    uint64_t v79 = v10;
    __int16 v80 = 2112;
    uint64_t v81 = (uint64_t)v18;
    __int16 v82 = 2112;
    v83 = v56;
    __int16 v84 = 2112;
    uint64_t v85 = v57;
    __int16 v86 = 2112;
    id v87 = v60;
    _os_log_impl(&dword_252495000, v54, OS_LOG_TYPE_DEBUG, "%{public}@Updating CATs (admin %@, user %@) for FabricID (browser's %@, server's %@, storage's %@", buf, 0x3Eu);

    uint64_t v4 = v59;
    int v7 = v75;

    id v27 = v74;
    uint64_t v52 = v73;

    id v3 = v72;
  }

LABEL_30:
  id v61 = [MEMORY[0x263EFF9A0] dictionary];
  id v62 = (void *)MEMORY[0x263EFFA08];
  long long v63 = (void *)[v3 copy];
  long long v64 = [v62 setWithArray:v63];
  __int16 v65 = [v64 allObjects];
  [v61 setObject:v65 forKeyedSubscript:@"adminNodesForPairing"];

  uint64_t v66 = (void *)MEMORY[0x263EFFA08];
  uint64_t v67 = (void *)[v4 copy];
  id v68 = [v66 setWithArray:v67];
  uint64_t v69 = [v68 allObjects];
  [v61 setObject:v69 forKeyedSubscript:@"regularNodesForPairing"];

  return v61;
}

- (void)_pairingComplete:(id)a3 context:(id)a4
{
  uint64_t v78 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  if (!v6) {
    [(HMMTRAccessoryServer *)self setPairingTimer:0];
  }
  if ([(HMMTRAccessoryServer *)self pairingProgress] == 3
    || [(HMMTRAccessoryServer *)self pairingProgress] == 4)
  {
    id v8 = (void *)MEMORY[0x2533B64D0]();
    id v9 = self;
    int v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v11 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v6;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_DEBUG, "%{public}@Pairing has already finished, ignoring pairing completion indication with error: %@", buf, 0x16u);
    }
  }
  else
  {
    int64_t linkLayerType = (void *)self->_linkLayerType;
    id v13 = [(HMMTRAccessoryServer *)self primaryAccessory];
    [v13 setLinkLayerType:linkLayerType];

    __int16 v14 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v15 = self;
    uint64_t v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      uint64_t v17 = HMFGetLogIdentifier();
      uint64_t v18 = HAPLinkLayerTypeDescription();
      *(_DWORD *)long long buf = 138544386;
      *(void *)&uint8_t buf[4] = v17;
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = @"accessoryTransport";
      *(_WORD *)&buf[22] = 2112;
      *(void *)&unsigned char buf[24] = @"accessory transport";
      __int16 v74 = 2114;
      id v75 = @"transport";
      __int16 v76 = 2112;
      id v77 = v18;
      _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\"", buf, 0x34u);
    }
    unsigned int v19 = [MEMORY[0x263F499E0] sharedInstance];
    id v20 = objc_alloc(MEMORY[0x263F499F0]);
    unsigned int v21 = HAPLinkLayerTypeDescription();
    if (v21)
    {
      BOOL v71 = @"transport";
      int64_t linkLayerType = HAPLinkLayerTypeDescription();
      uint64_t v72 = linkLayerType;
      uint64_t v22 = [NSDictionary dictionaryWithObjects:&v72 forKeys:&v71 count:1];
    }
    else
    {
      uint64_t v22 = (void *)MEMORY[0x263EFFA78];
    }
    uint64_t v23 = (void *)[v20 initWithTag:@"accessoryTransport" data:v22];
    BOOL v24 = [(HMFActivity *)v15->_activity tagProcessorList];
    [v19 submitTaggedEvent:v23 processorList:v24];

    if (v21)
    {
    }
    uint64_t v25 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v26 = v15;
    id v27 = HMFGetOSLogHandle();
    id v28 = v27;
    if (v6)
    {
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        unsigned int v29 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543874;
        *(void *)&uint8_t buf[4] = v29;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v6;
        *(_WORD *)&buf[22] = 2112;
        *(void *)&unsigned char buf[24] = v7;
        _os_log_impl(&dword_252495000, v28, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed: %@, %@", buf, 0x20u);
      }
      [(HMMTRAccessoryServer *)v26 _handlePairingFailureWithError:v6 context:v7];
    }
    else
    {
      if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
      {
        __int16 v30 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v30;
        _os_log_impl(&dword_252495000, v28, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory pairing succeeded", buf, 0xCu);
      }
      [(HMMTRAccessoryServer *)v26 _notifyDelegateOfPairingStep:8];
      memset(buf, 0, sizeof(buf));
      long long v69 = 0u;
      long long v70 = 0u;
      cced25519_make_key_pair_compat();
      id v56 = (void *)[objc_alloc(MEMORY[0x263EFF8F8]) initWithBytes:buf length:32];
      if ([(HMMTRAccessoryServer *)v26 pairedState] != 1)
      {
        id v54 = v7;
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        id obj = [(HAPAccessoryServer *)v26 accessories];
        uint64_t v31 = [obj countByEnumeratingWithState:&v58 objects:v68 count:16];
        if (v31)
        {
          uint64_t v32 = v31;
          uint64_t v33 = *(void *)v59;
          while (2)
          {
            for (uint64_t i = 0; i != v32; ++i)
            {
              if (*(void *)v59 != v33) {
                objc_enumerationMutation(obj);
              }
              uint64_t v35 = *(void **)(*((void *)&v58 + 1) + 8 * i);
              long long v36 = [(HAPAccessoryServer *)v26 keyStore];
              int v37 = [v35 identifier];
              id v57 = 0;
              char v38 = [v36 savePublicKey:v56 forAccessoryName:v37 error:&v57];
              id v39 = v57;

              if ((v38 & 1) == 0)
              {
                unsigned int v44 = (void *)MEMORY[0x2533B64D0]();
                id v45 = v26;
                uint64_t v46 = HMFGetOSLogHandle();
                id v7 = v54;
                if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v47 = HMFGetLogIdentifier();
                  *(_DWORD *)id v62 = 138543874;
                  long long v63 = v47;
                  __int16 v64 = 2112;
                  __int16 v65 = v35;
                  __int16 v66 = 2112;
                  id v67 = v39;
                  _os_log_impl(&dword_252495000, v46, OS_LOG_TYPE_ERROR, "%{public}@Failed to save public key for paired accessory %@: %@", v62, 0x20u);
                }
                __int16 v48 = +[HMMTRAccessoryPairingEndContext hapContextWithStep:8 error:v39];
                [(HMMTRAccessoryServer *)v45 _handlePairingFailureWithError:v39 context:v48];

                goto LABEL_45;
              }
            }
            uint64_t v32 = [obj countByEnumeratingWithState:&v58 objects:v68 count:16];
            if (v32) {
              continue;
            }
            break;
          }
        }

        id v7 = v54;
      }
      if ([(HMMTRAccessoryServer *)v26 pairedState] == 1)
      {
        [(HMMTRAccessoryServer *)v26 setPairedState:2];
        [(HMMTRAccessoryServer *)v26 setPairingProgress:4];
        uint64_t v40 = [(HMMTRAccessoryServer *)v26 stageCompletion];

        if (v40)
        {
          uint64_t v41 = [(HMMTRAccessoryServer *)v26 browser];
          int v42 = [v41 isSystemCommissionerMode];

          if (v42)
          {
            [(HMMTRAccessoryServer *)v26 _notifyDelegateOfPairingProgress:13];
            uint64_t v43 = [(HMMTRAccessoryServer *)v26 browser];
            [v43 commitStagedAccessoryServer:v26];
          }
          else
          {
            uint64_t v53 = [(HMMTRAccessoryServer *)v26 stageCompletion];
            ((void (**)(void, uint64_t, HMMTRAccessoryServer *, void))v53)[2](v53, 1, v26, 0);

            [(HMMTRAccessoryServer *)v26 setStageCompletion:0];
          }
        }
        else
        {
          id v49 = (void *)MEMORY[0x2533B64D0]();
          uint64_t v50 = v26;
          uint64_t v51 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            uint64_t v52 = HMFGetLogIdentifier();
            *(_DWORD *)id v62 = 138543362;
            long long v63 = v52;
            _os_log_impl(&dword_252495000, v51, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory is paired and staged but has no stage completion handler set!", v62, 0xCu);
          }
        }
      }
      else
      {
        [(HMMTRAccessoryServer *)v26 _finalizePairing];
      }
      [(HMMTRAccessoryServer *)v26 _clearCommissioneeInfoAfterPairingCompletion];
LABEL_45:
    }
  }
}

- (id)_pairingSetupPayload
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  uint64_t v3 = [(HMMTRAccessoryServer *)self setupPayloadString];
  if (v3
    && (uint64_t v4 = (void *)v3,
        [(HMMTRAccessoryServer *)self setupPayloadString],
        id v5 = objc_claimAutoreleasedReturnValue(),
        char v6 = [v5 isEqual:&stru_2702A0B38],
        v5,
        v4,
        (v6 & 1) == 0))
  {
    uint64_t v18 = (void *)MEMORY[0x2533B64D0]();
    unsigned int v19 = self;
    id v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      unsigned int v21 = HMFGetLogIdentifier();
      nodeID = v19->_nodeID;
      uint64_t v23 = [(HMMTRAccessoryServer *)v19 setupPayloadString];
      *(_DWORD *)long long buf = 138543874;
      uint64_t v33 = (uint64_t)v21;
      __int16 v34 = 2112;
      uint64_t v35 = nodeID;
      __int16 v36 = 2112;
      int v37 = v23;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_INFO, "%{public}@Pairing node ID: %@, onboarding payload: %@", buf, 0x20u);
    }
    BOOL v24 = (void *)MEMORY[0x263F10FE0];
    uint64_t v25 = [(HMMTRAccessoryServer *)v19 setupPayloadString];
    id v31 = 0;
    uint64_t v16 = [v24 setupPayloadWithOnboardingPayload:v25 error:&v31];
    uint64_t v17 = (NSNumber *)v31;

    if (!v16)
    {
      uint64_t v26 = (void *)MEMORY[0x2533B64D0]();
      id v27 = v19;
      id v28 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        unsigned int v29 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543618;
        uint64_t v33 = (uint64_t)v29;
        __int16 v34 = 2112;
        uint64_t v35 = v17;
        _os_log_impl(&dword_252495000, v28, OS_LOG_TYPE_ERROR, "%{public}@Failed to parse onboarding payload: %@", buf, 0x16u);
      }
      uint64_t v16 = 0;
    }
  }
  else
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = self;
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = HMFGetLogIdentifier();
      unsigned int v11 = (void *)v10;
      __int16 v12 = v8->_nodeID;
      discriminator = v8->_discriminator;
      if (v8->_discriminatorIsOriginatedFromShort) {
        __int16 v14 = @"YES";
      }
      else {
        __int16 v14 = @"NO";
      }
      setUpPINCode = v8->_setUpPINCode;
      *(_DWORD *)long long buf = 138544386;
      uint64_t v33 = v10;
      __int16 v34 = 2112;
      uint64_t v35 = v12;
      __int16 v36 = 2112;
      int v37 = discriminator;
      __int16 v38 = 2112;
      id v39 = v14;
      __int16 v40 = 2112;
      uint64_t v41 = setUpPINCode;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_INFO, "%{public}@Pairing node ID: %@, discriminator: %@, short: %@, setupPINCode: %@", buf, 0x34u);
    }
    uint64_t v16 = (void *)[objc_alloc(MEMORY[0x263F10FE0]) initWithSetupPasscode:v8->_setUpPINCode discriminator:v8->_discriminator];
    [v16 setHasShortDiscriminator:v8->_discriminatorIsOriginatedFromShort];
    uint64_t v17 = 0;
  }

  return v16;
}

- (void)_restoreCommissioneeInfoBeforeNextPairingAttempt
{
  if (![(HMMTRAccessoryServer *)self pairingUsingMatterSupport])
  {
    uint64_t v3 = [(HMMTRAccessoryServer *)self originalPairingAttemptRootCert];
    uint64_t v4 = [(HMMTRAccessoryServer *)self storage];
    [v4 setRootCert:v3];

    id v6 = [(HMMTRAccessoryServer *)self originalPairingAttemptOperationalCert];
    id v5 = [(HMMTRAccessoryServer *)self storage];
    [v5 setOperationalCert:v6];
  }
}

- (void)_clearCommissioneeInfoAfterPairingCompletion
{
  uint64_t v3 = [(HMMTRAccessoryServer *)self browser];
  [v3 setCommissioneeAccessoryServer:0];

  if (![(HMMTRAccessoryServer *)self pairingUsingMatterSupport])
  {
    uint64_t v4 = [(HMMTRAccessoryServer *)self storage];
    id v5 = [v4 rootCert];
    [(HMMTRAccessoryServer *)self setOriginalPairingAttemptRootCert:v5];

    id v6 = [(HMMTRAccessoryServer *)self storage];
    id v7 = [v6 operationalCert];
    [(HMMTRAccessoryServer *)self setOriginalPairingAttemptOperationalCert:v7];
  }
  id v8 = [(HMMTRAccessoryServer *)self storage];
  [v8 setRootCert:0];

  id v9 = [(HMMTRAccessoryServer *)self storage];
  [v9 setOperationalCert:0];
}

- (void)_persistAccessoryServerData
{
  uint64_t v100 = *MEMORY[0x263EF8340];
  uint64_t v3 = (void *)MEMORY[0x2533B64D0](self, a2);
  uint64_t v4 = self;
  id v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    id v7 = [(HMMTRAccessoryServer *)v4 storage];
    [v7 isSharedAdmin];
    id v8 = HMFBooleanToString();
    [(HMMTRAccessoryServer *)v4 knownToSystemCommissioner];
    id v9 = HMFBooleanToString();
    int v92 = 138544130;
    id v93 = v6;
    __int16 v94 = 2112;
    id v95 = v4;
    __int16 v96 = 2112;
    uint64_t v97 = v8;
    __int16 v98 = 2112;
    id v99 = v9;
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@Persisting HomeKitMatter Data for Accessory: %@, shared admin: %@, system commissioner mode: %@", (uint8_t *)&v92, 0x2Au);
  }
  uint64_t v10 = [(HMMTRAccessoryServer *)v4 storage];
  int v11 = [v10 isSharedAdmin];

  if (isFeatureMatterLocalFabricConfigEnabled())
  {
    uint64_t v12 = [(HMMTRAccessoryServer *)v4 pairingTargetHomeUUID];
    if (v12)
    {
      id v13 = (void *)v12;
      __int16 v14 = [(HMMTRAccessoryServer *)v4 storage];
      uint64_t v15 = [v14 dataSource];
      uint64_t v16 = [(HMMTRAccessoryServer *)v4 pairingTargetHomeUUID];
      uint64_t v17 = [v15 appleHomeFabricWithUUID:v16];

      if (v17)
      {
        uint64_t v18 = [v17 delegate];
        char v19 = [v18 requiresRemoteFabricDataUpdate];

        LOBYTE(v11) = v19 | v11;
      }
    }
    if ((v11 & 1) == 0) {
      goto LABEL_11;
    }
  }
  else if (!v11)
  {
    goto LABEL_11;
  }
  if (![(HMMTRAccessoryServer *)v4 knownToSystemCommissioner])
  {
    __int16 v74 = [(HMMTRAccessoryServer *)v4 browser];
    [v74 notifyPairingCompletionForAccessoryServer:v4];

    id v75 = [(HMMTRAccessoryServer *)v4 storage];
    [v75 endLocalStorageModeBySyncingToRemote:0];
LABEL_33:

    goto LABEL_34;
  }
LABEL_11:
  uint64_t v20 = [(HMMTRAccessoryServer *)v4 isKnownToSystemCommissioner];
  unsigned int v21 = [(HMMTRAccessoryServer *)v4 storage];
  [v21 setSystemCommissionerFabric:v20];

  uint64_t v22 = [(HMMTRAccessoryServer *)v4 storage];
  uint64_t v23 = [(HMMTRAccessoryServer *)v4 fabricID];
  [v22 prepareStorageForFabricID:v23];

  BOOL v24 = [(HMMTRAccessoryServer *)v4 storage];
  [v24 startLocalStorageMode];

  uint64_t v25 = [(HMMTRAccessoryServer *)v4 storage];
  uint64_t v26 = [(HMMTRAccessoryServer *)v4 nodeID];
  [v25 addPairedNodeID:v26];

  id v27 = [(HMMTRAccessoryServer *)v4 storage];
  id v28 = [(HMMTRAccessoryServer *)v4 vendorID];
  unsigned int v29 = [(HMMTRAccessoryServer *)v4 nodeID];
  [v27 setVendorID:v28 forNode:v29];

  __int16 v30 = [(HMMTRAccessoryServer *)v4 storage];
  id v31 = [(HMMTRAccessoryServer *)v4 fabricID];
  uint64_t v32 = [(HMMTRAccessoryServer *)v4 nodeID];
  [v30 setFabricID:v31 forNode:v32];

  uint64_t v33 = [(HMMTRAccessoryServer *)v4 storage];
  __int16 v34 = [(HMMTRAccessoryServer *)v4 productID];
  uint64_t v35 = [(HMMTRAccessoryServer *)v4 nodeID];
  [v33 setProductID:v34 forNode:v35];

  __int16 v36 = [(HMMTRAccessoryServer *)v4 storage];
  int v37 = [(HAPAccessoryServer *)v4 category];
  __int16 v38 = [(HMMTRAccessoryServer *)v4 nodeID];
  [v36 setCategory:v37 forNode:v38];

  id v39 = [(HMMTRAccessoryServer *)v4 storage];
  __int16 v40 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", -[HAPAccessoryServer configNumber](v4, "configNumber"));
  uint64_t v41 = [(HMMTRAccessoryServer *)v4 nodeID];
  [v39 setConfigNumber:v40 forNode:v41];

  uint64_t v42 = [(HMMTRAccessoryServer *)v4 storage];
  uint64_t v43 = [(HMMTRAccessoryServer *)v4 isStaged];
  unsigned int v44 = [(HMMTRAccessoryServer *)v4 nodeID];
  [v42 setStaged:v43 forNode:v44];

  id v45 = [(HMMTRAccessoryServer *)v4 topology];

  if (v45)
  {
    uint64_t v46 = [(HMMTRAccessoryServer *)v4 storage];
    uint64_t v47 = [(HMMTRAccessoryServer *)v4 topology];
    __int16 v48 = [(HMMTRAccessoryServer *)v4 nodeID];
    [v46 setTopology:v47 forNode:v48];
  }
  else if (![(HMMTRAccessoryServer *)v4 isKnownToSystemCommissioner])
  {
    _HMFPreconditionFailure();
  }
  if ([(HMMTRAccessoryServer *)v4 isKnownToSystemCommissioner])
  {
    id v49 = [(HMMTRAccessoryServer *)v4 storage];
    uint64_t v50 = [(HMMTRAccessoryServer *)v4 nodeID];
    uint64_t v51 = [(HMMTRAccessoryServer *)v4 commissioningID];
    [v49 setSystemCommissionerFabricNodeID:v50 forUuid:v51];

    uint64_t v52 = [(HMMTRAccessoryServer *)v4 storage];
    uint64_t v53 = [(HMMTRAccessoryServer *)v4 commissioningID];
    id v54 = [(HMMTRAccessoryServer *)v4 nodeID];
    [v52 setUuid:v53 forSystemCommissionerFabricNode:v54];

    id v55 = [(HMMTRAccessoryServer *)v4 primaryAccessory];
    id v56 = [v55 serialNumber];

    if (v56)
    {
      id v57 = [(HMMTRAccessoryServer *)v4 storage];
      long long v58 = [(HMMTRAccessoryServer *)v4 primaryAccessory];
      long long v59 = [v58 serialNumber];
      long long v60 = [(HMMTRAccessoryServer *)v4 nodeID];
      [v57 setSerialNumber:v59 forSystemCommissionerFabricNode:v60];
    }
    long long v61 = [(HMMTRAccessoryServer *)v4 storage];
    id v62 = [(HAPAccessoryServer *)v4 name];
    long long v63 = [(HMMTRAccessoryServer *)v4 nodeID];
    [v61 setDeviceName:v62 forSystemCommissionerFabricNode:v63];

    uint64_t v64 = [(HMMTRAccessoryServer *)v4 setupPayloadString];
    if (v64
      && (__int16 v65 = (void *)v64,
          [(HMMTRAccessoryServer *)v4 setupPayloadString],
          __int16 v66 = objc_claimAutoreleasedReturnValue(),
          char v67 = [v66 isEqual:&stru_2702A0B38],
          v66,
          v65,
          (v67 & 1) == 0))
    {
      uint64_t v72 = [(HMMTRAccessoryServer *)v4 storage];
      uint64_t v73 = [(HMMTRAccessoryServer *)v4 setupPayloadString];
    }
    else
    {
      uint64_t v68 = [(HMMTRAccessoryServer *)v4 onboardingSetupPayloadString];
      if (!v68
        || (long long v69 = (void *)v68,
            [(HMMTRAccessoryServer *)v4 onboardingSetupPayloadString],
            long long v70 = objc_claimAutoreleasedReturnValue(),
            char v71 = [v70 isEqual:&stru_2702A0B38],
            v70,
            v69,
            (v71 & 1) != 0))
      {
LABEL_25:
        if (isFeatureMatterLocalFabricConfigEnabled())
        {
          uint64_t v78 = [(HMMTRAccessoryServer *)v4 storage];
          uint64_t v79 = [(HMMTRAccessoryServer *)v4 isWEDDevice];
          __int16 v80 = [(HMMTRAccessoryServer *)v4 nodeID];
          [v78 setWEDSupported:v79 forSystemCommissionerFabricNode:v80];

          if ([(HMMTRAccessoryServer *)v4 isWEDDevice])
          {
            uint64_t v81 = [(HMMTRAccessoryServer *)v4 storage];
            __int16 v82 = [(HMMTRAccessoryServer *)v4 eMACAddress];
            v83 = [(HMMTRAccessoryServer *)v4 nodeID];
            [v81 setExtendedMACAddress:v82 forSystemCommissionerFabricNode:v83];
          }
        }
        goto LABEL_28;
      }
      uint64_t v72 = [(HMMTRAccessoryServer *)v4 storage];
      uint64_t v73 = [(HMMTRAccessoryServer *)v4 onboardingSetupPayloadString];
    }
    __int16 v76 = (void *)v73;
    id v77 = [(HMMTRAccessoryServer *)v4 nodeID];
    [v72 setSetupPayload:v76 forSystemCommissionerFabricNode:v77];

    goto LABEL_25;
  }
LABEL_28:
  __int16 v84 = [(HMMTRAccessoryServer *)v4 storage];
  [v84 endLocalStorageModeBySyncingToRemote:1];

  if ([(HMMTRAccessoryServer *)v4 isKnownToSystemCommissioner])
  {
    id v75 = [(HMMTRAccessoryServer *)v4 browser];
    uint64_t v85 = [(HMMTRAccessoryServer *)v4 commissioningID];
    __int16 v86 = [(HMMTRAccessoryServer *)v4 vendorID];
    id v87 = [(HMMTRAccessoryServer *)v4 productID];
    uint64_t v88 = [(HMMTRAccessoryServer *)v4 primaryAccessory];
    id v89 = [v88 serialNumber];
    id v90 = [(HMMTRAccessoryServer *)v4 setupPayloadString];
    if ([v90 isEqual:&stru_2702A0B38])
    {
      [v75 cleanUpStaleSystemCommissionerPairingsWithNewlyPairedUUID:v85 vendorID:v86 productID:v87 serialNumber:v89 setupPayload:0];
    }
    else
    {
      uint64_t v91 = [(HMMTRAccessoryServer *)v4 setupPayloadString];
      [v75 cleanUpStaleSystemCommissionerPairingsWithNewlyPairedUUID:v85 vendorID:v86 productID:v87 serialNumber:v89 setupPayload:v91];
    }
    goto LABEL_33;
  }
LABEL_34:
  [(HMMTRAccessoryServer *)v4 setStorageUpdatePending:0];
}

- (void)_deleteAccessoryServerData
{
  if (![(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    id v4 = [(HMMTRAccessoryServer *)self storage];
    uint64_t v3 = [(HMMTRAccessoryServer *)self nodeID];
    [v4 removeRecordsForNode:v3 systemCommissionerFabric:0];
  }
}

- (void)_notifyDelegateOfPairingProgress:(int64_t)a3 error:(id)a4
{
  id v6 = a4;
  uint64_t v7 = [(HAPAccessoryServer *)self delegateQueue];
  if (v7)
  {
    id v8 = (void *)v7;
    BOOL v9 = [(HMMTRAccessoryServer *)self _delegateRespondsToSelector:sel_accessoryServer_updatePairingProgress_];

    if (v9)
    {
      uint64_t v10 = [(HAPAccessoryServer *)self delegateQueue];
      v15[0] = MEMORY[0x263EF8330];
      v15[1] = 3221225472;
      v15[2] = __63__HMMTRAccessoryServer__notifyDelegateOfPairingProgress_error___block_invoke;
      v15[3] = &unk_265377168;
      void v15[4] = self;
      void v15[5] = a3;
      dispatch_async(v10, v15);
    }
  }
  if ([(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    uint64_t v11 = [(HMMTRAccessoryServer *)self stageCompletion];
    if (v11)
    {
      uint64_t v12 = (void *)v11;
      id v13 = [(HMMTRAccessoryServer *)self stageProgressUpdateHandler];

      if (v13)
      {
        __int16 v14 = [(HMMTRAccessoryServer *)self stageProgressUpdateHandler];
        v14[2](v14, a3);
      }
    }
  }
  [(HMMTRAccessoryServer *)self _updateMetricWithProgressState:a3 error:v6];
}

void __63__HMMTRAccessoryServer__notifyDelegateOfPairingProgress_error___block_invoke(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  [v2 accessoryServer:*(void *)(a1 + 32) updatePairingProgress:*(void *)(a1 + 40)];
}

- (void)_notifyDelegateOfPairingProgress:(int64_t)a3
{
}

- (void)_updateMetricWithProgressState:(int64_t)a3 error:(id)a4
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  id v6 = a4;
  uint64_t v7 = [(HMMTRAccessoryServer *)self _progressStateToString:a3];
  uint64_t v8 = [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventLastProgressState" value:v7];
  if (v6)
  {
    uint64_t v9 = [(HMMTRAccessoryServer *)self _metricCollectionWithError:v6 description:@"Error in progress state" progressState:a3];
  }
  else
  {
    uint64_t v10 = (void *)MEMORY[0x2533B64D0](v8);
    uint64_t v11 = self;
    uint64_t v12 = HMFGetOSLogHandle();
    unint64_t v13 = 0x263F08000;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      __int16 v14 = HMFGetLogIdentifier();
      uint64_t v15 = [NSNumber numberWithInteger:a3];
      *(_DWORD *)long long buf = 138544898;
      uint64_t v52 = v14;
      __int16 v53 = 2114;
      id v54 = @"hmmtrAccessoryServerStateChange";
      __int16 v55 = 2112;
      id v56 = @"Matter Progress Pairing State";
      __int16 v57 = 2114;
      long long v58 = @"state";
      __int16 v59 = 2112;
      long long v60 = v15;
      __int16 v61 = 2114;
      id v62 = @"stateName";
      __int16 v63 = 2112;
      uint64_t v64 = v7;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\"", buf, 0x48u);

      unint64_t v13 = 0x263F08000uLL;
    }

    uint64_t v16 = [MEMORY[0x263F499E0] sharedInstance];
    id v17 = objc_alloc(MEMORY[0x263F499F0]);
    uint64_t v18 = [*(id *)(v13 + 2584) numberWithInteger:a3];
    char v19 = HMDTaggedLoggingCreateDictionary();
    uint64_t v20 = objc_msgSend(v17, "initWithTag:data:", @"hmmtrAccessoryServerStateChange", v19, @"state", v18, @"stateName", v7);
    unsigned int v21 = [(HMFActivity *)v11->_activity tagProcessorList];
    [v16 submitTaggedEvent:v20 processorList:v21];
  }
  switch(a3)
  {
    case 17:
    case 20:
    case 21:
    case 27:
    case 30:
    case 33:
      break;
    case 18:
      uint64_t v22 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameNetworkScan"];
      uint64_t v23 = @"hmmtrAccessoryPairingEventNetworkScanDurationInSeconds";
      goto LABEL_19;
    case 19:
      BOOL v24 = @"hmmtrAccessoryMetricNameNetworkScan";
      goto LABEL_21;
    case 22:
      uint64_t v22 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNamePairingWindow"];
      uint64_t v23 = @"hmmtrAccessoryPairingEventWindowOpenedDurationInSeconds";
      goto LABEL_19;
    case 23:
      BOOL v24 = @"hmmtrAccessoryMetricNamePairingWindow";
      goto LABEL_21;
    case 25:
      uint64_t v22 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNamePairingWindowWithPasscode"];
      uint64_t v23 = @"hmmtrAccessoryPairingEventWindowOpenedWithPassCodeDurationInSeconds";
      goto LABEL_19;
    case 26:
      BOOL v24 = @"hmmtrAccessoryMetricNamePairingWindowWithPasscode";
      goto LABEL_21;
    case 28:
      uint64_t v22 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameCommissioningAccessory"];
      uint64_t v23 = @"hmmtrAccessoryPairingEventCommissioningDurationInSeconds";
      goto LABEL_19;
    case 29:
      BOOL v24 = @"hmmtrAccessoryMetricNameCommissioningAccessory";
      goto LABEL_21;
    case 31:
      uint64_t v22 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNameRetrieveThreadCredentials"];
      uint64_t v23 = @"hmmtrAccessoryPairingEventThreadCredentialSetupDurationInSeconds";
LABEL_19:
      [(HMMTRAccessoryServer *)self addMetricsWithDuration:v22 metricsKey:v23];

      break;
    case 32:
      BOOL v24 = @"hmmtrAccessoryMetricNameRetrieveThreadCredentials";
LABEL_21:
      id v29 = [(HMMTRAccessoryServer *)self _endCurrentMetricTimeWithName:v24];
      break;
    case 34:
      __int16 v30 = (void *)MEMORY[0x263EFFA88];
      id v31 = (void *)MEMORY[0x2533B64D0]([(HAPAccessoryServer *)self setPairingMetricWithKey:@"HMMTRAccessoryPairingEventCASESessionSanityCheckPassed" value:MEMORY[0x263EFFA88]]);
      uint64_t v32 = self;
      uint64_t v33 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
        __int16 v34 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138544386;
        uint64_t v52 = v34;
        __int16 v53 = 2114;
        id v54 = @"hmmtrAccessoryServerCaseSessionSanityCheck";
        __int16 v55 = 2112;
        id v56 = @"Case Sanity Check";
        __int16 v57 = 2114;
        long long v58 = @"success";
        __int16 v59 = 2112;
        long long v60 = v30;
        _os_log_impl(&dword_252495000, v33, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\"", buf, 0x34u);
      }
      uint64_t v35 = [MEMORY[0x263F499E0] sharedInstance];
      id v36 = objc_alloc(MEMORY[0x263F499F0]);
      uint64_t v47 = @"success";
      __int16 v48 = v30;
      int v37 = NSDictionary;
      __int16 v38 = &v48;
      id v39 = &v47;
      goto LABEL_28;
    case 35:
      __int16 v40 = (void *)MEMORY[0x263EFFA80];
      uint64_t v41 = (void *)MEMORY[0x2533B64D0]([(HAPAccessoryServer *)self setPairingMetricWithKey:@"HMMTRAccessoryPairingEventCASESessionSanityCheckPassed" value:MEMORY[0x263EFFA80]]);
      uint64_t v32 = self;
      uint64_t v42 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
      {
        uint64_t v43 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138544386;
        uint64_t v52 = v43;
        __int16 v53 = 2114;
        id v54 = @"hmmtrAccessoryServerCaseSessionSanityCheck";
        __int16 v55 = 2112;
        id v56 = @"Case Sanity Check";
        __int16 v57 = 2114;
        long long v58 = @"success";
        __int16 v59 = 2112;
        long long v60 = v40;
        _os_log_impl(&dword_252495000, v42, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\"", buf, 0x34u);
      }
      uint64_t v35 = [MEMORY[0x263F499E0] sharedInstance];
      id v36 = objc_alloc(MEMORY[0x263F499F0]);
      id v49 = @"success";
      uint64_t v50 = v40;
      int v37 = NSDictionary;
      __int16 v38 = &v50;
      id v39 = &v49;
LABEL_28:
      unsigned int v44 = [v37 dictionaryWithObjects:v38 forKeys:v39 count:1];
      id v45 = (void *)[v36 initWithTag:@"hmmtrAccessoryServerCaseSessionSanityCheck" data:v44];
      uint64_t v46 = [(HMFActivity *)v32->_activity tagProcessorList];
      [v35 submitTaggedEvent:v45 processorList:v46];

      break;
    default:
      uint64_t v25 = (void *)MEMORY[0x2533B64D0](v9);
      uint64_t v26 = self;
      id v27 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
      {
        id v28 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543618;
        uint64_t v52 = v28;
        __int16 v53 = 2048;
        id v54 = (__CFString *)a3;
        _os_log_impl(&dword_252495000, v27, OS_LOG_TYPE_INFO, "%{public}@Unhandled progress state %ld", buf, 0x16u);
      }
      break;
  }
}

- (id)_progressStateToString:(int64_t)a3
{
  int64_t v3 = a3 - 18;
  if (unint64_t)(a3 - 18) < 0x15 && ((0x1FEDB3u >> v3))
  {
    id v4 = off_265377F70[v3];
  }
  else
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Unknown progressState %ld", a3);
    id v4 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  return v4;
}

- (void)addMetricsWithDuration:(id)a3 metricsKey:(id)a4
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  if (v6)
  {
    uint64_t v8 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v9 = self;
    uint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138544386;
      uint64_t v20 = v11;
      __int16 v21 = 2114;
      id v22 = v7;
      __int16 v23 = 2112;
      id v24 = v7;
      __int16 v25 = 2114;
      uint64_t v26 = @"duration";
      __int16 v27 = 2112;
      id v28 = v6;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\"", buf, 0x34u);
    }
    uint64_t v12 = [MEMORY[0x263F499E0] sharedInstance];
    id v13 = objc_alloc(MEMORY[0x263F499F0]);
    id v17 = @"duration";
    id v18 = v6;
    __int16 v14 = [NSDictionary dictionaryWithObjects:&v18 forKeys:&v17 count:1];
    uint64_t v15 = (void *)[v13 initWithTag:v7 data:v14];
    uint64_t v16 = [(HMFActivity *)v9->_activity tagProcessorList];
    [v12 submitTaggedEvent:v15 processorList:v16];

    [(HAPAccessoryServer *)v9 setPairingMetricWithKey:v7 value:v6];
  }
}

- (BOOL)_delegateRespondsToSelector:(SEL)a3
{
  id v4 = [(HAPAccessoryServer *)self delegate];
  if (v4)
  {
    id v5 = [(HAPAccessoryServer *)self delegateQueue];
    if (v5)
    {
      id v6 = [(HAPAccessoryServer *)self delegate];
      char v7 = objc_opt_respondsToSelector();
    }
    else
    {
      char v7 = 0;
    }
  }
  else
  {
    char v7 = 0;
  }

  return v7 & 1;
}

- (BOOL)pingSupported
{
  return 0;
}

- (void)handleUpdatesForCharacteristics:(id)a3 stateNumber:(id)a4
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v9 = self;
  uint64_t v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    uint64_t v11 = HMFGetLogIdentifier();
    int v12 = 138543362;
    id v13 = v11;
    _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@UNIMPLEMENTED: CHIP Accessory doesn't implement handleUpdatesForCharacteristics", (uint8_t *)&v12, 0xCu);
  }
}

- (void)identifyWithCompletion:(id)a3
{
  id v4 = a3;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __47__HMMTRAccessoryServer_identifyWithCompletion___block_invoke;
  block[3] = &unk_265377430;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, block);
}

void __47__HMMTRAccessoryServer_identifyWithCompletion___block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    id v2 = [MEMORY[0x263F087E8] hapErrorWithCode:3];
    (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
  }
}

- (void)enableEvents:(BOOL)a3 forCharacteristics:(id)a4 withCompletionHandler:(id)a5 queue:(id)a6
{
  id v7 = a5;
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __84__HMMTRAccessoryServer_enableEvents_forCharacteristics_withCompletionHandler_queue___block_invoke;
  block[3] = &unk_265377430;
  id v10 = v7;
  id v8 = v7;
  dispatch_async((dispatch_queue_t)a6, block);
}

void __84__HMMTRAccessoryServer_enableEvents_forCharacteristics_withCompletionHandler_queue___block_invoke(uint64_t a1)
{
  uint64_t v1 = (void (**)(void, void, void))MEMORY[0x2533B66E0](*(void *)(a1 + 32));
  if (v1)
  {
    id v2 = v1;
    v1[2](v1, 0, 0);
    uint64_t v1 = (void (**)(void, void, void))v2;
  }
}

- (void)_populateServiceForCharacteristic:(id)a3
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [(HMMTRAccessoryServer *)self primaryAccessory];
  id v6 = [v4 type];
  id v7 = [v5 characteristicsOfType:v6];

  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  id obj = v7;
  uint64_t v8 = [obj countByEnumeratingWithState:&v43 objects:v53 count:16];
  if (v8)
  {
    uint64_t v10 = v8;
    uint64_t v11 = *(void *)v44;
    *(void *)&long long v9 = 138543874;
    long long v41 = v9;
    do
    {
      for (uint64_t i = 0; i != v10; ++i)
      {
        if (*(void *)v44 != v11) {
          objc_enumerationMutation(obj);
        }
        id v13 = *(void **)(*((void *)&v43 + 1) + 8 * i);
        uint64_t v14 = objc_msgSend(v4, "service", v41);

        if (!v14)
        {
          uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
          uint64_t v16 = self;
          id v17 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            id v18 = HMFGetLogIdentifier();
            *(_DWORD *)long long buf = 138543618;
            __int16 v48 = v18;
            __int16 v49 = 2112;
            id v50 = v4;
            _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@read/write is missing service for Characteristic %@", buf, 0x16u);
          }
          char v19 = (void *)MEMORY[0x2533B64D0]();
          uint64_t v20 = v16;
          __int16 v21 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            id v22 = HMFGetLogIdentifier();
            *(_DWORD *)long long buf = 138543618;
            __int16 v48 = v22;
            __int16 v49 = 2112;
            id v50 = v13;
            _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_ERROR, "%{public}@current primary characteristic %@", buf, 0x16u);
          }
        }
        __int16 v23 = [v13 service];

        if (!v23)
        {
          id v24 = (void *)MEMORY[0x2533B64D0]();
          __int16 v25 = self;
          uint64_t v26 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            __int16 v27 = HMFGetLogIdentifier();
            *(_DWORD *)long long buf = 138543618;
            __int16 v48 = v27;
            __int16 v49 = 2112;
            id v50 = v13;
            _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_ERROR, "%{public}@No primary service for primary Characteristic %@", buf, 0x16u);
          }
        }
        id v28 = [v13 instanceID];
        uint64_t v29 = [v4 instanceID];
        int v30 = [v28 isEqualToNumber:v29];

        if (v30)
        {
          uint64_t v31 = [v4 service];
          if (!v31) {
            goto LABEL_19;
          }
          uint64_t v32 = (void *)v31;
          uint64_t v33 = [v13 service];
          __int16 v34 = [v4 service];
          char v35 = [v33 isEqualToService:v34];

          if ((v35 & 1) == 0)
          {
LABEL_19:
            id v36 = (void *)MEMORY[0x2533B64D0]();
            int v37 = self;
            __int16 v38 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
            {
              id v39 = HMFGetLogIdentifier();
              *(_DWORD *)long long buf = v41;
              __int16 v48 = v39;
              __int16 v49 = 2112;
              id v50 = v4;
              __int16 v51 = 2112;
              uint64_t v52 = v13;
              _os_log_impl(&dword_252495000, v38, OS_LOG_TYPE_INFO, "%{public}@Updating service for Characteristic %@ using local characteristic %@", buf, 0x20u);
            }
            __int16 v40 = [v13 service];
            [v4 setService:v40];
          }
        }
      }
      uint64_t v10 = [obj countByEnumeratingWithState:&v43 objects:v53 count:16];
    }
    while (v10);
  }
}

- (id)_populateHandlingForCharacteristics:(id)a3
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  id v3 = a3;
  objc_msgSend(MEMORY[0x263EFF980], "arrayWithCapacity:", objc_msgSend(v3, "count"));
  id v30 = (id)objc_claimAutoreleasedReturnValue();
  if ([v3 count])
  {
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    id v25 = v3;
    id obj = v3;
    uint64_t v4 = [obj countByEnumeratingWithState:&v31 objects:v35 count:16];
    if (!v4)
    {
      __int16 v27 = 0;
      id v6 = 0;
      goto LABEL_29;
    }
    uint64_t v5 = v4;
    char v26 = 0;
    __int16 v27 = 0;
    id v6 = 0;
    uint64_t v29 = *(void *)v32;
    while (1)
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v32 != v29) {
          objc_enumerationMutation(obj);
        }
        uint64_t v8 = *(void **)(*((void *)&v31 + 1) + 8 * i);
        long long v9 = [[HMMTRCharacteristicWriteRequestTuple alloc] initWithRequestTuple:v8];
        [(HMMTRCharacteristicWriteRequestTuple *)v9 setSecondary:0];
        uint64_t v10 = [v8 characteristic];
        uint64_t v11 = [v10 type];
        if ([v11 isEqualToString:@"00000013-0000-1000-8000-0026BB765291"])
        {

LABEL_10:
          if (!v6)
          {
            uint64_t v15 = v9;
            id v6 = v15;
LABEL_12:
            -[HMMTRCharacteristicWriteRequestTuple setCharacteristicHandlingType:](v15, "setCharacteristicHandlingType:", 0, v25);
            goto LABEL_25;
          }
          [(HMMTRCharacteristicWriteRequestTuple *)v6 setCharacteristicHandlingType:1];
          [(HMMTRCharacteristicWriteRequestTuple *)v9 setCharacteristicHandlingType:2];
          char v19 = [(HMMTRCharacteristicWriteRequestTuple *)v6 primary];
          [(HMMTRCharacteristicWriteRequestTuple *)v9 setSecondary:v19];

          id v6 = 0;
          goto LABEL_25;
        }
        int v12 = [v8 characteristic];
        id v13 = [v12 type];
        int v14 = [v13 isEqualToString:@"0000002F-0000-1000-8000-0026BB765291"];

        if (v14) {
          goto LABEL_10;
        }
        uint64_t v16 = [v8 characteristic];
        id v17 = [v16 type];
        int v18 = [v17 isEqualToString:@"00000029-0000-1000-8000-0026BB765291"];

        if (v18)
        {
          [(HMMTRCharacteristicWriteRequestTuple *)v9 setCharacteristicHandlingType:0];
          if (v27) {
            [(HMMTRCharacteristicWriteRequestTuple *)v27 setCharacteristicHandlingType:3];
          }
          else {
            __int16 v27 = 0;
          }
          char v26 = 1;
        }
        else
        {
          uint64_t v20 = [v8 characteristic];
          __int16 v21 = [v20 type];
          int v22 = [v21 isEqualToString:@"000000B0-0000-1000-8000-0026BB765291"];

          if (!v22)
          {
            uint64_t v15 = v9;
            goto LABEL_12;
          }
          __int16 v23 = v9;

          if (v26)
          {
            [(HMMTRCharacteristicWriteRequestTuple *)v23 setCharacteristicHandlingType:3];
            char v26 = 1;
          }
          else
          {
            [(HMMTRCharacteristicWriteRequestTuple *)v23 setCharacteristicHandlingType:0];
            char v26 = 0;
          }
          __int16 v27 = v23;
        }
LABEL_25:
        objc_msgSend(v30, "addObject:", v9, v25);
      }
      uint64_t v5 = [obj countByEnumeratingWithState:&v31 objects:v35 count:16];
      if (!v5)
      {
LABEL_29:

        id v3 = v25;
        break;
      }
    }
  }

  return v30;
}

- (void)writeCharacteristicValues:(id)a3 timeout:(double)a4 completionQueue:(id)a5 completionHandler:(id)a6
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  id v10 = a3;
  uint64_t v11 = a5;
  id v12 = a6;
  if (!v11 || (id v13 = v12) == 0) {
    _HMFPreconditionFailure();
  }
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    int v14 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v15 = self;
    uint64_t v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      id v17 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      long long v33 = v17;
      _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting writing characteristic.", buf, 0xCu);
    }
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke;
    block[3] = &unk_265377430;
    id v31 = v13;
    dispatch_async(v11, block);
  }
  else
  {
    int v18 = (void *)random();
    char v19 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v20 = self;
    __int16 v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      int v22 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543874;
      long long v33 = v22;
      __int16 v34 = 2112;
      id v35 = v10;
      __int16 v36 = 2048;
      int v37 = v18;
      _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Write characteristics(%@) job(%lu) queued.", buf, 0x20u);
    }
    objc_initWeak((id *)buf, v20);
    v25[0] = MEMORY[0x263EF8330];
    v25[1] = 3221225472;
    v25[2] = __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_504;
    v25[3] = &unk_265377850;
    objc_copyWeak(v29, (id *)buf);
    v29[1] = v18;
    v29[2] = *(id *)&a4;
    id v28 = v13;
    char v26 = v11;
    id v27 = v10;
    v23[0] = MEMORY[0x263EF8330];
    v23[1] = 3221225472;
    v23[2] = __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_510;
    void v23[3] = &unk_2653787C8;
    id v24 = v28;
    [(HMMTRAccessoryServer *)v20 queueAccessoryOperation:v25 highPriority:1 completion:v23];

    objc_destroyWeak(v29);
    objc_destroyWeak((id *)buf);
  }
}

void __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
  (*(void (**)(uint64_t, void, id))(v1 + 16))(v1, 0, v2);
}

void __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_504(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  id v3 = (void *)MEMORY[0x2533B64D0]();
  id v4 = WeakRetained;
  uint64_t v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    uint64_t v7 = *(void *)(a1 + 64);
    *(_DWORD *)long long buf = 138543618;
    id v24 = v6;
    __int16 v25 = 2048;
    uint64_t v26 = v7;
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Write characteristics job(%lu) started.", buf, 0x16u);
  }
  uint64_t v8 = dispatch_group_create();
  dispatch_group_enter(v8);
  long long v9 = [v4 clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_505;
  block[3] = &unk_265377828;
  void block[4] = v4;
  uint64_t v21 = *(void *)(a1 + 72);
  id v20 = *(id *)(a1 + 48);
  id v17 = v8;
  id v18 = *(id *)(a1 + 32);
  id v10 = *(id *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 64);
  id v19 = v10;
  uint64_t v22 = v11;
  id v12 = v8;
  dispatch_async(v9, block);

  id v13 = [v4 clientQueue];
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_509;
  v15[3] = &unk_265377168;
  uint64_t v14 = *(void *)(a1 + 64);
  void v15[4] = v4;
  void v15[5] = v14;
  dispatch_group_notify(v12, v13, v15);
}

uint64_t __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_510(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_505(uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = HMFGetLogIdentifier();
    id v6 = [NSNumber numberWithDouble:*(double *)(a1 + 72)];
    *(_DWORD *)long long buf = 138543618;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to send write requests with time out %@", buf, 0x16u);
  }
  uint64_t v7 = [*(id *)(a1 + 32) deviceController];
  if (v7)
  {
    *(void *)long long buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v39 = 0;
    v27[0] = MEMORY[0x263EF8330];
    v27[1] = 3221225472;
    v27[2] = __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_2;
    void v27[3] = &unk_265377800;
    uint64_t v8 = *(void *)(a1 + 32);
    id v31 = buf;
    v27[4] = v8;
    id v28 = *(id *)(a1 + 48);
    id v30 = *(id *)(a1 + 64);
    id v29 = *(id *)(a1 + 40);
    long long v9 = (void (**)(void, void, void))MEMORY[0x2533B66E0](v27);
    id v10 = [*(id *)(a1 + 32) _populateHandlingForCharacteristics:*(void *)(a1 + 56)];
    uint64_t v11 = [*(id *)(a1 + 32) matterDevice];

    if (v11)
    {
      [*(id *)(a1 + 32) _writeCharacteristicValues:v10 responseTuples:0 completionQueue:*(void *)(a1 + 48) completionHandler:v9];
      dispatch_time_t v12 = dispatch_time(0, 60000000000);
      id v13 = [*(id *)(a1 + 32) clientQueue];
      block[0] = MEMORY[0x263EF8330];
      block[1] = 3221225472;
      block[2] = __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_2_508;
      block[3] = &unk_265377430;
      uint64_t v26 = v9;
      dispatch_after(v12, v13, block);

      uint64_t v14 = v26;
    }
    else
    {
      id v20 = (void *)MEMORY[0x2533B64D0]();
      id v21 = *(id *)(a1 + 32);
      HMFGetOSLogHandle();
      uint64_t v22 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        __int16 v23 = HMFGetLogIdentifier();
        uint64_t v24 = *(void *)(a1 + 80);
        *(_DWORD *)__int16 v34 = 138543618;
        id v35 = v23;
        __int16 v36 = 2048;
        uint64_t v37 = v24;
        _os_log_impl(&dword_252495000, v22, OS_LOG_TYPE_ERROR, "%{public}@Write characteristics job(%lu) started without an available MTRDevice", v34, 0x16u);
      }
      uint64_t v14 = [MEMORY[0x263F087E8] hapErrorWithCode:13];
      ((void (**)(void, void, void *))v9)[2](v9, 0, v14);
    }

    _Block_object_dispose(buf, 8);
  }
  else
  {
    uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = *(id *)(a1 + 32);
    id v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      id v18 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v18;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to write characteristics", buf, 0xCu);
    }
    id v19 = [*(id *)(a1 + 32) clientQueue];
    v32[0] = MEMORY[0x263EF8330];
    v32[1] = 3221225472;
    v32[2] = __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_506;
    v32[3] = &unk_265377430;
    id v33 = *(id *)(a1 + 64);
    dispatch_async(v19, v32);

    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
}

void __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_509(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    uint64_t v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Write characteristics job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_506(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
  (*(void (**)(uint64_t, void, id))(v1 + 16))(v1, 0, v2);
}

void __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8);
  if (!*(unsigned char *)(v7 + 24))
  {
    *(unsigned char *)(v7 + 24) = 1;
    uint64_t v8 = (void *)MEMORY[0x2533B64D0]();
    id v9 = *(id *)(a1 + 32);
    uint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      long long v45 = v11;
      __int16 v46 = 2112;
      id v47 = v6;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Write completion error: %@", buf, 0x16u);
    }
    id v31 = v6;

    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    id v32 = v5;
    id obj = v5;
    uint64_t v12 = [obj countByEnumeratingWithState:&v40 objects:v52 count:16];
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v14 = *(void *)v41;
      uint64_t v33 = a1;
      uint64_t v34 = *(void *)v41;
      do
      {
        for (uint64_t i = 0; i != v13; ++i)
        {
          if (*(void *)v41 != v14) {
            objc_enumerationMutation(obj);
          }
          id v16 = *(void **)(*((void *)&v40 + 1) + 8 * i);
          id v17 = (void *)MEMORY[0x2533B64D0]();
          id v18 = *(id *)(a1 + 32);
          id v19 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
          {
            id v20 = HMFGetLogIdentifier();
            id v21 = [v16 characteristic];
            uint64_t v22 = [v21 instanceID];
            __int16 v23 = [v16 value];
            uint64_t v24 = [v16 error];
            *(_DWORD *)long long buf = 138544130;
            long long v45 = v20;
            __int16 v46 = 2112;
            id v47 = v22;
            __int16 v48 = 2112;
            __int16 v49 = v23;
            __int16 v50 = 2112;
            __int16 v51 = v24;
            _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_INFO, "%{public}@Write completion contains tuple for characteristic %@ with value:%@ Error: %@", buf, 0x2Au);

            a1 = v33;
            uint64_t v14 = v34;
          }
        }
        uint64_t v13 = [obj countByEnumeratingWithState:&v40 objects:v52 count:16];
      }
      while (v13);
    }

    __int16 v25 = *(NSObject **)(a1 + 40);
    id v6 = v31;
    if (v25)
    {
      uint64_t v26 = *(void **)(a1 + 56);
      if (v26)
      {
        if (v31)
        {
          uint64_t v27 = (void *)MEMORY[0x263F087E8];
          id v28 = [v31 domain];
          id v29 = objc_msgSend(v27, "errorWithDomain:code:userInfo:", v28, objc_msgSend(v31, "code"), 0);

          __int16 v25 = *(NSObject **)(a1 + 40);
          uint64_t v26 = *(void **)(a1 + 56);
        }
        else
        {
          id v29 = 0;
        }
        block[0] = MEMORY[0x263EF8330];
        block[1] = 3221225472;
        block[2] = __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_507;
        block[3] = &unk_265378900;
        id v39 = v26;
        id v37 = obj;
        id v38 = v29;
        id v30 = v29;
        dispatch_async(v25, block);
      }
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
    id v5 = v32;
  }
}

void __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_2_508(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] errorWithDomain:@"HMMTRProtocolOperationErrorDomain" code:3 userInfo:0];
  (*(void (**)(uint64_t, void, id))(v1 + 16))(v1, 0, v2);
}

uint64_t __92__HMMTRAccessoryServer_writeCharacteristicValues_timeout_completionQueue_completionHandler___block_invoke_507(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

- (void)_writeCharacteristicValues:(id)a3 responseTuples:(id)a4 completionQueue:(id)a5 completionHandler:(id)a6
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = a6;
  uint64_t v14 = v11;
  id v15 = v13;
  id v16 = (void *)MEMORY[0x2533B64D0]();
  id v17 = self;
  id v18 = HMFGetOSLogHandle();
  __int16 v55 = v15;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    id v19 = HMFGetLogIdentifier();
    uint64_t v20 = [v10 count];
    uint64_t v21 = MEMORY[0x2533B66E0](v15);
    id v22 = v10;
    __int16 v23 = (void *)v21;
    *(_DWORD *)long long buf = 138544642;
    __int16 v66 = v19;
    __int16 v67 = 2048;
    uint64_t v68 = v20;
    __int16 v69 = 2112;
    id v70 = v22;
    __int16 v71 = 2112;
    id v72 = v11;
    __int16 v73 = 2112;
    id v74 = v12;
    __int16 v75 = 2112;
    uint64_t v76 = v21;
    _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_DEBUG, "%{public}@_writeCharacteristicValues count %lu, characteristicWriteRequests %@, responseTuples %@, completionQueue %@, completionHandler %@", buf, 0x3Eu);

    id v10 = v22;
    id v15 = v55;
  }
  uint64_t v24 = +[HMMTRProtocolOperationManager sharedInstance];
  if ([v10 count])
  {
    uint64_t v53 = v10;
    uint64_t v54 = v24;
    __int16 v51 = v12;
    __int16 v25 = [v10 popFirstObject];
    if (!v14)
    {
      uint64_t v14 = [MEMORY[0x263EFF980] array];
    }
    uint64_t v52 = v14;
    uint64_t v26 = [v25 primary];
    uint64_t v27 = [v26 characteristic];
    [(HMMTRAccessoryServer *)v17 _populateServiceForCharacteristic:v27];

    id v28 = [HMMTRProtocolOperation alloc];
    uint64_t v29 = [v25 characteristicHandlingType];
    id v30 = [v25 primary];
    id v31 = [v30 characteristic];
    id v32 = [v25 primary];
    uint64_t v33 = [v32 value];
    uint64_t v34 = [(HMMTRAccessoryServer *)v17 matterDevice];
    id v35 = [(HMMTRAccessoryServer *)v17 clusterIDCharacteristicMap];
    __int16 v36 = [(HMMTRProtocolOperation *)v28 initWithOperationOfType:1 characteristicHandlingType:v29 targetCharacteristic:v31 targetValue:v33 matterDevice:v34 clusterIDCharacteristicMap:v35];

    id v37 = [v25 primary];
    [(HMMTRProtocolOperation *)v36 setWritePrimaryRequestTuple:v37];

    id v38 = [v25 secondary];
    [(HMMTRProtocolOperation *)v36 setWriteSecondaryRequestTuple:v38];

    id v39 = [HMMTRDeviceTopology alloc];
    long long v40 = [(HMMTRAccessoryServer *)v17 nodeID];
    long long v41 = [(HMMTRDeviceTopology *)v39 initWithNodeId:v40 server:v17];
    [(HMMTRProtocolOperation *)v36 setTopology:v41];

    if (v36)
    {
      v56[0] = MEMORY[0x263EF8330];
      v56[1] = 3221225472;
      void v56[2] = __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke;
      v56[3] = &unk_2653777D8;
      id v42 = v25;
      id v57 = v42;
      uint64_t v14 = v52;
      id v58 = v52;
      __int16 v59 = v17;
      id v10 = v53;
      id v60 = v53;
      id v61 = v51;
      id v64 = v55;
      id v62 = v54;
      __int16 v63 = v36;
      long long v43 = (void *)MEMORY[0x2533B66E0](v56);
      long long v44 = [v42 primary];
      long long v45 = [v44 characteristic];
      [(HMMTRAccessoryServer *)v17 _queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic:v45 completion:v43];

      id v12 = v51;
      id v15 = v55;

      __int16 v46 = v57;
    }
    else
    {
      __int16 v46 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:3 userInfo:0];
      id v47 = (void *)MEMORY[0x263F358E8];
      __int16 v48 = [v25 primary];
      __int16 v49 = [v48 characteristic];
      __int16 v50 = [v47 responseTupleForCharacteristic:v49 error:v46];

      uint64_t v14 = v52;
      [v52 addObject:v50];
      id v10 = v53;
      id v12 = v51;
      id v15 = v55;
      [(HMMTRAccessoryServer *)v17 _writeCharacteristicValues:v53 responseTuples:v52 completionQueue:v51 completionHandler:v55];
    }
    uint64_t v24 = v54;
  }
  else
  {
    (*((void (**)(id, void *, void))v15 + 2))(v15, v14, 0);
  }
}

void __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke(uint64_t a1, int a2)
{
  if (a2)
  {
    id v3 = (void *)MEMORY[0x263F358E8];
    id v4 = [*(id *)(a1 + 32) primary];
    id v5 = [v4 characteristic];
    id v6 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:-70402 userInfo:0];
    uint64_t v7 = [v3 responseTupleForCharacteristic:v5 error:v6];

    [*(id *)(a1 + 40) addObject:v7];
    uint64_t v8 = [*(id *)(a1 + 48) clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke_2;
    block[3] = &unk_265377CF8;
    id v9 = *(void **)(a1 + 56);
    void block[4] = *(void *)(a1 + 48);
    id v26 = v9;
    id v27 = *(id *)(a1 + 40);
    id v28 = *(id *)(a1 + 64);
    id v29 = *(id *)(a1 + 88);
    dispatch_async(v8, block);
  }
  else
  {
    id v10 = *(void **)(a1 + 72);
    uint64_t v11 = *(void *)(a1 + 80);
    id v12 = *(void **)(a1 + 48);
    id v13 = [v12 clientQueue];
    uint64_t v14 = [*(id *)(a1 + 48) reportDistributor];
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke_3;
    v19[3] = &unk_2653772C8;
    id v15 = *(id *)(a1 + 40);
    uint64_t v16 = *(void *)(a1 + 48);
    id v17 = *(void **)(a1 + 56);
    id v20 = v15;
    uint64_t v21 = v16;
    id v22 = v17;
    id v23 = *(id *)(a1 + 64);
    id v24 = *(id *)(a1 + 88);
    v18[0] = MEMORY[0x263EF8330];
    v18[1] = 3221225472;
    v18[2] = __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke_4;
    v18[3] = &unk_2653777B0;
    void v18[4] = *(void *)(a1 + 48);
    [v10 registerOperation:v11 accessoryServer:v12 clientQueue:v13 reportDistributor:v14 operationResponseHandler:v19 updatedAttributesHandler:v18];

    uint64_t v7 = v20;
  }
}

uint64_t __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke_2(uint64_t a1)
{
  return [*(id *)(a1 + 32) _writeCharacteristicValues:*(void *)(a1 + 40) responseTuples:*(void *)(a1 + 48) completionQueue:*(void *)(a1 + 56) completionHandler:*(void *)(a1 + 64)];
}

uint64_t __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke_3(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) addObject:a2];
  uint64_t v4 = *(void *)(a1 + 32);
  id v3 = *(void **)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = *(void *)(a1 + 64);
  return [v3 _writeCharacteristicValues:v5 responseTuples:v4 completionQueue:v6 completionHandler:v7];
}

void __100__HMMTRAccessoryServer__writeCharacteristicValues_responseTuples_completionQueue_completionHandler___block_invoke_4(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 matterDevice];
  [v2 device:v4 receivedAttributeReport:v3];
}

- (void)readCharacteristicValues:(id)a3 timeout:(double)a4 completionQueue:(id)a5 completionHandler:(id)a6
{
}

- (void)_readCharacteristicValues:(id)a3 timeout:(double)a4 skipCache:(BOOL)a5 sendNotification:(BOOL)a6 completionQueue:(id)a7 completionHandler:(id)a8
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  id v14 = a3;
  id v15 = a7;
  id v16 = a8;
  if (!v15 || (id v17 = v16) == 0) {
    _HMFPreconditionFailure();
  }
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    id v18 = (void *)MEMORY[0x2533B64D0]();
    id v19 = self;
    id v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      uint64_t v21 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      long long v41 = v21;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting reading characteristic.", buf, 0xCu);
    }
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke;
    block[3] = &unk_265377430;
    id v39 = v17;
    dispatch_async(v15, block);
    id v22 = v39;
  }
  else
  {
    uint64_t v23 = random();
    id v24 = (void *)MEMORY[0x2533B64D0]();
    __int16 v25 = self;
    id v26 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
    {
      id v27 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543874;
      long long v41 = v27;
      __int16 v42 = 2112;
      id v43 = v14;
      __int16 v44 = 2048;
      uint64_t v45 = v23;
      _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Read characteristics(%@) job(%lu) queued.", buf, 0x20u);
    }
    v30[0] = MEMORY[0x263EF8330];
    v30[1] = 3221225472;
    v30[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_494;
    v30[3] = &unk_265377788;
    void v30[4] = v25;
    uint64_t v34 = v23;
    double v35 = a4;
    id v31 = v14;
    BOOL v36 = a5;
    id v32 = v15;
    id v33 = v17;
    BOOL v37 = a6;
    v28[0] = MEMORY[0x263EF8330];
    v28[1] = 3221225472;
    v28[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_503;
    v28[3] = &unk_2653787C8;
    id v29 = v33;
    [(HMMTRAccessoryServer *)v25 queueAccessoryOperation:v30 highPriority:0 completion:v28];

    id v22 = v31;
  }
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
  (*(void (**)(uint64_t, void, id))(v1 + 16))(v1, 0, v2);
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_494(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 64);
    *(_DWORD *)long long buf = 138543618;
    __int16 v25 = v5;
    __int16 v26 = 2048;
    uint64_t v27 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Read characteristics job(%lu) started.", buf, 0x16u);
  }
  uint64_t v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  uint64_t v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_495;
  block[3] = &unk_265377760;
  id v9 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  uint64_t v20 = *(void *)(a1 + 72);
  id v16 = v9;
  char v22 = *(unsigned char *)(a1 + 80);
  id v17 = *(id *)(a1 + 48);
  id v10 = *(id *)(a1 + 56);
  char v23 = *(unsigned char *)(a1 + 81);
  id v18 = v7;
  id v19 = v10;
  uint64_t v21 = *(void *)(a1 + 64);
  uint64_t v11 = v7;
  dispatch_async(v8, block);

  id v12 = [*(id *)(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x263EF8330];
  v14[1] = 3221225472;
  v14[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_3_502;
  v14[3] = &unk_265377168;
  uint64_t v13 = *(void *)(a1 + 64);
  v14[4] = *(void *)(a1 + 32);
  void v14[5] = v13;
  dispatch_group_notify(v11, v12, v14);
}

uint64_t __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_503(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_495(uint64_t a1)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = HMFGetLogIdentifier();
    uint64_t v6 = [NSNumber numberWithDouble:*(double *)(a1 + 72)];
    *(_DWORD *)long long buf = 138543618;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to send read requests with time out %@", buf, 0x16u);
  }
  *(void *)long long buf = 0;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000;
  id v62 = __Block_byref_object_copy__8456;
  __int16 v63 = __Block_byref_object_dispose__8457;
  id v64 = 0;
  v55[0] = 0;
  v55[1] = v55;
  void v55[2] = 0x3032000000;
  v55[3] = __Block_byref_object_copy__8456;
  v55[4] = __Block_byref_object_dispose__8457;
  id v56 = [MEMORY[0x263EFF980] array];
  dispatch_group_t v7 = dispatch_group_create();
  dispatch_group_t v8 = dispatch_group_create();
  v53[0] = 0;
  v53[1] = v53;
  void v53[2] = 0x2020000000;
  char v54 = 0;
  v51[0] = 0;
  v51[1] = v51;
  void v51[2] = 0x2020000000;
  char v52 = 0;
  v49[0] = 0;
  v49[1] = v49;
  void v49[2] = 0x2020000000;
  char v50 = 0;
  v33[0] = MEMORY[0x263EF8330];
  v33[1] = 3221225472;
  v33[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_496;
  v33[3] = &unk_265377710;
  long long v41 = v49;
  id v9 = *(id *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 32);
  id v34 = v9;
  uint64_t v35 = v10;
  __int16 v42 = v55;
  id v43 = v51;
  char v47 = *(unsigned char *)(a1 + 88);
  uint64_t v11 = v8;
  BOOL v36 = v11;
  __int16 v44 = v53;
  id v12 = v7;
  BOOL v37 = v12;
  uint64_t v45 = buf;
  id v38 = *(id *)(a1 + 48);
  id v40 = *(id *)(a1 + 64);
  char v48 = *(unsigned char *)(a1 + 89);
  id v13 = *(id *)(a1 + 56);
  uint64_t v14 = *(void *)(a1 + 80);
  id v39 = v13;
  uint64_t v46 = v14;
  id v15 = (void (**)(void))MEMORY[0x2533B66E0](v33);
  if ([*(id *)(a1 + 32) isReadyToReadFromMTRDevice])
  {
    v15[2](v15);
  }
  else
  {
    id v16 = (void *)MEMORY[0x2533B64D0]();
    id v17 = *(id *)(a1 + 32);
    HMFGetOSLogHandle();
    id v18 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      id v19 = HMFGetLogIdentifier();
      uint64_t v20 = *(void *)(a1 + 80);
      *(_DWORD *)id v57 = 138543618;
      id v58 = v19;
      __int16 v59 = 2048;
      uint64_t v60 = v20;
      _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_INFO, "%{public}@Read job(%lu) deferred till MTRDevice is ready to read from", v57, 0x16u);
    }
    uint64_t v21 = (void *)MEMORY[0x2533B66E0](v15);
    char v22 = [*(id *)(a1 + 32) pendingMTRDeviceReadReadyHandlers];
    char v23 = [NSNumber numberWithLong:*(void *)(a1 + 80)];
    [v22 setObject:v21 forKeyedSubscript:v23];

    id v24 = *(void **)(a1 + 32);
    dispatch_time_t v25 = dispatch_time(0, 60000000000);
    v27[0] = MEMORY[0x263EF8330];
    v27[1] = 3221225472;
    v27[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_500;
    void v27[3] = &unk_265377738;
    uint64_t v26 = *(void *)(a1 + 32);
    id v31 = v49;
    v27[4] = v26;
    uint64_t v32 = *(void *)(a1 + 80);
    id v28 = *(id *)(a1 + 48);
    id v30 = *(id *)(a1 + 64);
    id v29 = *(id *)(a1 + 56);
    [v24 dispatchAfter:v25 block:v27];
  }
  _Block_object_dispose(v49, 8);
  _Block_object_dispose(v51, 8);
  _Block_object_dispose(v53, 8);

  _Block_object_dispose(v55, 8);
  _Block_object_dispose(buf, 8);
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_3_502(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    dispatch_group_t v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: Read characteristics job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_496(uint64_t a1)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(*(void *)(a1 + 88) + 8);
  if (!*(unsigned char *)(v1 + 24))
  {
    *(unsigned char *)(v1 + 24) = 1;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    id obj = *(id *)(a1 + 32);
    uint64_t v3 = [obj countByEnumeratingWithState:&v59 objects:v63 count:16];
    if (v3)
    {
      uint64_t v4 = *(void *)v60;
      id v30 = v55;
      do
      {
        for (uint64_t i = 0; i != v3; ++i)
        {
          if (*(void *)v60 != v4) {
            objc_enumerationMutation(obj);
          }
          uint64_t v6 = *(void *)(*((void *)&v59 + 1) + 8 * i);
          objc_msgSend(*(id *)(a1 + 40), "_populateServiceForCharacteristic:", v6, v30);
          int v7 = [*(id *)(a1 + 40) _readFixedCharacteristicValue:v6];
          if (v7)
          {
            dispatch_group_t v8 = [MEMORY[0x263F358E8] responseTupleForCharacteristic:v6 error:0];
            [*(id *)(*(void *)(*(void *)(a1 + 96) + 8) + 40) addObject:v8];
            *(unsigned char *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = 1;
          }
          else
          {
            dispatch_group_t v8 = [*(id *)(a1 + 40) _readLocallyMaintainedCharacteristicValue:v6];
            if (v8)
            {
              __int16 v9 = [MEMORY[0x263F358E8] responseTupleForCharacteristic:v6 error:0];
              [*(id *)(*(void *)(*(void *)(a1 + 96) + 8) + 40) addObject:v9];
              *(unsigned char *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = 1;
            }
            else if (*(unsigned char *)(a1 + 136))
            {
              *(unsigned char *)(*(void *)(*(void *)(a1 + 112) + 8) + 24) = 1;
              uint64_t v10 = *(void **)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
              uint64_t v11 = (void *)MEMORY[0x263F358E8];
              __int16 v9 = [MEMORY[0x263F087E8] hmfErrorWithCode:11];
              id v12 = [v11 responseTupleForCharacteristic:v6 error:v9];
              [v10 addObject:v12];
            }
            else
            {
              dispatch_group_enter(*(dispatch_group_t *)(a1 + 48));
              v54[0] = MEMORY[0x263EF8330];
              v54[1] = 3221225472;
              v55[0] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_2;
              v55[1] = &unk_265377668;
              long long v57 = *(_OWORD *)(a1 + 104);
              uint64_t v58 = *(void *)(a1 + 96);
              id v13 = *(void **)(a1 + 40);
              id v56 = *(id *)(a1 + 48);
              [v13 _readCharacteristicValueFromCacheWithCharacteristic:v6 responseHandler:v54];
              __int16 v9 = v56;
            }
          }
        }
        uint64_t v3 = [obj countByEnumeratingWithState:&v59 objects:v63 count:16];
      }
      while (v3);
    }

    v52[0] = 0;
    v52[1] = v52;
    void v52[2] = 0x2020000000;
    char v53 = 0;
    dispatch_group_enter(*(dispatch_group_t *)(a1 + 56));
    uint64_t v14 = *(NSObject **)(a1 + 48);
    id v15 = [*(id *)(a1 + 40) clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_3;
    block[3] = &unk_265377690;
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v17 = *(void *)(a1 + 104);
    uint64_t v48 = *(void *)(a1 + 112);
    __int16 v49 = v52;
    void block[4] = v16;
    uint64_t v18 = *(void *)(a1 + 120);
    uint64_t v50 = v17;
    uint64_t v51 = v18;
    id v47 = *(id *)(a1 + 56);
    dispatch_group_notify(v14, v15, block);

    v39[0] = MEMORY[0x263EF8330];
    v39[1] = 3221225472;
    v39[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_497;
    v39[3] = &unk_2653776B8;
    __int16 v44 = v52;
    id v40 = *(id *)(a1 + 64);
    id v19 = *(id *)(a1 + 80);
    char v45 = *(unsigned char *)(a1 + 137);
    uint64_t v20 = *(void *)(a1 + 40);
    id v43 = v19;
    uint64_t v41 = v20;
    id v42 = *(id *)(a1 + 72);
    uint64_t v21 = (void *)MEMORY[0x2533B66E0](v39);
    dispatch_time_t v22 = dispatch_time(0, 60000000000);
    char v23 = [*(id *)(a1 + 40) clientQueue];
    v36[0] = MEMORY[0x263EF8330];
    v36[1] = 3221225472;
    v36[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_3_499;
    v36[3] = &unk_265377A50;
    uint64_t v24 = *(void *)(a1 + 128);
    void v36[4] = *(void *)(a1 + 40);
    uint64_t v38 = v24;
    id v25 = v21;
    id v37 = v25;
    dispatch_after(v22, v23, v36);

    uint64_t v26 = *(NSObject **)(a1 + 56);
    uint64_t v27 = [*(id *)(a1 + 40) clientQueue];
    v32[0] = MEMORY[0x263EF8330];
    v32[1] = 3221225472;
    v32[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_4;
    v32[3] = &unk_2653776E8;
    uint64_t v28 = *(void *)(a1 + 96);
    id v33 = v25;
    uint64_t v34 = v28;
    uint64_t v35 = *(void *)(a1 + 120);
    id v29 = v25;
    dispatch_group_notify(v26, v27, v32);

    _Block_object_dispose(v52, 8);
  }
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_500(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 64) + 8);
  if (!*(unsigned char *)(v1 + 24))
  {
    *(unsigned char *)(v1 + 24) = 1;
    uint64_t v3 = [*(id *)(a1 + 32) pendingMTRDeviceReadReadyHandlers];
    uint64_t v4 = [NSNumber numberWithLong:*(void *)(a1 + 72)];
    [v3 setObject:0 forKeyedSubscript:v4];

    uint64_t v5 = *(NSObject **)(a1 + 40);
    v6[0] = MEMORY[0x263EF8330];
    v6[1] = 3221225472;
    v6[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_2_501;
    v6[3] = &unk_2653770F0;
    id v8 = *(id *)(a1 + 56);
    id v7 = *(id *)(a1 + 48);
    dispatch_async(v5, v6);
  }
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_2_501(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = [MEMORY[0x263F087E8] errorWithDomain:@"HMMTRProtocolOperationErrorDomain" code:3 userInfo:0];
  (*(void (**)(uint64_t, void, void *))(v2 + 16))(v2, 0, v3);

  uint64_t v4 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v4);
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_2(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 error];

  uint64_t v5 = 48;
  if (!v4) {
    uint64_t v5 = 40;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + v5) + 8) + 24) = 1;
  [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) addObject:v3];

  uint64_t v6 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v6);
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_3(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)
    && !*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24))
  {
    uint64_t v2 = (void *)MEMORY[0x2533B64D0]();
    id v3 = *(id *)(a1 + 32);
    uint64_t v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = HMFGetLogIdentifier();
      int v9 = 138543362;
      uint64_t v10 = v5;
      _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_ERROR, "%{public}@Cache read didn't succeed for all requests.", (uint8_t *)&v9, 0xCu);
    }
    if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24))
    {
      uint64_t v6 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:1 userInfo:0];
      uint64_t v7 = *(void *)(*(void *)(a1 + 72) + 8);
      id v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = v6;
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_497(uint64_t a1, void *a2, void *a3)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(*(void *)(a1 + 64) + 8);
  if (!*(unsigned char *)(v8 + 24))
  {
    *(unsigned char *)(v8 + 24) = 1;
    if (!*(void *)(a1 + 32) || !*(void *)(a1 + 56)) {
      goto LABEL_22;
    }
    if (v6)
    {
      int v9 = (void *)MEMORY[0x263F087E8];
      uint64_t v10 = [v6 domain];
      uint64_t v11 = objc_msgSend(v9, "errorWithDomain:code:userInfo:", v10, objc_msgSend(v7, "code"), 0);

LABEL_21:
      dispatch_time_t v22 = *(NSObject **)(a1 + 32);
      block[0] = MEMORY[0x263EF8330];
      block[1] = 3221225472;
      block[2] = __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_2_498;
      block[3] = &unk_265378900;
      id v28 = *(id *)(a1 + 56);
      id v26 = v5;
      id v27 = v11;
      id v23 = v11;
      dispatch_async(v22, block);

LABEL_22:
      dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
      goto LABEL_23;
    }
    if (!*(unsigned char *)(a1 + 72))
    {
LABEL_20:
      uint64_t v11 = 0;
      goto LABEL_21;
    }
    id v12 = objc_alloc_init(MEMORY[0x263EFF980]);
    long long v29 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    id v13 = v5;
    uint64_t v14 = [v13 countByEnumeratingWithState:&v29 objects:v33 count:16];
    if (v14)
    {
      uint64_t v15 = v14;
      id v24 = v5;
      char v16 = 0;
      uint64_t v17 = *(void *)v30;
      do
      {
        for (uint64_t i = 0; i != v15; ++i)
        {
          if (*(void *)v30 != v17) {
            objc_enumerationMutation(v13);
          }
          id v19 = *(void **)(*((void *)&v29 + 1) + 8 * i);
          uint64_t v20 = objc_msgSend(v19, "error", v24);

          if (!v20)
          {
            uint64_t v21 = [v19 characteristic];
            [v12 addObject:v21];

            char v16 = 1;
          }
        }
        uint64_t v15 = [v13 countByEnumeratingWithState:&v29 objects:v33 count:16];
      }
      while (v15);

      id v5 = v24;
      if ((v16 & 1) == 0) {
        goto LABEL_19;
      }
      id v13 = [*(id *)(a1 + 40) delegate];
      [v13 accessoryServer:*(void *)(a1 + 40) didUpdateValuesForCharacteristics:v12 stateNumber:0 broadcast:0];
    }

LABEL_19:
    goto LABEL_20;
  }
LABEL_23:
}

void __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_3_499(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) pendingMTRDeviceReadReadyHandlers];
  id v3 = [NSNumber numberWithLong:*(void *)(a1 + 48)];
  [v2 setObject:0 forKeyedSubscript:v3];

  uint64_t v4 = *(void *)(a1 + 40);
  id v5 = [MEMORY[0x263F087E8] errorWithDomain:@"HMMTRProtocolOperationErrorDomain" code:3 userInfo:0];
  (*(void (**)(uint64_t, void, id))(v4 + 16))(v4, 0, v5);
}

uint64_t __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_4(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[4] + 16))(a1[4], *(void *)(*(void *)(a1[5] + 8) + 40), *(void *)(*(void *)(a1[6] + 8) + 40));
}

uint64_t __119__HMMTRAccessoryServer__readCharacteristicValues_timeout_skipCache_sendNotification_completionQueue_completionHandler___block_invoke_2_498(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

- (id)_readLocallyMaintainedCharacteristicValue:(id)a3
{
  id v4 = a3;
  id v5 = [v4 type];
  int v6 = [v5 isEqual:@"0000026E-0000-1000-8000-0026BB765291"];

  if (v6)
  {
    uint64_t v7 = [(HMMTRAccessoryServer *)self matterFirmwareUpdateStatus];
    uint64_t v8 = [v7 readForMatterFirmwareUpdateStatusCharacteristic:v4];
LABEL_7:
    id v13 = (void *)v8;

    goto LABEL_8;
  }
  int v9 = [v4 type];
  int v10 = [v9 isEqual:@"00000235-0000-1000-8000-0026BB765291"];

  if (v10)
  {
    uint64_t v7 = [(HMMTRAccessoryServer *)self matterFirmwareUpdateStatus];
    uint64_t v8 = [v7 readForHAPFirmwareUpdateStatusCharacteristic:v4];
    goto LABEL_7;
  }
  uint64_t v11 = [v4 type];
  int v12 = [v11 isEqual:@"00000234-0000-1000-8000-0026BB765291"];

  if (v12)
  {
    uint64_t v7 = [(HMMTRAccessoryServer *)self matterFirmwareUpdateStatus];
    uint64_t v8 = [v7 readForHAPFirmwareUpdateReadinessCharacteristic:v4];
    goto LABEL_7;
  }
  id v13 = 0;
LABEL_8:

  return v13;
}

- (void)_readCharacteristicValueFromCacheAfterConfirmingBridgedAccessroyReachabilityWithCharacteristic:(id)a3 responseHandler:(id)a4
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  id v6 = a3;
  uint64_t v7 = (void (**)(id, void *))a4;
  uint64_t v8 = [(HMMTRAccessoryServer *)self matterDevice];

  int v9 = (void *)MEMORY[0x2533B64D0]();
  int v10 = self;
  uint64_t v11 = HMFGetOSLogHandle();
  int v12 = v11;
  if (v8)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      id v13 = HMFGetLogIdentifier();
      int v28 = 138543618;
      long long v29 = v13;
      __int16 v30 = 2112;
      id v31 = v6;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_DEBUG, "%{public}@Read cache operation starts for characteristic: %@", (uint8_t *)&v28, 0x16u);
    }
    uint64_t v14 = [HMMTRProtocolOperation alloc];
    uint64_t v15 = [(HMMTRAccessoryServer *)v10 matterDevice];
    char v16 = [(HMMTRAccessoryServer *)v10 clusterIDCharacteristicMap];
    uint64_t v17 = [(HMMTRProtocolOperation *)v14 initWithOperationOfType:4 characteristic:v6 matterDevice:v15 clusterIDCharacteristicMap:v16];

    if (v17)
    {
      uint64_t v18 = +[HMMTRProtocolOperationManager sharedInstance];
      id v19 = [(HAPAccessoryServer *)v10 clientQueue];
      uint64_t v20 = [(HMMTRAccessoryServer *)v10 reportDistributor];
      [v18 registerOperation:v17 accessoryServer:v10 clientQueue:v19 reportDistributor:v20 operationResponseHandler:v7 updatedAttributesHandler:0];
    }
    else
    {
      id v23 = (void *)MEMORY[0x2533B64D0]();
      id v24 = v10;
      id v25 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        id v26 = HMFGetLogIdentifier();
        int v28 = 138543618;
        long long v29 = v26;
        __int16 v30 = 2112;
        id v31 = v6;
        _os_log_impl(&dword_252495000, v25, OS_LOG_TYPE_DEBUG, "%{public}@Read cache operation failed to be created for characteristic: %@", (uint8_t *)&v28, 0x16u);
      }
      id v27 = (void *)MEMORY[0x263F358E8];
      uint64_t v18 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:14 userInfo:0];
      id v19 = [v27 responseTupleForCharacteristic:v6 error:v18];
      v7[2](v7, v19);
    }
  }
  else
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v21 = HMFGetLogIdentifier();
      int v28 = 138543618;
      long long v29 = v21;
      __int16 v30 = 2112;
      id v31 = v6;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_ERROR, "%{public}@MTRDevice unavailable to read characteristic value from cache for characteristic %@", (uint8_t *)&v28, 0x16u);
    }
    dispatch_time_t v22 = (void *)MEMORY[0x263F358E8];
    uint64_t v17 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:14 userInfo:0];
    uint64_t v18 = [v22 responseTupleForCharacteristic:v6 error:v17];
    v7[2](v7, v18);
  }
}

- (void)_readCharacteristicValueFromCacheWithCharacteristic:(id)a3 responseHandler:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 3221225472;
  v10[2] = __92__HMMTRAccessoryServer__readCharacteristicValueFromCacheWithCharacteristic_responseHandler___block_invoke;
  v10[3] = &unk_265377640;
  void v10[4] = self;
  id v11 = v6;
  id v12 = v7;
  id v8 = v7;
  id v9 = v6;
  [(HMMTRAccessoryServer *)self _queryBridgedAccessoryAndUnreachablePerCacheForCharacteristic:v9 completion:v10];
}

void __92__HMMTRAccessoryServer__readCharacteristicValueFromCacheWithCharacteristic_responseHandler___block_invoke(uint64_t a1, int a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (a2)
  {
    id v3 = (void *)MEMORY[0x2533B64D0]();
    id v4 = *(id *)(a1 + 32);
    id v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      id v6 = HMFGetLogIdentifier();
      uint64_t v7 = *(void *)(a1 + 40);
      int v17 = 138543618;
      uint64_t v18 = v6;
      __int16 v19 = 2112;
      uint64_t v20 = v7;
      _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_ERROR, "%{public}@Read cache operation aborted for characteristic since the bridged accessory is unreachable: %@", (uint8_t *)&v17, 0x16u);
    }
    id v8 = (void *)MEMORY[0x263F358E8];
    uint64_t v11 = a1 + 40;
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v10 = *(void *)(v11 + 8);
    id v12 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F355F0] code:-70402 userInfo:0];
    id v13 = [v8 responseTupleForCharacteristic:v9 error:v12];
    (*(void (**)(uint64_t, void *))(v10 + 16))(v10, v13);
  }
  else
  {
    uint64_t v14 = *(void **)(a1 + 32);
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v16 = *(void *)(a1 + 48);
    [v14 _readCharacteristicValueFromCacheAfterConfirmingBridgedAccessroyReachabilityWithCharacteristic:v15 responseHandler:v16];
  }
}

- (id)_readFixedCharacteristicValue:(id)a3
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [v4 type];
  if ([v5 isEqual:@"000000CB-0000-1000-8000-0026BB765291"])
  {
  }
  else
  {
    id v6 = [v4 type];
    int v7 = [v6 isEqual:@"000000CD-0000-1000-8000-0026BB765291"];

    if (!v7)
    {
      id v12 = 0;
      goto LABEL_8;
    }
  }
  id v8 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v9 = self;
  uint64_t v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v11 = HMFGetLogIdentifier();
    int v14 = 138543618;
    uint64_t v15 = v11;
    __int16 v16 = 2112;
    id v17 = v4;
    _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_DEBUG, "%{public}@Read operation on fixed value characteristic: %@", (uint8_t *)&v14, 0x16u);
  }
  id v12 = [v4 value];
LABEL_8:

  return v12;
}

- (void)removeAllPairingsWithCompletionHandler:(id)a3
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v4 = a3;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = self;
    int v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v24 = v8;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting removing all pairings.", buf, 0xCu);
    }
    uint64_t v9 = [(HAPAccessoryServer *)v6 clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke;
    block[3] = &unk_265377430;
    id v22 = v4;
    dispatch_async(v9, block);

    id v10 = v22;
  }
  else
  {
    uint64_t v11 = random();
    id v12 = (void *)MEMORY[0x2533B64D0]();
    id v13 = self;
    int v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      uint64_t v15 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      id v24 = v15;
      __int16 v25 = 2048;
      uint64_t v26 = v11;
      _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove all pairings job(%lu) queued.", buf, 0x16u);
    }
    v18[0] = MEMORY[0x263EF8330];
    v18[1] = 3221225472;
    v18[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_472;
    v18[3] = &unk_265377A50;
    void v18[4] = v13;
    uint64_t v20 = v11;
    id v19 = v4;
    v16[0] = MEMORY[0x263EF8330];
    v16[1] = 3221225472;
    v16[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_479;
    v16[3] = &unk_2653787C8;
    id v17 = v19;
    [(HMMTRAccessoryServer *)v13 queueAccessoryOperation:v18 highPriority:1 completion:v16];

    id v10 = v19;
  }
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_472(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138543618;
    uint64_t v18 = v5;
    __int16 v19 = 2048;
    uint64_t v20 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove all pairings job(%lu) started.", buf, 0x16u);
  }
  int v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_473;
  block[3] = &unk_265378900;
  uint64_t v9 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  uint64_t v15 = v7;
  id v16 = v9;
  id v10 = v7;
  dispatch_async(v8, block);

  uint64_t v11 = [*(id *)(a1 + 32) clientQueue];
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  v13[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_478;
  v13[3] = &unk_265377168;
  uint64_t v12 = *(void *)(a1 + 48);
  void v13[4] = *(void *)(a1 + 32);
  void v13[5] = v12;
  dispatch_group_notify(v10, v11, v13);
}

uint64_t __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_479(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_473(id *a1)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = a1[4];
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    uint64_t v27 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Removing all pairings", buf, 0xCu);
  }
  v23[0] = MEMORY[0x263EF8330];
  v23[1] = 3221225472;
  v23[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_474;
  void v23[3] = &unk_265378578;
  id v25 = a1[6];
  id v24 = a1[5];
  uint64_t v6 = (void *)MEMORY[0x2533B66E0](v23);
  int v7 = [a1[4] deviceController];
  if (v7)
  {
    id v8 = [a1[4] nodeID];
    uint64_t v9 = [v8 unsignedLongLongValue];
    id v10 = [a1[4] clientQueue];
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_2;
    v19[3] = &unk_265377520;
    void v19[4] = a1[4];
    uint64_t v20 = v6;
    id v11 = v6;
    [v7 getBaseDevice:v9 queue:v10 completionHandler:v19];

    uint64_t v12 = v20;
  }
  else
  {
    id v13 = (void *)MEMORY[0x2533B64D0]();
    id v14 = a1[4];
    uint64_t v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      id v16 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v27 = v16;
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to remove all pairings", buf, 0xCu);
    }
    id v17 = [a1[4] clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_475;
    block[3] = &unk_265377430;
    id v22 = v6;
    id v18 = v6;
    dispatch_async(v17, block);

    uint64_t v12 = v22;
  }
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_478(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove all pairings job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_474(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v2);
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_475(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    id v7 = objc_alloc(MEMORY[0x263F42520]);
    id v8 = [*(id *)(a1 + 32) clientQueue];
    __int16 v9 = (void *)[v7 initWithQueue:v8];

    *(void *)long long buf = _HMFThreadLocalAsyncContextPush();
    uint64_t v10 = +[HMMTRDescriptorClusterManager sharedManager];
    uint64_t v11 = [*(id *)(a1 + 32) clientQueue];
    uint64_t v12 = [v10 runBlockForAllEndpointsWithClusterID:&unk_2702B59A0 device:v5 callbackQueue:v11 block:&__block_literal_global_477];
    v21[0] = MEMORY[0x263EF8330];
    v21[1] = 3221225472;
    void v21[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_4;
    v21[3] = &unk_265377618;
    id v13 = v5;
    uint64_t v14 = *(void *)(a1 + 32);
    uint64_t v15 = *(void **)(a1 + 40);
    id v22 = v13;
    uint64_t v23 = v14;
    id v24 = v15;
    id v16 = (id)[v12 finally:v21];

    _HMFThreadLocalAsyncContextPop();
  }
  else
  {
    id v17 = (void *)MEMORY[0x2533B64D0]();
    id v18 = *(id *)(a1 + 32);
    __int16 v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      *(void *)&uint8_t buf[4] = v20;
      __int16 v26 = 2112;
      id v27 = v6;
      _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_ERROR, "%{public}@Could not fetch pairings because no device paired: %@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

uint64_t __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_4(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) clientQueue];
  id v4 = [*(id *)(a1 + 40) browser];
  id v5 = [v4 vendorMetadataStore];
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 3221225472;
  void v8[2] = __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_5;
  v8[3] = &unk_265378578;
  id v6 = *(void **)(a1 + 48);
  v8[4] = *(void *)(a1 + 40);
  id v9 = v6;
  [v2 removeAllPairingsForCallbackQueue:v3 vendorMetadataStore:v5 completionHandler:v8];

  return 1;
}

void __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_5(uint64_t a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  id v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v8 = HMFGetLogIdentifier();
      int v10 = 138543618;
      uint64_t v11 = v8;
      __int16 v12 = 2112;
      id v13 = v3;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to remove all pairings: %@", (uint8_t *)&v10, 0x16u);
    }
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      int v10 = 138543362;
      uint64_t v11 = v9;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Successfully removed all pairings.", (uint8_t *)&v10, 0xCu);
    }
    [*(id *)(a1 + 32) setOperationDisabled:1];
    [*(id *)(a1 + 32) setOperationDisabledReason:2];
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

uint64_t __63__HMMTRAccessoryServer_removeAllPairingsWithCompletionHandler___block_invoke_3()
{
  return [MEMORY[0x263F42538] futureWithNoValue];
}

- (void)fetchExtendedMACAddressFromDevice:(id)a3 completion:(id)a4
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    id v8 = (void *)MEMORY[0x2533B64D0]();
    id v9 = self;
    int v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v28 = v11;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fetching eMAC address.", buf, 0xCu);
    }
    __int16 v12 = [(HAPAccessoryServer *)v9 clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke;
    block[3] = &unk_265377430;
    id v26 = v7;
    dispatch_async(v12, block);

    id v13 = v26;
  }
  else
  {
    uint64_t v14 = random();
    uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = self;
    id v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      id v18 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      uint64_t v28 = v18;
      __int16 v29 = 2048;
      uint64_t v30 = v14;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch eMAC address job(%lu) queued.", buf, 0x16u);
    }
    v21[0] = MEMORY[0x263EF8330];
    v21[1] = 3221225472;
    void v21[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_461;
    v21[3] = &unk_265377408;
    void v21[4] = v16;
    uint64_t v24 = v14;
    id v23 = v7;
    id v22 = v6;
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_471;
    v19[3] = &unk_2653787C8;
    id v20 = v23;
    [(HMMTRAccessoryServer *)v16 queueAccessoryOperation:v21 highPriority:0 completion:v19];

    id v13 = v23;
  }
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
  (*(void (**)(uint64_t, void, id))(v1 + 16))(v1, 0, v2);
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_461(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 56);
    *(_DWORD *)long long buf = 138543618;
    id v18 = v5;
    __int16 v19 = 2048;
    uint64_t v20 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch eMAC address job(%lu) started.", buf, 0x16u);
  }
  id v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_462;
  block[3] = &unk_2653775F0;
  void block[4] = *(void *)(a1 + 32);
  id v16 = *(id *)(a1 + 48);
  uint64_t v14 = v7;
  id v15 = *(id *)(a1 + 40);
  id v9 = v7;
  dispatch_async(v8, block);

  int v10 = [*(id *)(a1 + 32) clientQueue];
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 3221225472;
  v12[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_470;
  v12[3] = &unk_265377168;
  uint64_t v11 = *(void *)(a1 + 56);
  void v12[4] = *(void *)(a1 + 32);
  void v12[5] = v11;
  dispatch_group_notify(v9, v10, v12);
}

uint64_t __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_471(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_462(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    id v16 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Fetching eMAC address", buf, 0xCu);
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 3221225472;
  v12[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_463;
  v12[3] = &unk_265377598;
  id v14 = *(id *)(a1 + 56);
  id v13 = *(id *)(a1 + 40);
  uint64_t v6 = (void *)MEMORY[0x2533B66E0](v12);
  id v7 = *(void **)(a1 + 48);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 3221225472;
  v10[2] = __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_466;
  v10[3] = &unk_2653775C8;
  void v10[4] = *(void *)(a1 + 32);
  id v11 = v6;
  id v9 = v6;
  [v7 readAttributesWithEndpointID:&unk_2702B5988 clusterID:&unk_2702B5B50 attributeID:&unk_2702B5988 params:0 queue:v8 completion:v10];
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_470(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch eMAC address job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_463(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v2);
}

void __69__HMMTRAccessoryServer_fetchExtendedMACAddressFromDevice_completion___block_invoke_466(uint64_t a1, void *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  int v7 = (void *)MEMORY[0x2533B64D0]();
  id v8 = *(id *)(a1 + 32);
  __int16 v9 = HMFGetOSLogHandle();
  uint64_t v10 = v9;
  if (v5)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      int v24 = 138543618;
      id v25 = v11;
      __int16 v26 = 2112;
      id v27 = v5;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory returned values as %@", (uint8_t *)&v24, 0x16u);
    }
    __int16 v12 = *(void **)(a1 + 32);
    id v13 = [v5 firstObject];
    id v14 = [v13 objectForKeyedSubscript:*MEMORY[0x263F10B90]];
    id v15 = [v12 _getOperationalHardwareAddressFromReadValue:v14];

    id v16 = [v15 stringByReplacingOccurrencesOfString:@":" withString:&stru_2702A0B38];
    [*(id *)(a1 + 32) setEMACAddress:v16];

    uint64_t v17 = (void *)MEMORY[0x2533B64D0]();
    id v18 = *(id *)(a1 + 32);
    __int16 v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      uint64_t v20 = HMFGetLogIdentifier();
      int v24 = 138543618;
      id v25 = v20;
      __int16 v26 = 2112;
      id v27 = v15;
      _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_INFO, "%{public}@Accessory returned eMAC address as %@", (uint8_t *)&v24, 0x16u);
    }
    uint64_t v21 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
  }
  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v22 = HMFGetLogIdentifier();
      int v24 = 138543618;
      id v25 = v22;
      __int16 v26 = 2112;
      id v27 = v6;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to retrieve eMAC address: %@", (uint8_t *)&v24, 0x16u);
    }
    uint64_t v23 = *(void *)(a1 + 40);
    id v15 = [MEMORY[0x263F087E8] hmfErrorWithCode:2];
    uint64_t v21 = *(void (**)(void))(v23 + 16);
  }
  v21();
}

- (void)fetchWEDSupportInformationFromDevice:(id)a3 completion:(id)a4
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    id v8 = (void *)MEMORY[0x2533B64D0]();
    __int16 v9 = self;
    uint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v28 = v11;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fetching WED support information.", buf, 0xCu);
    }
    __int16 v12 = [(HAPAccessoryServer *)v9 clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke;
    block[3] = &unk_265377430;
    id v26 = v7;
    dispatch_async(v12, block);

    id v13 = v26;
  }
  else
  {
    uint64_t v14 = random();
    id v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = self;
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      id v18 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      uint64_t v28 = v18;
      __int16 v29 = 2048;
      uint64_t v30 = v14;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch WED support information job(%lu) queued.", buf, 0x16u);
    }
    v21[0] = MEMORY[0x263EF8330];
    v21[1] = 3221225472;
    void v21[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_455;
    v21[3] = &unk_265377408;
    void v21[4] = v16;
    uint64_t v24 = v14;
    id v23 = v7;
    id v22 = v6;
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_460;
    v19[3] = &unk_2653787C8;
    id v20 = v23;
    [(HMMTRAccessoryServer *)v16 queueAccessoryOperation:v21 highPriority:0 completion:v19];

    id v13 = v23;
  }
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
  (*(void (**)(uint64_t, void, id))(v1 + 16))(v1, 0, v2);
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_455(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 56);
    *(_DWORD *)long long buf = 138543618;
    id v18 = v5;
    __int16 v19 = 2048;
    uint64_t v20 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch WED support information job(%lu) started.", buf, 0x16u);
  }
  id v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_456;
  block[3] = &unk_2653775F0;
  void block[4] = *(void *)(a1 + 32);
  id v16 = *(id *)(a1 + 48);
  uint64_t v14 = v7;
  id v15 = *(id *)(a1 + 40);
  __int16 v9 = v7;
  dispatch_async(v8, block);

  uint64_t v10 = [*(id *)(a1 + 32) clientQueue];
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 3221225472;
  v12[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_459;
  v12[3] = &unk_265377168;
  uint64_t v11 = *(void *)(a1 + 56);
  void v12[4] = *(void *)(a1 + 32);
  void v12[5] = v11;
  dispatch_group_notify(v9, v10, v12);
}

uint64_t __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_460(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_456(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    id v16 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Fetching WED support information", buf, 0xCu);
  }
  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 3221225472;
  v12[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_457;
  v12[3] = &unk_265377598;
  id v14 = *(id *)(a1 + 56);
  id v13 = *(id *)(a1 + 40);
  uint64_t v6 = (void *)MEMORY[0x2533B66E0](v12);
  id v7 = *(void **)(a1 + 48);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 3221225472;
  v10[2] = __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_2;
  v10[3] = &unk_2653775C8;
  void v10[4] = *(void *)(a1 + 32);
  id v11 = v6;
  id v9 = v6;
  [v7 readAttributesWithEndpointID:&unk_2702B5988 clusterID:&unk_2702B4F98 attributeID:&unk_2702B59D0 params:0 queue:v8 completion:v10];
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_459(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch WED support information job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_457(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v2);
}

void __72__HMMTRAccessoryServer_fetchWEDSupportInformationFromDevice_completion___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  int v7 = (void *)MEMORY[0x2533B64D0]();
  id v8 = *(id *)(a1 + 32);
  __int16 v9 = HMFGetOSLogHandle();
  uint64_t v10 = v9;
  if (v5)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      int v23 = 138543618;
      uint64_t v24 = v11;
      __int16 v25 = 2112;
      id v26 = v5;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory returned WED support information as %@", (uint8_t *)&v23, 0x16u);
    }
    if ([v5 count])
    {
      __int16 v12 = [v5 firstObject];
      id v13 = +[HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:v12];

      [*(id *)(a1 + 32) setWedDevice:v13 != 0];
    }
    else
    {
      uint64_t v14 = [*(id *)(a1 + 32) setWedDevice:0];
    }
    id v18 = (void *)MEMORY[0x2533B64D0](v14);
    id v19 = *(id *)(a1 + 32);
    uint64_t v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      uint64_t v21 = HMFGetLogIdentifier();
      [*(id *)(a1 + 32) isWEDDevice];
      id v22 = HMFBooleanToString();
      int v23 = 138543618;
      uint64_t v24 = v21;
      __int16 v25 = 2112;
      id v26 = v22;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_INFO, "%{public}@Setting WED support to %@", (uint8_t *)&v23, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v15 = HMFGetLogIdentifier();
      int v23 = 138543618;
      uint64_t v24 = v15;
      __int16 v25 = 2112;
      id v26 = v6;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to retrieve WED support information: %@", (uint8_t *)&v23, 0x16u);
    }
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v17 = [MEMORY[0x263F087E8] hmfErrorWithCode:2];
    (*(void (**)(uint64_t, void, void *))(v16 + 16))(v16, 0, v17);
  }
}

- (void)setupThreadPairing
{
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled()
    && [(HMMTRAccessoryServer *)self linkLayerType] == 4)
  {
    id v3 = [(HMMTRAccessoryServer *)self browser];
    int v4 = [v3 isCurrentDeviceAllowedAccessoryControlDespiteReachableResident];

    if (v4)
    {
      id v5 = [(HMMTRAccessoryServer *)self eMACAddress];
      id v6 = [v5 dataUsingEncoding:4];

      int v7 = [(HMMTRAccessoryServer *)self browser];
      id v8 = [v7 threadRadioManager];
      BOOL v9 = [(HMMTRAccessoryServer *)self isWEDDevice];
      v11[0] = MEMORY[0x263EF8330];
      v11[1] = 3221225472;
      v11[2] = __42__HMMTRAccessoryServer_setupThreadPairing__block_invoke;
      v11[3] = &unk_265378660;
      v11[4] = self;
      id v12 = v6;
      id v10 = v6;
      [v8 startAccessoryPairingWithExtendedMACAddress:v10 isWedDevice:v9 accessoryServer:self completion:v11];
    }
  }
}

void __42__HMMTRAccessoryServer_setupThreadPairing__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v8 = v3;
  if (!v3)
  {
    id v3 = (id)[*(id *)(a1 + 32) isWEDDevice];
    if (v3)
    {
      if (*(void *)(a1 + 40))
      {
        BOOL v9 = (void *)MEMORY[0x2533B64D0]();
        id v10 = *(id *)(a1 + 32);
        uint64_t v11 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          id v12 = HMFGetLogIdentifier();
          *(_DWORD *)long long buf = 138543362;
          uint64_t v31 = v12;
          _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_INFO, "%{public}@Aborting operations to flush the non-WED device state", buf, 0xCu);
        }
        id v13 = [*(id *)(a1 + 32) browser];
        uint64_t v14 = *(void *)(a1 + 32);
        id v15 = [MEMORY[0x263F087E8] hmmtrErrorWithCode:9];
        [v13 abortOperationsForAccessoryServer:v14 reason:v15];

        uint64_t v16 = (void *)MEMORY[0x2533B64D0]();
        id v17 = *(id *)(a1 + 32);
        id v18 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          id v19 = HMFGetLogIdentifier();
          uint64_t v20 = *(void **)(a1 + 32);
          *(_DWORD *)long long buf = 138543618;
          uint64_t v31 = v19;
          __int16 v32 = 2112;
          id v33 = v20;
          _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_INFO, "%{public}@Connecting to WED accessory: %@", buf, 0x16u);
        }
        uint64_t v21 = [*(id *)(a1 + 32) browser];
        id v22 = [v21 threadRadioManager];
        v28[0] = MEMORY[0x263EF8330];
        v28[1] = 3221225472;
        v28[2] = __42__HMMTRAccessoryServer_setupThreadPairing__block_invoke_454;
        v28[3] = &unk_265378660;
        int v23 = *(void **)(a1 + 40);
        void v28[4] = *(void *)(a1 + 32);
        id v29 = v23;
        [v22 connectToAccessoryWithExtendedMACAddress:v29 completion:v28];
      }
    }
  }
  uint64_t v24 = (void *)MEMORY[0x2533B64D0](v3, v4, v5, v6, v7);
  id v25 = *(id *)(a1 + 32);
  id v26 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
  {
    uint64_t v27 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543618;
    uint64_t v31 = v27;
    __int16 v32 = 2112;
    id v33 = v8;
    _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_INFO, "%{public}@startAccessoryPairingWithExtendedMACAddress completed, error: %@", buf, 0x16u);
  }
}

void __42__HMMTRAccessoryServer_setupThreadPairing__block_invoke_454(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    uint64_t v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = HMFGetLogIdentifier();
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(a1 + 40);
      int v10 = 138544130;
      uint64_t v11 = v7;
      __int16 v12 = 2112;
      uint64_t v13 = v8;
      __int16 v14 = 2112;
      uint64_t v15 = v9;
      __int16 v16 = 2112;
      id v17 = v3;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to establish WED connection to accessory %@ with emac %@, error %@", (uint8_t *)&v10, 0x2Au);
    }
  }
}

- (void)fetchSoftwareVersion:(BOOL)a3 completionHandler:(id)a4
{
  id v6 = a4;
  uint64_t v7 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __63__HMMTRAccessoryServer_fetchSoftwareVersion_completionHandler___block_invoke;
  block[3] = &unk_265377570;
  void block[4] = self;
  id v10 = v6;
  BOOL v11 = a3;
  id v8 = v6;
  dispatch_async(v7, block);
}

void __63__HMMTRAccessoryServer_fetchSoftwareVersion_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  id v2 = [*(id *)(a1 + 32) matterDevice];

  if (v2)
  {
    id v3 = objc_alloc(MEMORY[0x263F10CD8]);
    uint64_t v4 = [*(id *)(a1 + 32) matterDevice];
    id v5 = [*(id *)(a1 + 32) clientQueue];
    id v6 = (void *)[v3 initWithDevice:v4 endpointID:&unk_2702B5988 queue:v5];

    LODWORD(v4) = *(unsigned __int8 *)(a1 + 48);
    id v7 = objc_alloc_init(MEMORY[0x263F10FA0]);
    if (v4) {
      [v6 readAttributeSoftwareVersionWithParams:v7];
    }
    else {
    uint64_t v13 = [v6 readAttributeSoftwareVersionStringWithParams:v7];
    }

    __int16 v14 = (void *)MEMORY[0x2533B64D0]();
    id v15 = *(id *)(a1 + 32);
    __int16 v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      id v17 = HMFGetLogIdentifier();
      int v20 = 138543618;
      uint64_t v21 = v17;
      __int16 v22 = 2112;
      int v23 = v13;
      _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@Fetched software version data: %@", (uint8_t *)&v20, 0x16u);
    }
    uint64_t v18 = *(void *)(a1 + 40);
    if (v13)
    {
      id v19 = [v13 objectForKeyedSubscript:*MEMORY[0x263F10C30]];
      (*(void (**)(uint64_t, void *, void))(v18 + 16))(v18, v19, 0);
    }
    else
    {
      id v19 = [MEMORY[0x263F087E8] hmfErrorWithCode:8];
      (*(void (**)(uint64_t, void, void *))(v18 + 16))(v18, 0, v19);
    }
  }
  else
  {
    id v8 = (void *)MEMORY[0x2533B64D0]();
    id v9 = *(id *)(a1 + 32);
    id v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      BOOL v11 = HMFGetLogIdentifier();
      int v20 = 138543362;
      uint64_t v21 = v11;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to fetch software version", (uint8_t *)&v20, 0xCu);
    }
    uint64_t v12 = *(void *)(a1 + 40);
    id v6 = [MEMORY[0x263F087E8] hmfErrorWithCode:8];
    (*(void (**)(uint64_t, void, void *))(v12 + 16))(v12, 0, v6);
  }
}

- (void)_fetchSerialNumberWithCompletionHandler:(id)a3
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v4 = (void (**)(id, void *))a3;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = self;
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v21 = v8;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fetching serial number.", buf, 0xCu);
    }
    id v9 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
    v4[2](v4, v9);
  }
  else
  {
    uint64_t v10 = random();
    BOOL v11 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v12 = self;
    uint64_t v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      __int16 v14 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      uint64_t v21 = v14;
      __int16 v22 = 2048;
      uint64_t v23 = v10;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch serial number job(%lu) queued.", buf, 0x16u);
    }
    v17[0] = MEMORY[0x263EF8330];
    v17[1] = 3221225472;
    v17[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke;
    v17[3] = &unk_265377A50;
    void v17[4] = v12;
    uint64_t v19 = v10;
    uint64_t v18 = v4;
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 3221225472;
    v15[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_451;
    v15[3] = &unk_2653787C8;
    __int16 v16 = v18;
    [(HMMTRAccessoryServer *)v12 queueAccessoryOperation:v17 highPriority:0 completion:v15];
  }
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  uint64_t v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138543618;
    uint64_t v18 = v5;
    __int16 v19 = 2048;
    uint64_t v20 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch serial number job(%lu) started.", buf, 0x16u);
  }
  id v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_447;
  block[3] = &unk_265378900;
  id v9 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  id v15 = v7;
  id v16 = v9;
  uint64_t v10 = v7;
  dispatch_async(v8, block);

  BOOL v11 = [*(id *)(a1 + 32) clientQueue];
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  v13[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_450;
  v13[3] = &unk_265377168;
  uint64_t v12 = *(void *)(a1 + 48);
  void v13[4] = *(void *)(a1 + 32);
  void v13[5] = v12;
  dispatch_group_notify(v10, v11, v13);
}

uint64_t __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_451(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_447(id *a1)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = a1[4];
  uint64_t v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    uint64_t v27 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Fetching serial number", buf, 0xCu);
  }
  v23[0] = MEMORY[0x263EF8330];
  v23[1] = 3221225472;
  v23[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_448;
  void v23[3] = &unk_265378578;
  id v25 = a1[6];
  id v24 = a1[5];
  uint64_t v6 = (void *)MEMORY[0x2533B66E0](v23);
  id v7 = [a1[4] deviceController];
  if (v7)
  {
    id v8 = [a1[4] nodeID];
    uint64_t v9 = [v8 unsignedLongLongValue];
    uint64_t v10 = [a1[4] clientQueue];
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_2;
    v19[3] = &unk_265377520;
    void v19[4] = a1[4];
    uint64_t v20 = v6;
    id v11 = v6;
    [v7 getBaseDevice:v9 queue:v10 completionHandler:v19];

    uint64_t v12 = v20;
  }
  else
  {
    uint64_t v13 = (void *)MEMORY[0x2533B64D0]();
    id v14 = a1[4];
    id v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      id v16 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v27 = v16;
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to fetch serial number", buf, 0xCu);
    }
    id v17 = [a1[4] clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_449;
    block[3] = &unk_265377430;
    __int16 v22 = v6;
    id v18 = v6;
    dispatch_async(v17, block);

    uint64_t v12 = v22;
  }
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_450(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  uint64_t v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch serial number job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_448(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v2);
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_449(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    int v7 = [*(id *)(a1 + 32) clientQueue];
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 3221225472;
    v13[2] = __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_3;
    v13[3] = &unk_265377548;
    id v8 = *(void **)(a1 + 40);
    void v13[4] = *(void *)(a1 + 32);
    id v14 = v8;
    [v5 fetchSerialNumberWithCallbackQueue:v7 completionHandler:v13];
  }
  else
  {
    __int16 v9 = (void *)MEMORY[0x2533B64D0]();
    id v10 = *(id *)(a1 + 32);
    uint64_t v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      id v16 = v12;
      __int16 v17 = 2112;
      id v18 = v6;
      _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_ERROR, "%{public}@Could not fetch serial number because no device paired: %@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void __64__HMMTRAccessoryServer__fetchSerialNumberWithCompletionHandler___block_invoke_3(uint64_t a1, void *a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  int v7 = (void *)MEMORY[0x2533B64D0]();
  id v8 = *(id *)(a1 + 32);
  __int16 v9 = HMFGetOSLogHandle();
  id v10 = v9;
  if (v5)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      int v16 = 138543618;
      __int16 v17 = v11;
      __int16 v18 = 2112;
      id v19 = v5;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory returned Serial Number as %@", (uint8_t *)&v16, 0x16u);
    }
    uint64_t v12 = [*(id *)(a1 + 32) primaryAccessory];
    [v12 setSerialNumber:v5];

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = HMFGetLogIdentifier();
      int v16 = 138543618;
      __int16 v17 = v13;
      __int16 v18 = 2112;
      id v19 = v6;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to retrieve serial number: %@", (uint8_t *)&v16, 0x16u);
    }
    uint64_t v14 = *(void *)(a1 + 40);
    if (v6)
    {
      (*(void (**)(uint64_t, id))(v14 + 16))(v14, v6);
    }
    else
    {
      id v15 = [MEMORY[0x263F087E8] hmfErrorWithCode:2];
      (*(void (**)(uint64_t, void *))(v14 + 16))(v14, v15);
    }
  }
}

- (void)_fetchCurrentPairingWithCompletionHandler:(id)a3
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  id v4 = a3;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = self;
    int v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v21 = v8;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fetching current pairing.", buf, 0xCu);
    }
    __int16 v9 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
    (*((void (**)(id, void, void *, void))v4 + 2))(v4, 0, v9, 0);
  }
  else
  {
    uint64_t v10 = random();
    uint64_t v11 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v12 = self;
    uint64_t v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      uint64_t v14 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      uint64_t v21 = v14;
      __int16 v22 = 2048;
      uint64_t v23 = v10;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch current pairing job(%lu) queued.", buf, 0x16u);
    }
    v17[0] = MEMORY[0x263EF8330];
    v17[1] = 3221225472;
    v17[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke;
    v17[3] = &unk_265377A50;
    void v17[4] = v12;
    uint64_t v19 = v10;
    id v18 = v4;
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 3221225472;
    v15[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_446;
    v15[3] = &unk_2653787C8;
    id v16 = v18;
    [(HMMTRAccessoryServer *)v12 queueAccessoryOperation:v17 highPriority:0 completion:v15];
  }
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138543618;
    id v18 = v5;
    __int16 v19 = 2048;
    uint64_t v20 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch current pairing job(%lu) started.", buf, 0x16u);
  }
  int v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_442;
  block[3] = &unk_265378900;
  __int16 v9 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  id v15 = v7;
  id v16 = v9;
  uint64_t v10 = v7;
  dispatch_async(v8, block);

  uint64_t v11 = [*(id *)(a1 + 32) clientQueue];
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  v13[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_445;
  v13[3] = &unk_265377168;
  uint64_t v12 = *(void *)(a1 + 48);
  void v13[4] = *(void *)(a1 + 32);
  void v13[5] = v12;
  dispatch_group_notify(v10, v11, v13);
}

uint64_t __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_446(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_442(id *a1)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = a1[4];
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    uint64_t v27 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Fetching current pairing", buf, 0xCu);
  }
  v23[0] = MEMORY[0x263EF8330];
  v23[1] = 3221225472;
  v23[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_443;
  void v23[3] = &unk_2653774F8;
  id v25 = a1[6];
  id v24 = a1[5];
  uint64_t v6 = (void *)MEMORY[0x2533B66E0](v23);
  int v7 = [a1[4] deviceController];
  if (v7)
  {
    id v8 = [a1[4] nodeID];
    uint64_t v9 = [v8 unsignedLongLongValue];
    uint64_t v10 = [a1[4] clientQueue];
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_2;
    v19[3] = &unk_265377520;
    void v19[4] = a1[4];
    uint64_t v20 = v6;
    id v11 = v6;
    [v7 getBaseDevice:v9 queue:v10 completionHandler:v19];

    uint64_t v12 = v20;
  }
  else
  {
    uint64_t v13 = (void *)MEMORY[0x2533B64D0]();
    id v14 = a1[4];
    id v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      id v16 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v27 = v16;
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to fetch current pairing", buf, 0xCu);
    }
    __int16 v17 = [a1[4] clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_444;
    block[3] = &unk_265377430;
    __int16 v22 = v6;
    id v18 = v6;
    dispatch_async(v17, block);

    uint64_t v12 = v22;
  }
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_445(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch current pairing job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_443(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v2);
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_444(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
  (*(void (**)(uint64_t, void, id, void))(v1 + 16))(v1, 0, v2, 0);
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    int v7 = [*(id *)(a1 + 32) clientQueue];
    id v8 = [*(id *)(a1 + 32) browser];
    __int16 v9 = [v8 vendorMetadataStore];
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 3221225472;
    v15[2] = __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_3;
    v15[3] = &unk_2653774F8;
    uint64_t v10 = *(void **)(a1 + 40);
    void v15[4] = *(void *)(a1 + 32);
    id v16 = v10;
    [v5 fetchCurrentPairingWithCallbackQueue:v7 vendorMetadataStore:v9 completionHandler:v15];
  }
  else
  {
    uint64_t v11 = (void *)MEMORY[0x2533B64D0]();
    id v12 = *(id *)(a1 + 32);
    uint64_t v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      id v14 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      id v18 = v14;
      __int16 v19 = 2112;
      id v20 = v6;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_ERROR, "%{public}@Could not fetch current pairing because no device paired: %@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void __66__HMMTRAccessoryServer__fetchCurrentPairingWithCompletionHandler___block_invoke_3(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void *)MEMORY[0x2533B64D0]();
  id v11 = *(id *)(a1 + 32);
  id v12 = HMFGetOSLogHandle();
  uint64_t v13 = v12;
  if (v7)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      id v14 = HMFGetLogIdentifier();
      int v18 = 138543618;
      __int16 v19 = v14;
      __int16 v20 = 2112;
      id v21 = v7;
      id v15 = "%{public}@Successfully retrieved pairing: %@";
      id v16 = v13;
      os_log_type_t v17 = OS_LOG_TYPE_INFO;
LABEL_6:
      _os_log_impl(&dword_252495000, v16, v17, v15, (uint8_t *)&v18, 0x16u);
    }
  }
  else if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    id v14 = HMFGetLogIdentifier();
    int v18 = 138543618;
    __int16 v19 = v14;
    __int16 v20 = 2112;
    id v21 = v8;
    id v15 = "%{public}@Failed to retrieve pairing: %@";
    id v16 = v13;
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
    goto LABEL_6;
  }

  (*(void (**)(void, id, id, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v7, v8, 0);
}

- (void)fetchPairingsWithCompletionHandler:(id)a3
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v4 = a3;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = self;
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v24 = v8;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fetching pairings.", buf, 0xCu);
    }
    id v9 = [(HAPAccessoryServer *)v6 clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke;
    block[3] = &unk_265377430;
    id v22 = v4;
    dispatch_async(v9, block);

    id v10 = v22;
  }
  else
  {
    uint64_t v11 = random();
    id v12 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v13 = self;
    id v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      id v15 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      id v24 = v15;
      __int16 v25 = 2048;
      uint64_t v26 = v11;
      _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch pairings job(%lu) queued.", buf, 0x16u);
    }
    v18[0] = MEMORY[0x263EF8330];
    v18[1] = 3221225472;
    v18[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_435;
    v18[3] = &unk_265377A50;
    void v18[4] = v13;
    uint64_t v20 = v11;
    id v19 = v4;
    v16[0] = MEMORY[0x263EF8330];
    v16[1] = 3221225472;
    v16[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_441;
    v16[3] = &unk_2653787C8;
    id v17 = v19;
    [(HMMTRAccessoryServer *)v13 queueAccessoryOperation:v18 highPriority:0 completion:v16];

    id v10 = v19;
  }
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke(uint64_t a1)
{
  id v3 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
  id v2 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:10 error:v3];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_435(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138543618;
    int v18 = v5;
    __int16 v19 = 2048;
    uint64_t v20 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch pairings job(%lu) started.", buf, 0x16u);
  }
  id v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_436;
  block[3] = &unk_265378900;
  id v9 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  id v15 = v7;
  id v16 = v9;
  id v10 = v7;
  dispatch_async(v8, block);

  uint64_t v11 = [*(id *)(a1 + 32) clientQueue];
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  v13[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_440;
  v13[3] = &unk_265377168;
  uint64_t v12 = *(void *)(a1 + 48);
  void v13[4] = *(void *)(a1 + 32);
  void v13[5] = v12;
  dispatch_group_notify(v10, v11, v13);
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_441(uint64_t a1, void *a2)
{
  if (a2)
  {
    id v3 = a2;
    id v4 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:10 error:v3];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_436(id *a1)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = a1[4];
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    uint64_t v27 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Fetching pairings", buf, 0xCu);
  }
  v23[0] = MEMORY[0x263EF8330];
  v23[1] = 3221225472;
  v23[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_437;
  void v23[3] = &unk_2653774F8;
  id v25 = a1[6];
  id v24 = a1[5];
  uint64_t v6 = (void *)MEMORY[0x2533B66E0](v23);
  id v7 = [a1[4] deviceController];
  if (v7)
  {
    id v8 = [a1[4] nodeID];
    uint64_t v9 = [v8 unsignedLongLongValue];
    id v10 = [a1[4] clientQueue];
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_2;
    v19[3] = &unk_265377520;
    void v19[4] = a1[4];
    uint64_t v20 = v6;
    id v11 = v6;
    [v7 getBaseDevice:v9 queue:v10 completionHandler:v19];

    uint64_t v12 = v20;
  }
  else
  {
    uint64_t v13 = (void *)MEMORY[0x2533B64D0]();
    id v14 = a1[4];
    id v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      id v16 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v27 = v16;
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to fetch pairings", buf, 0xCu);
    }
    id v17 = [a1[4] clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_439;
    block[3] = &unk_265377430;
    id v22 = v6;
    id v18 = v6;
    dispatch_async(v17, block);

    uint64_t v12 = v22;
  }
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_440(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: fetch pairings job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_437(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v2);
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_439(uint64_t a1)
{
  id v3 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
  id v2 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:10 error:v3];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    int v7 = [*(id *)(a1 + 32) clientQueue];
    id v8 = [*(id *)(a1 + 32) browser];
    __int16 v9 = [v8 vendorMetadataStore];
    v16[0] = MEMORY[0x263EF8330];
    v16[1] = 3221225472;
    v16[2] = __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_3;
    v16[3] = &unk_2653774F8;
    uint64_t v10 = *(void **)(a1 + 40);
    void v16[4] = *(void *)(a1 + 32);
    id v17 = v10;
    [v5 fetchPairingsWithCallbackQueue:v7 vendorMetadataStore:v9 completionHandler:v16];
  }
  else
  {
    uint64_t v11 = (void *)MEMORY[0x2533B64D0]();
    id v12 = *(id *)(a1 + 32);
    uint64_t v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      id v14 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      __int16 v19 = v14;
      __int16 v20 = 2112;
      id v21 = v6;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_ERROR, "%{public}@Could not fetch pairings because no device paired: %@", buf, 0x16u);
    }
    id v15 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:10 error:v6];
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void __59__HMMTRAccessoryServer_fetchPairingsWithCompletionHandler___block_invoke_3(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void *)MEMORY[0x2533B64D0]();
  id v11 = *(id *)(a1 + 32);
  id v12 = HMFGetOSLogHandle();
  uint64_t v13 = v12;
  if (v7)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      id v14 = HMFGetLogIdentifier();
      int v18 = 138543618;
      __int16 v19 = v14;
      __int16 v20 = 2112;
      id v21 = v7;
      id v15 = "%{public}@Successfully retrieved pairings: %@";
      id v16 = v13;
      os_log_type_t v17 = OS_LOG_TYPE_INFO;
LABEL_6:
      _os_log_impl(&dword_252495000, v16, v17, v15, (uint8_t *)&v18, 0x16u);
    }
  }
  else if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    id v14 = HMFGetLogIdentifier();
    int v18 = 138543618;
    __int16 v19 = v14;
    __int16 v20 = 2112;
    id v21 = v8;
    id v15 = "%{public}@Failed to retrieve pairings: %@";
    id v16 = v13;
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
    goto LABEL_6;
  }

  (*(void (**)(void, id, id, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v7, v8, v9);
}

- (void)updateAccessoryName:(id)a3
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543618;
    id v47 = v8;
    __int16 v48 = 2112;
    id v49 = v4;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Updating accessory name to: %@", buf, 0x16u);
  }
  [(HAPAccessoryServer *)v6 setName:v4];
  id v9 = [(HMMTRAccessoryServer *)v6 primaryAccessory];
  [v9 setName:v4];

  id v35 = objc_alloc_init(MEMORY[0x263EFF980]);
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  uint64_t v10 = [(HMMTRAccessoryServer *)v6 primaryAccessory];
  id v11 = [v10 services];

  uint64_t v12 = [v11 countByEnumeratingWithState:&v40 objects:v45 count:16];
  if (v12)
  {
    uint64_t v13 = v12;
    uint64_t v14 = *(void *)v41;
    while (2)
    {
      for (uint64_t i = 0; i != v13; ++i)
      {
        if (*(void *)v41 != v14) {
          objc_enumerationMutation(v11);
        }
        id v16 = *(void **)(*((void *)&v40 + 1) + 8 * i);
        os_log_type_t v17 = [v16 type];
        int v18 = [v17 isEqualToString:@"0000003E-0000-1000-8000-0026BB765291"];

        if (v18)
        {
          long long v38 = 0u;
          long long v39 = 0u;
          long long v36 = 0u;
          long long v37 = 0u;
          __int16 v19 = [v16 characteristics];
          uint64_t v20 = [v19 countByEnumeratingWithState:&v36 objects:v44 count:16];
          if (v20)
          {
            uint64_t v21 = v20;
            uint64_t v22 = *(void *)v37;
            id v34 = v4;
            while (2)
            {
              for (uint64_t j = 0; j != v21; ++j)
              {
                if (*(void *)v37 != v22) {
                  objc_enumerationMutation(v19);
                }
                id v24 = *(void **)(*((void *)&v36 + 1) + 8 * j);
                id v25 = objc_msgSend(v24, "type", v34);
                int v26 = [v25 isEqualToString:@"00000023-0000-1000-8000-0026BB765291"];

                if (v26)
                {
                  uint64_t v27 = (void *)[v24 copy];
                  uint64_t v28 = [v24 service];
                  [v27 setService:v28];

                  id v4 = v34;
                  id v29 = (void *)MEMORY[0x2533B64D0]([v27 setValue:v34]);
                  uint64_t v30 = v6;
                  uint64_t v31 = HMFGetOSLogHandle();
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
                  {
                    __int16 v32 = HMFGetLogIdentifier();
                    *(_DWORD *)long long buf = 138543618;
                    id v47 = v32;
                    __int16 v48 = 2112;
                    id v49 = v27;
                    _os_log_impl(&dword_252495000, v31, OS_LOG_TYPE_INFO, "%{public}@Notification: Updated characteristic: %@", buf, 0x16u);
                  }
                  [v35 addObject:v27];

                  goto LABEL_24;
                }
              }
              uint64_t v21 = [v19 countByEnumeratingWithState:&v36 objects:v44 count:16];
              id v4 = v34;
              if (v21) {
                continue;
              }
              break;
            }
          }
LABEL_24:

          goto LABEL_25;
        }
      }
      uint64_t v13 = [v11 countByEnumeratingWithState:&v40 objects:v45 count:16];
      if (v13) {
        continue;
      }
      break;
    }
  }
LABEL_25:

  id v33 = [(HAPAccessoryServer *)v6 delegate];
  [v33 accessoryServer:v6 didUpdateValuesForCharacteristics:v35 stateNumber:0 broadcast:0];
}

- (void)updateFabricLabel:(id)a3 completionHandler:(id)a4
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    id v8 = (void *)MEMORY[0x2533B64D0]();
    id v9 = self;
    uint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      id v11 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v35 = v11;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting fabric label update.", buf, 0xCu);
    }
    uint64_t v12 = [(HAPAccessoryServer *)v9 clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke;
    block[3] = &unk_265377430;
    id v33 = v7;
    dispatch_async(v12, block);

    id v13 = v33;
  }
  else
  {
    uint64_t v14 = random();
    id v15 = [MEMORY[0x263EFF980] arrayWithCapacity:1];
    id v16 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
    os_unfair_lock_lock_with_options();
    os_log_type_t v17 = [(HMMTRAccessoryServer *)self lastPendingFabricLabel];
    int v18 = [v17 firstObject];
    char v19 = [v18 isEqual:v6];

    if ((v19 & 1) == 0)
    {
      [v15 addObject:v6];
      [(HMMTRAccessoryServer *)self setLastPendingFabricLabel:v15];
    }
    os_unfair_lock_unlock(v16);
    uint64_t v20 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v21 = self;
    uint64_t v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      uint64_t v23 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      id v35 = v23;
      __int16 v36 = 2048;
      uint64_t v37 = v14;
      _os_log_impl(&dword_252495000, v22, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update fabric label job(%lu) queued.", buf, 0x16u);
    }
    v26[0] = MEMORY[0x263EF8330];
    v26[1] = 3221225472;
    v26[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_429;
    v26[3] = &unk_2653774D0;
    v26[4] = v21;
    uint64_t v30 = v14;
    id v27 = v6;
    char v31 = v19;
    id v28 = v15;
    id v29 = v7;
    v24[0] = MEMORY[0x263EF8330];
    v24[1] = 3221225472;
    v24[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_434;
    v24[3] = &unk_2653787C8;
    id v25 = v29;
    id v13 = v15;
    [(HMMTRAccessoryServer *)v21 queueAccessoryOperation:v26 highPriority:0 completion:v24];
  }
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_429(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 64);
    *(_DWORD *)long long buf = 138543618;
    id v25 = v5;
    __int16 v26 = 2048;
    uint64_t v27 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update fabric label job(%lu) started.", buf, 0x16u);
  }
  id v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_430;
  block[3] = &unk_265377480;
  id v9 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  id v20 = v9;
  id v10 = *(id *)(a1 + 56);
  uint64_t v21 = v7;
  id v22 = v10;
  char v23 = *(unsigned char *)(a1 + 72);
  id v11 = v7;
  dispatch_async(v8, block);

  uint64_t v12 = [*(id *)(a1 + 32) clientQueue];
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_433;
  v15[3] = &unk_2653774A8;
  id v13 = *(id *)(a1 + 48);
  uint64_t v14 = *(void *)(a1 + 32);
  id v16 = v13;
  uint64_t v17 = v14;
  uint64_t v18 = *(void *)(a1 + 64);
  dispatch_group_notify(v11, v12, v15);
}

uint64_t __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_434(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_430(uint64_t a1)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138543618;
    char v31 = v5;
    __int16 v32 = 2112;
    uint64_t v33 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to update fabric label to %@", buf, 0x16u);
  }
  v27[0] = MEMORY[0x263EF8330];
  v27[1] = 3221225472;
  v27[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_431;
  void v27[3] = &unk_265378578;
  id v29 = *(id *)(a1 + 56);
  id v28 = *(id *)(a1 + 48);
  id v7 = (void (**)(void, void))MEMORY[0x2533B66E0](v27);
  if (*(unsigned char *)(a1 + 64))
  {
    id v8 = (void *)MEMORY[0x2533B64D0]();
    id v9 = *(id *)(a1 + 32);
    id v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      id v11 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      char v31 = v11;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Update fabric label job is redundant - do nothing.", buf, 0xCu);
    }
    uint64_t v12 = [*(id *)(a1 + 32) lastFabricLabelUpdateError];
    ((void (**)(void, void *))v7)[2](v7, v12);
  }
  else
  {
    uint64_t v13 = [*(id *)(a1 + 32) deviceController];
    if (v13)
    {
      uint64_t v12 = (void *)v13;
      uint64_t v14 = [*(id *)(a1 + 32) nodeID];
      uint64_t v15 = [v14 unsignedLongLongValue];
      id v16 = [*(id *)(a1 + 32) clientQueue];
      v24[0] = MEMORY[0x263EF8330];
      v24[1] = 3221225472;
      v24[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_432;
      v24[3] = &unk_265377250;
      uint64_t v17 = *(void **)(a1 + 40);
      void v24[4] = *(void *)(a1 + 32);
      id v25 = v17;
      __int16 v26 = v7;
      [v12 getBaseDevice:v15 queue:v16 completionHandler:v24];
    }
    else
    {
      uint64_t v18 = (void *)MEMORY[0x2533B64D0]();
      id v19 = *(id *)(a1 + 32);
      id v20 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543362;
        char v31 = v21;
        _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller to update fabric label job", buf, 0xCu);
      }
      id v22 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
      [*(id *)(a1 + 32) setLastFabricLabelUpdateError:v22];

      char v23 = [*(id *)(a1 + 32) lastFabricLabelUpdateError];
      ((void (**)(void, void *))v7)[2](v7, v23);

      uint64_t v12 = 0;
    }
  }
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_433(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]([*(id *)(a1 + 32) removeAllObjects]);
  id v3 = *(id *)(a1 + 40);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 48);
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: update fabric label job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_431(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v2);
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_432(uint64_t a1, void *a2, void *a3)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = [*(id *)(a1 + 32) setLastFabricLabelUpdateError:v6];
  if (v5)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    __int16 v9 = [*(id *)(a1 + 32) clientQueue];
    v16[0] = MEMORY[0x263EF8330];
    v16[1] = 3221225472;
    v16[2] = __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_2;
    v16[3] = &unk_265377458;
    uint64_t v10 = *(void **)(a1 + 40);
    void v16[4] = *(void *)(a1 + 32);
    id v17 = v10;
    id v19 = *(id *)(a1 + 48);
    id v18 = v6;
    [v5 updateFabricLabel:v8 callbackQueue:v9 completionHandler:v16];
  }
  else
  {
    uint64_t v11 = (void *)MEMORY[0x2533B64D0](v7);
    id v12 = *(id *)(a1 + 32);
    uint64_t v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = HMFGetLogIdentifier();
      uint64_t v15 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138543874;
      uint64_t v21 = v14;
      __int16 v22 = 2112;
      uint64_t v23 = v15;
      __int16 v24 = 2112;
      id v25 = v6;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_ERROR, "%{public}@Could not update fabric label to %@ because no device paired %@", buf, 0x20u);
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void __60__HMMTRAccessoryServer_updateFabricLabel_completionHandler___block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  uint64_t v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = HMFGetLogIdentifier();
      uint64_t v9 = *(void *)(a1 + 40);
      int v17 = 138543874;
      id v18 = v8;
      __int16 v19 = 2112;
      uint64_t v20 = v9;
      __int16 v21 = 2112;
      id v22 = v3;
      uint64_t v10 = "%{public}@Failed to update fabric label to %@ with error %@";
      uint64_t v11 = v7;
      os_log_type_t v12 = OS_LOG_TYPE_ERROR;
      uint32_t v13 = 32;
LABEL_6:
      _os_log_impl(&dword_252495000, v11, v12, v10, (uint8_t *)&v17, v13);
    }
  }
  else if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v8 = HMFGetLogIdentifier();
    uint64_t v14 = *(void *)(a1 + 40);
    int v17 = 138543618;
    id v18 = v8;
    __int16 v19 = 2112;
    uint64_t v20 = v14;
    uint64_t v10 = "%{public}@Successfully updated fabric label %@";
    uint64_t v11 = v7;
    os_log_type_t v12 = OS_LOG_TYPE_INFO;
    uint32_t v13 = 22;
    goto LABEL_6;
  }

  (*(void (**)(void, void, uint64_t, uint64_t))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), *(void *)(a1 + 48), v15, v16);
}

- (void)removePairing:(id)a3 completionHandler:(id)a4
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    uint64_t v8 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v9 = self;
    uint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v28 = v11;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting remove-pairing.", buf, 0xCu);
    }
    os_log_type_t v12 = [(HAPAccessoryServer *)v9 clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke;
    block[3] = &unk_265377430;
    id v26 = v7;
    dispatch_async(v12, block);

    uint32_t v13 = v26;
  }
  else
  {
    uint64_t v14 = random();
    uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v16 = self;
    int v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      id v18 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      id v28 = v18;
      __int16 v29 = 2048;
      uint64_t v30 = v14;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove pairing job(%lu) queued.", buf, 0x16u);
    }
    v21[0] = MEMORY[0x263EF8330];
    v21[1] = 3221225472;
    void v21[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_423;
    v21[3] = &unk_265377408;
    void v21[4] = v16;
    uint64_t v24 = v14;
    id v22 = v6;
    id v23 = v7;
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_428;
    v19[3] = &unk_2653787C8;
    id v20 = v23;
    [(HMMTRAccessoryServer *)v16 queueAccessoryOperation:v21 highPriority:0 completion:v19];

    uint32_t v13 = v22;
  }
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_423(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 56);
    *(_DWORD *)long long buf = 138543618;
    id v20 = v5;
    __int16 v21 = 2048;
    uint64_t v22 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove pairing job(%lu) started.", buf, 0x16u);
  }
  id v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  uint64_t v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_424;
  block[3] = &unk_2653775F0;
  uint64_t v9 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  id v16 = v9;
  id v10 = *(id *)(a1 + 48);
  int v17 = v7;
  id v18 = v10;
  uint64_t v11 = v7;
  dispatch_async(v8, block);

  os_log_type_t v12 = [*(id *)(a1 + 32) clientQueue];
  v14[0] = MEMORY[0x263EF8330];
  v14[1] = 3221225472;
  v14[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_427;
  v14[3] = &unk_265377168;
  uint64_t v13 = *(void *)(a1 + 56);
  v14[4] = *(void *)(a1 + 32);
  void v14[5] = v13;
  dispatch_group_notify(v11, v12, v14);
}

uint64_t __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_428(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_424(id *a1)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = a1[4];
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    id v6 = a1[5];
    *(_DWORD *)long long buf = 138543618;
    uint64_t v31 = v5;
    __int16 v32 = 2112;
    id v33 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Removing pairing: %@", buf, 0x16u);
  }
  v27[0] = MEMORY[0x263EF8330];
  v27[1] = 3221225472;
  v27[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_425;
  void v27[3] = &unk_265378578;
  id v29 = a1[7];
  id v28 = a1[6];
  id v7 = (void *)MEMORY[0x2533B66E0](v27);
  uint64_t v8 = [a1[4] deviceController];
  if (v8)
  {
    uint64_t v9 = [a1[4] nodeID];
    uint64_t v10 = [v9 unsignedLongLongValue];
    uint64_t v11 = [a1[4] clientQueue];
    v22[0] = MEMORY[0x263EF8330];
    v22[1] = 3221225472;
    v22[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_2;
    v22[3] = &unk_265377250;
    os_log_type_t v12 = (id *)v23;
    id v13 = a1[5];
    id v14 = a1[4];
    v23[0] = v13;
    v23[1] = v14;
    id v24 = v7;
    id v15 = v7;
    [v8 getBaseDevice:v10 queue:v11 completionHandler:v22];
  }
  else
  {
    id v16 = (void *)MEMORY[0x2533B64D0]();
    id v17 = a1[4];
    id v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      __int16 v19 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v31 = v19;
      _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_ERROR, "%{public}@No Matter device controller available to remove pairing", buf, 0xCu);
    }
    id v20 = [a1[4] clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_426;
    block[3] = &unk_265377430;
    os_log_type_t v12 = &v26;
    id v26 = v7;
    id v21 = v7;
    dispatch_async(v20, block);
  }
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_427(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    uint64_t v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: remove pairing job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_425(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v2);
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_426(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = [*(id *)(a1 + 40) clientQueue];
    __int16 v9 = [*(id *)(a1 + 40) browser];
    uint64_t v10 = [v9 vendorMetadataStore];
    v18[0] = MEMORY[0x263EF8330];
    v18[1] = 3221225472;
    v18[2] = __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_3;
    v18[3] = &unk_265377368;
    int8x16_t v17 = *(int8x16_t *)(a1 + 32);
    id v11 = (id)v17.i64[0];
    int8x16_t v19 = vextq_s8(v17, v17, 8uLL);
    id v20 = *(id *)(a1 + 48);
    [v5 removePairing:v7 callbackQueue:v8 vendorMetadataStore:v10 completionHandler:v18];
  }
  else
  {
    os_log_type_t v12 = (void *)MEMORY[0x2533B64D0]();
    id v13 = *(id *)(a1 + 40);
    id v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      id v15 = HMFGetLogIdentifier();
      uint64_t v16 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138543874;
      uint64_t v22 = v15;
      __int16 v23 = 2112;
      uint64_t v24 = v16;
      __int16 v25 = 2112;
      id v26 = v6;
      _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_ERROR, "%{public}@Could not remove pairing %@ because no device paired: %@", buf, 0x20u);
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void __56__HMMTRAccessoryServer_removePairing_completionHandler___block_invoke_3(uint64_t a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  uint64_t v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = HMFGetLogIdentifier();
      uint64_t v9 = *(void *)(a1 + 40);
      int v17 = 138543874;
      id v18 = v8;
      __int16 v19 = 2112;
      uint64_t v20 = v9;
      __int16 v21 = 2112;
      id v22 = v3;
      uint64_t v10 = "%{public}@Failed to remove CHIP pairing %@: %@";
      id v11 = v7;
      os_log_type_t v12 = OS_LOG_TYPE_ERROR;
      uint32_t v13 = 32;
LABEL_6:
      _os_log_impl(&dword_252495000, v11, v12, v10, (uint8_t *)&v17, v13);
    }
  }
  else if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v8 = HMFGetLogIdentifier();
    uint64_t v14 = *(void *)(a1 + 40);
    int v17 = 138543618;
    id v18 = v8;
    __int16 v19 = 2112;
    uint64_t v20 = v14;
    uint64_t v10 = "%{public}@Successfully removed CHIP pairing: %@";
    id v11 = v7;
    os_log_type_t v12 = OS_LOG_TYPE_INFO;
    uint32_t v13 = 22;
    goto LABEL_6;
  }

  (*(void (**)(void, id, uint64_t, uint64_t))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), v3, v15, v16);
}

- (void)readPairingWindowStatusWithCompletionHandler:(id)a3
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  id v4 = (void (**)(id, void, void *))a3;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = self;
    uint64_t v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v21 = v8;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting reading pairing window status.", buf, 0xCu);
    }
    uint64_t v9 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
    v4[2](v4, 0, v9);
  }
  else
  {
    uint64_t v10 = random();
    id v11 = (void *)MEMORY[0x2533B64D0]();
    os_log_type_t v12 = self;
    uint32_t v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      uint64_t v14 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      __int16 v21 = v14;
      __int16 v22 = 2048;
      uint64_t v23 = v10;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: read pairing window status job(%lu) queued.", buf, 0x16u);
    }
    v17[0] = MEMORY[0x263EF8330];
    v17[1] = 3221225472;
    v17[2] = __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke;
    v17[3] = &unk_265377A50;
    void v17[4] = v12;
    uint64_t v19 = v10;
    id v18 = v4;
    v15[0] = MEMORY[0x263EF8330];
    v15[1] = 3221225472;
    v15[2] = __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_422;
    v15[3] = &unk_2653787C8;
    uint64_t v16 = v18;
    [(HMMTRAccessoryServer *)v12 queueAccessoryOperation:v17 highPriority:0 completion:v15];
  }
}

void __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138543618;
    uint64_t v19 = v5;
    __int16 v20 = 2048;
    uint64_t v21 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: read pairing window status job(%lu) started.", buf, 0x16u);
  }
  uint64_t v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  uint64_t v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_414;
  block[3] = &unk_265377408;
  uint64_t v9 = *(void **)(a1 + 40);
  uint64_t v17 = *(void *)(a1 + 48);
  void block[4] = *(void *)(a1 + 32);
  uint64_t v15 = v7;
  id v16 = v9;
  uint64_t v10 = v7;
  dispatch_async(v8, block);

  id v11 = [*(id *)(a1 + 32) clientQueue];
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  v13[2] = __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_421;
  v13[3] = &unk_265377168;
  uint64_t v12 = *(void *)(a1 + 48);
  void v13[4] = *(void *)(a1 + 32);
  void v13[5] = v12;
  dispatch_group_notify(v10, v11, v13);
}

uint64_t __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_422(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_414(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  id v2 = [*(id *)(a1 + 32) controllerWrapper];
  id v3 = [v2 controller];

  if (v3)
  {
    id v4 = (void *)MEMORY[0x263F10CA8];
    id v5 = [*(id *)(a1 + 32) nodeID];
    uint64_t v6 = [v4 deviceWithNodeID:v5 controller:v3];

    if (v6)
    {
      id v7 = objc_alloc(MEMORY[0x263F10C70]);
      uint64_t v8 = [*(id *)(a1 + 32) clientQueue];
      uint64_t v9 = (void *)[v7 initWithDevice:v6 endpointID:&unk_2702B5988 queue:v8];

      if (!v9) {
        _HMFPreconditionFailure();
      }
      v22[0] = MEMORY[0x263EF8330];
      v22[1] = 3221225472;
      v22[2] = __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_420;
      v22[3] = &unk_265378978;
      void v22[4] = *(void *)(a1 + 32);
      id v24 = *(id *)(a1 + 48);
      id v23 = *(id *)(a1 + 40);
      [v9 readAttributeWindowStatusWithCompletion:v22];
    }
    else
    {
      uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
      id v16 = *(id *)(a1 + 32);
      uint64_t v17 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        id v18 = HMFGetLogIdentifier();
        uint64_t v19 = [*(id *)(a1 + 32) nodeID];
        *(_DWORD *)long long buf = 138543618;
        id v26 = v18;
        __int16 v27 = 2112;
        id v28 = v19;
        _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@Failed get a device to read pairing window status for node %@", buf, 0x16u);
      }
      uint64_t v20 = *(void *)(a1 + 48);
      uint64_t v21 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:1 userInfo:0];
      (*(void (**)(uint64_t, void, void *))(v20 + 16))(v20, 0, v21);

      dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    }
  }
  else
  {
    uint64_t v10 = (void *)MEMORY[0x2533B64D0]();
    id v11 = *(id *)(a1 + 32);
    uint64_t v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint32_t v13 = HMFGetLogIdentifier();
      uint64_t v14 = *(void **)(a1 + 56);
      *(_DWORD *)long long buf = 138543618;
      id v26 = v13;
      __int16 v27 = 2048;
      id v28 = v14;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_ERROR, "%{public}@No device controller to execute read pairing window status job(%lu)", buf, 0x16u);
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
}

void __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_421(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    uint64_t v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: read pairing window status job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __69__HMMTRAccessoryServer_readPairingWindowStatusWithCompletionHandler___block_invoke_420(uint64_t a1, void *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    int v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    __int16 v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = HMFGetLogIdentifier();
      int v11 = 138543618;
      uint64_t v12 = v10;
      __int16 v13 = 2112;
      id v14 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Reading AdministratorCommissioning cluster window status attribute failed: %@", (uint8_t *)&v11, 0x16u);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

- (void)_openPairingWindowWithPINForDuration:(double)a3 completionHandler:(id)a4
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  id v6 = (void (**)(id, void, void *))a4;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    int v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = self;
    __int16 v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v36 = v10;
      int v11 = "%{public}@Accessory server operations disabled. Aborting open pairing window.";
LABEL_15:
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_INFO, v11, buf, 0xCu);

      goto LABEL_16;
    }
    goto LABEL_16;
  }
  uint64_t v12 = [(HMMTRAccessoryServer *)self browser];

  if (!v12)
  {
    int v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = self;
    __int16 v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v36 = v10;
      int v11 = "%{public}@Browser is nil";
      goto LABEL_15;
    }
LABEL_16:

    id v28 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
    v6[2](v6, 0, v28);

    goto LABEL_17;
  }
  if (isFeatureMatteriPhoneOnlyPairingControlForThreadEnabled())
  {
    __int16 v13 = (void *)MEMORY[0x2533B64D0]();
    id v14 = self;
    uint64_t v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      id v16 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v36 = v16;
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_INFO, "%{public}@Aborting all thread connection requests due to external pairing request", buf, 0xCu);
    }
    uint64_t v17 = [(HMMTRAccessoryServer *)v14 browser];
    id v18 = [MEMORY[0x263F087E8] hmmtrErrorWithCode:6];
    [v17 abortAndSuspendAllOperationsWithReason:v18];

    uint64_t v19 = [(HMMTRAccessoryServer *)v14 browser];
    [v19 enableUnrestrictedOperationsForAccessoryServer:v14];

    if ([(HMMTRAccessoryServer *)v14 knownToSystemCommissioner])
    {
      uint64_t v20 = [(HMMTRAccessoryServer *)v14 browser];
      uint64_t v21 = [v20 threadRadioManager];
      uint64_t v22 = [(HMMTRAccessoryServer *)v14 fabricID];
      [v21 startThreadRadioForSystemCommissionerFabricID:v22];
    }
  }
  uint64_t v23 = random();
  id v24 = (void *)MEMORY[0x2533B64D0]();
  __int16 v25 = self;
  id v26 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
  {
    __int16 v27 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543618;
    __int16 v36 = v27;
    __int16 v37 = 2048;
    uint64_t v38 = v23;
    _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window with PIN job(%lu) queued.", buf, 0x16u);
  }
  v31[0] = MEMORY[0x263EF8330];
  v31[1] = 3221225472;
  v31[2] = __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke;
  v31[3] = &unk_265377390;
  v31[4] = v25;
  uint64_t v33 = v23;
  double v34 = a3;
  __int16 v32 = v6;
  v29[0] = MEMORY[0x263EF8330];
  v29[1] = 3221225472;
  v29[2] = __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke_413;
  id v29[3] = &unk_2653787C8;
  uint64_t v30 = v32;
  [(HMMTRAccessoryServer *)v25 queueAccessoryOperation:v31 highPriority:1 completion:v29];

LABEL_17:
}

void __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138543618;
    uint64_t v19 = v5;
    __int16 v20 = 2048;
    uint64_t v21 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window with PIN job(%lu) started.", buf, 0x16u);
  }
  [*(id *)(a1 + 32) _startCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNamePairingWindowWithPasscode"];
  [*(id *)(a1 + 32) _notifyDelegateOfPairingProgress:24];
  int v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke_408;
  block[3] = &unk_265377408;
  __int16 v9 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  uint64_t v17 = *(void *)(a1 + 56);
  uint64_t v15 = v7;
  id v16 = v9;
  uint64_t v10 = v7;
  dispatch_async(v8, block);

  int v11 = [*(id *)(a1 + 32) clientQueue];
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  v13[2] = __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke_412;
  v13[3] = &unk_265377168;
  uint64_t v12 = *(void *)(a1 + 48);
  void v13[4] = *(void *)(a1 + 32);
  void v13[5] = v12;
  dispatch_group_notify(v10, v11, v13);
}

uint64_t __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke_413(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke_408(uint64_t a1)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = [NSNumber numberWithDouble:*(double *)(a1 + 56)];
    *(_DWORD *)long long buf = 138543618;
    uint64_t v31 = v5;
    __int16 v32 = 2112;
    uint64_t v33 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to open the pairing window with PIN for a duration of %@", buf, 0x16u);
  }
  int v7 = [MEMORY[0x263F10FE0] generateRandomSetupPasscode];
  int64_t v8 = +[HMMTRUtilities randomDiscriminator];
  __int16 v9 = (void *)MEMORY[0x263F10DA8];
  uint64_t v10 = [*(id *)(a1 + 32) nodeID];
  uint64_t v11 = [v10 unsignedLongLongValue];
  uint64_t v12 = [*(id *)(a1 + 32) deviceController];
  __int16 v13 = [v9 deviceWithNodeID:v11 deviceController:v12];

  id v14 = objc_alloc(MEMORY[0x263F10CC8]);
  uint64_t v15 = [*(id *)(a1 + 32) clientQueue];
  id v16 = (void *)[v14 initWithDevice:v13 endpointID:&unk_2702B5988 queue:v15];

  if (v16)
  {
    v23[0] = MEMORY[0x263EF8330];
    v23[1] = 3221225472;
    void v23[2] = __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke_409;
    void v23[3] = &unk_2653773E0;
    void v23[4] = *(void *)(a1 + 32);
    id v24 = v13;
    id v25 = v7;
    int64_t v28 = v8;
    uint64_t v29 = *(void *)(a1 + 56);
    id v27 = *(id *)(a1 + 48);
    id v26 = *(id *)(a1 + 40);
    [v16 revokeCommissioningWithExpectedValues:MEMORY[0x263EFFA68] expectedValueInterval:&unk_2702B5988 completion:v23];
  }
  else
  {
    uint64_t v17 = (void *)MEMORY[0x2533B64D0]();
    id v18 = *(id *)(a1 + 32);
    uint64_t v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      __int16 v20 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v31 = v20;
      _os_log_impl(&dword_252495000, v19, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to open pairing window", buf, 0xCu);
    }
    uint64_t v21 = *(void *)(a1 + 48);
    uint64_t v22 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
    (*(void (**)(uint64_t, void, void *))(v21 + 16))(v21, 0, v22);

    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
}

void __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke_412(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    int64_t v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window with PIN job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke_409(uint64_t a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    int v7 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543618;
    id v18 = v7;
    __int16 v19 = 2112;
    id v20 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Revoked commissioning with error (expected): %@", buf, 0x16u);
  }
  int64_t v8 = *(void **)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = [NSNumber numberWithUnsignedInteger:*(void *)(a1 + 72)];
  uint64_t v11 = [NSNumber numberWithDouble:*(double *)(a1 + 80)];
  uint64_t v12 = [*(id *)(a1 + 32) clientQueue];
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  v13[2] = __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke_410;
  v13[3] = &unk_2653773B8;
  void v13[4] = *(void *)(a1 + 32);
  uint64_t v16 = *(void *)(a1 + 80);
  id v15 = *(id *)(a1 + 64);
  id v14 = *(id *)(a1 + 56);
  [v8 openCommissioningWindowWithSetupPasscode:v9 discriminator:v10 duration:v11 queue:v12 completion:v13];
}

void __79__HMMTRAccessoryServer__openPairingWindowWithPINForDuration_completionHandler___block_invoke_410(uint64_t a1, void *a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    int v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    uint64_t v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v24 = v10;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_INFO, "%{public}@Successfully opened pairing window", buf, 0xCu);
    }
    [*(id *)(a1 + 32) _notifyDelegateOfPairingProgress:25];
    uint64_t v11 = [*(id *)(a1 + 32) vendorID];
    [v5 setVendorID:v11];

    uint64_t v12 = [*(id *)(a1 + 32) productID];
    [v5 setProductID:v12];

    id v22 = 0;
    __int16 v13 = [v5 qrCodeString:&v22];
    id v14 = v22;
    id v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = *(id *)(a1 + 32);
    uint64_t v17 = HMFGetOSLogHandle();
    id v18 = v17;
    if (v13)
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        __int16 v19 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543618;
        id v24 = v19;
        __int16 v25 = 2112;
        id v26 = v13;
        _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_INFO, "%{public}@Returning setup payload = %@", buf, 0x16u);
      }
      id v20 = [*(id *)(a1 + 32) browser];
      [v20 registerPairingWindowWithSetupPayload:v13 duration:*(void *)(a1 + 32) accessoryServer:*(double *)(a1 + 56)];
    }
    else
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543618;
        id v24 = v21;
        __int16 v25 = 2112;
        id v26 = v14;
        _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_ERROR, "%{public}@QR code retrieval from setup payload failed: %@", buf, 0x16u);
      }
      id v14 = v14;

      __int16 v13 = 0;
      id v6 = v14;
    }
  }
  else
  {
    [*(id *)(a1 + 32) _notifyDelegateOfPairingProgress:26 error:v6];
    __int16 v13 = 0;
    id v14 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

- (void)openPairingWindowWithPINForDuration:(double)a3 completionHandler:(id)a4
{
  id v6 = a4;
  int v7 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __78__HMMTRAccessoryServer_openPairingWindowWithPINForDuration_completionHandler___block_invoke;
  block[3] = &unk_265377A50;
  double v11 = a3;
  void block[4] = self;
  id v10 = v6;
  id v8 = v6;
  dispatch_async(v7, block);
}

uint64_t __78__HMMTRAccessoryServer_openPairingWindowWithPINForDuration_completionHandler___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _openPairingWindowWithPINForDuration:*(void *)(a1 + 40) completionHandler:*(double *)(a1 + 48)];
}

- (void)_openPairingWindowForDuration:(double)a3 completionHandler:(id)a4
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v6 = (void (**)(id, void *))a4;
  if ([(HMMTRAccessoryServer *)self operationDisabled])
  {
    int v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = self;
    uint64_t v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      id v10 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v24 = v10;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_INFO, "%{public}@Accessory server operations disabled. Aborting open pairing window.", buf, 0xCu);
    }
    double v11 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
    v6[2](v6, v11);
  }
  else
  {
    uint64_t v12 = random();
    __int16 v13 = (void *)MEMORY[0x2533B64D0]();
    id v14 = self;
    id v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      id v16 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      id v24 = v16;
      __int16 v25 = 2048;
      uint64_t v26 = v12;
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window job(%lu) queued.", buf, 0x16u);
    }
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    v19[2] = __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke;
    v19[3] = &unk_265377390;
    void v19[4] = v14;
    uint64_t v21 = v12;
    double v22 = a3;
    id v20 = v6;
    v17[0] = MEMORY[0x263EF8330];
    v17[1] = 3221225472;
    v17[2] = __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_407;
    v17[3] = &unk_2653787C8;
    id v18 = v20;
    [(HMMTRAccessoryServer *)v14 queueAccessoryOperation:v19 highPriority:1 completion:v17];
  }
}

void __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138543618;
    __int16 v19 = v5;
    __int16 v20 = 2048;
    uint64_t v21 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window job(%lu) started.", buf, 0x16u);
  }
  [*(id *)(a1 + 32) _notifyDelegateOfPairingProgress:21];
  [*(id *)(a1 + 32) _startCurrentMetricTimeWithName:@"hmmtrAccessoryMetricNamePairingWindow"];
  int v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_399;
  block[3] = &unk_265377408;
  uint64_t v9 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  uint64_t v17 = *(void *)(a1 + 56);
  id v15 = v7;
  id v16 = v9;
  id v10 = v7;
  dispatch_async(v8, block);

  double v11 = [*(id *)(a1 + 32) clientQueue];
  v13[0] = MEMORY[0x263EF8330];
  v13[1] = 3221225472;
  v13[2] = __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_406;
  v13[3] = &unk_265377168;
  uint64_t v12 = *(void *)(a1 + 48);
  void v13[4] = *(void *)(a1 + 32);
  void v13[5] = v12;
  dispatch_group_notify(v10, v11, v13);
}

uint64_t __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_407(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_399(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = [NSNumber numberWithDouble:*(double *)(a1 + 56)];
    *(_DWORD *)long long buf = 138543618;
    int64_t v28 = v5;
    __int16 v29 = 2112;
    uint64_t v30 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to open the pairing window for a duration of %@", buf, 0x16u);
  }
  int v7 = (void *)MEMORY[0x263F10DA8];
  id v8 = [*(id *)(a1 + 32) nodeID];
  uint64_t v9 = [v8 unsignedLongLongValue];
  id v10 = [*(id *)(a1 + 32) deviceController];
  double v11 = [v7 deviceWithNodeID:v9 deviceController:v10];

  id v12 = objc_alloc(MEMORY[0x263F10CC8]);
  __int16 v13 = [*(id *)(a1 + 32) clientQueue];
  id v14 = (void *)[v12 initWithDevice:v11 endpoint:0 queue:v13];

  id v15 = objc_alloc_init(MEMORY[0x263F10C48]);
  id v16 = [NSNumber numberWithDouble:*(double *)(a1 + 56)];
  [v15 setCommissioningTimeout:v16];

  uint64_t v17 = [v15 setTimedInvokeTimeoutMs:&unk_2702B5B38];
  if (v14)
  {
    v24[0] = MEMORY[0x263EF8330];
    v24[1] = 3221225472;
    v24[2] = __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_405;
    v24[3] = &unk_265377368;
    void v24[4] = *(void *)(a1 + 32);
    id v26 = *(id *)(a1 + 48);
    id v25 = *(id *)(a1 + 40);
    [v14 openBasicCommissioningWindowWithParams:v15 expectedValues:0 expectedValueInterval:0 completionHandler:v24];
  }
  else
  {
    id v18 = (void *)MEMORY[0x2533B64D0](v17);
    id v19 = *(id *)(a1 + 32);
    __int16 v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      uint64_t v21 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      int64_t v28 = v21;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_ERROR, "%{public}@No Matter device available to open pairing window", buf, 0xCu);
    }
    uint64_t v22 = *(void *)(a1 + 48);
    uint64_t v23 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
    (*(void (**)(uint64_t, void *))(v22 + 16))(v22, v23);

    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
}

void __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_406(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    id v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: open pairing window job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __72__HMMTRAccessoryServer__openPairingWindowForDuration_completionHandler___block_invoke_405(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    [*(id *)(a1 + 32) _notifyDelegateOfPairingProgress:23 error:v3];
  }
  else
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    uint64_t v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v7 = HMFGetLogIdentifier();
      int v8 = 138543362;
      __int16 v9 = v7;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Successfully opened pairing window", (uint8_t *)&v8, 0xCu);
    }
    [*(id *)(a1 + 32) _notifyDelegateOfPairingProgress:22];
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

- (void)_metricCollectionWithError:(id)a3 description:(id)a4 progressState:(int64_t)a5
{
  id v15 = a3;
  int v7 = [NSNumber numberWithInteger:a5];
  HMMLogTagActivityWithErrorAndField();

  int v8 = [v15 userInfo];
  __int16 v9 = v8;
  if (v8)
  {
    uint64_t v10 = [v8 objectForKey:*MEMORY[0x263F08608]];
  }
  else
  {
    uint64_t v10 = 0;
  }
  uint64_t v11 = [v15 domain];
  [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventErrorDomainKey" value:v11];

  id v12 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(v15, "code"));
  [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventErrorCodeKey" value:v12];

  if (v10)
  {
    __int16 v13 = [v10 domain];
    [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventUnderlyingErrorDomainKey" value:v13];

    id v14 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(v10, "code"));
    [(HAPAccessoryServer *)self setPairingMetricWithKey:@"hmmtrAccessoryPairingEventUnderlyingErrorCodeKey" value:v14];
  }
}

- (void)openPairingWindowForDuration:(double)a3 completionHandler:(id)a4
{
  id v6 = a4;
  int v7 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __71__HMMTRAccessoryServer_openPairingWindowForDuration_completionHandler___block_invoke;
  block[3] = &unk_265377A50;
  double v11 = a3;
  void block[4] = self;
  id v10 = v6;
  id v8 = v6;
  dispatch_async(v7, block);
}

uint64_t __71__HMMTRAccessoryServer_openPairingWindowForDuration_completionHandler___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _openPairingWindowForDuration:*(void *)(a1 + 40) completionHandler:*(double *)(a1 + 48)];
}

- (void)_updateAttributeTimer:(id)a3 report:(id)a4 timeout:(double)a5 server:(id)a6
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  id v10 = a3;
  id v11 = a4;
  id v12 = a6;
  __int16 v13 = [v10 description];
  id v14 = [(HMMTRAccessoryServer *)self attributeTimers];
  id v15 = [v14 objectForKeyedSubscript:v13];

  id v16 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v17 = self;
  id v18 = HMFGetOSLogHandle();
  BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG);
  if (v15)
  {
    if (v19)
    {
      __int16 v20 = HMFGetLogIdentifier();
      int v27 = 138543874;
      int64_t v28 = v20;
      __int16 v29 = 2112;
      uint64_t v30 = v13;
      __int16 v31 = 2112;
      id v32 = v11;
      _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_DEBUG, "%{public}@Attribute timer found for %@ - reset timer and update report with %@", (uint8_t *)&v27, 0x20u);
    }
    uint64_t v21 = [(HMMTRAccessoryServer *)v17 attributeTimers];
    uint64_t v22 = [v21 objectForKey:v13];

    [(HMMTRAttributeTimer *)v22 updateReport:v11];
  }
  else
  {
    if (v19)
    {
      uint64_t v23 = HMFGetLogIdentifier();
      int v27 = 138543874;
      int64_t v28 = v23;
      __int16 v29 = 2112;
      uint64_t v30 = v13;
      __int16 v31 = 2112;
      id v32 = v11;
      _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_DEBUG, "%{public}@Attribute timer NOT found for path %@ - Create timer with report %@", (uint8_t *)&v27, 0x20u);
    }
    id v24 = [HMMTRAttributeTimer alloc];
    id v25 = [(HAPAccessoryServer *)v17 clientQueue];
    uint64_t v22 = [(HMMTRAttributeTimer *)v24 initWithServer:v10 report:v11 timeout:v25 queue:v17 server:a5];

    id v26 = [(HMMTRAccessoryServer *)v17 attributeTimers];
    [v26 setObject:v22 forKey:v13];

    [(HMMTRAttributeTimer *)v22 start];
  }
}

- (void)_updatedCharacteristicsForEventReport:(id)a3 completionHandler:(id)a4
{
  uint64_t v125 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v82 = a4;
  id v91 = objc_alloc_init(MEMORY[0x263EFF980]);
  int v92 = v6;
  int v7 = [v6 objectForKeyedSubscript:*MEMORY[0x263F10BD0]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v8 = v7;
  }
  else {
    id v8 = 0;
  }
  id v9 = v8;

  id v10 = [v9 cluster];
  int v11 = [v10 isEqual:&unk_2702B5B08];

  if (!v11) {
    goto LABEL_12;
  }
  id v12 = [v92 objectForKeyedSubscript:*MEMORY[0x263F10BC0]];
  objc_opt_class();
  __int16 v13 = (objc_opt_isKindOfClass() & 1) != 0 ? v12 : 0;
  id v14 = v13;

  int v15 = [v14 isEqual:MEMORY[0x263EFFA88]];
  if (v15)
  {
    id v16 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v17 = self;
    id v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      BOOL v19 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      long long v113 = v19;
      __int16 v114 = 2112;
      id v115 = v92;
      _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_DEBUG, "%{public}@Ignored switch event %@ in initial reports", buf, 0x16u);
    }
    __int16 v20 = v82;
    (*((void (**)(id, void))v82 + 2))(v82, MEMORY[0x263EFFA68]);
    uint64_t v21 = v91;
  }
  else
  {
LABEL_12:
    long long v110 = 0u;
    long long v111 = 0u;
    long long v108 = 0u;
    long long v109 = 0u;
    id obj = [(HAPAccessoryServer *)self accessories];
    uint64_t v85 = [obj countByEnumeratingWithState:&v108 objects:v124 count:16];
    if (v85)
    {
      uint64_t v84 = *(void *)v109;
      uint64_t v22 = &off_265374000;
      id v94 = v9;
      id v95 = self;
      do
      {
        uint64_t v23 = 0;
        do
        {
          if (*(void *)v109 != v84) {
            objc_enumerationMutation(obj);
          }
          uint64_t v86 = v23;
          id v24 = *(void **)(*((void *)&v108 + 1) + 8 * v23);
          long long v104 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          long long v107 = 0u;
          id v25 = [v24 services];
          uint64_t v26 = [v25 countByEnumeratingWithState:&v104 objects:v123 count:16];
          if (v26)
          {
            uint64_t v27 = v26;
            uint64_t v28 = *(void *)v105;
            uint64_t v87 = *(void *)v105;
            uint64_t v88 = v25;
            do
            {
              uint64_t v29 = 0;
              uint64_t v89 = v27;
              do
              {
                if (*(void *)v105 != v28) {
                  objc_enumerationMutation(v25);
                }
                uint64_t v30 = *(void **)(*((void *)&v104 + 1) + 8 * v29);
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  [v30 endpoint];
                  __int16 v31 = v90 = v29;
                  [v9 endpoint];
                  id v32 = v93 = v30;
                  int v33 = [v31 isEqualToNumber:v32];

                  uint64_t v29 = v90;
                  if (v33)
                  {
                    long long v102 = 0u;
                    long long v103 = 0u;
                    long long v100 = 0u;
                    long long v101 = 0u;
                    id v96 = [v93 characteristics];
                    uint64_t v34 = [v96 countByEnumeratingWithState:&v100 objects:v122 count:16];
                    if (v34)
                    {
                      uint64_t v35 = v34;
                      uint64_t v97 = *(void *)v101;
                      do
                      {
                        for (uint64_t i = 0; i != v35; ++i)
                        {
                          if (*(void *)v101 != v97) {
                            objc_enumerationMutation(v96);
                          }
                          __int16 v37 = *(void **)(*((void *)&v100 + 1) + 8 * i);
                          uint64_t v38 = [v22[103] protocolMap];
                          uint64_t v39 = [v9 endpoint];
                          long long v40 = [(HMMTRAccessoryServer *)self clusterIDCharacteristicMap];
                          long long v41 = [v38 reportDescriptionForCharacteristic:v37 endpointID:v39 clusterIDCharacteristicMap:v40];

                          if (v41)
                          {
                            long long v42 = [v41 clusterId];
                            long long v43 = [v9 cluster];
                            if (([v42 isEqualToNumber:v43] & 1) != 0
                              && ([v41 eventIds], (uint64_t v44 = objc_claimAutoreleasedReturnValue()) != 0))
                            {
                              char v45 = (void *)v44;
                              uint64_t v46 = [v41 eventIds];
                              v98[0] = MEMORY[0x263EF8330];
                              v98[1] = 3221225472;
                              v98[2] = __80__HMMTRAccessoryServer__updatedCharacteristicsForEventReport_completionHandler___block_invoke;
                              v98[3] = &unk_265377340;
                              id v47 = v9;
                              id v99 = v47;
                              uint64_t v48 = [v46 indexOfObjectPassingTest:v98];

                              uint64_t v22 = &off_265374000;
                              BOOL v49 = v48 == 0x7FFFFFFFFFFFFFFFLL;
                              self = v95;
                              if (!v49)
                              {
                                uint64_t v50 = [v93 type];
                                int v51 = [v50 isEqualToString:@"0000003E-0000-1000-8000-0026BB765291"];

                                if (!v51
                                  || ([v47 cluster],
                                      char v52 = objc_claimAutoreleasedReturnValue(),
                                      char v53 = [v52 isEqual:&unk_2702B5B20],
                                      v52,
                                      (v53 & 1) == 0))
                                {
                                  char v54 = [v41 mapEvent];

                                  if (v54)
                                  {
                                    __int16 v55 = [v41 mapEvent];
                                    id v56 = [v47 event];
                                    long long v57 = ((void (**)(void, void *, void *))v55)[2](v55, v56, v92);
                                  }
                                  else
                                  {
                                    long long v57 = +[HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:v92];
                                  }
                                  uint64_t v58 = (void *)MEMORY[0x2533B64D0]();
                                  long long v59 = v95;
                                  long long v60 = HMFGetOSLogHandle();
                                  long long v61 = v60;
                                  if (v57)
                                  {
                                    if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
                                    {
                                      long long v62 = HMFGetLogIdentifier();
                                      *(_DWORD *)long long buf = 138543874;
                                      long long v113 = v62;
                                      __int16 v114 = 2112;
                                      id v115 = v37;
                                      __int16 v116 = 2112;
                                      __int16 v117 = v57;
                                      _os_log_impl(&dword_252495000, v61, OS_LOG_TYPE_INFO, "%{public}@Updating characteristic: %@ from report with value: %@", buf, 0x20u);
                                    }
                                    __int16 v63 = (void *)MEMORY[0x2533B64D0]();
                                    uint64_t v64 = v59;
                                    uint64_t v65 = HMFGetOSLogHandle();
                                    if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
                                    {
                                      __int16 v66 = HMFGetLogIdentifier();
                                      *(_DWORD *)long long buf = 138543618;
                                      long long v113 = v66;
                                      __int16 v114 = 2112;
                                      id v115 = v37;
                                      _os_log_impl(&dword_252495000, v65, OS_LOG_TYPE_INFO, "%{public}@Creating a copy for characteristic before modifying it %@", buf, 0x16u);
                                    }
                                    __int16 v67 = (void *)[v37 copy];
                                    uint64_t v68 = [v37 service];
                                    [v67 setService:v68];

                                    [v67 setValue:v57];
                                    [v91 addObject:v67];
                                    __int16 v69 = +[HMMTRProtocolMap protocolMap];
                                    id v70 = [v47 endpoint];
                                    __int16 v71 = [(HMMTRAccessoryServer *)v64 clusterIDCharacteristicMap];
                                    id v72 = [v69 getUpdatedLinkedCharacteristics:v67 endpointID:v70 clusterIDCharacteristicMap:v71];

                                    [v91 addObjectsFromArray:v72];
                                    self = v95;
                                  }
                                  else
                                  {
                                    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
                                    {
                                      __int16 v73 = HMFGetLogIdentifier();
                                      *(_DWORD *)long long buf = 138543618;
                                      long long v113 = v73;
                                      __int16 v114 = 2112;
                                      id v115 = v92;
                                      _os_log_impl(&dword_252495000, v61, OS_LOG_TYPE_DEBUG, "%{public}@Ignored event %@ which doesn't derive a value", buf, 0x16u);

                                      self = v95;
                                    }
                                  }

                                  uint64_t v22 = &off_265374000;
                                }
                              }
                              long long v42 = v99;
                              id v9 = v94;
                            }
                            else
                            {
                            }
                          }
                        }
                        uint64_t v35 = [v96 countByEnumeratingWithState:&v100 objects:v122 count:16];
                      }
                      while (v35);
                    }

                    uint64_t v28 = v87;
                    id v25 = v88;
                    uint64_t v27 = v89;
                    uint64_t v29 = v90;
                  }
                }
                ++v29;
              }
              while (v29 != v27);
              uint64_t v27 = [v25 countByEnumeratingWithState:&v104 objects:v123 count:16];
            }
            while (v27);
          }

          uint64_t v23 = v86 + 1;
        }
        while (v86 + 1 != v85);
        uint64_t v85 = [obj countByEnumeratingWithState:&v108 objects:v124 count:16];
      }
      while (v85);
    }

    id v74 = (void *)MEMORY[0x2533B64D0]();
    __int16 v75 = self;
    uint64_t v76 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v77 = HMFGetLogIdentifier();
      uint64_t v78 = [v9 endpoint];
      uint64_t v79 = [v9 cluster];
      [v9 event];
      v81 = id v80 = v9;
      *(_DWORD *)long long buf = 138544386;
      long long v113 = v77;
      __int16 v114 = 2112;
      id v115 = v91;
      __int16 v116 = 2112;
      __int16 v117 = v78;
      __int16 v118 = 2112;
      uint64_t v119 = v79;
      __int16 v120 = 2112;
      long long v121 = v81;
      _os_log_impl(&dword_252495000, v76, OS_LOG_TYPE_DEBUG, "%{public}@Updated characteristics %@ for Report endpoint:%@ cluster:%@ event:%@", buf, 0x34u);

      id v9 = v80;
    }

    __int16 v20 = v82;
    uint64_t v21 = v91;
    (*((void (**)(id, id))v82 + 2))(v82, v91);
  }
}

uint64_t __80__HMMTRAccessoryServer__updatedCharacteristicsForEventReport_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 event];
  uint64_t v5 = [v3 isEqualToNumber:v4];

  return v5;
}

- (void)_updatedCharacteristicsForAttributeReport:(id)a3 completionHandler:(id)a4
{
  uint64_t v126 = *MEMORY[0x263EF8340];
  id v79 = a3;
  id v70 = a4;
  group = dispatch_group_create();
  uint64_t v111 = 0;
  long long v112 = &v111;
  uint64_t v113 = 0x3032000000;
  __int16 v114 = __Block_byref_object_copy__8456;
  id v115 = __Block_byref_object_dispose__8457;
  id v116 = objc_alloc_init(MEMORY[0x263EFF980]);
  uint64_t v5 = [v79 objectForKeyedSubscript:*MEMORY[0x263F10B70]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v6 = v5;
  }
  else {
    id v6 = 0;
  }
  id v7 = v6;

  if (v7)
  {
    long long v109 = 0u;
    long long v110 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    id obj = [(HAPAccessoryServer *)self accessories];
    uint64_t v66 = [obj countByEnumeratingWithState:&v107 objects:v125 count:16];
    if (!v66) {
      goto LABEL_57;
    }
    uint64_t v67 = *(void *)v108;
    while (1)
    {
      for (uint64_t i = 0; i != v66; ++i)
      {
        if (*(void *)v108 != v67) {
          objc_enumerationMutation(obj);
        }
        id v8 = *(void **)(*((void *)&v107 + 1) + 8 * i);
        long long v103 = 0u;
        long long v104 = 0u;
        long long v105 = 0u;
        long long v106 = 0u;
        objc_msgSend(v8, "services", v66);
        id v71 = (id)objc_claimAutoreleasedReturnValue();
        uint64_t v73 = [v71 countByEnumeratingWithState:&v103 objects:v124 count:16];
        if (v73)
        {
          uint64_t v72 = *(void *)v104;
          do
          {
            for (uint64_t j = 0; j != v73; ++j)
            {
              if (*(void *)v104 != v72) {
                objc_enumerationMutation(v71);
              }
              uint64_t v77 = *(void **)(*((void *)&v103 + 1) + 8 * j);
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                id v9 = [v77 endpoint];
                id v10 = [v7 endpoint];
                int v11 = [v9 isEqualToNumber:v10];

                if (v11)
                {
                  long long v101 = 0u;
                  long long v102 = 0u;
                  long long v99 = 0u;
                  long long v100 = 0u;
                  id v12 = [v77 characteristics];
                  uint64_t v13 = [v12 countByEnumeratingWithState:&v99 objects:v123 count:16];
                  if (!v13) {
                    goto LABEL_52;
                  }
                  uint64_t v82 = *(void *)v100;
                  id v80 = v12;
                  while (1)
                  {
                    uint64_t v83 = v13;
                    for (uint64_t k = 0; k != v83; ++k)
                    {
                      if (*(void *)v100 != v82) {
                        objc_enumerationMutation(v80);
                      }
                      int v15 = *(void **)(*((void *)&v99 + 1) + 8 * k);
                      id v16 = +[HMMTRProtocolMap protocolMap];
                      uint64_t v17 = [v7 endpoint];
                      id v18 = [(HMMTRAccessoryServer *)self clusterIDCharacteristicMap];
                      BOOL v19 = [v16 reportDescriptionForCharacteristic:v15 endpointID:v17 clusterIDCharacteristicMap:v18];

                      if (v19)
                      {
                        __int16 v20 = [v19 clusterId];
                        uint64_t v21 = [v7 cluster];
                        if (v20 == v21
                          || ([v19 clusterId],
                              uint64_t v84 = objc_claimAutoreleasedReturnValue(),
                              [v7 cluster],
                              uint64_t v85 = objc_claimAutoreleasedReturnValue(),
                              [(HMMTRAccessoryServer *)self _isBridgedBasicInformation:v84 reportClusterID:v85]))
                        {
                          uint64_t v22 = [v19 attributeIds];
                          uint64_t v23 = [v7 attribute];
                          int v24 = [v22 containsObject:v23];

                          if (v20 == v21)
                          {

                            if (!v24) {
                              goto LABEL_46;
                            }
                            goto LABEL_30;
                          }
                        }
                        else
                        {
                          LOBYTE(v24) = 0;
                        }

                        if ((v24 & 1) == 0) {
                          goto LABEL_46;
                        }
LABEL_30:
                        dispatch_group_enter(group);
                        id v25 = [v19 clusterClass];
                        if (!v25
                          || ([v19 clusterSelector],
                              uint64_t v26 = objc_claimAutoreleasedReturnValue(),
                              BOOL v27 = v26 == 0,
                              v26,
                              v25,
                              v27))
                        {
                          long long v40 = (void *)MEMORY[0x2533B64D0]();
                          long long v41 = self;
                          HMFGetOSLogHandle();
                          long long v42 = (id)objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
                          {
                            long long v43 = HMFGetLogIdentifier();
                            *(_DWORD *)long long buf = 138543874;
                            __int16 v118 = v43;
                            __int16 v119 = 2112;
                            __int16 v120 = v15;
                            __int16 v121 = 2112;
                            id v122 = v79;
                            _os_log_impl(&dword_252495000, v42, OS_LOG_TYPE_DEBUG, "%{public}@Updating characteristic: %@ from report: %@", buf, 0x20u);
                          }
                          uint64_t v44 = (void *)[v15 copy];
                          char v45 = [v15 service];
                          [v44 setService:v45];

                          uint64_t v46 = [v19 mapValue];
                          if (v46)
                          {
                            uint64_t v78 = [v19 mapValue];
                            uint64_t v47 = (*(void (**)(uint64_t, id))(v78 + 16))(v78, v79);
                            __int16 v75 = (void *)v47;
                          }
                          else
                          {
                            uint64_t v47 = +[HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:v79];
                            uint64_t v76 = (void *)v47;
                          }
                          [v44 setValue:v47];
                          uint64_t v48 = v76;
                          if (v46)
                          {

                            uint64_t v48 = (void *)v78;
                          }

                          BOOL v49 = (void *)MEMORY[0x2533B64D0]();
                          uint64_t v50 = v41;
                          HMFGetOSLogHandle();
                          int v51 = (id)objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
                          {
                            char v52 = HMFGetLogIdentifier();
                            *(_DWORD *)long long buf = 138543618;
                            __int16 v118 = v52;
                            __int16 v119 = 2112;
                            __int16 v120 = v44;
                            _os_log_impl(&dword_252495000, v51, OS_LOG_TYPE_INFO, "%{public}@Updated characteristic from report: %@", buf, 0x16u);
                          }
                          [(id)v112[5] addObject:v44];
                          char v53 = +[HMMTRProtocolMap protocolMap];
                          char v54 = [v7 endpoint];
                          __int16 v55 = [(HMMTRAccessoryServer *)v50 clusterIDCharacteristicMap];
                          id v56 = [v53 getUpdatedLinkedCharacteristics:v44 endpointID:v54 clusterIDCharacteristicMap:v55];

                          [(id)v112[5] addObjectsFromArray:v56];
                          v91[0] = MEMORY[0x263EF8330];
                          v91[1] = 3221225472;
                          v91[2] = __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_387;
                          v91[3] = &unk_2653772F0;
                          id v93 = &v111;
                          int v92 = group;
                          [(HMMTRAccessoryServer *)v50 _updateAdditionalCharacteristicsFromCharacteristicUpdate:v44 service:v77 path:v7 completionHandler:v91];
                        }
                        else
                        {
                          uint64_t v28 = (void *)MEMORY[0x2533B64D0]();
                          uint64_t v29 = self;
                          HMFGetOSLogHandle();
                          uint64_t v30 = (id)objc_claimAutoreleasedReturnValue();
                          if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
                          {
                            __int16 v31 = HMFGetLogIdentifier();
                            *(_DWORD *)long long buf = 138543618;
                            __int16 v118 = v31;
                            __int16 v119 = 2112;
                            __int16 v120 = v15;
                            _os_log_impl(&dword_252495000, v30, OS_LOG_TYPE_INFO, "%{public}@Attribute report needs custom handling for Characteristic %@", buf, 0x16u);
                          }
                          id v32 = [(HMMTRAccessoryServer *)v29 matterDevice];

                          if (v32)
                          {
                            int v33 = [HMMTRProtocolOperation alloc];
                            uint64_t v34 = [(HMMTRAccessoryServer *)v29 matterDevice];
                            uint64_t v35 = [(HMMTRAccessoryServer *)v29 clusterIDCharacteristicMap];
                            __int16 v36 = [(HMMTRProtocolOperation *)v33 initWithOperationOfType:2 characteristic:v15 matterDevice:v34 primaryArgument:v79 clusterIDCharacteristicMap:v35];

                            __int16 v37 = +[HMMTRProtocolOperationManager sharedInstance];
                            uint64_t v38 = [(HAPAccessoryServer *)v29 clientQueue];
                            uint64_t v39 = [(HMMTRAccessoryServer *)v29 reportDistributor];
                            v94[0] = MEMORY[0x263EF8330];
                            v94[1] = 3221225472;
                            v94[2] = __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke;
                            v94[3] = &unk_265377318;
                            v94[4] = v29;
                            v94[5] = v15;
                            __int16 v98 = &v111;
                            id v95 = v7;
                            id v96 = v77;
                            uint64_t v97 = group;
                            [v37 registerOperation:v36 accessoryServer:v29 clientQueue:v38 reportDistributor:v39 operationResponseHandler:v94 updatedAttributesHandler:0];
                          }
                          else
                          {
                            long long v57 = (void *)MEMORY[0x2533B64D0]();
                            uint64_t v58 = v29;
                            HMFGetOSLogHandle();
                            long long v59 = (id)objc_claimAutoreleasedReturnValue();
                            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
                            {
                              long long v60 = HMFGetLogIdentifier();
                              *(_DWORD *)long long buf = 138543618;
                              __int16 v118 = v60;
                              __int16 v119 = 2112;
                              __int16 v120 = v15;
                              _os_log_impl(&dword_252495000, v59, OS_LOG_TYPE_ERROR, "%{public}@MTRDevice unavailable to custom-handle the Attribute Report for characteristic %@", buf, 0x16u);
                            }
                            dispatch_group_leave(group);
                          }
                        }
                      }
LABEL_46:
                    }
                    id v12 = v80;
                    uint64_t v13 = [v80 countByEnumeratingWithState:&v99 objects:v123 count:16];
                    if (!v13)
                    {
LABEL_52:

                      break;
                    }
                  }
                }
              }
            }
            uint64_t v73 = [v71 countByEnumeratingWithState:&v103 objects:v124 count:16];
          }
          while (v73);
        }
      }
      uint64_t v66 = [obj countByEnumeratingWithState:&v107 objects:v125 count:16];
      if (!v66)
      {
LABEL_57:

        long long v61 = [(HAPAccessoryServer *)self clientQueue];
        block[0] = MEMORY[0x263EF8330];
        block[1] = 3221225472;
        block[2] = __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_2;
        block[3] = &unk_2653781A0;
        void block[4] = self;
        uint64_t v90 = &v111;
        id v88 = v7;
        id v89 = v70;
        dispatch_group_notify(group, v61, block);

        goto LABEL_61;
      }
    }
  }
  long long v62 = (void *)MEMORY[0x2533B64D0]();
  __int16 v63 = self;
  HMFGetOSLogHandle();
  uint64_t v64 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
  {
    uint64_t v65 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    __int16 v118 = v65;
    _os_log_impl(&dword_252495000, v64, OS_LOG_TYPE_ERROR, "%{public}@Attribute path missing from report. Cannot handle this report.", buf, 0xCu);
  }
  (*((void (**)(id, uint64_t))v70 + 2))(v70, v112[5]);
LABEL_61:

  _Block_object_dispose(&v111, 8);
}

void __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = [v3 error];

  if (v4)
  {
    uint64_t v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = *(id *)(a1 + 32);
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v8 = HMFGetLogIdentifier();
      id v9 = [v3 error];
      uint64_t v10 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138543874;
      BOOL v27 = v8;
      __int16 v28 = 2112;
      uint64_t v29 = v9;
      __int16 v30 = 2112;
      uint64_t v31 = v10;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_ERROR, "%{public}@Error: %@. Failed to handle a report for characteristic: %@", buf, 0x20u);
    }
  }
  else
  {
    int v11 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
    id v12 = [v3 characteristic];
    [v11 addObject:v12];

    uint64_t v13 = +[HMMTRProtocolMap protocolMap];
    id v14 = [v3 characteristic];
    int v15 = [*(id *)(a1 + 48) endpoint];
    id v16 = [*(id *)(a1 + 32) clusterIDCharacteristicMap];
    uint64_t v17 = [v13 getUpdatedLinkedCharacteristics:v14 endpointID:v15 clusterIDCharacteristicMap:v16];

    [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) addObjectsFromArray:v17];
  }
  id v18 = *(void **)(a1 + 32);
  BOOL v19 = [v3 characteristic];
  uint64_t v21 = *(void *)(a1 + 48);
  uint64_t v20 = *(void *)(a1 + 56);
  v24[0] = MEMORY[0x263EF8330];
  v24[1] = 3221225472;
  v24[2] = __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_385;
  v24[3] = &unk_2653772F0;
  long long v23 = *(_OWORD *)(a1 + 64);
  id v22 = (id)v23;
  long long v25 = v23;
  [v18 _updateAdditionalCharacteristicsFromCharacteristicUpdate:v19 service:v20 path:v21 completionHandler:v24];
}

void __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_387(uint64_t a1, uint64_t a2)
{
  [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) addObjectsFromArray:a2];
  id v3 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v3);
}

uint64_t __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_2(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    id v7 = [*(id *)(a1 + 40) endpoint];
    id v8 = [*(id *)(a1 + 40) cluster];
    id v9 = [*(id *)(a1 + 40) attribute];
    int v11 = 138544386;
    id v12 = v5;
    __int16 v13 = 2112;
    uint64_t v14 = v6;
    __int16 v15 = 2112;
    id v16 = v7;
    __int16 v17 = 2112;
    id v18 = v8;
    __int16 v19 = 2112;
    uint64_t v20 = v9;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_DEBUG, "%{public}@Updated characteristics %@ for Report endpoint:%@ cluster:%@ attribute:%@", (uint8_t *)&v11, 0x34u);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
}

void __84__HMMTRAccessoryServer__updatedCharacteristicsForAttributeReport_completionHandler___block_invoke_385(uint64_t a1, uint64_t a2)
{
  [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) addObjectsFromArray:a2];
  id v3 = *(NSObject **)(a1 + 32);
  dispatch_group_leave(v3);
}

- (void)_updateAdditionalCharacteristicsFromCharacteristicUpdate:(id)a3 service:(id)a4 path:(id)a5 completionHandler:(id)a6
{
  uint64_t v104 = *MEMORY[0x263EF8340];
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  __int16 v13 = (void (**)(id, id))a6;
  id v14 = objc_alloc_init(MEMORY[0x263EFF980]);
  __int16 v15 = [v12 cluster];
  if (![v15 isEqualToNumber:&unk_2702B5A60]) {
    goto LABEL_13;
  }
  uint64_t v6 = [v12 attribute];
  if (([v6 isEqualToNumber:&unk_2702B5A78] & 1) == 0)
  {

LABEL_13:
    goto LABEL_14;
  }
  id v16 = [v10 type];
  int v17 = [v16 isEqualToString:@"00000033-0000-1000-8000-0026BB765291"];

  if (v17)
  {
    id v18 = [v10 value];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      __int16 v19 = v18;
    }
    else {
      __int16 v19 = 0;
    }
    id v20 = v19;

    if (!v20
      || ([v20 isEqualToNumber:&unk_2702B5988] & 1) != 0
      || [v20 isEqualToNumber:&unk_2702B5A90])
    {
      v13[2](v13, v14);
    }
    else
    {
      id v73 = v20;
      uint64_t v78 = v14;
      id v81 = v11;
      long long v94 = 0u;
      long long v95 = 0u;
      long long v92 = 0u;
      long long v93 = 0u;
      id obja = [v11 characteristics];
      uint64_t v48 = [obja countByEnumeratingWithState:&v92 objects:v103 count:16];
      if (v48)
      {
        uint64_t v49 = v48;
        uint64_t v50 = *(void *)v93;
LABEL_47:
        uint64_t v51 = 0;
        while (1)
        {
          if (*(void *)v93 != v50) {
            objc_enumerationMutation(obja);
          }
          char v52 = *(void **)(*((void *)&v92 + 1) + 8 * v51);
          char v53 = [v52 type];
          char v54 = [v53 isEqualToString:@"00000035-0000-1000-8000-0026BB765291"];

          if (v54) {
            break;
          }
          if (v49 == ++v51)
          {
            uint64_t v49 = [obja countByEnumeratingWithState:&v92 objects:v103 count:16];
            if (v49) {
              goto LABEL_47;
            }
            goto LABEL_53;
          }
        }
        id v55 = v52;

        if (!v55) {
          goto LABEL_57;
        }
        id v56 = [(HMMTRAccessoryServer *)self matterDevice];

        if (v56)
        {
          long long v57 = [HMMTRProtocolOperation alloc];
          uint64_t v58 = [(HMMTRAccessoryServer *)self matterDevice];
          long long v59 = [(HMMTRAccessoryServer *)self clusterIDCharacteristicMap];
          id objb = [(HMMTRProtocolOperation *)v57 initWithOperationOfType:4 characteristic:v55 matterDevice:v58 clusterIDCharacteristicMap:v59];

          long long v60 = +[HMMTRProtocolOperationManager sharedInstance];
          long long v61 = [(HAPAccessoryServer *)self clientQueue];
          long long v62 = [(HMMTRAccessoryServer *)self reportDistributor];
          v87[0] = MEMORY[0x263EF8330];
          v87[1] = 3221225472;
          v87[2] = __112__HMMTRAccessoryServer__updateAdditionalCharacteristicsFromCharacteristicUpdate_service_path_completionHandler___block_invoke;
          v87[3] = &unk_2653772C8;
          v87[4] = self;
          id v88 = v55;
          id v89 = v10;
          id v90 = v78;
          id v91 = v13;
          id v63 = v55;
          [v60 registerOperation:objb accessoryServer:self clientQueue:v61 reportDistributor:v62 operationResponseHandler:v87 updatedAttributesHandler:0];

          id v14 = v78;
        }
        else
        {
          __int16 v69 = (void *)MEMORY[0x2533B64D0]();
          id v70 = self;
          id v71 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
          {
            uint64_t v72 = HMFGetLogIdentifier();
            *(_DWORD *)long long buf = 138543618;
            uint64_t v97 = v72;
            __int16 v98 = 2112;
            id v99 = v10;
            _os_log_impl(&dword_252495000, v71, OS_LOG_TYPE_ERROR, "%{public}@MTRDevice unavailable to update additional target temperature characteristics %@", buf, 0x16u);
          }
          id v14 = v78;
          v13[2](v13, v78);
        }
      }
      else
      {
LABEL_53:

LABEL_57:
        uint64_t v64 = (void *)MEMORY[0x2533B64D0]();
        uint64_t v65 = self;
        uint64_t v66 = HMFGetOSLogHandle();
        id v14 = v78;
        if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
        {
          uint64_t v67 = HMFGetLogIdentifier();
          uint64_t v68 = [v12 endpoint];
          *(_DWORD *)long long buf = 138543618;
          uint64_t v97 = v67;
          __int16 v98 = 2112;
          id v99 = v68;
          _os_log_impl(&dword_252495000, v66, OS_LOG_TYPE_ERROR, "%{public}@Unexpected, target temperature characteristic not found on endpoint %@", buf, 0x16u);
        }
        v13[2](v13, v78);
      }
      id v11 = v81;
      id v20 = v73;
    }

    goto LABEL_44;
  }
LABEL_14:
  uint64_t v21 = [v12 cluster];
  int v22 = [v21 isEqualToNumber:&unk_2702B5AA8];

  if (!v22)
  {
    v13[2](v13, v14);
    goto LABEL_44;
  }
  long long v23 = [v12 attribute];
  int v24 = [v23 isEqualToNumber:&unk_2702B5AC0];
  char v25 = v24;
  if (v24
    && ([v10 type],
        uint64_t v6 = objc_claimAutoreleasedReturnValue(),
        [v6 isEqualToString:@"00000013-0000-1000-8000-0026BB765291"]))
  {
  }
  else
  {
    uint64_t v26 = v13;
    id v27 = v14;
    __int16 v28 = [v12 attribute];
    if (![v28 isEqualToNumber:&unk_2702B5AD8])
    {

      if (v25) {
      id v14 = v27;
      }
      __int16 v13 = v26;
      goto LABEL_44;
    }
    uint64_t v29 = [v10 type];
    int v79 = [v29 isEqualToString:@"0000002F-0000-1000-8000-0026BB765291"];

    if (v25)
    {

      id v14 = v27;
      __int16 v13 = v26;
      if ((v79 & 1) == 0) {
        goto LABEL_44;
      }
    }
    else
    {

      id v14 = v27;
      __int16 v13 = v26;
      if (!v79) {
        goto LABEL_44;
      }
    }
  }
  id obj = v10;
  uint64_t v77 = v14;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  id v80 = v11;
  __int16 v30 = [v11 characteristics];
  uint64_t v31 = [v30 countByEnumeratingWithState:&v83 objects:v102 count:16];
  if (v31)
  {
    uint64_t v32 = v31;
    uint64_t v33 = *(void *)v84;
LABEL_29:
    uint64_t v34 = 0;
    while (1)
    {
      if (*(void *)v84 != v33) {
        objc_enumerationMutation(v30);
      }
      uint64_t v35 = *(void **)(*((void *)&v83 + 1) + 8 * v34);
      __int16 v36 = [v35 type];
      char v37 = [v36 isEqualToString:@"000000CE-0000-1000-8000-0026BB765291"];

      if (v37) {
        break;
      }
      if (v32 == ++v34)
      {
        uint64_t v32 = [v30 countByEnumeratingWithState:&v83 objects:v102 count:16];
        if (v32) {
          goto LABEL_29;
        }
        goto LABEL_35;
      }
    }
    id v38 = v35;

    if (!v38) {
      goto LABEL_40;
    }
    uint64_t v39 = (void *)MEMORY[0x2533B64D0]();
    long long v40 = self;
    long long v41 = HMFGetOSLogHandle();
    id v10 = obj;
    id v14 = v77;
    if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
    {
      long long v42 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543874;
      uint64_t v97 = v42;
      __int16 v98 = 2112;
      id v99 = v38;
      __int16 v100 = 2112;
      id v101 = obj;
      _os_log_impl(&dword_252495000, v41, OS_LOG_TYPE_INFO, "%{public}@Updated additional characteristic %@ \nbased on characteristic \n%@", buf, 0x20u);
    }
    [v38 setValue:&unk_2702B5AF0];
    [v77 addObject:v38];
    v13[2](v13, v77);
  }
  else
  {
LABEL_35:

LABEL_40:
    long long v43 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v44 = self;
    char v45 = HMFGetOSLogHandle();
    id v10 = obj;
    id v14 = v77;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      uint64_t v46 = HMFGetLogIdentifier();
      uint64_t v47 = [v12 endpoint];
      *(_DWORD *)long long buf = 138543618;
      uint64_t v97 = v46;
      __int16 v98 = 2112;
      id v99 = v47;
      _os_log_impl(&dword_252495000, v45, OS_LOG_TYPE_ERROR, "%{public}@Unexpected, color temperature characteristic not found on endpoint %@", buf, 0x16u);
    }
    v13[2](v13, v77);
  }
  id v11 = v80;
LABEL_44:
}

void __112__HMMTRAccessoryServer__updateAdditionalCharacteristicsFromCharacteristicUpdate_service_path_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = [v3 error];

  uint64_t v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = *(id *)(a1 + 32);
  id v7 = HMFGetOSLogHandle();
  id v8 = v7;
  if (v4)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v9 = HMFGetLogIdentifier();
      id v10 = [v3 error];
      uint64_t v11 = *(void *)(a1 + 40);
      int v17 = 138543874;
      id v18 = v9;
      __int16 v19 = 2112;
      id v20 = v10;
      __int16 v21 = 2112;
      uint64_t v22 = v11;
      _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_ERROR, "%{public}@Error: %@. Failed to handle a report for characteristic: %@", (uint8_t *)&v17, 0x20u);
    }
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v12 = HMFGetLogIdentifier();
      __int16 v13 = *(void **)(a1 + 40);
      uint64_t v14 = *(void *)(a1 + 48);
      int v17 = 138543874;
      id v18 = v12;
      __int16 v19 = 2112;
      id v20 = v13;
      __int16 v21 = 2112;
      uint64_t v22 = v14;
      _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_INFO, "%{public}@Updated additional characteristic %@ based on characteristic %@", (uint8_t *)&v17, 0x20u);
    }
    __int16 v15 = *(void **)(a1 + 56);
    id v16 = [v3 characteristic];
    [v15 addObject:v16];
  }
  (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
}

- (BOOL)_isBridgedBasicInformation:(id)a3 reportClusterID:(id)a4
{
  id v5 = a4;
  BOOL v6 = [a3 isEqualToNumber:&unk_2702B59E8]
    && ([v5 isEqualToNumber:&unk_2702B5A48] & 1) != 0;

  return v6;
}

- (id)deviceTopology
{
  id v3 = [HMMTRDeviceTopology alloc];
  id v4 = [(HMMTRAccessoryServer *)self nodeID];
  id v5 = [(HMMTRDeviceTopology *)v3 initWithNodeId:v4 server:self];

  return v5;
}

- (BOOL)_handleUnmappedAttributeReport:(id)a3
{
  id v4 = a3;
  id v5 = [v4 objectForKeyedSubscript:*MEMORY[0x263F10B70]];
  BOOL v6 = [v5 cluster];
  if ([v6 isEqualToNumber:&unk_2702B59B8])
  {
    id v7 = [v5 attribute];
    int v8 = [v7 isEqualToNumber:&unk_2702B59D0];

    if (v8)
    {
      id v9 = [(HMMTRAccessoryServer *)self chipDelegate];
      char v10 = objc_opt_respondsToSelector();

      if (v10)
      {
        uint64_t v11 = [(HAPAccessoryServer *)self delegateQueue];
        block[0] = MEMORY[0x263EF8330];
        block[1] = 3221225472;
        block[2] = __55__HMMTRAccessoryServer__handleUnmappedAttributeReport___block_invoke;
        block[3] = &unk_265378638;
        void block[4] = self;
        dispatch_async(v11, block);
      }
      goto LABEL_22;
    }
  }
  else
  {
  }
  id v12 = [v5 cluster];
  if ([v12 isEqualToNumber:&unk_2702B59E8])
  {
    __int16 v13 = [v5 attribute];
    int v14 = [v13 isEqualToNumber:&unk_2702B5A00];

    if (v14)
    {
      __int16 v15 = +[HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:v4];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        id v16 = v15;
      }
      else {
        id v16 = 0;
      }
      id v17 = v16;

      [(HMMTRAccessoryServer *)self updateSoftwareVersion:v17];
      goto LABEL_23;
    }
  }
  else
  {
  }
  id v18 = [v5 cluster];
  if ([v18 isEqualToNumber:&unk_2702B59E8])
  {
    __int16 v19 = [v5 attribute];
    int v20 = [v19 isEqualToNumber:&unk_2702B5A18];

    if (v20)
    {
      __int16 v21 = +[HMMTRUtilities mtrBaseClusterValueFromMTRClusterReportValue:v4];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = 0;
      }
      uint64_t v23 = v22;

      softwareVersionString = self->_softwareVersionString;
      self->_softwareVersionString = v23;

      goto LABEL_23;
    }
  }
  else
  {
  }
  char v25 = [v5 cluster];
  int v26 = [v25 isEqualToNumber:&unk_2702B5A30];

  if (!v26)
  {
LABEL_23:
    BOOL v28 = 0;
    goto LABEL_24;
  }
  id v27 = [(HMMTRAccessoryServer *)self matterFirmwareUpdateStatus];
  [v27 handleOTARequestorAttributeReport:v4];

LABEL_22:
  BOOL v28 = 1;
LABEL_24:

  return v28;
}

void __55__HMMTRAccessoryServer__handleUnmappedAttributeReport___block_invoke(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) chipDelegate];
  [v2 didUpdatePairingsForAccessoryServer:*(void *)(a1 + 32)];
}

- (void)isDiscoverableWithCompletion:(id)a3
{
  id v4 = a3;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  v7[2] = __53__HMMTRAccessoryServer_isDiscoverableWithCompletion___block_invoke;
  v7[3] = &unk_2653770F0;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

uint64_t __53__HMMTRAccessoryServer_isDiscoverableWithCompletion___block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if ([*(id *)(a1 + 32) removalInProgress])
  {
    id v2 = (void *)MEMORY[0x2533B64D0]();
    id v3 = *(id *)(a1 + 32);
    id v4 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
LABEL_5:

      return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0);
    }
    id v5 = HMFGetLogIdentifier();
    int v9 = 138543362;
    char v10 = v5;
    id v6 = "%{public}@Do not discover server - Removal in progress";
LABEL_4:
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, v6, (uint8_t *)&v9, 0xCu);

    goto LABEL_5;
  }
  if ([*(id *)(a1 + 32) mtrDeviceStateReported]
    && ([*(id *)(a1 + 32) mtrDeviceConnected] & 1) == 0
    && [*(id *)(a1 + 32) _shouldUpdateUnreachableState])
  {
    id v2 = (void *)MEMORY[0x2533B64D0]();
    id v3 = *(id *)(a1 + 32);
    id v4 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_INFO)) {
      goto LABEL_5;
    }
    id v5 = HMFGetLogIdentifier();
    int v9 = 138543362;
    char v10 = v5;
    id v6 = "%{public}@Do not discover server - MTRDevice state is not reachable";
    goto LABEL_4;
  }
  id v8 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
  return v8();
}

- (void)triggerEstablishingMatterSubscription
{
  v2[0] = MEMORY[0x263EF8330];
  v2[1] = 3221225472;
  v2[2] = __61__HMMTRAccessoryServer_triggerEstablishingMatterSubscription__block_invoke;
  v2[3] = &unk_265378638;
  v2[4] = self;
  [(HMMTRAccessoryServer *)self dispatchBlock:v2];
}

void __61__HMMTRAccessoryServer_triggerEstablishingMatterSubscription__block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    id v2 = [*(id *)(a1 + 32) matterDevice];
    char v3 = objc_opt_respondsToSelector();

    if (v3)
    {
      id v4 = (void *)MEMORY[0x2533B64D0]();
      id v5 = *(id *)(a1 + 32);
      id v6 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        id v7 = HMFGetLogIdentifier();
        int v9 = 138543362;
        char v10 = v7;
        _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Calling MTRDevice _deviceMayBeReachable", (uint8_t *)&v9, 0xCu);
      }
      id v8 = [*(id *)(a1 + 32) matterDevice];
      [v8 _deviceMayBeReachable];
    }
  }
}

- (void)_setupMatterDevice
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  char v3 = [(HAPAccessoryServer *)self clientQueue];
  dispatch_assert_queue_V2(v3);

  BOOL v4 = [(HMMTRAccessoryServer *)self isDisabled];
  id v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_INFO);
  if (v4)
  {
    if (v8)
    {
      int v9 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v30 = v9;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Setup-reporting block called after server is disabled. Ignored.", buf, 0xCu);
    }
  }
  else
  {
    if (v8)
    {
      char v10 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v30 = v10;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Request to setup reporting", buf, 0xCu);
    }
    uint64_t v11 = [(HMMTRAccessoryServer *)v6 matterDevice];
    BOOL v12 = v11 == 0;

    if (v12)
    {
      v28[0] = MEMORY[0x263EF8330];
      v28[1] = 3221225472;
      v28[2] = __42__HMMTRAccessoryServer__setupMatterDevice__block_invoke;
      v28[3] = &unk_265377278;
      void v28[4] = v6;
      __int16 v13 = (void (**)(void, void))MEMORY[0x2533B66E0](v28);
      ((void (**)(void, HMMTRAccessoryServer *))v13)[2](v13, v6);
      if (![(HMMTRAccessoryServer *)v6 controllerRevokeHandlerRegistered])
      {
        [(HMMTRAccessoryServer *)v6 setControllerRevokeHandlerRegistered:1];
        objc_initWeak(&location, v6);
        int v14 = [(HMMTRAccessoryServer *)v6 controllerWrapper];
        __int16 v15 = [(HAPAccessoryServer *)v6 clientQueue];
        v24[0] = MEMORY[0x263EF8330];
        v24[1] = 3221225472;
        v24[2] = __42__HMMTRAccessoryServer__setupMatterDevice__block_invoke_328;
        v24[3] = &unk_2653772A0;
        objc_copyWeak(&v26, &location);
        char v25 = v13;
        [v14 registerRevokeHandlerWithQueue:v15 handler:v24];

        int v20 = (void *)MEMORY[0x2533B64D0](v16, v17, v18, v19);
        __int16 v21 = v6;
        HMFGetOSLogHandle();
        uint64_t v22 = (id)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
        {
          uint64_t v23 = HMFGetLogIdentifier();
          *(_DWORD *)long long buf = 138543362;
          __int16 v30 = v23;
          _os_log_impl(&dword_252495000, v22, OS_LOG_TYPE_INFO, "%{public}@Registered controller revoke handler", buf, 0xCu);
        }

        objc_destroyWeak(&v26);
        objc_destroyWeak(&location);
      }
    }
  }
}

void __42__HMMTRAccessoryServer__setupMatterDevice__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  id v3 = a2;
  BOOL v4 = [v3 controllerWrapper];

  id v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = v3;
  id v7 = HMFGetOSLogHandle();
  BOOL v8 = v7;
  if (v4)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      int v9 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v34 = v9;
      _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_INFO, "%{public}@Setting up MTRDevice", buf, 0xCu);
    }
    char v10 = [v6 nodeID];
    uint64_t v11 = [v6 deviceController];
    BOOL v12 = [v6 mtrDeviceWithNodeID:v10 controller:v11];
    [v6 setMatterDevice:v12];

    __int16 v13 = [v6 matterDevice];
    int v14 = [v6 clientQueue];
    [v13 setDelegate:v6 queue:v14];

    __int16 v15 = [v6 matterDevice];
    LODWORD(v14) = [v15 deviceCachePrimed];

    uint64_t v16 = [v6 reportDistributor];
    uint64_t v17 = v16;
    if (v14) {
      [v16 allAttributesReady];
    }
    else {
      [v16 allAttributesNotReady];
    }

    uint64_t v19 = [v6 matterDevice];
    uint64_t v20 = [v19 state];
    BOOL v21 = v20 == 1;

    [v6 setMtrDeviceStateReported:v21];
    [v6 setMtrDeviceConnected:v21];
    if (v20 != 1)
    {
      uint64_t v22 = [*(id *)(a1 + 32) matterDevice];
      char v23 = [v22 deviceCachePrimed];

      if ((v23 & 1) == 0)
      {
        int v24 = (void *)MEMORY[0x2533B64D0]();
        id v25 = *(id *)(a1 + 32);
        id v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          id v27 = HMFGetLogIdentifier();
          *(_DWORD *)long long buf = 138543362;
          uint64_t v34 = v27;
          _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_INFO, "%{public}@Server starting as unreachable as MTRDevice is unreachable and its cache is not primed", buf, 0xCu);
        }
        [v6 setReachable:0];
      }
      BOOL v28 = [MEMORY[0x263F08C38] UUID];
      [v6 setInitialMTRDeviceStateTimeoutId:v28];
      v30[0] = MEMORY[0x263EF8330];
      v30[1] = 3221225472;
      v30[2] = __42__HMMTRAccessoryServer__setupMatterDevice__block_invoke_326;
      v30[3] = &unk_265376E98;
      id v31 = v6;
      id v32 = v28;
      id v29 = v28;
      [v31 _startInitialReachableStateTimerWithCompletion:v30];
    }
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v18 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v34 = v18;
      _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Not setting up MTRDevice for a disabled accessory server", buf, 0xCu);
    }
  }
}

uint64_t __42__HMMTRAccessoryServer__setupMatterDevice__block_invoke_328(uint64_t a1, void *a2, char a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v7 = WeakRetained;
  if ((a3 & 1) == 0)
  {
    __int16 v13 = [WeakRetained reportDistributor];
    [v13 allAttributesNotReady];

    [v7 setMatterDevice:0];
    int v14 = (void *)MEMORY[0x2533B64D0]([v7 _flushMTRDeviceReadReadyHandlers]);
    id v15 = v7;
    uint64_t v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      uint64_t v17 = HMFGetLogIdentifier();
      int v19 = 138543362;
      uint64_t v20 = v17;
      _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@Device controller wrapper is disabled.", (uint8_t *)&v19, 0xCu);
    }
    if (v7) {
      goto LABEL_5;
    }
LABEL_9:
    uint64_t v12 = 0;
    goto LABEL_10;
  }
  BOOL v8 = (void *)MEMORY[0x2533B64D0]();
  id v9 = v7;
  char v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    uint64_t v11 = HMFGetLogIdentifier();
    int v19 = 138543362;
    uint64_t v20 = v11;
    _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Device controller wrapper is revoked and back online. Setting up MTRDevice again.", (uint8_t *)&v19, 0xCu);
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  if (!v7) {
    goto LABEL_9;
  }
LABEL_5:
  uint64_t v12 = [v7 isDisabled] ^ 1;
LABEL_10:

  return v12;
}

void __42__HMMTRAccessoryServer__setupMatterDevice__block_invoke_326(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (([*(id *)(a1 + 32) mtrDeviceStateReported] & 1) == 0)
  {
    uint64_t v2 = [*(id *)(a1 + 32) matterDevice];
    if (v2)
    {
      id v3 = (void *)v2;
      BOOL v4 = [*(id *)(a1 + 32) initialMTRDeviceStateTimeoutId];
      id v5 = *(void **)(a1 + 40);

      if (v4 == v5)
      {
        id v6 = (void *)MEMORY[0x2533B64D0]();
        id v7 = *(id *)(a1 + 32);
        BOOL v8 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
        {
          id v9 = HMFGetLogIdentifier();
          int v10 = 138543618;
          uint64_t v11 = v9;
          __int16 v12 = 1024;
          int v13 = 60;
          _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_INFO, "%{public}@No MTRDevice state was reported for %d seconds. Reporting unreachable state.", (uint8_t *)&v10, 0x12u);
        }
        [*(id *)(a1 + 32) didUpdateReachability:0];
        [*(id *)(a1 + 32) _updateDelegateOfConnectionStatus:0 withError:0];
      }
    }
  }
}

- (void)setupReporting
{
  id v3 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __38__HMMTRAccessoryServer_setupReporting__block_invoke;
  block[3] = &unk_265378638;
  void block[4] = self;
  dispatch_async(v3, block);
}

uint64_t __38__HMMTRAccessoryServer_setupReporting__block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _setupMatterDevice];
}

- (void)_startInitialReachableStateTimerWithCompletion:(id)a3
{
  id v4 = a3;
  dispatch_time_t v5 = dispatch_time(0, 60000000000);
  id v6 = [(HAPAccessoryServer *)self clientQueue];
  dispatch_after(v5, v6, v4);
}

- (void)didUpdateReachability:(BOOL)a3
{
  BOOL v3 = a3;
  -[HAPAccessoryServer setReachable:](self, "setReachable:");
  dispatch_time_t v5 = [(HMMTRAccessoryServer *)self primaryAccessory];
  id v6 = [(HAPAccessoryServer *)self buildReachabilityNotificationDictionary:v5 reachable:v3 linkType:1 withError:0];

  [(HAPAccessoryServer *)self notifyClients:1 withDictionary:v6];
}

- (BOOL)isDisabled
{
  if ([(HAPAccessoryServer *)self isReachable]) {
    return 0;
  }
  id v4 = [(HMMTRAccessoryServer *)self controllerWrapper];
  BOOL v3 = v4 == 0;

  return v3;
}

- (void)_flushMTRDeviceReadReadyHandlers
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  BOOL v3 = [(HMMTRAccessoryServer *)self pendingMTRDeviceReadReadyHandlers];
  id v4 = [v3 allValues];

  dispatch_time_t v5 = [(HMMTRAccessoryServer *)self pendingMTRDeviceReadReadyHandlers];
  [v5 removeAllObjects];

  if ((objc_msgSend(v4, "hmf_isEmpty") & 1) == 0)
  {
    id v6 = (void *)MEMORY[0x2533B64D0]();
    id v7 = self;
    BOOL v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v21 = v9;
      _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_INFO, "%{public}@Flushing all pending MTRDevice read-ready handlers", buf, 0xCu);
    }
  }
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v10 = v4;
  uint64_t v11 = [v10 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v11)
  {
    uint64_t v12 = v11;
    uint64_t v13 = *(void *)v16;
    do
    {
      uint64_t v14 = 0;
      do
      {
        if (*(void *)v16 != v13) {
          objc_enumerationMutation(v10);
        }
        (*(void (**)(void))(*(void *)(*((void *)&v15 + 1) + 8 * v14) + 16))(*(void *)(*((void *)&v15 + 1) + 8 * v14));
        ++v14;
      }
      while (v12 != v14);
      uint64_t v12 = [v10 countByEnumeratingWithState:&v15 objects:v19 count:16];
    }
    while (v12);
  }
}

- (void)disable
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  BOOL v3 = (void *)MEMORY[0x2533B64D0](self, a2);
  id v4 = self;
  dispatch_time_t v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    id v29 = v6;
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@disabling", buf, 0xCu);
  }
  id v7 = [(HMMTRAccessoryServer *)v4 matterFirmwareUpdateStatus];
  uint64_t v8 = [v7 otaProviderState];

  if (v8 == 4)
  {
    id v9 = [(HMMTRAccessoryServer *)v4 matterFirmwareUpdateStatus];
    [v9 updateFirmwareUpdateStatus:0];
  }
  id v10 = [(HMMTRAccessoryServer *)v4 serviceEnumerationFromDeviceCompletionHandlers];
  uint64_t v11 = (void *)[v10 copy];

  uint64_t v12 = [(HMMTRAccessoryServer *)v4 serviceEnumerationFromDeviceCompletionHandlers];
  [v12 removeAllObjects];

  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v13 = v11;
  uint64_t v14 = [v13 countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (v14)
  {
    uint64_t v15 = v14;
    uint64_t v16 = *(void *)v24;
    do
    {
      uint64_t v17 = 0;
      do
      {
        if (*(void *)v24 != v16) {
          objc_enumerationMutation(v13);
        }
        uint64_t v18 = *(void *)(*((void *)&v23 + 1) + 8 * v17);
        int v19 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
        (*(void (**)(uint64_t, void *))(v18 + 16))(v18, v19);

        ++v17;
      }
      while (v15 != v17);
      uint64_t v15 = [v13 countByEnumeratingWithState:&v23 objects:v27 count:16];
    }
    while (v15);
  }

  [(HAPAccessoryServer *)v4 setReachable:0];
  [(HAPAccessoryServer *)v4 setSecuritySessionOpen:0];
  [(HMMTRAccessoryServer *)v4 setControllerWrapper:0];
  [(HMMTRAccessoryServer *)v4 setMatterDevice:0];
  uint64_t v20 = [(HMMTRAccessoryServer *)v4 reachabilityManager];
  [v20 stop];

  uint64_t v21 = [(HAPAccessoryServer *)v4 clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __31__HMMTRAccessoryServer_disable__block_invoke;
  block[3] = &unk_265378638;
  void block[4] = v4;
  dispatch_async(v21, block);
}

uint64_t __31__HMMTRAccessoryServer_disable__block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _flushMTRDeviceReadReadyHandlers];
}

- (void)discoverAccessories
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  BOOL v3 = (void *)MEMORY[0x2533B64D0](self, a2);
  id v4 = self;
  dispatch_time_t v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    id v10 = v6;
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@discoverAccessories", buf, 0xCu);
  }
  id v7 = [(HAPAccessoryServer *)v4 clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __43__HMMTRAccessoryServer_discoverAccessories__block_invoke;
  block[3] = &unk_265378638;
  void block[4] = v4;
  dispatch_async(v7, block);
}

void __43__HMMTRAccessoryServer_discoverAccessories__block_invoke(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  int v2 = [*(id *)(a1 + 32) servicesEnumerated];
  BOOL v3 = *(void **)(a1 + 32);
  if (v2)
  {
    if ([v3 _delegateRespondsToSelector:sel_accessoryServer_didDiscoverAccessories_transaction_error_])
    {
      id v4 = (void *)MEMORY[0x2533B64D0]();
      id v5 = *(id *)(a1 + 32);
      id v6 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        id v7 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543362;
        id v13 = v7;
        _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Did discover accessories", buf, 0xCu);
      }
      uint64_t v8 = [*(id *)(a1 + 32) delegateQueue];
      block[0] = MEMORY[0x263EF8330];
      block[1] = 3221225472;
      block[2] = __43__HMMTRAccessoryServer_discoverAccessories__block_invoke_322;
      block[3] = &unk_265378638;
      void block[4] = *(void *)(a1 + 32);
      dispatch_async(v8, block);
    }
    if ([*(id *)(a1 + 32) mtrDeviceConnected]) {
      [*(id *)(a1 + 32) _updateDelegateOfConnectionStatus:1 withError:0];
    }
  }
  else if ([v3 serviceEnumerationFailed] {
         && [*(id *)(a1 + 32) _delegateRespondsToSelector:sel_accessoryServer_didDiscoverAccessories_transaction_error_])
  }
  {
    id v9 = [*(id *)(a1 + 32) delegateQueue];
    v10[0] = MEMORY[0x263EF8330];
    v10[1] = 3221225472;
    v10[2] = __43__HMMTRAccessoryServer_discoverAccessories__block_invoke_2;
    v10[3] = &unk_265378638;
    void v10[4] = *(void *)(a1 + 32);
    dispatch_async(v9, v10);
  }
}

void __43__HMMTRAccessoryServer_discoverAccessories__block_invoke_322(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) delegate];
  int v2 = *(void **)(a1 + 32);
  BOOL v3 = [v2 accessories];
  id v4 = (void *)[v3 copy];
  [v5 accessoryServer:v2 didDiscoverAccessories:v4 transaction:0 error:0];
}

void __43__HMMTRAccessoryServer_discoverAccessories__block_invoke_2(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  int v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    int v9 = 138543362;
    id v10 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Did fail discovering accessories", (uint8_t *)&v9, 0xCu);
  }
  id v6 = [*(id *)(a1 + 32) delegate];
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = [MEMORY[0x263F087E8] hapErrorWithCode:19 description:@"Accessory enumeration failed" reason:0 suggestion:0 underlyingError:0];
  [v6 accessoryServer:v7 didDiscoverAccessories:0 transaction:0 error:v8];
}

- (void)listPairingsWithCompletionQueue:(id)a3 completionHandler:(id)a4
{
  id v6 = a4;
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 3221225472;
  void v8[2] = __74__HMMTRAccessoryServer_listPairingsWithCompletionQueue_completionHandler___block_invoke;
  v8[3] = &unk_2653770F0;
  v8[4] = self;
  id v9 = v6;
  id v7 = v6;
  dispatch_async((dispatch_queue_t)a3, v8);
}

uint64_t __74__HMMTRAccessoryServer_listPairingsWithCompletionQueue_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    int v7 = 138543362;
    uint64_t v8 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory List Pairings a WIP", (uint8_t *)&v7, 0xCu);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

- (BOOL)isPairedInStorage
{
  uint64_t v3 = [(HMMTRAccessoryServer *)self nodeID];
  if (!v3) {
    return 0;
  }
  id v4 = (void *)v3;
  id v5 = [(HMMTRAccessoryServer *)self fabricID];

  if (!v5) {
    return 0;
  }
  BOOL v6 = [(HMMTRAccessoryServer *)self knownToSystemCommissioner];
  int v7 = [(HMMTRAccessoryServer *)self storage];
  uint64_t v8 = v7;
  if (v6)
  {
    uint64_t v9 = [v7 pairedNodeIDsOnSystemCommissionerFabric:1];
    id v10 = [(HMMTRAccessoryServer *)self nodeID];
    char v11 = [v9 containsObject:v10];
  }
  else
  {
    uint64_t v9 = [v7 dataSource];
    id v10 = [(HMMTRAccessoryServer *)self fabricID];
    uint64_t v12 = [v9 storageDataSourceForFabricWithID:v10];
    id v13 = [v12 allNodeIDs];
    uint64_t v14 = [(HMMTRAccessoryServer *)self nodeID];
    char v11 = [v13 containsObject:v14];
  }
  return v11;
}

- (void)commitStagedPairing
{
  uint64_t v3 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __43__HMMTRAccessoryServer_commitStagedPairing__block_invoke;
  block[3] = &unk_265378638;
  void block[4] = self;
  dispatch_async(v3, block);
}

void __43__HMMTRAccessoryServer_commitStagedPairing__block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = [*(id *)(a1 + 32) pairedState];
  uint64_t v3 = (void *)MEMORY[0x2533B64D0]();
  id v4 = *(id *)(a1 + 32);
  id v5 = HMFGetOSLogHandle();
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_INFO);
  if (v2 == 2)
  {
    if (v6)
    {
      int v7 = HMFGetLogIdentifier();
      int v9 = 138543362;
      id v10 = v7;
      _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@Committing staged server by marking as paired and notifying the delegate", (uint8_t *)&v9, 0xCu);
    }
    [*(id *)(a1 + 32) _finalizePairing];
  }
  else
  {
    if (v6)
    {
      uint64_t v8 = HMFGetLogIdentifier();
      int v9 = 138543362;
      id v10 = v8;
      _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@Ignoring attempt to commit a server that is not staged", (uint8_t *)&v9, 0xCu);
    }
  }
}

- (void)_onUnpairFinishedWithError:(id)a3 queue:(id)a4 completion:(id)a5
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  id v8 = a3;
  queue = a4;
  id v9 = a5;
  id v10 = [v8 domain];
  int v11 = [v10 isEqualToString:*MEMORY[0x263F10BB0]];

  if (v11)
  {
    uint64_t v12 = [MEMORY[0x263F087E8] hapErrorWithCode:1];

    id v8 = (id)v12;
  }
  [(HMMTRAccessoryServer *)self setPairedState:0];
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id v13 = [(HAPAccessoryServer *)self accessories];
  uint64_t v14 = [v13 countByEnumeratingWithState:&v33 objects:v41 count:16];
  if (v14)
  {
    uint64_t v15 = v14;
    uint64_t v16 = *(void *)v34;
    do
    {
      for (uint64_t i = 0; i != v15; ++i)
      {
        if (*(void *)v34 != v16) {
          objc_enumerationMutation(v13);
        }
        uint64_t v18 = *(void **)(*((void *)&v33 + 1) + 8 * i);
        int v19 = [(HAPAccessoryServer *)self keyStore];
        uint64_t v20 = [v18 identifier];
        [v19 removeAccessoryKeyForName:v20 error:0];
      }
      uint64_t v15 = [v13 countByEnumeratingWithState:&v33 objects:v41 count:16];
    }
    while (v15);
  }

  [(HMMTRAccessoryServer *)self _deleteAccessoryServerData];
  uint64_t v21 = [(HMMTRAccessoryServer *)self browser];
  uint64_t v22 = [MEMORY[0x263F087E8] hmmtrErrorWithCode:12];
  [v21 abortOperationsForAccessoryServer:self reason:v22];

  [(HMMTRAccessoryServer *)self disable];
  long long v23 = (void *)MEMORY[0x2533B64D0]([(HMMTRAccessoryServer *)self setRemovalInProgress:0]);
  long long v24 = self;
  long long v25 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
  {
    long long v26 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543618;
    id v38 = v26;
    __int16 v39 = 2112;
    id v40 = v8;
    _os_log_impl(&dword_252495000, v25, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory unpair completed. Error: %@", buf, 0x16u);
  }
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __68__HMMTRAccessoryServer__onUnpairFinishedWithError_queue_completion___block_invoke;
  block[3] = &unk_2653770F0;
  id v31 = v8;
  id v32 = v9;
  id v27 = v8;
  id v28 = v9;
  dispatch_async(queue, block);
}

void __68__HMMTRAccessoryServer__onUnpairFinishedWithError_queue_completion___block_invoke(uint64_t a1)
{
  uint64_t v2 = (void (**)(void, void))MEMORY[0x2533B66E0](*(void *)(a1 + 40));
  if (v2)
  {
    id v3 = v2;
    v2[2](v2, *(void *)(a1 + 32));
    uint64_t v2 = (void (**)(void, void))v3;
  }
}

- (void)_unpair:(id)a3 completion:(id)a4
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  BOOL v6 = a3;
  id v7 = a4;
  discriminator = self->_discriminator;
  self->_discriminator = 0;

  setUpPINCode = self->_setUpPINCode;
  self->_setUpPINCode = 0;

  id v10 = [(HMMTRAccessoryServer *)self deviceController];
  if (![(HMMTRAccessoryServer *)self isPaired]
    && ![(HMMTRAccessoryServer *)self commissioningCompleted])
  {
    uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v16 = self;
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v27 = v18;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@Ignoring unpair request as accessory is not paired", buf, 0xCu);
    }
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __43__HMMTRAccessoryServer__unpair_completion___block_invoke;
    block[3] = &unk_2653770F0;
    void block[4] = v16;
    id v13 = &v25;
    id v25 = v7;
    uint64_t v14 = block;
    goto LABEL_9;
  }
  [(HMMTRAccessoryServer *)self setRemovalInProgress:1];
  if (!v10)
  {
    v22[0] = MEMORY[0x263EF8330];
    v22[1] = 3221225472;
    v22[2] = __43__HMMTRAccessoryServer__unpair_completion___block_invoke_2;
    v22[3] = &unk_2653770F0;
    void v22[4] = self;
    id v13 = &v23;
    id v23 = v7;
    uint64_t v14 = v22;
LABEL_9:
    dispatch_async(v6, v14);
    goto LABEL_10;
  }
  unint64_t v11 = [(NSNumber *)self->_nodeID unsignedLongLongValue];
  uint64_t v12 = [(HAPAccessoryServer *)self clientQueue];
  v19[0] = MEMORY[0x263EF8330];
  v19[1] = 3221225472;
  v19[2] = __43__HMMTRAccessoryServer__unpair_completion___block_invoke_3;
  v19[3] = &unk_265377250;
  void v19[4] = self;
  id v13 = (id *)&v20;
  uint64_t v20 = v6;
  id v21 = v7;
  [v10 getBaseDevice:v11 queue:v12 completionHandler:v19];

LABEL_10:
}

void __43__HMMTRAccessoryServer__unpair_completion___block_invoke(uint64_t a1)
{
  [*(id *)(a1 + 32) setRemoveReason:0 pairingEndContextWhenRemove:0];
  id v3 = (void (**)(id, void *))MEMORY[0x2533B66E0](*(void *)(a1 + 40));
  if (v3)
  {
    uint64_t v2 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
    v3[2](v3, v2);
  }
}

void __43__HMMTRAccessoryServer__unpair_completion___block_invoke_2(uint64_t a1)
{
  [*(id *)(a1 + 32) setRemoveReason:0 pairingEndContextWhenRemove:0];
  id v3 = (void (**)(id, void *))MEMORY[0x2533B66E0](*(void *)(a1 + 40));
  if (v3)
  {
    uint64_t v2 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
    v3[2](v3, v2);
  }
}

void __43__HMMTRAccessoryServer__unpair_completion___block_invoke_3(uint64_t a1, void *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      *(void *)&uint8_t buf[4] = v10;
      __int16 v26 = 2112;
      id v27 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Error: %@. Failed to establish a connection to the device for unpairing. The device will not be notified of removal", buf, 0x16u);
    }
    [*(id *)(a1 + 32) _onUnpairFinishedWithError:v6 queue:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
  }
  else
  {
    id v11 = objc_alloc(MEMORY[0x263F42520]);
    uint64_t v12 = [*(id *)(a1 + 32) clientQueue];
    id v13 = (void *)[v11 initWithQueue:v12];

    *(void *)long long buf = _HMFThreadLocalAsyncContextPush();
    uint64_t v14 = +[HMMTRDescriptorClusterManager sharedManager];
    uint64_t v15 = [v14 runBlockForAllEndpointsWithClusterID:&unk_2702B59A0 device:v5 callbackQueue:*(void *)(a1 + 40) block:&__block_literal_global_314];
    v20[0] = MEMORY[0x263EF8330];
    v20[1] = 3221225472;
    v20[2] = __43__HMMTRAccessoryServer__unpair_completion___block_invoke_2_316;
    v20[3] = &unk_265377228;
    id v16 = v5;
    uint64_t v17 = *(void *)(a1 + 32);
    uint64_t v18 = *(void **)(a1 + 40);
    id v21 = v16;
    uint64_t v22 = v17;
    id v23 = v18;
    id v24 = *(id *)(a1 + 48);
    id v19 = (id)[v15 finally:v20];

    _HMFThreadLocalAsyncContextPop();
  }
}

uint64_t __43__HMMTRAccessoryServer__unpair_completion___block_invoke_2_316(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) clientQueue];
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = __43__HMMTRAccessoryServer__unpair_completion___block_invoke_3_317;
  v6[3] = &unk_265377368;
  id v4 = *(void **)(a1 + 48);
  void v6[4] = *(void *)(a1 + 40);
  id v7 = v4;
  id v8 = *(id *)(a1 + 56);
  [v2 unpairDevice:v3 completionHandler:v6];

  return 1;
}

void __43__HMMTRAccessoryServer__unpair_completion___block_invoke_3_317(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    int v8 = 138543618;
    id v9 = v7;
    __int16 v10 = 2112;
    id v11 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Unpair Status: %@", (uint8_t *)&v8, 0x16u);
  }
  [*(id *)(a1 + 32) _onUnpairFinishedWithError:v3 queue:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

uint64_t __43__HMMTRAccessoryServer__unpair_completion___block_invoke_311()
{
  return [MEMORY[0x263F42538] futureWithNoValue];
}

- (BOOL)removePairingForCurrentControllerOnQueue:(id)a3 completion:(id)a4
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = (void (**)(id, void))a4;
  if ([(HMMTRAccessoryServer *)self isDisabled])
  {
    int v8 = (void *)MEMORY[0x2533B64D0]();
    id v9 = self;
    __int16 v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      id v11 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v11;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Accessory server already disabled. Remove complete.", buf, 0xCu);
    }
    uint64_t v12 = [(HMMTRAccessoryServer *)v9 browser];
    id v13 = [MEMORY[0x263F087E8] hmmtrErrorWithCode:12];
    [v12 invalidateAccessoryServer:v9 reason:v13];

    v7[2](v7, 0);
  }
  else if ([(HMMTRAccessoryServer *)self operationDisabled] {
         && [(HMMTRAccessoryServer *)self operationDisabledReason] != 1)
  }
  {
    id v21 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v22 = self;
    id v23 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      id v24 = HMFGetLogIdentifier();
      uint64_t v25 = [(HMMTRAccessoryServer *)v22 operationDisabledReason];
      __int16 v26 = "";
      if (v25 == 2) {
        __int16 v26 = " because pairings are removed on accessory side";
      }
      *(_DWORD *)long long buf = 138543618;
      *(void *)&uint8_t buf[4] = v24;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v26;
      _os_log_impl(&dword_252495000, v23, OS_LOG_TYPE_INFO, "%{public}@Operation disabled%s. Proceeding with removing accessory on the controller side.", buf, 0x16u);
    }
    id v27 = [(HMMTRAccessoryServer *)v22 browser];
    uint64_t v28 = v27;
    if (!v27
      || ([v27 workQueue],
          id v29 = objc_claimAutoreleasedReturnValue(),
          BOOL v30 = v29 == 0,
          v29,
          v30))
    {
      [(HMMTRAccessoryServer *)v22 _onUnpairFinishedWithError:0 queue:v6 completion:v7];
    }
    else
    {
      id v31 = [v28 workQueue];
      block[0] = MEMORY[0x263EF8330];
      block[1] = 3221225472;
      block[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke;
      block[3] = &unk_2653775F0;
      id v48 = v28;
      uint64_t v49 = v22;
      id v50 = v6;
      uint64_t v51 = v7;
      dispatch_async(v31, block);
    }
  }
  else
  {
    uint64_t v14 = random();
    uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = self;
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      uint64_t v18 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      *(void *)&uint8_t buf[4] = v18;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v14;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: unpair job(%lu) queued.", buf, 0x16u);
    }
    *(void *)long long buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v53 = 0;
    [(HMMTRAccessoryServer *)v16 setRemovalInProgress:1];
    v42[0] = MEMORY[0x263EF8330];
    v42[1] = 3221225472;
    v42[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_301;
    v42[3] = &unk_265377190;
    v42[4] = v16;
    uint64_t v46 = v14;
    id v43 = v6;
    char v45 = buf;
    uint64_t v44 = v7;
    v37[0] = MEMORY[0x263EF8330];
    v37[1] = 3221225472;
    v37[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_305;
    v37[3] = &unk_2653771B8;
    id v40 = buf;
    uint64_t v41 = v14;
    v37[4] = v16;
    id v38 = v43;
    id v19 = v44;
    id v39 = v19;
    [(HMMTRAccessoryServer *)v16 queueAccessoryOperation:v42 highPriority:1 completion:v37];
    dispatch_time_t v20 = dispatch_time(0, 5000000000);
    v33[0] = MEMORY[0x263EF8330];
    v33[1] = 3221225472;
    v33[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_2_307;
    v33[3] = &unk_2653771E0;
    void v33[4] = v16;
    long long v35 = buf;
    uint64_t v36 = v14;
    long long v34 = v19;
    [(HMMTRAccessoryServer *)v16 dispatchAfter:v20 block:v33];

    _Block_object_dispose(buf, 8);
  }

  return 1;
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = [MEMORY[0x263F087E8] hmmtrErrorWithCode:12];
  [v2 invalidateAccessoryServer:v3 reason:v4];

  id v5 = [*(id *)(a1 + 40) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_2;
  block[3] = &unk_265378900;
  id v6 = *(void **)(a1 + 48);
  void block[4] = *(void *)(a1 + 40);
  id v8 = v6;
  id v9 = *(id *)(a1 + 56);
  dispatch_async(v5, block);
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_301(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 64);
    *(_DWORD *)long long buf = 138543618;
    id v21 = v5;
    __int16 v22 = 2048;
    uint64_t v23 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: unpair job(%lu) started.", buf, 0x16u);
  }
  id v7 = dispatch_group_create();
  dispatch_group_enter(v7);
  id v8 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_302;
  block[3] = &unk_265377140;
  id v9 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  id v17 = v9;
  long long v14 = *(_OWORD *)(a1 + 48);
  id v10 = (id)v14;
  long long v19 = v14;
  uint64_t v18 = v7;
  id v11 = v7;
  dispatch_async(v8, block);

  uint64_t v12 = [*(id *)(a1 + 32) clientQueue];
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_3;
  v15[3] = &unk_265377168;
  uint64_t v13 = *(void *)(a1 + 64);
  void v15[4] = *(void *)(a1 + 32);
  void v15[5] = v13;
  dispatch_group_notify(v11, v12, v15);
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_305(uint64_t a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    uint64_t v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      id v7 = HMFGetLogIdentifier();
      uint64_t v8 = *(void *)(a1 + 64);
      *(_DWORD *)long long buf = 138543618;
      id v16 = v7;
      __int16 v17 = 2048;
      uint64_t v18 = v8;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: unpair job(%lu) unscheduled.", buf, 0x16u);
    }
    id v9 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + (int)*MEMORY[0x263F35B30]);
    os_unfair_lock_lock_with_options();
    uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8);
    if (*(unsigned char *)(v10 + 24))
    {
      os_unfair_lock_unlock(v9);
    }
    else
    {
      *(unsigned char *)(v10 + 24) = 1;
      os_unfair_lock_unlock(v9);
      v12[0] = MEMORY[0x263EF8330];
      v12[1] = 3221225472;
      v12[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_306;
      v12[3] = &unk_2653770F0;
      id v11 = *(NSObject **)(a1 + 40);
      id v14 = *(id *)(a1 + 48);
      id v13 = v3;
      dispatch_async(v11, v12);
    }
  }
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_2_307(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v2 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  if (*(unsigned char *)(v3 + 24))
  {
    os_unfair_lock_unlock(v2);
  }
  else
  {
    *(unsigned char *)(v3 + 24) = 1;
    os_unfair_lock_unlock(v2);
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    uint64_t v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      id v7 = HMFGetLogIdentifier();
      uint64_t v8 = *(void *)(a1 + 56);
      int v11 = 138543618;
      uint64_t v12 = v7;
      __int16 v13 = 2048;
      uint64_t v14 = v8;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Characteristic Operation Queue: unpair job(%lu) timed out before completion", (uint8_t *)&v11, 0x16u);
    }
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v10 = [MEMORY[0x263F087E8] hmfErrorWithCode:13];
    (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);
  }
}

uint64_t __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_306(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_302(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    uint64_t v15 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Request to remove pairing for current controller", buf, 0xCu);
  }
  id v7 = *(void **)(a1 + 32);
  uint64_t v6 = *(void **)(a1 + 40);
  v9[0] = MEMORY[0x263EF8330];
  v9[1] = 3221225472;
  v9[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_303;
  v9[3] = &unk_265377118;
  uint64_t v8 = *(void *)(a1 + 64);
  v9[4] = v7;
  uint64_t v13 = v8;
  id v10 = v6;
  id v12 = *(id *)(a1 + 56);
  id v11 = *(id *)(a1 + 48);
  [v7 _unpair:v10 completion:v9];
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_3(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138543618;
    uint64_t v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Characteristics Operation Queue: unpair job(%lu) complete.", (uint8_t *)&v7, 0x16u);
  }
}

void __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_303(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  uint64_t v5 = *(void *)(*(void *)(a1 + 64) + 8);
  if (*(unsigned char *)(v5 + 24))
  {
    os_unfair_lock_unlock(v4);
  }
  else
  {
    *(unsigned char *)(v5 + 24) = 1;
    os_unfair_lock_unlock(v4);
    uint64_t v6 = *(NSObject **)(a1 + 40);
    v7[0] = MEMORY[0x263EF8330];
    v7[1] = 3221225472;
    v7[2] = __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_2_304;
    v7[3] = &unk_2653770F0;
    id v9 = *(id *)(a1 + 56);
    id v8 = v3;
    dispatch_async(v6, v7);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

uint64_t __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_2_304(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t __76__HMMTRAccessoryServer_removePairingForCurrentControllerOnQueue_completion___block_invoke_2(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onUnpairFinishedWithError:0 queue:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

- (void)removePairing:(id)a3 completionQueue:(id)a4 completionHandler:(id)a5
{
  id v8 = a3;
  id v9 = a5;
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __72__HMMTRAccessoryServer_removePairing_completionQueue_completionHandler___block_invoke;
  block[3] = &unk_265378900;
  void block[4] = self;
  id v13 = v8;
  id v14 = v9;
  id v10 = v9;
  id v11 = v8;
  dispatch_async((dispatch_queue_t)a4, block);
}

uint64_t __72__HMMTRAccessoryServer_removePairing_completionQueue_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    int v8 = 138543618;
    id v9 = v5;
    __int16 v10 = 2112;
    uint64_t v11 = v6;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory Remove Pairing is a WIP. Removal requested for pairing identity %@", (uint8_t *)&v8, 0x16u);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
}

- (void)addPairing:(id)a3 completionQueue:(id)a4 completionHandler:(id)a5
{
  id v7 = a5;
  v9[0] = MEMORY[0x263EF8330];
  v9[1] = 3221225472;
  v9[2] = __69__HMMTRAccessoryServer_addPairing_completionQueue_completionHandler___block_invoke;
  v9[3] = &unk_2653770F0;
  v9[4] = self;
  id v10 = v7;
  id v8 = v7;
  dispatch_async((dispatch_queue_t)a4, v9);
}

uint64_t __69__HMMTRAccessoryServer_addPairing_completionQueue_completionHandler___block_invoke(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = HMFGetLogIdentifier();
    int v7 = 138543362;
    id v8 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory Add Pairing is a WIP", (uint8_t *)&v7, 0xCu);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

- (BOOL)stopPairingWithError:(id *)a3
{
  objc_initWeak(&location, self);
  id v4 = [(HAPAccessoryServer *)self clientQueue];
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = __45__HMMTRAccessoryServer_stopPairingWithError___block_invoke;
  v6[3] = &unk_265376E28;
  objc_copyWeak(&v7, &location);
  dispatch_async(v4, v6);

  objc_destroyWeak(&v7);
  objc_destroyWeak(&location);
  return 1;
}

void __45__HMMTRAccessoryServer_stopPairingWithError___block_invoke(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v1 = (id *)(a1 + 32);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v3 = (void *)MEMORY[0x2533B64D0]();
  id v4 = (id *)WeakRetained;
  uint64_t v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    uint64_t v19 = v6;
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@Attempting to stop pairing.", buf, 0xCu);
  }
  [v4 setPairingProgress:0];
  [v4 setPairingTimer:0];
  id v7 = [v4 deviceController];
  uint64_t v8 = [v4[56] unsignedLongLongValue];
  id v17 = 0;
  [v7 stopDevicePairing:v8 error:&v17];
  id v9 = v17;

  if (v9)
  {
    id v10 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v11 = v4;
    uint64_t v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      id v13 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      uint64_t v19 = v13;
      __int16 v20 = 2112;
      id v21 = v9;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory failed to stop Pairing with Error: %@", buf, 0x16u);
    }
  }
  id v14 = [v4 clientQueue];
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = __45__HMMTRAccessoryServer_stopPairingWithError___block_invoke_298;
  v15[3] = &unk_2653770C8;
  objc_copyWeak(&v16, v1);
  [v4 removePairingForCurrentControllerOnQueue:v14 completion:v15];

  objc_destroyWeak(&v16);
}

void __45__HMMTRAccessoryServer_stopPairingWithError___block_invoke_298(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = (void *)MEMORY[0x2533B64D0]();
  id v6 = WeakRetained;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v8 = HMFGetLogIdentifier();
    int v14 = 138543618;
    uint64_t v15 = v8;
    __int16 v16 = 2112;
    id v17 = v3;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Pairing stopped and accessory pairing removed with error: %@", (uint8_t *)&v14, 0x16u);
  }
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    id v9 = (void *)MEMORY[0x2533B64D0]();
    id v10 = v6;
    uint64_t v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v12 = HMFGetLogIdentifier();
      int v14 = 138543362;
      uint64_t v15 = v12;
      _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_DEBUG, "%{public}@Resetting storage state after pairing error", (uint8_t *)&v14, 0xCu);
    }
    id v13 = [v10 browser];
    [v13 setupStorageStateAndRediscoverAccessoriesForHomeFabricID:0];
  }
}

- (BOOL)tryPairingPassword:(id)a3 onboardingSetupPayloadString:(id)a4 error:(id *)a5
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v7 = a3;
  id v8 = a4;
  BOOL v9 = [(HMMTRAccessoryServer *)self locallyDiscovered];
  if (v9)
  {
    id v10 = [(HAPAccessoryServer *)self clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __78__HMMTRAccessoryServer_tryPairingPassword_onboardingSetupPayloadString_error___block_invoke;
    block[3] = &unk_265376F38;
    void block[4] = self;
    id v17 = v7;
    id v18 = v8;
    dispatch_async(v10, block);
  }
  else
  {
    uint64_t v11 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v12 = self;
    id v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      int v14 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v20 = v14;
      _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@CHIP Accessory in current state cannot try pairing password.", buf, 0xCu);
    }
  }

  return v9;
}

void __78__HMMTRAccessoryServer_tryPairingPassword_onboardingSetupPayloadString_error___block_invoke(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v2 = NSNumber;
  id v3 = [*(id *)(a1 + 40) stringByReplacingOccurrencesOfString:@"-" withString:&stru_2702A0B38];
  id v4 = objc_msgSend(v2, "numberWithLongLong:", objc_msgSend(v3, "longLongValue"));
  [*(id *)(a1 + 32) setSetUpPINCode:v4];

  uint64_t v5 = (void *)MEMORY[0x2533B64D0]([*(id *)(a1 + 32) setOnboardingSetupPayloadString:*(void *)(a1 + 48)]);
  id v6 = *(id *)(a1 + 32);
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    BOOL v9 = *(void **)(a1 + 40);
    id v10 = [*(id *)(a1 + 32) setUpPINCode];
    uint64_t v11 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138544130;
    uint64_t v22 = v8;
    __int16 v23 = 2112;
    id v24 = v9;
    __int16 v25 = 2112;
    __int16 v26 = v10;
    __int16 v27 = 2112;
    uint64_t v28 = v11;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Move forward with pairing a discovered accessory with password: %@, used PIN code: %@, onboarding setup payload: %@", buf, 0x2Au);
  }
  uint64_t v12 = *(void **)(a1 + 32);
  id v19 = 0;
  id v20 = 0;
  [v12 _startPairingWithError:&v20 pairingEndContext:&v19];
  id v13 = v20;
  id v14 = v19;
  if (v13)
  {
    uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = *(id *)(a1 + 32);
    id v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      id v18 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      uint64_t v22 = v18;
      __int16 v23 = 2112;
      id v24 = v13;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed with error %@", buf, 0x16u);
    }
    [*(id *)(a1 + 32) setPairedState:0];
    [*(id *)(a1 + 32) _handlePairingFailureWithError:v13 context:v14];
  }
}

- (void)setPrimaryAccessory:(id)a3
{
  id v4 = (HAPAccessory *)a3;
  uint64_t v5 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  if (self->_primaryAccessory)
  {
    _HMFPreconditionFailure();
    __break(1u);
  }
  else
  {
    self->_primaryAccessory = v4;
    os_unfair_lock_unlock(v5);
    [(HMMTRAccessoryServer *)self _initAccessoriesForServer];
  }
}

- (void)_initAccessoriesForServer
{
  v5[1] = *MEMORY[0x263EF8340];
  id v3 = [(HMMTRAccessoryServer *)self primaryAccessory];
  v5[0] = v3;
  id v4 = [MEMORY[0x263EFF8C0] arrayWithObjects:v5 count:1];
  [(HAPAccessoryServer *)self setAccessories:v4];
}

- (HAPAccessory)primaryAccessory
{
  id v3 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  id v4 = self->_primaryAccessory;
  os_unfair_lock_unlock(v3);
  return v4;
}

- (BOOL)isPairingInProgress
{
  unint64_t v2 = [(HMMTRAccessoryServer *)self pairingProgress];
  return (v2 < 5) & (6u >> v2);
}

- (void)setPairingProgress:(unint64_t)a3
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v5 = (void *)MEMORY[0x2533B64D0](self, a2);
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    id v8 = HMFGetLogIdentifier();
    int v10 = 138543874;
    uint64_t v11 = v8;
    __int16 v12 = 2048;
    unint64_t v13 = a3;
    __int16 v14 = 2112;
    uint64_t v15 = v6;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Pairing progress updated: %tu for server: %@", (uint8_t *)&v10, 0x20u);
  }
  BOOL v9 = (os_unfair_lock_s *)((char *)v6 + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  v6->_pairingProgress = a3;
  os_unfair_lock_unlock(v9);
}

- (unint64_t)pairingProgress
{
  id v3 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  unint64_t pairingProgress = self->_pairingProgress;
  os_unfair_lock_unlock(v3);
  return pairingProgress;
}

- (BOOL)matchesSetupID:(id)a3 serverIdentifier:(id)a4
{
  unint64_t v6 = (unint64_t)a3;
  unint64_t v7 = (unint64_t)a4;
  if (![(HMMTRAccessoryServer *)self isKnownToSystemCommissioner]
    && v6 | v7
    && [(HMMTRAccessoryServer *)self pairingProgress] != 3)
  {
    if (v6)
    {
      BOOL v10 = [(HMMTRAccessoryServer *)self matchesSetupID:v6];
      if (v7)
      {
LABEL_8:
        uint64_t v11 = [(HAPAccessoryServer *)self identifier];
        char v12 = [v11 isEqualToString:v7];

LABEL_11:
        BOOL v8 = v10 & v12;
        goto LABEL_5;
      }
    }
    else
    {
      BOOL v10 = 1;
      if (v7) {
        goto LABEL_8;
      }
    }
    char v12 = 1;
    goto LABEL_11;
  }
  BOOL v8 = 0;
LABEL_5:

  return v8;
}

- (BOOL)matchesSetupID:(id)a3
{
  id v4 = a3;
  if (![(HMMTRAccessoryServer *)self isDisabled])
  {
    uint64_t v5 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
    os_unfair_lock_lock_with_options();
    unint64_t v6 = [(HMMTRAccessoryServer *)self discriminator];
    if (v6
      && ([(HMMTRAccessoryServer *)self setUpPINCode],
          unint64_t v7 = objc_claimAutoreleasedReturnValue(),
          v7,
          v6,
          v7))
    {
      BOOL v8 = [(HMMTRAccessoryServer *)self setUpPINCode];
      BOOL v9 = [(HMMTRAccessoryServer *)self discriminatorIsOriginatedFromShort];
      if (v9)
      {
        BOOL v10 = NSNumber;
        uint64_t v11 = [(HMMTRAccessoryServer *)self discriminator];
        char v12 = objc_msgSend(v10, "numberWithUnsignedInteger:", (unint64_t)objc_msgSend(v11, "unsignedIntegerValue") >> 8);
      }
      else
      {
        char v12 = [(HMMTRAccessoryServer *)self discriminator];
        uint64_t v11 = v12;
      }
      uint64_t v15 = +[HMMTRUtilities setupIDFromSetupCode:v8 discriminator:v12];
      if (v9) {

      }
      os_unfair_lock_unlock(v5);
      if (v15)
      {
        char v13 = [v15 isEqualToString:v4];

        goto LABEL_8;
      }
    }
    else
    {
      os_unfair_lock_unlock(v5);
    }
  }
  char v13 = 0;
LABEL_8:

  return v13;
}

- (void)_startLocallyDiscoveredAccessoryServerPairingWithRequest:(id)a3 fabricID:(id)a4
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  id v6 = a3;
  id v7 = a4;
  v29[0] = MEMORY[0x263EF8330];
  v29[1] = 3221225472;
  v29[2] = __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke;
  id v29[3] = &unk_265378638;
  void v29[4] = self;
  BOOL v8 = (void *)MEMORY[0x2533B66E0](v29);
  uint64_t v9 = [v6 isOwnerPairing] ^ 1;
  BOOL v10 = [(HMMTRAccessoryServer *)self storage];
  [v10 setSharedAdmin:v9];

  if (([v6 isOwnerPairing] & 1) == 0)
  {
    uint64_t v11 = [v6 chipFabricID];

    id v7 = (id)v11;
  }
  v26[0] = MEMORY[0x263EF8330];
  v26[1] = 3221225472;
  v26[2] = __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_2;
  v26[3] = &unk_265378978;
  v26[4] = self;
  id v12 = v7;
  id v27 = v12;
  id v13 = v8;
  id v28 = v13;
  __int16 v14 = (void *)MEMORY[0x2533B66E0](v26);
  uint64_t v15 = [(HMMTRAccessoryServer *)self browser];
  if (v15)
  {
    v22[0] = MEMORY[0x263EF8330];
    v22[1] = 3221225472;
    v22[2] = __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_285;
    v22[3] = &unk_265377458;
    void v22[4] = self;
    id v23 = v12;
    id v24 = v6;
    id v25 = v14;
    [v15 createMatterOperationalKeyPairIfAbsentWithCompletion:v22];
  }
  else
  {
    uint64_t v16 = (void *)MEMORY[0x2533B64D0]();
    id v17 = self;
    id v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      id v19 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v31 = v19;
      _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_ERROR, "%{public}@No accessory server browser to move on with pairing", buf, 0xCu);
    }
    id v20 = [MEMORY[0x263F087E8] hmfErrorWithCode:11];
    uint64_t v21 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v20];
    [(HMMTRAccessoryServer *)v17 _handlePairingFailureWithError:v20 context:v21];
  }
}

void __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  unint64_t v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    uint64_t v9 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Prompting for setup code for discovered accessory", buf, 0xCu);
  }
  id v6 = [*(id *)(a1 + 32) delegateQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_284;
  block[3] = &unk_265378638;
  void block[4] = *(void *)(a1 + 32);
  dispatch_async(v6, block);
}

void __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_3;
  block[3] = &unk_265377CF8;
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void **)(a1 + 40);
  id v13 = v6;
  uint64_t v14 = v8;
  id v15 = v9;
  id v16 = v5;
  id v17 = *(id *)(a1 + 48);
  id v10 = v5;
  id v11 = v6;
  dispatch_async(v7, block);
}

void __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_285(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_2_286;
  block[3] = &unk_265377CF8;
  uint64_t v5 = *(void *)(a1 + 32);
  id v6 = *(void **)(a1 + 40);
  id v9 = v3;
  uint64_t v10 = v5;
  id v11 = v6;
  id v12 = *(id *)(a1 + 48);
  id v13 = *(id *)(a1 + 56);
  id v7 = v3;
  dispatch_async(v4, block);
}

void __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_2_286(uint64_t a1)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 32))
  {
    unint64_t v2 = (void *)MEMORY[0x2533B64D0]();
    id v3 = *(id *)(a1 + 40);
    id v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      uint64_t v47 = v5;
      _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_ERROR, "%{public}@Failed to create Matter Key Pairs for pairing", buf, 0xCu);
    }
    id v6 = [MEMORY[0x263F087E8] hmfErrorWithCode:11];
    id v7 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v6];
    [*(id *)(a1 + 40) _handlePairingFailureWithError:v6 context:v7];
LABEL_5:

    goto LABEL_6;
  }
  if (isFeatureMatterLocalFabricConfigEnabled())
  {
    uint64_t v8 = *(void **)(a1 + 48);
    if (v8 && ![v8 isEqual:&unk_2702B5988])
    {
      id v9 = [*(id *)(a1 + 40) browser];
      id v6 = [v9 appleHomeFabricWithID:*(void *)(a1 + 48)];
    }
    else
    {
      id v9 = [*(id *)(a1 + 40) browser];
      uint64_t v10 = [*(id *)(a1 + 40) pairingTargetHomeUUID];
      id v6 = [v9 appleHomeFabricWithUUID:v10];
    }
    if (v6)
    {
      int v21 = [*(id *)(a1 + 40) shouldPairWithoutResident] ^ 1;
      uint64_t v22 = [*(id *)(a1 + 40) pairingTargetHomeUUID];

      id v23 = [*(id *)(a1 + 40) browser];
      id v24 = v23;
      if (v22)
      {
        id v25 = [*(id *)(a1 + 40) pairingTargetHomeUUID];
        int v26 = [v24 supportsCommissioningCertificateRetrievalForHomeUUID:v25];
      }
      else
      {
        int v26 = [v23 supportsCommissioningCertificateRetrievalForCurrentlyPairingAccessory];
      }

      uint64_t v34 = [*(id *)(a1 + 56) isOwnerPairing] ^ 1 | v26 & v21;
      v41[0] = MEMORY[0x263EF8330];
      v41[1] = 3221225472;
      v41[2] = __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_287;
      void v41[3] = &unk_265377458;
      id v45 = *(id *)(a1 + 64);
      id v35 = *(id *)(a1 + 48);
      uint64_t v36 = *(void *)(a1 + 40);
      id v42 = v35;
      uint64_t v43 = v36;
      id v44 = v6;
      [v44 loadFabricAndControllerDataForPairing:1 fetchFromResident:v34 completion:v41];

      id v7 = v45;
    }
    else
    {
      id v27 = (void *)MEMORY[0x2533B64D0]();
      id v28 = *(id *)(a1 + 40);
      uint64_t v29 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        BOOL v30 = HMFGetLogIdentifier();
        uint64_t v31 = *(void *)(a1 + 48);
        uint64_t v32 = [*(id *)(a1 + 40) pairingTargetHomeUUID];
        *(_DWORD *)long long buf = 138543874;
        uint64_t v47 = v30;
        __int16 v48 = 2112;
        uint64_t v49 = v31;
        __int16 v50 = 2112;
        uint64_t v51 = v32;
        _os_log_impl(&dword_252495000, v29, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch Fabric object for target fabric ID %@ or Home UUID %@", buf, 0x20u);
      }
      id v7 = [MEMORY[0x263F087E8] hmfErrorWithCode:2];
      long long v33 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v7];
      [*(id *)(a1 + 40) _handlePairingFailureWithError:v7 context:v33];
    }
    goto LABEL_5;
  }
  id v11 = [*(id *)(a1 + 40) pairingTargetHomeUUID];

  id v12 = [*(id *)(a1 + 40) browser];
  id v13 = v12;
  if (v11)
  {
    uint64_t v14 = [*(id *)(a1 + 40) pairingTargetHomeUUID];
    uint64_t v15 = [v13 supportsCommissioningCertificateRetrievalForHomeUUID:v14];
  }
  else
  {
    uint64_t v15 = [v12 supportsCommissioningCertificateRetrievalForCurrentlyPairingAccessory];
  }

  id v16 = [*(id *)(a1 + 40) storage];
  uint64_t v17 = *(void *)(a1 + 48);
  uint64_t v18 = [*(id *)(a1 + 56) isOwnerPairing];
  v37[0] = MEMORY[0x263EF8330];
  v37[1] = 3221225472;
  v37[2] = __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_3_289;
  v37[3] = &unk_265377368;
  id v40 = *(id *)(a1 + 64);
  id v19 = *(id *)(a1 + 48);
  uint64_t v20 = *(void *)(a1 + 40);
  id v38 = v19;
  uint64_t v39 = v20;
  [v16 fetchCertForFabricWithID:v17 isOwner:v18 forPairing:1 forceFetchFromResident:v15 completion:v37];

  id v6 = v40;
LABEL_6:
}

void __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_287(id *a1, uint64_t a2)
{
  if (a2)
  {
    id v3 = (void (*)(void))*((void *)a1[7] + 2);
    v3();
  }
  else
  {
    id v4 = [a1[5] browser];
    uint64_t v5 = [a1[6] fabricID];
    v6[0] = MEMORY[0x263EF8330];
    v6[1] = 3221225472;
    v6[2] = __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_2_288;
    v6[3] = &unk_265378900;
    id v9 = a1[7];
    id v7 = a1[6];
    id v8 = 0;
    [v4 setupStorageStateForHomeFabricID:v5 completion:v6];
  }
}

void __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_3_289(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v3 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
    v3();
  }
  else
  {
    id v4 = [*(id *)(a1 + 40) browser];
    uint64_t v5 = *(void *)(a1 + 32);
    v7[0] = MEMORY[0x263EF8330];
    v7[1] = 3221225472;
    v7[2] = __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_4;
    v7[3] = &unk_2653770A0;
    id v6 = *(id *)(a1 + 48);
    id v8 = 0;
    id v9 = v6;
    [v4 setupStorageStateAfterCertFetchForHomeFabricID:v5 completion:v7];
  }
}

uint64_t __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), a2, *(void *)(a1 + 32));
}

void __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_2_288(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id v3 = [*(id *)(a1 + 32) fabricID];
  (*(void (**)(uint64_t, id, void))(v2 + 16))(v2, v3, *(void *)(a1 + 40));
}

void __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_3(uint64_t a1)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 32))
  {
    uint64_t v2 = getLowestError();
    id v3 = (void *)MEMORY[0x2533B64D0]();
    id v4 = *(id *)(a1 + 40);
    uint64_t v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      id v6 = HMFGetLogIdentifier();
      id v7 = *(void **)(a1 + 48);
      uint64_t v8 = *(void *)(a1 + 32);
      int v36 = 138544130;
      char v37 = v6;
      __int16 v38 = 2112;
      uint64_t v39 = v7;
      __int16 v40 = 2112;
      uint64_t v41 = v8;
      __int16 v42 = 2112;
      uint64_t v43 = v2;
      _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@Failed to fetch certificates required for pairing on fabricID %@ with error %@ and underlying error %@", (uint8_t *)&v36, 0x2Au);
    }
    if ([*(id *)(a1 + 32) isHAPError] && objc_msgSend(*(id *)(a1 + 32), "code") == 36)
    {
      uint64_t v9 = [*(id *)(a1 + 32) copy];
    }
    else
    {
      uint64_t v9 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F41FD8] code:11 userInfo:0];
    }
    uint64_t v10 = (void *)v9;
    id v11 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v2];
    [*(id *)(a1 + 40) _handlePairingFailureWithError:v10 context:v11];

    goto LABEL_25;
  }
  id v12 = [*(id *)(a1 + 40) storage];
  id v13 = [v12 fabricID];
  char v14 = [v13 isEqual:*(void *)(a1 + 56)];

  if (v14)
  {
    uint64_t v15 = *(void **)(a1 + 56);
    id v16 = [*(id *)(a1 + 40) fabricID];
    if ([v15 isEqual:v16])
    {
      uint64_t v17 = [*(id *)(a1 + 40) controllerWrapper];

      if (v17)
      {
LABEL_20:
        long long v33 = [*(id *)(a1 + 40) browser];
        uint64_t v34 = [*(id *)(a1 + 40) fabricID];
        [v33 addFabricWithActiveClientForFabricID:v34];

        (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
        return;
      }
    }
    else
    {
    }
    id v25 = (void *)MEMORY[0x2533B64D0]();
    id v26 = *(id *)(a1 + 40);
    id v27 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
    {
      id v28 = HMFGetLogIdentifier();
      uint64_t v29 = *(void **)(a1 + 56);
      int v36 = 138543618;
      char v37 = v28;
      __int16 v38 = 2112;
      uint64_t v39 = v29;
      _os_log_impl(&dword_252495000, v27, OS_LOG_TYPE_INFO, "%{public}@Pairing accessory requires retrieving controller wrapper with fabric ID: %@", (uint8_t *)&v36, 0x16u);
    }
    BOOL v30 = [*(id *)(a1 + 40) browser];
    uint64_t v31 = [v30 currentHomeFabricDeviceControllerWrapper];
    [*(id *)(a1 + 40) setControllerWrapper:v31];

    uint64_t v32 = [*(id *)(a1 + 40) controllerWrapper];

    if (v32)
    {
      [*(id *)(a1 + 40) setFabricID:*(void *)(a1 + 56)];
      goto LABEL_20;
    }
    uint64_t v18 = (void *)MEMORY[0x2533B64D0]();
    id v19 = *(id *)(a1 + 40);
    uint64_t v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      int v21 = HMFGetLogIdentifier();
      id v35 = *(void **)(a1 + 56);
      int v36 = 138543618;
      char v37 = v21;
      __int16 v38 = 2112;
      uint64_t v39 = v35;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_ERROR, "%{public}@Unable to get controller wrapper for fabric ID: %@", (uint8_t *)&v36, 0x16u);
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v18 = (void *)MEMORY[0x2533B64D0]();
    id v19 = *(id *)(a1 + 40);
    uint64_t v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      int v21 = HMFGetLogIdentifier();
      uint64_t v22 = [*(id *)(a1 + 40) storage];
      id v23 = [v22 fabricID];
      uint64_t v24 = *(void *)(a1 + 56);
      int v36 = 138543874;
      char v37 = v21;
      __int16 v38 = 2112;
      uint64_t v39 = v23;
      __int16 v40 = 2112;
      uint64_t v41 = v24;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_ERROR, "%{public}@Unexpected storage fabric ID %@ after generating cert for fabric ID %@", (uint8_t *)&v36, 0x20u);

LABEL_23:
    }
  }

  uint64_t v2 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F41FD8] code:11 userInfo:0];
  uint64_t v10 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v2];
  [*(id *)(a1 + 40) _handlePairingFailureWithError:v2 context:v10];
LABEL_25:
}

void __90__HMMTRAccessoryServer__startLocallyDiscoveredAccessoryServerPairingWithRequest_fabricID___block_invoke_284(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  [v2 accessoryServer:*(void *)(a1 + 32) promptUserForPasswordWithType:1];
}

- (void)startPairingWithRequest:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  v7[2] = __48__HMMTRAccessoryServer_startPairingWithRequest___block_invoke;
  v7[3] = &unk_265376E98;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __48__HMMTRAccessoryServer_startPairingWithRequest___block_invoke(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    int v21 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Starting pairing", buf, 0xCu);
  }
  [*(id *)(a1 + 32) setOnboardingSetupPayloadString:0];
  [*(id *)(a1 + 32) _setupPairingProperties];
  if ([*(id *)(a1 + 32) locallyDiscovered])
  {
    id v6 = [*(id *)(a1 + 32) setupPayloadString];

    if (!v6)
    {
      if ([*(id *)(a1 + 32) _delegateRespondsToSelector:sel_accessoryServer_promptUserForPasswordWithType_])
      {
        id v8 = [*(id *)(a1 + 40) chipFabricID];
        [*(id *)(a1 + 32) _startLocallyDiscoveredAccessoryServerPairingWithRequest:*(void *)(a1 + 40) fabricID:v8];
        goto LABEL_11;
      }
      char v14 = (void *)MEMORY[0x2533B64D0]();
      id v15 = *(id *)(a1 + 32);
      id v16 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        uint64_t v17 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543362;
        int v21 = v17;
        _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_ERROR, "%{public}@Failed to dispatch setup code prompt request to delegate", buf, 0xCu);
      }
      id v8 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F41FD8] code:11 userInfo:0];
      id v9 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v8];
      goto LABEL_9;
    }
  }
  objc_msgSend(*(id *)(a1 + 32), "setStageNetworkScanRequested:", objc_msgSend(*(id *)(a1 + 40), "doNetworkScan"));
  id v7 = *(void **)(a1 + 32);
  id v18 = 0;
  id v19 = 0;
  [v7 _startPairingWithError:&v19 pairingEndContext:&v18];
  id v8 = v19;
  id v9 = v18;
  if (v8)
  {
    uint64_t v10 = (void *)MEMORY[0x2533B64D0]();
    id v11 = *(id *)(a1 + 32);
    id v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      id v13 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      int v21 = v13;
      __int16 v22 = 2112;
      id v23 = v8;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed with error %@", buf, 0x16u);
    }
LABEL_9:
    [*(id *)(a1 + 32) _handlePairingFailureWithError:v8 context:v9];
  }

LABEL_11:
}

- (void)_setupPairingProperties
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  id v3 = (void *)MEMORY[0x2533B64D0](self, a2);
  id v4 = self;
  uint64_t v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    isFeatureMatteriPhoneOnlyPairingControlEnabled();
    id v7 = HMFBooleanToString();
    id v8 = [(HMMTRAccessoryServer *)v4 pairingTargetFabric];
    id v9 = [(HMMTRAccessoryServer *)v4 pairingTargetFabric];
    uint64_t v10 = [v9 delegate];
    [v10 requiresRemoteFabricDataUpdate];
    id v11 = HMFBooleanToString();
    int v15 = 138544130;
    id v16 = v6;
    __int16 v17 = 2112;
    id v18 = v7;
    __int16 v19 = 2112;
    uint64_t v20 = v8;
    __int16 v21 = 2112;
    __int16 v22 = v11;
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@_setupPairingProperties - iPhoneOnlyPairing: %@, pairingTargetFabric: %@, requiresRemoteFabricDataUpdate: %@", (uint8_t *)&v15, 0x2Au);
  }
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    id v12 = [(HMMTRAccessoryServer *)v4 pairingTargetFabric];
    if (v12)
    {
      id v13 = [(HMMTRAccessoryServer *)v4 pairingTargetFabric];
      char v14 = [v13 delegate];
      -[HMMTRAccessoryServer setShouldPairWithoutResident:](v4, "setShouldPairWithoutResident:", [v14 requiresRemoteFabricDataUpdate] ^ 1);
    }
    else
    {
      [(HMMTRAccessoryServer *)v4 setShouldPairWithoutResident:0];
    }
  }
  else
  {
    [(HMMTRAccessoryServer *)v4 setShouldPairWithoutResident:0];
  }
}

- (void)abortStagingWithError:(id)a3 context:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  id v8 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __54__HMMTRAccessoryServer_abortStagingWithError_context___block_invoke;
  block[3] = &unk_265376F38;
  void block[4] = self;
  id v12 = v6;
  id v13 = v7;
  id v9 = v7;
  id v10 = v6;
  dispatch_async(v8, block);
}

uint64_t __54__HMMTRAccessoryServer_abortStagingWithError_context___block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  id v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = HMFGetLogIdentifier();
    int v9 = 138543362;
    id v10 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Aborting staging", (uint8_t *)&v9, 0xCu);
  }
  id v6 = [*(id *)(a1 + 32) deviceController];
  id v7 = [*(id *)(a1 + 32) nodeID];
  objc_msgSend(v6, "stopDevicePairing:error:", objc_msgSend(v7, "unsignedLongLongValue"), 0);

  return [*(id *)(a1 + 32) _pairingComplete:*(void *)(a1 + 40) context:*(void *)(a1 + 48)];
}

- (BOOL)updateProductAttributes
{
  v82[1] = *MEMORY[0x263EF8340];
  id v4 = [(HMMTRAccessoryServer *)self vendorID];

  if (v4)
  {
    uint64_t v5 = [(HMMTRAccessoryServer *)self browser];
    id v6 = [v5 vendorMetadataStore];
    id v7 = [(HMMTRAccessoryServer *)self vendorID];
    id v8 = [(HMMTRAccessoryServer *)self productID];
    id v4 = [v6 retrieveVendorMetadataForVendorID:v7 productID:v8];

    int v9 = [v4 name];
    [(HMMTRAccessoryServer *)self setVendorNameFromDcl:v9];
  }
  id v10 = [(HMMTRAccessoryServer *)self productID];

  if (v10)
  {
    uint64_t v11 = [(HMMTRAccessoryServer *)self productID];
    id v10 = [v4 productWithID:v11];

    id v12 = [v10 name];
    [(HMMTRAccessoryServer *)self setProductNameFromDcl:v12];

    id v13 = [v10 categoryNumber];

    uint64_t v58 = v4;
    if (v13)
    {
      char v14 = (void *)MEMORY[0x2533B64D0]();
      int v15 = self;
      id v16 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        id v2 = HMFGetLogIdentifier();
        __int16 v17 = [(HAPAccessoryServer *)v15 category];
        id v18 = [v10 categoryNumber];
        *(_DWORD *)long long buf = 138543874;
        long long v60 = v2;
        __int16 v61 = 2112;
        long long v62 = v17;
        __int16 v63 = 2112;
        uint64_t v64 = v18;
        _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_INFO, "%{public}@Updating product category from %@ to %@", buf, 0x20u);
      }
      __int16 v19 = [v10 categoryNumber];
      [(HAPAccessoryServer *)v15 setCategory:v19];

      uint64_t v20 = (void *)MEMORY[0x2533B64D0]();
      __int16 v21 = v15;
      __int16 v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        id v2 = HMFGetLogIdentifier();
        uint64_t v23 = [v21 category];
        *(_DWORD *)long long buf = 138544386;
        long long v60 = v2;
        __int16 v61 = 2114;
        long long v62 = @"stagedPairingAccessoryInfo";
        __int16 v63 = 2112;
        uint64_t v64 = @"Accessory Info";
        __int16 v65 = 2114;
        uint64_t v66 = @"categoryNumber";
        __int16 v67 = 2112;
        uint64_t v68 = v23;
        _os_log_impl(&dword_252495000, v22, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\"", buf, 0x34u);
      }
      uint64_t v24 = [MEMORY[0x263F499E0] sharedInstance];
      id v25 = objc_alloc(MEMORY[0x263F499F0]);
      id v26 = [v21 category];
      if (v26)
      {
        id v81 = @"categoryNumber";
        id v2 = [v21 category];
        v82[0] = v2;
        id v27 = [NSDictionary dictionaryWithObjects:v82 forKeys:&v81 count:1];
      }
      else
      {
        id v27 = (void *)MEMORY[0x263EFFA78];
      }
      uint64_t v29 = (void *)[v25 initWithTag:@"stagedPairingAccessoryInfo" data:v27];
      BOOL v30 = [v21[58] tagProcessorList];
      [v24 submitTaggedEvent:v29 processorList:v30];

      if (v26)
      {
      }
      int v28 = 1;
    }
    else
    {
      int v28 = 0;
    }
    uint64_t v31 = [v10 name];

    if (v31)
    {
      uint64_t v32 = [v10 name];
      long long v33 = +[HMMTRUtilities sanitizeHAPName:v32];

      uint64_t v34 = (void *)MEMORY[0x2533B64D0]();
      id v35 = self;
      int v36 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
      {
        char v37 = HMFGetLogIdentifier();
        __int16 v38 = [(HAPAccessoryServer *)v35 name];
        *(_DWORD *)long long buf = 138543874;
        long long v60 = v37;
        __int16 v61 = 2112;
        long long v62 = v38;
        __int16 v63 = 2112;
        uint64_t v64 = v33;
        _os_log_impl(&dword_252495000, v36, OS_LOG_TYPE_INFO, "%{public}@Updating product name from %@ to %@", buf, 0x20u);
      }
      if (v13)
      {
        int v28 = 1;
      }
      else
      {
        uint64_t v39 = [(HAPAccessoryServer *)v35 name];
        int v28 = [v39 isEqual:v33] ^ 1;
      }
      [(HAPAccessoryServer *)v35 setName:v33];
    }
    __int16 v40 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v41 = self;
    __int16 v42 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
    {
      uint64_t v43 = HMFGetLogIdentifier();
      uint64_t v44 = objc_msgSend(NSNumber, "numberWithInteger:", -[HMMTRAccessoryServer communicationProtocol](v41, "communicationProtocol"));
      id v45 = [(HMMTRAccessoryServer *)v41 vendorID];
      uint64_t v46 = [(HMMTRAccessoryServer *)v41 productID];
      uint64_t v47 = objc_msgSend(NSNumber, "numberWithBool:", -[HMMTRAccessoryServer knownToSystemCommissioner](v41, "knownToSystemCommissioner"));
      *(_DWORD *)long long buf = 138545922;
      long long v60 = v43;
      __int16 v61 = 2114;
      long long v62 = @"stagedPairingAccessoryInfo";
      __int16 v63 = 2112;
      uint64_t v64 = @"Accessory Info";
      __int16 v65 = 2114;
      uint64_t v66 = @"communicationProtocol";
      __int16 v67 = 2112;
      uint64_t v68 = v44;
      __int16 v69 = 2114;
      id v70 = @"vendorNumber";
      __int16 v71 = 2112;
      uint64_t v72 = v45;
      __int16 v73 = 2114;
      id v74 = @"productID";
      __int16 v75 = 2112;
      uint64_t v76 = v46;
      __int16 v77 = 2114;
      uint64_t v78 = @"accessoryKnownToSystemCommissioner";
      __int16 v79 = 2112;
      id v80 = v47;
      _os_log_impl(&dword_252495000, v42, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\"", buf, 0x70u);
    }
    __int16 v48 = [MEMORY[0x263F499E0] sharedInstance];
    id v49 = objc_alloc(MEMORY[0x263F499F0]);
    __int16 v50 = objc_msgSend(NSNumber, "numberWithInteger:", -[HMMTRAccessoryServer communicationProtocol](v41, "communicationProtocol"));
    uint64_t v51 = [(HMMTRAccessoryServer *)v41 vendorID];
    uint64_t v52 = [(HMMTRAccessoryServer *)v41 productID];
    char v53 = objc_msgSend(NSNumber, "numberWithBool:", -[HMMTRAccessoryServer knownToSystemCommissioner](v41, "knownToSystemCommissioner"));
    uint64_t v54 = HMDTaggedLoggingCreateDictionary();
    id v55 = objc_msgSend(v49, "initWithTag:data:", @"stagedPairingAccessoryInfo", v54, @"communicationProtocol", v50, @"vendorNumber", v51, @"productID", v52, @"accessoryKnownToSystemCommissioner", v53);
    id v56 = [(HMFActivity *)v41->_activity tagProcessorList];
    [v48 submitTaggedEvent:v55 processorList:v56];

    LOBYTE(v10) = v28 != 0;
    id v4 = v58;
  }

  return (char)v10;
}

- (void)validateAttestationDeviceInfo:(id)a3 error:(id)a4 completion:(id)a5
{
  id v7 = a3;
  id v8 = a5;
  int v9 = [(HAPAccessoryServer *)self clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __71__HMMTRAccessoryServer_validateAttestationDeviceInfo_error_completion___block_invoke;
  block[3] = &unk_265378900;
  void block[4] = self;
  id v13 = v7;
  id v14 = v8;
  id v10 = v8;
  id v11 = v7;
  dispatch_async(v9, block);
}

void __71__HMMTRAccessoryServer_validateAttestationDeviceInfo_error_completion___block_invoke(id *a1)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  id v2 = [a1[4] stageDeviceCredentialHandler];

  if (v2)
  {
    id v3 = objc_alloc(MEMORY[0x263F11018]);
    id v4 = [a1[5] certificateDeclaration];
    uint64_t v5 = [a1[5] dacCertificate];
    id v6 = [a1[5] dacPAICertificate];
    id v7 = (void *)[v3 initWithCertificationDeclaration:v4 deviceAttestationCertificate:v5 productAttestationIntermediateCertificate:v6];

    id v8 = (void *)MEMORY[0x2533B64D0]();
    id v9 = a1[4];
    id v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      id v11 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v17 = v11;
      _os_log_impl(&dword_252495000, v10, OS_LOG_TYPE_INFO, "%{public}@Calling custom device credential validation handler", buf, 0xCu);
    }
    id v12 = [a1[4] stageDeviceCredentialHandler];
    v14[0] = MEMORY[0x263EF8330];
    v14[1] = 3221225472;
    v14[2] = __71__HMMTRAccessoryServer_validateAttestationDeviceInfo_error_completion___block_invoke_281;
    v14[3] = &unk_265378578;
    v14[4] = a1[4];
    id v15 = a1[6];
    ((void (**)(void, void *, void *))v12)[2](v12, v7, v14);
  }
  else
  {
    id v13 = (void (*)(void))*((void *)a1[6] + 2);
    v13();
  }
}

void __71__HMMTRAccessoryServer_validateAttestationDeviceInfo_error_completion___block_invoke_281(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    int v8 = 138543618;
    id v9 = v7;
    __int16 v10 = 2112;
    id v11 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Completed custom device credential validation with error: %@", (uint8_t *)&v8, 0x16u);
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

- (void)updateVidPidWithAttestationDeviceInfo:(id)a3
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  id v4 = a3;
  uint64_t v5 = [(HMMTRAccessoryServer *)self vendorID];
  if (v5
    && (id v6 = (void *)v5,
        [(HMMTRAccessoryServer *)self productID],
        id v7 = objc_claimAutoreleasedReturnValue(),
        v7,
        v6,
        v7))
  {
    int v8 = [(HMMTRAccessoryServer *)self vendorID];
    id v9 = [v4 basicInformationVendorID];
    if ([v8 isEqualToNumber:v9])
    {
      __int16 v10 = [(HMMTRAccessoryServer *)self productID];
      id v11 = [v4 basicInformationProductID];
      char v12 = [v10 isEqualToNumber:v11];

      if (v12) {
        goto LABEL_13;
      }
    }
    else
    {
    }
    id v13 = (void *)MEMORY[0x2533B64D0]();
    __int16 v22 = self;
    id v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      id v16 = HMFGetLogIdentifier();
      __int16 v17 = [(HMMTRAccessoryServer *)v22 vendorID];
      uint64_t v18 = [(HMMTRAccessoryServer *)v22 productID];
      __int16 v19 = [v4 basicInformationVendorID];
      uint64_t v20 = [v4 basicInformationProductID];
      int v25 = 138544642;
      id v26 = v16;
      __int16 v27 = 2112;
      int v28 = v17;
      __int16 v29 = 2112;
      BOOL v30 = v18;
      __int16 v31 = 2112;
      uint64_t v32 = v19;
      __int16 v33 = 2112;
      uint64_t v34 = v20;
      __int16 v35 = 2112;
      int v36 = v22;
      __int16 v21 = "%{public}@Accessory vid/pid (%@/%@) mismatch with deviceAttestation. Using vid/pid from deviceAttestation (%"
            "@/%@) for accessoryServer %@";
      goto LABEL_11;
    }
  }
  else
  {
    id v13 = (void *)MEMORY[0x2533B64D0]();
    id v14 = self;
    id v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      id v16 = HMFGetLogIdentifier();
      __int16 v17 = [(HMMTRAccessoryServer *)v14 vendorID];
      uint64_t v18 = [(HMMTRAccessoryServer *)v14 productID];
      __int16 v19 = [v4 basicInformationVendorID];
      uint64_t v20 = [v4 basicInformationProductID];
      int v25 = 138544642;
      id v26 = v16;
      __int16 v27 = 2112;
      int v28 = v17;
      __int16 v29 = 2112;
      BOOL v30 = v18;
      __int16 v31 = 2112;
      uint64_t v32 = v19;
      __int16 v33 = 2112;
      uint64_t v34 = v20;
      __int16 v35 = 2112;
      int v36 = v14;
      __int16 v21 = "%{public}@Accessory has nil vid/pid (%@/%@). Using vid/pid from deviceAttestation (%@/%@) for accessoryServer %@";
LABEL_11:
      _os_log_impl(&dword_252495000, v15, OS_LOG_TYPE_INFO, v21, (uint8_t *)&v25, 0x3Eu);
    }
  }

  uint64_t v23 = [v4 basicInformationVendorID];
  [(HMMTRAccessoryServer *)self setVendorID:v23];

  uint64_t v24 = [v4 basicInformationProductID];
  [(HMMTRAccessoryServer *)self setProductID:v24];

  [(HMMTRAccessoryServer *)self updateProductAttributes];
LABEL_13:
}

- (void)startStagedPairingWithDeviceCredentialHandler:(id)a3 wifiScanResultsHandler:(id)a4 threadScanResultsHandler:(id)a5 readyToCancelHandler:(id)a6 progressUpdateHandler:(id)a7 scanningNetworks:(BOOL)a8 completion:(id)a9
{
  id v15 = a3;
  id v16 = a4;
  id v17 = a5;
  id v18 = a6;
  id v19 = a7;
  id v20 = a9;
  __int16 v21 = [(HAPAccessoryServer *)self clientQueue];
  v28[0] = MEMORY[0x263EF8330];
  v28[1] = 3221225472;
  v28[2] = __189__HMMTRAccessoryServer_startStagedPairingWithDeviceCredentialHandler_wifiScanResultsHandler_threadScanResultsHandler_readyToCancelHandler_progressUpdateHandler_scanningNetworks_completion___block_invoke;
  v28[3] = &unk_265377078;
  void v28[4] = self;
  id v29 = v15;
  id v30 = v16;
  id v31 = v17;
  BOOL v35 = a8;
  id v32 = v19;
  id v33 = v20;
  id v34 = v18;
  id v22 = v18;
  id v23 = v20;
  id v24 = v19;
  id v25 = v17;
  id v26 = v16;
  id v27 = v15;
  dispatch_async(v21, v28);
}

void __189__HMMTRAccessoryServer_startStagedPairingWithDeviceCredentialHandler_wifiScanResultsHandler_threadScanResultsHandler_readyToCancelHandler_progressUpdateHandler_scanningNetworks_completion___block_invoke(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  [*(id *)(a1 + 32) setPairedState:1];
  [*(id *)(a1 + 32) setStageDeviceCredentialHandler:*(void *)(a1 + 40)];
  [*(id *)(a1 + 32) setStageWiFiScanResultsHandler:*(void *)(a1 + 48)];
  [*(id *)(a1 + 32) setStageThreadScanResultsHandler:*(void *)(a1 + 56)];
  [*(id *)(a1 + 32) setStageProgressUpdateHandler:*(void *)(a1 + 64)];
  [*(id *)(a1 + 32) setStageNetworkScanRequested:*(unsigned __int8 *)(a1 + 88)];
  [*(id *)(a1 + 32) setStageCompletion:*(void *)(a1 + 72)];
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 80);
  id v9 = 0;
  [v2 _startPairingWithReadyToCancelHandler:v3 error:&v9 pairingEndContext:0];
  id v4 = v9;
  if (v4)
  {
    uint64_t v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = *(id *)(a1 + 32);
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v8 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      id v11 = v8;
      __int16 v12 = 2112;
      id v13 = v4;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed with error %@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
    [*(id *)(a1 + 32) setPairedState:0];
    [*(id *)(a1 + 32) setStageWiFiScanResultsHandler:0];
    [*(id *)(a1 + 32) setStageThreadScanResultsHandler:0];
    [*(id *)(a1 + 32) setStageProgressUpdateHandler:0];
    [*(id *)(a1 + 32) setStageNetworkScanRequested:0];
    [*(id *)(a1 + 32) setStageCompletion:0];
  }
}

- (void)startStagedPairingWithCompletion:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  v7[2] = __57__HMMTRAccessoryServer_startStagedPairingWithCompletion___block_invoke;
  v7[3] = &unk_2653770F0;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __57__HMMTRAccessoryServer_startStagedPairingWithCompletion___block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  [*(id *)(a1 + 32) setPairedState:1];
  id v2 = *(void **)(a1 + 32);
  id v12 = 0;
  [v2 _startPairingWithError:&v12 pairingEndContext:0];
  id v3 = v12;
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = *(id *)(a1 + 32);
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v8 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      uint64_t v14 = v8;
      __int16 v15 = 2112;
      id v16 = v4;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_ERROR, "%{public}@CHIP Accessory pairing failed with error %@", buf, 0x16u);
    }
    id v9 = [v4 domain];
    int v10 = [v9 isEqualToString:*MEMORY[0x263F10BB0]];

    if (v10)
    {
      uint64_t v11 = [MEMORY[0x263F087E8] hapErrorWithCode:15];

      id v4 = (void *)v11;
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    [*(id *)(a1 + 32) setPairedState:0];
  }
  else
  {
    [*(id *)(a1 + 32) setStageCompletion:*(void *)(a1 + 40)];
  }
}

- (BOOL)hasNetworkProvisioningFailed:(unsigned int)a3
{
  unsigned int v3 = self->_networkProvisioningFailures | a3;
  if ((~v3 & 3) == 0) {
    v3 |= 4u;
  }
  self->_networkProvisioningFailures = v3;
  return (v3 >> 2) & 1;
}

- (void)timerDidFire:(id)a3
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  id v4 = a3;
  id v5 = [(HMMTRAccessoryServer *)self pairingTimer];

  if (v5 == v4)
  {
    __int16 v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = self;
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      id v18 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543874;
      __int16 v42 = v18;
      __int16 v43 = 2112;
      uint64_t v44 = v16;
      __int16 v45 = 1024;
      int v46 = 180;
      _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@Pairing Timeout: Accessory Server: %@ was not paired in over %d seconds. Cancelling pairing...", buf, 0x1Cu);
    }
    id v19 = [(HMMTRAccessoryServer *)v16 deviceController];
    id v20 = [(HMMTRAccessoryServer *)v16 nodeID];
    [v19 cancelCommissioningForNodeID:v20 error:0];

    __int16 v21 = [MEMORY[0x263F087E8] hapErrorWithCode:24];
    id v22 = [MEMORY[0x263F087E8] hapErrorWithCode:15 description:@"Failed to pair Matter Accessory in time" reason:0 suggestion:0 underlyingError:v21];
    id v23 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithCancelledError:v21];
    [(HMMTRAccessoryServer *)v16 _pairingComplete:v22 context:v23];
  }
  else
  {
    id v6 = [(HMMTRAccessoryServer *)self residentReachabilityUpdateWaitTimer];

    if (v6 == v4)
    {
      id v24 = (void *)MEMORY[0x2533B64D0]();
      id v25 = self;
      id v26 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
      {
        id v27 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543362;
        __int16 v42 = v27;
        _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_INFO, "%{public}@Waited long enough for resident to update reachability", buf, 0xCu);
      }
      [(HMMTRAccessoryServer *)v25 setResidentReachabilityUpdateWaitTimer:0];
    }
    else
    {
      id v7 = [(HMMTRAccessoryServer *)self stateCaptureConfigChangeTimer];

      if (v7 == v4)
      {
        int v28 = (void *)MEMORY[0x2533B64D0]();
        int v10 = self;
        id v29 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
        {
          id v30 = HMFGetLogIdentifier();
          *(_DWORD *)long long buf = 138543362;
          __int16 v42 = v30;
          _os_log_impl(&dword_252495000, v29, OS_LOG_TYPE_INFO, "%{public}@State Capture: Timer expired, generate State Capture Information for configuration change", buf, 0xCu);
        }
        [(HMMTRAccessoryServer *)v10 setStateCaptureConfigChangeTimer:0];
        uint64_t v36 = MEMORY[0x263EF8330];
        uint64_t v37 = 3221225472;
        __int16 v38 = __37__HMMTRAccessoryServer_timerDidFire___block_invoke;
        uint64_t v39 = &unk_265377050;
        __int16 v40 = v10;
        id v13 = @"ConfigurationChange";
        uint64_t v14 = &v36;
        goto LABEL_17;
      }
      id v8 = [(HMMTRAccessoryServer *)self stateCaptureDeviceConnectedTimer];

      if (v8 == v4)
      {
        id v9 = (void *)MEMORY[0x2533B64D0]();
        int v10 = self;
        uint64_t v11 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          id v12 = HMFGetLogIdentifier();
          *(_DWORD *)long long buf = 138543362;
          __int16 v42 = v12;
          _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_INFO, "%{public}@State Capture: Timer expired, generate State Capture Information for Device Connected", buf, 0xCu);
        }
        [(HMMTRAccessoryServer *)v10 setStateCaptureDeviceConnectedTimer:0];
        uint64_t v31 = MEMORY[0x263EF8330];
        uint64_t v32 = 3221225472;
        id v33 = __37__HMMTRAccessoryServer_timerDidFire___block_invoke_279;
        id v34 = &unk_265377050;
        BOOL v35 = v10;
        id v13 = @"DeviceConnected";
        uint64_t v14 = &v31;
LABEL_17:
        -[HMMTRAccessoryServer generateStateCaptureInformationForReason:completionHandler:](v10, "generateStateCaptureInformationForReason:completionHandler:", v13, v14, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40);
      }
    }
  }
}

void __37__HMMTRAccessoryServer_timerDidFire___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v10 = HMFGetLogIdentifier();
      uint64_t v11 = *(void *)(a1 + 32);
      int v15 = 138543874;
      id v16 = v10;
      __int16 v17 = 2112;
      uint64_t v18 = v11;
      __int16 v19 = 2112;
      id v20 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@State Capture: completed for server:%@ with Error: %@.", (uint8_t *)&v15, 0x20u);
    }
  }
  else
  {
    id v12 = (void *)[v5 copy];
    [*(id *)(a1 + 32) setPartsListStateCaptureInformation:v12];

    if ([*(id *)(a1 + 32) partsListStateCaptureHandle]) {
      [*(id *)(a1 + 32) _deregisterPartsListStateCaptureHandler];
    }
    id v13 = *(void **)(a1 + 32);
    uint64_t v14 = [v13 partsListStateCaptureInformation];
    objc_msgSend(*(id *)(a1 + 32), "setPartsListStateCaptureHandle:", objc_msgSend(v13, "_registerStateCaptureHandlerWithStateCaptureInformation:", v14));
  }
}

void __37__HMMTRAccessoryServer_timerDidFire___block_invoke_279(uint64_t a1, void *a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v10 = HMFGetLogIdentifier();
      uint64_t v11 = *(void *)(a1 + 32);
      int v15 = 138543874;
      id v16 = v10;
      __int16 v17 = 2112;
      uint64_t v18 = v11;
      __int16 v19 = 2112;
      id v20 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@State Capture: completed for server:%@ with Error: %@.", (uint8_t *)&v15, 0x20u);
    }
  }
  else
  {
    id v12 = (void *)[v5 copy];
    [*(id *)(a1 + 32) setDeviceConnectedStateCaptureInformation:v12];

    if ([*(id *)(a1 + 32) deviceConnectedStateHandle]) {
      [*(id *)(a1 + 32) _deregisterDeviceConnectedStateCaptureHandler];
    }
    id v13 = *(void **)(a1 + 32);
    uint64_t v14 = [v13 deviceConnectedStateCaptureInformation];
    objc_msgSend(*(id *)(a1 + 32), "setDeviceConnectedStateHandle:", objc_msgSend(v13, "_registerStateCaptureHandlerWithStateCaptureInformation:", v14));
  }
}

- (void)queueAccessoryOperation:(id)a3 highPriority:(BOOL)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a5;
  if (isFeatureMatteriPhoneOnlyPairingControlEnabled())
  {
    int v10 = [(HAPAccessoryServer *)self clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke;
    block[3] = &unk_265377000;
    void block[4] = self;
    id v21 = v9;
    id v22 = v8;
    BOOL v23 = a4;
    id v11 = v9;
    id v12 = v8;
    dispatch_async(v10, block);

    id v13 = v21;
  }
  else
  {
    uint64_t v14 = [(HAPAccessoryServer *)self clientQueue];
    v17[0] = MEMORY[0x263EF8330];
    v17[1] = 3221225472;
    v17[2] = __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_268;
    v17[3] = &unk_265377028;
    id v18 = v8;
    id v19 = v9;
    id v15 = v9;
    id v16 = v8;
    dispatch_async(v14, v17);

    id v13 = v18;
  }
}

void __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke(uint64_t a1)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if ([*(id *)(a1 + 32) isDisabled])
  {
    id v2 = (void *)MEMORY[0x2533B64D0]();
    id v3 = *(id *)(a1 + 32);
    id v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v5 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v33 = v5;
      _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled by the time operation is executed", buf, 0xCu);
    }
    uint64_t v6 = *(void *)(a1 + 40);
    id v7 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
    (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v7);
  }
  else
  {
    uint64_t v8 = [*(id *)(a1 + 32) browser];
    if (v8
      && (id v9 = (void *)v8,
          [*(id *)(a1 + 32) browser],
          int v10 = objc_claimAutoreleasedReturnValue(),
          char v11 = objc_opt_respondsToSelector(),
          v10,
          v9,
          (v11 & 1) != 0))
    {
      id v12 = (void *)MEMORY[0x2533B64D0]();
      id v13 = *(id *)(a1 + 32);
      uint64_t v14 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        id v15 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543362;
        id v33 = v15;
        _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_INFO, "%{public}@Connecting to an accessory for an operation", buf, 0xCu);
      }
      id v16 = [*(id *)(a1 + 32) browser];
      uint64_t v17 = *(void *)(a1 + 32);
      uint64_t v18 = *(unsigned __int8 *)(a1 + 56);
      v26[0] = MEMORY[0x263EF8330];
      v26[1] = 3221225472;
      v26[2] = __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_266;
      v26[3] = &unk_265376FD8;
      v26[4] = v17;
      id v27 = *(id *)(a1 + 40);
      id v28 = *(id *)(a1 + 48);
      [v16 connectToAccessoryWhenAllowed:v17 highPriority:v18 completion:v26];

      id v19 = v27;
    }
    else
    {
      id v20 = (void *)MEMORY[0x2533B64D0]();
      id v21 = *(id *)(a1 + 32);
      id v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        BOOL v23 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543362;
        id v33 = v23;
        _os_log_impl(&dword_252495000, v22, OS_LOG_TYPE_INFO, "%{public}@Executing an operation without connecting to the accessory", buf, 0xCu);
      }
      id v24 = [*(id *)(a1 + 32) clientQueue];
      block[0] = MEMORY[0x263EF8330];
      block[1] = 3221225472;
      block[2] = __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_265;
      block[3] = &unk_265376F88;
      id v25 = *(void **)(a1 + 40);
      void block[4] = *(void *)(a1 + 32);
      id v30 = v25;
      id v31 = *(id *)(a1 + 48);
      dispatch_async(v24, block);

      id v19 = v30;
    }
  }
}

uint64_t __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_268(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  id v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
  return v2();
}

void __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_265(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if ([*(id *)(a1 + 32) isDisabled])
  {
    id v2 = (void *)MEMORY[0x2533B64D0]();
    id v3 = *(id *)(a1 + 32);
    id v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v5 = HMFGetLogIdentifier();
      int v9 = 138543362;
      int v10 = v5;
      _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled by the time operation is executed", (uint8_t *)&v9, 0xCu);
    }
    uint64_t v6 = *(void *)(a1 + 40);
    id v7 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
    (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v7);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    uint64_t v8 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v8();
  }
}

void __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_266(id *a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x2533B64D0]();
  id v5 = a1[4];
  uint64_t v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543618;
    uint64_t v17 = v7;
    __int16 v18 = 2112;
    id v19 = v3;
    _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Connected to an accessory for an operation with error: %@", buf, 0x16u);
  }
  uint64_t v8 = [a1[4] clientQueue];
  v11[0] = MEMORY[0x263EF8330];
  v11[1] = 3221225472;
  v11[2] = __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_267;
  v11[3] = &unk_265376FB0;
  id v12 = v3;
  id v9 = a1[5];
  id v13 = a1[4];
  id v14 = v9;
  id v15 = a1[6];
  id v10 = v3;
  dispatch_async(v8, v11);
}

void __72__HMMTRAccessoryServer_queueAccessoryOperation_highPriority_completion___block_invoke_267(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 32))
  {
    id v2 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
LABEL_8:
    v2();
    return;
  }
  if (![*(id *)(a1 + 40) isDisabled])
  {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    id v2 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
    goto LABEL_8;
  }
  id v3 = (void *)MEMORY[0x2533B64D0]();
  id v4 = *(id *)(a1 + 40);
  id v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    uint64_t v6 = HMFGetLogIdentifier();
    int v9 = 138543362;
    id v10 = v6;
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_ERROR, "%{public}@Accessory server disabled by the time operation is executed", (uint8_t *)&v9, 0xCu);
  }
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = [MEMORY[0x263F087E8] hapErrorWithCode:1];
  (*(void (**)(uint64_t, void *))(v7 + 16))(v7, v8);
}

- (void)_findSystemCommissionerPairingMatchingSetupPayload:(id)a3 systemCommissionerPairings:(id)a4 pairingManager:(id)a5
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if ([(HMMTRAccessoryServer *)self _pairingInProgressForMatterSupportFallback])
  {
    if (objc_msgSend(v9, "hmf_isEmpty"))
    {
      uint64_t v11 = (void *)MEMORY[0x2533B64D0]();
      id v12 = self;
      id v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        id v14 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543362;
        uint64_t v36 = v14;
        _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Exhausted all system commissioner pairings to match onboarding setup payload", buf, 0xCu);
      }
      [(HMMTRAccessoryServer *)v12 _retryPairing];
    }
    else
    {
      id v15 = [v9 objectAtIndexedSubscript:0];
      id v16 = objc_msgSend(MEMORY[0x263F088D0], "indexSetWithIndexesInRange:", 1, objc_msgSend(v9, "count") - 1);
      uint64_t v17 = [v9 objectsAtIndexes:v16];

      __int16 v18 = (void *)MEMORY[0x2533B64D0]();
      id v19 = self;
      uint64_t v20 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        id v21 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543618;
        uint64_t v36 = v21;
        __int16 v37 = 2112;
        __int16 v38 = v15;
        _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_DEBUG, "%{public}@Checking %@ for onboarding setup payload match", buf, 0x16u);
      }
      id v22 = [v15 setupPayload];
      int v23 = [v22 isEqualAsOnboarding:v8];

      if (v23)
      {
        id v24 = (void *)MEMORY[0x2533B64D0]();
        id v25 = v19;
        id v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          id v27 = HMFGetLogIdentifier();
          id v28 = [v15 uuid];
          *(_DWORD *)long long buf = 138543618;
          uint64_t v36 = v27;
          __int16 v37 = 2112;
          __int16 v38 = v28;
          _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_INFO, "%{public}@System commissioner pairing %@ matched onboarding payload. Checking whether it is connected.", buf, 0x16u);
        }
        id v29 = [v15 uuid];
        v30[0] = MEMORY[0x263EF8330];
        v30[1] = 3221225472;
        v30[2] = __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke;
        v30[3] = &unk_265378128;
        void v30[4] = v25;
        id v31 = v8;
        id v32 = v17;
        id v33 = v10;
        id v34 = v15;
        [v33 readCommissioningWindowStatusForSystemCommissionerPairingUUID:v29 completionHandler:v30];
      }
      else
      {
        [(HMMTRAccessoryServer *)v19 findSystemCommissionerPairingMatchingSetupPayload:v8 systemCommissionerPairings:v17 pairingManager:v10];
      }
    }
  }
}

void __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if ([*(id *)(a1 + 32) _pairingInProgressForMatterSupportFallback])
  {
    if (v6)
    {
      uint64_t v7 = (void *)MEMORY[0x2533B64D0]();
      id v8 = *(id *)(a1 + 32);
      id v9 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        id v10 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543618;
        id v19 = v10;
        __int16 v20 = 2112;
        id v21 = v6;
        _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to read commissioning window status: %@. Moving on to next.", buf, 0x16u);
      }
      [*(id *)(a1 + 32) findSystemCommissionerPairingMatchingSetupPayload:*(void *)(a1 + 40) systemCommissionerPairings:*(void *)(a1 + 48) pairingManager:*(void *)(a1 + 56)];
    }
    else if ([v5 isEqual:&unk_2702B5988])
    {
      uint64_t v11 = [*(id *)(a1 + 32) clientQueue];
      v16[0] = MEMORY[0x263EF8330];
      v16[1] = 3221225472;
      v16[2] = __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_259;
      v16[3] = &unk_265376E98;
      void v16[4] = *(void *)(a1 + 32);
      id v17 = *(id *)(a1 + 64);
      dispatch_async(v11, v16);
    }
    else
    {
      id v12 = (void *)MEMORY[0x2533B64D0]();
      id v13 = *(id *)(a1 + 32);
      id v14 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        id v15 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543618;
        id v19 = v15;
        __int16 v20 = 2112;
        id v21 = v5;
        _os_log_impl(&dword_252495000, v14, OS_LOG_TYPE_ERROR, "%{public}@System commissioner pairing commissioning window is open (%@). This must not be used as staged accessory for next pairing to avoid disrupting other on-going pairing attempt.", buf, 0x16u);
      }
      [*(id *)(a1 + 32) _retryPairing];
    }
  }
}

void __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_259(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if ([*(id *)(a1 + 32) _pairingInProgressForMatterSupportFallback])
  {
    id v2 = [*(id *)(a1 + 32) browser];
    if (v2)
    {
      id v3 = [*(id *)(a1 + 40) nodeID];
      v15[0] = MEMORY[0x263EF8330];
      v15[1] = 3221225472;
      v15[2] = __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_260;
      v15[3] = &unk_265376F60;
      id v4 = *(void **)(a1 + 40);
      void v15[4] = *(void *)(a1 + 32);
      id v16 = v4;
      [v2 accessoryServerForSystemCommissionerDeviceWithNodeID:v3 completionHandler:v15];
    }
    else
    {
      id v9 = (void *)MEMORY[0x2533B64D0]();
      id v10 = *(id *)(a1 + 32);
      uint64_t v11 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        id v12 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543362;
        __int16 v18 = v12;
        _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_ERROR, "%{public}@No accessory server browser. Aborting attempt to return system commissioner accessory as staged accessory.", buf, 0xCu);
      }
      id v13 = [MEMORY[0x263F087E8] hapErrorWithCode:15];
      id v14 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:2 error:v13];
      [*(id *)(a1 + 32) _handlePairingFailureWithError:v13 context:v14];
    }
  }
  else
  {
    id v5 = (void *)MEMORY[0x2533B64D0]();
    id v6 = *(id *)(a1 + 32);
    uint64_t v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v18 = v8;
      _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Pairing timed out already when matching system commissioner pairing was verified to be connected.", buf, 0xCu);
    }
  }
}

void __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_260(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_2;
  block[3] = &unk_265376F38;
  id v5 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  id v8 = v3;
  id v9 = v5;
  id v6 = v3;
  dispatch_async(v4, block);
}

void __117__HMMTRAccessoryServer__findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke_2(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if ([*(id *)(a1 + 32) _pairingInProgressForMatterSupportFallback])
  {
    uint64_t v2 = *(void *)(a1 + 40);
    id v3 = (void *)MEMORY[0x2533B64D0]();
    id v4 = *(id *)(a1 + 32);
    id v5 = HMFGetOSLogHandle();
    id v6 = v5;
    if (v2)
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        uint64_t v7 = HMFGetLogIdentifier();
        id v8 = *(void **)(a1 + 40);
        int v16 = 138543618;
        id v17 = v7;
        __int16 v18 = 2112;
        uint64_t v19 = v8;
        _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@Returning system commissioner device as staged accessory server: %@", (uint8_t *)&v16, 0x16u);
      }
      [*(id *)(a1 + 32) setPairedState:3];
      id v9 = [*(id *)(a1 + 32) stageCompletion];
      v9[2](v9, 1, *(void *)(a1 + 40), 0);

      [*(id *)(a1 + 32) setStageCompletion:0];
    }
    else
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        id v14 = HMFGetLogIdentifier();
        id v15 = [*(id *)(a1 + 48) uuid];
        int v16 = 138543618;
        id v17 = v14;
        __int16 v18 = 2112;
        uint64_t v19 = v15;
        _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_ERROR, "%{public}@Could not fetch accessory server for system commissioner pairing %@", (uint8_t *)&v16, 0x16u);
      }
      [*(id *)(a1 + 32) _retryPairing];
    }
  }
  else
  {
    id v10 = (void *)MEMORY[0x2533B64D0]();
    id v11 = *(id *)(a1 + 32);
    id v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      id v13 = HMFGetLogIdentifier();
      int v16 = 138543362;
      id v17 = v13;
      _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_INFO, "%{public}@Pairing timed out already when connected staged server was retrieved", (uint8_t *)&v16, 0xCu);
    }
  }
}

- (void)findSystemCommissionerPairingMatchingSetupPayload:(id)a3 systemCommissionerPairings:(id)a4 pairingManager:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  id v11 = [(HAPAccessoryServer *)self clientQueue];
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = __116__HMMTRAccessoryServer_findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke;
  v15[3] = &unk_265376EE8;
  void v15[4] = self;
  id v16 = v8;
  id v17 = v9;
  id v18 = v10;
  id v12 = v10;
  id v13 = v9;
  id v14 = v8;
  dispatch_async(v11, v15);
}

uint64_t __116__HMMTRAccessoryServer_findSystemCommissionerPairingMatchingSetupPayload_systemCommissionerPairings_pairingManager___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _findSystemCommissionerPairingMatchingSetupPayload:*(void *)(a1 + 40) systemCommissionerPairings:*(void *)(a1 + 48) pairingManager:*(void *)(a1 + 56)];
}

- (void)_returnMatterSupportPairingAsStagedPairing
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v3 = [(HMMTRAccessoryServer *)self setupPayloadString];
  if (v3
    && (id v4 = (void *)v3,
        [(HMMTRAccessoryServer *)self setupPayloadString],
        id v5 = objc_claimAutoreleasedReturnValue(),
        int v6 = [v5 isEqual:&stru_2702A0B38],
        v5,
        v4,
        !v6))
  {
    id v13 = (void *)MEMORY[0x263F10FE0];
    id v14 = [(HMMTRAccessoryServer *)self setupPayloadString];
    id v32 = 0;
    id v12 = [v13 setupPayloadWithOnboardingPayload:v14 error:&v32];
    id v11 = v32;

    if (v11)
    {
      id v15 = (void *)MEMORY[0x2533B64D0]();
      id v16 = self;
      id v17 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        id v18 = HMFGetLogIdentifier();
        uint64_t v19 = [(HMMTRAccessoryServer *)v16 setupPayloadString];
        *(_DWORD *)long long buf = 138543874;
        id v34 = v18;
        __int16 v35 = 2112;
        uint64_t v36 = v19;
        __int16 v37 = 2112;
        id v38 = v11;
        _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@Parsing setup payload \"%@\" failed: %@. Failing pairing without looking for matching MatterSupport pairing", buf, 0x20u);
      }
      id v20 = [MEMORY[0x263F087E8] hapErrorWithCode:9];
      id v21 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:2 error:v20];
      [(HMMTRAccessoryServer *)v16 _handlePairingFailureWithError:v20 context:v21];
    }
    else
    {
      uint64_t v22 = [(HMMTRAccessoryServer *)self browser];
      int v23 = [v22 systemCommissionerPairingManager];

      if (v23)
      {
        id v24 = [(HMMTRAccessoryServer *)self storage];
        [v24 endLocalStorageModeBySyncingToRemote:0];

        v29[0] = MEMORY[0x263EF8330];
        v29[1] = 3221225472;
        v29[2] = __66__HMMTRAccessoryServer__returnMatterSupportPairingAsStagedPairing__block_invoke;
        id v29[3] = &unk_265376EC0;
        void v29[4] = self;
        id v30 = v12;
        id v20 = v23;
        id v31 = v20;
        [v20 fetchSystemCommissionerPairingsWithCompletionHandler:v29];
      }
      else
      {
        id v25 = (void *)MEMORY[0x2533B64D0]();
        id v26 = self;
        id v27 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          id v28 = HMFGetLogIdentifier();
          *(_DWORD *)long long buf = 138543362;
          id v34 = v28;
          _os_log_impl(&dword_252495000, v27, OS_LOG_TYPE_ERROR, "%{public}@No system commissioner pairing managager is available. Retrying pairing directly.", buf, 0xCu);
        }
        [(HMMTRAccessoryServer *)v26 _retryPairing];
        id v20 = 0;
      }
    }
  }
  else
  {
    uint64_t v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = self;
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      id v10 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v34 = v10;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_INFO, "%{public}@Pairing without onboarding payload. Hence, failing pairing without looking for matching MatterSupport pairing", buf, 0xCu);
    }
    id v11 = [MEMORY[0x263F087E8] hapErrorWithCode:9];
    id v12 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:2 error:v11];
    [(HMMTRAccessoryServer *)v8 _handlePairingFailureWithError:v11 context:v12];
  }
}

void __66__HMMTRAccessoryServer__returnMatterSupportPairingAsStagedPairing__block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    [*(id *)(a1 + 32) findSystemCommissionerPairingMatchingSetupPayload:*(void *)(a1 + 40) systemCommissionerPairings:v5 pairingManager:*(void *)(a1 + 48)];
  }
  else
  {
    uint64_t v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = HMFGetLogIdentifier();
      int v11 = 138543618;
      id v12 = v10;
      __int16 v13 = 2112;
      id v14 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch system commissioner pairings as fallback for staged pairing: %@", (uint8_t *)&v11, 0x16u);
    }
    [*(id *)(a1 + 32) _retryPairing];
  }
}

- (void)_tryPairingWithOnboardingPayload:(id)a3 systemCommissionerPairings:(id)a4 pairingManager:(id)a5
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if ([(HMMTRAccessoryServer *)self _pairingInProgressForMatterSupportFallback])
  {
    if (objc_msgSend(v9, "hmf_isEmpty"))
    {
      int v11 = (void *)MEMORY[0x2533B64D0]();
      id v12 = self;
      __int16 v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        id v14 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543362;
        __int16 v35 = v14;
        _os_log_impl(&dword_252495000, v13, OS_LOG_TYPE_INFO, "%{public}@Exhausted all system commissioner pairings to pair for onboarding setup payload", buf, 0xCu);
      }
      [(HMMTRAccessoryServer *)v12 _retryPairing];
    }
    else
    {
      uint64_t v15 = [v9 objectAtIndexedSubscript:0];
      id v16 = objc_msgSend(MEMORY[0x263F088D0], "indexSetWithIndexesInRange:", 1, objc_msgSend(v9, "count") - 1);
      id v17 = [v9 objectsAtIndexes:v16];

      id v18 = (void *)MEMORY[0x2533B64D0]();
      uint64_t v19 = self;
      id v20 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        id v21 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543618;
        __int16 v35 = v21;
        __int16 v36 = 2112;
        __int16 v37 = v15;
        _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_DEBUG, "%{public}@Checking %@ for onboarding setup payload match", buf, 0x16u);
      }
      uint64_t v22 = [v15 setupPayload];
      int v23 = [v22 isEqualAsOnboarding:v8];

      if (v23)
      {
        id v24 = (void *)MEMORY[0x2533B64D0]();
        id v25 = v19;
        id v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          id v27 = HMFGetLogIdentifier();
          id v28 = [v15 uuid];
          *(_DWORD *)long long buf = 138543618;
          __int16 v35 = v27;
          __int16 v36 = 2112;
          __int16 v37 = v28;
          _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_INFO, "%{public}@System commissioner pairing %@ matched onboarding payload. Attempting to open commissioning window", buf, 0x16u);
        }
        id v29 = [v15 uuid];
        v30[0] = MEMORY[0x263EF8330];
        v30[1] = 3221225472;
        v30[2] = __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke;
        v30[3] = &unk_265376F10;
        void v30[4] = v25;
        id v31 = v8;
        id v32 = v17;
        id v33 = v10;
        [v33 openCommissioningWindowForSystemCommissionerPairingUUID:v29 duration:v30 completionHandler:180.0];
      }
      else
      {
        [(HMMTRAccessoryServer *)v19 tryPairingWithOnboardingPayload:v8 systemCommissionerPairings:v17 pairingManager:v10];
      }
    }
  }
}

void __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = (void *)MEMORY[0x2533B64D0]();
  id v11 = *(id *)(a1 + 32);
  id v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    __int16 v13 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543618;
    id v27 = v13;
    __int16 v28 = 2112;
    id v29 = v9;
    _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_DEBUG, "%{public}@System commissioner open commissioning window completed with error: %@", buf, 0x16u);
  }
  if ([*(id *)(a1 + 32) _pairingInProgressForMatterSupportFallback])
  {
    if (v9)
    {
      id v14 = (void *)MEMORY[0x2533B64D0]();
      id v15 = *(id *)(a1 + 32);
      id v16 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        id v17 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543618;
        id v27 = v17;
        __int16 v28 = 2112;
        id v29 = v9;
        _os_log_impl(&dword_252495000, v16, OS_LOG_TYPE_ERROR, "%{public}@Failed to open commissioning window using system commissioner pairing: %@", buf, 0x16u);
      }
      [*(id *)(a1 + 32) tryPairingWithOnboardingPayload:*(void *)(a1 + 40) systemCommissionerPairings:*(void *)(a1 + 48) pairingManager:*(void *)(a1 + 56)];
    }
    else
    {
      uint64_t v22 = [*(id *)(a1 + 32) browser];
      int v23 = [*(id *)(a1 + 32) fabricID];
      v24[0] = MEMORY[0x263EF8330];
      v24[1] = 3221225472;
      v24[2] = __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke_256;
      v24[3] = &unk_265376E98;
      void v24[4] = *(void *)(a1 + 32);
      id v25 = v7;
      [v22 setupStorageStateForHomeFabricID:v23 completion:v24];
    }
  }
  else
  {
    id v18 = (void *)MEMORY[0x2533B64D0]();
    id v19 = *(id *)(a1 + 32);
    id v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      id v21 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v27 = v21;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_INFO, "%{public}@Pairing timed out already. Discarding open commissioning window completion.", buf, 0xCu);
    }
  }
}

void __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke_256(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) clientQueue];
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 3221225472;
  void v5[2] = __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke_2;
  v5[3] = &unk_265376E98;
  id v3 = *(id *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 32);
  id v6 = v3;
  uint64_t v7 = v4;
  dispatch_async(v2, v5);
}

void __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke_2(uint64_t a1)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  id v25 = 0;
  id v3 = [MEMORY[0x263F10FE0] setupPayloadWithOnboardingPayload:v2 error:&v25];
  id v4 = v25;
  id v5 = *(void **)(a1 + 40);
  id v6 = [v5 browser];
  [v6 setCommissioneeAccessoryServer:v5];

  uint64_t v7 = (void *)MEMORY[0x2533B64D0]();
  id v8 = *(id *)(a1 + 40);
  id v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    id v10 = HMFGetLogIdentifier();
    id v11 = *(void **)(a1 + 32);
    *(_DWORD *)long long buf = 138543618;
    id v27 = v10;
    __int16 v28 = 2112;
    id v29 = v11;
    _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_INFO, "%{public}@Attempting to pair using new setup code as fallback: %@", buf, 0x16u);
  }
  id v12 = [*(id *)(a1 + 40) deviceController];
  if (v12)
  {
    __int16 v13 = *(void **)(a1 + 40);
    id v14 = [v13 clientQueue];
    [v12 setDeviceControllerDelegate:v13 queue:v14];

    uint64_t v15 = *(void *)(*(void *)(a1 + 40) + 448);
    id v24 = v4;
    [v12 setupCommissioningSessionWithPayload:v3 newNodeID:v15 error:&v24];
    id v16 = v24;
  }
  else
  {
    id v16 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
  }
  id v17 = v16;

  if (v17)
  {
    id v18 = (void *)MEMORY[0x2533B64D0]();
    id v19 = *(id *)(a1 + 40);
    id v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      id v21 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      id v27 = v21;
      __int16 v28 = 2112;
      id v29 = v17;
      _os_log_impl(&dword_252495000, v20, OS_LOG_TYPE_ERROR, "%{public}@Failed to setup commissioning session with MatterSupport ECM: %@", buf, 0x16u);
    }
    uint64_t v22 = [*(id *)(a1 + 40) clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke_257;
    block[3] = &unk_265378638;
    void block[4] = *(void *)(a1 + 40);
    dispatch_async(v22, block);
  }
}

uint64_t __99__HMMTRAccessoryServer__tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke_257(uint64_t a1)
{
  return [*(id *)(a1 + 32) _retryPairing];
}

- (void)tryPairingWithOnboardingPayload:(id)a3 systemCommissionerPairings:(id)a4 pairingManager:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  id v11 = [(HAPAccessoryServer *)self clientQueue];
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 3221225472;
  v15[2] = __98__HMMTRAccessoryServer_tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke;
  v15[3] = &unk_265376EE8;
  void v15[4] = self;
  id v16 = v8;
  id v17 = v9;
  id v18 = v10;
  id v12 = v10;
  id v13 = v9;
  id v14 = v8;
  dispatch_async(v11, v15);
}

uint64_t __98__HMMTRAccessoryServer_tryPairingWithOnboardingPayload_systemCommissionerPairings_pairingManager___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _tryPairingWithOnboardingPayload:*(void *)(a1 + 40) systemCommissionerPairings:*(void *)(a1 + 48) pairingManager:*(void *)(a1 + 56)];
}

- (void)_tryPairingUsingMatterSupport
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v3 = [(HMMTRAccessoryServer *)self setupPayloadString];
  if (v3
    && (id v4 = (void *)v3,
        [(HMMTRAccessoryServer *)self setupPayloadString],
        id v5 = objc_claimAutoreleasedReturnValue(),
        int v6 = [v5 isEqual:&stru_2702A0B38],
        v5,
        v4,
        !v6))
  {
    id v11 = (void *)MEMORY[0x263F10FE0];
    id v12 = [(HMMTRAccessoryServer *)self setupPayloadString];
    id v32 = 0;
    id v13 = [v11 setupPayloadWithOnboardingPayload:v12 error:&v32];
    id v14 = v32;

    if (v14)
    {
      uint64_t v15 = (void *)MEMORY[0x2533B64D0]();
      id v16 = self;
      id v17 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        id v18 = HMFGetLogIdentifier();
        id v19 = [(HMMTRAccessoryServer *)v16 setupPayloadString];
        *(_DWORD *)long long buf = 138543874;
        id v34 = v18;
        __int16 v35 = 2112;
        __int16 v36 = v19;
        __int16 v37 = 2112;
        id v38 = v14;
        _os_log_impl(&dword_252495000, v17, OS_LOG_TYPE_ERROR, "%{public}@Parsing setup payload \"%@\" failed: %@. Failing pairing without trying with MatterSupport", buf, 0x20u);
      }
      id v20 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:2 error:v14];
      id v21 = [MEMORY[0x263F087E8] hapErrorWithCode:9];
      [(HMMTRAccessoryServer *)v16 _handlePairingFailureWithError:v21 context:v20];
    }
    else
    {
      uint64_t v22 = [(HMMTRAccessoryServer *)self browser];
      int v23 = [v22 systemCommissionerPairingManager];

      if (v23)
      {
        id v24 = [(HMMTRAccessoryServer *)self storage];
        [v24 endLocalStorageModeBySyncingToRemote:0];

        [(HMMTRAccessoryServer *)self setPairingUsingMatterSupport:1];
        v29[0] = MEMORY[0x263EF8330];
        v29[1] = 3221225472;
        v29[2] = __53__HMMTRAccessoryServer__tryPairingUsingMatterSupport__block_invoke;
        id v29[3] = &unk_265376EC0;
        void v29[4] = self;
        id v30 = v13;
        id v20 = v23;
        id v31 = v20;
        [v20 fetchSystemCommissionerPairingsWithCompletionHandler:v29];
      }
      else
      {
        id v25 = (void *)MEMORY[0x2533B64D0]();
        id v26 = self;
        id v27 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          __int16 v28 = HMFGetLogIdentifier();
          *(_DWORD *)long long buf = 138543362;
          id v34 = v28;
          _os_log_impl(&dword_252495000, v27, OS_LOG_TYPE_ERROR, "%{public}@No system commissioner pairing managager is available. Retrying pairing directly.", buf, 0xCu);
        }
        [(HMMTRAccessoryServer *)v26 _retryPairing];
        id v20 = 0;
      }
    }
  }
  else
  {
    uint64_t v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = self;
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      id v10 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      id v34 = v10;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_INFO, "%{public}@Nearby accessory pairing flow. Hence, cannot try with MatterSupport. Retrying pairing directly.", buf, 0xCu);
    }
    [(HMMTRAccessoryServer *)v8 _retryPairing];
  }
}

void __53__HMMTRAccessoryServer__tryPairingUsingMatterSupport__block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    [*(id *)(a1 + 32) tryPairingWithOnboardingPayload:*(void *)(a1 + 40) systemCommissionerPairings:v5 pairingManager:*(void *)(a1 + 48)];
  }
  else
  {
    uint64_t v7 = (void *)MEMORY[0x2533B64D0]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543618;
      id v14 = v10;
      __int16 v15 = 2112;
      id v16 = v6;
      _os_log_impl(&dword_252495000, v9, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch system commissioner pairings to try matching setup payload: %@", buf, 0x16u);
    }
    id v11 = [*(id *)(a1 + 32) clientQueue];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = __53__HMMTRAccessoryServer__tryPairingUsingMatterSupport__block_invoke_253;
    block[3] = &unk_265378638;
    void block[4] = *(void *)(a1 + 32);
    dispatch_async(v11, block);
  }
}

uint64_t __53__HMMTRAccessoryServer__tryPairingUsingMatterSupport__block_invoke_253(uint64_t a1)
{
  return [*(id *)(a1 + 32) _retryPairing];
}

- (BOOL)_pairingInProgressForMatterSupportFallback
{
  return [(HMMTRAccessoryServer *)self pairingProgress] != 3
      && [(HMMTRAccessoryServer *)self pairingProgress] != 0;
}

- (void)_retryPairing
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (![(HMMTRAccessoryServer *)self _pairingInProgressForMatterSupportFallback])return; {
  [(HMMTRAccessoryServer *)self _clearCommissioneeInfoAfterPairingCompletion];
  }
  [(HMMTRAccessoryServer *)self setCommissioningFailureOverridingError:0];
  if ([(HMMTRAccessoryServer *)self pairingUsingMatterSupport]) {
    goto LABEL_3;
  }
  [(HMMTRAccessoryServer *)self setPairingUsingMatterSupport:1];
  if ([(HMMTRAccessoryServer *)self isKnownToSystemCommissioner])
  {
    id v14 = [(HMMTRAccessoryServer *)self stageCompletion];

    __int16 v15 = (void *)MEMORY[0x2533B64D0]();
    id v16 = self;
    uint64_t v17 = HMFGetOSLogHandle();
    id v18 = v17;
    if (!v14)
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        id v33 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543362;
        __int16 v36 = v33;
        _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_ERROR, "%{public}@No fallback for failed pairing system commissioner with no staging interface. Will keep retrying with original setup payload.", buf, 0xCu);
      }
LABEL_3:
      [(HMMTRAccessoryServer *)self setPairingUsingMatterSupport:0];
      [(HMMTRAccessoryServer *)self _restoreCommissioneeInfoBeforeNextPairingAttempt];
      uint64_t v3 = [(HMMTRAccessoryServer *)self browser];
      if (v3)
      {
        id v4 = [(HMMTRAccessoryServer *)self _pairingSetupPayload];
        id v5 = (void *)MEMORY[0x2533B64D0]();
        id v6 = self;
        uint64_t v7 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
          id v8 = HMFGetLogIdentifier();
          *(_DWORD *)long long buf = 138543618;
          __int16 v36 = v8;
          __int16 v37 = 2112;
          id v38 = v4;
          _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Retrying pairing with setup payload: %@", buf, 0x16u);
        }
        [v3 setCommissioneeAccessoryServer:v6];
        id v9 = [(HMMTRAccessoryServer *)v6 deviceController];
        if (v9)
        {
          id v10 = [(HAPAccessoryServer *)v6 clientQueue];
          [v9 setDeviceControllerDelegate:v6 queue:v10];

          nodeID = v6->_nodeID;
          id v34 = 0;
          [v9 setupCommissioningSessionWithPayload:v4 newNodeID:nodeID error:&v34];
          id v12 = v34;
          uint64_t v13 = +[HMMTRAccessoryPairingEndContext mtrContextWithStep:2 error:v12];
        }
        else
        {
          id v12 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F10BB0] code:6 userInfo:0];
          uint64_t v13 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:2 error:v12];
        }
        __int16 v28 = (void *)v13;
        if (v12)
        {
          id v29 = (void *)MEMORY[0x2533B64D0]();
          id v30 = v6;
          id v31 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            id v32 = HMFGetLogIdentifier();
            *(_DWORD *)long long buf = 138543618;
            __int16 v36 = v32;
            __int16 v37 = 2112;
            id v38 = v12;
            _os_log_impl(&dword_252495000, v31, OS_LOG_TYPE_ERROR, "%{public}@Failed to setup commissioning session: %@", buf, 0x16u);
          }
          [(HMMTRAccessoryServer *)v30 _pairingComplete:v12 context:v28];
        }
      }
      else
      {
        id v24 = (void *)MEMORY[0x2533B64D0]();
        id v25 = self;
        id v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          id v27 = HMFGetLogIdentifier();
          *(_DWORD *)long long buf = 138543362;
          __int16 v36 = v27;
          _os_log_impl(&dword_252495000, v26, OS_LOG_TYPE_ERROR, "%{public}@Browser is gone. Stopping pairing attempt.", buf, 0xCu);
        }
        id v4 = [MEMORY[0x263F087E8] hapErrorWithCode:15];
        id v12 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:2 error:v4];
        [(HMMTRAccessoryServer *)v25 _handlePairingFailureWithError:v4 context:v12];
      }

      return;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      id v19 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v36 = v19;
      _os_log_impl(&dword_252495000, v18, OS_LOG_TYPE_INFO, "%{public}@Trying to find an existing System Commissioner pairing as a fallback", buf, 0xCu);
    }
    [(HMMTRAccessoryServer *)v16 _returnMatterSupportPairingAsStagedPairing];
  }
  else
  {
    id v20 = (void *)MEMORY[0x2533B64D0]();
    id v21 = self;
    uint64_t v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      int v23 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v36 = v23;
      _os_log_impl(&dword_252495000, v22, OS_LOG_TYPE_INFO, "%{public}@Trying to pair using MatterSupport", buf, 0xCu);
    }
    [(HMMTRAccessoryServer *)v21 _tryPairingUsingMatterSupport];
  }
}

- (void)startPairingMetricWithActivity:(id)a3
{
  id v4 = a3;
  id v5 = [(HAPAccessoryServer *)self clientQueue];
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  v7[2] = __55__HMMTRAccessoryServer_startPairingMetricWithActivity___block_invoke;
  v7[3] = &unk_265376E98;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __55__HMMTRAccessoryServer_startPairingMetricWithActivity___block_invoke(uint64_t a1)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  objc_storeStrong((id *)(*(void *)(a1 + 32) + 464), *(id *)(a1 + 40));
  uint64_t v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    id v33 = v2;
    id v6 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(*(id *)(a1 + 32), "communicationProtocol"));
    uint64_t v7 = [*(id *)(a1 + 32) category];
    id v8 = [*(id *)(a1 + 32) vendorID];
    id v9 = [*(id *)(a1 + 32) productID];
    id v10 = objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(*(id *)(a1 + 32), "discoveredOverBLE"));
    id v11 = objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(*(id *)(a1 + 32), "knownToSystemCommissioner"));
    *(_DWORD *)long long buf = 138546946;
    id v38 = v5;
    __int16 v39 = 2114;
    __int16 v40 = @"stagedPairingAccessoryInfo";
    __int16 v41 = 2112;
    __int16 v42 = @"Accessory Info";
    __int16 v43 = 2114;
    uint64_t v44 = @"communicationProtocol";
    __int16 v45 = 2112;
    int v46 = v6;
    __int16 v47 = 2114;
    __int16 v48 = @"categoryNumber";
    __int16 v49 = 2112;
    __int16 v50 = v7;
    __int16 v51 = 2114;
    uint64_t v52 = @"vendorNumber";
    __int16 v53 = 2112;
    uint64_t v54 = v8;
    __int16 v55 = 2114;
    id v56 = @"productID";
    __int16 v57 = 2112;
    uint64_t v58 = v9;
    __int16 v59 = 2114;
    long long v60 = @"accessoryDiscoveredOverBLE";
    __int16 v61 = 2112;
    long long v62 = v10;
    __int16 v63 = 2114;
    uint64_t v64 = @"accessoryKnownToSystemCommissioner";
    __int16 v65 = 2112;
    uint64_t v66 = v11;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\"", buf, 0x98u);

    uint64_t v2 = v33;
  }

  id v34 = [MEMORY[0x263F499E0] sharedInstance];
  id v12 = objc_alloc(MEMORY[0x263F499F0]);
  id v32 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(*(id *)(a1 + 32), "communicationProtocol"));
  uint64_t v13 = [*(id *)(a1 + 32) category];
  id v14 = [*(id *)(a1 + 32) vendorID];
  __int16 v15 = [*(id *)(a1 + 32) productID];
  id v16 = objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(*(id *)(a1 + 32), "discoveredOverBLE"));
  uint64_t v17 = objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(*(id *)(a1 + 32), "knownToSystemCommissioner"));
  id v18 = HMDTaggedLoggingCreateDictionary();
  id v19 = objc_msgSend(v12, "initWithTag:data:", @"stagedPairingAccessoryInfo", v18, @"communicationProtocol", v32, @"categoryNumber", v13, @"vendorNumber", v14, @"productID", v15, @"accessoryDiscoveredOverBLE", v16, @"accessoryKnownToSystemCommissioner", v17);
  id v20 = [*(id *)(*(void *)(a1 + 32) + 464) tagProcessorList];
  [v34 submitTaggedEvent:v19 processorList:v20];

  id v21 = (void *)MEMORY[0x2533B64D0]();
  id v22 = *(id *)(a1 + 32);
  int v23 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    id v24 = HMFGetLogIdentifier();
    id v25 = [*(id *)(a1 + 32) softwareVersionString];
    *(_DWORD *)long long buf = 138544386;
    id v38 = v24;
    __int16 v39 = 2114;
    __int16 v40 = @"firmwareVersion";
    __int16 v41 = 2112;
    __int16 v42 = @"Firmware version";
    __int16 v43 = 2114;
    uint64_t v44 = @"firmwareVersion";
    __int16 v45 = 2112;
    int v46 = v25;
    _os_log_impl(&dword_252495000, v23, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\"", buf, 0x34u);
  }
  id v26 = [MEMORY[0x263F499E0] sharedInstance];
  id v27 = objc_alloc(MEMORY[0x263F499F0]);
  __int16 v28 = [*(id *)(a1 + 32) softwareVersionString];
  if (v28)
  {
    __int16 v35 = @"firmwareVersion";
    int v23 = [*(id *)(a1 + 32) softwareVersionString];
    __int16 v36 = v23;
    id v29 = [NSDictionary dictionaryWithObjects:&v36 forKeys:&v35 count:1];
  }
  else
  {
    id v29 = (void *)MEMORY[0x263EFFA78];
  }
  id v30 = (void *)[v27 initWithTag:@"firmwareVersion" data:v29];
  id v31 = [*(id *)(*(void *)(a1 + 32) + 464) tagProcessorList];
  [v26 submitTaggedEvent:v30 processorList:v31];

  if (v28)
  {
  }
}

- (void)_startPairingWithReadyToCancelHandler:(id)a3 error:(id *)a4 pairingEndContext:(id *)a5
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  id v8 = (void (**)(id, void *))a3;
  id v9 = [(HMMTRAccessoryServer *)self browser];
  id v10 = [v9 attestationStatus];
  [v10 setAccessoryServer:self];

  id v11 = [(HMMTRAccessoryServer *)self browser];
  [v11 setCommissioneeAccessoryServer:self];

  id v12 = [(HMMTRAccessoryServer *)self deviceController];
  if ([v12 isRunning])
  {
    uint64_t v13 = (HMFActivity *)[objc_alloc(MEMORY[0x263F424F0]) initWithName:@"CHIP Accessory Pairing"];
    activity = self->_activity;
    self->_activity = v13;

    if (![(HMMTRAccessoryServer *)self hasPriorSuccessfulPairing]) {
      [(HMMTRAccessoryServer *)self _prepareThreadCredentials];
    }
    __int16 v15 = [(HAPAccessoryServer *)self clientQueue];
    [v12 setDeviceControllerDelegate:self queue:v15];

    uint64_t v16 = [(HMMTRAccessoryServer *)self _pairingSetupPayload];
    if (v16)
    {
      id v17 = (id)v16;
      [(HMMTRAccessoryServer *)self setCommissioningSessionEstablished:0];
      [(HMMTRAccessoryServer *)self setCommissioningCompleted:0];
      [(HMMTRAccessoryServer *)self setPairingUsingMatterSupport:0];
      [(HMMTRAccessoryServer *)self _notifyDelegateOfPairingStep:2];
      id v18 = (id)[v12 setupCommissioningSessionWithPayload:v17 newNodeID:self->_nodeID error:a4];
      if (*a4)
      {
        if (a5)
        {
          +[HMMTRAccessoryPairingEndContext mtrContextWithStep:error:](HMMTRAccessoryPairingEndContext, "mtrContextWithStep:error:", 2);
          id v18 = (id)objc_claimAutoreleasedReturnValue();
          *a5 = v18;
        }
        id v19 = (void *)MEMORY[0x2533B64D0](v18);
        id v20 = self;
        id v21 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          uint64_t v22 = HMFGetLogIdentifier();
          int v23 = (void *)v22;
          id v24 = (HMMTRAccessoryServer *)*a4;
          if (a5) {
            id v25 = *a5;
          }
          else {
            id v25 = 0;
          }
          *(_DWORD *)long long buf = 138543874;
          uint64_t v43 = v22;
          __int16 v44 = 2112;
          __int16 v45 = v24;
          __int16 v46 = 2112;
          id v47 = v25;
          _os_log_impl(&dword_252495000, v21, OS_LOG_TYPE_ERROR, "%{public}@Error setup commissioning session %@, context %@", buf, 0x20u);
        }
      }
      id v31 = (void *)MEMORY[0x2533B64D0](v18);
      id v32 = self;
      id v33 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
        id v34 = HMFGetLogIdentifier();
        *(_DWORD *)long long buf = 138543618;
        uint64_t v43 = (uint64_t)v34;
        __int16 v44 = 2112;
        __int16 v45 = v32;
        _os_log_impl(&dword_252495000, v33, OS_LOG_TYPE_INFO, "%{public}@Starting pairing for accessory: %@", buf, 0x16u);
      }
      if (isFeatureMatteriPhoneOnlyPairingControlForThreadEnabled())
      {
        __int16 v35 = [(HMMTRAccessoryServer *)v32 browser];
        [v35 enableUnrestrictedOperationsForAccessoryServer:v32];
      }
      [(HMMTRAccessoryServer *)v32 _updateMetrics];
      [(HMMTRAccessoryServer *)v32 setCommissioningFailureOverridingError:0];
      [(HMMTRAccessoryServer *)v32 setPairingProgress:1];
      __int16 v36 = (void *)[objc_alloc(MEMORY[0x263F42658]) initWithTimeInterval:0 options:180.0];
      [(HMMTRAccessoryServer *)v32 setPairingTimer:v36];

      __int16 v37 = [(HAPAccessoryServer *)v32 clientQueue];
      id v38 = [(HMMTRAccessoryServer *)v32 pairingTimer];
      [v38 setDelegateQueue:v37];

      __int16 v39 = [(HMMTRAccessoryServer *)v32 pairingTimer];
      [v39 setDelegate:v32];

      __int16 v40 = [(HMMTRAccessoryServer *)v32 pairingTimer];
      [v40 resume];

      if (v8)
      {
        v41[0] = MEMORY[0x263EF8330];
        v41[1] = 3221225472;
        v41[2] = __86__HMMTRAccessoryServer__startPairingWithReadyToCancelHandler_error_pairingEndContext___block_invoke;
        void v41[3] = &unk_265378638;
        void v41[4] = v32;
        v8[2](v8, v41);
      }
    }
    else
    {
      id v30 = [MEMORY[0x263F087E8] hapErrorWithCode:9];
      *a4 = v30;
      if (a5)
      {
        *a5 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v30];
      }

      id v17 = 0;
    }
LABEL_28:

    goto LABEL_29;
  }
  id v26 = (void *)MEMORY[0x2533B64D0]();
  id v27 = self;
  __int16 v28 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    id v29 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    uint64_t v43 = (uint64_t)v29;
    _os_log_impl(&dword_252495000, v28, OS_LOG_TYPE_ERROR, "%{public}@CHIP Stack is not running", buf, 0xCu);
  }
  if (a4)
  {
    id v17 = [MEMORY[0x263F087E8] hapErrorWithCode:3];
    *a4 = v17;
    if (a5)
    {
      *a5 = +[HMMTRAccessoryPairingEndContext hmmtrContextWithStep:1 error:v17];
    }
    goto LABEL_28;
  }
LABEL_29:
}

uint64_t __86__HMMTRAccessoryServer__startPairingWithReadyToCancelHandler_error_pairingEndContext___block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = (void *)MEMORY[0x2533B64D0]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543362;
    id v10 = v5;
    _os_log_impl(&dword_252495000, v4, OS_LOG_TYPE_INFO, "%{public}@Staging is cancelled", buf, 0xCu);
  }
  id v6 = *(void **)(a1 + 32);
  uint64_t v8 = 0;
  return [v6 stopPairingWithError:&v8];
}

- (void)_startPairingWithError:(id *)a3 pairingEndContext:(id *)a4
{
}

- (void)_updateMetrics
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  id v3 = (void *)MEMORY[0x2533B64D0](self, a2);
  id v4 = self;
  id v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138544386;
    id v17 = v6;
    __int16 v18 = 2114;
    id v19 = @"hmmtrAccessoryPairingStart";
    __int16 v20 = 2112;
    id v21 = @"Pairing start";
    __int16 v22 = 2114;
    int v23 = @"transport";
    __int16 v24 = 2112;
    id v25 = @"unknown";
    _os_log_impl(&dword_252495000, v5, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\"", buf, 0x34u);
  }
  uint64_t v7 = [MEMORY[0x263F499E0] sharedInstance];
  id v8 = objc_alloc(MEMORY[0x263F499F0]);
  id v14 = @"transport";
  __int16 v15 = @"unknown";
  id v9 = [NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
  id v10 = (void *)[v8 initWithTag:@"hmmtrAccessoryPairingStart" data:v9];
  uint64_t v11 = [(HMFActivity *)v4->_activity tagProcessorList];
  [v7 submitTaggedEvent:v10 processorList:v11];

  id v12 = objc_msgSend(NSNumber, "numberWithBool:", -[HMMTRAccessoryServer discoveredOverBLE](v4, "discoveredOverBLE"));
  [(HAPAccessoryServer *)v4 setPairingMetricWithKey:@"hmmtrAccessoryPairingDiscoveredOverBLE" value:v12];

  uint64_t v13 = objc_msgSend(NSNumber, "numberWithBool:", -[HMMTRAccessoryServer knownToSystemCommissioner](v4, "knownToSystemCommissioner"));
  [(HAPAccessoryServer *)v4 setPairingMetricWithKey:@"HMMTRAccessoryPairingKnownToSystemCommissioner" value:v13];
}

- (NSData)rootPublicKey
{
  BOOL v3 = [(HMMTRAccessoryServer *)self isKnownToSystemCommissioner];
  id v4 = [(HMMTRAccessoryServer *)self browser];
  id v5 = v4;
  if (v3) {
    [v4 systemCommissionerFabricRootPublicKey];
  }
  else {
  id v6 = [v4 appleHomeFabricRootPublicKey];
  }

  return (NSData *)v6;
}

- (NSString)softwareVersionString
{
  return self->_softwareVersionString;
}

- (void)notifyMatterFirmwareRevisionNumberCharacteristicChanged
{
  if (self->_softwareVersionNumber)
  {
    objc_initWeak(&location, self);
    dispatch_time_t v3 = dispatch_time(0, 100000000);
    id v4 = [(HAPAccessoryServer *)self clientQueue];
    v5[0] = MEMORY[0x263EF8330];
    v5[1] = 3221225472;
    void v5[2] = __79__HMMTRAccessoryServer_notifyMatterFirmwareRevisionNumberCharacteristicChanged__block_invoke;
    v5[3] = &unk_265376E28;
    objc_copyWeak(&v6, &location);
    dispatch_after(v3, v4, v5);

    objc_destroyWeak(&v6);
    objc_destroyWeak(&location);
  }
}

void __79__HMMTRAccessoryServer_notifyMatterFirmwareRevisionNumberCharacteristicChanged__block_invoke(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = objc_alloc_init(MEMORY[0x263EFF980]);
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  dispatch_time_t v3 = [WeakRetained primaryAccessory];
  id v4 = [v3 services];

  uint64_t v5 = [v4 countByEnumeratingWithState:&v33 objects:v42 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v34;
    while (2)
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v34 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v33 + 1) + 8 * i);
        id v10 = [v9 type];
        int v11 = [v10 isEqualToString:@"0000003E-0000-1000-8000-0026BB765291"];

        if (v11)
        {
          long long v31 = 0u;
          long long v32 = 0u;
          long long v29 = 0u;
          long long v30 = 0u;
          id v12 = [v9 characteristics];
          uint64_t v13 = [v12 countByEnumeratingWithState:&v29 objects:v41 count:16];
          if (v13)
          {
            uint64_t v14 = v13;
            uint64_t v15 = *(void *)v30;
            __int16 v28 = v2;
            while (2)
            {
              for (uint64_t j = 0; j != v14; ++j)
              {
                if (*(void *)v30 != v15) {
                  objc_enumerationMutation(v12);
                }
                id v17 = *(void **)(*((void *)&v29 + 1) + 8 * j);
                __int16 v18 = [v17 type];
                int v19 = [v18 isEqualToString:@"0000026D-0000-1000-8000-0026BB765291"];

                if (v19)
                {
                  __int16 v20 = (void *)[v17 copy];
                  id v21 = [v17 service];
                  [v20 setService:v21];

                  [v20 setValue:WeakRetained[68]];
                  id v2 = v28;
                  __int16 v22 = (void *)MEMORY[0x2533B64D0]([v28 addObject:v20]);
                  int v23 = WeakRetained;
                  __int16 v24 = HMFGetOSLogHandle();
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
                  {
                    id v25 = HMFGetLogIdentifier();
                    uint64_t v26 = WeakRetained[68];
                    *(_DWORD *)long long buf = 138543618;
                    id v38 = v25;
                    __int16 v39 = 2112;
                    uint64_t v40 = v26;
                    _os_log_impl(&dword_252495000, v24, OS_LOG_TYPE_INFO, "%{public}@sending notification for software version = %@", buf, 0x16u);
                  }
                  id v27 = [v23 delegate];
                  [v27 accessoryServer:v23 didUpdateValuesForCharacteristics:v28 stateNumber:0 broadcast:0];

                  goto LABEL_22;
                }
              }
              uint64_t v14 = [v12 countByEnumeratingWithState:&v29 objects:v41 count:16];
              id v2 = v28;
              if (v14) {
                continue;
              }
              break;
            }
          }
LABEL_22:

          goto LABEL_23;
        }
      }
      uint64_t v6 = [v4 countByEnumeratingWithState:&v33 objects:v42 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
LABEL_23:
}

- (void)updateSoftwareVersion:(id)a3
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  id v5 = a3;
  uint64_t v6 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v7 = self;
  id v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    id v9 = HMFGetLogIdentifier();
    id v10 = [(HMMTRAccessoryServer *)v7 softwareVersionNumber];
    *(_DWORD *)long long buf = 138543874;
    __int16 v20 = v9;
    __int16 v21 = 2112;
    __int16 v22 = v10;
    __int16 v23 = 2112;
    id v24 = v5;
    _os_log_impl(&dword_252495000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Updating software version number from from %@ to %@", buf, 0x20u);
  }
  objc_storeStrong((id *)&v7->_softwareVersionNumber, a3);
  int v11 = [(HMMTRAccessoryServer *)v7 storage];
  id v12 = [v11 fabricDataSource];
  uint64_t v13 = [(HMMTRAccessoryServer *)v7 nodeID];
  uint64_t v14 = [v12 storageDataSourceForDeviceWithNodeID:v13];
  uint64_t v15 = [(HMMTRAccessoryServer *)v7 softwareVersionNumber];
  v18[0] = MEMORY[0x263EF8330];
  v18[1] = 3221225472;
  v18[2] = __46__HMMTRAccessoryServer_updateSoftwareVersion___block_invoke;
  v18[3] = &unk_265376E00;
  void v18[4] = v7;
  [v14 updateSoftwareVersionNumber:v15 completion:v18];

  uint64_t v16 = [(HMMTRAccessoryServer *)v7 matterFirmwareUpdateStatus];

  if (v16)
  {
    id v17 = [(HMMTRAccessoryServer *)v7 matterFirmwareUpdateStatus];
    [v17 checkCurrentFirmwareVersionNumber:v5];
  }
}

void __46__HMMTRAccessoryServer_updateSoftwareVersion___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x2533B64D0]();
    id v5 = *(id *)(a1 + 32);
    uint64_t v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = HMFGetLogIdentifier();
      id v8 = [*(id *)(a1 + 32) softwareVersionNumber];
      int v9 = 138543874;
      id v10 = v7;
      __int16 v11 = 2112;
      id v12 = v8;
      __int16 v13 = 2112;
      id v14 = v3;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to update version number in storage to %@ with error: %@", (uint8_t *)&v9, 0x20u);
    }
  }
}

- (NSNumber)softwareVersionNumber
{
  return self->_softwareVersionNumber;
}

- (id)reachabilityChangedReason
{
  return @"Keepalive";
}

- (BOOL)hasPreferredLocalLink
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if ([(HMMTRAccessoryServer *)self isDisabled])
  {
    BOOL v3 = 0;
  }
  else
  {
    id v4 = [(HMMTRAccessoryServer *)self residentReachabilityUpdateWaitTimer];
    BOOL v3 = v4 != 0;
  }
  id v5 = (void *)MEMORY[0x2533B64D0]();
  uint64_t v6 = self;
  uint64_t v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    id v8 = HMFGetLogIdentifier();
    [(HMMTRAccessoryServer *)v6 isDisabled];
    int v9 = HMFBooleanToString();
    id v10 = [(HMMTRAccessoryServer *)v6 residentReachabilityUpdateWaitTimer];
    __int16 v11 = HMFBooleanToString();
    id v12 = HMFBooleanToString();
    int v14 = 138544130;
    uint64_t v15 = v8;
    __int16 v16 = 2112;
    id v17 = v9;
    __int16 v18 = 2112;
    int v19 = v11;
    __int16 v20 = 2112;
    __int16 v21 = v12;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_DEBUG, "%{public}@disabled %@, timer running %@ -> local link preferred: %@", (uint8_t *)&v14, 0x2Au);
  }
  return v3;
}

- (int64_t)communicationProtocol
{
  return 2;
}

- (int64_t)linkType
{
  return 1;
}

- (void)setLinkLayerType:(int64_t)a3
{
  id v5 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  self->_int64_t linkLayerType = a3;
  os_unfair_lock_unlock(v5);
}

- (BOOL)accessoryLinkLayerTypeIsWifiOrEthernet
{
  return (unint64_t)([(HMMTRAccessoryServer *)self linkLayerType] - 1) < 2;
}

- (int64_t)linkLayerType
{
  BOOL v3 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  int64_t linkLayerType = self->_linkLayerType;
  os_unfair_lock_unlock(v3);
  if (!linkLayerType)
  {
    if ([(HAPAccessoryServer *)self isReachable])
    {
      id v5 = [(HMMTRAccessoryServer *)self primaryAccessory];
      int64_t linkLayerType = [(HMMTRAccessoryServer *)self getLinkLayerTypeForAccessory:v5];
      [(HMMTRAccessoryServer *)self setLinkLayerType:linkLayerType];
      [v5 setLinkLayerType:linkLayerType];
    }
    else
    {
      return 0;
    }
  }
  return linkLayerType;
}

- (void)setPairedState:(int64_t)a3
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  id v5 = (void *)MEMORY[0x2533B64D0](self, a2);
  uint64_t v6 = self;
  uint64_t v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)long long buf = 138543874;
    uint64_t v15 = v8;
    __int16 v16 = 2048;
    uint64_t v17 = [(HMMTRAccessoryServer *)v6 pairedState];
    __int16 v18 = 2048;
    int64_t v19 = a3;
    _os_log_impl(&dword_252495000, v7, OS_LOG_TYPE_INFO, "%{public}@Updating paired state from %ld to %ld", buf, 0x20u);
  }
  BOOL v9 = [(HMMTRAccessoryServer *)v6 isStaged];
  id v10 = (os_unfair_lock_s *)((char *)v6 + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  v6->_pairedState = a3;
  os_unfair_lock_unlock(v10);
  __int16 v11 = [(HAPAccessoryServer *)v6 clientQueue];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = __39__HMMTRAccessoryServer_setPairedState___block_invoke;
  block[3] = &unk_265376DD8;
  void block[4] = v6;
  void block[5] = a3;
  BOOL v13 = v9;
  dispatch_async(v11, block);
}

void __39__HMMTRAccessoryServer_setPairedState___block_invoke(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 >= 3)
  {
    if (v2 != 3) {
      goto LABEL_8;
    }
    BOOL v3 = (id *)(a1 + 32);
    uint64_t v4 = 1;
    goto LABEL_7;
  }
  BOOL v3 = (id *)(a1 + 32);
  if (([*(id *)(a1 + 32) isSecuritySessionOpen] & 1) != 0
    || [*v3 locallyDiscovered])
  {
    uint64_t v4 = 0;
LABEL_7:
    [*v3 setHasPairings:v4];
  }
LABEL_8:
  uint64_t v5 = [*(id *)(a1 + 32) isStaged];
  if (*(unsigned __int8 *)(a1 + 48) != v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = [*(id *)(a1 + 32) storage];
    id v8 = [*(id *)(a1 + 32) nodeID];
    [v7 setStaged:v6 forNode:v8];

    BOOL v9 = (void *)MEMORY[0x2533B64D0]();
    id v10 = *(id *)(a1 + 32);
    __int16 v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      id v12 = HMFGetLogIdentifier();
      uint64_t v13 = *(void *)(a1 + 32);
      int v14 = 138543874;
      uint64_t v15 = v12;
      __int16 v16 = 1024;
      int v17 = v6;
      __int16 v18 = 2112;
      uint64_t v19 = v13;
      _os_log_impl(&dword_252495000, v11, OS_LOG_TYPE_DEBUG, "%{public}@Stored Staged State:%d for server:%@", (uint8_t *)&v14, 0x1Cu);
    }
  }
}

- (int64_t)pairedState
{
  BOOL v3 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  int64_t pairedState = self->_pairedState;
  os_unfair_lock_unlock(v3);
  return pairedState;
}

- (BOOL)isPaired
{
  return [(HMMTRAccessoryServer *)self pairedState] == 3;
}

- (BOOL)isStaged
{
  return [(HMMTRAccessoryServer *)self pairedState] == 2;
}

- (HMMTRPairing)currentPairing
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  BOOL v3 = [(HMMTRAccessoryServer *)self currentPairingInfo];

  if (!v3)
  {
    uint64_t v4 = (void *)MEMORY[0x2533B64D0]();
    uint64_t v5 = self;
    uint64_t v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = HMFGetLogIdentifier();
      *(_DWORD *)long long buf = 138543362;
      __int16 v46 = v7;
      _os_log_impl(&dword_252495000, v6, OS_LOG_TYPE_INFO, "%{public}@CurrentPairingInfo is not cached, fetching info from storage", buf, 0xCu);
    }
    id v8 = [(HMMTRAccessoryServer *)v5 storage];
    BOOL v9 = [v8 dataSource];
    id v10 = [(HMMTRAccessoryServer *)v5 fabricID];
    __int16 v11 = [v9 storageDataSourceForFabricWithID:v10];
    id v12 = [(HMMTRAccessoryServer *)v5 nodeID];
    uint64_t v13 = [v11 storageDataSourceForDeviceWithNodeID:v12];
    int v14 = [v13 pairings];

    uint64_t v15 = [v14 objectEnumerator];
    uint64_t v16 = [v15 nextObject];
    if (v16)
    {
      int v17 = (void *)v16;
      do
      {
        __int16 v18 = [v17 nodeID];
        uint64_t v19 = [(HMMTRAccessoryServer *)v5 nodeID];
        if ([v18 isEqual:v19])
        {
          uint64_t v20 = [v17 rootPublicKey];
          __int16 v21 = [(HMMTRAccessoryServer *)v5 rootPublicKey];
          char v22 = [v20 isEqual:v21];

          if (v22)
          {
            __int16 v44 = v14;
            __int16 v42 = [HMMTRPairing alloc];
            uint64_t v43 = [v17 nodeID];
            id v24 = [v17 fabricID];
            uint64_t v25 = [v17 fabricLabel];
            uint64_t v26 = [v17 rootPublicKey];
            id v27 = [v17 vendorID];
            __int16 v28 = [v17 vendorName];
            long long v29 = [(HMMTRPairing *)v42 initWithNodeID:v43 fabricID:v24 fabricLabel:v25 rootPublicKey:v26 vendorID:v27 vendorName:v28];
            [(HMMTRAccessoryServer *)v5 setCurrentPairingInfo:v29];

            long long v30 = (void *)MEMORY[0x2533B64D0]();
            long long v31 = v5;
            long long v32 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
            {
              long long v34 = HMFGetLogIdentifier();
              *(_DWORD *)long long buf = 138543618;
              __int16 v46 = v34;
              __int16 v47 = 2112;
              uint64_t v48 = v17;
              _os_log_impl(&dword_252495000, v32, OS_LOG_TYPE_INFO, "%{public}@Updated currentPairingInfo with pairing from storage: %@", buf, 0x16u);
            }

            int v14 = v44;
            break;
          }
        }
        else
        {
        }
        uint64_t v23 = [v15 nextObject];

        int v17 = (void *)v23;
      }
      while (v23);
    }
  }
  long long v35 = (void *)MEMORY[0x2533B64D0]();
  long long v36 = self;
  __int16 v37 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
  {
    id v38 = HMFGetLogIdentifier();
    __int16 v39 = [(HMMTRAccessoryServer *)v36 currentPairingInfo];
    *(_DWORD *)long long buf = 138543618;
    __int16 v46 = v38;
    __int16 v47 = 2112;
    uint64_t v48 = v39;
    _os_log_impl(&dword_252495000, v37, OS_LOG_TYPE_INFO, "%{public}@Returning current pairing info %@", buf, 0x16u);
  }
  uint64_t v40 = [(HMMTRAccessoryServer *)v36 currentPairingInfo];
  return (HMMTRPairing *)v40;
}

- (void)setRemoveReason:(id)a3 pairingEndContextWhenRemove:(id)a4
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v6 = (NSError *)a3;
  uint64_t v7 = (HMMTRAccessoryPairingEndContext *)a4;
  id v8 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  uint64_t v9 = os_unfair_lock_lock_with_options();
  id v10 = (void *)MEMORY[0x2533B64D0](v9);
  __int16 v11 = self;
  HMFGetOSLogHandle();
  id v12 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    uint64_t v13 = HMFGetLogIdentifier();
    removeReason = v11->_removeReason;
    pairingEndContextWhenRemove = v11->_pairingEndContextWhenRemove;
    int v19 = 138544386;
    uint64_t v20 = v13;
    __int16 v21 = 2112;
    char v22 = removeReason;
    __int16 v23 = 2112;
    id v24 = v6;
    __int16 v25 = 2112;
    uint64_t v26 = pairingEndContextWhenRemove;
    __int16 v27 = 2112;
    __int16 v28 = v7;
    _os_log_impl(&dword_252495000, v12, OS_LOG_TYPE_INFO, "%{public}@Setting removeReason %@ -> %@, context %@ -> %@", (uint8_t *)&v19, 0x34u);
  }
  uint64_t v16 = v11->_removeReason;
  v11->_removeReason = v6;
  int v17 = v6;

  __int16 v18 = v11->_pairingEndContextWhenRemove;
  v11->_pairingEndContextWhenRemove = v7;

  os_unfair_lock_unlock(v8);
}

- (HMMTRAccessoryPairingEndContext)pairingEndContextWhenRemove
{
  BOOL v3 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  uint64_t v4 = self->_pairingEndContextWhenRemove;
  os_unfair_lock_unlock(v3);
  return v4;
}

- (NSError)removeReason
{
  BOOL v3 = (os_unfair_lock_s *)((char *)self + (int)*MEMORY[0x263F35B30]);
  os_unfair_lock_lock_with_options();
  uint64_t v4 = self->_removeReason;
  os_unfair_lock_unlock(v3);
  return v4;
}

- (void)setClusterIDForCharacteristic:(id)a3 endpointID:(id)a4 clusterID:(id)a5
{
  id v14 = a4;
  clusterIDCharacteristicMap = self->_clusterIDCharacteristicMap;
  id v9 = a5;
  id v10 = a3;
  __int16 v11 = [(NSMutableDictionary *)clusterIDCharacteristicMap objectForKeyedSubscript:v14];

  if (!v11)
  {
    id v12 = objc_alloc_init(MEMORY[0x263EFF9A0]);
    [(NSMutableDictionary *)self->_clusterIDCharacteristicMap setObject:v12 forKeyedSubscript:v14];
  }
  uint64_t v13 = [(NSMutableDictionary *)self->_clusterIDCharacteristicMap objectForKeyedSubscript:v14];
  [v13 setValue:v9 forKey:v10];
}

- (NSMutableDictionary)clusterIDCharacteristicMap
{
  return self->_clusterIDCharacteristicMap;
}

- (id)deviceID
{
  id v3 = objc_alloc(MEMORY[0x263F359A0]);
  uint64_t v4 = [(HAPAccessoryServer *)self identifier];
  uint64_t v5 = (void *)[v3 initWithDeviceIDString:v4];

  return v5;
}

- (void)_updateDefaultEntriesForBridgedClusterIDCharacteristicMap:(id)a3
{
  id v4 = a3;
  uint64_t v5 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000023-0000-1000-8000-0026BB765291"];
  uint64_t v6 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 40);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v5 endpointID:v4 clusterID:v6];

  uint64_t v7 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000021-0000-1000-8000-0026BB765291"];
  id v8 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 40);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v7 endpointID:v4 clusterID:v8];

  id v9 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000020-0000-1000-8000-0026BB765291"];
  id v10 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 40);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v9 endpointID:v4 clusterID:v10];

  id v12 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000030-0000-1000-8000-0026BB765291"];
  __int16 v11 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 40);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v12 endpointID:v4 clusterID:v11];
}

- (void)_updateDefaultEntriesForClusterIDCharacteristicMap:(id)a3
{
  id v4 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000023-0000-1000-8000-0026BB765291"];
  uint64_t v5 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 40);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v4 endpointID:&unk_2702B5988 clusterID:v5];

  uint64_t v6 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000021-0000-1000-8000-0026BB765291"];
  uint64_t v7 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 40);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v6 endpointID:&unk_2702B5988 clusterID:v7];

  id v8 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000020-0000-1000-8000-0026BB765291"];
  id v9 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 40);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v8 endpointID:&unk_2702B5988 clusterID:v9];

  id v10 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000014-0000-1000-8000-0026BB765291"];
  __int16 v11 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 3);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v10 endpointID:&unk_2702B5988 clusterID:v11];

  id v12 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000030-0000-1000-8000-0026BB765291"];
  uint64_t v13 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 40);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v12 endpointID:&unk_2702B5988 clusterID:v13];

  id v14 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000052-0000-1000-8000-0026BB765291"];
  uint64_t v15 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 40);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v14 endpointID:&unk_2702B5988 clusterID:v15];

  uint64_t v16 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"0000026D-0000-1000-8000-0026BB765291"];
  int v17 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 40);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v16 endpointID:&unk_2702B5988 clusterID:v17];

  __int16 v18 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000234-0000-1000-8000-0026BB765291"];
  int v19 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 42);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v18 endpointID:&unk_2702B5988 clusterID:v19];

  id v21 = +[HMMTRUtilities hmmtr_shortTypeFromUUID:@"00000235-0000-1000-8000-0026BB765291"];
  uint64_t v20 = objc_msgSend(NSString, "stringWithFormat:", @"%0X", 42);
  [(HMMTRAccessoryServer *)self setClusterIDForCharacteristic:v21 endpointID:&unk_2702B5988 clusterID:v20];
}

- (MTRDeviceController)deviceController
{
  unint64_t v2 = [(HMMTRAccessoryServer *)self controllerWrapper];
  id v3 = [v2 controller];

  return (MTRDeviceController *)v3;
}

- (void)dispatchBlock:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HAPAccessoryServer *)self clientQueue];
  dispatch_async(v5, v4);
}

- (void)dealloc
{
  [(HMMTRAccessoryServer *)self _deregisterStateCaptureHandlers];
  v3.receiver = self;
  v3.super_class = (Class)HMMTRAccessoryServer;
  [(HMMTRAccessoryServer *)&v3 dealloc];
}

- (HMMTRAccessoryServer)initWithKeystore:(id)a3 browser:(id)a4
{
  id v6 = a4;
  v47.receiver = self;
  v47.super_class = (Class)HMMTRAccessoryServer;
  uint64_t v7 = [(HAPAccessoryServer *)&v47 initWithKeystore:a3];
  if (v7)
  {
    uint64_t v8 = [NSNumber numberWithUnsignedInt:arc4random()];
    objectID = v7->_objectID;
    v7->_objectID = (NSNumber *)v8;

    objc_storeWeak((id *)&v7->_browser, v6);
    id v10 = [v6 storage];
    objc_storeWeak((id *)&v7->_storage, v10);

    id WeakRetained = objc_loadWeakRetained((id *)&v7->_storage);
    uint64_t v12 = [WeakRetained fabricID];
    fabricID = v7->_fabricID;
    v7->_fabricID = (NSNumber *)v12;

    int v14 = [v6 isSystemCommissionerMode];
    v7->_knownToSystemCommissioner = v14;
    if (v14)
    {
      uint64_t v15 = [MEMORY[0x263F08C38] UUID];
      commissioningID = v7->_commissioningID;
      v7->_commissioningID = (NSUUID *)v15;
    }
    v7->_int64_t pairedState = 0;
    v7->_unint64_t pairingProgress = 0;
    v7->_storageUpdatePending = 0;
    v7->_removalInProgress = 0;
    v7->_blockInvalidation = 0;
    v7->_locallyDiscovered = 0;
    v7->_discoveredOverBLE = 0;
    v7->_bleScanPending = 0;
    v7->_int64_t linkLayerType = 0;
    v7->_certified = 0;
    v7->_requiresThreadRouter = 0;
    v7->_delayDiscovery = 0;
    v7->_wedDevice = 0;
    supportedLinkLayerTypes = v7->_supportedLinkLayerTypes;
    v7->_supportedLinkLayerTypes = 0;

    v7->_operationDisabled = 0;
    v7->_operationDisabledReason = 0;
    v7->_hasPriorSuccessfulPairing = 0;
    maxMetricDuration = v7->_maxMetricDuration;
    v7->_maxMetricDuration = 0;

    softwareVersionNumber = v7->_softwareVersionNumber;
    v7->_softwareVersionNumber = 0;

    softwareVersionString = v7->_softwareVersionString;
    v7->_softwareVersionString = (NSString *)@"unknown";

    id v21 = objc_alloc_init(MEMORY[0x263EFF9A0]);
    [(HMMTRAccessoryServer *)v7 setPairingDurationDictionary:v21];

    char v22 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x263EFF9A0]);
    clusterIDCharacteristicMap = v7->_clusterIDCharacteristicMap;
    v7->_clusterIDCharacteristicMap = v22;

    id v24 = [[HMMTRHAPEnumerator alloc] initWithClusterIDCharacteristicMap:v7->_clusterIDCharacteristicMap];
    hapEnumerator = v7->_hapEnumerator;
    v7->_hapEnumerator = v24;

    uint64_t v26 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x263EFF9A0]);
    attributeTimers = v7->_attributeTimers;
    v7->_attributeTimers = v26;

    __int16 v28 = objc_alloc_init(HMMTRAttributeReportDistributor);
    reportDistributor = v7->_reportDistributor;
    v7->_reportDistributor = v28;

    commissioneeNetworkCommissioningClusterEndpoint = v7->_commissioneeNetworkCommissioningClusterEndpoint;
    v7->_commissioneeNetworkCommissioningClusterEndpoint = 0;

    commissioneeNetworks = v7->_commissioneeNetworks;
    v7->_commissioneeNetworks = 0;

    v7->_commissioneeHasActiveNetworuint64_t k = 0;
    long long v32 = (void *)[objc_alloc(MEMORY[0x263F35A60]) initWithValue:1];
    long long v33 = (void *)[objc_alloc(MEMORY[0x263F359E0]) initWithOTAProviderState:v32 downloadedFirmwareVersionNumber:0 accessoryDownloadProgressPercent:0];
    long long v34 = [[HMMTRFirmwareUpdateStatus alloc] initWithFirmwareUpdateStatus:v33 accessoryServer:v7 browser:v6];
    matterFirmwareUpdateStatus = v7->_matterFirmwareUpdateStatus;
    v7->_matterFirmwareUpdateStatus = v34;

    long long v36 = [MEMORY[0x263F08A00] defaultCenter];
    [v36 addObserver:v7 selector:sel_handleThreadNetworkStateChangedNotification_ name:@"HMMTRThreadRadioStateChangedNotification" object:0];

    v7->_deferStartThreadForPairing = 0;
    __int16 v37 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x263EFF9A0]);
    characteristicProtocolMappingStates = v7->_characteristicProtocolMappingStates;
    v7->_characteristicProtocolMappingStates = v37;

    [(HMMTRAccessoryServer *)v7 _updateDefaultEntriesForClusterIDCharacteristicMap:v7->_clusterIDCharacteristicMap];
    deviceConnectedStateCaptureInformation = v7->_deviceConnectedStateCaptureInformation;
    v7->_deviceConnectedStateCaptureInformation = 0;

    partsListStateCaptureInformation = v7->_partsListStateCaptureInformation;
    v7->_partsListStateCaptureInformation = 0;

    id descriptorClusterManager = v7->_descriptorClusterManager;
    v7->_id descriptorClusterManager = &__block_literal_global_8964;

    uint64_t v42 = [MEMORY[0x263EFF980] array];
    serviceEnumerationFromDeviceCompletionHandlers = v7->_serviceEnumerationFromDeviceCompletionHandlers;
    v7->_serviceEnumerationFromDeviceCompletionHandlers = (NSMutableArray *)v42;

    uint64_t v44 = [MEMORY[0x263EFF9A0] dictionary];
    pendingMTRDeviceReadReadyHandlers = v7->_pendingMTRDeviceReadReadyHandlers;
    v7->_pendingMTRDeviceReadReadyHandlers = (NSMutableDictionary *)v44;
  }
  return v7;
}

id __49__HMMTRAccessoryServer_initWithKeystore_browser___block_invoke()
{
  return +[HMMTRDescriptorClusterManager sharedManager];
}

+ (id)shortDescription
{
  unint64_t v2 = (objc_class *)objc_opt_class();
  return NSStringFromClass(v2);
}

+ (id)logCategory
{
  if (logCategory__hmf_once_t602 != -1) {
    dispatch_once(&logCategory__hmf_once_t602, &__block_literal_global_922);
  }
  unint64_t v2 = (void *)logCategory__hmf_once_v603;
  return v2;
}

uint64_t __35__HMMTRAccessoryServer_logCategory__block_invoke()
{
  uint64_t v0 = HMFCreateOSLogHandle();
  uint64_t v1 = logCategory__hmf_once_v603;
  logCategory__hmf_once_v603 = v0;
  return MEMORY[0x270F9A758](v0, v1);
}

+ (BOOL)certificateSubjectHasCATs:(id)a3
{
  objc_super v3 = [MEMORY[0x263F10CC0] convertX509Certificate:a3];
  id v4 = (void *)[objc_alloc(MEMORY[0x263F10CB8]) initWithTLVBytes:v3];
  uint64_t v5 = [v4 subject];
  id v6 = [v5 caseAuthenticatedTags];
  BOOL v7 = [v6 count] != 0;

  return v7;
}

@end