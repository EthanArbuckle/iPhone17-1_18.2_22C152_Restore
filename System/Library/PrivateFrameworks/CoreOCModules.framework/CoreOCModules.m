id sub_24B6BA6BC(__n128 a1, __n128 a2, __n128 a3, uint64_t a4, const char *a5, uint64_t a6)
{
  void *v6;
  const char *v7;
  uint64_t v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  void *v18;
  const char *v19;
  uint64_t v20;
  void *v21;
  const char *v22;
  uint64_t v23;
  void *v24;
  const char *v25;
  uint64_t v26;
  void *v27;
  const char *v28;
  uint64_t v29;
  void *v30;
  const char *v31;
  void *v32;
  float v34;
  float v35;
  void v38[10];
  uint64_t vars8;

  v35 = a1.n128_f32[2];
  v38[9] = *MEMORY[0x263EF8340];
  v6 = objc_msgSend_numberWithDouble_(NSNumber, a5, a6, a1.n128_f32[0], a1.n128_u64[0]);
  v38[0] = v6;
  v9 = objc_msgSend_numberWithDouble_(NSNumber, v7, v8, a2.n128_f32[0]);
  v38[1] = v9;
  v12 = objc_msgSend_numberWithDouble_(NSNumber, v10, v11, a3.n128_f32[0]);
  v38[2] = v12;
  v15 = objc_msgSend_numberWithDouble_(NSNumber, v13, v14, v34);
  v38[3] = v15;
  v18 = objc_msgSend_numberWithDouble_(NSNumber, v16, v17, a2.n128_f32[1]);
  v38[4] = v18;
  v21 = objc_msgSend_numberWithDouble_(NSNumber, v19, v20, a3.n128_f32[1]);
  v38[5] = v21;
  v24 = objc_msgSend_numberWithDouble_(NSNumber, v22, v23, v35);
  v38[6] = v24;
  v27 = objc_msgSend_numberWithDouble_(NSNumber, v25, v26, a2.n128_f32[2]);
  v38[7] = v27;
  v30 = objc_msgSend_numberWithDouble_(NSNumber, v28, v29, a3.n128_f32[2]);
  v38[8] = v30;
  v32 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x263EFF8C0], v31, (uint64_t)v38, 9);

  return v32;
}

void sub_24B6BA89C(void *a1)
{
  v2 = (const void *)a1[6];
  if (v2) {
    CFRelease(v2);
  }
  v3 = (const void *)a1[7];
  if (v3) {
    CFRelease(v3);
  }
  v4 = (const void *)a1[8];
  if (v4) {
    CFRelease(v4);
  }
  v5 = (const void *)a1[9];
  if (v5)
  {
    CFRelease(v5);
  }
}

uint64_t sub_24B6BA904()
{
  qword_2697D0E20 = (uint64_t)os_log_create("com.apple.CoreOCModules", "General");
  return MEMORY[0x270F9A758]();
}

uint64_t sub_24B6BA948(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2)
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v8 = qword_2697D0E20;
    if (!os_log_type_enabled((os_log_t)qword_2697D0E20, OS_LOG_TYPE_ERROR)) {
      return 4294967294;
    }
    *(_WORD *)buf = 0;
    v9 = "HEIC Deserialization: Invalid imageData or imageDataInternal.";
    goto LABEL_216;
  }
  if (!*(void *)a1)
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v8 = qword_2697D0E20;
    if (!os_log_type_enabled((os_log_t)qword_2697D0E20, OS_LOG_TYPE_ERROR)) {
      return 4294967294;
    }
    *(_WORD *)buf = 0;
    v9 = "HEIC Deserialization: Cannot read image field.";
LABEL_216:
    _os_log_error_impl(&dword_24B6B9000, v8, OS_LOG_TYPE_ERROR, v9, buf, 2u);
    return 4294967294;
  }
  *(void *)a2 = *(void *)a1;
  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  v4 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_INFO, "HEIC Deserialization: Read image field.", buf, 2u);
  }

  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(a2 + 16) = v5;
  if (v5)
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v6 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v7 = "HEIC Deserialization: Read depth data map.";
LABEL_25:
      _os_log_impl(&dword_24B6B9000, v6, OS_LOG_TYPE_INFO, v7, buf, 2u);
    }
  }
  else
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v6 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v7 = "HEIC Deserialization: Cannot read depth data map.";
      goto LABEL_25;
    }
  }

  uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a2 + 24) = v11;
  if (v11)
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v12 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v13 = "HEIC Deserialization: Read depth confidence map.";
LABEL_35:
      _os_log_impl(&dword_24B6B9000, v12, OS_LOG_TYPE_INFO, v13, buf, 2u);
    }
  }
  else
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v12 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v13 = "HEIC Deserialization: Cannot read depth confidence map.";
      goto LABEL_35;
    }
  }

  uint64_t v14 = *(void *)(a1 + 24);
  *(void *)(a2 + 32) = v14;
  if (v14)
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v15 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v16 = "HEIC Deserialization: Read object mask.";
LABEL_45:
      _os_log_impl(&dword_24B6B9000, v15, OS_LOG_TYPE_INFO, v16, buf, 2u);
    }
  }
  else
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v15 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v16 = "HEIC Deserialization: Cannot read object mask.";
      goto LABEL_45;
    }
  }

  uint64_t v17 = *(void *)(a1 + 32);
  *(void *)(a2 + 8) = v17;
  if (v17)
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v18 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v19 = "HEIC Deserialization: Read image properties metadata.";
LABEL_55:
      _os_log_impl(&dword_24B6B9000, v18, OS_LOG_TYPE_INFO, v19, buf, 2u);
    }
  }
  else
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v18 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v19 = "Cannot read image properties";
      goto LABEL_55;
    }
  }

  v20 = *(void **)(a1 + 48);
  if (v20)
  {
    id v21 = v20;
    if (objc_msgSend_count(v21, v22, v23) != 9)
    {
      v281 = objc_msgSend_currentHandler(MEMORY[0x263F08690], v24, v25);
      v283 = objc_msgSend_stringWithUTF8String_(NSString, v282, (uint64_t)"simd_float3x3 rowMajorUnflattenToSimdFloat3x3(const CFArrayRef)");
      objc_msgSend_handleFailureInFunction_file_lineNumber_description_(v281, v284, (uint64_t)v283, @"SerializationInternal.m", 30, @"input data needs to have length 9.");
    }
    v26 = objc_msgSend_objectAtIndexedSubscript_(v21, v24, 0);
    objc_msgSend_floatValue(v26, v27, v28);
    unsigned int v326 = v29;
    v31 = objc_msgSend_objectAtIndexedSubscript_(v21, v30, 1);
    objc_msgSend_floatValue(v31, v32, v33);
    unsigned int v319 = v34;
    v36 = objc_msgSend_objectAtIndexedSubscript_(v21, v35, 2);
    objc_msgSend_floatValue(v36, v37, v38);
    unsigned int v313 = v39;

    v41 = objc_msgSend_objectAtIndexedSubscript_(v21, v40, 3);
    objc_msgSend_floatValue(v41, v42, v43);
    unsigned int v304 = v44;
    v46 = objc_msgSend_objectAtIndexedSubscript_(v21, v45, 4);
    objc_msgSend_floatValue(v46, v47, v48);
    unsigned int v301 = v49;
    v51 = objc_msgSend_objectAtIndexedSubscript_(v21, v50, 5);
    objc_msgSend_floatValue(v51, v52, v53);
    unsigned int v298 = v54;

    v56 = objc_msgSend_objectAtIndexedSubscript_(v21, v55, 6);
    objc_msgSend_floatValue(v56, v57, v58);
    int v60 = v59;
    v62 = objc_msgSend_objectAtIndexedSubscript_(v21, v61, 7);
    objc_msgSend_floatValue(v62, v63, v64);
    int v66 = v65;
    v68 = objc_msgSend_objectAtIndexedSubscript_(v21, v67, 8);

    objc_msgSend_floatValue(v68, v69, v70);
    int v72 = v71;

    *(_DWORD *)(a2 + 136) = v60;
    *(void *)(a2 + 128) = __PAIR64__(v304, v326);
    *(_DWORD *)(a2 + 152) = v66;
    *(void *)(a2 + 144) = __PAIR64__(v301, v319);
    *(_DWORD *)(a2 + 168) = v72;
    *(void *)(a2 + 160) = __PAIR64__(v298, v313);
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v73 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v74 = "HEIC Deserialization: Read intrinsics data.";
LABEL_67:
      _os_log_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_INFO, v74, buf, 2u);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 136) = 0;
    *(void *)(a2 + 128) = 0;
    *(_DWORD *)(a2 + 152) = 0;
    *(void *)(a2 + 144) = 0;
    *(_DWORD *)(a2 + 168) = 0;
    *(void *)(a2 + 160) = 0;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v73 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v74 = "HEIC Deserialization: Cannot read camera intrinsics internal metadata.";
      goto LABEL_67;
    }
  }

  v75 = *(void **)(a1 + 56);
  if (v75 && (v76 = *(void **)(a1 + 64)) != 0)
  {
    id v77 = v75;
    id v78 = v76;
    if (objc_msgSend_count(v78, v79, v80) != 9)
    {
      v285 = objc_msgSend_currentHandler(MEMORY[0x263F08690], v81, v82);
      v287 = objc_msgSend_stringWithUTF8String_(NSString, v286, (uint64_t)"simd_float4x4 transformRowMajorUnflattenToSimdFloat4x4(const CFArrayRef, const CFArrayRef)");
      objc_msgSend_handleFailureInFunction_file_lineNumber_description_(v285, v288, (uint64_t)v287, @"SerializationInternal.m", 43, @"rotation needs to have length 9.");
    }
    if (objc_msgSend_count(v77, v81, v82) != 3)
    {
      v289 = objc_msgSend_currentHandler(MEMORY[0x263F08690], v83, v84);
      v291 = objc_msgSend_stringWithUTF8String_(NSString, v290, (uint64_t)"simd_float4x4 transformRowMajorUnflattenToSimdFloat4x4(const CFArrayRef, const CFArrayRef)");
      objc_msgSend_handleFailureInFunction_file_lineNumber_description_(v289, v292, (uint64_t)v291, @"SerializationInternal.m", 44, @"position needs to have length 3.");
    }
    v85 = objc_msgSend_objectAtIndexedSubscript_(v78, v83, 0);
    objc_msgSend_floatValue(v85, v86, v87);
    v325.i64[0] = v88;
    v90 = objc_msgSend_objectAtIndexedSubscript_(v78, v89, 1);
    objc_msgSend_floatValue(v90, v91, v92);
    __int32 v305 = v93;
    v95 = objc_msgSend_objectAtIndexedSubscript_(v78, v94, 2);
    objc_msgSend_floatValue(v95, v96, v97);
    unsigned int v302 = v98;
    v100 = objc_msgSend_objectAtIndexedSubscript_(v77, v99, 0);
    objc_msgSend_floatValue(v100, v101, v102);
    unsigned int v299 = v103;

    v105 = objc_msgSend_objectAtIndexedSubscript_(v78, v104, 3);
    objc_msgSend_floatValue(v105, v106, v107);
    v318.i64[0] = v108;
    v110 = objc_msgSend_objectAtIndexedSubscript_(v78, v109, 4);
    objc_msgSend_floatValue(v110, v111, v112);
    __int32 v297 = v113;
    v115 = objc_msgSend_objectAtIndexedSubscript_(v78, v114, 5);
    objc_msgSend_floatValue(v115, v116, v117);
    unsigned int v296 = v118;
    v120 = objc_msgSend_objectAtIndexedSubscript_(v77, v119, 1);
    objc_msgSend_floatValue(v120, v121, v122);
    unsigned int v295 = v123;

    v125 = objc_msgSend_objectAtIndexedSubscript_(v78, v124, 6);
    objc_msgSend_floatValue(v125, v126, v127);
    v312.i64[0] = v128;
    v130 = objc_msgSend_objectAtIndexedSubscript_(v78, v129, 7);
    objc_msgSend_floatValue(v130, v131, v132);
    __int32 v294 = v133;
    v135 = objc_msgSend_objectAtIndexedSubscript_(v78, v134, 8);

    objc_msgSend_floatValue(v135, v136, v137);
    uint64_t v293 = v138;
    v140 = objc_msgSend_objectAtIndexedSubscript_(v77, v139, 2);
    objc_msgSend_floatValue(v140, v141, v142);
    int32x4_t v143 = v325;
    v143.i32[1] = v305;
    int32x4_t v327 = v143;
    v143.i64[1] = __PAIR64__(v299, v302);
    int32x4_t v306 = v143;
    int32x4_t v144 = v318;
    v144.i32[1] = v297;
    int32x4_t v320 = v144;
    v144.i64[1] = __PAIR64__(v295, v296);
    int32x4_t v303 = v144;
    int32x4_t v145 = v312;
    v145.i32[1] = v294;
    int32x4_t v314 = v145;
    v146.i64[0] = v293;
    v146.i64[1] = __PAIR64__(v147, v293);
    int32x4_t v300 = v146;

    int32x4_t v148 = vzip2q_s32(v306, v300);
    int32x4_t v307 = vzip1q_s32(v327, v314);
    int32x4_t v311 = vzip1q_s32(v320, (int32x4_t)0);
    v320.i64[0] = v148.i64[0];
    int32x4_t v324 = vzip2q_s32(v303, (int32x4_t)xmmword_24B72A590);
    int32x4_t v328 = vzip2q_s32(v148, v324);

    v149 = (float *)(a2 + 48);
    v333.val[0] = (float32x2_t)v307.i64[0];
    v333.val[1] = (float32x2_t)v311.i64[0];
    vst2_f32(v149, v333);
    *(int32x4_t *)(a2 + 64) = vzip2q_s32(v307, v311);
    v150 = (float *)(a2 + 80);
    v333.val[0] = (float32x2_t)v320.i64[0];
    v333.val[1] = (float32x2_t)v324.i64[0];
    vst2_f32(v150, v333);
    *(int32x4_t *)(a2 + 96) = v328;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v151 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v151, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v152 = "HEIC Deserialization: Read camera transform data.";
LABEL_82:
      _os_log_impl(&dword_24B6B9000, v151, OS_LOG_TYPE_INFO, v152, buf, 2u);
    }
  }
  else
  {
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v151 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v151, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v152 = "HEIC Deserialization: Cannot read camera transform internal metadata.";
      goto LABEL_82;
    }
  }

  uint64_t v153 = *(void *)(a1 + 40);
  *(void *)(a2 + 432) = v153;
  if (v153)
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v154 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v154, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v155 = "HEIC Deserialization: Read XMP custom metadata.";
LABEL_92:
      _os_log_impl(&dword_24B6B9000, v154, OS_LOG_TYPE_INFO, v155, buf, 2u);
    }
  }
  else
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v154 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v154, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v155 = "HEIC Deserialization: Cannot read XMP custom metadata.";
      goto LABEL_92;
    }
  }

  id v156 = *(id *)(a1 + 72);
  v158 = objc_msgSend_objectForKeyedSubscript_(v156, v157, @"tag:apple.com,2023:ObjectCapture#CameraTrackingState");

  if (v158)
  {
    v160 = objc_msgSend_objectForKeyedSubscript_(v156, v159, @"tag:apple.com,2023:ObjectCapture#CameraTrackingState");
    objc_msgSend_getBytes_length_(v160, v161, a2 + 112, 4);
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v162 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v162, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v162, OS_LOG_TYPE_INFO, "HEIC Deserialization: Read flattened camera tracking state field.", buf, 2u);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 112) = 0;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v160 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v160, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v160, OS_LOG_TYPE_INFO, "HEIC Deserialization: Cannot read camera tracking state internal metadata.", buf, 2u);
    }
  }

  v164 = objc_msgSend_objectForKeyedSubscript_(v156, v163, @"tag:apple.com,2023:ObjectCapture#CameraCalibrationData");

  if (v164)
  {
    v166 = objc_msgSend_objectForKeyedSubscript_(v156, v165, @"tag:apple.com,2023:ObjectCapture#CameraCalibrationData");
    v167 = (void *)MEMORY[0x263EFFA08];
    uint64_t v168 = objc_opt_class();
    uint64_t v169 = objc_opt_class();
    uint64_t v170 = objc_opt_class();
    uint64_t v171 = objc_opt_class();
    uint64_t v172 = objc_opt_class();
    v174 = objc_msgSend_setWithObjects_(v167, v173, v168, v169, v170, v171, v172, 0);
    objc_msgSend_unarchivedObjectOfClasses_fromData_error_(MEMORY[0x263F08928], v175, (uint64_t)v174, v166, 0);
    id v176 = (id)objc_claimAutoreleasedReturnValue();
    *(void *)(a2 + 176) = v176;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v177 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v177, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v177, OS_LOG_TYPE_INFO, "HEIC Deserialization: Read camera.calibrationData field.", buf, 2u);
    }
  }
  else
  {
    *(void *)(a2 + 176) = 0;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v166 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v166, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v166, OS_LOG_TYPE_INFO, "HEIC Deserialization: Cannot read camera.calibrationData field.", buf, 2u);
    }
  }

  v179 = objc_msgSend_objectForKeyedSubscript_(v156, v178, @"tag:apple.com,2023:ObjectCapture#RawFeaturePoints");

  if (v179)
  {
    v181 = objc_msgSend_objectForKeyedSubscript_(v156, v180, @"tag:apple.com,2023:ObjectCapture#RawFeaturePoints");
    *(void *)(a2 + 384) = v181;

    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v182 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v182, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v183 = "HEIC Deserialization: Read raw feature points field.";
LABEL_122:
      _os_log_impl(&dword_24B6B9000, v182, OS_LOG_TYPE_INFO, v183, buf, 2u);
    }
  }
  else
  {
    *(void *)(a2 + 384) = 0;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v182 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v182, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v183 = "HEIC Deserialization: Cannot read raw feature points field.";
      goto LABEL_122;
    }
  }

  v185 = objc_msgSend_objectForKeyedSubscript_(v156, v184, @"tag:apple.com,2023:ObjectCapture#PointCloudData");

  if (v185)
  {
    v187 = objc_msgSend_objectForKeyedSubscript_(v156, v186, @"tag:apple.com,2023:ObjectCapture#PointCloudData");
    *(void *)(a2 + 40) = OCNonModularSPI_NSData_CreateDepthPointCloudDataBuffer(v187);

    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v188 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v188, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v189 = "HEIC Deserialization: Read point cloud data field.";
LABEL_132:
      _os_log_impl(&dword_24B6B9000, v188, OS_LOG_TYPE_INFO, v189, buf, 2u);
    }
  }
  else
  {
    *(void *)(a2 + 40) = 0;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v188 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v188, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v189 = "HEIC Deserialization: Cannot read LiDAR point cloud internal metadata.";
      goto LABEL_132;
    }
  }

  v192 = objc_msgSend_objectForKeyedSubscript_(v156, v190, @"tag:apple.com,2023:ObjectCapture#ObjectTransform");
  v193 = (int8x16_t *)MEMORY[0x263EF89A8];
  if (v192
    && (objc_msgSend_objectForKeyedSubscript_(v156, v191, @"tag:apple.com,2023:ObjectCapture#ObjectBoundingBox"), v194 = objc_claimAutoreleasedReturnValue(), v194, v192, v194))
  {
    v196 = objc_msgSend_objectForKeyedSubscript_(v156, v195, @"tag:apple.com,2023:ObjectCapture#ObjectTransform");
    int8x16_t v308 = *v193;
    int8x16_t v315 = v193[1];
    int8x16_t v321 = v193[2];
    int8x16_t v329 = v193[3];
    id v197 = v196;
    uint64_t v200 = objc_msgSend_bytes(v197, v198, v199);
    *(void *)&long long v201 = *(void *)v200;
    int8x16_t v309 = vextq_s8(v308, v308, 8uLL);
    HIDWORD(v201) = v309.i32[1];
    DWORD2(v201) = *(_DWORD *)(v200 + 8);
    *(void *)&long long v202 = *(void *)(v200 + 12);
    int8x16_t v316 = vextq_s8(v315, v315, 8uLL);
    HIDWORD(v202) = v316.i32[1];
    DWORD2(v202) = *(_DWORD *)(v200 + 20);
    *(void *)&long long v203 = *(void *)(v200 + 24);
    int8x16_t v322 = vextq_s8(v321, v321, 8uLL);
    HIDWORD(v203) = v322.i32[1];
    DWORD2(v203) = *(_DWORD *)(v200 + 32);
    *(void *)&long long v204 = *(void *)(v200 + 36);
    int8x16_t v330 = vextq_s8(v329, v329, 8uLL);
    HIDWORD(v204) = v330.i32[1];
    DWORD2(v204) = *(_DWORD *)(v200 + 44);
    *(_OWORD *)(a2 + 256) = v201;
    *(_OWORD *)(a2 + 272) = v202;
    *(_OWORD *)(a2 + 288) = v203;
    *(_OWORD *)(a2 + 304) = v204;

    objc_msgSend_objectForKeyedSubscript_(v156, v205, @"tag:apple.com,2023:ObjectCapture#ObjectBoundingBox");
    id v206 = objc_claimAutoreleasedReturnValue();
    uint64_t v209 = objc_msgSend_bytes(v206, v207, v208);
    *(void *)&long long v210 = *(void *)v209;
    HIDWORD(v210) = v309.i32[1];
    DWORD2(v210) = *(_DWORD *)(v209 + 8);
    *(void *)&long long v211 = *(void *)(v209 + 12);
    HIDWORD(v211) = v316.i32[1];
    DWORD2(v211) = *(_DWORD *)(v209 + 20);
    *(void *)&long long v212 = *(void *)(v209 + 24);
    HIDWORD(v212) = v322.i32[1];
    DWORD2(v212) = *(_DWORD *)(v209 + 32);
    *(void *)&long long v213 = *(void *)(v209 + 36);
    HIDWORD(v213) = v330.i32[1];
    DWORD2(v213) = *(_DWORD *)(v209 + 44);
    *(_OWORD *)(a2 + 320) = v210;
    *(_OWORD *)(a2 + 336) = v211;
    *(_OWORD *)(a2 + 352) = v212;
    *(_OWORD *)(a2 + 368) = v213;

    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v214 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v214, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v215 = "HEIC Deserialization: Read object field.";
LABEL_143:
      _os_log_impl(&dword_24B6B9000, v214, OS_LOG_TYPE_INFO, v215, buf, 2u);
    }
  }
  else
  {
    *(_OWORD *)(a2 + 256) = 0u;
    *(_OWORD *)(a2 + 272) = 0u;
    *(_OWORD *)(a2 + 288) = 0u;
    *(_OWORD *)(a2 + 304) = xmmword_24B72A590;
    *(_OWORD *)(a2 + 320) = 0u;
    *(_OWORD *)(a2 + 336) = 0u;
    *(_OWORD *)(a2 + 352) = 0u;
    *(_OWORD *)(a2 + 368) = 0u;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v214 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v214, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v215 = "HEIC Deserialization: Cannot read object internal metadata.";
      goto LABEL_143;
    }
  }

  v217 = objc_msgSend_objectForKeyedSubscript_(v156, v216, @"tag:apple.com,2023:ObjectCapture#BundleVersion");

  if (v217)
  {
    v219 = objc_msgSend_objectForKeyedSubscript_(v156, v218, @"tag:apple.com,2023:ObjectCapture#BundleVersion");
    id v220 = [NSString alloc];
    id v222 = (id)objc_msgSend_initWithData_encoding_(v220, v221, (uint64_t)v219, 4);
    *(void *)(a2 + 392) = v222;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v223 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v223, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v223, OS_LOG_TYPE_INFO, "HEIC Deserialization: Read HEIC version.", buf, 2u);
    }
  }
  else
  {
    *(void *)(a2 + 392) = 0;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v219 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v219, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v219, OS_LOG_TYPE_INFO, "HEIC Deserialization: Cannot read bundle version internal metadata.", buf, 2u);
    }
  }

  v225 = objc_msgSend_objectForKeyedSubscript_(v156, v224, @"tag:apple.com,2023:ObjectCapture#SegmentID");

  if (v225)
  {
    v227 = objc_msgSend_objectForKeyedSubscript_(v156, v226, @"tag:apple.com,2023:ObjectCapture#SegmentID");
    objc_msgSend_getBytes_length_(v227, v228, a2 + 400, 4);
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v229 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v229, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v229, OS_LOG_TYPE_INFO, "HEIC Deserialization: Read segment ID.", buf, 2u);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 400) = -1;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v227 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v227, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v227, OS_LOG_TYPE_INFO, "HEIC Deserialization: Cannot read segment ID internal metadata.", buf, 2u);
    }
  }

  v231 = objc_msgSend_objectForKeyedSubscript_(v156, v230, @"tag:apple.com,2024:ObjectCapture#SessionUUID");

  if (v231)
  {
    v233 = objc_msgSend_objectForKeyedSubscript_(v156, v232, @"tag:apple.com,2024:ObjectCapture#SessionUUID");
    id v234 = [NSString alloc];
    id v236 = (id)objc_msgSend_initWithData_encoding_(v234, v235, (uint64_t)v233, 4);
    *(void *)(a2 + 408) = v236;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v237 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v237, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v237, OS_LOG_TYPE_INFO, "HEIC Deserialization: Read session UUID.", buf, 2u);
    }
  }
  else
  {
    *(void *)(a2 + 408) = 0;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v233 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v233, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v233, OS_LOG_TYPE_INFO, "HEIC Deserialization: Cannot read session UUID internal metadata.", buf, 2u);
    }
  }

  v239 = objc_msgSend_objectForKeyedSubscript_(v156, v238, @"tag:apple.com,2024:ObjectCapture#CaptureMode");

  if (v239)
  {
    v241 = objc_msgSend_objectForKeyedSubscript_(v156, v240, @"tag:apple.com,2024:ObjectCapture#CaptureMode");
    objc_msgSend_getBytes_length_(v241, v242, a2 + 416, 4);
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v243 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v243, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v243, OS_LOG_TYPE_INFO, "HEIC Deserialization: Read session capture mode.", buf, 2u);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 416) = -1;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v241 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v241, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v241, OS_LOG_TYPE_INFO, "HEIC Deserialization: Cannot read session capture mode internal metadata.", buf, 2u);
    }
  }

  v245 = objc_msgSend_objectForKeyedSubscript_(v156, v244, @"tag:apple.com,2023:ObjectCapture#Feedback");

  if (v245)
  {
    v247 = objc_msgSend_objectForKeyedSubscript_(v156, v246, @"tag:apple.com,2023:ObjectCapture#Feedback");
    objc_msgSend_getBytes_length_(v247, v248, a2 + 420, 4);
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v249 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v249, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v249, OS_LOG_TYPE_INFO, "HEIC Deserialization: Read feedback.", buf, 2u);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 420) = -1;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v247 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v247, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v247, OS_LOG_TYPE_INFO, "HEIC Deserialization: Cannot read feedback internal metadata.", buf, 2u);
    }
  }

  v251 = objc_msgSend_objectForKeyedSubscript_(v156, v250, @"tag:apple.com,2023:ObjectCapture#WideToDepthCameraTransform");

  if (v251)
  {
    v253 = objc_msgSend_objectForKeyedSubscript_(v156, v252, @"tag:apple.com,2023:ObjectCapture#WideToDepthCameraTransform");
    int8x16_t v310 = *v193;
    int8x16_t v317 = v193[1];
    int8x16_t v323 = v193[2];
    int8x16_t v331 = v193[3];
    id v254 = v253;
    uint64_t v257 = objc_msgSend_bytes(v254, v255, v256);
    *(void *)&long long v258 = *(void *)v257;
    HIDWORD(v258) = vextq_s8(v310, v310, 8uLL).i32[1];
    DWORD2(v258) = *(_DWORD *)(v257 + 8);
    *(void *)&long long v259 = *(void *)(v257 + 12);
    HIDWORD(v259) = vextq_s8(v317, v317, 8uLL).i32[1];
    DWORD2(v259) = *(_DWORD *)(v257 + 20);
    *(void *)&long long v260 = *(void *)(v257 + 24);
    HIDWORD(v260) = vextq_s8(v323, v323, 8uLL).i32[1];
    DWORD2(v260) = *(_DWORD *)(v257 + 32);
    *(void *)&long long v261 = *(void *)(v257 + 36);
    HIDWORD(v261) = vextq_s8(v331, v331, 8uLL).i32[1];
    DWORD2(v261) = *(_DWORD *)(v257 + 44);
    *(_OWORD *)(a2 + 192) = v258;
    *(_OWORD *)(a2 + 208) = v259;
    *(_OWORD *)(a2 + 224) = v260;
    *(_OWORD *)(a2 + 240) = v261;

    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v262 = (id)qword_2697D0E20;
    if (!os_log_type_enabled(v262, OS_LOG_TYPE_INFO)) {
      goto LABEL_204;
    }
    *(_WORD *)buf = 0;
    v263 = "HEIC Deserialization: Read camera.wideToDepthTransform field.";
  }
  else
  {
    int8x16_t v264 = v193[1];
    *(int8x16_t *)(a2 + 192) = *v193;
    *(int8x16_t *)(a2 + 208) = v264;
    int8x16_t v265 = v193[3];
    *(int8x16_t *)(a2 + 224) = v193[2];
    *(int8x16_t *)(a2 + 240) = v265;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v262 = (id)qword_2697D0E20;
    if (!os_log_type_enabled(v262, OS_LOG_TYPE_INFO)) {
      goto LABEL_204;
    }
    *(_WORD *)buf = 0;
    v263 = "HEIC Deserialization: Cannot read camera wide to LiDAR camera transform internal metadata.";
  }
  _os_log_impl(&dword_24B6B9000, v262, OS_LOG_TYPE_INFO, v263, buf, 2u);
LABEL_204:

  v267 = objc_msgSend_objectForKeyedSubscript_(v156, v266, @"tag:apple.com,2023:ObjectCapture#TemporalDepthPointClouds");

  if (v267)
  {
    v268 = (void *)MEMORY[0x263EFFA08];
    uint64_t v269 = objc_opt_class();
    uint64_t v270 = objc_opt_class();
    uint64_t v271 = objc_opt_class();
    uint64_t v272 = objc_opt_class();
    uint64_t v273 = objc_opt_class();
    v275 = objc_msgSend_setWithObjects_(v268, v274, v269, v270, v271, v272, v273, 0);
    v277 = objc_msgSend_objectForKeyedSubscript_(v156, v276, @"tag:apple.com,2023:ObjectCapture#TemporalDepthPointClouds");
    objc_msgSend_unarchivedObjectOfClasses_fromData_error_(MEMORY[0x263F08928], v278, (uint64_t)v275, v277, 0);
    id v279 = (id)objc_claimAutoreleasedReturnValue();
    *(void *)(a2 + 424) = v279;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v280 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v280, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v280, OS_LOG_TYPE_INFO, "HEIC Deserialization: Read temporal LiDAR point clouds.", buf, 2u);
    }
  }
  else
  {
    *(void *)(a2 + 424) = 0;
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v275 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v275, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24B6B9000, v275, OS_LOG_TYPE_INFO, "HEIC Deserialization: Cannot read temporal LiDAR point clouds internal metadata.", buf, 2u);
    }
  }

  return 0;
}

void sub_24B6BC5F0(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    id v3 = objc_begin_catch(exception_object);
    sub_24B6BC684(v2);

    objc_end_catch();
    JUMPOUT(0x24B6BC0ACLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_24B6BC684(void *a1)
{
  v2 = (const void *)a1[22];
  if (v2) {
    CFRelease(v2);
  }
  id v3 = (const void *)a1[49];
  if (v3) {
    CFRelease(v3);
  }
  v4 = (const void *)a1[51];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[53];
  if (v5)
  {
    CFRelease(v5);
  }
}

uint64_t OCNonModularSPI_ADJasperPointCloud_CreateDataBuffer(void *a1)
{
  id v1 = a1;
  v4 = v1;
  if (!v1) {
    goto LABEL_11;
  }
  if (objc_msgSend_dataBuffer(v1, v2, v3))
  {
    v7 = (__CVBuffer *)objc_msgSend_dataBuffer(v4, v5, v6);
    uint64_t v8 = (uint64_t)CVBufferRetain(v7);
    goto LABEL_12;
  }
  uint64_t v9 = objc_msgSend_length(v4, v5, v6);
  uint64_t v11 = objc_msgSend_requiredStorageBytesForLength_(MEMORY[0x263F26BF8], v10, v9);
  CFTypeRef cf = 0;
  if (sub_24B6BC870(1785950320, v11, (IOSurfaceRef *)&cf))
  {
LABEL_11:
    uint64_t v8 = 0;
    goto LABEL_12;
  }
  if (CVDataBufferCreateWithIOSurface())
  {
    CFRelease(cf);
    goto LABEL_11;
  }
  CFRelease(cf);
  if ((objc_msgSend_prepareDataBuffer_forLength_(MEMORY[0x263F26BF8], v12, 0, v9) & 1) == 0)
  {
    CVBufferRelease(0);
    goto LABEL_11;
  }
  id v13 = objc_alloc(MEMORY[0x263F26C08]);
  v15 = objc_msgSend_initWithDataBuffer_(v13, v14, 0);
  uint64_t v17 = v15;
  if (v15)
  {
    objc_msgSend_replacePointsInRange_withPointsFrom_range_(v15, v16, 0, (int)v9, v4, 0, (int)v9);
    uint64_t v8 = objc_msgSend_dataBuffer(v17, v18, v19);
  }
  else
  {
    CVBufferRelease(0);
    uint64_t v8 = 0;
  }
LABEL_12:

  return v8;
}

void sub_24B6BC83C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B6BC870(int a1, uint64_t a2, IOSurfaceRef *a3)
{
  uint64_t v3 = 4294960635;
  if (!a2 || !a3) {
    return v3;
  }
  int v4 = a2;
  uint64_t v5 = (const void *)*MEMORY[0x263F0EE48];
  uint64_t v6 = (const void *)*MEMORY[0x263F0ED30];
  v7 = (const void *)*MEMORY[0x263F0EF50];
  uint64_t v8 = (const void *)*MEMORY[0x263F0EDF8];
  uint64_t v9 = (const void *)*MEMORY[0x263F0ED50];
  v10 = (const void *)*MEMORY[0x263F0ED48];
  uint64_t v11 = (const void *)*MEMORY[0x263F0EDC0];
  v12 = (const void *)*MEMORY[0x263F0EDB8];
  id v13 = (CFTypeRef *)operator new(0x40uLL);
  CFTypeRef *v13 = v5;
  v13[1] = v6;
  v13[2] = v7;
  v13[3] = v8;
  v13[4] = v9;
  v13[5] = v10;
  v13[6] = v11;
  v13[7] = v12;
  uint64_t v14 = (char *)operator new(0x20uLL);
  uint64_t v15 = 0;
  v16 = 0;
  uint64_t v17 = 0;
  v18 = 0;
  *(_DWORD *)uint64_t v14 = a1;
  *((_DWORD *)v14 + 1) = v4;
  *(_OWORD *)(v14 + 8) = xmmword_24B72A5A0;
  *((void *)v14 + 3) = 0x100000001;
  v45 = v14;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  for (CFNumberRef i = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberIntType, v14);
        ;
        CFNumberRef i = CFNumberCreate(allocator, kCFNumberIntType, &v14[4 * v15]))
  {
    CFNumberRef v20 = i;
    if (!i)
    {
      CFRelease(*v13);
      CFRelease(v13[1]);
      CFRelease(v13[2]);
      CFRelease(v13[3]);
      CFRelease(v13[4]);
      CFRelease(v13[5]);
      CFRelease(v13[6]);
      CFRelease(v13[7]);
      if (v17 == (char *)v18) {
        goto LABEL_64;
      }
      uint64_t v25 = 0;
      if ((unint64_t)((v17 - (char *)v18) >> 3) <= 1) {
        uint64_t v26 = 1;
      }
      else {
        uint64_t v26 = (v17 - (char *)v18) >> 3;
      }
      do
        CFRelease(v18[v25++]);
      while (v26 != v25);
      v27 = v18;
      uint64_t v28 = v17;
      goto LABEL_32;
    }
    if (v17 < v16)
    {
      *(void *)uint64_t v17 = i;
      v17 += 8;
      goto LABEL_5;
    }
    uint64_t v21 = (v17 - (char *)v18) >> 3;
    unint64_t v22 = v21 + 1;
    if ((unint64_t)(v21 + 1) >> 61) {
      abort();
    }
    if ((v16 - (char *)v18) >> 2 > v22) {
      unint64_t v22 = (v16 - (char *)v18) >> 2;
    }
    if ((unint64_t)(v16 - (char *)v18) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v23 = v22;
    }
    if (v23)
    {
      if (v23 >> 61) {
        sub_24B6BCD7C();
      }
      v24 = operator new(8 * v23);
    }
    else
    {
      v24 = 0;
    }
    v27 = (const void **)&v24[8 * v21];
    const char *v27 = v20;
    uint64_t v28 = (char *)(v27 + 1);
    if (v17 != (char *)v18)
    {
      unint64_t v29 = v17 - 8 - (char *)v18;
      if (v29 >= 0x168)
      {
        if (&v24[v17 - (char *)v18 - 8 - (v29 & 0xFFFFFFFFFFFFFFF8)] > &v24[v17 - (char *)v18 - 8])
        {
          v30 = (const void **)v17;
        }
        else if (&v17[-(v29 & 0xFFFFFFFFFFFFFFF8) - 8] > v17 - 8)
        {
          v30 = (const void **)v17;
        }
        else if ((unint64_t)((char *)v18 - v24) >= 0x20)
        {
          uint64_t v32 = (v29 >> 3) + 1;
          v30 = (const void **)&v17[-8 * (v32 & 0x3FFFFFFFFFFFFFFCLL)];
          uint64_t v33 = &v24[8 * v21 - 16];
          unsigned int v34 = v17 - 16;
          uint64_t v35 = v32 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v36 = *(_OWORD *)v34;
            *(v33 - 1) = *((_OWORD *)v34 - 1);
            *uint64_t v33 = v36;
            v33 -= 2;
            v34 -= 32;
            v35 -= 4;
          }
          while (v35);
          v27 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
          if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_29;
          }
        }
        else
        {
          v30 = (const void **)v17;
        }
      }
      else
      {
        v30 = (const void **)v17;
      }
      do
      {
        v31 = *--v30;
        *--v27 = v31;
      }
      while (v30 != v18);
LABEL_29:
      uint64_t v17 = (char *)v18;
    }
    v16 = &v24[8 * v23];
    if (v17) {
      operator delete(v17);
    }
LABEL_32:
    if (!v20)
    {
      uint64_t v3 = 4294960634;
      uint64_t v14 = v45;
      goto LABEL_65;
    }
    uint64_t v17 = v28;
    v18 = v27;
    uint64_t v14 = v45;
LABEL_5:
    if (++v15 == 8) {
      break;
    }
  }
  CFDictionaryRef v37 = CFDictionaryCreate(allocator, v13, v18, 8, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFDictionaryRef v38 = v37;
  if (!v37)
  {
    CFRelease(*v13);
    CFRelease(v13[1]);
    CFRelease(v13[2]);
    CFRelease(v13[3]);
    CFRelease(v13[4]);
    CFRelease(v13[5]);
    CFRelease(v13[6]);
    CFRelease(v13[7]);
    if (v17 == (char *)v18)
    {
LABEL_64:
      uint64_t v3 = 4294960634;
      v27 = (const void **)v17;
      if (!v17) {
        goto LABEL_66;
      }
    }
    else
    {
      if ((unint64_t)((v17 - (char *)v18) >> 3) <= 1) {
        uint64_t v41 = 1;
      }
      else {
        uint64_t v41 = (v17 - (char *)v18) >> 3;
      }
      v42 = v18;
      do
      {
        CFRelease(*v42++);
        --v41;
      }
      while (v41);
      uint64_t v3 = 4294960634;
      v27 = v18;
    }
LABEL_65:
    operator delete(v27);
    goto LABEL_66;
  }
  *a3 = IOSurfaceCreate(v37);
  CFRelease(v38);
  CFRelease(*v13);
  CFRelease(v13[1]);
  CFRelease(v13[2]);
  CFRelease(v13[3]);
  CFRelease(v13[4]);
  CFRelease(v13[5]);
  CFRelease(v13[6]);
  CFRelease(v13[7]);
  if (v17 != (char *)v18)
  {
    if ((unint64_t)((v17 - (char *)v18) >> 3) <= 1) {
      uint64_t v39 = 1;
    }
    else {
      uint64_t v39 = (v17 - (char *)v18) >> 3;
    }
    v40 = v18;
    do
    {
      CFRelease(*v40++);
      --v39;
    }
    while (v39);
  }
  if (*a3) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = 4294960634;
  }
  v27 = v18;
  if (v18) {
    goto LABEL_65;
  }
LABEL_66:
  operator delete(v14);
  operator delete(v13);
  return v3;
}

void sub_24B6BCD18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  operator delete(v11);
  _Unwind_Resume(a1);
}

void sub_24B6BCD7C()
{
}

id OCNonModularSPI_ADJasperPointCloud_CreatePointCloud(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (uint64_t)a1;
    id v3 = objc_alloc(MEMORY[0x263F26BF8]);
    a1 = objc_msgSend_initWithDataBuffer_(v3, v4, v2);
    uint64_t v1 = vars8;
  }
  return a1;
}

uint64_t *sub_24B6BCDD4(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v2[1];
        operator delete(v2);
        uint64_t v2 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

void *sub_24B6BCE38(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  id v13 = (void *)(a1 + 16);
  v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_34;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_34:
      }
        sub_24B6BD1F0(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v23 = *(void *)a1;
  v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    void *v10 = *v24;
LABEL_58:
    void *v24 = v10;
    goto LABEL_59;
  }
  void *v10 = *v13;
  void *v13 = v10;
  *(void *)(v23 + 8 * v3) = v13;
  if (*v10)
  {
    unint64_t v25 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_24B6BD124(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_24B6BD394((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_24B6BD138(void *a1)
{
  if (a1)
  {
    sub_24B6BD138(*a1);
    sub_24B6BD138(a1[1]);
    operator delete(a1);
  }
}

uint64_t sub_24B6BD184(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v5 = (void *)*v2;
      unint64_t v6 = (void *)v2[3];
      if (v6)
      {
        v2[4] = v6;
        operator delete(v6);
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  unint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

void sub_24B6BD1F0(uint64_t a1, unint64_t a2)
{
  if (!a2)
  {
    float v15 = *(void **)a1;
    *(void *)a1 = 0;
    if (v15) {
      operator delete(v15);
    }
    *(void *)(a1 + 8) = 0;
    return;
  }
  if (a2 >> 61) {
    sub_24B6BCD7C();
  }
  uint64_t v4 = operator new(8 * a2);
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = 0;
  *(void *)(a1 + 8) = a2;
  do
    *(void *)(*(void *)a1 + 8 * v6++) = 0;
  while (a2 != v6);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void **)(a1 + 16);
  if (v7)
  {
    unint64_t v9 = v7[1];
    unint64_t v10 = a2 - 1;
    if ((a2 & (a2 - 1)) == 0)
    {
      uint64_t v11 = v9 & v10;
      *(void *)(*(void *)a1 + 8 * v11) = v8;
      while (1)
      {
        uint64_t v12 = (void *)*v7;
        if (!*v7) {
          break;
        }
        uint64_t v13 = v12[1] & v10;
        if (v13 == v11)
        {
          unint64_t v7 = (void *)*v7;
        }
        else if (*(void *)(*(void *)a1 + 8 * v13))
        {
          void *v7 = *v12;
          uint64_t v14 = 8 * v13;
          void *v12 = **(void **)(*(void *)a1 + v14);
          **(void **)(*(void *)a1 + v14) = v12;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v13) = v7;
          unint64_t v7 = v12;
          uint64_t v11 = v13;
        }
      }
      return;
    }
    if (v9 >= a2) {
      v9 %= a2;
    }
    *(void *)(*(void *)a1 + 8 * v9) = v8;
    BOOL v16 = (void *)*v7;
    if (*v7)
    {
      do
      {
        unint64_t v18 = v16[1];
        if (v18 >= a2) {
          v18 %= a2;
        }
        if (v18 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v18))
          {
            *(void *)(*(void *)a1 + 8 * v18) = v7;
            goto LABEL_26;
          }
          void *v7 = *v16;
          uint64_t v17 = 8 * v18;
          void *v16 = **(void **)(*(void *)a1 + v17);
          **(void **)(*(void *)a1 + v17) = v16;
          BOOL v16 = v7;
        }
        unint64_t v18 = v9;
LABEL_26:
        unint64_t v7 = v16;
        BOOL v16 = (void *)*v16;
        unint64_t v9 = v18;
      }
      while (v16);
    }
  }
}

uint64_t sub_24B6BD394(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      unint64_t v3 = (void *)v2[3];
      if (v3)
      {
        v2[4] = v3;
        operator delete(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t *sub_24B6BD3E4(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = a2[2];
      if (*(unsigned char *)(v2 + 24)) {
        break;
      }
      unint64_t v3 = *(uint64_t **)(v2 + 16);
      uint64_t v4 = *v3;
      if (*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), uint64_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if (*(uint64_t **)v2 == a2)
          {
            unint64_t v9 = (uint64_t *)a2[2];
          }
          else
          {
            unint64_t v9 = *(uint64_t **)(v2 + 8);
            uint64_t v10 = *v9;
            *(void *)(v2 + 8) = *v9;
            if (v10)
            {
              *(void *)(v10 + 16) = v2;
              unint64_t v3 = *(uint64_t **)(v2 + 16);
            }
            v9[2] = (uint64_t)v3;
            *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = v9;
            uint64_t *v9 = v2;
            *(void *)(v2 + 16) = v9;
            unint64_t v3 = (uint64_t *)v9[2];
            uint64_t v2 = *v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v14 = *(void *)(v2 + 8);
          uint64_t *v3 = v14;
          if (v14) {
            *(void *)(v14 + 16) = v3;
          }
          *(void *)(v2 + 16) = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          *(void *)(v2 + 8) = v3;
          v3[2] = v2;
          return result;
        }
      }
      else if (!v4 || (v6 = *(unsigned __int8 *)(v4 + 24), uint64_t v5 = (unsigned char *)(v4 + 24), v6))
      {
        if (*(uint64_t **)v2 == a2)
        {
          uint64_t v11 = a2[1];
          *(void *)uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            unint64_t v3 = *(uint64_t **)(v2 + 16);
          }
          a2[2] = (uint64_t)v3;
          *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = a2;
          a2[1] = v2;
          *(void *)(v2 + 16) = a2;
          unint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v12 = (uint64_t *)v3[1];
        uint64_t v13 = *v12;
        v3[1] = *v12;
        if (v13) {
          *(void *)(v13 + 16) = v3;
        }
        v12[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v12;
        uint64_t *v12 = (uint64_t)v3;
        v3[2] = (uint64_t)v12;
        return result;
      }
      *(unsigned char *)(v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      unsigned char *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t OCObjectContourGetCenterOfMass(char *a1, unint64_t a2, float32x2_t *a3)
{
  uint64_t v3 = 4294967294;
  if (a1)
  {
    unint64_t v4 = a2;
    if (a2 >= 3)
    {
      if (a3)
      {
        if ((a2 & 0x8000000000000000) != 0) {
          abort();
        }
        unint64_t v7 = 8 * a2;
        int v8 = (float32x2_t *)operator new(8 * a2);
        memcpy(v8, a1, 8 * v4);
        unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
        if (v4 >= 0x1FFFFFFFFFFFFFFFLL) {
          abort();
        }
        if (2 * v4 <= v4 + 1) {
          uint64_t v10 = v4 + 1;
        }
        else {
          uint64_t v10 = 2 * v4;
        }
        if (v7 < 0x7FFFFFFFFFFFFFF8) {
          unint64_t v9 = v10;
        }
        if (v9 >> 61) {
          sub_24B6BCD7C();
        }
        uint64_t v11 = (float32x2_t *)operator new(8 * v9);
        v11[v4] = *v8;
        memcpy(v11, a1, 8 * v4);
        operator delete(v8);
        uint64_t v12 = 0;
        float32x2_t v13 = *v11;
        int32x2_t v14 = 0;
        float32x2_t v15 = 0;
        float32x2_t v16 = *v11;
        do
        {
          float32x2_t v17 = vsub_f32(v16, v11[v12 + 1]);
          v17.f32[0] = sqrtf(vaddv_f32(vmul_f32(v17, v17)));
          *(float *)v14.i32 = *(float *)v14.i32 + v17.f32[0];
          float32x2_t v15 = vmla_n_f32(v15, *(float32x2_t *)&a1[8 * v12], v17.f32[0]);
          float32x2_t v16 = v11[++v12];
        }
        while (v4 != v12);
        if (*(float *)v14.i32 >= 1.0e-10)
        {
          float32x2_t v18 = vdiv_f32(v15, (float32x2_t)vdup_lane_s32(v14, 0));
          uint64_t v19 = v11 + 1;
          int32x2_t v20 = 0;
          float32x2_t v21 = 0;
          __asm { FMOV            V4.2S, #3.0 }
          do
          {
            float32x2_t v27 = *v19++;
            float32x2_t v28 = vdiv_f32(vadd_f32(v18, vadd_f32(v13, v27)), _D4);
            float32x2_t v29 = vsub_f32(v13, v18);
            float32x2_t v30 = vsub_f32(v27, v18);
            v29.f32[0] = fabsf(vmlas_n_f32((float)-v29.f32[1] * v30.f32[0], v30.f32[1], v29.f32[0]));
            float32x2_t v21 = vmla_n_f32(v21, v28, v29.f32[0]);
            *(float *)v20.i32 = *(float *)v20.i32 + v29.f32[0];
            float32x2_t v13 = v27;
            --v4;
          }
          while (v4);
          if (*(float *)v20.i32 > 0.0) {
            float32x2_t v18 = vdiv_f32(v21, (float32x2_t)vdup_lane_s32(v20, 0));
          }
          uint64_t v3 = 0;
          *a3 = v18;
        }
        else
        {
          uint64_t v3 = 0xFFFFFFFFLL;
        }
        operator delete(v11);
      }
    }
  }
  return v3;
}

void sub_24B6BD748(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t OCObjectContourGetNearestPoints(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4, float32x2_t a5)
{
  uint64_t v5 = 4294967294;
  if (!a1 || !a2 || !a3 || !a4) {
    return v5;
  }
  uint64_t v6 = 0;
  unint64_t v7 = 0;
  float v8 = 3.4028e38;
  do
  {
    float32x2_t v9 = vsub_f32(*(float32x2_t *)(a1 + 8 * v6), a5);
    float v10 = sqrtf(vaddv_f32(vmul_f32(v9, v9)));
    if (vabds_f32(v8, v10) < 1.0e-10)
    {
      uint64_t v11 = v7 + 1;
      if (v7 + 1 <= 1)
      {
        uint64_t v12 = &a3[v7];
        goto LABEL_6;
      }
      goto LABEL_7;
    }
    if (v10 < v8)
    {
      uint64_t v12 = a3;
      float v8 = v10;
      uint64_t v11 = 1;
LABEL_6:
      void *v12 = v6;
LABEL_7:
      unint64_t v7 = v11;
    }
    ++v6;
  }
  while (a2 != v6);
  uint64_t v5 = 0;
  uint64_t v13 = 2;
  if (v7 < 2) {
    uint64_t v13 = v7;
  }
  *a4 = v13;
  return v5;
}

BOOL OCObjectContourIsPointInsideObjectContour(uint64_t a1, unint64_t a2, float32x2_t a3)
{
  uint64_t v3 = 0;
  if (a1 && a2 >= 3)
  {
    for (uint64_t i = 0; a2 != i; ++i)
    {
      uint64_t v5 = i + 1;
      if (a2 - 1 == i) {
        uint64_t v6 = 0;
      }
      else {
        uint64_t v6 = i + 1;
      }
      float32x2_t v7 = vsub_f32(*(float32x2_t *)(a1 + 8 * i), a3);
      float32x2_t v8 = vsub_f32(*(float32x2_t *)(a1 + 8 * v6), a3);
      if (vmlas_n_f32((float)-v7.f32[1] * v8.f32[0], v8.f32[1], v7.f32[0]) < 1.0e-10)
      {
        unint64_t v9 = v5 - 1;
        return v9 >= a2;
      }
    }
    unint64_t v9 = a2;
    return v9 >= a2;
  }
  return v3;
}

uint64_t OCCreateObjectContour(uint64_t a1, unint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t result = 4294967294;
  if (!a1 || a2 < 3 || !a3 || !a4) {
    return result;
  }
  if (a2 >> 61) {
    abort();
  }
  uint64_t v9 = 8 * a2;
  float v10 = (char *)operator new(8 * a2);
  bzero(v10, 8 * a2);
  uint64_t v11 = 0;
  do
  {
    *(void *)&v10[8 * v11] = *(void *)(a1 + 8 * v11);
    ++v11;
  }
  while (a2 != v11);
  if (a2 <= 2)
  {
    *a4 = 0;
    goto LABEL_236;
  }
  int32x4_t v146 = a3;
  int32x4_t v144 = a4;
  uint64_t v12 = 0;
  unint64_t v13 = v9 >> 3;
  if ((unint64_t)(v9 >> 3) <= 1) {
    uint64_t v14 = 1;
  }
  else {
    uint64_t v14 = v9 >> 3;
  }
  int v15 = -1;
  float v16 = 3.4028e38;
  do
  {
    if (v16 > COERCE_FLOAT(*(void *)&v10[8 * v12]))
    {
      int v15 = v12;
      LODWORD(v16) = *(void *)&v10[8 * v12];
    }
    ++v12;
  }
  while (v14 != v12);
  v150 = &v150;
  v151 = &v150;
  unint64_t v152 = 0;
  *(_OWORD *)v154 = 0u;
  *(_OWORD *)v155 = 0u;
  float v156 = 1.0;
  if (v9 < 0) {
    abort();
  }
  float32x2_t v17 = (int *)operator new(4 * a2);
  unint64_t v18 = v15;
  memset_pattern16(v17, &unk_24B72A830, v9 >> 1);
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  __p = v17;
  int32x4_t v145 = &v17[v13];
  unint64_t v148 = v18;
  while (2)
  {
    if (v18 == (int)v20) {
      goto LABEL_22;
    }
    float32x2_t v22 = vsub_f32(*(float32x2_t *)&v10[8 * v20], *(float32x2_t *)&v10[8 * v18]);
    int v23 = (int)(float)((float)((float)(atan2f(v22.f32[1], v22.f32[0]) / 1.5708) * 2147500000.0) * 0.9999);
    int v153 = v23;
    v17[v19] = v23;
    unint64_t v24 = v23;
    unint64_t v25 = (unint64_t)v154[1];
    if (v154[1])
    {
      uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v154[1]);
      v26.i16[0] = vaddlv_u8(v26);
      if (v26.u32[0] > 1uLL)
      {
        unint64_t v27 = v23;
        if (v154[1] <= (void *)v23) {
          unint64_t v27 = v23 % (unint64_t)v154[1];
        }
      }
      else
      {
        unint64_t v27 = ((unint64_t)v154[1] - 1) & v23;
      }
      float32x2_t v28 = (uint64_t **)*((void *)v154[0] + v27);
      if (v28)
      {
        float32x2_t v29 = *v28;
        if (v29)
        {
          if (v26.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v30 = v29[1];
              if (v30 == v23)
              {
                if (*((_DWORD *)v29 + 4) == v23) {
                  goto LABEL_83;
                }
              }
              else if ((v30 & ((uint64_t)v154[1] - 1)) != v27)
              {
                goto LABEL_44;
              }
              float32x2_t v29 = (uint64_t *)*v29;
              if (!v29) {
                goto LABEL_44;
              }
            }
          }
          do
          {
            unint64_t v31 = v29[1];
            if (v31 == v23)
            {
              if (*((_DWORD *)v29 + 4) == v23)
              {
LABEL_83:
                unsigned int v49 = sub_24B6BCE38((uint64_t)v154, v23, &v153);
                v50 = v49;
                v52 = (char *)v49[4];
                unint64_t v51 = v49[5];
                if ((unint64_t)v52 < v51)
                {
                  *(void *)v52 = v20;
                  float32x2_t v21 = v52 + 8;
                  float32x2_t v17 = __p;
                }
                else
                {
                  uint64_t v53 = (char *)v49[3];
                  uint64_t v54 = (v52 - v53) >> 3;
                  unint64_t v55 = v54 + 1;
                  if ((unint64_t)(v54 + 1) >> 61) {
                    abort();
                  }
                  uint64_t v56 = v51 - (void)v53;
                  if (v56 >> 2 > v55) {
                    unint64_t v55 = v56 >> 2;
                  }
                  if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v57 = v55;
                  }
                  if (v57)
                  {
                    if (v57 >> 61) {
                      sub_24B6BCD7C();
                    }
                    unint64_t v58 = v57;
                    int v59 = operator new(8 * v57);
                    unint64_t v57 = v58;
                  }
                  else
                  {
                    int v59 = 0;
                  }
                  uint64_t v64 = &v59[8 * v54];
                  *uint64_t v64 = v20;
                  float32x2_t v21 = v64 + 1;
                  if (v52 == v53)
                  {
                    float32x2_t v17 = __p;
                  }
                  else
                  {
                    unint64_t v65 = v52 - 8 - v53;
                    if (v65 < 0x58)
                    {
                      float32x2_t v17 = __p;
                      goto LABEL_124;
                    }
                    float32x2_t v17 = __p;
                    if ((unint64_t)(v53 - v59) < 0x20) {
                      goto LABEL_245;
                    }
                    uint64_t v66 = (v65 >> 3) + 1;
                    v67 = &v59[8 * v54 - 16];
                    v68 = v52 - 16;
                    uint64_t v69 = v66 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v70 = *(_OWORD *)v68;
                      *(v67 - 1) = *((_OWORD *)v68 - 1);
                      _OWORD *v67 = v70;
                      v67 -= 2;
                      v68 -= 32;
                      v69 -= 4;
                    }
                    while (v69);
                    v64 -= v66 & 0x3FFFFFFFFFFFFFFCLL;
                    v52 -= 8 * (v66 & 0x3FFFFFFFFFFFFFFCLL);
                    if (v66 != (v66 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_245:
                      do
                      {
LABEL_124:
                        uint64_t v71 = *((void *)v52 - 1);
                        v52 -= 8;
                        *--uint64_t v64 = v71;
                      }
                      while (v52 != v53);
                    }
                  }
                  v50[3] = v64;
                  v50[4] = v21;
                  v50[5] = &v59[8 * v57];
                  if (v53) {
                    operator delete(v53);
                  }
                }
                v50[4] = v21;
                unint64_t v18 = v148;
                goto LABEL_21;
              }
            }
            else
            {
              if ((void *)v31 >= v154[1]) {
                v31 %= (unint64_t)v154[1];
              }
              if (v31 != v27) {
                break;
              }
            }
            float32x2_t v29 = (uint64_t *)*v29;
          }
          while (v29);
        }
      }
    }
LABEL_44:
    uint64_t v32 = operator new(8uLL);
    void *v32 = v20;
    uint64_t v33 = v32 + 1;
    *(void *)&long long v34 = v32;
    *((void *)&v34 + 1) = v32 + 1;
    long long v149 = v34;
    if (!v25) {
      goto LABEL_64;
    }
    uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)v25);
    v35.i16[0] = vaddlv_u8(v35);
    if (v35.u32[0] > 1uLL)
    {
      unint64_t v18 = v23;
      if (v25 <= v23) {
        unint64_t v18 = v23 % v25;
      }
    }
    else
    {
      unint64_t v18 = (v25 - 1) & v23;
    }
    long long v36 = (uint64_t **)*((void *)v154[0] + v18);
    if (!v36 || (CFDictionaryRef v37 = *v36) == 0)
    {
LABEL_64:
      v40 = (char *)operator new(0x30uLL);
      v157 = (uint64_t **)v40;
      v158 = (uint64_t *)v155;
      *(void *)v40 = 0;
      *((void *)v40 + 1) = v23;
      *((_DWORD *)v40 + 4) = v23;
      *(_OWORD *)(v40 + 24) = v149;
      *((void *)v40 + 5) = v33;
      LOBYTE(v159) = 1;
      float v41 = (float)((unint64_t)v155[1] + 1);
      if (!v25 || (float)(v156 * (float)v25) < v41)
      {
        BOOL v42 = (v25 & (v25 - 1)) != 0;
        if (v25 < 3) {
          BOOL v42 = 1;
        }
        unint64_t v43 = v42 | (2 * v25);
        unint64_t v44 = vcvtps_u32_f32(v41 / v156);
        if (v43 <= v44) {
          size_t prime = v44;
        }
        else {
          size_t prime = v43;
        }
        if (prime == 1)
        {
          size_t prime = 2;
        }
        else if ((prime & (prime - 1)) != 0)
        {
          size_t prime = std::__next_prime(prime);
          unint64_t v25 = (unint64_t)v154[1];
        }
        if (prime > v25) {
          goto LABEL_76;
        }
        if (prime < v25)
        {
          unint64_t v46 = vcvtps_u32_f32((float)(unint64_t)v155[1] / v156);
          if (v25 < 3 || (uint8x8_t v47 = (uint8x8_t)vcnt_s8((int8x8_t)v25), v47.i16[0] = vaddlv_u8(v47), v47.u32[0] > 1uLL))
          {
            unint64_t v46 = std::__next_prime(v46);
          }
          else
          {
            uint64_t v48 = 1 << -(char)__clz(v46 - 1);
            if (v46 >= 2) {
              unint64_t v46 = v48;
            }
          }
          if (prime <= v46) {
            size_t prime = v46;
          }
          if (prime < v25) {
LABEL_76:
          }
            sub_24B6BD1F0((uint64_t)v154, prime);
        }
        unint64_t v25 = (unint64_t)v154[1];
        if (((unint64_t)v154[1] & ((unint64_t)v154[1] - 1)) != 0)
        {
          if (v154[1] <= (void *)v24) {
            unint64_t v18 = v24 % (unint64_t)v154[1];
          }
          else {
            unint64_t v18 = v24;
          }
        }
        else
        {
          unint64_t v18 = ((unint64_t)v154[1] - 1) & v24;
        }
      }
      v61 = v154[0];
      v62 = (void *)*((void *)v154[0] + v18);
      if (v62)
      {
        *(void *)v40 = *v62;
        unint64_t v18 = v148;
      }
      else
      {
        *(void **)v40 = v155[0];
        v155[0] = v40;
        v61[v18] = v155;
        unint64_t v18 = v148;
        if (!*(void *)v40)
        {
LABEL_112:
          ++v155[1];
          int v60 = 0;
          goto LABEL_113;
        }
        unint64_t v63 = *(void *)(*(void *)v40 + 8);
        if ((v25 & (v25 - 1)) != 0)
        {
          if (v63 >= v25) {
            v63 %= v25;
          }
        }
        else
        {
          v63 &= v25 - 1;
        }
        v62 = (char *)v154[0] + 8 * v63;
      }
      void *v62 = v40;
      goto LABEL_112;
    }
    if (v35.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v39 = v37[1];
        if (v39 == v23)
        {
          if (*((_DWORD *)v37 + 4) == v23) {
            goto LABEL_93;
          }
        }
        else if ((v39 & (v25 - 1)) != v18)
        {
          goto LABEL_64;
        }
        CFDictionaryRef v37 = (uint64_t *)*v37;
        if (!v37) {
          goto LABEL_64;
        }
      }
    }
    while (1)
    {
      unint64_t v38 = v37[1];
      if (v38 == v23) {
        break;
      }
      if (v38 >= v25) {
        v38 %= v25;
      }
      if (v38 != v18) {
        goto LABEL_64;
      }
LABEL_54:
      CFDictionaryRef v37 = (uint64_t *)*v37;
      if (!v37) {
        goto LABEL_64;
      }
    }
    if (*((_DWORD *)v37 + 4) != v23) {
      goto LABEL_54;
    }
LABEL_93:
    unint64_t v18 = v148;
    int v60 = (void *)v149;
LABEL_113:
    float32x2_t v17 = __p;
    if (v60) {
      operator delete(v60);
    }
LABEL_21:
    ++v19;
LABEL_22:
    if (++v20 < v13) {
      continue;
    }
    break;
  }
  int v72 = 0;
  v158 = 0;
  uint64_t v159 = 0;
  v157 = &v158;
  v73 = &v158;
  v74 = v146;
  while (1)
  {
    v75 = &v158;
    if (v73 == &v158) {
      goto LABEL_134;
    }
    v76 = v72;
    id v77 = &v158;
    if (v72)
    {
      do
      {
        v75 = (uint64_t **)v76;
        v76 = (uint64_t *)v76[1];
      }
      while (v76);
    }
    else
    {
      do
      {
        v75 = (uint64_t **)v77[2];
        BOOL v78 = *v75 == (uint64_t *)v77;
        id v77 = v75;
      }
      while (v78);
    }
    int v79 = *v17;
    if (*((_DWORD *)v75 + 7) < *v17)
    {
LABEL_134:
      uint64_t v80 = v72 ? v75 : &v158;
      v81 = v72 ? v75 + 1 : &v158;
    }
    else
    {
      uint64_t v80 = &v158;
      v81 = &v158;
      if (v72)
      {
        v81 = &v158;
        while (1)
        {
          while (1)
          {
            uint64_t v80 = (uint64_t **)v72;
            int v83 = *((_DWORD *)v72 + 7);
            if (v79 >= v83) {
              break;
            }
            int v72 = *v80;
            v81 = v80;
            if (!*v80) {
              goto LABEL_141;
            }
          }
          if (v83 >= v79) {
            break;
          }
          v81 = v80 + 1;
          int v72 = v80[1];
          if (!v72) {
            goto LABEL_141;
          }
        }
      }
    }
    if (!*v81)
    {
LABEL_141:
      uint64_t v82 = operator new(0x20uLL);
      v82[7] = *v17;
      *(void *)uint64_t v82 = 0;
      *((void *)v82 + 1) = 0;
      *((void *)v82 + 2) = v80;
      const char *v81 = (uint64_t *)v82;
      if (*v157)
      {
        v157 = (uint64_t **)*v157;
        uint64_t v82 = *v81;
      }
      sub_24B6BD3E4(v158, (uint64_t *)v82);
      ++v159;
    }
    if (++v17 == v145) {
      break;
    }
    v73 = v157;
    int v72 = v158;
  }
  uint64_t v84 = v157;
  if (v157 != &v158)
  {
    int8x8_t v85 = (int8x8_t)v154[1];
    if (v154[1])
    {
      while (1)
      {
        unint64_t v86 = *((int *)v84 + 7);
        int v153 = *((_DWORD *)v84 + 7);
        if (v85)
        {
          uint8x8_t v87 = (uint8x8_t)vcnt_s8(v85);
          v87.i16[0] = vaddlv_u8(v87);
          if (v87.u32[0] > 1uLL)
          {
            unint64_t v88 = v86;
            if (*(void *)&v85 <= v86) {
              unint64_t v88 = v86 % *(void *)&v85;
            }
          }
          else
          {
            unint64_t v88 = (*(void *)&v85 - 1) & v86;
          }
          v89 = (uint64_t **)*((void *)v154[0] + v88);
          if (v89)
          {
            v90 = *v89;
            if (v90)
            {
              if (v87.u32[0] < 2uLL)
              {
                uint64_t v91 = *(void *)&v85 - 1;
                while (1)
                {
                  uint64_t v93 = v90[1];
                  if (v93 == v86)
                  {
                    if (*((_DWORD *)v90 + 4) == v86) {
                      goto LABEL_176;
                    }
                  }
                  else if ((v93 & v91) != v88)
                  {
                    goto LABEL_179;
                  }
                  v90 = (uint64_t *)*v90;
                  if (!v90) {
                    goto LABEL_179;
                  }
                }
              }
              do
              {
                unint64_t v92 = v90[1];
                if (v92 == v86)
                {
                  if (*((_DWORD *)v90 + 4) == v86)
                  {
LABEL_176:
                    v94 = sub_24B6BCE38((uint64_t)v154, v86, &v153);
                    v95 = (uint64_t *)v94[3];
                    v96 = (uint64_t *)v94[4];
                    if (v95 != v96)
                    {
                      uint64_t v97 = v150;
                      unint64_t v98 = v152 + 1;
                      do
                      {
                        uint64_t v99 = *v95;
                        v100 = operator new(0x18uLL);
                        v100[2] = *(void *)&v10[8 * v99];
                        void *v100 = v97;
                        v100[1] = &v150;
                        v97[1] = v100;
                        v150 = v100;
                        unint64_t v152 = v98;
                        ++v95;
                        ++v98;
                        uint64_t v97 = v100;
                      }
                      while (v95 != v96);
                    }
                    break;
                  }
                }
                else
                {
                  if (v92 >= *(void *)&v85) {
                    v92 %= *(void *)&v85;
                  }
                  if (v92 != v88) {
                    break;
                  }
                }
                v90 = (uint64_t *)*v90;
              }
              while (v90);
            }
          }
        }
LABEL_179:
        v101 = v84[1];
        if (v101)
        {
          do
          {
            uint64_t v102 = (uint64_t **)v101;
            v101 = (uint64_t *)*v101;
          }
          while (v101);
        }
        else
        {
          do
          {
            uint64_t v102 = (uint64_t **)v84[2];
            BOOL v78 = *v102 == (uint64_t *)v84;
            uint64_t v84 = v102;
          }
          while (!v78);
        }
        unint64_t v18 = v148;
        if (v102 == &v158) {
          break;
        }
        int8x8_t v85 = (int8x8_t)v154[1];
        uint64_t v84 = v102;
      }
    }
    else
    {
      do
      {
        unsigned int v103 = v84[1];
        if (v103)
        {
          do
          {
            v104 = (uint64_t **)v103;
            unsigned int v103 = (uint64_t *)*v103;
          }
          while (v103);
        }
        else
        {
          do
          {
            v104 = (uint64_t **)v84[2];
            BOOL v78 = *v104 == (uint64_t *)v84;
            uint64_t v84 = v104;
          }
          while (!v78);
        }
        uint64_t v84 = v104;
      }
      while (v104 != &v158);
    }
  }
  v105 = operator new(0x18uLL);
  v105[2] = *(void *)&v10[8 * v18];
  v106 = v151;
  void *v105 = &v150;
  v105[1] = v106;
  void *v106 = v105;
  unint64_t v107 = v152;
  v151 = v105;
  ++v152;
  uint64_t v108 = operator new(0x18uLL);
  v108[2] = *(void *)&v10[8 * v18];
  v109 = v150;
  *uint64_t v108 = v150;
  v108[1] = &v150;
  v109[1] = v108;
  v150 = v108;
  unint64_t v152 = v107 + 2;
  sub_24B6BD138(v158);
  operator delete(__p);
  v110 = v155[0];
  if (v155[0])
  {
    do
    {
      v124 = (void *)*v110;
      v125 = (void *)v110[3];
      if (v125)
      {
        v110[4] = v125;
        operator delete(v125);
      }
      operator delete(v110);
      v110 = v124;
    }
    while (v124);
  }
  v111 = v154[0];
  v154[0] = 0;
  if (v111) {
    operator delete(v111);
  }
  if (v152)
  {
    v154[0] = v154;
    v154[1] = v154;
    v155[0] = 0;
    uint64_t v112 = v151;
    if (v152 > 3)
    {
      if (v151 == &v150) {
        goto LABEL_220;
      }
      __int32 v113 = 0;
      do
      {
        v126 = operator new(0x18uLL);
        v126[2] = v112[2];
        uint64_t v127 = v154[0];
        void *v126 = v154[0];
        v126[1] = v154;
        v127[1] = v126;
        ++v113;
        v154[0] = v126;
        v155[0] = v113;
        if ((unint64_t)v113 >= 3)
        {
          do
          {
            uint64_t v128 = *(void **)v154[0];
            float32x2_t v129 = *(float32x2_t *)(*(void *)v154[0] + 16);
            v130 = **(float32x2_t ***)v154[0];
            float32x2_t v131 = vsub_f32(v129, v130[2]);
            float32x2_t v132 = vsub_f32(*(float32x2_t *)((char *)v154[0] + 16), v129);
            if (vmlas_n_f32((float)-v131.f32[1] * v132.f32[0], v132.f32[1], v131.f32[0]) > 0.0) {
              break;
            }
            v130[1] = (float32x2_t)v128[1];
            *(void *)v128[1] = v130;
            v155[0] = v113 - 1;
            operator delete(v128);
            __int32 v113 = (char *)v155[0];
          }
          while (v155[0] >= (void *)3);
        }
        uint64_t v112 = (void *)v112[1];
      }
      while (v112 != &v150);
LABEL_201:
      if (v113)
      {
        v116 = (void **)v154[1];
        if (v154[1] == v154)
        {
          __int32 v113 = 0;
          uint64_t v123 = 0;
        }
        else
        {
          unint64_t v117 = -1;
          unsigned int v118 = (void **)v154[1];
          do
          {
            unint64_t v119 = v117;
            unsigned int v118 = (void **)v118[1];
            ++v117;
          }
          while (v118 != v154);
          if (v117 >= 0x1FFFFFFFFFFFFFFFLL) {
            abort();
          }
          v120 = (char *)operator new(8 * (v119 + 2));
          __int32 v113 = v120;
          v121 = v116;
          uint64_t v122 = v120;
          do
          {
            *(void *)uint64_t v122 = v121[2];
            v122 += 8;
            v121 = (void **)v121[1];
          }
          while (v121 != v154);
          uint64_t v123 = (v122 - v120) >> 3;
        }
        uint64_t v133 = (uint64_t)&v113[8 * v123 - 8];
        v134 = (void **)v154[0];
        v135 = *v116;
        v135[1] = *((void *)v154[0] + 1);
        *v134[1] = v135;
        v155[0] = 0;
        if (v116 != v154)
        {
          do
          {
            v136 = (void **)v116[1];
            operator delete(v116);
            v116 = v136;
          }
          while (v136 != v154);
        }
      }
      else
      {
        uint64_t v133 = 0;
      }
    }
    else
    {
      if (v151 != &v150)
      {
        __int32 v113 = 0;
        v114 = v154;
        do
        {
          v115 = operator new(0x18uLL);
          v115[2] = v112[2];
          void *v115 = v114;
          v115[1] = v154;
          v114[1] = v115;
          ++v113;
          v154[0] = v115;
          v155[0] = v113;
          uint64_t v112 = (void *)v112[1];
          v114 = (void **)v115;
        }
        while (v112 != &v150);
        goto LABEL_201;
      }
LABEL_220:
      uint64_t v133 = 0;
      __int32 v113 = 0;
    }
    if (v152)
    {
      uint64_t v138 = v150;
      uint64_t v137 = v151;
      uint64_t v139 = *v151;
      *(void *)(v139 + 8) = v150[1];
      *(void *)v138[1] = v139;
      unint64_t v152 = 0;
      if (v137 != &v150)
      {
        do
        {
          v140 = (void *)v137[1];
          operator delete(v137);
          uint64_t v137 = v140;
        }
        while (v140 != &v150);
      }
    }
    unint64_t v141 = (v133 - (uint64_t)v113) >> 3;
    *int32x4_t v144 = v141;
    if ((char *)v133 == v113)
    {
      if (v133) {
        goto LABEL_235;
      }
    }
    else
    {
      if (v141 <= 1) {
        unint64_t v141 = 1;
      }
      uint64_t v142 = v113;
      do
      {
        uint64_t v143 = *(void *)v142;
        v142 += 8;
        *v74++ = v143;
        --v141;
      }
      while (v141);
LABEL_235:
      operator delete(v113);
    }
  }
  else
  {
    *int32x4_t v144 = 0;
  }
LABEL_236:
  operator delete(v10);
  return 0;
}

void sub_24B6BE5CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, long long a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  sub_24B6BCDD4(&a20);
  sub_24B6BCDD4(&a16);
  operator delete(v22);
  _Unwind_Resume(a1);
}

uint64_t sub_24B6BE6BC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (result) {
    JUMPOUT(0x24C5D7790);
  }
  return result;
}

void sub_24B6BE6E4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9C8F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x24C5D7790);
}

void sub_24B6BE738(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9C8F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_24B6BE75C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (result) {
    JUMPOUT(0x24C5D7790);
  }
  return result;
}

void sub_24B6BE784(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9C8C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x24C5D7790);
}

void sub_24B6BE7D8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9C8C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_24B6BE7FC(void *a1)
{
  uint64_t v2 = a1[13];
  a1[13] = 0;
  if (v2) {
    MEMORY[0x24C5D7790](v2, 0x1000C40B166FFE6);
  }
  uint64_t v3 = a1[12];
  a1[12] = 0;
  if (v3) {
    MEMORY[0x24C5D7790](v3, 0x1000C40FA9F20B1);
  }
  uint64_t result = a1[11];
  a1[11] = 0;
  if (result)
  {
    JUMPOUT(0x24C5D7790);
  }
  return result;
}

void sub_24B6BE894(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9C888;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x24C5D7790);
}

void sub_24B6BE8E8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9C888;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_24B6BE90C(void *a1)
{
  uint64_t v2 = a1[13];
  a1[13] = 0;
  if (v2) {
    MEMORY[0x24C5D7790](v2, 0x1000C408F47704FLL);
  }
  uint64_t v3 = (void **)a1[8];
  unint64_t v4 = (void **)a1[9];
  a1[12] = 0;
  unint64_t v5 = (char *)v4 - (char *)v3;
  if ((unint64_t)((char *)v4 - (char *)v3) >= 0x11)
  {
    do
    {
      operator delete(*v3);
      unint64_t v4 = (void **)a1[9];
      uint64_t v3 = (void **)(a1[8] + 8);
      a1[8] = v3;
      unint64_t v5 = (char *)v4 - (char *)v3;
    }
    while ((unint64_t)((char *)v4 - (char *)v3) > 0x10);
  }
  unint64_t v6 = v5 >> 3;
  if (v6 == 1)
  {
    uint64_t v7 = 25;
    goto LABEL_9;
  }
  if (v6 == 2)
  {
    uint64_t v7 = 51;
LABEL_9:
    a1[11] = v7;
  }
  if (v3 != v4)
  {
    do
    {
      float32x2_t v8 = *v3++;
      operator delete(v8);
    }
    while (v3 != v4);
    uint64_t v10 = a1[8];
    uint64_t v9 = a1[9];
    if (v9 != v10) {
      a1[9] = v9 + ((v10 - v9 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  uint64_t v11 = (void *)a1[7];
  if (v11)
  {
    operator delete(v11);
  }
}

void sub_24B6BEA0C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9C850;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x24C5D7790);
}

void sub_24B6BEA60(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9C850;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_24B6BEA80(void *a1, uint64_t a2, float32x4_t *a3, float32x2_t *a4, float32x4_t *a5, uint64_t a6, void *a7, uint64_t a8)
{
  float32x2_t v8 = a5;
  unint64_t v9 = (unint64_t)a3;
  uint64_t v10 = a2;
  if (a7) {
    *a7 = 0;
  }
  uint64_t v11 = a1[20];
  uint64_t v12 = *(char **)(v11 + 48);
  unint64_t v13 = *(char **)(v11 + 40);
  uint64_t v14 = v12 - v13;
  long long v487 = *(_OWORD *)(a2 + 144);
  long long v490 = *(_OWORD *)(a2 + 128);
  long long v481 = *(_OWORD *)(a2 + 176);
  long long v484 = *(_OWORD *)(a2 + 160);
  double v15 = *(double *)(a2 + 264);
  if (v12 == v13) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = 51 * ((v12 - v13) >> 3) - 1;
  }
  unint64_t v17 = *(void *)(v11 + 64);
  unint64_t v18 = *(void *)(v11 + 72) + v17;
  if (v16 != v18)
  {
    unint64_t v31 = a1;
    uint64_t v30 = a4;
    goto LABEL_119;
  }
  if (v17 < 0x33)
  {
    uint64_t v32 = v14 >> 3;
    uint64_t v33 = *(char **)(v11 + 56);
    long long v34 = *(char **)(v11 + 32);
    if (v14 >> 3 < (unint64_t)((v33 - v34) >> 3))
    {
      uint8x8_t v35 = operator new(0xFF0uLL);
      if (v33 != v12)
      {
        long long v36 = *(char **)(v11 + 48);
        unint64_t v9 = (unint64_t)a3;
        if (v36 != *(char **)(v11 + 56))
        {
LABEL_117:
          *(void *)long long v36 = v35;
          *(void *)(v11 + 48) += 8;
          unint64_t v31 = a1;
          uint64_t v30 = a4;
          uint64_t v10 = a2;
          goto LABEL_118;
        }
        unint64_t v38 = *(char **)(v11 + 32);
        CFDictionaryRef v37 = *(char **)(v11 + 40);
        if (v37 > v38)
        {
          uint64_t v39 = (v37 - v38) >> 3;
          if (v39 >= -1) {
            uint64_t v40 = v39 + 1;
          }
          else {
            uint64_t v40 = v39 + 2;
          }
          uint64_t v41 = v40 >> 1;
          uint64_t v42 = -v41;
          unint64_t v43 = &v37[-8 * v41];
          int64_t v44 = v36 - v37;
          if (v36 != v37)
          {
            memmove(&v37[-8 * v41], *(const void **)(v11 + 40), v36 - v37);
            long long v36 = *(char **)(v11 + 40);
          }
          v45 = &v36[8 * v42];
          long long v36 = &v43[v44];
          *(void *)(v11 + 40) = v45;
          *(void *)(v11 + 48) = &v43[v44];
          goto LABEL_117;
        }
        unint64_t v93 = (v36 - v38) >> 2;
        if (v36 == v38) {
          unint64_t v93 = 1;
        }
        if (v93 >> 61) {
          goto LABEL_475;
        }
        unint64_t v94 = v93 >> 2;
        uint64_t v95 = 8 * v93;
        v96 = (char *)operator new(8 * v93);
        uint64_t v97 = &v96[8 * v94];
        int64_t v98 = v36 - v37;
        _ZF = v36 == v37;
        long long v36 = v97;
        if (!_ZF)
        {
          long long v36 = &v97[v98 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v99 = v98 - 8;
          if ((unint64_t)(v98 - 8) < 0x38)
          {
            v100 = &v96[8 * v94];
            goto LABEL_114;
          }
          uint64_t v127 = &v96[8 * v94];
          v100 = v127;
          if ((unint64_t)(v127 - v37) < 0x20)
          {
            do
            {
LABEL_114:
              uint64_t v134 = *(void *)v37;
              v37 += 8;
              *(void *)v100 = v134;
              v100 += 8;
            }
            while (v100 != v36);
            goto LABEL_115;
          }
          uint64_t v128 = (v99 >> 3) + 1;
          uint64_t v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
          v100 = &v97[v129];
          v130 = (long long *)(v37 + 16);
          float32x2_t v131 = v127 + 16;
          uint64_t v132 = v128 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v133 = *v130;
            *(v131 - 1) = *(v130 - 1);
            _OWORD *v131 = v133;
            v130 += 2;
            v131 += 2;
            v132 -= 4;
          }
          while (v132);
          if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
          {
            v37 += v129;
            goto LABEL_114;
          }
        }
LABEL_115:
        *(void *)(v11 + 32) = v96;
        *(void *)(v11 + 40) = v97;
        *(void *)(v11 + 48) = v36;
        *(void *)(v11 + 56) = &v96[v95];
        if (v38)
        {
          operator delete(v38);
          long long v36 = *(char **)(v11 + 48);
        }
        goto LABEL_117;
      }
      int v60 = *(char **)(v11 + 40);
      unint64_t v9 = (unint64_t)a3;
      if (v60 != *(char **)(v11 + 32))
      {
        v61 = *(char **)(v11 + 40);
        goto LABEL_452;
      }
      unint64_t v88 = *(unsigned char **)(v11 + 48);
      unint64_t v87 = *(void *)(v11 + 56);
      if ((unint64_t)v88 < v87)
      {
        uint64_t v89 = (uint64_t)(v87 - (void)v88) >> 3;
        if (v89 >= -1) {
          uint64_t v90 = v89 + 1;
        }
        else {
          uint64_t v90 = v89 + 2;
        }
        uint64_t v91 = v90 >> 1;
        unint64_t v92 = &v88[8 * (v90 >> 1)];
        v61 = &v92[-(v88 - v60)];
        if (v88 != v60)
        {
          memmove(&v92[-(v88 - v60)], *(const void **)(v11 + 40), v88 - v60);
          int v60 = *(char **)(v11 + 48);
        }
        *(void *)(v11 + 40) = v61;
        *(void *)(v11 + 48) = &v60[8 * v91];
LABEL_452:
        *((void *)v61 - 1) = v35;
        v424 = *(char **)(v11 + 40);
        v423 = *(char **)(v11 + 48);
        *(void *)(v11 + 40) = v424 - 8;
        uint64_t v425 = *((void *)v424 - 1);
        *(void *)(v11 + 40) = v424;
        uint64_t v10 = a2;
        if (v423 != *(char **)(v11 + 56))
        {
LABEL_474:
          *(void *)v423 = v425;
          *(void *)(v11 + 48) += 8;
          goto LABEL_97;
        }
        v426 = *(char **)(v11 + 32);
        if (v424 > v426)
        {
          v427 = v8;
          uint64_t v428 = (v424 - v426) >> 3;
          if (v428 >= -1) {
            uint64_t v429 = v428 + 1;
          }
          else {
            uint64_t v429 = v428 + 2;
          }
          uint64_t v430 = v429 >> 1;
          uint64_t v431 = -v430;
          v432 = &v424[-8 * v430];
          int64_t v433 = v423 - v424;
          if (v423 != v424)
          {
            memmove(&v424[-8 * v430], v424, v423 - v424);
            v424 = *(char **)(v11 + 40);
          }
          v423 = &v432[v433];
          *(void *)(v11 + 40) = &v424[8 * v431];
          *(void *)(v11 + 48) = &v432[v433];
          float32x2_t v8 = v427;
          goto LABEL_474;
        }
        unint64_t v434 = (v423 - v426) >> 2;
        if (v423 == v426) {
          unint64_t v434 = 1;
        }
        if (v434 >> 61) {
          goto LABEL_475;
        }
        v435 = v8;
        unint64_t v436 = v434 >> 2;
        uint64_t v437 = 8 * v434;
        v438 = (char *)operator new(8 * v434);
        v439 = &v438[8 * v436];
        int64_t v440 = v423 - v424;
        _ZF = v423 == v424;
        v423 = v439;
        if (!_ZF)
        {
          v423 = &v439[v440 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v441 = v440 - 8;
          if ((unint64_t)(v440 - 8) < 0x38)
          {
            v442 = &v438[8 * v436];
            goto LABEL_471;
          }
          v443 = &v438[8 * v436];
          v442 = v443;
          if ((unint64_t)(v443 - v424) < 0x20)
          {
            do
            {
LABEL_471:
              uint64_t v450 = *(void *)v424;
              v424 += 8;
              *(void *)v442 = v450;
              v442 += 8;
            }
            while (v442 != v423);
            goto LABEL_472;
          }
          uint64_t v444 = (v441 >> 3) + 1;
          uint64_t v445 = 8 * (v444 & 0x3FFFFFFFFFFFFFFCLL);
          v442 = &v439[v445];
          v446 = (long long *)(v424 + 16);
          v447 = v443 + 16;
          uint64_t v448 = v444 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v449 = *v446;
            *(v447 - 1) = *(v446 - 1);
            _OWORD *v447 = v449;
            v446 += 2;
            v447 += 2;
            v448 -= 4;
          }
          while (v448);
          if (v444 != (v444 & 0x3FFFFFFFFFFFFFFCLL))
          {
            v424 += v445;
            goto LABEL_471;
          }
        }
LABEL_472:
        *(void *)(v11 + 32) = v438;
        *(void *)(v11 + 40) = v439;
        *(void *)(v11 + 48) = v423;
        *(void *)(v11 + 56) = &v438[v437];
        float32x2_t v8 = v435;
        if (v426)
        {
          operator delete(v426);
          v423 = *(char **)(v11 + 48);
        }
        goto LABEL_474;
      }
      uint64_t v109 = v87 - (void)v60;
      _ZF = v109 == 0;
      unint64_t v110 = v109 >> 2;
      if (_ZF) {
        unint64_t v110 = 1;
      }
      if (v110 >> 61) {
        goto LABEL_475;
      }
      unint64_t v111 = (v110 + 3) >> 2;
      uint64_t v112 = 8 * v110;
      __int32 v113 = (char *)operator new(8 * v110);
      v61 = &v113[8 * v111];
      v114 = &v113[v112];
      v115 = v61;
      uint64_t v116 = v88 - v60;
      if (v88 != v60)
      {
        v115 = &v61[v116 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v117 = v116 - 8;
        unsigned int v118 = &v113[8 * v111];
        unint64_t v119 = v60;
        if (v117 > 0x37)
        {
          v120 = &v113[8 * v111];
          unsigned int v118 = v120;
          unint64_t v119 = v60;
          if ((unint64_t)(v120 - v60) >= 0x20)
          {
            uint64_t v121 = (v117 >> 3) + 1;
            uint64_t v122 = 8 * (v121 & 0x3FFFFFFFFFFFFFFCLL);
            unsigned int v118 = &v61[v122];
            uint64_t v123 = (long long *)(v60 + 16);
            v124 = v120 + 16;
            uint64_t v125 = v121 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v126 = *v123;
              *(v124 - 1) = *(v123 - 1);
              _OWORD *v124 = v126;
              v123 += 2;
              v124 += 2;
              v125 -= 4;
            }
            while (v125);
            if (v121 == (v121 & 0x3FFFFFFFFFFFFFFCLL))
            {
              *(void *)(v11 + 32) = v113;
              *(void *)(v11 + 40) = v61;
              *(void *)(v11 + 48) = v115;
              *(void *)(v11 + 56) = v114;
LABEL_451:
              operator delete(v60);
              v61 = *(char **)(v11 + 40);
              goto LABEL_452;
            }
            unint64_t v119 = &v60[v122];
          }
        }
        do
        {
          uint64_t v422 = *(void *)v119;
          v119 += 8;
          *(void *)unsigned int v118 = v422;
          v118 += 8;
        }
        while (v118 != v115);
      }
      *(void *)(v11 + 32) = v113;
      *(void *)(v11 + 40) = v61;
      *(void *)(v11 + 48) = v115;
      *(void *)(v11 + 56) = v114;
      if (!v60) {
        goto LABEL_452;
      }
      goto LABEL_451;
    }
    if (v33 == v34) {
      unint64_t v46 = 1;
    }
    else {
      unint64_t v46 = (v33 - v34) >> 2;
    }
    if (v46 >> 61) {
      goto LABEL_475;
    }
    uint8x8_t v47 = (char *)operator new(8 * v46);
    uint64_t v48 = &v47[8 * v32];
    unsigned int v49 = &v47[8 * v46];
    v50 = operator new(0xFF0uLL);
    if (v32 == v46)
    {
      if (v14 < 1)
      {
        unint64_t v62 = v14 >> 2;
        if (v12 == v13) {
          unint64_t v62 = 1;
        }
        if (v62 >> 61) {
          goto LABEL_475;
        }
        uint64_t v63 = 8 * v62;
        uint64_t v48 = (char *)operator new(8 * v62);
        unsigned int v49 = &v48[v63];
        operator delete(v47);
        unint64_t v13 = *(char **)(v11 + 40);
        uint64_t v12 = *(char **)(v11 + 48);
        uint8x8_t v47 = v48;
      }
      else
      {
        unint64_t v51 = v32 + 2;
        if (v32 >= -1) {
          unint64_t v51 = v32 + 1;
        }
        v48 -= 8 * (v51 >> 1);
      }
    }
    *(void *)uint64_t v48 = v50;
    uint64_t v64 = v48 + 8;
    if (v12 == v13)
    {
      unint64_t v65 = v48;
      uint64_t v66 = v48 + 8;
LABEL_49:
      v67 = *(void **)(v11 + 32);
      *(void *)(v11 + 32) = v47;
      *(void *)(v11 + 40) = v65;
      *(void *)(v11 + 48) = v66;
      *(void *)(v11 + 56) = v49;
      float32x2_t v8 = a5;
      unint64_t v31 = a1;
      uint64_t v30 = a4;
      uint64_t v10 = a2;
      unint64_t v9 = (unint64_t)a3;
      if (v67) {
        operator delete(v67);
      }
      goto LABEL_118;
    }
    while (v48 != v47)
    {
      v68 = v48;
      uint64_t v66 = v64;
LABEL_52:
      uint64_t v69 = *((void *)v12 - 1);
      v12 -= 8;
      *((void *)v68 - 1) = v69;
      unint64_t v65 = v68 - 8;
      uint64_t v64 = v66;
      uint64_t v48 = v65;
      if (v12 == *(char **)(v11 + 40)) {
        goto LABEL_49;
      }
    }
    if (v64 < v49)
    {
      uint64_t v70 = (v49 - v64) >> 3;
      if (v70 >= -1) {
        unint64_t v71 = v70 + 1;
      }
      else {
        unint64_t v71 = v70 + 2;
      }
      uint64_t v66 = &v64[8 * (v71 >> 1)];
      v68 = &v48[8 * (v71 >> 1)];
      if (v64 == v48)
      {
        uint8x8_t v47 = v64;
      }
      else
      {
        memmove(&v48[8 * (v71 >> 1)], v48, v64 - v48);
        uint8x8_t v47 = v48;
      }
      goto LABEL_52;
    }
    unint64_t v72 = (v49 - v48) >> 2;
    if (v49 == v48) {
      unint64_t v72 = 1;
    }
    if (v72 >> 61) {
      goto LABEL_475;
    }
    unint64_t v73 = (v72 + 3) >> 2;
    uint64_t v74 = 8 * v72;
    v75 = (char *)operator new(8 * v72);
    uint8x8_t v47 = v75;
    v68 = &v75[8 * v73];
    uint64_t v66 = v68;
    int64_t v76 = v64 - v48;
    if (v64 != v48)
    {
      uint64_t v66 = &v68[v76 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v77 = v76 - 8;
      BOOL v78 = &v75[8 * v73];
      int v79 = v48;
      if (v77 >= 0x38)
      {
        BOOL v78 = &v75[8 * v73];
        int v79 = v48;
        if ((unint64_t)(v78 - v48) >= 0x20)
        {
          uint64_t v80 = (v77 >> 3) + 1;
          uint64_t v81 = 8 * (v80 & 0x3FFFFFFFFFFFFFFCLL);
          BOOL v78 = &v68[v81];
          uint64_t v82 = (long long *)(v48 + 16);
          int v83 = &v75[8 * v73 + 16];
          uint64_t v84 = v80 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v85 = *v82;
            *((_OWORD *)v83 - 1) = *(v82 - 1);
            *(_OWORD *)int v83 = v85;
            v82 += 2;
            v83 += 32;
            v84 -= 4;
          }
          while (v84);
          if (v80 == (v80 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_71;
          }
          int v79 = &v48[v81];
        }
      }
      do
      {
        uint64_t v86 = *(void *)v79;
        v79 += 8;
        *(void *)BOOL v78 = v86;
        v78 += 8;
      }
      while (v78 != v66);
    }
LABEL_71:
    unsigned int v49 = &v75[v74];
    operator delete(v48);
    goto LABEL_52;
  }
  *(void *)(v11 + 64) = v17 - 51;
  float32x2_t v21 = v13 + 8;
  uint64_t v20 = *(void *)v13;
  *(void *)(v11 + 40) = v13 + 8;
  if (*(char **)(v11 + 56) == v12)
  {
    float32x2_t v22 = *(char **)(v11 + 32);
    if (v21 > v22)
    {
      uint64_t v23 = (v21 - v22) >> 3;
      if (v23 >= -1) {
        uint64_t v24 = v23 + 1;
      }
      else {
        uint64_t v24 = v23 + 2;
      }
      uint64_t v25 = v24 >> 1;
      uint64_t v26 = -v25;
      unint64_t v27 = &v21[-8 * v25];
      int64_t v28 = v12 - v21;
      if (v12 == v21)
      {
        float32x2_t v29 = v12;
      }
      else
      {
        memmove(&v21[-8 * v25], v21, v12 - v21);
        float32x2_t v29 = *(char **)(v11 + 40);
      }
      uint64_t v12 = &v27[v28];
      *(void *)(v11 + 40) = &v29[8 * v26];
      *(void *)(v11 + 48) = &v27[v28];
      goto LABEL_96;
    }
    unint64_t v52 = (v12 - v22) >> 2;
    if (v12 == v22) {
      unint64_t v52 = 1;
    }
    if (!(v52 >> 61))
    {
      unint64_t v53 = v52 >> 2;
      uint64_t v54 = 8 * v52;
      unint64_t v55 = (char *)operator new(8 * v52);
      uint64_t v56 = &v55[8 * v53];
      int64_t v57 = v12 - v21;
      _ZF = v12 == v21;
      uint64_t v12 = v56;
      if (_ZF) {
        goto LABEL_94;
      }
      uint64_t v12 = &v56[v57 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v58 = v57 - 8;
      if ((unint64_t)(v57 - 8) >= 0x38)
      {
        v101 = &v55[8 * v53];
        int v59 = v101;
        if ((unint64_t)(v101 - v21) >= 0x20)
        {
          uint64_t v102 = (v58 >> 3) + 1;
          uint64_t v103 = 8 * (v102 & 0x3FFFFFFFFFFFFFFCLL);
          int v59 = &v56[v103];
          v104 = (long long *)(v13 + 24);
          v105 = v101 + 16;
          uint64_t v106 = v102 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v107 = *v104;
            *(v105 - 1) = *(v104 - 1);
            _OWORD *v105 = v107;
            v104 += 2;
            v105 += 2;
            v106 -= 4;
          }
          while (v106);
          if (v102 == (v102 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_94:
            *(void *)(v11 + 32) = v55;
            *(void *)(v11 + 40) = v56;
            *(void *)(v11 + 48) = v12;
            *(void *)(v11 + 56) = &v55[v54];
            unint64_t v9 = (unint64_t)a3;
            if (v22)
            {
              operator delete(v22);
              uint64_t v12 = *(char **)(v11 + 48);
            }
            goto LABEL_96;
          }
          v21 += v103;
        }
      }
      else
      {
        int v59 = &v55[8 * v53];
      }
      do
      {
        uint64_t v108 = *(void *)v21;
        v21 += 8;
        *(void *)int v59 = v108;
        v59 += 8;
      }
      while (v59 != v12);
      goto LABEL_94;
    }
LABEL_475:
    sub_24B6BCD7C();
  }
LABEL_96:
  *(void *)uint64_t v12 = v20;
  *(void *)(v11 + 48) += 8;
  float32x2_t v8 = a5;
LABEL_97:
  unint64_t v31 = a1;
  uint64_t v30 = a4;
LABEL_118:
  unint64_t v13 = *(char **)(v11 + 40);
  unint64_t v18 = *(void *)(v11 + 72) + *(void *)(v11 + 64);
LABEL_119:
  unint64_t v135 = *(void *)&v13[8 * (v18 / 0x33)] + 80 * (v18 % 0x33);
  *(_OWORD *)unint64_t v135 = v490;
  *(_OWORD *)(v135 + 16) = v487;
  v142.f64[1] = *((float64_t *)&v481 + 1);
  *(_OWORD *)(v135 + 32) = v484;
  *(_OWORD *)(v135 + 48) = v481;
  *(double *)(v135 + 64) = v15;
  unint64_t v136 = *(void *)(v11 + 64);
  unint64_t v137 = *(void *)(v11 + 72) + 1;
  *(void *)(v11 + 72) = v137;
  uint64_t v138 = *(void ***)(v11 + 40);
  uint64_t v139 = &v138[v136 / 0x33];
  v140 = (double *)*v139;
  unint64_t v141 = v136 % 0x33;
  v142.f64[0] = *(float64_t *)v11;
  if (*((double *)*v139 + 10 * (v136 % 0x33) + 8) < v15 - *(double *)v11)
  {
    do
    {
      uint64_t v143 = *(void *)(v11 + 72) - 1;
      *(void *)(v11 + 64) = ++v136;
      *(void *)(v11 + 72) = v143;
      if (v136 >= 0x66)
      {
        operator delete(*v138);
        uint64_t v138 = (void **)(*(void *)(v11 + 40) + 8);
        *(void *)(v11 + 40) = v138;
        unint64_t v136 = *(void *)(v11 + 64) - 51;
        *(void *)(v11 + 64) = v136;
        v142.f64[0] = *(float64_t *)v11;
      }
      v140 = (double *)v138[v136 / 0x33];
      unint64_t v141 = v136 % 0x33;
    }
    while (v140[10 * (v136 % 0x33) + 8] < v15 - v142.f64[0]);
    uint64_t v139 = &v138[v136 / 0x33];
    unint64_t v137 = *(void *)(v11 + 72);
  }
  if (v137 < 0xA)
  {
    uint64_t v144 = 0;
    goto LABEL_162;
  }
  int32x4_t v145 = *(void ***)(v11 + 48);
  float64x2_t v146 = 0uLL;
  if (v145 == v138
    || (unsigned int v147 = (float32x4_t *)&v140[10 * v141],
        unint64_t v148 = (unint64_t)v138[(v137 + v136) / 0x33] + 80 * ((v137 + v136) % 0x33),
        v147 == (float32x4_t *)v148))
  {
    float64x2_t v152 = 0uLL;
    float64x2_t v154 = 0uLL;
    float64x2_t v150 = 0uLL;
    float64x2_t v151 = 0uLL;
  }
  else
  {
    float64x2_t v142 = 0uLL;
    long long v149 = v140;
    float64x2_t v150 = 0uLL;
    float64x2_t v151 = 0uLL;
    float64x2_t v152 = 0uLL;
    int v153 = v139;
    float64x2_t v154 = 0uLL;
    do
    {
      v157 = v147 + 5;
      if ((char *)&v147[5] - (char *)v149 == 4080)
      {
        v158 = (float32x4_t *)v153[1];
        ++v153;
        long long v149 = (double *)v158;
        v157 = v158;
      }
      float64x2_t v155 = (float64x2_t)vaddq_f32(v147[3], vmlaq_f32(vmlaq_f32(*v147, (float32x4_t)0, v147[1]), (float32x4_t)0, v147[2]));
      float64x2_t v156 = vcvtq_f64_f32(*(float32x2_t *)&v155.f64[0]);
      v155.f64[0] = *(float *)&v155.f64[1];
      float64x2_t v150 = vaddq_f64(v150, v156);
      float64x2_t v151 = vaddq_f64(v151, v155);
      float64x2_t v152 = vaddq_f64(v152, vmulq_f64(v156, v156));
      float64x2_t v154 = vaddq_f64(v154, vmulq_f64(v155, v155));
      unsigned int v147 = v157;
    }
    while (v157 != (float32x4_t *)v148);
  }
  v142.f64[0] = (double)v137;
  float64x2_t v159 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v137), 0);
  float64x2_t v160 = vdivq_f64(v151, v142);
  float64x2_t v161 = vdivq_f64(v150, v159);
  float64x2_t v162 = vmlsq_f64(vdivq_f64(v152, v159), v161, v161);
  float64x2_t v163 = vmlsq_f64(vdivq_f64(v154, v142), v160, v160);
  *(void *)&double v164 = *(_OWORD *)&vmulq_f64(v163, v163);
  double v165 = vaddvq_f64(vmulq_f64(v162, v162));
  if (v145 != v138)
  {
    v166 = (float32x4_t *)&v140[10 * v141];
    unint64_t v167 = (unint64_t)v138[(v137 + v136) / 0x33] + 80 * ((v137 + v136) % 0x33);
    if (v166 != (float32x4_t *)v167)
    {
      uint64_t v168 = v140;
      float64x2_t v169 = 0uLL;
      float64x2_t v170 = 0uLL;
      float64x2_t v146 = 0uLL;
      uint64_t v171 = v139;
      float64x2_t v172 = 0uLL;
      do
      {
        v175 = v166 + 5;
        if ((char *)&v166[5] - (char *)v168 == 4080)
        {
          id v176 = (float32x4_t *)v171[1];
          ++v171;
          uint64_t v168 = (double *)v176;
          v175 = v176;
        }
        float64x2_t v173 = (float64x2_t)vaddq_f32(v166[3], vmlaq_f32(vaddq_f32(v166[1], vmulq_f32(*v166, (float32x4_t)0)), (float32x4_t)0, v166[2]));
        float64x2_t v174 = vcvtq_f64_f32(*(float32x2_t *)&v173.f64[0]);
        v173.f64[0] = *(float *)&v173.f64[1];
        float64x2_t v169 = vaddq_f64(v169, v174);
        float64x2_t v170 = vaddq_f64(v170, v173);
        float64x2_t v146 = vaddq_f64(v146, vmulq_f64(v174, v174));
        float64x2_t v172 = vaddq_f64(v172, vmulq_f64(v173, v173));
        v166 = v175;
      }
      while (v175 != (float32x4_t *)v167);
      goto LABEL_142;
    }
    float64x2_t v146 = 0uLL;
  }
  float64x2_t v172 = 0uLL;
  float64x2_t v169 = 0uLL;
  float64x2_t v170 = 0uLL;
LABEL_142:
  v177.f64[0] = (double)v137;
  v177.f64[1] = (double)v137;
  double v178 = v164 + v165;
  float64x2_t v179 = vdivq_f64(v169, v177);
  float64x2_t v180 = vdivq_f64(v170, v142);
  float64x2_t v181 = vmlsq_f64(vdivq_f64(v146, v177), v179, v179);
  float64x2_t v182 = vmlsq_f64(vdivq_f64(v172, v142), v180, v180);
  double v183 = vmulq_f64(v182, v182).f64[0] + vaddvq_f64(vmulq_f64(v181, v181));
  if (v145 == v138
    || (v184 = (float32x4_t *)&v140[10 * v141],
        unint64_t v185 = (unint64_t)v138[(v137 + v136) / 0x33] + 80 * ((v137 + v136) % 0x33),
        v184 == (float32x4_t *)v185))
  {
    float64x2_t v188 = 0uLL;
    float64x2_t v189 = 0uLL;
    float64x2_t v186 = 0uLL;
    float64x2_t v187 = 0uLL;
  }
  else
  {
    float64x2_t v186 = 0uLL;
    float64x2_t v187 = 0uLL;
    float64x2_t v188 = 0uLL;
    float64x2_t v189 = 0uLL;
    do
    {
      v192 = v184 + 5;
      if ((char *)&v184[5] - (char *)v140 == 4080)
      {
        v193 = (float32x4_t *)v139[1];
        ++v139;
        v140 = (double *)v193;
        v192 = v193;
      }
      float64x2_t v190 = (float64x2_t)vaddq_f32(v184[3], vaddq_f32(v184[2], vmlaq_f32(vmulq_f32(*v184, (float32x4_t)0), (float32x4_t)0, v184[1])));
      float64x2_t v191 = vcvtq_f64_f32(*(float32x2_t *)&v190.f64[0]);
      v190.f64[0] = *(float *)&v190.f64[1];
      float64x2_t v186 = vaddq_f64(v186, v191);
      float64x2_t v187 = vaddq_f64(v187, v190);
      float64x2_t v188 = vaddq_f64(v188, vmulq_f64(v191, v191));
      float64x2_t v189 = vaddq_f64(v189, vmulq_f64(v190, v190));
      v184 = v192;
    }
    while (v192 != (float32x4_t *)v185);
  }
  v194.f64[0] = sqrt(v178);
  double v195 = sqrt(v183);
  v196.f64[0] = (double)v137;
  v196.f64[1] = (double)v137;
  float64x2_t v197 = vdivq_f64(v186, v196);
  float64x2_t v198 = vdivq_f64(v187, v142);
  float64x2_t v199 = vmlsq_f64(vdivq_f64(v188, v196), v197, v197);
  float64x2_t v200 = vmlsq_f64(vdivq_f64(v189, v142), v198, v198);
  double v201 = sqrt(vmulq_f64(v200, v200).f64[0] + vaddvq_f64(vmulq_f64(v199, v199)));
  if (*(unsigned char *)(v11 + 8))
  {
    v202.f64[0] = v194.f64[0];
    v202.f64[1] = v195;
    uint64_t v203 = *(void *)(v11 + 80);
    if (*(unsigned char *)(v203 + 16))
    {
      *(float64x2_t *)(v203 + 24) = v202;
      *(double *)(v203 + 40) = v201;
      *(unsigned char *)(v203 + 16) = 0;
    }
    else
    {
      float64x2_t v204 = *(float64x2_t *)(v203 + 24);
      if (*(unsigned char *)(v203 + 17))
      {
        float64x2_t v205 = *(float64x2_t *)(v203 + 48);
        double v206 = *(double *)(v203 + 40);
        double v207 = *(double *)(v203 + 64);
      }
      else
      {
        v194.f64[1] = v195;
        float64x2_t v205 = vsubq_f64(v194, v204);
        *(float64x2_t *)(v203 + 48) = v205;
        double v206 = *(double *)(v203 + 40);
        double v207 = v201 - v206;
        *(double *)(v203 + 64) = v201 - v206;
        *(unsigned char *)(v203 + 17) = 1;
      }
      double v208 = *(double *)(v203 + 8);
      double v209 = 1.0 - *(double *)v203;
      double v210 = *(double *)v203 * v201 + v209 * (v206 + v207);
      double v211 = v208 * (v210 - v206) + (1.0 - v208) * v207;
      float64x2_t v212 = vaddq_f64(vmulq_n_f64(v202, *(double *)v203), vmulq_n_f64(vaddq_f64(v204, v205), v209));
      float64x2_t v213 = vaddq_f64(vmulq_n_f64(vsubq_f64(v212, v204), v208), vmulq_n_f64(v205, 1.0 - v208));
      *(float64x2_t *)(v203 + 24) = v212;
      *(double *)(v203 + 40) = v210;
      *(float64x2_t *)(v203 + 48) = v213;
      *(double *)(v203 + 64) = v211;
      float64x2_t v214 = vaddq_f64(v212, v213);
      double v201 = v210 + v211;
      v194.f64[0] = fmax(v214.f64[0], 0.0);
      double v195 = fmax(v214.f64[1], 0.0);
      if (v201 <= 0.0) {
        double v201 = 0.0;
      }
    }
  }
  BOOL v215 = v194.f64[0] >= 0.005;
  if (v195 >= 0.005) {
    BOOL v215 = 1;
  }
  uint64_t v144 = v201 >= 0.005 || v215;
LABEL_162:
  uint64_t v216 = v31[24];
  float v217 = *(float *)(v10 + 256);
  if (*(unsigned char *)(v216 + 12))
  {
    double v218 = v217;
    uint64_t v219 = *(void *)(v216 + 32);
    int v220 = *(unsigned __int8 *)(v219 + 16);
    if (*(unsigned char *)(v219 + 16))
    {
      *(double *)(v219 + 24) = v218;
      *(unsigned char *)(v219 + 16) = 0;
      double v221 = 0.0;
    }
    else
    {
      if (*(unsigned char *)(v219 + 17))
      {
        double v222 = *(double *)(v219 + 24);
        double v223 = *(double *)(v219 + 32);
      }
      else
      {
        double v222 = *(double *)(v219 + 24);
        double v223 = v218 - v222;
        *(double *)(v219 + 32) = v218 - v222;
        *(unsigned char *)(v219 + 17) = 1;
      }
      double v224 = *(double *)v219 * v218 + (1.0 - *(double *)v219) * (v222 + v223);
      double v225 = *(double *)(v219 + 8) * (v224 - v222) + (1.0 - *(double *)(v219 + 8)) * v223;
      *(double *)(v219 + 24) = v224;
      *(double *)(v219 + 32) = v225;
      double v221 = v225 + v224;
    }
    float v226 = v221;
    float v227 = fmaxf(v226, 0.0);
    if (!v220) {
      float v217 = v227;
    }
  }
  BOOL v228 = 0;
  float v229 = *(float *)v216;
  int v230 = *(_DWORD *)(v216 + 40);
  if ((v230 - 1) <= 1 && v217 > 0.0)
  {
    float v231 = *(float *)(v216 + 8);
    float v232 = logf(v217);
    BOOL v228 = v232 > (float)(logf(v229) * (float)(1.0 - v231));
  }
  _ZF = v217 < v229 && !v228;
  if (_ZF)
  {
    uint64_t v238 = 0;
  }
  else
  {
    BOOL v234 = 0;
    float v235 = *(float *)(v216 + 4);
    if (v230 == 2 && v217 > 0.0)
    {
      float v236 = *(float *)(v216 + 8);
      float v237 = logf(v217);
      BOOL v234 = v237 > (float)(logf(v235) * (float)(1.0 - v236));
    }
    if (v217 >= v235) {
      BOOL v234 = 1;
    }
    if (v234) {
      uint64_t v238 = 2;
    }
    else {
      uint64_t v238 = 1;
    }
  }
  *(_DWORD *)(v216 + 40) = v238;
  if (v30 && v8)
  {
    uint64_t v469 = v144;
    if (!v9)
    {
      uint64_t v342 = v31[22];
      double v343 = *(double *)(v342 + 88);
      double v344 = *(double *)(v10 + 264);
      if (v343 < 0.0)
      {
        *(double *)(v342 + 88) = v344;
        double v343 = v344;
      }
      if (v344 - v343 >= 5.0 && sub_24B7279CC(v342, (float32x4_t *)v10, v30, v8)) {
        *(_DWORD *)(v342 + 96) = 2;
      }
      else {
        *(_DWORD *)(v342 + 96) = 0;
      }
      goto LABEL_446;
    }
    kdebug_trace();
    unsigned __int32 v239 = *(_DWORD *)v9;
    uint64_t v468 = v238;
    if (!*(_DWORD *)v9) {
      goto LABEL_332;
    }
    *(void *)v508 = 0;
    uint64_t v503 = 0;
    float32x4_t v240 = v8[1];
    float32x4_t v241 = v8[2];
    float32x4_t v242 = v8[3];
    float32x4_t v243 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, COERCE_FLOAT(*(_OWORD *)v30[2].f32)), v240, v30[2], 1), v241, *(float32x4_t *)v30[2].f32, 2), v242, *(float32x4_t *)v30[2].f32, 3);
    float32x4_t v244 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, COERCE_FLOAT(*(_OWORD *)v30[4].f32)), v240, v30[4], 1), v241, *(float32x4_t *)v30[4].f32, 2), v242, *(float32x4_t *)v30[4].f32, 3);
    float32x4_t v245 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, COERCE_FLOAT(*(_OWORD *)v30[6].f32)), v240, v30[6], 1), v241, *(float32x4_t *)v30[6].f32, 2), v242, *(float32x4_t *)v30[6].f32, 3);
    float32x4_t v504 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, COERCE_FLOAT(*(_OWORD *)v30->f32)), v240, *v30, 1), v241, *(float32x4_t *)v30->f32, 2), v242, *(float32x4_t *)v30->f32, 3);
    float32x4_t v505 = v243;
    float32x4_t v506 = v244;
    float32x4_t v507 = v245;
    if (!sub_24B7237E8((float32x4_t *)v10, &v504, &v508[1], v508, (int *)&v503 + 1, (int *)&v503))
    {
LABEL_332:
      kdebug_trace();
      uint32x2_t v496 = 0;
      uint64_t v338 = v31[26];
      int v339 = 1;
      uint64_t v341 = a6;
      v340 = a7;
      goto LABEL_377;
    }
    float32x4_t v246 = v8[1];
    float32x4_t v248 = v8[2];
    float32x4_t v247 = v8[3];
    v461 = v8;
    float32x4_t v249 = *(float32x4_t *)v30[2].f32;
    int8x16_t v250 = (int8x16_t)vmulq_f32(*(float32x4_t *)v30->f32, *(float32x4_t *)v30->f32);
    *(float32x2_t *)v250.i8 = vadd_f32(*(float32x2_t *)v250.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v250, v250, 8uLL));
    v250.i32[0] = vadd_f32(*(float32x2_t *)v250.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v250.i8, 1)).u32[0];
    float32x2_t v251 = vrsqrte_f32((float32x2_t)v250.u32[0]);
    float32x2_t v252 = vmul_f32(v251, vrsqrts_f32((float32x2_t)v250.u32[0], vmul_f32(v251, v251)));
    v250.i32[0] = vmul_f32(v252, vrsqrts_f32((float32x2_t)v250.u32[0], vmul_f32(v252, v252))).u32[0];
    int8x16_t v253 = (int8x16_t)vmulq_f32(v249, v249);
    *(float32x2_t *)v253.i8 = vadd_f32(*(float32x2_t *)v253.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v253, v253, 8uLL));
    v253.i32[0] = vadd_f32(*(float32x2_t *)v253.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v253.i8, 1)).u32[0];
    float32x4_t v254 = vmulq_n_f32(*(float32x4_t *)v30->f32, *(float *)v250.i32);
    *(float32x2_t *)v250.i8 = vrsqrte_f32((float32x2_t)v253.u32[0]);
    *(float32x2_t *)v250.i8 = vmul_f32(*(float32x2_t *)v250.i8, vrsqrts_f32((float32x2_t)v253.u32[0], vmul_f32(*(float32x2_t *)v250.i8, *(float32x2_t *)v250.i8)));
    v250.i32[0] = vmul_f32(*(float32x2_t *)v250.i8, vrsqrts_f32((float32x2_t)v253.u32[0], vmul_f32(*(float32x2_t *)v250.i8, *(float32x2_t *)v250.i8))).u32[0];
    float32x4_t v255 = *(float32x4_t *)v30[4].f32;
    int8x16_t v256 = (int8x16_t)vmulq_f32(v255, v255);
    *(float32x2_t *)v256.i8 = vadd_f32(*(float32x2_t *)v256.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v256, v256, 8uLL));
    v256.i32[0] = vadd_f32(*(float32x2_t *)v256.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v256.i8, 1)).u32[0];
    float32x4_t v257 = vmulq_n_f32(v249, *(float *)v250.i32);
    *(float32x2_t *)v250.i8 = vrsqrte_f32((float32x2_t)v256.u32[0]);
    *(float32x2_t *)v250.i8 = vmul_f32(*(float32x2_t *)v250.i8, vrsqrts_f32((float32x2_t)v256.u32[0], vmul_f32(*(float32x2_t *)v250.i8, *(float32x2_t *)v250.i8)));
    float32x4_t v258 = vmulq_n_f32(v255, vmul_f32(*(float32x2_t *)v250.i8, vrsqrts_f32((float32x2_t)v256.u32[0], vmul_f32(*(float32x2_t *)v250.i8, *(float32x2_t *)v250.i8))).f32[0]);
    float32x4_t v259 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, v254.f32[0]), v246, *(float32x2_t *)v254.f32, 1), v248, v254, 2), v247, v254, 3);
    float32x4_t v260 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, v257.f32[0]), v246, *(float32x2_t *)v257.f32, 1), v248, v257, 2), v247, v257, 3);
    float32x4_t v261 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, v258.f32[0]), v246, *(float32x2_t *)v258.f32, 1), v248, v258, 2), v247, v258, 3);
    float32x4_t v262 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, COERCE_FLOAT(*(_OWORD *)v30[6].f32)), v246, v30[6], 1), v248, *(float32x4_t *)v30[6].f32, 2), v247, *(float32x4_t *)v30[6].f32, 3);
    float32x4_t v264 = *(float32x4_t *)(v9 + 32);
    float32x4_t v263 = *(float32x4_t *)(v9 + 48);
    float32x4_t v266 = *(float32x4_t *)(v9 + 64);
    float32x4_t v265 = *(float32x4_t *)(v9 + 80);
    float32x4_t v267 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v259, v264.f32[0]), v260, *(float32x2_t *)v264.f32, 1), v261, v264, 2);
    float32x4_t v268 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v259, v263.f32[0]), v260, *(float32x2_t *)v263.f32, 1), v261, v263, 2);
    float32x4_t v269 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v259, v266.f32[0]), v260, *(float32x2_t *)v266.f32, 1), v261, v266, 2);
    float32x4_t v270 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v259, v265.f32[0]), v260, *(float32x2_t *)v265.f32, 1), v261, v265, 2);
    long long v500 = 0u;
    long long v501 = 0u;
    int v502 = 1065353216;
    *(_OWORD *)v497 = 0u;
    *(_OWORD *)__p = 0u;
    int v499 = 1065353216;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1330, memory_order_acquire) & 1) == 0)
    {
      float32x4_t v489 = v268;
      float32x4_t v492 = v267;
      float32x4_t v483 = v270;
      float32x4_t v486 = v269;
      float32x4_t v474 = v265;
      float32x4_t v476 = v262;
      float32x4_t v472 = v266;
      float32x4_t v465 = v264;
      float32x4_t v467 = v263;
      int v451 = __cxa_guard_acquire(&qword_2697D1330);
      float32x4_t v264 = v465;
      float32x4_t v263 = v467;
      float32x4_t v266 = v472;
      float32x4_t v265 = v474;
      float32x4_t v262 = v476;
      float32x4_t v270 = v483;
      float32x4_t v269 = v486;
      float32x4_t v268 = v489;
      float32x4_t v267 = v492;
      if (v451)
      {
        *(simd_float4x4 *)zmmword_2697D12F0 = __invert_f4(*(simd_float4x4 *)zmmword_24B72F120);
        __cxa_guard_release(&qword_2697D1330);
        float32x4_t v264 = v465;
        float32x4_t v263 = v467;
        float32x4_t v266 = v472;
        float32x4_t v265 = v474;
        float32x4_t v262 = v476;
        float32x4_t v270 = v483;
        float32x4_t v269 = v486;
        float32x4_t v268 = v489;
        float32x4_t v267 = v492;
      }
    }
    unsigned int v475 = 0;
    unsigned __int32 v271 = 0;
    float32x4_t v488 = vmlaq_laneq_f32(v268, v262, v263, 3);
    float32x4_t v491 = vmlaq_laneq_f32(v267, v262, v264, 3);
    float32x4_t v482 = vmlaq_laneq_f32(v270, v262, v265, 3);
    float32x4_t v485 = vmlaq_laneq_f32(v269, v262, v266, 3);
    float32x4_t v464 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, COERCE_FLOAT(*(_OWORD *)(v10 + 208))), *(float32x4_t *)&zmmword_2697D12F0[16], *(float32x2_t *)(v10 + 208), 1), *(float32x4_t *)&zmmword_2697D12F0[32], *(float32x4_t *)(v10 + 208), 2), *(float32x4_t *)&zmmword_2697D12F0[48], *(float32x4_t *)(v10 + 208), 3);
    float32x4_t v466 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, COERCE_FLOAT(*(_OWORD *)(v10 + 192))), *(float32x4_t *)&zmmword_2697D12F0[16], *(float32x2_t *)(v10 + 192), 1), *(float32x4_t *)&zmmword_2697D12F0[32], *(float32x4_t *)(v10 + 192), 2), *(float32x4_t *)&zmmword_2697D12F0[48], *(float32x4_t *)(v10 + 192), 3);
    int8x16_t v462 = (int8x16_t)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, COERCE_FLOAT(*(_OWORD *)(v10 + 240))), *(float32x4_t *)&zmmword_2697D12F0[16], *(float32x2_t *)(v10 + 240), 1), *(float32x4_t *)&zmmword_2697D12F0[32], *(float32x4_t *)(v10 + 240), 2), *(float32x4_t *)&zmmword_2697D12F0[48], *(float32x4_t *)(v10 + 240), 3);
    float32x4_t v463 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, COERCE_FLOAT(*(_OWORD *)(v10 + 224))), *(float32x4_t *)&zmmword_2697D12F0[16], *(float32x2_t *)(v10 + 224), 1), *(float32x4_t *)&zmmword_2697D12F0[32], *(float32x4_t *)(v10 + 224), 2), *(float32x4_t *)&zmmword_2697D12F0[48], *(float32x4_t *)(v10 + 224), 3);
    float64x2_t v471 = 0u;
    long long v473 = 0u;
    while (1)
    {
      float32x4_t v272 = *(float32x4_t *)(*(void *)(v9 + 8) + 48 * v271);
      float32x4_t v273 = *(float32x4_t *)(v10 + 192);
      float32x4_t v274 = *(float32x4_t *)(v10 + 208);
      float32x4_t v276 = *(float32x4_t *)(v10 + 224);
      float32x4_t v275 = *(float32x4_t *)(v10 + 240);
      float32x4_t v278 = *(float32x4_t *)(v10 + 32);
      float32x4_t v277 = *(float32x4_t *)(v10 + 48);
      float32x4_t v279 = *(float32x4_t *)(v10 + 64);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1330, memory_order_acquire) & 1) == 0)
      {
        float32x4_t v458 = v279;
        float32x4_t v459 = v277;
        float32x4_t v456 = v275;
        float32x4_t v457 = v278;
        float32x4_t v454 = v274;
        float32x4_t v455 = v276;
        float32x4_t v452 = v272;
        float32x4_t v453 = v273;
        int v337 = __cxa_guard_acquire(&qword_2697D1330);
        float32x4_t v272 = v452;
        float32x4_t v273 = v453;
        float32x4_t v274 = v454;
        float32x4_t v276 = v455;
        float32x4_t v275 = v456;
        float32x4_t v278 = v457;
        float32x4_t v279 = v458;
        float32x4_t v277 = v459;
        if (v337)
        {
          *(simd_float4x4 *)zmmword_2697D12F0 = __invert_f4(*(simd_float4x4 *)zmmword_24B72F120);
          __cxa_guard_release(&qword_2697D1330);
          float32x4_t v272 = v452;
          float32x4_t v273 = v453;
          float32x4_t v274 = v454;
          float32x4_t v276 = v455;
          float32x4_t v275 = v456;
          float32x4_t v278 = v457;
          float32x4_t v279 = v458;
          float32x4_t v277 = v459;
        }
      }
      float32x4_t v280 = vaddq_f32(v482, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v491, v272.f32[0]), v488, *(float32x2_t *)v272.f32, 1), v485, v272, 2));
      float32x4_t v281 = vaddq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, v275.f32[0]), *(float32x4_t *)&zmmword_2697D12F0[16], *(float32x2_t *)v275.f32, 1), *(float32x4_t *)&zmmword_2697D12F0[32], v275, 2), *(float32x4_t *)&zmmword_2697D12F0[48], v275, 3), vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(
                           vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, v273.f32[0]),
                           *(float32x4_t *)&zmmword_2697D12F0[16],
                           *(float32x2_t *)v273.f32,
                           1),
                         *(float32x4_t *)&zmmword_2697D12F0[32],
                         v273,
                         2),
                       *(float32x4_t *)&zmmword_2697D12F0[48],
                       v273,
                       3),
                     v280.f32[0]),
                   vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, v274.f32[0]), *(float32x4_t *)&zmmword_2697D12F0[16], *(float32x2_t *)v274.f32, 1), *(float32x4_t *)&zmmword_2697D12F0[32], v274, 2), *(float32x4_t *)&zmmword_2697D12F0[48], v274, 3), *(float32x2_t *)v280.f32, 1), vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, v276.f32[0]), *(float32x4_t *)&zmmword_2697D12F0[16],
                       *(float32x2_t *)v276.f32,
                       1),
                     *(float32x4_t *)&zmmword_2697D12F0[32],
                     v276,
                     2),
                   *(float32x4_t *)&zmmword_2697D12F0[48],
                   v276,
                   3),
                 v280,
                 2));
      float v282 = fmaxf(fabsf(v281.f32[2]), 0.00000011921);
      float v283 = v281.f32[2] < 0.0 ? -v282 : v282;
      v281.i64[0] = vaddq_f32(v279, vmlaq_n_f32(vmulq_n_f32(v278, v281.f32[0] / v283), v277, v281.f32[1] / v283)).u64[0];
      uint64_t v284 = (int)v281.f32[0];
      uint64_t v285 = (int)v281.f32[1];
      if (v281.f32[2] < 0.0)
      {
        v290 = v497;
        unint64_t v286 = (unint64_t)v497[1];
      }
      else
      {
        unint64_t v286 = *((void *)&v500 + 1);
        if (*((void *)&v500 + 1))
        {
          unint64_t v287 = (int)(v285 ^ v284);
          uint8x8_t v288 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v500 + 8));
          v288.i16[0] = vaddlv_u8(v288);
          if (v288.u32[0] > 1uLL)
          {
            unint64_t v289 = (int)(v285 ^ v284);
            if (*((void *)&v500 + 1) <= v287) {
              unint64_t v289 = v287 % *((void *)&v500 + 1);
            }
          }
          else
          {
            unint64_t v289 = (*((void *)&v500 + 1) - 1) & v287;
          }
          v291 = *(uint64_t ***)(v500 + 8 * v289);
          if (v291)
          {
            v292 = *v291;
            if (v292)
            {
              if (v288.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v295 = v292[1];
                  if (v295 == v287)
                  {
                    if (*((_DWORD *)v292 + 4) == v284 && *((_DWORD *)v292 + 5) == v285) {
                      goto LABEL_234;
                    }
                  }
                  else if ((v295 & (*((void *)&v500 + 1) - 1)) != v289)
                  {
                    goto LABEL_229;
                  }
                  v292 = (uint64_t *)*v292;
                  if (!v292) {
                    goto LABEL_229;
                  }
                }
              }
              do
              {
                unint64_t v293 = v292[1];
                if (v293 == v287)
                {
                  if (*((_DWORD *)v292 + 4) == v284 && *((_DWORD *)v292 + 5) == v285) {
                    goto LABEL_234;
                  }
                }
                else
                {
                  if (v293 >= *((void *)&v500 + 1)) {
                    v293 %= *((void *)&v500 + 1);
                  }
                  if (v293 != v289) {
                    break;
                  }
                }
                v292 = (uint64_t *)*v292;
              }
              while (v292);
            }
          }
        }
LABEL_229:
        if ((v284 & 0x80000000) != 0)
        {
LABEL_234:
          v290 = (void **)&v500;
        }
        else
        {
          v290 = (void **)&v500;
          if (*(_DWORD *)(v10 + 276) > (int)v285 && (v285 & 0x80000000) == 0 && *(_DWORD *)(v10 + 272) > (int)v284)
          {
            ++v475;
            int8x16_t v297 = (int8x16_t)vmlaq_laneq_f32(vmlaq_f32(vmulq_n_f32(v466, v280.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v280.f32, 1), v464), v463, v280, 2);
            *((void *)&v298 + 1) = *((void *)&v473 + 1);
            *(int32x2_t *)&long long v298 = vsub_s32(*(int32x2_t *)&v473, vcgt_f32((float32x2_t)0x3ECCCCCD3E4CCCCDLL, (float32x2_t)vdup_lane_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v462, v462, 8uLL), (float32x2_t)*(_OWORD *)&vextq_s8(v297, v297, 8uLL)), 0)));
            float64x2_t v471 = vaddq_f64(v471, vcvtq_f64_f32(*(float32x2_t *)v281.f32));
            long long v473 = v298;
          }
        }
      }
      int v299 = v285 ^ v284;
      unint64_t v300 = (int)(v285 ^ v284);
      if (v286)
      {
        uint8x8_t v301 = (uint8x8_t)vcnt_s8((int8x8_t)v286);
        v301.i16[0] = vaddlv_u8(v301);
        if (v301.u32[0] > 1uLL)
        {
          unint64_t v9 = v299;
          if (v286 <= v299) {
            unint64_t v9 = v300 % v286;
          }
        }
        else
        {
          unint64_t v9 = (v286 - 1) & v300;
        }
        unsigned int v302 = (uint64_t **)*((void *)*v290 + v9);
        if (v302)
        {
          int32x4_t v303 = *v302;
          if (v303)
          {
            if (v301.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v307 = v303[1];
                if (v307 == v300)
                {
                  if (*((_DWORD *)v303 + 4) == v284 && *((_DWORD *)v303 + 5) == v285) {
                    goto LABEL_328;
                  }
                }
                else if ((v307 & (v286 - 1)) != v9)
                {
                  goto LABEL_261;
                }
                int32x4_t v303 = (uint64_t *)*v303;
                if (!v303) {
                  goto LABEL_261;
                }
              }
            }
            do
            {
              unint64_t v305 = v303[1];
              if (v305 == v300)
              {
                if (*((_DWORD *)v303 + 4) == v284 && *((_DWORD *)v303 + 5) == v285) {
                  goto LABEL_328;
                }
              }
              else
              {
                if (v305 >= v286) {
                  v305 %= v286;
                }
                if (v305 != v9) {
                  break;
                }
              }
              int32x4_t v303 = (uint64_t *)*v303;
            }
            while (v303);
          }
        }
      }
LABEL_261:
      uint64_t v308 = v285 << 32;
      int8x16_t v309 = operator new(0x18uLL);
      *int8x16_t v309 = 0;
      v309[1] = v300;
      v309[2] = v308 | v284;
      float v310 = (float)((unint64_t)v290[3] + 1);
      float v311 = *((float *)v290 + 8);
      if (!v286 || (float)(v311 * (float)v286) < v310) {
        break;
      }
LABEL_318:
      v334 = *v290;
      v335 = (void *)*((void *)*v290 + v9);
      if (v335)
      {
        *int8x16_t v309 = *v335;
      }
      else
      {
        *int8x16_t v309 = v290[2];
        v290[2] = v309;
        v334[v9] = v290 + 2;
        if (!*v309) {
          goto LABEL_327;
        }
        unint64_t v336 = *(void *)(*v309 + 8);
        if ((v286 & (v286 - 1)) != 0)
        {
          if (v336 >= v286) {
            v336 %= v286;
          }
        }
        else
        {
          v336 &= v286 - 1;
        }
        v335 = (char *)*v290 + 8 * v336;
      }
      void *v335 = v309;
LABEL_327:
      v290[3] = (char *)v290[3] + 1;
      uint64_t v10 = a2;
LABEL_328:
      v271 += 3;
      unint64_t v9 = (unint64_t)a3;
      if (v271 >= v239)
      {
        if (v475)
        {
          float64x2_t v345 = vdivq_f64(v471, (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v475), 0));
          unint64_t v31 = a1;
          uint64_t v30 = a4;
          if (v345.f64[0] >= 0.0 && v345.f64[1] >= 0.0)
          {
            uint64_t v346 = *(void *)(v10 + 272);
            v347.i64[0] = v346;
            v347.i64[1] = HIDWORD(v346);
            float64x2_t v345 = vdivq_f64(v345, vcvtq_f64_u64(v347));
          }
          float64x2_t v494 = v345;
        }
        else
        {
          __asm { FMOV            V0.2D, #-1.0 }
          float64x2_t v494 = _Q0;
          unint64_t v31 = a1;
          uint64_t v30 = a4;
        }
        int v352 = (int)__p[1];
        int v353 = DWORD2(v501);
        kdebug_trace();
        v354 = __p[0];
        if (__p[0])
        {
          do
          {
            v355 = (void *)*v354;
            operator delete(v354);
            v354 = v355;
          }
          while (v355);
        }
        v356 = v497[0];
        v497[0] = 0;
        if (v356) {
          operator delete(v356);
        }
        float32x2_t v357 = vcvt_f32_u32(*(uint32x2_t *)&v473);
        float32x2_t v358 = (float32x2_t)vdup_n_s32(0x3E99999Au);
        v359 = (void *)v501;
        if ((void)v501)
        {
          do
          {
            v360 = (void *)*v359;
            operator delete(v359);
            v359 = v360;
          }
          while (v360);
        }
        float32x2_t v361 = vdiv_f32(v357, v358);
        v362 = (void *)v500;
        *(void *)&long long v500 = 0;
        if (v362) {
          operator delete(v362);
        }
        uint32x2_t v496 = vcvt_u32_f32(v361);
        kdebug_trace();
        uint64_t v338 = v31[26];
        if (v239)
        {
          float v363 = (float)(v353 + v352);
          LODWORD(v500) = 0;
          LODWORD(v497[0]) = 0;
          *(void *)v508 = 0;
          float32x2_t v8 = v461;
          float32x4_t v364 = v461[1];
          float32x4_t v365 = v461[2];
          float32x4_t v366 = v461[3];
          float32x4_t v367 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v461, COERCE_FLOAT(*(_OWORD *)v30[2].f32)), v364, v30[2], 1), v365, *(float32x4_t *)v30[2].f32, 2), v366, *(float32x4_t *)v30[2].f32, 3);
          float32x4_t v368 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v461, COERCE_FLOAT(*(_OWORD *)v30[4].f32)), v364, v30[4], 1), v365, *(float32x4_t *)v30[4].f32, 2), v366, *(float32x4_t *)v30[4].f32, 3);
          float32x4_t v369 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v461, COERCE_FLOAT(*(_OWORD *)v30[6].f32)), v364, v30[6], 1), v365, *(float32x4_t *)v30[6].f32, 2), v366, *(float32x4_t *)v30[6].f32, 3);
          float32x4_t v504 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v461, COERCE_FLOAT(*(_OWORD *)v30->f32)), v364, *v30, 1), v365, *(float32x4_t *)v30->f32, 2), v366, *(float32x4_t *)v30->f32, 3);
          float32x4_t v505 = v367;
          float32x4_t v506 = v368;
          float32x4_t v507 = v369;
          BOOL v370 = sub_24B7237E8((float32x4_t *)v10, &v504, (int *)&v500, (int *)v497, &v508[1], v508);
          BOOL v371 = 0;
          if (v370)
          {
            BOOL v371 = (float)(v508[0] - v508[1]) >= (float)*(unsigned int *)(v10 + 272);
            if ((float)(LODWORD(v497[0]) - v500) >= (float)*(unsigned int *)(v10 + 276)) {
              BOOL v371 = 1;
            }
          }
          float v372 = (float)v475 / v363;
          if (*(unsigned char *)(v338 + 8))
          {
            double v373 = v372;
            uint64_t v374 = *(void *)(v338 + 32);
            float64x2_t v375 = v494;
            if (*(unsigned char *)(v374 + 16))
            {
              *(double *)(v374 + 24) = v373;
              *(unsigned char *)(v374 + 16) = 0;
              uint64_t v341 = a6;
              v340 = a7;
              uint64_t v376 = a8;
            }
            else
            {
              if (*(unsigned char *)(v374 + 17))
              {
                double v377 = *(double *)(v374 + 24);
                double v378 = *(double *)(v374 + 32);
              }
              else
              {
                double v377 = *(double *)(v374 + 24);
                double v378 = v373 - v377;
                *(double *)(v374 + 32) = v373 - v377;
                *(unsigned char *)(v374 + 17) = 1;
              }
              uint64_t v341 = a6;
              v340 = a7;
              uint64_t v376 = a8;
              double v379 = *(double *)v374 * v373 + (1.0 - *(double *)v374) * (v377 + v378);
              double v380 = *(double *)(v374 + 8) * (v379 - v377) + (1.0 - *(double *)(v374 + 8)) * v378;
              *(double *)(v374 + 24) = v379;
              *(double *)(v374 + 32) = v380;
              float v381 = v380 + v379;
              float v382 = 1.0;
              if (v381 <= 1.0) {
                float v382 = v381;
              }
              _NF = v381 < 0.0;
              float v372 = 0.0;
              if (!_NF) {
                float v372 = v382;
              }
            }
          }
          else
          {
            uint64_t v341 = a6;
            v340 = a7;
            uint64_t v376 = a8;
            float64x2_t v375 = v494;
          }
          *(unsigned char *)uint64_t v376 = 1;
          *(float *)(v376 + 4) = v372;
          *(float64x2_t *)(v376 + 8) = v375;
          BOOL v383 = *(_DWORD *)(v338 + 44) == 1 && v372 < *(float *)(v338 + 4);
          if (v372 < *(float *)v338) {
            BOOL v383 = 1;
          }
          BOOL v384 = fabsf(v372) <= 0.000001;
          if (v371) {
            int v339 = v384;
          }
          else {
            int v339 = v383;
          }
        }
        else
        {
          int v339 = 1;
          float32x2_t v8 = v461;
          uint64_t v341 = a6;
          v340 = a7;
        }
LABEL_377:
        *(_DWORD *)(v338 + 44) = v339;
        kdebug_trace();
        if (v341 && v340) {
          void *v340 = 0;
        }
        uint64_t v385 = v31[22];
        double v386 = *(double *)(v385 + 88);
        double v387 = *(double *)(v10 + 264);
        uint64_t v238 = v468;
        if (v386 < 0.0)
        {
          *(double *)(v385 + 88) = v387;
          double v386 = v387;
        }
        if (v387 - v386 < 5.0)
        {
LABEL_383:
          *(_DWORD *)(v385 + 96) = 0;
LABEL_446:
          uint64_t v144 = v469;
          return v144 | (v238 << 32);
        }
        float32x4_t v388 = v8[1];
        float32x4_t v389 = v8[2];
        float32x4_t v390 = v8[3];
        float32x4_t v391 = *(float32x4_t *)v30[6].f32;
        float32x4_t v392 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, COERCE_FLOAT(*(_OWORD *)v30[2].f32)), v388, v30[2], 1), v389, *(float32x4_t *)v30[2].f32, 2), v390, *(float32x4_t *)v30[2].f32, 3);
        float32x4_t v393 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, COERCE_FLOAT(*(_OWORD *)v30[4].f32)), v388, v30[4], 1), v389, *(float32x4_t *)v30[4].f32, 2), v390, *(float32x4_t *)v30[4].f32, 3);
        float32x4_t v394 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, v391.f32[0]), v388, *(float32x2_t *)v391.f32, 1), v389, v391, 2);
        float32x4_t v504 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v8, COERCE_FLOAT(*(_OWORD *)v30->f32)), v388, *v30, 1), v389, *(float32x4_t *)v30->f32, 2), v390, *(float32x4_t *)v30->f32, 3);
        float32x4_t v505 = v392;
        float32x4_t v506 = v393;
        float32x4_t v507 = vmlaq_laneq_f32(v394, v390, v391, 3);
        LODWORD(v500) = 0;
        LODWORD(v497[0]) = 0;
        *(void *)v508 = 0;
        int v395 = *(_DWORD *)(v10 + 276);
        int v396 = *(_DWORD *)(v10 + 272);
        BOOL v397 = sub_24B7237E8((float32x4_t *)v10, &v504, (int *)&v500, (int *)v497, &v508[1], v508);
        BOOL v398 = 0;
        if (v397) {
          BOOL v398 = v508[1] < v396 && v508[0] > 0 && (int)v500 < v395 && SLODWORD(v497[0]) > 0;
        }
        if (v496.i32[0] <= 0x14u) {
          BOOL v398 = 0;
        }
        double v402 = (double)v398;
        if (*(unsigned char *)(v385 + 8))
        {
          uint64_t v403 = *(void *)(v385 + 64);
          uint64_t v238 = v468;
          if (*(unsigned char *)(v403 + 16))
          {
            *(double *)(v403 + 24) = v402;
            *(unsigned char *)(v403 + 16) = 0;
          }
          else
          {
            if (*(unsigned char *)(v403 + 17))
            {
              double v404 = *(double *)(v403 + 24);
              double v405 = *(double *)(v403 + 32);
            }
            else
            {
              double v404 = *(double *)(v403 + 24);
              double v405 = v402 - v404;
              *(double *)(v403 + 32) = v402 - v404;
              *(unsigned char *)(v403 + 17) = 1;
            }
            double v406 = *(double *)v403 * v402 + (1.0 - *(double *)v403) * (v404 + v405);
            double v407 = *(double *)(v403 + 8) * (v406 - v404) + (1.0 - *(double *)(v403 + 8)) * v405;
            *(double *)(v403 + 24) = v406;
            *(double *)(v403 + 32) = v407;
            double v408 = v407 + v406;
            if (v408 <= 1.0) {
              double v402 = v408;
            }
            else {
              double v402 = 1.0;
            }
            if (v408 < 0.0) {
              double v402 = 0.0;
            }
          }
        }
        else
        {
          uint64_t v238 = v468;
        }
        BOOL v410 = v402 > 0.5 && *(_DWORD *)(v385 + 96) == 1;
        if (v402 > 0.8 || v410)
        {
          *(_DWORD *)(v385 + 96) = 1;
          goto LABEL_446;
        }
        if (v496.i32[1] >= 0x14u) {
          double v411 = 0.0;
        }
        else {
          double v411 = 1.0;
        }
        if (*(unsigned char *)(v385 + 9))
        {
          uint64_t v412 = *(void *)(v385 + 72);
          if (*(unsigned char *)(v412 + 16))
          {
            *(double *)(v412 + 24) = v411;
            *(unsigned char *)(v412 + 16) = 0;
          }
          else
          {
            if (*(unsigned char *)(v412 + 17))
            {
              double v413 = *(double *)(v412 + 24);
              double v414 = *(double *)(v412 + 32);
            }
            else
            {
              double v413 = *(double *)(v412 + 24);
              double v414 = v411 - v413;
              *(double *)(v412 + 32) = v411 - v413;
              *(unsigned char *)(v412 + 17) = 1;
            }
            double v415 = *(double *)v412 * v411 + (1.0 - *(double *)v412) * (v413 + v414);
            double v416 = *(double *)(v412 + 8) * (v415 - v413) + (1.0 - *(double *)(v412 + 8)) * v414;
            *(double *)(v412 + 24) = v415;
            *(double *)(v412 + 32) = v416;
            double v417 = v416 + v415;
            if (v417 <= 1.0) {
              double v411 = v417;
            }
            else {
              double v411 = 1.0;
            }
            if (v417 < 0.0)
            {
              char v418 = 0;
              double v411 = 0.0;
LABEL_437:
              BOOL v420 = v411 > 0.5 && *(_DWORD *)(v385 + 96) == 2;
              if ((v418 & 1) != 0 || v420)
              {
                *(_DWORD *)(v385 + 96) = 2;
                goto LABEL_446;
              }
              goto LABEL_383;
            }
          }
        }
        if (v411 <= 0.8) {
          char v418 = 0;
        }
        else {
          char v418 = sub_24B7279CC(v385, (float32x4_t *)v10, v30, v8);
        }
        goto LABEL_437;
      }
    }
    BOOL v312 = (v286 & (v286 - 1)) != 0;
    if (v286 < 3) {
      BOOL v312 = 1;
    }
    unint64_t v313 = v312 | (2 * v286);
    unint64_t v314 = vcvtps_u32_f32(v310 / v311);
    if (v313 <= v314) {
      size_t prime = v314;
    }
    else {
      size_t prime = v313;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v286 = (unint64_t)v290[1];
    }
    if (prime <= v286)
    {
      if (prime >= v286) {
        goto LABEL_313;
      }
      unint64_t v327 = vcvtps_u32_f32((float)(unint64_t)v290[3] / *((float *)v290 + 8));
      if (v286 < 3 || (uint8x8_t v328 = (uint8x8_t)vcnt_s8((int8x8_t)v286), v328.i16[0] = vaddlv_u8(v328), v328.u32[0] > 1uLL))
      {
        unint64_t v327 = std::__next_prime(v327);
      }
      else
      {
        uint64_t v329 = 1 << -(char)__clz(v327 - 1);
        if (v327 >= 2) {
          unint64_t v327 = v329;
        }
      }
      if (prime <= v327) {
        size_t prime = v327;
      }
      if (prime >= v286) {
        goto LABEL_313;
      }
      if (!prime)
      {
        float32x2x2_t v333 = *v290;
        const char *v290 = 0;
        if (v333) {
          operator delete(v333);
        }
        v290[1] = 0;
        goto LABEL_313;
      }
    }
    if (prime >> 61) {
      goto LABEL_475;
    }
    int8x16_t v316 = operator new(8 * prime);
    int8x16_t v317 = *v290;
    const char *v290 = v316;
    if (v317) {
      operator delete(v317);
    }
    uint64_t v318 = 0;
    v290[1] = (void *)prime;
    do
      *((void *)*v290 + v318++) = 0;
    while (prime != v318);
    int32x4_t v320 = v290 + 2;
    unsigned int v319 = v290[2];
    if (!v319) {
      goto LABEL_313;
    }
    size_t v321 = v319[1];
    size_t v322 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v323 = v321 & v322;
      *((void *)*v290 + v323) = v320;
      while (1)
      {
        int32x4_t v324 = (void *)*v319;
        if (!*v319) {
          break;
        }
        size_t v325 = v324[1] & v322;
        if (v325 == v323)
        {
          unsigned int v319 = (void *)*v319;
        }
        else if (*((void *)*v290 + v325))
        {
          *unsigned int v319 = *v324;
          uint64_t v326 = 8 * v325;
          *int32x4_t v324 = **(void **)((char *)*v290 + v326);
          **(void **)((char *)*v290 + v326) = v324;
        }
        else
        {
          *((void *)*v290 + v325) = v319;
          unsigned int v319 = v324;
          size_t v323 = v325;
        }
      }
LABEL_313:
      unint64_t v286 = (unint64_t)v290[1];
      if ((v286 & (v286 - 1)) != 0)
      {
        if (v286 <= v300) {
          unint64_t v9 = v300 % v286;
        }
        else {
          unint64_t v9 = v300;
        }
      }
      else
      {
        unint64_t v9 = (v286 - 1) & v300;
      }
      goto LABEL_318;
    }
    if (v321 >= prime) {
      v321 %= prime;
    }
    *((void *)*v290 + v321) = v320;
    int8x16_t v330 = (void *)*v319;
    if (!*v319) {
      goto LABEL_313;
    }
    while (1)
    {
      size_t v332 = v330[1];
      if (v332 >= prime) {
        v332 %= prime;
      }
      if (v332 != v321)
      {
        if (!*((void *)*v290 + v332))
        {
          *((void *)*v290 + v332) = v319;
          goto LABEL_299;
        }
        *unsigned int v319 = *v330;
        uint64_t v331 = 8 * v332;
        *int8x16_t v330 = **(void **)((char *)*v290 + v331);
        **(void **)((char *)*v290 + v331) = v330;
        int8x16_t v330 = v319;
      }
      size_t v332 = v321;
LABEL_299:
      unsigned int v319 = v330;
      int8x16_t v330 = (void *)*v330;
      size_t v321 = v332;
      if (!v330) {
        goto LABEL_313;
      }
    }
  }
  return v144 | (v238 << 32);
}

uint64_t OCDataBufferGetTypeID()
{
  return MEMORY[0x270EEA058]();
}

uint64_t OCDataBufferGetIOSurface(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  int v1 = MEMORY[0x24C5D7200]();
  if (v1 != 2021227107 && v1 != 1278227250) {
    return 0;
  }
  return CVDataBufferGetIOSurface();
}

uint64_t OCDataBufferGetBytesPerData(uint64_t result)
{
  if (result)
  {
    int v1 = MEMORY[0x24C5D7200]();
    if (v1 == 1278227250 || v1 == 2021227107) {
      int v3 = v1;
    }
    else {
      int v3 = 0;
    }
    if (v3 == 2021227107) {
      return 48;
    }
    else {
      return 4 * (v3 == 1278227250);
    }
  }
  return result;
}

uint64_t OCDataBufferGetDataFormatType(uint64_t result)
{
  if (result)
  {
    LODWORD(result) = MEMORY[0x24C5D7200]();
    if (result == 1278227250 || result == 2021227107) {
      return result;
    }
    else {
      return 0;
    }
  }
  return result;
}

unint64_t OCDataBufferGetSize(unint64_t result)
{
  if (result)
  {
    unint64_t v1 = result;
    int v2 = MEMORY[0x24C5D7200]();
    if (v2 == 1278227250 || v2 == 2021227107) {
      int v4 = v2;
    }
    else {
      int v4 = 0;
    }
    if (v4 == 2021227107) {
      unint64_t v5 = 48;
    }
    else {
      unint64_t v5 = 4 * (v4 == 1278227250);
    }
    int v6 = MEMORY[0x24C5D7200](v1);
    if (v6 == 2021227107 || v6 == 1278227250)
    {
      unint64_t DataSize = CVDataBufferGetDataSize();
      if (v5) {
        return DataSize / v5;
      }
    }
    else
    {
      unint64_t DataSize = 0;
      if (v5) {
        return DataSize / v5;
      }
    }
    return 0;
  }
  return result;
}

uint64_t OCDataBufferGetDataSize(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  int v1 = MEMORY[0x24C5D7200]();
  if (v1 != 2021227107 && v1 != 1278227250) {
    return 0;
  }
  return CVDataBufferGetDataSize();
}

char *OCDataBufferGetDataAt(char *result, unint64_t a2)
{
  if (result)
  {
    int v3 = result;
    int v4 = MEMORY[0x24C5D7200]();
    if (v4 == 1278227250 || v4 == 2021227107) {
      int v6 = v4;
    }
    else {
      int v6 = 0;
    }
    if (v6 == 2021227107) {
      unint64_t v7 = 48;
    }
    else {
      unint64_t v7 = 4 * (v6 == 1278227250);
    }
    int v8 = MEMORY[0x24C5D7200](v3);
    if (v8 == 2021227107 || v8 == 1278227250)
    {
      unint64_t DataSize = CVDataBufferGetDataSize();
      if (!v7) {
        return 0;
      }
    }
    else
    {
      unint64_t DataSize = 0;
      if (!v7) {
        return 0;
      }
    }
    if (DataSize / v7 > a2)
    {
      int v10 = MEMORY[0x24C5D7200](v3);
      if (v10 == 1278227250 || v10 == 2021227107) {
        int v12 = v10;
      }
      else {
        int v12 = 0;
      }
      int v13 = MEMORY[0x24C5D7200](v3);
      if (v13 == 2021227107 || v13 == 1278227250) {
        IOSurface = (__IOSurface *)CVDataBufferGetIOSurface();
      }
      else {
        IOSurface = 0;
      }
      BaseAddress = (char *)IOSurfaceGetBaseAddress(IOSurface);
      if (v12 == 1278227250) {
        return &BaseAddress[4 * a2];
      }
      if (v12 == 2021227107) {
        return &BaseAddress[48 * a2];
      }
    }
    return 0;
  }
  return result;
}

void *OCDataBufferGetBaseAddress(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  int v2 = MEMORY[0x24C5D7200]();
  if (v2 != 2021227107 && v2 != 1278227250) {
    return 0;
  }
  int v3 = MEMORY[0x24C5D7200](a1);
  int v4 = MEMORY[0x24C5D7200](a1);
  if (v4 != 2021227107 && v4 != 1278227250) {
    return 0;
  }
  if (v3 != 1278227250 && v3 != 2021227107) {
    int v3 = 0;
  }
  if (v3 == 1278227250) {
    uint64_t v6 = 3;
  }
  else {
    uint64_t v6 = -1;
  }
  unint64_t DataSize = CVDataBufferGetDataSize();
  unint64_t v8 = 47;
  if (v3 != 2021227107) {
    unint64_t v8 = v6;
  }
  if (v8 >= DataSize) {
    return 0;
  }
  int v9 = MEMORY[0x24C5D7200](a1);
  if (v9 == 2021227107 || v9 == 1278227250) {
    IOSurface = (__IOSurface *)CVDataBufferGetIOSurface();
  }
  else {
    IOSurface = 0;
  }
  return IOSurfaceGetBaseAddress(IOSurface);
}

uint64_t OCDataBufferCreateWithIOSurface(uint64_t a1, const void *a2, uint64_t a3, int a4)
{
  if (!a3) {
    return 4294960615;
  }
  if (!a2 || a4 != 2021227107 && a4 != 1278227250) {
    return 4294960635;
  }
  IOSurfaceRef buffer = 0;
  uint64_t v5 = 48;
  if (a4 != 2021227107) {
    uint64_t v5 = 4 * (a4 == 1278227250);
  }
  size_t v6 = v5 * a3;
  uint64_t v7 = sub_24B6BC870(a4, v5 * a3, &buffer);
  if (!v7)
  {
    BaseAddress = IOSurfaceGetBaseAddress(buffer);
    memcpy(BaseAddress, a2, v6);
    uint64_t v7 = CVDataBufferCreateWithIOSurface();
    CFRelease(buffer);
  }
  return v7;
}

const void *OCDataBufferRetain(const void *a1)
{
  int v1 = a1;
  if (a1)
  {
    int v2 = MEMORY[0x24C5D7200](a1);
    if (v2 == 2021227107 || v2 == 1278227250) {
      CFRetain(v1);
    }
    else {
      return 0;
    }
  }
  return v1;
}

void OCDataBufferRelease(const void *a1)
{
  if (a1)
  {
    int v2 = MEMORY[0x24C5D7200]();
    if (v2 == 2021227107 || v2 == 1278227250)
    {
      CFRelease(a1);
    }
  }
}

uint64_t OCImageFilterBilateralCreate(uint64_t a1, void *a2)
{
  uint64_t result = 4294967294;
  if (a1 && a2)
  {
    if (*(_DWORD *)a1 > 1u
      || (*(void *)(a1 + 8) >= 2uLL ? (BOOL v5 = (*(void *)(a1 + 8) & 1) == 0) : (BOOL v5 = 1),
          v5 || *(float *)(a1 + 20) <= 0.0 || *(float *)(a1 + 16) <= 0.0))
    {
      if (qword_2697D0E38 != -1) {
        dispatch_once(&qword_2697D0E38, &unk_26FE9C920);
      }
      int v9 = qword_2697D0E30;
      if (os_log_type_enabled((os_log_t)qword_2697D0E30, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_24B6B9000, v9, OS_LOG_TYPE_ERROR, "Failed to create Bilateral Filter, invalid filter configuration parameters", buf, 2u);
      }
    }
    else
    {
      size_t v6 = operator new(0x10uLL, MEMORY[0x263F8C180]);
      if (!v6) {
        return 4294967293;
      }
      uint64_t v7 = v6;
      void *v6 = 0;
      v6[1] = 0;
      sub_24B6C123C(&v10, (_DWORD *)a1);
      uint64_t v8 = v10;
      void *v7 = v10;
      if (v8)
      {
        uint64_t result = 0;
        *((_DWORD *)v7 + 2) = *(_DWORD *)a1;
        *a2 = v7;
        return result;
      }
      OCImageFilterDestroy(v7);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

void sub_24B6C123C(void *a1, _DWORD *a2)
{
  if (*a2 == 1) {
    operator new();
  }
  if (!*a2) {
    operator new();
  }
  if (qword_2697D0E38 != -1) {
    dispatch_once(&qword_2697D0E38, &unk_26FE9C920);
  }
  int v3 = qword_2697D0E30;
  if (os_log_type_enabled((os_log_t)qword_2697D0E30, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v4 = 0;
    _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "Invalid filter-type!", v4, 2u);
  }
  *a1 = 0;
}

uint64_t OCImageFilterDestroy(uint64_t *a1)
{
  if (!a1) {
    return 4294967294;
  }
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  MEMORY[0x24C5D7790](a1, 0x1020C403A5D3213);
  if (qword_2697D0E38 != -1) {
    dispatch_once(&qword_2697D0E38, &unk_26FE9C920);
  }
  int v3 = qword_2697D0E30;
  uint64_t result = os_log_type_enabled((os_log_t)qword_2697D0E30, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    *(_WORD *)BOOL v5 = 0;
    _os_log_debug_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_DEBUG, "Destroyed OCImageFilter handle", v5, 2u);
    return 0;
  }
  return result;
}

uint64_t sub_24B6C1654()
{
  qword_2697D0E30 = (uint64_t)os_log_create("com.apple.CoreOCModules", "General");
  return MEMORY[0x270F9A758]();
}

uint64_t OCImageFilterStart(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 4294967294;
  }
}

uint64_t OCImageFilterStop(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 4294967294;
  }
}

uint64_t OCImageFilterApplyFilter(uint64_t *a1, CVPixelBufferRef pixelBuffer, __CVBuffer *a3)
{
  uint64_t result = 4294967294;
  if (a1 && pixelBuffer && a3)
  {
    if (*((_DWORD *)a1 + 2) == 1)
    {
      return 4294967294;
    }
    else
    {
      uint64_t v7 = *a1;
      size_t Width = CVPixelBufferGetWidth(pixelBuffer);
      size_t Height = CVPixelBufferGetHeight(pixelBuffer);
      OSType PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
      OSType v11 = CVPixelBufferGetPixelFormatType(a3);
      BOOL v13 = PixelFormatType != 1717855600 && PixelFormatType != 1278226534;
      char v14 = PixelFormatType != v11 || v13;
      if (Width
        && Height
        && Width == CVPixelBufferGetWidth(a3)
        && ((size_t v15 = CVPixelBufferGetHeight(a3), !v7) ? (v16 = 1) : (v16 = v14), (v16 & 1) == 0 && Height == v15))
      {
        CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
        BaseAddress = CVPixelBufferGetBaseAddress(pixelBuffer);
        CVPixelBufferLockBaseAddress(a3, 0);
        *(void *)buf = &unk_26FE9CDB0;
        uint64_t v26 = BaseAddress;
        unint64_t v27 = CVPixelBufferGetBaseAddress(a3);
        v28.i64[0] = CVPixelBufferGetWidth(pixelBuffer);
        v28.i64[1] = CVPixelBufferGetHeight(pixelBuffer);
        size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
        context[1] = v7;
        context[2] = 20;
        context[0] = buf;
        __asm { FMOV            V1.2S, #20.0 }
        float32x2_t v22 = vrndp_f32(vdiv_f32(vcvt_f32_f64(vcvtq_f64_u64(v28)), _D1));
        dispatch_apply_f((unint64_t)vmul_lane_f32(v22, v22, 1).f32[0], 0, context, (void (__cdecl *)(void *, size_t))sub_24B6C18FC);
        CVPixelBufferUnlockBaseAddress(a3, 0);
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
        return 0;
      }
      else
      {
        if (qword_2697D0E38 != -1) {
          dispatch_once(&qword_2697D0E38, &unk_26FE9C920);
        }
        uint64_t v23 = qword_2697D0E30;
        if (os_log_type_enabled((os_log_t)qword_2697D0E30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_24B6B9000, v23, OS_LOG_TYPE_ERROR, "Failed to apply bilateral filter to input image", buf, 2u);
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}

uint64_t sub_24B6C18FC(uint64_t result, unint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result;
    unint64_t v3 = *(void *)(result + 16);
    if (v3)
    {
      int v4 = *(void **)result;
      unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(*(void *)result + 24) / (float)v3);
      if (v5 * vcvtps_u32_f32((float)*(unint64_t *)(*(void *)result + 32) / (float)v3) > a2)
      {
        unint64_t v6 = a2 / v5;
        unint64_t v7 = a2 % v5;
        unint64_t v8 = v7 * v3;
        unint64_t v9 = v7 * v3 + v3;
        unint64_t v10 = v6 * v3;
        unint64_t v11 = v6 * v3 + v3;
        if (v6 * v3 < v11 && v8 < v9)
        {
          do
          {
            unint64_t v13 = v4[2] + v4[5] * v10;
            unint64_t v14 = v8;
            do
            {
              if (v14 < v4[3] && v10 < v4[4])
              {
                uint64_t result = (*(uint64_t (**)(void, void *, unint64_t, unint64_t))(**(void **)(v2 + 8) + 24))(*(void *)(v2 + 8), v4, v14, v10);
                if ((result & 0xFF00000000) != 0) {
                  *(_DWORD *)(v13 + 4 * v14) = result;
                }
              }
              ++v14;
            }
            while (v14 != v9);
            ++v10;
          }
          while (v10 != v11);
        }
      }
    }
  }
  return result;
}

uint64_t OCImageFilterApplyCrossBilateralFilter(uint64_t *a1, CVPixelBufferRef pixelBuffer, __CVBuffer *a3, __CVBuffer *a4)
{
  uint64_t result = 4294967294;
  if (a1 && pixelBuffer && a3 && a4)
  {
    if (*((_DWORD *)a1 + 2) == 1)
    {
      uint64_t v9 = *a1;
      size_t Width = CVPixelBufferGetWidth(pixelBuffer);
      size_t Height = CVPixelBufferGetHeight(pixelBuffer);
      OSType PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
      OSType v13 = CVPixelBufferGetPixelFormatType(a4);
      BOOL v15 = PixelFormatType != 1717855600 && PixelFormatType != 1278226534;
      int v16 = PixelFormatType != v13 || v15;
      OSType v17 = CVPixelBufferGetPixelFormatType(a3);
      BOOL v18 = Width != CVPixelBufferGetWidth(a3) || Width != CVPixelBufferGetWidth(a4);
      BOOL v19 = Height != CVPixelBufferGetHeight(a3) || Height != CVPixelBufferGetHeight(a4);
      if (v9) {
        BOOL v20 = Width == 0;
      }
      else {
        BOOL v20 = 1;
      }
      int v22 = v20 || Height == 0 || v18;
      int v23 = v22 | v19 | v16;
      if (v17 == 875704422) {
        int v24 = v23;
      }
      else {
        int v24 = 1;
      }
      if ((v24 & 1) == 0)
      {
        CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
        BaseAddress = CVPixelBufferGetBaseAddress(pixelBuffer);
        CVPixelBufferLockBaseAddress(a3, 1uLL);
        BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a3, 0);
        CVPixelBufferLockBaseAddress(a4, 0);
        long long v36 = BaseAddressOfPlane;
        v33[0] = &unk_26FE9CDD8;
        v33[1] = BaseAddress;
        v33[2] = CVPixelBufferGetBaseAddress(a4);
        v34.i64[0] = CVPixelBufferGetWidth(pixelBuffer);
        v34.i64[1] = CVPixelBufferGetHeight(pixelBuffer);
        size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
        size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a3, 0);
        context[1] = v9;
        context[2] = 20;
        context[0] = v33;
        __asm { FMOV            V1.2S, #20.0 }
        float32x2_t v31 = vrndp_f32(vdiv_f32(vcvt_f32_f64(vcvtq_f64_u64(v34)), _D1));
        dispatch_apply_f((unint64_t)vmul_lane_f32(v31, v31, 1).f32[0], 0, context, (void (__cdecl *)(void *, size_t))sub_24B6C18FC);
        CVPixelBufferUnlockBaseAddress(a4, 0);
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
      }
      return (v24 << 31 >> 31);
    }
    else
    {
      return 4294967294;
    }
  }
  return result;
}

uint64_t OCExplicitFeedbackCreate(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v3 = operator new(8uLL, MEMORY[0x263F8C180]);
    if (v3) {
      void *v3 = 0;
    }
    if (a1) {
      operator new();
    }
    operator new();
  }
  return 0xFFFFFFFFLL;
}

void sub_24B6C24EC(_Unwind_Exception *a1)
{
  uint64_t shared_owners = v2[2].__shared_owners_;
  v2[2].__shared_owners_ = 0;
  if (shared_owners) {
    MEMORY[0x24C5D7790](shared_owners, 0x1000C40FA9F20B1);
  }
  std::__shared_weak_count::~__shared_weak_count(v2);
  operator delete(v5);
  unint64_t v6 = (std::__shared_weak_count *)v1[27];
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  unint64_t v7 = (std::__shared_weak_count *)v1[25];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  unint64_t v8 = (std::__shared_weak_count *)v1[23];
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)v1[21];
  if (v9)
  {
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  MEMORY[0x24C5D7790](v1, 0x1020C40683E84EFLL);
  _Unwind_Resume(a1);
}

void *sub_24B6C2684(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[27];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    unint64_t v3 = (std::__shared_weak_count *)a1[25];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    unint64_t v3 = (std::__shared_weak_count *)a1[25];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  int v4 = (std::__shared_weak_count *)a1[23];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    unint64_t v5 = (std::__shared_weak_count *)a1[21];
    if (!v5) {
      return a1;
    }
  }
  else
  {
    unint64_t v5 = (std::__shared_weak_count *)a1[21];
    if (!v5) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1;
}

uint64_t OCExplicitFeedbackDestroy(void **a1)
{
  if (!a1) {
    return 4294967294;
  }
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    unint64_t v3 = sub_24B6C2684(v2);
    MEMORY[0x24C5D7790](v3, 0x1020C40683E84EFLL);
  }
  MEMORY[0x24C5D7790](a1, 0x20C4093837F09);
  return 0;
}

uint64_t OCExplicitFeedbackStart(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t OCExplicitFeedbackStop(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t OCExplicitFeedbackProcess(void *a1, uint64_t a2, uint64_t *a3, float32x2_t *a4, uint64_t a5, int *a6, uint64_t a7, void *a8, uint64_t a9)
{
  if (!a1) {
    return 4294967294;
  }
  if (a9) {
    _ZF = a6 == 0;
  }
  else {
    _ZF = 1;
  }
  BOOL v12 = _ZF || *a1 == 0;
  if (v12 || a4 && !sub_24B6ED7CC((uint64_t)a4)) {
    return 4294967294;
  }
  if (a5)
  {
    float32x4_t v19 = *(float32x4_t *)a5;
    float32x4_t v20 = *(float32x4_t *)(a5 + 16);
    float32x4_t v21 = *(float32x4_t *)(a5 + 32);
    float32x4_t v22 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
    float32x4_t v23 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
    float32x4_t v24 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
    uint32x4_t v25 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v19, *(float32x2_t *)v19.f32, 1), v20, *(float32x2_t *)v20.f32, 1), v21, *(float32x2_t *)v21.f32, 1), v22)), (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v19, v19.f32[0]), v20, v20.f32[0]),
                                           v21,
                                           v21.f32[0]),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v19, v19, 2), v20, v20, 2), v21, v21, 2), v23)));
    v25.i32[3] = v25.i32[2];
    if ((vminvq_u32(v25) & 0x80000000) == 0) {
      return 4294967294;
    }
    float32x4_t v26 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2);
    float32x4_t v27 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v19, (int32x4_t)v21), (int32x4_t)v26);
    float32x4_t v28 = (float32x4_t)vtrn2q_s32((int32x4_t)v19, (int32x4_t)v20);
    v28.i32[2] = HIDWORD(*(void *)(a5 + 32));
    float32x4_t v29 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v19, (int32x4_t)v21), (int32x4_t)v20);
    uint32x4_t v30 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v29, v20.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1), v28), v26, v27), v22)), (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v29, v19.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1),
                                             v28),
                                           (float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2),
                                           v27),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v29, v21.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1), v28), (float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), v27), v23)));
    v30.i32[3] = v30.i32[2];
    if ((vminvq_u32(v30) & 0x80000000) == 0) {
      return 4294967294;
    }
    float32x4_t v31 = vmulq_f32(v19, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v21, (int8x16_t)v21, 0xCuLL), (int8x16_t)v21, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), (int8x16_t)v21, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v20, (int8x16_t)v20, 0xCuLL), (int8x16_t)v20, 8uLL)));
    if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1))).f32[0]+ -1.0) > 0.000011)return 4294967294; {
    float32x2_t v32 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v19, (int8x16_t)v19, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL)));
    }
    float32x2_t v33 = (float32x2_t)vdup_n_s32(0x38D1B717u);
    uint32x2_t v34 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v33, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a5 + 48), *(int8x16_t *)(a5 + 48), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v33, v32));
    if ((vpmin_u32(v34, v34).u32[0] & 0x80000000) == 0) {
      return 4294967294;
    }
  }
  if (a3
    && (!*a3 || MEMORY[0x24C5D7200]() != 2021227107 || !sub_24B6ED7CC((uint64_t)(a3 + 2))))
  {
    return 4294967294;
  }
  int v35 = *(_DWORD *)(a2 + 152);
  uint64_t v36 = *(void *)(a2 + 144);
  CVPixelBufferRef v81 = *(CVPixelBufferRef *)a2;
  long long v37 = *(_OWORD *)(a2 + 48);
  long long v83 = *(_OWORD *)(a2 + 32);
  long long v84 = v37;
  long long v38 = *MEMORY[0x263EF89A0];
  long long v39 = *(_OWORD *)(MEMORY[0x263EF89A0] + 16);
  simd_float4 v40 = *(simd_float4 *)(a2 + 80);
  long long v85 = *(_OWORD *)(a2 + 64);
  long long v86 = v38;
  long long v41 = *(_OWORD *)(MEMORY[0x263EF89A0] + 32);
  long long v87 = v39;
  long long v88 = v41;
  simd_float4 v42 = *(simd_float4 *)(a2 + 128);
  simd_float4 v43 = *(simd_float4 *)(a2 + 96);
  simd_float4 v91 = *(simd_float4 *)(a2 + 112);
  simd_float4 v92 = v42;
  long long v82 = *(_OWORD *)(a2 + 8);
  simd_float4 v89 = v40;
  simd_float4 v90 = v43;
  int v94 = v35;
  uint64_t v95 = v36;
  int v98 = 0;
  v99.columns[2] = v91;
  v99.columns[3] = v92;
  v99.columns[0] = v40;
  v99.columns[1] = v43;
  simd_float4x4 v93 = __invert_f4(v99);
  unsigned int Width = CVPixelBufferGetWidth(v81);
  unsigned int v96 = Width;
  uint64_t Height = CVPixelBufferGetHeight(v81);
  if ((void)v82)
  {
    HIDWORD(Height) = CVPixelBufferGetWidth((CVPixelBufferRef)v82);
    int v98 = CVPixelBufferGetHeight((CVPixelBufferRef)v82);
    float v44 = (float)HIDWORD(Height) / (float)Width;
    float v45 = *(float *)(a2 + 32) * v44;
    float v46 = *(float *)(a2 + 52) * v44;
    long long v47 = *MEMORY[0x263EF89A0];
    long long v48 = *(_OWORD *)(MEMORY[0x263EF89A0] + 16);
    DWORD2(v86) = *(void *)(MEMORY[0x263EF89A0] + 8);
    *(float *)&long long v47 = v45;
    long long v49 = *(_OWORD *)(a2 + 64);
    DWORD2(v87) = DWORD2(v48);
    *((float *)&v48 + 1) = v46;
    *(void *)&long long v86 = v47;
    *(void *)&long long v87 = v48;
    DWORD2(v88) = *(_DWORD *)(MEMORY[0x263EF89A0] + 40);
    *(float32x2_t *)&long long v88 = vmul_n_f32(*(float32x2_t *)&v49, v44);
  }
  v78[0] = 0;
  int v79 = -1082130432;
  __asm { FMOV            V0.2D, #-1.0 }
  long long v80 = _Q0;
  if (a3)
  {
    memset(v77, 0, 32);
    uint64_t v54 = *a3;
    if (*a3)
    {
      int v55 = MEMORY[0x24C5D7200](*a3);
      if (v55 == 1278227250 || v55 == 2021227107) {
        int v57 = v55;
      }
      else {
        int v57 = 0;
      }
      uint64_t v58 = 4 * (v57 == 1278227250);
      _ZF = v57 == 2021227107;
      uint64_t v59 = 48;
      if (!_ZF) {
        uint64_t v59 = v58;
      }
      unint64_t v76 = v59;
      int v60 = MEMORY[0x24C5D7200](v54);
      if (v60 == 2021227107 || v60 == 1278227250) {
        unint64_t DataSize = CVDataBufferGetDataSize();
      }
      else {
        unint64_t DataSize = 0;
      }
      LODWORD(v65) = v76;
      if (v76) {
        unint64_t v65 = DataSize / v76;
      }
    }
    else
    {
      LODWORD(v65) = 0;
    }
    LODWORD(v77[0]) = v65;
    *((void *)&v77[0] + 1) = OCDataBufferGetBaseAddress(*a3);
    long long v66 = *((_OWORD *)a3 + 2);
    v77[2] = *((_OWORD *)a3 + 1);
    v77[3] = v66;
    long long v67 = *((_OWORD *)a3 + 4);
    v77[4] = *((_OWORD *)a3 + 3);
    v77[5] = v67;
    uint64_t v63 = (void *)*a1;
    uint64_t v64 = (float32x4_t *)v77;
  }
  else
  {
    uint64_t v63 = (void *)*a1;
    uint64_t v64 = 0;
  }
  uint64_t v68 = sub_24B6BEA80(v63, (uint64_t)&v81, v64, a4, (float32x4_t *)a5, a7, a8, (uint64_t)v78);
  int v71 = v79;
  *(unsigned char *)a9 = v78[0];
  *(_DWORD *)(a9 + 4) = v71;
  *(_OWORD *)(a9 + 8) = v80;
  int v72 = v68 == 1;
  *a6 = v72;
  if (HIDWORD(v68) == 1)
  {
    int v73 = 2;
  }
  else
  {
    if (HIDWORD(v68) != 2) {
      goto LABEL_48;
    }
    int v73 = 32;
  }
  v72 |= v73;
  *a6 = v72;
LABEL_48:
  if (v70 == 2)
  {
    int v74 = 4;
    goto LABEL_52;
  }
  if (v70 == 1)
  {
    int v74 = 8;
LABEL_52:
    v72 |= v74;
    *a6 = v72;
  }
  if (v69 == 1) {
    *a6 = v72 | 0x10;
  }
  return 0;
}

uint64_t OCSignPostsSubclass()
{
  return 181;
}

uint64_t OCSignPostsTrackCodeOffsetForCoreOC()
{
  return 1000;
}

uint64_t OCSignPostsAriadneDbgCode(__int16 a1)
{
  return (4 * a1 + 4000) & 0xFFFC | 0x2BB50000u;
}

uint64_t OCFrameSelectionCreate(uint64_t a1, uint64_t a2)
{
  uint64_t result = 4294967294;
  if (a1)
  {
    if (a2) {
      operator new();
    }
  }
  return result;
}

void sub_24B6C3250(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_2697D1358);
  MEMORY[0x24C5D7790](v1, 0x10E1C40B06222C9);
  _Unwind_Resume(a1);
}

uint64_t OCFrameSelectionStart(uint64_t a1)
{
  if (!a1) {
    return 4294967294;
  }
  uint64_t result = 0;
  int32x4_t v3 = vdupq_n_s32(0x7F7FFFFFu);
  *(int32x4_t *)(a1 + 8) = v3;
  *(int32x4_t *)(a1 + 24) = v3;
  *(void *)(a1 + 40) = v3.i64[0];
  *(_DWORD *)(a1 + 48) = 0;
  return result;
}

BOOL OCFrameSelectionIsSharpFrame(uint64_t a1, CVPixelBufferRef pixelBuffer, float *a3, double a4, double a5, double a6, double a7)
{
  BOOL result = 0;
  if (!a1 || !pixelBuffer) {
    return result;
  }
  if (*(void *)a1)
  {
    size_t Width = CVPixelBufferGetWidth(pixelBuffer);
    size_t Height = CVPixelBufferGetHeight(pixelBuffer);
    (***(void (****)(void, CVPixelBufferRef, unint64_t, unint64_t, unint64_t, unint64_t))a1)(*(void *)a1, pixelBuffer, (unint64_t)(a4 * ((double)Width + -1.0) + 0.5), (unint64_t)(a5 * ((double)Height + -1.0) + 0.5), (unint64_t)a6, (unint64_t)a7);
  }
  else
  {
    float v17 = 0.0;
  }
  uint64_t v18 = *(unsigned int *)(a1 + 48);
  *(float *)(a1 + 8 + 4 * v18) = v17;
  *(_DWORD *)(a1 + 48) = ((int)v18 + 1) % 0xAu;
  long long v19 = *(_OWORD *)(a1 + 24);
  v74[0] = *(_OWORD *)(a1 + 8);
  v74[1] = v19;
  uint64_t v75 = *(void *)(a1 + 40);
  float32x4_t v20 = (float *)v74;
  float32x4_t v21 = (char *)&v76;
  do
  {
    unint64_t v22 = (v21 - (char *)v20) >> 2;
    if (v22 < 2) {
      break;
    }
    if (v22 == 3)
    {
      float v57 = *v20;
      float v58 = v20[1];
      float v59 = *((float *)v21 - 1);
      if (v58 <= *v20)
      {
        if (v59 > v58)
        {
          v20[1] = v59;
          *((float *)v21 - 1) = v58;
          float v71 = *v20;
          float v70 = v20[1];
          if (v70 > *v20)
          {
            float *v20 = v70;
            v20[1] = v71;
          }
        }
      }
      else
      {
        if (v59 <= v58)
        {
          float *v20 = v58;
          v20[1] = v57;
          float v72 = *((float *)v21 - 1);
          if (v72 <= v57) {
            break;
          }
          v20[1] = v72;
        }
        else
        {
          float *v20 = v59;
        }
        *((float *)v21 - 1) = v57;
      }
      break;
    }
    if (v22 == 2)
    {
      float v60 = *((float *)v21 - 1);
      float v61 = *v20;
      if (v60 > *v20)
      {
        float *v20 = v60;
        *((float *)v21 - 1) = v61;
      }
      break;
    }
    if (v21 - (char *)v20 <= 31)
    {
      while (v20 != (float *)(v21 - 4))
      {
        unint64_t v62 = v20++;
        if (v62 != (float *)v21 && v20 != (float *)v21)
        {
          float v63 = *v62;
          float v64 = *v62;
          unint64_t v65 = v20;
          long long v66 = v62;
          long long v67 = v20;
          do
          {
            float v68 = *v67++;
            float v69 = v68;
            if (v68 > v64)
            {
              float v64 = v69;
              long long v66 = v65;
            }
            unint64_t v65 = v67;
          }
          while (v67 != (float *)v21);
          if (v66 != v62)
          {
            float *v62 = *v66;
            *long long v66 = v63;
          }
        }
      }
      break;
    }
    float32x4_t v23 = &v20[v22 >> 1];
    float32x4_t v24 = (float *)(v21 - 4);
    float v25 = *((float *)v21 - 1);
    float v26 = *v23;
    float v27 = *v20;
    if (*v23 > *v20)
    {
      if (v25 <= v26)
      {
        float *v20 = v26;
        *float32x4_t v23 = v27;
        if (*v24 > v27)
        {
          *float32x4_t v23 = *v24;
          float *v24 = v27;
          goto LABEL_19;
        }
      }
      else
      {
        float *v20 = v25;
        float *v24 = v27;
      }
LABEL_20:
      int v29 = 1;
      goto LABEL_22;
    }
    if (v25 > v26)
    {
      *float32x4_t v23 = v25;
      float *v24 = v26;
      float v28 = *v20;
      if (*v23 > *v20)
      {
        float *v20 = *v23;
        *float32x4_t v23 = v28;
LABEL_19:
        int v29 = 2;
        goto LABEL_22;
      }
      goto LABEL_20;
    }
    int v29 = 0;
LABEL_22:
    float v30 = *v20;
    if (*v20 > *v23)
    {
LABEL_27:
      int v35 = v20 + 1;
      if (v20 + 1 >= v24)
      {
        long long v38 = v20 + 1;
      }
      else
      {
        uint64_t v36 = v20 + 1;
        while (1)
        {
          float v37 = *v23;
          do
          {
            long long v38 = v36;
            float v39 = *v36++;
            float v40 = v39;
          }
          while (v39 > v37);
          do
          {
            float v41 = *--v24;
            float v42 = v41;
          }
          while (v41 <= v37);
          if (v38 >= v24) {
            break;
          }
          *long long v38 = v42;
          float *v24 = v40;
          ++v29;
          if (v23 == v38) {
            float32x4_t v23 = v24;
          }
        }
      }
      if (v38 != v23)
      {
        int v43 = *(_DWORD *)v38;
        if (*v23 > *v38)
        {
          *long long v38 = *v23;
          *(_DWORD *)float32x4_t v23 = v43;
          ++v29;
        }
      }
      if (v38 == (float *)((char *)v74 + 4)) {
        break;
      }
      if (!v29)
      {
        if (v38 <= (float *)v74 + 1)
        {
          long long v49 = v38 + 1;
          while (v49 != (float *)v21)
          {
            float v51 = *(v49 - 1);
            float v50 = *v49++;
            if (v50 > v51) {
              goto LABEL_42;
            }
          }
        }
        else
        {
          while (v35 != v38)
          {
            float v46 = *(v35 - 1);
            float v45 = *v35++;
            if (v45 > v46) {
              goto LABEL_42;
            }
          }
        }
        break;
      }
LABEL_42:
      if (v38 <= (float *)v74 + 1) {
        float v44 = v38 + 1;
      }
      else {
        float v44 = v20;
      }
      if (v38 > (float *)v74 + 1) {
        float32x4_t v21 = (char *)v38;
      }
    }
    else
    {
      float32x4_t v31 = (float *)(v21 - 8);
      while (v31 != v20)
      {
        float32x2_t v32 = v31;
        float v33 = *v31--;
        float v34 = v33;
        if (v33 > *v23)
        {
          float *v20 = v34;
          float *v32 = v30;
          ++v29;
          float32x4_t v24 = v32;
          goto LABEL_27;
        }
      }
      long long v47 = v20 + 1;
      if (v30 <= *v24)
      {
        if (v47 == v24) {
          break;
        }
        while (1)
        {
          float v48 = *v47;
          if (v30 > *v47) {
            break;
          }
          if (++v47 == v24) {
            goto LABEL_94;
          }
        }
        *v47++ = *v24;
        float *v24 = v48;
      }
      if (v47 == v24) {
        break;
      }
      while (1)
      {
        float v52 = *v20;
        do
        {
          float v44 = v47;
          float v53 = *v47++;
          float v54 = v53;
        }
        while (v52 <= v53);
        do
        {
          float v55 = *--v24;
          float v56 = v55;
        }
        while (v52 > v55);
        if (v44 >= v24) {
          break;
        }
        *float v44 = v56;
        float *v24 = v54;
      }
      if (v44 > (float *)v74 + 1) {
        break;
      }
    }
    float32x4_t v20 = v44;
  }
  while (v21 != (char *)v74 + 4);
LABEL_94:
  float v73 = *((float *)v74 + 1);
  if (a3)
  {
    *a3 = v17;
    a3[1] = v73;
  }
  return v17 >= v73;
}

double OCFrameSelectionCalculateImageSharpness(void (****a1)(void), CVPixelBufferRef pixelBuffer)
{
  if (!a1 || !pixelBuffer || !*a1) {
    return 0.0;
  }
  CVPixelBufferGetWidth(pixelBuffer);
  CVPixelBufferGetHeight(pixelBuffer);
  int v4 = ***a1;
  v4();
  return result;
}

uint64_t OCFrameSelectionStop(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 4294967294;
  }
}

uint64_t OCFrameSelectionDestroy(uint64_t *a1)
{
  if (!a1) {
    return 4294967294;
  }
  uint64_t v2 = *a1;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
  }
  MEMORY[0x24C5D7790](a1, 0x1020C403357C6A3);
  return 0;
}

BOOL OCNonModularSPI_CoreAppleCVA_isSimilarSE3(simd_float4x4 a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float a6)
{
  simd_float4x4 v27 = __invert_f4(a1);
  v26[0] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v27.columns[0], a2.f32[0]), (float32x4_t)v27.columns[1], *(float32x2_t *)a2.f32, 1), (float32x4_t)v27.columns[2], a2, 2), (float32x4_t)v27.columns[3], a2, 3);
  v26[1] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v27.columns[0], a3.f32[0]), (float32x4_t)v27.columns[1], *(float32x2_t *)a3.f32, 1), (float32x4_t)v27.columns[2], a3, 2), (float32x4_t)v27.columns[3], a3, 3);
  v26[2] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v27.columns[0], a4.f32[0]), (float32x4_t)v27.columns[1], *(float32x2_t *)a4.f32, 1), (float32x4_t)v27.columns[2], a4, 2), (float32x4_t)v27.columns[3], a4, 3);
  v26[3] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v27.columns[0], a5.f32[0]), (float32x4_t)v27.columns[1], *(float32x2_t *)a5.f32, 1), (float32x4_t)v27.columns[2], a5, 2), (float32x4_t)v27.columns[3], a5, 3);
  v25[0] = (float *)v26;
  v25[1] = (float *)4;
  sub_24B6C3A70((uint64_t)&v19, v25);
  return sqrtf((float)((float)((float)(v19 * v19) + (float)(v20 * v20)) + (float)(v21 * v21))+ (float)((float)((float)(v22 * v22) + (float)(v23 * v23)) + (float)(v24 * v24))) < a6;
}

void sub_24B6C3A70(uint64_t a1, float **a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  int v4 = *a2;
  unint64_t v3 = (unint64_t)a2[1];
  float v5 = (*a2)[(v3 + 2)];
  float v6 = (*a2)[(2 * v3) | 1];
  float v7 = (float)(v5 - v6) * 0.5;
  unint64_t v8 = (float32x2_t *)&(*a2)[(2 * v3)];
  float v9 = v8->f32[0];
  float v10 = (*a2)[1];
  float v11 = (*a2)[2];
  float v12 = (float)(v8->f32[0] - v11) * 0.5;
  float v13 = (*a2)[v3];
  float v14 = **a2;
  float v15 = (*a2)[(v3 + 1)];
  float v16 = (float)(v10 - v13) * 0.5;
  float v17 = (*a2)[(2 * v3 + 2)];
  float v18 = -1.0;
  float v19 = (float)((float)((float)(v14 + v15) + v17) + -1.0) * 0.5;
  float v20 = (float)((float)(v12 * v12) + (float)(v7 * v7)) + (float)(v16 * v16);
  if (v19 >= -1.0 || (float)(v19 + 1.0) <= -0.00001)
  {
    BOOL v22 = v19 > 1.0;
    if ((float)(v19 + -1.0) >= 0.00001) {
      BOOL v22 = 0;
    }
    if (v19 > 0.99 || v22)
    {
      float v24 = (float)(v20 * (float)((float)(v20 * (float)((float)((float)(v20 * 5.0) / 112.0) + 0.075)) + 0.16667)) + 1.0;
      v25.f32[0] = v7 * v24;
      float v26 = v12 * v24;
      *(_DWORD *)a1 = v25.i32[0];
      *(float *)(a1 + 4) = v12 * v24;
      float v27 = v16 * v24;
      *(float *)(a1 + 8) = v16 * v24;
      goto LABEL_35;
    }
    if (v19 > -0.99)
    {
      float v28 = (float)(v10 - v13) * 0.5;
      float v29 = (float)(v8->f32[0] - v11) * 0.5;
      float v30 = acosf(v19) / sqrtf(v20);
      v25.f32[0] = v7 * v30;
      float v26 = v29 * v30;
      *(_DWORD *)a1 = v25.i32[0];
      *(float *)(a1 + 4) = v29 * v30;
      float v27 = v28 * v30;
      *(float *)(a1 + 8) = v28 * v30;
      goto LABEL_35;
    }
    float v18 = (float)((float)((float)(v14 + v15) + v17) + -1.0) * 0.5;
  }
  float v65 = (*a2)[(v3 + 2)];
  float v66 = (*a2)[2];
  float v67 = (*a2)[1];
  float v62 = (float)(v5 - v6) * 0.5;
  float v63 = (*a2)[v3];
  float v61 = (float)(v8->f32[0] - v11) * 0.5;
  float v64 = (*a2)[(2 * v3) | 1];
  float v31 = (float)(v10 - v13) * 0.5;
  float v32 = asinf(sqrtf(v20));
  float v33 = (float)((float)(3.1416 - v32) * (float)(3.1416 - v32)) / (float)(1.0 - v18);
  float v34 = (float)(v14 - v18) * v33;
  float v35 = (float)(v15 - v18) * v33;
  float v36 = (float)(v17 - v18) * v33;
  if (v34 <= v35)
  {
    float v40 = v33 * 0.5;
    v41.f32[0] = v66;
    if (v35 <= v36)
    {
      float v44 = sqrtf(v36);
      if (v31 >= 0.0) {
        float v27 = v44;
      }
      else {
        float v27 = -v44;
      }
      *(float *)(a1 + 8) = v27;
      v41.f32[1] = v65;
      float32x2_t v25 = vmul_n_f32(vmul_n_f32(vadd_f32(*v8, v41), v40), 1.0 / v27);
      *(float32x2_t *)a1 = v25;
      float v26 = v25.f32[1];
    }
    else
    {
      float v42 = sqrtf(v35);
      if (v61 >= 0.0) {
        float v26 = v42;
      }
      else {
        float v26 = -v42;
      }
      v25.f32[0] = (float)(1.0 / v26) * (float)(v40 * (float)(v63 + v67));
      *(_DWORD *)a1 = v25.i32[0];
      *(float *)(a1 + 4) = v26;
      float v27 = (float)(1.0 / v26) * (float)(v40 * (float)(v64 + v65));
      *(float *)(a1 + 8) = v27;
    }
  }
  else
  {
    float v37 = v33 * 0.5;
    float v38 = (float)(v33 * 0.5) * (float)(v9 + v66);
    if (v34 <= v36)
    {
      float v43 = sqrtf(v36);
      if (v31 >= 0.0) {
        float v27 = v43;
      }
      else {
        float v27 = -v43;
      }
      v25.f32[0] = (float)(1.0 / v27) * v38;
      float v26 = (float)(1.0 / v27) * (float)(v37 * (float)(v64 + v65));
      *(_DWORD *)a1 = v25.i32[0];
      *(float *)(a1 + 4) = v26;
      *(float *)(a1 + 8) = v27;
    }
    else
    {
      float v39 = sqrtf(v34);
      if (v62 >= 0.0) {
        v25.f32[0] = v39;
      }
      else {
        v25.f32[0] = -v39;
      }
      float v26 = (float)(1.0 / v25.f32[0]) * (float)(v37 * (float)(v63 + v67));
      *(_DWORD *)a1 = v25.i32[0];
      *(float *)(a1 + 4) = v26;
      float v27 = (float)(1.0 / v25.f32[0]) * v38;
      *(float *)(a1 + 8) = v27;
    }
  }
LABEL_35:
  float v45 = (float)((float)(v25.f32[0] * v25.f32[0]) + (float)(v26 * v26)) + (float)(v27 * v27);
  if (v45 >= 0.0061)
  {
    float v49 = sqrtf(v45);
    __int32 v68 = v25.i32[0];
    __float2 v50 = __sincosf_stret(v49);
    v25.i32[0] = v68;
    float v48 = v50.__sinval / v49;
    float v46 = (float)(1.0 / v45) * (float)(1.0 - v50.__cosval);
    float v47 = (float)(1.0 / v45) * (float)(1.0 - (float)(v50.__sinval / v49));
  }
  else
  {
    float v46 = 0.5 - (float)(v45 * (float)((float)(v45 / -720.0) + 0.041667));
    float v47 = 0.16667 - (float)(v45 * (float)((float)(v45 / -5040.0) + 0.0083333));
    float v48 = 1.0 - (float)(v45 * v47);
  }
  if (v45 >= 0.00000149)
  {
    if (v45 <= 9.0) {
      float v51 = (float)-(float)(v47 - (float)(v46 * 0.5)) / v48;
    }
    else {
      float v51 = (float)(v46 + (float)(v48 * -0.5)) / (float)(v45 * v46);
    }
  }
  else
  {
    float v51 = (float)((float)(v45 * 0.0013889) + 0.083333) + (float)(v45 * 0.000033069);
  }
  float v52 = (float32x2_t *)&v4[(3 * v3 + HIDWORD(v3)) - HIDWORD(v3)];
  float v53 = v52->f32[1];
  float v54 = v52[1].f32[0];
  float32_t v55 = (float)(v26 * v54) - (float)(v27 * v53);
  float32_t v69 = v55;
  *(float *)v70.i32 = (float)(v27 * v52->f32[0]) - (float)(v25.f32[0] * v54);
  *(float *)&v70.i32[1] = (float)(v25.f32[0] * v53) - (float)(v26 * v52->f32[0]);
  float32x2_t v56 = *(float32x2_t *)(a1 + 4);
  v57.i32[1] = v56.i32[1];
  v57.i32[0] = *(_DWORD *)a1;
  v58.i32[0] = vdup_lane_s32(v70, 1).u32[0];
  v58.f32[1] = v55;
  float32x2_t v59 = vadd_f32(vadd_f32(*v52, vmul_f32(*(float32x2_t *)&v69, (float32x2_t)0xBF000000BF000000)), vmul_n_f32(vmla_f32(vmul_f32((float32x2_t)v70, vneg_f32((float32x2_t)vrev64_s32(v57))), v58, v56), v51));
  float v60 = (float)(v51 * vmlas_n_f32(-(float)(v56.f32[0] * v55), *(float *)a1, *(float *)v70.i32))
      + (float)(v54 + (float)(*(float *)&v70.i32[1] * -0.5));
  *(float32x2_t *)(a1 + 12) = v59;
  *(float *)(a1 + 20) = v60;
}

__n128 OCNonModularSPI_CoreAppleCVA_meanSE3(__n128 a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8)
{
  v44[0] = a1;
  v44[1] = a2;
  v44[2] = a3;
  v44[3] = a4;
  v43[0] = (float *)v44;
  v43[1] = (float *)4;
  sub_24B6C3A70((uint64_t)&v41, v43);
  v40[0] = a5;
  v40[1] = a6;
  v40[2] = a7;
  v40[3] = a8;
  v39[0] = (float *)v40;
  v39[1] = (float *)4;
  sub_24B6C3A70((uint64_t)&v37, v39);
  v8.i64[0] = 0x3F0000003F000000;
  v8.i64[1] = 0x3F0000003F000000;
  float32x2_t v36 = vmul_f32(vadd_f32(v42, v38), (float32x2_t)0x3F0000003F000000);
  long long v31 = xmmword_24B72AA30;
  long long v32 = unk_24B72AA40;
  long long v33 = xmmword_24B72AA50;
  long long v34 = unk_24B72AA60;
  float32x4_t v35 = vmulq_f32(vaddq_f32(v41, v37), v8);
  float32x4_t v9 = vmulq_f32(v35, v35);
  float v10 = vaddq_f32(vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1)), (float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2)).f32[0];
  if (v10 >= 0.0061)
  {
    float v15 = sqrtf(v10);
    float v29 = v10;
    __float2 v16 = __sincosf_stret(v15);
    float cosval = v16.__cosval;
    float v13 = v16.__sinval / v15;
    float v11 = (float)(1.0 / v29) * (float)(1.0 - v16.__cosval);
    float v12 = (float)(1.0 / v29) * (float)(1.0 - (float)(v16.__sinval / v15));
  }
  else
  {
    float v11 = 0.5 - (float)(v10 * (float)((float)(v10 / -720.0) + 0.041667));
    float v12 = 0.16667 - (float)(v10 * (float)((float)(v10 / -5040.0) + 0.0083333));
    float v13 = 1.0 - (float)(v10 * v12);
    float cosval = 1.0 - (float)(v10 * v11);
  }
  float v47 = v11;
  float v48 = v12;
  float v45 = cosval;
  float v46 = v13;
  sub_24B6C4314((uint64_t)&v35, &v45, (float32x2_t *)&v31);
  long long v30 = v31;
  long long v31 = xmmword_24B72AA30;
  long long v32 = unk_24B72AA40;
  long long v33 = xmmword_24B72AA50;
  long long v34 = unk_24B72AA60;
  float v17 = (float)((float)(v35.f32[0] * v35.f32[0]) + (float)(v35.f32[1] * v35.f32[1])) + (float)(v35.f32[2] * v35.f32[2]);
  if (v17 >= 0.0061)
  {
    float v22 = sqrtf(v17);
    __float2 v23 = __sincosf_stret(v22);
    float v21 = v23.__cosval;
    float v20 = v23.__sinval / v22;
    float v18 = (float)(1.0 / v17) * (float)(1.0 - v23.__cosval);
    float v19 = (float)(1.0 / v17) * (float)(1.0 - (float)(v23.__sinval / v22));
  }
  else
  {
    float v18 = 0.5 - (float)(v17 * (float)((float)(v17 / -720.0) + 0.041667));
    float v19 = 0.16667 - (float)(v17 * (float)((float)(v17 / -5040.0) + 0.0083333));
    float v20 = 1.0 - (float)(v17 * v19);
    float v21 = 1.0 - (float)(v17 * v18);
  }
  float v47 = v18;
  float v48 = v19;
  float v45 = v21;
  float v46 = v20;
  sub_24B6C4314((uint64_t)&v35, &v45, (float32x2_t *)&v31);
  return (__n128)v30;
}

uint64_t sub_24B6C4314(uint64_t result, float *a2, float32x2_t *a3)
{
  float v3 = *a2;
  float v4 = a2[1];
  float v5 = a2[2];
  float v6 = v5 * *(float *)result;
  float v7 = v5 * *(float *)(result + 4);
  float v8 = v5 * *(float *)(result + 8);
  a3->f32[0] = *a2 + (float)(v6 * *(float *)result);
  a3[2].f32[1] = v3 + (float)(v7 * *(float *)(result + 4));
  a3[5].f32[0] = v3 + (float)(v8 * *(float *)(result + 8));
  float v9 = *(float *)(result + 4);
  float v10 = v6 * v9;
  float v11 = *(float *)(result + 8);
  float v12 = v6 * v11;
  float v13 = v7 * v11;
  float v14 = v4 * *(float *)result;
  float v15 = v4 * v9;
  float v16 = v4 * v11;
  a3[2].f32[0] = v10 - v16;
  a3[4].f32[0] = v15 + v12;
  a3[4].f32[1] = v13 - v14;
  a3->f32[1] = v10 + v16;
  a3[1].f32[0] = v12 - v15;
  a3[3].f32[0] = v13 + v14;
  float v17 = *(float *)(result + 8);
  float v18 = *(float *)(result + 12);
  float v19 = *(float *)(result + 16);
  float v20 = *(float *)(result + 20);
  float v21 = *(float *)(result + 4);
  float v22 = (float)(v21 * v20) - (float)(v17 * v19);
  float v23 = (float)(v17 * v18) - (float)(*(float *)result * v20);
  *(float *)long long v33 = v22;
  *(float *)&v33[4] = v23;
  float v24 = (float)(*(float *)result * v19) - (float)(v21 * v18);
  *(float *)&v33[8] = v24;
  float v26 = a2[2];
  float v25 = a2[3];
  if ((float32x2_t *)result == a3)
  {
    float v28 = v20 + (float)(v26 * v24);
    float32x2_t v29 = *(float32x2_t *)(result + 4);
    v30.i32[1] = v29.i32[1];
    v30.i32[0] = *(_DWORD *)result;
    v31.i32[0] = vdup_lane_s32(*(int32x2_t *)&v33[4], 1).u32[0];
    v31.f32[1] = v22;
    float32x2_t v32 = vadd_f32(vadd_f32(*(float32x2_t *)(result + 12), vmul_n_f32(*(float32x2_t *)v33, v26)), vmul_n_f32(vmla_f32(vmul_f32(*(float32x2_t *)&v33[4], vneg_f32((float32x2_t)vrev64_s32(v30))), v31, v29), v25));
    float v27 = (float)(v25 * vmlas_n_f32(-(float)(v29.f32[0] * v22), *(float *)result, *(float *)&v33[4])) + v28;
    a3[6] = v32;
  }
  else
  {
    a3[6].f32[0] = (float)(v18 + (float)(v22 * v26))
                 + (float)(v25 * (float)((float)(*(float *)(result + 4) * v24) - (float)(*(float *)(result + 8) * v23)));
    a3[6].f32[1] = (float)(*(float *)(result + 16) + (float)(v23 * v26))
                 + (float)(v25 * (float)((float)(*(float *)(result + 8) * v22) - (float)(*(float *)result * v24)));
    float v27 = (float)(*(float *)(result + 20) + (float)(v24 * v26))
        + (float)(v25 * (float)((float)(*(float *)result * v23) - (float)(*(float *)(result + 4) * v22)));
  }
  a3[7].f32[0] = v27;
  return result;
}

void OCMaskingCreate()
{
}

void sub_24B6C45C0(_Unwind_Exception *a1)
{
  uint64_t v3 = *v1;
  *uint64_t v1 = 0;
  if (v3)
  {
    sub_24B6C4618(v3 + 8);
    MEMORY[0x24C5D7790](v3, 0x1080C40E0B7A938);
  }
  MEMORY[0x24C5D7790](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

uint64_t sub_24B6C4618(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    float v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    float v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    float v6 = &v2[v5 / 0xAA];
    unint64_t v7 = (unint64_t)*v6 + 24 * (v5 % 0xAA);
    unint64_t v8 = (unint64_t)v2[(*(void *)(a1 + 40) + v5) / 0xAA] + 24 * ((*(void *)(a1 + 40) + v5) % 0xAA);
    if (v7 != v8)
    {
      do
      {
        sub_24B6BD138(*(void **)(v7 + 8));
        v7 += 24;
        if (v7 - (void)*v6 == 4080)
        {
          unint64_t v9 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v9;
        }
      }
      while (v7 != v8);
      uint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  void *v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 85;
    goto LABEL_15;
  }
  if (v11 == 2)
  {
    uint64_t v12 = 170;
LABEL_15:
    *(void *)(a1 + 32) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      float v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 != v15) {
      *(void *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t OCMaskingStart(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t OCMaskingCreateObjectVoxelsAndComputeBBox(uint64_t a1, uint64_t a2, long long *a3, const void *a4, uint64_t a5, void *a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v91 = *MEMORY[0x263EF8340];
  kdebug_trace();
  uint64_t v16 = 0xFFFFFFFFLL;
  if (a1 && a2 && a3 && a4)
  {
    uint64_t v73 = a1;
    float v17 = a6;
    float v18 = a7;
    int v19 = MEMORY[0x24C5D7200](a4);
    BOOL v20 = v19 == 1278227250 || v19 == 2021227107;
    int v21 = v20 ? v19 : 0;
    unint64_t v22 = v21 == 2021227107 ? 48 : 4 * (v21 == 1278227250);
    int v23 = MEMORY[0x24C5D7200](a4);
    if (v23 == 2021227107 || v23 == 1278227250)
    {
      unint64_t DataSize = CVDataBufferGetDataSize();
      uint64_t v16 = 0xFFFFFFFFLL;
      if (!v22) {
        return v16;
      }
    }
    else
    {
      unint64_t DataSize = 0;
      uint64_t v16 = 0xFFFFFFFFLL;
      if (!v22) {
        return v16;
      }
    }
    if (a8)
    {
      if (a5)
      {
        float v25 = v18;
        float v26 = v17;
        if (v22 <= DataSize)
        {
          uint64_t v72 = a8;
          long long v27 = *a3;
          HIDWORD(v27) = 0;
          long long v84 = v27;
          uint64_t v85 = 0;
          uint64_t v86 = 0;
          uint64_t v28 = *(void *)(a2 + 96);
          uint64_t v29 = *(unsigned int *)(a2 + 104);
          *(_OWORD *)__p = 0u;
          long long v90 = 0u;
          long long v30 = *(_OWORD *)(a2 + 16);
          v88[3] = *(_OWORD *)a2;
          v88[4] = v30;
          long long v31 = *(_OWORD *)(a2 + 48);
          v88[5] = *(_OWORD *)(a2 + 32);
          v88[6] = v31;
          float32x4_t v32 = *(float32x4_t *)(a2 + 64);
          long long v33 = *(_OWORD *)(a2 + 80);
          long long v87 = xmmword_24B72A590;
          v88[0] = v32;
          v88[1] = v33;
          if (v29)
          {
            int32x2_t v70 = v25;
            uint64_t v71 = a5;
            long long v34 = 0;
            float32x4_t v35 = 0;
            float32x2_t v36 = 0;
            for (uint64_t i = 0; i != v29; ++i)
            {
              if (v34 < v36)
              {
                *(_OWORD *)long long v34 = *(_OWORD *)(v28 + 16 * i);
                v34 += 16;
              }
              else
              {
                uint64_t v38 = (v34 - v35) >> 4;
                unint64_t v39 = v38 + 1;
                if ((unint64_t)(v38 + 1) >> 60) {
                  abort();
                }
                if ((v36 - v35) >> 3 > v39) {
                  unint64_t v39 = (v36 - v35) >> 3;
                }
                if ((unint64_t)(v36 - v35) >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v40 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v40 = v39;
                }
                if (v40)
                {
                  if (v40 >> 60) {
                    sub_24B6BCD7C();
                  }
                  float32x4_t v41 = (char *)operator new(16 * v40);
                }
                else
                {
                  float32x4_t v41 = 0;
                }
                float32x2_t v42 = &v41[16 * v38];
                *(_OWORD *)float32x2_t v42 = *(_OWORD *)(v28 + 16 * i);
                float v43 = v42 + 16;
                if (v34 != v35)
                {
                  do
                  {
                    long long v44 = *((_OWORD *)v34 - 1);
                    v34 -= 16;
                    *((_OWORD *)v42 - 1) = v44;
                    v42 -= 16;
                  }
                  while (v34 != v35);
                  long long v34 = v35;
                }
                float32x4_t v35 = v42;
                float32x2_t v36 = &v41[16 * v40];
                if (v34) {
                  operator delete(v34);
                }
                long long v34 = v43;
              }
            }
            __p[1] = v34;
            *(void *)&long long v90 = v36;
            __p[0] = v35;
            float32x4_t v32 = *(float32x4_t *)(a2 + 64);
            float v26 = v17;
            a5 = v71;
            float v25 = v70;
          }
          float32x4_t v45 = *(float32x4_t *)a2;
          float32x4_t v46 = *(float32x4_t *)(a2 + 16);
          float32x4_t v47 = *(float32x4_t *)(a2 + 32);
          float32x4_t v48 = *(float32x4_t *)(a2 + 48);
          float32x4_t v49 = vmlaq_f32(vmlaq_f32(vaddq_f32(v46, vmulq_f32(*(float32x4_t *)a2, (float32x4_t)0)), (float32x4_t)0, v47), (float32x4_t)0, v48);
          v88[2] = v49;
          float32x4_t v50 = vmulq_f32(v49, vaddq_f32(v48, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v45, v32.f32[0]), v46, *(float32x2_t *)v32.f32, 1), v47, v32, 2)));
          v49.i32[3] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).u32[0];
          v88[7] = v49;
          CVPixelBufferRef v81 = 0;
          uint64_t v82 = 0;
          uint64_t v83 = 0;
          BaseAddress = OCDataBufferGetBaseAddress((uint64_t)a4);
          int v52 = MEMORY[0x24C5D7200](a4);
          if (v52 == 1278227250 || v52 == 2021227107) {
            int v54 = v52;
          }
          else {
            int v54 = 0;
          }
          if (v54 == 2021227107) {
            unint64_t v55 = 48;
          }
          else {
            unint64_t v55 = 4 * (v54 == 1278227250);
          }
          int v56 = MEMORY[0x24C5D7200](a4);
          if (v56 == 2021227107 || v56 == 1278227250)
          {
            unint64_t v57 = CVDataBufferGetDataSize();
            if (v55)
            {
LABEL_56:
              unint64_t v58 = v57 / v55;
LABEL_59:
              sub_24B6EC03C((uint64_t)BaseAddress, v58, (float32x4_t *)a5, (uint64_t)&v81);
              int v76 = 0;
              float32x2_t v59 = v81;
              uint64_t v75 = v81;
              int v74 = -1431655765 * ((unint64_t)(v82 - (void)v81) >> 4);
              long long v60 = *(_OWORD *)(a5 + 16);
              float32x4_t v77 = *(float32x4_t *)a5;
              long long v78 = v60;
              long long v61 = *(_OWORD *)(a5 + 48);
              long long v79 = *(_OWORD *)(a5 + 32);
              long long v80 = v61;
              if (sub_24B70E3E4(*(void *)v73, &v74, (uint64_t)v88, (uint64_t)&v84, v72, (void *)(v73 + 80)))
              {
                if (v26 && v25)
                {
                  uint64_t v62 = *(void *)(v73 + 80);
                  *float v25 = (unint64_t)(*(void *)(v73 + 88) - v62) >> 2;
                  void *v26 = v62;
                }
                float v63 = *(const void **)(v73 + 8);
                if (v63)
                {
                  int v64 = MEMORY[0x24C5D7200](*(void *)(v73 + 8));
                  if (v64 == 2021227107 || v64 == 1278227250) {
                    CFRelease(v63);
                  }
                }
                int v65 = MEMORY[0x24C5D7200](a4);
                if (v65 == 2021227107 || v65 == 1278227250) {
                  CFRetain(a4);
                }
                else {
                  a4 = 0;
                }
                *(void *)(v73 + 8) = a4;
                float32x4_t v66 = *(float32x4_t *)a5;
                long long v67 = *(_OWORD *)(a5 + 16);
                long long v68 = *(_OWORD *)(a5 + 48);
                *(_OWORD *)(v73 + 48) = *(_OWORD *)(a5 + 32);
                *(_OWORD *)(v73 + 64) = v68;
                *(float32x4_t *)(v73 + 16) = v66;
                *(_OWORD *)(v73 + 32) = v67;
                kdebug_trace();
                uint64_t v16 = 0;
              }
              else
              {
                uint64_t v16 = 0xFFFFFFFFLL;
              }
              if (v59) {
                operator delete(v59);
              }
              if (__p[0])
              {
                __p[1] = __p[0];
                operator delete(__p[0]);
              }
              return v16;
            }
          }
          else
          {
            unint64_t v57 = 0;
            if (v55) {
              goto LABEL_56;
            }
          }
          LODWORD(v58) = 0;
          goto LABEL_59;
        }
      }
    }
  }
  return v16;
}

void sub_24B6C4C60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54)
{
  if (__p)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OCMaskingComputeMaskFromObjectVoxels(uint64_t a1, __CVBuffer *a2, simd_float4x4 *a3, uint64_t a4, float32x4_t *a5, uint64_t a6, int a7, __CVBuffer *a8)
{
  if (!a1 || !a2 || !a3) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v10 = a8;
  if (!a4) {
    goto LABEL_20;
  }
  int v16 = MEMORY[0x24C5D7200](a4);
  if (v16 == 1278227250 || v16 == 2021227107) {
    int v18 = v16;
  }
  else {
    int v18 = 0;
  }
  if (v18 == 2021227107) {
    unint64_t v19 = 48;
  }
  else {
    unint64_t v19 = 4 * (v18 == 1278227250);
  }
  int v20 = MEMORY[0x24C5D7200](a4);
  if (v20 == 2021227107 || v20 == 1278227250)
  {
    unint64_t DataSize = CVDataBufferGetDataSize();
    unint64_t v10 = a8;
    if (v19) {
      goto LABEL_17;
    }
LABEL_20:
    unint64_t v22 = 0;
    if (!v10) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_21;
  }
  unint64_t DataSize = 0;
  unint64_t v10 = a8;
  if (!v19) {
    goto LABEL_20;
  }
LABEL_17:
  unint64_t v22 = DataSize / v19;
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
LABEL_21:
  if (a7)
  {
    if (a6)
    {
      if (a5)
      {
        if (v22)
        {
          simd_float4x4 v38 = __invert_f4(*a3);
          float32x4_t v34 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_24B72A5D0, v38.columns[0].f32[0]), (float32x4_t)xmmword_24B72A5E0, *(float32x2_t *)v38.columns[0].f32, 1), (float32x4_t)xmmword_24B72A5F0, (float32x4_t)v38.columns[0], 2), (float32x4_t)xmmword_24B72A590, (float32x4_t)v38.columns[0], 3);
          float32x4_t v35 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_24B72A5D0, v38.columns[1].f32[0]), (float32x4_t)xmmword_24B72A5E0, *(float32x2_t *)v38.columns[1].f32, 1), (float32x4_t)xmmword_24B72A5F0, (float32x4_t)v38.columns[1], 2), (float32x4_t)xmmword_24B72A590, (float32x4_t)v38.columns[1], 3);
          float32x4_t v36 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_24B72A5D0, v38.columns[2].f32[0]), (float32x4_t)xmmword_24B72A5E0, *(float32x2_t *)v38.columns[2].f32, 1), (float32x4_t)xmmword_24B72A5F0, (float32x4_t)v38.columns[2], 2), (float32x4_t)xmmword_24B72A590, (float32x4_t)v38.columns[2], 3);
          float32x4_t v37 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_24B72A5D0, v38.columns[3].f32[0]), (float32x4_t)xmmword_24B72A5E0, *(float32x2_t *)v38.columns[3].f32, 1), (float32x4_t)xmmword_24B72A5F0, (float32x4_t)v38.columns[3], 2), (float32x4_t)xmmword_24B72A590, (float32x4_t)v38.columns[3], 3);
          if (sub_24B6EC238(a2, v10, (uint64_t)v33))
          {
            memset(__p, 0, sizeof(__p));
            BaseAddress = OCDataBufferGetBaseAddress(a4);
            if (a4)
            {
              int v25 = MEMORY[0x24C5D7200](a4);
              if (v25 == 1278227250 || v25 == 2021227107) {
                int v27 = v25;
              }
              else {
                int v27 = 0;
              }
              if (v27 == 2021227107) {
                unint64_t v28 = 48;
              }
              else {
                unint64_t v28 = 4 * (v27 == 1278227250);
              }
              int v29 = MEMORY[0x24C5D7200](a4);
              if (v29 == 2021227107 || v29 == 1278227250)
              {
                unint64_t v30 = CVDataBufferGetDataSize();
                if (v28)
                {
LABEL_39:
                  unint64_t v31 = v30 / v28;
                  goto LABEL_42;
                }
              }
              else
              {
                unint64_t v30 = 0;
                if (v28) {
                  goto LABEL_39;
                }
              }
            }
            LODWORD(v31) = 0;
LABEL_42:
            sub_24B6EC03C((uint64_t)BaseAddress, v31, a5, (uint64_t)__p);
            CVPixelBufferLockBaseAddress(v10, 0);
            cva::imageViewFromPixelBuffer<unsigned char>();
          }
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

void sub_24B6C5094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  operator delete(v19);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t OCMaskingComputeMaskFromBoundingBox(uint64_t a1, __CVBuffer *a2, simd_float4x4 *a3, uint64_t a4, __CVBuffer *a5)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && a3 && a4 && a5)
  {
    simd_float4x4 v13 = __invert_f4(*a3);
    float32x4_t v9 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_24B72A5D0, v13.columns[0].f32[0]), (float32x4_t)xmmword_24B72A5E0, *(float32x2_t *)v13.columns[0].f32, 1), (float32x4_t)xmmword_24B72A5F0, (float32x4_t)v13.columns[0], 2), (float32x4_t)xmmword_24B72A590, (float32x4_t)v13.columns[0], 3);
    float32x4_t v10 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_24B72A5D0, v13.columns[1].f32[0]), (float32x4_t)xmmword_24B72A5E0, *(float32x2_t *)v13.columns[1].f32, 1), (float32x4_t)xmmword_24B72A5F0, (float32x4_t)v13.columns[1], 2), (float32x4_t)xmmword_24B72A590, (float32x4_t)v13.columns[1], 3);
    float32x4_t v11 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_24B72A5D0, v13.columns[2].f32[0]), (float32x4_t)xmmword_24B72A5E0, *(float32x2_t *)v13.columns[2].f32, 1), (float32x4_t)xmmword_24B72A5F0, (float32x4_t)v13.columns[2], 2), (float32x4_t)xmmword_24B72A590, (float32x4_t)v13.columns[2], 3);
    float32x4_t v12 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_24B72A5D0, v13.columns[3].f32[0]), (float32x4_t)xmmword_24B72A5E0, *(float32x2_t *)v13.columns[3].f32, 1), (float32x4_t)xmmword_24B72A5F0, (float32x4_t)v13.columns[3], 2), (float32x4_t)xmmword_24B72A590, (float32x4_t)v13.columns[3], 3);
    if (sub_24B6EC238(a2, a5, (uint64_t)v8))
    {
      CVPixelBufferLockBaseAddress(a5, 0);
      cva::imageViewFromPixelBuffer<unsigned char>();
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t OCMaskingStop(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t OCMaskingDestroy(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2)
  {
    int v3 = MEMORY[0x24C5D7200](*(void *)(a1 + 8));
    if (v3 == 2021227107 || v3 == 1278227250) {
      CFRelease(v2);
    }
  }
  unint64_t v5 = *(void **)(a1 + 80);
  if (v5)
  {
    *(void *)(a1 + 88) = v5;
    operator delete(v5);
  }
  float v6 = *(uint64_t **)a1;
  *(void *)a1 = 0;
  if (v6)
  {
    uint64_t v7 = v6[1];
    v6[1] = 0;
    if (v7) {
      MEMORY[0x24C5D7790](v7, 0x1000C40B794406BLL);
    }
    uint64_t v8 = *v6;
    uint64_t *v6 = 0;
    if (v8)
    {
      sub_24B6C4618(v8 + 8);
      MEMORY[0x24C5D7790](v8, 0x1080C40E0B7A938);
    }
    MEMORY[0x24C5D7790](v6, 0x20C40A4A59CD2);
  }
  MEMORY[0x24C5D7790](a1, 0x1030C407D372109);
  return 0;
}

uint64_t OCMaskingGetDebugInfo(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(void *)a2 = *(void *)(a1 + 8);
  long long v4 = *(_OWORD *)(a1 + 16);
  long long v5 = *(_OWORD *)(a1 + 32);
  long long v6 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a2 + 48) = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(a2 + 64) = v6;
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v7 = *(void *)(a1 + 88);
  *(void *)(a2 + 80) = v8;
  *(_DWORD *)(a2 + 88) = (unint64_t)(v7 - v8) >> 2;
  return result;
}

uint64_t OCNonModularSPI_NSData_CreateDepthPointCloudDataBuffer(void *a1)
{
  id v1 = a1;
  long long v4 = v1;
  if (v1)
  {
    IOSurfaceRef buffer = 0;
    uint64_t v5 = objc_msgSend_length(v1, v2, v3);
    if (!sub_24B6BC870(1785950320, v5, &buffer))
    {
      BaseAddress = IOSurfaceGetBaseAddress(buffer);
      uint64_t v9 = objc_msgSend_length(v4, v7, v8);
      objc_msgSend_getBytes_length_(v4, v10, (uint64_t)BaseAddress, v9);
      CVDataBufferCreateWithIOSurface();
      CFRelease(buffer);
    }
  }

  return 0;
}

void sub_24B6C54D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t OCNonModularSPI_CMPhoto_HeicWriteCreate(void *a1)
{
  if (!a1) {
    return 4294967294;
  }
  if (CMPhotoCompressionSessionCreate()) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = malloc_type_malloc(8uLL, 0x2004093837F09uLL);
  uint64_t result = 0;
  void *v3 = 0;
  *a1 = v3;
  return result;
}

uint64_t OCNonModularSPI_CMPhoto_HeicWriteStart(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 4294967294;
  }
}

uint64_t OCNonModularSPI_CMPhoto_write(const void **a1, void *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v203 = *MEMORY[0x263EF8340];
  id v6 = a2;
  uint64_t v9 = v6;
  uint64_t v10 = 4294967294;
  if (!a1 || !v6 || !objc_msgSend_isFileURL(v6, v7, v8)) {
    goto LABEL_135;
  }
  simd_float4x4 v13 = objc_msgSend_pathExtension(v9, v11, v12);
  if (objc_msgSend_caseInsensitiveCompare_(v13, v14, @"HEIC"))
  {

    goto LABEL_135;
  }
  uint64_t v15 = *a3;

  if (!v15)
  {
    uint64_t v10 = 4294967294;
    goto LABEL_135;
  }
  long long v190 = 0u;
  long long v191 = 0u;
  long long v188 = 0u;
  long long v189 = 0u;
  if (!*a3)
  {
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    unsigned int v96 = qword_2697D0E20;
    if (os_log_type_enabled((os_log_t)qword_2697D0E20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_24B6B9000, v96, OS_LOG_TYPE_ERROR, "HEIC Serialization: Invalid imageData or imageDataInternal.", (uint8_t *)&buf, 2u);
      uint64_t v10 = 0xFFFFFFFFLL;
      goto LABEL_135;
    }
LABEL_122:
    uint64_t v10 = 0xFFFFFFFFLL;
    goto LABEL_135;
  }
  uint64_t v186 = *a3;
  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  int v16 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v16, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared shot image.", (uint8_t *)&buf, 2u);
  }

  float64x2_t v187 = (__CVBuffer *)a3[2];
  float64x2_t v161 = v187;
  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  float v17 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v17, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared shot depth data.", (uint8_t *)&buf, 2u);
  }

  uint64_t v160 = a3[3];
  *(void *)&long long v188 = v160;
  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  int v18 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v18, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared shot depth confidence data.", (uint8_t *)&buf, 2u);
  }

  *((void *)&v188 + 1) = a3[4];
  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  unint64_t v19 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v19, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared object mask.", (uint8_t *)&buf, 2u);
  }

  long long v180 = *((_OWORD *)a3 + 10);
  long long v182 = *((_OWORD *)a3 + 9);
  long long v176 = *((_OWORD *)a3 + 8);
  float64x2_t v172 = objc_msgSend_numberWithDouble_(NSNumber, v20, v21, *(float *)&v176);
  *(void *)&long long buf = v172;
  uint64_t v168 = objc_msgSend_numberWithDouble_(NSNumber, v22, v23, *(float *)&v182);
  *((void *)&buf + 1) = v168;
  double v164 = objc_msgSend_numberWithDouble_(NSNumber, v24, v25, *(float *)&v180);
  float64x2_t v196 = v164;
  unint64_t v28 = objc_msgSend_numberWithDouble_(NSNumber, v26, v27, *((float *)&v176 + 1));
  float64x2_t v197 = v28;
  unint64_t v31 = objc_msgSend_numberWithDouble_(NSNumber, v29, v30, *((float *)&v182 + 1));
  float64x2_t v198 = v31;
  float32x4_t v34 = objc_msgSend_numberWithDouble_(NSNumber, v32, v33, *((float *)&v180 + 1));
  float64x2_t v199 = v34;
  float32x4_t v37 = objc_msgSend_numberWithDouble_(NSNumber, v35, v36, *((float *)&v176 + 2));
  float64x2_t v200 = v37;
  unint64_t v40 = objc_msgSend_numberWithDouble_(NSNumber, v38, v39, *((float *)&v182 + 2));
  double v201 = v40;
  float v43 = objc_msgSend_numberWithDouble_(NSNumber, v41, v42, *((float *)&v180 + 2));
  float64x2_t v202 = v43;
  uint64_t v181 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x263EFF8C0], v44, (uint64_t)&buf, 9);

  *(void *)&long long v190 = v181;
  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  float32x4_t v45 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v45, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared camera intrinsics.", (uint8_t *)&buf, 2u);
  }

  long long v183 = *((_OWORD *)a3 + 6);
  float32x4_t v48 = objc_msgSend_numberWithDouble_(NSNumber, v46, v47, *(float *)&v183);
  *(void *)&long long buf = v48;
  float v51 = objc_msgSend_numberWithDouble_(NSNumber, v49, v50, *((float *)&v183 + 1));
  *((void *)&buf + 1) = v51;
  int v54 = objc_msgSend_numberWithDouble_(NSNumber, v52, v53, *((float *)&v183 + 2));
  float64x2_t v196 = v54;
  uint64_t v184 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x263EFF8C0], v55, (uint64_t)&buf, 3);

  *((void *)&v190 + 1) = v184;
  *(void *)&long long v191 = sub_24B6BA6BC(*((__n128 *)a3 + 3), *((__n128 *)a3 + 4), *((__n128 *)a3 + 5), v56, v57, v58);
  uint64_t v163 = v191;
  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  float32x2_t v59 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v59, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared camera extrinsics.", (uint8_t *)&buf, 2u);
  }

  CFDictionaryRef v60 = (const __CFDictionary *)a3[1];
  *(void *)&long long v189 = v60;
  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  long long v61 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v61, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared image properties.", (uint8_t *)&buf, 2u);
  }

  CFDictionaryRef theDict = (const __CFDictionary *)a3[54];
  *((void *)&v189 + 1) = theDict;
  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  uint64_t v62 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v62, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared XMP custom metadata.", (uint8_t *)&buf, 2u);
  }

  id v63 = objc_alloc_init(MEMORY[0x263EFF9A0]);
  LODWORD(v194[0]) = *((_DWORD *)a3 + 28);
  int v65 = objc_msgSend_dataWithBytes_length_(MEMORY[0x263EFF8F8], v64, (uint64_t)v194, 4);
  objc_msgSend_setObject_forKeyedSubscript_(v63, v66, (uint64_t)v65, @"tag:apple.com,2023:ObjectCapture#CameraTrackingState");

  uint64_t v68 = a3[22];
  if (v68)
  {
    float32_t v69 = objc_msgSend_archivedDataWithRootObject_requiringSecureCoding_error_(MEMORY[0x263F08910], v67, v68, 1, 0);
    objc_msgSend_setObject_forKeyedSubscript_(v63, v70, (uint64_t)v69, @"tag:apple.com,2023:ObjectCapture#CameraCalibrationData");
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    uint64_t v71 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl(&dword_24B6B9000, v71, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared camera calibration data.", (uint8_t *)&buf, 2u);
    }
  }
  int32x4_t v173 = *((int32x4_t *)a3 + 18);
  long long v177 = *((_OWORD *)a3 + 16);
  int8x16_t v165 = *((int8x16_t *)a3 + 17);
  int8x16_t v169 = *((int8x16_t *)a3 + 19);
  objc_msgSend_dataWithLength_(MEMORY[0x263EFF990], v67, 48, *((void *)&v188 + 1));
  id v72 = objc_claimAutoreleasedReturnValue();
  uint64_t v75 = objc_msgSend_mutableBytes(v72, v73, v74);
  long long v76 = v177;
  HIDWORD(v76) = v165.i32[0];
  *(_OWORD *)uint64_t v75 = v76;
  *(int8x16_t *)(v75 + 16) = vextq_s8(vextq_s8(v165, v165, 0xCuLL), (int8x16_t)v173, 8uLL);
  *(int8x16_t *)(v75 + 32) = vextq_s8((int8x16_t)vuzp1q_s32(v173, v173), v169, 0xCuLL);
  objc_msgSend_setObject_forKeyedSubscript_(v63, v77, (uint64_t)v72, @"tag:apple.com,2023:ObjectCapture#ObjectTransform");

  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  long long v78 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v78, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared object transform.", (uint8_t *)&buf, 2u);
  }

  int32x4_t v174 = *((int32x4_t *)a3 + 22);
  long long v178 = *((_OWORD *)a3 + 20);
  int8x16_t v166 = *((int8x16_t *)a3 + 21);
  int8x16_t v170 = *((int8x16_t *)a3 + 23);
  objc_msgSend_dataWithLength_(MEMORY[0x263EFF990], v79, 48);
  id v80 = objc_claimAutoreleasedReturnValue();
  uint64_t v83 = objc_msgSend_mutableBytes(v80, v81, v82);
  long long v84 = v178;
  HIDWORD(v84) = v166.i32[0];
  *(_OWORD *)uint64_t v83 = v84;
  *(int8x16_t *)(v83 + 16) = vextq_s8(vextq_s8(v166, v166, 0xCuLL), (int8x16_t)v174, 8uLL);
  *(int8x16_t *)(v83 + 32) = vextq_s8((int8x16_t)vuzp1q_s32(v174, v174), v170, 0xCuLL);
  objc_msgSend_setObject_forKeyedSubscript_(v63, v85, (uint64_t)v80, @"tag:apple.com,2023:ObjectCapture#ObjectBoundingBox");

  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  uint64_t v86 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v86, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared bounding box transform.", (uint8_t *)&buf, 2u);
  }

  uint64_t v88 = a3[48];
  if (v88)
  {
    objc_msgSend_setObject_forKeyedSubscript_(v63, v87, v88, @"tag:apple.com,2023:ObjectCapture#RawFeaturePoints");
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    simd_float4 v89 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl(&dword_24B6B9000, v89, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared raw feature points.", (uint8_t *)&buf, 2u);
    }
  }
  if (a3[5])
  {
    unint64_t DataSize = (void *)CVDataBufferGetDataSize();
    if (DataSize)
    {
      IOSurface = (__IOSurface *)CVDataBufferGetIOSurface();
      if (IOSurface)
      {
        BaseAddress = IOSurfaceGetBaseAddress(IOSurface);
        unint64_t DataSize = objc_msgSend_dataWithBytes_length_(MEMORY[0x263EFF8F8], v94, (uint64_t)BaseAddress, DataSize);
        objc_msgSend_setObject_forKeyedSubscript_(v63, v95, (uint64_t)DataSize, @"tag:apple.com,2023:ObjectCapture#PointCloudData");
LABEL_71:

        if (qword_2697D0E28 != -1) {
          dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
        }
        uint64_t v97 = (id)qword_2697D0E20;
        if (os_log_type_enabled(v97, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf) = 0;
          _os_log_debug_impl(&dword_24B6B9000, v97, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared point cloud data.", (uint8_t *)&buf, 2u);
        }

        goto LABEL_76;
      }
      unint64_t DataSize = 0;
    }
    objc_msgSend_setObject_forKeyedSubscript_(v63, v90, (uint64_t)DataSize, @"tag:apple.com,2023:ObjectCapture#PointCloudData");
    goto LABEL_71;
  }
LABEL_76:
  int v98 = (void *)a3[49];
  if (v98)
  {
    id v99 = v98;
    v101 = objc_msgSend_dataUsingEncoding_(v99, v100, 4);
    objc_msgSend_setObject_forKeyedSubscript_(v63, v102, (uint64_t)v101, @"tag:apple.com,2023:ObjectCapture#BundleVersion");
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    uint64_t v103 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl(&dword_24B6B9000, v103, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared heic version data.", (uint8_t *)&buf, 2u);
    }
  }
  if ((a3[50] & 0x80000000) == 0)
  {
    v104 = objc_msgSend_dataWithBytes_length_(MEMORY[0x263EFF8F8], v87, (uint64_t)(a3 + 50), 4);
    objc_msgSend_setObject_forKeyedSubscript_(v63, v105, (uint64_t)v104, @"tag:apple.com,2023:ObjectCapture#SegmentID");

    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    uint64_t v106 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl(&dword_24B6B9000, v106, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared segment ID data.", (uint8_t *)&buf, 2u);
    }
  }
  long long v107 = (void *)a3[51];
  if (v107)
  {
    id v108 = v107;
    unint64_t v110 = objc_msgSend_dataUsingEncoding_(v108, v109, 4);
    objc_msgSend_setObject_forKeyedSubscript_(v63, v111, (uint64_t)v110, @"tag:apple.com,2024:ObjectCapture#SessionUUID");
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    uint64_t v112 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v112, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl(&dword_24B6B9000, v112, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared session UUID data.", (uint8_t *)&buf, 2u);
    }
  }
  if ((a3[52] & 0x80000000) == 0)
  {
    __int32 v113 = objc_msgSend_dataWithBytes_length_(MEMORY[0x263EFF8F8], v87, (uint64_t)(a3 + 52), 4);
    objc_msgSend_setObject_forKeyedSubscript_(v63, v114, (uint64_t)v113, @"tag:apple.com,2024:ObjectCapture#CaptureMode");

    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    v115 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v115, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl(&dword_24B6B9000, v115, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared capture mode data.", (uint8_t *)&buf, 2u);
    }
  }
  if ((*((_DWORD *)a3 + 105) & 0x80000000) == 0)
  {
    uint64_t v116 = objc_msgSend_dataWithBytes_length_(MEMORY[0x263EFF8F8], v87, (uint64_t)a3 + 420, 4);
    objc_msgSend_setObject_forKeyedSubscript_(v63, v117, (uint64_t)v116, @"tag:apple.com,2023:ObjectCapture#Feedback");

    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    unsigned int v118 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v118, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl(&dword_24B6B9000, v118, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared feedback data.", (uint8_t *)&buf, 2u);
    }
  }
  int32x4_t v175 = *((int32x4_t *)a3 + 14);
  long long v179 = *((_OWORD *)a3 + 12);
  int8x16_t v167 = *((int8x16_t *)a3 + 13);
  int8x16_t v171 = *((int8x16_t *)a3 + 15);
  objc_msgSend_dataWithLength_(MEMORY[0x263EFF990], v87, 48);
  id v119 = objc_claimAutoreleasedReturnValue();
  uint64_t v122 = objc_msgSend_mutableBytes(v119, v120, v121);
  long long v123 = v179;
  HIDWORD(v123) = v167.i32[0];
  *(_OWORD *)uint64_t v122 = v123;
  *(int8x16_t *)(v122 + 16) = vextq_s8(vextq_s8(v167, v167, 0xCuLL), (int8x16_t)v175, 8uLL);
  *(int8x16_t *)(v122 + 32) = vextq_s8((int8x16_t)vuzp1q_s32(v175, v175), v171, 0xCuLL);
  objc_msgSend_setObject_forKeyedSubscript_(v63, v124, (uint64_t)v119, @"tag:apple.com,2023:ObjectCapture#WideToDepthCameraTransform");

  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  uint64_t v125 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v125, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v125, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared wide to depth camera transform.", (uint8_t *)&buf, 2u);
  }

  long long v126 = (void *)a3[53];
  if (v126)
  {
    id v127 = v126;
    uint64_t v129 = objc_msgSend_archivedDataWithRootObject_requiringSecureCoding_error_(MEMORY[0x263F08910], v128, (uint64_t)v127, 1, 0);
    objc_msgSend_setObject_forKeyedSubscript_(v63, v130, (uint64_t)v129, @"tag:apple.com,2023:ObjectCapture#TemporalDepthPointClouds");
    if (qword_2697D0E28 != -1) {
      dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
    }
    float32x2_t v131 = (id)qword_2697D0E20;
    if (os_log_type_enabled(v131, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v154 = objc_msgSend_count(v127, v132, v133);
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v154;
      _os_log_debug_impl(&dword_24B6B9000, v131, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared %lu frames of temporal LiDAR point cloud data.", (uint8_t *)&buf, 0xCu);
    }
  }
  id v134 = v63;
  *((void *)&v191 + 1) = v134;
  if (qword_2697D0E28 != -1) {
    dispatch_once(&qword_2697D0E28, &unk_26FE9C820);
  }
  unint64_t v135 = (id)qword_2697D0E20;
  if (os_log_type_enabled(v135, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v135, OS_LOG_TYPE_DEBUG, "HEIC Serialization: Prepared HEIF custom metadata.", (uint8_t *)&buf, 2u);
  }

  unint64_t v136 = *a1;
  uint64_t v137 = *MEMORY[0x263F2F868];
  v192[0] = *MEMORY[0x263F2F870];
  v192[1] = v137;
  v193[0] = &unk_26FE9F6D8;
  v193[1] = &unk_26FE9F6F0;
  v192[2] = *MEMORY[0x263F2F860];
  v193[2] = v9;
  objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v138, (uint64_t)v193, v192, 3);
  if (CMPhotoCompressionSessionOpenEmptyContainer())
  {
    CFRelease(v136);
    sub_24B6BA89C(&v186);
    goto LABEL_122;
  }
  if (!CMPhotoCompressionSessionIsContainerOpen())
  {
    float64x2_t v155 = objc_msgSend_currentHandler(MEMORY[0x263F08690], v139, v140);
    v157 = objc_msgSend_stringWithUTF8String_(NSString, v156, (uint64_t)"OCReturn OCNonModularSPI_CMPhoto_write(const OCHeicWriteHandle, const NSURL *__strong, const OCImageData *, size_t)");
    objc_msgSend_handleFailureInFunction_file_lineNumber_description_(v155, v158, (uint64_t)v157, @"CMPhoto+NonModularSPI.m", 637, @"Failed to open the compression session container to write.");
  }
  unint64_t v141 = objc_msgSend_dictionary(MEMORY[0x263EFF9A0], v139, v140);
  uint64_t v142 = *MEMORY[0x263F2F888];
  objc_msgSend_setObject_forKeyedSubscript_(v141, v143, (uint64_t)&unk_26FE9F708, *MEMORY[0x263F2F888]);
  if (v181) {
    objc_msgSend_setObject_forKeyedSubscript_(v141, v144, v181, *MEMORY[0x263F2F8B0]);
  }
  if (v184 && v163)
  {
    objc_msgSend_setObject_forKeyedSubscript_(v141, v144, v184, *MEMORY[0x263F2F890]);
    objc_msgSend_setObject_forKeyedSubscript_(v141, v145, v163, *MEMORY[0x263F2F898]);
  }
  if (v60)
  {
    Value = CFDictionaryGetValue(v60, (const void *)*MEMORY[0x263F0F4C8]);
    objc_msgSend_setObject_forKeyedSubscript_(v141, v147, (uint64_t)Value, *MEMORY[0x263F2F8A8]);
  }
  objc_msgSend_setObject_forKeyedSubscript_(v141, v144, MEMORY[0x263EFFA88], *MEMORY[0x263F2F8F8]);
  BOOL v148 = CMPhotoCompressionSessionAddImage() == 0;

  if (!v148) {
    goto LABEL_133;
  }
  if (a4)
  {
    v194[0] = *MEMORY[0x263F2F8B8];
    float64x2_t v151 = objc_msgSend_numberWithUnsignedLong_(NSNumber, v149, a4);
    v194[1] = v142;
    *(void *)&long long buf = v151;
    *((void *)&buf + 1) = &unk_26FE9F708;
    objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v152, (uint64_t)&buf, v194, 2);
    BOOL v153 = CMPhotoCompressionSessionAddThumbnail() == 0;

    if (!v153) {
      goto LABEL_133;
    }
  }
  if ((!v60 || !CMPhotoCompressionSessionAddMetadataFromImageProperties())
    && sub_24B6C6D38((int)v136, 0, theDict)
    && sub_24B6C6E50((int)v136, 0, v161, v160, v159)
    && sub_24B6C7024((uint64_t)v136, 0, v134))
  {
    if (CMPhotoCompressionSessionCloseContainer()) {
      uint64_t v10 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v10 = 0;
    }
  }
  else
  {
LABEL_133:
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  sub_24B6BA89C(&v186);
LABEL_135:

  return v10;
}

void sub_24B6C6CC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  if (a2 == 1)
  {
    id v29 = objc_begin_catch(exception_object);
    sub_24B6BA89C(&a29);

    objc_end_catch();
    JUMPOUT(0x24B6C657CLL);
  }
  _Unwind_Resume(exception_object);
}

CGImageMetadata *sub_24B6C6D38(int a1, int a2, CFDictionaryRef theDict)
{
  if (!theDict) {
    return (CGImageMetadata *)1;
  }
  if (!CFDictionaryGetCount(theDict)) {
    return (CGImageMetadata *)1;
  }
  uint64_t result = CGImageMetadataCreateMutable();
  if (result)
  {
    uint64_t v5 = result;
    uint64_t result = (CGImageMetadata *)CGImageMetadataRegisterNamespaceForPrefix(result, @"http://ns.apple.com/oc/1.0/", @"oc", 0);
    if (result)
    {
      v8[0] = v5;
      v8[1] = @"http://ns.apple.com/oc/1.0/";
      v8[2] = @"oc";
      uint64_t v9 = 1;
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_24B6C79DC, v8);
      if ((_BYTE)v9)
      {
        CFDataRef XMPData = CGImageMetadataCreateXMPData(v5, 0);
        CFRelease(v5);
        if (XMPData)
        {
          int v7 = CMPhotoCompressionSessionAddXMP();
          CFRelease(XMPData);
          return (CGImageMetadata *)(v7 == 0);
        }
      }
      else
      {
        CFRelease(v5);
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_24B6C6E50(int a1, const char *a2, CVPixelBufferRef pixelBuffer, uint64_t a4, uint64_t a5)
{
  v19[1] = *MEMORY[0x263EF8340];
  int v7 = (uint64_t *)MEMORY[0x263F2F888];
  if (pixelBuffer)
  {
    if (CVPixelBufferGetPixelFormatType(pixelBuffer) != 1751411059) {
      CVPixelBufferGetPixelFormatType(pixelBuffer);
    }
    uint64_t v18 = *v7;
    v19[0] = &unk_26FE9F708;
    objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v9, (uint64_t)v19, &v18, 1);
    if (CMPhotoCompressionSessionAddAuxiliaryImage()) {
      return 0;
    }
  }
  uint64_t v10 = (uint64_t *)MEMORY[0x263F2F880];
  if (a4)
  {
    uint64_t v11 = *MEMORY[0x263F2F880];
    v16[0] = *v7;
    v16[1] = v11;
    v17[0] = &unk_26FE9F708;
    v17[1] = @"tag:apple.com,2023:ObjectCapture#DepthConfidenceMap";
    objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, a2, (uint64_t)v17, v16, 2);
    if (CMPhotoCompressionSessionAddAuxiliaryImage()) {
      return 0;
    }
  }
  if (a5
    && (uint64_t v12 = *v10,
        v14[0] = *v7,
        v14[1] = v12,
        v15[0] = &unk_26FE9F708,
        v15[1] = @"tag:apple.com,2023:ObjectCapture#ObjectMask",
        objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, a2, (uint64_t)v15, v14, 2),
        CMPhotoCompressionSessionAddAuxiliaryImage()))
  {
    return 0;
  }
  else
  {
    return 1;
  }
}

uint64_t sub_24B6C7024(uint64_t a1, uint64_t a2, void *a3)
{
  v139[3] = *MEMORY[0x263EF8340];
  id v3 = a3;
  uint64_t v5 = v3;
  if (v3)
  {
    int v7 = objc_msgSend_objectForKeyedSubscript_(v3, v4, @"tag:apple.com,2023:ObjectCapture#CameraTrackingState");
    uint64_t v8 = (void *)MEMORY[0x263F2F910];
    uint64_t v9 = (uint64_t *)MEMORY[0x263F2F920];
    uint64_t v10 = (uint64_t *)MEMORY[0x263F2F918];
    if (v7)
    {
      v138[0] = *MEMORY[0x263F2F910];
      uint64_t v11 = objc_msgSend_objectForKeyedSubscript_(v5, v6, @"tag:apple.com,2023:ObjectCapture#CameraTrackingState");
      uint64_t v12 = *v9;
      v139[0] = v11;
      v139[1] = @"tag:apple.com,2023:ObjectCapture#CameraTrackingState";
      uint64_t v13 = *v10;
      v138[1] = v12;
      v138[2] = v13;
      v139[2] = @"Object Capture camera tracking state";
      objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v14, (uint64_t)v139, v138, 3);
      if (CMPhotoCompressionSessionAddCustomMetadata())
      {
        BOOL v15 = 1;
        goto LABEL_71;
      }
      __int32 v113 = v11;
    }
    uint64_t v18 = objc_msgSend_objectForKeyedSubscript_(v5, v6, @"tag:apple.com,2023:ObjectCapture#CameraCalibrationData");
    if (v18)
    {
      v136[0] = *v8;
      unint64_t v19 = objc_msgSend_objectForKeyedSubscript_(v5, v17, @"tag:apple.com,2023:ObjectCapture#CameraCalibrationData");
      uint64_t v20 = *v9;
      v137[0] = v19;
      v137[1] = @"tag:apple.com,2023:ObjectCapture#CameraCalibrationData";
      uint64_t v21 = *v10;
      v136[1] = v20;
      v136[2] = v21;
      v137[2] = @"Object Capture camera calibration data";
      objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v22, (uint64_t)v137, v136, 3);
      if (CMPhotoCompressionSessionAddCustomMetadata())
      {
        BOOL v15 = 1;
LABEL_69:

LABEL_70:
        uint64_t v11 = v113;
        if (!v7)
        {
LABEL_72:

          uint64_t v16 = !v15;
          goto LABEL_73;
        }
LABEL_71:

        goto LABEL_72;
      }
      unint64_t v110 = v19;
      uint64_t v8 = (void *)MEMORY[0x263F2F910];
    }
    uint64_t v112 = objc_msgSend_objectForKeyedSubscript_(v5, v17, @"tag:apple.com,2023:ObjectCapture#ObjectTransform");
    if (v112)
    {
      v134[0] = *v8;
      uint64_t v24 = objc_msgSend_objectForKeyedSubscript_(v5, v23, @"tag:apple.com,2023:ObjectCapture#ObjectTransform");
      uint64_t v25 = *v9;
      unint64_t v111 = (void *)v24;
      v135[0] = v24;
      v135[1] = @"tag:apple.com,2023:ObjectCapture#ObjectTransform";
      uint64_t v26 = *v10;
      v134[1] = v25;
      v134[2] = v26;
      v135[2] = @"Object Capture object transform";
      objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v27, (uint64_t)v135, v134, 3);
      if (CMPhotoCompressionSessionAddCustomMetadata())
      {
        BOOL v15 = 1;
        unint64_t v19 = v110;
        unint64_t v28 = (void *)v112;
LABEL_67:

LABEL_68:
        if (!v18) {
          goto LABEL_70;
        }
        goto LABEL_69;
      }
      id v29 = v8;
    }
    else
    {
      id v29 = v8;
    }
    unint64_t v31 = objc_msgSend_objectForKeyedSubscript_(v5, v23, @"tag:apple.com,2023:ObjectCapture#ObjectBoundingBox");
    if (v31)
    {
      v132[0] = *v29;
      uint64_t v32 = objc_msgSend_objectForKeyedSubscript_(v5, v30, @"tag:apple.com,2023:ObjectCapture#ObjectBoundingBox");
      uint64_t v33 = *v9;
      uint64_t v109 = (void *)v32;
      v133[0] = v32;
      v133[1] = @"tag:apple.com,2023:ObjectCapture#ObjectBoundingBox";
      uint64_t v34 = *v10;
      v132[1] = v33;
      v132[2] = v34;
      v133[2] = @"Object Capture object bounding box";
      objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v35, (uint64_t)v133, v132, 3);
      if (CMPhotoCompressionSessionAddCustomMetadata())
      {
        BOOL v15 = 1;
        uint64_t v36 = v109;
        unint64_t v28 = (void *)v112;
LABEL_65:

LABEL_66:
        unint64_t v19 = v110;
        if (!v28) {
          goto LABEL_68;
        }
        goto LABEL_67;
      }
    }
    uint64_t v107 = objc_msgSend_objectForKeyedSubscript_(v5, v30, @"tag:apple.com,2023:ObjectCapture#RawFeaturePoints");
    id v108 = v31;
    if (v107)
    {
      v130[0] = *v29;
      uint64_t v38 = objc_msgSend_objectForKeyedSubscript_(v5, v37, @"tag:apple.com,2023:ObjectCapture#RawFeaturePoints");
      uint64_t v39 = *v9;
      uint64_t v106 = (void *)v38;
      v131[0] = v38;
      v131[1] = @"tag:apple.com,2023:ObjectCapture#RawFeaturePoints";
      uint64_t v40 = *v10;
      v130[1] = v39;
      v130[2] = v40;
      v131[2] = @"Object Capture raw feature points";
      objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v41, (uint64_t)v131, v130, 3);
      if (CMPhotoCompressionSessionAddCustomMetadata())
      {
        BOOL v15 = 1;
        uint64_t v36 = v109;
        uint64_t v42 = (void *)v107;
        unint64_t v28 = (void *)v112;
LABEL_63:

LABEL_64:
        unint64_t v31 = v108;
        if (!v108) {
          goto LABEL_66;
        }
        goto LABEL_65;
      }
    }
    uint64_t v105 = objc_msgSend_objectForKeyedSubscript_(v5, v37, @"tag:apple.com,2023:ObjectCapture#PointCloudData");
    if (v105)
    {
      v128[0] = *v29;
      uint64_t v44 = objc_msgSend_objectForKeyedSubscript_(v5, v43, @"tag:apple.com,2023:ObjectCapture#PointCloudData");
      uint64_t v45 = *v9;
      v104 = (void *)v44;
      v129[0] = v44;
      v129[1] = @"tag:apple.com,2023:ObjectCapture#PointCloudData";
      uint64_t v46 = *v10;
      v128[1] = v45;
      v128[2] = v46;
      v129[2] = @"Object Capture point cloud data";
      objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v47, (uint64_t)v129, v128, 3);
      if (CMPhotoCompressionSessionAddCustomMetadata())
      {
        BOOL v15 = 1;
        uint64_t v36 = v109;
        uint64_t v42 = (void *)v107;
        unint64_t v28 = (void *)v112;
        float32x4_t v48 = (void *)v105;
LABEL_61:

LABEL_62:
        if (!v42) {
          goto LABEL_64;
        }
        goto LABEL_63;
      }
    }
    uint64_t v103 = objc_msgSend_objectForKeyedSubscript_(v5, v43, @"tag:apple.com,2023:ObjectCapture#BundleVersion");
    if (v103)
    {
      v126[0] = *v29;
      uint64_t v50 = objc_msgSend_objectForKeyedSubscript_(v5, v49, @"tag:apple.com,2023:ObjectCapture#BundleVersion");
      uint64_t v51 = *v9;
      uint64_t v102 = (void *)v50;
      v127[0] = v50;
      v127[1] = @"tag:apple.com,2023:ObjectCapture#BundleVersion";
      uint64_t v52 = *v10;
      v126[1] = v51;
      v126[2] = v52;
      v127[2] = @"Object Capture bundle version";
      objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v53, (uint64_t)v127, v126, 3);
      if (CMPhotoCompressionSessionAddCustomMetadata())
      {
        BOOL v15 = 1;
        uint64_t v36 = v109;
        uint64_t v42 = (void *)v107;
        unint64_t v28 = (void *)v112;
        float32x4_t v48 = (void *)v105;
        int v54 = (void *)v103;
LABEL_59:

LABEL_60:
        if (!v48) {
          goto LABEL_62;
        }
        goto LABEL_61;
      }
    }
    uint64_t v101 = objc_msgSend_objectForKeyedSubscript_(v5, v49, @"tag:apple.com,2023:ObjectCapture#SegmentID");
    if (v101)
    {
      v124[0] = *v29;
      uint64_t v56 = objc_msgSend_objectForKeyedSubscript_(v5, v55, @"tag:apple.com,2023:ObjectCapture#SegmentID");
      uint64_t v57 = *v9;
      v100 = (void *)v56;
      v125[0] = v56;
      v125[1] = @"tag:apple.com,2023:ObjectCapture#SegmentID";
      uint64_t v58 = *v10;
      v124[1] = v57;
      v124[2] = v58;
      v125[2] = @"Object Capture segment ID";
      objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v59, (uint64_t)v125, v124, 3);
      if (CMPhotoCompressionSessionAddCustomMetadata())
      {
        BOOL v15 = 1;
        uint64_t v36 = v109;
        uint64_t v42 = (void *)v107;
        unint64_t v28 = (void *)v112;
        float32x4_t v48 = (void *)v105;
        int v54 = (void *)v103;
        CFDictionaryRef v60 = (void *)v101;
LABEL_57:

LABEL_58:
        if (!v54) {
          goto LABEL_60;
        }
        goto LABEL_59;
      }
    }
    uint64_t v99 = objc_msgSend_objectForKeyedSubscript_(v5, v55, @"tag:apple.com,2024:ObjectCapture#SessionUUID");
    if (v99)
    {
      v122[0] = *v29;
      uint64_t v62 = objc_msgSend_objectForKeyedSubscript_(v5, v61, @"tag:apple.com,2024:ObjectCapture#SessionUUID");
      uint64_t v63 = *v9;
      int v98 = (void *)v62;
      v123[0] = v62;
      v123[1] = @"tag:apple.com,2024:ObjectCapture#SessionUUID";
      uint64_t v64 = *v10;
      v122[1] = v63;
      v122[2] = v64;
      v123[2] = @"Object Capture session UUID";
      objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v65, (uint64_t)v123, v122, 3);
      if (CMPhotoCompressionSessionAddCustomMetadata())
      {
        BOOL v15 = 1;
        uint64_t v36 = v109;
        uint64_t v42 = (void *)v107;
        unint64_t v28 = (void *)v112;
        float32x4_t v48 = (void *)v105;
        int v54 = (void *)v103;
        float32x4_t v66 = (void *)v99;
LABEL_55:

LABEL_56:
        CFDictionaryRef v60 = (void *)v101;
        if (!v101) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }
    }
    uint64_t v97 = objc_msgSend_objectForKeyedSubscript_(v5, v61, @"tag:apple.com,2024:ObjectCapture#CaptureMode");
    if (v97)
    {
      v120[0] = *v29;
      uint64_t v68 = objc_msgSend_objectForKeyedSubscript_(v5, v67, @"tag:apple.com,2024:ObjectCapture#CaptureMode");
      uint64_t v69 = *v9;
      uint64_t v95 = (void *)v68;
      v121[0] = v68;
      v121[1] = @"tag:apple.com,2024:ObjectCapture#CaptureMode";
      uint64_t v70 = *v10;
      v120[1] = v69;
      v120[2] = v70;
      v121[2] = @"Object Capture session capture mode";
      objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v71, (uint64_t)v121, v120, 3);
      if (CMPhotoCompressionSessionAddCustomMetadata())
      {
        BOOL v15 = 1;
        uint64_t v36 = v109;
        uint64_t v42 = (void *)v107;
        unint64_t v28 = (void *)v112;
        float32x4_t v48 = (void *)v105;
        int v54 = (void *)v103;
        id v72 = (void *)v97;
LABEL_53:

LABEL_54:
        float32x4_t v66 = (void *)v99;
        if (!v99) {
          goto LABEL_56;
        }
        goto LABEL_55;
      }
    }
    unsigned int v96 = objc_msgSend_objectForKeyedSubscript_(v5, v67, @"tag:apple.com,2023:ObjectCapture#Feedback");
    if (v96)
    {
      v118[0] = *v29;
      uint64_t v74 = objc_msgSend_objectForKeyedSubscript_(v5, v73, @"tag:apple.com,2023:ObjectCapture#Feedback");
      uint64_t v75 = *v9;
      int v94 = (void *)v74;
      v119[0] = v74;
      v119[1] = @"tag:apple.com,2023:ObjectCapture#Feedback";
      uint64_t v76 = *v10;
      v118[1] = v75;
      v118[2] = v76;
      v119[2] = @"Object Capture feedback";
      objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v77, (uint64_t)v119, v118, 3);
      if (CMPhotoCompressionSessionAddCustomMetadata())
      {
        BOOL v15 = 1;
        uint64_t v36 = v109;
        uint64_t v42 = (void *)v107;
        unint64_t v28 = (void *)v112;
        float32x4_t v48 = (void *)v105;
        int v54 = (void *)v103;
        id v72 = (void *)v97;
LABEL_51:

LABEL_52:
        if (!v72) {
          goto LABEL_54;
        }
        goto LABEL_53;
      }
    }
    uint64_t v93 = objc_msgSend_objectForKeyedSubscript_(v5, v73, @"tag:apple.com,2023:ObjectCapture#WideToDepthCameraTransform");
    if (!v93) {
      goto LABEL_45;
    }
    v116[0] = *v29;
    uint64_t v79 = objc_msgSend_objectForKeyedSubscript_(v5, v78, @"tag:apple.com,2023:ObjectCapture#WideToDepthCameraTransform");
    uint64_t v80 = *v9;
    simd_float4 v92 = (void *)v79;
    v117[0] = v79;
    v117[1] = @"tag:apple.com,2023:ObjectCapture#WideToDepthCameraTransform";
    uint64_t v81 = *v10;
    v116[1] = v80;
    v116[2] = v81;
    v117[2] = @"Object Capture wide to depth camera transform";
    objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v82, (uint64_t)v117, v116, 3);
    if (CMPhotoCompressionSessionAddCustomMetadata())
    {
      BOOL v15 = 1;
      uint64_t v36 = v109;
      uint64_t v83 = (void *)v93;
    }
    else
    {
LABEL_45:
      uint64_t v84 = objc_msgSend_objectForKeyedSubscript_(v5, v78, @"tag:apple.com,2023:ObjectCapture#TemporalDepthPointClouds");
      if (v84)
      {
        v114[0] = *v29;
        uint64_t v86 = (void *)v84;
        long long v87 = objc_msgSend_objectForKeyedSubscript_(v5, v85, @"tag:apple.com,2023:ObjectCapture#TemporalDepthPointClouds");
        uint64_t v88 = *v9;
        v115[0] = v87;
        v115[1] = @"tag:apple.com,2023:ObjectCapture#TemporalDepthPointClouds";
        uint64_t v89 = *v10;
        v114[1] = v88;
        v114[2] = v89;
        v115[2] = @"Object Capture temporal depth point clouds";
        objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v90, (uint64_t)v115, v114, 3);
        BOOL v15 = CMPhotoCompressionSessionAddCustomMetadata() != 0;
      }
      else
      {
        BOOL v15 = 0;
      }
      uint64_t v36 = v109;
      uint64_t v83 = (void *)v93;
      if (!v93)
      {
LABEL_50:
        uint64_t v42 = (void *)v107;
        unint64_t v28 = (void *)v112;
        float32x4_t v48 = (void *)v105;
        int v54 = (void *)v103;
        id v72 = (void *)v97;
        if (!v96) {
          goto LABEL_52;
        }
        goto LABEL_51;
      }
    }

    goto LABEL_50;
  }
  uint64_t v16 = 1;
LABEL_73:

  return v16;
}

void sub_24B6C79DC(CFStringRef name, CFTypeRef value, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 24))
  {
    uint64_t v5 = *(CGImageMetadata **)a3;
    CFStringRef v6 = *(const __CFString **)(a3 + 16);
    CGImageMetadataTagRef v7 = CGImageMetadataTagCreate(*(CFStringRef *)(a3 + 8), v6, name, kCGImageMetadataTypeDefault, value);
    CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@:%@", v6, name);
    char v9 = 0;
    if (v7) {
      BOOL v10 = v8 == 0;
    }
    else {
      BOOL v10 = 1;
    }
    if (!v10)
    {
      CFStringRef v11 = v8;
      if (CGImageMetadataSetTagWithPath(v5, 0, v8, v7))
      {
        CFRelease(v7);
        CFRelease(v11);
        char v9 = 1;
      }
      else
      {
        char v9 = 0;
      }
    }
    *(unsigned char *)(a3 + 24) = v9;
  }
}

uint64_t OCNonModularSPI_CMPhoto_update(uint64_t a1, void *a2, void *a3, void *a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8, __n128 a9, int8x16_t a10, int8x16_t a11, int8x16_t a12)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  id v15 = a2;
  id v16 = a3;
  id v17 = a4;
  uint64_t v20 = objc_msgSend_numberWithDouble_(NSNumber, v18, v19, a8.n128_f32[0]);
  uint64_t v73 = v20;
  objc_msgSend_numberWithDouble_(NSNumber, v21, v22, a8.n128_f32[1]);
  uint64_t v23 = (void **)objc_claimAutoreleasedReturnValue();
  uint64_t v74 = v23;
  uint64_t v26 = objc_msgSend_numberWithDouble_(NSNumber, v24, v25, a8.n128_f32[2]);
  uint64_t v75 = (uint64_t)v26;
  unint64_t v28 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x263EFF8C0], v27, (uint64_t)&v73, 3);

  uint64_t v32 = sub_24B6BA6BC(a5, a6, a7, v29, v30, v31);
  uint64_t v34 = objc_msgSend_dataWithLength_(MEMORY[0x263EFF990], v33, 48);
  __n128 v35 = a9;
  v35.n128_u32[3] = a10.i32[0];
  __n128 v65 = v35;
  id v36 = v34;
  uint64_t v39 = objc_msgSend_mutableBytes(v36, v37, v38);
  *(__n128 *)uint64_t v39 = v65;
  *(int8x16_t *)(v39 + 16) = vextq_s8(vextq_s8(a10, a10, 0xCuLL), a11, 8uLL);
  *(int8x16_t *)(v39 + 32) = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a11, (int32x4_t)a11), a12, 0xCuLL);
  uint64_t v42 = 4294967294;
  if (a1 && v15 && objc_msgSend_isFileURL(v15, v40, v41))
  {
    uint64_t v45 = objc_msgSend_pathExtension(v15, v43, v44);
    uint64_t v47 = objc_msgSend_caseInsensitiveCompare_(v45, v46, @"HEIC");
    if (v16 && !v47 && (objc_msgSend_isFileURL(v16, v48, v49) & 1) != 0)
    {
      uint64_t v52 = objc_msgSend_pathExtension(v16, v50, v51);
      uint64_t v54 = objc_msgSend_caseInsensitiveCompare_(v52, v53, @"HEIC");

      uint64_t v42 = 4294967294;
      if (!v54 && v28 && v32 && v36)
      {
        uint64_t v73 = 0;
        uint64_t v74 = &v73;
        int v76 = -1;
        uint64_t v56 = *MEMORY[0x263F2F868];
        v71[0] = *MEMORY[0x263F2F870];
        v71[1] = v56;
        v72[0] = &unk_26FE9F6D8;
        v72[1] = &unk_26FE9F6F0;
        uint64_t v75 = 0x2020000000;
        v71[2] = *MEMORY[0x263F2F860];
        v72[2] = v16;
        objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v55, (uint64_t)v72, v71, 3);
        id v67 = v28;
        id v68 = v32;
        id v69 = v36;
        id v70 = v17;
        if (CMPhotoCompressionSessionOpenExistingContainerForModification() || *((_DWORD *)v74 + 6))
        {
          uint64_t v42 = 0xFFFFFFFFLL;
        }
        else if (CMPhotoCompressionSessionCloseContainer())
        {
          uint64_t v42 = 0xFFFFFFFFLL;
        }
        else
        {
          uint64_t v42 = 0;
        }

        _Block_object_dispose(&v73, 8);
      }
    }
    else
    {

      uint64_t v42 = 4294967294;
    }
  }

  return v42;
}

void sub_24B6C7E64(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_24B6C7E80(uint64_t *a1, void *a2)
{
  v84[2] = *MEMORY[0x263EF8340];
  if (!a2) {
    return *(unsigned int *)(*(void *)(a1[8] + 8) + 24);
  }
  id v3 = a2;
  uint64_t v5 = objc_msgSend_objectForKeyedSubscript_(v3, v4, *MEMORY[0x263F2F850]);
  uint64_t v7 = objc_msgSend_objectForKeyedSubscript_(v3, v6, *MEMORY[0x263F2F848]);
  BOOL v10 = (void *)v7;
  if (v5) {
    BOOL v11 = v7 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11)
  {
    uint64_t v12 = *(unsigned int *)(*(void *)(a1[8] + 8) + 24);
  }
  else
  {
    uint64_t v75 = v5;
    uint64_t v13 = (int)objc_msgSend_intValue(v5, v8, v9);
    id v15 = objc_msgSend_objectAtIndexedSubscript_(v10, v14, v13);
    uint64_t v16 = *MEMORY[0x263F2F830];
    uint64_t v18 = objc_msgSend_objectForKeyedSubscript_(v15, v17, *MEMORY[0x263F2F830]);

    uint64_t v74 = v18;
    if (v18)
    {
      objc_msgSend_setObject_forKeyedSubscript_(v18, v19, a1[4], *MEMORY[0x263F2F838]);
      objc_msgSend_setObject_forKeyedSubscript_(v18, v20, a1[5], *MEMORY[0x263F2F840]);
    }
    else
    {
      uint64_t v22 = *MEMORY[0x263F2F840];
      v83[0] = *MEMORY[0x263F2F838];
      v83[1] = v22;
      uint64_t v23 = a1[5];
      v84[0] = a1[4];
      v84[1] = v23;
      uint64_t v24 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v19, (uint64_t)v84, v83, 2);
      uint64_t v26 = objc_msgSend_objectAtIndexedSubscript_(v10, v25, v13);
      objc_msgSend_setObject_forKeyedSubscript_(v26, v27, (uint64_t)v24, v16);
    }
    unint64_t v28 = objc_msgSend_objectAtIndexedSubscript_(v10, v21, v13, v13);
    uint64_t v30 = objc_msgSend_objectForKeyedSubscript_(v28, v29, *MEMORY[0x263F2F828]);

    uint64_t v33 = objc_msgSend_count(v30, v31, v32);
    uint64_t v35 = *MEMORY[0x263F2F920];
    if (v33)
    {
      uint64_t v36 = 0;
      while (1)
      {
        float32x4_t v37 = objc_msgSend_objectAtIndexedSubscript_(v30, v34, v36);
        uint64_t v39 = objc_msgSend_objectForKeyedSubscript_(v37, v38, v35);
        uint64_t v41 = objc_msgSend_compare_(v39, v40, @"tag:apple.com,2023:ObjectCapture#ObjectBoundingBox");

        if (!v41) {
          break;
        }

        if (++v36 >= (unint64_t)objc_msgSend_count(v30, v43, v44)) {
          goto LABEL_16;
        }
      }
      objc_msgSend_setObject_forKeyedSubscript_(v37, v42, a1[6], *MEMORY[0x263F2F910]);
    }
    else
    {
LABEL_16:
      uint64_t v45 = a1[6];
      v81[0] = *MEMORY[0x263F2F910];
      v81[1] = v35;
      v82[0] = v45;
      v82[1] = @"tag:apple.com,2023:ObjectCapture#ObjectBoundingBox";
      v81[2] = *MEMORY[0x263F2F918];
      v82[2] = @"Object Capture object bounding box";
      float32x4_t v37 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v34, (uint64_t)v82, v81, 3);
      objc_msgSend_addObject_(v30, v46, (uint64_t)v37);
    }

    if (a1[7])
    {
      float32x4_t v48 = objc_msgSend_objectAtIndexedSubscript_(v10, v47, v73);
      uint64_t v49 = *MEMORY[0x263F2F858];
      uint64_t v51 = objc_msgSend_objectForKeyedSubscript_(v48, v50, *MEMORY[0x263F2F858]);

      if (v51 && objc_msgSend_count(v51, v52, v53))
      {
        objc_msgSend_objectAtIndexedSubscript_(v51, v54, 0);
        CFDataRef v55 = (const __CFData *)objc_claimAutoreleasedReturnValue();
        uint64_t v56 = sub_24B6C83C8(v55);
        objc_msgSend_addEntriesFromDictionary_(v56, v57, a1[7]);
        Mutable = CGImageMetadataCreateMutable();
        if (Mutable)
        {
          float32x2_t v59 = Mutable;
          CFDataRef XMPData = 0;
          if (CGImageMetadataRegisterNamespaceForPrefix(Mutable, @"http://ns.apple.com/oc/1.0/", @"oc", 0))
          {
            context = v59;
            uint64_t v77 = @"http://ns.apple.com/oc/1.0/";
            uint64_t v79 = 1;
            long long v78 = @"oc";
            CFDictionaryApplyFunction((CFDictionaryRef)v56, (CFDictionaryApplierFunction)sub_24B6C79DC, &context);
            if ((_BYTE)v79) {
              CFDataRef XMPData = CGImageMetadataCreateXMPData(v59, 0);
            }
            else {
              CFDataRef XMPData = 0;
            }
            CFRelease(v59);
          }
        }
        else
        {
          CFDataRef XMPData = 0;
        }

        objc_msgSend_setObject_atIndexedSubscript_(v51, v71, (uint64_t)XMPData, 0);
      }
      else
      {
        CFDictionaryRef v61 = (const __CFDictionary *)a1[7];
        uint64_t v62 = CGImageMetadataCreateMutable();
        if (v62)
        {
          uint64_t v63 = v62;
          if (CGImageMetadataRegisterNamespaceForPrefix(v62, @"http://ns.apple.com/oc/1.0/", @"oc", 0))
          {
            context = v63;
            uint64_t v77 = @"http://ns.apple.com/oc/1.0/";
            uint64_t v79 = 1;
            long long v78 = @"oc";
            CFDictionaryApplyFunction(v61, (CFDictionaryApplierFunction)sub_24B6C79DC, &context);
            if ((_BYTE)v79)
            {
              CFDataRef v64 = CGImageMetadataCreateXMPData(v63, 0);
              CFRelease(v63);
              if (v64)
              {
                CFDataRef v80 = v64;
                objc_msgSend_arrayWithObjects_count_(MEMORY[0x263EFF8C0], v65, (uint64_t)&v80, 1);
                v67 = CFDataRef v66 = v64;
                id v69 = objc_msgSend_objectAtIndexedSubscript_(v10, v68, v73);
                objc_msgSend_setObject_forKeyedSubscript_(v69, v70, (uint64_t)v67, v49);
              }
            }
            else
            {
              CFRelease(v63);
            }
          }
        }
      }
    }
    *(_DWORD *)(*(void *)(a1[8] + 8) + 24) = 0;
    uint64_t v12 = *(unsigned int *)(*(void *)(a1[8] + 8) + 24);

    uint64_t v5 = v75;
  }

  return v12;
}

id sub_24B6C83C8(const __CFData *a1)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (!a1) {
    goto LABEL_21;
  }
  uint64_t v1 = CGImageMetadataCreateFromXMPData(a1);
  if (!v1) {
    goto LABEL_21;
  }
  uint64_t v2 = v1;
  CFArrayRef v3 = CGImageMetadataCopyTags(v1);
  if (!v3)
  {
    CFRelease(v2);
LABEL_21:
    id v5 = 0;
    goto LABEL_22;
  }
  CFArrayRef v4 = v3;
  CFTypeRef cf = v2;
  id v5 = objc_alloc_init(MEMORY[0x263EFF9A0]);
  CFIndex Count = CFArrayGetCount(v4);
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    for (CFIndex i = 0; i != v7; ++i)
    {
      ValueAtIndex = (CGImageMetadataTag *)CFArrayGetValueAtIndex(v4, i);
      CFStringRef v11 = CGImageMetadataTagCopyPrefix(ValueAtIndex);
      if (CFStringCompare(v11, @"oc", 1uLL))
      {
        if (qword_2697D0E48 != -1) {
          dispatch_once(&qword_2697D0E48, &unk_26FE9C940);
        }
        uint64_t v12 = qword_2697D0E40;
        if (os_log_type_enabled((os_log_t)qword_2697D0E40, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v25 = v11;
          _os_log_debug_impl(&dword_24B6B9000, v12, OS_LOG_TYPE_DEBUG, "copyXMPMetadata: Ignore prefix = %{public}@", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v13 = (__CFString *)CGImageMetadataTagCopyName(ValueAtIndex);
        CFTypeRef v14 = CGImageMetadataTagCopyValue(ValueAtIndex);
        CFTypeID v15 = CFGetTypeID(v14);
        if (v15 == CFArrayGetTypeID())
        {
          id v9 = objc_alloc_init(MEMORY[0x263EFF980]);
          for (CFIndex j = 0; j < CFArrayGetCount((CFArrayRef)v14); ++j)
          {
            uint64_t v19 = (CGImageMetadataTag *)CFArrayGetValueAtIndex((CFArrayRef)v14, j);
            uint64_t v20 = (void *)CGImageMetadataTagCopyValue(v19);
            objc_msgSend_addObject_(v9, v21, (uint64_t)v20);
          }
          objc_msgSend_setObject_forKeyedSubscript_(v5, v18, (uint64_t)v9, v13);

          CFRelease(v14);
        }
        else
        {
          objc_msgSend_setObject_forKeyedSubscript_(v5, v16, (uint64_t)v14, v13);

          id v9 = (id)v14;
        }
      }
      CFRelease(v11);
    }
  }
  CFRelease(v4);
  CFRelease(cf);
LABEL_22:
  return v5;
}

uint64_t sub_24B6C863C()
{
  qword_2697D0E40 = (uint64_t)os_log_create("com.apple.CoreOCModules", "General");
  return MEMORY[0x270F9A758]();
}

uint64_t OCNonModularSPI_CMPhoto_updateInplace(void *a1, void *a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6, __n128 a7, int8x16_t a8, int8x16_t a9, int8x16_t a10)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  id v11 = a1;
  CFDictionaryRef v12 = a2;
  CFTypeID v15 = objc_msgSend_numberWithDouble_(NSNumber, v13, v14, a6.n128_f32[0]);
  *(void *)&long long buf = v15;
  uint64_t v18 = objc_msgSend_numberWithDouble_(NSNumber, v16, v17, a6.n128_f32[1]);
  *((void *)&buf + 1) = v18;
  objc_msgSend_numberWithDouble_(NSNumber, v19, v20, a6.n128_f32[2]);
  uint64_t v21 = (__CFString *)objc_claimAutoreleasedReturnValue();
  id v67 = v21;
  uint64_t v23 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x263EFF8C0], v22, (uint64_t)&buf, 3);

  uint64_t v27 = sub_24B6BA6BC(a3, a4, a5, v24, v25, v26);
  __n128 v28 = a7;
  v28.n128_u32[3] = a8.i32[0];
  __n128 v62 = v28;
  objc_msgSend_dataWithLength_(MEMORY[0x263EFF990], v29, 48);
  id v30 = objc_claimAutoreleasedReturnValue();
  uint64_t v33 = objc_msgSend_mutableBytes(v30, v31, v32);
  *(__n128 *)uint64_t v33 = v62;
  *(int8x16_t *)(v33 + 16) = vextq_s8(vextq_s8(a8, a8, 0xCuLL), a9, 8uLL);
  *(int8x16_t *)(v33 + 32) = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a9, (int32x4_t)a9), a10, 0xCuLL);
  if (!v11) {
    goto LABEL_4;
  }
  uint64_t v36 = objc_msgSend_pathExtension(v11, v34, v35);
  if (objc_msgSend_caseInsensitiveCompare_(v36, v37, @"HEIC"))
  {

LABEL_4:
    uint64_t v40 = 4294967294;
    goto LABEL_5;
  }
  int isFileURL = objc_msgSend_isFileURL(v11, v38, v39);

  uint64_t v40 = 4294967294;
  if (isFileURL && v23 && v27 && v30)
  {
    if (qword_2697D0E48 != -1) {
      dispatch_once(&qword_2697D0E48, &unk_26FE9C940);
    }
    float v43 = qword_2697D0E40;
    if (os_log_type_enabled((os_log_t)qword_2697D0E40, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf) = 138477827;
      *(void *)((char *)&buf + 4) = v11;
      _os_log_impl(&dword_24B6B9000, v43, OS_LOG_TYPE_INFO, "CMPhoto_update: Has valid arguments for URL: %{private}@", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v44 = objc_alloc_init(OCNonModularSPI_CMPhoto_InPlaceEditor);
    if (qword_2697D0E48 != -1) {
      dispatch_once(&qword_2697D0E48, &unk_26FE9C940);
    }
    uint64_t v45 = qword_2697D0E40;
    if (os_log_type_enabled((os_log_t)qword_2697D0E40, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf) = 138477827;
      *(void *)((char *)&buf + 4) = v11;
      _os_log_impl(&dword_24B6B9000, v45, OS_LOG_TYPE_INFO, "CMPhoto_update: Created editor for URL: %{private}@", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v47 = *MEMORY[0x263F2F920];
    v64[0] = *MEMORY[0x263F2F910];
    v64[1] = v47;
    v65[0] = v30;
    v65[1] = @"tag:apple.com,2023:ObjectCapture#ObjectBoundingBox";
    v64[2] = *MEMORY[0x263F2F918];
    v65[2] = @"Object Capture object bounding box";
    float32x4_t v48 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v46, (uint64_t)v65, v64, 3, *(_OWORD *)&a3, *(_OWORD *)&a4, *(_OWORD *)&a5);
    objc_msgSend_updateModifiedCustom_(v44, v49, (uint64_t)v48);
    if (v12)
    {
      Mutable = CGImageMetadataCreateMutable();
      if (Mutable)
      {
        uint64_t v52 = Mutable;
        if (CGImageMetadataRegisterNamespaceForPrefix(Mutable, @"http://ns.apple.com/oc/1.0/", @"oc", 0))
        {
          *(void *)&long long buf = v52;
          *((void *)&buf + 1) = @"http://ns.apple.com/oc/1.0/";
          id v67 = @"oc";
          uint64_t v68 = 1;
          CFDictionaryApplyFunction(v12, (CFDictionaryApplierFunction)sub_24B6C79DC, &buf);
          if ((_BYTE)v68)
          {
            CFDataRef XMPData = CGImageMetadataCreateXMPData(v52, 0);
            CFRelease(v52);
            if (XMPData)
            {
              objc_msgSend_updateModifiedXMP_(v44, v50, (uint64_t)XMPData);
            }
          }
          else
          {
            CFRelease(v52);
          }
        }
      }
    }
    objc_msgSend_updateModifiedExtrinsicsPosition_rotation_(v44, v50, (uint64_t)v23, v27);
    if (MEMORY[0x24C5D7190](v11, 0, v44))
    {
      uint64_t v40 = 0xFFFFFFFFLL;
    }
    else
    {
      if (qword_2697D0E48 != -1) {
        dispatch_once(&qword_2697D0E48, &unk_26FE9C940);
      }
      uint64_t v54 = qword_2697D0E40;
      if (os_log_type_enabled((os_log_t)qword_2697D0E40, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf) = 138477827;
        *(void *)((char *)&buf + 4) = v11;
        _os_log_impl(&dword_24B6B9000, v54, OS_LOG_TYPE_INFO, "CMPhoto_update: HEIF in-place update success for URL: %{private}@", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v40 = 0;
    }
  }
LABEL_5:

  return v40;
}

uint64_t OCNonModularSPI_CMPhoto_HeicWriteStop(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 4294967294;
  }
}

uint64_t OCNonModularSPI_CMPhoto_HeicWriteDestroy(CFTypeRef *a1)
{
  if (!a1) {
    return 4294967294;
  }
  CFRelease(*a1);
  free(a1);
  return 0;
}

uint64_t OCNonModularSPI_CMPhoto_HeicReadCreate(void *a1)
{
  if (!a1) {
    return 4294967294;
  }
  if (CMPhotoDecompressionSessionCreate()) {
    return 0xFFFFFFFFLL;
  }
  CFArrayRef v3 = malloc_type_malloc(8uLL, 0x2004093837F09uLL);
  uint64_t result = 0;
  void *v3 = 0;
  *a1 = v3;
  return result;
}

uint64_t OCNonModularSPI_CMPhoto_HeicReadStart(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 4294967294;
  }
}

uint64_t OCNonModularSPI_CMPhoto_readTimestamp(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  CFStringRef v8 = v5;
  uint64_t v9 = 4294967294;
  if (a1)
  {
    if (v5)
    {
      if (objc_msgSend_isFileURL(v5, v6, v7))
      {
        CFDictionaryRef v12 = objc_msgSend_pathExtension(v8, v10, v11);
        uint64_t v14 = objc_msgSend_caseInsensitiveCompare_(v12, v13, @"HEIC");

        if (a3)
        {
          if (!v14)
          {
            if (!CMPhotoDecompressionSessionCreateContainer()) {
              CMPhotoDecompressionContainerGetImageCount();
            }
            uint64_t v9 = 0xFFFFFFFFLL;
          }
        }
      }
    }
  }

  return v9;
}

BOOL sub_24B6C8EEC()
{
  return CMPhotoDecompressionContainerGetExifCountForIndex() == 0;
}

uint64_t OCNonModularSPI_CMPhoto_readResolution(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7 = a2;
  BOOL v10 = v7;
  uint64_t v11 = 4294967294;
  if (a1)
  {
    if (v7)
    {
      if (objc_msgSend_isFileURL(v7, v8, v9))
      {
        uint64_t v14 = objc_msgSend_pathExtension(v10, v12, v13);
        uint64_t v16 = objc_msgSend_caseInsensitiveCompare_(v14, v15, @"HEIC");

        uint64_t v11 = 4294967294;
        if (a4)
        {
          if (a3 && !v16)
          {
            if (!CMPhotoDecompressionSessionCreateContainer()) {
              CMPhotoDecompressionContainerGetImageCount();
            }
            uint64_t v11 = 0xFFFFFFFFLL;
          }
        }
      }
    }
  }

  return v11;
}

uint64_t OCNonModularSPI_CMPhoto_read(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFStringRef v6 = v3;
  uint64_t v7 = 4294967294;
  if (a1 && v3 && objc_msgSend_isFileURL(v3, v4, v5))
  {
    BOOL v10 = objc_msgSend_pathExtension(v6, v8, v9);
    uint64_t v12 = objc_msgSend_caseInsensitiveCompare_(v10, v11, @"HEIC");

    if (v12)
    {
      uint64_t v7 = 4294967294;
    }
    else
    {
      CFTypeRef v16 = 0;
      int v15 = 0;
      if (!CMPhotoDecompressionSessionCreateContainer())
      {
        memset(v14, 0, sizeof(v14));
        uint64_t v17 = 0;
        CMPhotoDecompressionContainerGetImageCount();
        sub_24B6CA090(v16, (uint64_t)v14);
      }
      uint64_t v7 = 0xFFFFFFFFLL;
    }
  }

  return v7;
}

uint64_t sub_24B6C9890(uint64_t a1, uint64_t a2, void *a3)
{
  if (CMPhotoDecompressionContainerGetCustomMetadataCountForIndex()) {
    return 0;
  }
  uint64_t v7 = objc_msgSend_dictionary(MEMORY[0x263EFF9A0], v4, v5);
  if (objc_msgSend_count(v7, v8, v9)) {
    *a3 = v7;
  }
  uint64_t v6 = 1;

  return v6;
}

void sub_24B6CA090(const void *a1, uint64_t a2)
{
  if (a1) {
    CFRelease(a1);
  }
  if (a2)
  {
    if (*(void *)a2) {
      CVPixelBufferRelease(*(CVPixelBufferRef *)a2);
    }
    id v3 = *(__CVBuffer **)(a2 + 8);
    if (v3) {
      CVPixelBufferRelease(v3);
    }
    CFArrayRef v4 = *(__CVBuffer **)(a2 + 16);
    if (v4) {
      CVPixelBufferRelease(v4);
    }
    uint64_t v5 = *(__CVBuffer **)(a2 + 24);
    if (v5) {
      CVPixelBufferRelease(v5);
    }
    uint64_t v6 = *(const void **)(a2 + 32);
    if (v6) {
      CFRelease(v6);
    }
    uint64_t v7 = *(const void **)(a2 + 40);
    if (v7) {
      CFRelease(v7);
    }
    CFStringRef v8 = *(const void **)(a2 + 48);
    if (v8) {
      CFRelease(v8);
    }
    uint64_t v9 = *(const void **)(a2 + 56);
    if (v9) {
      CFRelease(v9);
    }
    BOOL v10 = *(const void **)(a2 + 64);
    if (v10) {
      CFRelease(v10);
    }
    uint64_t v11 = *(const void **)(a2 + 72);
    if (v11)
    {
      CFRelease(v11);
    }
  }
}

id sub_24B6CA14C()
{
  if (qword_2697D0E48 != -1) {
    dispatch_once(&qword_2697D0E48, &unk_26FE9C940);
  }
  v0 = (void *)qword_2697D0E40;
  return v0;
}

uint64_t OCNonModularSPI_CMPhoto_readThumbnail(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  id v6 = a2;
  uint64_t v9 = v6;
  uint64_t v10 = 4294967294;
  if (a1)
  {
    if (v6)
    {
      if (objc_msgSend_isFileURL(v6, v7, v8))
      {
        uint64_t v13 = objc_msgSend_pathExtension(v9, v11, v12);
        uint64_t v15 = objc_msgSend_caseInsensitiveCompare_(v13, v14, @"HEIC");

        uint64_t v10 = 4294967294;
        if (a4)
        {
          if (!v15)
          {
            if (!CMPhotoDecompressionSessionCreateContainer()) {
              CMPhotoDecompressionContainerGetImageCount();
            }
            uint64_t v10 = 0xFFFFFFFFLL;
          }
        }
      }
    }
  }

  return v10;
}

uint64_t OCNonModularSPI_CMPhoto_readVersion(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v8 = v5;
  uint64_t v9 = 4294967294;
  if (a1)
  {
    if (v5)
    {
      int isFileURL = objc_msgSend_isFileURL(v5, v6, v7);
      if (a3)
      {
        if (isFileURL)
        {
          uint64_t v13 = objc_msgSend_pathExtension(v8, v11, v12);
          uint64_t v15 = objc_msgSend_caseInsensitiveCompare_(v13, v14, @"HEIC");

          if (v15)
          {
            uint64_t v9 = 4294967294;
          }
          else if (CMPhotoDecompressionSessionCreateContainer() {
                 || CMPhotoDecompressionContainerGetCustomMetadataCountForIndex())
          }
          {
            uint64_t v9 = 0xFFFFFFFFLL;
          }
          else
          {
            uint64_t v9 = 0;
          }
        }
      }
    }
  }

  return v9;
}

uint64_t OCNonModularSPI_CMPhoto_HeicReadStop(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 4294967294;
  }
}

uint64_t OCNonModularSPI_CMPhoto_HeicReadDestroy(CFTypeRef *a1)
{
  if (!a1) {
    return 4294967294;
  }
  CFRelease(*a1);
  free(a1);
  return 0;
}

uint64_t OCVoxelCloudCreate(unsigned int a1, long long *a2, uint64_t *a3, float a4, float32x4_t a5, __n128 a6, float32x4_t a7, int8x16_t a8)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  if (a4 <= 0.0001 || a1 == 0 || a2 == 0) {
    goto LABEL_17;
  }
  float32x4_t v13 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a5, a5.f32[0]), (float32x4_t)a6, a6.n128_f32[0]), a7, a7.f32[0]);
  float32x4_t v14 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a5, *(float32x2_t *)a5.f32, 1), (float32x4_t)a6, (float32x2_t)a6.n128_u64[0], 1), a7, *(float32x2_t *)a7.f32, 1);
  float32x4_t v15 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a5, a5, 2), (float32x4_t)a6, (float32x4_t)a6, 2), a7, a7, 2);
  float32x4_t v16 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v17 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v19 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v18, vabdq_f32(v14, v16)), (int8x16_t)vcgeq_f32(v18, vabdq_f32(v13, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v18, vabdq_f32(v15, v17)));
  v19.i32[3] = v19.i32[2];
  if ((vminvq_u32(v19) & 0x80000000) == 0) {
    goto LABEL_17;
  }
  float32x4_t v20 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a6, 2);
  float32x4_t v21 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)v20);
  float32x4_t v22 = (float32x4_t)vtrn2q_s32((int32x4_t)a5, (int32x4_t)a6);
  v22.i32[2] = a7.i32[1];
  float32x4_t v23 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)a6);
  float32x4_t v24 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v25 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, a6.n128_f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)a6.n128_u64[0], 1), v22), v20, v21), v16)), (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, a5.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 1),
                                           v22),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a5, 2),
                                         v21),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, a7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 1), v22), (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2), v21), v17)));
  v25.i32[3] = v25.i32[2];
  if ((vminvq_u32(v25) & 0x80000000) == 0) {
    goto LABEL_17;
  }
  float32x4_t v26 = vmulq_f32(a5, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a7, (int8x16_t)a7, 0xCuLL), (int8x16_t)a7, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a6, (int32x4_t)a6), (int8x16_t)a6, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a7, (int32x4_t)a7), (int8x16_t)a7, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a6, (int8x16_t)a6, 0xCuLL), (int8x16_t)a6, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a3&& (float32x2_t v28 = (float32x2_t)vdup_n_s32(0x38D1B717u), v29 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v28, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a8, a8, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(
                                        v28,
                                        vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a5, (int8x16_t)a5, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a6, (int8x16_t)a6, 8uLL))))), (vpmin_u32(v29, v29).u32[0] & 0x80000000) != 0))
  {
    id v30 = a2;
    float32x4_t v41 = a5;
    float32x4_t v43 = a7;
    uint64_t v32 = sub_24B6CAB0C(a1);
    if (v32)
    {
      uint64_t v33 = 0;
      do
      {
        long long v34 = *v30++;
        long long v35 = v34;
        HIDWORD(v35) = 1;
        *(_OWORD *)(*(void *)(v32 + 96) + v33) = v35;
        uint64_t v36 = *(void *)(v32 + 96) + v33;
        *(void *)(v36 + 16) = 0;
        *(void *)(v36 + 24) = 0;
        *(_OWORD *)(*(void *)(v32 + 96) + v33 + 32) = xmmword_24B72A590;
        v33 += 48;
      }
      while (48 * a1 != v33);
      uint64_t v37 = 0;
      *(float *)(v32 + 16) = a4;
      *(float32x4_t *)(v32 + 32) = v41;
      *(__n128 *)(v32 + 48) = a6;
      *(float32x4_t *)(v32 + 64) = v43;
      *(int8x16_t *)(v32 + 80) = a8;
      *a3 = v32;
    }
    else
    {
      if (qword_2697D0E58 != -1) {
        dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
      }
      uint64_t v40 = qword_2697D0E50;
      if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315394;
        uint64_t v46 = "OCVoxelCloudCreate";
        __int16 v47 = 1026;
        int v48 = 121;
        _os_log_error_impl(&dword_24B6B9000, v40, OS_LOG_TYPE_ERROR, "%s:%{public}d Insufficient memory.", buf, 0x12u);
      }
      return 4294967293;
    }
  }
  else
  {
LABEL_17:
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    uint64_t v38 = qword_2697D0E50;
    if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      uint64_t v46 = "OCVoxelCloudCreate";
      __int16 v47 = 1026;
      int v48 = 115;
      _os_log_error_impl(&dword_24B6B9000, v38, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
  return v37;
}

uint64_t sub_24B6CAB0C(unsigned int a1)
{
  if (qword_2697D0E68 != -1) {
    dispatch_once(&qword_2697D0E68, &unk_26FE9C980);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v3 = Instance;
  if (Instance)
  {
    size_t prime = a1;
    id v6 = *(unsigned char **)(Instance + 96);
    id v5 = *(char **)(Instance + 104);
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v5 - v6) >> 4);
    unint64_t v8 = a1 - v7;
    if (a1 <= v7)
    {
      if (a1 >= v7) {
        goto LABEL_21;
      }
      float32x4_t v20 = &v6[48 * a1];
    }
    else
    {
      uint64_t v9 = *(void *)(Instance + 112);
      if (0xAAAAAAAAAAAAAAABLL * ((v9 - (uint64_t)v5) >> 4) < v8)
      {
        unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v9 - (uint64_t)v6) >> 4);
        unint64_t v11 = 0x5555555555555556 * ((v9 - (uint64_t)v6) >> 4);
        if (v11 <= a1) {
          unint64_t v11 = a1;
        }
        if (v10 >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v12 = 0x555555555555555;
        }
        else {
          unint64_t v12 = v11;
        }
        if (v12 > 0x555555555555555) {
          sub_24B6BCD7C();
        }
        uint64_t v13 = 48 * v12;
        float32x4_t v14 = (char *)operator new(48 * v12);
        float32x4_t v15 = &v14[16 * ((v5 - v6) >> 4)];
        float32x4_t v16 = &v14[v13];
        bzero(v15, 48 * ((48 * v8 - 48) / 0x30) + 48);
        float32x4_t v17 = &v15[48 * ((48 * v8 - 48) / 0x30) + 48];
        if (v5 != v6)
        {
          do
          {
            long long v18 = *((_OWORD *)v5 - 3);
            long long v19 = *((_OWORD *)v5 - 1);
            *((_OWORD *)v15 - 2) = *((_OWORD *)v5 - 2);
            *((_OWORD *)v15 - 1) = v19;
            *((_OWORD *)v15 - 3) = v18;
            v15 -= 48;
            v5 -= 48;
          }
          while (v5 != v6);
          id v5 = *(char **)(v3 + 96);
        }
        *(void *)(v3 + 96) = v15;
        *(void *)(v3 + 104) = v17;
        *(void *)(v3 + 112) = v16;
        if (v5) {
          operator delete(v5);
        }
LABEL_21:
        *(_OWORD *)__p = 0u;
        *(_OWORD *)long long v35 = 0u;
        *(void *)&v35[16] = a1;
        int v36 = 1065353216;
        if (a1 == 1)
        {
          size_t prime = 2;
        }
        else
        {
          if ((a1 & (a1 - 1)) != 0) {
            size_t prime = std::__next_prime(a1);
          }
          if (!prime) {
            goto LABEL_27;
          }
        }
        sub_24B6BD1F0((uint64_t)__p, prime);
LABEL_27:
        if (*(void *)(v3 + 144))
        {
          float32x4_t v21 = *(void **)(v3 + 136);
          if (v21)
          {
            do
            {
              float32x4_t v22 = (void *)*v21;
              operator delete(v21);
              float32x4_t v21 = v22;
            }
            while (v22);
          }
          *(void *)(v3 + 136) = 0;
          uint64_t v23 = *(void *)(v3 + 128);
          if (v23)
          {
            for (uint64_t i = 0; i != v23; ++i)
              *(void *)(*(void *)(v3 + 120) + 8 * i) = 0;
          }
          *(void *)(v3 + 144) = 0;
        }
        uint32x4_t v25 = __p[0];
        __p[0] = 0;
        float32x4_t v26 = *(void **)(v3 + 120);
        *(void *)(v3 + 120) = v25;
        if (v26) {
          operator delete(v26);
        }
        unint64_t v28 = (unint64_t)__p[1];
        uint64_t v27 = *(void **)v35;
        *(void *)(v3 + 136) = *(void *)v35;
        *(void *)(v3 + 128) = v28;
        __p[1] = 0;
        uint64_t v29 = *(void *)&v35[8];
        *(_OWORD *)(v3 + 144) = *(_OWORD *)&v35[8];
        *(_DWORD *)(v3 + 160) = v36;
        if (v29)
        {
          unint64_t v30 = v27[1];
          if ((v28 & (v28 - 1)) != 0)
          {
            if (v30 >= v28) {
              v30 %= v28;
            }
          }
          else
          {
            v30 &= v28 - 1;
          }
          *(void *)(*(void *)(v3 + 120) + 8 * v30) = v3 + 136;
          *(_OWORD *)long long v35 = 0uLL;
        }
        else if (v27)
        {
          do
          {
            uint64_t v31 = (void *)*v27;
            operator delete(v27);
            uint64_t v27 = v31;
          }
          while (v31);
        }
        uint64_t v32 = __p[0];
        __p[0] = 0;
        if (v32) {
          operator delete(v32);
        }
        return v3;
      }
      bzero(*(void **)(Instance + 104), 48 * ((48 * v8 - 48) / 0x30) + 48);
      float32x4_t v20 = &v5[48 * ((48 * v8 - 48) / 0x30) + 48];
    }
    *(void *)(v3 + 104) = v20;
    goto LABEL_21;
  }
  return v3;
}

uint64_t sub_24B6CAE3C()
{
  qword_2697D0E70 = 0;
  *(void *)algn_2697D0E78 = "OCVoxelCloud";
  qword_2697D0E80 = (uint64_t)sub_24B6CB06C;
  unk_2697D0E88 = 0;
  qword_2697D0E98 = 0;
  unk_2697D0EA0 = 0;
  qword_2697D0E90 = (uint64_t)sub_24B6CAF60;
  qword_2697D0EA8 = (uint64_t)sub_24B6CAF04;
  qword_2697D0EB0 = (uint64_t)sub_24B6CAEB4;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_2697D0E60 = result;
  return result;
}

CFStringRef sub_24B6CAEB4(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<OCVoxelCloud %p [%p]>", a1, v3);
}

CFStringRef sub_24B6CAF04(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, @"<OCVoxelCloud %p [%p]>", a1, v5);
}

double sub_24B6CAF60(uint64_t a1)
{
  if (a1)
  {
    CFAllocatorRef v2 = *(void **)(a1 + 96);
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 96) = 0;
    if (v2) {
      operator delete(v2);
    }
    CFAllocatorRef v3 = *(void **)(a1 + 120);
    unint64_t v4 = *(void *)(a1 + 128);
    CFAllocatorRef v5 = *(void **)(a1 + 136);
    int v6 = *(_DWORD *)(a1 + 160);
    unint64_t v11 = v3;
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    unint64_t v12 = v5;
    long long v13 = *(_OWORD *)(a1 + 144);
    uint64_t v7 = v13;
    *(_OWORD *)(a1 + 144) = xmmword_24B72A600;
    *(_DWORD *)(a1 + 160) = 1065353216;
    int v14 = v6;
    if (v7)
    {
      unint64_t v8 = v5[1];
      if ((v4 & (v4 - 1)) != 0)
      {
        if (v8 >= v4) {
          v8 %= v4;
        }
        v3[v8] = &v12;
      }
      else
      {
        v3[(v4 - 1) & v8] = &v12;
      }
    }
    else if (!v5)
    {
      if (!v3)
      {
LABEL_10:
        double result = 0.0;
        *(_OWORD *)(a1 + 144) = 0u;
        *(_OWORD *)(a1 + 160) = 0u;
        *(_OWORD *)(a1 + 112) = 0u;
        *(_OWORD *)(a1 + 128) = 0u;
        *(_OWORD *)(a1 + 80) = 0u;
        *(_OWORD *)(a1 + 96) = 0u;
        *(_OWORD *)(a1 + 48) = 0u;
        *(_OWORD *)(a1 + 64) = 0u;
        *(_OWORD *)(a1 + 16) = 0u;
        *(_OWORD *)(a1 + 32) = 0u;
        return result;
      }
LABEL_9:
      operator delete(v3);
      goto LABEL_10;
    }
    do
    {
      unint64_t v10 = (void *)*v5;
      operator delete(v5);
      CFAllocatorRef v5 = v10;
    }
    while (v10);
    CFAllocatorRef v3 = v11;
    if (!v11) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  return result;
}

double sub_24B6CB06C(_OWORD *a1)
{
  double result = 0.0;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

os_log_t sub_24B6CB088()
{
  os_log_t result = os_log_create("com.apple.CoreOCModules", "VoxelHashing");
  qword_2697D0E50 = (uint64_t)result;
  return result;
}

uint64_t OCVoxelCloudCreateWithRGB(unsigned int a1, long long *a2, long long *a3, uint64_t *a4, float a5, float32x4_t a6, __n128 a7, float32x4_t a8, int8x16_t a9)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  if (a5 <= 0.0001 || a1 == 0 || a2 == 0 || a3 == 0) {
    goto LABEL_20;
  }
  float32x4_t v15 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a6, a6.f32[0]), (float32x4_t)a7, a7.n128_f32[0]), a8, a8.f32[0]);
  float32x4_t v16 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a6, *(float32x2_t *)a6.f32, 1), (float32x4_t)a7, (float32x2_t)a7.n128_u64[0], 1), a8, *(float32x2_t *)a8.f32, 1);
  float32x4_t v17 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a6, a6, 2), (float32x4_t)a7, (float32x4_t)a7, 2), a8, a8, 2);
  float32x4_t v18 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v19 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v20 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v21 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v20, vabdq_f32(v16, v18)), (int8x16_t)vcgeq_f32(v20, vabdq_f32(v15, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v20, vabdq_f32(v17, v19)));
  v21.i32[3] = v21.i32[2];
  if ((vminvq_u32(v21) & 0x80000000) == 0) {
    goto LABEL_20;
  }
  float32x4_t v22 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2);
  float32x4_t v23 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a6, (int32x4_t)a8), (int32x4_t)v22);
  float32x4_t v24 = (float32x4_t)vtrn2q_s32((int32x4_t)a6, (int32x4_t)a7);
  v24.i32[2] = a8.i32[1];
  float32x4_t v25 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a6, (int32x4_t)a8), (int32x4_t)a7);
  float32x4_t v26 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v27 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v26, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v25, a7.n128_f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)a7.n128_u64[0], 1), v24), v22, v23), v18)), (int8x16_t)vcgeq_f32(v26, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v25, a6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 1),
                                           v24),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a6, 2),
                                         v23),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v26, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v25, a8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a8.f32, 1), v24), (float32x4_t)vdupq_laneq_s32((int32x4_t)a8, 2), v23), v19)));
  v27.i32[3] = v27.i32[2];
  if ((vminvq_u32(v27) & 0x80000000) == 0) {
    goto LABEL_20;
  }
  float32x4_t v28 = vmulq_f32(a6, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a8, (int8x16_t)a8, 0xCuLL), (int8x16_t)a8, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a7, (int32x4_t)a7), (int8x16_t)a7, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a8, (int32x4_t)a8), (int8x16_t)a8, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a7, (int8x16_t)a7, 0xCuLL), (int8x16_t)a7, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a4&& (float32x2_t v30 = (float32x2_t)vdup_n_s32(0x38D1B717u), v31 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v30, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a8, (int8x16_t)a8, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a9, a9, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(
                                        v30,
                                        vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a6, (int8x16_t)a6, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL))))), (vpmin_u32(v31, v31).u32[0] & 0x80000000) != 0))
  {
    uint64_t v32 = a3;
    uint64_t v33 = a2;
    float32x4_t v46 = a6;
    float32x4_t v48 = a8;
    uint64_t v35 = sub_24B6CAB0C(a1);
    if (v35)
    {
      uint64_t v36 = 0;
      do
      {
        long long v37 = *v33++;
        long long v38 = v37;
        HIDWORD(v38) = 1;
        *(_OWORD *)(*(void *)(v35 + 96) + v36) = v38;
        uint64_t v39 = *(void *)(v35 + 96) + v36;
        *(void *)(v39 + 16) = 0;
        *(void *)(v39 + 24) = 0;
        long long v40 = *v32++;
        long long v41 = v40;
        HIDWORD(v41) = 1.0;
        *(_OWORD *)(*(void *)(v35 + 96) + v36 + 32) = v41;
        v36 += 48;
      }
      while (48 * a1 != v36);
      uint64_t v42 = 0;
      *(float *)(v35 + 16) = a5;
      *(float32x4_t *)(v35 + 32) = v46;
      *(__n128 *)(v35 + 48) = a7;
      *(float32x4_t *)(v35 + 64) = v48;
      *(int8x16_t *)(v35 + 80) = a9;
      *a4 = v35;
    }
    else
    {
      if (qword_2697D0E58 != -1) {
        dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
      }
      uint64_t v45 = qword_2697D0E50;
      if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315394;
        uint64_t v51 = "OCVoxelCloudCreateWithRGB";
        __int16 v52 = 1026;
        int v53 = 148;
        _os_log_error_impl(&dword_24B6B9000, v45, OS_LOG_TYPE_ERROR, "%s:%{public}d Insufficient memory.", buf, 0x12u);
      }
      return 4294967293;
    }
  }
  else
  {
LABEL_20:
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    float32x4_t v43 = qword_2697D0E50;
    if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      uint64_t v51 = "OCVoxelCloudCreateWithRGB";
      __int16 v52 = 1026;
      int v53 = 142;
      _os_log_error_impl(&dword_24B6B9000, v43, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
  return v42;
}

uint64_t OCVoxelCloudCreateWithNormal(unsigned int a1, long long *a2, long long *a3, uint64_t *a4, float a5, float32x4_t a6, __n128 a7, float32x4_t a8, int8x16_t a9)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  if (a5 <= 0.0001 || a1 == 0 || a2 == 0 || a3 == 0) {
    goto LABEL_20;
  }
  float32x4_t v15 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a6, a6.f32[0]), (float32x4_t)a7, a7.n128_f32[0]), a8, a8.f32[0]);
  float32x4_t v16 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a6, *(float32x2_t *)a6.f32, 1), (float32x4_t)a7, (float32x2_t)a7.n128_u64[0], 1), a8, *(float32x2_t *)a8.f32, 1);
  float32x4_t v17 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a6, a6, 2), (float32x4_t)a7, (float32x4_t)a7, 2), a8, a8, 2);
  float32x4_t v18 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v19 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v20 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v21 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v20, vabdq_f32(v16, v18)), (int8x16_t)vcgeq_f32(v20, vabdq_f32(v15, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v20, vabdq_f32(v17, v19)));
  v21.i32[3] = v21.i32[2];
  if ((vminvq_u32(v21) & 0x80000000) == 0) {
    goto LABEL_20;
  }
  float32x4_t v22 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2);
  float32x4_t v23 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a6, (int32x4_t)a8), (int32x4_t)v22);
  float32x4_t v24 = (float32x4_t)vtrn2q_s32((int32x4_t)a6, (int32x4_t)a7);
  v24.i32[2] = a8.i32[1];
  float32x4_t v25 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a6, (int32x4_t)a8), (int32x4_t)a7);
  float32x4_t v26 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v27 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v26, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v25, a7.n128_f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)a7.n128_u64[0], 1), v24), v22, v23), v18)), (int8x16_t)vcgeq_f32(v26, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v25, a6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 1),
                                           v24),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a6, 2),
                                         v23),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v26, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v25, a8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a8.f32, 1), v24), (float32x4_t)vdupq_laneq_s32((int32x4_t)a8, 2), v23), v19)));
  v27.i32[3] = v27.i32[2];
  if ((vminvq_u32(v27) & 0x80000000) == 0) {
    goto LABEL_20;
  }
  float32x4_t v28 = vmulq_f32(a6, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a8, (int8x16_t)a8, 0xCuLL), (int8x16_t)a8, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a7, (int32x4_t)a7), (int8x16_t)a7, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a8, (int32x4_t)a8), (int8x16_t)a8, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a7, (int8x16_t)a7, 0xCuLL), (int8x16_t)a7, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a4&& (float32x2_t v30 = (float32x2_t)vdup_n_s32(0x38D1B717u), v31 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v30, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a8, (int8x16_t)a8, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a9, a9, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(
                                        v30,
                                        vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a6, (int8x16_t)a6, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL))))), (vpmin_u32(v31, v31).u32[0] & 0x80000000) != 0))
  {
    uint64_t v32 = a3;
    uint64_t v33 = a2;
    float32x4_t v45 = a6;
    float32x4_t v47 = a8;
    uint64_t v35 = sub_24B6CAB0C(a1);
    if (v35)
    {
      uint64_t v36 = 0;
      do
      {
        long long v37 = *v33++;
        long long v38 = v37;
        HIDWORD(v38) = 1;
        *(_OWORD *)(*(void *)(v35 + 96) + v36) = v38;
        long long v39 = *v32++;
        long long v40 = v39;
        HIDWORD(v40) = 1.0;
        *(_OWORD *)(*(void *)(v35 + 96) + v36 + 16) = v40;
        *(_OWORD *)(*(void *)(v35 + 96) + v36 + 32) = xmmword_24B72A590;
        v36 += 48;
      }
      while (48 * a1 != v36);
      uint64_t v41 = 0;
      *(float *)(v35 + 16) = a5;
      *(float32x4_t *)(v35 + 32) = v45;
      *(__n128 *)(v35 + 48) = a7;
      *(float32x4_t *)(v35 + 64) = v47;
      *(int8x16_t *)(v35 + 80) = a9;
      *a4 = v35;
    }
    else
    {
      if (qword_2697D0E58 != -1) {
        dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
      }
      uint64_t v44 = qword_2697D0E50;
      if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315394;
        uint64_t v50 = "OCVoxelCloudCreateWithNormal";
        __int16 v51 = 1026;
        int v52 = 175;
        _os_log_error_impl(&dword_24B6B9000, v44, OS_LOG_TYPE_ERROR, "%s:%{public}d Insufficient memory.", buf, 0x12u);
      }
      return 4294967293;
    }
  }
  else
  {
LABEL_20:
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    uint64_t v42 = qword_2697D0E50;
    if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      uint64_t v50 = "OCVoxelCloudCreateWithNormal";
      __int16 v51 = 1026;
      int v52 = 169;
      _os_log_error_impl(&dword_24B6B9000, v42, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
  return v41;
}

uint64_t OCVoxelCloudCreateWithRGBNormal(unsigned int a1, long long *a2, long long *a3, long long *a4, uint64_t *a5, float a6, float32x4_t a7, __n128 a8, float32x4_t a9, int8x16_t a10)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (a6 <= 0.0001 || a1 == 0 || a2 == 0 || a3 == 0) {
    goto LABEL_21;
  }
  float32x4_t v16 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a7, a7.f32[0]), (float32x4_t)a8, a8.n128_f32[0]), a9, a9.f32[0]);
  float32x4_t v17 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a7, *(float32x2_t *)a7.f32, 1), (float32x4_t)a8, (float32x2_t)a8.n128_u64[0], 1), a9, *(float32x2_t *)a9.f32, 1);
  float32x4_t v18 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a7, a7, 2), (float32x4_t)a8, (float32x4_t)a8, 2), a9, a9, 2);
  float32x4_t v19 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v20 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v21 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v22 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v21, vabdq_f32(v17, v19)), (int8x16_t)vcgeq_f32(v21, vabdq_f32(v16, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v21, vabdq_f32(v18, v20)));
  v22.i32[3] = v22.i32[2];
  if ((vminvq_u32(v22) & 0x80000000) == 0) {
    goto LABEL_21;
  }
  float32x4_t v23 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a8, 2);
  float32x4_t v24 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a7, (int32x4_t)a9), (int32x4_t)v23);
  float32x4_t v25 = (float32x4_t)vtrn2q_s32((int32x4_t)a7, (int32x4_t)a8);
  v25.i32[2] = a9.i32[1];
  float32x4_t v26 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a7, (int32x4_t)a9), (int32x4_t)a8);
  float32x4_t v27 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v28 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v27, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v26, a8.n128_f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)a8.n128_u64[0], 1), v25), v23, v24), v19)), (int8x16_t)vcgeq_f32(v27, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v26, a7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 1),
                                           v25),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2),
                                         v24),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v27, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v26, a9.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a9.f32, 1), v25), (float32x4_t)vdupq_laneq_s32((int32x4_t)a9, 2), v24), v20)));
  v28.i32[3] = v28.i32[2];
  if ((vminvq_u32(v28) & 0x80000000) == 0) {
    goto LABEL_21;
  }
  float32x4_t v29 = vmulq_f32(a7, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a9, (int8x16_t)a9, 0xCuLL), (int8x16_t)a9, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a8, (int32x4_t)a8), (int8x16_t)a8, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a9, (int32x4_t)a9), (int8x16_t)a9, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a8, (int8x16_t)a8, 0xCuLL), (int8x16_t)a8, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a5&& (v31 = a4) != 0&& (v32 = (float32x2_t)vdup_n_s32(0x38D1B717u), uint32x2_t v33 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v32, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a9, (int8x16_t)a9, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a10, a10, 8uLL)), (float32x2_t)0xBF80000080000000))),
                            (int8x8_t)vcge_f32(v32, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a8, (int8x16_t)a8, 8uLL))))), (vpmin_u32(v33, v33).u32[0] & 0x80000000) != 0))
  {
    long long v34 = a3;
    uint64_t v35 = a2;
    float32x4_t v49 = a7;
    float32x4_t v51 = a9;
    uint64_t v37 = sub_24B6CAB0C(a1);
    if (v37)
    {
      uint64_t v38 = 0;
      do
      {
        long long v39 = *v35++;
        long long v40 = v39;
        HIDWORD(v40) = 1;
        *(_OWORD *)(*(void *)(v37 + 96) + v38) = v40;
        long long v41 = *v31++;
        long long v42 = v41;
        HIDWORD(v42) = 1.0;
        *(_OWORD *)(*(void *)(v37 + 96) + v38 + 16) = v42;
        long long v43 = *v34++;
        long long v44 = v43;
        HIDWORD(v44) = 1.0;
        *(_OWORD *)(*(void *)(v37 + 96) + v38 + 32) = v44;
        v38 += 48;
      }
      while (48 * a1 != v38);
      uint64_t v45 = 0;
      *(float *)(v37 + 16) = a6;
      *(float32x4_t *)(v37 + 32) = v49;
      *(__n128 *)(v37 + 48) = a8;
      *(float32x4_t *)(v37 + 64) = v51;
      *(int8x16_t *)(v37 + 80) = a10;
      *a5 = v37;
    }
    else
    {
      if (qword_2697D0E58 != -1) {
        dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
      }
      float32x4_t v48 = qword_2697D0E50;
      if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315394;
        uint64_t v54 = "OCVoxelCloudCreateWithRGBNormal";
        __int16 v55 = 1026;
        int v56 = 202;
        _os_log_error_impl(&dword_24B6B9000, v48, OS_LOG_TYPE_ERROR, "%s:%{public}d Insufficient memory.", buf, 0x12u);
      }
      return 4294967293;
    }
  }
  else
  {
LABEL_21:
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    float32x4_t v46 = qword_2697D0E50;
    if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      uint64_t v54 = "OCVoxelCloudCreateWithRGBNormal";
      __int16 v55 = 1026;
      int v56 = 196;
      _os_log_error_impl(&dword_24B6B9000, v46, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
  return v45;
}

uint64_t OCVoxelCloudCreateFromOCVoxels(unsigned int a1, const void *a2, uint64_t *a3, float a4, float32x4_t a5, __n128 a6, float32x4_t a7, int8x16_t a8)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  if (a4 <= 0.0001 || a1 == 0 || a2 == 0) {
    goto LABEL_15;
  }
  float32x4_t v13 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a5, a5.f32[0]), (float32x4_t)a6, a6.n128_f32[0]), a7, a7.f32[0]);
  float32x4_t v14 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a5, *(float32x2_t *)a5.f32, 1), (float32x4_t)a6, (float32x2_t)a6.n128_u64[0], 1), a7, *(float32x2_t *)a7.f32, 1);
  float32x4_t v15 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a5, a5, 2), (float32x4_t)a6, (float32x4_t)a6, 2), a7, a7, 2);
  float32x4_t v16 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v17 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v19 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v18, vabdq_f32(v14, v16)), (int8x16_t)vcgeq_f32(v18, vabdq_f32(v13, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v18, vabdq_f32(v15, v17)));
  v19.i32[3] = v19.i32[2];
  if ((vminvq_u32(v19) & 0x80000000) == 0) {
    goto LABEL_15;
  }
  float32x4_t v20 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a6, 2);
  float32x4_t v21 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)v20);
  float32x4_t v22 = (float32x4_t)vtrn2q_s32((int32x4_t)a5, (int32x4_t)a6);
  v22.i32[2] = a7.i32[1];
  float32x4_t v23 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)a6);
  float32x4_t v24 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v25 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, a6.n128_f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)a6.n128_u64[0], 1), v22), v20, v21), v16)), (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, a5.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 1),
                                           v22),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a5, 2),
                                         v21),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, a7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 1), v22), (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2), v21), v17)));
  v25.i32[3] = v25.i32[2];
  if ((vminvq_u32(v25) & 0x80000000) == 0) {
    goto LABEL_15;
  }
  float32x4_t v26 = vmulq_f32(a5, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a7, (int8x16_t)a7, 0xCuLL), (int8x16_t)a7, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a6, (int32x4_t)a6), (int8x16_t)a6, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a7, (int32x4_t)a7), (int8x16_t)a7, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a6, (int8x16_t)a6, 0xCuLL), (int8x16_t)a6, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a3&& (float32x2_t v28 = (float32x2_t)vdup_n_s32(0x38D1B717u), v29 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v28, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a8, a8, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(
                                        v28,
                                        vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a5, (int8x16_t)a5, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a6, (int8x16_t)a6, 8uLL))))), (vpmin_u32(v29, v29).u32[0] & 0x80000000) != 0))
  {
    float32x4_t v37 = a5;
    float32x4_t v39 = a7;
    uint64_t v32 = sub_24B6CAB0C(a1);
    if (v32)
    {
      uint64_t v33 = v32;
      *(float *)(v32 + 16) = a4;
      *(float32x4_t *)(v32 + 32) = v37;
      *(__n128 *)(v32 + 48) = a6;
      *(float32x4_t *)(v32 + 64) = v39;
      *(int8x16_t *)(v32 + 80) = a8;
      memcpy(*(void **)(v32 + 96), a2, 48 * a1);
      uint64_t result = 0;
      *a3 = v33;
    }
    else
    {
      if (qword_2697D0E58 != -1) {
        dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
      }
      uint64_t v36 = qword_2697D0E50;
      if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315394;
        long long v42 = "OCVoxelCloudCreateFromOCVoxels";
        __int16 v43 = 1026;
        int v44 = 228;
        _os_log_error_impl(&dword_24B6B9000, v36, OS_LOG_TYPE_ERROR, "%s:%{public}d Insufficient memory.", buf, 0x12u);
      }
      return 4294967293;
    }
  }
  else
  {
LABEL_15:
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    uint64_t v35 = qword_2697D0E50;
    if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      long long v42 = "OCVoxelCloudCreateFromOCVoxels";
      __int16 v43 = 1026;
      int v44 = 222;
      _os_log_error_impl(&dword_24B6B9000, v35, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
  return result;
}

uint64_t OCVoxelCloudCreateFromOCPoints(unsigned int a1, uint64_t a2, uint64_t *a3, float a4, float32x4_t a5, __n128 a6, float32x4_t a7, int8x16_t a8)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  if (a4 <= 0.0001 || a1 == 0 || a2 == 0) {
    goto LABEL_17;
  }
  float32x4_t v13 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a5, a5.f32[0]), (float32x4_t)a6, a6.n128_f32[0]), a7, a7.f32[0]);
  float32x4_t v14 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a5, *(float32x2_t *)a5.f32, 1), (float32x4_t)a6, (float32x2_t)a6.n128_u64[0], 1), a7, *(float32x2_t *)a7.f32, 1);
  float32x4_t v15 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a5, a5, 2), (float32x4_t)a6, (float32x4_t)a6, 2), a7, a7, 2);
  float32x4_t v16 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v17 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v19 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v18, vabdq_f32(v14, v16)), (int8x16_t)vcgeq_f32(v18, vabdq_f32(v13, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v18, vabdq_f32(v15, v17)));
  v19.i32[3] = v19.i32[2];
  if ((vminvq_u32(v19) & 0x80000000) == 0) {
    goto LABEL_17;
  }
  float32x4_t v20 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a6, 2);
  float32x4_t v21 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)v20);
  float32x4_t v22 = (float32x4_t)vtrn2q_s32((int32x4_t)a5, (int32x4_t)a6);
  v22.i32[2] = a7.i32[1];
  float32x4_t v23 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)a6);
  float32x4_t v24 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v25 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, a6.n128_f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)a6.n128_u64[0], 1), v22), v20, v21), v16)), (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, a5.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 1),
                                           v22),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a5, 2),
                                         v21),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, a7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 1), v22), (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2), v21), v17)));
  v25.i32[3] = v25.i32[2];
  if ((vminvq_u32(v25) & 0x80000000) == 0) {
    goto LABEL_17;
  }
  float32x4_t v26 = vmulq_f32(a5, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a7, (int8x16_t)a7, 0xCuLL), (int8x16_t)a7, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a6, (int32x4_t)a6), (int8x16_t)a6, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a7, (int32x4_t)a7), (int8x16_t)a7, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a6, (int8x16_t)a6, 0xCuLL), (int8x16_t)a6, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a3&& (float32x2_t v28 = (float32x2_t)vdup_n_s32(0x38D1B717u), v29 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v28, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a8, a8, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(
                                        v28,
                                        vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a5, (int8x16_t)a5, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a6, (int8x16_t)a6, 8uLL))))), (vpmin_u32(v29, v29).u32[0] & 0x80000000) != 0))
  {
    float32x4_t v39 = a5;
    float32x4_t v41 = a7;
    uint64_t v32 = sub_24B6CAB0C(a1);
    if (v32)
    {
      uint64_t v33 = 0;
      do
      {
        *(int32x2_t *)&long long v34 = vcvt_s32_f32(vrndm_f32(*(float32x2_t *)(a2 + v33)));
        *((void *)&v34 + 1) = vcvtms_s32_f32(*(float *)(a2 + v33 + 8)) | 0x100000000;
        *(_OWORD *)(*(void *)(v32 + 96) + v33) = v34;
        *(_OWORD *)(*(void *)(v32 + 96) + v33 + 16) = *(_OWORD *)(a2 + v33 + 16);
        *(_OWORD *)(*(void *)(v32 + 96) + v33 + 32) = *(_OWORD *)(a2 + v33 + 32);
        v33 += 48;
      }
      while (48 * a1 != v33);
      uint64_t v35 = 0;
      *(float *)(v32 + 16) = a4;
      *(float32x4_t *)(v32 + 32) = v39;
      *(__n128 *)(v32 + 48) = a6;
      *(float32x4_t *)(v32 + 64) = v41;
      *(int8x16_t *)(v32 + 80) = a8;
      *a3 = v32;
    }
    else
    {
      if (qword_2697D0E58 != -1) {
        dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
      }
      uint64_t v38 = qword_2697D0E50;
      if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315394;
        int v44 = "OCVoxelCloudCreateFromOCPoints";
        __int16 v45 = 1026;
        int v46 = 249;
        _os_log_error_impl(&dword_24B6B9000, v38, OS_LOG_TYPE_ERROR, "%s:%{public}d Insufficient memory.", buf, 0x12u);
      }
      return 4294967293;
    }
  }
  else
  {
LABEL_17:
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    uint64_t v36 = qword_2697D0E50;
    if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      int v44 = "OCVoxelCloudCreateFromOCPoints";
      __int16 v45 = 1026;
      int v46 = 243;
      _os_log_error_impl(&dword_24B6B9000, v36, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
  return v35;
}

CFTypeRef OCVoxelCloudRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

void OCVoxelCloudRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t OCVoxelCloudSize(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return -1431655765 * ((*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 4);
  }
  if (qword_2697D0E58 != -1) {
    dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
  }
  CFAllocatorRef v2 = qword_2697D0E50;
  uint64_t result = os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v3 = 136315394;
    unint64_t v4 = "OCVoxelCloudSize";
    __int16 v5 = 1026;
    int v6 = 283;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid voxelcloud.", (uint8_t *)&v3, 0x12u);
    return 0;
  }
  return result;
}

uint64_t OCVoxelCloudVoxels(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (!a1 || (uint64_t result = *(void *)(a1 + 96), result == *(void *)(a1 + 104)))
  {
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    int v3 = qword_2697D0E50;
    if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
    {
      int v4 = 136315394;
      __int16 v5 = "OCVoxelCloudVoxels";
      __int16 v6 = 1026;
      int v7 = 292;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid voxelcloud.", (uint8_t *)&v4, 0x12u);
    }
    return 0;
  }
  return result;
}

uint64_t OCVoxelCloudVoxelAt(uint64_t a1, unint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 96);
    if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 104) - v2) >> 4) > a2) {
      return v2 + 48 * a2;
    }
  }
  if (qword_2697D0E58 != -1) {
    dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
  }
  int v4 = qword_2697D0E50;
  if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
  {
    int v5 = 136315394;
    __int16 v6 = "OCVoxelCloudVoxelAt";
    __int16 v7 = 1026;
    int v8 = 301;
    _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid voxelcloud.", (uint8_t *)&v5, 0x12u);
  }
  return 0;
}

uint64_t OCVoxelCloudBuildSpatialInfo(uint64_t a1)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 96);
    uint64_t v3 = *(void *)(a1 + 104);
    if (v4 == v3)
    {
      if (qword_2697D0E58 != -1) {
        dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
      }
      uint64_t v38 = qword_2697D0E50;
      if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315394;
        float32x4_t v41 = "OCVoxelCloudBuildSpatialInfo";
        __int16 v42 = 1026;
        int v43 = 315;
        _os_log_error_impl(&dword_24B6B9000, v38, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to build spatial info.", buf, 0x12u);
      }
      return 0xFFFFFFFFLL;
    }
    else
    {
      int v5 = (uint64_t *)(a1 + 120);
      if (*(void *)(a1 + 144))
      {
        __int16 v6 = *(void **)(a1 + 136);
        if (v6)
        {
          do
          {
            __int16 v7 = (void *)*v6;
            operator delete(v6);
            __int16 v6 = v7;
          }
          while (v7);
        }
        *(void *)(a1 + 136) = 0;
        uint64_t v8 = *(void *)(a1 + 128);
        if (v8)
        {
          for (uint64_t i = 0; i != v8; ++i)
            *(void *)(*v5 + 8 * i) = 0;
        }
        *(void *)(a1 + 144) = 0;
        uint64_t v4 = *(void *)(a1 + 96);
        uint64_t v3 = *(void *)(a1 + 104);
      }
      if (v3 != v4)
      {
        unint64_t v10 = 0;
        unint64_t v11 = (int32x4_t **)(a1 + 136);
        do
        {
          int32x4_t v12 = *(int32x4_t *)(v4 + 48 * v10);
          v13.i64[1] = v12.i32[3];
          v13.i64[0] = 83492791 * (int)*(void *)(v4 + 48 * v10 + 8);
          int64x2_t v14 = vmull_s32(*(int32x2_t *)v12.i8, (int32x2_t)0x12740A50466F45DLL);
          unint64_t v15 = veorq_s8((int8x16_t)vdupq_laneq_s64(v14, 1), veorq_s8(v13, (int8x16_t)v14)).u64[0]
              % *(void *)(a1 + 152);
          unint64_t v16 = *(void *)(a1 + 128);
          if (v16)
          {
            uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
            v17.i16[0] = vaddlv_u8(v17);
            if (v17.u32[0] > 1uLL)
            {
              unint64_t v1 = v15;
              if (v15 >= v16) {
                unint64_t v1 = v15 % v16;
              }
            }
            else
            {
              unint64_t v1 = (v16 - 1) & v15;
            }
            float32x4_t v18 = *(int32x4_t ***)(*v5 + 8 * v1);
            if (v18)
            {
              uint32x4_t v19 = *v18;
              if (*v18)
              {
                if (v17.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v23 = v19->i64[1];
                    if (v23 == v15)
                    {
                      uint32x4_t v22 = (uint32x4_t)vceqq_s32(v19[1], v12);
                      v22.i32[3] = v22.i32[2];
                      if ((vminvq_u32(v22) & 0x80000000) != 0) {
                        goto LABEL_70;
                      }
                    }
                    else if ((v23 & (v16 - 1)) != v1)
                    {
                      goto LABEL_32;
                    }
                    uint32x4_t v19 = (int32x4_t *)v19->i64[0];
                    if (!v19) {
                      goto LABEL_32;
                    }
                  }
                }
                do
                {
                  unint64_t v21 = v19->u64[1];
                  if (v21 == v15)
                  {
                    uint32x4_t v20 = (uint32x4_t)vceqq_s32(v19[1], v12);
                    v20.i32[3] = v20.i32[2];
                    if ((vminvq_u32(v20) & 0x80000000) != 0) {
                      goto LABEL_70;
                    }
                  }
                  else
                  {
                    if (v21 >= v16) {
                      v21 %= v16;
                    }
                    if (v21 != v1) {
                      break;
                    }
                  }
                  uint32x4_t v19 = (int32x4_t *)v19->i64[0];
                }
                while (v19);
              }
            }
          }
LABEL_32:
          int32x4_t v39 = *(int32x4_t *)(v4 + 48 * v10);
          uint32x4_t v19 = (int32x4_t *)operator new(0x30uLL);
          v19->i64[0] = 0;
          v19->i64[1] = v15;
          v19[1] = v39;
          v19[2].i64[0] = 0;
          float v24 = (float)(unint64_t)(*(void *)(a1 + 144) + 1);
          float v25 = *(float *)(a1 + 160);
          if (!v16 || (float)(v25 * (float)v16) < v24)
          {
            BOOL v26 = (v16 & (v16 - 1)) != 0;
            if (v16 < 3) {
              BOOL v26 = 1;
            }
            unint64_t v27 = v26 | (2 * v16);
            unint64_t v28 = vcvtps_u32_f32(v24 / v25);
            if (v27 <= v28) {
              size_t prime = v28;
            }
            else {
              size_t prime = v27;
            }
            if (prime == 1)
            {
              size_t prime = 2;
            }
            else if ((prime & (prime - 1)) != 0)
            {
              size_t prime = std::__next_prime(prime);
              unint64_t v16 = *(void *)(a1 + 128);
            }
            if (prime > v16) {
              goto LABEL_44;
            }
            if (prime < v16)
            {
              unint64_t v30 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 144) / *(float *)(a1 + 160));
              if (v16 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v16), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
              {
                unint64_t v30 = std::__next_prime(v30);
              }
              else
              {
                uint64_t v32 = 1 << -(char)__clz(v30 - 1);
                if (v30 >= 2) {
                  unint64_t v30 = v32;
                }
              }
              if (prime <= v30) {
                size_t prime = v30;
              }
              if (prime < v16) {
LABEL_44:
              }
                sub_24B6BD1F0(a1 + 120, prime);
            }
            unint64_t v16 = *(void *)(a1 + 128);
            if ((v16 & (v16 - 1)) != 0)
            {
              if (v15 >= v16) {
                unint64_t v1 = v15 % v16;
              }
              else {
                unint64_t v1 = v15;
              }
            }
            else
            {
              unint64_t v1 = (v16 - 1) & v15;
            }
          }
          uint64_t v33 = *v5;
          long long v34 = *(int32x4_t ***)(*v5 + 8 * v1);
          if (v34)
          {
            v19->i64[0] = (uint64_t)*v34;
          }
          else
          {
            v19->i64[0] = (uint64_t)*v11;
            *unint64_t v11 = v19;
            *(void *)(v33 + 8 * v1) = v11;
            if (!v19->i64[0]) {
              goto LABEL_69;
            }
            unint64_t v35 = *(void *)(v19->i64[0] + 8);
            if ((v16 & (v16 - 1)) != 0)
            {
              if (v35 >= v16) {
                v35 %= v16;
              }
            }
            else
            {
              v35 &= v16 - 1;
            }
            long long v34 = (int32x4_t **)(*v5 + 8 * v35);
          }
          *long long v34 = v19;
LABEL_69:
          ++*(void *)(a1 + 144);
          uint64_t v4 = *(void *)(a1 + 96);
          uint64_t v3 = *(void *)(a1 + 104);
LABEL_70:
          v19[2].i64[0] = v10++;
        }
        while (v10 < 0xAAAAAAAAAAAAAAABLL * ((v3 - v4) >> 4));
      }
      return 0;
    }
  }
  else
  {
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    float32x4_t v37 = qword_2697D0E50;
    if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      float32x4_t v41 = "OCVoxelCloudBuildSpatialInfo";
      __int16 v42 = 1026;
      int v43 = 310;
      _os_log_error_impl(&dword_24B6B9000, v37, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid voxelcloud.", buf, 0x12u);
    }
    return 4294967294;
  }
}

uint64_t OCVoxelCloudVoxelIndexFromPosition(void *a1, int32x4_t a2, double a3, double a4, int8x16_t a5)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    unint64_t v10 = qword_2697D0E50;
    if (!os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR)) {
      return -1;
    }
    int v20 = 136315394;
    unint64_t v21 = "OCVoxelCloudVoxelIndexFromPosition";
    __int16 v22 = 1026;
    int v23 = 325;
    unint64_t v11 = "%s:%{public}d Invalid voxelcloud.";
    goto LABEL_37;
  }
  if (!a1[18])
  {
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    unint64_t v10 = qword_2697D0E50;
    if (!os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR)) {
      return -1;
    }
    int v20 = 136315394;
    unint64_t v21 = "OCVoxelCloudVoxelIndexFromPosition";
    __int16 v22 = 1026;
    int v23 = 333;
    unint64_t v11 = "%s:%{public}d Spatial map is empty. Note: You must call OCVoxelCloudBuildSpatialInfo once before using OCVoxel"
          "CloudVoxelIndexFromPosition.";
    goto LABEL_37;
  }
  int8x8_t v5 = (int8x8_t)a1[16];
  if (!*(void *)&v5) {
    goto LABEL_31;
  }
  int64x2_t v6 = vmull_s32(*(int32x2_t *)a2.i8, (int32x2_t)0x12740A50466F45DLL);
  a5.i64[0] = 83492791 * a2.i32[2];
  unint64_t v7 = veorq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), veorq_s8(a5, (int8x16_t)v6)).u64[0] % a1[19];
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v5);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v9 = v7;
    if (v7 >= *(void *)&v5) {
      unint64_t v9 = v7 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v7;
  }
  int32x4_t v12 = *(int32x4_t ***)(a1[15] + 8 * v9);
  if (!v12 || (int8x16_t v13 = *v12) == 0)
  {
LABEL_31:
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    unint64_t v10 = qword_2697D0E50;
    if (!os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR)) {
      return -1;
    }
    int v20 = 136315394;
    unint64_t v21 = "OCVoxelCloudVoxelIndexFromPosition";
    __int16 v22 = 1026;
    int v23 = 339;
    unint64_t v11 = "%s:%{public}d Voxel position not found in map.";
LABEL_37:
    _os_log_error_impl(&dword_24B6B9000, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v20, 0x12u);
    return -1;
  }
  if (v8.u32[0] < 2uLL)
  {
    uint64_t v14 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v18 = v13->i64[1];
      if (v18 == v7)
      {
        uint32x4_t v17 = (uint32x4_t)vceqq_s32(v13[1], a2);
        v17.i32[3] = v17.i32[2];
        if ((vminvq_u32(v17) & 0x80000000) != 0) {
          return v13[2].i64[0];
        }
      }
      else if ((v18 & v14) != v9)
      {
        goto LABEL_31;
      }
      int8x16_t v13 = (int32x4_t *)v13->i64[0];
      if (!v13) {
        goto LABEL_31;
      }
    }
  }
  while (1)
  {
    unint64_t v16 = v13->u64[1];
    if (v16 == v7) {
      break;
    }
    if (v16 >= *(void *)&v5) {
      v16 %= *(void *)&v5;
    }
    if (v16 != v9) {
      goto LABEL_31;
    }
LABEL_21:
    int8x16_t v13 = (int32x4_t *)v13->i64[0];
    if (!v13) {
      goto LABEL_31;
    }
  }
  uint32x4_t v15 = (uint32x4_t)vceqq_s32(v13[1], a2);
  v15.i32[3] = v15.i32[2];
  if ((vminvq_u32(v15) & 0x80000000) == 0) {
    goto LABEL_21;
  }
  return v13[2].i64[0];
}

double OCVoxelCloudVoxelDimension(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    unint64_t v1 = (const float *)(a1 + 16);
    *(void *)&double result = vld1q_dup_f32(v1).u64[0];
  }
  else
  {
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    uint64_t v3 = qword_2697D0E50;
    BOOL v4 = os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR);
    double result = 0.0;
    if (v4)
    {
      int v5 = 136315394;
      int64x2_t v6 = "OCVoxelCloudVoxelDimension";
      __int16 v7 = 1026;
      int v8 = 348;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid voxelcloud.", (uint8_t *)&v5, 0x12u);
      return 0.0;
    }
  }
  return result;
}

double OCVoxelCloudGetData@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 96);
    *(_DWORD *)(a2 + 80) = -1431655765 * ((unint64_t)(*(void *)(a1 + 104) - v3) >> 4);
    long long v4 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 32);
    *(_OWORD *)(a2 + 32) = v4;
    long long v6 = *(_OWORD *)(a1 + 64);
    long long v5 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)(a2 + 48) = v6;
    *(_OWORD *)(a2 + 64) = v5;
    LODWORD(v6) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)a2 = v6;
    *(void *)(a2 + 88) = v3;
  }
  else
  {
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    __int16 v7 = qword_2697D0E50;
    if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315394;
      unint64_t v10 = "OCVoxelCloudGetData";
      __int16 v11 = 1026;
      int v12 = 357;
      _os_log_error_impl(&dword_24B6B9000, v7, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid voxelcloud.", (uint8_t *)&v9, 0x12u);
    }
    *(void *)&long long v6 = 0;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
  return *(double *)&v6;
}

double OCVoxelCloudTransformMatrix(float32x4_t *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(void *)&double result = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(a1[2], a1[1].f32[0]), (float32x4_t)0, a1[3]), (float32x4_t)0, a1[4]), (float32x4_t)0, a1[5]).u64[0];
  }
  else
  {
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    uint64_t v2 = qword_2697D0E50;
    if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315394;
      long long v4 = "OCVoxelCloudTransformMatrix";
      __int16 v5 = 1026;
      int v6 = 371;
      _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid voxelcloud.", (uint8_t *)&v3, 0x12u);
    }
    return 0.0;
  }
  return result;
}

uint64_t OCFramingStationsGetTypeID()
{
  if (qword_2697D0ED0 != -1) {
    dispatch_once(&qword_2697D0ED0, &unk_26FE9C9A0);
  }
  return qword_2697D0ED8;
}

uint64_t sub_24B6CD3F8()
{
  qword_2697D0EE0 = 0;
  *(void *)algn_2697D0EE8 = "OCFramingStations";
  qword_2697D0EF0 = (uint64_t)sub_24B6CD59C;
  unk_2697D0EF8 = 0;
  qword_2697D0F08 = 0;
  unk_2697D0F10 = 0;
  qword_2697D0F00 = (uint64_t)sub_24B6CD510;
  qword_2697D0F18 = (uint64_t)sub_24B6CD4C0;
  qword_2697D0F20 = (uint64_t)sub_24B6CD470;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_2697D0ED8 = result;
  return result;
}

CFStringRef sub_24B6CD470(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<OCFramingStations %p [%p]>", a1, v3);
}

CFStringRef sub_24B6CD4C0(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<OCFramingStations %p [%p]>", a1, v3);
}

uint64_t sub_24B6CD510(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFAllocatorRef v2 = *(void **)(result + 16);
    if (v2)
    {
      CFAllocatorRef v3 = (void *)v2[12];
      if (v3)
      {
        do
        {
          long long v4 = (void *)*v3;
          operator delete(v3);
          CFAllocatorRef v3 = v4;
        }
        while (v4);
      }
      __int16 v5 = (void *)v2[10];
      v2[10] = 0;
      if (v5) {
        operator delete(v5);
      }
      int v6 = (void *)v2[6];
      if (v6)
      {
        v2[7] = v6;
        operator delete(v6);
      }
      uint64_t result = MEMORY[0x24C5D7790](v2, 0x10A0C402D199CC2);
    }
    *(void *)(v1 + 16) = 0;
  }
  return result;
}

uint64_t sub_24B6CD59C(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t sub_24B6CD5A4(uint64_t a1, void *a2)
{
  if (qword_2697D0ED0 != -1) {
    dispatch_once(&qword_2697D0ED0, &unk_26FE9C9A0);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294967293;
  }
  int v6 = (void *)Instance;
  uint64_t v7 = operator new(0x80uLL, MEMORY[0x263F8C180]);
  if (!v7)
  {
    v6[2] = 0;
    CFRelease(v6);
    return 4294967293;
  }
  int v8 = v7;
  uint64_t v9 = *(void *)(a1 + 16);
  long long v11 = *(_OWORD *)(v9 + 16);
  long long v10 = *(_OWORD *)(v9 + 32);
  _OWORD *v7 = *(_OWORD *)v9;
  v7[1] = v11;
  v7[2] = v10;
  *((void *)v7 + 7) = 0;
  *((void *)v7 + 8) = 0;
  *((void *)v7 + 6) = 0;
  uint64_t v13 = *(unsigned char **)(v9 + 48);
  int v12 = *(unsigned char **)(v9 + 56);
  int64_t v14 = v12 - v13;
  if (v12 != v13)
  {
    if (v14 < 0) {
      abort();
    }
    uint32x4_t v15 = (char *)operator new(v12 - v13);
    *((void *)v8 + 6) = v15;
    int8x8_t v2 = (int8x8_t)&v15[64 * (v14 >> 6)];
    *((int8x8_t *)v8 + 8) = v2;
    memcpy(v15, v13, v14);
    *((int8x8_t *)v8 + 7) = v2;
  }
  int v16 = *(_DWORD *)(v9 + 72);
  v8[5] = 0u;
  uint32x4_t v17 = (uint64_t *)(v8 + 5);
  *((_DWORD *)v8 + 18) = v16;
  v8[6] = 0u;
  *((_DWORD *)v8 + 28) = *(_DWORD *)(v9 + 112);
  size_t prime = *(void *)(v9 + 88);
  int v46 = a2;
  if (prime != 1)
  {
    if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      int8x8_t v2 = *(int8x8_t *)((char *)v8 + 88);
      BOOL v20 = prime >= *(void *)&v2;
      if (prime > *(void *)&v2) {
        goto LABEL_26;
      }
    }
    else
    {
      int8x8_t v2 = 0;
      BOOL v20 = 1;
      if (prime) {
        goto LABEL_26;
      }
    }
    if (v20) {
      goto LABEL_27;
    }
    unint64_t v21 = vcvtps_u32_f32((float)*((unint64_t *)v8 + 13) / *((float *)v8 + 28));
    if (*(void *)&v2 < 3uLL || (uint8x8_t v22 = (uint8x8_t)vcnt_s8(v2), v22.i16[0] = vaddlv_u8(v22), v22.u32[0] > 1uLL))
    {
      unint64_t v21 = std::__next_prime(v21);
    }
    else
    {
      uint64_t v23 = 1 << -(char)__clz(v21 - 1);
      if (v21 >= 2) {
        unint64_t v21 = v23;
      }
    }
    if (prime <= v21) {
      size_t prime = v21;
    }
    if (prime >= *(void *)&v2) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  size_t prime = 2;
LABEL_26:
  sub_24B6BD1F0((uint64_t)(v8 + 5), prime);
LABEL_27:
  uint64_t v24 = *(uint64_t ***)(v9 + 96);
  if (v24)
  {
    float v25 = v8 + 6;
    unint64_t v26 = *((void *)v8 + 11);
    do
    {
      unint64_t v27 = *((unsigned int *)v24 + 4);
      if (v26)
      {
        uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v26);
        v28.i16[0] = vaddlv_u8(v28);
        if (v28.u32[0] > 1uLL)
        {
          int8x8_t v2 = (int8x8_t)*((unsigned int *)v24 + 4);
          if (v26 <= v27) {
            int8x8_t v2 = (int8x8_t)(v27 % v26);
          }
        }
        else
        {
          int8x8_t v2 = (int8x8_t)((v26 - 1) & v27);
        }
        uint32x2_t v29 = *(uint64_t ***)(*v17 + 8 * *(void *)&v2);
        if (v29)
        {
          unint64_t v30 = *v29;
          if (v30)
          {
            if (v28.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v32 = v30[1];
                if (v32 == v27)
                {
                  if (*((_DWORD *)v30 + 4) == v27) {
                    goto LABEL_87;
                  }
                }
                else if ((v32 & (v26 - 1)) != *(void *)&v2)
                {
                  goto LABEL_49;
                }
                unint64_t v30 = (uint64_t *)*v30;
                if (!v30) {
                  goto LABEL_49;
                }
              }
            }
            do
            {
              unint64_t v31 = v30[1];
              if (v31 == v27)
              {
                if (*((_DWORD *)v30 + 4) == v27) {
                  goto LABEL_87;
                }
              }
              else
              {
                if (v31 >= v26) {
                  v31 %= v26;
                }
                if (v31 != *(void *)&v2) {
                  break;
                }
              }
              unint64_t v30 = (uint64_t *)*v30;
            }
            while (v30);
          }
        }
      }
LABEL_49:
      uint64_t v33 = operator new(0x18uLL);
      *uint64_t v33 = 0;
      v33[1] = v27;
      v33[2] = v24[2];
      float v34 = (float)(unint64_t)(*((void *)v8 + 13) + 1);
      float v35 = *((float *)v8 + 28);
      if (!v26 || (float)(v35 * (float)v26) < v34)
      {
        BOOL v36 = (v26 & (v26 - 1)) != 0;
        if (v26 < 3) {
          BOOL v36 = 1;
        }
        unint64_t v37 = v36 | (2 * v26);
        unint64_t v38 = vcvtps_u32_f32(v34 / v35);
        if (v37 <= v38) {
          size_t v39 = v38;
        }
        else {
          size_t v39 = v37;
        }
        if (v39 == 1)
        {
          size_t v39 = 2;
        }
        else if ((v39 & (v39 - 1)) != 0)
        {
          size_t v39 = std::__next_prime(v39);
          unint64_t v26 = *((void *)v8 + 11);
        }
        if (v39 > v26) {
          goto LABEL_61;
        }
        if (v39 < v26)
        {
          unint64_t v40 = vcvtps_u32_f32((float)*((unint64_t *)v8 + 13) / *((float *)v8 + 28));
          if (v26 < 3 || (uint8x8_t v41 = (uint8x8_t)vcnt_s8((int8x8_t)v26), v41.i16[0] = vaddlv_u8(v41), v41.u32[0] > 1uLL))
          {
            unint64_t v40 = std::__next_prime(v40);
          }
          else
          {
            uint64_t v42 = 1 << -(char)__clz(v40 - 1);
            if (v40 >= 2) {
              unint64_t v40 = v42;
            }
          }
          if (v39 <= v40) {
            size_t v39 = v40;
          }
          if (v39 < v26) {
LABEL_61:
          }
            sub_24B6BD1F0((uint64_t)(v8 + 5), v39);
        }
        unint64_t v26 = *((void *)v8 + 11);
        if ((v26 & (v26 - 1)) != 0)
        {
          if (v26 <= v27) {
            int8x8_t v2 = (int8x8_t)(v27 % v26);
          }
          else {
            int8x8_t v2 = (int8x8_t)v27;
          }
        }
        else
        {
          int8x8_t v2 = (int8x8_t)((v26 - 1) & v27);
        }
      }
      uint64_t v43 = *v17;
      uint64_t v44 = *(void **)(*v17 + 8 * *(void *)&v2);
      if (v44)
      {
        *uint64_t v33 = *v44;
      }
      else
      {
        *uint64_t v33 = *v25;
        *float v25 = v33;
        *(void *)(v43 + 8 * *(void *)&v2) = v25;
        if (!*v33) {
          goto LABEL_86;
        }
        unint64_t v45 = *(void *)(*v33 + 8);
        if ((v26 & (v26 - 1)) != 0)
        {
          if (v45 >= v26) {
            v45 %= v26;
          }
        }
        else
        {
          v45 &= v26 - 1;
        }
        uint64_t v44 = (void *)(*v17 + 8 * v45);
      }
      *uint64_t v44 = v33;
LABEL_86:
      ++*((void *)v8 + 13);
LABEL_87:
      uint64_t v24 = (uint64_t **)*v24;
    }
    while (v24);
  }
  uint64_t result = 0;
  v6[2] = v8;
  void *v46 = v6;
  return result;
}

CFTypeRef OCFramingStationsRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

void OCFramingStationsRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t OCFramingStationsStationAt(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(*(void *)(result + 16) + 48);
    uint64_t v3 = *(void *)(*(void *)(result + 16) + 56) - v2;
    if (((unint64_t)v3 >> 6) <= a2)
    {
      return 0;
    }
    else
    {
      if (a2 >= (unint64_t)(v3 >> 6)) {
        abort();
      }
      return v2 + ((unint64_t)a2 << 6);
    }
  }
  return result;
}

uint64_t OCFramingStationsCount(uint64_t result)
{
  if (result) {
    return (*(void *)(*(void *)(result + 16) + 56) - *(void *)(*(void *)(result + 16) + 48)) >> 6;
  }
  return result;
}

uint64_t OCFramingStationsData(uint64_t result)
{
  if (result) {
    return *(void *)(*(void *)(result + 16) + 48);
  }
  return result;
}

uint64_t OCFramingStationsFindBestUnfinishedStation(uint64_t a1, _DWORD *a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, float32x4_t a10)
{
  if (!a1) {
    return 4294967294;
  }
  uint64_t v10 = *(void *)(*(void *)(a1 + 16) + 48);
  unint64_t v11 = *(void *)(*(void *)(a1 + 16) + 56) - v10;
  if ((v11 & 0x3FFFFFFFC0) == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = 0;
  int v13 = 0;
  float32x4_t v14 = vmlaq_f32(vmulq_f32(a7, (float32x4_t)0), (float32x4_t)0, a8);
  __asm { FMOV            V5.4S, #-1.0 }
  float32x4_t v20 = vmlaq_f32(vmlaq_f32(v14, _Q5, a9), (float32x4_t)0, a10);
  uint64_t v21 = (v11 >> 6);
  char v22 = 1;
  float v23 = 0.07;
LABEL_4:
  uint64_t v24 = (float32x2_t *)(v10 + (v12 << 6));
  do
  {
    if ((v24[6].i32[0] - 1) <= 1)
    {
      int8x16_t v25 = (int8x16_t)vmulq_f32(v20, vmlaq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a3, COERCE_FLOAT(*(_OWORD *)v24[2].f32)), a4, v24[2], 1), a5, *(float32x4_t *)v24[2].f32, 2), (float32x4_t)0, a6));
      if (vaddv_f32(vadd_f32(*(float32x2_t *)v25.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL))) < -0.7)
      {
        float32x4_t v26 = vaddq_f32(a6, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a3, COERCE_FLOAT(*(_OWORD *)v24->f32)), a4, *v24, 1), a5, *(float32x4_t *)v24->f32, 2));
        int8x16_t v27 = (int8x16_t)vmulq_f32(v20, vsubq_f32(v26, a10));
        float32x2_t v28 = vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL));
        if (vaddv_f32(v28) > 0.0)
        {
          float32x4_t v29 = vsubq_f32(vmlaq_n_f32(a10, v20, vadd_f32(v28, (float32x2_t)vdup_lane_s32((int32x2_t)v28, 1)).f32[0]), v26);
          int8x16_t v30 = (int8x16_t)vmulq_f32(v29, v29);
          float v31 = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL))));
          if (v31 < v23)
          {
            char v22 = 0;
            int v13 = v12++;
            float v23 = v31;
            if (v12 != v21) {
              goto LABEL_4;
            }
            goto LABEL_15;
          }
        }
      }
    }
    ++v12;
    v24 += 8;
  }
  while (v21 != v12);
  if (v22) {
    return 0xFFFFFFFFLL;
  }
LABEL_15:
  uint64_t result = 0;
  *a2 = v13;
  return result;
}

void OCFramingStationsDefaultCameraTransform(float32x4_t *a1)
{
  float32x4_t v2 = a1[1];
  LODWORD(v3) = a1[1].i64[1];
  LODWORD(v4) = HIDWORD(a1[1].i64[0]);
  float v5 = 1.0
     / sqrtf((float)(vmulq_f32(v2, v2).f32[0] + vmuls_lane_f32(v4, *(float32x2_t *)v2.f32, 1)) + vmuls_lane_f32(v3, v2, 2));
  float v6 = v5 * v2.f32[0];
  float v7 = vmuls_lane_f32(v5, *(float32x2_t *)v2.f32, 1);
  float v8 = vmuls_lane_f32(v5, v2, 2);
  __asm { FMOV            V5.2S, #1.0 }
  uint64_t v68 = _D5;
  LODWORD(v69) = 1065353216;
  if (fabsf(v6) <= 0.000001)
  {
    if (fabsf(v7) <= 0.000001)
    {
      float v16 = 1.0;
      float v17 = 1.0;
      float v18 = 1.0;
      if (fabsf(v8) <= 0.000001) {
        goto LABEL_8;
      }
      uint64_t v14 = 2;
      float v15 = v8;
    }
    else
    {
      uint64_t v14 = 1;
      float v15 = v7;
    }
  }
  else
  {
    uint64_t v14 = 0;
    float v15 = v6;
  }
  *((float *)&v68 + v14) = (float)-(float)((float)(v8 + (float)(v6 + v7)) + (float)((float)-v15 * *((float *)&v68 + v14)))
                         / v15;
  float v19 = 1.0
      / sqrtf((float)((float)(*(float *)&v68 * *(float *)&v68) + (float)(*((float *)&v68 + 1) * *((float *)&v68 + 1)))+ (float)(*(float *)&v69 * *(float *)&v69));
  float v17 = *(float *)&v68 * v19;
  float v16 = *((float *)&v68 + 1) * v19;
  *(float *)&uint64_t v68 = *(float *)&v68 * v19;
  *((float *)&v68 + 1) = *((float *)&v68 + 1) * v19;
  float v18 = *(float *)&v69 * v19;
  *(float *)&uint64_t v69 = *(float *)&v69 * v19;
LABEL_8:
  float32x2_t v54 = *(float32x2_t *)v2.f32;
  v61.columns[0].i64[0] = (uint64_t)v68;
  v61.columns[0].i32[2] = (int)v69;
  v61.columns[0].f32[3] = (float)(v4 * v18) - (float)(v3 * v16);
  v61.columns[1].f32[0] = (float)(v3 * v17) - (float)(v2.f32[0] * v18);
  v61.columns[1].f32[1] = (float)(v2.f32[0] * v16) - (float)(v4 * v17);
  uint64_t v93 = &v61;
  uint64_t v71 = &v93;
  id v72 = &v61;
  unsigned long long v62 = 0uLL;
  sub_24B6EDA40((uint64_t)&v62, (uint64_t)&v71);
  v64[0] = __invert_f2((simd_float2x2)v62);
  *(void *)uint64_t v75 = &v61;
  *(void *)&v75[8] = v64;
  memset(v66, 0, 24);
  *(double *)v20.i64 = sub_24B6EDB28((uint64_t)v66, (float **)v75);
  v20.i32[0] = DWORD2(v66[0]);
  v21.i32[0] = DWORD1(v66[1]);
  v22.i64[0] = v61.columns[0].i64[0];
  float32x4_t v23 = (float32x4_t)vzip1q_s32(v22, vdupq_lane_s32(*(int32x2_t *)v61.columns[0].f32, 1));
  v24.i64[0] = *(uint64_t *)((char *)&v61.columns[0].i64[1] + 4);
  float32x4_t v25 = (float32x4_t)vzip1q_s32(v24, vdupq_lane_s32(*(int32x2_t *)((char *)&v61.columns[0].u64[1] + 4), 1));
  v26.i64[0] = *(void *)&v66[0];
  v27.i64[0] = *(void *)((char *)v66 + 12);
  float32x2_t v57 = vmla_n_f32(vmla_n_f32(0, *(float32x2_t *)&v66[0], v61.columns[0].f32[0]), *(float32x2_t *)((char *)v66 + 12), v61.columns[0].f32[3]);
  float32x4_t v28 = (float32x4_t)vextq_s8(vextq_s8(v20, v20, 4uLL), v26, 0xCuLL);
  v28.i32[3] = v28.i32[0];
  float32x4_t v29 = vmlaq_f32((float32x4_t)0, v23, v28);
  float32x4_t v30 = (float32x4_t)vextq_s8(vextq_s8(v21, v21, 4uLL), v27, 0xCuLL);
  v30.i32[3] = v30.i32[0];
  float32x4_t v58 = vmlaq_f32(v29, v25, v30);
  float32x2_t v59 = vmla_n_f32(vmla_n_f32(0, *(float32x2_t *)&v66[0], v61.columns[0].f32[2]), *(float32x2_t *)((char *)v66 + 12), v61.columns[1].f32[1]);
  float v31 = 0.0;
  float v60 = (float)((float)(*((float *)v66 + 2) * v61.columns[0].f32[2]) + 0.0)
      + (float)(*((float *)&v66[1] + 1) * v61.columns[1].f32[1]);
  float32x2_t v55 = 0;
  v56[0] = 0;
  v56[1] = 1065353216;
  *(void *)&v66[0] = &v57;
  *((void *)&v66[0] + 1) = (char *)v56 + 4;
  sub_24B6CE324((float *)&v55, (float **)v66);
  if (fabsf(v55.f32[0]) > 0.000001 || fabsf(v55.f32[1]) > 0.000001 || fabsf(*(float *)v56) > 0.000001)
  {
    float v35 = 1.0
        / sqrtf((float)((float)(v55.f32[0] * v55.f32[0]) + (float)(v55.f32[1] * v55.f32[1]))+ (float)(*(float *)v56 * *(float *)v56));
    v55.f32[0] = v55.f32[0] * v35;
    v55.f32[1] = v55.f32[1] * v35;
    float v31 = *(float *)v56 * v35;
    *(float *)int v56 = *(float *)v56 * v35;
    float32x2_t v32 = vneg_f32(v54);
    float v33 = -v3;
    float32x2_t v34 = v55;
  }
  else
  {
    float32x2_t v32 = (float32x2_t)0xBF80000000000000;
    float v33 = 0.0;
    float32x2_t v34 = (float32x2_t)1065353216;
  }
  _Q0 = vmlaq_n_f32(*a1, a1[1], a1[2].f32[0]);
  float v37 = (float)(vmuls_lane_f32(v31, v32, 1) - vmuls_lane_f32(v33, v34, 1)) + _Q0.f32[0];
  float v38 = _Q0.f32[1] + (float)((float)(v33 * v34.f32[0]) - (float)(v31 * v32.f32[0]));
  float v39 = _Q0.f32[2] + (float)(vmuls_lane_f32(v32.f32[0], v34, 1) - vmuls_lane_f32(v34.f32[0], v32, 1));
  v34.f32[0] = _Q0.f32[0] + v34.f32[0];
  v32.f32[0] = _Q0.f32[0] - v32.f32[0];
  float v40 = _Q0.f32[2] - v33;
  float v87 = (float)((float)((float)(v37 + v34.f32[0]) + v32.f32[0]) + _Q0.f32[0]) * 0.25;
  float v88 = (float)((float)((float)(v38 + (float)(_Q0.f32[1] + v34.f32[1])) + (float)(_Q0.f32[1] - v32.f32[1])) + _Q0.f32[1])
      * 0.25;
  float v41 = (float)((float)((float)(v39 + (float)(_Q0.f32[2] + v31)) + v40) + _Q0.f32[2]) * 0.25;
  v92[0] = v37 - v87;
  v92[1] = v38 - v88;
  v92[2] = v39 - v41;
  v91[0] = v34.f32[0] - v87;
  v91[1] = (float)(_Q0.f32[1] + v34.f32[1]) - v88;
  v91[2] = (float)(_Q0.f32[2] + v31) - v41;
  float v89 = v41;
  v90[0] = v32.f32[0] - v87;
  v90[1] = (float)(_Q0.f32[1] - v32.f32[1]) - v88;
  v90[2] = v40 - v41;
  *(float *)&uint64_t v93 = _Q0.f32[0] - v87;
  *((float *)&v93 + 1) = _Q0.f32[1] - v88;
  float v94 = _Q0.f32[2] - v41;
  __asm { FMOV            V0.2S, #0.25 }
  uint64_t v77 = _Q0.i64[0];
  int v78 = 1048576000;
  unint64_t v85 = 0xBE8000003F400000;
  int v86 = -1098907648;
  uint64_t v83 = 0x3F400000BE800000;
  int v84 = -1098907648;
  __asm { FMOV            V0.2S, #-0.25 }
  uint64_t v81 = _Q0.i64[0];
  int v82 = 1061158912;
  uint64_t v79 = _Q0.i64[0];
  int v80 = -1098907648;
  uint64_t v74 = v92;
  *(void *)&v64[0] = &v85;
  *((void *)&v64[0] + 1) = &v74;
  uint64_t v73 = v91;
  *(void *)&unsigned long long v62 = &v83;
  *((void *)&v62 + 1) = &v73;
  memset((char *)v66 + 4, 0, 36);
  sub_24B6EC3A4((uint64_t)v66 + 4, (uint64_t)v64);
  memset((char *)&v66[2] + 8, 0, 36);
  uint64_t v42 = (simd_float2x2 *)&v62;
  sub_24B6EC3A4((uint64_t)&v66[2] + 8, (uint64_t)&v62);
  id v70 = v90;
  uint64_t v71 = (simd_float4x4 **)&v81;
  id v72 = (simd_float4x4 *)&v70;
  *(void *)uint64_t v75 = v66;
  memset(&v75[8], 0, 32);
  int v76 = 0;
  sub_24B6EC3A4((uint64_t)&v75[8], (uint64_t)&v71);
  id v67 = &v93;
  uint64_t v68 = &v79;
  uint64_t v69 = &v67;
  v61.columns[0].i64[0] = (uint64_t)v75;
  memset(&v61.columns[0].u32[2], 0, 36);
  sub_24B6EC3A4((uint64_t)&v61.columns[0].i64[1], (uint64_t)&v68);
  float v43 = (float)((float)(*(float *)(*(void *)v61.columns[0].i64[0] + 36)
                      + *(float *)(*(void *)v61.columns[0].i64[0] + 72))
              + *(float *)(v61.columns[0].i64[0] + 40))
      + v61.columns[2].f32[2];
  float32x4_t v44 = vaddq_f32(vaddq_f32(vaddq_f32(*(float32x4_t *)(*(void *)v61.columns[0].i64[0] + 4), *(float32x4_t *)(*(void *)v61.columns[0].i64[0] + 40)), *(float32x4_t *)(v61.columns[0].i64[0] + 8)), *(float32x4_t *)((char *)v61.columns + 8));
  float32x4_t v45 = vaddq_f32(vaddq_f32(vaddq_f32(*(float32x4_t *)(*(void *)v61.columns[0].i64[0] + 20), *(float32x4_t *)(*(void *)v61.columns[0].i64[0] + 56)), *(float32x4_t *)(v61.columns[0].i64[0] + 24)), *(float32x4_t *)((char *)&v61.columns[1] + 8));
  memset(v66, 0, 93);
  *(void *)((char *)&v66[5] + 4) = 0x300000003;
  v61.columns[0] = (simd_float4)v44;
  v61.columns[1] = (simd_float4)v45;
  v61.columns[2].f32[0] = v43;
  sub_24B6EC49C((uint64_t)v66);
  *(_DWORD *)&v75[32] = v66[2];
  *(_OWORD *)uint64_t v75 = v66[0];
  *(_OWORD *)&v75[16] = v66[1];
  v64[0] = *(_OWORD *)((char *)&v66[2] + 4);
  v64[1] = *(_OWORD *)((char *)&v66[3] + 4);
  int v65 = DWORD1(v66[4]);
  v61.columns[0].i64[0] = (uint64_t)v75;
  v61.columns[0].i64[1] = (uint64_t)v64;
  memset(&v62, 0, 32);
  int v63 = 0;
  sub_24B6EC5C0((uint64_t)&v62, (float **)&v61);
  uint64_t v71 = (simd_float4x4 **)&v62;
  id v72 = (simd_float4x4 *)&v87;
  v61.columns[0] = (simd_float4)(unint64_t)&v77;
  v61.columns[1].i32[0] = 0;
  sub_24B6CE324(&v61.columns[0].f32[2], (float **)&v71);
  int v46 = 0;
  uint64_t v47 = 0;
  float v48 = *(float *)(v61.columns[0].i64[0] + 8);
  uint64_t v68 = (uint64_t *)vsub_f32(*(float32x2_t *)v61.columns[0].i64[0], *(float32x2_t *)&v61.columns[0].u32[2]);
  *(float *)&uint64_t v69 = v48 - v61.columns[1].f32[0];
  memset(&v61, 0, sizeof(v61));
  do
  {
    __int32 v49 = v42->columns[0].i32[0];
    uint64_t v42 = (simd_float2x2 *)((char *)v42 + 4);
    v61.columns[0].i32[v47] = v49;
    if (v46 > 1) {
      ++v47;
    }
    ++v47;
    if (v46 <= 1) {
      ++v46;
    }
    else {
      int v46 = 0;
    }
  }
  while (v47 != 12);
  int v50 = 0;
  float32x4_t v51 = (__int32 *)&v68;
  for (uint64_t i = 12; i != 16; ++i)
  {
    __int32 v53 = *v51++;
    v61.columns[0].i32[i] = v53;
    if (v50 > 1) {
      ++i;
    }
    if (v50 <= 1) {
      ++v50;
    }
    else {
      int v50 = 0;
    }
  }
  __invert_f4(v61);
}

float *sub_24B6CE324(float *result, float **a2)
{
  float32x4_t v2 = result;
  float v3 = *a2;
  if (*a2 == result || (float v4 = a2[1], v4 == result))
  {
    int v6 = 0;
    uint64_t v5 = 0;
    uint64_t result = (float *)sub_24B6CE324(&v5);
    *(void *)float32x4_t v2 = v5;
    *((_DWORD *)v2 + 2) = v6;
  }
  else
  {
    *uint64_t result = (float)((float)((float)(*v3 * *v4) + 0.0) + (float)(v3[3] * v4[1])) + (float)(v3[6] * v4[2]);
    result[1] = (float)((float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[4] * v4[1])) + (float)(v3[7] * v4[2]);
    result[2] = (float)((float)((float)(v3[2] * *v4) + 0.0) + (float)(v3[5] * v4[1])) + (float)(v3[8] * v4[2]);
  }
  return result;
}

uint64_t OCProxySurfaceCreate(uint64_t a1, void *a2)
{
  uint64_t v111 = *MEMORY[0x263EF8340];
  if (!a1 || !a2) {
    goto LABEL_48;
  }
  if (*(_DWORD *)a1 >= 2u)
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    float v3 = qword_2697D0F40;
    if (!os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "isConfigurationValid";
    LOWORD(v79) = 1026;
    *(_DWORD *)((char *)&v79 + 2) = 46;
    float v4 = "%s:%{public}d Invalid pipeline type.";
    goto LABEL_47;
  }
  if (*(_DWORD *)(a1 + 16) >= 5u)
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    float v3 = qword_2697D0F40;
    if (!os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "isConfigurationValid";
    LOWORD(v79) = 1026;
    *(_DWORD *)((char *)&v79 + 2) = 52;
    float v4 = "%s:%{public}d Invalid input type.";
    goto LABEL_47;
  }
  if (*(_DWORD *)(a1 + 20) >= 2u)
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    float v3 = qword_2697D0F40;
    if (!os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "isConfigurationValid";
    LOWORD(v79) = 1026;
    *(_DWORD *)((char *)&v79 + 2) = 57;
    float v4 = "%s:%{public}d Invalid mode type.";
    goto LABEL_47;
  }
  float v5 = *(float *)(a1 + 24);
  float v6 = fabsf(v5);
  if (v5 < 0.0 && v6 > 0.000001)
  {
    char v9 = 0;
  }
  else
  {
    BOOL v8 = fabsf(v5 + -1.0) <= 0.000011;
    char v9 = v5 <= 1.0 || v8;
  }
  if (*(float *)(a1 + 32) < 0.0001 || !*(unsigned char *)(a1 + 36) || *(float *)(a1 + 40) < 1.0 || !*(_DWORD *)(a1 + 28)) {
    goto LABEL_43;
  }
  float v11 = *(float *)(a1 + 44);
  float v10 = *(float *)(a1 + 48);
  float v12 = fabsf(v11);
  BOOL v13 = v10 > 0.0;
  if (fabsf(v10) <= 0.000001) {
    BOOL v13 = 1;
  }
  BOOL v14 = v12 > 0.000001 && v11 < 0.0;
  BOOL v15 = v14 || v10 <= v11;
  if (v15 || !v13) {
    goto LABEL_43;
  }
  if (*(float *)(a1 + 72) <= 0.0) {
    char v9 = 0;
  }
  if (*(float *)(a1 + 64) <= 0.0 || *(float *)(a1 + 68) <= 0.0 || (v9 & 1) == 0)
  {
LABEL_43:
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    float v3 = qword_2697D0F40;
    if (!os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "isConfigurationValid";
    LOWORD(v79) = 1026;
    *(_DWORD *)((char *)&v79 + 2) = 70;
    float v4 = "%s:%{public}d Invalid voxel integrator config.";
LABEL_47:
    _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, v4, buf, 0x12u);
LABEL_48:
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    float v17 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "OCProxySurfaceCreate";
      LOWORD(v79) = 1026;
      *(_DWORD *)((char *)&v79 + 2) = 51;
      _os_log_error_impl(&dword_24B6B9000, v17, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create OCProxySurface - invalid config.", buf, 0x12u);
    }
    return 4294967294;
  }
  if (!*(_DWORD *)(a1 + 96) || !*(_DWORD *)(a1 + 100))
  {
    int8x16_t v20 = sub_24B6CF610();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "isConfigurationValid";
      LOWORD(v79) = 1026;
      *(_DWORD *)((char *)&v79 + 2) = 76;
      _os_log_error_impl(&dword_24B6B9000, v20, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid surface sampling config.", buf, 0x12u);
    }
    goto LABEL_83;
  }
  if (*(float *)(a1 + 104) < 0.0)
  {
    float v19 = sub_24B6CF610();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      double v30 = *(float *)(a1 + 104);
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "isConfigurationValid";
      uint64_t v79 = 0x802000000530402;
      double v80 = v30;
      _os_log_error_impl(&dword_24B6B9000, v19, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid value for pointCloudSamplingConfig.sampledPointRandomOffsetStdDev = %{public}f", buf, 0x1Cu);
    }

    goto LABEL_48;
  }
  if (*(_DWORD *)(a1 + 112) >= 3u)
  {
    int8x16_t v20 = sub_24B6CF610();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "isConfigurationValid";
      LOWORD(v79) = 1026;
      *(_DWORD *)((char *)&v79 + 2) = 89;
      _os_log_error_impl(&dword_24B6B9000, v20, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid depth rendering config.", buf, 0x12u);
    }
LABEL_83:

    goto LABEL_48;
  }
  if (!*(_DWORD *)(a1 + 116) || !*(_DWORD *)(a1 + 120))
  {
    int8x16_t v20 = sub_24B6CF610();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "isConfigurationValid";
      LOWORD(v79) = 1026;
      *(_DWORD *)((char *)&v79 + 2) = 96;
      _os_log_error_impl(&dword_24B6B9000, v20, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid coverage config.", buf, 0x12u);
    }
    goto LABEL_83;
  }
  int32x4_t v22 = operator new(0x50uLL, MEMORY[0x263F8C180]);
  if (!v22)
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    float32x4_t v29 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "OCProxySurfaceCreate";
      LOWORD(v79) = 1026;
      *(_DWORD *)((char *)&v79 + 2) = 57;
      _os_log_error_impl(&dword_24B6B9000, v29, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create OCProxySurface - out of memory.", buf, 0x12u);
    }
    return 4294967293;
  }
  float32x4_t v23 = v22;
  *((_OWORD *)v22 + 3) = 0u;
  *((_OWORD *)v22 + 4) = 0u;
  *((_OWORD *)v22 + 1) = 0u;
  *((_OWORD *)v22 + 2) = 0u;
  *(_OWORD *)int32x4_t v22 = 0u;
  *((unsigned char *)v22 + 56) = *(unsigned char *)(a1 + 4);
  dispatch_queue_t v24 = dispatch_queue_create("com.apple.coreocmodules.proxysurfaceserialqueue", 0);
  float32x4_t v25 = (void *)v23[2];
  v23[2] = v24;

  if (!v23[2])
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    float v31 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "OCProxySurfaceCreate";
      LOWORD(v79) = 1026;
      *(_DWORD *)((char *)&v79 + 2) = 66;
      _os_log_error_impl(&dword_24B6B9000, v31, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create OCProxySurface - failed to create serial queue.", buf, 0x12u);
    }
    goto LABEL_114;
  }
  dispatch_group_t v26 = dispatch_group_create();
  int8x16_t v27 = (void *)v23[8];
  v23[8] = v26;

  if (!v23[8])
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    float32x2_t v32 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "OCProxySurfaceCreate";
      LOWORD(v79) = 1026;
      *(_DWORD *)((char *)&v79 + 2) = 74;
      _os_log_error_impl(&dword_24B6B9000, v32, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create OCProxySurface - failed to create pipeline task group.", buf, 0x12u);
    }
    goto LABEL_114;
  }
  int v28 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 >= 2u) {
    int v28 = 2;
  }
  if (v28 == 1) {
    operator new();
  }
  if (!v28) {
    operator new();
  }
  uint64_t v33 = 0;
  uint64_t v34 = v23[3];
  v23[3] = 0;
  if (v34)
  {
    (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
    uint64_t v33 = v23[3];
  }
  if (!v33)
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    float v48 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "OCProxySurfaceCreate";
      LOWORD(v79) = 1026;
      *(_DWORD *)((char *)&v79 + 2) = 82;
      _os_log_error_impl(&dword_24B6B9000, v48, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create OCProxySurface - failed to create voxelhashing pipeline.", buf, 0x12u);
    }
LABEL_114:
    OCProxySurfaceDestroy((uint64_t)v23);
    return 0xFFFFFFFFLL;
  }
  v36.columns[0] = (simd_float4)*MEMORY[0x263EF89A8];
  v36.columns[1] = *(simd_float4 *)(MEMORY[0x263EF89A8] + 16);
  v36.columns[2] = *(simd_float4 *)(MEMORY[0x263EF89A8] + 32);
  float32x4_t v35 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  v36.columns[3] = *(simd_float4 *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v37 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v38 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v37, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32((float32x4_t)v36.columns[0], *(float32x2_t *)v36.columns[0].f32, 1), (float32x4_t)v36.columns[1], *(float32x2_t *)v36.columns[1].f32, 1), (float32x4_t)v36.columns[2], *(float32x2_t *)v36.columns[2].f32, 1), v35)), (int8x16_t)vcgeq_f32(v37,
                                     vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)v36.columns[0], v36.columns[0].f32[0]), (float32x4_t)v36.columns[1], v36.columns[1].f32[0]), (float32x4_t)v36.columns[2], v36.columns[2].f32[0]), *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v37, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32((float32x4_t)v36.columns[0], (float32x4_t)v36.columns[0], 2), (float32x4_t)v36.columns[1], (float32x4_t)v36.columns[1], 2), (float32x4_t)v36.columns[2], (float32x4_t)v36.columns[2],
                                       2),
                                     (float32x4_t)v36.columns[3])));
  v38.i32[3] = v38.i32[2];
  if ((vminvq_u32(v38) & 0x80000000) == 0) {
    goto LABEL_107;
  }
  float32x4_t v39 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v36.columns[1], 2);
  float32x4_t v40 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v36.columns[0], (int32x4_t)v36.columns[2]), (int32x4_t)v39);
  float32x4_t v41 = (float32x4_t)vtrn2q_s32((int32x4_t)v36.columns[0], (int32x4_t)v36.columns[1]);
  v41.i32[2] = HIDWORD(*(void *)(MEMORY[0x263EF89A8] + 32));
  float32x4_t v42 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v36.columns[0], (int32x4_t)v36.columns[2]), (int32x4_t)v36.columns[1]);
  uint32x4_t v43 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v37, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v42, v36.columns[1].f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.columns[1].f32, 1), v41), v39, v40), v35)), (int8x16_t)vcgeq_f32(v37, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v42, v36.columns[0].f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.columns[0].f32, 1),
                                           v41),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)v36.columns[0], 2),
                                         v40),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v37, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v42, v36.columns[2].f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.columns[2].f32, 1), v41), (float32x4_t)vdupq_laneq_s32((int32x4_t)v36.columns[2], 2), v40), (float32x4_t)v36.columns[3])));
  v43.i32[3] = v43.i32[2];
  if ((vminvq_u32(v43) & 0x80000000) == 0
    || (float32x4_t v44 = vmulq_f32((float32x4_t)v36.columns[0], vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v36.columns[2], (int8x16_t)v36.columns[2], 0xCuLL), (int8x16_t)v36.columns[2], 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v36.columns[1], (int32x4_t)v36.columns[1]), (int8x16_t)v36.columns[1], 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v36.columns[2], (int32x4_t)v36.columns[2]), (int8x16_t)v36.columns[2], 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v36.columns[1], (int8x16_t)v36.columns[1], 0xCuLL), (int8x16_t)v36.columns[1], 8uLL))),
        fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))).f32[0]+ -1.0) > 0.000011)|| (v36.columns[3] = *(simd_float4 *)(a1 + 80), v36.columns[3].i32[3] = *(_DWORD *)(MEMORY[0x263EF89A8] + 60), v45 = (float32x2_t)vdup_n_s32(0x38D1B717u), uint32x2_t v46 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v45, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v36.columns[2], (int8x16_t)v36.columns[2], 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v36.columns[3],
                                                                                    (int8x16_t)v36.columns[3],
                                                                                    8uLL)),
                                            (float32x2_t)0xBF80000080000000))),
                            (int8x8_t)vcge_f32(v45, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v36.columns[0], (int8x16_t)v36.columns[0], 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v36.columns[1], (int8x16_t)v36.columns[1], 8uLL))))), (vpmin_u32(v46, v46).u32[0] & 0x80000000) == 0))
  {
LABEL_107:
    buf[0] = 0;
    char v110 = 0;
    uint64_t v47 = sub_24B6CF610();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v74 = 136315394;
      uint64_t v75 = "OCProxySurfaceCreate";
      __int16 v76 = 1026;
      int v77 = 91;
      _os_log_error_impl(&dword_24B6B9000, v47, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create OCProxySurface - failed to create voxelhashing pipeline config.", v74, 0x12u);
    }
LABEL_109:

    OCProxySurfaceDestroy((uint64_t)v23);
    return 0xFFFFFFFFLL;
  }
  uint64_t v49 = *(unsigned int *)(a1 + 16);
  if (v49 > 5) {
    int v50 = 5;
  }
  else {
    int v50 = dword_24B72AA70[v49];
  }
  if (*(_DWORD *)(a1 + 20) >= 2u) {
    int v51 = 2;
  }
  else {
    int v51 = *(_DWORD *)(a1 + 20);
  }
  unint64_t v72 = __PAIR64__(v51, v50);
  LODWORD(v52) = *(_DWORD *)(a1 + 24);
  uint64_t v53 = *(void *)(a1 + 44);
  int v70 = v52;
  long long v71 = *(_OWORD *)(a1 + 64);
  int v54 = *(_DWORD *)(a1 + 28);
  int v55 = *(_DWORD *)(a1 + 32);
  char v56 = *(unsigned char *)(a1 + 36);
  HIDWORD(v52) = *(_DWORD *)(a1 + 40);
  uint64_t v69 = v52;
  uint64_t v57 = *(void *)(a1 + 96);
  char v58 = *(unsigned char *)(a1 + 108);
  int v59 = *(_DWORD *)(a1 + 104);
  uint64_t v60 = *(unsigned int *)(a1 + 112);
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  if (v60 <= 2)
  {
    uint64_t v63 = 8 * v60;
    uint64_t v61 = *(void *)((char *)&unk_24B72AA88 + v63);
    uint64_t v62 = *(void *)((char *)&unk_24B72AAA0 + v63);
  }
  simd_float4x4 v112 = __invert_f4(v36);
  char v64 = *(unsigned char *)(a1 + 4);
  char v65 = *(unsigned char *)(a1 + 124);
  uint64_t v66 = *(void *)(a1 + 116);
  int v67 = *(_DWORD *)(a1 + 128);
  *(void *)long long buf = v72;
  *(_DWORD *)&uint8_t buf[8] = v70;
  uint64_t v79 = v53;
  long long v81 = v71;
  int v82 = v54;
  int v83 = v55;
  char v84 = v56;
  uint64_t v85 = v69;
  char v86 = 0;
  uint64_t v87 = v57;
  char v88 = v58;
  int v89 = v59;
  uint64_t v90 = v61;
  uint64_t v91 = v62;
  simd_float4x4 v92 = v112;
  char v93 = v64;
  BOOL v94 = v51 == 1;
  char v95 = v65;
  long long v96 = xmmword_24B72A610;
  uint64_t v97 = 0x186A000000000;
  int v98 = 1;
  uint64_t v99 = 0x40A000003DCCCCCDLL;
  long long v100 = xmmword_24B72A620;
  long long v101 = xmmword_24B72A630;
  long long v102 = xmmword_24B72A640;
  long long v103 = xmmword_24B72A650;
  char v104 = 0;
  uint64_t v105 = 5;
  int v106 = 1096810496;
  __int16 v107 = 0;
  int v108 = v67;
  uint64_t v109 = v66;
  char v110 = 1;
  if ((*(unsigned int (**)(void, unsigned char *))(*(void *)v23[3] + 16))(v23[3], buf))
  {
    uint64_t v47 = sub_24B6CF610();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v74 = 136315394;
      uint64_t v75 = "OCProxySurfaceCreate";
      __int16 v76 = 1026;
      int v77 = 98;
      _os_log_error_impl(&dword_24B6B9000, v47, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create OCProxySurface - failed to initialize voxelhashing pipeline.", v74, 0x12u);
    }
    goto LABEL_109;
  }
  atomic_store(0, v23 + 9);
  *a2 = v23;
  uint64_t v68 = sub_24B6CF610();
  if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v74 = 136315394;
    uint64_t v75 = "OCProxySurfaceCreate";
    __int16 v76 = 1026;
    int v77 = 107;
    _os_log_impl(&dword_24B6B9000, v68, OS_LOG_TYPE_DEFAULT, "%s:%{public}d OCProxySurfaceCreate succeeded.", v74, 0x12u);
  }

  return 0;
}

uint64_t OCProxySurfaceDestroy(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 4294967294;
  }
  dispatch_sync(*(dispatch_queue_t *)(a1 + 16), &unk_26FE9C9C0);
  float32x4_t v2 = *(NSObject **)(a1 + 64);
  if (v2) {
    dispatch_group_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  }
  float v3 = *(const void **)(a1 + 32);
  if (v3) {
    CFRelease(v3);
  }
  float v4 = *(const void **)(a1 + 40);
  if (v4) {
    CFRelease(v4);
  }
  float v5 = *(const void **)(a1 + 48);
  if (v5) {
    CFRelease(v5);
  }

  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }

  MEMORY[0x24C5D7790](a1, 0x10A0C40A52DDF8DLL);
  if (qword_2697D0F48 != -1) {
    dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
  }
  float v7 = qword_2697D0F40;
  BOOL v8 = os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v8)
  {
    int v10 = 136315394;
    float v11 = "OCProxySurfaceDestroy";
    __int16 v12 = 1026;
    int v13 = 146;
    _os_log_impl(&dword_24B6B9000, v7, OS_LOG_TYPE_DEFAULT, "%s:%{public}d OCProxySurfaceDestroy succeeded.", (uint8_t *)&v10, 0x12u);
    return 0;
  }
  return result;
}

id sub_24B6CF610()
{
  if (qword_2697D0F48 != -1) {
    dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
  }
  v0 = (void *)qword_2697D0F40;
  return v0;
}

uint64_t sub_24B6CF668()
{
  qword_2697D0F40 = (uint64_t)os_log_create("com.apple.CoreOCModules", "VoxelHashing");
  return MEMORY[0x270F9A758]();
}

uint64_t OCProxySurfaceWait(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    dispatch_sync(*(dispatch_queue_t *)(a1 + 16), &unk_26FE9C9C0);
    return 0;
  }
  else
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    float32x4_t v2 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315394;
      float v4 = "OCProxySurfaceWait";
      __int16 v5 = 1026;
      int v6 = 173;
      _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to wait on OCProxySurface - invalid handle.", (uint8_t *)&v3, 0x12u);
    }
    return 4294967294;
  }
}

uint64_t OCProxySurfaceStart(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return 0;
  }
  if (qword_2697D0F48 != -1) {
    dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
  }
  float32x4_t v2 = qword_2697D0F40;
  if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    float v4 = "OCProxySurfaceStart";
    __int16 v5 = 1026;
    int v6 = 153;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to start OCProxySurface - invalid handle.", (uint8_t *)&v3, 0x12u);
  }
  return 4294967294;
}

uint64_t OCProxySurfaceStop(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return 0;
  }
  if (qword_2697D0F48 != -1) {
    dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
  }
  float32x4_t v2 = qword_2697D0F40;
  if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    float v4 = "OCProxySurfaceStop";
    __int16 v5 = 1026;
    int v6 = 163;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to stop OCProxySurface - invalid handle.", (uint8_t *)&v3, 0x12u);
  }
  return 4294967294;
}

uint64_t OCProxySurfaceExecutePipeline(uint64_t a1, void *a2, __int16 a3, int a4, __n128 a5, __n128 a6, __n128 a7, int8x16_t a8, int8x16_t a9, int8x16_t a10, int8x16_t a11, double a12, double a13, double a14, double a15)
{
  uint64_t v92 = *MEMORY[0x263EF8340];
  v90[0] = a9;
  v90[1] = a10;
  v90[2] = a11;
  *(double *)int v89 = a13;
  *(double *)&v89[1] = a14;
  if (!a1)
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    simd_float4x4 v36 = qword_2697D0F40;
    if (!os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR)) {
      return 4294967294;
    }
    buf.columns[0].i32[0] = 136315394;
    *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"isValidInputForExecutePipeline";
    buf.columns[0].i16[6] = 1026;
    *(__int32 *)((char *)&buf.columns[0].i32[3] + 2) = 198;
    float32x4_t v37 = "%s:%{public}d Failed to run OCProxySurface pipeline - invalid handle.";
    goto LABEL_19;
  }
  if (!a2)
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    simd_float4x4 v36 = qword_2697D0F40;
    if (!os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR)) {
      return 4294967294;
    }
    buf.columns[0].i32[0] = 136315394;
    *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"isValidInputForExecutePipeline";
    buf.columns[0].i16[6] = 1026;
    *(__int32 *)((char *)&buf.columns[0].i32[3] + 2) = 203;
    float32x4_t v37 = "%s:%{public}d Failed to run OCProxySurface pipeline - invalid pointcloud.";
    goto LABEL_19;
  }
  float32x4_t v21 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)a5, a5.n128_f32[0]), (float32x4_t)a6, a6.n128_f32[0]), (float32x4_t)a7, a7.n128_f32[0]);
  float32x4_t v22 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32((float32x4_t)a5, (float32x2_t)a5.n128_u64[0], 1), (float32x4_t)a6, (float32x2_t)a6.n128_u64[0], 1), (float32x4_t)a7, (float32x2_t)a7.n128_u64[0], 1);
  float32x4_t v23 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32((float32x4_t)a5, (float32x4_t)a5, 2), (float32x4_t)a6, (float32x4_t)a6, 2), (float32x4_t)a7, (float32x4_t)a7, 2);
  float32x4_t v24 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v25 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v26 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v27 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v26, vabdq_f32(v22, v24)), (int8x16_t)vcgeq_f32(v26, vabdq_f32(v21, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v26, vabdq_f32(v23, v25)));
  v27.i32[3] = v27.i32[2];
  if ((vminvq_u32(v27) & 0x80000000) != 0)
  {
    float32x4_t v28 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a6, 2);
    float32x4_t v29 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)v28);
    float32x4_t v30 = (float32x4_t)vtrn2q_s32((int32x4_t)a5, (int32x4_t)a6);
    v30.i32[2] = a7.n128_i32[1];
    float32x4_t v31 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)a6);
    uint32x4_t v32 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v26, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v31, a6.n128_f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)a6.n128_u64[0], 1), v30), v28, v29), v24)), (int8x16_t)vcgeq_f32(v26, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v31, a5.n128_f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)a5.n128_u64[0], 1),
                                             v30),
                                           (float32x4_t)vdupq_laneq_s32((int32x4_t)a5, 2),
                                           v29),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v26, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v31, a7.n128_f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)a7.n128_u64[0], 1), v30), (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2), v29), v25)));
    v32.i32[3] = v32.i32[2];
    if ((vminvq_u32(v32) & 0x80000000) != 0)
    {
      float32x4_t v33 = vmulq_f32((float32x4_t)a5, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a7, (int8x16_t)a7, 0xCuLL), (int8x16_t)a7, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a6, (int32x4_t)a6), (int8x16_t)a6, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a7, (int32x4_t)a7), (int8x16_t)a7, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a6, (int8x16_t)a6, 0xCuLL), (int8x16_t)a6, 8uLL)));
      if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1))).f32[0]+ -1.0) <= 0.000011)
      {
        float32x2_t v34 = (float32x2_t)vdup_n_s32(0x38D1B717u);
        uint32x2_t v35 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v34, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a8, a8, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v34, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a5, (int8x16_t)a5, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                         (int8x16_t)a6,
                                                                                         (int8x16_t)a6,
                                                                                         8uLL)))));
        if ((vpmin_u32(v35, v35).u32[0] & 0x80000000) != 0)
        {
          uint32x2_t v40 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v34, vabs_f32(vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a10, a10, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a11, a11, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v34, vabs_f32((float32x2_t)*(_OWORD *)&vextq_s8(a9, a9, 4uLL))));
          if ((vpmin_u32(v40, v40).u32[0] & 0x80000000) == 0)
          {
            if (qword_2697D0F48 != -1) {
              dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
            }
            simd_float4x4 v36 = qword_2697D0F40;
            if (!os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR)) {
              return 4294967294;
            }
            buf.columns[0].i32[0] = 136315394;
            *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"isValidInputForExecutePipeline";
            buf.columns[0].i16[6] = 1026;
            *(__int32 *)((char *)&buf.columns[0].i32[3] + 2) = 215;
            float32x4_t v37 = "%s:%{public}d Failed to run OCProxySurface pipeline - invalid camera intrinsics.";
            goto LABEL_19;
          }
          if (a13 < 0.0 || fabs(a13) <= 0.000000999999997 || a14 < 0.0 || fabs(a14) <= 0.000000999999997)
          {
            if (qword_2697D0F48 != -1) {
              dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
            }
            simd_float4x4 v36 = qword_2697D0F40;
            if (!os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR)) {
              return 4294967294;
            }
            buf.columns[0].i32[0] = 136315394;
            *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"isValidInputForExecutePipeline";
            buf.columns[0].i16[6] = 1026;
            *(__int32 *)((char *)&buf.columns[0].i32[3] + 2) = 222;
            float32x4_t v37 = "%s:%{public}d Failed to run OCProxySurface pipeline - invalid color image dimensions.";
            goto LABEL_19;
          }
          if (a15 < 0.0 || (double v42 = COERCE_DOUBLE(atomic_load((unint64_t *)(a1 + 72))), v42 > a15))
          {
            if (qword_2697D0F48 != -1) {
              dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
            }
            simd_float4x4 v36 = qword_2697D0F40;
            if (!os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR)) {
              return 4294967294;
            }
            buf.columns[0].i32[0] = 136315394;
            *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"isValidInputForExecutePipeline";
            buf.columns[0].i16[6] = 1026;
            *(__int32 *)((char *)&buf.columns[0].i32[3] + 2) = 227;
            float32x4_t v37 = "%s:%{public}d Failed to run OCProxySurface pipeline - invalid timestamp.";
            goto LABEL_19;
          }
          *(__n128 *)char v58 = a5;
          *(__n128 *)&v58[16] = a6;
          *(__n128 *)&v58[32] = a7;
          *(int8x16_t *)&v58[48] = a8;
          if (dispatch_group_wait(*(dispatch_group_t *)(a1 + 64), 0))
          {
            if (qword_2697D0F48 != -1) {
              dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
            }
            float32x2_t v45 = qword_2697D0F40;
            if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_DEBUG))
            {
              buf.columns[0].i32[0] = 136315394;
              *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"OCProxySurfaceExecutePipeline";
              buf.columns[0].i16[6] = 1026;
              *(__int32 *)((char *)&buf.columns[0].i32[3] + 2) = 247;
              _os_log_debug_impl(&dword_24B6B9000, v45, OS_LOG_TYPE_DEBUG, "%s:%{public}d Active pipeline task in queue, dropping input frame.", (uint8_t *)&buf, 0x12u);
            }
            return 0xFFFFFFFFLL;
          }
          int v46 = -1431655765 * ((a2[13] - a2[12]) >> 4);
          uint64_t v47 = OCPointCloudPoints((uint64_t)a2);
          uint64_t v48 = OCPointCloudPointSupplements((uint64_t)a2);
          if (!v46 || !v47 || !v48)
          {
            if (qword_2697D0F48 != -1) {
              dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
            }
            uint64_t v52 = qword_2697D0F40;
            if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
            {
              buf.columns[0].i32[0] = 136315394;
              *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"OCProxySurfaceExecutePipeline";
              buf.columns[0].i16[6] = 1026;
              *(__int32 *)((char *)&buf.columns[0].i32[3] + 2) = 256;
              _os_log_error_impl(&dword_24B6B9000, v52, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to run OCProxySurface pipeline - invalid pointcloud.", (uint8_t *)&buf, 0x12u);
              return 0xFFFFFFFFLL;
            }
            return 0xFFFFFFFFLL;
          }
          int v57 = v46;
          uint64_t v56 = v48;
          uint64_t v85 = 0;
          char v86 = &v85;
          uint64_t v87 = 0x2020000000;
          int v88 = 0;
          if ((a3 & 0x100) == 0) {
            goto LABEL_71;
          }
          uint64_t v49 = *(void *)(a1 + 24);
          simd_float4x4 buf = __invert_f4(*(simd_float4x4 *)v58);
          int v50 = (*(uint64_t (**)(uint64_t, simd_float4x4 *, _OWORD *, void *))(*(void *)v49 + 48))(v49, &buf, v90, v89);
          switch(v50)
          {
            case 0:
              goto LABEL_71;
            case 2:
              int v51 = -4;
              break;
            case 4:
              int v51 = -2;
              break;
            default:
              int v51 = -1;
              break;
          }
          *((_DWORD *)v86 + 6) = v51;
          if (qword_2697D0F48 != -1) {
            dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
          }
          uint64_t v53 = qword_2697D0F40;
          if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
          {
            buf.columns[0].i32[0] = 136315394;
            *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"OCProxySurfaceExecutePipeline";
            buf.columns[0].i16[6] = 1026;
            *(__int32 *)((char *)&buf.columns[0].i32[3] + 2) = 268;
            _os_log_error_impl(&dword_24B6B9000, v53, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to render depth image.", (uint8_t *)&buf, 0x12u);
            if (*(unsigned char *)(a1 + 56)) {
              goto LABEL_64;
            }
          }
          else
          {
LABEL_71:
            if (*(unsigned char *)(a1 + 56))
            {
LABEL_64:
              CFRetain(a2);
              dispatch_group_enter(*(dispatch_group_t *)(a1 + 64));
              int v54 = *(NSObject **)(a1 + 16);
              block[0] = MEMORY[0x263EF8330];
              block[1] = 3221225472;
              block[2] = sub_24B6D0380;
              block[3] = &unk_2652DEF48;
              long long v73 = *(_OWORD *)v58;
              long long v74 = *(_OWORD *)&v58[16];
              long long v75 = *(_OWORD *)&v58[32];
              long long v76 = *(_OWORD *)&v58[48];
              uint64_t v77 = a1;
              uint64_t v78 = v47;
              uint64_t v79 = v56;
              double v80 = a2;
              __int16 v84 = a3;
              int v82 = v57;
              int v83 = a4;
              double v81 = a15;
              dispatch_async(v54, block);
LABEL_68:
              uint64_t v38 = *((unsigned int *)v86 + 6);
              _Block_object_dispose(&v85, 8);
              return v38;
            }
          }
          int v55 = *(NSObject **)(a1 + 16);
          v59[0] = MEMORY[0x263EF8330];
          v59[1] = 3221225472;
          v59[2] = sub_24B6D0488;
          v59[3] = &unk_2652DEF70;
          long long v60 = *(_OWORD *)v58;
          long long v61 = *(_OWORD *)&v58[16];
          long long v62 = *(_OWORD *)&v58[32];
          long long v63 = *(_OWORD *)&v58[48];
          uint64_t v66 = v47;
          uint64_t v67 = v56;
          char v64 = &v85;
          uint64_t v65 = a1;
          __int16 v71 = a3;
          int v69 = v57;
          int v70 = a4;
          double v68 = a15;
          dispatch_sync(v55, v59);
          goto LABEL_68;
        }
      }
    }
  }
  if (qword_2697D0F48 != -1) {
    dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
  }
  simd_float4x4 v36 = qword_2697D0F40;
  if (!os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR)) {
    return 4294967294;
  }
  buf.columns[0].i32[0] = 136315394;
  *(uint64_t *)((char *)buf.columns[0].i64 + 4) = (uint64_t)"isValidInputForExecutePipeline";
  buf.columns[0].i16[6] = 1026;
  *(__int32 *)((char *)&buf.columns[0].i32[3] + 2) = 209;
  float32x4_t v37 = "%s:%{public}d Failed to run OCProxySurface pipeline - invalid camera to world transform.";
LABEL_19:
  _os_log_error_impl(&dword_24B6B9000, v36, OS_LOG_TYPE_ERROR, v37, (uint8_t *)&buf, 0x12u);
  return 4294967294;
}

void sub_24B6D0364(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Unwind_Resume(a1);
}

void sub_24B6D0380(uint64_t a1)
{
  kdebug_trace();
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)(*(void *)(a1 + 96) + 24) + 32))(*(void *)(*(void *)(a1 + 96) + 24), a1 + 32, *(unsigned int *)(a1 + 136), *(void *)(a1 + 104), *(void *)(a1 + 112));
  float32x4_t v2 = *(const void **)(a1 + 120);
  if (v2) {
    CFRelease(v2);
  }
  if (*(unsigned char *)(a1 + 144) || *(unsigned char *)(a1 + 145)) {
    (*(void (**)(void, void))(**(void **)(*(void *)(a1 + 96) + 24) + 40))(*(void *)(*(void *)(a1 + 96) + 24), *(unsigned int *)(a1 + 140));
  }
  atomic_store(*(void *)(a1 + 128), (unint64_t *)(*(void *)(a1 + 96) + 72));
  kdebug_trace();
  int v3 = *(NSObject **)(*(void *)(a1 + 96) + 64);
  dispatch_group_leave(v3);
}

uint64_t sub_24B6D0488(uint64_t a1)
{
  kdebug_trace();
  int v2 = (*(uint64_t (**)(void, uint64_t, void, void, void))(**(void **)(*(void *)(a1 + 104) + 24)
                                                                          + 32))(*(void *)(*(void *)(a1 + 104) + 24), a1 + 32, *(unsigned int *)(a1 + 136), *(void *)(a1 + 112), *(void *)(a1 + 120));
  if (v2)
  {
    if (v2 == 2)
    {
      int v3 = -4;
    }
    else if (v2 == 4)
    {
      int v3 = -2;
    }
    else
    {
      int v3 = -1;
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) = v3;
  }
  if (*(unsigned char *)(a1 + 144) || *(unsigned char *)(a1 + 145))
  {
    unsigned int v4 = (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 104) + 24) + 40))(*(void *)(*(void *)(a1 + 104) + 24), *(unsigned int *)(a1 + 140));
    if (v4 > 4) {
      int v5 = -1;
    }
    else {
      int v5 = dword_24B72AAB8[v4];
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) = v5;
  }
  atomic_store(*(void *)(a1 + 128), (unint64_t *)(*(void *)(a1 + 104) + 72));
  return kdebug_trace();
}

uint64_t OCProxySurfaceGetVoxelCloud(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = (uint64_t *)(a1 + 32);
    int v2 = *(const void **)(a1 + 32);
    *(void *)(a1 + 32) = 0;
    (*(void (**)(unsigned int *__return_ptr))(**(void **)(a1 + 24) + 72))(&v5);
    OCVoxelCloudCreateFromOCPoints(v5, *(uint64_t *)((char *)&v6 + 4), v1, *((float *)&v6 + 3), v7, v8, v9, v10);
    if (v2) {
      CFRelease(v2);
    }
    return *v1;
  }
  else
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    unsigned int v4 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      unsigned int v5 = 136315394;
      *(void *)&long long v6 = "OCProxySurfaceGetVoxelCloud";
      WORD4(v6) = 1026;
      *(_DWORD *)((char *)&v6 + 10) = 332;
      _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get voxelcloud - invalid handle.", (uint8_t *)&v5, 0x12u);
    }
    return 0;
  }
}

uint64_t OCProxySurfaceGetDebugVoxelCloud(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = (uint64_t *)(a1 + 40);
    int v2 = *(const void **)(a1 + 40);
    *(void *)(a1 + 40) = 0;
    (*(void (**)(float *__return_ptr))(**(void **)(a1 + 24) + 64))(&v5);
    OCVoxelCloudCreateFromOCVoxels(*(unsigned int *)v6, *(const void **)&v6[4], v1, v5, *(float32x4_t *)&v6[12], v7, v8, v9);
    if (v2) {
      CFRelease(v2);
    }
    return *v1;
  }
  else
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    unsigned int v4 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      float v5 = 4.8151e-34;
      *(void *)long long v6 = "OCProxySurfaceGetDebugVoxelCloud";
      *(_WORD *)&v6[8] = 1026;
      *(_DWORD *)&v6[10] = 354;
      _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get debug voxelcloud - invalid handle.", (uint8_t *)&v5, 0x12u);
    }
    return 0;
  }
}

float32x4_t *OCProxySurfaceGetPointCloud(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = (float32x4_t **)(a1 + 48);
    int v2 = *(const void **)(a1 + 48);
    *(void *)(a1 + 48) = 0;
    (*(void (**)(unsigned int *__return_ptr))(**(void **)(a1 + 24) + 72))(&v5);
    OCPointCloudCreateFromOCPoints(v5, *(uint64_t *)((char *)&v6 + 4), v1, *((float32_t *)&v6 + 3), v7, v8, v9, v10);
    if (v2) {
      CFRelease(v2);
    }
    return *v1;
  }
  else
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    unsigned int v4 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      unsigned int v5 = 136315394;
      *(void *)&long long v6 = "OCProxySurfaceGetPointCloud";
      WORD4(v6) = 1026;
      *(_DWORD *)((char *)&v6 + 10) = 375;
      _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get pointcloud - invalid handle.", (uint8_t *)&v5, 0x12u);
    }
    return 0;
  }
}

__CVBuffer *OCProxySurfaceCreateDepthImage(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    unsigned int v5 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      int v8 = 136315394;
      float32x4_t v9 = "OCProxySurfaceCreateDepthImage";
      __int16 v10 = 1026;
      int v11 = 396;
      _os_log_error_impl(&dword_24B6B9000, v5, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get depth image - invalid handle.", (uint8_t *)&v8, 0x12u);
    }
    return 0;
  }
  CFNumberRef v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberDoubleType, (const void *)(a1 + 72));
  int v3 = (__CVBuffer *)(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 88))(*(void *)(a1 + 24));
  if (!v3)
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    long long v6 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      int v8 = 136315394;
      float32x4_t v9 = "OCProxySurfaceCreateDepthImage";
      __int16 v10 = 1026;
      int v11 = 406;
      _os_log_error_impl(&dword_24B6B9000, v6, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get depth image from voxelhashing pipeline.", (uint8_t *)&v8, 0x12u);
      if (!v2) {
        return 0;
      }
    }
    else if (!v2)
    {
      return 0;
    }
    CFRelease(v2);
    return 0;
  }
  unsigned int v4 = v3;
  CVBufferSetAttachment(v3, @"Timestamp", v2, kCVAttachmentMode_ShouldPropagate);
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

__CVBuffer *OCProxySurfaceCreateNormalImage(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    unsigned int v5 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      int v8 = 136315394;
      float32x4_t v9 = "OCProxySurfaceCreateNormalImage";
      __int16 v10 = 1026;
      int v11 = 424;
      _os_log_error_impl(&dword_24B6B9000, v5, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get normal image - invalid handle.", (uint8_t *)&v8, 0x12u);
    }
    return 0;
  }
  CFNumberRef v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberDoubleType, (const void *)(a1 + 72));
  int v3 = (__CVBuffer *)(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 96))(*(void *)(a1 + 24));
  if (!v3)
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    long long v6 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      int v8 = 136315394;
      float32x4_t v9 = "OCProxySurfaceCreateNormalImage";
      __int16 v10 = 1026;
      int v11 = 433;
      _os_log_error_impl(&dword_24B6B9000, v6, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get normal image from voxelhashing pipeline.", (uint8_t *)&v8, 0x12u);
      if (!v2) {
        return 0;
      }
    }
    else if (!v2)
    {
      return 0;
    }
    CFRelease(v2);
    return 0;
  }
  unsigned int v4 = v3;
  CVBufferSetAttachment(v3, @"Timestamp", v2, kCVAttachmentMode_ShouldPropagate);
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

uint64_t OCProxySurfaceCoverageGuideAddCameraShot(uint64_t a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(__n128 *)&v17[32] = a7;
    *(__n128 *)&v17[48] = a8;
    *(__n128 *)float v17 = a5;
    *(__n128 *)&v17[16] = a6;
    int v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 112))(*(void *)(a1 + 24));
    int v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 120))(*(void *)(a1 + 24));
    uint64_t v11 = *(void *)(a1 + 24);
    *(_DWORD *)simd_float4x4 buf = v9;
    LODWORD(v19) = v10;
    *(__n128 *)&v21[2] = a2;
    __n128 v22 = a3;
    __n128 v23 = a4;
    simd_float4x4 v24 = *(simd_float4x4 *)v17;
    simd_float4x4 v25 = __invert_f4(*(simd_float4x4 *)v17);
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v11 + 128))(v11, buf);
    return 0;
  }
  else
  {
    if (qword_2697D0F48 != -1) {
      dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
    }
    int v13 = qword_2697D0F40;
    if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      float v19 = "OCProxySurfaceCoverageGuideAddCameraShot";
      __int16 v20 = 1026;
      *(_DWORD *)float32x4_t v21 = 452;
      _os_log_error_impl(&dword_24B6B9000, v13, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to add camera shot - invalid handle.", buf, 0x12u);
    }
    return 4294967294;
  }
}

void OCProxySurfaceCreateResults(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  if (a1)
  {
    kdebug_trace();
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 24) + 104))(buf);
    uint64_t v4 = *(void *)((char *)&v42 + 4);
    uint64_t v5 = *(unsigned int *)buf;
    if (*(void *)((char *)&v42 + 4)) {
      BOOL v6 = *(_DWORD *)buf == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6)
    {
      kdebug_trace();
      a2[4] = 0u;
      a2[5] = 0u;
      a2[2] = 0u;
      a2[3] = 0u;
      *a2 = 0u;
      a2[1] = 0u;
      float32x4_t v7 = (int *)__p;
      if (!__p) {
        return;
      }
LABEL_26:
      float32x2_t v45 = v7;
      operator delete(v7);
      return;
    }
    int v9 = (int *)__p;
    int v10 = v45;
    DWORD2(v33) = v46;
    uint64_t v11 = (char *)operator new(48 * *(unsigned int *)buf);
    size_t v12 = 48 * ((48 * v5 - 48) / 0x30uLL) + 48;
    bzero(v11, v12);
    int v13 = v11 + 32;
    uint64_t v14 = v4 + 16;
    float32x4_t v15 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    if (v9 == v10)
    {
      do
      {
        *((_OWORD *)v13 - 2) = *(_OWORD *)(v14 - 16);
        *((_OWORD *)v13 - 1) = *(_OWORD *)v14;
        float32x4_t v18 = vminnmq_f32(vmaxnmq_f32(vrndaq_f32(vmulq_f32(*(float32x4_t *)(v14 + 16), v15)), (float32x4_t)0), v15);
        *(void *)int v13 = v18.f32[3] | (v18.f32[1] << 16) | (v18.f32[0] << 24) | (v18.f32[2] << 8);
        v13 += 48;
        v14 += 48;
        --v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        *((_OWORD *)v13 - 2) = *(_OWORD *)(v14 - 16);
        *((_OWORD *)v13 - 1) = *(_OWORD *)v14;
        float32x4_t v16 = vminnmq_f32(vmaxnmq_f32(vrndaq_f32(vmulq_f32(*(float32x4_t *)(v14 + 16), v15)), (float32x4_t)0), v15);
        *(_DWORD *)int v13 = v16.f32[3] | (v16.f32[1] << 16) | (v16.f32[0] << 24) | (v16.f32[2] << 8);
        int v17 = *v9++;
        *((_DWORD *)v13 + 1) = v17;
        v13 += 48;
        v14 += 48;
        --v5;
      }
      while (v5);
    }
    *(void *)IOSurfaceRef buffer = 0;
    if (sub_24B6BC870(2021227107, 48 * (v12 / 0x30), (IOSurfaceRef *)buffer)
      || (float v19 = IOSurfaceGetBaseAddress(*(IOSurfaceRef *)buffer),
          memcpy(v19, v11, 48 * (v12 / 0x30)),
          int v20 = CVDataBufferCreateWithIOSurface(),
          CFRelease(*(CFTypeRef *)buffer),
          v20))
    {
      if (qword_2697D0F48 != -1) {
        dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
      }
      float32x4_t v21 = qword_2697D0F40;
      if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)IOSurfaceRef buffer = 136315394;
        *(void *)&buffer[4] = "OCProxySurfaceCreateResults";
        __int16 v39 = 1026;
        int v40 = 543;
        _os_log_error_impl(&dword_24B6B9000, v21, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create results - failed to create IOSurface for vertex buffer.", buffer, 0x12u);
      }
    }
    else
    {
      *((void *)&v32 + 1) = 0;
      __n128 v22 = v43;
      if (v43
        && HIDWORD(v42)
        && ((*(void *)IOSurfaceRef buffer = 0,
             uint64_t v23 = 4 * HIDWORD(v42),
             sub_24B6BC870(1278227250, v23, (IOSurfaceRef *)buffer))
         || (simd_float4x4 v24 = IOSurfaceGetBaseAddress(*(IOSurfaceRef *)buffer),
             memcpy(v24, v22, v23),
             int v25 = CVDataBufferCreateWithIOSurface(),
             CFRelease(*(CFTypeRef *)buffer),
             v25)))
      {
        if (qword_2697D0F48 != -1) {
          dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
        }
        uint64_t v26 = qword_2697D0F40;
        if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)IOSurfaceRef buffer = 136315394;
          *(void *)&buffer[4] = "OCProxySurfaceCreateResults";
          __int16 v39 = 1026;
          int v40 = 563;
          _os_log_error_impl(&dword_24B6B9000, v26, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create results - failed to create IOSurface for index buffer.", buffer, 0x12u);
        }
      }
      else
      {
        *(void *)&long long v33 = 0;
        uint32x4_t v27 = v48;
        if (!v48
          || !v47
          || (*(void *)IOSurfaceRef buffer = 0,
              uint64_t v28 = 48 * v47,
              !sub_24B6BC870(2021227107, v28, (IOSurfaceRef *)buffer))
          && (BaseAddress = IOSurfaceGetBaseAddress(*(IOSurfaceRef *)buffer),
              memcpy(BaseAddress, v27, v28),
              int v30 = CVDataBufferCreateWithIOSurface(),
              CFRelease(*(CFTypeRef *)buffer),
              !v30))
        {
          long long v34 = v49;
          long long v35 = v50;
          long long v36 = v51;
          long long v37 = v52;
          kdebug_trace();
          a2[2] = v34;
          a2[3] = v35;
          a2[4] = v36;
          a2[5] = v37;
          *a2 = v32;
          a2[1] = v33;
LABEL_25:
          operator delete(v11);
          float32x4_t v7 = (int *)__p;
          if (!__p) {
            return;
          }
          goto LABEL_26;
        }
        if (qword_2697D0F48 != -1) {
          dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
        }
        float32x4_t v31 = qword_2697D0F40;
        if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)IOSurfaceRef buffer = 136315394;
          *(void *)&buffer[4] = "OCProxySurfaceCreateResults";
          __int16 v39 = 1026;
          int v40 = 584;
          _os_log_error_impl(&dword_24B6B9000, v31, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create results - failed to create IOSurface for dense point buffer.", buffer, 0x12u);
        }
      }
    }
    kdebug_trace();
    a2[4] = 0u;
    a2[5] = 0u;
    a2[2] = 0u;
    a2[3] = 0u;
    *a2 = 0u;
    a2[1] = 0u;
    goto LABEL_25;
  }
  if (qword_2697D0F48 != -1) {
    dispatch_once(&qword_2697D0F48, &unk_26FE9C9E0);
  }
  int v8 = qword_2697D0F40;
  if (os_log_type_enabled((os_log_t)qword_2697D0F40, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&long long v42 = "OCProxySurfaceCreateResults";
    WORD4(v42) = 1026;
    *(_DWORD *)((char *)&v42 + 10) = 484;
    _os_log_error_impl(&dword_24B6B9000, v8, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create results - invalid handle.", buf, 0x12u);
  }
  a2[4] = 0u;
  a2[5] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
}

void sub_24B6D1640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30)
{
  operator delete(v30);
  if (!__p) {
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t OCProxySurfaceNumVoxelsAlongAxisInVoxelBlock()
{
  return 8;
}

uint64_t OCNonModularSPI_GetWideToDepthTransform(_OWORD *a1, const char *a2)
{
  if (!a1) {
    return 4294967294;
  }
  int v3 = objc_msgSend_defaultDeviceWithDeviceType_mediaType_position_(MEMORY[0x263EFA598], a2, *MEMORY[0x263EF9670], *MEMORY[0x263EF9D48], 1);
  uint64_t v5 = objc_msgSend_defaultDeviceWithDeviceType_mediaType_position_(MEMORY[0x263EFA598], v4, *MEMORY[0x263EF9640], *MEMORY[0x263EF9D20], 1);
  float32x4_t v7 = (void *)v5;
  if (v3) {
    BOOL v8 = v5 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    uint64_t v9 = 0xFFFFFFFFLL;
  }
  else
  {
    int v10 = objc_msgSend_extrinsicMatrixFromDevice_toDevice_(MEMORY[0x263EFA598], v6, (uint64_t)v3, v5);
    int v13 = v10;
    if (v10)
    {
      if ((unint64_t)objc_msgSend_length(v10, v11, v12) <= 0x3F)
      {
        float32x4_t v21 = objc_msgSend_currentHandler(MEMORY[0x263F08690], v14, v15);
        uint64_t v23 = objc_msgSend_stringWithUTF8String_(NSString, v22, (uint64_t)"OCReturn OCNonModularSPI_GetWideToDepthTransform(simd_float4x4 *)");
        objc_msgSend_handleFailureInFunction_file_lineNumber_description_(v21, v24, (uint64_t)v23, @"AVCapture+NonModularSPI.mm", 48, @"NSData must contain enough bytes for simd_float4x3");
      }
      objc_msgSend_getBytes_length_(v13, v14, (uint64_t)v25, 64);
      uint64_t v9 = 0;
      long long v16 = v25[0];
      long long v17 = v25[1];
      HIDWORD(v16) = 0;
      HIDWORD(v17) = 0;
      long long v18 = v25[2];
      long long v19 = v25[3];
      HIDWORD(v18) = 0;
      *a1 = v16;
      a1[1] = v17;
      HIDWORD(v19) = 1.0;
      a1[2] = v18;
      a1[3] = v19;
    }
    else
    {
      uint64_t v9 = 0xFFFFFFFFLL;
    }
  }
  return v9;
}

void sub_24B6D1828(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t OCNonModularSPI_AVCaptureDevice_IsTimeOfFlightOCMacroModeSupported(uint64_t a1, const char *a2)
{
  CFNumberRef v2 = objc_msgSend_defaultDeviceWithDeviceType_mediaType_position_(MEMORY[0x263EFA598], a2, *MEMORY[0x263EF9640], *MEMORY[0x263EF9D20], 1);
  uint64_t v4 = v2;
  if (v2) {
    uint64_t isTimeOfFlightProjectorModeSupported = objc_msgSend_isTimeOfFlightProjectorModeSupported_(v2, v3, 6);
  }
  else {
    uint64_t isTimeOfFlightProjectorModeSupported = 0;
  }

  return isTimeOfFlightProjectorModeSupported;
}

void sub_24B6D18E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL OCNonModularSPI_AVCaptureDevice_IsTimeOfFlightSensorType80(uint64_t a1, const char *a2)
{
  CFNumberRef v2 = objc_msgSend_defaultDeviceWithDeviceType_mediaType_position_(MEMORY[0x263EFA598], a2, *MEMORY[0x263EF9640], *MEMORY[0x263EF9D20], 1);
  uint64_t v5 = v2;
  if (v2)
  {
    BOOL v6 = objc_msgSend_formats(v2, v3, v4);
    BOOL v8 = objc_msgSend_objectAtIndexedSubscript_(v6, v7, 0);
    objc_msgSend_formatDescription(v8, v9, v10);
    int NumberOfPoints = CMPointCloudFormatDescriptionGetNumberOfPoints();

    BOOL v13 = NumberOfPoints == 84 || NumberOfPoints == 168;
  }
  else
  {
    BOOL v13 = 0;
  }

  return v13;
}

void sub_24B6D19A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id OCNonModularSPI_CapturePhotoSettings(uint64_t a1, const char *a2)
{
  v11[1] = *MEMORY[0x263EF8340];
  CFNumberRef v2 = (void *)MEMORY[0x263EFA628];
  uint64_t v10 = *MEMORY[0x263F04180];
  v11[0] = &unk_26FE9F720;
  int v3 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, a2, (uint64_t)v11, &v10, 1);
  uint64_t v5 = objc_msgSend_photoSettingsWithFormat_(v2, v4, (uint64_t)v3);

  objc_msgSend_setHighResolutionPhotoEnabled_(v5, v6, 1);
  objc_msgSend_setPhotoQualityPrioritization_(v5, v7, 1);
  objc_msgSend_setShutterSound_(v5, v8, 0);
  return v5;
}

void sub_24B6D1AA8(_Unwind_Exception *a1)
{
  CFNumberRef v2 = v1;

  _Unwind_Resume(a1);
}

uint64_t OCNonModularSPI_ShutterSoundEntitlementValue()
{
  v0 = SecTaskCreateFromSelf((CFAllocatorRef)*MEMORY[0x263EFFB08]);
  if (!v0) {
    return 0;
  }
  uint64_t v1 = v0;
  CFTypeRef v2 = SecTaskCopyValueForEntitlement(v0, @"com.apple.avfoundation.allow-still-image-capture-shutter-sound-manipulation", 0);
  if (v2)
  {
    int v3 = (void *)v2;
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 == CFBooleanGetTypeID()) {
      uint64_t v7 = objc_msgSend_BOOLValue(v3, v5, v6);
    }
    else {
      uint64_t v7 = 0;
    }
    CFRelease(v3);
  }
  else
  {
    uint64_t v7 = 0;
  }
  CFRelease(v1);
  return v7;
}

void OCMetalInitWithDevice(id obj)
{
}

id OCMetalDevice()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1358, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2697D1358))
  {
    qword_2697D1350 = sub_24B727BB4();
    __cxa_atexit((void (*)(void *))sub_24B727D84, &qword_2697D1350, &dword_24B6B9000);
    __cxa_guard_release(&qword_2697D1358);
  }
  if (qword_2697D1350) {
    id v0 = *(id *)qword_2697D1350;
  }
  else {
    id v0 = 0;
  }
  return v0;
}

void sub_24B6D1C1C(_Unwind_Exception *a1)
{
}

id OCMetalCommandQueue()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1358, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2697D1358))
  {
    qword_2697D1350 = sub_24B727BB4();
    __cxa_atexit((void (*)(void *))sub_24B727D84, &qword_2697D1350, &dword_24B6B9000);
    __cxa_guard_release(&qword_2697D1358);
  }
  if (qword_2697D1350) {
    id v0 = *(id *)(qword_2697D1350 + 8);
  }
  else {
    id v0 = 0;
  }
  return v0;
}

void sub_24B6D1CD8(_Unwind_Exception *a1)
{
}

id OCMetalDefaultLibrary()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1358, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2697D1358))
  {
    qword_2697D1350 = sub_24B727BB4();
    __cxa_atexit((void (*)(void *))sub_24B727D84, &qword_2697D1350, &dword_24B6B9000);
    __cxa_guard_release(&qword_2697D1358);
  }
  if (qword_2697D1350) {
    id v0 = *(id *)(qword_2697D1350 + 16);
  }
  else {
    id v0 = 0;
  }
  return v0;
}

void sub_24B6D1D94(_Unwind_Exception *a1)
{
}

BOOL isAppleGPU()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1358, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2697D1358))
  {
    qword_2697D1350 = sub_24B727BB4();
    __cxa_atexit((void (*)(void *))sub_24B727D84, &qword_2697D1350, &dword_24B6B9000);
    __cxa_guard_release(&qword_2697D1358);
  }
  return qword_2697D1350 && *(unsigned char *)(qword_2697D1350 + 24) != 0;
}

void sub_24B6D1E44(_Unwind_Exception *a1)
{
}

uint64_t OCImageScalerCreate(uint64_t a1, uint64_t a2)
{
  uint64_t result = 4294967294;
  if (a1)
  {
    if (a2) {
      operator new();
    }
  }
  return result;
}

void sub_24B6D1F04(_Unwind_Exception *a1)
{
  MEMORY[0x24C5D7790](v1, 0x1020C40D5A9D86FLL);
  _Unwind_Resume(a1);
}

uint64_t OCImageScalerStart(uint64_t a1)
{
  if (qword_2697D0F58 != -1) {
    dispatch_once(&qword_2697D0F58, &unk_26FE9CA00);
  }
  CFTypeRef v2 = qword_2697D0F50;
  if (os_log_type_enabled((os_log_t)qword_2697D0F50, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)CFTypeID v4 = 0;
    _os_log_debug_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_DEBUG, "OCImageScalerStart", v4, 2u);
  }
  if (a1) {
    return 0;
  }
  else {
    return 4294967294;
  }
}

uint64_t sub_24B6D1FC8()
{
  qword_2697D0F50 = (uint64_t)os_log_create("com.apple.CoreOCModules", "General");
  return MEMORY[0x270F9A758]();
}

uint64_t OCImageScalerResizeImage(void ***a1, __CVBuffer *a2, CVPixelBufferRef pixelBuffer, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  v122[2] = *MEMORY[0x263EF8340];
  v90.origin.x = a4;
  v90.origin.y = a5;
  v90.size.width = a6;
  v90.size.height = a7;
  if (a1)
  {
    uint64_t v7 = *a1;
    if (*(_DWORD *)*a1)
    {
      if (qword_2697D11D8 != -1) {
        dispatch_once(&qword_2697D11D8, &unk_26FE9CE20);
      }
      BOOL v8 = qword_2697D11D0;
      if (!os_log_type_enabled((os_log_t)qword_2697D11D0, OS_LOG_TYPE_ERROR)) {
        goto LABEL_6;
      }
      *(_WORD *)simd_float4x4 buf = 0;
      double v80 = "Failed to crop and scale image, input buffer is not RGB frame!";
      goto LABEL_36;
    }
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
    unint64_t Width = CVPixelBufferGetWidth(pixelBuffer);
    unint64_t Height = CVPixelBufferGetHeight(pixelBuffer);
    if (PixelFormatType != 875704422 && PixelFormatType != 1111970369 && PixelFormatType != 1278226488)
    {
      if (qword_2697D11D8 != -1) {
        dispatch_once(&qword_2697D11D8, &unk_26FE9CE20);
      }
      uint64_t v79 = qword_2697D11D0;
      if (os_log_type_enabled((os_log_t)qword_2697D11D0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)simd_float4x4 buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = PixelFormatType;
        _os_log_error_impl(&dword_24B6B9000, v79, OS_LOG_TYPE_ERROR, "Failed to crop and scale image, pixel format %{public}x not supported!", buf, 8u);
      }
      goto LABEL_6;
    }
    OSType v20 = CVPixelBufferGetPixelFormatType(a2);
    CVPixelBufferRef pixelBufferOut = 0;
    if (v20 == PixelFormatType)
    {
      if (!sub_24B6F6550(a2, &v90, v7[1], pixelBuffer))
      {
        if (qword_2697D11D8 != -1) {
          dispatch_once(&qword_2697D11D8, &unk_26FE9CE20);
        }
        BOOL v8 = qword_2697D11D0;
        if (!os_log_type_enabled((os_log_t)qword_2697D11D0, OS_LOG_TYPE_ERROR)) {
          goto LABEL_6;
        }
        *(_WORD *)simd_float4x4 buf = 0;
        double v80 = "Failed to crop and scale image, error in cropping and scaling the grayscale image!";
LABEL_36:
        _os_log_error_impl(&dword_24B6B9000, v8, OS_LOG_TYPE_ERROR, v80, buf, 2u);
        goto LABEL_6;
      }
LABEL_14:
      CFDictionaryRef v21 = (const __CFDictionary *)CVBufferCopyAttachment(a2, @"Calibration Data", 0);
      CFDictionaryRef v22 = v21;
      if (v21)
      {
        CFTypeID v23 = CFGetTypeID(v21);
        if (v23 == CFDictionaryGetTypeID())
        {
          double v95 = 0.0;
          double v96 = 0.0;
          double v93 = 0.0;
          double v94 = 0.0;
          double v92 = 0.0;
          int CalibrationPinholeModel_0 = getCalibrationPinholeModel_0(v22, 0, (void **)&v96, (void **)&v95, (void **)&v94, (void **)&v93, (void **)&v92);
          CFRelease(v22);
          if (CalibrationPinholeModel_0)
          {
            double v27 = (double)Width;
            if (vabdd_f64((double)Width / a6, (double)Height / a7) <= 0.000001)
            {
              double v28 = (double)(unint64_t)a6;
              double v29 = v95;
              double v30 = (v94 - a4) * v27 / v28;
              double v31 = v93;
              long long v32 = objc_msgSend_numberWithDouble_(NSNumber, v25, v26, v30);
              v122[0] = v32;
              long long v35 = objc_msgSend_numberWithDouble_(NSNumber, v33, v34, (v31 - a5) * v27 / v28);
              v122[1] = v35;
              int v89 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x263EFF8C0], v36, (uint64_t)v122, 2);

              __int16 v39 = objc_msgSend_numberWithDouble_(NSNumber, v37, v38, v92);
              uint64_t v121 = v39;
              int v88 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x263EFF8C0], v40, (uint64_t)&v121, 1);

              v116[0] = @"Aspect Ratio";
              v114 = @"Data";
              char v86 = objc_msgSend_numberWithDouble_(NSNumber, v41, v42, v96);
              __int32 v113 = v86;
              uint64_t v85 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x263EFF8C0], v43, (uint64_t)&v113, 1);
              v115 = v85;
              __int16 v84 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v44, (uint64_t)&v115, &v114, 1);
              *(void *)simd_float4x4 buf = v84;
              v116[1] = @"Focal Length";
              uint64_t v111 = @"Data";
              unsigned int v47 = objc_msgSend_numberWithDouble_(NSNumber, v45, v46, v29 * v27 / v28);
              char v110 = v47;
              long long v49 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x263EFF8C0], v48, (uint64_t)&v110, 1);
              simd_float4x4 v112 = v49;
              long long v51 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v50, (uint64_t)&v112, &v111, 1);
              unsigned int v118 = v51;
              v116[2] = @"Principal Point";
              int v108 = @"Data";
              uint64_t v109 = v89;
              uint64_t v53 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v52, (uint64_t)&v109, &v108, 1);
              id v119 = v53;
              void v116[3] = @"Skew";
              int v106 = @"Data";
              __int16 v107 = v88;
              int v55 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v54, (uint64_t)&v107, &v106, 1);
              v120 = v55;
              int v57 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v56, (uint64_t)buf, v116, 4);
              uint64_t v87 = objc_msgSend_mutableCopy(v57, v58, v59);

              long long v61 = objc_msgSend_numberWithUnsignedLong_(NSNumber, v60, Width);
              v105[0] = v61;
              long long v63 = objc_msgSend_numberWithUnsignedLong_(NSNumber, v62, Height);
              v105[1] = v63;
              uint64_t v65 = objc_msgSend_arrayWithObjects_count_(MEMORY[0x263EFF8C0], v64, (uint64_t)v105, 2);

              long long v103 = @"Sensors";
              long long v101 = @"Intrinsics";
              v98[1] = v65;
              uint64_t v99 = @"RGB";
              v97[0] = @"Pinhole";
              v97[1] = @"Resolution";
              v98[0] = v87;
              uint64_t v67 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v66, (uint64_t)v98, v97, 2);
              long long v100 = v67;
              int v69 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v68, (uint64_t)&v100, &v99, 1);
              long long v102 = v69;
              __int16 v71 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v70, (uint64_t)&v102, &v101, 1);
              char v104 = v71;
              long long v73 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v72, (uint64_t)&v104, &v103, 1);
              CFDictionaryRef v22 = (const __CFDictionary *)objc_msgSend_mutableCopy(v73, v74, v75);

              CFRetain(v22);
              goto LABEL_44;
            }
          }
        }
        else
        {
          CFRelease(v22);
        }
        CFDictionaryRef v22 = 0;
      }
LABEL_44:
      CVBufferSetAttachment(pixelBuffer, @"Calibration Data", v22, kCVAttachmentMode_ShouldPropagate);
      CFTypeRef v82 = CVBufferCopyAttachment(a2, @"MetadataDictionary", 0);
      CVBufferSetAttachment(pixelBuffer, @"MetadataDictionary", v82, kCVAttachmentMode_ShouldPropagate);
      if (v82) {
        CFRelease(v82);
      }
      if (v22) {
        CFRelease(v22);
      }
      unsigned int v9 = 0x80000000;
      return ((int)~v9 >> 31);
    }
    if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], Width, Height, v20, 0, &pixelBufferOut))
    {
LABEL_6:
      unsigned int v9 = 0;
      return ((int)~v9 >> 31);
    }
    if (!sub_24B6F6550(a2, &v90, v7[1], pixelBufferOut))
    {
      if (qword_2697D11D8 != -1) {
        dispatch_once(&qword_2697D11D8, &unk_26FE9CE20);
      }
      double v81 = qword_2697D11D0;
      if (os_log_type_enabled((os_log_t)qword_2697D11D0, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)simd_float4x4 buf = 0;
        _os_log_error_impl(&dword_24B6B9000, v81, OS_LOG_TYPE_ERROR, "Failed to crop and scale image, error in cropping and scaling the grayscale image!", buf, 2u);
      }
      CVPixelBufferRelease(pixelBufferOut);
      goto LABEL_6;
    }
    long long v76 = (OpaqueVTPixelTransferSession *)v7[1];
    if (v76)
    {
      if (!VTPixelTransferSessionTransferImage(v76, pixelBufferOut, pixelBuffer))
      {
        CVPixelBufferRelease(pixelBufferOut);
        goto LABEL_14;
      }
      if (qword_2697D11D8 != -1) {
        dispatch_once(&qword_2697D11D8, &unk_26FE9CE20);
      }
      uint64_t v77 = qword_2697D11D0;
      if (!os_log_type_enabled((os_log_t)qword_2697D11D0, OS_LOG_TYPE_ERROR))
      {
LABEL_52:
        if (qword_2697D11D8 != -1) {
          dispatch_once(&qword_2697D11D8, &unk_26FE9CE20);
        }
        int v83 = (id)qword_2697D11D0;
        if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)simd_float4x4 buf = 0;
          _os_log_error_impl(&dword_24B6B9000, v83, OS_LOG_TYPE_ERROR, "Failed to crop and scale image, error in converting buffer type after scaling!", buf, 2u);
        }

        CVPixelBufferRelease(pixelBufferOut);
        goto LABEL_6;
      }
      *(_WORD *)simd_float4x4 buf = 0;
      uint64_t v78 = "Failed to convert buffer pixel format in VTPixelTransferSession";
    }
    else
    {
      if (qword_2697D11D8 != -1) {
        dispatch_once(&qword_2697D11D8, &unk_26FE9CE20);
      }
      uint64_t v77 = qword_2697D11D0;
      if (!os_log_type_enabled((os_log_t)qword_2697D11D0, OS_LOG_TYPE_ERROR)) {
        goto LABEL_52;
      }
      *(_WORD *)simd_float4x4 buf = 0;
      uint64_t v78 = "Failed to convert buffer type, pixel transfer session ref is nil!";
    }
    _os_log_error_impl(&dword_24B6B9000, v77, OS_LOG_TYPE_ERROR, v78, buf, 2u);
    goto LABEL_52;
  }
  return 4294967294;
}

void sub_24B6D2974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t OCImageScalerStop(uint64_t a1)
{
  if (qword_2697D0F58 != -1) {
    dispatch_once(&qword_2697D0F58, &unk_26FE9CA00);
  }
  CFTypeRef v2 = qword_2697D0F50;
  if (os_log_type_enabled((os_log_t)qword_2697D0F50, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)CFTypeID v4 = 0;
    _os_log_debug_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_DEBUG, "OCImageScalerStop", v4, 2u);
  }
  if (a1) {
    return 0;
  }
  else {
    return 4294967294;
  }
}

uint64_t OCImageScalerDestroy(uint64_t *a1)
{
  if (!a1) {
    return 4294967294;
  }
  uint64_t v2 = *a1;
  if (*a1)
  {
    int v3 = *(OpaqueVTPixelTransferSession **)(v2 + 8);
    if (v3)
    {
      VTPixelTransferSessionInvalidate(v3);
      CFRelease(*(CFTypeRef *)(v2 + 8));
      *(void *)(v2 + 8) = 0;
    }
    MEMORY[0x24C5D7790](v2, 0x1020C40D5A9D86FLL);
  }
  MEMORY[0x24C5D7790](a1, 0x20C4093837F09);
  return 0;
}

uint64_t sub_24B6D2BCC()
{
  qword_2697D0F70 = 0;
  *(void *)algn_2697D0F78 = "OCCoverageResults";
  qword_2697D0F80 = (uint64_t)sub_24B6D2D50;
  unk_2697D0F88 = 0;
  qword_2697D0F98 = 0;
  unk_2697D0FA0 = 0;
  qword_2697D0F90 = (uint64_t)sub_24B6D2CE4;
  qword_2697D0FA8 = (uint64_t)sub_24B6D2C94;
  qword_2697D0FB0 = (uint64_t)sub_24B6D2C44;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_2697D0F68 = result;
  return result;
}

CFStringRef sub_24B6D2C44(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<OCCoverageResults %p [%p]>", a1, v3);
}

CFStringRef sub_24B6D2C94(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<OCCoverageResults %p [%p]>", a1, v3);
}

uint64_t sub_24B6D2CE4(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFAllocatorRef v2 = *(void **)(result + 16);
    if (v2)
    {
      if (*v2)
      {
        MEMORY[0x24C5D7760](*v2, 0x1000C80451B5BE8);
        void *v2 = 0;
      }
      uint64_t result = MEMORY[0x24C5D7790](v2, 0x10A0C40700A216ALL);
    }
    *(void *)(v1 + 16) = 0;
  }
  return result;
}

uint64_t sub_24B6D2D50(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

CFTypeRef OCCoverageResultsRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

uint64_t OCCoverageResultsGetData(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

void OCCoverageResultsRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t sub_24B6D2DA0(float **a1, const void *a2, uint64_t *a3)
{
  if (!a3) {
    return 4294967294;
  }
  uint64_t v6 = *a3;
  if (*a3)
  {
    if (*(void *)v6) {
      CFRelease(*(CFTypeRef *)v6);
    }
    *(void *)uint64_t v6 = 0;
    uint64_t v7 = *(void *)(v6 + 8);
    if (v7)
    {
      MEMORY[0x24C5D7760](v7, 0x1000C8052888210);
      *(void *)(v6 + 8) = 0;
    }
    MEMORY[0x24C5D7790](v6, 0x10A0C40D63CFB62);
    *a3 = 0;
  }
  BOOL v8 = operator new(0x20uLL, MEMORY[0x263F8C180]);
  if (!v8) {
    return 4294967293;
  }
  unsigned int v9 = v8;
  _OWORD *v8 = 0u;
  v8[1] = 0u;
  uint64_t v10 = *a1;
  uint64_t v11 = a1[1];
  uint64_t v12 = (char *)v11 - (char *)*a1;
  if (v12 < 0) {
    size_t v13 = -1;
  }
  else {
    size_t v13 = (char *)v11 - (char *)*a1;
  }
  uint64_t v14 = (char *)operator new[](v13, MEMORY[0x263F8C180]);
  *((void *)v9 + 1) = v14;
  if (!v14)
  {
    *(void *)unsigned int v9 = 0;
    MEMORY[0x24C5D7790](v9, 0x10A0C40D63CFB62);
    return 4294967293;
  }
  unint64_t v15 = v12 >> 2;
  *((void *)v9 + 2) = v12 >> 2;
  if (v11 != v10)
  {
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    if (v15 < 8 || (unint64_t)(v14 - (char *)v10) <= 0x1F)
    {
      unint64_t v17 = 0;
LABEL_27:
      unint64_t v23 = v15 - v17;
      uint64_t v24 = v17;
      int v25 = &v14[4 * v17];
      uint64_t v26 = &v10[v24];
      do
      {
        int v27 = *(_DWORD *)v26++;
        *(_DWORD *)int v25 = v27;
        v25 += 4;
        --v23;
      }
      while (v23);
      goto LABEL_29;
    }
    unint64_t v17 = v15 & 0xFFFFFFFFFFFFFFF8;
    long long v19 = v14 + 16;
    OSType v20 = (long long *)(v10 + 4);
    unint64_t v21 = v15 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      long long v22 = *v20;
      *(v19 - 1) = *(v20 - 1);
      _OWORD *v19 = v22;
      v19 += 2;
      v20 += 2;
      v21 -= 8;
    }
    while (v21);
    if (v15 != v17) {
      goto LABEL_27;
    }
  }
LABEL_29:
  if (a2)
  {
    CFRetain(a2);
    uint64_t v10 = *a1;
    uint64_t v11 = a1[1];
  }
  *(void *)unsigned int v9 = a2;
  if (v10 != v11)
  {
    uint64_t v28 = (char *)v11 - (char *)v10;
    unint64_t v29 = (char *)v11 - (char *)v10 - 4;
    if (v29 >= 0x1C)
    {
      uint64_t v32 = (v29 >> 2) + 1;
      long long v33 = (float32x4_t *)(v10 + 4);
      int64x2_t v34 = 0uLL;
      float32x4_t v35 = (float32x4_t)vdupq_n_s32(0x3F4CCCCDu);
      int8x16_t v36 = (int8x16_t)vdupq_n_s64(1uLL);
      uint64_t v37 = v32 & 0x7FFFFFFFFFFFFFF8;
      int64x2_t v38 = 0uLL;
      int64x2_t v39 = 0uLL;
      int64x2_t v40 = 0uLL;
      do
      {
        int32x4_t v41 = vcgtq_f32(v33[-1], v35);
        v42.i64[0] = v41.u32[0];
        v42.i64[1] = v41.u32[1];
        int64x2_t v43 = (int64x2_t)vandq_s8(v42, v36);
        v42.i64[0] = v41.u32[2];
        v42.i64[1] = v41.u32[3];
        int64x2_t v44 = (int64x2_t)vandq_s8(v42, v36);
        int32x4_t v45 = vcgtq_f32(*v33, v35);
        v42.i64[0] = v45.u32[0];
        v42.i64[1] = v45.u32[1];
        int64x2_t v46 = (int64x2_t)vandq_s8(v42, v36);
        v42.i64[0] = v45.u32[2];
        v42.i64[1] = v45.u32[3];
        int64x2_t v38 = vaddq_s64(v38, v44);
        int64x2_t v34 = vaddq_s64(v34, v43);
        int64x2_t v40 = vaddq_s64(v40, (int64x2_t)vandq_s8(v42, v36));
        int64x2_t v39 = vaddq_s64(v39, v46);
        v33 += 2;
        v37 -= 8;
      }
      while (v37);
      unint64_t v30 = vaddvq_s64(vaddq_s64(vaddq_s64(v39, v34), vaddq_s64(v40, v38)));
      if (v32 == (v32 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_42:
        float v31 = (float)v30 / (float)(unint64_t)(v28 >> 2);
        goto LABEL_43;
      }
      v10 += v32 & 0x7FFFFFFFFFFFFFF8;
    }
    else
    {
      unint64_t v30 = 0;
    }
    do
    {
      float v47 = *v10++;
      if (v47 > 0.8) {
        ++v30;
      }
    }
    while (v10 != v11);
    goto LABEL_42;
  }
  float v31 = 0.0;
LABEL_43:
  uint64_t result = 0;
  *((float *)v9 + 6) = v31;
  *a3 = (uint64_t)v9;
  return result;
}

void sub_24B6D3050(float32x4_t **a1, CFTypeRef *a2)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  if (*a1) {
    BOOL v2 = a1[1] == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2
    || a1[2] != (float32x4_t *)(-1431655765 * ((unint64_t)((*a1)[6].i64[1] - (*a1)[6].i64[0]) >> 4))
    || !a2
    || *((float *)a1 + 6) < 0.0)
  {
    return;
  }
  if (*a2)
  {
    CFRelease(*a2);
    *a2 = 0;
  }
  if (qword_2697D0F60 != -1) {
    dispatch_once(&qword_2697D0F60, &unk_26FE9CA20);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return;
  }
  uint64_t v6 = (void *)Instance;
  uint64_t v7 = operator new(0x60uLL, MEMORY[0x263F8C180]);
  v6[2] = v7;
  if (!v7
    || ((unint64_t v8 = (unint64_t)a1[2], v8 >> 60) ? (v9 = -1) : (v9 = 16 * v8),
        uint64_t v10 = operator new[](v9, MEMORY[0x263F8C180]),
        (*(void *)v6[2] = v10) == 0))
  {
    CFRelease(v6);
    return;
  }
  uint64_t v11 = *a1;
  if (*a1)
  {
    float v12 = v11[1].f32[0];
    float32x4_t v13 = v11[2];
    float32x4_t v14 = v11[3];
    float32x4_t v15 = v11[4];
    float32x4_t v16 = v11[5];
    float32x4_t v56 = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v13, v12), (float32x4_t)0, v14), (float32x4_t)0, v15), (float32x4_t)0, v16);
    float32x4_t v17 = vmulq_f32(v13, (float32x4_t)0);
    float32x4_t v18 = vmlaq_f32(vmlaq_f32(vmlaq_n_f32(v17, v14, v12), (float32x4_t)0, v15), (float32x4_t)0, v16);
    float32x4_t v19 = vmlaq_f32(v17, (float32x4_t)0, v14);
    float32x4_t v54 = vmlaq_f32(vmlaq_n_f32(v19, v15, v12), (float32x4_t)0, v16);
    float32x4_t v55 = v18;
    float32x4_t v20 = vaddq_f32(v16, vmlaq_f32(v19, (float32x4_t)0, v15));
  }
  else
  {
    if (qword_2697D0E58 != -1) {
      dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
    }
    unint64_t v21 = qword_2697D0E50;
    if (os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = "OCVoxelCloudTransformMatrix";
      __int16 v58 = 1026;
      int v59 = 371;
      _os_log_error_impl(&dword_24B6B9000, v21, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid voxelcloud.", buf, 0x12u);
    }
    float32x4_t v20 = 0uLL;
    float32x4_t v55 = 0u;
    float32x4_t v56 = 0u;
    float32x4_t v54 = 0u;
  }
  float32x4_t v53 = v20;
  if (!a1[2])
  {
    long long v33 = 0;
    uint64_t v52 = v6[2];
    *(void *)(v52 + 8) = 0;
    *(_DWORD *)(v52 + 16) = *((_DWORD *)a1 + 6);
    goto LABEL_52;
  }
  uint64_t v22 = 0;
  unint64_t v23 = 0;
  do
  {
    uint64_t v26 = *a1;
    if (*a1 && (uint64_t v28 = v26 + 6, v27 = v26[6].i64[0], 0xAAAAAAAAAAAAAAABLL * ((v28->i64[1] - v27) >> 4) > v23))
    {
      if (!v27) {
        goto LABEL_30;
      }
      float32x4_t v24 = vaddq_f32(v53, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v56, (float)*(int *)(v27 + v22)), v55, (float)*(int *)(v27 + v22 + 4)), v54, (float)*(int *)(v27 + v22 + 8)));
    }
    else
    {
      if (qword_2697D0E58 != -1) {
        dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
      }
      unint64_t v29 = qword_2697D0E50;
      BOOL v30 = os_log_type_enabled((os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR);
      v24.i64[0] = 0;
      v24.i32[2] = 0;
      if (v30)
      {
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = "OCVoxelCloudVoxelAt";
        __int16 v58 = 1026;
        int v59 = 301;
        _os_log_error_impl(&dword_24B6B9000, v29, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid voxelcloud.", buf, 0x12u);
LABEL_30:
        v24.i64[0] = 0;
        v24.i32[2] = 0;
      }
    }
    v24.i32[3] = a1[1]->i32[v23];
    *(float32x4_t *)(*(void *)v6[2] + 16 * v23++) = v24;
    unint64_t v25 = (unint64_t)a1[2];
    v22 += 48;
  }
  while (v23 < v25);
  uint64_t v31 = v6[2];
  *(void *)(v31 + 8) = v25;
  *(_DWORD *)(v31 + 16) = *((_DWORD *)a1 + 6);
  if (v25)
  {
    if (v25 >= 0x555555555555556) {
      abort();
    }
    uint64_t v32 = 48 * v25;
    long long v33 = (char *)operator new(48 * v25);
    bzero(v33, 48 * ((v32 - 48) / 0x30uLL) + 48);
    unint64_t v35 = 0;
    int8x16_t v36 = *a1;
    uint64_t v37 = a1[1];
    uint64_t v38 = 32;
    unint64_t v39 = (unint64_t)a1[2];
    float32x4_t v40 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      if (!v36 || (uint64_t v41 = v36[6].i64[0], 0xAAAAAAAAAAAAAAABLL * ((v36[6].i64[1] - v41) >> 4) <= v35))
      {
        if (qword_2697D0E58 != -1) {
          dispatch_once(&qword_2697D0E58, &unk_26FE9C960);
        }
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = "OCVoxelCloudVoxelAt";
        __int16 v58 = 1026;
        int v59 = 301;
        _os_log_error_impl(&dword_24B6B9000, (os_log_t)qword_2697D0E50, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid voxelcloud.", buf, 0x12u);
        __break(1u);
        return;
      }
      int8x16_t v42 = (float32x4_t *)(v41 + v38);
      *(float32x2_t *)v34.f32 = vadd_f32(vcvt_f32_s32(*(int32x2_t *)v42[-2].f32), (float32x2_t)0x3F0000003F000000);
      v34.f32[2] = (float)v42[-2].i32[2] + 0.5;
      int64x2_t v43 = (float32x4_t *)&v33[v38];
      v43[-2] = v34;
      v43[-1] = v42[-1];
      float32x4_t v34 = vminnmq_f32(vmaxnmq_f32(vrndaq_f32(vmulq_f32(*v42, v40)), (float32x4_t)0), v40);
      v43->i32[0] = v34.f32[3] | (v34.f32[1] << 16) | (v34.f32[0] << 24) | (v34.f32[2] << 8);
      v43->i32[1] = v37->i32[v35++];
      v38 += 48;
    }
    while (v35 < v39);
    if (v39)
    {
      *(void *)simd_float4x4 buf = 0;
      size_t v44 = 48 * v39;
      if (!sub_24B6BC870(2021227107, 48 * v39, (IOSurfaceRef *)buf))
      {
        BaseAddress = IOSurfaceGetBaseAddress(*(IOSurfaceRef *)buf);
        memcpy(BaseAddress, v33, v44);
        int v46 = CVDataBufferCreateWithIOSurface();
        CFRelease(*(CFTypeRef *)buf);
        if (!v46)
        {
          *(double *)&long long v47 = OCVoxelCloudTransformMatrix(*a1);
          uint64_t v48 = (_OWORD *)v6[2];
          v48[2] = v47;
          v48[3] = v49;
          v48[4] = v50;
          v48[5] = v51;
          *a2 = v6;
          goto LABEL_53;
        }
      }
    }
  }
  else
  {
    long long v33 = 0;
  }
LABEL_52:
  CFRelease(v6);
  if (v33) {
LABEL_53:
  }
    operator delete(v33);
}

void sub_24B6D3670(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

id OCNonModularSPI_AVCameraCalibrationData_CreateDictionaryFrom(void *a1, const char *a2, uint64_t a3)
{
  if (a1)
  {
    a1 = objc_msgSend_cameraCalibrationDataDictionary(a1, a2, a3);
    uint64_t v3 = vars8;
  }
  return a1;
}

id OCNonModularSPI_AVCameraCalibrationData_InitFrom(void *a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = (objc_class *)MEMORY[0x263EFA548];
    id v4 = a1;
    id v5 = [v3 alloc];
    uint64_t v7 = objc_msgSend_initWithCameraCalibrationDataDictionary_error_(v5, v6, (uint64_t)v4, a2);
  }
  else
  {
    uint64_t v7 = 0;
  }
  return v7;
}

uint64_t OCMeshToObjFile(uint64_t a1, uint64_t a2)
{
  v31[20] = *MEMORY[0x263EF8340];
  if (a1) {
    BOOL v2 = a2 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  uint64_t v3 = !v2;
  if (v2)
  {
    if (qword_2697D0FD8 != -1) {
      dispatch_once(&qword_2697D0FD8, &unk_26FE9CA40);
    }
    float32x4_t v24 = qword_2697D0FD0;
    if (os_log_type_enabled((os_log_t)qword_2697D0FD0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)simd_float4x4 buf = 0;
      _os_log_error_impl(&dword_24B6B9000, v24, OS_LOG_TYPE_ERROR, "OCMeshToObjFile: Input mesh or filepath is empty!", buf, 2u);
    }
  }
  else
  {
    unsigned int v27 = v3;
    uint64_t v5 = MEMORY[0x263F8C310] + 24;
    uint64_t v6 = MEMORY[0x263F8C310] + 64;
    v31[0] = MEMORY[0x263F8C310] + 64;
    uint64_t v7 = *(void *)(MEMORY[0x263F8C2B0] + 16);
    *(void *)simd_float4x4 buf = *(void *)(MEMORY[0x263F8C2B0] + 8);
    *(void *)&buf[*(void *)(*(void *)buf - 24)] = v7;
    unint64_t v8 = (std::ios_base *)&buf[*(void *)(*(void *)buf - 24)];
    std::ios_base::init(v8, v30);
    v8[1].__vftable = 0;
    v8[1].__fmtflags_ = -1;
    *(void *)simd_float4x4 buf = v5;
    v31[0] = v6;
    MEMORY[0x24C5D75C0](v30);
    std::ofstream::open();
    uint64_t v26 = *(void *)(a1 + 8);
    uint64_t v9 = *(unsigned int *)(a1 + 24);
    uint64_t v10 = *(unsigned int *)(a1 + 28);
    if (v9)
    {
      uint64_t v11 = *(void *)a1 + 8;
      float v12 = (std::locale::id *)MEMORY[0x263F8C108];
      do
      {
        sub_24B6D3CA0(buf, (uint64_t)"v ", 2);
        float32x4_t v13 = (void *)std::ostream::operator<<();
        sub_24B6D3CA0(v13, (uint64_t)" ", 1);
        float32x4_t v14 = (void *)std::ostream::operator<<();
        sub_24B6D3CA0(v14, (uint64_t)" ", 1);
        v11 += 16;
        float32x4_t v15 = (void *)std::ostream::operator<<();
        std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(void *)(*v15 - 24)));
        float32x4_t v16 = std::locale::use_facet(&v28, v12);
        ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10);
        std::locale::~locale(&v28);
        std::ostream::put();
        std::ostream::flush();
        --v9;
      }
      while (v9);
    }
    std::ios_base::getloc((const std::ios_base *)&buf[*(void *)(*(void *)buf - 24)]);
    float32x4_t v17 = std::locale::use_facet(&v28, MEMORY[0x263F8C108]);
    ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
    std::locale::~locale(&v28);
    std::ostream::put();
    std::ostream::flush();
    if (v10)
    {
      uint64_t v18 = v26 + 8;
      float32x4_t v19 = (std::locale::id *)MEMORY[0x263F8C108];
      do
      {
        sub_24B6D3CA0(buf, (uint64_t)"f ", 2);
        float32x4_t v20 = (void *)std::ostream::operator<<();
        sub_24B6D3CA0(v20, (uint64_t)" ", 1);
        unint64_t v21 = (void *)std::ostream::operator<<();
        sub_24B6D3CA0(v21, (uint64_t)" ", 1);
        v18 += 16;
        uint64_t v22 = (void *)std::ostream::operator<<();
        std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(void *)(*v22 - 24)));
        unint64_t v23 = std::locale::use_facet(&v28, v19);
        ((void (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10);
        std::locale::~locale(&v28);
        std::ostream::put();
        std::ostream::flush();
        --v10;
      }
      while (v10);
    }
    if (!std::filebuf::close()) {
      std::ios_base::clear((std::ios_base *)&buf[*(void *)(*(void *)buf - 24)], *(_DWORD *)&v30[*(void *)(*(void *)buf - 24) + 24] | 4);
    }
    *(void *)simd_float4x4 buf = *MEMORY[0x263F8C2B0];
    *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x263F8C2B0] + 24);
    MEMORY[0x24C5D75D0](v30);
    std::ostream::~ostream();
    MEMORY[0x24C5D7720](v31);
    return v27;
  }
  return v3;
}

void *sub_24B6D3CA0(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x24C5D7600](v23, a1);
  if (!v23[0]) {
    goto LABEL_32;
  }
  uint64_t v6 = (char *)a1 + *(void *)(*a1 - 24);
  uint64_t v7 = *((void *)v6 + 5);
  uint64_t v8 = a2 + a3;
  if ((*((_DWORD *)v6 + 2) & 0xB0) == 0x20) {
    uint64_t v9 = a2 + a3;
  }
  else {
    uint64_t v9 = a2;
  }
  int v10 = *((_DWORD *)v6 + 36);
  if (v10 == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    uint64_t v11 = std::locale::use_facet(&__b, MEMORY[0x263F8C108]);
    int v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
    std::locale::~locale(&__b);
    *((_DWORD *)v6 + 36) = v10;
    if (!v7) {
      goto LABEL_31;
    }
  }
  else if (!v7)
  {
    goto LABEL_31;
  }
  uint64_t v12 = *((void *)v6 + 3);
  BOOL v13 = v12 <= a3;
  size_t v14 = v12 - a3;
  if (v13) {
    size_t v15 = 0;
  }
  else {
    size_t v15 = v14;
  }
  if (v9 - a2 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, a2, v9 - a2) != v9 - a2)
  {
    goto LABEL_31;
  }
  if ((uint64_t)v15 >= 1)
  {
    if (v15 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v15 >= 0x17)
    {
      uint64_t v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17) {
        uint64_t v17 = v15 | 7;
      }
      uint64_t v18 = v17 + 1;
      p_b = (std::locale::__imp *)operator new(v17 + 1);
      size_t v25 = v15;
      int64_t v26 = v18 | 0x8000000000000000;
      __b.__locale_ = p_b;
    }
    else
    {
      HIBYTE(v26) = v15;
      p_b = (std::locale::__imp *)&__b;
    }
    memset(p_b, v10, v15);
    *((unsigned char *)p_b + v15) = 0;
    if (v26 >= 0) {
      locale = &__b;
    }
    else {
      locale = __b.__locale_;
    }
    uint64_t v20 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v7 + 96))(v7, locale, v15);
    uint64_t v21 = v20;
    if ((SHIBYTE(v26) & 0x80000000) == 0)
    {
      if (v20 != v15) {
        goto LABEL_31;
      }
      goto LABEL_28;
    }
    operator delete(__b.__locale_);
    if (v21 != v15)
    {
LABEL_31:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
      goto LABEL_32;
    }
  }
LABEL_28:
  if (v8 - v9 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, v9, v8 - v9) != v8 - v9)
  {
    goto LABEL_31;
  }
  *((void *)v6 + 3) = 0;
LABEL_32:
  MEMORY[0x24C5D7610](v23);
  return a1;
}

os_log_t sub_24B6D3F4C()
{
  os_log_t result = os_log_create("com.apple.CoreOCModules", "General");
  qword_2697D0FD0 = (uint64_t)result;
  return result;
}

uint64_t OCFramingGuideGetTypeID()
{
  if (qword_2697D0FE0 != -1) {
    dispatch_once(&qword_2697D0FE0, &unk_26FE9CA60);
  }
  return qword_2697D0FE8;
}

uint64_t sub_24B6D3FC0()
{
  qword_2697D0FF0 = 0;
  *(void *)algn_2697D0FF8 = "OCFramingGuide";
  qword_2697D1000 = (uint64_t)sub_24B6D4118;
  unk_2697D1008 = 0;
  qword_2697D1018 = 0;
  unk_2697D1020 = 0;
  qword_2697D1010 = (uint64_t)sub_24B6D40D8;
  qword_2697D1028 = (uint64_t)sub_24B6D4088;
  qword_2697D1030 = (uint64_t)sub_24B6D4038;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_2697D0FE8 = result;
  return result;
}

CFStringRef sub_24B6D4038(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<OCFramingGuide %p [%p]>", a1, v3);
}

CFStringRef sub_24B6D4088(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<OCFramingGuide %p [%p]>", a1, v3);
}

double sub_24B6D40D8(uint64_t a1)
{
  if (a1)
  {
    CFAllocatorRef v2 = *(const void **)(a1 + 64);
    if (v2) {
      CFRelease(v2);
    }
    double result = 0.0;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
  }
  return result;
}

double sub_24B6D4118(_OWORD *a1)
{
  double result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

uint64_t OCFramingGuideCreate(long long *a1, void *a2)
{
  uint64_t result = 4294967294;
  if (a1 && a2)
  {
    if (qword_2697D0FE0 != -1) {
      dispatch_once(&qword_2697D0FE0, &unk_26FE9CA60);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v6 = (_OWORD *)Instance;
      uint64_t result = 0;
      long long v7 = *a1;
      long long v8 = a1[2];
      v6[2] = a1[1];
      v6[3] = v8;
      v6[1] = v7;
      *a2 = v6;
    }
    else
    {
      return 4294967293;
    }
  }
  return result;
}

uint64_t OCFramingGuideStart(uint64_t a1, simd_float4 a2, simd_float4 a3, simd_float4 a4, simd_float4 a5, float32x4_t a6, float32x4_t a7, float32x4_t a8, float32x4_t a9)
{
  if (!a1) {
    return 4294967294;
  }
  if (*(void *)(a1 + 64)) {
    return 0xFFFFFFFFLL;
  }
  int v11 = *(_DWORD *)(a1 + 32);
  long long v151 = *(_OWORD *)(a1 + 36);
  long long v155 = *(_OWORD *)(a1 + 16);
  uint64_t v12 = *(void *)(a1 + 52);
  char v13 = *(unsigned char *)(a1 + 60);
  if (qword_2697D0ED0 != -1) {
    dispatch_once(&qword_2697D0ED0, &unk_26FE9C9A0);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 4294967293;
  }
  size_t v15 = (void *)Instance;
  float32x4_t v16 = (char *)operator new(0x80uLL, MEMORY[0x263F8C180]);
  if (v16)
  {
    uint64_t v17 = (float32x2_t *)v16;
    unint64_t v135 = v15;
    *(_OWORD *)float32x4_t v16 = v155;
    *((_DWORD *)v16 + 4) = v11;
    *(_OWORD *)(v16 + 20) = v151;
    *(void *)(v16 + 36) = v12;
    v16[44] = v13;
    *((void *)v16 + 6) = 0;
    float64x2_t v156 = (float32x4_t **)(v16 + 48);
    *((_OWORD *)v16 + 5) = 0u;
    uint64_t v18 = (uint64_t)(v16 + 80);
    *((_OWORD *)v16 + 6) = 0u;
    *((void *)v16 + 7) = 0;
    *((void *)v16 + 8) = 0;
    *((_DWORD *)v16 + 18) = 0;
    *((_DWORD *)v16 + 28) = 1065353216;
    v185.columns[0] = a2;
    v185.columns[1] = a3;
    v185.columns[2] = a4;
    v185.columns[3] = a5;
    simd_float4x4 v186 = __invert_f4(v185);
    float32x4_t v152 = (float32x4_t)v186.columns[3];
    float32x4_t v174 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v186.columns[0], COERCE_FLOAT(*(_OWORD *)v17->f32)), (float32x4_t)v186.columns[1], *v17, 1), (float32x4_t)v186.columns[2], *(float32x4_t *)v17->f32, 2);
    v186.columns[3] = (simd_float4)vmulq_f32(a6, a6);
    *(float32x2_t *)v186.columns[3].f32 = vadd_f32(*(float32x2_t *)v186.columns[3].f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v186.columns[3], (int8x16_t)v186.columns[3], 8uLL));
    unsigned __int32 v19 = vadd_f32(*(float32x2_t *)v186.columns[3].f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v186.columns[3].f32, 1)).u32[0];
    float32x2_t v20 = vrsqrte_f32((float32x2_t)v19);
    float32x2_t v21 = vmul_f32(v20, vrsqrts_f32((float32x2_t)v19, vmul_f32(v20, v20)));
    float32x4_t v22 = vmulq_n_f32(a6, vmul_f32(v21, vrsqrts_f32((float32x2_t)v19, vmul_f32(v21, v21))).f32[0]);
    int8x16_t v23 = (int8x16_t)vmulq_f32(a7, a7);
    *(float32x2_t *)v23.i8 = vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL));
    v21.i32[0] = vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v23.i8, 1)).u32[0];
    float32x2_t v24 = vrsqrte_f32((float32x2_t)v21.u32[0]);
    float32x2_t v25 = vmul_f32(v24, vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v24, v24)));
    float32x4_t v26 = vmulq_n_f32(a7, vmul_f32(v25, vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v25, v25))).f32[0]);
    int8x16_t v27 = (int8x16_t)vmulq_f32(a8, a8);
    *(float32x2_t *)v27.i8 = vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL));
    v25.i32[0] = vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1)).u32[0];
    float32x2_t v28 = vrsqrte_f32((float32x2_t)v25.u32[0]);
    float32x2_t v29 = vmul_f32(v28, vrsqrts_f32((float32x2_t)v25.u32[0], vmul_f32(v28, v28)));
    float32x4_t v30 = vmulq_n_f32(a8, vmul_f32(v29, vrsqrts_f32((float32x2_t)v25.u32[0], vmul_f32(v29, v29))).f32[0]);
    float32x4_t v147 = v26;
    float32x4_t v149 = v22;
    float32x4_t v171 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v186.columns[0], v22.f32[0]), (float32x4_t)v186.columns[1], *(float32x2_t *)v22.f32, 1), (float32x4_t)v186.columns[2], v22, 2);
    float32x4_t v168 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v186.columns[0], v26.f32[0]), (float32x4_t)v186.columns[1], *(float32x2_t *)v26.f32, 1), (float32x4_t)v186.columns[2], v26, 2);
    float32x4_t v145 = v30;
    float32x4_t v165 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v186.columns[0], v30.f32[0]), (float32x4_t)v186.columns[1], *(float32x2_t *)v30.f32, 1), (float32x4_t)v186.columns[2], v30, 2);
    float32x4_t v162 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v186.columns[0], a9.f32[0]), (float32x4_t)v186.columns[1], *(float32x2_t *)a9.f32, 1), (float32x4_t)v186.columns[2], a9, 2);
    float v160 = sqrtf(vaddv_f32(*(float32x2_t *)v186.columns[3].f32));
    float v31 = sqrtf(vaddv_f32(*(float32x2_t *)v23.i8));
    int v32 = (int)(float)((float)(v31 / v17[4].f32[0]) + 0.5);
    float v158 = sqrtf(vaddv_f32(*(float32x2_t *)v27.i8));
    if (v32 <= 1) {
      int v32 = 1;
    }
    if (v32 >= 4) {
      unsigned int v33 = 4;
    }
    else {
      unsigned int v33 = v32;
    }
    if (v17[5].i8[4]) {
      float v34 = 0.0;
    }
    else {
      float v34 = -0.5236;
    }
    if ((float)((float)(v31 * 0.5) + (float)((float)(sinf(v34) * 0.6) * v31)) < 0.1) {
      float v34 = fminf(asinf(fmaxf(fminf((float)((float)(v31 * -0.5) + 0.1) / (float)(v31 * 0.6), 1.0), -1.0)), 0.2618);
    }
    int v35 = 0;
    unsigned int v36 = 0;
    float32x4_t v172 = vmlaq_laneq_f32(v171, v152, v149, 3);
    float32x4_t v169 = vmlaq_laneq_f32(v168, v152, v147, 3);
    float32x4_t v166 = vmlaq_laneq_f32(v165, v152, v145, 3);
    float32x4_t v163 = vmlaq_laneq_f32(v162, v152, a9, 3);
    float32x4_t v175 = vmlaq_f32(v174, (float32x4_t)0, v152);
    float v37 = v160 * 0.74;
    float v38 = v158 * 0.74;
    if ((float)(v158 * 0.74) >= (float)(v160 * 0.74)) {
      float v39 = v160 * 0.74;
    }
    else {
      float v39 = v158 * 0.74;
    }
    if (v37 >= v38) {
      float v40 = v160 * 0.74;
    }
    else {
      float v40 = v158 * 0.74;
    }
    float v141 = v40;
    float v142 = v39;
    float v143 = v31;
    float v41 = (float)(v31 * 1880.0) / 2560.0;
    float v137 = (float)(int)(v33 - 1);
    float v138 = v34;
    float v140 = flt_24B72A840[v33 - 1];
    float v136 = v140 - v34;
    uint64_t v150 = v18;
    unsigned int v139 = v33;
    do
    {
      float v42 = v140;
      if (v33 >= 2) {
        float v42 = v138 + (float)((float)(v136 * (float)v35) / v137);
      }
      int v146 = v35;
      float v148 = v42;
      __float2 v45 = __sincosf_stret(v42);
      float cosval = v45.__cosval;
      v43.i32[0] = *(void *)&v45;
      int v46 = 0;
      float v47 = v142 * cosval;
      float v48 = v17[2].f32[1];
      if (v48 >= (float)(v142 * cosval)) {
        float v47 = v17[2].f32[1];
      }
      if (v48 < (float)(v141 * cosval)) {
        float v48 = v141 * cosval;
      }
      float v49 = v48 * 6.2832;
      float v50 = v17[3].f32[1];
      if (v50 < 0.001) {
        float v50 = 0.001;
      }
      int v51 = (int)(float)((float)(v49 / v50) + 0.5);
      float v52 = v47 * 6.2832;
      if (v17[3].f32[0] >= 0.001) {
        float v53 = v17[3].f32[0];
      }
      else {
        float v53 = 0.001;
      }
      int v54 = (int)(float)((float)(v52 / v53) + 0.5);
      if (v54 >= 16) {
        int v54 = 16;
      }
      if (v51 <= v54) {
        int v51 = v54;
      }
      if (v51 <= 3) {
        int v55 = 3;
      }
      else {
        int v55 = v51;
      }
      float v56 = (float)v55;
      float v144 = v143 * *(float *)v43.i32;
      *(float *)v43.i32 = (float)(v143 * *(float *)v43.i32) * 0.6;
      float32x4_t v153 = (float32x4_t)vdupq_lane_s32(v43, 0);
      do
      {
        float32x4_t v183 = 0u;
        float32x4_t v184 = 0u;
        __int32 v61 = v17[9].i32[0];
        float v62 = v17[2].f32[1];
        if (v62 >= v37) {
          float v63 = v17[2].f32[1];
        }
        else {
          float v63 = v160 * 0.74;
        }
        float v64 = cosval * v63;
        if (v62 < v38) {
          float v62 = v158 * 0.74;
        }
        float v65 = cosval * v62;
        __float2 v66 = __sincosf_stret((float)((float)v46 * 6.2832) / v56);
        float32x4_t v67 = vmlaq_f32(vaddq_f32(v163, vmlaq_n_f32(vmlaq_f32(vmulq_n_f32(v172, v66.__cosval * v64), (float32x4_t)0, v169), v166, -(float)(v66.__sinval * v65))), v153, v175);
        float32x4_t v68 = vsubq_f32(v67, v163);
        float32x4_t v69 = vmulq_f32(v68, v68);
        LODWORD(v177) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 2), vaddq_f32(v69, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v69.f32, 1))).u32[0];
        float32x4_t v179 = v67;
        float32x2_t v70 = vrsqrte_f32((float32x2_t)LODWORD(v177));
        float32x2_t v71 = vmul_f32(v70, vrsqrts_f32((float32x2_t)LODWORD(v177), vmul_f32(v70, v70)));
        float32x4_t v72 = vmulq_n_f32(v68, vmul_f32(v71, vrsqrts_f32((float32x2_t)LODWORD(v177), vmul_f32(v71, v71))).f32[0]);
        float32x4_t v181 = v72;
        if (!v17[5].i8[4])
        {
          float32x4_t v73 = vmulq_f32(v175, v72);
          float32x2_t v74 = (float32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 2), vaddq_f32(v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v73.f32, 1))).u64[0];
          if (v74.f32[0] < 0.0)
          {
            float32x4_t v75 = vmlsq_lane_f32(v72, v175, v74, 0);
            int32x4_t v76 = (int32x4_t)vmulq_f32(v75, v75);
            v76.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v76, 2), vadd_f32(*(float32x2_t *)v76.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v76.i8, 1))).u32[0];
            float32x2_t v77 = vrsqrte_f32((float32x2_t)v76.u32[0]);
            float32x2_t v78 = vmul_f32(v77, vrsqrts_f32((float32x2_t)v76.u32[0], vmul_f32(v77, v77)));
            float32x4_t v181 = vmulq_n_f32(v75, vmul_f32(v78, vrsqrts_f32((float32x2_t)v76.u32[0], vmul_f32(v78, v78))).f32[0]);
          }
        }
        __float2 v79 = __sincosf_stret((float)((float)((float)v46 * 6.2832) / v56) + 1.5708);
        v80.f32[0] = v160 * v79.__cosval;
        v80.f32[1] = v158 * v79.__sinval;
        float v81 = (float)(sqrtf(vaddv_f32(vmul_f32(v80, v80))) * 1880.0) / 1920.0;
        if (v41 >= v81) {
          float v81 = v41;
        }
        v183.i64[0] = __PAIR64__(v36, COERCE_UNSIGNED_INT(fmaxf((float)(v81 * 1.2) - sqrtf(v177), 0.25)));
        v183.i32[2] = v61;
        v184.i32[0] = 1;
        int v83 = (float32x4_t *)v17[7];
        unint64_t v82 = (unint64_t)v17[8];
        if ((unint64_t)v83 < v82)
        {
          float32x4_t *v83 = v179;
          v83[1] = v181;
          float32x4_t v57 = v184;
          void v83[2] = v183;
          v83[3] = v57;
          f32 = (_OWORD *)v83[4].f32;
        }
        else
        {
          __int16 v84 = *v156;
          uint64_t v85 = ((char *)v83 - (char *)*v156) >> 6;
          unint64_t v86 = v85 + 1;
          if ((unint64_t)(v85 + 1) >> 58) {
LABEL_110:
          }
            abort();
          uint64_t v87 = v82 - (void)v84;
          if (v87 >> 5 > v86) {
            unint64_t v86 = v87 >> 5;
          }
          if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFC0) {
            unint64_t v88 = 0x3FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v88 = v86;
          }
          if (v88)
          {
            if (v88 >> 58) {
LABEL_111:
            }
              sub_24B6BCD7C();
            int v89 = (char *)operator new(v88 << 6);
          }
          else
          {
            int v89 = 0;
          }
          CGRect v90 = (float32x4_t *)&v89[64 * v85];
          float32x4_t *v90 = v179;
          v90[1] = v181;
          float32x4_t v91 = v184;
          v90[2] = v183;
          _OWORD v90[3] = v91;
          double v92 = v90;
          if (v83 != v84)
          {
            do
            {
              float32x4_t v93 = v83[-4];
              float32x4_t v94 = v83[-3];
              float32x4_t v95 = v83[-1];
              v92[-2] = v83[-2];
              v92[-1] = v95;
              v92[-4] = v93;
              v92[-3] = v94;
              v92 -= 4;
              v83 -= 4;
            }
            while (v83 != v84);
            int v83 = *v156;
          }
          f32 = (_OWORD *)v90[4].f32;
          v17[6] = (float32x2_t)v92;
          v17[7] = (float32x2_t)&v90[4];
          v17[8] = (float32x2_t)&v89[64 * v88];
          if (v83) {
            operator delete(v83);
          }
          uint64_t v18 = v150;
        }
        ++v36;
        v17[7] = (float32x2_t)f32;
        int v59 = (((unint64_t)f32 - *(void *)&v17[6]) >> 6) - 1;
        *((_DWORD *)sub_24B6EF354(v18, v183.u32[1], &v183.i32[1]) + 5) = v59;
        ++v46;
      }
      while (v46 != v55);
      if (v148 > 0.0 && v17[5].i8[4])
      {
        int v96 = 0;
        *(float *)v60.i32 = v144 * -0.6;
        float32x4_t v154 = (float32x4_t)vdupq_lane_s32(v60, 0);
        do
        {
          float32x4_t v183 = 0u;
          float32x4_t v184 = 0u;
          __int32 v100 = v17[9].i32[0];
          float v101 = v17[2].f32[1];
          if (v101 >= v37) {
            float v102 = v17[2].f32[1];
          }
          else {
            float v102 = v160 * 0.74;
          }
          float v103 = cosval * v102;
          if (v101 < v38) {
            float v101 = v158 * 0.74;
          }
          float v104 = cosval * v101;
          __float2 v105 = __sincosf_stret((float)((float)v96 * 6.2832) / v56);
          float32x4_t v106 = vmlaq_f32(vaddq_f32(v163, vmlaq_n_f32(vmlaq_f32(vmulq_n_f32(v172, v105.__cosval * v103), (float32x4_t)0, v169), v166, -(float)(v105.__sinval * v104))), v154, v175);
          float32x4_t v107 = vsubq_f32(v106, v163);
          float32x4_t v108 = vmulq_f32(v107, v107);
          LODWORD(v178) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 2), vaddq_f32(v108, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v108.f32, 1))).u32[0];
          float32x4_t v180 = v106;
          float32x2_t v109 = vrsqrte_f32((float32x2_t)LODWORD(v178));
          float32x2_t v110 = vmul_f32(v109, vrsqrts_f32((float32x2_t)LODWORD(v178), vmul_f32(v109, v109)));
          float32x4_t v111 = vmulq_n_f32(v107, vmul_f32(v110, vrsqrts_f32((float32x2_t)LODWORD(v178), vmul_f32(v110, v110))).f32[0]);
          float32x4_t v182 = v111;
          if (!v17[5].i8[4])
          {
            float32x4_t v112 = vmulq_f32(v175, v111);
            float32x2_t v113 = (float32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 2), vaddq_f32(v112, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v112.f32, 1))).u64[0];
            if (v113.f32[0] < 0.0)
            {
              float32x4_t v114 = vmlsq_lane_f32(v111, v175, v113, 0);
              int32x4_t v115 = (int32x4_t)vmulq_f32(v114, v114);
              v115.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v115, 2), vadd_f32(*(float32x2_t *)v115.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v115.i8, 1))).u32[0];
              float32x2_t v116 = vrsqrte_f32((float32x2_t)v115.u32[0]);
              float32x2_t v117 = vmul_f32(v116, vrsqrts_f32((float32x2_t)v115.u32[0], vmul_f32(v116, v116)));
              float32x4_t v182 = vmulq_n_f32(v114, vmul_f32(v117, vrsqrts_f32((float32x2_t)v115.u32[0], vmul_f32(v117, v117))).f32[0]);
            }
          }
          __float2 v118 = __sincosf_stret((float)((float)((float)v96 * 6.2832) / v56) + 1.5708);
          v119.f32[0] = v160 * v118.__cosval;
          v119.f32[1] = v158 * v118.__sinval;
          float v120 = (float)(sqrtf(vaddv_f32(vmul_f32(v119, v119))) * 1880.0) / 1920.0;
          if (v41 >= v120) {
            float v120 = v41;
          }
          v183.i64[0] = __PAIR64__(v36, COERCE_UNSIGNED_INT(fmaxf((float)(v120 * 1.2) - sqrtf(v178), 0.25)));
          v183.i32[2] = v100;
          v184.i32[0] = 1;
          uint64_t v122 = (float32x4_t *)v17[7];
          unint64_t v121 = (unint64_t)v17[8];
          if ((unint64_t)v122 < v121)
          {
            *uint64_t v122 = v180;
            v122[1] = v182;
            float32x4_t v97 = v184;
            v122[2] = v183;
            void v122[3] = v97;
            int v98 = (_OWORD *)v122[4].f32;
          }
          else
          {
            long long v123 = *v156;
            uint64_t v124 = ((char *)v122 - (char *)*v156) >> 6;
            unint64_t v125 = v124 + 1;
            if ((unint64_t)(v124 + 1) >> 58) {
              goto LABEL_110;
            }
            uint64_t v126 = v121 - (void)v123;
            if (v126 >> 5 > v125) {
              unint64_t v125 = v126 >> 5;
            }
            if ((unint64_t)v126 >= 0x7FFFFFFFFFFFFFC0) {
              unint64_t v127 = 0x3FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v127 = v125;
            }
            if (v127)
            {
              if (v127 >> 58) {
                goto LABEL_111;
              }
              uint64_t v128 = (char *)operator new(v127 << 6);
            }
            else
            {
              uint64_t v128 = 0;
            }
            uint64_t v129 = (float32x4_t *)&v128[64 * v124];
            float32x4_t *v129 = v180;
            v129[1] = v182;
            float32x4_t v130 = v184;
            v129[2] = v183;
            void v129[3] = v130;
            float32x2_t v131 = v129;
            if (v122 != v123)
            {
              do
              {
                float32x4_t v132 = v122[-4];
                float32x4_t v133 = v122[-3];
                float32x4_t v134 = v122[-1];
                v131[-2] = v122[-2];
                v131[-1] = v134;
                v131[-4] = v132;
                v131[-3] = v133;
                v131 -= 4;
                v122 -= 4;
              }
              while (v122 != v123);
              uint64_t v122 = *v156;
            }
            int v98 = (_OWORD *)v129[4].f32;
            v17[6] = (float32x2_t)v131;
            v17[7] = (float32x2_t)&v129[4];
            v17[8] = (float32x2_t)&v128[64 * v127];
            if (v122) {
              operator delete(v122);
            }
            uint64_t v18 = v150;
          }
          ++v36;
          v17[7] = (float32x2_t)v98;
          int v99 = (((unint64_t)v98 - *(void *)&v17[6]) >> 6) - 1;
          *((_DWORD *)sub_24B6EF354(v18, v183.u32[1], &v183.i32[1]) + 5) = v99;
          ++v96;
        }
        while (v96 != v55);
      }
      int v35 = v146 + 1;
      unsigned int v33 = v139;
    }
    while (v146 + 1 != v139);
    uint64_t result = 0;
    v135[2] = v17;
    *(void *)(a1 + 64) = v135;
  }
  else
  {
    void v15[2] = 0;
    CFRelease(v15);
    return 4294967293;
  }
  return result;
}

uint64_t OCFramingGuideSignalNewFrame(uint64_t a1)
{
  if (a1)
  {
    CFAllocatorRef v2 = (void *)(a1 + 64);
    uint64_t v1 = *(const void **)(a1 + 64);
    if (v1)
    {
      void *v2 = 0;
      uint64_t v3 = sub_24B6CD5A4((uint64_t)v1, v2);
      if (!v3)
      {
        id v4 = *(int8x8_t **)(*v2 + 16);
        ++v4[9].i32[0];
        uint64_t v5 = (char *)v4[7];
        uint64_t v6 = (uint64_t)&v5[-*(void *)&v4[6]];
        unint64_t v7 = v6 >> 6;
        if (v6)
        {
          unint64_t v8 = 0;
          uint64_t v9 = v4 + 10;
          do
          {
            uint64_t v5 = (char *)v4[6];
            int v10 = &v5[64 * v8 + 48];
            while (*(_DWORD *)v10 != 3 || (v4[2].i32[0] + *((_DWORD *)v10 - 2)) > v4[9].i32[0])
            {
              ++v8;
              v10 += 64;
              if (v8 >= v7) {
                goto LABEL_62;
              }
            }
            if (v8 != --v7)
            {
              int8x8_t v11 = v4[11];
              if (v11)
              {
                unint64_t v12 = *(unsigned int *)&v5[64 * v8 + 36];
                uint8x8_t v13 = (uint8x8_t)vcnt_s8(v11);
                v13.i16[0] = vaddlv_u8(v13);
                if (v13.u32[0] > 1uLL)
                {
                  unint64_t v14 = *(unsigned int *)&v5[64 * v8 + 36];
                  if (*(void *)&v11 <= v12) {
                    unint64_t v14 = v12 % *(void *)&v11;
                  }
                }
                else
                {
                  unint64_t v14 = (v11.i32[0] - 1) & v12;
                }
                int8x8_t v15 = *v9;
                float32x4_t v16 = *(int8x8_t ***)(*(void *)v9 + 8 * v14);
                if (v16)
                {
                  uint64_t v17 = *v16;
                  if (*v16)
                  {
                    uint64_t v18 = *(void *)&v11 - 1;
                    if (v13.u32[0] < 2uLL)
                    {
                      while (1)
                      {
                        int8x8_t v19 = v17[1];
                        if (*(void *)&v19 == v12)
                        {
                          if (v17[2].i32[0] == v12) {
                            goto LABEL_32;
                          }
                        }
                        else if ((*(void *)&v19 & v18) != v14)
                        {
                          goto LABEL_59;
                        }
                        uint64_t v17 = (int8x8_t *)*v17;
                        if (!v17) {
                          goto LABEL_59;
                        }
                      }
                    }
                    do
                    {
                      unint64_t v20 = (unint64_t)v17[1];
                      if (v20 == v12)
                      {
                        if (v17[2].i32[0] == v12)
                        {
LABEL_32:
                          if (v13.u32[0] > 1uLL)
                          {
                            if (*(void *)&v11 <= v12) {
                              v12 %= *(void *)&v11;
                            }
                          }
                          else
                          {
                            v12 &= v18;
                          }
                          float32x2_t v21 = *(int8x8_t **)(*(void *)&v15 + 8 * v12);
                          do
                          {
                            float32x4_t v22 = v21;
                            float32x2_t v21 = (int8x8_t *)*v21;
                          }
                          while (v21 != v17);
                          if (v22 == &v4[12]) {
                            goto LABEL_49;
                          }
                          unint64_t v23 = (unint64_t)v22[1];
                          if (v13.u32[0] > 1uLL)
                          {
                            if (v23 >= *(void *)&v11) {
                              v23 %= *(void *)&v11;
                            }
                          }
                          else
                          {
                            v23 &= v18;
                          }
                          if (v23 != v12)
                          {
LABEL_49:
                            if (!*(void *)v17) {
                              goto LABEL_50;
                            }
                            unint64_t v24 = *(void *)(*(void *)v17 + 8);
                            if (v13.u32[0] > 1uLL)
                            {
                              if (v24 >= *(void *)&v11) {
                                v24 %= *(void *)&v11;
                              }
                            }
                            else
                            {
                              v24 &= v18;
                            }
                            if (v24 != v12) {
LABEL_50:
                            }
                              *(void *)(*(void *)&v15 + 8 * v12) = 0;
                          }
                          int8x8_t v25 = *v17;
                          if (*v17)
                          {
                            unint64_t v26 = *(void *)(*(void *)&v25 + 8);
                            if (v13.u32[0] > 1uLL)
                            {
                              if (v26 >= *(void *)&v11) {
                                v26 %= *(void *)&v11;
                              }
                            }
                            else
                            {
                              v26 &= v18;
                            }
                            if (v26 != v12)
                            {
                              *(void *)(*(void *)v9 + 8 * v26) = v22;
                              int8x8_t v25 = *v17;
                            }
                          }
                          int8x8_t *v22 = v25;
                          --*(void *)&v4[13];
                          operator delete(v17);
                          uint64_t v5 = (char *)v4[6];
                          break;
                        }
                      }
                      else
                      {
                        if (v20 >= *(void *)&v11) {
                          v20 %= *(void *)&v11;
                        }
                        if (v20 != v14) {
                          break;
                        }
                      }
                      uint64_t v17 = (int8x8_t *)*v17;
                    }
                    while (v17);
                  }
                }
              }
LABEL_59:
              int8x16_t v27 = &v5[64 * v8];
              float32x2_t v28 = &v5[64 * v7];
              long long v30 = *((_OWORD *)v27 + 2);
              long long v29 = *((_OWORD *)v27 + 3);
              long long v32 = *(_OWORD *)v27;
              long long v31 = *((_OWORD *)v27 + 1);
              long long v33 = *((_OWORD *)v28 + 3);
              long long v35 = *(_OWORD *)v28;
              long long v34 = *((_OWORD *)v28 + 1);
              *((_OWORD *)v27 + 2) = *((_OWORD *)v28 + 2);
              *((_OWORD *)v27 + 3) = v33;
              *(_OWORD *)int8x16_t v27 = v35;
              *((_OWORD *)v27 + 1) = v34;
              *(_OWORD *)float32x2_t v28 = v32;
              *((_OWORD *)v28 + 1) = v31;
              *((_OWORD *)v28 + 2) = v30;
              *((_OWORD *)v28 + 3) = v29;
              *((_DWORD *)sub_24B6EF354((uint64_t)&v4[10], *(_DWORD *)(*(void *)&v4[6] + (v8 << 6) + 36), (_DWORD *)(*(void *)&v4[6] + (v8 << 6) + 36))+ 5) = v8;
            }
          }
          while (v8 < v7);
          uint64_t v5 = (char *)v4[6];
        }
LABEL_62:
        unsigned int v36 = (unsigned char *)v4[7];
        unint64_t v37 = (v36 - v5) >> 6;
        BOOL v38 = v7 >= v37;
        unint64_t v39 = v7 - v37;
        if (v7 > v37)
        {
          int8x8_t v40 = v4[8];
          if (v39 > (uint64_t)(*(void *)&v40 - (void)v36) >> 6)
          {
            if (v7 >> 58) {
              abort();
            }
            uint64_t v41 = *(void *)&v40 - (void)v5;
            uint64_t v42 = v41 >> 5;
            if (v41 >> 5 <= v7) {
              uint64_t v42 = v7;
            }
            BOOL v38 = (unint64_t)v41 >= 0x7FFFFFFFFFFFFFC0;
            unint64_t v43 = 0x3FFFFFFFFFFFFFFLL;
            if (!v38) {
              unint64_t v43 = v42;
            }
            if (v43 >> 58) {
              sub_24B6BCD7C();
            }
            unint64_t v44 = v43 << 6;
            __float2 v45 = (char *)operator new(v43 << 6);
            int v46 = &v45[64 * v37];
            float v47 = &v45[v44];
            bzero(v46, v39 << 6);
            float v48 = &v46[64 * v39];
            if (v36 != v5)
            {
              do
              {
                long long v49 = *((_OWORD *)v36 - 4);
                long long v50 = *((_OWORD *)v36 - 3);
                long long v51 = *((_OWORD *)v36 - 1);
                *((_OWORD *)v46 - 2) = *((_OWORD *)v36 - 2);
                *((_OWORD *)v46 - 1) = v51;
                *((_OWORD *)v46 - 4) = v49;
                *((_OWORD *)v46 - 3) = v50;
                v46 -= 64;
                v36 -= 64;
              }
              while (v36 != v5);
              uint64_t v5 = (char *)v4[6];
            }
            v4[6] = (int8x8_t)v46;
            v4[7] = (int8x8_t)v48;
            v4[8] = (int8x8_t)v47;
            if (v5) {
              operator delete(v5);
            }
            uint64_t v3 = 0;
            goto LABEL_81;
          }
          bzero(*(void **)&v4[7], v39 << 6);
          uint64_t v3 = 0;
          float v52 = &v36[64 * v39];
          goto LABEL_80;
        }
        uint64_t v3 = 0;
        if (!v38)
        {
          float v52 = &v5[64 * v7];
LABEL_80:
          v4[7] = (int8x8_t)v52;
        }
      }
LABEL_81:
      CFRelease(v1);
      return v3;
    }
  }
  return 4294967294;
}

uint64_t OCFramingGuideStations(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t OCFramingGuideGetIsCameraInPosition(uint64_t a1, unsigned int a2, char *a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, float32x4_t a10, float32x4_t a11)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 4294967294;
  }
  uint64_t result = 4294967294;
  if (a3)
  {
    uint64_t v14 = *(void *)(a1 + 64);
    if (v14)
    {
      uint64_t v15 = *(void *)(v14 + 16);
      unint64_t v16 = *(void *)(v15 + 88);
      if (!v16) {
        return 0xFFFFFFFFLL;
      }
      uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
      v18.i16[0] = vaddlv_u8(v18);
      if (v18.u32[0] > 1uLL)
      {
        unint64_t v19 = a2;
        if (v16 <= a2) {
          unint64_t v19 = a2 % v16;
        }
      }
      else
      {
        unint64_t v19 = (v16 - 1) & a2;
      }
      unint64_t v20 = *(uint64_t ***)(*(void *)(v15 + 80) + 8 * v19);
      if (!v20) {
        return 0xFFFFFFFFLL;
      }
      float32x2_t v21 = *v20;
      if (!v21) {
        return 0xFFFFFFFFLL;
      }
      if (v18.u32[0] < 2uLL)
      {
        unint64_t v22 = v16 - 1;
        uint64_t result = 0xFFFFFFFFLL;
        while (1)
        {
          uint64_t v23 = v21[1];
          if (v23 == a2)
          {
            if (*((_DWORD *)v21 + 4) == a2) {
              goto LABEL_27;
            }
          }
          else if ((v23 & v22) != v19)
          {
            return 0xFFFFFFFFLL;
          }
          float32x2_t v21 = (uint64_t *)*v21;
          if (!v21) {
            return result;
          }
        }
      }
      uint64_t result = 0xFFFFFFFFLL;
      do
      {
        unint64_t v24 = v21[1];
        if (v24 == a2)
        {
          if (*((_DWORD *)v21 + 4) == a2)
          {
LABEL_27:
            uint64_t v25 = *((unsigned int *)v21 + 5);
            uint64_t v26 = *(void *)(v15 + 48);
            int8x16_t v27 = (float32x2_t *)(v26 + (v25 << 6));
            if ((v27[6].i32[0] - 1) <= 1)
            {
              float32x4_t v28 = vmlaq_f32(vmulq_f32(a8, (float32x4_t)0), (float32x4_t)0, a9);
              __asm { FMOV            V4.4S, #-1.0 }
              float32x4_t v56 = vmlaq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a4, COERCE_FLOAT(*(_OWORD *)v27[2].f32)), a5, v27[2], 1), a6, *(float32x4_t *)v27[2].f32, 2), (float32x4_t)0, a7);
              float32x4_t v57 = vmlaq_f32(vmlaq_f32(v28, _Q4, a10), (float32x4_t)0, a11);
              float32x4_t v51 = a4;
              float v34 = cosf((float)(*(float *)(v15 + 36) * 3.1416) / 180.0);
              int8x16_t v35 = (int8x16_t)vmulq_f32(v57, v56);
              float v36 = vaddv_f32(vadd_f32(*(float32x2_t *)v35.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL)));
              if (v36 >= (float)-v34)
              {
                if (qword_2697D11A8 != -1) {
                  dispatch_once(&qword_2697D11A8, &unk_26FE9CCF8);
                }
                unint64_t v44 = qword_2697D11A0;
                if (!os_log_type_enabled((os_log_t)qword_2697D11A0, OS_LOG_TYPE_INFO)) {
                  goto LABEL_46;
                }
                *(_DWORD *)simd_float4x4 buf = 134349056;
                double v59 = v36;
                int v46 = "Station is not directly facing the camera: (%{public}f)";
              }
              else
              {
                float32x4_t v37 = vaddq_f32(a7, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v51, COERCE_FLOAT(*(_OWORD *)v27->f32)), a5, *v27, 1), a6, *(float32x4_t *)v27->f32, 2));
                int8x16_t v38 = (int8x16_t)vmulq_f32(v57, vsubq_f32(v37, a11));
                float32x2_t v39 = vadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL));
                float v40 = vaddv_f32(v39);
                uint64_t v41 = v26 + (v25 << 6);
                float v43 = *(float *)(v41 + 32);
                uint64_t v42 = (float *)(v41 + 32);
                if (vabds_f32(v40, v43) > *(float *)(v15 + 40))
                {
                  if (qword_2697D11A8 != -1) {
                    dispatch_once(&qword_2697D11A8, &unk_26FE9CCF8);
                  }
                  unint64_t v44 = qword_2697D11A0;
                  if (os_log_type_enabled((os_log_t)qword_2697D11A0, OS_LOG_TYPE_INFO))
                  {
                    double v45 = vabds_f32(v40, *v42);
                    *(_DWORD *)simd_float4x4 buf = 134349056;
                    double v59 = v45;
                    int v46 = "Camera not at the right distance from the station: (%{public}f)";
                    goto LABEL_45;
                  }
LABEL_46:
                  char v50 = 0;
LABEL_47:
                  uint64_t result = 0;
                  *a3 = v50;
                  return result;
                }
                float32x4_t v47 = vsubq_f32(vmlaq_n_f32(a11, v57, vadd_f32(v39, (float32x2_t)vdup_lane_s32((int32x2_t)v39, 1)).f32[0]), v37);
                int8x16_t v48 = (int8x16_t)vmulq_f32(v47, v47);
                float v49 = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v48.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v48, v48, 8uLL))));
                if (v49 <= 0.007)
                {
                  char v50 = 1;
                  goto LABEL_47;
                }
                if (qword_2697D11A8 != -1) {
                  dispatch_once(&qword_2697D11A8, &unk_26FE9CCF8);
                }
                unint64_t v44 = qword_2697D11A0;
                if (!os_log_type_enabled((os_log_t)qword_2697D11A0, OS_LOG_TYPE_INFO)) {
                  goto LABEL_46;
                }
                *(_DWORD *)simd_float4x4 buf = 134349056;
                double v59 = v49;
                int v46 = "Camera not looking directly at station: (%{public}f)";
              }
LABEL_45:
              _os_log_impl(&dword_24B6B9000, v44, OS_LOG_TYPE_INFO, v46, buf, 0xCu);
              goto LABEL_46;
            }
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          if (v24 >= v16) {
            v24 %= v16;
          }
          if (v24 != v19) {
            return 0xFFFFFFFFLL;
          }
        }
        float32x2_t v21 = (uint64_t *)*v21;
      }
      while (v21);
    }
  }
  return result;
}

uint64_t OCFramingGuideSetStationProgress(uint64_t a1, unsigned int a2, int a3)
{
  if (!a1) {
    return 4294967294;
  }
  id v4 = (void *)(a1 + 64);
  uint64_t v3 = *(const void **)(a1 + 64);
  if (!v3) {
    return 4294967294;
  }
  void *v4 = 0;
  uint64_t v7 = sub_24B6CD5A4((uint64_t)v3, v4);
  if (v7) {
    goto LABEL_32;
  }
  uint64_t v8 = *(void *)(*v4 + 16);
  unint64_t v9 = *(void *)(v8 + 88);
  if (!v9) {
    goto LABEL_31;
  }
  uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v11 = a2;
    if (v9 <= a2) {
      unint64_t v11 = a2 % v9;
    }
  }
  else
  {
    unint64_t v11 = (v9 - 1) & a2;
  }
  unint64_t v12 = *(uint64_t ***)(*(void *)(v8 + 80) + 8 * v11);
  if (!v12) {
    goto LABEL_31;
  }
  uint8x8_t v13 = *v12;
  if (!v13) {
    goto LABEL_31;
  }
  if (v10.u32[0] < 2uLL)
  {
    unint64_t v14 = v9 - 1;
    uint64_t v7 = 0xFFFFFFFFLL;
    while (1)
    {
      uint64_t v15 = v13[1];
      if (v15 == a2)
      {
        if (*((_DWORD *)v13 + 4) == a2) {
          goto LABEL_27;
        }
      }
      else if ((v15 & v14) != v11)
      {
        goto LABEL_31;
      }
      uint8x8_t v13 = (uint64_t *)*v13;
      if (!v13) {
        goto LABEL_32;
      }
    }
  }
  uint64_t v7 = 0xFFFFFFFFLL;
  while (1)
  {
    unint64_t v16 = v13[1];
    if (v16 == a2) {
      break;
    }
    if (v16 >= v9) {
      v16 %= v9;
    }
    if (v16 != v11) {
      goto LABEL_31;
    }
LABEL_21:
    uint8x8_t v13 = (uint64_t *)*v13;
    if (!v13) {
      goto LABEL_32;
    }
  }
  if (*((_DWORD *)v13 + 4) != a2) {
    goto LABEL_21;
  }
LABEL_27:
  uint64_t v17 = *((unsigned int *)v13 + 5);
  uint64_t v18 = *(void *)(v8 + 48);
  uint64_t v19 = v18 + (v17 << 6);
  unint64_t v20 = (unsigned char *)(v19 + 44);
  if (*(char *)(v19 + 44) > a3
    || (v22 = *(_DWORD *)(v19 + 48), float32x2_t v21 = (_DWORD *)(v19 + 48), (v22 - 1) > 1))
  {
LABEL_31:
    uint64_t v7 = 0xFFFFFFFFLL;
    goto LABEL_32;
  }
  unsigned char *v20 = a3;
  uint64_t v7 = 0;
  if (a3 >= 100)
  {
    *float32x2_t v21 = 3;
    *(_DWORD *)(v18 + (v17 << 6) + 40) = *(_DWORD *)(v8 + 72);
  }
LABEL_32:
  CFRelease(v3);
  return v7;
}

uint64_t OCFramingGuideStop(uint64_t a1)
{
  if (!a1) {
    return 4294967294;
  }
  CFAllocatorRef v2 = *(const void **)(a1 + 64);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  CFRelease(v2);
  uint64_t result = 0;
  *(void *)(a1 + 64) = 0;
  return result;
}

void OCFramingGuideRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t createPixelBufferFromFile()
{
  return MEMORY[0x270F18AD0]();
}

BOOL savePixelBufferToJpeg(__CVBuffer *a1, const char *a2, uint64_t a3)
{
  v33[1] = *MEMORY[0x263EF8340];
  uint64_t v32 = *MEMORY[0x263F0EFE8];
  uint64_t v5 = objc_msgSend_numberWithFloat_(NSNumber, a2, a3);
  v33[0] = v5;
  uint64_t v7 = objc_msgSend_dictionaryWithObjects_forKeys_count_(NSDictionary, v6, (uint64_t)v33, &v32, 1);

  memset(length, 0, sizeof(length));
  int v8 = MEMORY[0x24C5D73A0](a1, v7, 0, &length[1], length);
  if (*(void *)&length[1])
  {
    IOSurfaceLock(*(IOSurfaceRef *)&length[1], 0, 0);
    BaseAddress = (const UInt8 *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)&length[1]);
    CFDataRef v10 = CFDataCreateWithBytesNoCopy(0, BaseAddress, length[0], (CFAllocatorRef)*MEMORY[0x263EFFB28]);
    if (v10)
    {
      CFDictionaryRef Width = (const __CFDictionary *)CVPixelBufferGetWidth(a1);
      CVPixelBufferGetHeight(a1);
      unint64_t v12 = (H10ISP *)CVBufferCopyAttachment(a1, (CFStringRef)*MEMORY[0x263F2C558], 0);
      if (v12)
      {
        uint8x8_t v13 = v12;
        unint64_t v14 = (__CFDictionary *)H10ISP::H10ISPCreateEXIFDictFromMetadataDict(v12, Width);
        CFRelease(v13);
        if (v14) {
          goto LABEL_5;
        }
      }
      else
      {
        if (qword_2697D1058 != -1) {
          dispatch_once(&qword_2697D1058, &unk_26FE9CA80);
        }
        uint64_t v25 = qword_2697D1050;
        if (os_log_type_enabled((os_log_t)qword_2697D1050, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)simd_float4x4 buf = 0;
          _os_log_error_impl(&dword_24B6B9000, v25, OS_LOG_TYPE_ERROR, "Failed to obtain CaptureSampleBufferAttachmentKey metadata dictionary!", buf, 2u);
        }
        unint64_t v14 = (__CFDictionary *)H10ISP::H10ISPCreateEXIFDictFromMetadataDict(0, Width);
        if (v14)
        {
LABEL_5:
          uint64_t v15 = (const void *)*MEMORY[0x263F0F4C8];
          CFTypeRef v16 = CVBufferCopyAttachment(a1, (CFStringRef)*MEMORY[0x263F0F4C8], 0);
          if (v16)
          {
            uint64_t v17 = v16;
            CFDictionarySetValue(v14, v15, v16);
            CFRelease(v17);
          }
          CFDataRef EXIFJPEGData = (const __CFData *)CGImageCreateEXIFJPEGData();
          if (EXIFJPEGData)
          {
            uint64_t v19 = fopen(a2, "wb");
            if (v19)
            {
              BytePtr = CFDataGetBytePtr(EXIFJPEGData);
              CFIndex v21 = CFDataGetLength(EXIFJPEGData);
              fwrite(BytePtr, 1uLL, v21, v19);
              fclose(v19);
              IOSurfaceUnlock(*(IOSurfaceRef *)&length[1], 0, 0);
              CFRelease(*(CFTypeRef *)&length[1]);
              CFRelease(v10);
              CFRelease(v14);
              CFRelease(EXIFJPEGData);
              return 1;
            }
            if (qword_2697D1058 != -1) {
              dispatch_once(&qword_2697D1058, &unk_26FE9CA80);
            }
            float32x4_t v28 = qword_2697D1050;
            if (os_log_type_enabled((os_log_t)qword_2697D1050, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)simd_float4x4 buf = 136380675;
              long long v31 = a2;
              _os_log_error_impl(&dword_24B6B9000, v28, OS_LOG_TYPE_ERROR, "Failed to open output JPEG file: %{private}s", buf, 0xCu);
            }
            IOSurfaceUnlock(*(IOSurfaceRef *)&length[1], 0, 0);
            CFRelease(*(CFTypeRef *)&length[1]);
            CFRelease(v10);
            CFRelease(v14);
            CFRelease(EXIFJPEGData);
          }
          else
          {
            if (qword_2697D1058 != -1) {
              dispatch_once(&qword_2697D1058, &unk_26FE9CA80);
            }
            int8x16_t v27 = qword_2697D1050;
            if (os_log_type_enabled((os_log_t)qword_2697D1050, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)simd_float4x4 buf = 0;
              _os_log_error_impl(&dword_24B6B9000, v27, OS_LOG_TYPE_ERROR, "Failed to create EXIF/JPEG formatted data!", buf, 2u);
            }
            IOSurfaceUnlock(*(IOSurfaceRef *)&length[1], 0, 0);
            CFRelease(*(CFTypeRef *)&length[1]);
            CFRelease(v10);
            CFRelease(v14);
          }
          return 0;
        }
      }
      if (qword_2697D1058 != -1) {
        dispatch_once(&qword_2697D1058, &unk_26FE9CA80);
      }
      uint64_t v26 = qword_2697D1050;
      if (os_log_type_enabled((os_log_t)qword_2697D1050, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)simd_float4x4 buf = 0;
        _os_log_error_impl(&dword_24B6B9000, v26, OS_LOG_TYPE_ERROR, "Failed to create JPEG properties dictionary!", buf, 2u);
      }
      IOSurfaceUnlock(*(IOSurfaceRef *)&length[1], 0, 0);
      CFRelease(*(CFTypeRef *)&length[1]);
      CFRelease(v10);
    }
    else
    {
      if (qword_2697D1058 != -1) {
        dispatch_once(&qword_2697D1058, &unk_26FE9CA80);
      }
      unint64_t v24 = qword_2697D1050;
      if (os_log_type_enabled((os_log_t)qword_2697D1050, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)simd_float4x4 buf = 0;
        _os_log_error_impl(&dword_24B6B9000, v24, OS_LOG_TYPE_ERROR, "Failed to create JPEG code stream", buf, 2u);
      }
      IOSurfaceUnlock(*(IOSurfaceRef *)&length[1], 0, 0);
      CFRelease(*(CFTypeRef *)&length[1]);
    }
    return 0;
  }
  if (qword_2697D1058 != -1) {
    dispatch_once(&qword_2697D1058, &unk_26FE9CA80);
  }
  uint64_t v23 = qword_2697D1050;
  BOOL result = os_log_type_enabled((os_log_t)qword_2697D1050, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)simd_float4x4 buf = 67240192;
    LODWORD(v31) = v8;
    _os_log_error_impl(&dword_24B6B9000, v23, OS_LOG_TYPE_ERROR, "Failed to encode JPEG, error: 0x%{public}08X\n", buf, 8u);
    return 0;
  }
  return result;
}

void sub_24B6D5CF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B6D5D0C()
{
  qword_2697D1050 = (uint64_t)os_log_create("com.apple.CoreOCModules", "General");
  return MEMORY[0x270F9A758]();
}

void savePixelBufferOneComponent8ToPng(__CVBuffer *a1)
{
}

void savePixelBufferFloat32ToTiff(__CVBuffer *a1)
{
}

CVPixelBufferRef copyPixelBufferForType(__CVBuffer *a1, OSType a2)
{
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  CVReturn v7 = CVPixelBufferCreate(v4, Width, Height, a2, 0, &pixelBufferOut);
  CVPixelBufferRef result = 0;
  if (!v7)
  {
    CFTypeRef cf = 0;
    if (VTPixelTransferSessionCreate(v4, (VTPixelTransferSessionRef *)&cf))
    {
      CVPixelBufferRelease(pixelBufferOut);
      return 0;
    }
    else if (VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)cf, a1, pixelBufferOut))
    {
      CVPixelBufferRelease(pixelBufferOut);
      CFRelease(cf);
      return 0;
    }
    else
    {
      VTPixelTransferSessionInvalidate((VTPixelTransferSessionRef)cf);
      CFRelease(cf);
      return pixelBufferOut;
    }
  }
  return result;
}

uint64_t OCMeshingCreate(uint64_t a1, void *a2)
{
  uint64_t v3 = operator new(8uLL, MEMORY[0x263F8C180]);
  if (!v3) {
    return 4294967293;
  }
  CFAllocatorRef v4 = v3;
  uint64_t v5 = operator new(0x50uLL, MEMORY[0x263F8C180]);
  if (v5)
  {
    v5[3] = 0u;
    v5[4] = 0u;
    _OWORD *v5 = 0u;
    v5[1] = 0u;
    v5[2] = 0u;
    *((void *)v5 + 3) = v5 + 2;
    *((void *)v5 + 6) = 0;
    *((void *)v5 + 7) = 0;
    *((void *)v5 + 8) = 0;
  }
  uint64_t v6 = 0;
  void *v4 = v5;
  *a2 = v4;
  return v6;
}

uint64_t OCMeshingStart()
{
  return 0;
}

uint64_t OCMeshingStop()
{
  return 0;
}

uint64_t OCMeshingDestroy(char ***a1)
{
  CFAllocatorRef v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = v2[6];
    if (v3)
    {
      v2[7] = v3;
      operator delete(v3);
    }
    sub_24B6BD138(v2[4]);
    CFAllocatorRef v4 = *v2;
    if (*v2)
    {
      uint64_t v5 = v2[1];
      uint64_t v6 = *v2;
      if (v5 != v4)
      {
        do
        {
          sub_24B6BD138(*((void **)v5 - 3));
          sub_24B6BD138(*((void **)v5 - 6));
          sub_24B6BD138(*((void **)v5 - 9));
          v5 -= 128;
        }
        while (v5 != v4);
        uint64_t v6 = *v2;
      }
      v2[1] = v4;
      operator delete(v6);
    }
    MEMORY[0x24C5D7790](v2, 0x10A0C40554643BBLL);
  }
  MEMORY[0x24C5D7790](a1, 0x20C4093837F09);
  return 0;
}

uint64_t sub_24B6D6054()
{
  qword_2697D1070 = 0;
  *(void *)algn_2697D1078 = "OCMesh";
  qword_2697D1080 = (uint64_t)sub_24B6D61B4;
  unk_2697D1088 = 0;
  qword_2697D1098 = 0;
  unk_2697D10A0 = 0;
  qword_2697D1090 = (uint64_t)sub_24B6D616C;
  qword_2697D10A8 = (uint64_t)sub_24B6D611C;
  qword_2697D10B0 = (uint64_t)sub_24B6D60CC;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_2697D1068 = result;
  return result;
}

CFStringRef sub_24B6D60CC(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<OCMesh %p [%p]>", a1, v3);
}

CFStringRef sub_24B6D611C(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<OCMesh %p [%p]>", a1, v3);
}

uint64_t sub_24B6D616C(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = *(void *)(result + 16);
    if (result) {
      uint64_t result = MEMORY[0x24C5D7790](result, 0x1080C409B94441ALL);
    }
    *(void *)(v1 + 16) = 0;
  }
  return result;
}

uint64_t sub_24B6D61B4(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t OCMeshingProcess(float32x4_t a1, float32x4_t a2, float32x4_t a3, __n128 a4, uint64_t a5, long long *a6, unint64_t a7)
{
  uint64_t v219 = *MEMORY[0x263EF8340];
  int8x16_t v7 = (int8x16_t)vmulq_f32(a1, a1);
  int8x16_t v8 = (int8x16_t)vmulq_f32(a2, a2);
  float32x4_t v9 = vmulq_f32(a3, a3);
  float v162 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]);
  float32x4_t v171 = (float (**)(void **, float32x2_t *))&unk_26FE9CC98;
  float32x4_t v172 = 0;
  float32x2_t v10 = vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)), vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v7.i8, *(int32x2_t *)v8.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v7.i8, *(int32x2_t *)v8.i8))));
  int32x4_t v173 = 0;
  uint64_t v174 = 0;
  float32x2_t v165 = v10;
  if (a7)
  {
    unint64_t v11 = a7;
    sub_24B6E76DC((char **)&v172, a7);
    float32x2_t v10 = v165;
    uint8x8_t v13 = v172;
    do
    {
      long long v14 = *a6;
      long long v15 = a6[2];
      v13[1] = a6[1];
      v13[2] = v15;
      _OWORD *v13 = v14;
      v13 += 3;
      a6 += 3;
      --v11;
    }
    while (v11);
  }
  float32x2_t v141 = vdiv_f32(v10, (float32x2_t)vdup_n_s32(0x42480000u));
  float v151 = v162 / 50.0;
  long long v190 = (void (**)(void **))&unk_26FE9CCC0;
  *(void *)long long v191 = &v171;
  v193 = (void **)&v190;
  long long v189 = v188;
  sub_24B6EF2D0((uint64_t)&v190, v188);
  v190[4]((void **)&v190);
  float32x2_t v16 = v141;
  *(_OWORD *)float32x4_t v166 = 0u;
  long long v167 = 0u;
  long long v168 = 0u;
  *(_OWORD *)float32x4_t v169 = 0u;
  int8x16_t v170 = 0;
  if (fabsf(vmuls_lane_f32(v16.f32[0], v16, 1) * (float)(v162 / 50.0)) >= 0.00001)
  {
    int v140 = vcvtps_s32_f32(vdiv_f32(v165, v141).f32[0]);
    if (v140 >= 1)
    {
      int32x2_t v17 = vcvt_s32_f32(vrndp_f32(vdiv_f32((float32x2_t)__PAIR64__(v165.u32[1], LODWORD(v162)), (float32x2_t)__PAIR64__(v141.u32[1], LODWORD(v151)))));
      int32x2_t v18 = vcgtz_s32(v17);
      if (v18.i32[1] & v18.i32[0])
      {
        int v19 = 0;
        float v20 = a4.n128_f32[2] + (float)(v162 * -0.5);
        float v21 = sqrtf((float)(vmul_f32(v141, v141).f32[0] + (float)(v141.f32[1] * v141.f32[1])) + (float)(v151 * v151))
            * 0.5;
        float32x2_t v22 = vadd_f32((float32x2_t)a4.n128_u64[0], vmul_f32(v165, (float32x2_t)0xBF000000BF000000));
        float32x2_t v144 = vmul_f32(v141, (float32x2_t)0x3F0000003F000000);
        __int32 v143 = v17.i32[1];
        __int32 v150 = v17.i32[0];
LABEL_9:
        int v23 = 0;
        int v142 = v19;
        float v148 = v22.f32[0] + (float)((float)v19 * v16.f32[0]);
        float v146 = v148 + v16.f32[0];
LABEL_11:
        unsigned int v24 = 0;
        int v145 = v23;
        v25.f32[0] = v148;
        v25.f32[1] = v22.f32[1] + (float)((float)v23 * v141.f32[1]);
        float32x2_t v26 = vadd_f32(v25, v144);
        float v147 = v25.f32[1];
LABEL_15:
        float v28 = v20 + (float)((float)v24 * v151);
        float32x2_t v184 = v26;
        float v185 = v28 + (float)(v151 * 0.5);
        unsigned int v27 = v24;
        if (fabsf((*v171)((void **)&v171, &v184)) > v21) {
          goto LABEL_14;
        }
        unsigned int v149 = v27;
        long long v190 = (void (**)(void **))__PAIR64__(LODWORD(v147), LODWORD(v148));
        *(float *)long long v191 = v28;
        *(float *)&v191[4] = v146;
        *(float *)&v191[8] = v147;
        float v192 = v28;
        v193 = (void **)__PAIR64__(LODWORD(v147), LODWORD(v146));
        float v194 = v28 + v151;
        unint64_t v195 = __PAIR64__(LODWORD(v147), LODWORD(v148));
        float v196 = v28 + v151;
        *(float *)&uint64_t v197 = v148;
        *((float *)&v197 + 1) = v147 + v141.f32[1];
        float v198 = v28;
        *(float *)&uint64_t v199 = v146;
        *((float *)&v199 + 1) = v147 + v141.f32[1];
        float v200 = v28;
        *(float *)&uint64_t v201 = v146;
        *((float *)&v201 + 1) = v147 + v141.f32[1];
        float v202 = v28 + v151;
        *(float *)&uint64_t v203 = v148;
        *((float *)&v203 + 1) = v147 + v141.f32[1];
        float v204 = v28 + v151;
        *(void *)float32x4_t v175 = __PAIR64__(LODWORD(v147), LODWORD(v148));
        *(float *)&v175[8] = v28;
        float v29 = (*v171)((void **)&v171, (float32x2_t *)v175);
        if (fabsf(v29) < 1.1755e-38) {
          float v29 = v29 + 0.000001;
        }
        double v205 = v29;
        *(void *)float32x4_t v175 = *(void *)&v191[4];
        *(float *)&v175[8] = v192;
        float v30 = (*v171)((void **)&v171, (float32x2_t *)v175);
        if (fabsf(v30) < 1.1755e-38) {
          float v30 = v30 + 0.000001;
        }
        double v206 = v30;
        *(void *)float32x4_t v175 = v193;
        *(float *)&v175[8] = v194;
        float v31 = (*v171)((void **)&v171, (float32x2_t *)v175);
        if (fabsf(v31) < 1.1755e-38) {
          float v31 = v31 + 0.000001;
        }
        double v207 = v31;
        *(void *)float32x4_t v175 = v195;
        *(float *)&v175[8] = v196;
        float v32 = (*v171)((void **)&v171, (float32x2_t *)v175);
        if (fabsf(v32) < 1.1755e-38) {
          float v32 = v32 + 0.000001;
        }
        double v208 = v32;
        *(void *)float32x4_t v175 = v197;
        *(float *)&v175[8] = v198;
        float v33 = (*v171)((void **)&v171, (float32x2_t *)v175);
        if (fabsf(v33) < 1.1755e-38) {
          float v33 = v33 + 0.000001;
        }
        double v209 = v33;
        *(void *)float32x4_t v175 = v199;
        *(float *)&v175[8] = v200;
        float v34 = (*v171)((void **)&v171, (float32x2_t *)v175);
        if (fabsf(v34) < 1.1755e-38) {
          float v34 = v34 + 0.000001;
        }
        double v210 = v34;
        *(void *)float32x4_t v175 = v201;
        *(float *)&v175[8] = v202;
        float v35 = (*v171)((void **)&v171, (float32x2_t *)v175);
        if (fabsf(v35) < 1.1755e-38) {
          float v35 = v35 + 0.000001;
        }
        double v211 = v35;
        *(void *)float32x4_t v175 = v203;
        *(float *)&v175[8] = v204;
        float v36 = (*v171)((void **)&v171, (float32x2_t *)v175);
        uint64_t v37 = 0;
        if (fabsf(v36) < 1.1755e-38) {
          float v36 = v36 + 0.000001;
        }
        double v212 = v36;
        long long v182 = 0u;
        long long v183 = 0u;
        long long v180 = 0u;
        long long v181 = 0u;
        long long v178 = 0u;
        long long v179 = 0u;
        long long v176 = 0u;
        long long v177 = 0u;
        *(_OWORD *)&v175[4] = 0u;
        v175[0] = (v205 < 0.0) | (2 * (v206 < 0.0)) | (4 * (v207 < 0.0)) | (8 * (v208 < 0.0)) | (16 * (v209 < 0.0)) | (32 * (v210 < 0.0)) | ((v211 < 0.0) << 6) | ((v36 < 0.0) << 7);
        uint64_t v154 = v175[0];
        int v38 = dword_24B72ED18[v175[0]];
        while (1)
        {
          if (((unsigned __int16)v38 & (unsigned __int16)word_24B72EC88[v37]) == 0) {
            goto LABEL_35;
          }
          uint64_t v42 = *(int *)&word_24B72EC88[v37 + 2];
          double v43 = *(&v205 + v42);
          unint64_t v44 = (float32x2_t *)&v191[12 * (int)v42 - 8];
          if (vabdd_f64(0.0, v43) >= 0.00000999999975)
          {
            uint64_t v45 = *(int *)&word_24B72EC88[v37 + 4];
            double v46 = *(&v205 + v45);
            float32x4_t v47 = (float32x2_t *)&v191[12 * (int)v45 - 8];
            if (vabdd_f64(0.0, v46) < 0.00000999999975)
            {
              float32x2_t v39 = *v47;
              float v40 = v47[1].f32[0];
              goto LABEL_34;
            }
            if (vabdd_f64(v43, v46) >= 0.00000999999975)
            {
              float v48 = (0.0 - v43) / (v46 - v43);
              float32x2_t v39 = vadd_f32(*v44, vmul_n_f32(vsub_f32(*v47, *v44), v48));
              float v40 = v44[1].f32[0] + (float)((float)(v47[1].f32[0] - v44[1].f32[0]) * v48);
              goto LABEL_34;
            }
          }
          float32x2_t v39 = *v44;
          float v40 = v44[1].f32[0];
LABEL_34:
          uint64_t v41 = &v175[v37 * 2];
          *(float32x2_t *)(v41 + 4) = v39;
          *((float *)v41 + 3) = v40;
LABEL_35:
          v37 += 6;
          if (v37 == 72)
          {
            uint64_t v49 = v154;
            if (v154 && v154 != 255)
            {
              uint64_t v50 = 0;
              int v51 = dword_24B72AB08[16 * v154];
              float v53 = (char *)v166[1];
              uint64_t i = (char *)v166[0];
              int v54 = (char *)v169[1];
              float64x2_t v161 = v170;
              CFIndex j = (char *)v169[0];
              v157 = (char *)*((void *)&v168 + 1);
              float32x4_t v163 = (char *)v167;
              float32x4_t v56 = (char *)v168;
              __p = (char *)*((void *)&v167 + 1);
              float32x4_t v57 = (char *)v169[0];
              __int16 v58 = (char *)v166[0];
              while (1)
              {
                double v59 = &v175[12 * v51 + 4];
                uint64_t v159 = v50;
                uint64_t v60 = (char *)&dword_24B72AB08[16 * v49 + v50];
                int v62 = *((_DWORD *)v60 + 1);
                int v61 = *((_DWORD *)v60 + 2);
                float v63 = v163;
                int v155 = v61;
                if (v53 >= v163)
                {
                  unint64_t v66 = 0xAAAAAAAAAAAAAAABLL * ((v53 - v58) >> 2) + 1;
                  if (v66 > 0x1555555555555555) {
                    goto LABEL_199;
                  }
                  if (0x5555555555555556 * ((v163 - v58) >> 2) > v66) {
                    unint64_t v66 = 0x5555555555555556 * ((v163 - v58) >> 2);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((v163 - v58) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                    unint64_t v67 = 0x1555555555555555;
                  }
                  else {
                    unint64_t v67 = v66;
                  }
                  int v152 = v62;
                  if (v67)
                  {
                    if (v67 > 0x1555555555555555) {
                      goto LABEL_200;
                    }
                    float32x4_t v68 = (char *)operator new(12 * v67);
                  }
                  else
                  {
                    float32x4_t v68 = 0;
                  }
                  float32x4_t v69 = &v68[4 * ((v53 - v58) >> 2)];
                  *(void *)float32x4_t v69 = *(void *)v59;
                  *((_DWORD *)v69 + 2) = *((_DWORD *)v59 + 2);
                  for (uint64_t i = v69; v53 != v58; *((_DWORD *)i + 2) = v71)
                  {
                    uint64_t v70 = *(void *)(v53 - 12);
                    v53 -= 12;
                    int v71 = *((_DWORD *)v53 + 2);
                    *(void *)(i - 12) = v70;
                    i -= 12;
                  }
                  float v63 = &v68[12 * v67];
                  float v65 = v69 + 12;
                  if (v58) {
                    operator delete(v58);
                  }
                  __int16 v58 = i;
                  int v61 = v155;
                  int v62 = v152;
                }
                else
                {
                  uint64_t v64 = *(void *)v59;
                  *((_DWORD *)v53 + 2) = *((_DWORD *)v59 + 2);
                  *(void *)float v53 = v64;
                  float v65 = v53 + 12;
                }
                float32x4_t v72 = &v175[12 * v62 + 4];
                double v164 = v72;
                if (v65 >= v63)
                {
                  unint64_t v75 = 0xAAAAAAAAAAAAAAABLL * ((v65 - v58) >> 2) + 1;
                  if (v75 > 0x1555555555555555) {
                    goto LABEL_199;
                  }
                  if (0x5555555555555556 * ((v63 - v58) >> 2) > v75) {
                    unint64_t v75 = 0x5555555555555556 * ((v63 - v58) >> 2);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((v63 - v58) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                    unint64_t v76 = 0x1555555555555555;
                  }
                  else {
                    unint64_t v76 = v75;
                  }
                  if (v76)
                  {
                    if (v76 > 0x1555555555555555) {
                      sub_24B6BCD7C();
                    }
                    float32x2_t v77 = (char *)operator new(12 * v76);
                  }
                  else
                  {
                    float32x2_t v77 = 0;
                  }
                  uint64_t i = &v77[4 * ((v65 - v58) >> 2)];
                  float v63 = &v77[12 * v76];
                  *(void *)uint64_t i = *(void *)v164;
                  *((_DWORD *)i + 2) = *((_DWORD *)v164 + 2);
                  float32x2_t v74 = i + 12;
                  if (v65 == v58) {
                    goto LABEL_79;
                  }
                  do
                  {
                    uint64_t v78 = *(void *)(v65 - 12);
                    v65 -= 12;
                    int v79 = *((_DWORD *)v65 + 2);
                    *(void *)(i - 12) = v78;
                    i -= 12;
                    *((_DWORD *)i + 2) = v79;
                  }
                  while (v65 != v58);
                  if (v58) {
LABEL_79:
                  }
                    operator delete(v58);
                  __int16 v58 = i;
                  int v61 = v155;
                }
                else
                {
                  uint64_t v73 = *(void *)v72;
                  *((_DWORD *)v65 + 2) = *((_DWORD *)v72 + 2);
                  *(void *)float v65 = v73;
                  float32x2_t v74 = v65 + 12;
                }
                float32x2_t v80 = &v175[12 * v61 + 4];
                if (v74 >= v63)
                {
                  unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((v74 - v58) >> 2) + 1;
                  if (v82 > 0x1555555555555555) {
                    goto LABEL_199;
                  }
                  if (0x5555555555555556 * ((v63 - v58) >> 2) > v82) {
                    unint64_t v82 = 0x5555555555555556 * ((v63 - v58) >> 2);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((v63 - v58) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                    unint64_t v83 = 0x1555555555555555;
                  }
                  else {
                    unint64_t v83 = v82;
                  }
                  if (v83)
                  {
                    if (v83 > 0x1555555555555555) {
                      sub_24B6BCD7C();
                    }
                    __int16 v84 = (char *)operator new(12 * v83);
                  }
                  else
                  {
                    __int16 v84 = 0;
                  }
                  uint64_t i = &v84[4 * ((v74 - v58) >> 2)];
                  float v63 = &v84[12 * v83];
                  *(void *)uint64_t i = *(void *)v80;
                  *((_DWORD *)i + 2) = *((_DWORD *)v80 + 2);
                  float v53 = i + 12;
                  if (v74 == v58) {
                    goto LABEL_96;
                  }
                  do
                  {
                    uint64_t v85 = *(void *)(v74 - 12);
                    v74 -= 12;
                    int v86 = *((_DWORD *)v74 + 2);
                    *(void *)(i - 12) = v85;
                    i -= 12;
                    *((_DWORD *)i + 2) = v86;
                  }
                  while (v74 != v58);
                  if (v58) {
LABEL_96:
                  }
                    operator delete(v58);
                  __int16 v58 = i;
                }
                else
                {
                  uint64_t v81 = *(void *)v80;
                  *((_DWORD *)v74 + 2) = *((_DWORD *)v80 + 2);
                  *(void *)float32x2_t v74 = v81;
                  float v53 = v74 + 12;
                }
                if (!v189) {
                  goto LABEL_198;
                }
                (*(void (**)(uint64_t *__return_ptr))(*v189 + 48))(&v215);
                float v87 = 1.0
                    / sqrtf((float)((float)(*(float *)&v215 * *(float *)&v215)+ (float)(*((float *)&v215 + 1) * *((float *)&v215 + 1)))+ (float)(v216 * v216));
                *(float *)&uint64_t v215 = *(float *)&v215 * v87;
                *((float *)&v215 + 1) = *((float *)&v215 + 1) * v87;
                float v216 = v216 * v87;
                uint64_t v217 = v215;
                float v218 = v216;
                if (!v189
                  || ((*(void (**)(uint64_t *__return_ptr))(*v189 + 48))(&v213),
                      float v88 = 1.0
                          / sqrtf((float)((float)(*(float *)&v213 * *(float *)&v213)+ (float)(*((float *)&v213 + 1) * *((float *)&v213 + 1)))+ (float)(v214 * v214)), *(float *)&uint64_t v213 = *(float *)&v213 * v88, *((float *)&v213 + 1) = *((float *)&v213 + 1) * v88, v214 = v214 * v88, v215 = v213, v216 = v214, !v189))
                {
LABEL_198:
                  sub_24B6EC38C();
LABEL_199:
                  abort();
                }
                (*(void (**)(uint64_t *__return_ptr))(*v189 + 48))(&v186);
                float v89 = 1.0
                    / sqrtf((float)((float)(*(float *)&v186 * *(float *)&v186)+ (float)(*((float *)&v186 + 1) * *((float *)&v186 + 1)))+ (float)(v187 * v187));
                *(float *)&uint64_t v186 = *(float *)&v186 * v89;
                *((float *)&v186 + 1) = *((float *)&v186 + 1) * v89;
                float v187 = v187 * v89;
                uint64_t v213 = v186;
                float v214 = v187;
                unint64_t v90 = (unint64_t)v161;
                float32x4_t v163 = v63;
                if (v54 >= v161)
                {
                  unint64_t v93 = 0xAAAAAAAAAAAAAAABLL * ((v54 - v57) >> 2) + 1;
                  if (v93 > 0x1555555555555555) {
                    goto LABEL_201;
                  }
                  if (0x5555555555555556 * ((v161 - v57) >> 2) > v93) {
                    unint64_t v93 = 0x5555555555555556 * ((v161 - v57) >> 2);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((v161 - v57) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                    unint64_t v94 = 0x1555555555555555;
                  }
                  else {
                    unint64_t v94 = v93;
                  }
                  if (v94)
                  {
                    if (v94 > 0x1555555555555555) {
                      goto LABEL_200;
                    }
                    float32x4_t v95 = (char *)operator new(12 * v94);
                  }
                  else
                  {
                    float32x4_t v95 = 0;
                  }
                  int v96 = &v95[4 * ((v54 - v57) >> 2)];
                  *(void *)int v96 = v217;
                  *((float *)v96 + 2) = v218;
                  for (CFIndex j = v96; v54 != v57; *((_DWORD *)j + 2) = v98)
                  {
                    uint64_t v97 = *(void *)(v54 - 12);
                    v54 -= 12;
                    int v98 = *((_DWORD *)v54 + 2);
                    *(void *)(j - 12) = v97;
                    j -= 12;
                  }
                  unint64_t v90 = (unint64_t)&v95[12 * v94];
                  double v92 = v96 + 12;
                  int8x16_t v170 = (char *)v90;
                  if (v57)
                  {
                    int v99 = &v95[12 * v94];
                    operator delete(v57);
                    unint64_t v90 = (unint64_t)v99;
                  }
                  float32x4_t v57 = j;
                }
                else
                {
                  uint64_t v91 = v217;
                  *((float *)v54 + 2) = v218;
                  *(void *)int v54 = v91;
                  double v92 = v54 + 12;
                }
                if ((unint64_t)v92 < v90)
                {
                  *(void *)double v92 = v215;
                  *((float *)v92 + 2) = v216;
                  __int32 v100 = v92 + 12;
                  if ((unint64_t)(v92 + 12) >= v90) {
                    goto LABEL_138;
                  }
                  goto LABEL_120;
                }
                unint64_t v101 = 0xAAAAAAAAAAAAAAABLL * ((v92 - v57) >> 2) + 1;
                if (v101 > 0x1555555555555555) {
                  goto LABEL_199;
                }
                if (0x5555555555555556 * ((uint64_t)(v90 - (void)v57) >> 2) > v101) {
                  unint64_t v101 = 0x5555555555555556 * ((uint64_t)(v90 - (void)v57) >> 2);
                }
                unint64_t v102 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v90 - (void)v57) >> 2) >= 0xAAAAAAAAAAAAAAALL
                     ? 0x1555555555555555
                     : v101;
                if (v102)
                {
                  if (v102 > 0x1555555555555555) {
                    goto LABEL_200;
                  }
                  float v103 = (char *)operator new(12 * v102);
                }
                else
                {
                  float v103 = 0;
                }
                CFIndex j = &v103[4 * ((v92 - v57) >> 2)];
                unint64_t v90 = (unint64_t)&v103[12 * v102];
                *(void *)CFIndex j = v215;
                *((float *)j + 2) = v216;
                __int32 v100 = j + 12;
                if (v92 == v57) {
                  break;
                }
                do
                {
                  uint64_t v104 = *(void *)(v92 - 12);
                  v92 -= 12;
                  int v105 = *((_DWORD *)v92 + 2);
                  *(void *)(j - 12) = v104;
                  j -= 12;
                  *((_DWORD *)j + 2) = v105;
                }
                while (v92 != v57);
                int8x16_t v170 = &v103[12 * v102];
                if (v57) {
                  goto LABEL_136;
                }
LABEL_137:
                float32x4_t v57 = j;
                if ((unint64_t)v100 >= v90)
                {
LABEL_138:
                  unint64_t v107 = 0xAAAAAAAAAAAAAAABLL * ((v100 - v57) >> 2) + 1;
                  if (v107 > 0x1555555555555555) {
                    goto LABEL_199;
                  }
                  if (0x5555555555555556 * ((uint64_t)(v90 - (void)v57) >> 2) > v107) {
                    unint64_t v107 = 0x5555555555555556 * ((uint64_t)(v90 - (void)v57) >> 2);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v90 - (void)v57) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                    unint64_t v108 = 0x1555555555555555;
                  }
                  else {
                    unint64_t v108 = v107;
                  }
                  if (v108)
                  {
                    if (v108 > 0x1555555555555555) {
                      goto LABEL_200;
                    }
                    float32x2_t v109 = (char *)operator new(12 * v108);
                  }
                  else
                  {
                    float32x2_t v109 = 0;
                  }
                  CFIndex j = &v109[4 * ((v100 - v57) >> 2)];
                  *(void *)CFIndex j = v213;
                  *((float *)j + 2) = v214;
                  int v54 = j + 12;
                  float64x2_t v161 = &v109[12 * v108];
                  if (v100 == v57)
                  {
                    int8x16_t v170 = &v109[12 * v108];
                  }
                  else
                  {
                    do
                    {
                      uint64_t v110 = *(void *)(v100 - 12);
                      v100 -= 12;
                      int v111 = *((_DWORD *)v100 + 2);
                      *(void *)(j - 12) = v110;
                      j -= 12;
                      *((_DWORD *)j + 2) = v111;
                    }
                    while (v100 != v57);
                    int8x16_t v170 = &v109[12 * v108];
                    if (!v57) {
                      goto LABEL_154;
                    }
                  }
                  operator delete(v57);
LABEL_154:
                  float32x4_t v57 = j;
                  goto LABEL_155;
                }
LABEL_120:
                float64x2_t v161 = (char *)v90;
                *(void *)__int32 v100 = v213;
                *((float *)v100 + 2) = v214;
                int v54 = v100 + 12;
LABEL_155:
                uint64_t v49 = v154;
                int v112 = -1431655765 * ((unint64_t)(v53 - v58) >> 2);
                v169[1] = v54;
                int v113 = v112 - 1;
                int v114 = v112 - 3;
                int v115 = v112 - 2;
                uint64_t v116 = v159;
                if (v56 < v157)
                {
                  *(_DWORD *)float32x4_t v56 = v114;
                  *((_DWORD *)v56 + 1) = v115;
                  *((_DWORD *)v56 + 2) = v113;
                  v56 += 12;
                }
                else
                {
                  float32x2_t v117 = __p;
                  unint64_t v118 = 0xAAAAAAAAAAAAAAABLL * ((v56 - __p) >> 2) + 1;
                  if (v118 > 0x1555555555555555) {
LABEL_201:
                  }
                    abort();
                  if (0x5555555555555556 * ((v157 - __p) >> 2) > v118) {
                    unint64_t v118 = 0x5555555555555556 * ((v157 - __p) >> 2);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((v157 - __p) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                    unint64_t v118 = 0x1555555555555555;
                  }
                  unint64_t v158 = v118;
                  if (v118)
                  {
                    if (v118 > 0x1555555555555555) {
LABEL_200:
                    }
                      sub_24B6BCD7C();
                    int v156 = v113;
                    float32x2_t v119 = (char *)operator new(12 * v118);
                    int v113 = v156;
                    float32x2_t v117 = __p;
                  }
                  else
                  {
                    float32x2_t v119 = 0;
                  }
                  float v120 = &v119[4 * ((v56 - __p) >> 2)];
                  *(_DWORD *)float v120 = v114;
                  *((_DWORD *)v120 + 1) = v115;
                  *((_DWORD *)v120 + 2) = v113;
                  unint64_t v121 = v120;
                  if (v56 == v117)
                  {
                    unint64_t v122 = v158;
                  }
                  else
                  {
                    unint64_t v122 = v158;
                    do
                    {
                      uint64_t v123 = *(void *)(v56 - 12);
                      v56 -= 12;
                      int v124 = *((_DWORD *)v56 + 2);
                      *(void *)(v121 - 12) = v123;
                      v121 -= 12;
                      *((_DWORD *)v121 + 2) = v124;
                    }
                    while (v56 != v117);
                  }
                  float32x4_t v56 = v120 + 12;
                  *((void *)&v167 + 1) = v121;
                  v157 = &v119[12 * v122];
                  *((void *)&v168 + 1) = v157;
                  if (v117) {
                    operator delete(v117);
                  }
                  __p = v121;
                  uint64_t v49 = v154;
                  uint64_t v116 = v159;
                }
                *(void *)&long long v168 = v56;
                uint64_t v50 = v116 + 3;
                int v51 = dword_24B72AB08[16 * v49 + v50];
                if (v51 == -1)
                {
                  v166[1] = v53;
                  *(void *)&long long v167 = v163;
                  v169[0] = j;
                  v166[0] = i;
                  goto LABEL_13;
                }
              }
              int8x16_t v170 = &v103[12 * v102];
LABEL_136:
              float32x4_t v106 = &v103[12 * v102];
              operator delete(v57);
              unint64_t v90 = (unint64_t)v106;
              goto LABEL_137;
            }
LABEL_13:
            unsigned int v27 = v149;
LABEL_14:
            unsigned int v24 = v27 + 1;
            if (v27 + 1 != v150) {
              goto LABEL_15;
            }
            int v23 = v145 + 1;
            if (v145 + 1 != v143) {
              goto LABEL_11;
            }
            int v19 = v142 + 1;
            v16.i32[0] = v141.i32[0];
            if (v142 + 1 == v140) {
              break;
            }
            goto LABEL_9;
          }
        }
      }
    }
  }
  if (v189 == v188)
  {
    (*(void (**)(void *))(v188[0] + 32))(v188);
  }
  else if (v189)
  {
    (*(void (**)(void))(*v189 + 40))();
  }
  float32x4_t v171 = (float (**)(void **, float32x2_t *))&unk_26FE9CC98;
  if (v172)
  {
    int32x4_t v173 = v172;
    operator delete(v172);
  }
  if (qword_2697D1060 != -1) {
    dispatch_once(&qword_2697D1060, &unk_26FE9CAA0);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v126 = operator new(0x20uLL, MEMORY[0x263F8C180]);
  unint64_t v127 = v126;
  if (v126)
  {
    *(_OWORD *)uint64_t v126 = 0u;
    *((_OWORD *)v126 + 1) = 0u;
  }
  unint64_t v128 = 0xAAAAAAAAAAAAAAABLL * (((char *)v166[1] - (char *)v166[0]) >> 2);
  uint64_t v129 = (void *)*((void *)&v167 + 1);
  unsigned int v130 = -1431655765 * ((uint64_t)(v168 - *((void *)&v167 + 1)) >> 2);
  *((_DWORD *)v126 + 6) = v128;
  *((_DWORD *)v126 + 7) = v130;
  float32x2_t v131 = (const std::nothrow_t *)MEMORY[0x263F8C180];
  float32x4_t v132 = operator new[](0xFFFFFFFAAAAAAAB0 * (((char *)v166[1] - (char *)v166[0]) >> 2), MEMORY[0x263F8C180]);
  *unint64_t v127 = v132;
  float32x4_t v133 = operator new[](16 * v130, v131);
  v127[1] = v133;
  if (v128)
  {
    uint64_t v135 = -1431655765 * (((char *)v166[1] - (char *)v166[0]) >> 2);
    float v136 = (char *)v166[0] + 8;
    do
    {
      *(void *)&long long v134 = *((void *)v136 - 1);
      DWORD2(v134) = *v136;
      *v132++ = v134;
      v136 += 3;
      --v135;
    }
    while (v135);
  }
  if (v130)
  {
    uint64_t v137 = -1431655765 * ((uint64_t)(v168 - *((void *)&v167 + 1)) >> 2);
    float v138 = (_DWORD *)(*((void *)&v167 + 1) + 8);
    do
    {
      *(void *)&long long v134 = *((void *)v138 - 1);
      DWORD2(v134) = *v138;
      *v133++ = v134;
      v138 += 3;
      --v137;
    }
    while (v137);
  }
  if (Instance) {
    *(void *)(Instance + 16) = v127;
  }
  if (v169[0])
  {
    operator delete(v169[0]);
    uint64_t v129 = (void *)*((void *)&v167 + 1);
  }
  if (v129) {
    operator delete(v129);
  }
  if (v166[0]) {
    operator delete(v166[0]);
  }
  return Instance;
}

void sub_24B6D76E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
}

uint64_t sub_24B6D76FC(uint64_t a1)
{
  CFAllocatorRef v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  CFAllocatorRef v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  CFAllocatorRef v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
  }
  return a1;
}

uint64_t OCMeshingGetMesh(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 4294967294;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  int v3 = *(_DWORD *)(v2 + 24);
  if (v3)
  {
    *(_DWORD *)(a2 + 24) = v3;
    uint64_t v5 = *(unsigned int *)(v2 + 24);
    *(_DWORD *)(a2 + 28) = *(_DWORD *)(v2 + 28);
    *(void *)a2 = operator new[](16 * v5, MEMORY[0x263F8C180]);
    if (v5)
    {
      for (unint64_t i = 0; i < v7; ++i)
      {
        *(_OWORD *)(*(void *)a2 + 16 * i) = *(_OWORD *)(*(void *)v2 + 16 * i);
        unint64_t v7 = *(unsigned int *)(v2 + 24);
      }
    }
    else
    {
      unint64_t v7 = 0;
    }
    *(void *)(a2 + 16) = operator new[](8 * v7, MEMORY[0x263F8C180]);
    if (v7)
    {
      uint64_t v9 = *(void *)(v2 + 16);
      if (v9)
      {
        uint64_t v10 = 0;
LABEL_12:
        *(void *)(*(void *)(a2 + 16) + 8 * v10) = *(void *)(v9 + 8 * v10);
        while (++v10 < (unint64_t)*(unsigned int *)(v2 + 24))
        {
          uint64_t v9 = *(void *)(v2 + 16);
          if (v9) {
            goto LABEL_12;
          }
        }
      }
    }
    uint64_t v11 = *(unsigned int *)(v2 + 28);
    *(void *)(a2 + 8) = operator new[](16 * v11, MEMORY[0x263F8C180]);
    if (v11)
    {
      unint64_t v12 = 0;
      do
      {
        *(_OWORD *)(*(void *)(a2 + 8) + 16 * v12) = *(_OWORD *)(*(void *)(v2 + 8) + 16 * v12);
        ++v12;
      }
      while (v12 < *(unsigned int *)(v2 + 28));
    }
  }
  return 0;
}

CFTypeRef OCMeshingRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

void OCMeshingRelease(void *cf)
{
  if (cf)
  {
    uint64_t v2 = (void *)cf[2];
    if (*v2)
    {
      MEMORY[0x24C5D7760](*v2, 0x1000C80451B5BE8);
      void *v2 = 0;
    }
    uint64_t v3 = v2[2];
    if (v3)
    {
      MEMORY[0x24C5D7760](v3, 0x1000C8000313F17);
      v2[2] = 0;
    }
    uint64_t v4 = v2[1];
    if (v4)
    {
      MEMORY[0x24C5D7760](v4, 0x1000C80451B5BE8);
      v2[1] = 0;
    }
    CFRelease(cf);
  }
}

uint64_t OCCoverageGuideCreate(int *a1, void *a2)
{
  uint64_t result = 4294967294;
  if (!a1 || !a2 || !a1[1] || !a1[2] || !a1[4] || !a1[5]) {
    return result;
  }
  uint64_t v5 = (char *)operator new(0x58uLL, MEMORY[0x263F8C180]);
  if (!v5) {
    return 4294967293;
  }
  uint64_t v6 = v5;
  *((_OWORD *)v5 + 2) = 0u;
  unint64_t v7 = v5 + 32;
  *((void *)v5 + 10) = 0;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  long long v8 = *((_OWORD *)a1 + 1);
  *(_OWORD *)uint64_t v5 = *(_OWORD *)a1;
  *((_OWORD *)v5 + 1) = v8;
  long long v25 = xmmword_24B72A610;
  uint64_t v26 = 0x186A000000000;
  int v27 = 1;
  uint64_t v28 = 0x40A000003DCCCCCDLL;
  long long v29 = xmmword_24B72A620;
  long long v30 = xmmword_24B72A630;
  long long v31 = xmmword_24B72A640;
  long long v32 = xmmword_24B72A650;
  char v33 = 0;
  uint64_t v34 = 5;
  int v35 = 1096810496;
  __int16 v36 = 256;
  int v37 = 1065353216;
  switch(*a1)
  {
    case 0:
      LODWORD(v25) = 0;
      goto LABEL_15;
    case 1:
      int v9 = 1;
      goto LABEL_14;
    case 2:
      int v9 = 2;
      goto LABEL_14;
    case 3:
      int v9 = 3;
      goto LABEL_14;
    case 4:
      int v9 = 4;
LABEL_14:
      LODWORD(v25) = v9;
LABEL_15:
      DWORD1(v25) = 1;
      LODWORD(v26) = 0;
      HIDWORD(v28) = 1084227584;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1358, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_2697D1358))
      {
        qword_2697D1350 = sub_24B727BB4();
        __cxa_atexit((void (*)(void *))sub_24B727D84, &qword_2697D1350, &dword_24B6B9000);
        __cxa_guard_release(&qword_2697D1358);
      }
      char v10 = qword_2697D1350;
      if (qword_2697D1350) {
        char v10 = *(unsigned char *)(qword_2697D1350 + 24) != 0;
      }
      HIBYTE(v36) = v10;
      float v11 = *((float *)a1 + 3);
      float v12 = 0.0;
      if (v11 >= 0.0)
      {
        float v12 = 1.0;
        if (v11 <= 1.0) {
          float v12 = *((float *)a1 + 3);
        }
      }
      int v37 = LODWORD(v12);
      uint8x8_t v13 = (int *)operator new(0x320uLL, MEMORY[0x263F8C180]);
      if (!v13)
      {
        *((void *)v6 + 5) = 0;
        goto LABEL_33;
      }
      long long v14 = v13;
      sub_24B712DDC((uint64_t)v13, &v25);
      *((void *)v6 + 5) = v14;
      if ((sub_24B712FC4(v14, *((unsigned int *)v6 + 1), *((unsigned int *)v6 + 2)) & 1) == 0)
      {
        OCCoverageGuideDestroy(v6);
        return 4294967294;
      }
      long long v15 = operator new(0x130uLL, MEMORY[0x263F8C180]);
      if (!v15)
      {
        *((void *)v6 + 6) = 0;
        goto LABEL_33;
      }
      uint64_t v16 = (uint64_t)v15;
      sub_24B727DE4((uint64_t)v15);
      *((void *)v6 + 6) = v16;
      if ((sub_24B727ED4(v16, *((unsigned int *)v6 + 4), *((unsigned int *)v6 + 5), *((unsigned int *)v6 + 6), *((unsigned int *)v6 + 7), (uint64_t)&v25) & 1) == 0)
      {
LABEL_33:
        OCCoverageGuideDestroy(v6);
        return 4294967293;
      }
      *((void *)v6 + 8) = 0;
      uint64_t v17 = *((void *)v6 + 2);
      *(void *)&long long v18 = v17;
      *((void *)&v18 + 1) = HIDWORD(v17);
      long long v22 = v18;
      int v23 = 1111970369;
      long long v24 = xmmword_24B72A660;
      if ((sub_24B6F6A90(&v22, (CVPixelBufferPoolRef *)v6 + 9) & 1) != 0
        && (uint64_t v19 = *((void *)v6 + 3),
            *(void *)&long long v20 = v19,
            *((void *)&v20 + 1) = HIDWORD(v19),
            long long v22 = v20,
            int v23 = 1717855600,
            (sub_24B6F6A90(&v22, (CVPixelBufferPoolRef *)v6 + 10) & 1) != 0))
      {
        *a2 = v6;
        int v21 = *a1;
        if ((*a1 - 1) < 2) {
          goto LABEL_38;
        }
        if ((v21 - 3) < 2)
        {
          uint64_t result = 0;
          _DWORD *v7 = 0x40000000;
          return result;
        }
        if (v21)
        {
          return 0xFFFFFFFFLL;
        }
        else
        {
LABEL_38:
          uint64_t result = 0;
          _DWORD *v7 = 1077936128;
        }
      }
      else
      {
        OCCoverageGuideDestroy(v6);
        return 0xFFFFFFFFLL;
      }
      return result;
    default:
      return 0xFFFFFFFFLL;
  }
}

void sub_24B6D7CC4(_Unwind_Exception *a1)
{
}

void sub_24B6D7CDC(_Unwind_Exception *a1)
{
  MEMORY[0x24C5D7780](v1, MEMORY[0x263F8C180]);
  _Unwind_Resume(a1);
}

void *OCCoverageGuideDestroy(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[5];
    if (v2)
    {
      uint64_t v3 = sub_24B6D7E90(v2);
      MEMORY[0x24C5D7790](v3, 0x10E0C40FDB0B8DBLL);
      v1[5] = 0;
    }
    uint64_t v4 = (id *)v1[6];
    if (v4)
    {

      MEMORY[0x24C5D7790](v4, 0x10E0C4013A4462ALL);
      v1[6] = 0;
    }
    uint64_t v5 = v1[7];
    if (v5)
    {
      if (*(void *)v5) {
        CFRelease(*(CFTypeRef *)v5);
      }
      *(void *)uint64_t v5 = 0;
      uint64_t v6 = *(void *)(v5 + 8);
      if (v6)
      {
        MEMORY[0x24C5D7760](v6, 0x1000C8052888210);
        *(void *)(v5 + 8) = 0;
      }
      MEMORY[0x24C5D7790](v5, 0x10A0C40D63CFB62);
      v1[7] = 0;
    }
    unint64_t v7 = (const void *)v1[8];
    if (v7)
    {
      CFRelease(v7);
      v1[8] = 0;
    }
    long long v8 = (__CVPixelBufferPool *)v1[9];
    if (v8)
    {
      CVPixelBufferPoolRelease(v8);
      v1[9] = 0;
    }
    JUMPOUT(0x24C5D7790);
  }
  return result;
}

uint64_t sub_24B6D7E90(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 768);
  if (v2)
  {
    *(void *)(a1 + 776) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 744);
  if (v3)
  {
    *(void *)(a1 + 752) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 704);
  if (v4)
  {
    do
    {
      uint64_t v5 = (void *)*v4;
      operator delete(v4);
      uint64_t v4 = v5;
    }
    while (v5);
  }
  uint64_t v6 = *(void **)(a1 + 688);
  *(void *)(a1 + 688) = 0;
  if (v6) {
    operator delete(v6);
  }

  unint64_t v7 = *(void **)(a1 + 152);
  if (v7)
  {
    *(void *)(a1 + 160) = v7;
    operator delete(v7);
  }
  long long v8 = *(void **)(a1 + 128);
  if (v8)
  {
    *(void *)(a1 + 136) = v8;
    operator delete(v8);
  }
  return a1;
}

uint64_t OCCoverageGuideStart(uint64_t a1)
{
  if (!a1) {
    return 4294967294;
  }
  if (*(void *)(a1 + 56)) {
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(a1 + 64)) {
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t OCCoverageGuideAddCameraShot(uint64_t a1, __n128 a2, __n128 a3, __n128 a4, simd_float4 a5, simd_float4 a6, simd_float4 a7, simd_float4 a8)
{
  if (!a1) {
    return 4294967294;
  }
  if (!*(void *)(a1 + 40)) {
    return 4294967294;
  }
  uint64_t v10 = *(void *)(a1 + 4);
  __n128 v11 = a2;
  __n128 v12 = a3;
  __n128 v13 = a4;
  simd_float4 v14 = a5;
  simd_float4 v15 = a6;
  simd_float4 v16 = a7;
  simd_float4 v17 = a8;
  v19.columns[0] = a5;
  v19.columns[1] = a6;
  v19.columns[2] = a7;
  v19.columns[3] = a8;
  simd_float4x4 v18 = __invert_f4(v19);
  sub_24B715424(*(void *)(a1 + 40), (uint64_t)&v10);
  return 0;
}

uint64_t OCCoverageGuideCompute(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 4294967294;
  if (!a1) {
    return v2;
  }
  if (!a2) {
    return v2;
  }
  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5) {
    return v2;
  }
  __p[0] = 0;
  __p[1] = 0;
  float32x2x2_t v333 = 0;
  float v6 = *(float *)(a2 + 16);
  if (v6 > 0.0)
  {
    float32x4_t v7 = *(float32x4_t *)(a2 + 32);
    float32x4_t v8 = *(float32x4_t *)(a2 + 48);
    float32x4_t v9 = *(float32x4_t *)(a2 + 64);
    uint64_t v10 = (float32x4_t *)MEMORY[0x263EF89A0];
    float32x4_t v11 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
    float32x4_t v12 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
    float32x4_t v13 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
    uint32x4_t v14 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v13, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v7, *(float32x2_t *)v7.f32, 1), v8, *(float32x2_t *)v8.f32, 1), v9, *(float32x2_t *)v9.f32, 1), v11)), (int8x16_t)vcgeq_f32(v13, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v7, v7.f32[0]), v8, v8.f32[0]),
                                           v9,
                                           v9.f32[0]),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v13, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v7, v7, 2), v8, v8, 2), v9, v9, 2), v12)));
    v14.i32[3] = v14.i32[2];
    if ((vminvq_u32(v14) & 0x80000000) != 0)
    {
      float32x4_t v15 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2);
      float32x4_t v16 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v7, (int32x4_t)v9), (int32x4_t)v15);
      float32x4_t v17 = (float32x4_t)vtrn2q_s32((int32x4_t)v7, (int32x4_t)v8);
      v17.i32[2] = HIDWORD(*(void *)(a2 + 64));
      float32x4_t v18 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v7, (int32x4_t)v9), (int32x4_t)v8);
      uint32x4_t v19 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v13, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v18, v8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1), v17), v15, v16), v11)), (int8x16_t)vcgeq_f32(v13, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v18, v7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1),
                                               v17),
                                             (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2),
                                             v16),
                                           *MEMORY[0x263EF89A0]))),
                          (int8x16_t)vcgeq_f32(v13, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v18, v9.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1), v17), (float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), v16), v12)));
      v19.i32[3] = v19.i32[2];
      if ((vminvq_u32(v19) & 0x80000000) != 0)
      {
        float32x4_t v20 = vmulq_f32(v7, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v9, (int8x16_t)v9, 0xCuLL), (int8x16_t)v9, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL), (int8x16_t)v8, 8uLL)));
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0]+ -1.0) <= 0.000011)
        {
          int8x16_t v21 = *(int8x16_t *)(a2 + 80);
          float32x2_t v22 = (float32x2_t)vdup_n_s32(0x38D1B717u);
          uint32x2_t v23 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v22, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v22, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v7, (int8x16_t)v7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                           (int8x16_t)v8,
                                                                                           (int8x16_t)v8,
                                                                                           8uLL)))));
          if ((vpmin_u32(v23, v23).u32[0] & 0x80000000) != 0)
          {
            long long v24 = *(int32x4_t **)(a2 + 96);
            unint64_t v25 = -1431655765 * ((uint64_t)(*(void *)(a2 + 104) - (void)v24) >> 4);
            if (-1431655765 * ((uint64_t)(*(void *)(a2 + 104) - (void)v24) >> 4))
            {
              if (v24)
              {
                float32x4_t v330 = 0uLL;
                __asm { FMOV            V5.4S, #-1.0 }
                float32x4_t v331 = _Q5;
                v323[0] = v6;
                float32x4_t v324 = v7;
                float32x4_t v325 = v8;
                float32x4_t v326 = v9;
                int8x16_t v327 = v21;
                unint64_t v30 = v25;
                unint64_t v328 = v25;
                uint64_t v329 = v24;
                do
                {
                  int32x4_t v31 = *v24;
                  float32x4_t v33 = v330;
                  float32x4_t v32 = v331;
                  uint32x4_t v34 = (uint32x4_t)vcgtq_f32(v330, v331);
                  v34.i32[3] = v34.i32[2];
                  if ((vmaxvq_u32(v34) & 0x80000000) != 0)
                  {
                    float32x4_t v330 = vcvtq_f32_s32(v31);
                    float32x4_t v331 = v330;
                  }
                  else
                  {
                    if (v330.f32[0] > (float)v31.i32[0]) {
                      v330.f32[0] = (float)v31.i32[0];
                    }
                    if (v331.f32[0] < (float)v31.i32[0]) {
                      v331.f32[0] = (float)v31.i32[0];
                    }
                    if (v33.f32[1] > (float)v31.i32[1]) {
                      v330.f32[1] = (float)v31.i32[1];
                    }
                    if (v32.f32[1] < (float)v31.i32[1]) {
                      v331.f32[1] = (float)v31.i32[1];
                    }
                    if (v33.f32[2] > (float)v31.i32[2]) {
                      v330.f32[2] = (float)v31.i32[2];
                    }
                    if (v32.f32[2] < (float)v31.i32[2]) {
                      v331.f32[2] = (float)v31.i32[2];
                    }
                  }
                  v24 += 3;
                  --v30;
                }
                while (v30);
                if (*(_DWORD *)(v5 + 4) != 1 || v25 < *(unsigned int *)(v5 + 16)) {
                  goto LABEL_29;
                }
                __p[1] = 0;
                block.i32[0] = 0;
                __int16 v36 = (__int32 *)operator new(4 * v25);
                unint64_t v39 = (v25 - 1) & 0x3FFFFFFFFFFFFFFFLL;
                float v40 = v36;
                if (v39 >= 0x13)
                {
                  if (v36 >= &block.i32[1] || (float v40 = v36, &v36[v25] <= (__int32 *)&block))
                  {
                    uint64_t v41 = (v39 + 1) & 0x7FFFFFFFFFFFFFF8;
                    float32x4_t v38 = 0uLL;
                    uint64_t v42 = v36;
                    uint64_t v43 = v41;
                    do
                    {
                      *(_OWORD *)uint64_t v42 = 0uLL;
                      *((_OWORD *)v42 + 1) = 0uLL;
                      v42 += 8;
                      v43 -= 8;
                    }
                    while (v43);
                    if (v39 + 1 == v41)
                    {
LABEL_42:
                      __p[0] = v36;
                      __p[1] = &v36[v25];
                      float32x2x2_t v333 = __p[1];
                      uint64_t v45 = *(void *)(v5 + 128);
                      uint64_t v46 = *(void *)(v5 + 136);
                      if (v45 == v46) {
                        goto LABEL_136;
                      }
                      if (!*(unsigned char *)(v5 + 120)
                        || *(void *)(v5 + 736) != 0xAAAAAAAAAAAAAAABLL * ((v46 - v45) >> 6)
                        || !*(void *)(v5 + 712))
                      {
LABEL_57:
                        if (!*(unsigned char *)(v5 + 121) || *(_DWORD *)v5)
                        {
                          v337[0] = 0;
                          v337[1] = 0;
                          uint64_t v338 = 0;
                          if (!*(unsigned char *)(v5 + 480)) {
                            goto LABEL_29;
                          }
                          if (!sub_24B6F2F98(v5 + 192, (uint64_t)v323, v37)) {
                            goto LABEL_131;
                          }
                          int v70 = *(_DWORD *)v5;
                          if (*(_DWORD *)v5 == 4)
                          {
                            if (*(unsigned char *)(v5 + 481) && *(_DWORD *)(v5 + 384) == 4)
                            {
                              unint64_t v129 = *(unsigned int *)(v5 + 484);
                              block.i32[0] = 0;
                              sub_24B6F3514((uint64_t)__p, v129, block.f32);
                              if (*(void *)(v5 + 128) == *(void *)(v5 + 136)) {
                                goto LABEL_138;
                              }
                              float32x4_t v132 = objc_msgSend_contents(*(void **)(v5 + 328), v130, v131);
                              size_t v135 = objc_msgSend_length(*(void **)(v5 + 328), v133, v134);
                              bzero(v132, v135);
                              float v138 = objc_msgSend_contents(*(void **)(v5 + 656), v136, v137);
                              size_t v141 = objc_msgSend_length(*(void **)(v5 + 656), v139, v140);
                              bzero(v138, v141);
                              float32x2_t v144 = objc_msgSend_contents(*(void **)(v5 + 664), v142, v143);
                              size_t v147 = objc_msgSend_length(*(void **)(v5 + 664), v145, v146);
                              bzero(v144, v147);
                              __int32 v150 = objc_msgSend_contents(*(void **)(v5 + 672), v148, v149);
                              size_t v153 = objc_msgSend_length(*(void **)(v5 + 672), v151, v152);
                              bzero(v150, v153);
                              uint64_t v154 = *(void *)(v5 + 128);
                              uint64_t v155 = *(void *)(v5 + 136);
                              if (v154 == v155)
                              {
LABEL_99:
                                sub_24B6F41DC(v5 + 192, (const char *)__p, 0);
                                goto LABEL_138;
                              }
                              while (1)
                              {
                                kdebug_trace();
                                unint64_t v158 = objc_msgSend_contents(*(void **)(v5 + 648), v156, v157);
                                size_t v161 = objc_msgSend_length(*(void **)(v5 + 648), v159, v160);
                                bzero(v158, v161);
                                int64x2_t v343 = *(int64x2_t *)(v154 + 112);
                                float32x4_t v162 = *(float32x4_t *)(v154 + 144);
                                float32x4_t v163 = *(float32x4_t *)(v154 + 160);
                                float32x4_t v164 = *(float32x4_t *)(v154 + 176);
                                float32x4_t block = *(float32x4_t *)(v154 + 128);
                                float32x4_t v347 = v162;
                                float32x4_t v348 = v163;
                                float32x4_t v349 = v164;
                                float v165 = atan2f((float)*(unsigned int *)(v154 + 4), *(float *)(v154 + 36) + *(float *)(v154 + 36));
                                if (!sub_24B6F3720(v5 + 192, (uint64_t)&block, (uint64_t)&v343, 0, 0, 0, v165 + v165))break; {
                                kdebug_trace();
                                }
                                v154 += 192;
                                if (v154 == v155) {
                                  goto LABEL_99;
                                }
                              }
                            }
LABEL_131:
                            int v84 = -2;
                            goto LABEL_132;
                          }
                          if (v70 == 3)
                          {
                            if (*(unsigned char *)(v5 + 481) && *(_DWORD *)(v5 + 384) == 3)
                            {
                              unint64_t v89 = *(unsigned int *)(v5 + 484);
                              block.i32[0] = 0;
                              sub_24B6F3514((uint64_t)__p, v89, block.f32);
                              if (*(void *)(v5 + 128) == *(void *)(v5 + 136)) {
                                goto LABEL_138;
                              }
                              double v92 = objc_msgSend_contents(*(void **)(v5 + 624), v90, v91);
                              size_t v95 = objc_msgSend_length(*(void **)(v5 + 624), v93, v94);
                              bzero(v92, v95);
                              int v98 = objc_msgSend_contents(*(void **)(v5 + 632), v96, v97);
                              size_t v101 = objc_msgSend_length(*(void **)(v5 + 632), v99, v100);
                              bzero(v98, v101);
                              uint64_t v104 = objc_msgSend_contents(*(void **)(v5 + 640), v102, v103);
                              size_t v107 = objc_msgSend_length(*(void **)(v5 + 640), v105, v106);
                              bzero(v104, v107);
                              uint64_t v110 = *(void *)(v5 + 128);
                              uint64_t v111 = *(void *)(v5 + 136);
                              if (v110 == v111) {
                                goto LABEL_138;
                              }
                              uint64_t v112 = v110 + 192;
                              do
                              {
                                int v113 = objc_msgSend_contents(*(void **)(v5 + 328), v108, v109);
                                size_t v116 = objc_msgSend_length(*(void **)(v5 + 328), v114, v115);
                                bzero(v113, v116);
                                float32x2_t v119 = objc_msgSend_contents(*(void **)(v5 + 616), v117, v118);
                                size_t v122 = objc_msgSend_length(*(void **)(v5 + 616), v120, v121);
                                bzero(v119, v122);
                                int64x2_t v343 = *(int64x2_t *)(v112 - 80);
                                float32x4_t v123 = *(float32x4_t *)(v112 - 48);
                                float32x4_t v124 = *(float32x4_t *)(v112 - 32);
                                float32x4_t v125 = *(float32x4_t *)(v112 - 16);
                                float32x4_t block = *(float32x4_t *)(v112 - 64);
                                float32x4_t v347 = v123;
                                float32x4_t v348 = v124;
                                float32x4_t v349 = v125;
                                float v126 = atan2f((float)*(unsigned int *)(v112 - 188), *(float *)(v112 - 156) + *(float *)(v112 - 156));
                                char v127 = sub_24B6F3720(v5 + 192, (uint64_t)&block, (uint64_t)&v343, 0, 0, __p, v126 + v126);
                                if (v112 == v111) {
                                  char v128 = 0;
                                }
                                else {
                                  char v128 = v127;
                                }
                                v112 += 192;
                              }
                              while ((v128 & 1) != 0);
                              if (v127) {
                                goto LABEL_138;
                              }
                            }
                            goto LABEL_131;
                          }
                          if (v70 == 2)
                          {
                            if (*(unsigned char *)(v5 + 481) && *(_DWORD *)(v5 + 384) == 2)
                            {
                              unint64_t v71 = *(unsigned int *)(v5 + 484);
                              block.i32[0] = 0;
                              sub_24B6F3514((uint64_t)__p, v71, block.f32);
                              if (*(void *)(v5 + 128) != *(void *)(v5 + 136))
                              {
                                float32x2_t v74 = objc_msgSend_contents(*(void **)(v5 + 328), v72, v73);
                                size_t v77 = objc_msgSend_length(*(void **)(v5 + 328), v75, v76);
                                bzero(v74, v77);
                                uint64_t v78 = *(void *)(v5 + 128);
                                uint64_t v79 = *(void *)(v5 + 136);
                                if (v78 != v79)
                                {
                                  while (1)
                                  {
                                    int64x2_t v343 = *(int64x2_t *)(v78 + 112);
                                    float32x4_t v80 = *(float32x4_t *)(v78 + 144);
                                    float32x4_t v81 = *(float32x4_t *)(v78 + 160);
                                    float32x4_t v82 = *(float32x4_t *)(v78 + 176);
                                    float32x4_t block = *(float32x4_t *)(v78 + 128);
                                    float32x4_t v347 = v80;
                                    float32x4_t v348 = v81;
                                    float32x4_t v349 = v82;
                                    float v83 = atan2f((float)*(unsigned int *)(v78 + 4), *(float *)(v78 + 36) + *(float *)(v78 + 36));
                                    if ((sub_24B6F3720(v5 + 192, (uint64_t)&block, (uint64_t)&v343, 0, 0, 0, v83 + v83) & 1) == 0)goto LABEL_131; {
                                    v78 += 192;
                                    }
                                    if (v78 == v79) {
                                      goto LABEL_99;
                                    }
                                  }
                                }
                                goto LABEL_99;
                              }
LABEL_138:
                              if (*(unsigned char *)(v5 + 100))
                              {
                                sub_24B713774(&block, v5, (uint64_t)v323, __p);
                                if (__p[0])
                                {
                                  __p[1] = __p[0];
                                  operator delete(__p[0]);
                                }
                                v38.i64[0] = block.i64[0];
                                *(float32x4_t *)__p = block;
                                float32x2x2_t v333 = (void *)v347.i64[0];
                              }
                              if (*(unsigned char *)(v5 + 120)) {
                                sub_24B713CF4(v5, (uint64_t)v323, __p, *(double *)v38.i64, v69);
                              }
                              int v84 = 0;
LABEL_132:
                              uint64_t v85 = (float32x4_t *)v337[0];
                              if (v337[0])
                              {
                                v337[1] = v337[0];
                                goto LABEL_134;
                              }
LABEL_135:
                              if (!v84)
                              {
LABEL_136:
                                v38.i32[0] = *(_DWORD *)(a1 + 32);
                                sub_24B6F64A0((float *)__p[0], (float *)__p[1], *(double *)v38.i64);
                                uint64_t v2 = sub_24B6D2DA0((float **)__p, (const void *)a2, (uint64_t *)(a1 + 56));
                                if (!v2)
                                {
                                  sub_24B6D3050(*(float32x4_t ***)(a1 + 56), (CFTypeRef *)(a1 + 64));
                                  uint64_t v2 = v214;
                                }
                                goto LABEL_30;
                              }
LABEL_29:
                              uint64_t v2 = 0xFFFFFFFFLL;
                              goto LABEL_30;
                            }
                            goto LABEL_131;
                          }
                          uint64_t v166 = *(void *)(v5 + 128);
                          if (*(void *)(v5 + 136) == v166) {
                            goto LABEL_138;
                          }
                          unint64_t v167 = 0;
                          v38.f32[0] = v323[0];
                          *(float *)v69.i32 = (float)v328;
                          float v168 = v323[0] * (float)v328;
                          while (1)
                          {
                            int v169 = *(_DWORD *)v5;
                            if ((*(_DWORD *)v5 - 2) >= 3)
                            {
                              uint64_t v170 = v166 + 192 * v167;
                              if (v169 == 1)
                              {
                                LODWORD(v334) = *(_DWORD *)(*(void *)(v5 + 152) + 4 * v167);
                                *(float *)v350 = v168;
                                if (!*(unsigned char *)(v5 + 481)) {
                                  goto LABEL_131;
                                }
                                if (v168 < 0.0) {
                                  goto LABEL_131;
                                }
                                if (*(_DWORD *)(v5 + 384) != 1) {
                                  goto LABEL_131;
                                }
                                unint64_t v183 = *(unsigned int *)(v5 + 484);
                                block.i32[0] = 0;
                                sub_24B6F3514((uint64_t)v337, v183, block.f32);
                                uint64_t v186 = objc_msgSend_contents(*(void **)(v5 + 328), v184, v185);
                                size_t v189 = objc_msgSend_length(*(void **)(v5 + 328), v187, v188);
                                bzero(v186, v189);
                                float v192 = objc_msgSend_contents(*(void **)(v5 + 600), v190, v191);
                                size_t v195 = objc_msgSend_length(*(void **)(v5 + 600), v193, v194);
                                bzero(v192, v195);
                                uint64_t v196 = v166 + 192 * v167;
                                int64x2_t v343 = *(int64x2_t *)(v196 + 112);
                                float32x4_t v197 = *(float32x4_t *)(v196 + 144);
                                float32x4_t v198 = *(float32x4_t *)(v196 + 160);
                                float32x4_t v199 = *(float32x4_t *)(v196 + 176);
                                float32x4_t block = *(float32x4_t *)(v196 + 128);
                                float32x4_t v347 = v197;
                                float32x4_t v348 = v198;
                                float32x4_t v349 = v199;
                                float v200 = atan2f((float)*(unsigned int *)(v196 + 4), *(float *)(v170 + 36) + *(float *)(v170 + 36));
                                if ((sub_24B6F3720(v5 + 192, (uint64_t)&block, (uint64_t)&v343, (uint64_t)&v334, (uint64_t)v350, v337, v200 + v200) & 1) == 0)goto LABEL_131; {
                              }
                                }
                              else
                              {
                                if (v169)
                                {
                                  int v84 = -3;
                                  goto LABEL_132;
                                }
                                float32x4_t v171 = (float32x4_t *)(v166 + 192 * v167);
                                float32x4_t v172 = v171[9];
                                float32x4_t v173 = v171[10];
                                float32x4_t v174 = v171[11];
                                float32x4_t block = v171[8];
                                float32x4_t v347 = v172;
                                float32x4_t v348 = v173;
                                float32x4_t v349 = v174;
                                v38.f32[0] = atan2f((float)v171->u32[1], *(float *)(v170 + 36) + *(float *)(v170 + 36));
                                if (!*(unsigned char *)(v5 + 481)) {
                                  goto LABEL_131;
                                }
                                if (*(_DWORD *)(v5 + 384)) {
                                  goto LABEL_131;
                                }
                                float v175 = v38.f32[0];
                                unint64_t v176 = *(unsigned int *)(v5 + 484);
                                v343.i32[0] = 0;
                                sub_24B6F3514((uint64_t)v337, v176, (const float *)v343.i32);
                                long long v179 = objc_msgSend_contents(*(void **)(v5 + 328), v177, v178);
                                size_t v182 = objc_msgSend_length(*(void **)(v5 + 328), v180, v181);
                                bzero(v179, v182);
                                if ((sub_24B6F3720(v5 + 192, (uint64_t)&block, 0, 0, 0, v337, v175 + v175) & 1) == 0) {
                                  goto LABEL_131;
                                }
                              }
                            }
                            uint64_t v201 = (char *)__p[0];
                            if (__p[1] != __p[0])
                            {
                              unint64_t v202 = ((char *)__p[1] - (char *)__p[0]) >> 2;
                              uint64_t v203 = (char *)v337[0];
                              if (v202 <= 1) {
                                unint64_t v202 = 1;
                              }
                              if (v202 >= 8
                                && (__p[0] < (char *)v337[0] + 4 * v202
                                  ? (_CF = v337[0] >= (char *)__p[0] + 4 * v202)
                                  : (_CF = 1),
                                    _CF))
                              {
                                unint64_t v205 = v202 & 0xFFFFFFFFFFFFFFF8;
                                double v206 = (float32x4_t *)((char *)__p[0] + 16);
                                double v207 = (float32x4_t *)((char *)v337[0] + 16);
                                unint64_t v208 = v202 & 0xFFFFFFFFFFFFFFF8;
                                do
                                {
                                  float32x4_t v38 = vaddq_f32(v207[-1], v206[-1]);
                                  int8x16_t v69 = (int8x16_t)vaddq_f32(*v207, *v206);
                                  v206[-1] = v38;
                                  *double v206 = (float32x4_t)v69;
                                  v206 += 2;
                                  v207 += 2;
                                  v208 -= 8;
                                }
                                while (v208);
                                if (v202 == v205) {
                                  goto LABEL_102;
                                }
                              }
                              else
                              {
                                unint64_t v205 = 0;
                              }
                              unint64_t v209 = v202 - v205;
                              uint64_t v210 = 4 * v205;
                              double v211 = (__int32 *)&v201[v210];
                              double v212 = (float *)&v203[v210];
                              do
                              {
                                float v213 = *v212++;
                                v69.i32[0] = *v211;
                                v38.f32[0] = v213 + *(float *)v211;
                                *v211++ = v38.i32[0];
                                --v209;
                              }
                              while (v209);
                            }
LABEL_102:
                            ++v167;
                            uint64_t v166 = *(void *)(v5 + 128);
                            if (v167 >= 0xAAAAAAAAAAAAAAABLL * ((*(void *)(v5 + 136) - v166) >> 6)) {
                              goto LABEL_138;
                            }
                          }
                        }
                        v334 = 0;
                        v335 = 0;
                        uint64_t v336 = 0;
                        if (!*(unsigned char *)(v5 + 480)) {
                          goto LABEL_29;
                        }
                        if (!sub_24B6F2F98(v5 + 192, (uint64_t)v323, v37)
                          || *(_DWORD *)v5
                          || (unint64_t v215 = *(unsigned int *)(v5 + 484),
                              block.i32[0] = 0,
                              sub_24B6F3514((uint64_t)&v334, v215, block.f32),
                              !*(unsigned char *)(v5 + 481))
                          || (float v311 = (_DWORD *)(v5 + 484),
                              *(_DWORD *)(v5 + 484) > ((unint64_t)((char *)v335 - (char *)v334) >> 2))
                          || (uint64_t v219 = *(void *)(v5 + 752),
                              uint64_t v220 = *(void *)(v5 + 744),
                              (v219 - v220) >> 6 != (uint64_t)(*(void *)(v5 + 776) - *(void *)(v5 + 768)) >> 2))
                        {
                          int v84 = -2;
                          uint64_t v85 = v334;
                          if (!v334) {
                            goto LABEL_135;
                          }
                          goto LABEL_75;
                        }
                        if (v220 != v219)
                        {
                          int8x16_t v315 = objc_msgSend_commandBuffer(*(void **)(*(void *)(v5 + 192) + 8), v216, v217);
                          double v223 = objc_msgSend_contents(*(void **)(v5 + 328), v221, v222);
                          size_t v226 = objc_msgSend_length(*(void **)(v5 + 328), v224, v225);
                          bzero(v223, v226);
                          uint64_t v228 = 128;
                          if ((unint64_t)((uint64_t)(*(void *)(v5 + 752) - *(void *)(v5 + 744)) >> 6) < 0x80) {
                            uint64_t v228 = (uint64_t)(*(void *)(v5 + 752) - *(void *)(v5 + 744)) >> 6;
                          }
                          unint64_t v313 = (uint64_t)(*(void *)(v5 + 752) - *(void *)(v5 + 744)) >> 6;
                          unint64_t v314 = v228;
                          unint64_t v312 = vcvtps_u32_f32((float)(unint64_t)v228 / 5.0);
                          if (v312)
                          {
                            uint64_t v320 = 0;
                            uint64_t v321 = 0;
                            unint64_t v229 = 5;
                            int32x4_t v230 = vdupq_n_s32(0x38D1B717u);
                            float32x4_t v322 = (float32x4_t)v230;
                            float32x2_t v231 = (float32x2_t)vdup_n_s32(0x38D1B717u);
                            v230.i64[0] = 0;
                            int32x4_t v310 = v230;
                            do
                            {
                              unint64_t v232 = v313;
                              if (v313 >= v229) {
                                unint64_t v232 = v229;
                              }
                              if (v232 >= 0x80) {
                                uint64_t v233 = 128;
                              }
                              else {
                                uint64_t v233 = v232;
                              }
                              BOOL v234 = objc_msgSend_renderCommandEncoderWithDescriptor_(v315, v227, *(void *)(v5 + 520), *(_OWORD *)&v310);
                              float v236 = v234;
                              if (v234)
                              {
                                objc_msgSend_setLabel_(v234, v235, @"CoverageVisibilityTileEncoder");
                                float32x4_t block = 0uLL;
                                float32x4_t v347 = (float32x4_t)vcvtq_f64_u64(*(uint64x2_t *)(v5 + 400));
                                float32x4_t v348 = (float32x4_t)xmmword_24B72A670;
                                objc_msgSend_setViewport_(v236, v237, (uint64_t)&block);
                                id v238 = v236;
                              }

                              unint64_t v241 = 5 * v321;
                              unint64_t v242 = 5 * v321 + 5;
                              if (v314 < v242) {
                                unint64_t v242 = v314;
                              }
                              if (v241 < v242)
                              {
                                float32x4_t v243 = *v10;
                                float32x4_t v244 = v10[1];
                                uint64_t v245 = v320;
                                float32x4_t v246 = v10[2];
                                do
                                {
                                  float32x4_t v247 = (float32x4_t *)(*(void *)(v5 + 744) + v245);
                                  float32x4_t v249 = *v247;
                                  float32x4_t v248 = v247[1];
                                  float32x4_t v250 = v247[2];
                                  uint32x4_t v251 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v322, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v249, *(float32x2_t *)v249.f32, 1), v248, *(float32x2_t *)v248.f32, 1), v250, *(float32x2_t *)v250.f32, 1), v244)), (int8x16_t)vcgeq_f32(v322,
                                                                      vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v249, v249.f32[0]), v248, v248.f32[0]), v250, v250.f32[0]), v243))), (int8x16_t)vcgeq_f32(v322, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v249, v249, 2), v248, v248, 2), v250, v250,
                                                                        2),
                                                                      v246)));
                                  v251.i32[3] = v251.i32[2];
                                  if ((vminvq_u32(v251) & 0x80000000) != 0)
                                  {
                                    float32x4_t v252 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v248, 2);
                                    float32x4_t v253 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v249, (int32x4_t)v250), (int32x4_t)v252);
                                    float32x4_t v254 = (float32x4_t)vtrn2q_s32((int32x4_t)v249, (int32x4_t)v248);
                                    v254.i32[2] = HIDWORD(v247[2].i64[0]);
                                    float32x4_t v255 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v249, (int32x4_t)v250), (int32x4_t)v248);
                                    uint32x4_t v256 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v322, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v255, v248.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v248.f32, 1), v254), v252, v253), v244)), (int8x16_t)vcgeq_f32(v322, vabdq_f32(vmlaq_f32(vmlaq_f32(
                                                                              vmulq_n_f32(v255, v249.f32[0]),
                                                                              (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v249.f32, 1), v254), (float32x4_t)vdupq_laneq_s32((int32x4_t)v249, 2), v253), v243))), (int8x16_t)vcgeq_f32(v322, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v255, v250.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v250.f32, 1), v254), (float32x4_t)vdupq_laneq_s32(
                                                                                         (int32x4_t)v250,
                                                                                         2),
                                                                          v253),
                                                                        v246)));
                                    v256.i32[3] = v256.i32[2];
                                    if ((vminvq_u32(v256) & 0x80000000) != 0)
                                    {
                                      float32x4_t v257 = vmulq_f32(v249, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v250, (int8x16_t)v250, 0xCuLL), (int8x16_t)v250, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v248, (int32x4_t)v248), (int8x16_t)v248, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v250, (int32x4_t)v250), (int8x16_t)v250, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v248, (int8x16_t)v248, 0xCuLL),
                                                                (int8x16_t)v248,
                                                                8uLL)));
                                      if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v257, 2), vaddq_f32(v257, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v257.f32, 1))).f32[0]+ -1.0) <= 0.000011)
                                      {
                                        float32x4_t v316 = v247[3];
                                        float32x4_t v317 = *v247;
                                        float32x4_t v318 = v247[1];
                                        float32x4_t v319 = v247[2];
                                        uint32x2_t v258 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v231, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v250, (int8x16_t)v250, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v316, (int8x16_t)v316, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v231, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v249, (int8x16_t)v249, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v248, (int8x16_t)v248, 8uLL)))));
                                        if ((vpmin_u32(v258, v258).u32[0] & 0x80000000) != 0)
                                        {
                                          float v259 = *(float *)(*(void *)(v5 + 768) + 4 * v241);
                                          if (v259 > 0.0 && v259 < 3.1416)
                                          {
                                            float v260 = (float)*(unint64_t *)(v5 + 400)
                                                 / (float)*(unint64_t *)(v5 + 408);
                                            if (v260 >= 0.001 && v259 >= 0.0 && fabsf(v259) > 0.000001)
                                            {
                                              float v261 = *(float *)(v5 + 392);
                                              float v262 = *(float *)(v5 + 396);
                                              if (v262 > v261
                                                && v262 >= 0.001
                                                && v261 >= 0.001
                                                && fabsf(v259 + -3.1416) > 0.000032416)
                                              {
                                                float v263 = 1.0 / tanf(v259 * 0.5);
                                                *(float *)&unsigned int v264 = v263 / v260;
                                                LODWORD(v265) = 0;
                                                *((float *)&v265 + 1) = v263;
                                                v266.i64[0] = v310.i64[0];
                                                v266.f32[2] = (float)-v262 / (float)(v262 - v261);
                                                v266.i32[3] = -1.0;
                                                v267.i64[0] = 0;
                                                v267.i64[1] = COERCE_UNSIGNED_INT(v266.f32[2] * v261);
                                                float32x4_t v268 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v317, COERCE_FLOAT(*(_OWORD *)(v5 + 416))), v318, *(float32x2_t *)(v5 + 416), 1), v319, *(float32x4_t *)(v5 + 416), 2), v316, *(float32x4_t *)(v5 + 416), 3);
                                                float32x4_t v269 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v317, COERCE_FLOAT(*(_OWORD *)(v5 + 432))), v318, *(float32x2_t *)(v5 + 432), 1), v319, *(float32x4_t *)(v5 + 432), 2), v316, *(float32x4_t *)(v5 + 432), 3);
                                                float32x4_t v270 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v317, COERCE_FLOAT(*(_OWORD *)(v5 + 448))), v318, *(float32x2_t *)(v5 + 448), 1), v319, *(float32x4_t *)(v5 + 448), 2), v316, *(float32x4_t *)(v5 + 448), 3);
                                                float32x4_t v271 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v317, COERCE_FLOAT(*(_OWORD *)(v5 + 464))), v318, *(float32x2_t *)(v5 + 464), 1), v319, *(float32x4_t *)(v5 + 464), 2), v316, *(float32x4_t *)(v5 + 464), 3);
                                                float32x4_t block = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v264, v268.f32[0]), (float32x4_t)v265, *(float32x2_t *)v268.f32, 1), v266, v268, 2), v267, v268, 3);
                                                float32x4_t v347 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v264, v269.f32[0]), (float32x4_t)v265, *(float32x2_t *)v269.f32, 1), v266, v269, 2), v267, v269, 3);
                                                float32x4_t v348 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v264, v270.f32[0]), (float32x4_t)v265, *(float32x2_t *)v270.f32, 1), v266, v270, 2), v267, v270, 3);
                                                float32x4_t v349 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v264, v271.f32[0]), (float32x4_t)v265, *(float32x2_t *)v271.f32, 1), v266, v271, 2), v267, v271, 3);
                                                id v272 = v236;
                                                objc_msgSend_pushDebugGroup_(v272, v273, @"ProjectSurfaceVoxels");
                                                objc_msgSend_setRenderPipelineState_(v272, v274, *(void *)(v5 + 512));
                                                objc_msgSend_setDepthStencilState_(v272, v275, *(void *)(v5 + 240));
                                                objc_msgSend_setVertexBuffer_offset_atIndex_(v272, v276, *(void *)(v5 + 304), 0, 0);
                                                objc_msgSend_setVertexBytes_length_atIndex_(v272, v277, (uint64_t)&block, 64, 1);
                                                objc_msgSend_drawPrimitives_vertexStart_vertexCount_(v272, v278, 3, 0, (36 * *v311));
                                                objc_msgSend_popDebugGroup(v272, v279, v280);

                                                id v281 = v272;
                                                v350[0] = v241;
                                                int v345 = objc_msgSend_length(*(void **)(v5 + 328), v282, v283);
                                                objc_msgSend_pushDebugGroup_(v281, v284, @"FetchVisibleSurfaceVoxels");
                                                objc_msgSend_setRenderPipelineState_(v281, v285, *(void *)(v5 + 504));
                                                objc_msgSend_setTileBytes_length_atIndex_(v281, v286, (uint64_t)v311, 4, 0);
                                                objc_msgSend_setTileBytes_length_atIndex_(v281, v287, (uint64_t)&unk_24B72EB70, 4, 1);
                                                objc_msgSend_setTileBytes_length_atIndex_(v281, v288, (uint64_t)v350, 4, 2);
                                                objc_msgSend_setTileBytes_length_atIndex_(v281, v289, (uint64_t)&v345, 4, 3);
                                                objc_msgSend_setTileBuffer_offset_atIndex_(v281, v290, *(void *)(v5 + 328), 0, 4);
                                                int64x2_t v343 = vdupq_n_s64(0x20uLL);
                                                uint64_t v344 = 1;
                                                objc_msgSend_dispatchThreadsPerTile_(v281, v291, (uint64_t)&v343);
                                                objc_msgSend_popDebugGroup(v281, v292, v293);

                                                float32x4_t v243 = *v10;
                                                float32x4_t v244 = v10[1];
                                                float32x4_t v246 = v10[2];
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  ++v241;
                                  v245 += 64;
                                }
                                while (v233 != v241);
                              }
                              objc_msgSend_endEncoding(v236, v239, v240);

                              v229 += 5;
                              v320 += 320;
                              ++v321;
                            }
                            while (v321 != v312);
                          }
                          v337[0] = (void *)MEMORY[0x263EF8330];
                          v337[1] = (void *)3221225472;
                          uint64_t v338 = sub_24B6F56B0;
                          int v339 = &unk_2652DF050;
                          uint64_t v340 = v5 + 192;
                          uint64_t v341 = &v334;
                          unint64_t v342 = v314;
                          objc_msgSend_addCompletedHandler_(v315, v227, (uint64_t)v337);
                          objc_msgSend_commit(v315, v294, v295);
                          objc_msgSend_waitUntilCompleted(v315, v296, v297);
                        }
                        long long v298 = (char *)__p[0];
                        if (__p[1] != __p[0])
                        {
                          unint64_t v299 = ((char *)__p[1] - (char *)__p[0]) >> 2;
                          unint64_t v300 = v334;
                          if (v299 <= 1) {
                            unint64_t v299 = 1;
                          }
                          if (v299 < 8
                            || __p[0] < &v334->f32[v299] && v334 < (float32x4_t *)((char *)__p[0] + 4 * v299))
                          {
                            unint64_t v301 = 0;
LABEL_188:
                            unint64_t v302 = v299 - v301;
                            uint64_t v303 = v301;
                            unsigned int v304 = (__int32 *)&v298[v303 * 4];
                            unint64_t v305 = &v300->f32[v303];
                            do
                            {
                              float v306 = *v305++;
                              v218.i32[0] = *v304;
                              v38.f32[0] = v306 + *(float *)v304;
                              *v304++ = v38.i32[0];
                              --v302;
                            }
                            while (v302);
                            goto LABEL_190;
                          }
                          unint64_t v301 = v299 & 0xFFFFFFFFFFFFFFF8;
                          uint64_t v307 = (float32x4_t *)((char *)__p[0] + 16);
                          uint64_t v308 = v334 + 1;
                          unint64_t v309 = v299 & 0xFFFFFFFFFFFFFFF8;
                          do
                          {
                            float32x4_t v38 = vaddq_f32(v308[-1], v307[-1]);
                            int8x16_t v218 = (int8x16_t)vaddq_f32(*v308, *v307);
                            v307[-1] = v38;
                            *uint64_t v307 = (float32x4_t)v218;
                            v307 += 2;
                            v308 += 2;
                            v309 -= 8;
                          }
                          while (v309);
                          if (v299 != v301) {
                            goto LABEL_188;
                          }
                        }
LABEL_190:
                        if (*(unsigned char *)(v5 + 100))
                        {
                          sub_24B713774(&block, v5, (uint64_t)v323, __p);
                          if (__p[0])
                          {
                            __p[1] = __p[0];
                            operator delete(__p[0]);
                          }
                          v38.i64[0] = block.i64[0];
                          *(float32x4_t *)__p = block;
                          float32x2x2_t v333 = (void *)v347.i64[0];
                        }
                        if (*(unsigned char *)(v5 + 120)) {
                          sub_24B713CF4(v5, (uint64_t)v323, __p, *(double *)v38.i64, v218);
                        }
                        int v84 = 0;
                        uint64_t v85 = v334;
                        if (!v334) {
                          goto LABEL_135;
                        }
LABEL_75:
                        v335 = v85;
LABEL_134:
                        operator delete(v85);
                        goto LABEL_135;
                      }
                      block.i64[0] = MEMORY[0x263EF8330];
                      block.i64[1] = 3221225472;
                      v347.i64[0] = (uint64_t)sub_24B714FBC;
                      v347.i64[1] = (uint64_t)&unk_2652DF218;
                      v348.i64[0] = v5;
                      v348.i64[1] = (uint64_t)v323;
                      v349.i64[0] = (uint64_t)__p;
                      dispatch_apply(vcvtps_u32_f32((float)v25 / 500.0), 0, &block);
                      float v48 = (float *)__p[0];
                      uint64_t v49 = (float *)__p[1];
                      if (__p[0] == __p[1]) {
                        goto LABEL_136;
                      }
                      unint64_t v50 = (char *)__p[1] - (char *)__p[0] - 4;
                      if (v50 >= 0x1C)
                      {
                        uint64_t v53 = (v50 >> 2) + 1;
                        int v54 = (float32x4_t *)((char *)__p[0] + 16);
                        int64x2_t v55 = 0uLL;
                        v56.i64[0] = 0xBF000000BF000000;
                        v56.i64[1] = 0xBF000000BF000000;
                        int8x16_t v57 = (int8x16_t)vdupq_n_s64(1uLL);
                        uint64_t v58 = v53 & 0x7FFFFFFFFFFFFFF8;
                        int64x2_t v59 = 0uLL;
                        int64x2_t v60 = 0uLL;
                        int64x2_t v61 = 0uLL;
                        do
                        {
                          int32x4_t v62 = vcgtq_f32(v56, v54[-1]);
                          v63.i64[0] = v62.u32[0];
                          v63.i64[1] = v62.u32[1];
                          int64x2_t v64 = (int64x2_t)vandq_s8(v63, v57);
                          v63.i64[0] = v62.u32[2];
                          v63.i64[1] = v62.u32[3];
                          int64x2_t v65 = (int64x2_t)vandq_s8(v63, v57);
                          int32x4_t v66 = vcgtq_f32(v56, *v54);
                          v63.i64[0] = v66.u32[0];
                          v63.i64[1] = v66.u32[1];
                          int64x2_t v67 = (int64x2_t)vandq_s8(v63, v57);
                          v63.i64[0] = v66.u32[2];
                          v63.i64[1] = v66.u32[3];
                          int64x2_t v59 = vaddq_s64(v59, v65);
                          int64x2_t v55 = vaddq_s64(v55, v64);
                          int64x2_t v61 = vaddq_s64(v61, (int64x2_t)vandq_s8(v63, v57));
                          int64x2_t v60 = vaddq_s64(v60, v67);
                          v54 += 2;
                          v58 -= 8;
                        }
                        while (v58);
                        int64x2_t v47 = vaddq_s64(v61, v59);
                        unint64_t v51 = vaddvq_s64(vaddq_s64(vaddq_s64(v60, v55), v47));
                        if (v53 == (v53 & 0x7FFFFFFFFFFFFFF8)) {
                          goto LABEL_56;
                        }
                        float v52 = (float *)((char *)__p[0] + 4 * (v53 & 0x7FFFFFFFFFFFFFF8));
                      }
                      else
                      {
                        unint64_t v51 = 0;
                        float v52 = (float *)__p[0];
                      }
                      do
                      {
                        float v68 = *v52++;
                        *(float *)v47.i32 = v68;
                        if (v68 < -0.5) {
                          ++v51;
                        }
                      }
                      while (v52 != __p[1]);
LABEL_56:
                      if (v51 <= 9)
                      {
                        uint64_t v86 = 0;
                        uint64_t v87 = v5 + 688;
                        do
                        {
                          float v88 = *v48;
                          if (*v48 < -0.5)
                          {
                            *float v48 = 0.0;
                            float v88 = 0.0;
                          }
                          *(int32x4_t *)int v337 = v329[v86];
                          *(float *)sub_24B713F8C(v87, (int32x2_t *)v337, (int32x4_t *)v337, *(double *)v337, (int8x16_t)v47)[2].i32 = v88;
                          ++v48;
                          v86 += 3;
                        }
                        while (v48 != v49);
                        goto LABEL_136;
                      }
                      goto LABEL_57;
                    }
                    float v40 = &v36[v41];
                  }
                }
                __int32 v44 = block.i32[0];
                do
                  *v40++ = v44;
                while (v40 != &v36[v25]);
                goto LABEL_42;
              }
            }
          }
        }
      }
    }
  }
LABEL_30:
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v2;
}

void sub_24B6D9618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,void *__p,uint64_t a51,uint64_t a52,void *a53,uint64_t a54)
{
  if (__p) {
    operator delete(__p);
  }
  if (a47) {
    operator delete(a47);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OCCoverageGuideGetResults(uint64_t result)
{
  if (result) {
    return *(void *)(result + 64);
  }
  return result;
}

CVPixelBufferRef OCCoverageGuideCreateHeatmap(uint64_t a1, int32x4_t *a2, unsigned int a3, const void *a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8, float a9, double a10, double a11, double a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, long long a17, long long a18, long long a19, long long a20,float a21)
{
  v54[0] = a17;
  v54[1] = a18;
  v54[2] = a19;
  v54[3] = a20;
  if (!a1) {
    return 0;
  }
  uint64_t v19 = 0;
  if (a4)
  {
    if (a2)
    {
      uint64_t v21 = *(void *)(a1 + 48);
      if (v21)
      {
        if (a9 <= 0.0) {
          return 0;
        }
        float32x4_t v22 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
        float32x4_t v23 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
        float32x4_t v24 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
        uint32x4_t v25 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a5, *(float32x2_t *)a5.f32, 1), a6, *(float32x2_t *)a6.f32, 1), a7, *(float32x2_t *)a7.f32, 1), v22)), (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a5, a5.f32[0]), a6, a6.f32[0]),
                                               a7,
                                               a7.f32[0]),
                                             *MEMORY[0x263EF89A0]))),
                            (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a5, a5, 2), a6, a6, 2), a7, a7, 2), v23)));
        v25.i32[3] = v25.i32[2];
        if ((vminvq_u32(v25) & 0x80000000) == 0) {
          return 0;
        }
        float32x4_t v26 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a6, 2);
        float32x4_t v27 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)v26);
        float32x4_t v28 = (float32x4_t)vtrn2q_s32((int32x4_t)a5, (int32x4_t)a6);
        v28.i32[2] = a7.i32[1];
        float32x4_t v29 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)a6);
        uint32x4_t v30 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v29, a6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 1), v28), v26, v27), v22)), (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v29, a5.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 1),
                                                 v28),
                                               (float32x4_t)vdupq_laneq_s32((int32x4_t)a5, 2),
                                               v27),
                                             *MEMORY[0x263EF89A0]))),
                            (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v29, a7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 1), v28), (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2), v27), v23)));
        v30.i32[3] = v30.i32[2];
        if ((vminvq_u32(v30) & 0x80000000) == 0) {
          return 0;
        }
        float32x4_t v32 = vmulq_f32(a5, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a7, (int8x16_t)a7, 0xCuLL), (int8x16_t)a7, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a6, (int32x4_t)a6), (int8x16_t)a6, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a7, (int32x4_t)a7), (int8x16_t)a7, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a6, (int8x16_t)a6, 0xCuLL), (int8x16_t)a6, 8uLL)));
        uint64_t v19 = 0;
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).f32[0]+ -1.0) <= 0.000011)
        {
          float32x2_t v33 = (float32x2_t)vdup_n_s32(0x38D1B717u);
          uint32x2_t v34 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v33, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a8, a8, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v33, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a5, (int8x16_t)a5, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                           (int8x16_t)a6,
                                                                                           (int8x16_t)a6,
                                                                                           8uLL)))));
          if ((vpmin_u32(v34, v34).u32[0] & 0x80000000) != 0)
          {
            if (a3)
            {
              float32x4_t v52 = 0uLL;
              __asm { FMOV            V6.4S, #-1.0 }
              float32x4_t v53 = _Q6;
              v45[0] = a9;
              float32x4_t v46 = a5;
              float32x4_t v47 = a6;
              float32x4_t v48 = a7;
              int8x16_t v49 = a8;
              uint64_t v40 = a3;
              uint64_t v50 = a3;
              unint64_t v51 = a2;
              do
              {
                int32x4_t v41 = *a2;
                float32x4_t v43 = v52;
                float32x4_t v42 = v53;
                uint32x4_t v44 = (uint32x4_t)vcgtq_f32(v52, v53);
                v44.i32[3] = v44.i32[2];
                if ((vmaxvq_u32(v44) & 0x80000000) != 0)
                {
                  float32x4_t v52 = vcvtq_f32_s32(v41);
                  float32x4_t v53 = v52;
                }
                else
                {
                  if (v52.f32[0] > (float)v41.i32[0]) {
                    v52.f32[0] = (float)v41.i32[0];
                  }
                  if (v53.f32[0] < (float)v41.i32[0]) {
                    v53.f32[0] = (float)v41.i32[0];
                  }
                  if (v43.f32[1] > (float)v41.i32[1]) {
                    v52.f32[1] = (float)v41.i32[1];
                  }
                  if (v42.f32[1] < (float)v41.i32[1]) {
                    v53.f32[1] = (float)v41.i32[1];
                  }
                  if (v43.f32[2] > (float)v41.i32[2]) {
                    v52.f32[2] = (float)v41.i32[2];
                  }
                  if (v42.f32[2] < (float)v41.i32[2]) {
                    v53.f32[2] = (float)v41.i32[2];
                  }
                }
                a2 += 3;
                --v40;
              }
              while (v40);
              if (sub_24B728B88(v21, (uint64_t)v45, a4, (uint64_t)v54, 1, a21)) {
                return sub_24B6D99D8(a1, 1);
              }
              return 0;
            }
          }
        }
      }
    }
  }
  return (CVPixelBufferRef)v19;
}

CVPixelBufferRef sub_24B6D99D8(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (!v2) {
    return 0;
  }
  if (!a2)
  {
    if (*(unsigned char *)(v2 + 208))
    {
      id v14 = *(id *)(v2 + 128);
      if (v14)
      {
        uint64_t v5 = v14;
        CVPixelBufferRef pixelBufferOut = 0;
        if (!CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x263EFFB08], *(CVPixelBufferPoolRef *)(a1 + 80), &pixelBufferOut))goto LABEL_6; {
LABEL_10:
        }
        CVPixelBufferRef v13 = 0;
        goto LABEL_11;
      }
    }
    return 0;
  }
  if (!*(unsigned char *)(v2 + 208)) {
    return 0;
  }
  id v4 = *(id *)(v2 + 120);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  CVPixelBufferRef pixelBufferOut = 0;
  if (CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x263EFFB08], *(CVPixelBufferPoolRef *)(a1 + 72), &pixelBufferOut))
  {
    goto LABEL_10;
  }
LABEL_6:
  CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
  BaseAddress = CVPixelBufferGetBaseAddress(pixelBufferOut);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBufferOut);
  memset(v16, 0, 24);
  v16[3] = (CVPixelBufferRef)objc_msgSend_width(v5, v8, v9);
  v16[4] = (CVPixelBufferRef)objc_msgSend_height(v5, v10, v11);
  v16[5] = (CVPixelBufferRef)1;
  objc_msgSend_getBytes_bytesPerRow_fromRegion_mipmapLevel_(v5, v12, (uint64_t)BaseAddress, BytesPerRow, v16, 0);
  CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
  CVPixelBufferRef v13 = pixelBufferOut;
LABEL_11:

  return v13;
}

void sub_24B6D9B08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CVPixelBufferRef OCCoverageGuideCreateScoreMap(uint64_t a1, int32x4_t *a2, unsigned int a3, const void *a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8, float a9, double a10, double a11, double a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, long long a17, long long a18, long long a19, long long a20,float a21)
{
  v54[0] = a17;
  v54[1] = a18;
  v54[2] = a19;
  v54[3] = a20;
  if (!a1) {
    return 0;
  }
  uint64_t v19 = 0;
  if (a4)
  {
    if (a2)
    {
      uint64_t v21 = *(void *)(a1 + 48);
      if (v21)
      {
        if (a9 <= 0.0) {
          return 0;
        }
        float32x4_t v22 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
        float32x4_t v23 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
        float32x4_t v24 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
        uint32x4_t v25 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a5, *(float32x2_t *)a5.f32, 1), a6, *(float32x2_t *)a6.f32, 1), a7, *(float32x2_t *)a7.f32, 1), v22)), (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a5, a5.f32[0]), a6, a6.f32[0]),
                                               a7,
                                               a7.f32[0]),
                                             *MEMORY[0x263EF89A0]))),
                            (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a5, a5, 2), a6, a6, 2), a7, a7, 2), v23)));
        v25.i32[3] = v25.i32[2];
        if ((vminvq_u32(v25) & 0x80000000) == 0) {
          return 0;
        }
        float32x4_t v26 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a6, 2);
        float32x4_t v27 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)v26);
        float32x4_t v28 = (float32x4_t)vtrn2q_s32((int32x4_t)a5, (int32x4_t)a6);
        v28.i32[2] = a7.i32[1];
        float32x4_t v29 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)a6);
        uint32x4_t v30 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v29, a6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 1), v28), v26, v27), v22)), (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v29, a5.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 1),
                                                 v28),
                                               (float32x4_t)vdupq_laneq_s32((int32x4_t)a5, 2),
                                               v27),
                                             *MEMORY[0x263EF89A0]))),
                            (int8x16_t)vcgeq_f32(v24, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v29, a7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 1), v28), (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2), v27), v23)));
        v30.i32[3] = v30.i32[2];
        if ((vminvq_u32(v30) & 0x80000000) == 0) {
          return 0;
        }
        float32x4_t v32 = vmulq_f32(a5, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a7, (int8x16_t)a7, 0xCuLL), (int8x16_t)a7, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a6, (int32x4_t)a6), (int8x16_t)a6, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a7, (int32x4_t)a7), (int8x16_t)a7, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a6, (int8x16_t)a6, 0xCuLL), (int8x16_t)a6, 8uLL)));
        uint64_t v19 = 0;
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).f32[0]+ -1.0) <= 0.000011)
        {
          float32x2_t v33 = (float32x2_t)vdup_n_s32(0x38D1B717u);
          uint32x2_t v34 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v33, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a8, a8, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v33, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a5, (int8x16_t)a5, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                           (int8x16_t)a6,
                                                                                           (int8x16_t)a6,
                                                                                           8uLL)))));
          if ((vpmin_u32(v34, v34).u32[0] & 0x80000000) != 0)
          {
            if (a3)
            {
              float32x4_t v52 = 0uLL;
              __asm { FMOV            V6.4S, #-1.0 }
              float32x4_t v53 = _Q6;
              v45[0] = a9;
              float32x4_t v46 = a5;
              float32x4_t v47 = a6;
              float32x4_t v48 = a7;
              int8x16_t v49 = a8;
              uint64_t v40 = a3;
              uint64_t v50 = a3;
              unint64_t v51 = a2;
              do
              {
                int32x4_t v41 = *a2;
                float32x4_t v43 = v52;
                float32x4_t v42 = v53;
                uint32x4_t v44 = (uint32x4_t)vcgtq_f32(v52, v53);
                v44.i32[3] = v44.i32[2];
                if ((vmaxvq_u32(v44) & 0x80000000) != 0)
                {
                  float32x4_t v52 = vcvtq_f32_s32(v41);
                  float32x4_t v53 = v52;
                }
                else
                {
                  if (v52.f32[0] > (float)v41.i32[0]) {
                    v52.f32[0] = (float)v41.i32[0];
                  }
                  if (v53.f32[0] < (float)v41.i32[0]) {
                    v53.f32[0] = (float)v41.i32[0];
                  }
                  if (v43.f32[1] > (float)v41.i32[1]) {
                    v52.f32[1] = (float)v41.i32[1];
                  }
                  if (v42.f32[1] < (float)v41.i32[1]) {
                    v53.f32[1] = (float)v41.i32[1];
                  }
                  if (v43.f32[2] > (float)v41.i32[2]) {
                    v52.f32[2] = (float)v41.i32[2];
                  }
                  if (v42.f32[2] < (float)v41.i32[2]) {
                    v53.f32[2] = (float)v41.i32[2];
                  }
                }
                a2 += 3;
                --v40;
              }
              while (v40);
              if (sub_24B728B88(v21, (uint64_t)v45, a4, (uint64_t)v54, 0, a21)) {
                return sub_24B6D99D8(a1, 0);
              }
              return 0;
            }
          }
        }
      }
    }
  }
  return (CVPixelBufferRef)v19;
}

uint64_t OCCoverageGuideStop(uint64_t a1)
{
  if (!a1) {
    return 4294967294;
  }
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {
    if (*(void *)v2) {
      CFRelease(*(CFTypeRef *)v2);
    }
    *(void *)uint64_t v2 = 0;
    uint64_t v3 = *(void *)(v2 + 8);
    if (v3)
    {
      MEMORY[0x24C5D7760](v3, 0x1000C8052888210);
      *(void *)(v2 + 8) = 0;
    }
    MEMORY[0x24C5D7790](v2, 0x10A0C40D63CFB62);
  }
  *(void *)(a1 + 56) = 0;
  id v4 = *(const void **)(a1 + 64);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t result = 0;
  *(void *)(a1 + 64) = 0;
  return result;
}

void *OCModulesGitHash()
{
  return &unk_2697D10D0;
}

uint64_t computePointColor(__CVBuffer *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  int Height = CVPixelBufferGetHeight(a1);
  signed int Width = CVPixelBufferGetWidth(a1);
  BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a1, 0);
  CVPixelBufferRef v13 = (char *)CVPixelBufferGetBaseAddressOfPlane(a1, 1uLL);
  size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, 0);
  size_t v15 = CVPixelBufferGetBytesPerRowOfPlane(a1, 1uLL);
  if (a4)
  {
    uint64_t v17 = 0;
    float32x4_t v18 = (double *)(a2 + 8);
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x437F0000u);
    __asm { FMOV            V4.2S, #1.0 }
    do
    {
      unsigned int v37 = llround(*(v18 - 1));
      if ((v37 & 0x80000000) != 0
        || (int)v37 >= Width
        || (double v38 = *v18, LODWORD(v16) = llround(*v18), (v16 & 0x80000000) != 0)
        || (int)v16 >= Height)
      {
        if ((a5 & 1) == 0) {
          *(_OWORD *)(a3 + 16 * v17++) = 0uLL;
        }
      }
      else
      {
        size_t v25 = BytesPerRowOfPlane * v16 + v37;
        float32x4_t v26 = &v13[(v37 & 0xFFFFFFFE) + v15 * (v16 >> 1)];
        uint64_t v16 = *v26;
        LOBYTE(v38) = BaseAddressOfPlane[v25];
        float v27 = (float)(v26[1] - 128);
        v28.f32[0] = (float)LODWORD(v38);
        float v29 = (float)(v16 - 128);
        float32_t v30 = v28.f32[0] + (float)(v29 * -0.39176);
        float v31 = v28.f32[0] + (float)(v29 * 2.0172);
        uint64_t v32 = a3 + 16 * v17;
        v28.f32[1] = v30;
        float32x2_t v33 = vmaxnm_f32(vmla_n_f32(v28, (float32x2_t)0xBF501EA43FCC4A9ALL, v27), 0);
        int8x8_t v34 = vbsl_s8((int8x8_t)vcgt_f32(v33, v19), _D4, (int8x8_t)vdiv_f32(v33, v19));
        float v35 = fmaxf(v31, 0.0);
        if (v35 <= 255.0) {
          float v36 = v35 / 255.0;
        }
        else {
          float v36 = 1.0;
        }
        ++v17;
        *(float *)(v32 + 8) = v36;
        *(int8x8_t *)uint64_t v32 = v34;
      }
      v18 += 2;
      --a4;
    }
    while (a4);
  }
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  return 0;
}

BOOL initColorBufferData(__CVBuffer *a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  *(_DWORD *)a2 = CVPixelBufferGetHeight(a1);
  *(_DWORD *)(a2 + 4) = CVPixelBufferGetWidth(a1);
  *(void *)(a2 + 8) = CVPixelBufferGetBaseAddressOfPlane(a1, 0);
  *(void *)(a2 + 16) = CVPixelBufferGetBaseAddressOfPlane(a1, 1uLL);
  *(void *)(a2 + 24) = CVPixelBufferGetBytesPerRowOfPlane(a1, 0);
  *(void *)(a2 + 32) = CVPixelBufferGetBytesPerRowOfPlane(a1, 1uLL);
  return *(void *)(a2 + 8) && *(void *)(a2 + 16) != 0;
}

float retrieveColorFromBuffer(uint64_t a1, double *a2)
{
  int v2 = llround(*a2);
  __asm { FMOV            V0.4S, #-1.0 }
  if ((v2 & 0x80000000) == 0)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 4);
    if ((int)v8 > v2)
    {
      LODWORD(v8) = llround(a2[1]);
      if ((v8 & 0x80000000) == 0 && *(_DWORD *)a1 > (int)v8)
      {
        uint64_t v9 = *(void *)(a1 + 24) * v8 + v2;
        uint64_t v10 = (unsigned __int8 *)(*(void *)(a1 + 16)
                                + (v2 & 0xFFFFFFFE)
                                + *(void *)(a1 + 32) * (v8 >> 1));
        LOBYTE(_Q0) = *(unsigned char *)(*(void *)(a1 + 8) + v9);
        v11.f32[0] = (float)_Q0;
        v11.f32[1] = v11.f32[0] + (float)((float)(*v10 - 128) * -0.39176);
        float32x2_t v12 = vmaxnm_f32(vmla_n_f32(v11, (float32x2_t)0xBF501EA43FCC4A9ALL, (float)(v10[1] - 128)), 0);
        float32x2_t v13 = (float32x2_t)vdup_n_s32(0x437F0000u);
        int8x8_t v14 = (int8x8_t)vcgt_f32(v12, v13);
        *(float32x2_t *)&_Q0 = vdiv_f32(v12, v13);
        __asm { FMOV            V1.2S, #1.0 }
        LODWORD(_Q0) = vbsl_s8(v14, _D1, *(int8x8_t *)&_Q0).u32[0];
      }
    }
  }
  return *(float *)&_Q0;
}

int8x8_t scalarToBGRA(float a1)
{
  if (a1 <= 1.0) {
    float v1 = a1;
  }
  else {
    float v1 = 1.0;
  }
  if (a1 < 0.0) {
    float v1 = 0.0;
  }
  __asm { FMOV            V4.2D, #4.0 }
  float64x2_t v7 = vabsq_f64(vmlaq_n_f64((float64x2_t)xmmword_24B72A680, _Q4, v1));
  __asm { FMOV            V2.2D, #1.5 }
  *(float32x2_t *)&v7.f64[0] = vcvt_f32_f64(vsubq_f64(_Q2, v7));
  __asm { FMOV            V4.2S, #1.0 }
  return vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v7.f64[0], *(float32x2_t *)&_Q4.f64[0]), *(int8x8_t *)&_Q4.f64[0], *(int8x8_t *)&v7.f64[0]), (int8x8_t)vcltz_f32(*(float32x2_t *)&v7.f64[0]));
}

uint64_t OCMultiviewGeometryCreate(uint64_t a1, uint64_t a2)
{
  uint64_t result = 4294967294;
  if (a1)
  {
    if (a2) {
      operator new();
    }
  }
  return result;
}

void sub_24B6DA5B4(void *a1)
{
  int v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    id v4 = a1 + 5;
    uint64_t v3 = (void **)a1[1];
  }
  else
  {
    id v4 = a1 + 5;
    unint64_t v5 = a1[4];
    float v6 = &v2[v5 / 0x12];
    unint64_t v7 = (unint64_t)*v6 + 224 * (v5 % 0x12);
    unint64_t v8 = (unint64_t)v2[(a1[5] + v5) / 0x12] + 224 * ((a1[5] + v5) % 0x12);
    if (v7 != v8)
    {
      do
      {
        CVPixelBufferRelease(*(CVPixelBufferRef *)v7);
        CVPixelBufferRelease(*(CVPixelBufferRef *)(v7 + 8));
        if (*(char *)(v7 + 215) < 0) {
          operator delete(*(void **)(v7 + 192));
        }
        v7 += 224;
        if (v7 - (void)*v6 == 4032)
        {
          unint64_t v9 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v9;
        }
      }
      while (v7 != v8);
      int v2 = (void **)a1[1];
      uint64_t v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if (v10 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v11 = a1[2];
      int v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v10 = v11 - (void)v2;
    }
    while (v10 > 0x10);
  }
  if (v10 >> 3 == 1)
  {
    uint64_t v12 = 9;
  }
  else
  {
    if (v10 >> 3 != 2) {
      return;
    }
    uint64_t v12 = 18;
  }
  a1[4] = v12;
}

void sub_24B6DA6F8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 215) < 0) {
    operator delete(*(void **)(v1 + 192));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_24B6DA714()
{
  qword_2697D10E0 = (uint64_t)os_log_create("com.apple.CoreOCModules", "General");
  return MEMORY[0x270F9A758]();
}

uint64_t OCMultiviewGeometryStart(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 4294967294;
  }
}

uint64_t OCMultiviewGeometryStop(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  else {
    return 4294967294;
  }
}

uint64_t OCMultiviewGeometryDestroy(uint64_t *a1)
{
  if (!a1) {
    return 4294967294;
  }
  uint64_t v2 = *a1;
  if (*a1)
  {
    CVPixelBufferPoolRelease(*(CVPixelBufferPoolRef *)(v2 + 24));
    *(void *)(v2 + 24) = 0;
    CVPixelBufferRelease(*(CVPixelBufferRef *)(v2 + 32));
    *(void *)(v2 + 32) = 0;
    CVPixelBufferRelease(*(CVPixelBufferRef *)(v2 + 40));
    *(void *)(v2 + 40) = 0;
    uint64_t v3 = (void **)(v2 + 48);
    sub_24B6DA5B4((void *)(v2 + 48));
    id v4 = *(void ***)(v2 + 56);
    unint64_t v5 = *(void ***)(v2 + 64);
    if (v4 != v5)
    {
      do
      {
        float v6 = *v4++;
        operator delete(v6);
      }
      while (v4 != v5);
      uint64_t v8 = *(void *)(v2 + 56);
      uint64_t v7 = *(void *)(v2 + 64);
      if (v7 != v8) {
        *(void *)(v2 + 64) = v7 + ((v8 - v7 + 7) & 0xFFFFFFFFFFFFFFF8);
      }
    }
    if (*v3) {
      operator delete(*v3);
    }
    MEMORY[0x24C5D7790](v2, 0x10A0C40F9B348C6);
  }
  MEMORY[0x24C5D7790](a1, 0x20C4093837F09);
  return 0;
}

void sub_24B6DA868(_Unwind_Exception *a1)
{
  uint64_t v3 = (void **)(v1 + 6);
  sub_24B6DA5B4(v1 + 6);
  id v4 = (void **)v1[7];
  unint64_t v5 = (void **)v1[8];
  if (v4 != v5)
  {
    do
    {
      float v6 = *v4++;
      operator delete(v6);
    }
    while (v4 != v5);
    uint64_t v8 = v1[7];
    uint64_t v7 = v1[8];
    if (v7 != v8) {
      v1[8] = v7 + ((v8 - v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*v3) {
    operator delete(*v3);
  }
  _Unwind_Resume(a1);
}

uint64_t OCMultiviewGeometryProcess(uint64_t *a1, uint64_t a2)
{
  uint64_t v234 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 4294967294;
  }
  unint64_t v5 = *(__CVBuffer **)a2;
  id v4 = *(__CVBuffer **)(a2 + 8);
  double v6 = *(double *)(a2 + 192);
  CVPixelBufferRef texture = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  long long v7 = *(_OWORD *)(a2 + 32);
  long long v218 = *(_OWORD *)(a2 + 16);
  long long v219 = v7;
  long long v8 = *(_OWORD *)(a2 + 64);
  long long v220 = *(_OWORD *)(a2 + 48);
  long long v221 = v8;
  long long v9 = *(_OWORD *)(MEMORY[0x263EF89A0] + 16);
  long long v222 = *MEMORY[0x263EF89A0];
  long long v223 = v9;
  long long v10 = *(_OWORD *)(a2 + 176);
  long long v227 = *(_OWORD *)(a2 + 160);
  long long v228 = v10;
  long long v11 = *(_OWORD *)(a2 + 144);
  long long v225 = *(_OWORD *)(a2 + 128);
  long long v226 = v11;
  long long v224 = *(_OWORD *)(MEMORY[0x263EF89A0] + 32);
  std::to_string(&__p, v6);
  unint64_t Width = CVPixelBufferGetWidth(v4);
  unint64_t Height = CVPixelBufferGetHeight(v4);
  float v215 = (float)Width / (float)CVPixelBufferGetWidth(v5);
  size_t v14 = CVPixelBufferGetHeight(v5);
  size_t v15 = (CFAllocatorRef *)MEMORY[0x263EFFB08];
  if (vabds_f32(v215, (float)Height / (float)v14) < 0.000001)
  {
    long long v16 = *(_OWORD *)(a2 + 112);
    long long v223 = *(_OWORD *)(a2 + 96);
    long long v224 = v16;
    long long v222 = *(_OWORD *)(a2 + 80);
    *(float32x2_t *)&long long v222 = vmul_n_f32(*(float32x2_t *)&v222, v215);
    *(float32x2_t *)&long long v223 = vmul_n_f32(*(float32x2_t *)&v223, v215);
    *(float32x2_t *)&long long v224 = vmul_n_f32(*(float32x2_t *)&v16, v215);
    if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], Width, Height, 0x4C303038u, 0, &pixelBufferOut))
    {
      if (qword_2697D11C8 != -1) {
        dispatch_once(&qword_2697D11C8, &unk_26FE9CD80);
      }
      uint64_t v17 = qword_2697D11C0;
      if (os_log_type_enabled((os_log_t)qword_2697D11C0, OS_LOG_TYPE_ERROR))
      {
        LOWORD(pixelTransferSessionOut.__r_.__value_.__l.__data_) = 0;
        float32x4_t v18 = "MVGDataFrame::setImageBufferAndIntrinsics: Failed to create image buffer!";
LABEL_29:
        _os_log_error_impl(&dword_24B6B9000, v17, OS_LOG_TYPE_ERROR, v18, (uint8_t *)&pixelTransferSessionOut, 2u);
        goto LABEL_30;
      }
      goto LABEL_30;
    }
    float32x4_t v20 = pixelBufferOut;
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBufferOut);
    if (PixelFormatType == 1278226488 || (OSType v22 = PixelFormatType, PixelFormatType == 1278226742))
    {
      pixelTransferSessionOut.__r_.__value_.__r.__words[0] = 0;
      if (VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)&pixelTransferSessionOut))
      {
        if (qword_2697D11C8 != -1) {
          dispatch_once(&qword_2697D11C8, &unk_26FE9CD80);
        }
        float32x4_t v23 = qword_2697D11C0;
        if (os_log_type_enabled((os_log_t)qword_2697D11C0, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf[0]) = 0;
          _os_log_error_impl(&dword_24B6B9000, v23, OS_LOG_TYPE_ERROR, "MVGDataFrame::scaleAndConvertToGrayscale: Failed to create vtConverter!", (uint8_t *)buf, 2u);
        }
      }
      else
      {
        OSStatus v25 = VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)pixelTransferSessionOut.__r_.__value_.__l.__data_, v5, v20);
        VTPixelTransferSessionInvalidate((VTPixelTransferSessionRef)pixelTransferSessionOut.__r_.__value_.__l.__data_);
        CFRelease(pixelTransferSessionOut.__r_.__value_.__l.__data_);
        if (!v25) {
          goto LABEL_30;
        }
      }
    }
    else
    {
      if (qword_2697D11C8 != -1) {
        dispatch_once(&qword_2697D11C8, &unk_26FE9CD80);
      }
      float32x4_t v24 = qword_2697D11C0;
      if (!os_log_type_enabled((os_log_t)qword_2697D11C0, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      LODWORD(pixelTransferSessionOut.__r_.__value_.__l.__data_) = 67240192;
      HIDWORD(pixelTransferSessionOut.__r_.__value_.__r.__words[0]) = v22;
      _os_log_error_impl(&dword_24B6B9000, v24, OS_LOG_TYPE_ERROR, "MVGDataFrame::scaleAndConvertToGrayscale: Pixel format %{public}x is not supported!", (uint8_t *)&pixelTransferSessionOut, 8u);
    }
    if (qword_2697D11C8 != -1) {
      dispatch_once(&qword_2697D11C8, &unk_26FE9CD80);
    }
LABEL_27:
    uint64_t v17 = qword_2697D11C0;
    if (!os_log_type_enabled((os_log_t)qword_2697D11C0, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
    LOWORD(pixelTransferSessionOut.__r_.__value_.__l.__data_) = 0;
    float32x4_t v18 = "MVGDataFrame::setImageBufferAndIntrinsics: Failed to convert image buffer!";
    goto LABEL_29;
  }
  if (qword_2697D11C8 != -1) {
    dispatch_once(&qword_2697D11C8, &unk_26FE9CD80);
  }
  uint64_t v17 = qword_2697D11C0;
  if (os_log_type_enabled((os_log_t)qword_2697D11C0, OS_LOG_TYPE_ERROR))
  {
    LOWORD(pixelTransferSessionOut.__r_.__value_.__l.__data_) = 0;
    float32x4_t v18 = "MVGDataFrame::setImageBufferAndIntrinsics: Invalid scaling parameters!";
    goto LABEL_29;
  }
LABEL_30:
  CVPixelBufferRef texture = CVPixelBufferRetain(v4);
  uint64_t v26 = *a1;
  if (*(void *)(*a1 + 88) == *(void *)(*a1 + 16) + 1)
  {
    if (qword_2697D1198 != -1) {
      dispatch_once(&qword_2697D1198, &unk_26FE9CC68);
    }
    float v27 = qword_2697D1190;
    if (os_log_type_enabled((os_log_t)qword_2697D1190, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v75 = *(void *)(v26 + 56);
      if (*(void *)(v26 + 64) == v75) {
        unint64_t v76 = 0;
      }
      else {
        unint64_t v76 = *(void *)(v75 + 8 * (*(void *)(v26 + 80) / 0x12uLL)) + 224 * (*(void *)(v26 + 80) % 0x12uLL);
      }
      if (*(char *)(v76 + 215) < 0) {
        sub_24B6EEF48(&pixelTransferSessionOut, *(void **)(v76 + 192), *(void *)(v76 + 200));
      }
      else {
        std::string pixelTransferSessionOut = *(std::string *)(v76 + 192);
      }
      p_std::string pixelTransferSessionOut = &pixelTransferSessionOut;
      if ((pixelTransferSessionOut.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_std::string pixelTransferSessionOut = (std::string *)pixelTransferSessionOut.__r_.__value_.__r.__words[0];
      }
      uint64_t v90 = *(void *)(v26 + 88);
      buf[0] = 136446466;
      *(void *)&buf[1] = p_pixelTransferSessionOut;
      __int16 v231 = 2050;
      uint64_t v232 = v90;
      _os_log_debug_impl(&dword_24B6B9000, v27, OS_LOG_TYPE_DEBUG, "MVGConsistency::addNewFrame: Erasing frame %{public}s, size = %{public}lu", (uint8_t *)buf, 0x16u);
      if (SHIBYTE(pixelTransferSessionOut.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(pixelTransferSessionOut.__r_.__value_.__l.__data_);
      }
    }
    unint64_t v28 = *(void *)(v26 + 80);
    uint64_t v29 = *(void *)(*(void *)(v26 + 56) + 8 * (v28 / 0x12));
    unint64_t v30 = v28 % 0x12;
    uint64_t v31 = v29 + 224 * (v28 % 0x12);
    CVPixelBufferRelease(*(CVPixelBufferRef *)v31);
    CVPixelBufferRelease(*(CVPixelBufferRef *)(v31 + 8));
    if (*(char *)(v31 + 215) < 0) {
      operator delete(*(void **)(v29 + 224 * v30 + 192));
    }
    int64x2_t v32 = vaddq_s64(*(int64x2_t *)(v26 + 80), (int64x2_t)xmmword_24B72A6A0);
    *(int64x2_t *)(v26 + 80) = v32;
    if (v32.i64[0] >= 0x24uLL)
    {
      operator delete(**(void ***)(v26 + 56));
      *(void *)(v26 + 56) += 8;
      *(void *)(v26 + 80) -= 18;
    }
  }
  CVPixelBufferPoolFlush(*(CVPixelBufferPoolRef *)(v26 + 24), 1uLL);
  CVPixelBufferRelease(*(CVPixelBufferRef *)(v26 + 32));
  *(void *)(v26 + 32) = 0;
  CFAllocatorRef v33 = *v15;
  CVReturn PixelBuffer = CVPixelBufferPoolCreatePixelBuffer(*v15, *(CVPixelBufferPoolRef *)(v26 + 24), (CVPixelBufferRef *)(v26 + 32));
  CVPixelBufferRelease(*(CVPixelBufferRef *)(v26 + 40));
  *(void *)(v26 + 40) = 0;
  if (PixelBuffer | CVPixelBufferPoolCreatePixelBuffer(v33, *(CVPixelBufferPoolRef *)(v26 + 24), (CVPixelBufferRef *)(v26 + 40)))
  {
    if (qword_2697D1198 != -1) {
      dispatch_once(&qword_2697D1198, &unk_26FE9CC68);
    }
    int64x2_t v55 = qword_2697D1190;
    if (os_log_type_enabled((os_log_t)qword_2697D1190, OS_LOG_TYPE_ERROR))
    {
      LOWORD(pixelTransferSessionOut.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_24B6B9000, v55, OS_LOG_TYPE_ERROR, "MVGConsistency::addNewFrame: Failed to create buffers!", (uint8_t *)&pixelTransferSessionOut, 2u);
    }
    uint64_t v19 = 0xFFFFFFFFLL;
    goto LABEL_222;
  }
  if (qword_2697D1198 != -1) {
    dispatch_once(&qword_2697D1198, &unk_26FE9CC68);
  }
  float v35 = &qword_2697D1000;
  float v36 = qword_2697D1190;
  if (os_log_type_enabled((os_log_t)qword_2697D1190, OS_LOG_TYPE_DEBUG))
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_24B6EEF48(&pixelTransferSessionOut, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string pixelTransferSessionOut = __p;
    }
    float v88 = &pixelTransferSessionOut;
    if ((pixelTransferSessionOut.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      float v88 = (std::string *)pixelTransferSessionOut.__r_.__value_.__r.__words[0];
    }
    buf[0] = 136446210;
    *(void *)&buf[1] = v88;
    _os_log_debug_impl(&dword_24B6B9000, v36, OS_LOG_TYPE_DEBUG, "MVGConsistency::addNewFrame: Adding frame %{public}s", (uint8_t *)buf, 0xCu);
    if (SHIBYTE(pixelTransferSessionOut.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(pixelTransferSessionOut.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v214 = a1;
  unsigned int v37 = *(char **)(v26 + 56);
  double v38 = *(char **)(v26 + 64);
  uint64_t v39 = (v38 - v37) >> 3;
  uint64_t v40 = v38 - v37;
  if (v38 == v37) {
    uint64_t v41 = 0;
  }
  else {
    uint64_t v41 = 18 * v39 - 1;
  }
  unint64_t v42 = *(void *)(v26 + 80);
  if (v41 == *(void *)(v26 + 88) + v42)
  {
    BOOL v43 = v42 >= 0x12;
    unint64_t v44 = v42 - 18;
    if (!v43)
    {
      float32x4_t v56 = *(char **)(v26 + 72);
      int8x16_t v57 = *(char **)(v26 + 48);
      if (v39 < (unint64_t)((v56 - v57) >> 3))
      {
        uint64_t v58 = operator new(0xFC0uLL);
        if (v56 != v38)
        {
          int64x2_t v59 = *(char **)(v26 + 64);
          if (v59 != *(char **)(v26 + 72))
          {
LABEL_176:
            *(void *)int64x2_t v59 = v58;
LABEL_204:
            double v38 = (char *)(*(void *)(v26 + 64) + 8);
            *(void *)(v26 + 64) = v38;
            goto LABEL_205;
          }
          int64x2_t v61 = *(char **)(v26 + 48);
          int64x2_t v60 = *(char **)(v26 + 56);
          if (v60 > v61)
          {
            uint64_t v62 = (v60 - v61) >> 3;
            if (v62 >= -1) {
              uint64_t v63 = v62 + 1;
            }
            else {
              uint64_t v63 = v62 + 2;
            }
            uint64_t v64 = v63 >> 1;
            uint64_t v65 = -v64;
            int32x4_t v66 = &v60[-8 * v64];
            int64_t v67 = v59 - v60;
            if (v59 != v60)
            {
              memmove(&v60[-8 * v64], *(const void **)(v26 + 56), v59 - v60);
              int64x2_t v59 = *(char **)(v26 + 56);
            }
            float v68 = &v59[8 * v65];
            int64x2_t v59 = &v66[v67];
            *(void *)(v26 + 56) = v68;
            *(void *)(v26 + 64) = &v66[v67];
            goto LABEL_176;
          }
          unint64_t v122 = (v59 - v61) >> 2;
          if (v59 == v61) {
            unint64_t v122 = 1;
          }
          if (!(v122 >> 61))
          {
            unint64_t v123 = v122 >> 2;
            uint64_t v124 = 8 * v122;
            float32x4_t v125 = (char *)operator new(8 * v122);
            float v126 = &v125[8 * v123];
            int64_t v127 = v59 - v60;
            BOOL v82 = v59 == v60;
            int64x2_t v59 = v126;
            if (v82) {
              goto LABEL_174;
            }
            int64x2_t v59 = &v126[v127 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v128 = v127 - 8;
            if ((unint64_t)(v127 - 8) >= 0x38)
            {
              int v156 = &v125[8 * v123];
              unint64_t v129 = v156;
              if ((unint64_t)(v156 - v60) >= 0x20)
              {
                uint64_t v157 = (v128 >> 3) + 1;
                uint64_t v158 = 8 * (v157 & 0x3FFFFFFFFFFFFFFCLL);
                unint64_t v129 = &v126[v158];
                uint64_t v159 = (long long *)(v60 + 16);
                uint64_t v160 = v156 + 16;
                uint64_t v161 = v157 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v162 = *v159;
                  *(v160 - 1) = *(v159 - 1);
                  _OWORD *v160 = v162;
                  v159 += 2;
                  v160 += 2;
                  v161 -= 4;
                }
                while (v161);
                if (v157 == (v157 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_174:
                  *(void *)(v26 + 48) = v125;
                  *(void *)(v26 + 56) = v126;
                  *(void *)(v26 + 64) = v59;
                  *(void *)(v26 + 72) = &v125[v124];
                  if (v61)
                  {
                    operator delete(v61);
                    int64x2_t v59 = *(char **)(v26 + 64);
                  }
                  goto LABEL_176;
                }
                v60 += v158;
              }
            }
            else
            {
              unint64_t v129 = &v125[8 * v123];
            }
            do
            {
              uint64_t v163 = *(void *)v60;
              v60 += 8;
              *(void *)unint64_t v129 = v163;
              v129 += 8;
            }
            while (v129 != v59);
            goto LABEL_174;
          }
LABEL_232:
          sub_24B6BCD7C();
        }
        uint64_t v86 = *(char **)(v26 + 56);
        if (v86 != *(char **)(v26 + 48))
        {
          uint64_t v87 = *(char **)(v26 + 56);
          goto LABEL_181;
        }
        float32x2_t v117 = *(unsigned char **)(v26 + 64);
        unint64_t v116 = *(void *)(v26 + 72);
        if ((unint64_t)v117 < v116)
        {
          uint64_t v118 = (uint64_t)(v116 - (void)v117) >> 3;
          if (v118 >= -1) {
            uint64_t v119 = v118 + 1;
          }
          else {
            uint64_t v119 = v118 + 2;
          }
          uint64_t v120 = v119 >> 1;
          uint64_t v121 = &v117[8 * (v119 >> 1)];
          uint64_t v87 = &v121[-(v117 - v86)];
          if (v117 != v86)
          {
            memmove(&v121[-(v117 - v86)], *(const void **)(v26 + 56), v117 - v86);
            uint64_t v86 = *(char **)(v26 + 64);
          }
          *(void *)(v26 + 56) = v87;
          *(void *)(v26 + 64) = &v86[8 * v120];
LABEL_181:
          *((void *)v87 - 1) = v58;
          uint64_t v166 = *(char **)(v26 + 56);
          float v165 = *(char **)(v26 + 64);
          *(void *)(v26 + 56) = v166 - 8;
          uint64_t v167 = *((void *)v166 - 1);
          *(void *)(v26 + 56) = v166;
          if (v165 != *(char **)(v26 + 72))
          {
LABEL_203:
            *(void *)float v165 = v167;
            goto LABEL_204;
          }
          float v168 = *(char **)(v26 + 48);
          if (v166 > v168)
          {
            uint64_t v169 = (v166 - v168) >> 3;
            if (v169 >= -1) {
              uint64_t v170 = v169 + 1;
            }
            else {
              uint64_t v170 = v169 + 2;
            }
            uint64_t v171 = v170 >> 1;
            uint64_t v172 = -v171;
            float32x4_t v173 = &v166[-8 * v171];
            int64_t v174 = v165 - v166;
            if (v165 != v166)
            {
              memmove(&v166[-8 * v171], v166, v165 - v166);
              uint64_t v166 = *(char **)(v26 + 56);
            }
            float v165 = &v173[v174];
            *(void *)(v26 + 56) = &v166[8 * v172];
            *(void *)(v26 + 64) = &v173[v174];
            goto LABEL_203;
          }
          unint64_t v175 = (v165 - v168) >> 2;
          if (v165 == v168) {
            unint64_t v175 = 1;
          }
          if (v175 >> 61) {
            goto LABEL_232;
          }
          unint64_t v176 = v175 >> 2;
          uint64_t v177 = 8 * v175;
          uint64_t v178 = (char *)operator new(8 * v175);
          long long v179 = &v178[8 * v176];
          int64_t v180 = v165 - v166;
          BOOL v82 = v165 == v166;
          float v165 = v179;
          if (!v82)
          {
            float v165 = &v179[v180 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v181 = v180 - 8;
            if ((unint64_t)(v180 - 8) < 0x38)
            {
              size_t v182 = &v178[8 * v176];
              goto LABEL_200;
            }
            unint64_t v183 = &v178[8 * v176];
            size_t v182 = v183;
            if ((unint64_t)(v183 - v166) < 0x20)
            {
              do
              {
LABEL_200:
                uint64_t v190 = *(void *)v166;
                v166 += 8;
                *(void *)size_t v182 = v190;
                v182 += 8;
              }
              while (v182 != v165);
              goto LABEL_201;
            }
            uint64_t v184 = (v181 >> 3) + 1;
            uint64_t v185 = 8 * (v184 & 0x3FFFFFFFFFFFFFFCLL);
            size_t v182 = &v179[v185];
            uint64_t v186 = (long long *)(v166 + 16);
            float v187 = v183 + 16;
            uint64_t v188 = v184 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v189 = *v186;
              *(v187 - 1) = *(v186 - 1);
              _OWORD *v187 = v189;
              v186 += 2;
              v187 += 2;
              v188 -= 4;
            }
            while (v188);
            if (v184 != (v184 & 0x3FFFFFFFFFFFFFFCLL))
            {
              v166 += v185;
              goto LABEL_200;
            }
          }
LABEL_201:
          *(void *)(v26 + 48) = v178;
          *(void *)(v26 + 56) = v179;
          *(void *)(v26 + 64) = v165;
          *(void *)(v26 + 72) = &v178[v177];
          if (v168)
          {
            operator delete(v168);
            float v165 = *(char **)(v26 + 64);
          }
          goto LABEL_203;
        }
        uint64_t v138 = v116 - (void)v86;
        BOOL v82 = v138 == 0;
        unint64_t v139 = v138 >> 2;
        if (v82) {
          unint64_t v139 = 1;
        }
        if (v139 >> 61) {
          goto LABEL_232;
        }
        unint64_t v140 = (v139 + 3) >> 2;
        uint64_t v141 = 8 * v139;
        int v142 = (char *)operator new(8 * v139);
        uint64_t v87 = &v142[8 * v140];
        uint64_t v143 = &v142[v141];
        float32x2_t v144 = v87;
        uint64_t v145 = v117 - v86;
        if (v117 != v86)
        {
          float32x2_t v144 = &v87[v145 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v146 = v145 - 8;
          size_t v147 = &v142[8 * v140];
          float v148 = v86;
          if (v146 > 0x37)
          {
            uint64_t v149 = &v142[8 * v140];
            size_t v147 = v149;
            float v148 = v86;
            if ((unint64_t)(v149 - v86) >= 0x20)
            {
              uint64_t v150 = (v146 >> 3) + 1;
              uint64_t v151 = 8 * (v150 & 0x3FFFFFFFFFFFFFFCLL);
              size_t v147 = &v87[v151];
              uint64_t v152 = (long long *)(v86 + 16);
              size_t v153 = v149 + 16;
              uint64_t v154 = v150 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v155 = *v152;
                *(v153 - 1) = *(v152 - 1);
                *size_t v153 = v155;
                v152 += 2;
                v153 += 2;
                v154 -= 4;
              }
              while (v154);
              if (v150 == (v150 & 0x3FFFFFFFFFFFFFFCLL))
              {
                *(void *)(v26 + 48) = v142;
                *(void *)(v26 + 56) = v87;
                *(void *)(v26 + 64) = v144;
                *(void *)(v26 + 72) = v143;
LABEL_180:
                operator delete(v86);
                uint64_t v87 = *(char **)(v26 + 56);
                goto LABEL_181;
              }
              float v148 = &v86[v151];
            }
          }
          do
          {
            uint64_t v164 = *(void *)v148;
            v148 += 8;
            *(void *)size_t v147 = v164;
            v147 += 8;
          }
          while (v147 != v144);
        }
        *(void *)(v26 + 48) = v142;
        *(void *)(v26 + 56) = v87;
        *(void *)(v26 + 64) = v144;
        *(void *)(v26 + 72) = v143;
        if (!v86) {
          goto LABEL_181;
        }
        goto LABEL_180;
      }
      if (v56 == v57) {
        unint64_t v69 = 1;
      }
      else {
        unint64_t v69 = (v56 - v57) >> 2;
      }
      if (v69 >> 61) {
        goto LABEL_232;
      }
      int v70 = (char *)operator new(8 * v69);
      unint64_t v71 = &v70[8 * v39];
      float32x4_t v72 = &v70[8 * v69];
      uint64_t v73 = operator new(0xFC0uLL);
      if (v39 == v69)
      {
        if (v40 < 1)
        {
          unint64_t v91 = v40 >> 2;
          if (v38 == v37) {
            unint64_t v91 = 1;
          }
          if (v91 >> 61) {
            goto LABEL_232;
          }
          uint64_t v92 = 8 * v91;
          unint64_t v71 = (char *)operator new(8 * v91);
          float32x4_t v72 = &v71[v92];
          operator delete(v70);
          unsigned int v37 = *(char **)(v26 + 56);
          double v38 = *(char **)(v26 + 64);
          int v70 = v71;
        }
        else
        {
          unint64_t v74 = v39 + 2;
          if (v39 >= -1) {
            unint64_t v74 = v39 + 1;
          }
          v71 -= 8 * (v74 >> 1);
        }
      }
      *(void *)unint64_t v71 = v73;
      unint64_t v93 = v71 + 8;
      if (v38 == v37)
      {
        uint64_t v94 = v71;
        size_t v95 = v71 + 8;
LABEL_111:
        int v96 = *(void **)(v26 + 48);
        *(void *)(v26 + 48) = v70;
        *(void *)(v26 + 56) = v94;
        double v38 = v95;
        *(void *)(v26 + 64) = v95;
        *(void *)(v26 + 72) = v72;
        float v35 = &qword_2697D1000;
        if (v96)
        {
          operator delete(v96);
          double v38 = *(char **)(v26 + 64);
        }
        goto LABEL_205;
      }
      while (v71 != v70)
      {
        uint64_t v97 = v71;
        size_t v95 = v93;
LABEL_114:
        uint64_t v98 = *((void *)v38 - 1);
        v38 -= 8;
        *((void *)v97 - 1) = v98;
        uint64_t v94 = v97 - 8;
        unint64_t v93 = v95;
        unint64_t v71 = v94;
        if (v38 == *(char **)(v26 + 56)) {
          goto LABEL_111;
        }
      }
      if (v93 < v72)
      {
        uint64_t v99 = (v72 - v93) >> 3;
        if (v99 >= -1) {
          unint64_t v100 = v99 + 1;
        }
        else {
          unint64_t v100 = v99 + 2;
        }
        size_t v95 = &v93[8 * (v100 >> 1)];
        uint64_t v97 = &v71[8 * (v100 >> 1)];
        if (v93 == v71)
        {
          int v70 = v93;
        }
        else
        {
          memmove(&v71[8 * (v100 >> 1)], v71, v93 - v71);
          int v70 = v71;
        }
        goto LABEL_114;
      }
      unint64_t v101 = (v72 - v71) >> 2;
      if (v72 == v71) {
        unint64_t v101 = 1;
      }
      if (v101 >> 61) {
        goto LABEL_232;
      }
      unint64_t v102 = (v101 + 3) >> 2;
      uint64_t v103 = 8 * v101;
      uint64_t v104 = (char *)operator new(8 * v101);
      int v70 = v104;
      uint64_t v97 = &v104[8 * v102];
      size_t v95 = v97;
      int64_t v105 = v93 - v71;
      if (v93 != v71)
      {
        size_t v95 = &v97[v105 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v106 = v105 - 8;
        size_t v107 = &v104[8 * v102];
        unint64_t v108 = v71;
        if (v106 >= 0x38)
        {
          size_t v107 = &v104[8 * v102];
          unint64_t v108 = v71;
          if ((unint64_t)(v107 - v71) >= 0x20)
          {
            uint64_t v109 = (v106 >> 3) + 1;
            uint64_t v110 = 8 * (v109 & 0x3FFFFFFFFFFFFFFCLL);
            size_t v107 = &v97[v110];
            uint64_t v111 = (long long *)(v71 + 16);
            uint64_t v112 = &v104[8 * v102 + 16];
            uint64_t v113 = v109 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v114 = *v111;
              *((_OWORD *)v112 - 1) = *(v111 - 1);
              *(_OWORD *)uint64_t v112 = v114;
              v111 += 2;
              v112 += 32;
              v113 -= 4;
            }
            while (v113);
            if (v109 == (v109 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_133;
            }
            unint64_t v108 = &v71[v110];
          }
        }
        do
        {
          uint64_t v115 = *(void *)v108;
          v108 += 8;
          *(void *)size_t v107 = v115;
          v107 += 8;
        }
        while (v107 != v95);
      }
LABEL_133:
      float32x4_t v72 = &v104[v103];
      operator delete(v71);
      goto LABEL_114;
    }
    *(void *)(v26 + 80) = v44;
    uint64_t v45 = v37 + 8;
    uint64_t v46 = *(void *)v37;
    *(void *)(v26 + 56) = v37 + 8;
    if (v38 != *(char **)(v26 + 72))
    {
LABEL_156:
      *(void *)double v38 = v46;
      double v38 = (char *)(*(void *)(v26 + 64) + 8);
      *(void *)(v26 + 64) = v38;
      float v35 = &qword_2697D1000;
LABEL_205:
      unsigned int v37 = *(char **)(v26 + 56);
      goto LABEL_206;
    }
    float32x4_t v47 = *(char **)(v26 + 48);
    if (v45 > v47)
    {
      uint64_t v48 = (v45 - v47) >> 3;
      if (v48 >= -1) {
        uint64_t v49 = v48 + 1;
      }
      else {
        uint64_t v49 = v48 + 2;
      }
      uint64_t v50 = v49 >> 1;
      uint64_t v51 = -v50;
      float32x4_t v52 = &v45[-8 * v50];
      int64_t v53 = v38 - v45;
      if (v38 != v45)
      {
        memmove(&v45[-8 * v50], v37 + 8, v38 - v45);
        double v38 = *(char **)(v26 + 56);
      }
      int v54 = &v38[8 * v51];
      double v38 = &v52[v53];
      *(void *)(v26 + 56) = v54;
      *(void *)(v26 + 64) = &v52[v53];
      goto LABEL_156;
    }
    unint64_t v77 = (v38 - v47) >> 2;
    if (v38 == v47) {
      unint64_t v77 = 1;
    }
    if (v77 >> 61) {
      goto LABEL_232;
    }
    unint64_t v78 = v77 >> 2;
    uint64_t v79 = 8 * v77;
    float32x4_t v80 = (char *)operator new(8 * v77);
    float32x4_t v81 = &v80[8 * v78];
    int64_t v83 = v38 - v45;
    BOOL v82 = v38 == v45;
    double v38 = v81;
    if (!v82)
    {
      double v38 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v84 = v83 - 8;
      if ((unint64_t)(v83 - 8) < 0x38)
      {
        uint64_t v85 = &v80[8 * v78];
        goto LABEL_153;
      }
      unsigned int v130 = &v80[8 * v78];
      uint64_t v85 = v130;
      if ((unint64_t)(v130 - v45) < 0x20)
      {
        do
        {
LABEL_153:
          uint64_t v137 = *(void *)v45;
          v45 += 8;
          *(void *)uint64_t v85 = v137;
          v85 += 8;
        }
        while (v85 != v38);
        goto LABEL_154;
      }
      uint64_t v131 = (v84 >> 3) + 1;
      uint64_t v132 = 8 * (v131 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v85 = &v81[v132];
      float32x4_t v133 = (long long *)(v37 + 24);
      uint64_t v134 = v130 + 16;
      uint64_t v135 = v131 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v136 = *v133;
        *(v134 - 1) = *(v133 - 1);
        _OWORD *v134 = v136;
        v133 += 2;
        v134 += 2;
        v135 -= 4;
      }
      while (v135);
      if (v131 != (v131 & 0x3FFFFFFFFFFFFFFCLL))
      {
        v45 += v132;
        goto LABEL_153;
      }
    }
LABEL_154:
    *(void *)(v26 + 48) = v80;
    *(void *)(v26 + 56) = v81;
    *(void *)(v26 + 64) = v38;
    *(void *)(v26 + 72) = &v80[v79];
    if (v47)
    {
      operator delete(v47);
      double v38 = *(char **)(v26 + 64);
    }
    goto LABEL_156;
  }
LABEL_206:
  if (v38 == v37)
  {
    unint64_t v192 = 0;
  }
  else
  {
    unint64_t v191 = *(void *)(v26 + 88) + *(void *)(v26 + 80);
    unint64_t v192 = *(void *)&v37[8 * (v191 / 0x12)] + 224 * (v191 % 0x12);
  }
  *(void *)unint64_t v192 = 0;
  *(void *)(v192 + 8) = 0;
  long long v193 = v218;
  long long v194 = v219;
  long long v195 = v221;
  *(_OWORD *)(v192 + 48) = v220;
  *(_OWORD *)(v192 + 64) = v195;
  *(_OWORD *)(v192 + 16) = v193;
  *(_OWORD *)(v192 + 32) = v194;
  long long v196 = v222;
  long long v197 = v224;
  *(_OWORD *)(v192 + 96) = v223;
  *(_OWORD *)(v192 + 112) = v197;
  *(_OWORD *)(v192 + 80) = v196;
  long long v198 = v225;
  long long v199 = v226;
  long long v200 = v228;
  *(_OWORD *)(v192 + 160) = v227;
  *(_OWORD *)(v192 + 176) = v200;
  *(_OWORD *)(v192 + 128) = v198;
  *(_OWORD *)(v192 + 144) = v199;
  uint64_t v201 = (unsigned char *)(v192 + 192);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_24B6EEF48(v201, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else
  {
    long long v202 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *(void *)(v192 + 208) = *((void *)&__p.__r_.__value_.__l + 2);
    *(_OWORD *)uint64_t v201 = v202;
  }
  *(void *)unint64_t v192 = CVPixelBufferRetain(pixelBufferOut);
  *(void *)(v192 + 8) = CVPixelBufferRetain(texture);
  ++*(void *)(v26 + 88);
  uint64_t v203 = (void *)*v214;
  if (*(void *)(*v214 + 88) >= (unint64_t)(*(void *)(*v214 + 16) + 1))
  {
    if (qword_2697D1198 != -1) {
      dispatch_once(&qword_2697D1198, &unk_26FE9CC68);
    }
    unint64_t v205 = v35[50];
    if (os_log_type_enabled(v205, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v207 = v203[11] + v203[10] - 1;
      uint64_t v208 = *(void *)(v203[7] + 8 * (v207 / 0x12));
      unint64_t v209 = v207 % 0x12;
      uint64_t v210 = v208 + 224 * v209;
      double v211 = (void **)(v210 + 192);
      if (*(char *)(v210 + 215) < 0)
      {
        sub_24B6EEF48(&pixelTransferSessionOut, *v211, *(void *)(v208 + 224 * v209 + 200));
      }
      else
      {
        long long v212 = *(_OWORD *)v211;
        pixelTransferSessionOut.__r_.__value_.__r.__words[2] = *(void *)(v210 + 208);
        *(_OWORD *)&pixelTransferSessionOut.__r_.__value_.__l.__data_ = v212;
      }
      float v213 = &pixelTransferSessionOut;
      if ((pixelTransferSessionOut.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        float v213 = (std::string *)pixelTransferSessionOut.__r_.__value_.__r.__words[0];
      }
      buf[0] = 136446210;
      *(void *)&buf[1] = v213;
      _os_log_debug_impl(&dword_24B6B9000, v205, OS_LOG_TYPE_DEBUG, "MVGConsistency::evaluateFrame: Evaluating frame %{public}s", (uint8_t *)buf, 0xCu);
      if (SHIBYTE(pixelTransferSessionOut.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(pixelTransferSessionOut.__r_.__value_.__l.__data_);
      }
    }
    CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)(*(void *)(v203[7] + 8 * ((v203[11] + v203[10] - 1) / 0x12uLL))+ 224 * ((v203[11] + v203[10] - 1) % 0x12uLL)+ 8), 1uLL);
    cva::imageViewFromPixelBuffer<float>();
  }
  if (qword_2697D1198 != -1) {
    dispatch_once(&qword_2697D1198, &unk_26FE9CC68);
  }
  float v204 = v35[50];
  if (os_log_type_enabled(v204, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(pixelTransferSessionOut.__r_.__value_.__l.__data_) = 0;
    _os_log_debug_impl(&dword_24B6B9000, v204, OS_LOG_TYPE_DEBUG, "MVGConsistency::evaluateFrame: Not enough frames, skipping evaluation.", (uint8_t *)&pixelTransferSessionOut, 2u);
  }
  uint64_t v19 = 0;
LABEL_222:
  CVPixelBufferRelease(pixelBufferOut);
  CVPixelBufferRelease(texture);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v19;
}

void sub_24B6DC380(_Unwind_Exception *exception_object)
{
}

void sub_24B6DC38C(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x307]) < 0) {
    operator delete((void *)STACK[0x2F0]);
  }
  _Unwind_Resume(a1);
}

CVPixelBufferRef OCMultiviewGeometryCreatePhotometricConfidenceMap(CVPixelBufferRef result)
{
  if (result) {
    return CVPixelBufferRetain(*(CVPixelBufferRef *)(*(void *)result + 40));
  }
  return result;
}

CVPixelBufferRef OCMultiviewGeometryCreateGeometricConfidenceMap(CVPixelBufferRef result)
{
  if (result) {
    return CVPixelBufferRetain(*(CVPixelBufferRef *)(*(void *)result + 32));
  }
  return result;
}

void sub_24B6DC3D4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x24C5D7790);
}

uint64_t sub_24B6DC428(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }
  return a1;
}

float sub_24B6DC45C(uint64_t a1, CVPixelBufferRef pixelBuffer, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, 0);
  size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, 0);
  float result = 0.0;
  if (*(void *)(a1 + 8) >= a5 && *(void *)(a1 + 16) >= a6 && WidthOfPlane > a3 && HeightOfPlane > a4)
  {
    double v15 = (double)a3;
    double v16 = (double)a5 * 0.5;
    unint64_t v17 = (unint64_t)fmax((double)a3 - v16, 0.0);
    vImagePixelCount v18 = (unint64_t)fmin(v16 + v15, (double)WidthOfPlane) - v17;
    double v19 = (double)a6 * 0.5;
    unint64_t v20 = (unint64_t)fmax((double)a4 - v19, 0.0);
    vImagePixelCount v21 = (unint64_t)fmin(v19 + (double)a4, (double)HeightOfPlane) - v20;
    CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
    BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
    size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
    src.data = &BaseAddressOfPlane[BytesPerRowOfPlane * v20 + v17];
    src.height = v21;
    src.width = v18;
    src.rowBytes = BytesPerRowOfPlane;
    dest.data = *(void **)(a1 + 64);
    dest.height = v21;
    dest.width = v18;
    dest.rowBytes = 4 * v18;
    vImageConvert_Planar8toPlanarF(&src, &dest, 0.0, 255.0, 0);
    CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
    vDSP_f3x3(*(const float **)(a1 + 64), v21, v18, (const float *)(a1 + 24), *(float **)(a1 + 64));
    uint64_t __StandardDeviation = 0;
    vDSP_normalize(*(const float **)(a1 + 64), 1, 0, 1, (float *)&__StandardDeviation + 1, (float *)&__StandardDeviation, v21 * v18);
    return *(float *)&__StandardDeviation;
  }
  return result;
}

void sub_24B6DC608(uint64_t a1)
{
  sub_24B6DC640(a1);
  JUMPOUT(0x24C5D7790);
}

uint64_t sub_24B6DC640(uint64_t a1)
{
  CVMetalTextureCacheFlush(*(CVMetalTextureCacheRef *)(a1 + 64), 0);

  uint64_t v2 = *(void **)(a1 + 120);
  if (v2)
  {
    *(void *)(a1 + 128) = v2;
    operator delete(v2);
  }

  return a1;
}

void sub_24B6DC6B0(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void **)(v1 + 120);
  if (v3)
  {
    *(void *)(v1 + 128) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(a1);
}

float sub_24B6DC700(uint64_t a1, CVPixelBufferRef pixelBuffer, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  CVPixelBufferGetPixelFormatType(pixelBuffer);
  unint64_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, 0);
  size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, 0);
  float v14 = 0.0;
  if (*(void *)(a1 + 8) >= a5 && *(void *)(a1 + 16) >= a6 && WidthOfPlane > a3)
  {
    uint64_t v15 = HeightOfPlane;
    if (HeightOfPlane > a4)
    {
      CVMetalTextureRef textureOut = 0;
      if (!CVMetalTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x263EFFB08], *(CVMetalTextureCacheRef *)(a1 + 64), pixelBuffer, 0, MTLPixelFormatR8Unorm, WidthOfPlane, HeightOfPlane, 0, &textureOut))
      {
        int64x2_t v59 = CVMetalTextureGetTexture(textureOut);
        id v16 = *(id *)(*(void *)(a1 + 72) + 8);
        double v19 = objc_msgSend_commandBuffer(v16, v17, v18);
        OSType v22 = objc_msgSend_computeCommandEncoder(v19, v20, v21);
        objc_msgSend_setComputePipelineState_(v22, v23, *(void *)(a1 + 144));
        objc_msgSend_setTexture_atIndex_(v22, v24, (uint64_t)v59, 0);
        v25.i64[0] = a3;
        v25.i64[1] = a4;
        v26.i64[0] = a5;
        v26.i64[1] = a6;
        float64x2_t v27 = vcvtq_f64_u64(v25);
        v28.i64[0] = WidthOfPlane;
        v28.i64[1] = v15;
        __asm { FMOV            V3.2D, #0.5 }
        float64x2_t v34 = vmulq_f64(vcvtq_f64_u64(v26), _Q3);
        int32x4_t v35 = (int32x4_t)vcvtq_u64_f64(vmaxnmq_f64(vsubq_f64(v27, v34), (float64x2_t)0));
        int32x4_t v58 = (int32x4_t)vsubq_s64((int64x2_t)vcvtq_u64_f64(vminnmq_f64(vaddq_f64(v34, v27), vcvtq_f64_u64(v28))), (int64x2_t)v35);
        int32x4_t v66 = vuzp1q_s32(v35, v58);
        objc_msgSend_setBytes_length_atIndex_(v22, v36, (uint64_t)&v66, 16, 0);
        objc_msgSend_setTexture_atIndex_(v22, v37, *(void *)(a1 + 96), 1);
        id v38 = *(id *)(a1 + 144);
        unint64_t v41 = objc_msgSend_threadExecutionWidth(v38, v39, v40);
        unint64_t v44 = objc_msgSend_maxTotalThreadsPerThreadgroup(v38, v42, v43) / v41;

        int32x4_t v64 = v58;
        uint64_t v65 = 1;
        v63[0] = v41;
        v63[1] = v44;
        v63[2] = 1;
        objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v22, v45, (uint64_t)&v64, v63);
        objc_msgSend_endEncoding(v22, v46, v47);
        objc_msgSend_encodeToCommandBuffer_sourceTexture_destinationTexture_(*(void **)(a1 + 80), v48, (uint64_t)v19, *(void *)(a1 + 96), *(void *)(a1 + 104));
        objc_msgSend_encodeToCommandBuffer_sourceTexture_destinationTexture_(*(void **)(a1 + 88), v49, (uint64_t)v19, *(void *)(a1 + 104), *(void *)(a1 + 112));
        objc_msgSend_commit(v19, v50, v51);
        objc_msgSend_waitUntilCompleted(v19, v52, v53);
        int v54 = *(void **)(a1 + 112);
        uint64_t v55 = *(void *)(a1 + 120);
        memset(v60, 0, sizeof(v60));
        long long v61 = xmmword_24B72A6D0;
        uint64_t v62 = 1;
        objc_msgSend_getBytes_bytesPerRow_fromRegion_mipmapLevel_(v54, v56, v55, 8, v60, 0);
        float v14 = *(float *)(*(void *)(a1 + 120) + 4);
      }
    }
  }
  return v14;
}

void sub_24B6DC994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

double OCNonModularSPI_Serialization_InvalidBoundingBoxTransform()
{
  return 0.0;
}

double OCNonModularSPI_Serialization_InvalidObjectTransform()
{
  return 0.0;
}

double OCNonModularSPI_Serialization_InvalidCameraIntrinsics()
{
  return 0.0;
}

double OCNonModularSPI_Serialization_InvalidCameraTransform()
{
  return 0.0;
}

__IOSurface *OCNonModularSPI_Serialization_CVBufferToData(__IOSurface *DataSize)
{
  if (DataSize)
  {
    unint64_t DataSize = (__IOSurface *)CVDataBufferGetDataSize();
    if (DataSize)
    {
      uint64_t v2 = DataSize;
      unint64_t DataSize = (__IOSurface *)CVDataBufferGetIOSurface();
      if (DataSize)
      {
        BaseAddress = IOSurfaceGetBaseAddress(DataSize);
        objc_msgSend_dataWithBytes_length_(MEMORY[0x263EFF8F8], v4, (uint64_t)BaseAddress, v2);
        unint64_t DataSize = (__IOSurface *)objc_claimAutoreleasedReturnValue();
      }
    }
    uint64_t v1 = vars8;
  }
  return DataSize;
}

uint64_t OCImageDSPCentralCropMean(__CVBuffer *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, float *a6)
{
  if (!a1) {
    return 4294967294;
  }
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  uint64_t v13 = 4294967294;
  if ((a4 & 1) != 0 && PixelFormatType == 1717855600 && (a5 & 1) != 0 && a6)
  {
    size_t Width = CVPixelBufferGetWidth(a1);
    size_t Height = CVPixelBufferGetHeight(a1);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
    id v16 = 0;
    unint64_t v17 = a4 >> 1;
    if (a2 >= a4 >> 1) {
      uint64_t v18 = a2 - (a4 >> 1);
    }
    else {
      uint64_t v18 = 0;
    }
    unint64_t v19 = a5 >> 1;
    size_t v20 = v17 + a2;
    if (a3 >= a5 >> 1) {
      unint64_t v21 = a3 - (a5 >> 1);
    }
    else {
      unint64_t v21 = 0;
    }
    if (v20 < Width) {
      size_t Width = v20 + 1;
    }
    if (Height > (a5 + a3 < 2)) {
      size_t Height = a3 + v19 + 1;
    }
    size_t v22 = Height - v21;
    if (Height != v21)
    {
      if (v22 >> 62) {
        abort();
      }
      float32x4_t v23 = (float *)operator new(4 * v22);
      id v16 = v23;
      if (a3 >= v19) {
        unint64_t v24 = v19;
      }
      else {
        unint64_t v24 = a3;
      }
      bzero(v23, 4 * (Height + v24) - 4 * a3);
    }
    if (!CVPixelBufferLockBaseAddress(a1, 1uLL))
    {
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
      block[0] = MEMORY[0x263EF8330];
      block[1] = 3221225472;
      block[2] = sub_24B6DCCC0;
      block[3] = &unk_2652DF090;
      void block[4] = &BaseAddress[4 * v18 + ((BytesPerRow * v21) & 0xFFFFFFFFFFFFFFFCLL)];
      block[5] = BytesPerRow;
      block[6] = v16;
      block[7] = Width - v18;
      dispatch_apply(Height - v21, 0, block);
      float __C = 0.0;
      vDSP_sve(v16, 1, &__C, Height - v21);
      if (!CVPixelBufferUnlockBaseAddress(a1, 1uLL))
      {
        uint64_t v13 = 0;
        *a6 = __C / (float)(v22 * (Width - v18));
        if (!v16) {
          return v13;
        }
        goto LABEL_25;
      }
    }
    uint64_t v13 = 0xFFFFFFFFLL;
    if (v16) {
LABEL_25:
    }
      operator delete(v16);
  }
  return v13;
}

void sub_24B6DCCA0(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_24B6DCCC0(void *a1, uint64_t a2)
{
}

uint64_t OCNonModularSPI_AppleMakerNote_Version()
{
  return *MEMORY[0x263F2C068];
}

uint64_t OCNonModularSPI_AppleMakerNote_Timestamp()
{
  return *MEMORY[0x263F2C060];
}

uint64_t OCNonModularSPI_AppleMakerNote_FocusAccelerometerVector()
{
  return *MEMORY[0x263F2C040];
}

uint64_t OCNonModularSPI_AppleMakerNote_Camera()
{
  return *MEMORY[0x263F2C038];
}

uint64_t OCNonModularSPI_AppleMakerNote_BackWideAngleCamera()
{
  return 2;
}

uint64_t OCRegistrationCreate(_DWORD *a1, void *a2)
{
  id v4 = operator new(0x10uLL, MEMORY[0x263F8C180]);
  if (!v4) {
    return 4294967293;
  }
  unint64_t v5 = v4;
  uint64_t result = 0;
  void *v5 = 0;
  v5[1] = 0;
  *(_DWORD *)unint64_t v5 = *a1;
  *a2 = v5;
  return result;
}

uint64_t OCRegistrationStart(uint64_t a1)
{
  if (a1) {
    operator new();
  }
  return 0xFFFFFFFFLL;
}

uint64_t OCRegistrationStop(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v1 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 128);
    *(void *)(v1 + 128) = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    }
    uint64_t v3 = *(void **)(v1 + 8);
    if (v3)
    {
      *(void *)(v1 + 16) = v3;
      operator delete(v3);
    }
    id v4 = *(uint64_t **)v1;
    *(void *)uint64_t v1 = 0;
    if (v4)
    {
      unint64_t v5 = sub_24B6EEEA0(v4);
      MEMORY[0x24C5D7790](v5, 0x1020C406C4767B9);
    }
    MEMORY[0x24C5D7790](v1, 0x1060C406E0EDD12);
  }
  return 0;
}

uint64_t OCRegistrationDestroy(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 128);
    *(void *)(v2 + 128) = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
    id v4 = *(void **)(v2 + 8);
    if (v4)
    {
      *(void *)(v2 + 16) = v4;
      operator delete(v4);
    }
    unint64_t v5 = *(uint64_t **)v2;
    *(void *)uint64_t v2 = 0;
    if (v5)
    {
      double v6 = sub_24B6EEEA0(v5);
      MEMORY[0x24C5D7790](v6, 0x1020C406C4767B9);
    }
    MEMORY[0x24C5D7790](v2, 0x1060C406E0EDD12);
  }
  MEMORY[0x24C5D7790](a1, 0x1020C40D5A9D86FLL);
  return 0;
}

uint64_t OCRegistrationProcess(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4, float32x4_t *a5, __n128 a6, __n128 a7, __n128 a8, __n128 a9)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = *(void *)(a1 + 8);
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = 4294967294;
  if (a4)
  {
    if (a5)
    {
      uint64_t v13 = *a4;
      uint64_t v14 = a4[1];
      *(void *)(v10 + 112) = *a4;
      *(void *)(v10 + 120) = v14;
      if (fabsf(*(float *)&v14) != INFINITY)
      {
        BOOL v15 = fabsf(*((float *)&v14 + 1)) == INFINITY || v13 == 0;
        if (!v15 && *(float *)&v14 <= 1.0 && *(float *)&v14 > 0.0 && *((float *)&v14 + 1) > 0.0)
        {
          *(void *)(v10 + 112) = v13;
          *(void *)(v10 + 120) = v14;
          unint64_t v17 = *(__n128 **)(a1 + 8);
          v17[3] = a6;
          v17[4] = a7;
          v17[5] = a8;
          v17[6] = a9;
          float32x4_t v151 = 0u;
          float32x4_t v152 = 0u;
          float32x4_t v149 = 0u;
          float32x4_t v150 = 0u;
          if (a3)
          {
            if (a3 >= 0x555555555555556) {
LABEL_148:
            }
              abort();
            unint64_t v19 = (char *)operator new(48 * a3);
            bzero(v19, 48 * ((48 * a3 - 48) / 0x30) + 48);
            uint64_t v20 = 0;
            unsigned int v21 = 1;
            do
            {
              long long v22 = *(_OWORD *)(a2 + v20 + 16);
              long long v23 = *(_OWORD *)(a2 + v20 + 32);
              unint64_t v24 = &v19[v20];
              *(_OWORD *)unint64_t v24 = *(_OWORD *)(a2 + v20);
              *((_OWORD *)v24 + 1) = v22;
              *((_OWORD *)v24 + 2) = v23;
              unint64_t v25 = v21;
              v20 += 48;
              ++v21;
            }
            while (v25 < a3);
            uint64x2_t v26 = &v19[48 * ((48 * a3 - 48) / 0x30) + 48];
          }
          else
          {
            unint64_t v19 = 0;
            uint64x2_t v26 = 0;
          }
          uint64x2_t v28 = *(float32x4_t **)(a1 + 8);
          if (fabsf(v28[6].f32[3] + -1.0) > 1.1755e-38) {
            goto LABEL_144;
          }
          unint64_t v140 = a5;
          int v160 = 0;
          uint64_t v158 = 0;
          size_t v159 = 0;
          uint64_t v161 = 0;
          size_t v162 = 0;
          int v163 = 0;
          uint64_t v164 = 0;
          size_t v165 = 0;
          int v166 = 0;
          uint64_t v167 = 0;
          size_t v168 = 0;
          int v169 = 0;
          uint64_t v153 = 0x7F7FFFFF00800000;
          uint64_t v141 = v28->i64[1];
          unsigned int v29 = -1431655765 * ((unint64_t)(v28[1].i64[0] - v141) >> 4);
          float32x4_t v30 = v28[4];
          float32x4_t v154 = v28[3];
          float32x4_t v155 = v30;
          float32x4_t v31 = v28[6];
          float32x4_t v156 = v28[5];
          float32x4_t v157 = v31;
          if (&v28[3] != &v149)
          {
            float32x4_t v32 = v28[4];
            float32x4_t v149 = v28[3];
            float32x4_t v150 = v32;
            float32x4_t v33 = v28[6];
            float32x4_t v151 = v28[5];
            float32x4_t v152 = v33;
          }
          unint64_t v34 = 0;
          float v35 = (float)v29;
          unint64_t v146 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v19) >> 4);
          uint64_t v143 = v28;
          float32x2_t v144 = v26;
          unsigned int v142 = v29;
LABEL_25:
          unint64_t v145 = v34;
          float v36 = v28;
          uint64_t v178 = 0;
          uint64_t v179 = 16;
          memptr[0] = 0;
          malloc_type_posix_memalign(memptr, 0x20uLL, 0x40uLL, 0x49090899uLL);
          unsigned int v37 = memptr[0];
          uint64_t v178 = memptr[0];
          LODWORD(v180) = 4;
          *(float32x4_t *)memptr[0] = v154;
          v37[1] = v155;
          v37[2] = v156;
          v37[3] = v157;
          if (v19 != v26)
          {
            id v38 = v19;
            do
            {
              long long v39 = *(_OWORD *)v38;
              long long v40 = *((_OWORD *)v38 + 1);
              memptr[0] = *(void **)v38;
              *(void *)&long long v172 = v40;
              memptr[1] = (void *)(DWORD2(v39) | 0x3F80000000000000);
              *((void *)&v172 + 1) = DWORD2(v40);
              uint64_t v170 = &v178;
              uint64_t v171 = memptr;
              sub_24B703574((uint64_t)memptr, (uint64_t)&v170);
              uint64_t v170 = &v178;
              uint64_t v171 = (void **)&v172;
              sub_24B703574((uint64_t)&v172, (uint64_t)&v170);
              long long v41 = *(_OWORD *)memptr;
              long long v42 = v172;
              HIDWORD(v41) = 1.0;
              HIDWORD(v42) = 0;
              *(_OWORD *)id v38 = v41;
              *((_OWORD *)v38 + 1) = v42;
              v38 += 48;
            }
            while (v38 != v26);
          }
          free(v37);
          uint64x2_t v28 = v36;
          uint64_t v43 = v36->i64[0];
          unint64_t v44 = v145;
          if (!v43 || !v29)
          {
LABEL_143:
            free(v167);
            free(v164);
            free(v161);
            free(v158);
LABEL_144:
            uint64_t v11 = 0xFFFFFFFFLL;
            goto LABEL_145;
          }
          float v45 = v28[8].f32[2];
          memptr[0] = 0;
          memptr[1] = 0;
          uint64_t v175 = 0;
          long long v172 = 0uLL;
          uint64_t v173 = 0;
          uint64_t v153 = 0;
          if (v19 == v26)
          {
            unint64_t v93 = 0;
            BOOL v81 = 0;
            goto LABEL_132;
          }
          uint64_t v46 = 0;
          unsigned int v47 = 0;
          uint64_t v48 = 0;
          size_t v147 = 0;
          float v148 = 0;
          unint64_t v49 = v146;
          while (1)
          {
            memptr[1] = memptr[0];
            if (!*(void *)(v43 + 24)) {
              goto LABEL_33;
            }
            long long v50 = *(_OWORD *)&v19[48 * v46];
            uint64_t v176 = *(void *)&v19[48 * v46];
            float v177 = *((float *)&v50 + 2);
            sub_24B6EDC20((uint64_t)memptr, 1uLL);
            uint64_t v51 = (_DWORD *)v172;
            if (*((void *)&v172 + 1) == (void)v172)
            {
              sub_24B6EDDD0((uint64_t)&v172, 1uLL);
              uint64_t v51 = (_DWORD *)v172;
            }
            else if (*((void *)&v172 + 1) - (void)v172 >= 5uLL)
            {
              *((void *)&v172 + 1) = v172 + 4;
            }
            uint64_t v52 = *(void *)(v43 + 8);
            uint64_t v53 = (char *)memptr[0];
            uint64_t v178 = memptr[0];
            uint64_t v179 = (uint64_t)v51;
            long long v180 = xmmword_24B72A6E0;
            _DWORD *v51 = 2139095039;
            if (!*(void *)(v52 + 40)) {
              break;
            }
            int v54 = *(int **)(v52 + 24);
            if (!v54)
            {
              exception = __cxa_allocate_exception(0x10uLL);
              MEMORY[0x24C5D7550](exception, "[nanoflann] findNeighbors() called before building the index.");
              __cxa_throw(exception, (struct type_info *)&unk_26FE9CBF0, MEMORY[0x263F8C070]);
            }
            LODWORD(v171) = 0;
            uint64_t v170 = 0;
            float v55 = *(float *)(v52 + 60);
            float v56 = 0.0;
            if (*(float *)&v176 < v55)
            {
              float v56 = (float)(*(float *)&v176 - v55) * (float)(*(float *)&v176 - v55);
              *(float *)&uint64_t v170 = v56;
            }
            float v57 = *(float *)(v52 + 64);
            if (*(float *)&v176 > v57)
            {
              *(float *)&uint64_t v170 = (float)(*(float *)&v176 - v57) * (float)(*(float *)&v176 - v57);
              float v56 = v56 + *(float *)&v170;
            }
            float v58 = *(float *)(v52 + 68);
            if (*((float *)&v176 + 1) < v58)
            {
              *((float *)&v170 + 1) = (float)(*((float *)&v176 + 1) - v58) * (float)(*((float *)&v176 + 1) - v58);
              float v56 = v56 + *((float *)&v170 + 1);
            }
            float v59 = *(float *)(v52 + 72);
            if (*((float *)&v176 + 1) > v59)
            {
              *((float *)&v170 + 1) = (float)(*((float *)&v176 + 1) - v59) * (float)(*((float *)&v176 + 1) - v59);
              float v56 = v56 + *((float *)&v170 + 1);
            }
            float v60 = *(float *)(v52 + 76);
            if (v177 < v60)
            {
              *(float *)&uint64_t v171 = (float)(v177 - v60) * (float)(v177 - v60);
              float v56 = v56 + *(float *)&v171;
            }
            float v61 = *(float *)(v52 + 80);
            if (v177 > v61)
            {
              *(float *)&uint64_t v171 = (float)(v177 - v61) * (float)(v177 - v61);
              float v56 = v56 + *(float *)&v171;
            }
            sub_24B6EDF80(v52, (uint64_t *)&v178, (float *)&v176, v54, (uint64_t)&v170, v56, 1.0);
            unint64_t v62 = *((void *)&v180 + 1);
            unint64_t v63 = ((char *)memptr[1] - (char *)v53) >> 2;
            if (*((void *)&v180 + 1) <= v63) {
              goto LABEL_56;
            }
            sub_24B6EDC20((uint64_t)memptr, *((void *)&v180 + 1) - v63);
LABEL_58:
            unint64_t v64 = (uint64_t)(*((void *)&v172 + 1) - (void)v51) >> 2;
            if (v62 <= v64)
            {
              if (v62 < v64) {
                *((void *)&v172 + 1) = &v51[v62];
              }
            }
            else
            {
              sub_24B6EDDD0((uint64_t)&v172, v62 - v64);
            }
            if (memptr[0] == memptr[1] || *(float *)v172 > v45) {
              goto LABEL_33;
            }
            uint64_t v65 = v19;
            unint64_t v66 = *(unsigned int *)memptr[0] | (unint64_t)(v46 << 32);
            if (v148 >= v147)
            {
              uint64_t v67 = (v148 - v48) >> 3;
              unint64_t v68 = v67 + 1;
              if ((unint64_t)(v67 + 1) >> 61) {
                goto LABEL_148;
              }
              if ((v147 - v48) >> 2 > v68) {
                unint64_t v68 = (v147 - v48) >> 2;
              }
              if ((unint64_t)(v147 - v48) >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v69 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v69 = v68;
              }
              if (v69)
              {
                if (v69 >> 61) {
                  sub_24B6BCD7C();
                }
                int v70 = operator new(8 * v69);
              }
              else
              {
                int v70 = 0;
              }
              unint64_t v71 = &v70[8 * v67];
              *(void *)unint64_t v71 = v66;
              float32x4_t v72 = v71 + 8;
              if (v148 == v48)
              {
                unint64_t v19 = v65;
                unint64_t v49 = v146;
              }
              else
              {
                unint64_t v73 = v148 - 8 - v48;
                unint64_t v19 = v65;
                if (v73 < 0x168)
                {
                  unint64_t v74 = v148;
                  unint64_t v49 = v146;
                  goto LABEL_83;
                }
                if (&v70[v148 - v48 - 8 - (v73 & 0xFFFFFFFFFFFFFFF8)] > &v70[v148 - v48 - 8]
                  || &v148[-(v73 & 0xFFFFFFFFFFFFFFF8) - 8] > v148 - 8
                  || (unint64_t)(v48 - v70) < 0x20)
                {
                  unint64_t v74 = v148;
                  unint64_t v49 = v146;
                  goto LABEL_83;
                }
                uint64_t v76 = (v73 >> 3) + 1;
                unint64_t v74 = &v148[-8 * (v76 & 0x3FFFFFFFFFFFFFFCLL)];
                unint64_t v77 = &v70[8 * v67 - 16];
                unint64_t v78 = v148 - 16;
                uint64_t v79 = v76 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v80 = *(_OWORD *)v78;
                  *(v77 - 1) = *((_OWORD *)v78 - 1);
                  *unint64_t v77 = v80;
                  v77 -= 2;
                  v78 -= 32;
                  v79 -= 4;
                }
                while (v79);
                v71 -= 8 * (v76 & 0x3FFFFFFFFFFFFFFCLL);
                unint64_t v49 = v146;
                if (v76 != (v76 & 0x3FFFFFFFFFFFFFFCLL))
                {
                  do
                  {
LABEL_83:
                    uint64_t v75 = *((void *)v74 - 1);
                    v74 -= 8;
                    *((void *)v71 - 1) = v75;
                    v71 -= 8;
                  }
                  while (v74 != v48);
                }
              }
              size_t v147 = &v70[8 * v69];
              if (v48) {
                operator delete(v48);
              }
              float v148 = v72;
              uint64_t v48 = v71;
              goto LABEL_33;
            }
            *(void *)float v148 = v66;
            v148 += 8;
            unint64_t v19 = v65;
LABEL_33:
            uint64_t v46 = ++v47;
            if (v49 <= v47)
            {
              BOOL v81 = v48 != v148;
              uint64x2_t v26 = v144;
              unsigned int v29 = v142;
              unint64_t v44 = v145;
              if (v48 != v148)
              {
                unint64_t v82 = (v148 - v48) >> 3;
                int v160 = v82;
                uint64_t v83 = ((unint64_t)(v148 - v48) >> 3);
                if (v82)
                {
                  size_t v84 = (3 * v82);
                  uint64_t v85 = 4 * v84;
                  if (v159 < v84)
                  {
                    free(v158);
                    size_t v86 = (v85 + 31) & 0x7FFFFFFE0;
                    uint64_t v158 = 0;
                    size_t v159 = v86 >> 2;
                    uint64_t v178 = 0;
                    malloc_type_posix_memalign(&v178, 0x20uLL, v86, 0x49090899uLL);
                    uint64_t v158 = v178;
                  }
                  int v163 = v82;
                  if (v162 < v84)
                  {
                    free(v161);
                    size_t v87 = (v85 + 31) & 0x7FFFFFFE0;
                    uint64_t v161 = 0;
                    size_t v162 = v87 >> 2;
                    uint64_t v178 = 0;
                    malloc_type_posix_memalign(&v178, 0x20uLL, v87, 0x49090899uLL);
                    uint64_t v161 = v178;
                  }
                  int v166 = v82;
                  if (v165 < v84)
                  {
                    free(v164);
                    size_t v88 = (v85 + 31) & 0x7FFFFFFE0;
                    uint64_t v164 = 0;
                    size_t v165 = v88 >> 2;
                    uint64_t v178 = 0;
                    malloc_type_posix_memalign(&v178, 0x20uLL, v88, 0x49090899uLL);
                    uint64_t v164 = v178;
                  }
                  int v169 = v82;
                  if (v168 < v84)
                  {
                    free(v167);
                    size_t v89 = (v85 + 31) & 0x7FFFFFFE0;
                    uint64_t v167 = 0;
                    size_t v168 = v89 >> 2;
                    uint64_t v178 = 0;
                    malloc_type_posix_memalign(&v178, 0x20uLL, v89, 0x49090899uLL);
                    uint64_t v167 = v178;
                  }
                  uint64_t v178 = 0;
                  malloc_type_posix_memalign(&v178, 0x20uLL, (4 * v83 + 31) & 0x7FFFFFFE0, 0x49090899uLL);
                  unint64_t v91 = (float *)v178;
                  uint64_t v92 = (char *)v167;
                }
                else
                {
                  free(v158);
                  uint64_t v158 = 0;
                  size_t v159 = 0;
                  int v163 = 0;
                  free(v161);
                  uint64_t v161 = 0;
                  size_t v162 = 0;
                  int v166 = 0;
                  free(v164);
                  uint64_t v164 = 0;
                  size_t v165 = 0;
                  int v169 = 0;
                  free(v167);
                  uint64_t v92 = 0;
                  unint64_t v91 = 0;
                  uint64_t v167 = 0;
                  size_t v168 = 0;
                }
                unsigned int v94 = 0;
                uint64_t v95 = 0;
                int v96 = (char *)v158;
                uint64_t v97 = (char *)v161;
                uint64_t v98 = (unsigned int *)(v48 + 4);
                uint64_t v99 = (char *)v164;
                do
                {
                  uint64_t v100 = v141 + 48 * *(v98 - 1);
                  float v101 = *(float *)v100;
                  float v102 = *(float *)(v100 + 4);
                  uint64_t v103 = (float *)&v19[48 * *v98];
                  float v104 = *v103;
                  float v105 = v103[1];
                  float v106 = *(float *)(v100 + 8);
                  float v107 = v103[2];
                  v91[v95] = sqrtf((float)((float)(v106 - v107) * (float)(v106 - v107))+ (float)((float)((float)(*(float *)v100 - *v103) * (float)(*(float *)v100 - *v103))+ (float)((float)(v102 - v105) * (float)(v102 - v105))));
                  uint64_t v108 = 4 * v94;
                  uint64_t v109 = (float *)&v96[v108];
                  float *v109 = v101;
                  v109[1] = v102;
                  v109[2] = v106;
                  uint64_t v110 = (float *)&v97[v108];
                  float *v110 = v104;
                  v110[1] = v105;
                  v110[2] = v107;
                  uint64_t v111 = &v99[v108];
                  int v112 = *(_DWORD *)(v100 + 24);
                  *(void *)uint64_t v111 = *(void *)(v100 + 16);
                  *((_DWORD *)v111 + 2) = v112;
                  int v113 = *((_DWORD *)v103 + 6);
                  long long v114 = &v92[v108];
                  *(void *)long long v114 = *((void *)v103 + 2);
                  ++v95;
                  v98 += 2;
                  v94 += 3;
                  *((_DWORD *)v114 + 2) = v113;
                }
                while (v82 > v95);
                *(float *)&uint64_t v153 = (float)v82 / v35;
                if (v82)
                {
                  float v115 = *v91;
                  if (v82 != 1)
                  {
                    unint64_t v116 = v91 + 1;
                    uint64_t v117 = 4 * v83 - 4;
                    do
                    {
                      float v118 = *v116++;
                      float v115 = v115 + v118;
                      v117 -= 4;
                    }
                    while (v117);
                  }
                  uint64_t v119 = &v91[v83];
                  *(float *)v90.i32 = v115 / (float)v82;
                  unint64_t v120 = (v83 - 1) & 0x3FFFFFFFFFFFFFFFLL;
                  uint64_t v121 = v91;
                  if (v120 < 7)
                  {
                    do
                    {
LABEL_115:
                      float *v121 = *v121 - *(float *)v90.i32;
                      ++v121;
                    }
                    while (v121 != v119);
                  }
                  else
                  {
                    uint64_t v122 = (v120 + 1) & 0x7FFFFFFFFFFFFFF8;
                    float32x4_t v123 = (float32x4_t)vdupq_lane_s32(v90, 0);
                    uint64_t v124 = (float32x4_t *)(v91 + 4);
                    uint64_t v125 = v122;
                    do
                    {
                      float32x4_t v126 = vsubq_f32(*v124, v123);
                      v124[-1] = vsubq_f32(v124[-1], v123);
                      float32x4_t *v124 = v126;
                      v124 += 2;
                      v125 -= 8;
                    }
                    while (v125);
                    if (v120 + 1 != v122)
                    {
                      uint64_t v121 = &v91[v122];
                      goto LABEL_115;
                    }
                  }
                  float v127 = *v91 * *v91;
                  if (v82 == 1)
                  {
                    BOOL v81 = v48 != v148;
                    goto LABEL_126;
                  }
                  unint64_t v128 = v91 + 1;
                  unint64_t v129 = (v83 + 0x3FFFFFFFFFFFFFFELL) & 0x3FFFFFFFFFFFFFFFLL;
                  if (v129 >= 7)
                  {
                    unint64_t v130 = v129 + 1;
                    uint64_t v131 = (float32x4_t *)(v91 + 5);
                    uint64_t v132 = v130 & 0x7FFFFFFFFFFFFFF8;
                    do
                    {
                      float32x4_t v133 = vmulq_f32(v131[-1], v131[-1]);
                      float32x4_t v134 = vmulq_f32(*v131, *v131);
                      float v127 = (float)((float)((float)((float)((float)((float)((float)(v127 + v133.f32[0]) + v133.f32[1])
                                                                   + v133.f32[2])
                                                           + v133.f32[3])
                                                   + v134.f32[0])
                                           + v134.f32[1])
                                   + v134.f32[2])
                           + v134.f32[3];
                      v131 += 2;
                      v132 -= 8;
                    }
                    while (v132);
                    BOOL v81 = v48 != v148;
                    if (v130 != (v130 & 0x7FFFFFFFFFFFFFF8))
                    {
                      v128 += v130 & 0x7FFFFFFFFFFFFFF8;
                      goto LABEL_125;
                    }
                  }
                  else
                  {
                    BOOL v81 = v48 != v148;
                    do
                    {
LABEL_125:
                      float v135 = *v128++;
                      float v127 = v127 + (float)(v135 * v135);
                    }
                    while (v128 != v119);
                  }
                }
                else
                {
                  float v127 = 0.0;
                  BOOL v81 = v48 != v148;
                }
LABEL_126:
                HIDWORD(v153) = sqrtf(v127);
                free(v91);
              }
              if (v48) {
                operator delete(v48);
              }
              if ((void)v172) {
                operator delete((void *)v172);
              }
              unint64_t v93 = memptr[0];
              uint64x2_t v28 = v143;
LABEL_132:
              if (v93) {
                operator delete(v93);
              }
              if (!v81) {
                goto LABEL_143;
              }
              BOOL v136 = v28[7].i64[0] > v44 && (v28[7].f32[2] > *(float *)&v153 || v28[7].f32[3] < *((float *)&v153 + 1));
              if (!(**(unsigned int (***)(uint64_t, void **, void **, void **, void **, float32x4_t *))v28[8].i64[0])(v28[8].i64[0], &v158, &v164, &v161, &v164, &v154))goto LABEL_143; {
              uint64_t v178 = &v154;
              }
              uint64_t v179 = (uint64_t)&v149;
              sub_24B703600(&v149, (uint64_t)&v178);
              unint64_t v34 = v44 + 1;
              if (!v136)
              {
                free(v167);
                free(v164);
                free(v161);
                free(v158);
                uint64_t v11 = 0;
                float32x4_t v137 = v150;
                float32x4_t *v140 = v149;
                v140[1] = v137;
                float32x4_t v138 = v152;
                v140[2] = v151;
                v140[3] = v138;
LABEL_145:
                if (v19) {
                  operator delete(v19);
                }
                return v11;
              }
              goto LABEL_25;
            }
          }
          unint64_t v62 = 0;
          unint64_t v63 = ((char *)memptr[1] - (char *)v53) >> 2;
LABEL_56:
          if (v63 > v62) {
            memptr[1] = &v53[4 * v62];
          }
          goto LABEL_58;
        }
      }
    }
  }
  return v11;
}

void sub_24B6DE228(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t OCPointCloudCreate(unsigned int a1, uint64_t a2, float32x4_t **a3, float32_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (!a1) {
    goto LABEL_7;
  }
  if (!a2) {
    goto LABEL_7;
  }
  if (a4 <= 0.0) {
    goto LABEL_7;
  }
  float32x4_t v11 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a5, a5.f32[0]), a6, a6.f32[0]), a7, a7.f32[0]);
  float32x4_t v12 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a5, *(float32x2_t *)a5.f32, 1), a6, *(float32x2_t *)a6.f32, 1), a7, *(float32x2_t *)a7.f32, 1);
  float32x4_t v13 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a5, a5, 2), a6, a6, 2), a7, a7, 2);
  float32x4_t v14 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v15 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v17 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v16, vabdq_f32(v12, v14)), (int8x16_t)vcgeq_f32(v16, vabdq_f32(v11, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v16, vabdq_f32(v13, v15)));
  v17.i32[3] = v17.i32[2];
  if ((vminvq_u32(v17) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  float32x4_t v18 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a6, 2);
  float32x4_t v19 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)v18);
  float32x4_t v20 = (float32x4_t)vtrn2q_s32((int32x4_t)a5, (int32x4_t)a6);
  v20.i32[2] = a7.i32[1];
  float32x4_t v21 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)a6);
  uint32x4_t v22 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v21, a6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 1), v20), v18, v19), v14)), (int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v21, a5.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 1),
                                           v20),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a5, 2),
                                         v19),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v21, a7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 1), v20), (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2), v19), v15)));
  v22.i32[3] = v22.i32[2];
  if ((vminvq_u32(v22) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  float32x4_t v23 = vmulq_f32(a5, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a7, (int8x16_t)a7, 0xCuLL), (int8x16_t)a7, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a6, (int32x4_t)a6), (int8x16_t)a6, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a7, (int32x4_t)a7), (int8x16_t)a7, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a6, (int8x16_t)a6, 0xCuLL), (int8x16_t)a6, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a3&& (v27 = (float32x2_t)vdup_n_s32(0x38D1B717u), uint32x2_t v28 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v27, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a8, a8, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(
                                        v27,
                                        vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a5, (int8x16_t)a5, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a6, (int8x16_t)a6, 8uLL))))), (vpmin_u32(v28, v28).u32[0] & 0x80000000) != 0))
  {
    float32x4_t v33 = a5;
    kdebug_trace();
    float32x4_t v30 = (float32x4_t *)sub_24B6DE640(a1);
    if (v30)
    {
      float32x4_t v31 = v30;
      sub_24B6DE818(a1, a2, 0, v30);
      v31[1].f32[0] = a4;
      v31[2] = v33;
      v31[3] = a6;
      v31[4] = a7;
      v31[5] = (float32x4_t)a8;
      *a3 = v31;
      kdebug_trace();
      return 0;
    }
    else
    {
      if (qword_2697D10F8 != -1) {
        dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
      }
      float32x4_t v32 = qword_2697D10F0;
      if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)simd_float4x4 buf = 136315394;
        id v38 = "OCPointCloudCreate";
        __int16 v39 = 1026;
        int v40 = 401;
        _os_log_error_impl(&dword_24B6B9000, v32, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - insufficient memory.", buf, 0x12u);
      }
      kdebug_trace();
      return 4294967293;
    }
  }
  else
  {
LABEL_7:
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    unint64_t v24 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      id v38 = "OCPointCloudCreate";
      __int16 v39 = 1026;
      int v40 = 391;
      _os_log_error_impl(&dword_24B6B9000, v24, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
}

void *sub_24B6DE640(unsigned int a1)
{
  if (qword_2697D1108 != -1) {
    dispatch_once(&qword_2697D1108, &unk_26FE9CB50);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  uint64_t v3 = Instance;
  if (Instance)
  {
    unint64_t v4 = a1;
    unint64_t v5 = (unsigned char *)Instance[12];
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(Instance[14] - (void)v5) >> 4) < v4)
    {
      double v6 = (unsigned char *)Instance[13];
      long long v7 = (char *)operator new(48 * v4);
      long long v8 = &v7[48 * ((v6 - v5) / 48)];
      long long v9 = v8;
      if (v6 != v5)
      {
        uint64_t v10 = &v7[48 * ((v6 - v5) / 48)];
        do
        {
          long long v11 = *((_OWORD *)v6 - 3);
          long long v12 = *((_OWORD *)v6 - 1);
          long long v9 = v10 - 48;
          *((_OWORD *)v10 - 2) = *((_OWORD *)v6 - 2);
          *((_OWORD *)v10 - 1) = v12;
          *((_OWORD *)v10 - 3) = v11;
          v6 -= 48;
          v10 -= 48;
        }
        while (v6 != v5);
      }
      v3[12] = v9;
      v3[13] = v8;
      v3[14] = &v7[48 * v4];
      if (v5) {
        operator delete(v5);
      }
    }
    float32x4_t v13 = (unsigned char *)v3[15];
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v3[17] - (void)v13) >> 2) < v4)
    {
      float32x4_t v14 = (unsigned char *)v3[16];
      float32x4_t v15 = (char *)operator new(20 * v4);
      float32x4_t v16 = &v15[20 * ((v14 - v13) / 20)];
      uint32x4_t v17 = v16;
      if (v14 != v13)
      {
        float32x4_t v18 = &v15[20 * ((v14 - v13) / 20)];
        do
        {
          long long v19 = *(_OWORD *)(v14 - 20);
          uint32x4_t v17 = v18 - 20;
          *((_DWORD *)v18 - 1) = *((_DWORD *)v14 - 1);
          *(_OWORD *)(v18 - 20) = v19;
          v14 -= 20;
          v18 -= 20;
        }
        while (v14 != v13);
      }
      v3[15] = v17;
      v3[16] = v16;
      v3[17] = &v15[20 * v4];
      if (v13) {
        operator delete(v13);
      }
    }
  }
  return v3;
}

void sub_24B6DE818(unsigned int a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = 0;
  uint64_t v8 = a1;
  do
  {
    float32x4_t v10 = *(float32x4_t *)(a2 + 16 * v7);
    if (a3)
    {
      float32x4_t v11 = *(float32x4_t *)(a3 + 16 * v7);
    }
    else
    {
      int32x4_t v12 = (int32x4_t)vmulq_f32(v10, v10);
      v12.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2), vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 1))).u32[0];
      float32x2_t v13 = vrsqrte_f32((float32x2_t)v12.u32[0]);
      float32x2_t v14 = vmul_f32(v13, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v13, v13)));
      float32x4_t v11 = vmulq_n_f32(vnegq_f32(v10), vmul_f32(v14, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v14, v14))).f32[0]);
    }
    v10.i32[3] = 1.0;
    v11.i32[3] = 0;
    float32x4_t v16 = (float32x4_t *)a4[13];
    unint64_t v15 = a4[14];
    if ((unint64_t)v16 >= v15)
    {
      float32x4_t v18 = (float32x4_t *)a4[12];
      unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (v16 - v18) + 1;
      if (v19 > 0x555555555555555) {
        goto LABEL_42;
      }
      unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - (void)v18) >> 4);
      if (2 * v20 > v19) {
        unint64_t v19 = 2 * v20;
      }
      if (v20 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v21 = 0x555555555555555;
      }
      else {
        unint64_t v21 = v19;
      }
      if (v21)
      {
        float32x4_t v37 = v11;
        float32x4_t v38 = v10;
        if (v21 > 0x555555555555555) {
          goto LABEL_43;
        }
        uint32x4_t v22 = (char *)operator new(48 * v21);
        float32x4_t v11 = v37;
        float32x4_t v10 = v38;
      }
      else
      {
        uint32x4_t v22 = 0;
      }
      float32x4_t v23 = (float32x4_t *)&v22[16 * (v16 - v18)];
      *float32x4_t v23 = v10;
      v23[1] = v11;
      v23[2] = (float32x4_t)xmmword_24B72A590;
      unint64_t v24 = v23;
      if (v16 != v18)
      {
        do
        {
          float32x4_t v25 = v16[-3];
          float32x4_t v26 = v16[-1];
          v24[-2] = v16[-2];
          v24[-1] = v26;
          v24[-3] = v25;
          v24 -= 3;
          v16 -= 3;
        }
        while (v16 != v18);
        float32x4_t v16 = (float32x4_t *)a4[12];
      }
      f32 = (_OWORD *)v23[3].f32;
      a4[12] = v24;
      a4[13] = v23 + 3;
      a4[14] = &v22[48 * v21];
      if (v16) {
        operator delete(v16);
      }
    }
    else
    {
      float32x4_t *v16 = v10;
      v16[1] = v11;
      f32 = (_OWORD *)v16[3].f32;
      void v16[2] = (float32x4_t)xmmword_24B72A590;
    }
    a4[13] = f32;
    uint32x2_t v28 = (char *)a4[16];
    unint64_t v27 = a4[17];
    if ((unint64_t)v28 < v27)
    {
      *((_DWORD *)v28 + 4) = 0;
      *(_OWORD *)uint32x2_t v28 = xmmword_24B72AAF4;
      long long v9 = v28 + 20;
    }
    else
    {
      unsigned int v29 = (unsigned char *)a4[15];
      unint64_t v30 = 0xCCCCCCCCCCCCCCCDLL * ((v28 - v29) >> 2) + 1;
      if (v30 > 0xCCCCCCCCCCCCCCCLL) {
LABEL_42:
      }
        abort();
      unint64_t v31 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v27 - (void)v29) >> 2);
      if (2 * v31 > v30) {
        unint64_t v30 = 2 * v31;
      }
      if (v31 >= 0x666666666666666) {
        unint64_t v32 = 0xCCCCCCCCCCCCCCCLL;
      }
      else {
        unint64_t v32 = v30;
      }
      if (v32)
      {
        if (v32 > 0xCCCCCCCCCCCCCCCLL) {
LABEL_43:
        }
          sub_24B6BCD7C();
        float32x4_t v33 = (char *)operator new(20 * v32);
      }
      else
      {
        float32x4_t v33 = 0;
      }
      unint64_t v34 = &v33[4 * ((v28 - v29) >> 2)];
      *(_OWORD *)unint64_t v34 = xmmword_24B72AAF4;
      *((_DWORD *)v34 + 4) = 0;
      float v35 = v34;
      if (v28 != v29)
      {
        do
        {
          long long v36 = *(_OWORD *)(v28 - 20);
          *((_DWORD *)v35 - 1) = *((_DWORD *)v28 - 1);
          *(_OWORD *)(v35 - 20) = v36;
          v35 -= 20;
          v28 -= 20;
        }
        while (v28 != v29);
        uint32x2_t v28 = (char *)a4[15];
      }
      long long v9 = v34 + 20;
      a4[15] = v35;
      a4[16] = v34 + 20;
      a4[17] = &v33[20 * v32];
      if (v28) {
        operator delete(v28);
      }
    }
    a4[16] = v9;
    ++v7;
  }
  while (v7 != v8);
}

uint64_t sub_24B6DEB1C()
{
  qword_2697D1110 = 0;
  *(void *)algn_2697D1118 = "OCPointCloud";
  qword_2697D1120 = (uint64_t)sub_24B6DECA4;
  unk_2697D1128 = 0;
  qword_2697D1138 = 0;
  unk_2697D1140 = 0;
  qword_2697D1130 = (uint64_t)sub_24B6DEC40;
  qword_2697D1148 = (uint64_t)sub_24B6DEBE4;
  qword_2697D1150 = (uint64_t)sub_24B6DEB94;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_2697D1100 = result;
  return result;
}

CFStringRef sub_24B6DEB94(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<OCPointCloud %p [%p]>", a1, v3);
}

CFStringRef sub_24B6DEBE4(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, @"<OCPointCloud %p [%p]>", a1, v5);
}

double sub_24B6DEC40(uint64_t a1)
{
  if (a1)
  {
    CFAllocatorRef v2 = *(void **)(a1 + 96);
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 96) = 0;
    if (v2) {
      operator delete(v2);
    }
    CFAllocatorRef v3 = *(void **)(a1 + 120);
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    *(void *)(a1 + 120) = 0;
    if (v3) {
      operator delete(v3);
    }
    double result = 0.0;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
  }
  return result;
}

double sub_24B6DECA4(_OWORD *a1)
{
  double result = 0.0;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

uint64_t sub_24B6DECBC()
{
  qword_2697D10F0 = (uint64_t)os_log_create("com.apple.CoreOCModules", "VoxelHashing");
  return MEMORY[0x270F9A758]();
}

uint64_t OCPointCloudCreateWithRGB(unsigned int a1, uint64_t a2, uint64_t a3, __CVBuffer *a4, float32x4_t **a5, float32_t a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, int8x16_t a10)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  if (a6 <= 0.0 || a1 == 0 || a2 == 0 || a3 == 0 || a4 == 0) {
    goto LABEL_22;
  }
  float32x4_t v16 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a7, a7.f32[0]), a8, a8.f32[0]), a9, a9.f32[0]);
  float32x4_t v17 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a7, *(float32x2_t *)a7.f32, 1), a8, *(float32x2_t *)a8.f32, 1), a9, *(float32x2_t *)a9.f32, 1);
  float32x4_t v18 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a7, a7, 2), a8, a8, 2), a9, a9, 2);
  float32x4_t v19 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v20 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v21 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v22 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v21, vabdq_f32(v17, v19)), (int8x16_t)vcgeq_f32(v21, vabdq_f32(v16, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v21, vabdq_f32(v18, v20)));
  v22.i32[3] = v22.i32[2];
  if ((vminvq_u32(v22) & 0x80000000) == 0) {
    goto LABEL_22;
  }
  float32x4_t v23 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a8, 2);
  float32x4_t v24 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a7, (int32x4_t)a9), (int32x4_t)v23);
  float32x4_t v25 = (float32x4_t)vtrn2q_s32((int32x4_t)a7, (int32x4_t)a8);
  v25.i32[2] = a9.i32[1];
  float32x4_t v26 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a7, (int32x4_t)a9), (int32x4_t)a8);
  uint32x4_t v27 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v21, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v26, a8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a8.f32, 1), v25), v23, v24), v19)), (int8x16_t)vcgeq_f32(v21, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v26, a7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 1),
                                           v25),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2),
                                         v24),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v21, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v26, a9.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a9.f32, 1), v25), (float32x4_t)vdupq_laneq_s32((int32x4_t)a9, 2), v24), v20)));
  v27.i32[3] = v27.i32[2];
  if ((vminvq_u32(v27) & 0x80000000) == 0) {
    goto LABEL_22;
  }
  float32x4_t v28 = vmulq_f32(a7, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a9, (int8x16_t)a9, 0xCuLL), (int8x16_t)a9, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a8, (int32x4_t)a8), (int8x16_t)a8, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a9, (int32x4_t)a9), (int8x16_t)a9, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a8, (int8x16_t)a8, 0xCuLL), (int8x16_t)a8, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a5&& (float32x2_t v30 = (float32x2_t)vdup_n_s32(0x38D1B717u), v31 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v30, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a9, (int8x16_t)a9, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a10, a10, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(
                                        v30,
                                        vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a8, (int8x16_t)a8, 8uLL))))), (vpmin_u32(v31, v31).u32[0] & 0x80000000) != 0))
  {
    float32x4_t v42 = a7;
    kdebug_trace();
    long long v36 = (float32x4_t *)sub_24B6DE640(a1);
    if (v36)
    {
      float32x4_t v37 = v36;
      if (sub_24B6DF1E4(a1, a2, 0, a3, a4, v36))
      {
        v37[1].f32[0] = a6;
        v37[2] = v42;
        v37[3] = a8;
        v37[4] = a9;
        v37[5] = (float32x4_t)a10;
        *a5 = v37;
        kdebug_trace();
        return 0;
      }
      else
      {
        if (qword_2697D10F8 != -1) {
          dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
        }
        uint64_t v41 = qword_2697D10F0;
        if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)simd_float4x4 buf = 136315394;
          unsigned int v47 = "OCPointCloudCreateWithRGB";
          __int16 v48 = 1026;
          int v49 = 471;
          _os_log_error_impl(&dword_24B6B9000, v41, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - no points with valid pixel coords.", buf, 0x12u);
        }
        CFRelease(v37);
        kdebug_trace();
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      if (qword_2697D10F8 != -1) {
        dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
      }
      int v40 = qword_2697D10F0;
      if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)simd_float4x4 buf = 136315394;
        unsigned int v47 = "OCPointCloudCreateWithRGB";
        __int16 v48 = 1026;
        int v49 = 450;
        _os_log_error_impl(&dword_24B6B9000, v40, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - insufficient memory.", buf, 0x12u);
      }
      kdebug_trace();
      return 4294967293;
    }
  }
  else
  {
LABEL_22:
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    __int16 v39 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      unsigned int v47 = "OCPointCloudCreateWithRGB";
      __int16 v48 = 1026;
      int v49 = 440;
      _os_log_error_impl(&dword_24B6B9000, v39, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
}

BOOL sub_24B6DF1E4(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, CVPixelBufferRef pixelBuffer, void *a6)
{
  long long v9 = pixelBuffer;
  uint64_t v13 = 0;
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v14 = a1;
  do
  {
    float32x4_t v16 = *(float32x4_t *)(a2 + 16 * v13);
    if (a3)
    {
      float32x4_t v17 = *(float32x4_t *)(a3 + 16 * v13);
    }
    else
    {
      int32x4_t v18 = (int32x4_t)vmulq_f32(v16, v16);
      v18.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v18, 2), vadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v18.i8, 1))).u32[0];
      float32x2_t v19 = vrsqrte_f32((float32x2_t)v18.u32[0]);
      float32x2_t v20 = vmul_f32(v19, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v19, v19)));
      float32x4_t v17 = vmulq_n_f32(vnegq_f32(v16), vmul_f32(v20, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v20, v20))).f32[0]);
    }
    float32x4_t v21 = (double *)(a4 + 16 * v13);
    LODWORD(v6) = llround(*v21);
    if ((v6 & 0x80000000) == 0)
    {
      LODWORD(v7) = llround(v21[1]);
      if ((v7 & 0x80000000) == 0)
      {
        float32x4_t v47 = v17;
        long long v49 = *(_OWORD *)(a2 + 16 * v13);
        if ((CVPixelBufferGetPixelFormatType(v9) | 0x10) == 0x34323076)
        {
          sub_24B6F68EC((uint64_t)&v51, v9, v6, v7);
          if (v52)
          {
            float32x4_t v23 = v47;
            long long v22 = v49;
            HIDWORD(v22) = 1.0;
            v23.i32[3] = 0;
            long long v24 = v51;
            HIDWORD(v24) = 1.0;
            float32x4_t v26 = (_OWORD *)a6[13];
            unint64_t v25 = a6[14];
            if ((unint64_t)v26 >= v25)
            {
              size_t v7 = a6[12];
              unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v26 - v7) >> 4) + 1;
              if (v28 > 0x555555555555555) {
                goto LABEL_48;
              }
              unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - v7) >> 4);
              if (2 * v29 > v28) {
                unint64_t v28 = 2 * v29;
              }
              if (v29 >= 0x2AAAAAAAAAAAAAALL) {
                unint64_t v30 = 0x555555555555555;
              }
              else {
                unint64_t v30 = v28;
              }
              if (v30)
              {
                long long v45 = v24;
                float32x4_t v48 = v23;
                long long v50 = v22;
                if (v30 > 0x555555555555555) {
                  goto LABEL_49;
                }
                uint32x2_t v31 = (char *)operator new(48 * v30);
                float32x4_t v23 = v48;
                long long v22 = v50;
                long long v24 = v45;
              }
              else
              {
                uint32x2_t v31 = 0;
              }
              unint64_t v32 = &v31[16 * ((uint64_t)((uint64_t)v26 - v7) >> 4)];
              *(_OWORD *)unint64_t v32 = v22;
              *((float32x4_t *)v32 + 1) = v23;
              *((_OWORD *)v32 + 2) = v24;
              float32x4_t v33 = v32;
              if (v26 != (_OWORD *)v7)
              {
                do
                {
                  long long v34 = *(v26 - 3);
                  long long v35 = *(v26 - 1);
                  *((_OWORD *)v33 - 2) = *(v26 - 2);
                  *((_OWORD *)v33 - 1) = v35;
                  *((_OWORD *)v33 - 3) = v34;
                  v33 -= 48;
                  v26 -= 3;
                }
                while (v26 != (_OWORD *)v7);
                float32x4_t v26 = (_OWORD *)a6[12];
              }
              uint32x4_t v27 = v32 + 48;
              a6[12] = v33;
              a6[13] = v32 + 48;
              a6[14] = &v31[48 * v30];
              if (v26) {
                operator delete(v26);
              }
              long long v9 = pixelBuffer;
            }
            else
            {
              _OWORD *v26 = v22;
              v26[1] = v23;
              uint32x4_t v27 = v26 + 3;
              v26[2] = v24;
            }
            a6[13] = v27;
            size_t v6 = a6[16];
            size_t v36 = a6[17];
            if (v6 < v36)
            {
              *(_DWORD *)(v6 + 16) = 0;
              *(_OWORD *)size_t v6 = xmmword_24B72AAF4;
              size_t v15 = v6 + 20;
            }
            else
            {
              size_t v7 = a6[15];
              unint64_t v37 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v6 - v7) >> 2) + 1;
              if (v37 > 0xCCCCCCCCCCCCCCCLL) {
LABEL_48:
              }
                abort();
              unint64_t v38 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v36 - v7) >> 2);
              if (2 * v38 > v37) {
                unint64_t v37 = 2 * v38;
              }
              if (v38 >= 0x666666666666666) {
                unint64_t v39 = 0xCCCCCCCCCCCCCCCLL;
              }
              else {
                unint64_t v39 = v37;
              }
              if (v39)
              {
                if (v39 > 0xCCCCCCCCCCCCCCCLL) {
LABEL_49:
                }
                  sub_24B6BCD7C();
                int v40 = (char *)operator new(20 * v39);
              }
              else
              {
                int v40 = 0;
              }
              uint64_t v41 = &v40[4 * ((uint64_t)(v6 - v7) >> 2)];
              *(_OWORD *)uint64_t v41 = xmmword_24B72AAF4;
              *((_DWORD *)v41 + 4) = 0;
              float32x4_t v42 = v41;
              if (v6 != v7)
              {
                do
                {
                  long long v43 = *(_OWORD *)(v6 - 20);
                  *((_DWORD *)v42 - 1) = *(_DWORD *)(v6 - 4);
                  *(_OWORD *)(v42 - 20) = v43;
                  v42 -= 20;
                  v6 -= 20;
                }
                while (v6 != v7);
                size_t v6 = a6[15];
              }
              size_t v15 = (size_t)(v41 + 20);
              a6[15] = v42;
              a6[16] = v41 + 20;
              a6[17] = &v40[20 * v39];
              if (v6) {
                operator delete((void *)v6);
              }
              long long v9 = pixelBuffer;
            }
            a6[16] = v15;
          }
        }
      }
    }
    ++v13;
  }
  while (v13 != v14);
  return a6[12] != a6[13];
}

void OCPointCloudRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t OCPointCloudCreateWithRGBAndPlaneClassification(size_t a1, uint64_t a2, uint64_t a3, __CVBuffer *a4, size_t a5, float32x4_t **a6, float32_t a7, float32x4_t a8, float32x4_t a9, float32x4_t a10, int8x16_t a11, uint64_t a12, uint64_t a13, double a14, double a15, double a16, float32x4_t a17, float32x4_t a18, float32x4_t a19, float32x4_t a20,float a21)
{
  uint64_t v144 = *MEMORY[0x263EF8340];
  if (a7 <= 0.0 || a1 == 0 || a2 == 0 || a3 == 0 || a4 == 0) {
    goto LABEL_22;
  }
  float32x4_t v26 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a8, a8.f32[0]), a9, a9.f32[0]), a10, a10.f32[0]);
  float32x4_t v27 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a8, *(float32x2_t *)a8.f32, 1), a9, *(float32x2_t *)a9.f32, 1), a10, *(float32x2_t *)a10.f32, 1);
  float32x4_t v28 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a8, a8, 2), a9, a9, 2), a10, a10, 2);
  float32x4_t v30 = *(float32x4_t *)MEMORY[0x263EF89A0];
  float32x4_t v29 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v31 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v32 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v33 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v32, vabdq_f32(v27, v29)), (int8x16_t)vcgeq_f32(v32, vabdq_f32(v26, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v32, vabdq_f32(v28, v31)));
  v33.i32[3] = v33.i32[2];
  if ((vminvq_u32(v33) & 0x80000000) == 0) {
    goto LABEL_22;
  }
  float32x4_t v34 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a9, 2);
  float32x4_t v35 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a8, (int32x4_t)a10), (int32x4_t)v34);
  float32x4_t v36 = (float32x4_t)vtrn2q_s32((int32x4_t)a8, (int32x4_t)a9);
  v36.i32[2] = a10.i32[1];
  float32x4_t v37 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a8, (int32x4_t)a10), (int32x4_t)a9);
  uint32x4_t v38 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v32, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v37, a9.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a9.f32, 1), v36), v34, v35), v29)), (int8x16_t)vcgeq_f32(v32, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v37, a8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a8.f32, 1),
                                           v36),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a8, 2),
                                         v35),
                                       v30))),
                      (int8x16_t)vcgeq_f32(v32, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v37, a10.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a10.f32, 1), v36), (float32x4_t)vdupq_laneq_s32((int32x4_t)a10, 2), v35), v31)));
  v38.i32[3] = v38.i32[2];
  if ((vminvq_u32(v38) & 0x80000000) == 0) {
    goto LABEL_22;
  }
  float32x4_t v39 = vmulq_f32(a8, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a10, (int8x16_t)a10, 0xCuLL), (int8x16_t)a10, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a9, (int32x4_t)a9), (int8x16_t)a9, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a10, (int32x4_t)a10), (int8x16_t)a10, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a9, (int8x16_t)a9, 0xCuLL), (int8x16_t)a9, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0]+ -1.0) > 0.000011)goto LABEL_22; {
  size_t v40 = a5;
  }
  if (!a5) {
    goto LABEL_22;
  }
  float32x2_t v41 = (float32x2_t)vdup_n_s32(0x38D1B717u);
  uint32x2_t v42 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v41, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a10, (int8x16_t)a10, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a11, a11, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v41, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a8, (int8x16_t)a8, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                   (int8x16_t)a9,
                                                                                   (int8x16_t)a9,
                                                                                   8uLL)))));
  if ((vpmin_u32(v42, v42).u32[0] & 0x80000000) == 0) {
    goto LABEL_22;
  }
  float32x4_t v43 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v44 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v43, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a17, *(float32x2_t *)a17.f32, 1), a18, *(float32x2_t *)a18.f32, 1), a19, *(float32x2_t *)a19.f32, 1), v29)), (int8x16_t)vcgeq_f32(v43, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a17, a17.f32[0]), a18, a18.f32[0]),
                                         a19,
                                         a19.f32[0]),
                                       v30))),
                      (int8x16_t)vcgeq_f32(v43, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a17, a17, 2), a18, a18, 2), a19, a19, 2), v31)));
  v44.i32[3] = v44.i32[2];
  if ((vminvq_u32(v44) & 0x80000000) == 0) {
    goto LABEL_22;
  }
  float32x4_t v45 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a18, 2);
  float32x4_t v46 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a17, (int32x4_t)a19), (int32x4_t)v45);
  float32x4_t v47 = (float32x4_t)vtrn2q_s32((int32x4_t)a17, (int32x4_t)a18);
  v47.i32[2] = a19.i32[1];
  float32x4_t v48 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a17, (int32x4_t)a19), (int32x4_t)a18);
  uint32x4_t v49 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v43, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v48, a18.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a18.f32, 1), v47), v45, v46), v29)), (int8x16_t)vcgeq_f32(v43, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v48, a17.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a17.f32, 1),
                                           v47),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a17, 2),
                                         v46),
                                       v30))),
                      (int8x16_t)vcgeq_f32(v43, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v48, a19.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a19.f32, 1), v47), (float32x4_t)vdupq_laneq_s32((int32x4_t)a19, 2), v46), v31)));
  v49.i32[3] = v49.i32[2];
  if ((vminvq_u32(v49) & 0x80000000) == 0) {
    goto LABEL_22;
  }
  float32x4_t v50 = vmulq_f32(a17, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a19, (int8x16_t)a19, 0xCuLL), (int8x16_t)a19, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a18, (int32x4_t)a18), (int8x16_t)a18, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a19, (int32x4_t)a19), (int8x16_t)a19, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a18, (int8x16_t)a18, 0xCuLL), (int8x16_t)a18, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a6&& a21 >= 0.0&& (float32x2_t v55 = (float32x2_t)vdup_n_s32(0x38D1B717u), v56 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v55, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a19, (int8x16_t)a19, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a20,
                                                                                    (int8x16_t)a20,
                                                                                    8uLL)),
                                            (float32x2_t)0xBF80000080000000))),
                            (int8x8_t)vcge_f32(v55, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a17, (int8x16_t)a17, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a18, (int8x16_t)a18, 8uLL))))), (vpmin_u32(v56, v56).u32[0] & 0x80000000) != 0))
  {
    size_t v60 = a1;
    float32x4_t v138 = a8;
    float32x4_t v140 = a10;
    int8x16_t v141 = a11;
    kdebug_trace();
    float v61 = (float32x4_t *)sub_24B6DE640(v60);
    if (v61)
    {
      unint64_t v62 = v61;
      v142[8] = 0;
      *(void *)unsigned int v142 = 0x3F80000000000000;
      uint64_t v63 = *(unsigned int *)(v40 + 104);
      uint64_t v131 = v61;
      if (v63)
      {
        unint64_t v64 = 0;
        uint64_t v65 = 0;
        unint64_t v66 = 0;
        uint64_t v67 = 0;
        uint64_t v136 = *(void *)(v40 + 96);
        float32x4_t v69 = v140;
        int8x16_t v68 = v141;
        float32x4_t v71 = v138;
        float32x4_t v70 = a9;
        uint64_t v129 = *(unsigned int *)(v40 + 104);
        do
        {
          if (v66 < v64)
          {
            *(_OWORD *)unint64_t v66 = *(_OWORD *)(v136 + 16 * v67);
            float32x4_t v72 = v66 + 16;
          }
          else
          {
            unint64_t v73 = v65;
            uint64_t v74 = (v66 - v65) >> 4;
            unint64_t v75 = v74 + 1;
            if ((unint64_t)(v74 + 1) >> 60) {
              abort();
            }
            std::string __p = v73;
            unint64_t v76 = v64 - v73;
            unint64_t v77 = (v64 - v73) >> 3;
            if (v77 > v75) {
              unint64_t v75 = v77;
            }
            BOOL v78 = v76 >= 0x7FFFFFFFFFFFFFF0;
            unint64_t v79 = 0xFFFFFFFFFFFFFFFLL;
            if (!v78) {
              unint64_t v79 = v75;
            }
            unint64_t v132 = v79;
            if (v79)
            {
              if (v79 >> 60) {
                sub_24B6BCD7C();
              }
              long long v80 = (char *)operator new(16 * v79);
              float32x4_t v69 = v140;
              int8x16_t v68 = v141;
              float32x4_t v71 = v138;
              float32x4_t v70 = a9;
            }
            else
            {
              long long v80 = 0;
            }
            BOOL v81 = &v80[16 * v74];
            *(_OWORD *)BOOL v81 = *(_OWORD *)(v136 + 16 * v67);
            float32x4_t v72 = v81 + 16;
            if (v66 == __p)
            {
              unint64_t v82 = v132;
            }
            else
            {
              unint64_t v82 = v132;
              do
              {
                long long v83 = *((_OWORD *)v66 - 1);
                v66 -= 16;
                *((_OWORD *)v81 - 1) = v83;
                v81 -= 16;
              }
              while (v66 != __p);
            }
            unint64_t v64 = &v80[16 * v82];
            if (__p)
            {
              size_t v84 = &v80[16 * v82];
              operator delete(__p);
              unint64_t v64 = v84;
              float32x4_t v71 = v138;
              float32x4_t v70 = a9;
              float32x4_t v69 = v140;
              int8x16_t v68 = v141;
            }
            uint64_t v65 = v81;
            uint64_t v63 = v129;
            unint64_t v62 = v131;
          }
          ++v67;
          unint64_t v66 = v72;
        }
        while (v67 != v63);
      }
      else
      {
        uint64_t v65 = 0;
        float32x4_t v69 = v140;
        int8x16_t v68 = v141;
        float32x4_t v71 = v138;
        float32x4_t v70 = a9;
      }
      __pa = v65;
      uint64_t v86 = 0;
      float32x4_t v87 = *(float32x4_t *)(v40 + 48);
      float32x4_t v88 = *(float32x4_t *)(v40 + 16);
      float32x4_t v89 = *(float32x4_t *)(v40 + 32);
      float32x4_t v90 = vmlaq_f32(vmlaq_f32(vaddq_f32(v88, vmulq_f32(*(float32x4_t *)v40, (float32x4_t)0)), (float32x4_t)0, v89), (float32x4_t)0, v87);
      float32x4_t v91 = vmulq_f32(v90, vaddq_f32(v87, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)v40, COERCE_FLOAT(*(_OWORD *)(v40 + 64))), v88, *(float32x2_t *)(v40 + 64), 1), v89, *(float32x4_t *)(v40 + 64), 2)));
      uint64_t v92 = v60;
      v90.i32[3] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 2), vaddq_f32(v91, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v91.f32, 1))).u32[0];
      float32x4_t v133 = v90;
      uint64_t v130 = v60;
      do
      {
        unint64_t v93 = (double *)(a3 + 16 * v86);
        LODWORD(v60) = llround(*v93);
        if ((v60 & 0x80000000) == 0)
        {
          LODWORD(v40) = llround(v93[1]);
          if ((v40 & 0x80000000) == 0)
          {
            float32x4_t v137 = *(float32x4_t *)(a2 + 16 * v86);
            if ((CVPixelBufferGetPixelFormatType(a4) | 0x10) == 0x34323076
              && (sub_24B6F68EC((uint64_t)buf, a4, v60, v40), buf[16]))
            {
              float32x4_t v94 = v137;
              v94.i32[3] = 1.0;
              int32x4_t v95 = (int32x4_t)vmulq_f32(v137, v137);
              v95.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v95, 2), vadd_f32(*(float32x2_t *)v95.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v95.i8, 1))).u32[0];
              float32x2_t v96 = vrsqrte_f32((float32x2_t)v95.u32[0]);
              float32x2_t v97 = vmul_f32(v96, vrsqrts_f32((float32x2_t)v95.u32[0], vmul_f32(v96, v96)));
              float32x4_t v98 = vmulq_n_f32(vnegq_f32(v137), vmul_f32(v97, vrsqrts_f32((float32x2_t)v95.u32[0], vmul_f32(v97, v97))).f32[0]);
              v98.i32[3] = 0;
              float32x4_t v99 = *(float32x4_t *)buf;
              v99.i32[3] = 1.0;
              float v101 = (float32x4_t *)v62[6].i64[1];
              unint64_t v100 = v62[7].u64[0];
              if ((unint64_t)v101 >= v100)
              {
                uint64_t v103 = (float32x4_t *)v62[6].i64[0];
                unint64_t v104 = 0xAAAAAAAAAAAAAAABLL * (v101 - v103) + 1;
                if (v104 > 0x555555555555555) {
                  abort();
                }
                unint64_t v105 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v100 - (void)v103) >> 4);
                if (2 * v105 > v104) {
                  unint64_t v104 = 2 * v105;
                }
                if (v105 >= 0x2AAAAAAAAAAAAAALL) {
                  size_t v40 = 0x555555555555555;
                }
                else {
                  size_t v40 = v104;
                }
                if (v40)
                {
                  float32x4_t v126 = v98;
                  float32x4_t v127 = v99;
                  float32x4_t v128 = v94;
                  if (v40 > 0x555555555555555) {
                    sub_24B6BCD7C();
                  }
                  float v106 = (char *)operator new(48 * v40);
                  float32x4_t v99 = v127;
                  float32x4_t v94 = v128;
                  float32x4_t v98 = v126;
                }
                else
                {
                  float v106 = 0;
                }
                float v107 = (float32x4_t *)&v106[16 * (v101 - v103)];
                *float v107 = v94;
                v107[1] = v98;
                v107[2] = v99;
                uint64_t v108 = v107;
                if (v101 == v103)
                {
                  unint64_t v62 = v131;
                }
                else
                {
                  unint64_t v62 = v131;
                  do
                  {
                    float32x4_t v109 = v101[-3];
                    float32x4_t v110 = v101[-1];
                    v108[-2] = v101[-2];
                    v108[-1] = v110;
                    v108[-3] = v109;
                    v108 -= 3;
                    v101 -= 3;
                  }
                  while (v101 != v103);
                  float v101 = (float32x4_t *)v131[6].i64[0];
                }
                f32 = (_OWORD *)v107[3].f32;
                v62[6].i64[0] = (uint64_t)v108;
                v62[6].i64[1] = (uint64_t)&v107[3];
                v62[7].i64[0] = (uint64_t)&v106[48 * v40];
                if (v101) {
                  operator delete(v101);
                }
              }
              else
              {
                float32x4_t *v101 = v94;
                v101[1] = v98;
                f32 = (_OWORD *)v101[3].f32;
                v101[2] = v99;
              }
              float32x4_t v69 = v140;
              int8x16_t v68 = v141;
              float32x4_t v71 = v138;
              float32x4_t v70 = a9;
              float32x4_t v111 = vaddq_f32(a20, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a17, v137.f32[0]), a18, *(float32x2_t *)v137.f32, 1), a19, v137, 2));
              v111.i32[3] = -1.0;
              int8x16_t v112 = (int8x16_t)vmulq_f32(v133, v111);
              BOOL v113 = vaddv_f32(vadd_f32(*(float32x2_t *)v112.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v112, v112, 8uLL))) >= a21;
              v62[6].i64[1] = (uint64_t)f32;
              size_t v60 = v62[8].u64[0];
              size_t v114 = v62[8].u64[1];
              if (v60 >= v114)
              {
                uint64_t v116 = v62[7].i64[1];
                unint64_t v117 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v60 - v116) >> 2) + 1;
                if (v117 > 0xCCCCCCCCCCCCCCCLL) {
                  abort();
                }
                unint64_t v118 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v114 - v116) >> 2);
                if (2 * v118 > v117) {
                  unint64_t v117 = 2 * v118;
                }
                if (v118 >= 0x666666666666666) {
                  size_t v40 = 0xCCCCCCCCCCCCCCCLL;
                }
                else {
                  size_t v40 = v117;
                }
                if (v40)
                {
                  if (v40 > 0xCCCCCCCCCCCCCCCLL) {
                    sub_24B6BCD7C();
                  }
                  uint64_t v119 = (char *)operator new(20 * v40);
                  float32x4_t v69 = v140;
                  int8x16_t v68 = v141;
                  float32x4_t v71 = v138;
                  float32x4_t v70 = a9;
                }
                else
                {
                  uint64_t v119 = 0;
                }
                unint64_t v120 = &v119[4 * ((uint64_t)(v60 - v116) >> 2)];
                *(void *)unint64_t v120 = 0x3F8000003F800000;
                v120[8] = v113;
                *(void *)(v120 + 9) = *(void *)&v142[1];
                *((_DWORD *)v120 + 4) = 0;
                uint64_t v121 = v120;
                if (v60 == v116)
                {
                  unint64_t v62 = v131;
                }
                else
                {
                  unint64_t v62 = v131;
                  do
                  {
                    long long v122 = *(_OWORD *)(v60 - 20);
                    *((_DWORD *)v121 - 1) = *(_DWORD *)(v60 - 4);
                    *(_OWORD *)(v121 - 20) = v122;
                    v121 -= 20;
                    v60 -= 20;
                  }
                  while (v60 != v116);
                  size_t v60 = v131[7].u64[1];
                }
                size_t v115 = (size_t)(v120 + 20);
                v62[7].i64[1] = (uint64_t)v121;
                v62[8].i64[0] = (uint64_t)(v120 + 20);
                v62[8].i64[1] = (uint64_t)&v119[20 * v40];
                if (v60)
                {
                  operator delete((void *)v60);
                  float32x4_t v71 = v138;
                  float32x4_t v70 = a9;
                  float32x4_t v69 = v140;
                  int8x16_t v68 = v141;
                }
              }
              else
              {
                *(void *)size_t v60 = 0x3F8000003F800000;
                *(unsigned char *)(v60 + 8) = v113;
                *(void *)(v60 + 9) = *(void *)&v142[1];
                *(_DWORD *)(v60 + 16) = 0;
                size_t v115 = v60 + 20;
              }
              v62[8].i64[0] = v115;
              uint64_t v92 = v130;
            }
            else
            {
              float32x4_t v69 = v140;
              int8x16_t v68 = v141;
              float32x4_t v71 = v138;
              float32x4_t v70 = a9;
            }
          }
        }
        ++v86;
      }
      while (v86 != v92);
      uint64_t v123 = v62[6].i64[0];
      uint64_t v124 = v62[6].i64[1];
      if (__pa)
      {
        operator delete(__pa);
        float32x4_t v71 = v138;
        float32x4_t v70 = a9;
        float32x4_t v69 = v140;
        int8x16_t v68 = v141;
      }
      if (v123 == v124)
      {
        if (qword_2697D10F8 != -1) {
          dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
        }
        uint64_t v125 = qword_2697D10F0;
        if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)simd_float4x4 buf = 136315394;
          *(void *)&uint8_t buf[4] = "OCPointCloudCreateWithRGBAndPlaneClassification";
          *(_WORD *)&unsigned char buf[12] = 1026;
          *(_DWORD *)&buf[14] = 534;
          _os_log_error_impl(&dword_24B6B9000, v125, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - no points above plane with valid pixel coords.", buf, 0x12u);
        }
        CFRelease(v62);
        uint64_t v52 = 0xFFFFFFFFLL;
      }
      else
      {
        uint64_t v52 = 0;
        v62[1].f32[0] = a7;
        v62[2] = v71;
        v62[3] = v70;
        v62[4] = v69;
        v62[5] = (float32x4_t)v68;
        *a6 = v62;
      }
      kdebug_trace();
    }
    else
    {
      if (qword_2697D10F8 != -1) {
        dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
      }
      uint64_t v85 = qword_2697D10F0;
      if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = "OCPointCloudCreateWithRGBAndPlaneClassification";
        *(_WORD *)&unsigned char buf[12] = 1026;
        *(_DWORD *)&buf[14] = 513;
        _os_log_error_impl(&dword_24B6B9000, v85, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - insufficient memory.", buf, 0x12u);
      }
      kdebug_trace();
      return 4294967293;
    }
  }
  else
  {
LABEL_22:
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    long long v51 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = "OCPointCloudCreateWithRGBAndPlaneClassification";
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = 503;
      _os_log_error_impl(&dword_24B6B9000, v51, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
  return v52;
}

void sub_24B6E01D4(_Unwind_Exception *exception_object)
{
}

void sub_24B6E01E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p)
{
  if (!__p) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t OCPointCloudCreateWithNormal(unsigned int a1, uint64_t a2, uint64_t a3, float32x4_t **a4, float32_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8, int8x16_t a9)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (a5 <= 0.0 || a1 == 0 || a2 == 0 || a3 == 0) {
    goto LABEL_18;
  }
  float32x4_t v14 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a6, a6.f32[0]), a7, a7.f32[0]), a8, a8.f32[0]);
  float32x4_t v15 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a6, *(float32x2_t *)a6.f32, 1), a7, *(float32x2_t *)a7.f32, 1), a8, *(float32x2_t *)a8.f32, 1);
  float32x4_t v16 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a6, a6, 2), a7, a7, 2), a8, a8, 2);
  float32x4_t v17 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v18 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v20 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v19, vabdq_f32(v15, v17)), (int8x16_t)vcgeq_f32(v19, vabdq_f32(v14, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v19, vabdq_f32(v16, v18)));
  v20.i32[3] = v20.i32[2];
  if ((vminvq_u32(v20) & 0x80000000) == 0) {
    goto LABEL_18;
  }
  float32x4_t v21 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2);
  float32x4_t v22 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a6, (int32x4_t)a8), (int32x4_t)v21);
  float32x4_t v23 = (float32x4_t)vtrn2q_s32((int32x4_t)a6, (int32x4_t)a7);
  v23.i32[2] = a8.i32[1];
  float32x4_t v24 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a6, (int32x4_t)a8), (int32x4_t)a7);
  uint32x4_t v25 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v19, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v24, a7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 1), v23), v21, v22), v17)), (int8x16_t)vcgeq_f32(v19, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v24, a6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 1),
                                           v23),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a6, 2),
                                         v22),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v19, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v24, a8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a8.f32, 1), v23), (float32x4_t)vdupq_laneq_s32((int32x4_t)a8, 2), v22), v18)));
  v25.i32[3] = v25.i32[2];
  if ((vminvq_u32(v25) & 0x80000000) == 0) {
    goto LABEL_18;
  }
  float32x4_t v26 = vmulq_f32(a6, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a8, (int8x16_t)a8, 0xCuLL), (int8x16_t)a8, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a7, (int32x4_t)a7), (int8x16_t)a7, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a8, (int32x4_t)a8), (int8x16_t)a8, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a7, (int8x16_t)a7, 0xCuLL), (int8x16_t)a7, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a4&& (float32x2_t v28 = (float32x2_t)vdup_n_s32(0x38D1B717u), v29 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v28, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a8, (int8x16_t)a8, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a9, a9, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(
                                        v28,
                                        vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a6, (int8x16_t)a6, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL))))), (vpmin_u32(v29, v29).u32[0] & 0x80000000) != 0))
  {
    float32x4_t v38 = a6;
    kdebug_trace();
    uint32x4_t v33 = (float32x4_t *)sub_24B6DE640(a1);
    if (v33)
    {
      float32x4_t v34 = v33;
      sub_24B6DE818(a1, a2, a3, v33);
      v34[1].f32[0] = a5;
      v34[2] = v38;
      v34[3] = a7;
      v34[4] = a8;
      v34[5] = (float32x4_t)a9;
      *a4 = v34;
      kdebug_trace();
      return 0;
    }
    else
    {
      if (qword_2697D10F8 != -1) {
        dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
      }
      float32x4_t v37 = qword_2697D10F0;
      if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)simd_float4x4 buf = 136315394;
        float32x4_t v43 = "OCPointCloudCreateWithNormal";
        __int16 v44 = 1026;
        int v45 = 573;
        _os_log_error_impl(&dword_24B6B9000, v37, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - insufficient memory.", buf, 0x12u);
      }
      kdebug_trace();
      return 4294967293;
    }
  }
  else
  {
LABEL_18:
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    float32x4_t v36 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      float32x4_t v43 = "OCPointCloudCreateWithNormal";
      __int16 v44 = 1026;
      int v45 = 563;
      _os_log_error_impl(&dword_24B6B9000, v36, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
}

uint64_t OCPointCloudCreateWithRGBNormal(unsigned int a1, uint64_t a2, uint64_t a3, __CVBuffer *a4, uint64_t a5, float32x4_t **a6, float32_t a7, float32x4_t a8, float32x4_t a9, float32x4_t a10, int8x16_t a11)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  if (a7 <= 0.0 || a1 == 0 || a2 == 0 || a3 == 0 || a4 == 0 || a5 == 0) {
    goto LABEL_25;
  }
  float32x4_t v18 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a8, a8.f32[0]), a9, a9.f32[0]), a10, a10.f32[0]);
  float32x4_t v19 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a8, *(float32x2_t *)a8.f32, 1), a9, *(float32x2_t *)a9.f32, 1), a10, *(float32x2_t *)a10.f32, 1);
  float32x4_t v20 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a8, a8, 2), a9, a9, 2), a10, a10, 2);
  float32x4_t v21 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v22 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v24 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v23, vabdq_f32(v19, v21)), (int8x16_t)vcgeq_f32(v23, vabdq_f32(v18, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v23, vabdq_f32(v20, v22)));
  v24.i32[3] = v24.i32[2];
  if ((vminvq_u32(v24) & 0x80000000) == 0) {
    goto LABEL_25;
  }
  float32x4_t v25 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a9, 2);
  float32x4_t v26 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a8, (int32x4_t)a10), (int32x4_t)v25);
  float32x4_t v27 = (float32x4_t)vtrn2q_s32((int32x4_t)a8, (int32x4_t)a9);
  v27.i32[2] = a10.i32[1];
  float32x4_t v28 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a8, (int32x4_t)a10), (int32x4_t)a9);
  uint32x4_t v29 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v23, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v28, a9.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a9.f32, 1), v27), v25, v26), v21)), (int8x16_t)vcgeq_f32(v23, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v28, a8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a8.f32, 1),
                                           v27),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a8, 2),
                                         v26),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v23, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v28, a10.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a10.f32, 1), v27), (float32x4_t)vdupq_laneq_s32((int32x4_t)a10, 2), v26), v22)));
  v29.i32[3] = v29.i32[2];
  if ((vminvq_u32(v29) & 0x80000000) == 0) {
    goto LABEL_25;
  }
  float32x4_t v30 = vmulq_f32(a8, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a10, (int8x16_t)a10, 0xCuLL), (int8x16_t)a10, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a9, (int32x4_t)a9), (int8x16_t)a9, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a10, (int32x4_t)a10), (int8x16_t)a10, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a9, (int8x16_t)a9, 0xCuLL), (int8x16_t)a9, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a6&& (v32 = (float32x2_t)vdup_n_s32(0x38D1B717u), uint32x2_t v33 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v32, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a10, (int8x16_t)a10, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a11, a11, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(
                                        v32,
                                        vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a8, (int8x16_t)a8, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a9, (int8x16_t)a9, 8uLL))))), (vpmin_u32(v33, v33).u32[0] & 0x80000000) != 0))
  {
    float32x4_t v45 = a8;
    kdebug_trace();
    float32x4_t v39 = (float32x4_t *)sub_24B6DE640(a1);
    if (v39)
    {
      size_t v40 = v39;
      if (sub_24B6DF1E4(a1, a2, a5, a3, a4, v39))
      {
        v40[1].f32[0] = a7;
        v40[2] = v45;
        v40[3] = a9;
        _OWORD v40[4] = a10;
        v40[5] = (float32x4_t)a11;
        *a6 = v40;
        kdebug_trace();
        return 0;
      }
      else
      {
        if (qword_2697D10F8 != -1) {
          dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
        }
        __int16 v44 = qword_2697D10F0;
        if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)simd_float4x4 buf = 136315394;
          float32x4_t v50 = "OCPointCloudCreateWithRGBNormal";
          __int16 v51 = 1026;
          int v52 = 644;
          _os_log_error_impl(&dword_24B6B9000, v44, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - no points with valid pixel coords.", buf, 0x12u);
        }
        CFRelease(v40);
        kdebug_trace();
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      if (qword_2697D10F8 != -1) {
        dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
      }
      float32x4_t v43 = qword_2697D10F0;
      if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)simd_float4x4 buf = 136315394;
        float32x4_t v50 = "OCPointCloudCreateWithRGBNormal";
        __int16 v51 = 1026;
        int v52 = 623;
        _os_log_error_impl(&dword_24B6B9000, v43, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - insufficient memory.", buf, 0x12u);
      }
      kdebug_trace();
      return 4294967293;
    }
  }
  else
  {
LABEL_25:
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    uint32x2_t v42 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      float32x4_t v50 = "OCPointCloudCreateWithRGBNormal";
      __int16 v51 = 1026;
      int v52 = 613;
      _os_log_error_impl(&dword_24B6B9000, v42, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
}

uint64_t OCPointCloudCreateFromOCPoints(unsigned int a1, uint64_t a2, float32x4_t **a3, float32_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  if (!a1) {
    goto LABEL_7;
  }
  if (!a2) {
    goto LABEL_7;
  }
  if (a4 <= 0.0) {
    goto LABEL_7;
  }
  float32x4_t v11 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a5, a5.f32[0]), a6, a6.f32[0]), a7, a7.f32[0]);
  float32x4_t v12 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a5, *(float32x2_t *)a5.f32, 1), a6, *(float32x2_t *)a6.f32, 1), a7, *(float32x2_t *)a7.f32, 1);
  float32x4_t v13 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a5, a5, 2), a6, a6, 2), a7, a7, 2);
  float32x4_t v14 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v15 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v17 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v16, vabdq_f32(v12, v14)), (int8x16_t)vcgeq_f32(v16, vabdq_f32(v11, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v16, vabdq_f32(v13, v15)));
  v17.i32[3] = v17.i32[2];
  if ((vminvq_u32(v17) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  float32x4_t v18 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a6, 2);
  float32x4_t v19 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)v18);
  float32x4_t v20 = (float32x4_t)vtrn2q_s32((int32x4_t)a5, (int32x4_t)a6);
  v20.i32[2] = a7.i32[1];
  float32x4_t v21 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a5, (int32x4_t)a7), (int32x4_t)a6);
  uint32x4_t v22 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v21, a6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 1), v20), v18, v19), v14)), (int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v21, a5.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 1),
                                           v20),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)a5, 2),
                                         v19),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v21, a7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a7.f32, 1), v20), (float32x4_t)vdupq_laneq_s32((int32x4_t)a7, 2), v19), v15)));
  v22.i32[3] = v22.i32[2];
  if ((vminvq_u32(v22) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  float32x4_t v23 = vmulq_f32(a5, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a7, (int8x16_t)a7, 0xCuLL), (int8x16_t)a7, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a6, (int32x4_t)a6), (int8x16_t)a6, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a7, (int32x4_t)a7), (int8x16_t)a7, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a6, (int8x16_t)a6, 0xCuLL), (int8x16_t)a6, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a3&& (v27 = (float32x2_t)vdup_n_s32(0x38D1B717u), uint32x2_t v28 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v27, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a7, (int8x16_t)a7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a8, a8, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(
                                        v27,
                                        vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a5, (int8x16_t)a5, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a6, (int8x16_t)a6, 8uLL))))), (vpmin_u32(v28, v28).u32[0] & 0x80000000) != 0))
  {
    float32x4_t v68 = a5;
    kdebug_trace();
    float32x4_t v30 = (float32x4_t *)sub_24B6DE640(a1);
    if (v30)
    {
      float32x4_t v31 = v30;
      uint64_t v32 = 0;
      __asm { FMOV            V9.2S, #1.0 }
      uint64_t v38 = a1;
      do
      {
        size_t v40 = (_OWORD *)(a2 + 48 * v32);
        uint32x2_t v42 = (_OWORD *)v31[6].i64[1];
        unint64_t v41 = v31[7].u64[0];
        if ((unint64_t)v42 >= v41)
        {
          uint64_t v46 = (_OWORD *)v31[6].i64[0];
          unint64_t v47 = 0xAAAAAAAAAAAAAAABLL * (v42 - v46) + 1;
          if (v47 > 0x555555555555555) {
            goto LABEL_58;
          }
          unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v41 - (void)v46) >> 4);
          if (2 * v48 > v47) {
            unint64_t v47 = 2 * v48;
          }
          if (v48 >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v49 = 0x555555555555555;
          }
          else {
            unint64_t v49 = v47;
          }
          if (v49)
          {
            if (v49 > 0x555555555555555) {
              goto LABEL_59;
            }
            float32x4_t v50 = (char *)operator new(48 * v49);
          }
          else
          {
            float32x4_t v50 = 0;
          }
          __int16 v51 = &v50[16 * (v42 - v46)];
          long long v52 = v40[1];
          *(_OWORD *)__int16 v51 = *v40;
          *((_OWORD *)v51 + 1) = v52;
          *((_OWORD *)v51 + 2) = v40[2];
          uint64_t v53 = v51;
          if (v42 != v46)
          {
            do
            {
              long long v54 = *(v42 - 3);
              long long v55 = *(v42 - 1);
              *((_OWORD *)v53 - 2) = *(v42 - 2);
              *((_OWORD *)v53 - 1) = v55;
              *((_OWORD *)v53 - 3) = v54;
              v53 -= 48;
              v42 -= 3;
            }
            while (v42 != v46);
            uint32x2_t v42 = (_OWORD *)v31[6].i64[0];
          }
          uint32x2_t v56 = &v50[48 * v49];
          float32x4_t v45 = v51 + 48;
          v31[6].i64[0] = (uint64_t)v53;
          v31[6].i64[1] = (uint64_t)(v51 + 48);
          v31[7].i64[0] = (uint64_t)v56;
          if (v42) {
            operator delete(v42);
          }
        }
        else
        {
          long long v43 = *v40;
          long long v44 = v40[2];
          v42[1] = v40[1];
          v42[2] = v44;
          _OWORD *v42 = v43;
          float32x4_t v45 = v42 + 3;
        }
        v31[6].i64[1] = (uint64_t)v45;
        float v58 = (char *)v31[8].i64[0];
        unint64_t v57 = v31[8].u64[1];
        if ((unint64_t)v58 < v57)
        {
          *(void *)float v58 = _D9;
          v58[8] = 1;
          float32x4_t v39 = v58 + 20;
          *(void *)(v58 + 12) = 0x23F800000;
        }
        else
        {
          float v59 = (unsigned char *)v31[7].i64[1];
          unint64_t v60 = 0xCCCCCCCCCCCCCCCDLL * ((v58 - v59) >> 2) + 1;
          if (v60 > 0xCCCCCCCCCCCCCCCLL) {
LABEL_58:
          }
            abort();
          unint64_t v61 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v57 - (void)v59) >> 2);
          if (2 * v61 > v60) {
            unint64_t v60 = 2 * v61;
          }
          if (v61 >= 0x666666666666666) {
            unint64_t v62 = 0xCCCCCCCCCCCCCCCLL;
          }
          else {
            unint64_t v62 = v60;
          }
          if (v62)
          {
            if (v62 > 0xCCCCCCCCCCCCCCCLL) {
LABEL_59:
            }
              sub_24B6BCD7C();
            uint64_t v63 = (char *)operator new(20 * v62);
          }
          else
          {
            uint64_t v63 = 0;
          }
          unint64_t v64 = &v63[4 * ((v58 - v59) >> 2)];
          *(void *)unint64_t v64 = _D9;
          v64[8] = 1;
          *(void *)(v64 + 12) = 0x23F800000;
          uint64_t v65 = v64;
          if (v58 != v59)
          {
            do
            {
              long long v66 = *(_OWORD *)(v58 - 20);
              *((_DWORD *)v65 - 1) = *((_DWORD *)v58 - 1);
              *(_OWORD *)(v65 - 20) = v66;
              v65 -= 20;
              v58 -= 20;
            }
            while (v58 != v59);
            float v58 = (char *)v31[7].i64[1];
          }
          float32x4_t v39 = v64 + 20;
          v31[7].i64[1] = (uint64_t)v65;
          v31[8].i64[0] = (uint64_t)(v64 + 20);
          v31[8].i64[1] = (uint64_t)&v63[20 * v62];
          if (v58) {
            operator delete(v58);
          }
        }
        v31[8].i64[0] = (uint64_t)v39;
        ++v32;
      }
      while (v32 != v38);
      v31[1].f32[0] = a4;
      v31[2] = v68;
      v31[3] = a6;
      v31[4] = a7;
      v31[5] = (float32x4_t)a8;
      *a3 = v31;
      kdebug_trace();
      return 0;
    }
    else
    {
      if (qword_2697D10F8 != -1) {
        dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
      }
      uint64_t v67 = qword_2697D10F0;
      if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)simd_float4x4 buf = 136315394;
        unint64_t v73 = "OCPointCloudCreateFromOCPoints";
        __int16 v74 = 1026;
        int v75 = 682;
        _os_log_error_impl(&dword_24B6B9000, v67, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - insufficient memory.", buf, 0x12u);
      }
      kdebug_trace();
      return 4294967293;
    }
  }
  else
  {
LABEL_7:
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    uint32x4_t v24 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      unint64_t v73 = "OCPointCloudCreateFromOCPoints";
      __int16 v74 = 1026;
      int v75 = 672;
      _os_log_error_impl(&dword_24B6B9000, v24, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - invalid arguments.", buf, 0x12u);
    }
    return 4294967294;
  }
}

uint64_t sub_24B6E1198(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 60) * *(_DWORD *)(a1 + 56)
    && *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 88)
    && *(_DWORD *)(a1 + 112))
  {
    BOOL v1 = *(_DWORD *)(a1 + 116) == 0;
    if (!*(void *)(a1 + 152)) {
      goto LABEL_13;
    }
  }
  else
  {
    BOOL v1 = 1;
    if (!*(void *)(a1 + 152)) {
      goto LABEL_13;
    }
  }
  if (*(void *)(a1 + 160))
  {
    if (*(_DWORD *)(a1 + 168))
    {
      if (*(_DWORD *)(a1 + 172))
      {
        unsigned int v2 = *(_DWORD *)(a1 + 176);
        if (v2)
        {
          unsigned int v3 = *(_DWORD *)(a1 + 180);
          if (v3)
          {
            if (v2 >= *(_DWORD *)(a1 + 112))
            {
              BOOL v4 = v3 < *(_DWORD *)(a1 + 116);
              goto LABEL_14;
            }
          }
        }
      }
    }
  }
LABEL_13:
  BOOL v4 = 1;
LABEL_14:
  if (*(float *)(a1 + 184) > 0.0
    && *(float *)(a1 + 188) > 0.0
    && (float v5 = *(float *)(a1 + 192), v5 >= 0.0)
    && v5 < (float)((float)*(unsigned int *)(a1 + 176) * 0.5)
    && (float v6 = *(float *)(a1 + 196), v6 >= 0.0))
  {
    BOOL v7 = v6 >= (float)((float)*(unsigned int *)(a1 + 180) * 0.5);
    int v8 = *(_DWORD *)(a1 + 224);
    if (!v8) {
      goto LABEL_23;
    }
  }
  else
  {
    BOOL v7 = 1;
    int v8 = *(_DWORD *)(a1 + 224);
    if (!v8) {
      goto LABEL_23;
    }
  }
  int v8 = *(_DWORD *)(a1 + 232);
  if (v8)
  {
    int v8 = *(_DWORD *)(a1 + 236);
    if (v8) {
      int v8 = *(_DWORD *)(a1 + 240) != 0;
    }
  }
LABEL_23:
  uint64_t v9 = *(void *)(a1 + 520);
  if (v9)
  {
    uint64_t v9 = *(void *)(a1 + 528);
    if (v9) {
      LODWORD(v9) = *(void *)(a1 + 536) != 0;
    }
  }
  if (v1 || v4 || v7) {
    return 0;
  }
  else {
    return v8 & v9;
  }
}

uint64_t sub_24B6E1748(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, _OWORD *a7, double a8, double a9)
{
  double v9 = floor(a8);
  double v10 = floor(a9);
  if (v9 == a8 && v10 == a9)
  {
    unint64_t v95 = (unint64_t)a8;
    unint64_t v96 = (unint64_t)a9;
    if ((unint64_t)a8 < a5 && result != 0 && a2 != 0 && a3 != 0 && a4 != 0 && v96 < a6)
    {
      unint64_t v102 = v95 + v96 * a3;
      uint64_t v103 = (unsigned __int8 *)(a2 + (v95 & 0xFFFFFFFFFFFFFFFELL) + (v96 >> 1) * a4);
      LOBYTE(a8) = *(unsigned char *)(result + v102);
      v104.f32[0] = (float)LODWORD(a8);
      float v105 = (float)(*v103 - 128);
      float32_t v106 = v104.f32[0] + (float)(v105 * -0.39176);
      float v107 = v104.f32[0] + (float)(v105 * 2.0172);
      v104.f32[1] = v106;
      float32x2_t v108 = vdiv_f32(vmla_n_f32(v104, (float32x2_t)0xBF501EA43FCC4A9ALL, (float)(v103[1] - 128)), (float32x2_t)vdup_n_s32(0x437F0000u));
      __asm { FMOV            V3.2S, #1.0 }
      *(int8x8_t *)&long long v94 = vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v108, _D3), (int8x8_t)_D3, (int8x8_t)v108), (int8x8_t)vcltz_f32(v108));
      float v91 = v107 / 255.0;
      goto LABEL_94;
    }
  }
  else
  {
    unint64_t v12 = (unint64_t)v9;
    unint64_t v13 = vcvtpd_u64_f64(a8);
    unint64_t v14 = (unint64_t)v9 - 1;
    if (a5 - 1 <= (unint64_t)v9) {
      unint64_t v15 = (unint64_t)v9;
    }
    else {
      unint64_t v15 = v12 + 1;
    }
    if (a5 - 1 > (unint64_t)v9) {
      unint64_t v14 = (unint64_t)v9;
    }
    if (v13 == v12)
    {
      unint64_t v13 = v15;
      unint64_t v12 = v14;
    }
    unint64_t v16 = (unint64_t)v10;
    unint64_t v17 = vcvtpd_u64_f64(a9);
    if (a6 - 1 > (unint64_t)v10) {
      unint64_t v18 = (unint64_t)v10;
    }
    else {
      unint64_t v18 = (unint64_t)v10 - 1;
    }
    if (a6 - 1 <= (unint64_t)v10) {
      unint64_t v19 = (unint64_t)v10;
    }
    else {
      unint64_t v19 = v16 + 1;
    }
    if (v17 == v16)
    {
      unint64_t v16 = v18;
      unint64_t v17 = v19;
    }
    if (result) {
      BOOL v20 = a2 == 0;
    }
    else {
      BOOL v20 = 1;
    }
    BOOL v22 = v20 || a3 == 0 || a4 == 0;
    int v23 = !v22;
    BOOL v24 = !v22 && v12 < a5;
    BOOL v25 = v16 < a6 && v24;
    int32x4_t v26 = 0uLL;
    unint64_t v27 = v16 >> 1;
    int32x4_t v28 = 0uLL;
    if (v25)
    {
      uint32x4_t v29 = (unsigned __int8 *)(a2 + (v12 & 0xFFFFFFFFFFFFFFFELL) + v27 * a4);
      v28.i8[0] = *(unsigned char *)(result + v12 + v16 * a3);
      v30.f32[0] = (float)v28.u32[0];
      float v31 = (float)(*v29 - 128);
      float32_t v32 = v30.f32[0] + (float)(v31 * -0.39176);
      float v33 = v30.f32[0] + (float)(v31 * 2.0172);
      v30.f32[1] = v32;
      float32x2_t v34 = vdiv_f32(vmla_n_f32(v30, (float32x2_t)0xBF501EA43FCC4A9ALL, (float)(v29[1] - 128)), (float32x2_t)vdup_n_s32(0x437F0000u));
      __asm { FMOV            V6.2S, #1.0 }
      *(int8x8_t *)v28.i8 = vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v34, _D6), (int8x8_t)_D6, (int8x8_t)v34), (int8x8_t)vcltz_f32(v34));
      float v38 = v33 / 255.0;
      float v39 = 1.0;
      if (v38 <= 1.0) {
        float v39 = v38;
      }
      _NF = v38 < 0.0;
      float v40 = 0.0;
      if (!_NF) {
        float v40 = v39;
      }
      *(float *)&v28.i32[2] = v40;
    }
    char v41 = !v24;
    if (v17 >= a6) {
      char v42 = 1;
    }
    else {
      char v42 = v41;
    }
    unint64_t v43 = v17 >> 1;
    if ((v42 & 1) == 0)
    {
      long long v44 = (unsigned __int8 *)(a2 + (v12 & 0xFFFFFFFFFFFFFFFELL) + v43 * a4);
      v26.i8[0] = *(unsigned char *)(result + v12 + v17 * a3);
      v45.f32[0] = (float)v26.u32[0];
      float v46 = (float)(*v44 - 128);
      float32_t v47 = v45.f32[0] + (float)(v46 * -0.39176);
      float v48 = v45.f32[0] + (float)(v46 * 2.0172);
      v45.f32[1] = v47;
      float32x2_t v49 = vdiv_f32(vmla_n_f32(v45, (float32x2_t)0xBF501EA43FCC4A9ALL, (float)(v44[1] - 128)), (float32x2_t)vdup_n_s32(0x437F0000u));
      __asm { FMOV            V6.2S, #1.0 }
      *(int8x8_t *)v26.i8 = vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v49, _D6), (int8x8_t)_D6, (int8x8_t)v49), (int8x8_t)vcltz_f32(v49));
      float v51 = v48 / 255.0;
      float v52 = 1.0;
      if (v51 <= 1.0) {
        float v52 = v51;
      }
      _NF = v51 < 0.0;
      float v53 = 0.0;
      if (!_NF) {
        float v53 = v52;
      }
      *(float *)&v26.i32[2] = v53;
    }
    if (v13 >= a5) {
      int v23 = 0;
    }
    int32x4_t v54 = 0uLL;
    _CF = v23 != 1 || v16 >= a6;
    int32x4_t v56 = 0uLL;
    if (!_CF)
    {
      unint64_t v57 = (unsigned __int8 *)(a2 + (v13 & 0xFFFFFFFFFFFFFFFELL) + v27 * a4);
      v56.i8[0] = *(unsigned char *)(result + v13 + v16 * a3);
      v58.f32[0] = (float)v56.u32[0];
      float v59 = (float)(*v57 - 128);
      float32_t v60 = v58.f32[0] + (float)(v59 * -0.39176);
      float v61 = v58.f32[0] + (float)(v59 * 2.0172);
      v58.f32[1] = v60;
      float32x2_t v62 = vdiv_f32(vmla_n_f32(v58, (float32x2_t)0xBF501EA43FCC4A9ALL, (float)(v57[1] - 128)), (float32x2_t)vdup_n_s32(0x437F0000u));
      __asm { FMOV            V16.2S, #1.0 }
      *(int8x8_t *)v56.i8 = vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v62, _D16), (int8x8_t)_D16, (int8x8_t)v62), (int8x8_t)vcltz_f32(v62));
      float v64 = v61 / 255.0;
      float v65 = 1.0;
      if (v64 <= 1.0) {
        float v65 = v64;
      }
      _NF = v64 < 0.0;
      float v66 = 0.0;
      if (!_NF) {
        float v66 = v65;
      }
      *(float *)&v56.i32[2] = v66;
    }
    char v67 = v23 ^ 1;
    if (v17 >= a6) {
      char v67 = 1;
    }
    if ((v67 & 1) == 0)
    {
      float32x4_t v68 = (unsigned __int8 *)(a2 + (v13 & 0xFFFFFFFFFFFFFFFELL) + v43 * a4);
      v54.i8[0] = *(unsigned char *)(result + v13 + v17 * a3);
      v69.f32[0] = (float)v54.u32[0];
      float v70 = (float)(*v68 - 128);
      float32_t v71 = v69.f32[0] + (float)(v70 * -0.39176);
      float v72 = v69.f32[0] + (float)(v70 * 2.0172);
      v69.f32[1] = v71;
      float32x2_t v73 = vdiv_f32(vmla_n_f32(v69, (float32x2_t)0xBF501EA43FCC4A9ALL, (float)(v68[1] - 128)), (float32x2_t)vdup_n_s32(0x437F0000u));
      __asm { FMOV            V16.2S, #1.0 }
      *(int8x8_t *)v54.i8 = vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v73, _D16), (int8x8_t)_D16, (int8x8_t)v73), (int8x8_t)vcltz_f32(v73));
      float v75 = v72 / 255.0;
      float v76 = 1.0;
      if (v75 <= 1.0) {
        float v76 = v75;
      }
      _NF = v75 < 0.0;
      float v77 = 0.0;
      if (!_NF) {
        float v77 = v76;
      }
      *(float *)&v54.i32[2] = v77;
    }
    if (v17 >= a6) {
      BOOL v25 = 0;
    }
    if (v13 < a5 && v25)
    {
      float v78 = 1.0 / (float)((v17 - v16) * (v13 - v12));
      float v79 = a8;
      float v80 = (float)v13 - v79;
      float v81 = v79 - (float)v12;
      float v82 = a9;
      float v83 = (float)v17 - v82;
      int32x4_t v84 = vzip1q_s32(vzip1q_s32(v28, v26), vzip1q_s32(v56, v54));
      float v85 = v82 - (float)v16;
      int8x16_t v86 = (int8x16_t)vzip1q_s32(v84, (int32x4_t)vdupq_laneq_s64((int64x2_t)v84, 1));
      *(float32x2_t *)v86.i8 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)v86.i8, v80), (float32x2_t)*(_OWORD *)&vextq_s8(v86, v86, 8uLL), v81);
      int32x4_t v87 = vzip1q_s32(vtrn2q_s32(v28, v26), vtrn2q_s32(v56, v54));
      int8x16_t v88 = (int8x16_t)vzip1q_s32(v87, (int32x4_t)vdupq_laneq_s64((int64x2_t)v87, 1));
      int32x4_t v89 = vzip1q_s32(vzip2q_s32(v28, v26), vzip2q_s32(v56, v54));
      *(float32x2_t *)v88.i8 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)v88.i8, v80), (float32x2_t)*(_OWORD *)&vextq_s8(v88, v88, 8uLL), v81);
      int8x16_t v90 = (int8x16_t)vzip1q_s32(v89, (int32x4_t)vdupq_laneq_s64((int64x2_t)v89, 1));
      *(float32x2_t *)v90.i8 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)v90.i8, v80), (float32x2_t)*(_OWORD *)&vextq_s8(v90, v90, 8uLL), v81);
      float v91 = vmuls_lane_f32(v85, *(float32x2_t *)v90.i8, 1) + (float)((float)(v78 * *(float *)v90.i32) * v83);
      float32x2_t v92 = vmla_n_f32(vmul_n_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v86.i8, *(int32x2_t *)v88.i8), v85), vmul_n_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v86.i8, *(int32x2_t *)v88.i8), v78), v83);
      __asm { FMOV            V3.2S, #1.0 }
      *(int8x8_t *)&long long v94 = vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v92, _D3), (int8x8_t)_D3, (int8x8_t)v92), (int8x8_t)vcltz_f32(v92));
LABEL_94:
      if (v91 <= 1.0) {
        float v110 = v91;
      }
      else {
        float v110 = 1.0;
      }
      _NF = v91 < 0.0;
      float v111 = 0.0;
      if (!_NF) {
        float v111 = v110;
      }
      *((void *)&v94 + 1) = __PAIR64__(1.0, LODWORD(v111));
      *a7 = v94;
    }
  }
  return result;
}

uint64_t sub_24B6E1C7C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 416))
  {
    unsigned int v2 = *(void **)(a1 + 384);
    if (v2)
    {
      *(void *)(a1 + 392) = v2;
      operator delete(v2);
    }
  }
  unsigned int v3 = *(void **)(a1 + 24);
  if (v3)
  {
    do
    {
      BOOL v4 = (void *)*v3;
      operator delete(v3);
      unsigned int v3 = v4;
    }
    while (v4);
  }
  float v5 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

void sub_24B6E1CE0(float32x4_t *a1, unint64_t a2)
{
  uint64_t v68 = *MEMORY[0x263EF8340];
  if (a1 && (sub_24B6E1198((uint64_t)a1) & 1) != 0)
  {
    if (!HIDWORD(a2))
    {
      unsigned __int32 v4 = a1[14].u32[2];
      if (a1[14].i32[3] * v4 > a2)
      {
        __int32 v5 = a1[14].i32[0];
        uint64_t v6 = a1[12].i64[1];
        unsigned int v7 = HIDWORD(v6) + v5 * (a2 / v4);
        unsigned int v59 = v7 + v5;
        unsigned int v57 = a2;
        if (v7 < v7 + v5)
        {
          unsigned int v8 = v6 + v5 * (a2 % v4);
          unsigned int v9 = v8 + v5;
          unsigned int v58 = v8;
          if (v8 < v8 + v5)
          {
            int v10 = 0;
            float v11 = (float)a1[11].u32[0] / (float)a1[7].u32[0];
            float32x4_t v61 = (float32x4_t)vdupq_n_s32(0x358637BDu);
            unsigned int v60 = a1[14].i32[1] * a2;
            unsigned int v12 = v60;
            while (1)
            {
              if (v7 > a1[13].i32[1]) {
                goto LABEL_59;
              }
              uint64_t v15 = v58;
LABEL_19:
              if (v15 <= a1[13].i64[0]) {
                break;
              }
              __int32 v14 = a1[15].i32[0];
LABEL_14:
              v7 += v14;
              if (v7 >= v59) {
                goto LABEL_59;
              }
            }
            sub_24B6E12E8();
            float32x4_t v22 = v21;
            int8x8_t v23 = *(int8x8_t *)a1[1].f32;
            if (!*(void *)&v23) {
              goto LABEL_40;
            }
            unint64_t v24 = v7 | (unint64_t)(v15 << 32);
            uint8x8_t v25 = (uint8x8_t)vcnt_s8(v23);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] >= 2uLL)
            {
              unint64_t v26 = v7 | (unint64_t)(v15 << 32);
              if (v24 >= *(void *)&v23) {
                unint64_t v26 = v24 % *(void *)&v23;
              }
            }
            else
            {
              unint64_t v26 = (*(void *)&v23 - 1) & v24;
            }
            unint64_t v27 = *(int32x2_t ***)(a1->i64[1] + 8 * v26);
            if (!v27 || (int32x4_t v28 = *v27) == 0)
            {
LABEL_40:
              float32x4_t v34 = *(float32x4_t *)(a1[32].i64[0]
                                   + 16
                                   * ((v15 - a1[12].i64[1]) % a1[14].i32[0]
                                    + v60
                                    + (v7 - HIDWORD(a1[12].i64[1])) % a1[14].i32[0] * a1[14].i32[0]));
              if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v61, vabsq_f32(v22))))) & 1) == 0
                && a1[8].i32[1] * a1[8].i32[0])
              {
                int32x4_t v35 = (int32x4_t)vmulq_f32(v34, v34);
                v35.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v35, 2), vadd_f32(*(float32x2_t *)v35.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v35.i8, 1))).u32[0];
                float32x2_t v36 = vrsqrte_f32((float32x2_t)v35.u32[0]);
                float32x2_t v37 = vmul_f32(v36, vrsqrts_f32((float32x2_t)v35.u32[0], vmul_f32(v36, v36)));
                float32x4_t v38 = vmulq_n_f32(vnegq_f32(v34), vmul_f32(v37, vrsqrts_f32((float32x2_t)v35.u32[0], vmul_f32(v37, v37))).f32[0]);
                v38.i32[3] = v22.i32[3];
                float32x4_t v22 = v38;
              }
              float32x4_t v39 = vmulq_f32(v22, v22);
              float32x4_t v40 = vmulq_f32(v34, v34);
              float v41 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).f32[0])* sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0]);
              float v42 = 0.0;
              if (fabsf(v41) <= 0.000001)
              {
                float v44 = 0.0;
              }
              else
              {
                float32x4_t v43 = vmulq_f32(v22, vnegq_f32(v34));
                float v44 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v43, 2), vaddq_f32(v43, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 1))).f32[0]/ v41;
                if (v44 >= 0.6) {
                  float v42 = v44 * v44;
                }
              }
              float v45 = v42 + v42;
              float v46 = *(float *)(a1[6].i64[1] + a1[5].i64[0] + a1[6].i32[0] * v15 + a1[6].i32[1] * v7);
              int v47 = 1;
              goto LABEL_48;
            }
            if (v25.u32[0] < 2uLL)
            {
              uint64_t v29 = *(void *)&v23 - 1;
              while (1)
              {
                int32x2_t v33 = v28[1];
                if (*(void *)&v33 == v24)
                {
                  uint32x2_t v32 = (uint32x2_t)vceq_s32(v28[2], (int32x2_t)__PAIR64__(v7, v15));
                  if ((vpmin_u32(v32, v32).u32[0] & 0x80000000) != 0) {
                    goto LABEL_50;
                  }
                }
                else if ((*(void *)&v33 & v29) != v26)
                {
                  goto LABEL_40;
                }
                int32x4_t v28 = (int32x2_t *)*v28;
                if (!v28) {
                  goto LABEL_40;
                }
              }
            }
            while (1)
            {
              int32x2_t v31 = v28[1];
              if (*(void *)&v31 == v24)
              {
                uint32x2_t v30 = (uint32x2_t)vceq_s32(v28[2], (int32x2_t)__PAIR64__(v7, v15));
                if ((vpmin_u32(v30, v30).u32[0] & 0x80000000) != 0)
                {
LABEL_50:
                  v28[3].i8[4] = 1;
                  float32x4_t v34 = *(float32x4_t *)(a1->i64[0] + 16 * v28[3].u32[0]);
                  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v61, vabsq_f32(v22))))) & 1) == 0
                    && a1[8].i32[1] * a1[8].i32[0])
                  {
                    int32x4_t v48 = (int32x4_t)vmulq_f32(v34, v34);
                    v48.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v48, 2), vadd_f32(*(float32x2_t *)v48.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v48.i8, 1))).u32[0];
                    float32x2_t v49 = vrsqrte_f32((float32x2_t)v48.u32[0]);
                    float32x2_t v50 = vmul_f32(v49, vrsqrts_f32((float32x2_t)v48.u32[0], vmul_f32(v49, v49)));
                    float32x4_t v51 = vmulq_n_f32(vnegq_f32(v34), vmul_f32(v50, vrsqrts_f32((float32x2_t)v48.u32[0], vmul_f32(v50, v50))).f32[0]);
                    v51.i32[3] = v22.i32[3];
                    float32x4_t v22 = v51;
                  }
                  float32x4_t v52 = vmulq_f32(v22, v22);
                  float32x4_t v53 = vmulq_f32(v34, v34);
                  float v54 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 2), vaddq_f32(v53, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v53.f32, 1))).f32[0])* sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).f32[0]);
                  float v55 = 0.0;
                  if (fabsf(v54) <= 0.000001)
                  {
                    float v44 = 0.0;
                  }
                  else
                  {
                    float32x4_t v56 = vmulq_f32(v22, vnegq_f32(v34));
                    float v44 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 2), vaddq_f32(v56, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v56.f32, 1))).f32[0]/ v54;
                    if (v44 >= 0.6) {
                      float v55 = v44 * v44;
                    }
                  }
                  int v47 = 0;
                  v34.i32[3] = 1.0;
                  float v45 = v55 * 10.0;
                  float v46 = 1.0;
LABEL_48:
                  float32x4_t v62 = v34;
                  float32x4_t v63 = v22;
                  if (a1[26].i8[0])
                  {
                    float32x4_t v16 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1[28], v34.f32[0]), a1[29], *(float32x2_t *)v34.f32, 1), a1[30], v34, 2), a1[31], v34, 3);
                    v16.i32[3] = -1.0;
                    int8x16_t v17 = (int8x16_t)vmulq_f32(v16, a1[23]);
                    BOOL v18 = vaddv_f32(vadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL))) >= a1[27].f32[0];
                  }
                  else
                  {
                    BOOL v18 = 1;
                  }
                  uint64_t v19 = 48 * v12;
                  sub_24B6E1748(a1[9].i64[1], a1[10].i64[0], a1[10].u32[2], a1[10].u32[3], a1[11].u32[0], a1[11].u32[1], (_OWORD *)(a1[32].i64[1] + v19 + 32), (float)(v11 * (float)v15), (float)(v11 * (float)v7));
                  *(float32x4_t *)(a1[32].i64[1] + v19) = v62;
                  *(float32x4_t *)(a1[32].i64[1] + v19 + 16) = v63;
                  uint64_t v20 = a1[33].i64[0] + 20 * v12;
                  *(float *)uint64_t v20 = v45;
                  *(float *)(v20 + 4) = v46;
                  *(unsigned char *)(v20 + 8) = v18;
                  *(float *)(v20 + 12) = v44;
                  *(_DWORD *)(v20 + 16) = v47;
                  ++v12;
                  ++v10;
                  __int32 v14 = a1[15].i32[0];
                  uint64_t v15 = (v14 + v15);
                  if (v15 >= v9) {
                    goto LABEL_14;
                  }
                  goto LABEL_19;
                }
              }
              else
              {
                if (*(void *)&v31 >= *(void *)&v23) {
                  *(void *)&v31 %= *(void *)&v23;
                }
                if (*(void *)&v31 != v26) {
                  goto LABEL_40;
                }
              }
              int32x4_t v28 = (int32x2_t *)*v28;
              if (!v28) {
                goto LABEL_40;
              }
            }
          }
        }
        int v10 = 0;
LABEL_59:
        *(_DWORD *)(a1[33].i64[1] + 4 * v57) = v10;
      }
    }
  }
  else
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    unint64_t v13 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      float v65 = "createPointCloudFromDenseDepthAndPointcloudBlock";
      __int16 v66 = 1026;
      int v67 = 1079;
      _os_log_error_impl(&dword_24B6B9000, v13, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud from depth image and pointcloud - invalid pointcloud context.", buf, 0x12u);
    }
  }
}

void sub_24B6E2370(uint64_t a1, unint64_t a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (a1 && (sub_24B6E1198(a1) & 1) != 0)
  {
    if (!HIDWORD(a2))
    {
      unsigned int v4 = *(_DWORD *)(a1 + 232);
      if (*(_DWORD *)(a1 + 236) * v4 > a2)
      {
        int v5 = *(_DWORD *)(a1 + 224);
        uint64_t v6 = *(void *)(a1 + 200);
        unsigned int v7 = HIDWORD(v6) + v5 * (a2 / v4);
        int v8 = v7 + v5;
        if (v7 < v7 + v5)
        {
          unsigned int v9 = v6 + v5 * (a2 % v4);
          unsigned int v10 = v9 + v5;
          if (v9 < v10)
          {
            int v11 = *(_DWORD *)(a1 + 228) * a2;
            do
            {
              if (v7 > *(_DWORD *)(a1 + 212)) {
                break;
              }
              unsigned int v13 = v9;
              do
              {
                if (v13 > *(void *)(a1 + 208)) {
                  break;
                }
                float v14 = *(float *)(*(void *)(a1 + 72)
                               + *(void *)(a1 + 48)
                               + *(_DWORD *)(a1 + 64) * v13
                               + *(_DWORD *)(a1 + 68) * v7);
                unsigned int v15 = *(_DWORD *)(a1 + 224);
                *(float32x4_t *)(*(void *)(a1 + 512)
                               + 16
                               * ((v13 - *(void *)(a1 + 200)) % v15
                                + v11
                                + (v7 - HIDWORD(*(void *)(a1 + 200))) % v15 * v15)) = vaddq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)xmmword_24B72A5D0, (float)(v14 * (float)((float)v13 - *(float *)(a1 + 192))) / *(float *)(a1 + 184)), (float32x4_t)xmmword_24B72A6B0, (float)(v14 * (float)((float)v7 - *(float *)(a1 + 196))) / *(float *)(a1 + 188)), (float32x4_t)xmmword_24B72A6C0, v14), (float32x4_t)xmmword_24B72A590);
                ++v13;
              }
              while (v13 < v10);
              ++v7;
            }
            while (v7 != v8);
          }
        }
      }
    }
  }
  else
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    unsigned int v12 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      int v16 = 136315394;
      int8x16_t v17 = "computePointsInRenderCameraFrame";
      __int16 v18 = 1026;
      int v19 = 887;
      _os_log_error_impl(&dword_24B6B9000, v12, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid pointcloud context.", (uint8_t *)&v16, 0x12u);
    }
  }
}

uint64_t OCPointCloudCreateFromDenseDepth(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, int a5, uint64_t a6)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (sub_24B6E2768(a1, a2, a3, a4, a5, a6))
  {
    kdebug_trace();
    LOBYTE(v15[0]) = 0;
    char v16 = 0;
    v14[0] = 0;
    v14[64] = 0;
    sub_24B6E2CB8(0, 0, 0, a1, a2, a3, a4, a5, 0, v15, (uint64_t)v14, a6);
  }
  if (qword_2697D10F8 != -1) {
    dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
  }
  unsigned int v12 = qword_2697D10F0;
  if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)simd_float4x4 buf = 136315394;
    __int16 v18 = "OCPointCloudCreateFromDenseDepth";
    __int16 v19 = 1026;
    int v20 = 1598;
    _os_log_error_impl(&dword_24B6B9000, v12, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - invalid input.", buf, 0x12u);
  }
  return 4294967294;
}

uint64_t sub_24B6E2768(CVPixelBufferRef pixelBuffer, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, int a5, uint64_t a6)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  if (pixelBuffer
    && CVPixelBufferGetWidth(pixelBuffer)
    && CVPixelBufferGetHeight(pixelBuffer)
    && CVPixelBufferGetPixelFormatType(pixelBuffer) == 1717855600)
  {
    int v12 = 0;
    if (!a2) {
      goto LABEL_17;
    }
  }
  else
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    unsigned int v13 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      int v27 = 136315394;
      int32x4_t v28 = "isValidInputForPointCloudFromDenseDepth";
      __int16 v29 = 1026;
      int v30 = 1476;
      _os_log_error_impl(&dword_24B6B9000, v13, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid depth image.", (uint8_t *)&v27, 0x12u);
      int v12 = 1;
      if (!a2) {
        goto LABEL_17;
      }
    }
    else
    {
      int v12 = 1;
      if (!a2) {
        goto LABEL_17;
      }
    }
  }
  size_t Width = CVPixelBufferGetWidth(a2);
  if (Width == CVPixelBufferGetWidth(pixelBuffer))
  {
    size_t Height = CVPixelBufferGetHeight(a2);
    if (Height == CVPixelBufferGetHeight(pixelBuffer) && CVPixelBufferGetPixelFormatType(a2) == 1717855600)
    {
      int v16 = 0;
      if (!a3) {
        goto LABEL_31;
      }
      goto LABEL_22;
    }
  }
LABEL_17:
  if (qword_2697D10F8 != -1) {
    dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
  }
  int8x16_t v17 = qword_2697D10F0;
  if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
  {
    int v27 = 136315394;
    int32x4_t v28 = "isValidInputForPointCloudFromDenseDepth";
    __int16 v29 = 1026;
    int v30 = 1484;
    _os_log_error_impl(&dword_24B6B9000, v17, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid depth confidence image.", (uint8_t *)&v27, 0x12u);
  }
  int v16 = 1;
  if (a3)
  {
LABEL_22:
    size_t v18 = CVPixelBufferGetWidth(a3);
    if (v18 == CVPixelBufferGetWidth(pixelBuffer)
      && (size_t v19 = CVPixelBufferGetHeight(a3), v19 == CVPixelBufferGetHeight(pixelBuffer))
      && CVPixelBufferGetPixelFormatType(a3) == 1380410945)
    {
      LODWORD(a3) = 0;
    }
    else
    {
      if (qword_2697D10F8 != -1) {
        dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
      }
      int v20 = qword_2697D10F0;
      if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
      {
        int v27 = 136315394;
        int32x4_t v28 = "isValidInputForPointCloudFromDenseDepth";
        __int16 v29 = 1026;
        int v30 = 1494;
        _os_log_error_impl(&dword_24B6B9000, v20, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid normal image.", (uint8_t *)&v27, 0x12u);
      }
      LODWORD(a3) = 1;
    }
  }
LABEL_31:
  if (a4
    && CVPixelBufferGetWidth(a4)
    && CVPixelBufferGetHeight(a4)
    && (CVPixelBufferGetPixelFormatType(a4) == 875704422 || CVPixelBufferGetPixelFormatType(a4) == 875704438))
  {
    int v21 = 0;
    if (a6) {
      goto LABEL_46;
    }
  }
  else
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    float32x4_t v22 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      int v27 = 136315394;
      int32x4_t v28 = "isValidInputForPointCloudFromDenseDepth";
      __int16 v29 = 1026;
      int v30 = 1502;
      _os_log_error_impl(&dword_24B6B9000, v22, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid color image.", (uint8_t *)&v27, 0x12u);
    }
    int v21 = 1;
    if (a6) {
      goto LABEL_46;
    }
  }
  if (qword_2697D10F8 != -1) {
    dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
  }
  int8x8_t v23 = qword_2697D10F0;
  if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
  {
    int v27 = 136315394;
    int32x4_t v28 = "isValidInputForPointCloudFromDenseDepth";
    __int16 v29 = 1026;
    int v30 = 1507;
    _os_log_error_impl(&dword_24B6B9000, v23, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid input pointcloud.", (uint8_t *)&v27, 0x12u);
    if (a5) {
      goto LABEL_51;
    }
    goto LABEL_47;
  }
LABEL_46:
  if (a5) {
    goto LABEL_51;
  }
LABEL_47:
  if (qword_2697D10F8 != -1) {
    dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
  }
  unint64_t v24 = qword_2697D10F0;
  if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
  {
    int v27 = 136315394;
    int32x4_t v28 = "isValidInputForPointCloudFromDenseDepth";
    __int16 v29 = 1026;
    int v30 = 1512;
    _os_log_error_impl(&dword_24B6B9000, v24, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid step size.", (uint8_t *)&v27, 0x12u);
  }
LABEL_51:
  unsigned int v25 = (v12 | v16 | a3 | v21) ^ 1;
  if (!a5) {
    unsigned int v25 = 0;
  }
  if (a6) {
    return v25;
  }
  else {
    return 0;
  }
}

void sub_24B6E2CB8(unsigned int a1, int a2, uint64_t a3, CVPixelBufferRef pixelBuffer, __CVBuffer *a5, __CVBuffer *a6, __CVBuffer *a7, int a8, long long *a9, long long *a10, uint64_t a11, uint64_t a12)
{
  uint64_t v127 = *MEMORY[0x263EF8340];
  unsigned int v17 = vcvtps_u32_f32((float)CVPixelBufferGetWidth(pixelBuffer) * 0.03125);
  pixelBuffera = pixelBuffer;
  uint64_t v18 = vcvtps_u32_f32((float)CVPixelBufferGetHeight(pixelBuffer) * 0.03125) * v17;
  if (v18)
  {
    float v81 = operator new(49152 * v18);
    bzero(v81, 48 * ((49152 * v18 - 48) / 0x30uLL) + 48);
    float v82 = operator new(20480 * v18);
    bzero(v82, 20 * ((20480 * v18 - 20) / 0x14uLL) + 20);
    size_t v12 = 4 * v18;
    float v80 = operator new(4 * v18);
    bzero(v80, 4 * v18);
  }
  float v77 = a5;
  float v78 = a6;
  unsigned int v19 = a1;
  unint64_t v20 = a1;
  if (a1)
  {
    int v21 = operator new(48 * a1);
    bzero(v21, 48 * ((48 * (unint64_t)a1 - 48) / 0x30) + 48);
    size_t v12 = 20 * a1;
    float v79 = operator new(v12);
    bzero(v79, 20 * ((v12 - 20) / 0x14) + 20);
  }
  if (a9)
  {
    uint64_t v22 = *((void *)a9 + 12);
    uint64_t v23 = *((unsigned int *)a9 + 26);
    long long rect_16 = *a9;
    *(_OWORD *)int32x4_t v89 = a9[1];
    long long v24 = a9[3];
    long long v90 = a9[2];
    long long v91 = v24;
    if (v23)
    {
      unsigned int v25 = 0;
      unint64_t v26 = 0;
      int v27 = 0;
      for (uint64_t i = 0; i != v23; ++i)
      {
        if (v27 < v25)
        {
          *(_OWORD *)int v27 = *(_OWORD *)(v22 + 16 * i);
          v27 += 16;
        }
        else
        {
          uint64_t v29 = (v27 - v26) >> 4;
          unint64_t v30 = v29 + 1;
          if ((unint64_t)(v29 + 1) >> 60) {
            abort();
          }
          if ((v25 - v26) >> 3 > v30) {
            unint64_t v30 = (v25 - v26) >> 3;
          }
          if ((unint64_t)(v25 - v26) >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v31 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v31 = v30;
          }
          if (v31)
          {
            if (v31 >> 60) {
              sub_24B6BCD7C();
            }
            uint32x2_t v32 = (char *)operator new(16 * v31);
          }
          else
          {
            uint32x2_t v32 = 0;
          }
          int32x2_t v33 = &v32[16 * v29];
          *(_OWORD *)int32x2_t v33 = *(_OWORD *)(v22 + 16 * i);
          for (CFIndex j = v33 + 16; v27 != v26; v33 -= 16)
          {
            long long v35 = *((_OWORD *)v27 - 1);
            v27 -= 16;
            *((_OWORD *)v33 - 1) = v35;
          }
          unsigned int v25 = &v32[16 * v31];
          if (v26) {
            operator delete(v26);
          }
          unint64_t v26 = v33;
          int v27 = j;
        }
      }
      unint64_t v20 = a1;
      unsigned int v19 = a1;
    }
    else
    {
      int v27 = 0;
      unint64_t v26 = 0;
    }
    long long v123 = rect_16;
    long long v124 = *(_OWORD *)v89;
    long long v125 = v90;
    long long v126 = v91;
    long long v119 = rect_16;
    long long v120 = *(_OWORD *)v89;
    long long v121 = v90;
    long long v122 = v91;
    size_t v12 = v27 - v26;
    if (v27 != v26)
    {
      if ((v12 & 0x8000000000000000) != 0) {
        abort();
      }
      float32x2_t v36 = operator new(v27 - v26);
      memcpy(v36, v26, v12);
    }
  }
  long long v37 = a10[1];
  long long v115 = *a10;
  long long v116 = v37;
  long long v38 = a10[3];
  long long v117 = a10[2];
  long long v118 = v38;
  *(void *)&long long v90 = 0;
  long long rect_16a = 0u;
  *(_OWORD *)int32x4_t v89 = 0u;
  DWORD2(v90) = 1065353216;
  char v104 = 0;
  char v105 = 0;
  int v106 = 0;
  long long v91 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v102 = 0u;
  int v103 = 0;
  int v114 = 0;
  long long v112 = 0u;
  long long v113 = 0u;
  long long v110 = 0u;
  long long v111 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v107 = 0u;
  LODWORD(v95) = CVPixelBufferGetWidth(pixelBuffera);
  DWORD1(v95) = CVPixelBufferGetHeight(pixelBuffera);
  LODWORD(v99) = CVPixelBufferGetWidth(a7);
  if (!v19)
  {
LABEL_126:
    CVPixelBufferLockBaseAddress(pixelBuffera, 1uLL);
    CVPixelBufferLockBaseAddress(v77, 1uLL);
    CVPixelBufferLockBaseAddress(v78, 1uLL);
    CVPixelBufferLockBaseAddress(a7, 1uLL);
    cva::imageViewFromPixelBuffer<float>();
  }
  uint64_t v40 = 0;
  *(float *)v39.i32 = (float)v99 / (float)v95;
  float32x2_t v41 = (float32x2_t)vdup_lane_s32(v39, 0);
  while (1)
  {
    float64x2_t v42 = *(float64x2_t *)(a3 + 16 * v40);
    if (v42.f64[0] < 0.0 || v42.f64[1] < 0.0) {
      goto LABEL_37;
    }
    int32x2_t rect = (int32x2_t)vcvt_u32_f32(vrnda_f32(vdiv_f32(vcvt_f32_f64(v42), v41)));
    unint64_t v43 = rect.u32[1] | ((unint64_t)rect.u32[0] << 32);
    int8x8_t v44 = (int8x8_t)v89[0];
    if (v89[0])
    {
      uint8x8_t v45 = (uint8x8_t)vcnt_s8((int8x8_t)v89[0]);
      v45.i16[0] = vaddlv_u8(v45);
      if (v45.u32[0] > 1uLL)
      {
        size_t v12 = rect.u32[1] | ((unint64_t)rect.u32[0] << 32);
        if ((void *)v43 >= v89[0]) {
          size_t v12 = v43 % (unint64_t)v89[0];
        }
      }
      else
      {
        size_t v12 = v43 & ((unint64_t)v89[0] - 1);
      }
      float v46 = *(int32x2_t ***)(*((void *)&rect_16a + 1) + 8 * v12);
      if (v46)
      {
        int v47 = *v46;
        if (v47)
        {
          if (v45.u32[0] < 2uLL)
          {
            while (1)
            {
              int32x2_t v51 = v47[1];
              if (*(void *)&v51 == v43)
              {
                uint32x2_t v50 = (uint32x2_t)vceq_s32(v47[2], rect);
                if ((vpmin_u32(v50, v50).u32[0] & 0x80000000) != 0) {
                  goto LABEL_37;
                }
              }
              else if ((*(void *)&v51 & ((uint64_t)v89[0] - 1)) != v12)
              {
                goto LABEL_60;
              }
              int v47 = (int32x2_t *)*v47;
              if (!v47) {
                goto LABEL_60;
              }
            }
          }
          do
          {
            unint64_t v49 = (unint64_t)v47[1];
            if (v49 == v43)
            {
              uint32x2_t v48 = (uint32x2_t)vceq_s32(v47[2], rect);
              if ((vpmin_u32(v48, v48).u32[0] & 0x80000000) != 0) {
                goto LABEL_37;
              }
            }
            else
            {
              if ((void *)v49 >= v89[0]) {
                v49 %= (unint64_t)v89[0];
              }
              if (v49 != v12) {
                break;
              }
            }
            int v47 = (int32x2_t *)*v47;
          }
          while (v47);
        }
      }
    }
LABEL_60:
    float32x4_t v52 = operator new(0x20uLL);
    void *v52 = 0;
    v52[1] = v43;
    v52[2] = rect;
    v52[3] = v40;
    float v53 = (float)(unint64_t)(v90 + 1);
    if (!v89[0] || (float)(*((float *)&v90 + 2) * (float)(unint64_t)v89[0]) < v53) {
      break;
    }
LABEL_110:
    __int16 v74 = *(void **)(*((void *)&rect_16a + 1) + 8 * v12);
    if (v74)
    {
      void *v52 = *v74;
    }
    else
    {
      void *v52 = v89[1];
      v89[1] = v52;
      *(void *)(*((void *)&rect_16a + 1) + 8 * v12) = &v89[1];
      if (!*v52) {
        goto LABEL_36;
      }
      unint64_t v75 = *(void *)(*v52 + 8);
      if ((*(void *)&v44 & (*(void *)&v44 - 1)) != 0)
      {
        if (v75 >= *(void *)&v44) {
          v75 %= *(void *)&v44;
        }
      }
      else
      {
        v75 &= *(void *)&v44 - 1;
      }
      __int16 v74 = (void *)(*((void *)&rect_16a + 1) + 8 * v75);
    }
    void *v74 = v52;
LABEL_36:
    *(void *)&long long v90 = v90 + 1;
LABEL_37:
    if (++v40 >= v20) {
      goto LABEL_126;
    }
  }
  BOOL v54 = ((unint64_t)v89[0] & ((unint64_t)v89[0] - 1)) != 0;
  if (v89[0] < (void *)3) {
    BOOL v54 = 1;
  }
  unint64_t v55 = v54 | (2 * (uint64_t)v89[0]);
  unint64_t v56 = vcvtps_u32_f32(v53 / *((float *)&v90 + 2));
  if (v55 <= v56) {
    size_t prime = v56;
  }
  else {
    size_t prime = v55;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    int8x8_t v44 = (int8x8_t)v89[0];
  }
  if (prime <= *(void *)&v44)
  {
    if (prime >= *(void *)&v44) {
      goto LABEL_97;
    }
    unint64_t v68 = vcvtps_u32_f32((float)(unint64_t)v90 / *((float *)&v90 + 2));
    if (*(void *)&v44 < 3uLL || (uint8x8_t v69 = (uint8x8_t)vcnt_s8(v44), v69.i16[0] = vaddlv_u8(v69), v69.u32[0] > 1uLL))
    {
      unint64_t v68 = std::__next_prime(v68);
    }
    else
    {
      uint64_t v70 = 1 << -(char)__clz(v68 - 1);
      if (v68 >= 2) {
        unint64_t v68 = v70;
      }
    }
    if (prime <= v68) {
      size_t prime = v68;
    }
    if (prime >= *(void *)&v44)
    {
      int8x8_t v44 = (int8x8_t)v89[0];
LABEL_97:
      if ((*(void *)&v44 & (*(void *)&v44 - 1)) != 0)
      {
        if (v43 >= *(void *)&v44) {
          size_t v12 = v43 % *(void *)&v44;
        }
        else {
          size_t v12 = rect.u32[1] | ((unint64_t)rect.u32[0] << 32);
        }
      }
      else
      {
        size_t v12 = (*(void *)&v44 - 1) & v43;
      }
      goto LABEL_110;
    }
    if (!prime)
    {
      float v76 = (void *)*((void *)&rect_16a + 1);
      *((void *)&rect_16a + 1) = 0;
      if (v76) {
        operator delete(v76);
      }
      int8x8_t v44 = 0;
      v89[0] = 0;
      goto LABEL_97;
    }
  }
  if (prime >> 61) {
    sub_24B6BCD7C();
  }
  unsigned int v58 = operator new(8 * prime);
  unsigned int v59 = (void *)*((void *)&rect_16a + 1);
  *((void *)&rect_16a + 1) = v58;
  if (v59) {
    operator delete(v59);
  }
  uint64_t v60 = 0;
  v89[0] = (void *)prime;
  do
    *(void *)(*((void *)&rect_16a + 1) + 8 * v60++) = 0;
  while (prime != v60);
  float32x4_t v61 = (void **)v89[1];
  if (!v89[1])
  {
LABEL_96:
    int8x8_t v44 = (int8x8_t)prime;
    goto LABEL_97;
  }
  size_t v62 = *((void *)v89[1] + 1);
  size_t v63 = prime - 1;
  if ((prime & (prime - 1)) == 0)
  {
    size_t v64 = v62 & v63;
    *(void *)(*((void *)&rect_16a + 1) + 8 * v64) = &v89[1];
    for (k = *v61; *v61; k = *v61)
    {
      size_t v66 = k[1] & v63;
      if (v66 == v64)
      {
        float32x4_t v61 = (void **)k;
      }
      else if (*(void *)(*((void *)&rect_16a + 1) + 8 * v66))
      {
        float32x4_t *v61 = (void *)*k;
        uint64_t v67 = 8 * v66;
        void *k = **(void **)(*((void *)&rect_16a + 1) + v67);
        **(void **)(*((void *)&rect_16a + 1) + v67) = k;
      }
      else
      {
        *(void *)(*((void *)&rect_16a + 1) + 8 * v66) = v61;
        float32x4_t v61 = (void **)k;
        size_t v64 = v66;
      }
    }
    goto LABEL_96;
  }
  if (v62 >= prime) {
    v62 %= prime;
  }
  *(void *)(*((void *)&rect_16a + 1) + 8 * v62) = &v89[1];
  float32_t v71 = *v61;
  if (!*v61) {
    goto LABEL_96;
  }
  while (1)
  {
    size_t v73 = v71[1];
    if (v73 >= prime) {
      v73 %= prime;
    }
    if (v73 != v62)
    {
      if (!*(void *)(*((void *)&rect_16a + 1) + 8 * v73))
      {
        *(void *)(*((void *)&rect_16a + 1) + 8 * v73) = v61;
        goto LABEL_101;
      }
      float32x4_t *v61 = (void *)*v71;
      uint64_t v72 = 8 * v73;
      *float32_t v71 = **(void **)(*((void *)&rect_16a + 1) + v72);
      **(void **)(*((void *)&rect_16a + 1) + v72) = v71;
      float32_t v71 = v61;
    }
    size_t v73 = v62;
LABEL_101:
    float32x4_t v61 = (void **)v71;
    float32_t v71 = (void *)*v71;
    size_t v62 = v73;
    if (!v71) {
      goto LABEL_96;
    }
  }
}

void sub_24B6E4CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,void *a38,void *a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  sub_24B6E1C7C((uint64_t)&a63);
  if (v65 && v64)
  {
    operator delete(v64);
  }
  else if (!v65)
  {
    goto LABEL_7;
  }
  if (__p) {
    operator delete(__p);
  }
LABEL_7:
  if (a38)
  {
    operator delete(a38);
    if (!v66)
    {
LABEL_9:
      unint64_t v68 = a39;
      if (!a39) {
        goto LABEL_10;
      }
      goto LABEL_15;
    }
  }
  else if (!v66)
  {
    goto LABEL_9;
  }
  operator delete(v66);
  unint64_t v68 = a39;
  if (!a39)
  {
LABEL_10:
    if (!v63) {
      goto LABEL_11;
    }
    goto LABEL_16;
  }
LABEL_15:
  operator delete(v68);
  if (!v63)
  {
LABEL_11:
    if (!a40) {
      goto LABEL_12;
    }
    goto LABEL_17;
  }
LABEL_16:
  operator delete(v63);
  if (!a40) {
LABEL_12:
  }
    _Unwind_Resume(a1);
LABEL_17:
  operator delete(a40);
  _Unwind_Resume(a1);
}

uint64_t OCPointCloudCreateFromDenseDepthWithBoundingBox(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, int a5, uint64_t a6, double a7, double a8, double a9, float32x4_t a10, float32x4_t a11, float32x4_t a12, int8x16_t a13, uint64_t a14, uint64_t a15, long long a16, long long a17, long long a18, long long a19)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  long long v45 = a16;
  long long v46 = a17;
  long long v47 = a18;
  long long v48 = a19;
  if (sub_24B6E2768(a1, a2, a3, a4, a5, a6))
  {
    if (sub_24B6ED7CC((uint64_t)&v45))
    {
      float32x4_t v25 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
      float32x4_t v26 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
      float32x4_t v27 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
      uint32x4_t v28 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v27, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a10, *(float32x2_t *)a10.f32, 1), a11, *(float32x2_t *)a11.f32, 1), a12, *(float32x2_t *)a12.f32, 1), v25)), (int8x16_t)vcgeq_f32(v27, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a10, a10.f32[0]), a11, a11.f32[0]),
                                             a12,
                                             a12.f32[0]),
                                           *MEMORY[0x263EF89A0]))),
                          (int8x16_t)vcgeq_f32(v27, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a10, a10, 2), a11, a11, 2), a12, a12, 2), v26)));
      v28.i32[3] = v28.i32[2];
      if ((vminvq_u32(v28) & 0x80000000) != 0)
      {
        float32x4_t v29 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a11, 2);
        float32x4_t v30 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a10, (int32x4_t)a12), (int32x4_t)v29);
        float32x4_t v31 = (float32x4_t)vtrn2q_s32((int32x4_t)a10, (int32x4_t)a11);
        v31.i32[2] = a12.i32[1];
        float32x4_t v32 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a10, (int32x4_t)a12), (int32x4_t)a11);
        uint32x4_t v33 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v27, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v32, a11.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a11.f32, 1), v31), v29, v30), v25)), (int8x16_t)vcgeq_f32(v27, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v32, a10.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a10.f32, 1),
                                                 v31),
                                               (float32x4_t)vdupq_laneq_s32((int32x4_t)a10, 2),
                                               v30),
                                             *MEMORY[0x263EF89A0]))),
                            (int8x16_t)vcgeq_f32(v27, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v32, a12.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a12.f32, 1), v31), (float32x4_t)vdupq_laneq_s32((int32x4_t)a12, 2), v30), v26)));
        v33.i32[3] = v33.i32[2];
        if ((vminvq_u32(v33) & 0x80000000) != 0)
        {
          float32x4_t v34 = vmulq_f32(a10, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a12, (int8x16_t)a12, 0xCuLL), (int8x16_t)a12, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a11, (int32x4_t)a11), (int8x16_t)a11, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a12, (int32x4_t)a12), (int8x16_t)a12, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a11, (int8x16_t)a11, 0xCuLL), (int8x16_t)a11, 8uLL)));
          if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0]+ -1.0) <= 0.000011)
          {
            float32x2_t v35 = (float32x2_t)vdup_n_s32(0x38D1B717u);
            uint32x2_t v36 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v35, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a12, (int8x16_t)a12, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a13, a13, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v35, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a10, (int8x16_t)a10, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                             (int8x16_t)a11,
                                                                                             (int8x16_t)a11,
                                                                                             8uLL)))));
            if ((vpmin_u32(v36, v36).u32[0] & 0x80000000) != 0)
            {
              kdebug_trace();
              v51[0] = (__int128)a10;
              v51[1] = (__int128)a11;
              v51[2] = (__int128)a12;
              v51[3] = (__int128)a13;
              char v52 = 1;
              v49[0] = v45;
              v49[1] = v46;
              v49[2] = v47;
              v49[3] = v48;
              char v50 = 1;
              sub_24B6E2CB8(0, 0, 0, a1, a2, a3, a4, a5, 0, v51, (uint64_t)v49, a6);
            }
          }
        }
      }
      if (qword_2697D10F8 != -1) {
        dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
      }
      long long v37 = qword_2697D10F0;
      if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)simd_float4x4 buf = 136315394;
        BOOL v54 = "OCPointCloudCreateFromDenseDepthWithBoundingBox";
        __int16 v55 = 1026;
        int v56 = 1635;
        long long v38 = "%s:%{public}d Invalid camera to world transform, computing pointcloud without bounding box.";
LABEL_20:
        _os_log_debug_impl(&dword_24B6B9000, v37, OS_LOG_TYPE_DEBUG, v38, buf, 0x12u);
      }
    }
    else
    {
      if (qword_2697D10F8 != -1) {
        dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
      }
      long long v37 = qword_2697D10F0;
      if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)simd_float4x4 buf = 136315394;
        BOOL v54 = "OCPointCloudCreateFromDenseDepthWithBoundingBox";
        __int16 v55 = 1026;
        int v56 = 1629;
        long long v38 = "%s:%{public}d Invalid bounding box transform, computing pointcloud without bounding box.";
        goto LABEL_20;
      }
    }
  }
  else
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    int32x2_t v39 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      BOOL v54 = "OCPointCloudCreateFromDenseDepthWithBoundingBox";
      __int16 v55 = 1026;
      int v56 = 1623;
      _os_log_error_impl(&dword_24B6B9000, v39, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointcloud - invalid input.", buf, 0x12u);
    }
  }
  return 4294967294;
}

uint64_t OCPointCloudCreateFromDenseDepthWithPlaneClassification(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, int a5, long long *a6, uint64_t a7, double a8, double a9, double a10, int32x4_t a11, int32x4_t a12, int32x4_t a13, int8x16_t a14, float a15)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  if (sub_24B6E2768(a1, a2, a3, a4, a5, a7))
  {
    if (a6)
    {
      float32x4_t v24 = (float32x4_t)a11;
      float32x4_t v23 = (float32x4_t)a12;
      float32x4_t v25 = (float32x4_t)a13;
      float32x4_t v26 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v24, v24.f32[0]), v23, v23.f32[0]), v25, v25.f32[0]);
      float32x4_t v27 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v24, *(float32x2_t *)v24.f32, 1), v23, *(float32x2_t *)v23.f32, 1), v25, *(float32x2_t *)v25.f32, 1);
      float32x4_t v28 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v24, v24, 2), v23, v23, 2), v25, v25, 2);
      float32x4_t v29 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
      float32x4_t v30 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
      float32x4_t v31 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
      uint32x4_t v32 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v31, vabdq_f32(v27, v29)), (int8x16_t)vcgeq_f32(v31, vabdq_f32(v26, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v31, vabdq_f32(v28, v30)));
      v32.i32[3] = v32.i32[2];
      if ((vminvq_u32(v32) & 0x80000000) != 0)
      {
        float32x4_t v33 = (float32x4_t)vdupq_laneq_s32(a12, 2);
        float32x4_t v34 = (float32x4_t)vzip1q_s32(vzip2q_s32(a11, a13), (int32x4_t)v33);
        float32x4_t v35 = (float32x4_t)vtrn2q_s32(a11, a12);
        v35.i32[2] = a13.i32[1];
        float32x4_t v36 = (float32x4_t)vzip1q_s32(vzip1q_s32(a11, a13), a12);
        uint32x4_t v37 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v31, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v36, *(float *)a12.i32), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a12.i8, 1), v35), v33, v34), v29)), (int8x16_t)vcgeq_f32(v31, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v36, *(float *)a11.i32), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a11.i8, 1),
                                                 v35),
                                               (float32x4_t)vdupq_laneq_s32(a11, 2),
                                               v34),
                                             *MEMORY[0x263EF89A0]))),
                            (int8x16_t)vcgeq_f32(v31, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v36, *(float *)a13.i32), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a13.i8, 1), v35), (float32x4_t)vdupq_laneq_s32(a13, 2), v34), v30)));
        v37.i32[3] = v37.i32[2];
        if ((vminvq_u32(v37) & 0x80000000) != 0)
        {
          float32x4_t v38 = vmulq_f32((float32x4_t)a11, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a13, (int8x16_t)a13, 0xCuLL), (int8x16_t)a13, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(a12, a12), (int8x16_t)a12, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(a13, a13), (int8x16_t)a13, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a12, (int8x16_t)a12, 0xCuLL), (int8x16_t)a12, 8uLL)));
          if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a15 >= 0.0)
          {
            float32x2_t v42 = (float32x2_t)vdup_n_s32(0x38D1B717u);
            uint32x2_t v43 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v42, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a13, (int8x16_t)a13, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a14, a14, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v42, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a11, (int8x16_t)a11, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                             (int8x16_t)a12,
                                                                                             (int8x16_t)a12,
                                                                                             8uLL)))));
            if ((vpmin_u32(v43, v43).u32[0] & 0x80000000) != 0)
            {
              kdebug_trace();
              v49[0] = (__int128)a11;
              v49[1] = (__int128)a12;
              v49[2] = (__int128)a13;
              v49[3] = (__int128)a14;
              char v50 = 1;
              v48[0] = 0;
              v48[64] = 0;
              sub_24B6E2CB8(0, 0, 0, a1, a2, a3, a4, a5, a6, v49, (uint64_t)v48, a7);
            }
          }
        }
      }
    }
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    int32x2_t v39 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      char v52 = "OCPointCloudCreateFromDenseDepthWithPlaneClassification";
      __int16 v53 = 1026;
      int v54 = 1666;
      uint64_t v40 = "%s:%{public}d Invalid plane data.";
LABEL_15:
      _os_log_error_impl(&dword_24B6B9000, v39, OS_LOG_TYPE_ERROR, v40, buf, 0x12u);
    }
  }
  else
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    int32x2_t v39 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      char v52 = "OCPointCloudCreateFromDenseDepthWithPlaneClassification";
      __int16 v53 = 1026;
      int v54 = 1661;
      uint64_t v40 = "%s:%{public}d Failed to create pointcloud - invalid input.";
      goto LABEL_15;
    }
  }
  return 4294967294;
}

uint64_t OCPointCloudCreateFromDenseDepthWithPlaneClassificationAndBoundingBox(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, int a5, long long *a6, uint64_t a7, double a8, double a9, double a10, int32x4_t a11, int32x4_t a12, int32x4_t a13, int8x16_t a14, float a15, uint64_t a16, long long a17, long long a18, long long a19, long long a20)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  long long v54 = a17;
  long long v55 = a18;
  long long v56 = a19;
  long long v57 = a20;
  if (sub_24B6E2768(a1, a2, a3, a4, a5, a7))
  {
    if (a6)
    {
      float32x4_t v29 = (float32x4_t)a11;
      float32x4_t v28 = (float32x4_t)a12;
      float32x4_t v30 = (float32x4_t)a13;
      float32x4_t v31 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v29, v29.f32[0]), v28, v28.f32[0]), v30, v30.f32[0]);
      float32x4_t v32 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v29, *(float32x2_t *)v29.f32, 1), v28, *(float32x2_t *)v28.f32, 1), v30, *(float32x2_t *)v30.f32, 1);
      float32x4_t v33 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v29, v29, 2), v28, v28, 2), v30, v30, 2);
      float32x4_t v34 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
      float32x4_t v35 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
      float32x4_t v36 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
      uint32x4_t v37 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v36, vabdq_f32(v32, v34)), (int8x16_t)vcgeq_f32(v36, vabdq_f32(v31, *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v36, vabdq_f32(v33, v35)));
      v37.i32[3] = v37.i32[2];
      if ((vminvq_u32(v37) & 0x80000000) != 0)
      {
        float32x4_t v38 = (float32x4_t)vdupq_laneq_s32(a12, 2);
        float32x4_t v39 = (float32x4_t)vzip1q_s32(vzip2q_s32(a11, a13), (int32x4_t)v38);
        float32x4_t v40 = (float32x4_t)vtrn2q_s32(a11, a12);
        v40.i32[2] = a13.i32[1];
        float32x4_t v41 = (float32x4_t)vzip1q_s32(vzip1q_s32(a11, a13), a12);
        uint32x4_t v42 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v36, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v41, *(float *)a12.i32), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a12.i8, 1), v40), v38, v39), v34)), (int8x16_t)vcgeq_f32(v36, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v41, *(float *)a11.i32), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a11.i8, 1),
                                                 v40),
                                               (float32x4_t)vdupq_laneq_s32(a11, 2),
                                               v39),
                                             *MEMORY[0x263EF89A0]))),
                            (int8x16_t)vcgeq_f32(v36, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v41, *(float *)a13.i32), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a13.i8, 1), v40), (float32x4_t)vdupq_laneq_s32(a13, 2), v39), v35)));
        v42.i32[3] = v42.i32[2];
        if ((vminvq_u32(v42) & 0x80000000) != 0)
        {
          float32x4_t v43 = vmulq_f32((float32x4_t)a11, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a13, (int8x16_t)a13, 0xCuLL), (int8x16_t)a13, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(a12, a12), (int8x16_t)a12, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(a13, a13), (int8x16_t)a13, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a12, (int8x16_t)a12, 0xCuLL), (int8x16_t)a12, 8uLL)));
          if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v43, 2), vaddq_f32(v43, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a15 >= 0.0)
          {
            float32x2_t v47 = (float32x2_t)vdup_n_s32(0x38D1B717u);
            uint32x2_t v48 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v47, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a13, (int8x16_t)a13, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a14, a14, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v47, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a11, (int8x16_t)a11, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                             (int8x16_t)a12,
                                                                                             (int8x16_t)a12,
                                                                                             8uLL)))));
            if ((vpmin_u32(v48, v48).u32[0] & 0x80000000) != 0)
            {
              if (sub_24B6ED7CC((uint64_t)&v54))
              {
                kdebug_trace();
                v60[0] = (__int128)a11;
                v60[1] = (__int128)a12;
                v60[2] = (__int128)a13;
                void v60[3] = (__int128)a14;
                char v61 = 1;
                v58[0] = v54;
                v58[1] = v55;
                v58[2] = v56;
                v58[3] = v57;
                char v59 = 1;
                sub_24B6E2CB8(0, 0, 0, a1, a2, a3, a4, a5, a6, v60, (uint64_t)v58, a7);
              }
              if (qword_2697D10F8 != -1) {
                dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
              }
              unint64_t v49 = qword_2697D10F0;
              if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)simd_float4x4 buf = 136315394;
                size_t v63 = "OCPointCloudCreateFromDenseDepthWithPlaneClassificationAndBoundingBox";
                __int16 v64 = 1026;
                int v65 = 1703;
                _os_log_debug_impl(&dword_24B6B9000, v49, OS_LOG_TYPE_DEBUG, "%s:%{public}d Invalid bounding box transform.", buf, 0x12u);
              }
              return 4294967294;
            }
          }
        }
      }
    }
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    int8x8_t v44 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      size_t v63 = "OCPointCloudCreateFromDenseDepthWithPlaneClassificationAndBoundingBox";
      __int16 v64 = 1026;
      int v65 = 1698;
      long long v45 = "%s:%{public}d Invalid plane data.";
LABEL_15:
      _os_log_error_impl(&dword_24B6B9000, v44, OS_LOG_TYPE_ERROR, v45, buf, 0x12u);
    }
  }
  else
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    int8x8_t v44 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      size_t v63 = "OCPointCloudCreateFromDenseDepthWithPlaneClassificationAndBoundingBox";
      __int16 v64 = 1026;
      int v65 = 1693;
      long long v45 = "%s:%{public}d Failed to create pointcloud - invalid input.";
      goto LABEL_15;
    }
  }
  return 4294967294;
}

uint64_t OCPointCloudCreateFromSparseAndDenseDepth(unsigned int a1, uint64_t a2, uint64_t a3, CVPixelBufferRef pixelBuffer, __CVBuffer *a5, __CVBuffer *a6, __CVBuffer *a7, int a8, uint64_t a9)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (a1)
  {
    int v9 = a2;
    if (a2)
    {
      if (a3)
      {
        if (sub_24B6E2768(pixelBuffer, a5, a6, a7, a8, a9))
        {
          kdebug_trace();
          LOBYTE(v21[0]) = 0;
          char v22 = 0;
          v20[0] = 0;
          v20[64] = 0;
          sub_24B6E2CB8(a1, v9, a3, pixelBuffer, a5, a6, a7, a8, 0, v21, (uint64_t)v20, a9);
        }
        if (qword_2697D10F8 != -1) {
          dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
        }
        unsigned int v17 = qword_2697D10F0;
        if (!os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR)) {
          return 4294967294;
        }
        *(_DWORD *)simd_float4x4 buf = 136315394;
        float32x4_t v24 = "OCPointCloudCreateFromSparseAndDenseDepth";
        __int16 v25 = 1026;
        int v26 = 1734;
        uint64_t v18 = "%s:%{public}d Failed to create pointcloud - invalid input.";
LABEL_15:
        _os_log_error_impl(&dword_24B6B9000, v17, OS_LOG_TYPE_ERROR, v18, buf, 0x12u);
        return 4294967294;
      }
    }
  }
  if (qword_2697D10F8 != -1) {
    dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
  }
  unsigned int v17 = qword_2697D10F0;
  if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float32x4_t v24 = "OCPointCloudCreateFromSparseAndDenseDepth";
    __int16 v25 = 1026;
    int v26 = 1728;
    uint64_t v18 = "%s:%{public}d Invalid input pointcloud.";
    goto LABEL_15;
  }
  return 4294967294;
}

uint64_t OCPointCloudCreateFromSparseAndDenseDepthWithBoundingBox(unsigned int a1, uint64_t a2, uint64_t a3, CVPixelBufferRef pixelBuffer, __CVBuffer *a5, __CVBuffer *a6, __CVBuffer *a7, int a8, double a9, double a10, double a11, float32x4_t a12, float32x4_t a13, float32x4_t a14, int8x16_t a15, long long a16, long long a17, long long a18, long long a19, uint64_t a20)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  long long v49 = a16;
  long long v50 = a17;
  long long v51 = a18;
  long long v52 = a19;
  if (!a1 || (int v20 = a2, !a2) || !a3)
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    uint32x4_t v42 = qword_2697D10F0;
    if (!os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR)) {
      return 4294967294;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    unsigned int v58 = "OCPointCloudCreateFromSparseAndDenseDepthWithBoundingBox";
    __int16 v59 = 1026;
    int v60 = 1760;
    float32x4_t v43 = "%s:%{public}d Invalid input pointcloud.";
LABEL_22:
    _os_log_error_impl(&dword_24B6B9000, v42, OS_LOG_TYPE_ERROR, v43, buf, 0x12u);
    return 4294967294;
  }
  if ((sub_24B6E2768(pixelBuffer, a5, a6, a7, a8, a20) & 1) == 0)
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    uint32x4_t v42 = qword_2697D10F0;
    if (!os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR)) {
      return 4294967294;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    unsigned int v58 = "OCPointCloudCreateFromSparseAndDenseDepthWithBoundingBox";
    __int16 v59 = 1026;
    int v60 = 1766;
    float32x4_t v43 = "%s:%{public}d Failed to create pointcloud - invalid input.";
    goto LABEL_22;
  }
  if (sub_24B6ED7CC((uint64_t)&v49))
  {
    float32x4_t v28 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
    float32x4_t v29 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
    float32x4_t v30 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
    uint32x4_t v31 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v30, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a12, *(float32x2_t *)a12.f32, 1), a13, *(float32x2_t *)a13.f32, 1), a14, *(float32x2_t *)a14.f32, 1), v28)), (int8x16_t)vcgeq_f32(v30, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a12, a12.f32[0]), a13, a13.f32[0]),
                                           a14,
                                           a14.f32[0]),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v30, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a12, a12, 2), a13, a13, 2), a14, a14, 2), v29)));
    v31.i32[3] = v31.i32[2];
    if ((vminvq_u32(v31) & 0x80000000) != 0)
    {
      float32x4_t v32 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a13, 2);
      float32x4_t v33 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a12, (int32x4_t)a14), (int32x4_t)v32);
      float32x4_t v34 = (float32x4_t)vtrn2q_s32((int32x4_t)a12, (int32x4_t)a13);
      v34.i32[2] = a14.i32[1];
      float32x4_t v35 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a12, (int32x4_t)a14), (int32x4_t)a13);
      uint32x4_t v36 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v30, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v35, a13.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a13.f32, 1), v34), v32, v33), v28)), (int8x16_t)vcgeq_f32(v30, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v35, a12.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a12.f32, 1),
                                               v34),
                                             (float32x4_t)vdupq_laneq_s32((int32x4_t)a12, 2),
                                             v33),
                                           *MEMORY[0x263EF89A0]))),
                          (int8x16_t)vcgeq_f32(v30, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v35, a14.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a14.f32, 1), v34), (float32x4_t)vdupq_laneq_s32((int32x4_t)a14, 2), v33), v29)));
      v36.i32[3] = v36.i32[2];
      if ((vminvq_u32(v36) & 0x80000000) != 0)
      {
        float32x4_t v37 = vmulq_f32(a12, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a14, (int8x16_t)a14, 0xCuLL), (int8x16_t)a14, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a13, (int32x4_t)a13), (int8x16_t)a13, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a14, (int32x4_t)a14), (int8x16_t)a14, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a13, (int8x16_t)a13, 0xCuLL), (int8x16_t)a13, 8uLL)));
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).f32[0]+ -1.0) <= 0.000011)
        {
          float32x2_t v38 = (float32x2_t)vdup_n_s32(0x38D1B717u);
          uint32x2_t v39 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v38, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a14, (int8x16_t)a14, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a15, a15, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v38, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a12, (int8x16_t)a12, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                           (int8x16_t)a13,
                                                                                           (int8x16_t)a13,
                                                                                           8uLL)))));
          if ((vpmin_u32(v39, v39).u32[0] & 0x80000000) != 0)
          {
            kdebug_trace();
            v55[0] = (__int128)a12;
            v55[1] = (__int128)a13;
            v55[2] = (__int128)a14;
            v55[3] = (__int128)a15;
            char v56 = 1;
            v53[0] = v49;
            v53[1] = v50;
            v53[2] = v51;
            v53[3] = v52;
            char v54 = 1;
            sub_24B6E2CB8(a1, v20, a3, pixelBuffer, a5, a6, a7, a8, 0, v55, (uint64_t)v53, a20);
          }
        }
      }
    }
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    float32x4_t v40 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      unsigned int v58 = "OCPointCloudCreateFromSparseAndDenseDepthWithBoundingBox";
      __int16 v59 = 1026;
      int v60 = 1776;
      float32x4_t v41 = "%s:%{public}d Invalid camera to world transform.";
LABEL_28:
      _os_log_debug_impl(&dword_24B6B9000, v40, OS_LOG_TYPE_DEBUG, v41, buf, 0x12u);
    }
  }
  else
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    float32x4_t v40 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)simd_float4x4 buf = 136315394;
      unsigned int v58 = "OCPointCloudCreateFromSparseAndDenseDepthWithBoundingBox";
      __int16 v59 = 1026;
      int v60 = 1771;
      float32x4_t v41 = "%s:%{public}d Invalid bounding box transform.";
      goto LABEL_28;
    }
  }
  return 4294967294;
}

uint64_t OCPointCloudCreateFromSparseAndDenseDepthWithPlaneClassification(unsigned int a1, uint64_t a2, uint64_t a3, CVPixelBufferRef pixelBuffer, __CVBuffer *a5, __CVBuffer *a6, __CVBuffer *a7, int a8, double a9, double a10, double a11, float32x4_t a12, float32x4_t a13, float32x4_t a14, int8x16_t a15, float a16, long long *a17, uint64_t a18)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  if (!a1 || (int v18 = a2, !a2) || !a3)
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    uint32x2_t v39 = qword_2697D10F0;
    if (!os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR)) {
      return 4294967294;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    long long v50 = "OCPointCloudCreateFromSparseAndDenseDepthWithPlaneClassification";
    __int16 v51 = 1026;
    int v52 = 1802;
    float32x4_t v40 = "%s:%{public}d Invalid input pointcloud.";
LABEL_24:
    _os_log_error_impl(&dword_24B6B9000, v39, OS_LOG_TYPE_ERROR, v40, buf, 0x12u);
    return 4294967294;
  }
  if ((sub_24B6E2768(pixelBuffer, a5, a6, a7, a8, a18) & 1) == 0)
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    uint32x2_t v39 = qword_2697D10F0;
    if (!os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR)) {
      return 4294967294;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    long long v50 = "OCPointCloudCreateFromSparseAndDenseDepthWithPlaneClassification";
    __int16 v51 = 1026;
    int v52 = 1808;
    float32x4_t v40 = "%s:%{public}d Failed to create pointcloud - invalid input.";
    goto LABEL_24;
  }
  if (a17)
  {
    float32x4_t v27 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
    float32x4_t v28 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
    float32x4_t v29 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
    uint32x4_t v30 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v29, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a12, *(float32x2_t *)a12.f32, 1), a13, *(float32x2_t *)a13.f32, 1), a14, *(float32x2_t *)a14.f32, 1), v27)), (int8x16_t)vcgeq_f32(v29, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a12, a12.f32[0]), a13, a13.f32[0]),
                                           a14,
                                           a14.f32[0]),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v29, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a12, a12, 2), a13, a13, 2), a14, a14, 2), v28)));
    v30.i32[3] = v30.i32[2];
    if ((vminvq_u32(v30) & 0x80000000) != 0)
    {
      float32x4_t v31 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a13, 2);
      float32x4_t v32 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a12, (int32x4_t)a14), (int32x4_t)v31);
      float32x4_t v33 = (float32x4_t)vtrn2q_s32((int32x4_t)a12, (int32x4_t)a13);
      v33.i32[2] = a14.i32[1];
      float32x4_t v34 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a12, (int32x4_t)a14), (int32x4_t)a13);
      uint32x4_t v35 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v29, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v34, a13.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a13.f32, 1), v33), v31, v32), v27)), (int8x16_t)vcgeq_f32(v29, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v34, a12.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a12.f32, 1),
                                               v33),
                                             (float32x4_t)vdupq_laneq_s32((int32x4_t)a12, 2),
                                             v32),
                                           *MEMORY[0x263EF89A0]))),
                          (int8x16_t)vcgeq_f32(v29, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v34, a14.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a14.f32, 1), v33), (float32x4_t)vdupq_laneq_s32((int32x4_t)a14, 2), v32), v28)));
      v35.i32[3] = v35.i32[2];
      if ((vminvq_u32(v35) & 0x80000000) != 0)
      {
        float32x4_t v36 = vmulq_f32(a12, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a14, (int8x16_t)a14, 0xCuLL), (int8x16_t)a14, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a13, (int32x4_t)a13), (int8x16_t)a13, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a14, (int32x4_t)a14), (int8x16_t)a14, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a13, (int8x16_t)a13, 0xCuLL), (int8x16_t)a13, 8uLL)));
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a16 >= 0.0)
        {
          float32x2_t v37 = (float32x2_t)vdup_n_s32(0x38D1B717u);
          uint32x2_t v38 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v37, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a14, (int8x16_t)a14, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a15, a15, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v37, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a12, (int8x16_t)a12, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                           (int8x16_t)a13,
                                                                                           (int8x16_t)a13,
                                                                                           8uLL)))));
          if ((vpmin_u32(v38, v38).u32[0] & 0x80000000) != 0)
          {
            kdebug_trace();
            v47[0] = (__int128)a12;
            v47[1] = (__int128)a13;
            v47[2] = (__int128)a14;
            v47[3] = (__int128)a15;
            char v48 = 1;
            v46[0] = 0;
            v46[64] = 0;
            sub_24B6E2CB8(a1, v18, a3, pixelBuffer, a5, a6, a7, a8, a17, v47, (uint64_t)v46, a18);
          }
        }
      }
    }
  }
  if (qword_2697D10F8 != -1) {
    dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
  }
  uint32x2_t v39 = qword_2697D10F0;
  if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)simd_float4x4 buf = 136315394;
    long long v50 = "OCPointCloudCreateFromSparseAndDenseDepthWithPlaneClassification";
    __int16 v51 = 1026;
    int v52 = 1815;
    float32x4_t v40 = "%s:%{public}d Invalid plane data.";
    goto LABEL_24;
  }
  return 4294967294;
}

uint64_t OCPointCloudCreateFromSparseAndDenseDepthWithPlaneClassificationAndBoundingBox(unsigned int a1, uint64_t a2, uint64_t a3, CVPixelBufferRef pixelBuffer, __CVBuffer *a5, __CVBuffer *a6, __CVBuffer *a7, int a8, double a9, double a10, double a11, float32x4_t a12, float32x4_t a13, float32x4_t a14, int8x16_t a15, float a16, long long *a17, uint64_t a18, long long a19, long long a20,long long a21,long long a22,uint64_t a23)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  long long v52 = a19;
  long long v53 = a20;
  long long v54 = a21;
  long long v55 = a22;
  if (!a1 || (int v24 = a2, !a2) || !a3)
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    int8x8_t v44 = qword_2697D10F0;
    if (!os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR)) {
      return 4294967294;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint64_t v61 = "OCPointCloudCreateFromSparseAndDenseDepthWithPlaneClassificationAndBoundingBox";
    __int16 v62 = 1026;
    int v63 = 1842;
    long long v45 = "%s:%{public}d Invalid input pointcloud.";
LABEL_25:
    _os_log_error_impl(&dword_24B6B9000, v44, OS_LOG_TYPE_ERROR, v45, buf, 0x12u);
    return 4294967294;
  }
  if ((sub_24B6E2768(pixelBuffer, a5, a6, a7, a8, a23) & 1) == 0)
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    int8x8_t v44 = qword_2697D10F0;
    if (!os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR)) {
      return 4294967294;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint64_t v61 = "OCPointCloudCreateFromSparseAndDenseDepthWithPlaneClassificationAndBoundingBox";
    __int16 v62 = 1026;
    int v63 = 1848;
    long long v45 = "%s:%{public}d Failed to create pointcloud - invalid input.";
    goto LABEL_25;
  }
  if (a17)
  {
    float32x4_t v32 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
    float32x4_t v33 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
    float32x4_t v34 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
    uint32x4_t v35 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v34, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(a12, *(float32x2_t *)a12.f32, 1), a13, *(float32x2_t *)a13.f32, 1), a14, *(float32x2_t *)a14.f32, 1), v32)), (int8x16_t)vcgeq_f32(v34, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(a12, a12.f32[0]), a13, a13.f32[0]),
                                           a14,
                                           a14.f32[0]),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v34, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(a12, a12, 2), a13, a13, 2), a14, a14, 2), v33)));
    v35.i32[3] = v35.i32[2];
    if ((vminvq_u32(v35) & 0x80000000) != 0)
    {
      float32x4_t v36 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a13, 2);
      float32x4_t v37 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a12, (int32x4_t)a14), (int32x4_t)v36);
      float32x4_t v38 = (float32x4_t)vtrn2q_s32((int32x4_t)a12, (int32x4_t)a13);
      v38.i32[2] = a14.i32[1];
      float32x4_t v39 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a12, (int32x4_t)a14), (int32x4_t)a13);
      uint32x4_t v40 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v34, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v39, a13.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a13.f32, 1), v38), v36, v37), v32)), (int8x16_t)vcgeq_f32(v34, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v39, a12.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a12.f32, 1),
                                               v38),
                                             (float32x4_t)vdupq_laneq_s32((int32x4_t)a12, 2),
                                             v37),
                                           *MEMORY[0x263EF89A0]))),
                          (int8x16_t)vcgeq_f32(v34, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v39, a14.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a14.f32, 1), v38), (float32x4_t)vdupq_laneq_s32((int32x4_t)a14, 2), v37), v33)));
      v40.i32[3] = v40.i32[2];
      if ((vminvq_u32(v40) & 0x80000000) != 0)
      {
        float32x4_t v41 = vmulq_f32(a12, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)a14, (int8x16_t)a14, 0xCuLL), (int8x16_t)a14, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a13, (int32x4_t)a13), (int8x16_t)a13, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a14, (int32x4_t)a14), (int8x16_t)a14, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a13, (int8x16_t)a13, 0xCuLL), (int8x16_t)a13, 8uLL)));
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v41, 2), vaddq_f32(v41, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a16 >= 0.0)
        {
          float32x2_t v42 = (float32x2_t)vdup_n_s32(0x38D1B717u);
          uint32x2_t v43 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v42, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a14, (int8x16_t)a14, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a15, a15, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v42, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a12, (int8x16_t)a12, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                           (int8x16_t)a13,
                                                                                           (int8x16_t)a13,
                                                                                           8uLL)))));
          if ((vpmin_u32(v43, v43).u32[0] & 0x80000000) != 0)
          {
            if (sub_24B6ED7CC((uint64_t)&v52))
            {
              kdebug_trace();
              v58[0] = (__int128)a12;
              v58[1] = (__int128)a13;
              v58[2] = (__int128)a14;
              v58[3] = (__int128)a15;
              char v59 = 1;
              v56[0] = v52;
              v56[1] = v53;
              void v56[2] = v54;
              v56[3] = v55;
              char v57 = 1;
              sub_24B6E2CB8(a1, v24, a3, pixelBuffer, a5, a6, a7, a8, a17, v58, (uint64_t)v56, a23);
            }
            if (qword_2697D10F8 != -1) {
              dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
            }
            float32x2_t v47 = qword_2697D10F0;
            if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)simd_float4x4 buf = 136315394;
              uint64_t v61 = "OCPointCloudCreateFromSparseAndDenseDepthWithPlaneClassificationAndBoundingBox";
              __int16 v62 = 1026;
              int v63 = 1860;
              _os_log_debug_impl(&dword_24B6B9000, v47, OS_LOG_TYPE_DEBUG, "%s:%{public}d Invalid bounding box transform.", buf, 0x12u);
            }
            return 4294967294;
          }
        }
      }
    }
  }
  if (qword_2697D10F8 != -1) {
    dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
  }
  int8x8_t v44 = qword_2697D10F0;
  if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint64_t v61 = "OCPointCloudCreateFromSparseAndDenseDepthWithPlaneClassificationAndBoundingBox";
    __int16 v62 = 1026;
    int v63 = 1855;
    long long v45 = "%s:%{public}d Invalid plane data.";
    goto LABEL_25;
  }
  return 4294967294;
}

CFTypeRef OCPointCloudRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

uint64_t OCPointCloudSize(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return -1431655765 * ((*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 4);
  }
  if (qword_2697D10F8 != -1) {
    dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
  }
  unsigned int v2 = qword_2697D10F0;
  uint64_t result = os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v3 = 136315394;
    unsigned int v4 = "OCPointCloudSize";
    __int16 v5 = 1026;
    int v6 = 1896;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid pointcloud.", (uint8_t *)&v3, 0x12u);
    return 0;
  }
  return result;
}

uint64_t OCPointCloudPoints(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (!a1 || (uint64_t result = *(void *)(a1 + 96), result == *(void *)(a1 + 104)))
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    int v3 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      int v4 = 136315394;
      __int16 v5 = "OCPointCloudPoints";
      __int16 v6 = 1026;
      int v7 = 1905;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid pointcloud.", (uint8_t *)&v4, 0x12u);
    }
    return 0;
  }
  return result;
}

uint64_t OCPointCloudPointSupplements(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (!a1 || (uint64_t result = *(void *)(a1 + 120), result == *(void *)(a1 + 128)))
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    int v3 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      int v4 = 136315394;
      __int16 v5 = "OCPointCloudPointSupplements";
      __int16 v6 = 1026;
      int v7 = 1914;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid pointcloud.", (uint8_t *)&v4, 0x12u);
    }
    return 0;
  }
  return result;
}

double OCPointCloudGetData@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 16);
    uint64_t v3 = *(void *)(a1 + 96);
    *(_DWORD *)(a2 + 80) = -1431655765 * ((unint64_t)(*(void *)(a1 + 104) - v3) >> 4);
    long long v4 = *(_OWORD *)(a1 + 48);
    *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 32);
    *(_OWORD *)(a2 + 32) = v4;
    long long v5 = *(_OWORD *)(a1 + 64);
    long long v6 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)(a2 + 48) = v5;
    *(_OWORD *)(a2 + 64) = v6;
    *(void *)(a2 + 88) = v3;
  }
  else
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    int v7 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315394;
      unsigned int v10 = "OCPointCloudGetData";
      __int16 v11 = 1026;
      int v12 = 1924;
      _os_log_error_impl(&dword_24B6B9000, v7, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid pointcloud.", (uint8_t *)&v9, 0x12u);
    }
    *(void *)&long long v5 = 0;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
  return *(double *)&v5;
}

float OCPointCloudScale(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(float *)(a1 + 16);
  }
  if (qword_2697D10F8 != -1) {
    dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
  }
  unsigned int v2 = qword_2697D10F0;
  float v1 = 0.0;
  if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
  {
    int v4 = 136315394;
    long long v5 = "OCPointCloudScale";
    __int16 v6 = 1026;
    int v7 = 1938;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid pointcloud.", (uint8_t *)&v4, 0x12u);
  }
  return v1;
}

double OCPointCloudTransformMatrix(float32x4_t *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(void *)&double result = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(a1[2], a1[1].f32[0]), (float32x4_t)0, a1[3]), (float32x4_t)0, a1[4]), (float32x4_t)0, a1[5]).u64[0];
  }
  else
  {
    if (qword_2697D10F8 != -1) {
      dispatch_once(&qword_2697D10F8, &unk_26FE9CB30);
    }
    unsigned int v2 = qword_2697D10F0;
    if (os_log_type_enabled((os_log_t)qword_2697D10F0, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315394;
      int v4 = "OCPointCloudTransformMatrix";
      __int16 v5 = 1026;
      int v6 = 1947;
      _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Invalid pointcloud.", (uint8_t *)&v3, 0x12u);
    }
    return 0.0;
  }
  return result;
}

void sub_24B6E7544(void *a1)
{
  *a1 = &unk_26FE9CC98;
  unsigned int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B6E75B4(void *a1)
{
  *a1 = &unk_26FE9CC98;
  unsigned int v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

double sub_24B6E7604(uint64_t a1, uint64_t a2, float32x4_t a3)
{
  int v3 = *(float32x4_t **)(a1 + 8);
  a3.i32[0] = *(_DWORD *)a2;
  uint64_t v4 = *(void *)(a1 + 16) - (void)v3;
  if (v4)
  {
    unint64_t v5 = v4 / 48;
    float v7 = *(float *)(a2 + 4);
    float v6 = *(float *)(a2 + 8);
    if (v5 <= 1) {
      unint64_t v5 = 1;
    }
    uint64_t v8 = v3 + 1;
    v9.i64[0] = 0;
    v9.i32[2] = 0;
    float v10 = 3.4028e38;
    float32x4_t v11 = 0uLL;
    do
    {
      float v12 = sqrtf((float)((float)((float)(a3.f32[0] - COERCE_FLOAT(*(_OWORD *)&v8[-1]))* (float)(a3.f32[0] - COERCE_FLOAT(*(_OWORD *)&v8[-1])))+ (float)((float)(v7 - COERCE_FLOAT(HIDWORD(v8[-1].i64[0])))* (float)(v7 - COERCE_FLOAT(HIDWORD(v8[-1].i64[0])))))+ (float)((float)(v6 - COERCE_FLOAT(v8[-1].i64[1])) * (float)(v6 - COERCE_FLOAT(v8[-1].i64[1]))));
      if (v10 > v12)
      {
        float32x4_t v11 = *v8;
        float32x4_t v9 = v8[-1];
        float v10 = v12;
      }
      v8 += 3;
      --v5;
    }
    while (v5);
  }
  else
  {
    float v7 = *(float *)(a2 + 4);
    float v6 = *(float *)(a2 + 8);
    float32x4_t v11 = 0uLL;
    v9.i64[0] = 0;
    v9.i32[2] = 0;
  }
  a3.f32[1] = v7;
  *(float32x2_t *)a3.f32 = vsub_f32(*(float32x2_t *)a3.f32, *(float32x2_t *)v9.f32);
  a3.f32[2] = v6 - v9.f32[2];
  float32x4_t v13 = vmulq_f32(v11, a3);
  *(void *)&double result = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).u64[0];
  return result;
}

void sub_24B6E76DC(char **a1, unint64_t a2)
{
  unint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - v5) >> 4) >= a2)
  {
    if (a2)
    {
      size_t v12 = 48 * ((48 * a2 - 48) / 0x30) + 48;
      bzero(a1[1], v12);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    float v6 = *a1;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 4);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x555555555555555) {
      abort();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v6) >> 4);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v10 = 0x555555555555555;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x555555555555555) {
        sub_24B6BCD7C();
      }
      float32x4_t v11 = (char *)operator new(48 * v10);
    }
    else
    {
      float32x4_t v11 = 0;
    }
    float32x4_t v13 = &v11[48 * v7];
    float v14 = &v11[48 * v10];
    size_t v15 = 48 * ((48 * a2 - 48) / 0x30) + 48;
    bzero(v13, v15);
    int v16 = &v13[v15];
    if (v5 != v6)
    {
      do
      {
        long long v17 = *((_OWORD *)v5 - 3);
        long long v18 = *((_OWORD *)v5 - 1);
        *((_OWORD *)v13 - 2) = *((_OWORD *)v5 - 2);
        *((_OWORD *)v13 - 1) = v18;
        *((_OWORD *)v13 - 3) = v17;
        v13 -= 48;
        v5 -= 48;
      }
      while (v5 != v6);
      unint64_t v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v14;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_24B6E7888(char **a1, unint64_t a2, uint64_t a3, float *a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    uint64_t v4 = 2 * a2;
    if ((2 * a2) >> 61) {
LABEL_155:
    }
      abort();
    unint64_t v8 = (char *)operator new(16 * a2);
    uint64_t v9 = 0;
    unint64_t v10 = a1;
    *a1 = v8;
    a1[1] = v8;
    a1[2] = &v8[8 * v4];
    float32x4_t v11 = v8;
    size_t v12 = v8;
    float32x4_t v13 = v8;
    uint64_t v93 = a3;
    unint64_t v94 = a2;
    unint64_t v14 = a2;
    while (1)
    {
      uint64_t v15 = v9 + 1;
      if (v9 + 1 == v14) {
        unint64_t v16 = 0;
      }
      else {
        unint64_t v16 = v9 + 1;
      }
      if (v14 <= v16) {
        sub_24B6E81D8();
      }
      long long v17 = (float *)(a3 + 8 * v9);
      float v18 = a4[1];
      float v19 = a4[2] - *a4;
      float v20 = a4[3] - v18;
      float v21 = (float)(v19 * (float)(v18 - v17[1])) - (float)((float)(*a4 - *v17) * v20);
      BOOL v22 = v21 < 0.0 || fabsf(v21 / sqrtf((float)(v19 * v19) + (float)(v20 * v20))) <= 0.000001;
      float32x4_t v23 = (float *)(a3 + 8 * v16);
      float v24 = v23[1];
      float v25 = (float)(v19 * (float)(v18 - v24)) - (float)((float)(*a4 - *v23) * v20);
      if (v25 >= 0.0)
      {
        float v26 = fabsf(v25 / sqrtf((float)(v19 * v19) + (float)(v20 * v20)));
        if (v26 <= 0.000001 && v22)
        {
LABEL_21:
          if (v11 == v8
            || vabds_f32(*((float *)v8 - 2), *v23) > (float)((float)(fabsf(*v23) * 0.00001) + 0.000001)
            || vabds_f32(*((float *)v8 - 1), v24) > (float)((float)(fabsf(v24) * 0.00001) + 0.000001))
          {
            unint64_t v28 = (unint64_t)v10[2];
            if ((unint64_t)v8 < v28)
            {
              *(void *)unint64_t v8 = *(void *)v23;
              size_t v12 = v8 + 8;
              goto LABEL_69;
            }
            uint64_t v32 = (v8 - v11) >> 3;
            unint64_t v33 = v32 + 1;
            if ((unint64_t)(v32 + 1) >> 61) {
              goto LABEL_155;
            }
            uint64_t v34 = v28 - (void)v11;
            if (v34 >> 2 > v33) {
              unint64_t v33 = v34 >> 2;
            }
            if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v35 = v33;
            }
            if (v35)
            {
              if (v35 >> 61) {
                goto LABEL_156;
              }
              float32x4_t v36 = operator new(8 * v35);
              unint64_t v10 = a1;
            }
            else
            {
              float32x4_t v36 = 0;
            }
            int8x8_t v44 = &v36[8 * v32];
            *(void *)int8x8_t v44 = *(void *)v23;
            size_t v12 = v44 + 8;
            if (v11 == v8)
            {
              float32x4_t v11 = &v36[8 * v32];
              a3 = v93;
            }
            else
            {
              unint64_t v45 = v8 - 8 - v11;
              if (v45 < 0x168
                || &v36[v8 - v11 - 8 - (v45 & 0xFFFFFFFFFFFFFFF8)] > &v36[v8 - v11 - 8]
                || &v8[-(v45 & 0xFFFFFFFFFFFFFFF8) - 8] > v8 - 8
                || (unint64_t)(v11 - v36) < 0x20)
              {
                long long v46 = v8;
                a3 = v93;
                goto LABEL_63;
              }
              uint64_t v69 = (v45 >> 3) + 1;
              long long v46 = &v8[-8 * (v69 & 0x3FFFFFFFFFFFFFFCLL)];
              uint64_t v70 = &v36[8 * v32 - 16];
              float32_t v71 = v8 - 16;
              uint64_t v72 = v69 & 0x3FFFFFFFFFFFFFFCLL;
              a3 = v93;
              do
              {
                long long v73 = *(_OWORD *)v71;
                *(v70 - 1) = *((_OWORD *)v71 - 1);
                *uint64_t v70 = v73;
                v70 -= 2;
                v71 -= 32;
                v72 -= 4;
              }
              while (v72);
              v44 -= 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
              if (v69 != (v69 & 0x3FFFFFFFFFFFFFFCLL))
              {
                do
                {
LABEL_63:
                  uint64_t v47 = *((void *)v46 - 1);
                  v46 -= 8;
                  *((void *)v44 - 1) = v47;
                  v44 -= 8;
                }
                while (v46 != v11);
              }
              unint64_t v8 = *v10;
              float32x4_t v11 = v44;
            }
            const char *v10 = v11;
            v10[1] = v12;
            v10[2] = &v36[8 * v35];
            if (v8)
            {
              operator delete(v8);
              unint64_t v10 = a1;
            }
            unint64_t v14 = v94;
LABEL_69:
            v10[1] = v12;
            unint64_t v8 = v12;
          }
          else
          {
            size_t v12 = v8;
          }
          float32x4_t v13 = v11;
          goto LABEL_6;
        }
        if (v26 > 0.000001)
        {
          if (!v22) {
            goto LABEL_6;
          }
          uint64_t v98 = 0;
          uint64_t v42 = *(void *)v23;
          uint64_t v96 = *(void *)v17;
          uint64_t v97 = v42;
          sub_24B6E81E8(a4, (float *)&v96, (float *)&v98);
          if (v13 != v12
            && vabds_f32(*((float *)v12 - 2), *(float *)&v98) <= (float)((float)(fabsf(*(float *)&v98) * 0.00001)
                                                                       + 0.000001)
            && vabds_f32(*((float *)v12 - 1), *((float *)&v98 + 1)) <= (float)((float)(fabsf(*((float *)&v98 + 1))
                                                                                     * 0.00001)
                                                                             + 0.000001))
          {
            unint64_t v10 = a1;
            goto LABEL_6;
          }
          unint64_t v10 = a1;
          unint64_t v43 = (unint64_t)a1[2];
          if ((unint64_t)v12 >= v43)
          {
            uint64_t v64 = (v12 - v13) >> 3;
            unint64_t v65 = v64 + 1;
            if ((unint64_t)(v64 + 1) >> 61) {
              goto LABEL_155;
            }
            uint64_t v66 = v43 - (void)v13;
            if (v66 >> 2 > v65) {
              unint64_t v65 = v66 >> 2;
            }
            if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v67 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v67 = v65;
            }
            if (v67)
            {
              if (v67 >> 61) {
LABEL_156:
              }
                sub_24B6BCD7C();
              unint64_t v68 = (char *)operator new(8 * v67);
              unint64_t v10 = a1;
            }
            else
            {
              unint64_t v68 = 0;
            }
            float32x4_t v11 = &v68[8 * v64];
            *(void *)float32x4_t v11 = v98;
            unint64_t v8 = v11 + 8;
            if (v13 != v12)
            {
              unint64_t v84 = v12 - 8 - v13;
              if (v84 < 0x168
                || &v68[v12 - v13 - 8 - (v84 & 0xFFFFFFFFFFFFFFF8)] > &v68[v12 - v13 - 8]
                || &v12[-(v84 & 0xFFFFFFFFFFFFFFF8) - 8] > v12 - 8
                || (unint64_t)(v13 - v68) < 0x20)
              {
                float v85 = v12;
                a3 = v93;
              }
              else
              {
                uint64_t v87 = (v84 >> 3) + 1;
                float v85 = &v12[-8 * (v87 & 0x3FFFFFFFFFFFFFFCLL)];
                int8x16_t v88 = &v68[8 * v64 - 16];
                int32x4_t v89 = v12 - 16;
                uint64_t v90 = v87 & 0x3FFFFFFFFFFFFFFCLL;
                a3 = v93;
                do
                {
                  long long v91 = *(_OWORD *)v89;
                  *((_OWORD *)v88 - 1) = *((_OWORD *)v89 - 1);
                  *(_OWORD *)int8x16_t v88 = v91;
                  v88 -= 32;
                  v89 -= 32;
                  v90 -= 4;
                }
                while (v90);
                v11 -= 8 * (v87 & 0x3FFFFFFFFFFFFFFCLL);
                if (v87 == (v87 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_140:
                  size_t v12 = *v10;
LABEL_142:
                  const char *v10 = v11;
                  v10[1] = v8;
                  v10[2] = &v68[8 * v67];
                  if (v12)
                  {
                    operator delete(v12);
                    unint64_t v10 = a1;
                  }
                  float32x4_t v13 = v11;
                  unint64_t v14 = v94;
                  goto LABEL_5;
                }
              }
              do
              {
                uint64_t v86 = *((void *)v85 - 1);
                v85 -= 8;
                *((void *)v11 - 1) = v86;
                v11 -= 8;
              }
              while (v85 != v13);
              goto LABEL_140;
            }
            a3 = v93;
            goto LABEL_142;
          }
          *(void *)size_t v12 = v98;
          unint64_t v8 = v12 + 8;
          goto LABEL_5;
        }
      }
      else if (v22)
      {
        goto LABEL_21;
      }
      uint64_t v98 = 0;
      uint64_t v29 = *(void *)v23;
      uint64_t v96 = *(void *)v17;
      uint64_t v97 = v29;
      sub_24B6E81E8(a4, (float *)&v96, (float *)&v98);
      if (v13 != v12
        && vabds_f32(*((float *)v12 - 2), *(float *)&v98) <= (float)((float)(fabsf(*(float *)&v98) * 0.00001) + 0.000001))
      {
        float v30 = *((float *)&v98 + 1);
        if (vabds_f32(*((float *)v12 - 1), *((float *)&v98 + 1)) <= (float)((float)(fabsf(*((float *)&v98 + 1))
                                                                                   * 0.00001)
                                                                           + 0.000001))
        {
          float v51 = *(float *)&v29;
          unint64_t v10 = a1;
          goto LABEL_86;
        }
      }
      unint64_t v10 = a1;
      unint64_t v31 = (unint64_t)a1[2];
      if ((unint64_t)v12 >= v31) {
        break;
      }
      *(void *)size_t v12 = v98;
      unint64_t v8 = v12 + 8;
LABEL_85:
      v10[1] = v8;
      float v30 = *((float *)&v98 + 1);
      float v51 = *v23;
      size_t v12 = v8;
      uint64_t v29 = *(void *)v23;
LABEL_86:
      BOOL v54 = vabds_f32(*(float *)&v98, v51) > (float)((float)(fabsf(v51) * 0.00001) + 0.000001);
      float v52 = vabds_f32(v30, *((float *)&v29 + 1));
      float v53 = (float)(fabsf(*((float *)&v29 + 1)) * 0.00001) + 0.000001;
      BOOL v54 = v54 || v52 > v53;
      if (!v54) {
        goto LABEL_6;
      }
      unint64_t v55 = (unint64_t)v10[2];
      if ((unint64_t)v12 >= v55)
      {
        uint64_t v56 = (v12 - v13) >> 3;
        unint64_t v57 = v56 + 1;
        if ((unint64_t)(v56 + 1) >> 61) {
          goto LABEL_155;
        }
        uint64_t v58 = v55 - (void)v13;
        if (v58 >> 2 > v57) {
          unint64_t v57 = v58 >> 2;
        }
        if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
        }
        unint64_t v92 = v57;
        if (v57)
        {
          if (v57 >> 61) {
            goto LABEL_156;
          }
          char v59 = (char *)operator new(8 * v57);
          uint64_t v29 = *(void *)v23;
          unint64_t v10 = a1;
        }
        else
        {
          char v59 = 0;
        }
        float32x4_t v11 = &v59[8 * v56];
        *(void *)float32x4_t v11 = v29;
        unint64_t v8 = v11 + 8;
        if (v12 == v13)
        {
          a3 = v93;
          unint64_t v14 = v94;
          unint64_t v62 = v92;
        }
        else
        {
          unint64_t v60 = v12 - 8 - v13;
          if (v60 < 0x168
            || &v59[v12 - v13 - 8 - (v60 & 0xFFFFFFFFFFFFFFF8)] > &v59[v12 - v13 - 8]
            || &v12[-(v60 & 0xFFFFFFFFFFFFFFF8) - 8] > v12 - 8
            || (unint64_t)(v13 - v59) < 0x20)
          {
            uint64_t v61 = v12;
            a3 = v93;
            unint64_t v14 = v94;
            unint64_t v62 = v92;
            goto LABEL_108;
          }
          uint64_t v79 = (v60 >> 3) + 1;
          uint64_t v61 = &v12[-8 * (v79 & 0x3FFFFFFFFFFFFFFCLL)];
          float v80 = &v59[8 * v56 - 16];
          float v81 = v12 - 16;
          uint64_t v82 = v79 & 0x3FFFFFFFFFFFFFFCLL;
          a3 = v93;
          do
          {
            long long v83 = *(_OWORD *)v81;
            *((_OWORD *)v80 - 1) = *((_OWORD *)v81 - 1);
            *(_OWORD *)float v80 = v83;
            v80 -= 32;
            v81 -= 32;
            v82 -= 4;
          }
          while (v82);
          v11 -= 8 * (v79 & 0x3FFFFFFFFFFFFFFCLL);
          unint64_t v14 = v94;
          unint64_t v62 = v92;
          if (v79 != (v79 & 0x3FFFFFFFFFFFFFFCLL))
          {
            do
            {
LABEL_108:
              uint64_t v63 = *((void *)v61 - 1);
              v61 -= 8;
              *((void *)v11 - 1) = v63;
              v11 -= 8;
            }
            while (v61 != v13);
          }
          size_t v12 = *v10;
        }
        const char *v10 = v11;
        v10[1] = v8;
        v10[2] = &v59[8 * v62];
        if (v12)
        {
          operator delete(v12);
          unint64_t v10 = a1;
        }
        float32x4_t v13 = v11;
        goto LABEL_5;
      }
      *(void *)size_t v12 = v29;
      unint64_t v8 = v12 + 8;
LABEL_5:
      v10[1] = v8;
      size_t v12 = v8;
LABEL_6:
      uint64_t v9 = v15;
      if (v15 == v14) {
        return;
      }
    }
    uint64_t v37 = (v12 - v13) >> 3;
    unint64_t v38 = v37 + 1;
    if ((unint64_t)(v37 + 1) >> 61) {
      goto LABEL_155;
    }
    uint64_t v39 = v31 - (void)v13;
    if (v39 >> 2 > v38) {
      unint64_t v38 = v39 >> 2;
    }
    if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v40 = v38;
    }
    if (v40)
    {
      if (v40 >> 61) {
        goto LABEL_156;
      }
      float32x4_t v41 = (char *)operator new(8 * v40);
      unint64_t v10 = a1;
    }
    else
    {
      float32x4_t v41 = 0;
    }
    float32x4_t v11 = &v41[8 * v37];
    *(void *)float32x4_t v11 = v98;
    unint64_t v8 = v11 + 8;
    if (v13 == v12)
    {
      a3 = v93;
      goto LABEL_82;
    }
    unint64_t v48 = v12 - 8 - v13;
    if (v48 >= 0x168
      && &v41[v12 - v13 - 8 - (v48 & 0xFFFFFFFFFFFFFFF8)] <= &v41[v12 - v13 - 8]
      && &v12[-(v48 & 0xFFFFFFFFFFFFFFF8) - 8] <= v12 - 8
      && (unint64_t)(v13 - v41) >= 0x20)
    {
      uint64_t v74 = (v48 >> 3) + 1;
      long long v49 = &v12[-8 * (v74 & 0x3FFFFFFFFFFFFFFCLL)];
      unint64_t v75 = &v41[8 * v37 - 16];
      float v76 = v12 - 16;
      uint64_t v77 = v74 & 0x3FFFFFFFFFFFFFFCLL;
      a3 = v93;
      do
      {
        long long v78 = *(_OWORD *)v76;
        *((_OWORD *)v75 - 1) = *((_OWORD *)v76 - 1);
        *(_OWORD *)unint64_t v75 = v78;
        v75 -= 32;
        v76 -= 32;
        v77 -= 4;
      }
      while (v77);
      v11 -= 8 * (v74 & 0x3FFFFFFFFFFFFFFCLL);
      if (v74 == (v74 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_80;
      }
    }
    else
    {
      long long v49 = v12;
      a3 = v93;
    }
    do
    {
      uint64_t v50 = *((void *)v49 - 1);
      v49 -= 8;
      *((void *)v11 - 1) = v50;
      v11 -= 8;
    }
    while (v49 != v13);
LABEL_80:
    size_t v12 = *v10;
LABEL_82:
    const char *v10 = v11;
    v10[1] = v8;
    v10[2] = &v41[8 * v40];
    if (v12)
    {
      operator delete(v12);
      unint64_t v10 = a1;
    }
    float32x4_t v13 = v11;
    unint64_t v14 = v94;
    goto LABEL_85;
  }
}

void sub_24B6E81D8()
{
}

float *sub_24B6E81E8(float *result, float *a2, float *a3)
{
  float v4 = a2[2];
  float v3 = a2[3];
  float v6 = *a2;
  float v5 = a2[1];
  unint64_t v7 = result + 2;
  float v8 = result[2];
  float v10 = *result;
  float v9 = result[1];
  float v11 = v8 - *result;
  float v12 = v4 - *a2;
  float v13 = result[3];
  float v14 = (float)((float)(v3 - v5) * v11) - (float)(v12 * (float)(v13 - v9));
  float v15 = *result - *a2;
  float v16 = (float)(v12 * (float)(v9 - v5)) - (float)((float)(v3 - v5) * v15);
  if (fabsf(v14) > 0.000001)
  {
    *a3 = v10 + (float)((float)(v16 / v14) * v11);
    float v17 = result[1] + (float)((float)(v16 / v14) * (float)(result[3] - result[1]));
LABEL_3:
    a3[1] = v17;
    return result;
  }
  float v18 = fabsf((float)(v11 * (float)(v9 - v5)) - (float)((float)(v13 - v9) * v15));
  if (fabsf(v16) <= 0.000001 && v18 <= 0.000001)
  {
    BOOL v20 = v6 == v10 && v5 == v9;
    if (v20 || (v4 == v10 ? (BOOL v21 = v3 == v9) : (BOOL v21 = 0), v21))
    {
      if (a3 != result) {
        *(void *)a3 = *(void *)result;
      }
    }
    else if (v4 == v8 && v3 == v13 || v6 == v8 && v5 == v13)
    {
      if (v7 != a3) {
        *(void *)a3 = *(void *)v7;
      }
    }
    else
    {
      BOOL v22 = v6 > v10;
      if (v4 <= v10) {
        BOOL v22 = 0;
      }
      if (!v22 || v6 <= v8 || v4 <= v8)
      {
        BOOL v23 = v5 > v9;
        if (v3 <= v9) {
          BOOL v23 = 0;
        }
        if (!v23 || v5 <= v13 || v3 <= v13)
        {
          BOOL v24 = v6 < v10;
          if (v4 >= v10) {
            BOOL v24 = 0;
          }
          if (!v24 || v6 >= v8 || v4 >= v8)
          {
            BOOL v25 = v5 < v9;
            if (v3 >= v9) {
              BOOL v25 = 0;
            }
            if (!v25 || v5 >= v13 || v3 >= v13)
            {
              BOOL v26 = v10 > v8 && v24;
              BOOL v27 = v9 > v13 && v25;
              float v28 = result[1];
              float v29 = *result;
              if (!v26)
              {
                float v28 = result[1];
                float v29 = *result;
                if (!v27)
                {
                  if (v6 >= v8 || v4 >= v8 || (float v28 = result[3], v29 = result[2], v8 <= v10))
                  {
                    if (v5 >= v13 || v3 >= v13 || (float v28 = result[3], v29 = result[2], v13 <= v9))
                    {
                      if (v6 <= v10 || v6 <= v4 || (float v28 = a2[1], v29 = *a2, v6 <= v8))
                      {
                        BOOL v30 = v5 > v13;
                        BOOL v31 = v5 > v9;
                        if (v5 <= v3) {
                          BOOL v31 = 0;
                        }
                        if (v31 && v30) {
                          float v28 = a2[1];
                        }
                        else {
                          float v28 = a2[3];
                        }
                        if (v31 && v30) {
                          float v29 = *a2;
                        }
                        else {
                          float v29 = a2[2];
                        }
                      }
                    }
                  }
                }
              }
              if ((v29 != v10 || v28 != v9)
                && (v10 < v8 ? (v32 = v22) : (v32 = 0), v9 < v13 ? (BOOL v33 = v23) : (BOOL v33 = 0), v32 || v33))
              {
                float v5 = result[1];
                float v6 = *result;
              }
              else
              {
                if (v29 == v8 && v28 == v13) {
                  goto LABEL_103;
                }
                BOOL v34 = v5 > v13;
                if (v3 <= v13) {
                  BOOL v34 = 0;
                }
                if (v9 <= v13) {
                  BOOL v34 = 0;
                }
                BOOL v35 = v10 <= v8 || v4 <= v8;
                BOOL v36 = v35 || v6 <= v8;
                if (v36 && !v34)
                {
LABEL_103:
                  if (v29 == v6 && v28 == v5
                    || (v6 >= v10 || v6 >= v4 || v6 >= v8) && (v5 >= v9 || v5 >= v3 || v5 >= v13))
                  {
                    float v5 = a2[3];
                    float v6 = a2[2];
                  }
                }
                else
                {
                  float v5 = result[3];
                  float v6 = result[2];
                }
              }
              *(void *)a3 = 0;
              float v37 = *result;
              if (*result != v29 || (float v38 = 0.0, v39 = 0.0, result[1] != v28))
              {
                if (v37 != v6 || (float v38 = 0.0, v39 = 0.0, result[1] != v5))
                {
                  float v39 = v37 + 0.0;
                  *a3 = v37 + 0.0;
                  float v38 = result[1] + 0.0;
                  a3[1] = v38;
                }
              }
              float v40 = *v7;
              if ((*v7 != v29 || result[3] != v28) && (v40 != v6 || result[3] != v5))
              {
                float v39 = v40 + v39;
                *a3 = v39;
                float v38 = result[3] + v38;
                a3[1] = v38;
              }
              float v41 = *a2;
              float v42 = a2[1];
              if ((*a2 != v29 || v42 != v28) && (v41 != v6 || v42 != v5))
              {
                float v39 = v41 + v39;
                *a3 = v39;
                float v38 = a2[1] + v38;
                a3[1] = v38;
              }
              float v43 = a2[2];
              float v44 = a2[3];
              if ((v43 != v29 || v44 != v28) && (v43 != v6 || v44 != v5))
              {
                float v39 = v43 + v39;
                *a3 = v39;
                float v38 = a2[3] + v38;
              }
              float v17 = v38 * 0.5;
              *a3 = v39 * 0.5;
              goto LABEL_3;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_24B6E8618(float32x2_t **a1, float32x2_t *a2, float32x4_t *a3, uint32x2_t *a4)
{
  float v4 = a4;
  bzero(*(void **)&a4[3], (a4[1].i32[1] * a4[2].i32[1]));
  float v9 = *a1;
  float v8 = a1[1];
  uint64_t v240 = 0;
  if (v9 == v8)
  {
    float v235 = 0;
    BOOL v35 = 0;
    goto LABEL_112;
  }
  id v238 = v4;
  float v10 = 0;
  float v11 = 0;
  float v12 = 0;
  do
  {
    float32x4_t v15 = a3[1];
    float32x4_t v13 = vaddq_f32(a3[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a3, COERCE_FLOAT(*(_OWORD *)v9->f32)), v15, *v9, 1), a3[2], *(float32x4_t *)v9->f32, 2));
    float v14 = v13.f32[2];
    v15.i32[0] = 925353388;
    if (v13.f32[2] >= 0.00001) {
      v15.f32[0] = v13.f32[2];
    }
    float32x2_t v16 = *a2;
    v16.i32[1] = a2[2].i32[1];
    float32x2_t v17 = vadd_f32(a2[4], vdiv_f32(vmul_f32(v16, *(float32x2_t *)v13.f32), (float32x2_t)vdup_lane_s32(*(int32x2_t *)v15.f32, 0)));
    if (v12 < v11)
    {
      *(float32x2_t *)float v12 = v17;
      v12 += 2;
      goto LABEL_24;
    }
    int64_t v18 = (char *)v12 - (char *)v10;
    uint64_t v19 = ((char *)v12 - (char *)v10) >> 3;
    unint64_t v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 61) {
      goto LABEL_348;
    }
    if (v11 - v10 > v20) {
      unint64_t v20 = v11 - v10;
    }
    if ((unint64_t)((char *)v11 - (char *)v10) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v21 = v20;
    }
    if (v21)
    {
      if (v21 >> 61) {
LABEL_349:
      }
        sub_24B6BCD7C();
      BOOL v22 = v8;
      BOOL v23 = v10;
      BOOL v24 = operator new(8 * v21);
      float v10 = v23;
      float v8 = v22;
    }
    else
    {
      BOOL v24 = 0;
    }
    BOOL v25 = (float32x2_t *)&v24[8 * v19];
    *BOOL v25 = v17;
    BOOL v26 = (float *)&v25[1];
    if (v12 != v10)
    {
      unint64_t v27 = (char *)(v12 - 2) - (char *)v10;
      if (v27 >= 0x168)
      {
        if (&v24[v18 - 8 - (v27 & 0xFFFFFFFFFFFFFFF8)] > &v24[v18 - 8])
        {
          float v28 = v12;
        }
        else if ((float *)((char *)v12 - (v27 & 0xFFFFFFFFFFFFFFF8) - 8) > v12 - 2)
        {
          float v28 = v12;
        }
        else if ((unint64_t)((char *)v12 - &v24[v18]) >= 0x20)
        {
          uint64_t v30 = (v27 >> 3) + 1;
          float v28 = &v12[-2 * (v30 & 0x3FFFFFFFFFFFFFFCLL)];
          BOOL v31 = &v24[8 * v19 - 16];
          BOOL v32 = v12 - 4;
          uint64_t v33 = v30 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v34 = *(_OWORD *)v32;
            *(v31 - 1) = *((_OWORD *)v32 - 1);
            _OWORD *v31 = v34;
            v31 -= 2;
            v32 -= 8;
            v33 -= 4;
          }
          while (v33);
          v25 -= v30 & 0x3FFFFFFFFFFFFFFCLL;
          if (v30 == (v30 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_21;
          }
        }
        else
        {
          float v28 = v12;
        }
      }
      else
      {
        float v28 = v12;
      }
      do
      {
        float32x2_t v29 = *(float32x2_t *)(v28 - 2);
        v28 -= 2;
        v25[-1] = v29;
        --v25;
      }
      while (v28 != v10);
    }
LABEL_21:
    float v11 = (float *)&v24[8 * v21];
    if (v10) {
      operator delete(v10);
    }
    float v10 = (float *)v25;
    float v12 = v26;
LABEL_24:
    if (v14 < 0.00001)
    {
      uint64_t v36 = 0;
      if (v10) {
        goto LABEL_311;
      }
      return v36;
    }
    v9 += 2;
  }
  while (v9 != v8);
  float v235 = v10;
  if (v10 == v12)
  {
    BOOL v35 = 0;
  }
  else
  {
    float v37 = v10 + 2;
    float v38 = v10;
    if (v10 + 2 != v12)
    {
      float v39 = v10 + 2;
      float v38 = v10;
      do
      {
        if (*v39 < *v38
          || vabds_f32(*v39, *v38) <= (float)((float)(fabsf(*v38) * 0.00001) + 0.000001) && v39[1] < v38[1])
        {
          float v38 = v39;
        }
        v39 += 2;
      }
      while (v39 != v12);
    }
    v252[0] = *(void *)v38;
    float32x4_t v243 = (float *)v252;
    size_t v40 = (char *)v12 - (char *)v10;
    unint64_t v41 = ((char *)v12 - (char *)v10) >> 3;
    float v42 = (char *)v10;
    sub_24B6EA818((uint64_t)v10, v12, &v243, 126 - 2 * __clz(v41), 1);
    if (v37 == v12)
    {
      float v44 = (float *)v42;
    }
    else
    {
      float v43 = *(float *)v42;
      float v44 = (float *)v42;
      while (1)
      {
        float v45 = v43;
        long long v46 = v37 - 2;
        float v43 = *v37;
        if (vabds_f32(v45, *v37) <= (float)((float)(fabsf(*v37) * 0.00001) + 0.000001)
          && vabds_f32(*(v37 - 1), v37[1]) <= (float)((float)(fabsf(v37[1]) * 0.00001) + 0.000001))
        {
          break;
        }
        v37 += 2;
        if (v37 == v12) {
          goto LABEL_64;
        }
      }
      if (v46 != v12)
      {
        uint64_t v47 = v37 + 2;
        if (v37 + 2 != v12)
        {
          float v48 = *v46;
          do
          {
            if (vabds_f32(v48, *v47) > (float)((float)(fabsf(*v47) * 0.00001) + 0.000001)
              || vabds_f32(v46[1], v47[1]) > (float)((float)(fabsf(v47[1]) * 0.00001) + 0.000001))
            {
              uint64_t v49 = *(void *)v47;
              *((void *)v46 + 1) = *(void *)v47;
              v46 += 2;
              float v48 = *(float *)&v49;
            }
            v47 += 2;
          }
          while (v47 != v12);
        }
        long long v198 = v46 + 2;
        if (v46 + 2 != v12)
        {
          int64_t v199 = (char *)v198 - v42;
          long long v200 = &v42[((char *)v198 - v42) & 0xFFFFFFFFFFFFFFF8];
          uint64_t v201 = (char *)v12 - (char *)v198;
          long long v202 = (float *)&v200[(char *)v12 - (char *)v198];
          if (v202 == v12) {
            goto LABEL_335;
          }
          unint64_t v203 = (char *)v12 - &v42[v201 + (v199 & 0xFFFFFFFFFFFFFFF8)] - 8;
          if (v203 < 0x58 || (unint64_t)(v201 + 31) < 0x20)
          {
            unint64_t v207 = v200;
          }
          else
          {
            uint64_t v204 = v201 >> 3;
            uint64_t v205 = (v203 >> 3) + 1;
            uint64_t v206 = 8 * (v205 & 0x3FFFFFFFFFFFFFFCLL);
            unint64_t v207 = &v200[v206];
            uint64_t v208 = 8 * v204;
            uint64_t v209 = v205 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v210 = *(_OWORD *)&v200[v208 + 16];
              *(_OWORD *)long long v200 = *(_OWORD *)&v200[v208];
              *((_OWORD *)v200 + 1) = v210;
              v200 += 32;
              v209 -= 4;
            }
            while (v209);
            if (v205 == (v205 & 0x3FFFFFFFFFFFFFFCLL))
            {
              long long v200 = v207;
              goto LABEL_335;
            }
            long long v202 = (float *)((char *)v202 + v206);
          }
          long long v200 = v207;
          do
          {
            uint64_t v225 = *(void *)v202;
            v202 += 2;
            *(void *)long long v200 = v225;
            v200 += 8;
          }
          while (v202 != v12);
LABEL_335:
          size_t v40 = v200 - v42;
          unint64_t v41 = (v200 - v42) >> 3;
          float v12 = (float *)v200;
        }
      }
    }
LABEL_64:
    if (v12 != v44)
    {
      if ((v40 & 0x8000000000000000) == 0)
      {
        BOOL v35 = (float *)operator new(v40);
        uint64_t v50 = &v35[2 * v41];
        float v51 = v35;
        float v52 = v235;
        while (1)
        {
          float v55 = *v52;
          float v54 = v52[1];
          uint64_t v56 = (char *)v51 - (char *)v35;
          if ((unint64_t)((char *)v51 - (char *)v35) < 9
            || ((float v57 = (float)((float)(*(v51 - 2) - *(v51 - 4)) * (float)(v54 - *(v51 - 1)))
                     - (float)((float)(*(v51 - 1) - *(v51 - 3)) * (float)(v55 - *(v51 - 2))),
                 float v58 = fabsf(v57),
                 v57 > 0.0)
              ? (BOOL v59 = v58 > 0.000001)
              : (BOOL v59 = 0),
                v59))
          {
            uint64_t v66 = v51;
          }
          else
          {
            unint64_t v60 = v51 - 3;
            uint64_t v61 = v51 - 2;
            do
            {
              unint64_t v62 = v60;
              float v51 = v61;
              if ((unint64_t)((char *)v61 - (char *)v35) <= 8) {
                break;
              }
              v60 -= 2;
              float v63 = (float)((float)(*(v62 - 1) - *(v62 - 3)) * (float)(v54 - *v62))
                  - (float)((float)(*v62 - *(v62 - 2)) * (float)(v55 - *(v62 - 1)));
              float v64 = fabsf(v63);
              v61 -= 2;
            }
            while (v63 <= 0.0 || v64 <= 0.000001);
            uint64_t v66 = v62 + 1;
            uint64_t v56 = (char *)v51 - (char *)v35;
          }
          if (v66 >= v50) {
            break;
          }
          *uint64_t v66 = v55;
          v66[1] = v54;
          float v51 = v66 + 2;
LABEL_68:
          float v53 = v51;
          v52 += 2;
          if (v52 == v12) {
            goto LABEL_110;
          }
        }
        uint64_t v67 = v56 >> 3;
        unint64_t v68 = (v56 >> 3) + 1;
        if (v68 >> 61) {
          goto LABEL_348;
        }
        uint64_t v69 = (char *)v50 - (char *)v35;
        if (v50 - v35 > v68) {
          unint64_t v68 = v69 >> 2;
        }
        if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (v68)
        {
          if (v68 >> 61) {
            goto LABEL_349;
          }
          unint64_t v70 = v68;
          float32_t v71 = (char *)operator new(8 * v68);
        }
        else
        {
          unint64_t v70 = 0;
          float32_t v71 = 0;
        }
        uint64_t v72 = (float *)&v71[8 * v67];
        *uint64_t v72 = v55;
        v72[1] = v54;
        if (v66 == v35)
        {
          unint64_t v75 = (float *)&v71[8 * v67];
        }
        else
        {
          unint64_t v73 = (char *)(v51 - 2) - (char *)v35;
          if (v73 < 0x168
            || &v71[(v56 & 0xFFFFFFFFFFFFFFF8) - 8 - (v73 & 0xFFFFFFFFFFFFFFF8)] > &v71[(v56 & 0xFFFFFFFFFFFFFFF8)
                                                                                          - 8]
            || (float *)((char *)v66 - (v73 & 0xFFFFFFFFFFFFFFF8) - 8) > v66 - 2
            || (unint64_t)((char *)v51 - &v71[v56 & 0xFFFFFFFFFFFFFFF8]) < 0x20)
          {
            uint64_t v74 = v66;
            unint64_t v75 = (float *)&v71[8 * v67];
          }
          else
          {
            uint64_t v77 = (v73 >> 3) + 1;
            uint64_t v74 = &v66[-2 * (v77 & 0x3FFFFFFFFFFFFFFCLL)];
            long long v78 = &v71[8 * v67 - 16];
            uint64_t v79 = v66 - 4;
            uint64_t v80 = v77 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v81 = *(_OWORD *)v79;
              *((_OWORD *)v78 - 1) = *((_OWORD *)v79 - 1);
              *(_OWORD *)long long v78 = v81;
              v78 -= 32;
              v79 -= 8;
              v80 -= 4;
            }
            while (v80);
            unint64_t v75 = &v72[-2 * (v77 & 0x3FFFFFFFFFFFFFFCLL)];
            if (v77 == (v77 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_99;
            }
          }
          do
          {
            uint64_t v76 = *((void *)v74 - 1);
            v74 -= 2;
            *((void *)v75 - 1) = v76;
            v75 -= 2;
          }
          while (v74 != v35);
        }
LABEL_99:
        float v51 = v72 + 2;
        uint64_t v50 = (float *)&v71[8 * v70];
        if (v35)
        {
          unint64_t v242 = &v71[8 * v70];
          operator delete(v35);
          uint64_t v50 = (float *)v242;
        }
        BOOL v35 = v75;
        goto LABEL_68;
      }
LABEL_348:
      abort();
    }
    BOOL v35 = 0;
    float v53 = 0;
LABEL_110:
    uint64_t v240 = v53;
  }
  float v4 = v238;
LABEL_112:
  uint64_t v82 = (float32x2_t *)operator new(0x40uLL);
  *uint64_t v82 = 0;
  v82[1].i32[1] = 0;
  __asm { FMOV            V1.2S, #-1.0 }
  float32x2_t v86 = vadd_f32(vcvt_f32_u32(v4[1]), _D1);
  v82[2].i32[0] = v86.i32[0];
  uint64_t v87 = (float *)&v82[2];
  v82[2].i32[1] = 0;
  v82[1].i32[0] = v86.i32[0];
  void v82[3] = v86;
  v82[4] = v86;
  int8x16_t v88 = (float *)&v82[4];
  v82[5].i32[0] = 0;
  v82[5].i32[1] = v86.i32[1];
  v82[6].i32[0] = 0;
  int32x4_t v89 = (float *)&v82[6];
  v82[6].i32[1] = v86.i32[1];
  std::string __p = v82;
  v82[7] = 0;
  if ((char *)v240 - (char *)v35 <= -8 || !v35 && v240) {
    goto LABEL_330;
  }
  sub_24B6E7888((char **)&v243, ((char *)v240 - (char *)v35) >> 3, (uint64_t)v35, (float *)v82);
  if (v35) {
    operator delete(v35);
  }
  uint64_t v90 = v243;
  if ((char *)v244 - (char *)v243 < -7 || !v243 && v244) {
    goto LABEL_330;
  }
  sub_24B6E7888((char **)&v243, ((char *)v244 - (char *)v243) >> 3, (uint64_t)v243, v87);
  if (v90) {
    operator delete(v90);
  }
  long long v91 = v243;
  if ((char *)v244 - (char *)v243 < -7 || !v243 && v244) {
    goto LABEL_330;
  }
  sub_24B6E7888((char **)&v243, ((char *)v244 - (char *)v243) >> 3, (uint64_t)v243, v88);
  if (v91) {
    operator delete(v91);
  }
  unint64_t v92 = v243;
  if ((char *)v244 - (char *)v243 < -7 || !v243 && v244) {
    goto LABEL_330;
  }
  sub_24B6E7888((char **)&v243, ((char *)v244 - (char *)v243) >> 3, (uint64_t)v243, v89);
  if (v92) {
    operator delete(v92);
  }
  uint64_t v93 = v4;
  long long v95 = v243;
  unint64_t v94 = v244;
  float v236 = v243;
  if (v243 != v244)
  {
    uint64_t v96 = 0;
    uint64_t v97 = 0;
    uint64_t v98 = 0;
    while (v97 < v98)
    {
      *(void *)uint64_t v97 = (int)*v95 | ((unint64_t)(int)v95[1] << 32);
      long long v99 = v97 + 8;
LABEL_135:
      v95 += 2;
      uint64_t v97 = v99;
      if (v95 == v94) {
        goto LABEL_165;
      }
    }
    uint64_t v100 = (v97 - v96) >> 3;
    unint64_t v101 = v100 + 1;
    if ((unint64_t)(v100 + 1) >> 61) {
      goto LABEL_348;
    }
    if ((v98 - v96) >> 2 > v101) {
      unint64_t v101 = (v98 - v96) >> 2;
    }
    if ((unint64_t)(v98 - v96) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v102 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v102 = v101;
    }
    if (v102)
    {
      if (v102 >> 61) {
        goto LABEL_349;
      }
      int v103 = operator new(8 * v102);
    }
    else
    {
      int v103 = 0;
    }
    char v104 = (unint64_t *)&v103[8 * v100];
    unint64_t *v104 = (int)*v95 | ((unint64_t)(int)v95[1] << 32);
    long long v99 = (char *)(v104 + 1);
    if (v97 != v96)
    {
      unint64_t v105 = v97 - 8 - v96;
      if (v105 < 0x168)
      {
        int v106 = v97;
        goto LABEL_150;
      }
      if (&v103[v97 - v96 - 8 - (v105 & 0xFFFFFFFFFFFFFFF8)] > &v103[v97 - v96 - 8])
      {
        int v106 = v97;
        goto LABEL_150;
      }
      if (&v97[-(v105 & 0xFFFFFFFFFFFFFFF8) - 8] > v97 - 8)
      {
        int v106 = v97;
        goto LABEL_150;
      }
      if ((unint64_t)(v96 - v103) < 0x20)
      {
        int v106 = v97;
        goto LABEL_150;
      }
      uint64_t v108 = (v105 >> 3) + 1;
      int v106 = &v97[-8 * (v108 & 0x3FFFFFFFFFFFFFFCLL)];
      long long v109 = &v103[8 * v100 - 16];
      long long v110 = v97 - 16;
      uint64_t v111 = v108 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v112 = *(_OWORD *)v110;
        *(v109 - 1) = *((_OWORD *)v110 - 1);
        _OWORD *v109 = v112;
        v109 -= 2;
        v110 -= 32;
        v111 -= 4;
      }
      while (v111);
      v104 -= v108 & 0x3FFFFFFFFFFFFFFCLL;
      if (v108 != (v108 & 0x3FFFFFFFFFFFFFFCLL))
      {
        do
        {
LABEL_150:
          unint64_t v107 = *((void *)v106 - 1);
          v106 -= 8;
          *--char v104 = v107;
        }
        while (v106 != v96);
      }
    }
    uint64_t v98 = &v103[8 * v102];
    if (v96) {
      operator delete(v96);
    }
    uint64_t v96 = (char *)v104;
    goto LABEL_135;
  }
  long long v99 = 0;
  uint64_t v96 = 0;
LABEL_165:
  uint64_t v113 = v99 - v96;
  if (v99 - v96 <= -8) {
    goto LABEL_330;
  }
  _ZF = v99 && v96 == 0;
  if (_ZF) {
    goto LABEL_330;
  }
  uint32x2_t v115 = v93[3];
  float32x4_t v244 = (float *)*v93;
  long long v245 = *(_OWORD *)v93[1].i8;
  float32x4_t v243 = (float *)v245;
  uint32x2_t v246 = v115;
  v247.i8[0] = -1;
  long long v116 = v236;
  if (v99 == v96) {
    goto LABEL_306;
  }
  if ((unint64_t)v113 >= 0x7FFFFFFFFFFFFFF9) {
    goto LABEL_348;
  }
  uint64_t v117 = v113 >> 3;
  int64_t v234 = v99 - v96;
  long long v118 = (__n128 *)operator new(2 * v113);
  unint64_t v120 = v117;
  long long v121 = v118;
  uint64_t v122 = 0;
  signed int v123 = 0x80000000;
  int v124 = 0x7FFFFFFF;
  long long v125 = v118;
  long long v126 = v118;
  uint64_t v127 = &v118[v117];
  uint64_t v239 = v117;
  do
  {
    uint64_t v128 = v122 + 1;
    if (v122 + 1 == v120) {
      unint64_t v129 = 0;
    }
    else {
      unint64_t v129 = v122 + 1;
    }
    if (v120 <= v129) {
      goto LABEL_330;
    }
    uint64_t v130 = (int *)&v96[8 * v122];
    uint64_t v131 = (int *)&v96[8 * v129];
    int v132 = v131[1];
    int v133 = v130[1];
    if (v132 >= v133) {
      signed __int32 v134 = v130[1];
    }
    else {
      signed __int32 v134 = v131[1];
    }
    if (v133 <= v132) {
      signed int v135 = v131[1];
    }
    else {
      signed int v135 = v130[1];
    }
    if (v134 < v124) {
      int v124 = v134;
    }
    if (v123 <= v135) {
      signed int v123 = v135;
    }
    if (v134 != v135)
    {
      int v136 = *v131;
      int v137 = *v130;
      _VF = __OFSUB__(v132, v133);
      int v138 = v132 - v133;
      float v139 = (float)(v136 - v137) / (float)v138;
      if (v138 < 0 != _VF) {
        int v140 = v136;
      }
      else {
        int v140 = v137;
      }
      if (v125 < v127)
      {
        v125->n128_u32[0] = v134;
        v125->n128_u32[1] = v135;
        v119.n128_f32[0] = (float)v140;
        v125->n128_f32[2] = (float)v140;
        v125->n128_f32[3] = v139;
        ++v125;
      }
      else
      {
        uint64_t v141 = v125 - v126;
        unint64_t v142 = v141 + 1;
        if ((unint64_t)(v141 + 1) >> 60) {
          goto LABEL_348;
        }
        signed int v241 = v123;
        if (((char *)v127 - (char *)v126) >> 3 > v142) {
          unint64_t v142 = ((char *)v127 - (char *)v126) >> 3;
        }
        if ((unint64_t)((char *)v127 - (char *)v126) >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v142 = 0xFFFFFFFFFFFFFFFLL;
        }
        if (v142 >> 60) {
          goto LABEL_349;
        }
        uint64_t v143 = 16 * v142;
        uint64_t v144 = (char *)operator new(16 * v142);
        unint64_t v145 = (__n128 *)&v144[16 * v141];
        v145->n128_u32[0] = v134;
        v145->n128_u32[1] = v135;
        v119.n128_f32[0] = (float)v140;
        v145->n128_f32[2] = (float)v140;
        v145->n128_f32[3] = v139;
        if (v125 == v126)
        {
          long long v121 = (__n128 *)&v144[16 * v141];
        }
        else
        {
          unint64_t v146 = (__n128 *)&v144[16 * v141];
          do
          {
            __n128 v119 = v125[-1];
            long long v121 = v146 - 1;
            v146[-1] = v119;
            --v125;
            --v146;
          }
          while (v125 != v126);
        }
        uint64_t v127 = (__n128 *)&v144[v143];
        long long v125 = v145 + 1;
        if (v126) {
          operator delete(v126);
        }
        long long v126 = v121;
        signed int v123 = v241;
        unint64_t v120 = v239;
      }
    }
    uint64_t v122 = v128;
  }
  while (v128 != v120);
  unint64_t v147 = 126 - 2 * __clz(v125 - v121);
  signed int v148 = v123;
  if (v125 == v121) {
    uint64_t v149 = 0;
  }
  else {
    uint64_t v149 = v147;
  }
  sub_24B6E9838((unint64_t)v121, v125, v149, 1, v119);
  BOOL v150 = v124 <= v148;
  if (v124 != v148)
  {
    int v155 = v148;
    long long v116 = v236;
    if (!v150) {
      goto LABEL_304;
    }
    unint64_t v156 = 0;
    unint64_t v157 = 1;
    while (1)
    {
      if (v156 <= v157) {
        unint64_t v159 = v157;
      }
      else {
        unint64_t v159 = v156;
      }
      if (v124 < v155 && v121[v156].n128_u32[1] == v124) {
        unint64_t v160 = v159 + 1;
      }
      else {
        unint64_t v160 = v156;
      }
      if (v160 <= v157) {
        unint64_t v161 = v157;
      }
      else {
        unint64_t v161 = v160;
      }
      if (v124 < v155 && v121[v157].n128_u32[1] == v124) {
        unint64_t v157 = v161 + 1;
      }
      float v162 = v121[v160].n128_f32[2];
      float v163 = v121[v157].n128_f32[2];
      if (v162 <= v163) {
        unint64_t v156 = v160;
      }
      else {
        unint64_t v156 = v157;
      }
      if (v162 > v163) {
        unint64_t v157 = v160;
      }
      float v158 = v121[v156].n128_f32[2];
      if (v124 < 0) {
        goto LABEL_221;
      }
      if (SHIDWORD(v243) <= v124) {
        goto LABEL_221;
      }
      int v164 = llroundf(v121[v157].n128_f32[2]);
      if (v164 < 0) {
        goto LABEL_221;
      }
      int v165 = llroundf(v158);
      if ((int)v243 <= v165) {
        goto LABEL_221;
      }
      uint64_t v166 = v165 & ~(v165 >> 31);
      int v167 = v243 - 1;
      if ((int)v243 - 1 >= v164) {
        int v167 = v164;
      }
      uint32x2_t v168 = v246;
      uint64_t v169 = (HIDWORD(v245) * v124);
      uint64_t v170 = (unsigned char *)(*(void *)&v246 + v169 + v166);
      unint64_t v171 = *(void *)&v246 + v169 + v167 + 1;
      unint64_t v172 = v171 - (void)v170;
      if ((uint64_t)(v171 - (void)v170) < 1) {
        goto LABEL_221;
      }
      if (v172 < 8) {
        goto LABEL_262;
      }
      if (v170 < (unsigned char *)&v247 + 1 && (unint64_t)&v247 < v171) {
        goto LABEL_262;
      }
      if (v172 >= 0x20)
      {
        unint64_t v174 = v172 & 0xFFFFFFFFFFFFFFE0;
        int8x16_t v175 = vdupq_lane_s8(v247, 0);
        uint64_t v176 = (int8x16_t *)(*(void *)&v246 + v169 + v166 + 16);
        unint64_t v177 = v172 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          v176[-1] = v175;
          *uint64_t v176 = v175;
          v176 += 2;
          v177 -= 32;
        }
        while (v177);
        if (v172 == v174) {
          goto LABEL_220;
        }
        if ((v172 & 0x18) == 0)
        {
          v172 &= 0x1Fu;
          v170 += v174;
          goto LABEL_262;
        }
      }
      else
      {
        unint64_t v174 = 0;
      }
      v170 += v172 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v178 = &v247;
      int8x8_t v179 = vld1_dup_s8((const char *)v178);
      unint64_t v180 = v174 - (v172 & 0xFFFFFFFFFFFFFFF8);
      unint64_t v181 = (int8x8_t *)(*(void *)&v168 + v174 + v166 + v169);
      do
      {
        *v181++ = v179;
        v180 += 8;
      }
      while (v180);
      if (v172 == (v172 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_220;
      }
      v172 &= 7u;
LABEL_262:
      unint64_t v182 = v172 + 1;
      do
      {
        *v170++ = v247.i8[0];
        --v182;
      }
      while (v182 > 1);
LABEL_220:
      float v158 = v121[v156].n128_f32[2];
LABEL_221:
      v121[v156].n128_f32[2] = v121[v156].n128_f32[3] + v158;
      v121[v157].n128_f32[2] = v121[v157].n128_f32[3] + v121[v157].n128_f32[2];
      _ZF = v124++ == v155;
      if (_ZF) {
        goto LABEL_305;
      }
    }
  }
  v252[0] = v239;
  v252[1] = v96;
  float32x4_t v249 = v252;
  uint64_t v250 = 0;
  float32x4_t v151 = v252;
  uint64_t v248 = 0;
  if (v234 == 8) {
    goto LABEL_302;
  }
  int v152 = *((_DWORD *)v96 + 2);
  int v153 = *(_DWORD *)v96;
  float32x4_t v154 = &v248;
  if (v152 < *(_DWORD *)v96) {
    float32x4_t v154 = &v250;
  }
  uint64_t *v154 = 1;
  if (v234 == 16) {
    goto LABEL_216;
  }
  uint64_t v183 = 0;
  BOOL v59 = v152 < v153;
  uint64_t v184 = v152 >= v153;
  uint64_t v185 = v59;
  uint64_t v186 = v250;
  uint64_t v187 = v248;
  uint64_t v188 = v239 - 2;
  long long v189 = (int *)(v96 + 24);
  uint64_t v190 = 1;
  while (2)
  {
    if (v188 == v183) {
      goto LABEL_330;
    }
    uint64_t v191 = v183 + 2;
    if (v239 - 3 != v183)
    {
      v190 += 2;
      int v192 = *v189;
      int v193 = *(v189 - 2);
      if (*v189 >= v193)
      {
        if (v185 == v239 || v184 == v239) {
          goto LABEL_330;
        }
        if (v193 < *(_DWORD *)&v96[8 * v185])
        {
          uint64_t v185 = v183 + 2;
          uint64_t v186 = v183 + 2;
        }
        uint64_t v191 = v190;
        if (v192 < *(_DWORD *)&v96[8 * v184])
        {
LABEL_270:
          v183 += 2;
          v189 += 4;
          if (v188 == v183)
          {
            float32x4_t v151 = v252;
            float32x4_t v249 = v252;
            uint64_t v250 = v186;
            uint64_t v248 = v187;
            goto LABEL_302;
          }
          continue;
        }
      }
      else
      {
        if (v185 == v239 || v184 == v239) {
          goto LABEL_330;
        }
        if (v192 < *(_DWORD *)&v96[8 * v185])
        {
          uint64_t v185 = v183 + 3;
          uint64_t v186 = v183 + 3;
        }
        if (v193 < *(_DWORD *)&v96[8 * v184]) {
          goto LABEL_270;
        }
      }
      uint64_t v187 = v191;
      uint64_t v184 = v191;
      goto LABEL_270;
    }
    break;
  }
  uint32x4_t v251 = v252;
  float32x4_t v249 = v252;
  uint64_t v250 = v186;
  uint64_t v248 = v187;
  if (v185 == v239) {
    goto LABEL_330;
  }
  uint64_t v194 = 8 * v185;
  int v195 = *(_DWORD *)&v96[8 * v191];
  if (v195 < *(_DWORD *)&v96[v194])
  {
    long long v196 = &v250;
    long long v197 = &v251;
LABEL_301:
    *long long v197 = v252;
    uint64_t *v196 = v191;
    float32x4_t v151 = v251;
    goto LABEL_302;
  }
  if (v184 == v239) {
    goto LABEL_330;
  }
  if (v195 >= *(_DWORD *)&v96[8 * v184])
  {
    long long v196 = &v248;
    long long v197 = &v249;
    goto LABEL_301;
  }
LABEL_216:
  float32x4_t v151 = v252;
LABEL_302:
  long long v116 = v236;
  if (v252 != v151 || v250 != v239)
  {
    if (v250 != *v151 && v248 != *v249)
    {
      long long v212 = (int *)(v151[1] + 8 * v250);
      int v213 = v212[1];
      if (v213 < 0) {
        goto LABEL_304;
      }
      if (SHIDWORD(v243) <= v213) {
        goto LABEL_304;
      }
      int v214 = *(_DWORD *)(v249[1] + 8 * v248);
      if (v214 < 0) {
        goto LABEL_304;
      }
      int v215 = *v212;
      if ((int)v243 <= v215) {
        goto LABEL_304;
      }
      uint64_t v216 = v215 & ~(v215 >> 31);
      int v217 = v243 - 1;
      if ((int)v243 - 1 >= v214) {
        int v217 = *(_DWORD *)(v249[1] + 8 * v248);
      }
      uint32x2_t v218 = v246;
      uint64_t v219 = (HIDWORD(v245) * v213);
      long long v220 = (unsigned char *)(*(void *)&v246 + v219 + v216);
      unint64_t v221 = *(void *)&v246 + v219 + v217 + 1;
      unint64_t v222 = v221 - (void)v220;
      if ((uint64_t)(v221 - (void)v220) < 1) {
        goto LABEL_304;
      }
      if (v222 >= 8 && (v220 >= (unsigned char *)&v247 + 1 || (unint64_t)&v247 >= v221))
      {
        if (v222 >= 0x20)
        {
          unint64_t v224 = v222 & 0xFFFFFFFFFFFFFFE0;
          int8x16_t v226 = vdupq_lane_s8(v247, 0);
          long long v227 = (int8x16_t *)(v216 + v219 + *(void *)&v246 + 16);
          unint64_t v228 = v222 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            v227[-1] = v226;
            int8x16_t *v227 = v226;
            v227 += 2;
            v228 -= 32;
          }
          while (v228);
          if (v222 == v224) {
            goto LABEL_304;
          }
          if ((v222 & 0x18) == 0)
          {
            v222 &= 0x1Fu;
            v220 += v224;
            goto LABEL_345;
          }
        }
        else
        {
          unint64_t v224 = 0;
        }
        v220 += v222 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v229 = &v247;
        int8x8_t v230 = vld1_dup_s8((const char *)v229);
        unint64_t v231 = v224 - (v222 & 0xFFFFFFFFFFFFFFF8);
        uint64_t v232 = (int8x8_t *)(*(void *)&v218 + v224 + v216 + v219);
        do
        {
          *v232++ = v230;
          v231 += 8;
        }
        while (v231);
        if (v222 == (v222 & 0xFFFFFFFFFFFFFFF8)) {
          goto LABEL_304;
        }
        v222 &= 7u;
      }
LABEL_345:
      unint64_t v233 = v222 + 1;
      do
      {
        *v220++ = v247.i8[0];
        --v233;
      }
      while (v233 > 1);
      goto LABEL_304;
    }
LABEL_330:
    sub_24B6E81D8();
  }
LABEL_304:
  if (v121) {
LABEL_305:
  }
    operator delete(v121);
LABEL_306:
  if (v96) {
    operator delete(v96);
  }
  operator delete(__p);
  if (v116) {
    operator delete(v116);
  }
  uint64_t v36 = 1;
  float v10 = v235;
  if (v235) {
LABEL_311:
  }
    operator delete(v10);
  return v36;
}

float sub_24B6E9838(unint64_t a1, __n128 *a2, uint64_t a3, char a4, __n128 a5)
{
LABEL_1:
  float v11 = a2 - 1;
  k = (__n128 *)a1;
  while (1)
  {
    a1 = (unint64_t)k;
    uint64_t v13 = (char *)a2 - (char *)k;
    unint64_t v14 = a2 - k;
    if (v6 || !v5) {
      break;
    }
    if (v13 <= 383)
    {
      float v53 = k + 1;
      BOOL v55 = k == a2 || v53 == a2;
      if (a4)
      {
        if (v55) {
          return a5.n128_f32[0];
        }
        uint64_t v56 = 0;
        float v57 = k;
        while (2)
        {
          BOOL v59 = v57;
          float v57 = v53;
          signed __int32 v60 = v59[1].n128_i32[0];
          if (v60 < (signed __int32)v59->n128_u32[0])
          {
            a5.n128_u32[0] = v59[1].n128_u32[3];
            goto LABEL_122;
          }
          if (v60 == v59->n128_u32[0])
          {
            a5.n128_u32[0] = v59[1].n128_u32[3];
            if (a5.n128_f32[0] < v59->n128_f32[3])
            {
LABEL_122:
              unint64_t v61 = *(unint64_t *)((char *)v59[1].n128_u64 + 4);
              __n128 *v57 = *v59;
              float v58 = k;
              if (v59 != k)
              {
                uint64_t v62 = v56;
                while (1)
                {
                  signed __int32 v63 = *(__int32 *)((char *)k[-1].n128_i32 + v62);
                  if (v60 >= v63)
                  {
                    if (v60 != v63)
                    {
                      float v58 = (__n128 *)((char *)k + v62);
                      goto LABEL_116;
                    }
                    if (a5.n128_f32[0] >= *(float *)((char *)&k->n128_f32[-1] + v62)) {
                      break;
                    }
                  }
                  --v59;
                  *(__n128 *)((char *)k + v62) = *(__n128 *)((char *)k + v62 - 16);
                  v62 -= 16;
                  if (!v62)
                  {
                    float v58 = k;
                    goto LABEL_116;
                  }
                }
                float v58 = v59;
              }
LABEL_116:
              v58->n128_u32[0] = v60;
              *(unint64_t *)((char *)v58->n128_u64 + 4) = v61;
              v58->n128_u32[3] = a5.n128_u32[0];
            }
          }
          float v53 = v57 + 1;
          v56 += 16;
          if (&v57[1] == a2) {
            return a5.n128_f32[0];
          }
          continue;
        }
      }
      if (v55) {
        return a5.n128_f32[0];
      }
      while (2)
      {
        unint64_t v95 = a1;
        a1 = (unint64_t)v53;
        int v96 = *(_DWORD *)(v95 + 16);
        if (v96 >= *(_DWORD *)v95)
        {
          if (v96 == *(_DWORD *)v95)
          {
            a5.n128_u32[0] = *(_DWORD *)(v95 + 28);
            if (a5.n128_f32[0] < *(float *)(v95 + 12)) {
              goto LABEL_197;
            }
          }
        }
        else
        {
          a5.n128_u32[0] = *(_DWORD *)(v95 + 28);
LABEL_197:
          uint64_t v97 = *(void *)(v95 + 20);
          do
          {
            do
            {
              unint64_t v98 = v95;
              *(_OWORD *)(v95 + 16) = *(_OWORD *)v95;
              int v99 = *(_DWORD *)(v95 - 16);
              v95 -= 16;
              BOOL v100 = v96 == v99;
            }
            while (v96 < v99);
          }
          while (v100 && a5.n128_f32[0] < *(float *)(v98 - 4));
          *(_DWORD *)unint64_t v98 = v96;
          *(void *)(v98 + 4) = v97;
          *(_DWORD *)(v98 + 12) = a5.n128_u32[0];
        }
        float v53 = (__n128 *)(a1 + 16);
        if ((__n128 *)(a1 + 16) == a2) {
          return a5.n128_f32[0];
        }
        continue;
      }
    }
    if (!a3)
    {
      if (k == a2) {
        return a5.n128_f32[0];
      }
      int64_t v64 = (v14 - 2) >> 1;
      int64_t v65 = v64;
      while (2)
      {
        int64_t v67 = v65;
        if (v64 >= v65)
        {
          uint64_t v68 = (2 * v65) | 1;
          uint64_t v69 = &k[v68];
          if (2 * v67 + 2 < (uint64_t)v14)
          {
            signed __int32 v70 = v69[1].n128_i32[0];
            if ((signed __int32)v69->n128_u32[0] < v70
              || v69->n128_u32[0] == v70 && k[v68].n128_f32[3] < v69[1].n128_f32[3])
            {
              ++v69;
              uint64_t v68 = 2 * v67 + 2;
            }
          }
          float32_t v71 = &k[v67];
          signed __int32 v72 = v71->n128_u32[0];
          if ((signed __int32)v69->n128_u32[0] >= (signed __int32)v71->n128_u32[0])
          {
            if (v69->n128_u32[0] != v72)
            {
              float v73 = v71->n128_f32[3];
              goto LABEL_145;
            }
            float v73 = k[v67].n128_f32[3];
            if (v69->n128_f32[3] >= v73)
            {
LABEL_145:
              unint64_t v74 = *(unint64_t *)((char *)v71->n128_u64 + 4);
              *float32_t v71 = *v69;
              if (v64 >= v68)
              {
                while (1)
                {
                  uint64_t v75 = 2 * v68;
                  uint64_t v68 = (2 * v68) | 1;
                  uint64_t v66 = &k[v68];
                  uint64_t v76 = v75 + 2;
                  if (v76 < (uint64_t)v14)
                  {
                    signed __int32 v77 = v66[1].n128_i32[0];
                    if ((signed __int32)v66->n128_u32[0] < v77
                      || v66->n128_u32[0] == v77 && k[v68].n128_f32[3] < v66[1].n128_f32[3])
                    {
                      ++v66;
                      uint64_t v68 = v76;
                    }
                  }
                  if ((signed __int32)v66->n128_u32[0] < v72 || v66->n128_u32[0] == v72 && v66->n128_f32[3] < v73) {
                    break;
                  }
                  __n128 *v69 = *v66;
                  uint64_t v69 = v66;
                  if (v64 < v68) {
                    goto LABEL_133;
                  }
                }
              }
              uint64_t v66 = v69;
LABEL_133:
              v66->n128_u32[0] = v72;
              *(unint64_t *)((char *)v66->n128_u64 + 4) = v74;
              v66->n128_f32[3] = v73;
            }
          }
        }
        int64_t v65 = v67 - 1;
        if (v67) {
          continue;
        }
        break;
      }
      uint64_t v78 = (unint64_t)v13 >> 4;
      while (2)
      {
        uint64_t v80 = 0;
        __n128 v107 = *k;
        long long v81 = k;
        do
        {
          uint64_t v82 = v81;
          uint64_t v83 = v80 + 1;
          v81 += v80 + 1;
          uint64_t v84 = 2 * v80;
          uint64_t v80 = (2 * v80) | 1;
          uint64_t v85 = v84 + 2;
          if (v85 < v78)
          {
            signed __int32 v86 = v81[1].n128_i32[0];
            if ((signed __int32)v81->n128_u32[0] < v86
              || v81->n128_u32[0] == v86 && v82[v83].n128_f32[3] < v81[1].n128_f32[3])
            {
              ++v81;
              uint64_t v80 = v85;
            }
          }
          *uint64_t v82 = *v81;
        }
        while (v80 <= (uint64_t)((unint64_t)(v78 - 2) >> 1));
        if (v81 == --a2)
        {
          a5.n128_u32[0] = v107.n128_u32[0];
          __n128 *v81 = v107;
          goto LABEL_158;
        }
        __n128 *v81 = *a2;
        a5.n128_u32[0] = v107.n128_u32[0];
        *a2 = v107;
        uint64_t v87 = (char *)v81 - (char *)k + 16;
        if (v87 >= 17)
        {
          unint64_t v88 = ((unint64_t)v87 >> 4) - 2;
          unint64_t v89 = v88 >> 1;
          uint64_t v90 = &k[v88 >> 1];
          signed __int32 v91 = v81->n128_u32[0];
          if ((signed __int32)v90->n128_u32[0] < (signed __int32)v81->n128_u32[0])
          {
            a5.n128_u32[0] = v81->n128_u32[3];
            goto LABEL_172;
          }
          if (v90->n128_u32[0] == v91)
          {
            a5.n128_u32[0] = v81->n128_u32[3];
            if (k[v89].n128_f32[3] < a5.n128_f32[0])
            {
LABEL_172:
              unint64_t v92 = *(unint64_t *)((char *)v81->n128_u64 + 4);
              __n128 *v81 = *v90;
              if (v88 >= 2)
              {
                while (1)
                {
                  unint64_t v94 = v89 - 1;
                  unint64_t v89 = (v89 - 1) >> 1;
                  uint64_t v93 = &k[v89];
                  if ((signed __int32)v93->n128_u32[0] >= v91
                    && (v93->n128_u32[0] != v91 || k[v89].n128_f32[3] >= a5.n128_f32[0]))
                  {
                    break;
                  }
                  __n128 *v90 = *v93;
                  uint64_t v90 = &k[v89];
                  if (v94 <= 1) {
                    goto LABEL_174;
                  }
                }
              }
              uint64_t v93 = v90;
LABEL_174:
              v93->n128_u32[0] = v91;
              *(unint64_t *)((char *)v93->n128_u64 + 4) = v92;
              v93->n128_u32[3] = a5.n128_u32[0];
            }
          }
        }
LABEL_158:
        if (v78-- <= 2) {
          return a5.n128_f32[0];
        }
        continue;
      }
    }
    unint64_t v15 = v14 >> 1;
    float32x2_t v16 = &k[v14 >> 1];
    if ((unint64_t)v13 >= 0x801)
    {
      v17.n128_f32[0] = sub_24B6EA270((__n128 *)a1, (__n128 *)(a1 + 16 * (v14 >> 1)), a2 - 1, a5);
      uint64_t v18 = 16 * v15;
      uint64_t v19 = (__n128 *)(16 * v15 + a1 - 16);
      v20.n128_f32[0] = sub_24B6EA270((__n128 *)(a1 + 16), v19, a2 - 2, v17);
      v21.n128_f32[0] = sub_24B6EA270((__n128 *)(a1 + 32), (__n128 *)(a1 + 16 + v18), a2 - 3, v20);
      sub_24B6EA270(v19, v16, (__n128 *)(a1 + 16 + v18), v21);
      __n128 v102 = *(__n128 *)a1;
      *(__n128 *)a1 = *v16;
      a5 = v102;
      __n128 *v16 = v102;
    }
    else
    {
      sub_24B6EA270((__n128 *)(a1 + 16 * (v14 >> 1)), (__n128 *)a1, a2 - 1, a5);
    }
    --a3;
    signed __int32 v22 = *(_DWORD *)a1;
    if (a4) {
      goto LABEL_14;
    }
    signed __int32 v23 = *(_DWORD *)(a1 - 16);
    if (v23 < v22) {
      goto LABEL_14;
    }
    if (v23 == v22)
    {
      a5.n128_u32[0] = *(_DWORD *)(a1 + 12);
      if (*(float *)(a1 - 4) >= a5.n128_f32[0]) {
        goto LABEL_55;
      }
LABEL_14:
      unint64_t v24 = *(void *)(a1 + 4);
      a5.n128_u32[0] = *(_DWORD *)(a1 + 12);
      for (uint64_t i = (__n128 *)(a1 + 16);
            (signed __int32)i->n128_u32[0] < v22 || i->n128_u32[0] == v22 && i->n128_f32[3] < a5.n128_f32[0];
      if (&i[-1] == (__n128 *)a1)
      {
        CFIndex j = a2;
        if (i < a2)
        {
          unsigned __int32 v29 = v11->n128_u32[0];
          CFIndex j = a2 - 1;
          if ((signed __int32)v11->n128_u32[0] >= v22)
          {
            CFIndex j = a2 - 1;
            do
            {
              if (v29 == v22)
              {
                if (j->n128_f32[3] < a5.n128_f32[0] || i >= j) {
                  break;
                }
              }
              else if (i >= j)
              {
                break;
              }
              signed __int32 v30 = j[-1].n128_i32[0];
              --j;
              unsigned __int32 v29 = v30;
            }
            while (v30 >= v22);
          }
        }
      }
      else
      {
        signed __int32 v26 = v11->n128_u32[0];
        for (CFIndex j = a2 - 1; v26 >= v22 && (v26 != v22 || j->n128_f32[3] >= a5.n128_f32[0]); --j)
        {
          unsigned __int32 v28 = j[-1].n128_u32[0];
          signed __int32 v26 = v28;
        }
      }
      k = i;
      if (i < j)
      {
        k = i;
        BOOL v32 = j;
        do
        {
          __n128 v103 = *k;
          __n128 *k = *v32;
          __n128 *v32 = v103;
          do
          {
            do
            {
              signed __int32 v33 = k[1].n128_i32[0];
              ++k;
              BOOL v34 = v33 == v22;
            }
            while (v33 < v22);
          }
          while (v34 && k->n128_f32[3] < a5.n128_f32[0]);
          do
          {
            signed __int32 v36 = v32[-1].n128_i32[0];
            --v32;
            signed __int32 v35 = v36;
          }
          while (v36 >= v22 && (v35 != v22 || v32->n128_f32[3] >= a5.n128_f32[0]));
        }
        while (k < v32);
      }
      if (&k[-1] != (__n128 *)a1) {
        *(__n128 *)a1 = k[-1];
      }
      k[-1].n128_u32[0] = v22;
      *(unint64_t *)((char *)k[-1].n128_u64 + 4) = v24;
      k[-1].n128_u32[3] = a5.n128_u32[0];
      if (i < j) {
        goto LABEL_54;
      }
      BOOL v37 = sub_24B6EA558((__n128 *)a1, k - 1, a5);
      if (sub_24B6EA558(k, a2, v38))
      {
        a2 = k - 1;
        if (v37) {
          return a5.n128_f32[0];
        }
        goto LABEL_1;
      }
      if (!v37)
      {
LABEL_54:
        sub_24B6E9838(a1, &k[-1], a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      a5.n128_u32[0] = *(_DWORD *)(a1 + 12);
LABEL_55:
      signed __int32 v39 = v11->n128_u32[0];
      if (v22 < (signed __int32)v11->n128_u32[0] || v22 == v39 && a5.n128_f32[0] < a2[-1].n128_f32[3])
      {
        k = (__n128 *)a1;
        do
        {
          signed __int32 v41 = k[1].n128_i32[0];
          ++k;
          signed __int32 v40 = v41;
        }
        while (v22 >= v41 && (v22 != v40 || a5.n128_f32[0] >= k->n128_f32[3]));
      }
      else
      {
        for (k = (__n128 *)(a1 + 16);
              k < a2
           && v22 >= (signed __int32)k->n128_u32[0]
           && (v22 != k->n128_u32[0] || a5.n128_f32[0] >= k->n128_f32[3]);
      }
      m = a2;
      if (k < a2)
      {
        for (m = a2 - 1; v22 < v39 || v22 == v39 && a5.n128_f32[0] < m->n128_f32[3]; --m)
        {
          unsigned __int32 v43 = m[-1].n128_u32[0];
          signed __int32 v39 = v43;
        }
      }
      unint64_t v44 = *(void *)(a1 + 4);
      while (k < m)
      {
        __n128 v104 = *k;
        __n128 *k = *m;
        __n128 *m = v104;
        do
        {
          signed __int32 v46 = k[1].n128_i32[0];
          ++k;
          signed __int32 v45 = v46;
        }
        while (v22 >= v46 && (v22 != v45 || a5.n128_f32[0] >= k->n128_f32[3]));
        do
        {
          do
          {
            signed __int32 v47 = m[-1].n128_i32[0];
            --m;
            BOOL v48 = v22 == v47;
          }
          while (v22 < v47);
        }
        while (v48 && a5.n128_f32[0] < m->n128_f32[3]);
      }
      BOOL v5 = (unint64_t)k[-1].n128_u64 >= a1;
      BOOL v6 = &k[-1] == (__n128 *)a1;
      if (&k[-1] != (__n128 *)a1) {
        *(__n128 *)a1 = k[-1];
      }
      a4 = 0;
      k[-1].n128_u32[0] = v22;
      *(unint64_t *)((char *)k[-1].n128_u64 + 4) = v44;
      k[-1].n128_u32[3] = a5.n128_u32[0];
    }
  }
  switch(v14)
  {
    case 0uLL:
    case 1uLL:
      return a5.n128_f32[0];
    case 2uLL:
      if ((signed __int32)v11->n128_u32[0] < (signed __int32)k->n128_u32[0]
        || v11->n128_u32[0] == k->n128_u32[0] && (a5.n128_u32[0] = a2[-1].n128_u32[3], a5.n128_f32[0] < k->n128_f32[3]))
      {
        __n128 v105 = *k;
        __n128 *k = *v11;
        a5.n128_u32[0] = v105.n128_u32[0];
        *float v11 = v105;
      }
      break;
    case 3uLL:
      a5.n128_f32[0] = sub_24B6EA270(k, k + 1, a2 - 1, a5);
      break;
    case 4uLL:
      uint64_t v49 = k + 1;
      uint64_t v50 = k + 2;
      a5.n128_f32[0] = sub_24B6EA270(k, k + 1, k + 2, a5);
      signed __int32 v51 = k[2].n128_i32[0];
      if ((signed __int32)v11->n128_u32[0] < v51
        || v11->n128_u32[0] == v51 && (a5.n128_u32[0] = a2[-1].n128_u32[3], a5.n128_f32[0] < k[2].n128_f32[3]))
      {
        a5 = *v50;
        __n128 *v50 = *v11;
        *float v11 = a5;
        if ((signed __int32)v50->n128_u32[0] < (signed __int32)v49->n128_u32[0]
          || v50->n128_u32[0] == v49->n128_u32[0]
          && (a5.n128_u32[0] = k[2].n128_u32[3], a5.n128_f32[0] < k[1].n128_f32[3]))
        {
          a5 = *v49;
          *uint64_t v49 = *v50;
          __n128 *v50 = a5;
          signed __int32 v52 = k[1].n128_i32[0];
          if (v52 < (signed __int32)k->n128_u32[0]
            || v52 == k->n128_u32[0] && (a5.n128_u32[0] = k[1].n128_u32[3], a5.n128_f32[0] < k->n128_f32[3]))
          {
            __n128 v106 = *k;
            __n128 *k = *v49;
            a5.n128_u32[0] = v106.n128_u32[0];
            *uint64_t v49 = v106;
          }
        }
      }
      break;
    case 5uLL:
      a5.n128_f32[0] = sub_24B6EA384(k, k + 1, k + 2, k + 3, a2 - 1, a5);
      break;
    default:
      JUMPOUT(0);
  }
  return a5.n128_f32[0];
}

float sub_24B6EA270(__n128 *a1, __n128 *a2, __n128 *a3, __n128 a4)
{
  signed __int32 v4 = a2->n128_u32[0];
  if ((signed __int32)a2->n128_u32[0] < (signed __int32)a1->n128_u32[0]
    || v4 == a1->n128_u32[0] && (a4.n128_u32[0] = a2->n128_u32[3], a4.n128_f32[0] < a1->n128_f32[3]))
  {
    if ((signed __int32)a3->n128_u32[0] < v4 || a3->n128_u32[0] == v4 && a3->n128_f32[3] < a2->n128_f32[3])
    {
      a4 = *a1;
      *a1 = *a3;
LABEL_17:
      *a3 = a4;
      return a4.n128_f32[0];
    }
    a4 = *a1;
    *a1 = *a2;
    *a2 = a4;
    if ((signed __int32)a3->n128_u32[0] < (signed __int32)a2->n128_u32[0]
      || a3->n128_u32[0] == a2->n128_u32[0] && (a4.n128_u32[0] = a3->n128_u32[3], a4.n128_f32[0] < a2->n128_f32[3]))
    {
      a4 = *a2;
      *a2 = *a3;
      goto LABEL_17;
    }
  }
  else if ((signed __int32)a3->n128_u32[0] < v4 {
         || a3->n128_u32[0] == v4 && (a4.n128_u32[0] = a3->n128_u32[3], a4.n128_f32[0] < a2->n128_f32[3]))
  }
  {
    a4 = *a2;
    *a2 = *a3;
    *a3 = a4;
    if ((signed __int32)a2->n128_u32[0] < (signed __int32)a1->n128_u32[0]
      || a2->n128_u32[0] == a1->n128_u32[0] && (a4.n128_u32[0] = a2->n128_u32[3], a4.n128_f32[0] < a1->n128_f32[3]))
    {
      a4 = *a1;
      *a1 = *a2;
      *a2 = a4;
    }
  }
  return a4.n128_f32[0];
}

float sub_24B6EA384(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, __n128 a6)
{
  v11.n128_f32[0] = sub_24B6EA270(a1, a2, a3, a6);
  if ((signed __int32)a4->n128_u32[0] < (signed __int32)a3->n128_u32[0]
    || a4->n128_u32[0] == a3->n128_u32[0] && (v11.n128_u32[0] = a4->n128_u32[3], v11.n128_f32[0] < a3->n128_f32[3]))
  {
    __n128 v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    if ((signed __int32)a3->n128_u32[0] < (signed __int32)a2->n128_u32[0]
      || a3->n128_u32[0] == a2->n128_u32[0] && (v11.n128_u32[0] = a3->n128_u32[3], v11.n128_f32[0] < a2->n128_f32[3]))
    {
      __n128 v11 = *a2;
      *a2 = *a3;
      *a3 = v11;
      if ((signed __int32)a2->n128_u32[0] < (signed __int32)a1->n128_u32[0]
        || a2->n128_u32[0] == a1->n128_u32[0] && (v11.n128_u32[0] = a2->n128_u32[3], v11.n128_f32[0] < a1->n128_f32[3]))
      {
        __n128 v11 = *a1;
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  if ((signed __int32)a5->n128_u32[0] < (signed __int32)a4->n128_u32[0]
    || a5->n128_u32[0] == a4->n128_u32[0] && (v11.n128_u32[0] = a5->n128_u32[3], v11.n128_f32[0] < a4->n128_f32[3]))
  {
    __n128 v11 = *a4;
    *a4 = *a5;
    *a5 = v11;
    if ((signed __int32)a4->n128_u32[0] < (signed __int32)a3->n128_u32[0]
      || a4->n128_u32[0] == a3->n128_u32[0] && (v11.n128_u32[0] = a4->n128_u32[3], v11.n128_f32[0] < a3->n128_f32[3]))
    {
      __n128 v11 = *a3;
      *a3 = *a4;
      *a4 = v11;
      if ((signed __int32)a3->n128_u32[0] < (signed __int32)a2->n128_u32[0]
        || a3->n128_u32[0] == a2->n128_u32[0] && (v11.n128_u32[0] = a3->n128_u32[3], v11.n128_f32[0] < a2->n128_f32[3]))
      {
        __n128 v11 = *a2;
        *a2 = *a3;
        *a3 = v11;
        if ((signed __int32)a2->n128_u32[0] < (signed __int32)a1->n128_u32[0]
          || a2->n128_u32[0] == a1->n128_u32[0]
          && (v11.n128_u32[0] = a2->n128_u32[3], v11.n128_f32[0] < a1->n128_f32[3]))
        {
          __n128 v11 = *a1;
          *a1 = *a2;
          *a2 = v11;
        }
      }
    }
  }
  return v11.n128_f32[0];
}

BOOL sub_24B6EA558(__n128 *a1, __n128 *a2, __n128 a3)
{
  uint64_t v5 = a2 - a1;
  BOOL result = 1;
  switch(v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v7 = a2 - 1;
      signed __int32 v8 = a2[-1].n128_i32[0];
      if (v8 < (signed __int32)a1->n128_u32[0] || v8 == a1->n128_u32[0] && a2[-1].n128_f32[3] < a1->n128_f32[3])
      {
        __n128 v9 = *a1;
        *a1 = *v7;
        __n128 *v7 = v9;
      }
      return result;
    case 3:
      sub_24B6EA270(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      __n128 v20 = a1 + 1;
      __n128 v21 = a1 + 2;
      sub_24B6EA270(a1, a1 + 1, a1 + 2, a3);
      signed __int32 v22 = a2 - 1;
      signed __int32 v23 = a2[-1].n128_i32[0];
      signed __int32 v24 = a1[2].n128_i32[0];
      if (v23 < v24 || v23 == v24 && a2[-1].n128_f32[3] < a1[2].n128_f32[3])
      {
        __n128 v25 = *v21;
        *__n128 v21 = *v22;
        __n128 *v22 = v25;
        if ((signed __int32)v21->n128_u32[0] < (signed __int32)v20->n128_u32[0]
          || v21->n128_u32[0] == v20->n128_u32[0] && a1[2].n128_f32[3] < a1[1].n128_f32[3])
        {
          __n128 v26 = *v20;
          __n128 *v20 = *v21;
          *__n128 v21 = v26;
          signed __int32 v27 = a1[1].n128_i32[0];
          if (v27 < (signed __int32)a1->n128_u32[0] || v27 == a1->n128_u32[0] && a1[1].n128_f32[3] < a1->n128_f32[3])
          {
            __n128 v28 = *a1;
            *a1 = *v20;
            __n128 *v20 = v28;
          }
        }
      }
      return 1;
    case 5:
      sub_24B6EA384(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      float v10 = a1 + 2;
      sub_24B6EA270(a1, a1 + 1, a1 + 2, a3);
      __n128 v11 = a1 + 3;
      if (&a1[3] == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    signed __int32 v15 = v11->n128_u32[0];
    if ((signed __int32)v11->n128_u32[0] < (signed __int32)v10->n128_u32[0]) {
      break;
    }
    if (v15 == v10->n128_u32[0])
    {
      float v16 = v11->n128_f32[3];
      if (v16 < v10->n128_f32[3]) {
        goto LABEL_11;
      }
    }
LABEL_8:
    float v10 = v11;
    v12 += 16;
    if (++v11 == a2) {
      return 1;
    }
  }
  float v16 = v11->n128_f32[3];
LABEL_11:
  uint64_t v17 = *(uint64_t *)((char *)v11->n128_i64 + 4);
  *__n128 v11 = *v10;
  uint64_t v14 = (uint64_t)a1;
  if (v10 != a1)
  {
    uint64_t v18 = v12;
    while (1)
    {
      signed __int32 v19 = *(__int32 *)((char *)a1[1].n128_i32 + v18);
      if (v15 >= v19)
      {
        if (v15 != v19)
        {
          uint64_t v14 = (uint64_t)v10;
          goto LABEL_7;
        }
        if (v16 >= *(float *)((char *)&a1[1].n128_f32[3] + v18)) {
          break;
        }
      }
      --v10;
      *(__n128 *)((char *)a1 + v18 + 32) = *(__n128 *)((char *)a1 + v18 + 16);
      v18 -= 16;
      if (v18 == -32)
      {
        uint64_t v14 = (uint64_t)a1;
        goto LABEL_7;
      }
    }
    uint64_t v14 = (uint64_t)&a1[2] + v18;
  }
LABEL_7:
  *(_DWORD *)uint64_t v14 = v15;
  *(void *)(v14 + 4) = v17;
  *(float *)(v14 + 12) = v16;
  if (++v13 != 8) {
    goto LABEL_8;
  }
  return &v11[1] == a2;
}

uint64_t sub_24B6EA818(uint64_t result, float *a2, float **a3, uint64_t a4, char a5)
{
  __n128 v9 = (float *)result;
LABEL_2:
  float v10 = a2 - 2;
  int v215 = a2 - 6;
  uint64_t v216 = a2 - 4;
  __n128 v11 = v9;
  int v217 = a2 - 2;
  uint32x2_t v218 = a2;
  while (1)
  {
    __n128 v9 = v11;
    uint64_t v12 = (char *)a2 - (char *)v11;
    uint64_t v13 = ((char *)a2 - (char *)v11) >> 3;
    if (v6 || !v5)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          BOOL result = sub_24B6EB978(**a3, (*a3)[1], *(a2 - 2), *(a2 - 1), *v9, v9[1]);
          if (result)
          {
            uint64_t v100 = *(void *)v9;
            *(void *)__n128 v9 = *(void *)v10;
            *(void *)float v10 = v100;
          }
          break;
        case 3:
          BOOL result = sub_24B6EBB3C(v9, v9 + 2, v10, a3);
          break;
        case 4:
          sub_24B6EBB3C(v9, v9 + 2, v9 + 4, a3);
          BOOL result = sub_24B6EB978(**a3, (*a3)[1], *(a2 - 2), *(a2 - 1), v9[4], v9[5]);
          if (result)
          {
            uint64_t v101 = *((void *)v9 + 2);
            *((void *)v9 + 2) = *(void *)v10;
            *(void *)float v10 = v101;
            BOOL result = sub_24B6EB978(**a3, (*a3)[1], v9[4], v9[5], v9[2], v9[3]);
            if (result)
            {
              int8x16_t v102 = vextq_s8(*(int8x16_t *)(v9 + 2), *(int8x16_t *)(v9 + 2), 8uLL);
              *(int8x16_t *)(v9 + 2) = v102;
              BOOL result = sub_24B6EB978(**a3, (*a3)[1], *(float *)v102.i32, *(float *)&v102.i32[1], *v9, v9[1]);
              if (result) {
                *(int8x16_t *)__n128 v9 = vextq_s8(*(int8x16_t *)v9, *(int8x16_t *)v9, 8uLL);
              }
            }
          }
          break;
        case 5:
          BOOL result = sub_24B6EBC58(v9, v9 + 2, v9 + 4, v9 + 6, v10, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191) {
      break;
    }
    if (!a4)
    {
      if (v9 != a2)
      {
        int64_t v132 = (unint64_t)(v13 - 2) >> 1;
        int64_t v133 = v132;
        do
        {
          int64_t v134 = v133;
          if (v132 >= v133)
          {
            uint64_t v135 = (2 * v133) | 1;
            int v136 = &v9[2 * v135];
            uint64_t v137 = 2 * v133 + 2;
            int v138 = *a3;
            if (v137 < v13)
            {
              float v139 = *v136;
              float v140 = v136[2];
              float v143 = *v138;
              float v144 = v138[1];
              BOOL v141 = sub_24B6EB978(*v138, v144, *v136, v136[1], v140, v136[3]);
              if (v141) {
                float v142 = v140;
              }
              else {
                float v142 = v139;
              }
              if (v141)
              {
                v136 += 2;
                uint64_t v135 = 2 * v134 + 2;
              }
            }
            else
            {
              float v142 = *v136;
              float v143 = *v138;
              float v144 = v138[1];
            }
            unint64_t v145 = &v9[2 * v134];
            float v146 = *v145;
            float v147 = v145[1];
            BOOL result = sub_24B6EB978(v143, v144, v142, v136[1], *v145, v147);
            if ((result & 1) == 0)
            {
              do
              {
                float32x4_t v154 = v136;
                *(void *)unint64_t v145 = *(void *)v136;
                if (v132 < v135) {
                  break;
                }
                uint64_t v155 = (2 * v135) | 1;
                int v136 = &v9[2 * v155];
                uint64_t v135 = 2 * v135 + 2;
                unint64_t v156 = *a3;
                if (v135 < v13)
                {
                  float v148 = *v136;
                  float v149 = v136[2];
                  float v150 = *v156;
                  float v151 = v156[1];
                  BOOL v152 = sub_24B6EB978(*v156, v151, *v136, v136[1], v149, v136[3]);
                  float v153 = v152 ? v149 : v148;
                  if (v152) {
                    v136 += 2;
                  }
                  else {
                    uint64_t v135 = v155;
                  }
                }
                else
                {
                  float v153 = *v136;
                  uint64_t v135 = v155;
                  float v150 = *v156;
                  float v151 = v156[1];
                }
                BOOL result = sub_24B6EB978(v150, v151, v153, v136[1], v146, v147);
                unint64_t v145 = v154;
              }
              while (!result);
              float *v154 = v146;
              v154[1] = v147;
            }
          }
          int64_t v133 = v134 - 1;
        }
        while (v134);
        unint64_t v157 = v218;
        uint64_t v158 = (unint64_t)v12 >> 3;
        do
        {
          uint64_t v159 = 0;
          uint64_t v160 = *(void *)v9;
          unint64_t v161 = v9;
          do
          {
            int v164 = &v161[2 * v159 + 2];
            uint64_t v165 = (2 * v159) | 1;
            uint64_t v166 = 2 * v159 + 2;
            if (v166 < v158)
            {
              float v168 = **a3;
              float v167 = (*a3)[1];
              float v169 = *v164;
              float v170 = v164[1];
              float v171 = vabds_f32(v167, v170);
              float v172 = (float)(fabsf(v170) * 0.00001) + 0.000001;
              if (vabds_f32(v168, *v164) > (float)((float)(fabsf(*v164) * 0.00001) + 0.000001) || v171 > v172)
              {
                double v174 = (float)(v169 - v168);
                float v175 = v170 - v167;
                double v176 = vabdd_f64(0.0, v174) <= fabs(v174) * 0.00000999999975 + 0.000000999999997
                     ? (double)(int)((__PAIR64__(v175 > 0.0, LODWORD(v175)) - COERCE_UNSIGNED_INT(0.0)) >> 32)
                     * 1.79769313e308
                     : v175 / v174;
              }
              else
              {
                double v176 = -1.79769313e308;
              }
              float v177 = v164[2];
              float v178 = v164[3];
              float v179 = (float)(fabsf(v177) * 0.00001) + 0.000001;
              float v180 = vabds_f32(v167, v178);
              float v181 = (float)(fabsf(v178) * 0.00001) + 0.000001;
              if (vabds_f32(v168, v177) > v179 || v180 > v181)
              {
                double v183 = (float)(v177 - v168);
                float v184 = v178 - v167;
                double v185 = vabdd_f64(0.0, v183) <= fabs(v183) * 0.00000999999975 + 0.000000999999997
                     ? (double)(int)((__PAIR64__(v184 > 0.0, LODWORD(v184)) - COERCE_UNSIGNED_INT(0.0)) >> 32)
                     * 1.79769313e308
                     : v184 / v183;
              }
              else
              {
                double v185 = -1.79769313e308;
              }
              if (vabdd_f64(v176, v185) <= fabs(v185) * 0.00000999999975 + 0.000000999999997) {
                BOOL v162 = vabds_f32(v169, v177) > v179 ? v169 < v177 : v170 < v178;
              }
              else {
                BOOL v162 = v176 < v185;
              }
              if (v162)
              {
                v164 += 2;
                uint64_t v165 = v166;
              }
            }
            *(void *)unint64_t v161 = *(void *)v164;
            unint64_t v161 = v164;
            uint64_t v159 = v165;
          }
          while (v165 <= (uint64_t)((unint64_t)(v158 - 2) >> 1));
          v157 -= 2;
          if (v164 == v157)
          {
            *(void *)int v164 = v160;
          }
          else
          {
            *(void *)int v164 = *(void *)v157;
            *(void *)unint64_t v157 = v160;
            uint64_t v186 = (char *)v164 - (char *)v9 + 8;
            if (v186 >= 9)
            {
              unint64_t v187 = (((unint64_t)v186 >> 3) - 2) >> 1;
              uint64_t v188 = &v9[2 * v187];
              float v189 = *v164;
              float v190 = v164[1];
              BOOL result = sub_24B6EB978(**a3, (*a3)[1], *v188, v188[1], *v164, v190);
              if (result)
              {
                uint64_t v219 = v157;
                do
                {
                  uint64_t v191 = v188;
                  *(void *)int v164 = *(void *)v188;
                  if (!v187) {
                    break;
                  }
                  unint64_t v187 = (v187 - 1) >> 1;
                  uint64_t v188 = &v9[2 * v187];
                  BOOL result = sub_24B6EB978(**a3, (*a3)[1], *v188, v188[1], v189, v190);
                  int v164 = v191;
                }
                while ((result & 1) != 0);
                float *v191 = v189;
                v191[1] = v190;
                unint64_t v157 = v219;
              }
            }
          }
          BOOL v43 = v158-- <= 2;
        }
        while (!v43);
      }
      return result;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    signed __int32 v15 = &v9[2 * ((unint64_t)v13 >> 1)];
    if ((unint64_t)v12 < 0x401)
    {
      sub_24B6EBB3C(v15, v9, v10, a3);
    }
    else
    {
      sub_24B6EBB3C(v9, v15, v10, a3);
      uint64_t v16 = 2 * v14;
      sub_24B6EBB3C(v9 + 2, &v9[v16 - 2], v216, a3);
      sub_24B6EBB3C(v9 + 4, &v9[v16 + 2], v215, a3);
      sub_24B6EBB3C(&v9[v16 - 2], v15, &v9[v16 + 2], a3);
      uint64_t v17 = *(void *)v9;
      *(void *)__n128 v9 = *(void *)&v9[v16];
      *(void *)&v9[v16] = v17;
      float v10 = v217;
    }
    --a4;
    a2 = v218;
    if (a5)
    {
      float v19 = *v9;
      float v18 = v9[1];
      float v20 = **a3;
      float v21 = (*a3)[1];
LABEL_13:
      signed __int32 v22 = v9;
      do
      {
        signed __int32 v23 = v22;
        float v24 = v22[2];
        v22 += 2;
      }
      while (sub_24B6EB978(v20, v21, v24, v23[3], v19, v18));
      __n128 v25 = v218;
      if (v23 == v9)
      {
        __n128 v25 = v218;
        do
        {
          if (v22 >= v25) {
            break;
          }
          float v28 = *(v25 - 2);
          float v29 = *(v25 - 1);
          v25 -= 2;
        }
        while (!sub_24B6EB978(v20, v21, v28, v29, v19, v18));
      }
      else
      {
        do
        {
          float v26 = *(v25 - 2);
          float v27 = *(v25 - 1);
          v25 -= 2;
        }
        while (!sub_24B6EB978(v20, v21, v26, v27, v19, v18));
      }
      if (v22 < v25)
      {
        float v30 = (float)(fabsf(v19) * 0.00001) + 0.000001;
        float v31 = (float)(fabsf(v18) * 0.00001) + 0.000001;
        BOOL v32 = v22;
        signed __int32 v33 = v25;
        do
        {
          uint64_t v34 = *(void *)v32;
          *(void *)BOOL v32 = *(void *)v33;
          v32 += 2;
          *(void *)signed __int32 v33 = v34;
          float v35 = **a3;
          float v36 = (*a3)[1];
          float v37 = vabds_f32(v35, v19);
          float v38 = vabds_f32(v36, v18);
          double v39 = (float)(v19 - v35);
          double v40 = vabdd_f64(0.0, v39);
          double v41 = fabs(v39) * 0.00000999999975 + 0.000000999999997;
          double v42 = (float)(v18 - v36) / v39;
          if (v40 <= v41) {
            double v42 = (double)(int)((__PAIR64__((float)(v18 - v36) > 0.0, v18 - v36) - COERCE_UNSIGNED_INT(0.0)) >> 32)
          }
                * 1.79769313e308;
          BOOL v43 = v38 > v31 || v37 > v30;
          double v44 = -1.79769313e308;
          if (v43) {
            double v44 = v42;
          }
          double v45 = fabs(v44) * 0.00000999999975 + 0.000000999999997;
          while (1)
          {
            float v46 = *v32;
            float v47 = v32[1];
            float v48 = vabds_f32(v36, v47);
            float v49 = (float)(fabsf(v47) * 0.00001) + 0.000001;
            if (vabds_f32(v35, *v32) > (float)((float)(fabsf(*v32) * 0.00001) + 0.000001) || v48 > v49)
            {
              double v51 = (float)(v46 - v35);
              float v52 = v47 - v36;
              if (vabdd_f64(0.0, v51) <= fabs(v51) * 0.00000999999975 + 0.000000999999997) {
                double v53 = (double)(int)((__PAIR64__(v52 > 0.0, LODWORD(v52)) - COERCE_UNSIGNED_INT(0.0)) >> 32)
              }
                    * 1.79769313e308;
              else {
                double v53 = v52 / v51;
              }
            }
            else
            {
              double v53 = -1.79769313e308;
            }
            if (vabdd_f64(v53, v44) > v45)
            {
              if (v53 >= v44) {
                goto LABEL_47;
              }
              goto LABEL_33;
            }
            if (vabds_f32(v46, v19) <= v30) {
              break;
            }
            if (v46 >= v19) {
              goto LABEL_47;
            }
LABEL_33:
            v32 += 2;
          }
          if (v47 < v18) {
            goto LABEL_33;
          }
LABEL_47:
          signed __int32 v23 = v32 - 2;
          do
          {
            while (1)
            {
              while (1)
              {
                float v54 = *(v33 - 2);
                float v55 = *(v33 - 1);
                v33 -= 2;
                float v56 = vabds_f32(v36, v55);
                float v57 = (float)(fabsf(v55) * 0.00001) + 0.000001;
                if (vabds_f32(v35, v54) > (float)((float)(fabsf(v54) * 0.00001) + 0.000001) || v56 > v57)
                {
                  double v59 = (float)(v54 - v35);
                  float v60 = v55 - v36;
                  double v61 = vabdd_f64(0.0, v59) <= fabs(v59) * 0.00000999999975 + 0.000000999999997
                      ? (double)(int)((__PAIR64__(v60 > 0.0, LODWORD(v60)) - COERCE_UNSIGNED_INT(0.0)) >> 32)
                      * 1.79769313e308
                      : v60 / v59;
                }
                else
                {
                  double v61 = -1.79769313e308;
                }
                if (vabdd_f64(v61, v44) <= v45) {
                  break;
                }
                if (v61 < v44) {
                  goto LABEL_23;
                }
              }
              if (vabds_f32(v54, v19) <= v30) {
                break;
              }
              if (v54 < v19) {
                goto LABEL_23;
              }
            }
          }
          while (v55 >= v18);
LABEL_23:
          ;
        }
        while (v32 < v33);
      }
      if (v23 != v9) {
        *(void *)__n128 v9 = *(void *)v23;
      }
      *signed __int32 v23 = v19;
      v23[1] = v18;
      if (v22 < v25)
      {
LABEL_68:
        BOOL result = sub_24B6EA818(v9, v23, a3, a4, a5 & 1);
        a5 = 0;
        __n128 v11 = v23 + 2;
      }
      else
      {
        BOOL v62 = sub_24B6EBDE4(v9, v23, a3);
        __n128 v11 = v23 + 2;
        BOOL result = sub_24B6EBDE4(v23 + 2, v218, a3);
        if (result)
        {
          a2 = v23;
          if (v62) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v62) {
          goto LABEL_68;
        }
      }
    }
    else
    {
      float v19 = *v9;
      float v18 = v9[1];
      float v20 = **a3;
      float v21 = (*a3)[1];
      if (sub_24B6EB978(v20, v21, *(v9 - 2), *(v9 - 1), *v9, v18)) {
        goto LABEL_13;
      }
      BOOL result = sub_24B6EB978(v20, v21, v19, v18, *(v218 - 2), *(v218 - 1));
      if (result)
      {
        __n128 v11 = v9;
        do
        {
          float v63 = v11[2];
          float v64 = v11[3];
          v11 += 2;
          BOOL result = sub_24B6EB978(v20, v21, v19, v18, v63, v64);
        }
        while ((result & 1) == 0);
      }
      else
      {
        int64_t v65 = v9 + 2;
        do
        {
          __n128 v11 = v65;
          if (v65 >= v218) {
            break;
          }
          BOOL result = sub_24B6EB978(v20, v21, v19, v18, *v65, v65[1]);
          int64_t v65 = v11 + 2;
        }
        while (!result);
      }
      uint64_t v66 = v218;
      if (v11 < v218)
      {
        uint64_t v66 = v218;
        do
        {
          float v67 = *(v66 - 2);
          float v68 = *(v66 - 1);
          v66 -= 2;
          BOOL result = sub_24B6EB978(v20, v21, v19, v18, v67, v68);
        }
        while ((result & 1) != 0);
      }
      if (v11 < v66)
      {
        float v69 = (float)(fabsf(v19) * 0.00001) + 0.000001;
        float v70 = (float)(fabsf(v18) * 0.00001) + 0.000001;
        do
        {
          uint64_t v71 = *(void *)v11;
          *(void *)__n128 v11 = *(void *)v66;
          v11 += 2;
          *(void *)uint64_t v66 = v71;
          float v72 = **a3;
          float v73 = (*a3)[1];
          float v74 = vabds_f32(v72, v19);
          float v75 = vabds_f32(v73, v18);
          double v76 = (float)(v19 - v72);
          double v77 = vabdd_f64(0.0, v76);
          double v78 = fabs(v76) * 0.00000999999975 + 0.000000999999997;
          double v79 = (float)(v18 - v73) / v76;
          if (v77 <= v78) {
            double v79 = (double)(int)((__PAIR64__((float)(v18 - v73) > 0.0, v18 - v73) - COERCE_UNSIGNED_INT(0.0)) >> 32)
          }
                * 1.79769313e308;
          BOOL v80 = v75 > v70 || v74 > v69;
          double v81 = -1.79769313e308;
          if (v80) {
            double v81 = v79;
          }
          while (1)
          {
            float v82 = *v11;
            float v83 = v11[1];
            float v84 = (float)(fabsf(*v11) * 0.00001) + 0.000001;
            float v85 = vabds_f32(v73, v83);
            float v86 = (float)(fabsf(v83) * 0.00001) + 0.000001;
            if (vabds_f32(v72, *v11) > v84 || v85 > v86)
            {
              double v88 = (float)(v82 - v72);
              float v89 = v83 - v73;
              if (vabdd_f64(0.0, v88) <= fabs(v88) * 0.00000999999975 + 0.000000999999997) {
                double v90 = (double)(int)((__PAIR64__(v89 > 0.0, LODWORD(v89)) - COERCE_UNSIGNED_INT(0.0)) >> 32)
              }
                    * 1.79769313e308;
              else {
                double v90 = v89 / v88;
              }
            }
            else
            {
              double v90 = -1.79769313e308;
            }
            if (vabdd_f64(v81, v90) > fabs(v90) * 0.00000999999975 + 0.000000999999997)
            {
              if (v81 < v90) {
                goto LABEL_107;
              }
              goto LABEL_91;
            }
            if (vabds_f32(v19, v82) <= v84) {
              break;
            }
            if (v19 < v82) {
              goto LABEL_107;
            }
LABEL_91:
            v11 += 2;
          }
          if (v18 >= v83) {
            goto LABEL_91;
          }
          do
          {
            while (1)
            {
LABEL_107:
              while (1)
              {
                float v91 = *(v66 - 2);
                float v92 = *(v66 - 1);
                v66 -= 2;
                float v93 = (float)(fabsf(v91) * 0.00001) + 0.000001;
                float v94 = vabds_f32(v73, v92);
                float v95 = (float)(fabsf(v92) * 0.00001) + 0.000001;
                if (vabds_f32(v72, v91) > v93 || v94 > v95)
                {
                  double v97 = (float)(v91 - v72);
                  float v98 = v92 - v73;
                  double v99 = vabdd_f64(0.0, v97) <= fabs(v97) * 0.00000999999975 + 0.000000999999997
                      ? (double)(int)((__PAIR64__(v98 > 0.0, LODWORD(v98)) - COERCE_UNSIGNED_INT(0.0)) >> 32)
                      * 1.79769313e308
                      : v98 / v97;
                }
                else
                {
                  double v99 = -1.79769313e308;
                }
                if (vabdd_f64(v81, v99) <= fabs(v99) * 0.00000999999975 + 0.000000999999997) {
                  break;
                }
                if (v81 >= v99) {
                  goto LABEL_81;
                }
              }
              if (vabds_f32(v19, v91) <= v93) {
                break;
              }
              if (v19 >= v91) {
                goto LABEL_81;
              }
            }
          }
          while (v18 < v92);
LABEL_81:
          ;
        }
        while (v11 < v66);
      }
      BOOL v5 = v11 - 2 >= v9;
      BOOL v6 = v11 - 2 == v9;
      if (v11 - 2 != v9) {
        *(void *)__n128 v9 = *((void *)v11 - 1);
      }
      a5 = 0;
      *(v11 - 2) = v19;
      *(v11 - 1) = v18;
    }
  }
  __n128 v103 = v9 + 2;
  BOOL v105 = v9 == a2 || v103 == a2;
  if ((a5 & 1) == 0)
  {
    if (v105) {
      return result;
    }
    int v192 = *a3;
    while (1)
    {
      int v193 = v103;
      float v194 = v9[2];
      BOOL result = sub_24B6EB978(*v192, v192[1], v194, v103[1], *v9, v9[1]);
      if (result)
      {
        float v195 = v9[3];
        float v196 = (float)(fabsf(v194) * 0.00001) + 0.000001;
        float v197 = (float)(fabsf(v195) * 0.00001) + 0.000001;
        do
        {
          while (1)
          {
            while (1)
            {
              long long v198 = v9;
              *((void *)v9 + 1) = *(void *)v9;
              float v200 = **a3;
              float v199 = (*a3)[1];
              float v201 = vabds_f32(v199, v195);
              if (vabds_f32(v200, v194) > v196 || v201 > v197)
              {
                double v203 = (float)(v194 - v200);
                float v204 = v195 - v199;
                double v205 = vabdd_f64(0.0, v203) <= fabs(v203) * 0.00000999999975 + 0.000000999999997
                     ? (double)(int)((__PAIR64__(v204 > 0.0, LODWORD(v204)) - COERCE_UNSIGNED_INT(0.0)) >> 32)
                     * 1.79769313e308
                     : v204 / v203;
              }
              else
              {
                double v205 = -1.79769313e308;
              }
              float v206 = *(v9 - 2);
              float v207 = *(v9 - 1);
              float v208 = (float)(fabsf(v206) * 0.00001) + 0.000001;
              float v209 = vabds_f32(v199, v207);
              float v210 = (float)(fabsf(v207) * 0.00001) + 0.000001;
              if (vabds_f32(v200, v206) > v208 || v209 > v210)
              {
                double v212 = (float)(v206 - v200);
                float v213 = v207 - v199;
                double v214 = vabdd_f64(0.0, v212) <= fabs(v212) * 0.00000999999975 + 0.000000999999997
                     ? (double)(int)((__PAIR64__(v213 > 0.0, LODWORD(v213)) - COERCE_UNSIGNED_INT(0.0)) >> 32)
                     * 1.79769313e308
                     : v213 / v212;
              }
              else
              {
                double v214 = -1.79769313e308;
              }
              v9 -= 2;
              if (vabdd_f64(v205, v214) <= fabs(v214) * 0.00000999999975 + 0.000000999999997) {
                break;
              }
              if (v205 >= v214) {
                goto LABEL_245;
              }
            }
            if (vabds_f32(v194, v206) <= v208) {
              break;
            }
            if (v206 <= v194) {
              goto LABEL_245;
            }
          }
        }
        while (v207 > v195);
LABEL_245:
        float *v198 = v194;
        v198[1] = v195;
        int v192 = *a3;
      }
      __n128 v103 = v193 + 2;
      __n128 v9 = v193;
      if (v193 + 2 == a2) {
        return result;
      }
    }
  }
  if (v105) {
    return result;
  }
  uint64_t v106 = 0;
  __n128 v107 = *a3;
  uint64_t v108 = v9;
  while (2)
  {
    long long v110 = v103;
    float v111 = v108[2];
    BOOL result = sub_24B6EB978(*v107, v107[1], v111, v103[1], *v108, v108[1]);
    if (!result) {
      goto LABEL_150;
    }
    float v112 = v108[3];
    *((void *)v108 + 1) = *(void *)v108;
    long long v109 = v9;
    if (v108 == v9) {
      goto LABEL_149;
    }
    float v113 = (float)(fabsf(v111) * 0.00001) + 0.000001;
    float v114 = (float)(fabsf(v112) * 0.00001) + 0.000001;
    uint64_t v115 = v106;
    while (2)
    {
      float v117 = **a3;
      float v116 = (*a3)[1];
      float v118 = vabds_f32(v116, v112);
      if (vabds_f32(v117, v111) > v113 || v118 > v114)
      {
        double v120 = (float)(v111 - v117);
        float v121 = v112 - v116;
        if (vabdd_f64(0.0, v120) <= fabs(v120) * 0.00000999999975 + 0.000000999999997) {
          double v122 = (double)(int)((__PAIR64__(v121 > 0.0, LODWORD(v121)) - COERCE_UNSIGNED_INT(0.0)) >> 32)
        }
               * 1.79769313e308;
        else {
          double v122 = v121 / v120;
        }
      }
      else
      {
        double v122 = -1.79769313e308;
      }
      float v123 = *(float *)((char *)v9 + v115 - 8);
      float v124 = *(float *)((char *)v9 + v115 - 4);
      float v125 = (float)(fabsf(v123) * 0.00001) + 0.000001;
      float v126 = vabds_f32(v116, v124);
      float v127 = (float)(fabsf(v124) * 0.00001) + 0.000001;
      if (vabds_f32(v117, v123) > v125 || v126 > v127)
      {
        double v129 = (float)(v123 - v117);
        float v130 = v124 - v116;
        if (vabdd_f64(0.0, v129) <= fabs(v129) * 0.00000999999975 + 0.000000999999997) {
          double v131 = (double)(int)((__PAIR64__(v130 > 0.0, LODWORD(v130)) - COERCE_UNSIGNED_INT(0.0)) >> 32)
        }
               * 1.79769313e308;
        else {
          double v131 = v130 / v129;
        }
      }
      else
      {
        double v131 = -1.79769313e308;
      }
      if (vabdd_f64(v122, v131) <= fabs(v131) * 0.00000999999975 + 0.000000999999997)
      {
        if (vabds_f32(v111, v123) <= v125)
        {
          if (v124 <= v112)
          {
LABEL_177:
            long long v109 = v108;
            goto LABEL_149;
          }
        }
        else if (v123 <= v111)
        {
          goto LABEL_177;
        }
        goto LABEL_155;
      }
      if (v122 < v131)
      {
LABEL_155:
        v108 -= 2;
        *(void *)((char *)v9 + v115) = *(void *)((char *)v9 + v115 - 8);
        v115 -= 8;
        if (!v115)
        {
          long long v109 = v9;
          goto LABEL_149;
        }
        continue;
      }
      break;
    }
    long long v109 = (float *)((char *)v9 + v115);
LABEL_149:
    float *v109 = v111;
    v109[1] = v112;
    __n128 v107 = *a3;
LABEL_150:
    __n128 v103 = v110 + 2;
    v106 += 8;
    uint64_t v108 = v110;
    if (v110 + 2 != a2) {
      continue;
    }
    return result;
  }
}

BOOL sub_24B6EB978(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v6 = vabds_f32(a1, a3);
  float v7 = (float)(fabsf(a3) * 0.00001) + 0.000001;
  BOOL v11 = v6 == v7;
  BOOL v10 = v6 >= v7;
  float v8 = vabds_f32(a2, a4);
  float v9 = (float)(fabsf(a4) * 0.00001) + 0.000001;
  if (!v11 && v10)
  {
    BOOL v10 = 1;
    BOOL v11 = 0;
  }
  else
  {
    BOOL v11 = v8 == v9;
    BOOL v10 = v8 >= v9;
  }
  if (!v11 && v10)
  {
    double v12 = (float)(a3 - a1);
    float v13 = a4 - a2;
    if (vabdd_f64(0.0, v12) <= fabs(v12) * 0.00000999999975 + 0.000000999999997) {
      double v14 = (double)(int)((__PAIR64__(v13 > 0.0, LODWORD(v13)) - COERCE_UNSIGNED_INT(0.0)) >> 32) * 1.79769313e308;
    }
    else {
      double v14 = v13 / v12;
    }
  }
  else
  {
    double v14 = -1.79769313e308;
  }
  float v15 = vabds_f32(a1, a5);
  float v16 = (float)(fabsf(a5) * 0.00001) + 0.000001;
  BOOL v11 = v15 == v16;
  BOOL v10 = v15 >= v16;
  float v17 = vabds_f32(a2, a6);
  float v18 = (float)(fabsf(a6) * 0.00001) + 0.000001;
  if (!v11 && v10)
  {
    BOOL v19 = 1;
    BOOL v20 = 0;
  }
  else
  {
    BOOL v20 = v17 == v18;
    BOOL v19 = v17 >= v18;
  }
  if (!v20 && v19)
  {
    double v21 = (float)(a5 - a1);
    float v22 = a6 - a2;
    if (vabdd_f64(0.0, v21) <= fabs(v21) * 0.00000999999975 + 0.000000999999997) {
      double v23 = (double)(int)((__PAIR64__(v22 > 0.0, LODWORD(v22)) - COERCE_UNSIGNED_INT(0.0)) >> 32) * 1.79769313e308;
    }
    else {
      double v23 = v22 / v21;
    }
  }
  else
  {
    double v23 = -1.79769313e308;
  }
  if (vabdd_f64(v14, v23) > fabs(v23) * 0.00000999999975 + 0.000000999999997) {
    return v14 < v23;
  }
  if (vabds_f32(a3, a5) <= v16) {
    return a4 < a6;
  }
  return a3 < a5;
}

BOOL sub_24B6EBB3C(float *a1, float *a2, float *a3, float **a4)
{
  float v8 = *a2;
  float v9 = a2[1];
  float v10 = **a4;
  float v11 = (*a4)[1];
  BOOL v12 = sub_24B6EB978(v10, v11, *a2, v9, *a1, a1[1]);
  BOOL result = sub_24B6EB978(v10, v11, *a3, a3[1], v8, v9);
  if (v12)
  {
    uint64_t v14 = *(void *)a1;
    if (result)
    {
      *(void *)a1 = *(void *)a3;
    }
    else
    {
      *(void *)a1 = *(void *)a2;
      *(void *)a2 = v14;
      BOOL result = sub_24B6EB978(**a4, (*a4)[1], *a3, a3[1], *(float *)&v14, *((float *)&v14 + 1));
      if (!result) {
        return result;
      }
      *(void *)a2 = *(void *)a3;
    }
    *(void *)a3 = v14;
  }
  else if (result)
  {
    uint64_t v15 = *(void *)a2;
    *(void *)a2 = *(void *)a3;
    *(void *)a3 = v15;
    BOOL result = sub_24B6EB978(**a4, (*a4)[1], *a2, a2[1], *a1, a1[1]);
    if (result)
    {
      uint64_t v16 = *(void *)a1;
      *(void *)a1 = *(void *)a2;
      *(void *)a2 = v16;
    }
  }
  return result;
}

BOOL sub_24B6EBC58(float *a1, float *a2, float *a3, float *a4, float *a5, float **a6)
{
  sub_24B6EBB3C(a1, a2, a3, a6);
  float v12 = **a6;
  float v13 = (*a6)[1];
  if (sub_24B6EB978(v12, v13, *a4, a4[1], *a3, a3[1]))
  {
    uint64_t v14 = *(void *)a3;
    *(void *)a3 = *(void *)a4;
    *(void *)a4 = v14;
    float v12 = **a6;
    float v13 = (*a6)[1];
    if (sub_24B6EB978(v12, v13, *a3, a3[1], *a2, a2[1]))
    {
      uint64_t v15 = *(void *)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v15;
      float v12 = **a6;
      float v13 = (*a6)[1];
      if (sub_24B6EB978(v12, v13, *a2, a2[1], *a1, a1[1]))
      {
        uint64_t v16 = *(void *)a1;
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v16;
        float v12 = **a6;
        float v13 = (*a6)[1];
      }
    }
  }
  BOOL result = sub_24B6EB978(v12, v13, *a5, a5[1], *a4, a4[1]);
  if (result)
  {
    uint64_t v18 = *(void *)a4;
    *(void *)a4 = *(void *)a5;
    *(void *)a5 = v18;
    BOOL result = sub_24B6EB978(**a6, (*a6)[1], *a4, a4[1], *a3, a3[1]);
    if (result)
    {
      uint64_t v19 = *(void *)a3;
      *(void *)a3 = *(void *)a4;
      *(void *)a4 = v19;
      BOOL result = sub_24B6EB978(**a6, (*a6)[1], *a3, a3[1], *a2, a2[1]);
      if (result)
      {
        uint64_t v20 = *(void *)a2;
        *(void *)a2 = *(void *)a3;
        *(void *)a3 = v20;
        BOOL result = sub_24B6EB978(**a6, (*a6)[1], *a2, a2[1], *a1, a1[1]);
        if (result)
        {
          uint64_t v21 = *(void *)a1;
          *(void *)a1 = *(void *)a2;
          *(void *)a2 = v21;
        }
      }
    }
  }
  return result;
}

BOOL sub_24B6EBDE4(float *a1, float *a2, float **a3)
{
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (sub_24B6EB978(**a3, (*a3)[1], *(a2 - 2), *(a2 - 1), *a1, a1[1]))
      {
        uint64_t v8 = *(void *)a1;
        *(void *)a1 = *((void *)a2 - 1);
        *((void *)a2 - 1) = v8;
      }
      return 1;
    case 3:
      sub_24B6EBB3C(a1, a1 + 2, a2 - 2, a3);
      return 1;
    case 4:
      sub_24B6EBB3C(a1, a1 + 2, a1 + 4, a3);
      if (sub_24B6EB978(**a3, (*a3)[1], *(a2 - 2), *(a2 - 1), a1[4], a1[5]))
      {
        uint64_t v19 = *((void *)a1 + 2);
        *((void *)a1 + 2) = *((void *)a2 - 1);
        *((void *)a2 - 1) = v19;
        if (sub_24B6EB978(**a3, (*a3)[1], a1[4], a1[5], a1[2], a1[3]))
        {
          int8x16_t v20 = vextq_s8(*(int8x16_t *)(a1 + 2), *(int8x16_t *)(a1 + 2), 8uLL);
          *(int8x16_t *)(a1 + 2) = v20;
          if (sub_24B6EB978(**a3, (*a3)[1], *(float *)v20.i32, *(float *)&v20.i32[1], *a1, a1[1])) {
            *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
          }
        }
      }
      return 1;
    case 5:
      sub_24B6EBC58(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2, a3);
      return 1;
    default:
      float v9 = a1 + 4;
      sub_24B6EBB3C(a1, a1 + 2, a1 + 4, a3);
      float v10 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      float v13 = *a3;
      break;
  }
  while (1)
  {
    float v14 = *v10;
    float v15 = v10[1];
    if (sub_24B6EB978(*v13, v13[1], *v10, v15, *v9, v9[1])) {
      break;
    }
LABEL_6:
    float v9 = v10;
    v11 += 8;
    v10 += 2;
    if (v10 == a2) {
      return 1;
    }
  }
  uint64_t v16 = v11;
  while (1)
  {
    float v17 = (float *)((char *)a1 + v16);
    *(void *)((char *)a1 + v16 + 24) = *(void *)((char *)a1 + v16 + 16);
    if (v16 == -16) {
      break;
    }
    v16 -= 8;
    if (!sub_24B6EB978(**a3, (*a3)[1], v14, v15, v17[2], v17[3]))
    {
      uint64_t v18 = (float *)((char *)a1 + v16 + 24);
      goto LABEL_13;
    }
  }
  uint64_t v18 = a1;
LABEL_13:
  float *v18 = v14;
  v18[1] = v15;
  if (++v12 != 8)
  {
    float v13 = *a3;
    goto LABEL_6;
  }
  return v10 + 2 == a2;
}

void sub_24B6EC03C(uint64_t a1, unsigned int a2, float32x4_t *a3, uint64_t a4)
{
  uint64_t v8 = a2;
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 4);
  BOOL v10 = a2 >= v9;
  unint64_t v11 = a2 - v9;
  if (v11 != 0 && v10)
  {
    sub_24B6E76DC((char **)a4, v11);
  }
  else if (!v10)
  {
    *(void *)(a4 + 8) = *(void *)a4 + 48 * v8;
  }
  if (a2)
  {
    uint64_t v12 = 0;
    float32x4_t v13 = a3[1];
    int32x4_t v14 = (int32x4_t)vmulq_f32(*a3, *a3);
    v14.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v14, 2), vadd_f32(*(float32x2_t *)v14.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v14.i8, 1))).u32[0];
    float32x2_t v15 = vrsqrte_f32((float32x2_t)v14.u32[0]);
    float32x2_t v16 = vmul_f32(v15, vrsqrts_f32((float32x2_t)v14.u32[0], vmul_f32(v15, v15)));
    v14.i32[0] = vmul_f32(v16, vrsqrts_f32((float32x2_t)v14.u32[0], vmul_f32(v16, v16))).u32[0];
    int32x4_t v17 = (int32x4_t)vmulq_f32(v13, v13);
    v17.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v17, 2), vadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v17.i8, 1))).u32[0];
    float32x4_t v18 = vmulq_n_f32(*a3, *(float *)v14.i32);
    *(float32x2_t *)v14.i8 = vrsqrte_f32((float32x2_t)v17.u32[0]);
    *(float32x2_t *)v14.i8 = vmul_f32(*(float32x2_t *)v14.i8, vrsqrts_f32((float32x2_t)v17.u32[0], vmul_f32(*(float32x2_t *)v14.i8, *(float32x2_t *)v14.i8)));
    v14.i32[0] = vmul_f32(*(float32x2_t *)v14.i8, vrsqrts_f32((float32x2_t)v17.u32[0], vmul_f32(*(float32x2_t *)v14.i8, *(float32x2_t *)v14.i8))).u32[0];
    float32x4_t v19 = a3[2];
    int32x4_t v20 = (int32x4_t)vmulq_f32(v19, v19);
    v20.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v20, 2), vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v20.i8, 1))).u32[0];
    float32x4_t v21 = vmulq_n_f32(v13, *(float *)v14.i32);
    *(float32x2_t *)v14.i8 = vrsqrte_f32((float32x2_t)v20.u32[0]);
    float32x2_t v22 = vmul_f32(*(float32x2_t *)v14.i8, vrsqrts_f32((float32x2_t)v20.u32[0], vmul_f32(*(float32x2_t *)v14.i8, *(float32x2_t *)v14.i8)));
    float32x2_t v23 = vrsqrts_f32((float32x2_t)v20.u32[0], vmul_f32(v22, v22));
    float32x4_t v24 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    float32x4_t v25 = vmulq_n_f32(v19, vmul_f32(v22, v23).f32[0]);
    v26.i64[0] = 0xFF000000FFLL;
    v26.i64[1] = 0xFF000000FFLL;
    do
    {
      *(float32x2_t *)v27.f32 = vrndm_f32(*(float32x2_t *)(a1 + v12));
      v27.i64[1] = __PAIR64__(1.0, COERCE_UNSIGNED_INT(floorf(*(float *)(a1 + v12 + 8))));
      float32x4_t v28 = vaddq_f32(v27, (float32x4_t)xmmword_24B72A6F0);
      *(float32x4_t *)(*(void *)a4 + v12) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a3, v28.f32[0]), a3[1], *(float32x2_t *)v28.f32, 1), a3[2], v28, 2), a3[3], v28, 3);
      float32x4_t v29 = *(float32x4_t *)(a1 + v12 + 16);
      float32x4_t v30 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v18, v29.f32[0]), v21, *(float32x2_t *)v29.f32, 1), v25, v29, 2);
      v30.i32[3] = 0;
      *(float32x4_t *)(*(void *)a4 + v12 + 16) = v30;
      unsigned __int32 v31 = *(_DWORD *)(a1 + v12 + 32);
      v29.i32[0] = v31;
      v30.i32[0] = vshrq_n_u32((uint32x4_t)v29, 0x18uLL).u32[0];
      v29.i32[1] = HIWORD(v31);
      v29.i32[2] = v31 >> 8;
      v29.i32[3] = v31;
      uint32x4_t v32 = (uint32x4_t)vandq_s8((int8x16_t)v29, v26);
      v32.i32[0] = v30.i32[0];
      *(float32x4_t *)(*(void *)a4 + v12 + 32) = vdivq_f32(vcvtq_f32_u32(v32), v24);
      v12 += 48;
    }
    while (48 * v8 != v12);
  }
}

uint64_t sub_24B6EC238(__CVBuffer *a1, __CVBuffer *a2, uint64_t a3)
{
  uint64_t result = (uint64_t)CVBufferCopyAttachment(a1, @"Calibration Data", 0);
  if (result)
  {
    CFDictionaryRef v7 = (const __CFDictionary *)result;
    CFTypeID v8 = CFGetTypeID((CFTypeRef)result);
    if (v8 == CFDictionaryGetTypeID())
    {
      double v21 = 0.0;
      double v22 = 0.0;
      double v19 = 0.0;
      double v20 = 0.0;
      int CalibrationPinholeModel_0 = getCalibrationPinholeModel_0(v7, 0, (void **)&v22, (void **)&v21, (void **)&v20, (void **)&v19, &v18);
      CFRelease(v7);
      if (CalibrationPinholeModel_0)
      {
        double Width = (double)CVPixelBufferGetWidth(a2);
        double v11 = Width / (double)CVPixelBufferGetWidth(a1);
        double Height = (double)CVPixelBufferGetHeight(a2);
        double v13 = Height / (double)CVPixelBufferGetHeight(a1);
        *(float *)&unsigned int v14 = v11 * (v21 * v22);
        LODWORD(v15) = 0;
        float v16 = v21 * v13;
        *((float *)&v15 + 1) = v16;
        *(float *)&uint64_t v17 = v11 * v20;
        *(float *)&double v13 = v13 * v19;
        HIDWORD(v17) = LODWORD(v13);
        *(_DWORD *)(a3 + 8) = 0;
        *(void *)a3 = v14;
        *(_DWORD *)(a3 + 24) = 0;
        *(void *)(a3 + 16) = v15;
        *(_DWORD *)(a3 + 40) = 1065353216;
        *(void *)(a3 + 32) = v17;
        return 1;
      }
    }
    else
    {
      CFRelease(v7);
    }
    return 0;
  }
  return result;
}

double sub_24B6EC38C()
{
  std::__libcpp_verbose_abort("bad_function_call was thrown in -fno-exceptions mode");
  return sub_24B6EC3A4(v0, v1);
}

double sub_24B6EC3A4(uint64_t a1, uint64_t a2)
{
  float v3 = *(float **)a2;
  if (*(void *)a2 == a1)
  {
    int v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    sub_24B6EC3A4(&v7);
    double result = *(double *)&v7;
    long long v6 = v8;
    *(_OWORD *)a1 = v7;
    *(_OWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 32) = v9;
  }
  else
  {
    signed __int32 v4 = **(float ***)(a2 + 8);
    *(float *)a1 = (float)(*v3 * *v4) + 0.0;
    *(float *)(a1 + 4) = (float)(v3[1] * *v4) + 0.0;
    *(float *)(a1 + 8) = (float)(v3[2] * *v4) + 0.0;
    *(float *)(a1 + 12) = (float)(*v3 * v4[1]) + 0.0;
    *(float *)(a1 + 16) = (float)(v3[1] * v4[1]) + 0.0;
    *(float *)(a1 + 20) = (float)(v3[2] * v4[1]) + 0.0;
    *(float *)(a1 + 24) = (float)(*v3 * v4[2]) + 0.0;
    *(float *)(a1 + 28) = (float)(v3[1] * v4[2]) + 0.0;
    *(float *)&double result = (float)(v3[2] * v4[2]) + 0.0;
    *(_DWORD *)(a1 + 32) = LODWORD(result);
  }
  return result;
}

void sub_24B6EC49C(uint64_t a1)
{
  cva::vecLib::gesvd<float>();
  memptr = 0;
  malloc_type_posix_memalign(&memptr, 0x20uLL, (4 * 0.0 + 31) & 0x7FFFFFFE0, 0x49090899uLL);
  unsigned int v2 = memptr;
  cva::vecLib::gesvd<float>();
  free(v2);
  *(unsigned char *)(a1 + 92) = 1;
}

__n64 sub_24B6EC5C0(uint64_t a1, float **a2)
{
  float v3 = *a2;
  if (*a2 == (float *)a1 || (signed __int32 v4 = a2[1], v4 == (float *)a1))
  {
    int v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    sub_24B6EC5C0(&v7);
    result.n64_u64[0] = v7;
    long long v6 = v8;
    *(_OWORD *)a1 = v7;
    *(_OWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 32) = v9;
  }
  else
  {
    result.n64_u32[1] = 0;
    *(float *)a1 = (float)((float)((float)(*v3 * *v4) + 0.0) + (float)(v3[3] * v4[1])) + (float)(v3[6] * v4[2]);
    *(float *)(a1 + 4) = (float)((float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[4] * v4[1])) + (float)(v3[7] * v4[2]);
    *(float *)(a1 + 8) = (float)((float)((float)(v3[2] * *v4) + 0.0) + (float)(v3[5] * v4[1])) + (float)(v3[8] * v4[2]);
    *(float *)(a1 + 12) = (float)((float)((float)(*v3 * v4[3]) + 0.0) + (float)(v3[3] * v4[4])) + (float)(v3[6] * v4[5]);
    *(float *)(a1 + 16) = (float)((float)((float)(v3[1] * v4[3]) + 0.0) + (float)(v3[4] * v4[4]))
                        + (float)(v3[7] * v4[5]);
    *(float *)(a1 + 20) = (float)((float)((float)(v3[2] * v4[3]) + 0.0) + (float)(v3[5] * v4[4]))
                        + (float)(v3[8] * v4[5]);
    *(float *)(a1 + 24) = (float)((float)((float)(*v3 * v4[6]) + 0.0) + (float)(v3[3] * v4[7])) + (float)(v3[6] * v4[8]);
    *(float *)(a1 + 28) = (float)((float)((float)(v3[1] * v4[6]) + 0.0) + (float)(v3[4] * v4[7]))
                        + (float)(v3[7] * v4[8]);
    result.n64_f32[0] = (float)((float)((float)(v3[2] * v4[6]) + 0.0) + (float)(v3[5] * v4[7])) + (float)(v3[8] * v4[8]);
    *(_DWORD *)(a1 + 32) = result.n64_u32[0];
  }
  return result;
}

uint64_t sub_24B6EC770(uint64_t a1, void *a2, unint64_t a3, unint64_t a4)
{
  if ((*(unsigned int (**)(void *))(*a2 + 16))(a2) == 1
    && *(unsigned char *)(a1 + 24)
    && a2[1]
    && (uint64_t v8 = a2[6]) != 0
    && (unint64_t v9 = a2[3]) != 0)
  {
    uint64_t v10 = 0;
    if (v9 <= a3)
    {
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v11 = 0;
      unint64_t v35 = a2[4];
      if (v35 > a4)
      {
        unint64_t v12 = *(void *)(a1 + 8);
        unint64_t v13 = v12 >> 1;
        int v14 = a4 - (v12 >> 1);
        float v15 = 0.0;
        int v36 = (v12 >> 1) + a4;
        if (v14 >= v36 || (int)v12 < 1)
        {
          float v18 = 0.0;
        }
        else
        {
          uint64_t v32 = a2[1];
          uint64_t v33 = a2[6];
          uint64_t v34 = a2;
          int v16 = a3 - v13;
          unint64_t v39 = a3;
          int v17 = v13 + a3;
          float v18 = 0.0;
          if ((int)a3 - (int)v13 < (int)v13 + (int)a3)
          {
            uint64_t v19 = 0;
            uint64_t v31 = a2[7];
            uint64_t v38 = v8 + v31 * a4;
            uint64_t v20 = (int)v12;
            do
            {
              int v37 = v14;
              if ((v14 & 0x80000000) == 0 && v14 < (int)v35)
              {
                uint64_t v21 = 0;
                uint64_t v40 = v32 + v34[5] * v14;
                uint64_t v22 = v33 + v31 * v14;
                uint64_t v23 = 1;
                do
                {
                  unsigned int v24 = v16 + v23 - 1;
                  if ((v24 & 0x80000000) == 0 && (int)v24 < (int)v9)
                  {
                    float v25 = (float)(*(unsigned __int8 *)(v38 + v39) - *(unsigned __int8 *)(v22 + v24));
                    float v26 = *(float *)(*(void *)(*(void *)(a1 + 32) + v21) + 4 * v19);
                    float v27 = *(float *)(a1 + 20) * *(float *)(a1 + 20);
                    float v28 = v26 * (float)((float)(expf((float)((float)(v25 * v25) * -0.5) / v27) * 0.15915) / v27);
                    float v18 = v18 + (float)(v28 * *(float *)(v40 + 4 * v24));
                    float v15 = v15 + v28;
                  }
                  if (v16 + (int)v23 >= v17) {
                    break;
                  }
                  v21 += 24;
                }
                while (v23++ < v20);
              }
              int v14 = v37 + 1;
              if (v37 + 1 >= v36) {
                break;
              }
              ++v19;
            }
            while (v19 < v20);
          }
        }
        uint64_t v11 = COERCE_UNSIGNED_INT(v18 / v15);
        uint64_t v10 = 0x100000000;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
  }
  return v11 | v10;
}

void sub_24B6EC9D4(void *a1)
{
  *a1 = &unk_26FE9CE00;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = a1[5];
    signed __int32 v4 = (void *)a1[4];
    if (v3 != v2)
    {
      uint64_t v5 = a1[5];
      do
      {
        long long v7 = *(void **)(v5 - 24);
        v5 -= 24;
        long long v6 = v7;
        if (v7)
        {
          *(void *)(v3 - 16) = v6;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      signed __int32 v4 = (void *)a1[4];
    }
    a1[5] = v2;
    operator delete(v4);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B6ECA88(void *a1)
{
  *a1 = &unk_26FE9CE00;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = a1[5];
    signed __int32 v4 = (void *)a1[4];
    if (v3 != v2)
    {
      uint64_t v5 = a1[5];
      do
      {
        long long v7 = *(void **)(v5 - 24);
        v5 -= 24;
        long long v6 = v7;
        if (v7)
        {
          *(void *)(v3 - 16) = v6;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      signed __int32 v4 = (void *)a1[4];
    }
    a1[5] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t getCalibrationPinholeModel_0(const __CFDictionary *a1, void *a2, void **a3, void **a4, void **a5, void **a6, void **a7)
{
  if (!CFDictionaryContainsKey(a1, @"Sensors")) {
    return 0;
  }
  Value = CFDictionaryGetValue(a1, @"Sensors");
  CFTypeID v15 = CFGetTypeID(Value);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  uint64_t v17 = 0;
  if (!Value || v15 != TypeID) {
    return v17;
  }
  if (!CFDictionaryContainsKey((CFDictionaryRef)Value, @"Intrinsics")) {
    return 0;
  }
  float v18 = CFDictionaryGetValue((CFDictionaryRef)Value, @"Intrinsics");
  CFTypeID v19 = CFGetTypeID(v18);
  CFTypeID v20 = CFDictionaryGetTypeID();
  uint64_t v17 = 0;
  if (!v18 || v19 != v20) {
    return v17;
  }
  keys = a2;
  if (!a2)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v18) != 1) {
      return 0;
    }
    CFDictionaryGetKeysAndValues((CFDictionaryRef)v18, (const void **)&keys, 0);
    a2 = keys;
  }
  if (!CFDictionaryContainsKey((CFDictionaryRef)v18, a2)) {
    return 0;
  }
  uint64_t v17 = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)v18, a2);
  CFTypeID v21 = CFGetTypeID((CFTypeRef)v17);
  if (v21 != CFDictionaryGetTypeID()) {
    return 0;
  }
  if (!v17) {
    return v17;
  }
  if (!CFDictionaryContainsKey((CFDictionaryRef)v17, @"Pinhole")) {
    return 0;
  }
  uint64_t v22 = CFDictionaryGetValue((CFDictionaryRef)v17, @"Pinhole");
  CFTypeID v23 = CFGetTypeID(v22);
  CFTypeID v24 = CFDictionaryGetTypeID();
  uint64_t v17 = 0;
  if (v22)
  {
    if (v23 == v24)
    {
      CFArrayRef v25 = (const __CFArray *)sub_24B6ECDE0((const __CFDictionary *)v22, @"Aspect Ratio", 1);
      CFArrayRef v26 = (const __CFArray *)sub_24B6ECDE0((const __CFDictionary *)v22, @"Focal Length", 1);
      CFArrayRef v27 = (const __CFArray *)sub_24B6ECDE0((const __CFDictionary *)v22, @"Principal Point", 2);
      CFArrayRef v28 = (const __CFArray *)sub_24B6ECDE0((const __CFDictionary *)v22, @"Skew", 1);
      uint64_t v17 = 0;
      if (v25)
      {
        if (v26)
        {
          if (v27)
          {
            CFArrayRef v29 = v28;
            if (v28)
            {
              CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v25, 0);
              keys = 0;
              CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &keys);
              *a3 = keys;
              CFNumberRef v31 = (const __CFNumber *)CFArrayGetValueAtIndex(v26, 0);
              keys = 0;
              CFNumberGetValue(v31, kCFNumberDoubleType, &keys);
              *a4 = keys;
              CFNumberRef v32 = (const __CFNumber *)CFArrayGetValueAtIndex(v27, 0);
              keys = 0;
              CFNumberGetValue(v32, kCFNumberDoubleType, &keys);
              *a5 = keys;
              uint64_t v17 = 1;
              CFNumberRef v33 = (const __CFNumber *)CFArrayGetValueAtIndex(v27, 1);
              keys = 0;
              CFNumberGetValue(v33, kCFNumberDoubleType, &keys);
              *a6 = keys;
              CFNumberRef v34 = (const __CFNumber *)CFArrayGetValueAtIndex(v29, 0);
              keys = 0;
              CFNumberGetValue(v34, kCFNumberDoubleType, &keys);
              *a7 = keys;
            }
          }
        }
      }
    }
  }
  return v17;
}

const void *sub_24B6ECDE0(const __CFDictionary *a1, const void *a2, int a3)
{
  if (!CFDictionaryContainsKey(a1, a2)) {
    return 0;
  }
  Value = CFDictionaryGetValue(a1, a2);
  CFTypeID v7 = CFGetTypeID(Value);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  __n64 result = 0;
  if (Value && v7 == TypeID)
  {
    if (CFDictionaryContainsKey((CFDictionaryRef)Value, @"Data"))
    {
      uint64_t v10 = CFDictionaryGetValue((CFDictionaryRef)Value, @"Data");
      CFTypeID v11 = CFGetTypeID(v10);
      if (v11 == CFArrayGetTypeID())
      {
        if (CFArrayGetCount((CFArrayRef)v10) == a3) {
          return v10;
        }
        else {
          return 0;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_24B6ECE9C(uint64_t a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1358, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2697D1358))
  {
    qword_2697D1350 = sub_24B727BB4();
    __cxa_atexit((void (*)(void *))sub_24B727D84, &qword_2697D1350, &dword_24B6B9000);
    __cxa_guard_release(&qword_2697D1358);
  }
  uint64_t v2 = qword_2697D1350;
  *(_WORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  return a1;
}

void sub_24B6ECF38(_Unwind_Exception *a1)
{
}

uint64_t sub_24B6ECF50(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(id **)a1;
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t result = 0;
  if (a2)
  {
    if (!*(unsigned char *)(a1 + 36))
    {
      *(_DWORD *)(a1 + 32) = a2;
      uint64_t v5 = 48 * a2;
      id v6 = *v2;
      uint64_t v8 = objc_msgSend_newBufferWithLength_options_(v6, v7, v5, 0);
      unint64_t v9 = *(void **)(a1 + 16);
      *(void *)(a1 + 16) = v8;

      uint64_t result = *(void *)(a1 + 16);
      if (result)
      {
        objc_msgSend_setLabel_((void *)result, v10, @"SurfaceVoxelBuffer");
        uint64_t v11 = 576 * *(unsigned int *)(a1 + 32);
        id v12 = **(id **)a1;
        uint64_t v14 = objc_msgSend_newBufferWithLength_options_(v12, v13, v11, 0);
        CFTypeID v15 = *(void **)(a1 + 24);
        *(void *)(a1 + 24) = v14;

        uint64_t result = *(void *)(a1 + 24);
        if (result)
        {
          objc_msgSend_setLabel_((void *)result, v16, @"SurfaceVoxelVertexBuffer");
          float v18 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)a1 + 16), v17, @"coverageGenSurfaceVoxelVertex");
          id v19 = **(id **)a1;
          id v25 = 0;
          uint64_t v21 = objc_msgSend_newComputePipelineStateWithFunction_error_(v19, v20, (uint64_t)v18, &v25);
          id v22 = v25;
          CFTypeID v23 = *(void **)(a1 + 8);
          *(void *)(a1 + 8) = v21;

          uint64_t v24 = *(void *)(a1 + 8);
          if (v24)
          {
            uint64_t result = 1;
            *(unsigned char *)(a1 + 36) = 1;
            return result;
          }
          return 0;
        }
      }
    }
  }
  return result;
}

void sub_24B6ED0AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B6ED0CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0;
  if (*(unsigned char *)(a1 + 36) && *(float *)a2 > 0.0)
  {
    float32x4_t v6 = *(float32x4_t *)(a2 + 16);
    float32x4_t v7 = *(float32x4_t *)(a2 + 32);
    float32x4_t v8 = *(float32x4_t *)(a2 + 48);
    float32x4_t v9 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
    float32x4_t v10 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
    float32x4_t v11 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
    uint32x4_t v12 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v6, *(float32x2_t *)v6.f32, 1), v7, *(float32x2_t *)v7.f32, 1), v8, *(float32x2_t *)v8.f32, 1), v9)), (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v6, v6.f32[0]), v7, v7.f32[0]),
                                           v8,
                                           v8.f32[0]),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v6, v6, 2), v7, v7, 2), v8, v8, 2), v10)));
    v12.i32[3] = v12.i32[2];
    if ((vminvq_u32(v12) & 0x80000000) != 0
      && (float32x4_t v13 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2),
          float32x4_t v14 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v6, (int32x4_t)v8), (int32x4_t)v13),
          float32x4_t v15 = (float32x4_t)vtrn2q_s32((int32x4_t)v6, (int32x4_t)v7),
          v15.i32[2] = HIDWORD(*(void *)(a2 + 48)),
          float32x4_t v16 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v6, (int32x4_t)v8), (int32x4_t)v7),
          uint32x4_t v17 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1), v15), v13, v14), v9)), (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1),
                                                   v15),
                                                 (float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2),
                                                 v14),
                                               *MEMORY[0x263EF89A0]))),
                              (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1), v15), (float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), v14), v10))), v17.i32[3] = v17.i32[2], (vminvq_u32(v17) & 0x80000000) != 0))
    {
      float32x4_t v18 = vmulq_f32(v6, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL), (int8x16_t)v8, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v7, (int8x16_t)v7, 0xCuLL), (int8x16_t)v7, 8uLL)));
      uint64_t result = 0;
      if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0]+ -1.0) <= 0.000011)
      {
        float32x2_t v19 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v6, (int8x16_t)v6, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v7, (int8x16_t)v7, 8uLL)));
        float32x2_t v20 = (float32x2_t)vdup_n_s32(0x38D1B717u);
        uint32x2_t v21 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v20, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v8, (int8x16_t)v8, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a2 + 64), *(int8x16_t *)(a2 + 64), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v20, v19));
        if ((vpmin_u32(v21, v21).u32[0] & 0x80000000) != 0)
        {
          uint64_t v22 = *(void *)(a2 + 80);
          if (v22)
          {
            if (*(void *)(a2 + 88))
            {
              unsigned int v23 = *(_DWORD *)(a1 + 32);
              if (v23 < v22)
              {
                if (qword_2697D1178 != -1) {
                  dispatch_once(&qword_2697D1178, &unk_26FE9CBA0);
                }
                uint64_t v24 = qword_2697D1170;
                if (os_log_type_enabled((os_log_t)qword_2697D1170, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)simd_float4x4 buf = 0;
                  _os_log_impl(&dword_24B6B9000, v24, OS_LOG_TYPE_DEFAULT, "The size of input surface voxel cloud exceeds the maximum allowable size. Exceeded surface voxels are culled.", buf, 2u);
                }
                LODWORD(v22) = v23;
              }
              id v25 = objc_msgSend_contents(*(void **)(a1 + 16), (const char *)a2, a3);
              memcpy(v25, *(const void **)(a2 + 88), 48 * v22);
              *(_DWORD *)(a1 + 40) = *(_DWORD *)a2;
              *(_DWORD *)(a1 + 44) = v22;
              CFArrayRef v28 = objc_msgSend_commandBuffer(*(void **)(*(void *)a1 + 8), v26, v27);
              CFNumberRef v31 = objc_msgSend_computeCommandEncoder(v28, v29, v30);
              objc_msgSend_setLabel_(v31, v32, @"GenerateSurfaceVoxelVertexEncoder");
              objc_msgSend_setComputePipelineState_(v31, v33, *(void *)(a1 + 8));
              objc_msgSend_setBuffer_offset_atIndex_(v31, v34, *(void *)(a1 + 16), 0, 0);
              objc_msgSend_setBytes_length_atIndex_(v31, v35, a1 + 44, 4, 1);
              objc_msgSend_setBytes_length_atIndex_(v31, v36, a1 + 40, 4, 2);
              objc_msgSend_setBytes_length_atIndex_(v31, v37, a1 + 48, 1, 3);
              objc_msgSend_setBuffer_offset_atIndex_(v31, v38, *(void *)(a1 + 24), 0, 4);
              uint64_t v39 = *(unsigned int *)(a1 + 44);
              unint64_t v42 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 8), v40, v41);
              unint64_t v44 = *(unsigned int *)(a1 + 44);
              if (v42 < v44) {
                unint64_t v44 = v42;
              }
              *(void *)simd_float4x4 buf = v39;
              int64x2_t v54 = vdupq_n_s64(1uLL);
              unint64_t v51 = v44;
              int64x2_t v52 = v54;
              objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v31, v43, (uint64_t)buf, &v51);
              objc_msgSend_endEncoding(v31, v45, v46);

              v50[0] = MEMORY[0x263EF8330];
              v50[1] = 3221225472;
              v50[2] = sub_24B6ED4FC;
              v50[3] = &unk_2652DF278;
              v50[4] = a1;
              objc_msgSend_addCompletedHandler_(v28, v47, (uint64_t)v50);
              objc_msgSend_commit(v28, v48, v49);

              return 1;
            }
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_24B6ED4DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B6ED4FC(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 37) = 1;
  return result;
}

uint64_t sub_24B6ED50C()
{
  qword_2697D1170 = (uint64_t)os_log_create("com.apple.CoreOCModules", "General");
  return MEMORY[0x270F9A758]();
}

uint64_t sub_24B6ED550(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_24B6ED5BC()
{
  qword_2697D1180 = (uint64_t)os_log_create("com.apple.CoreOCModules", "VoxelHashing");
  return MEMORY[0x270F9A758]();
}

uint64_t sub_24B6ED600(uint64_t a1)
{
  float32x4_t v1 = *(float32x4_t *)a1;
  float32x4_t v2 = *(float32x4_t *)(a1 + 16);
  float32x4_t v3 = *(float32x4_t *)(a1 + 32);
  float32x4_t v4 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v5 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v6 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v7 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v6, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v1, *(float32x2_t *)v1.f32, 1), v2, *(float32x2_t *)v2.f32, 1), v3, *(float32x2_t *)v3.f32, 1), v4)), (int8x16_t)vcgeq_f32(v6, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v1, v1.f32[0]), v2, v2.f32[0]), v3, v3.f32[0]), *MEMORY[0x263EF89A0]))),
                     (int8x16_t)vcgeq_f32(v6, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v1, v1, 2), v2, v2, 2), v3, v3, 2), v5)));
  v7.i32[3] = v7.i32[2];
  if ((vminvq_u32(v7) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v9 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2);
  float32x4_t v10 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v1, (int32x4_t)v3), (int32x4_t)v9);
  float32x4_t v11 = (float32x4_t)vtrn2q_s32((int32x4_t)v1, (int32x4_t)v2);
  v11.i32[2] = HIDWORD(*(void *)(a1 + 32));
  float32x4_t v12 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v1, (int32x4_t)v3), (int32x4_t)v2);
  uint32x4_t v13 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v6, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v12, v2.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1), v11), v9, v10), v4)), (int8x16_t)vcgeq_f32(v6, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v12, v1.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v1.f32, 1),
                                           v11),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)v1, 2),
                                         v10),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v6, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v12, v3.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1), v11), (float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), v10), v5)));
  v13.i32[3] = v13.i32[2];
  if ((vminvq_u32(v13) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v14 = vmulq_f32(v1, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v3, (int8x16_t)v3, 0xCuLL), (int8x16_t)v3, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v2, (int8x16_t)v2, 0xCuLL), (int8x16_t)v2, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0]+ -1.0) > 0.000011)return 0; {
  float32x2_t v15 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v1, (int8x16_t)v1, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v2, (int8x16_t)v2, 8uLL)));
  }
  float32x2_t v16 = (float32x2_t)vdup_n_s32(0x38D1B717u);
  uint32x2_t v17 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v16, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v3, (int8x16_t)v3, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v16, v15));
  return vpmin_u32(v17, v17).u32[0] >> 31;
}

uint64_t sub_24B6ED7CC(uint64_t a1)
{
  float32x4_t v1 = *(float32x4_t *)(a1 + 16);
  int8x16_t v2 = (int8x16_t)vmulq_f32(*(float32x4_t *)a1, *(float32x4_t *)a1);
  *(float32x2_t *)v2.i8 = vadd_f32(*(float32x2_t *)v2.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL));
  v2.i32[0] = vadd_f32(*(float32x2_t *)v2.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v2.i8, 1)).u32[0];
  float32x2_t v3 = vrsqrte_f32((float32x2_t)v2.u32[0]);
  float32x2_t v4 = vmul_f32(v3, vrsqrts_f32((float32x2_t)v2.u32[0], vmul_f32(v3, v3)));
  float32x4_t v5 = vmulq_n_f32(*(float32x4_t *)a1, vmul_f32(v4, vrsqrts_f32((float32x2_t)v2.u32[0], vmul_f32(v4, v4))).f32[0]);
  int8x16_t v6 = (int8x16_t)vmulq_f32(v1, v1);
  *(float32x2_t *)v6.i8 = vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  v6.i32[0] = vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v6.i8, 1)).u32[0];
  float32x2_t v7 = vrsqrte_f32((float32x2_t)v6.u32[0]);
  float32x2_t v8 = vmul_f32(v7, vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v7, v7)));
  float32x4_t v9 = vmulq_n_f32(v1, vmul_f32(v8, vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v8, v8))).f32[0]);
  float32x4_t v10 = *(float32x4_t *)(a1 + 32);
  int8x16_t v11 = (int8x16_t)vmulq_f32(v10, v10);
  *(float32x2_t *)v11.i8 = vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL));
  v11.i32[0] = vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 1)).u32[0];
  float32x2_t v12 = vrsqrte_f32((float32x2_t)v11.u32[0]);
  float32x2_t v13 = vmul_f32(v12, vrsqrts_f32((float32x2_t)v11.u32[0], vmul_f32(v12, v12)));
  float32x4_t v14 = vmulq_n_f32(v10, vmul_f32(v13, vrsqrts_f32((float32x2_t)v11.u32[0], vmul_f32(v13, v13))).f32[0]);
  float32x4_t v15 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v16 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v17 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v18 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v5, *(float32x2_t *)v5.f32, 1), v9, *(float32x2_t *)v9.f32, 1), v14, *(float32x2_t *)v14.f32, 1), v15)), (int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v5, v5.f32[0]), v9, v9.f32[0]),
                                         v14,
                                         v14.f32[0]),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v5, v5, 2), v9, v9, 2), v14, v14, 2), v16)));
  v18.i32[3] = v18.i32[2];
  if ((vminvq_u32(v18) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v20 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2);
  float32x4_t v21 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v5, (int32x4_t)v14), (int32x4_t)v20);
  float32x4_t v22 = (float32x4_t)vtrn2q_s32((int32x4_t)v5, (int32x4_t)v9);
  v22.i32[2] = v14.i32[1];
  float32x4_t v23 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v5, (int32x4_t)v14), (int32x4_t)v9);
  uint32x4_t v24 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, v9.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1), v22), v20, v21), v15)), (int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, v5.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1),
                                           v22),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2),
                                         v21),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, v14.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1), v22), (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), v21), v16)));
  v24.i32[3] = v24.i32[2];
  if ((vminvq_u32(v24) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v25 = vmulq_f32(v5, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v14, (int8x16_t)v14, 0xCuLL), (int8x16_t)v14, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), (int8x16_t)v14, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v9, (int8x16_t)v9, 0xCuLL), (int8x16_t)v9, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0]+ -1.0) > 0.000011)return 0; {
  float32x2_t v26 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL)));
  }
  float32x2_t v27 = (float32x2_t)vdup_n_s32(0x38D1B717u);
  uint32x2_t v28 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v27, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v27, v26));
  return vpmin_u32(v28, v28).u32[0] >> 31;
}

double sub_24B6EDA40(uint64_t a1, uint64_t a2)
{
  float32x2_t v3 = *(float **)(a2 + 8);
  if (v3 == (float *)a1)
  {
    long long v6 = 0uLL;
    sub_24B6EDA40(&v6);
    double result = *(double *)&v6;
    *(_OWORD *)a1 = v6;
  }
  else
  {
    float32x2_t v4 = **(float ***)a2;
    *(float *)a1 = (float)((float)((float)(v4[1] * v3[1]) + (float)(*v4 * *v3)) + 0.0) + (float)(v4[2] * v3[2]);
    *(float *)(a1 + 4) = (float)((float)((float)(v4[4] * v3[1]) + (float)(v4[3] * *v3)) + 0.0) + (float)(v4[5] * v3[2]);
    *(float *)(a1 + 8) = (float)((float)((float)(v4[1] * v3[4]) + (float)(*v4 * v3[3])) + 0.0) + (float)(v4[2] * v3[5]);
    *(float *)&double result = (float)((float)((float)(v4[4] * v3[4]) + (float)(v4[3] * v3[3])) + 0.0) + (float)(v4[5] * v3[5]);
    *(_DWORD *)(a1 + 12) = LODWORD(result);
  }
  return result;
}

double sub_24B6EDB28(uint64_t a1, float **a2)
{
  float32x2_t v3 = *a2;
  if (*a2 == (float *)a1 || (float32x2_t v4 = a2[1], v4 == (float *)a1))
  {
    long long v6 = 0uLL;
    uint64_t v7 = 0;
    sub_24B6EDB28(&v6);
    double result = *(double *)&v6;
    *(_OWORD *)a1 = v6;
    *(void *)(a1 + 16) = v7;
  }
  else
  {
    *(float *)a1 = (float)((float)(*v3 * *v4) + 0.0) + (float)(v3[3] * v4[1]);
    *(float *)(a1 + 4) = (float)((float)(v3[1] * *v4) + 0.0) + (float)(v3[4] * v4[1]);
    *(float *)(a1 + 8) = (float)((float)(v3[2] * *v4) + 0.0) + (float)(v3[5] * v4[1]);
    *(float *)(a1 + 12) = (float)((float)(*v3 * v4[2]) + 0.0) + (float)(v3[3] * v4[3]);
    *(float *)(a1 + 16) = (float)((float)(v3[1] * v4[2]) + 0.0) + (float)(v3[4] * v4[3]);
    *(float *)&double result = (float)((float)(v3[2] * v4[2]) + 0.0) + (float)(v3[5] * v4[3]);
    *(_DWORD *)(a1 + 20) = LODWORD(result);
  }
  return result;
}

void sub_24B6EDC20(uint64_t a1, unint64_t a2)
{
  float32x4_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  long long v6 = v5;
  if (a2 <= (v4 - (uint64_t)v5) >> 2)
  {
    if (a2)
    {
      bzero(v5, 4 * a2);
      long long v6 = &v5[4 * a2];
    }
    *(void *)(a1 + 8) = v6;
  }
  else
  {
    uint64_t v7 = *(char **)a1;
    uint64_t v8 = (uint64_t)&v5[-*(void *)a1];
    uint64_t v9 = v8 >> 2;
    unint64_t v10 = (v8 >> 2) + a2;
    if (v10 >> 62) {
      sub_24B6EE184();
    }
    uint64_t v11 = v4 - (void)v7;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 62) {
        sub_24B6EE194();
      }
      float32x2_t v13 = operator new(4 * v12);
    }
    else
    {
      float32x2_t v13 = 0;
    }
    float32x4_t v14 = &v13[4 * v9];
    size_t v15 = 4 * a2;
    float32x4_t v16 = &v13[4 * v12];
    bzero(v14, v15);
    float32x4_t v17 = &v14[v15];
    if (v5 != v7)
    {
      unint64_t v18 = v5 - v7 - 4;
      if (v18 < 0x2C) {
        goto LABEL_31;
      }
      if ((unint64_t)(v5 - v13 - v8) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v19 = (v18 >> 2) + 1;
      long long v6 = &v5[-4 * (v19 & 0x7FFFFFFFFFFFFFF8)];
      float32x4_t v20 = &v13[4 * v9 - 16];
      float32x4_t v21 = v5 - 16;
      uint64_t v22 = v19 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        _OWORD *v20 = v23;
        v20 -= 2;
        v21 -= 32;
        v22 -= 8;
      }
      while (v22);
      v14 -= 4 * (v19 & 0x7FFFFFFFFFFFFFF8);
      if (v19 != (v19 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_31:
        do
        {
          int v24 = *((_DWORD *)v6 - 1);
          v6 -= 4;
          *((_DWORD *)v14 - 1) = v24;
          v14 -= 4;
        }
        while (v6 != v7);
      }
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v17;
    *(void *)(a1 + 16) = v16;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

void sub_24B6EDDD0(uint64_t a1, unint64_t a2)
{
  float32x4_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  long long v6 = v5;
  if (a2 <= (v4 - (uint64_t)v5) >> 2)
  {
    if (a2)
    {
      bzero(v5, 4 * a2);
      long long v6 = &v5[4 * a2];
    }
    *(void *)(a1 + 8) = v6;
  }
  else
  {
    uint64_t v7 = *(char **)a1;
    uint64_t v8 = (uint64_t)&v5[-*(void *)a1];
    uint64_t v9 = v8 >> 2;
    unint64_t v10 = (v8 >> 2) + a2;
    if (v10 >> 62) {
      sub_24B6EE184();
    }
    uint64_t v11 = v4 - (void)v7;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 62) {
        sub_24B6EE194();
      }
      float32x2_t v13 = operator new(4 * v12);
    }
    else
    {
      float32x2_t v13 = 0;
    }
    float32x4_t v14 = &v13[4 * v9];
    size_t v15 = 4 * a2;
    float32x4_t v16 = &v13[4 * v12];
    bzero(v14, v15);
    float32x4_t v17 = &v14[v15];
    if (v5 != v7)
    {
      unint64_t v18 = v5 - v7 - 4;
      if (v18 < 0x2C) {
        goto LABEL_31;
      }
      if ((unint64_t)(v5 - v13 - v8) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v19 = (v18 >> 2) + 1;
      long long v6 = &v5[-4 * (v19 & 0x7FFFFFFFFFFFFFF8)];
      float32x4_t v20 = &v13[4 * v9 - 16];
      float32x4_t v21 = v5 - 16;
      uint64_t v22 = v19 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        _OWORD *v20 = v23;
        v20 -= 2;
        v21 -= 32;
        v22 -= 8;
      }
      while (v22);
      v14 -= 4 * (v19 & 0x7FFFFFFFFFFFFFF8);
      if (v19 != (v19 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_31:
        do
        {
          int v24 = *((_DWORD *)v6 - 1);
          v6 -= 4;
          *((_DWORD *)v14 - 1) = v24;
          v14 -= 4;
        }
        while (v6 != v7);
      }
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v17;
    *(void *)(a1 + 16) = v16;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

uint64_t sub_24B6EDF80(uint64_t result, uint64_t *a2, float *a3, int *a4, uint64_t a5, float a6, float a7)
{
  uint64_t v9 = result;
  uint64_t v10 = *((void *)a4 + 2);
  uint64_t v11 = *((void *)a4 + 3);
  if (*((_OWORD *)a4 + 1) == 0)
  {
    unint64_t v12 = *(void *)a4;
    if (*(void *)a4 < *((void *)a4 + 1))
    {
      uint64_t v14 = a2[1];
      unint64_t v13 = a2[2];
      uint64_t v15 = *a2;
      float v16 = *(float *)(v14 + 4 * v13 - 4);
      uint64_t v17 = *(void *)result;
      uint64_t v18 = *(void *)(**(void **)(result + 136) + 8);
      do
      {
        unsigned int v19 = *(_DWORD *)(v17 + 4 * v12);
        float32x4_t v20 = (float *)(v18 + 48 * v19);
        float v21 = a3[2] - v20[2];
        float v22 = (float)((float)((float)((float)(*a3 - *v20) * (float)(*a3 - *v20)) + 0.0)
                    + (float)((float)(a3[1] - v20[1]) * (float)(a3[1] - v20[1])))
            + (float)(v21 * v21);
        if (v22 < v16)
        {
          unint64_t v23 = a2[3];
          if (v23)
          {
            double result = v14 + 4 * v23;
            int v24 = (_DWORD *)(*a2 + 4 * v23);
            unint64_t v25 = a2[3];
            do
            {
              float v26 = *(float *)(result - 4);
              if (v26 <= v22) {
                break;
              }
              if (v25 < v13)
              {
                *(float *)double result = v26;
                _DWORD *v24 = *(v24 - 1);
              }
              result -= 4;
              --v24;
              --v25;
            }
            while (v25);
          }
          else
          {
            unint64_t v25 = 0;
          }
          if (v25 < v13)
          {
            uint64_t v27 = 4 * v25;
            *(float *)(v14 + v27) = v22;
            *(_DWORD *)(v15 + v27) = v19;
          }
          if (v23 < v13) {
            a2[3] = v23 + 1;
          }
        }
        ++v12;
      }
      while (v12 < *((void *)a4 + 1));
    }
  }
  else
  {
    uint64_t v31 = *a4;
    float v32 = a3[v31];
    float v33 = v32 - *((float *)a4 + 1);
    float v34 = v32 - *((float *)a4 + 2);
    float v35 = v33 + v34;
    BOOL v36 = (float)(v33 + v34) < 0.0;
    if ((float)(v33 + v34) >= 0.0) {
      uint64_t v37 = *((void *)a4 + 3);
    }
    else {
      uint64_t v37 = *((void *)a4 + 2);
    }
    float v38 = v34 * v34;
    float v39 = v33 * v33;
    if (v36) {
      float v40 = v38;
    }
    else {
      float v40 = v39;
    }
    double result = sub_24B6EDF80(result, a2, a3, v37, a6, a7);
    float v41 = *(float *)(a5 + 4 * v31);
    float v42 = (float)(v40 + a6) - v41;
    *(float *)(a5 + 4 * v31) = v40;
    if ((float)(v42 * a7) <= *(float *)(a2[1] + 4 * a2[2] - 4))
    {
      if (v35 >= 0.0) {
        uint64_t v43 = v10;
      }
      else {
        uint64_t v43 = v11;
      }
      double result = sub_24B6EDF80(v9, a2, a3, v43, v42, a7);
    }
    *(float *)(a5 + 4 * v31) = v41;
  }
  return result;
}

void sub_24B6EE184()
{
}

void sub_24B6EE194()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  float32x4_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, (struct type_info *)&unk_26FE9CC50, MEMORY[0x263F8C090]);
}

void sub_24B6EE1C8()
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_24B6EE21C(exception);
  __cxa_throw(exception, (struct type_info *)&unk_26FE9CC38, MEMORY[0x263F8C060]);
}

void sub_24B6EE208(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_24B6EE21C(std::logic_error *a1)
{
  double result = std::logic_error::logic_error(a1, "vector");
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C388] + 16);
  return result;
}

unsigned int *sub_24B6EE258(unsigned int **a1)
{
  unint64_t v2 = **(unsigned int **)a1[15];
  a1[5] = (unsigned int *)v2;
  a1[6] = (unsigned int *)v2;
  unint64_t v3 = a1[1] - *a1;
  if (v2 != v3)
  {
    if (v2 <= v3)
    {
      if (v2 < v3) {
        a1[1] = &(*a1)[v2];
      }
    }
    else
    {
      sub_24B6EDC20((uint64_t)a1, v2 - v3);
      unint64_t v2 = (unint64_t)a1[5];
    }
  }
  if (v2)
  {
    uint64_t v4 = (int32x4_t *)*a1;
    if (v2 >= 8)
    {
      unint64_t v5 = v2 & 0xFFFFFFFFFFFFFFF8;
      int32x4_t v6 = (int32x4_t)xmmword_24B72A700;
      uint64_t v7 = v4 + 1;
      v8.i64[0] = 0x400000004;
      v8.i64[1] = 0x400000004;
      v9.i64[0] = 0x800000008;
      v9.i64[1] = 0x800000008;
      unint64_t v10 = v2 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        v7[-1] = v6;
        int32x4_t *v7 = vaddq_s32(v6, v8);
        int32x4_t v6 = vaddq_s32(v6, v9);
        v7 += 2;
        v10 -= 8;
      }
      while (v10);
      goto LABEL_13;
    }
    unint64_t v5 = 0;
    do
    {
      v4->i32[v5] = v5;
      ++v5;
LABEL_13:
      ;
    }
    while (v2 != v5);
  }
  double result = a1[12];
  if (result)
  {
    do
    {
      unint64_t v12 = *(unsigned int **)result;
      free(result);
      a1[12] = v12;
      double result = v12;
    }
    while (v12);
    unint64_t v2 = (unint64_t)a1[5];
  }
  *((_DWORD *)a1 + 22) = 0;
  a1[12] = 0;
  a1[14] = 0;
  a1[3] = 0;
  a1[6] = (unsigned int *)v2;
  if (v2)
  {
    unint64_t v13 = *(unsigned int **)a1[15];
    uint64_t v14 = *v13;
    if (!v14)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x24C5D7550](exception, "[nanoflann] computeBoundingBox() called but no data points found.");
      __cxa_throw(exception, (struct type_info *)&unk_26FE9CBF0, MEMORY[0x263F8C070]);
    }
    uint64_t v15 = (float *)a1 + 15;
    float v16 = (int32x4_t *)*a1;
    uint64_t v17 = *((void *)v13 + 1);
    uint64_t v18 = (float *)(v17 + 48 * **a1);
    long long v19 = *(_OWORD *)v18;
    *(unsigned int **)((char *)a1 + 60) = (unsigned int *)vdup_lane_s32(*(int32x2_t *)v18, 0);
    float v20 = v18[1];
    *((float *)a1 + 17) = v20;
    *((float *)a1 + 18) = v20;
    float v21 = v18[2];
    *((float *)a1 + 19) = v21;
    *((float *)a1 + 20) = v21;
    if (v14 == 1)
    {
LABEL_20:
      double result = (unsigned int *)sub_24B6EE4E0((uint64_t *)a1, (uint64_t *)a1, 0, v2, v15);
      a1[3] = result;
      return result;
    }
    uint64_t v22 = v17 + 4;
    uint64_t v23 = v14 - 1;
    int v24 = &v16->i32[1];
    float v25 = v21;
    float v26 = v20;
    float v27 = *(float *)&v19;
    while (1)
    {
      unsigned int v29 = *v24++;
      unsigned int v28 = v29;
      uint64_t v30 = (_OWORD *)(v17 + 48 * v29);
      long long v31 = *v30;
      if (COERCE_FLOAT(*v30) < v27)
      {
        *(_DWORD *)uint64_t v15 = v31;
        float v27 = *(float *)&v31;
        *(void *)&long long v31 = *(void *)v30;
      }
      if (*(float *)&v31 <= *(float *)&v19) {
        break;
      }
      *((_DWORD *)a1 + 16) = v31;
      float v32 = *(float *)(v22 + 48 * v28);
      LODWORD(v19) = v31;
      if (v32 < v26) {
        goto LABEL_30;
      }
LABEL_31:
      float v33 = *(float *)(v22 + 48 * v28);
      if (v33 > v20)
      {
        *((float *)a1 + 18) = v33;
        float v20 = v33;
      }
      float v34 = (float *)(v17 + 8 + 48 * v28);
      float v35 = *v34;
      if (*v34 >= v25)
      {
        float v36 = *v34;
        if (v35 > v21)
        {
LABEL_37:
          *((float *)a1 + 20) = v36;
          float v21 = v36;
        }
      }
      else
      {
        *((float *)a1 + 19) = v35;
        float v36 = *v34;
        float v25 = v35;
        if (*v34 > v21) {
          goto LABEL_37;
        }
      }
      if (!--v23) {
        goto LABEL_20;
      }
    }
    float v32 = *((float *)&v31 + 1);
    if (*((float *)&v31 + 1) >= v26) {
      goto LABEL_31;
    }
LABEL_30:
    *((float *)a1 + 17) = v32;
    float v26 = v32;
    goto LABEL_31;
  }
  return result;
}

void sub_24B6EE4CC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_24B6EE4E0(uint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t a4, float *a5)
{
  unsigned int v10 = *((_DWORD *)a2 + 22);
  int v11 = v10 - 32;
  if (v10 >= 0x20)
  {
    unint64_t v13 = (void *)a2[13];
  }
  else
  {
    *((_DWORD *)a2 + 29) += v10;
    unint64_t v12 = malloc_type_malloc(0x2000uLL, 0x63A5184BuLL);
    if (!v12)
    {
      fwrite("Failed to allocate memory.\n", 0x1BuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      double v129 = std::bad_alloc::bad_alloc(exception);
      __cxa_throw(v129, (struct type_info *)&unk_26FE9CC20, MEMORY[0x263F8C170]);
    }
    void *v12 = a2[12];
    a2[12] = (uint64_t)v12;
    unint64_t v13 = v12 + 1;
    int v11 = 8152;
  }
  a2[13] = (uint64_t)(v13 + 4);
  *((_DWORD *)a2 + 22) = v11;
  *((_DWORD *)a2 + 28) += 32;
  unint64_t v14 = a4 - a3;
  if (a4 - a3 <= a2[4])
  {
    v13[2] = 0;
    v13[3] = 0;
    void *v13 = a3;
    v13[1] = a4;
    uint64_t v34 = *a2;
    uint64_t v35 = *(void *)(*(void *)a2[15] + 8);
    float v36 = (float *)(v35 + 48 * *(unsigned int *)(*a2 + 4 * a3));
    float v37 = *v36;
    *a5 = *v36;
    float v38 = *v36;
    a5[1] = *v36;
    float v39 = v36[1];
    a5[2] = v39;
    float v40 = v36[1];
    a5[3] = v40;
    float v41 = v36[2];
    a5[4] = v41;
    float v42 = v36[2];
    a5[5] = v42;
    if (a3 + 1 >= a4) {
      return v13;
    }
    uint64_t v43 = v35 + 4;
    unint64_t v44 = ~a3 + a4;
    double v45 = (unsigned int *)(v34 + 4 * a3 + 4);
    while (1)
    {
      unsigned int v47 = *v45++;
      unsigned int v46 = v47;
      float v48 = (_OWORD *)(v35 + 48 * v47);
      long long v49 = *v48;
      if (v37 > COERCE_FLOAT(*v48))
      {
        *(_DWORD *)a5 = v49;
        float v37 = *(float *)&v49;
        *(void *)&long long v49 = *(void *)v48;
      }
      if (v38 >= *(float *)&v49) {
        break;
      }
      *((_DWORD *)a5 + 1) = v49;
      float v50 = *(float *)(v43 + 48 * v46);
      float v38 = *(float *)&v49;
      if (v39 > v50) {
        goto LABEL_30;
      }
LABEL_31:
      float v51 = *(float *)(v43 + 48 * v46);
      if (v40 < v51)
      {
        a5[3] = v51;
        float v40 = v51;
      }
      int64x2_t v52 = (float *)(v35 + 8 + 48 * v46);
      float v53 = *v52;
      if (v41 <= *v52)
      {
        float v54 = *v52;
        if (v42 >= v53) {
          goto LABEL_23;
        }
      }
      else
      {
        a5[4] = v53;
        float v54 = *v52;
        float v41 = v53;
        if (v42 >= *v52) {
          goto LABEL_23;
        }
      }
      a5[5] = v54;
      float v42 = v54;
LABEL_23:
      if (!--v44) {
        return v13;
      }
    }
    float v50 = *((float *)&v49 + 1);
    if (v39 <= *((float *)&v49 + 1)) {
      goto LABEL_31;
    }
LABEL_30:
    a5[2] = v50;
    float v39 = v50;
    goto LABEL_31;
  }
  float v15 = a5[1] - *a5;
  float v17 = a5[2];
  float v16 = a5[3];
  float v18 = v16 - v17;
  if ((float)(v16 - v17) <= v15) {
    float v19 = a5[1] - *a5;
  }
  else {
    float v19 = v16 - v17;
  }
  float v21 = a5[4];
  float v20 = a5[5];
  if ((float)(v20 - v21) > v19) {
    float v19 = v20 - v21;
  }
  float v22 = v19 * 0.99999;
  uint64_t v23 = (uint64_t *)a2[15];
  uint64_t v24 = *a1;
  float v25 = -1.0;
  if (v15 > v22)
  {
    uint64_t v26 = *(void *)(*v23 + 8);
    float v27 = *(float *)(v26 + 48 * *(unsigned int *)(v24 + 4 * a3));
    if (v14 < 2)
    {
      float v30 = *(float *)(v26 + 48 * *(unsigned int *)(v24 + 4 * a3));
    }
    else
    {
      unint64_t v28 = ~a3 + a4;
      unsigned int v29 = (unsigned int *)(v24 + 4 * a3 + 4);
      float v30 = *(float *)(v26 + 48 * *(unsigned int *)(v24 + 4 * a3));
      float v31 = v30;
      do
      {
        unsigned int v32 = *v29++;
        float v33 = *(float *)(v26 + 48 * v32);
        if (v33 < v27)
        {
          float v27 = v33;
          float v31 = v30;
        }
        if (v33 > v31)
        {
          float v30 = v33;
          float v31 = v33;
        }
        --v28;
      }
      while (v28);
    }
    float v55 = v30 - v27;
    float v25 = -1.0;
    if (v55 > -1.0) {
      float v25 = v55;
    }
  }
  if (v18 <= v22) {
    goto LABEL_53;
  }
  uint64_t v56 = *(void *)(*v23 + 8);
  float v57 = *(float *)(v56 + 48 * *(unsigned int *)(v24 + 4 * a3) + 4);
  if (v14 < 2)
  {
    float v61 = *(float *)(v56 + 48 * *(unsigned int *)(v24 + 4 * a3) + 4);
  }
  else
  {
    uint64_t v58 = v56 + 4;
    unint64_t v59 = ~a3 + a4;
    float v60 = (unsigned int *)(v24 + 4 * a3 + 4);
    float v61 = v57;
    float v62 = v57;
    do
    {
      unsigned int v63 = *v60++;
      float v64 = *(float *)(v58 + 48 * v63);
      if (v64 < v57)
      {
        float v57 = v64;
        float v62 = v61;
      }
      if (v64 > v62)
      {
        float v61 = v64;
        float v62 = v64;
      }
      --v59;
    }
    while (v59);
  }
  float v65 = v61 - v57;
  if (v65 <= v25)
  {
LABEL_53:
    unsigned int v68 = 0;
    uint64_t v67 = 0;
    char v66 = 1;
  }
  else
  {
    char v66 = 0;
    uint64_t v67 = 1;
    unsigned int v68 = 1;
    float v25 = v65;
  }
  unsigned int v69 = *(_DWORD *)(v24 + 4 * a3);
  if ((float)(v20 - v21) <= v22)
  {
    uint64_t v70 = *v23;
    uint64_t v71 = *(void *)(*v23 + 8);
    goto LABEL_66;
  }
  uint64_t v70 = *v23;
  uint64_t v71 = *(void *)(*v23 + 8);
  float v72 = *(float *)(v71 + 48 * v69 + 8);
  float v73 = v72;
  float v74 = v72;
  if (v14 >= 2)
  {
    unint64_t v75 = ~a3 + a4;
    double v76 = (unsigned int *)(v24 + 4 * a3 + 4);
    float v73 = *(float *)(v71 + 48 * v69 + 8);
    float v74 = v73;
    float v77 = v73;
    do
    {
      unsigned int v78 = *v76++;
      float v79 = *(float *)(v71 + 8 + 48 * v78);
      if (v79 < v73)
      {
        float v73 = v79;
        float v77 = v74;
      }
      if (v79 > v77)
      {
        float v74 = v79;
        float v77 = v79;
      }
      --v75;
    }
    while (v75);
  }
  if ((float)(v74 - v73) <= v25)
  {
LABEL_66:
    float v80 = a5[2 * v67] + a5[2 * v67 + 1];
    float v82 = (float *)(v71 + 48 * v69);
    if (v66)
    {
      int v81 = 0;
      float v72 = *v82;
      if (v14 >= 2) {
        goto LABEL_70;
      }
    }
    else
    {
      float v72 = v82[1];
      int v81 = 1;
      if (v14 >= 2) {
        goto LABEL_70;
      }
    }
LABEL_68:
    float v83 = v72;
    goto LABEL_92;
  }
  float v80 = v21 + v20;
  unsigned int v68 = 2;
  int v81 = 2;
  if (v14 < 2) {
    goto LABEL_68;
  }
LABEL_70:
  if (v81 == 1)
  {
    unint64_t v89 = ~a3 + a4;
    double v90 = (unsigned int *)(v24 + 4 * a3 + 4);
    float v83 = v72;
    float v91 = v72;
    do
    {
      unsigned int v92 = *v90++;
      float v93 = *(float *)(v71 + 4 + 48 * v92);
      if (v93 < v72)
      {
        float v72 = v93;
        float v91 = v83;
      }
      if (v93 > v91)
      {
        float v83 = v93;
        float v91 = v93;
      }
      --v89;
    }
    while (v89);
  }
  else if (v81)
  {
    unint64_t v94 = ~a3 + a4;
    float v95 = (unsigned int *)(v24 + 4 * a3 + 4);
    float v83 = v72;
    float v96 = v72;
    do
    {
      unsigned int v97 = *v95++;
      float v98 = *(float *)(v71 + 8 + 48 * v97);
      if (v98 < v72)
      {
        float v72 = v98;
        float v96 = v83;
      }
      if (v98 > v96)
      {
        float v83 = v98;
        float v96 = v98;
      }
      --v94;
    }
    while (v94);
  }
  else
  {
    unint64_t v84 = ~a3 + a4;
    float v85 = (unsigned int *)(v24 + 4 * a3 + 4);
    float v83 = v72;
    float v86 = v72;
    do
    {
      unsigned int v87 = *v85++;
      float v88 = *(float *)(v71 + 48 * v87);
      if (v88 < v72)
      {
        float v72 = v88;
        float v86 = v83;
      }
      if (v88 > v86)
      {
        float v83 = v88;
        float v86 = v88;
      }
      --v84;
    }
    while (v84);
  }
LABEL_92:
  unint64_t v99 = 0;
  float v100 = v80 * 0.5;
  if (v100 <= v83) {
    float v83 = v100;
  }
  if (v100 >= v72) {
    *(float *)&__int32 v101 = v83;
  }
  else {
    *(float *)&__int32 v101 = v72;
  }
  unint64_t v102 = v14 - 1;
  uint64_t v103 = v71 + 8;
  uint64_t v104 = v24 + 4 * a3;
  unint64_t v105 = v14 - 1;
LABEL_100:
  if (v81 == 1)
  {
    do
    {
      if (*(float *)(*(void *)(v70 + 8) + 4 + 48 * *(unsigned int *)(v104 + 4 * v99)) >= *(float *)&v101) {
        break;
      }
      ++v99;
    }
    while (v99 <= v105);
  }
  else if (v81)
  {
    do
    {
      if (*(float *)(*(void *)(v70 + 8) + 8 + 48 * *(unsigned int *)(v104 + 4 * v99)) >= *(float *)&v101) {
        break;
      }
      ++v99;
    }
    while (v99 <= v105);
  }
  else
  {
    do
    {
      if (*(float *)(*(void *)(v70 + 8) + 48 * *(unsigned int *)(v104 + 4 * v99)) >= *(float *)&v101) {
        break;
      }
      ++v99;
    }
    while (v99 <= v105);
  }
  while (1)
  {
    BOOL v109 = v105 != 0;
    if (v99 > v105)
    {
      unint64_t v111 = v105;
LABEL_126:
      if (v99 > v111) {
        break;
      }
      goto LABEL_98;
    }
    if (!v105) {
      goto LABEL_123;
    }
    while (1)
    {
      unsigned int v110 = *(_DWORD *)(v104 + 4 * v105);
      if (v81 != 1) {
        break;
      }
      if (*(float *)(*(void *)(v70 + 8) + 48 * v110 + 4) < *(float *)&v101) {
        goto LABEL_122;
      }
LABEL_119:
      unint64_t v111 = v105 - 1;
      BOOL v109 = v105 != 1;
      if (v99 <= v105 - 1)
      {
        if (--v105) {
          continue;
        }
      }
      goto LABEL_126;
    }
    if (!v81)
    {
      if (*(float *)(*(void *)(v70 + 8) + 48 * v110) < *(float *)&v101) {
        goto LABEL_122;
      }
      goto LABEL_119;
    }
    if (*(float *)(v103 + 48 * v110) >= *(float *)&v101) {
      goto LABEL_119;
    }
LABEL_122:
    BOOL v109 = 1;
LABEL_123:
    unint64_t v111 = v105;
    if (v99 > v105) {
      break;
    }
LABEL_98:
    if (!v109) {
      break;
    }
    uint64_t v106 = 4 * (v99 + a3);
    uint64_t v107 = 4 * (v111 + a3);
    int v108 = *(_DWORD *)(v24 + v106);
    *(_DWORD *)(v24 + v106) = *(_DWORD *)(v24 + v107);
    *(_DWORD *)(v24 + v107) = v108;
    ++v99;
    unint64_t v105 = v111 - 1;
    if (v99 <= v111 - 1) {
      goto LABEL_100;
    }
  }
  uint64_t v112 = a2[15];
  uint64_t v113 = v24 + 4 * a3;
  unint64_t v114 = v99;
  if (v99 <= v102) {
    goto LABEL_131;
  }
  while (1)
  {
    BOOL v118 = v102 != 0;
    if (v114 > v102)
    {
      unint64_t v120 = v102;
LABEL_157:
      if (v114 > v120) {
        break;
      }
      goto LABEL_129;
    }
    if (!v102) {
      goto LABEL_154;
    }
    while (1)
    {
      unsigned int v119 = *(_DWORD *)(v113 + 4 * v102);
      if (v81 != 1) {
        break;
      }
      if (*(float *)(*(void *)(*(void *)v112 + 8) + 48 * v119 + 4) <= *(float *)&v101) {
        goto LABEL_153;
      }
LABEL_150:
      unint64_t v120 = v102 - 1;
      BOOL v118 = v102 != 1;
      if (v114 <= v102 - 1)
      {
        if (--v102) {
          continue;
        }
      }
      goto LABEL_157;
    }
    if (!v81)
    {
      if (*(float *)(*(void *)(*(void *)v112 + 8) + 48 * v119) <= *(float *)&v101) {
        goto LABEL_153;
      }
      goto LABEL_150;
    }
    if (*(float *)(*(void *)(*(void *)v112 + 8) + 48 * v119 + 8) > *(float *)&v101) {
      goto LABEL_150;
    }
LABEL_153:
    BOOL v118 = 1;
LABEL_154:
    unint64_t v120 = v102;
    if (v114 > v102) {
      break;
    }
LABEL_129:
    if (!v118) {
      break;
    }
    uint64_t v115 = 4 * (v114 + a3);
    uint64_t v116 = 4 * (v120 + a3);
    int v117 = *(_DWORD *)(v24 + v115);
    *(_DWORD *)(v24 + v115) = *(_DWORD *)(v24 + v116);
    *(_DWORD *)(v24 + v116) = v117;
    ++v114;
    unint64_t v102 = v120 - 1;
    if (v114 <= v120 - 1)
    {
LABEL_131:
      if (v81 == 1)
      {
        do
        {
          if (*(float *)(*(void *)(*(void *)v112 + 8) + 4 + 48 * *(unsigned int *)(v113 + 4 * v114)) > *(float *)&v101) {
            break;
          }
          ++v114;
        }
        while (v114 <= v102);
      }
      else if (v81)
      {
        do
        {
          if (*(float *)(*(void *)(*(void *)v112 + 8) + 8 + 48 * *(unsigned int *)(v113 + 4 * v114)) > *(float *)&v101) {
            break;
          }
          ++v114;
        }
        while (v114 <= v102);
      }
      else
      {
        do
        {
          if (*(float *)(*(void *)(*(void *)v112 + 8) + 48 * *(unsigned int *)(v113 + 4 * v114)) > *(float *)&v101) {
            break;
          }
          ++v114;
        }
        while (v114 <= v102);
      }
    }
  }
  unint64_t v121 = v14 >> 1;
  if (v114 >= v121) {
    unint64_t v122 = v121;
  }
  else {
    unint64_t v122 = v114;
  }
  if (v99 <= v121) {
    unint64_t v123 = v122;
  }
  else {
    unint64_t v123 = v99;
  }
  *(_DWORD *)unint64_t v13 = v68;
  int32x4_t v132 = *(int32x4_t *)a5;
  int8x8_t v133 = *(int8x8_t *)(a5 + 4);
  uint64_t v124 = 2 * v68;
  v132.i32[v124 + 1] = v101;
  uint64_t v125 = v123 + a3;
  v13[2] = sub_24B6EE4E0(a1, a2, a3, v123 + a3, &v132);
  int32x4_t v130 = *(int32x4_t *)a5;
  int8x8_t v131 = *(int8x8_t *)(a5 + 4);
  v130.i32[v124] = v101;
  v13[3] = sub_24B6EE4E0(a1, a2, v125, a4, &v130);
  __int32 v126 = v130.i32[v124];
  *((_DWORD *)v13 + 1) = v132.i32[v124 + 1];
  *((_DWORD *)v13 + 2) = v126;
  *(int8x16_t *)a5 = vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vtrn2q_s32(vrev64q_s32(v132), v130), (float32x4_t)vtrn2q_s32(vrev64q_s32(v130), v132)), (int8x16_t)v130, (int8x16_t)v132);
  *((int8x8_t *)a5 + 2) = vbsl_s8((int8x8_t)vcgt_f32((float32x2_t)__PAIR64__(v131.u32[1], v133.u32[0]), (float32x2_t)__PAIR64__(v133.u32[1], v131.u32[0])), v131, v133);
  return v13;
}

uint64_t *sub_24B6EEEA0(uint64_t *a1)
{
  uint64_t v2 = a1[1];
  a1[1] = 0;
  if (v2)
  {
    unint64_t v3 = *(void **)(v2 + 96);
    if (v3)
    {
      do
      {
        uint64_t v4 = (void *)*v3;
        free(v3);
        *(void *)(v2 + 96) = v4;
        unint64_t v3 = v4;
      }
      while (v4);
    }
    *(_DWORD *)(v2 + 88) = 0;
    *(void *)(v2 + 96) = 0;
    *(void *)(v2 + 112) = 0;
    unint64_t v5 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v5;
      operator delete(v5);
    }
    MEMORY[0x24C5D7790](v2, 0x10F0C40B93F282ALL);
  }
  uint64_t v6 = *a1;
  *a1 = 0;
  if (v6) {
    MEMORY[0x24C5D7790](v6, 0x60C4044C4A2DFLL);
  }
  return a1;
}

void *sub_24B6EEF48(unsigned char *__dst, void *__src, unint64_t a3)
{
  unint64_t v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    int32x4_t v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000;
    void *v5 = v8;
    unint64_t v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }
  return memmove(v5, __src, a3 + 1);
}

os_log_t sub_24B6EEFE4()
{
  os_log_t result = os_log_create("com.apple.CoreOCModules", "General");
  qword_2697D1190 = (uint64_t)result;
  return result;
}

float sub_24B6EF014@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float *a3@<X8>)
{
  unint64_t v5 = *(float (****)(void, float32x2_t *))(a1 + 8);
  float32x2_t v22 = vadd_f32(*(float32x2_t *)a2, (float32x2_t)925353388);
  float v23 = *(float *)(a2 + 8) + 0.0;
  float v6 = (**v5)(v5, &v22);
  float v20 = *(float *)a2 + -0.00001;
  uint64_t v21 = *(void *)(a2 + 4);
  float v7 = (float)(v6 - (**v5)(v5, (float32x2_t *)&v20)) * 0.5;
  float32x2_t v18 = vadd_f32(*(float32x2_t *)a2, (float32x2_t)0x3727C5AC00000000);
  float v19 = *(float *)(a2 + 8) + 0.0;
  float v8 = (**v5)(v5, &v18);
  float v9 = *(float *)(a2 + 4) + -0.00001;
  v17[0] = *(_DWORD *)a2;
  *(float *)&v17[1] = v9;
  void v17[2] = *(_DWORD *)(a2 + 8);
  float v10 = (float)(v8 - (**v5)(v5, (float32x2_t *)v17)) * 0.5;
  float32x2_t v15 = vadd_f32(*(float32x2_t *)a2, 0);
  float v16 = *(float *)(a2 + 8) + 0.00001;
  float v11 = (**v5)(v5, &v15);
  float32x2_t v13 = *(float32x2_t *)a2;
  float v14 = *(float *)(a2 + 8) + -0.00001;
  float result = (float)(v11 - (**v5)(v5, &v13)) * 0.5;
  *a3 = v7;
  a3[1] = v10;
  a3[2] = result;
  return result;
}

uint64_t sub_24B6EF2D0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26FE9CCC0;
  a2[1] = v2;
  return result;
}

void *sub_24B6EF2F4(uint64_t a1)
{
  float result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *float result = &unk_26FE9CCC0;
  result[1] = v3;
  return result;
}

void sub_24B6EF33C()
{
}

void *sub_24B6EF354(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    float v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      float v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            float v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          float v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  float v10 = operator new(0x18uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_44;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_44:
      }
        sub_24B6BD1F0(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v22 = *(void *)a1;
  float v23 = *(void **)(*(void *)a1 + 8 * v3);
  if (v23)
  {
    void *v10 = *v23;
LABEL_58:
    *float v23 = v10;
    goto LABEL_59;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    float v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

os_log_t sub_24B6EF61C()
{
  os_log_t result = os_log_create("com.apple.CoreOCModules", "General");
  qword_2697D11A0 = (uint64_t)result;
  return result;
}

uint64_t sub_24B6EF64C()
{
  return 0;
}

uint64_t sub_24B6EF654()
{
  return 0;
}

BOOL sub_24B6EF65C(uint64_t a1, float32x2_t *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v235 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 8))
  {
    if (qword_2697D11B8 != -1) {
      dispatch_once(&qword_2697D11B8, &unk_26FE9CD60);
    }
    uint64_t v35 = qword_2697D11B0;
    BOOL result = os_log_type_enabled((os_log_t)qword_2697D11B0, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    sub_24B6F6D14(v229, "virtual BOOL oc::voxel_hashing::VoxelIntegratorCPU::integratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
    if (v230 >= 0) {
      float v36 = v229;
    }
    else {
      float v36 = (void **)v229[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint64_t v232 = v36;
    __int16 v233 = 1026;
    int v234 = 137;
    float v37 = "%s:%{public}d VoxelIntegratorCPU not initialized.";
LABEL_222:
    _os_log_error_impl(&dword_24B6B9000, v35, OS_LOG_TYPE_ERROR, v37, buf, 0x12u);
    if (v230 < 0) {
      operator delete(v229[0]);
    }
    return 0;
  }
  BOOL result = sub_24B6F0650((uint64_t)a2, a3, a4, a5, *(_DWORD *)(a1 + 260));
  if (result)
  {
    if (a3)
    {
      uint64_t v11 = 0;
      int v12 = 0;
      float32x4_t v13 = *(float32x4_t *)(a1 + 112);
      float32x4_t v14 = *(float32x4_t *)(a1 + 128);
      float32x4_t v15 = *(float32x4_t *)(a1 + 144);
      float32x4_t v16 = *(float32x4_t *)(a1 + 160);
      float32x4_t v17 = *(float32x4_t *)a2[4].f32;
      float32x4_t v18 = *(float32x4_t *)a2[6].f32;
      float32x4_t v19 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v13, COERCE_FLOAT(*(_OWORD *)a2->f32)), v14, *a2, 1), v15, *(float32x4_t *)a2->f32, 2), v16, *(float32x4_t *)a2->f32, 3);
      float32x4_t v20 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v13, COERCE_FLOAT(*(_OWORD *)a2[2].f32)), v14, a2[2], 1), v15, *(float32x4_t *)a2[2].f32, 2), v16, *(float32x4_t *)a2[2].f32, 3);
      float32x4_t v21 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v13, v17.f32[0]), v14, *(float32x2_t *)v17.f32, 1), v15, v17, 2), v16, v17, 3);
      float32x4_t v22 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v13, v18.f32[0]), v14, *(float32x2_t *)v18.f32, 1), v15, v18, 2);
      float32x4_t v23 = vmlaq_laneq_f32(v22, v16, v18, 3);
      float v24 = 1.0;
      float32x4_t v25 = vmulq_n_f32(vaddq_f32(v16, v22), 1.0 / *(float *)(a1 + 176));
      float32x4_t v26 = v25;
      v26.i32[3] = 1.0;
      uint64_t v27 = a3;
      float32x2_t v28 = (float32x2_t)vrev64_s32(*(int32x2_t *)v25.f32);
      float v29 = v25.f32[2];
      float v30 = (float *)(a1 + 216);
      __asm { FMOV            V25.4S, #1.0 }
      uint64_t v34 = dispatch_group_wait;
      do
      {
        float v39 = (float32x4_t *)(a4 + 48 * v11);
        float32x4_t v41 = *v39;
        f32 = v39[2].f32;
        float32x4_t v42 = v41;
        float v43 = -v41.f32[2];
        if (*(float *)(a1 + 72) <= (float)-v41.f32[2] && *(float *)(a1 + 68) >= v43)
        {
          unint64_t v44 = (float *)(a5 + 20 * v11);
          float v45 = fabsf(*v44);
          if (*v44 >= 0.0 && v45 > 0.000001)
          {
            float v47 = *(float *)(a5 + 20 * v11 + 4);
            float v48 = *(float *)(a1 + 256);
            _NF = v47 < v48;
            float v49 = vabds_f32(v47, v48);
            float v50 = (float)(fabsf(v48) * 0.00001) + 0.000001;
            if (!_NF && v49 > v50)
            {
              float32x4_t v52 = vmulq_n_f32(vaddq_f32(v23, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v19, v42.f32[0]), v20, *(float32x2_t *)v42.f32, 1), v21, v42, 2)), v24 / *(float *)(a1 + 176));
              v52.f32[3] = v24;
              float32x4_t v53 = vsubq_f32(v52, v26);
              int8x16_t v54 = (int8x16_t)vmulq_f32(v53, v53);
              float32x2_t v55 = vadd_f32(*(float32x2_t *)v54.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL));
              v55.f32[0] = sqrtf(vaddv_f32(v55));
              if (v55.f32[0] >= 0.001)
              {
                float32x4_t v56 = vdivq_f32(v53, (float32x4_t)vdupq_lane_s32((int32x2_t)v55, 0));
                long long v58 = *(_OWORD *)(a1 + 80);
                float32x4_t v57 = *(float32x4_t *)(a1 + 96);
                float32x4_t v59 = vdivq_f32(_Q25, v56);
                float32x2_t v60 = (float32x2_t)vrev64_s32(*(int32x2_t *)v59.f32);
                int8x8_t v61 = (int8x8_t)vcgez_f32(v60);
                float32x2_t v62 = vmul_f32(v60, vsub_f32((float32x2_t)vbsl_s8(v61, (int8x8_t)vrev64_s32(*(int32x2_t *)v57.f32), (int8x8_t)vrev64_s32(*(int32x2_t *)&v58)), v28));
                float32x2_t v63 = vmul_f32(*(float32x2_t *)v59.f32, vsub_f32((float32x2_t)vbsl_s8((int8x8_t)vrev64_s32((int32x2_t)vmvn_s8(v61)), *(int8x8_t *)v57.f32, *(int8x8_t *)&v58), *(float32x2_t *)v25.f32));
                int32x2_t v64 = vcgt_f32(v62, v63);
                if (((v64.i32[1] | v64.i32[0]) & 1) == 0)
                {
                  if (v62.f32[1] >= v62.f32[0]) {
                    v62.f32[0] = v62.f32[1];
                  }
                  if (v63.f32[1] < v63.f32[0]) {
                    v63.f32[0] = v63.f32[1];
                  }
                  LODWORD(v65) = *(void *)(a1 + 104);
                  if (v59.f32[2] >= 0.0) {
                    LODWORD(v66) = *(void *)(a1 + 104);
                  }
                  else {
                    LODWORD(v66) = *(void *)(a1 + 88);
                  }
                  if (v59.f32[2] >= 0.0) {
                    LODWORD(v65) = *(void *)(a1 + 88);
                  }
                  float v67 = vmuls_lane_f32(v66 - v29, v59, 2);
                  float v68 = vmuls_lane_f32(v65 - v29, v59, 2);
                  if (v62.f32[0] <= v68 && v67 <= v63.f32[0])
                  {
                    v57.f32[0] = v55.f32[0] + 1.5;
                    if (v62.f32[0] >= v67) {
                      float v67 = v62.f32[0];
                    }
                    float v70 = v68 >= v63.f32[0] ? v63.f32[0] : v68;
                    if (v67 > 0.0 || v70 < v57.f32[0])
                    {
                      float v72 = fmaxf(v67, 0.0);
                      float32x4_t v73 = vmlaq_n_f32(v25, v56, v72);
                      if (v70 >= v57.f32[0]) {
                        float v70 = v57.f32[0];
                      }
                      v57.f32[0] = v70 - v72;
                    }
                    else
                    {
                      float32x4_t v73 = v25;
                    }
                    if (v57.f32[0] > 0.0)
                    {
                      float v74 = *(void **)(a1 + 184);
                      unint64_t v75 = *(void *)(a1 + 192) - (void)v74;
                      unint64_t v76 = v75 >> 3;
                      if (!(v75 >> 3)) {
                        goto LABEL_98;
                      }
                      float32x4_t v77 = (float32x4_t)vextq_s8((int8x16_t)v73, (int8x16_t)v73, 4uLL);
                      *(int32x2_t *)v77.f32 = vcvt_s32_f32(vrndm_f32(*(float32x2_t *)v77.f32));
                      int v78 = v77.i32[1];
                      int32x2_t v79 = vdup_lane_s32(*(int32x2_t *)v77.f32, 0);
                      v79.i32[0] = vcvtms_s32_f32(v73.f32[0]);
                      v59.i16[0] = v79.i16[0];
                      v59.i16[1] = v77.i16[0];
                      v59.i16[2] = v77.i16[2];
                      void *v74 = v59.i64[0];
                      if (v56.f32[0] >= 0.0) {
                        __int16 v80 = 1;
                      }
                      else {
                        __int16 v80 = -1;
                      }
                      float v81 = v56.f32[1];
                      if (v56.f32[1] >= 0.0) {
                        __int16 v82 = 1;
                      }
                      else {
                        __int16 v82 = -1;
                      }
                      float v83 = v56.f32[2];
                      if (v56.f32[2] >= 0.0) {
                        __int16 v84 = 1;
                      }
                      else {
                        __int16 v84 = -1;
                      }
                      *(float32x2_t *)v77.f32 = vcvt_f32_s32(v79);
                      v77.f32[2] = (float)v78;
                      float32x4_t v85 = vsubq_f32(v73, v77);
                      if (fabsf(v56.f32[0]) >= 1.1755e-38)
                      {
                        if (v56.f32[0] >= 0.0) {
                          v77.f32[0] = (float)(v24 - v85.f32[0]) / v56.f32[0];
                        }
                        else {
                          v77.f32[0] = v85.f32[0] / (float)-v56.f32[0];
                        }
                      }
                      else
                      {
                        v77.i32[0] = 2139095040;
                      }
                      if (fabsf(v56.f32[1]) >= 1.1755e-38)
                      {
                        float v87 = v85.f32[1];
                        if (v56.f32[1] >= 0.0) {
                          float v87 = v24 - v85.f32[1];
                        }
                        else {
                          float v81 = -v56.f32[1];
                        }
                        float v86 = v87 / v81;
                      }
                      else
                      {
                        float v86 = INFINITY;
                      }
                      if (fabsf(v56.f32[2]) >= 1.1755e-38)
                      {
                        float v89 = v85.f32[2];
                        if (v56.f32[2] >= 0.0) {
                          float v89 = v24 - v85.f32[2];
                        }
                        else {
                          float v83 = -v56.f32[2];
                        }
                        float v88 = v89 / v83;
                      }
                      else
                      {
                        float v88 = INFINITY;
                      }
                      if (v76 < 2)
                      {
                        LODWORD(v76) = 1;
                        goto LABEL_98;
                      }
                      float32x4_t v90 = vdivq_f32(_Q25, vabsq_f32(v56));
                      v77.f32[1] = v86;
                      v77.f32[2] = v88;
                      float32x4_t v57 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0);
                      uint64_t v91 = (v75 >> 3);
                      uint64_t v92 = 1;
                      while (1)
                      {
                        uint32x4_t v95 = (uint32x4_t)vcgtq_f32(v57, v77);
                        v95.i32[3] = v95.i32[2];
                        if ((vmaxvq_u32(v95) & 0x80000000) == 0) {
                          break;
                        }
                        if (v77.f32[0] >= v77.f32[1])
                        {
                          if (v77.f32[1] < v77.f32[2])
                          {
                            LOWORD(v96) = v59.i16[0];
                            WORD1(v96) = v59.i16[1] + v82;
                            HIDWORD(v96) = v59.i32[1];
                            v94.i32[0] = v77.i32[0];
                            v94.f32[1] = v90.f32[1] + v77.f32[1];
                            v94.i32[2] = v77.i32[2];
                            v59.i64[0] = v96;
                            goto LABEL_89;
                          }
                        }
                        else if (v77.f32[0] < v77.f32[2])
                        {
                          LOWORD(v93) = v59.i16[0] + v80;
                          WORD1(v93) = v59.i16[1];
                          HIDWORD(v93) = v59.i32[1];
                          v94.f32[0] = v90.f32[0] + v77.f32[0];
                          v94.i32[1] = v77.i32[1];
                          v94.i32[2] = v77.i32[2];
                          goto LABEL_88;
                        }
                        LODWORD(v93) = v59.i32[0];
                        WORD2(v93) = v59.i16[2] + v84;
                        HIWORD(v93) = v59.i16[3];
                        v94.i64[0] = v77.i64[0];
                        v94.f32[2] = v90.f32[2] + v77.f32[2];
LABEL_88:
                        v59.i64[0] = v93;
LABEL_89:
                        v94.i32[3] = v77.i32[3];
                        v74[v92++] = v59.i64[0];
                        float32x4_t v77 = v94;
                        if (v91 == v92) {
                          goto LABEL_98;
                        }
                      }
                      LODWORD(v76) = v92;
LABEL_98:
                      int v228 = v12;
                      *(_DWORD *)(a1 + 180) = v76;
                      if (v76)
                      {
                        unint64_t v97 = 0;
                        float32x4_t v100 = v73;
                        v100.f32[3] = v24;
                        float32x4_t v98 = vsubq_f32(v52, v100);
                        float32x4_t v99 = vmulq_f32(v98, v98);
                        v100.i64[0] = vextq_s8((int8x16_t)v99, (int8x16_t)v99, 8uLL).u64[0];
                        float v101 = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v99.f32, *(float32x2_t *)v100.f32)));
                        float v102 = *f32;
                        uint64_t v103 = a4 + 48 * v11;
                        float v197 = *(float *)(v103 + 36);
                        float v198 = v102;
                        float v196 = *(float *)(v103 + 40);
                        uint64_t v104 = 1;
                        while (1)
                        {
                          unint64_t v105 = (int16x4_t *)(*(void *)(a1 + 184) + 8 * v97);
                          v99.i32[0] = v105->i16[0];
                          v99.i32[1] = v105->i16[1];
                          *(float32x2_t *)v99.f32 = vadd_f32(vcvt_f32_s32(*(int32x2_t *)v99.f32), (float32x2_t)0x3F0000003F000000);
                          v100.i16[0] = v105->i16[2];
                          v99.f32[2] = (float)vmovl_s16(*(int16x4_t *)v100.f32).i32[0] + 0.5;
                          float32x4_t v106 = vmulq_f32(v56, vsubq_f32(v99, v73));
                          float32x4_t v100 = vaddq_f32(v106, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v106.f32, 1));
                          float32x4_t v99 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 2), v100);
                          float v107 = v101 - v99.f32[0];
                          if (*(float *)(a1 + 60) < (float)(v101 - v99.f32[0]))
                          {
                            uint64_t v108 = *(void *)(a1 + 16);
LABEL_105:
                            if (!*(unsigned char *)v108 || !*(_DWORD *)(v108 + 4)) {
                              goto LABEL_100;
                            }
                            *(int16x4_t *)v100.f32 = vshr_n_s16(*v105, 3uLL);
                            v59.i32[0] = v100.u16[1];
                            v59.i32[1] = v100.u16[2];
                            v57.i32[0] = v100.i16[0];
                            *(int32x2_t *)v59.f32 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)v59.f32, 0x10uLL), 0x10uLL);
                            int32x4_t v109 = (int32x4_t)vextq_s8(vextq_s8((int8x16_t)v57, (int8x16_t)v57, 4uLL), (int8x16_t)v59, 0xCuLL);
                            float32x4_t v59 = *((float32x4_t *)v34 + 113);
                            int32x4_t v110 = vmulq_s32(v109, (int32x4_t)v59);
                            int8x16_t v111 = veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v110.i8, 1), (int8x16_t)vdupq_laneq_s32(v110, 2));
                            float32x4_t v57 = (float32x4_t)veorq_s8(v111, (int8x16_t)v110);
                            unsigned int v113 = *(_DWORD *)(v108 + 8);
                            int v112 = *(_DWORD *)(v108 + 12);
                            unsigned int v114 = v57.i32[0] % v113;
                            uint64_t v115 = v112 * (v57.i32[0] % v113);
                            uint64_t v116 = (v115 + v112);
                            unsigned int v117 = *(_DWORD *)(v108 + 16);
                            _CF = v115 >= v116 || v115 >= v117;
                            if (_CF || v116 > v117)
                            {
LABEL_100:
                              uint64_t v38 = v104;
                              goto LABEL_101;
                            }
                            uint64_t v120 = *(void *)(v108 + 48);
                            LODWORD(v121) = *(_DWORD *)(v108 + 16);
                            while (1)
                            {
                              if ((*(_DWORD *)(v120 + 16 * v115 + 12) & 0x80000000) == 0)
                              {
                                v57.i64[0] = *(void *)(v120 + 16 * v115);
                                *(int16x4_t *)v111.i8 = vceq_s16(*(int16x4_t *)v57.f32, *(int16x4_t *)v100.f32);
                                v111.i16[3] = v111.i16[2];
                                if ((vminv_u16(*(uint16x4_t *)v111.i8) & 0x8000) != 0)
                                {
                                  if (v117 <= v115) {
                                    goto LABEL_100;
                                  }
                                  unsigned int v149 = *(_DWORD *)(v120 + 16 * v115 + 12);
                                  if ((v149 & 0x80000000) != 0) {
                                    goto LABEL_100;
                                  }
LABEL_157:
                                  unint64_t v151 = *(void *)(v108 + 64)
                                       + 4104 * v149
                                       + ((*(void *)v105 & 7) << 9)
                                       + ((unint64_t)(HIWORD(v105->u32[0]) & 7) << 6)
                                       + 8 * (HIDWORD(*(unint64_t *)v105) & 7);
                                  unsigned int v154 = *(unsigned __int8 *)(v151 + 4);
                                  BOOL v152 = (unsigned char *)(v151 + 4);
                                  unsigned int v153 = v154;
                                  if (!v154) {
                                    goto LABEL_100;
                                  }
                                  unsigned char *v152 = (int)(float)((float)v153 / *(float *)(a1 + 208));
                                  unsigned int v227 = v104;
LABEL_159:
                                  float32x4_t v220 = v20;
                                  float32x4_t v223 = v19;
                                  float32x4_t v214 = v23;
                                  float32x4_t v217 = v21;
                                  float32x4_t v208 = v26;
                                  float32x4_t v211 = v25;
                                  uint64_t v155 = v30;
                                  float32x4_t v202 = v56;
                                  float32x4_t v205 = _Q25;
                                  unint64_t v156 = v34;
                                  float32x4_t v199 = v73;
                                  sub_24B6F12B0(v30, v149, v149);
                                  float32x4_t v73 = v199;
                                  float32x4_t v56 = v202;
                                  uint64_t v34 = v156;
                                  _Q25 = v205;
                                  float32x4_t v26 = v208;
                                  float v30 = v155;
                                  float32x4_t v25 = v211;
                                  float32x4_t v23 = v214;
                                  float v24 = 1.0;
                                  float32x4_t v21 = v217;
                                  float32x4_t v20 = v220;
                                  float32x4_t v19 = v223;
                                  uint64_t v38 = v227;
                                  goto LABEL_101;
                                }
                                v111.i32[0] = v57.i16[0];
                                v122.i32[0] = v57.u16[1];
                                v122.i32[1] = v57.u16[2];
                                *(int32x2_t *)v57.f32 = vshr_n_s32(vshl_n_s32(v122, 0x10uLL), 0x10uLL);
                                int32x4_t v123 = vmulq_s32((int32x4_t)vextq_s8(vextq_s8(v111, v111, 4uLL), (int8x16_t)v57, 0xCuLL), (int32x4_t)v59);
                                int8x16_t v111 = veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v123.i8, 1), (int8x16_t)vdupq_laneq_s32(v123, 2));
                                float32x4_t v57 = (float32x4_t)veorq_s8(v111, (int8x16_t)v123);
                                if (v57.i32[0] % v113 == v114 && v121 == v117)
                                {
                                  if (*(_DWORD *)(v120 + 16 * v115 + 8) >= v117) {
                                    LODWORD(v121) = *(_DWORD *)(v108 + 16);
                                  }
                                  else {
                                    LODWORD(v121) = v115;
                                  }
                                }
                              }
                              if (++v115 == v116)
                              {
                                if (v117 > v121)
                                {
                                  while (1)
                                  {
                                    uint64_t v121 = *(unsigned int *)(v120 + 16 * v121 + 8);
                                    if (v121 >= v117) {
                                      break;
                                    }
                                    uint16x4_t v150 = (uint16x4_t)vceq_s16(*(int16x4_t *)(v120 + 16 * v121), *(int16x4_t *)v100.f32);
                                    v150.i16[3] = v150.i16[2];
                                    if ((vminv_u16(v150) & 0x8000) != 0)
                                    {
                                      unsigned int v149 = *(_DWORD *)(v120 + 16 * v121 + 12);
                                      if ((v149 & 0x80000000) == 0) {
                                        goto LABEL_157;
                                      }
                                      goto LABEL_100;
                                    }
                                  }
                                }
                                goto LABEL_100;
                              }
                            }
                          }
                          uint64_t v108 = *(void *)(a1 + 16);
                          if (*(float *)(a1 + 64) > v107) {
                            goto LABEL_105;
                          }
                          if (!*(unsigned char *)v108) {
                            goto LABEL_210;
                          }
                          uint64_t v125 = *(void *)(v108 + 48);
                          uint64_t v126 = *(void *)(v108 + 64);
                          if (!v125 || v126 == 0) {
                            goto LABEL_210;
                          }
                          unsigned int v128 = *(_DWORD *)(v108 + 4);
                          unsigned int v129 = *(_DWORD *)(v108 + 16);
                          if (v128 >= v129) {
                            goto LABEL_210;
                          }
                          unsigned int v227 = v104;
                          int16x4_t v130 = *v105;
                          *(int16x4_t *)v17.f32 = vshr_n_s16(*v105, 3uLL);
                          v99.i32[0] = v17.i16[0];
                          v100.i32[0] = v17.u16[1];
                          v100.i32[1] = v17.u16[2];
                          *(int32x2_t *)v100.f32 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)v100.f32, 0x10uLL), 0x10uLL);
                          int32x4_t v131 = (int32x4_t)vextq_s8(vextq_s8((int8x16_t)v99, (int8x16_t)v99, 4uLL), (int8x16_t)v100, 0xCuLL);
                          float32x4_t v99 = *((float32x4_t *)v34 + 113);
                          int32x4_t v132 = vmulq_s32(v131, (int32x4_t)v99);
                          float v133 = *v44;
                          float32x4_t v57 = (float32x4_t)vdupq_laneq_s32(v132, 2);
                          float32x4_t v59 = (float32x4_t)veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v132.i8, 1), (int8x16_t)v57);
                          float32x4_t v100 = (float32x4_t)veorq_s8((int8x16_t)v59, (int8x16_t)v132);
                          unsigned int v134 = *(_DWORD *)(v108 + 8);
                          unsigned int v135 = *(_DWORD *)(v108 + 12);
                          unsigned int v136 = v100.i32[0] % v134;
                          uint64_t v137 = v135 * (v100.i32[0] % v134);
                          uint64_t v138 = v137 + v135;
                          BOOL v140 = v137 >= v138
                              || v137 >= v129
                              || v138 > v129;
                          unsigned int v141 = *(_DWORD *)(v108 + 16);
                          unsigned int v142 = v141;
                          unsigned int v143 = v141;
                          if (v140) {
                            goto LABEL_140;
                          }
                          unsigned int v143 = *(_DWORD *)(v108 + 16);
                          unsigned int v142 = v143;
                          unsigned int v141 = v143;
                          while (1)
                          {
                            if ((*(_DWORD *)(v125 + 16 * v137 + 12) & 0x80000000) != 0)
                            {
                              if (v143 == v129) {
                                unsigned int v143 = v137;
                              }
                              goto LABEL_162;
                            }
                            v100.i64[0] = *(void *)(v125 + 16 * v137);
                            *(int16x4_t *)v59.f32 = vceq_s16(*(int16x4_t *)v100.f32, *(int16x4_t *)v17.f32);
                            v59.i16[3] = v59.i16[2];
                            if ((vminv_u16(*(uint16x4_t *)v59.f32) & 0x8000) != 0) {
                              break;
                            }
                            v59.i32[0] = v100.i16[0];
                            v100.i32[0] = v100.u16[1];
                            v100.i32[1] = v100.u16[2];
                            *(int32x2_t *)v100.f32 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)v100.f32, 0x10uLL), 0x10uLL);
                            int32x4_t v157 = vmulq_s32((int32x4_t)vextq_s8(vextq_s8((int8x16_t)v59, (int8x16_t)v59, 4uLL), (int8x16_t)v100, 0xCuLL), (int32x4_t)v99);
                            float32x4_t v57 = (float32x4_t)vdupq_laneq_s32(v157, 2);
                            float32x4_t v59 = (float32x4_t)veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v157.i8, 1), (int8x16_t)v57);
                            float32x4_t v100 = (float32x4_t)veorq_s8((int8x16_t)v59, (int8x16_t)v157);
                            if (v100.i32[0] % v134 == v136)
                            {
                              if (v141 == v129)
                              {
                                if (*(_DWORD *)(v125 + 16 * v137 + 8) >= v129) {
                                  unsigned int v141 = *(_DWORD *)(v108 + 16);
                                }
                                else {
                                  unsigned int v141 = v137;
                                }
                              }
                              unsigned int v142 = v137;
                            }
LABEL_162:
                            if (++v137 == v138) {
                              goto LABEL_140;
                            }
                          }
                          unsigned int v141 = *(_DWORD *)(v108 + 16);
                          unsigned int v142 = v141;
                          unsigned int v143 = v141;
                          if (v129 > v137)
                          {
                            unsigned int v149 = *(_DWORD *)(v125 + 16 * v137 + 12);
                            int16x4_t v171 = *v105;
                            if ((v149 & 0x80000000) != 0) {
                              goto LABEL_210;
                            }
                            goto LABEL_207;
                          }
LABEL_140:
                          if (v143 >= v129 && v142 >= v129 && v141 >= v129) {
                            goto LABEL_210;
                          }
                          uint64_t v144 = v143;
                          if (v143 < v129
                            && (uint64_t v145 = v125 + 16 * v143,
                                int v147 = *(_DWORD *)(v145 + 12),
                                float v146 = (unsigned int *)(v145 + 12),
                                v147 < 0))
                          {
                            *(void *)(v125 + 16 * v144) = v17.i64[0];
                            *float v146 = v128;
                            unint64_t v187 = (void *)(v126 + 4104 * v128);
                            float32x4_t v221 = v20;
                            float32x4_t v225 = v19;
                            float32x4_t v215 = v23;
                            float32x4_t v218 = v21;
                            float32x4_t v209 = v26;
                            float32x4_t v212 = v25;
                            float v194 = v30;
                            float32x4_t v203 = v56;
                            float32x4_t v206 = _Q25;
                            float32x4_t v200 = v73;
                            int16x4_t v192 = v130;
                            float v190 = v133;
                            float32x4_t v188 = v17;
                            bzero(v187, 0x1000uLL);
                            float v133 = v190;
                            int16x4_t v130 = v192;
                            float32x4_t v73 = v200;
                            float32x4_t v56 = v203;
                            uint64_t v34 = dispatch_group_wait;
                            _Q25 = v206;
                            float32x4_t v26 = v209;
                            float v30 = v194;
                            float32x4_t v25 = v212;
                            float32x4_t v23 = v215;
                            float v24 = 1.0;
                            float32x4_t v21 = v218;
                            float32x4_t v20 = v221;
                            float32x4_t v19 = v225;
                            v99.i32[3] = v188.i32[3];
                            v187[512] = v188.i64[0];
                          }
                          else
                          {
                            if (v141 < v129)
                            {
                              unsigned int v142 = v141;
                              do
                              {
                                uint64_t v148 = *(unsigned int *)(v125 + 16 * v142 + 8);
                                if (v148 >= v129) {
                                  goto LABEL_171;
                                }
                                *(int16x4_t *)v100.f32 = vceq_s16(*(int16x4_t *)(v125 + 16 * v148), *(int16x4_t *)v17.f32);
                                v100.i16[3] = v100.i16[2];
                                unsigned int v142 = *(_DWORD *)(v125 + 16 * v142 + 8);
                              }
                              while ((vminv_u16(*(uint16x4_t *)v100.f32) & 0x8000) == 0);
                              unsigned int v149 = *(_DWORD *)(v125 + 16 * v148 + 12);
                              goto LABEL_205;
                            }
LABEL_171:
                            if (v142 >= v129) {
                              goto LABEL_210;
                            }
                            uint64_t v158 = v125 + 16 * v142;
                            unsigned int v160 = *(_DWORD *)(v158 + 8);
                            uint64_t v159 = (unsigned int *)(v158 + 8);
                            if (v160 < v129 || (*(_DWORD *)(v125 + 16 * v142 + 12) & 0x80000000) != 0) {
                              goto LABEL_210;
                            }
                            uint64_t v186 = v159;
                            unsigned int v161 = (v135 + v142 - 1) / v135 % v134;
                            unsigned int v162 = v161;
                            unsigned int v224 = v161;
                            while (1)
                            {
                              uint64_t v166 = v162 * v135;
                              uint64_t v167 = v166 + v135;
                              if (v166 < v129 && v167 < v129)
                              {
                                if (v166 < v167)
                                {
                                  BOOL v164 = 0;
                                  int v163 = 0;
                                  float v169 = (unsigned int *)(v125 + 8 + 16 * v166);
                                  unsigned int v165 = *(_DWORD *)(v108 + 16);
                                  while (1)
                                  {
                                    if ((v169[1] & 0x80000000) != 0)
                                    {
                                      if (v165 == v129) {
                                        unsigned int v165 = v166;
                                      }
                                      if (v163) {
                                        goto LABEL_178;
                                      }
                                      int v163 = 1;
                                    }
                                    else if (v164)
                                    {
                                      BOOL v164 = 1;
                                    }
                                    else if (*v169 >= v129)
                                    {
                                      BOOL v164 = 0;
                                    }
                                    else
                                    {
                                      v100.i32[0] = *((__int16 *)v169 - 4);
                                      v100.i32[1] = *((__int16 *)v169 - 3);
                                      v100.i32[2] = *((__int16 *)v169 - 2);
                                      int32x4_t v170 = vmulq_s32((int32x4_t)v100, (int32x4_t)v99);
                                      float32x4_t v57 = (float32x4_t)vdupq_laneq_s32(v170, 2);
                                      float32x4_t v59 = (float32x4_t)veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v170.i8, 1), (int8x16_t)v57);
                                      float32x4_t v100 = (float32x4_t)veorq_s8((int8x16_t)v59, (int8x16_t)v170);
                                      BOOL v164 = v100.i32[0] % v134 == v162;
                                    }
                                    v169 += 4;
                                    if (v167 == ++v166) {
                                      goto LABEL_176;
                                    }
                                  }
                                }
                                int v163 = 0;
                                BOOL v164 = 0;
                                unsigned int v165 = *(_DWORD *)(v108 + 16);
LABEL_176:
                                if (!v164 || v163 == 0) {
                                  unsigned int v165 = *(_DWORD *)(v108 + 16);
                                }
LABEL_178:
                                unsigned int v161 = v224;
                                if (v165 < v129) {
                                  break;
                                }
                              }
                              uint64_t v38 = 0;
                              if (v162 + 1 == v134) {
                                unsigned int v162 = 0;
                              }
                              else {
                                ++v162;
                              }
                              if (v162 == v161) {
                                goto LABEL_101;
                              }
                            }
                            uint64_t v182 = v125 + 16 * v165;
                            *(void *)uint64_t v182 = v17.i64[0];
                            *(_DWORD *)(v182 + 12) = v128;
                            float v184 = (void *)(v126 + 4104 * v128);
                            float32x4_t v222 = v20;
                            float32x4_t v226 = v19;
                            float32x4_t v216 = v23;
                            float32x4_t v219 = v21;
                            float32x4_t v210 = v26;
                            float32x4_t v213 = v25;
                            float v195 = v30;
                            float32x4_t v204 = v56;
                            float32x4_t v207 = _Q25;
                            float32x4_t v201 = v73;
                            int16x4_t v193 = v130;
                            float v191 = v133;
                            float32x4_t v189 = v17;
                            unsigned int v185 = v165;
                            bzero(v184, 0x1000uLL);
                            float v133 = v191;
                            int16x4_t v130 = v193;
                            float32x4_t v73 = v201;
                            float32x4_t v56 = v204;
                            uint64_t v34 = dispatch_group_wait;
                            _Q25 = v207;
                            float32x4_t v26 = v210;
                            float v30 = v195;
                            float32x4_t v25 = v213;
                            float32x4_t v23 = v216;
                            float v24 = 1.0;
                            float32x4_t v21 = v219;
                            float32x4_t v20 = v222;
                            float32x4_t v19 = v226;
                            v99.i32[3] = v189.i32[3];
                            v184[512] = v189.i64[0];
                            unsigned int *v186 = v185;
                          }
                          unsigned int v149 = *(_DWORD *)(v108 + 4);
                          *(_DWORD *)(v108 + 4) = v149 + 1;
LABEL_205:
                          if ((v149 & 0x80000000) != 0)
                          {
LABEL_210:
                            uint64_t v38 = 0;
                            goto LABEL_101;
                          }
                          int16x4_t v171 = *v105;
LABEL_207:
                          uint64_t v38 = 0;
                          if (v133 >= 0.0)
                          {
                            v100.f32[0] = fabsf(v133);
                            unsigned int v172 = 897988541;
                            if (v100.f32[0] > 0.000001)
                            {
                              int16x4_t v173 = vsub_s16(v171, (int16x4_t)(*(void *)&v130 & 0xFFF8FFF8FFF8FFF8));
                              uint64_t v174 = *(void *)(*(void *)(a1 + 16) + 64)
                                   + 4104 * v149
                                   + ((uint64_t)v173.i16[0] << 9)
                                   + ((uint64_t)v173.i32[0] >> 16 << 6)
                                   + 8 * ((uint64_t)(*(void *)&v173 << 16) >> 48);
                              float v175 = fminf(v133, 255.0);
                              LOBYTE(v172) = *(unsigned char *)(v174 + 4);
                              float v176 = (float)v172;
                              float v177 = fmaxf(fminf(roundf(*(float *)(a1 + 212) * v176), 255.0), v24);
                              float v178 = fminf(v175 + v176, 255.0);
                              *(float *)&unsigned int v179 = (float)((float)((float)(v175 * v107)
                                                              * (float)(v24 - (float)(v176 / 255.0)))
                                                      + (float)(*(float *)v174 * v176))
                                              / v178;
                              *(float *)uint64_t v174 = *(float *)&v179;
                              LOBYTE(v179) = *(unsigned char *)(v174 + 5);
                              *(float *)&unsigned int v180 = fminf((float)((float)((float)(v177 * v198) * 255.0)+ (float)(v176 * (float)v179))/ (float)(v177 + v176), 255.0);
                              *(unsigned char *)(v174 + 5) = (int)*(float *)&v180;
                              LOBYTE(v180) = *(unsigned char *)(v174 + 6);
                              *(float *)&unsigned int v181 = fminf((float)((float)((float)(v177 * v197) * 255.0)+ (float)(v176 * (float)v180))/ (float)(v177 + v176), 255.0);
                              *(unsigned char *)(v174 + 6) = (int)*(float *)&v181;
                              LOBYTE(v181) = *(unsigned char *)(v174 + 7);
                              *(unsigned char *)(v174 + 7) = (int)fminf((float)((float)((float)(v177 * v196) * 255.0)+ (float)(v176 * (float)v181))/ (float)(v177 + v176), 255.0);
                              *(unsigned char *)(v174 + 4) = (int)v178;
                              goto LABEL_159;
                            }
                          }
LABEL_101:
                          ++v97;
                          uint64_t v104 = v38;
                          if (v97 >= *(unsigned int *)(a1 + 180)) {
                            goto LABEL_14;
                          }
                        }
                      }
                      LODWORD(v38) = 1;
LABEL_14:
                      int v12 = v38 | v228;
                    }
                  }
                }
              }
            }
          }
        }
        ++v11;
      }
      while (v11 != v27);
      sub_24B6F0BC0();
      if (v12) {
        return 1;
      }
    }
    else
    {
      sub_24B6F0BC0();
    }
    if (qword_2697D11B8 != -1) {
      dispatch_once(&qword_2697D11B8, &unk_26FE9CD60);
    }
    uint64_t v35 = qword_2697D11B0;
    BOOL result = os_log_type_enabled((os_log_t)qword_2697D11B0, OS_LOG_TYPE_ERROR);
    if (result)
    {
      sub_24B6F6D14(v229, "virtual BOOL oc::voxel_hashing::VoxelIntegratorCPU::integratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
      if (v230 >= 0) {
        double v183 = v229;
      }
      else {
        double v183 = (void **)v229[0];
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      uint64_t v232 = v183;
      __int16 v233 = 1026;
      int v234 = 210;
      float v37 = "%s:%{public}d Couldn't find any existing voxels or create new voxels intersecting the pointcloud";
      goto LABEL_222;
    }
  }
  return result;
}

BOOL sub_24B6F0650(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  float32x4_t v5 = *(float32x4_t *)a1;
  float32x4_t v6 = *(float32x4_t *)(a1 + 16);
  float32x4_t v7 = *(float32x4_t *)(a1 + 32);
  float32x4_t v8 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v9 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v10 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v11 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v10, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v5, *(float32x2_t *)v5.f32, 1), v6, *(float32x2_t *)v6.f32, 1), v7, *(float32x2_t *)v7.f32, 1), v8)), (int8x16_t)vcgeq_f32(v10, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v5, v5.f32[0]), v6, v6.f32[0]),
                                         v7,
                                         v7.f32[0]),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v10, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v5, v5, 2), v6, v6, 2), v7, v7, 2), v9)));
  v11.i32[3] = v11.i32[2];
  if ((vminvq_u32(v11) & 0x80000000) == 0) {
    goto LABEL_5;
  }
  float32x4_t v12 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2);
  float32x4_t v13 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v5, (int32x4_t)v7), (int32x4_t)v12);
  float32x4_t v14 = (float32x4_t)vtrn2q_s32((int32x4_t)v5, (int32x4_t)v6);
  v14.i32[2] = HIDWORD(*(void *)(a1 + 32));
  float32x4_t v15 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v5, (int32x4_t)v7), (int32x4_t)v6);
  uint32x4_t v16 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v10, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v15, v6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1), v14), v12, v13), v8)), (int8x16_t)vcgeq_f32(v10, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v15, v5.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1),
                                           v14),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2),
                                         v13),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v10, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v15, v7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1), v14), (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), v13), v9)));
  v16.i32[3] = v16.i32[2];
  if ((vminvq_u32(v16) & 0x80000000) == 0
    || (float32x4_t v17 = vmulq_f32(v5, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v7, (int8x16_t)v7, 0xCuLL), (int8x16_t)v7, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), (int8x16_t)v6, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v6, (int8x16_t)v6, 0xCuLL), (int8x16_t)v6, 8uLL))), fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0]+ -1.0) > 0.000011)|| (v18 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v6, (int8x16_t)v6, 8uLL))), v19 = (float32x2_t)vdup_n_s32(0x38D1B717u),
        uint32x2_t v20 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v19, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v7, (int8x16_t)v7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v19, v18)), (vpmin_u32(v20, v20).u32[0] & 0x80000000) == 0))
  {
LABEL_5:
    if (qword_2697D11B8 != -1) {
      dispatch_once(&qword_2697D11B8, &unk_26FE9CD60);
    }
    float32x4_t v21 = qword_2697D11B0;
    BOOL result = os_log_type_enabled((os_log_t)qword_2697D11B0, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::areValidInputsToIntegratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *, const uint32_t)");
    if (v40 >= 0) {
      float32x4_t v23 = __p;
    }
    else {
      float32x4_t v23 = *(unsigned char **)__p;
    }
    *(_DWORD *)unsigned int v32 = 136315394;
    *(void *)&v32[4] = v23;
    __int16 v33 = 1026;
    int v34 = 326;
    float v24 = "%s:%{public}d Invalid input to world transform.";
    goto LABEL_13;
  }
  if (!a2)
  {
    if (qword_2697D11B8 != -1) {
      dispatch_once(&qword_2697D11B8, &unk_26FE9CD60);
    }
    float32x4_t v21 = qword_2697D11B0;
    BOOL result = os_log_type_enabled((os_log_t)qword_2697D11B0, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::areValidInputsToIntegratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *, const uint32_t)");
    if (v40 >= 0) {
      float v29 = __p;
    }
    else {
      float v29 = *(unsigned char **)__p;
    }
    *(_DWORD *)unsigned int v32 = 136315394;
    *(void *)&v32[4] = v29;
    __int16 v33 = 1026;
    int v34 = 332;
    float v24 = "%s:%{public}d Input pointcloud is empty.";
    goto LABEL_13;
  }
  if (a2 <= a5)
  {
    if (a3)
    {
      if (a4) {
        return 1;
      }
      if (qword_2697D11B8 != -1) {
        dispatch_once(&qword_2697D11B8, &unk_26FE9CD60);
      }
      float32x4_t v21 = qword_2697D11B0;
      BOOL result = os_log_type_enabled((os_log_t)qword_2697D11B0, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::areValidInputsToIntegratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *, const uint32_t)");
      if (v40 >= 0) {
        float v31 = __p;
      }
      else {
        float v31 = *(unsigned char **)__p;
      }
      *(_DWORD *)unsigned int v32 = 136315394;
      *(void *)&v32[4] = v31;
      __int16 v33 = 1026;
      int v34 = 350;
      float v24 = "%s:%{public}d Point supplements are invalid.";
    }
    else
    {
      if (qword_2697D11B8 != -1) {
        dispatch_once(&qword_2697D11B8, &unk_26FE9CD60);
      }
      float32x4_t v21 = qword_2697D11B0;
      BOOL result = os_log_type_enabled((os_log_t)qword_2697D11B0, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::areValidInputsToIntegratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *, const uint32_t)");
      if (v40 >= 0) {
        float v30 = __p;
      }
      else {
        float v30 = *(unsigned char **)__p;
      }
      *(_DWORD *)unsigned int v32 = 136315394;
      *(void *)&v32[4] = v30;
      __int16 v33 = 1026;
      int v34 = 344;
      float v24 = "%s:%{public}d Pointcloud is invalid.";
    }
LABEL_13:
    _os_log_error_impl(&dword_24B6B9000, v21, OS_LOG_TYPE_ERROR, v24, v32, 0x12u);
    if ((SHIBYTE(v40) & 0x80000000) == 0) {
      return 0;
    }
    float32x4_t v25 = *(void **)__p;
LABEL_15:
    operator delete(v25);
    return 0;
  }
  if (qword_2697D11B8 != -1) {
    dispatch_once(&qword_2697D11B8, &unk_26FE9CD60);
  }
  uint64_t v27 = qword_2697D11B0;
  BOOL result = os_log_type_enabled((os_log_t)qword_2697D11B0, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_24B6F6D14(v32, "BOOL oc::voxel_hashing::areValidInputsToIntegratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *, const uint32_t)");
    if (v35 >= 0) {
      float32x2_t v28 = v32;
    }
    else {
      float32x2_t v28 = *(unsigned char **)v32;
    }
    *(_DWORD *)std::string __p = 136315650;
    *(void *)&__p[4] = v28;
    __int16 v37 = 1026;
    int v38 = 338;
    __int16 v39 = 1026;
    int v40 = a5;
    _os_log_error_impl(&dword_24B6B9000, v27, OS_LOG_TYPE_ERROR, "%s:%{public}d Input pointcloud is greater than the max supported size %{public}u.", __p, 0x18u);
    if ((v35 & 0x80000000) == 0) {
      return 0;
    }
    float32x4_t v25 = *(void **)v32;
    goto LABEL_15;
  }
  return result;
}

void sub_24B6F0BC0()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  if (!*(unsigned char *)(v0 + 8)) {
    return;
  }
  unint64_t v3 = (void *)v0;
  uint64_t v4 = *(void *)(v0 + 16);
  if (!v4) {
    return;
  }
  float32x4_t v5 = (void **)(v0 + 232);
  float32x4_t v6 = *(uint64_t **)(v0 + 232);
  if (!v6) {
    goto LABEL_132;
  }
  int32x4_t v7 = (int32x4_t)xmmword_24B72A710;
  do
  {
    while (1)
    {
      unsigned int v8 = *((_DWORD *)v6 + 4);
      if ((v8 & 0x80000000) == 0 && v8 < *(_DWORD *)(v4 + 4))
      {
        uint64_t v9 = 0;
        LOBYTE(v10) = 0;
        uint64_t v11 = *(void *)(v4 + 64);
        uint64_t v12 = v11 + 4104 * v8;
        float v13 = 3.4028e38;
        do
        {
          int v10 = v10;
          if (v10 <= *(unsigned __int8 *)(v12 + v9 + 4)) {
            int v10 = *(unsigned __int8 *)(v12 + v9 + 4);
          }
          if (*(unsigned char *)(v12 + v9 + 4))
          {
            float v14 = fabsf(*(float *)(v12 + v9));
            if (v14 < v13) {
              float v13 = v14;
            }
          }
          v9 += 8;
        }
        while (v9 != 4096);
        if (!v10 || v13 > 2.0) {
          break;
        }
      }
      float32x4_t v6 = (uint64_t *)*v6;
      if (!v6) {
        goto LABEL_132;
      }
    }
    if (!*(unsigned char *)v4) {
      goto LABEL_51;
    }
    uint64_t v16 = *(void *)(v4 + 48);
    if (!v16) {
      goto LABEL_51;
    }
    int16x4_t v17 = *(int16x4_t *)(v11 + 4104 * v8 + 4096);
    v1.i32[0] = v17.i16[0];
    v2.i32[0] = v17.u16[1];
    v2.i32[1] = v17.u16[2];
    *(int32x2_t *)v2.i8 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)v2.i8, 0x10uLL), 0x10uLL);
    int32x4_t v18 = vmulq_s32((int32x4_t)vextq_s8(vextq_s8(v1, v1, 4uLL), v2, 0xCuLL), v7);
    int8x16_t v2 = veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v18.i8, 1), (int8x16_t)vdupq_laneq_s32(v18, 2));
    int8x16_t v1 = veorq_s8(v2, (int8x16_t)v18);
    unsigned int v20 = *(_DWORD *)(v4 + 8);
    int v19 = *(_DWORD *)(v4 + 12);
    unsigned int v21 = v1.i32[0] % v20;
    uint64_t v22 = v19 * (v1.i32[0] % v20);
    uint64_t v23 = (v22 + v19);
    unsigned int v24 = *(_DWORD *)(v4 + 16);
    BOOL v25 = v22 >= v23 || v22 >= v24;
    if (v25 || v23 > v24) {
      goto LABEL_51;
    }
    LODWORD(v27) = *(_DWORD *)(v4 + 16);
    while ((*(_DWORD *)(v16 + 16 * v22 + 12) & 0x80000000) != 0)
    {
LABEL_31:
      if (++v22 == v23)
      {
        if (v24 > v27)
        {
          while (1)
          {
            uint64_t v31 = v16 + 16 * v27;
            unsigned int v33 = *(_DWORD *)(v31 + 8);
            unsigned int v32 = (_DWORD *)(v31 + 8);
            uint64_t v27 = v33;
            if (v33 >= v24) {
              break;
            }
            *(int16x4_t *)v1.i8 = vceq_s16(*(int16x4_t *)(v16 + 16 * v27), v17);
            v1.i16[3] = v1.i16[2];
            if ((vminv_u16(*(uint16x4_t *)v1.i8) & 0x8000) != 0)
            {
              _DWORD *v32 = *(_DWORD *)(v16 + 16 * v27 + 8);
              goto LABEL_50;
            }
          }
        }
        goto LABEL_51;
      }
    }
    v1.i64[0] = *(void *)(v16 + 16 * v22);
    *(int16x4_t *)v2.i8 = vceq_s16(*(int16x4_t *)v1.i8, v17);
    v2.i16[3] = v2.i16[2];
    if ((vminv_u16(*(uint16x4_t *)v2.i8) & 0x8000) == 0)
    {
      v2.i32[0] = v1.i16[0];
      v28.i32[0] = v1.u16[1];
      v28.i32[1] = v1.u16[2];
      *(int32x2_t *)v1.i8 = vshr_n_s32(vshl_n_s32(v28, 0x10uLL), 0x10uLL);
      int32x4_t v29 = vmulq_s32((int32x4_t)vextq_s8(vextq_s8(v2, v2, 4uLL), v1, 0xCuLL), v7);
      int8x16_t v2 = veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v29.i8, 1), (int8x16_t)vdupq_laneq_s32(v29, 2));
      int8x16_t v1 = veorq_s8(v2, (int8x16_t)v29);
      if (v1.i32[0] % v20 == v21 && v27 == v24)
      {
        if (*(_DWORD *)(v16 + 16 * v22 + 8) >= v24) {
          LODWORD(v27) = *(_DWORD *)(v4 + 16);
        }
        else {
          LODWORD(v27) = v22;
        }
      }
      goto LABEL_31;
    }
    if (v24 > v22 && (*(_DWORD *)(v16 + 16 * v22 + 12) & 0x80000000) == 0)
    {
      uint64_t v27 = v22;
      uint64_t v34 = v16 + 16 * v22;
      unsigned int v37 = *(_DWORD *)(v34 + 8);
      float v36 = (void *)(v34 + 8);
      uint64_t v35 = v37;
      if (v37 < v24)
      {
        int v38 = (void *)(v16 + 16 * v35);
        v1.i64[0] = v38[1];
        *(void *)(v16 + 16 * v27) = *v38;
        void *v36 = v1.i64[0];
        unsigned int v24 = *(_DWORD *)(v4 + 16);
        uint64_t v4 = v3[2];
        uint64_t v27 = v35;
      }
LABEL_50:
      uint64_t v39 = v16 + 16 * v27;
      *(_DWORD *)(v39 + 8) = v24;
      *(_DWORD *)(v39 + 12) = -1;
    }
LABEL_51:
    int v40 = *(_DWORD *)(v4 + 4) - 1;
    if (v8 == v40)
    {
      float32x4_t v6 = (uint64_t *)*v6;
      goto LABEL_103;
    }
    if (*(unsigned char *)v4)
    {
      uint64_t v41 = *(void *)(v4 + 64);
      int16x4_t v42 = *(int16x4_t *)(v41 + 4104 * v40 + 4096);
      v1.i32[0] = v42.i16[0];
      v2.i32[0] = v42.u16[1];
      v2.i32[1] = v42.u16[2];
      *(int32x2_t *)v2.i8 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)v2.i8, 0x10uLL), 0x10uLL);
      int32x4_t v43 = vmulq_s32((int32x4_t)vextq_s8(vextq_s8(v1, v1, 4uLL), v2, 0xCuLL), v7);
      int8x16_t v44 = veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v43.i8, 1), (int8x16_t)vdupq_laneq_s32(v43, 2));
      int8x16_t v45 = veorq_s8(v44, (int8x16_t)v43);
      unsigned int v47 = *(_DWORD *)(v4 + 8);
      int v46 = *(_DWORD *)(v4 + 12);
      unsigned int v48 = v45.i32[0] % v47;
      uint64_t v49 = v46 * (v45.i32[0] % v47);
      uint64_t v50 = (v49 + v46);
      unsigned int v51 = *(_DWORD *)(v4 + 16);
      if (v49 < v50 && v49 < v51 && v50 <= v51)
      {
        uint64_t v54 = *(void *)(v4 + 48);
        LODWORD(v55) = v51;
        do
        {
          if ((*(_DWORD *)(v54 + 16 * v49 + 12) & 0x80000000) == 0)
          {
            v45.i64[0] = *(void *)(v54 + 16 * v49);
            *(int16x4_t *)v44.i8 = vceq_s16(*(int16x4_t *)v45.i8, v42);
            v44.i16[3] = v44.i16[2];
            if ((vminv_u16(*(uint16x4_t *)v44.i8) & 0x8000) != 0)
            {
              if (v51 > v49 && (*(_DWORD *)(v54 + 16 * v49 + 12) & 0x80000000) == 0) {
                unsigned int v51 = v49;
              }
              goto LABEL_81;
            }
            v44.i32[0] = v45.i16[0];
            v56.i32[0] = v45.u16[1];
            v56.i32[1] = v45.u16[2];
            *(int32x2_t *)v45.i8 = vshr_n_s32(vshl_n_s32(v56, 0x10uLL), 0x10uLL);
            int32x4_t v57 = vmulq_s32((int32x4_t)vextq_s8(vextq_s8(v44, v44, 4uLL), v45, 0xCuLL), v7);
            int8x16_t v44 = veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v57.i8, 1), (int8x16_t)vdupq_laneq_s32(v57, 2));
            int8x16_t v45 = veorq_s8(v44, (int8x16_t)v57);
            if (v45.i32[0] % v47 == v48 && v55 == v51)
            {
              if (*(_DWORD *)(v54 + 16 * v49 + 8) >= v51) {
                LODWORD(v55) = v51;
              }
              else {
                LODWORD(v55) = v49;
              }
            }
          }
          ++v49;
        }
        while (v49 != v50);
        if (v51 > v55)
        {
          while (1)
          {
            uint64_t v55 = *(unsigned int *)(v54 + 16 * v55 + 8);
            if (v55 >= v51) {
              break;
            }
            uint16x4_t v59 = (uint16x4_t)vceq_s16(*(int16x4_t *)(v54 + 16 * v55), v42);
            v59.i16[3] = v59.i16[2];
            if ((vminv_u16(v59) & 0x8000) != 0)
            {
              unsigned int v51 = v55;
              break;
            }
          }
        }
      }
    }
    else
    {
      unsigned int v51 = *(_DWORD *)(v4 + 16);
      uint64_t v41 = *(void *)(v4 + 64);
    }
LABEL_81:
    float32x2_t v60 = (void *)(v41 + 4104 * v8);
    int8x8_t v61 = (void *)(v41 + 4104 * v40);
    memcpy(__dst, v60, sizeof(__dst));
    memcpy(v60, v61, 0x1008uLL);
    memcpy(v61, __dst, 0x1008uLL);
    uint64_t v4 = v3[2];
    *(_DWORD *)(*(void *)(v4 + 48) + 16 * v51 + 12) = v8;
    unint64_t v62 = v3[28];
    if (!v62) {
      goto LABEL_101;
    }
    unint64_t v63 = v40;
    uint8x8_t v64 = (uint8x8_t)vcnt_s8((int8x8_t)v62);
    v64.i16[0] = vaddlv_u8(v64);
    if (v64.u32[0] > 1uLL)
    {
      unint64_t v65 = v40;
      if (v62 <= v40) {
        unint64_t v65 = v40 % v62;
      }
    }
    else
    {
      unint64_t v65 = (v62 - 1) & v40;
    }
    uint64_t v66 = v3[27];
    float v67 = *(void ***)(v66 + 8 * v65);
    if (!v67 || (float v68 = *v67) == 0)
    {
LABEL_101:
      float32x4_t v6 = (uint64_t *)*v6;
      goto LABEL_102;
    }
    unint64_t v69 = v62 - 1;
    if (v64.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v70 = v68[1];
        if (v70 == v40)
        {
          if (*((_DWORD *)v68 + 4) == v40) {
            goto LABEL_105;
          }
        }
        else if ((v70 & v69) != v65)
        {
          goto LABEL_101;
        }
        float v68 = (void *)*v68;
        if (!v68) {
          goto LABEL_101;
        }
      }
    }
    while (2)
    {
      unint64_t v71 = v68[1];
      if (v71 != v40)
      {
        if (v71 >= v62) {
          v71 %= v62;
        }
        if (v71 != v65) {
          goto LABEL_101;
        }
        goto LABEL_96;
      }
      if (*((_DWORD *)v68 + 4) != v40)
      {
LABEL_96:
        float v68 = (void *)*v68;
        if (!v68) {
          goto LABEL_101;
        }
        continue;
      }
      break;
    }
LABEL_105:
    if (v64.u32[0] > 1uLL)
    {
      if (v62 <= v40) {
        unint64_t v63 = v40 % v62;
      }
    }
    else
    {
      unint64_t v63 = v69 & v40;
    }
    float v72 = *(void **)(v66 + 8 * v63);
    do
    {
      float32x4_t v73 = v72;
      float v72 = (void *)*v72;
    }
    while (v72 != v68);
    if (v73 == v5) {
      goto LABEL_122;
    }
    unint64_t v74 = v73[1];
    if (v64.u32[0] > 1uLL)
    {
      if (v74 >= v62) {
        v74 %= v62;
      }
    }
    else
    {
      v74 &= v69;
    }
    if (v74 != v63)
    {
LABEL_122:
      if (!*v68) {
        goto LABEL_123;
      }
      unint64_t v75 = *(void *)(*v68 + 8);
      if (v64.u32[0] > 1uLL)
      {
        if (v75 >= v62) {
          v75 %= v62;
        }
      }
      else
      {
        v75 &= v69;
      }
      if (v75 != v63) {
LABEL_123:
      }
        *(void *)(v66 + 8 * v63) = 0;
    }
    uint64_t v76 = *v68;
    if (*v68)
    {
      unint64_t v77 = *(void *)(v76 + 8);
      if (v64.u32[0] > 1uLL)
      {
        if (v77 >= v62) {
          v77 %= v62;
        }
      }
      else
      {
        v77 &= v69;
      }
      if (v77 != v63)
      {
        *(void *)(v3[27] + 8 * v77) = v73;
        uint64_t v76 = *v68;
      }
    }
    void *v73 = v76;
    --v3[30];
    operator delete(v68);
    uint64_t v4 = v3[2];
LABEL_102:
    int32x4_t v7 = (int32x4_t)xmmword_24B72A710;
LABEL_103:
    --*(_DWORD *)(v4 + 4);
  }
  while (v6);
LABEL_132:
  if (v3[30])
  {
    int v78 = *v5;
    if (*v5)
    {
      do
      {
        int32x2_t v79 = (void *)*v78;
        operator delete(v78);
        int v78 = v79;
      }
      while (v79);
    }
    v3[29] = 0;
    uint64_t v80 = v3[28];
    if (v80)
    {
      for (uint64_t i = 0; i != v80; ++i)
        *(void *)(v3[27] + 8 * i) = 0;
    }
    v3[30] = 0;
  }
}

void sub_24B6F12B0(float *a1, int a2, int a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            int v10 = (uint64_t *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  float v13 = operator new(0x18uLL);
  void *v13 = 0;
  v13[1] = v6;
  *((_DWORD *)v13 + 4) = a3;
  float v14 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v15 = a1[8];
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_59;
      }
      unint64_t v31 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t v31 = std::__next_prime(v31);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2) {
          unint64_t v31 = v33;
        }
      }
      if (prime <= v31) {
        size_t prime = v31;
      }
      if (prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
LABEL_59:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v6) {
            unint64_t v3 = v6 % v7;
          }
          else {
            unint64_t v3 = v6;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & v6;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        uint64_t v41 = *(void **)a1;
        *(void *)a1 = 0;
        if (v41) {
          operator delete(v41);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      sub_24B6BCD7C();
    }
    unsigned int v20 = operator new(8 * prime);
    unsigned int v21 = *(void **)a1;
    *(void *)a1 = v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v22++) = 0;
    while (prime != v22);
    unsigned int v24 = (uint64_t *)(a1 + 4);
    uint64_t v23 = (void *)*((void *)a1 + 2);
    if (!v23)
    {
LABEL_58:
      unint64_t v7 = prime;
      goto LABEL_59;
    }
    size_t v25 = v23[1];
    size_t v26 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v27 = v25 & v26;
      *(void *)(*(void *)a1 + 8 * v27) = v24;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v29 = i[1] & v26;
        if (v29 == v27)
        {
          uint64_t v23 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v29))
        {
          *uint64_t v23 = *i;
          uint64_t v30 = 8 * v29;
          *uint64_t i = **(void **)(*(void *)a1 + v30);
          **(void **)(*(void *)a1 + v30) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v29) = v23;
          uint64_t v23 = i;
          size_t v27 = v29;
        }
      }
      goto LABEL_58;
    }
    if (v25 >= prime) {
      v25 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v25) = v24;
    uint64_t v34 = (void *)*v23;
    if (!*v23) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v36 = v34[1];
      if (v36 >= prime) {
        v36 %= prime;
      }
      if (v36 != v25)
      {
        if (!*(void *)(*(void *)a1 + 8 * v36))
        {
          *(void *)(*(void *)a1 + 8 * v36) = v23;
          goto LABEL_63;
        }
        *uint64_t v23 = *v34;
        uint64_t v35 = 8 * v36;
        *uint64_t v34 = **(void **)(*(void *)a1 + v35);
        **(void **)(*(void *)a1 + v35) = v34;
        uint64_t v34 = v23;
      }
      size_t v36 = v25;
LABEL_63:
      uint64_t v23 = v34;
      uint64_t v34 = (void *)*v34;
      size_t v25 = v36;
      if (!v34) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  unsigned int v37 = *(void **)a1;
  int v38 = *(void **)(*(void *)a1 + 8 * v3);
  if (v38)
  {
    void *v13 = *v38;
LABEL_80:
    *int v38 = v13;
    goto LABEL_81;
  }
  uint64_t v39 = *((void *)a1 + 2);
  void *v13 = v39;
  *((void *)a1 + 2) = v13;
  v37[v3] = a1 + 4;
  if (v39)
  {
    unint64_t v40 = *(void *)(v39 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v40 >= v7) {
        v40 %= v7;
      }
    }
    else
    {
      v40 &= v7 - 1;
    }
    int v38 = (void *)(*(void *)a1 + 8 * v40);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
}

os_log_t sub_24B6F16F0()
{
  os_log_t result = os_log_create("com.apple.CoreOCModules", "VoxelHashing");
  qword_2697D11B0 = (uint64_t)result;
  return result;
}

uint64_t sub_24B6F1720(float32x4_t *a1, float32x4_t *a2)
{
  uint64_t v2 = a1->u8[8];
  if (a1->i8[8])
  {
    uint64_t v2 = 0;
    if (a2->f32[0] > 0.0 && a2->f32[1] > 0.0 && a2->f32[2] > 0.0)
    {
      float v3 = 1.0 / a1[11].f32[0];
      v4.i64[0] = 0x3F0000003F000000;
      v4.i64[1] = 0x3F0000003F000000;
      a1[5] = vmulq_n_f32(vmulq_f32(*a2, v4), v3);
      v4.i64[0] = 0xBF000000BF000000;
      v4.i64[1] = 0xBF000000BF000000;
      a1[6] = vmulq_n_f32(vmulq_f32(*a2, v4), v3);
      return 1;
    }
  }
  return v2;
}

BOOL sub_24B6F1790(uint64_t a1, float32x4_t *a2)
{
  if (!sub_24B6F1A0C((uint64_t)a2)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4 || *(unsigned char *)(a1 + 8)) {
    return 0;
  }
  BOOL v5 = *(unsigned char *)v4 != 0;
  if (!*(unsigned char *)v4) {
    return v5;
  }
  *(_OWORD *)uint8x8_t v32 = *(_OWORD *)(v4 + 9);
  *(_OWORD *)&v32[11] = *(_OWORD *)(v4 + 20);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(v4 + 8);
  *(_OWORD *)(a1 + 33) = *(_OWORD *)v32;
  v7.i32[1] = *(_DWORD *)&v32[15];
  *(_OWORD *)(a1 + 44) = *(_OWORD *)&v32[11];
  *(float *)v7.i32 = 1.0 / a2[7].f32[0];
  *(float32x2_t *)(a1 + 60) = vmul_f32(*(float32x2_t *)&a2->u32[2], (float32x2_t)*(_OWORD *)&vdupq_lane_s32(v7, 0));
  *(void *)(a1 + 68) = a2[1].i64[0];
  v8.i64[0] = 0x3F0000003F000000;
  v8.i64[1] = 0x3F0000003F000000;
  *(float32x4_t *)(a1 + 80) = vmulq_n_f32(vmulq_f32(a2[2], v8), *(float *)v7.i32);
  v8.i64[0] = 0xBF000000BF000000;
  v8.i64[1] = 0xBF000000BF000000;
  *(float32x4_t *)(a1 + 96) = vmulq_n_f32(vmulq_f32(a2[2], v8), *(float *)v7.i32);
  float32x4_t v9 = a2[3];
  float32x4_t v10 = a2[4];
  float32x4_t v11 = a2[6];
  *(float32x4_t *)(a1 + 144) = a2[5];
  *(float32x4_t *)(a1 + 160) = v11;
  *(float32x4_t *)(a1 + 112) = v9;
  *(float32x4_t *)(a1 + 128) = v10;
  *(_DWORD *)(a1 + 176) = a2[7].i32[0];
  float v13 = *(char **)(a1 + 184);
  uint64_t v12 = *(char **)(a1 + 192);
  uint64_t v14 = v12 - v13;
  if (!((unint64_t)(v12 - v13) >> 18))
  {
    unint64_t v15 = 0x8000 - ((unint64_t)v14 >> 3);
    uint64_t v16 = *(void *)(a1 + 200);
    if (v15 > (v16 - (uint64_t)v12) >> 3)
    {
      uint64_t v17 = v14 >> 3;
      unint64_t v18 = (v14 >> 3) + v15;
      if (v18 >> 61) {
        abort();
      }
      uint64_t v19 = v16 - (void)v13;
      if (v19 >> 2 > v18) {
        unint64_t v18 = v19 >> 2;
      }
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20)
      {
        if (v20 >> 61) {
          sub_24B6BCD7C();
        }
        unsigned int v21 = (char *)operator new(8 * v20);
      }
      else
      {
        unsigned int v21 = 0;
      }
      uint64_t v23 = &v21[8 * v17];
      size_t v24 = 8 * v15;
      size_t v25 = &v21[8 * v20];
      bzero(v23, v24);
      size_t v26 = &v23[v24];
      if (v12 != v13)
      {
        do
        {
          uint64_t v27 = *((void *)v12 - 1);
          v12 -= 8;
          *((void *)v23 - 1) = v27;
          v23 -= 8;
        }
        while (v12 != v13);
        uint64_t v12 = *(char **)(a1 + 184);
      }
      *(void *)(a1 + 184) = v23;
      *(void *)(a1 + 192) = v26;
      *(void *)(a1 + 200) = v25;
      if (v12) {
        operator delete(v12);
      }
      goto LABEL_28;
    }
    bzero(*(void **)(a1 + 192), 8 * v15);
    uint64_t v22 = &v12[8 * v15];
    goto LABEL_21;
  }
  if (v14 != 0x40000)
  {
    uint64_t v22 = v13 + 0x40000;
LABEL_21:
    *(void *)(a1 + 192) = v22;
  }
LABEL_28:
  *(_DWORD *)(a1 + 208) = a2[7].i32[1];
  uint64_t v28 = a2->u32[0];
  if (v28 > 5)
  {
    int v31 = 0;
    int v30 = 0;
  }
  else
  {
    uint64_t v29 = 4 * v28;
    int v30 = *(_DWORD *)((char *)&unk_24B72EC00 + v29);
    int v31 = *(_DWORD *)((char *)&unk_24B72EC18 + v29);
  }
  *(_DWORD *)(a1 + 212) = v30;
  *(_DWORD *)(a1 + 256) = a2[7].i32[2];
  *(_DWORD *)(a1 + 260) = v31;
  *(unsigned char *)(a1 + 8) = 1;
  return v5;
}

BOOL sub_24B6F1A0C(uint64_t a1)
{
  float v1 = *(float *)(a1 + 8);
  BOOL v2 = v1 <= 0.0 || v1 <= *(float *)(a1 + 12);
  if (*(_DWORD *)a1 == 5) {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 4);
  if (v4 == 2) {
    BOOL v2 = 1;
  }
  if (v2) {
    return 0;
  }
  float v5 = *(float *)(a1 + 16);
  float v6 = *(float *)(a1 + 20);
  float v7 = fabsf(v6);
  BOOL v8 = v5 > 0.0;
  if (fabsf(v5) <= 0.000001) {
    BOOL v8 = 1;
  }
  if (v7 > 0.000001 && v6 < 0.0 || v5 <= v6 || !v8) {
    return 0;
  }
  uint64_t v12 = 0;
  if (*(float *)(a1 + 32) > 0.0 && *(float *)(a1 + 36) > 0.0 && *(float *)(a1 + 40) > 0.0)
  {
    float32x4_t v13 = *(float32x4_t *)(a1 + 48);
    float32x4_t v14 = *(float32x4_t *)(a1 + 64);
    float32x4_t v15 = *(float32x4_t *)(a1 + 80);
    float32x4_t v16 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
    float32x4_t v17 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
    float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
    uint32x4_t v19 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v18, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v13, *(float32x2_t *)v13.f32, 1), v14, *(float32x2_t *)v14.f32, 1), v15, *(float32x2_t *)v15.f32, 1), v16)), (int8x16_t)vcgeq_f32(v18, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v13, v13.f32[0]), v14, v14.f32[0]),
                                           v15,
                                           v15.f32[0]),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v18, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v13, v13, 2), v14, v14, 2), v15, v15, 2), v17)));
    v19.i32[3] = v19.i32[2];
    if ((vminvq_u32(v19) & 0x80000000) == 0) {
      return 0;
    }
    float32x4_t v20 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2);
    float32x4_t v21 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v13, (int32x4_t)v15), (int32x4_t)v20);
    float32x4_t v22 = (float32x4_t)vtrn2q_s32((int32x4_t)v13, (int32x4_t)v14);
    v22.i32[2] = HIDWORD(*(void *)(a1 + 80));
    float32x4_t v23 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v13, (int32x4_t)v15), (int32x4_t)v14);
    uint32x4_t v24 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v18, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, v14.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1), v22), v20, v21), v16)), (int8x16_t)vcgeq_f32(v18, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, v13.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1),
                                             v22),
                                           (float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2),
                                           v21),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v18, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v23, v15.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1), v22), (float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), v21), v17)));
    v24.i32[3] = v24.i32[2];
    if ((vminvq_u32(v24) & 0x80000000) == 0) {
      return 0;
    }
    float32x4_t v25 = vmulq_f32(v13, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v15, (int8x16_t)v15, 0xCuLL), (int8x16_t)v15, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), (int8x16_t)v14, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v15, (int32x4_t)v15), (int8x16_t)v15, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v14, (int8x16_t)v14, 0xCuLL), (int8x16_t)v14, 8uLL)));
    if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0]+ -1.0) > 0.000011)return 0; {
    float32x2_t v26 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL)));
    }
    float32x2_t v27 = (float32x2_t)vdup_n_s32(0x38D1B717u);
    uint32x2_t v28 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v27, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a1 + 96), *(int8x16_t *)(a1 + 96), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v27, v26));
    if ((vpmin_u32(v28, v28).u32[0] & 0x80000000) == 0) {
      return 0;
    }
    if (*(float *)(a1 + 112) < 0.0001) {
      return 0;
    }
    uint64_t v12 = 0;
    if (*(float *)(a1 + 116) >= 1.0)
    {
      float v29 = *(float *)(a1 + 120);
      if (v29 >= 0.0 && v29 <= 1.0)
      {
        uint64_t v12 = *(unsigned __int8 *)(a1 + 126);
        if (*(unsigned char *)(a1 + 126)) {
          return !*(unsigned char *)(a1 + 127) || v4 == 1;
        }
      }
    }
  }
  return v12;
}

void sub_24B6F1D00(uint64_t a1)
{
  sub_24B6F1D38(a1);
  JUMPOUT(0x24C5D7790);
}

uint64_t sub_24B6F1D38(uint64_t a1)
{
  float v3 = (void **)(a1 + 184);
  BOOL v2 = *(void **)(a1 + 184);
  v3[1] = 0;
  v3[2] = 0;
  void *v3 = 0;
  if (v2) {
    operator delete(v2);
  }
  int v4 = *(void **)(a1 + 216);
  unint64_t v5 = *(void *)(a1 + 224);
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  float32x4_t v16 = v4;
  float v6 = *(void **)(a1 + 232);
  uint64_t v7 = *(void *)(a1 + 240);
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  v17[0] = v6;
  v17[1] = v7;
  int v18 = *(_DWORD *)(a1 + 248);
  *(_DWORD *)(a1 + 248) = 1065353216;
  if (v7)
  {
    unint64_t v8 = v6[1];
    if ((v5 & (v5 - 1)) != 0)
    {
      if (v8 >= v5) {
        v8 %= v5;
      }
      v4[v8] = v17;
    }
    else
    {
      v4[v8 & (v5 - 1)] = v17;
    }
  }
  else if (!v6)
  {
    if (!v4) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  do
  {
    float32x4_t v15 = (void *)*v6;
    operator delete(v6);
    float v6 = v15;
  }
  while (v15);
  int v4 = v16;
  if (v16) {
LABEL_8:
  }
    operator delete(v4);
LABEL_9:
  float32x4_t v9 = *(void **)(a1 + 232);
  if (v9)
  {
    do
    {
      float32x4_t v10 = (void *)*v9;
      operator delete(v9);
      float32x4_t v9 = v10;
    }
    while (v10);
  }
  float32x4_t v11 = *(void **)(a1 + 216);
  *(void *)(a1 + 216) = 0;
  if (v11) {
    operator delete(v11);
  }
  uint64_t v12 = *v3;
  if (*v3)
  {
    *(void *)(a1 + 192) = v12;
    operator delete(v12);
  }
  float32x4_t v13 = *(std::__shared_weak_count **)(a1 + 24);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  return a1;
}

os_log_t sub_24B6F1EA0()
{
  os_log_t result = os_log_create("com.apple.CoreOCModules", "General");
  qword_2697D11C0 = (uint64_t)result;
  return result;
}

uint64_t sub_24B6F1ED0(uint64_t a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F12A50]);
  int v4 = v2;
  if (!v2) {
    goto LABEL_15;
  }
  objc_msgSend_setTextureType_(v2, v3, 2);
  objc_msgSend_setPixelFormat_(v4, v5, 53);
  objc_msgSend_setWidth_(v4, v6, *(void *)(a1 + 208));
  objc_msgSend_setHeight_(v4, v7, *(void *)(a1 + 216));
  objc_msgSend_setUsage_(v4, v8, 5);
  objc_msgSend_setStorageMode_(v4, v9, 2);
  id v10 = **(id **)a1;
  uint64_t v12 = objc_msgSend_newTextureWithDescriptor_(v10, v11, (uint64_t)v4);
  float32x4_t v13 = *(void **)(a1 + 144);
  *(void *)(a1 + 144) = v12;

  float32x4_t v15 = *(void **)(a1 + 144);
  if (!v15) {
    goto LABEL_15;
  }
  objc_msgSend_setLabel_(v15, v14, @"SurfaceVoxelVisibleIndexTexture");
  if ((*(_DWORD *)(a1 + 192) - 1) <= 2)
  {
    objc_msgSend_setPixelFormat_(v4, v16, 125);
    objc_msgSend_setUsage_(v4, v17, 7);
    id v18 = **(id **)a1;
    uint64_t v20 = objc_msgSend_newTextureWithDescriptor_(v18, v19, (uint64_t)v4);
    float32x4_t v21 = *(void **)(a1 + 152);
    *(void *)(a1 + 152) = v20;

    float32x4_t v23 = *(void **)(a1 + 152);
    if (!v23) {
      goto LABEL_15;
    }
    objc_msgSend_setLabel_(v23, v22, @"SurfaceVoxelNormalTexture");
    objc_msgSend_setUsage_(v4, v24, 3);
    id v25 = **(id **)a1;
    uint64_t v27 = objc_msgSend_newTextureWithDescriptor_(v25, v26, (uint64_t)v4);
    uint32x2_t v28 = *(void **)(a1 + 160);
    *(void *)(a1 + 160) = v27;

    int v30 = *(void **)(a1 + 160);
    if (!v30) {
      goto LABEL_15;
    }
    objc_msgSend_setLabel_(v30, v29, @"SurfaceVoxelSmoothedNormalTexture");
  }
  objc_msgSend_setPixelFormat_(v4, v16, 252);
  objc_msgSend_setUsage_(v4, v31, 4);
  if (*(unsigned char *)(*(void *)a1 + 24)) {
    objc_msgSend_setStorageMode_(v4, v32, 3);
  }
  else {
    objc_msgSend_setStorageMode_(v4, v32, 2);
  }
  id v33 = **(id **)a1;
  uint64_t v35 = objc_msgSend_newTextureWithDescriptor_(v33, v34, (uint64_t)v4);
  size_t v36 = *(void **)(a1 + 168);
  *(void *)(a1 + 168) = v35;

  int v38 = *(void **)(a1 + 168);
  if (!v38) {
    goto LABEL_15;
  }
  objc_msgSend_setLabel_(v38, v37, @"SurfaceVoxelDepthTexture");
  if (*(unsigned char *)(*(void *)a1 + 24))
  {
    objc_msgSend_setPixelFormat_(v4, v39, 53);
    objc_msgSend_setUsage_(v4, v40, 5);
    objc_msgSend_setStorageMode_(v4, v41, 3);
    id v42 = **(id **)a1;
    uint64_t v44 = objc_msgSend_newTextureWithDescriptor_(v42, v43, (uint64_t)v4);
    int8x16_t v45 = *(void **)(a1 + 336);
    *(void *)(a1 + 336) = v44;

    unsigned int v47 = *(void **)(a1 + 336);
    if (v47)
    {
      objc_msgSend_setLabel_(v47, v46, @"tmpSurfaceVoxelVisibleIndexTexture");
      goto LABEL_14;
    }
LABEL_15:
    uint64_t v48 = 0;
    goto LABEL_16;
  }
LABEL_14:
  uint64_t v48 = 1;
LABEL_16:

  return v48;
}

void sub_24B6F212C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_24B6F2158(unsigned int *a1, const char *a2)
{
  uint64_t v2 = a1[48];
  if (v2 <= 4)
  {
    uint64_t v4 = v2;
    unint64_t v5 = off_2652DF0F0[v4];
    float v6 = off_2652DF118[v4];
    uint64_t v7 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)a1 + 16), a2, (uint64_t)off_2652DF140[v4]);
    id v8 = **(id **)a1;
    id v129 = 0;
    uint64_t v10 = objc_msgSend_newComputePipelineStateWithFunction_error_(v8, v9, (uint64_t)v7, &v129);
    id v11 = v129;
    uint64_t v12 = (void *)*((void *)a1 + 1);
    *((void *)a1 + 1) = v10;

    if (!*((void *)a1 + 1))
    {
      BOOL v36 = 0;
LABEL_29:

      return v36;
    }
    id v13 = objc_alloc_init(MEMORY[0x263F128B0]);
    unint64_t v14 = *((void *)a1 + 26);
    float v127 = (float)*((unint64_t *)a1 + 27);
    float v128 = (float)v14;
    objc_msgSend_setConstantValue_type_atIndex_(v13, v15, (uint64_t)&v128, 3, 0);
    objc_msgSend_setConstantValue_type_atIndex_(v13, v16, (uint64_t)&v127, 3, 1);
    objc_msgSend_setConstantValue_type_atIndex_(v13, v17, (uint64_t)(a1 + 76), 3, 2);
    id v18 = *(id *)(*(void *)a1 + 16);
    id v126 = v11;
    uint64_t v20 = objc_msgSend_newFunctionWithName_constantValues_error_(v18, v19, @"coverageFetchGOMDVisibleMeshVertex", v13, &v126);
    id v21 = v126;

    id v22 = **(id **)a1;
    id v125 = v21;
    uint64_t v116 = (void *)v20;
    uint64_t v24 = objc_msgSend_newComputePipelineStateWithFunction_error_(v22, v23, v20, &v125);
    id v11 = v125;

    id v25 = (void *)*((void *)a1 + 2);
    *((void *)a1 + 2) = v24;

    if (*((void *)a1 + 2))
    {
      uint64_t v27 = v116;
      if (a1[48] != 4)
      {
        id v34 = v11;
LABEL_11:
        uint64_t v115 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)a1 + 16), v26, (uint64_t)v6);
        unsigned int v114 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)a1 + 16), v37, (uint64_t)v5);
        id v38 = objc_alloc_init(MEMORY[0x263F129C0]);
        unint64_t v40 = v38;
        if (v38)
        {
          objc_msgSend_setVertexFunction_(v38, v39, (uint64_t)v115);
          objc_msgSend_setFragmentFunction_(v40, v41, (uint64_t)v114);
          uint64_t v44 = objc_msgSend_pixelFormat(*((void **)a1 + 18), v42, v43);
          unsigned int v47 = objc_msgSend_colorAttachments(v40, v45, v46);
          uint64_t v49 = objc_msgSend_objectAtIndexedSubscript_(v47, v48, 0);
          objc_msgSend_setPixelFormat_(v49, v50, v44);

          uint64_t v53 = objc_msgSend_pixelFormat(*((void **)a1 + 19), v51, v52);
          int32x2_t v56 = objc_msgSend_colorAttachments(v40, v54, v55);
          long long v58 = objc_msgSend_objectAtIndexedSubscript_(v56, v57, 1);
          objc_msgSend_setPixelFormat_(v58, v59, v53);

          uint64_t v62 = objc_msgSend_pixelFormat(*((void **)a1 + 21), v60, v61);
          objc_msgSend_setDepthAttachmentPixelFormat_(v40, v63, v62);
          id v64 = **(id **)a1;
          id v123 = v34;
          uint64_t v66 = objc_msgSend_newRenderPipelineStateWithDescriptor_error_(v64, v65, (uint64_t)v40, &v123);
          id v67 = v123;

          float v68 = (void *)*((void *)a1 + 4);
          *((void *)a1 + 4) = v66;

          if (*((void *)a1 + 4))
          {
            uint64_t v70 = *(id **)a1;
            if (*(unsigned char *)(*(void *)a1 + 24))
            {
              id v71 = objc_alloc_init(MEMORY[0x263F128B0]);
              unint64_t v72 = *((void *)a1 + 26);
              float v121 = (float)*((unint64_t *)a1 + 27);
              float v122 = (float)v72;
              uint64_t v27 = v116;
              int v112 = v71;
              objc_msgSend_setConstantValue_type_atIndex_(v71, v73, (uint64_t)&v122, 3, 0);
              objc_msgSend_setConstantValue_type_atIndex_(v71, v74, (uint64_t)&v121, 3, 1);
              objc_msgSend_setConstantValue_type_atIndex_(v71, v75, (uint64_t)(a1 + 76), 3, 2);
              id v76 = *(id *)(*(void *)a1 + 16);
              id v120 = v67;
              int8x16_t v111 = objc_msgSend_newFunctionWithName_constantValues_error_(v76, v77, @"coverageTileFetchVisibleSurfaceVoxel", v71, &v120);
              id v34 = v120;

              id v78 = objc_alloc_init(MEMORY[0x263F12A70]);
              uint64_t v80 = v78;
              if (v78)
              {
                objc_msgSend_setTileFunction_(v78, v79, (uint64_t)v111);
                uint64_t v83 = objc_msgSend_pixelFormat(*((void **)a1 + 42), v81, v82);
                float v86 = objc_msgSend_colorAttachments(v80, v84, v85);
                float v88 = objc_msgSend_objectAtIndexedSubscript_(v86, v87, 0);
                objc_msgSend_setPixelFormat_(v88, v89, v83);

                objc_msgSend_setThreadgroupSizeMatchesTileSize_(v80, v90, 1);
                id v91 = **(id **)a1;
                id v119 = v34;
                uint64_t v93 = objc_msgSend_newRenderPipelineStateWithTileDescriptor_options_reflection_error_(v91, v92, (uint64_t)v80, 0, 0, &v119);
                id v94 = v119;

                uint32x4_t v95 = (void *)*((void *)a1 + 39);
                *((void *)a1 + 39) = v93;

                if (*((void *)a1 + 39))
                {
                  unint64_t v97 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)a1 + 16), v96, @"coverageVisibilityTileFragmentShader");
                  objc_msgSend_setFragmentFunction_(v40, v98, (uint64_t)v97);
                  id v99 = **(id **)a1;
                  id v118 = v94;
                  uint64_t v101 = objc_msgSend_newRenderPipelineStateWithDescriptor_error_(v99, v100, (uint64_t)v40, &v118);
                  id v34 = v118;

                  float v102 = (void *)*((void *)a1 + 40);
                  *((void *)a1 + 40) = v101;

                  uint64_t v103 = *((void *)a1 + 40);
                  if (!v103)
                  {
                    BOOL v36 = 0;
                    uint64_t v27 = v116;
                    goto LABEL_27;
                  }
                  uint64_t v70 = *(id **)a1;
                  goto LABEL_23;
                }
                id v34 = v94;
                uint64_t v27 = v116;
              }

              BOOL v36 = 0;
              goto LABEL_27;
            }
            id v34 = v67;
LABEL_23:
            unsigned int v113 = objc_msgSend_newFunctionWithName_(v70[2], v69, @"meshVisibilityVertexShader", v111);
            objc_msgSend_setVertexFunction_(v40, v104, (uint64_t)v113);
            id v105 = **(id **)a1;
            id v117 = v34;
            uint64_t v107 = objc_msgSend_newRenderPipelineStateWithDescriptor_error_(v105, v106, (uint64_t)v40, &v117);
            id v108 = v117;

            int32x4_t v109 = (void *)*((void *)a1 + 5);
            *((void *)a1 + 5) = v107;

            BOOL v36 = *((void *)a1 + 5) != 0;
            id v34 = v108;
            uint64_t v27 = v116;

            goto LABEL_27;
          }
          BOOL v36 = 0;
          id v34 = v67;
          uint64_t v27 = v116;
        }
        else
        {
          BOOL v36 = 0;
        }
LABEL_27:

        id v11 = v34;
        goto LABEL_28;
      }
      id v28 = *(id *)(*(void *)a1 + 16);
      uint64_t v30 = objc_msgSend_newFunctionWithName_(v28, v29, @"coverageGOMDProcess");

      id v31 = **(id **)a1;
      id v124 = v11;
      uint64_t v33 = objc_msgSend_newComputePipelineStateWithFunction_error_(v31, v32, v30, &v124);
      id v34 = v124;

      uint64_t v35 = (void *)*((void *)a1 + 3);
      *((void *)a1 + 3) = v33;

      if (*((void *)a1 + 3))
      {
        uint64_t v7 = (void *)v30;
        uint64_t v27 = v116;
        goto LABEL_11;
      }
      BOOL v36 = 0;
      uint64_t v7 = (void *)v30;
      id v11 = v34;
    }
    else
    {
      BOOL v36 = 0;
    }
    uint64_t v27 = v116;
LABEL_28:

    goto LABEL_29;
  }
  return 0;
}

void sub_24B6F27EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

BOOL sub_24B6F2980(uint64_t a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F128A0]);
  uint64_t v4 = v2;
  if (v2)
  {
    objc_msgSend_setDepthCompareFunction_(v2, v3, 1);
    objc_msgSend_setDepthWriteEnabled_(v4, v5, 1);
    id v6 = **(id **)a1;
    uint64_t v8 = objc_msgSend_newDepthStencilStateWithDescriptor_(v6, v7, (uint64_t)v4);
    float32x4_t v9 = *(void **)(a1 + 48);
    *(void *)(a1 + 48) = v8;

    BOOL v10 = *(void *)(a1 + 48) != 0;
  }
  else
  {
    BOOL v10 = 0;
  }

  return v10;
}

void sub_24B6F2A18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_24B6F2A34(uint64_t a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F129A0]);
  float v3 = *(void **)(a1 + 176);
  *(void *)(a1 + 176) = v2;

  uint64_t v6 = *(void *)(a1 + 176);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 144);
    uint64_t v8 = objc_msgSend_colorAttachments(*(void **)(a1 + 176), v4, v5);
    BOOL v10 = objc_msgSend_objectAtIndexedSubscript_(v8, v9, 0);
    objc_msgSend_setTexture_(v10, v11, v7);

    unint64_t v14 = objc_msgSend_colorAttachments(*(void **)(a1 + 176), v12, v13);
    float32x4_t v16 = objc_msgSend_objectAtIndexedSubscript_(v14, v15, 0);
    objc_msgSend_setLoadAction_(v16, v17, 2);

    uint64_t v20 = objc_msgSend_colorAttachments(*(void **)(a1 + 176), v18, v19);
    id v22 = objc_msgSend_objectAtIndexedSubscript_(v20, v21, 0);
    objc_msgSend_setClearColor_(v22, v23, v24, 0.0, 0.0, 0.0, 0.0);

    uint64_t v27 = objc_msgSend_colorAttachments(*(void **)(a1 + 176), v25, v26);
    float v29 = objc_msgSend_objectAtIndexedSubscript_(v27, v28, 0);
    objc_msgSend_setStoreAction_(v29, v30, 1);

    if ((*(_DWORD *)(a1 + 192) - 1) <= 3)
    {
      uint64_t v33 = *(void *)(a1 + 152);
      id v34 = objc_msgSend_colorAttachments(*(void **)(a1 + 176), v31, v32);
      BOOL v36 = objc_msgSend_objectAtIndexedSubscript_(v34, v35, 1);
      objc_msgSend_setTexture_(v36, v37, v33);

      unint64_t v40 = objc_msgSend_colorAttachments(*(void **)(a1 + 176), v38, v39);
      id v42 = objc_msgSend_objectAtIndexedSubscript_(v40, v41, 1);
      objc_msgSend_setLoadAction_(v42, v43, 2);

      uint64_t v46 = objc_msgSend_colorAttachments(*(void **)(a1 + 176), v44, v45);
      uint64_t v48 = objc_msgSend_objectAtIndexedSubscript_(v46, v47, 1);
      objc_msgSend_setClearColor_(v48, v49, v50, 0.0, 0.0, 0.0, 0.0);

      uint64_t v53 = objc_msgSend_colorAttachments(*(void **)(a1 + 176), v51, v52);
      uint64_t v55 = objc_msgSend_objectAtIndexedSubscript_(v53, v54, 1);
      objc_msgSend_setStoreAction_(v55, v56, 1);
    }
    uint64_t v57 = *(void *)(a1 + 168);
    long long v58 = objc_msgSend_depthAttachment(*(void **)(a1 + 176), v31, v32);
    objc_msgSend_setTexture_(v58, v59, v57);

    uint64_t v62 = objc_msgSend_depthAttachment(*(void **)(a1 + 176), v60, v61);
    objc_msgSend_setLoadAction_(v62, v63, 2);

    uint64_t v66 = objc_msgSend_depthAttachment(*(void **)(a1 + 176), v64, v65);
    objc_msgSend_setClearDepth_(v66, v67, v68, 1.0);

    id v71 = objc_msgSend_depthAttachment(*(void **)(a1 + 176), v69, v70);
    objc_msgSend_setStoreAction_(v71, v72, 0);
  }
  return v6 != 0;
}

void sub_24B6F2CAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_24B6F2D18(uint64_t a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F129A0]);
  float v3 = *(void **)(a1 + 328);
  *(void *)(a1 + 328) = v2;

  uint64_t v6 = *(void *)(a1 + 328);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 336);
    uint64_t v8 = objc_msgSend_colorAttachments(*(void **)(a1 + 328), v4, v5);
    BOOL v10 = objc_msgSend_objectAtIndexedSubscript_(v8, v9, 0);
    objc_msgSend_setTexture_(v10, v11, v7);

    unint64_t v14 = objc_msgSend_colorAttachments(*(void **)(a1 + 328), v12, v13);
    float32x4_t v16 = objc_msgSend_objectAtIndexedSubscript_(v14, v15, 0);
    objc_msgSend_setLoadAction_(v16, v17, 2);

    uint64_t v20 = objc_msgSend_colorAttachments(*(void **)(a1 + 328), v18, v19);
    id v22 = objc_msgSend_objectAtIndexedSubscript_(v20, v21, 0);
    objc_msgSend_setClearColor_(v22, v23, v24, 0.0, 0.0, 0.0, 0.0);

    uint64_t v27 = objc_msgSend_colorAttachments(*(void **)(a1 + 328), v25, v26);
    float v29 = objc_msgSend_objectAtIndexedSubscript_(v27, v28, 0);
    objc_msgSend_setStoreAction_(v29, v30, 0);

    uint64_t v31 = *(void *)(a1 + 168);
    id v34 = objc_msgSend_depthAttachment(*(void **)(a1 + 328), v32, v33);
    objc_msgSend_setTexture_(v34, v35, v31);

    id v38 = objc_msgSend_depthAttachment(*(void **)(a1 + 328), v36, v37);
    objc_msgSend_setLoadAction_(v38, v39, 2);

    id v42 = objc_msgSend_depthAttachment(*(void **)(a1 + 328), v40, v41);
    objc_msgSend_setClearDepth_(v42, v43, v44, 1.0);

    unsigned int v47 = objc_msgSend_depthAttachment(*(void **)(a1 + 328), v45, v46);
    objc_msgSend_setStoreAction_(v47, v48, 0);

    objc_msgSend_setTileWidth_(*(void **)(a1 + 328), v49, 32);
    objc_msgSend_setTileHeight_(*(void **)(a1 + 328), v50, 32);
  }
  return v6 != 0;
}

void sub_24B6F2ECC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_24B6F2F10(uint64_t a1)
{
  id v2 = objc_alloc(MEMORY[0x263F13288]);
  id v3 = **(id **)a1;
  LODWORD(v4) = 1128857600;
  uint64_t v6 = objc_msgSend_initWithDevice_sigma_(v2, v5, (uint64_t)v3, v4);
  uint64_t v7 = *(void **)(a1 + 184);
  *(void *)(a1 + 184) = v6;

  return *(void *)(a1 + 184) != 0;
}

void sub_24B6F2F88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B6F2F98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0;
  if (*(unsigned char *)(a1 + 288) && *(float *)a2 > 0.0)
  {
    float32x4_t v6 = *(float32x4_t *)(a2 + 16);
    float32x4_t v7 = *(float32x4_t *)(a2 + 32);
    float32x4_t v8 = *(float32x4_t *)(a2 + 48);
    float32x4_t v9 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
    float32x4_t v10 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
    float32x4_t v11 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
    uint32x4_t v12 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v6, *(float32x2_t *)v6.f32, 1), v7, *(float32x2_t *)v7.f32, 1), v8, *(float32x2_t *)v8.f32, 1), v9)), (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v6, v6.f32[0]), v7, v7.f32[0]),
                                           v8,
                                           v8.f32[0]),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v6, v6, 2), v7, v7, 2), v8, v8, 2), v10)));
    v12.i32[3] = v12.i32[2];
    if ((vminvq_u32(v12) & 0x80000000) != 0
      && (float32x4_t v13 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2),
          float32x4_t v14 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v6, (int32x4_t)v8), (int32x4_t)v13),
          float32x4_t v15 = (float32x4_t)vtrn2q_s32((int32x4_t)v6, (int32x4_t)v7),
          v15.i32[2] = HIDWORD(*(void *)(a2 + 48)),
          float32x4_t v16 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v6, (int32x4_t)v8), (int32x4_t)v7),
          uint32x4_t v17 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1), v15), v13, v14), v9)), (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1),
                                                   v15),
                                                 (float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2),
                                                 v14),
                                               *MEMORY[0x263EF89A0]))),
                              (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1), v15), (float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), v14), v10))), v17.i32[3] = v17.i32[2], (vminvq_u32(v17) & 0x80000000) != 0))
    {
      float32x4_t v18 = vmulq_f32(v6, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL), (int8x16_t)v8, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v7, (int8x16_t)v7, 0xCuLL), (int8x16_t)v7, 8uLL)));
      uint64_t result = 0;
      if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0]+ -1.0) <= 0.000011)
      {
        float32x2_t v19 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v6, (int8x16_t)v6, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v7, (int8x16_t)v7, 8uLL)));
        float32x2_t v20 = (float32x2_t)vdup_n_s32(0x38D1B717u);
        uint32x2_t v21 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v20, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v8, (int8x16_t)v8, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a2 + 64), *(int8x16_t *)(a2 + 64), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v20, v19));
        if ((vpmin_u32(v21, v21).u32[0] & 0x80000000) != 0)
        {
          if (*(void *)(a2 + 80))
          {
            if (*(void *)(a2 + 88))
            {
              uint64_t result = sub_24B6ED0CC(a1 + 56, a2, a3);
              if (result)
              {
                float32x4_t v24 = *(float32x4_t *)(a2 + 16);
                float32x4_t v25 = *(float32x4_t *)(a2 + 32);
                float32x4_t v26 = *(float32x4_t *)(a2 + 48);
                float32x4_t v27 = *(float32x4_t *)(a2 + 64);
                float32x4_t v28 = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v24, *(float *)a2), (float32x4_t)0, v25), (float32x4_t)0, v26), (float32x4_t)0, v27);
                float32x4_t v29 = vmulq_f32(v24, (float32x4_t)0);
                float32x4_t v30 = vmlaq_f32(vmlaq_f32(vmlaq_n_f32(v29, v25, *(float *)a2), (float32x4_t)0, v26), (float32x4_t)0, v27);
                float32x4_t v31 = vmlaq_f32(v29, (float32x4_t)0, v25);
                float32x4_t v32 = vmlaq_f32(vmlaq_n_f32(v31, v26, *(float *)a2), (float32x4_t)0, v27);
                *(float32x4_t *)(a1 + 224) = v28;
                *(float32x4_t *)(a1 + 240) = v30;
                *(float32x4_t *)(a1 + 256) = v32;
                *(float32x4_t *)(a1 + 272) = vaddq_f32(v27, vmlaq_f32(v31, (float32x4_t)0, v26));
                *(_DWORD *)(a1 + 292) = *(_DWORD *)(a1 + 100);
                *(void *)(a1 + 296) = *(void *)(a2 + 88);
                if (*(_DWORD *)(a1 + 192))
                {
                  uint64_t v33 = objc_msgSend_contents(*(void **)(a1 + 120), v22, v23);
                  memcpy(v33, *(const void **)(a2 + 88), 48 * *(unsigned int *)(a1 + 292));
                }
                uint64_t result = 1;
                *(unsigned char *)(a1 + 289) = 1;
                *(_DWORD *)(a1 + 488) = 1;
              }
            }
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_24B6F3244(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  if (a4 < 0.0001 || *(unsigned char *)(a1 + 288) == 0) {
    return 0;
  }
  float32x4_t v7 = *(float32x4_t *)a2;
  float32x4_t v6 = *(float32x4_t *)(a2 + 16);
  float32x4_t v8 = *(float32x4_t *)(a2 + 32);
  float32x4_t v9 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v10 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v11 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v12 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v7, *(float32x2_t *)v7.f32, 1), v6, *(float32x2_t *)v6.f32, 1), v8, *(float32x2_t *)v8.f32, 1), v9)), (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v7, v7.f32[0]), v6, v6.f32[0]),
                                         v8,
                                         v8.f32[0]),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v7, v7, 2), v6, v6, 2), v8, v8, 2), v10)));
  v12.i32[3] = v12.i32[2];
  if ((vminvq_u32(v12) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v13 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2);
  float32x4_t v14 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v7, (int32x4_t)v8), (int32x4_t)v13);
  float32x4_t v15 = (float32x4_t)vtrn2q_s32((int32x4_t)v7, (int32x4_t)v6);
  v15.i32[2] = HIDWORD(*(void *)(a2 + 32));
  float32x4_t v16 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v7, (int32x4_t)v8), (int32x4_t)v6);
  float32x4_t v17 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v18 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1), v15), v13, v14), v9)), (int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1),
                                           v15),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2),
                                         v14),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1), v15), (float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), v14), v10)));
  v18.i32[3] = v18.i32[2];
  if ((vminvq_u32(v18) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v19 = vmulq_f32(v7, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL), (int8x16_t)v8, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), (int8x16_t)v6, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v6, (int8x16_t)v6, 0xCuLL), (int8x16_t)v6, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).f32[0]+ -1.0) > 0.000011)return 0; {
  float32x2_t v20 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v7, (int8x16_t)v7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v6, (int8x16_t)v6, 8uLL)));
  }
  float32x2_t v21 = (float32x2_t)vdup_n_s32(0x38D1B717u);
  uint32x2_t v22 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v21, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v8, (int8x16_t)v8, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a2 + 48), *(int8x16_t *)(a2 + 48), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v21, v20));
  if ((vpmin_u32(v22, v22).u32[0] & 0x80000000) == 0) {
    return 0;
  }
  uint64_t result = *(void *)a3;
  if (*(void *)a3)
  {
    if (!*(void *)(a3 + 8) || !*(void *)(a3 + 16)) {
      return 0;
    }
    int v26 = *(_DWORD *)objc_msgSend_contents((void *)result, (const char *)a2, a3);
    float32x4_t v29 = (_DWORD *)objc_msgSend_contents(*(void **)(a3 + 16), v27, v28);
    uint64_t result = 0;
    if (v26 && *v29)
    {
      *(void *)(a1 + 128) = a3;
      float32x4_t v30 = *(float32x4_t *)(a2 + 16);
      float32x4_t v31 = *(float32x4_t *)(a2 + 32);
      float32x4_t v32 = *(float32x4_t *)(a2 + 48);
      float32x4_t v33 = vmulq_f32(*(float32x4_t *)a2, (float32x4_t)0);
      float32x4_t v34 = vmlaq_f32(vmlaq_f32(vmlaq_n_f32(v33, v30, a4), (float32x4_t)0, v31), (float32x4_t)0, v32);
      float32x4_t v35 = vmlaq_f32(v33, (float32x4_t)0, v30);
      *(float32x4_t *)(a1 + 224) = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(*(float32x4_t *)a2, a4), (float32x4_t)0, v30), (float32x4_t)0, v31), (float32x4_t)0, v32);
      *(float32x4_t *)(a1 + 240) = v34;
      *(float32x4_t *)(a1 + 256) = vmlaq_f32(vmlaq_n_f32(v35, v31, a4), (float32x4_t)0, v32);
      *(float32x4_t *)(a1 + 272) = vaddq_f32(v32, vmlaq_f32(v35, (float32x4_t)0, v31));
      *(_DWORD *)(a1 + 292) = v26;
      if (*(_DWORD *)(a1 + 192)) {
        objc_storeStrong((id *)(a1 + 120), *(id *)(a3 + 8));
      }
      uint64_t result = 1;
      *(unsigned char *)(a1 + 289) = 1;
      *(_DWORD *)(a1 + 488) = 2;
    }
  }
  return result;
}

int32x4_t *sub_24B6F3514(uint64_t a1, unint64_t a2, const float *a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  float32x4_t v7 = *(float **)a1;
  uint64_t result = (int32x4_t *)v7;
  if (a2 <= (v6 - (uint64_t)v7) >> 2)
  {
    float32x2_t v20 = *(float32x4_t **)(a1 + 8);
    int64_t v21 = (char *)v20 - (char *)v7;
    unint64_t v22 = ((char *)v20 - (char *)v7) >> 2;
    if (v22 >= a2) {
      unint64_t v23 = a2;
    }
    else {
      unint64_t v23 = ((char *)v20 - (char *)v7) >> 2;
    }
    if (v23)
    {
      if (v23 < 8 || v7 < a3 + 1 && &v7[v23] > a3) {
        goto LABEL_27;
      }
      uint64_t result = (int32x4_t *)&v7[v23 & 0xFFFFFFFFFFFFFFF8];
      float32x4_t v24 = vld1q_dup_f32(a3);
      float32x4_t v25 = (float32x4_t *)(v7 + 4);
      unint64_t v26 = v23 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        v25[-1] = v24;
        *float32x4_t v25 = v24;
        v25 += 2;
        v26 -= 8;
      }
      while (v26);
      if (v23 != (v23 & 0xFFFFFFFFFFFFFFF8))
      {
        v23 &= 7u;
        do
        {
LABEL_27:
          *(float *)result->i32 = *a3;
          uint64_t result = (int32x4_t *)((char *)result + 4);
          --v23;
        }
        while (v23);
      }
    }
    BOOL v10 = a2 >= v22;
    unint64_t v27 = a2 - v22;
    if (v27 == 0 || !v10)
    {
      float32x4_t v13 = &v7[a2];
      goto LABEL_39;
    }
    uint64_t v28 = (float32x4_t *)((char *)v20 + 4 * v27);
    unint64_t v29 = 4 * a2 - (v21 & 0xFFFFFFFFFFFFFFFCLL) - 4;
    if (v29 >= 0x4C && (v20 >= (float32x4_t *)(a3 + 1) || (char *)&v20->i32[1] + v29 <= (char *)a3))
    {
      uint64_t v30 = (v29 >> 2) + 1;
      float32x4_t v31 = vld1q_dup_f32(a3);
      float32x4_t v32 = v20 + 1;
      uint64_t v33 = v30 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v32[-1] = v31;
        float32x4_t *v32 = v31;
        v32 += 2;
        v33 -= 8;
      }
      while (v33);
      if (v30 == (v30 & 0x7FFFFFFFFFFFFFF8)) {
        goto LABEL_38;
      }
      float32x2_t v20 = (float32x4_t *)((char *)v20 + 4 * (v30 & 0x7FFFFFFFFFFFFFF8));
    }
    do
    {
      v20->f32[0] = *a3;
      float32x2_t v20 = (float32x4_t *)((char *)v20 + 4);
    }
    while (v20 != v28);
LABEL_38:
    *(void *)(a1 + 8) = v28;
    return result;
  }
  if (v7)
  {
    *(void *)(a1 + 8) = v7;
    operator delete(v7);
    uint64_t v6 = 0;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v9 = v6 >> 1;
  if (v6 >> 1 <= a2) {
    uint64_t v9 = a2;
  }
  BOOL v10 = (unint64_t)v6 >= 0x7FFFFFFFFFFFFFFCLL;
  unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
  if (!v10) {
    unint64_t v11 = v9;
  }
  if (v11 >> 62) {
    abort();
  }
  uint64_t v12 = 4 * v11;
  uint64_t result = (int32x4_t *)operator new(4 * v11);
  *(void *)a1 = result;
  *(void *)(a1 + 16) = (char *)result + v12;
  float32x4_t v13 = (float *)&result->i32[a2];
  *(float *)v14.i32 = *a3;
  unint64_t v15 = (a2 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v15 >= 7)
  {
    unint64_t v16 = v15 + 1;
    int32x4_t v17 = vdupq_lane_s32(v14, 0);
    uint32x4_t v18 = result + 1;
    uint64_t v19 = v16 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v18[-1] = v17;
      int32x4_t *v18 = v17;
      v18 += 2;
      v19 -= 8;
    }
    while (v19);
    if (v16 == (v16 & 0x7FFFFFFFFFFFFFF8)) {
      goto LABEL_39;
    }
    uint64_t result = (int32x4_t *)((char *)result + 4 * (v16 & 0x7FFFFFFFFFFFFFF8));
  }
  do
  {
    result->i32[0] = v14.i32[0];
    uint64_t result = (int32x4_t *)((char *)result + 4);
  }
  while (result != (int32x4_t *)v13);
LABEL_39:
  *(void *)(a1 + 8) = v13;
  return result;
}

uint64_t sub_24B6F3720(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, float a7)
{
  float32x4_t v8 = *(float32x4_t *)a2;
  float32x4_t v7 = *(float32x4_t *)(a2 + 16);
  float32x4_t v9 = *(float32x4_t *)(a2 + 32);
  float32x4_t v10 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v11 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v12 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v13 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v12, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v8, *(float32x2_t *)v8.f32, 1), v7, *(float32x2_t *)v7.f32, 1), v9, *(float32x2_t *)v9.f32, 1), v10)), (int8x16_t)vcgeq_f32(v12, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v8, v8.f32[0]), v7, v7.f32[0]),
                                         v9,
                                         v9.f32[0]),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v12, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v8, v8, 2), v7, v7, 2), v9, v9, 2), v11)));
  v13.i32[3] = v13.i32[2];
  if ((vminvq_u32(v13) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v14 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2);
  float32x4_t v15 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v8, (int32x4_t)v9), (int32x4_t)v14);
  float32x4_t v16 = (float32x4_t)vtrn2q_s32((int32x4_t)v8, (int32x4_t)v7);
  v16.i32[2] = HIDWORD(*(void *)(a2 + 32));
  float32x4_t v17 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v8, (int32x4_t)v9), (int32x4_t)v7);
  uint32x4_t v18 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v12, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v17, v7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1), v16), v14, v15), v10)), (int8x16_t)vcgeq_f32(v12, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v17, v8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1),
                                           v16),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2),
                                         v15),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v12, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v17, v9.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1), v16), (float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), v15), v11)));
  v18.i32[3] = v18.i32[2];
  if ((vminvq_u32(v18) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v19 = vmulq_f32(v8, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v9, (int8x16_t)v9, 0xCuLL), (int8x16_t)v9, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v7, (int8x16_t)v7, 0xCuLL), (int8x16_t)v7, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).f32[0]+ -1.0) > 0.000011)return 0; {
  uint64_t result = 0;
  }
  if (a7 < 3.1416 && a7 > 0.0)
  {
    float32x2_t v22 = (float32x2_t)vdup_n_s32(0x38D1B717u);
    uint32x2_t v23 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v22, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a2 + 48), *(int8x16_t *)(a2 + 48), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v22, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v8,
                                                                                     (int8x16_t)v8,
                                                                                     8uLL),
                                                            (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v7, (int8x16_t)v7, 8uLL)))));
    if ((vpmin_u32(v23, v23).u32[0] & 0x80000000) != 0)
    {
      if (a6 && *(_DWORD *)(a1 + 292) > ((a6[1] - *a6) >> 2)) {
        return 0;
      }
      uint64_t result = 0;
      float v28 = (float)*(unint64_t *)(a1 + 208) / (float)*(unint64_t *)(a1 + 216);
      if (v28 >= 0.001 && a7 >= 0.0 && fabsf(a7) > 0.000001)
      {
        uint64_t result = 0;
        float v29 = *(float *)(a1 + 200);
        float v30 = *(float *)(a1 + 204);
        if (v30 > v29 && v30 >= 0.001 && v29 >= 0.001 && fabsf(a7 + -3.1416) > 0.000032416)
        {
          float32x4_t v106 = *(float32x4_t *)(a2 + 16);
          float32x4_t v107 = *(float32x4_t *)(a2 + 32);
          float32x4_t v105 = *(float32x4_t *)a2;
          float32x4_t v108 = *(float32x4_t *)(a2 + 48);
          float v31 = 1.0 / tanf(a7 * 0.5);
          *(float *)&unsigned int v32 = v31 / v28;
          LODWORD(v33) = 0;
          *((float *)&v33 + 1) = v31;
          v34.i64[0] = 0;
          v34.f32[2] = (float)-v30 / (float)(v30 - v29);
          v34.i32[3] = -1.0;
          v35.i64[0] = 0;
          v35.i64[1] = COERCE_UNSIGNED_INT(v34.f32[2] * v29);
          float32x4_t v36 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v105, COERCE_FLOAT(*(_OWORD *)(a1 + 224))), v106, *(float32x2_t *)(a1 + 224), 1), v107, *(float32x4_t *)(a1 + 224), 2), v108, *(float32x4_t *)(a1 + 224), 3);
          float32x4_t v37 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v105, COERCE_FLOAT(*(_OWORD *)(a1 + 240))), v106, *(float32x2_t *)(a1 + 240), 1), v107, *(float32x4_t *)(a1 + 240), 2), v108, *(float32x4_t *)(a1 + 240), 3);
          float32x4_t v38 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v105, COERCE_FLOAT(*(_OWORD *)(a1 + 256))), v106, *(float32x2_t *)(a1 + 256), 1), v107, *(float32x4_t *)(a1 + 256), 2), v108, *(float32x4_t *)(a1 + 256), 3);
          float32x4_t v39 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v105, COERCE_FLOAT(*(_OWORD *)(a1 + 272))), v106, *(float32x2_t *)(a1 + 272), 1), v107, *(float32x4_t *)(a1 + 272), 2), v108, *(float32x4_t *)(a1 + 272), 3);
          v110[0] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v32, v36.f32[0]), (float32x4_t)v33, *(float32x2_t *)v36.f32, 1), v34, v36, 2), v35, v36, 3);
          v110[1] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v32, v37.f32[0]), (float32x4_t)v33, *(float32x2_t *)v37.f32, 1), v34, v37, 2), v35, v37, 3);
          v110[2] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v32, v38.f32[0]), (float32x4_t)v33, *(float32x2_t *)v38.f32, 1), v34, v38, 2), v35, v38, 3);
          v110[3] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v32, v39.f32[0]), (float32x4_t)v33, *(float32x2_t *)v39.f32, 1), v34, v39, 2), v35, v39, 3);
          id v42 = objc_msgSend_commandBuffer(*(void **)(*(void *)a1 + 8), v40, v41);
          uint64_t v44 = objc_msgSend_renderCommandEncoderWithDescriptor_(v42, v43, *(void *)(a1 + 176));
          objc_msgSend_setLabel_(v44, v45, @"VisibleIndexRenderEncoder");
          objc_msgSend_setRenderPipelineState_(v44, v46, *(void *)(a1 + 32));
          objc_msgSend_setDepthStencilState_(v44, v47, *(void *)(a1 + 48));
          objc_msgSend_setVertexBuffer_offset_atIndex_(v44, v48, *(void *)(a1 + 112), 0, 0);
          objc_msgSend_setVertexBytes_length_atIndex_(v44, v49, (uint64_t)v110, 64, 1);
          if ((*(_DWORD *)(a1 + 192) - 1) <= 3)
          {
            objc_msgSend_setVertexBuffer_offset_atIndex_(v44, v50, *(void *)(a1 + 120), 0, 2);
            objc_msgSend_setVertexBytes_length_atIndex_(v44, v51, a1 + 224, 64, 3);
            objc_msgSend_setVertexBytes_length_atIndex_(v44, v52, a1 + 488, 4, 4);
          }
          objc_msgSend_drawPrimitives_vertexStart_vertexCount_(v44, v50, 3, 0, (36 * *(_DWORD *)(a1 + 292)), *(_OWORD *)&v105, *(_OWORD *)&v106, *(_OWORD *)&v107, *(_OWORD *)&v108);
          uint64_t v111 = 0;
          uint64_t v112 = 0;
          float64x2_t v113 = vcvtq_f64_u64(*(uint64x2_t *)(a1 + 208));
          long long v114 = xmmword_24B72A670;
          objc_msgSend_setViewport_(v44, v53, (uint64_t)&v111);
          objc_msgSend_endEncoding(v44, v54, v55);

          if (*(_DWORD *)(a1 + 192) == 1) {
            objc_msgSend_encodeToCommandBuffer_sourceTexture_destinationTexture_(*(void **)(a1 + 184), v56, (uint64_t)v42, *(void *)(a1 + 152), *(void *)(a1 + 160));
          }
          long long v58 = objc_msgSend_computeCommandEncoder(v42, v56, v57);
          objc_msgSend_setLabel_(v58, v59, @"FetchVisibleSurfaceVoxelEncoder");
          objc_msgSend_setComputePipelineState_(v58, v60, *(void *)(a1 + 8));
          objc_msgSend_setTexture_atIndex_(v58, v61, *(void *)(a1 + 144), 0);
          int v63 = *(_DWORD *)(a1 + 192);
          if ((v63 - 2) >= 2)
          {
            if (v63 != 1)
            {
LABEL_27:
              uint64_t v65 = a1 + 292;
              switch(v63)
              {
                case 0:
                  objc_msgSend_setBytes_length_atIndex_(v58, v62, v65, 4, 0);
                  id v67 = (uint64_t *)(a1 + 136);
                  goto LABEL_33;
                case 1:
                  objc_msgSend_setBytes_length_atIndex_(v58, v62, v65, 4, 0);
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v68, *(void *)(a1 + 120), 0, 1);
                  objc_msgSend_setBytes_length_atIndex_(v58, v69, a1 + 224, 64, 2);
                  objc_msgSend_setBytes_length_atIndex_(v58, v70, a3, 16, 3);
                  objc_msgSend_setBytes_length_atIndex_(v58, v71, a4, 4, 4);
                  objc_msgSend_setBytes_length_atIndex_(v58, v72, a5, 4, 5);
                  objc_msgSend_setBytes_length_atIndex_(v58, v73, a1 + 344, 64, 6);
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v74, *(void *)(a1 + 136), 0, 7);
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v75, *(void *)(a1 + 408), 0, 8);
                  break;
                case 2:
                  objc_msgSend_setBytes_length_atIndex_(v58, v62, v65, 4, 0);
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v76, *(void *)(a1 + 120), 0, 1);
                  objc_msgSend_setBytes_length_atIndex_(v58, v77, a1 + 224, 64, 2);
                  objc_msgSend_setBytes_length_atIndex_(v58, v78, a3, 16, 3);
                  objc_msgSend_setBytes_length_atIndex_(v58, v79, (uint64_t)&unk_24B72EB6E, 1, 4);
                  objc_msgSend_setBytes_length_atIndex_(v58, v80, (uint64_t)&unk_24B72EB6F, 1, 5);
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v81, *(void *)(a1 + 136), 0, 6);
                  break;
                case 3:
                  objc_msgSend_setBytes_length_atIndex_(v58, v62, v65, 4, 0);
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v82, *(void *)(a1 + 120), 0, 1);
                  objc_msgSend_setBytes_length_atIndex_(v58, v83, a1 + 224, 64, 2);
                  objc_msgSend_setBytes_length_atIndex_(v58, v84, a3, 16, 3);
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v85, *(void *)(a1 + 432), 0, 4);
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v86, *(void *)(a1 + 440), 0, 5);
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v87, *(void *)(a1 + 448), 0, 6);
                  objc_msgSend_setBytes_length_atIndex_(v58, v88, a1 + 416, 4, 7);
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v89, *(void *)(a1 + 136), 0, 8);
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v90, *(void *)(a1 + 424), 0, 9);
                  break;
                case 4:
                  objc_msgSend_setBytes_length_atIndex_(v58, v62, v65, 4, 0);
                  id v67 = (uint64_t *)(a1 + 456);
LABEL_33:
                  objc_msgSend_setBuffer_offset_atIndex_(v58, v66, *v67, 0, 1);
                  break;
                default:
                  break;
              }
              uint64_t v91 = *(void *)(a1 + 208);
              uint64_t v92 = *(void *)(a1 + 216);
              unint64_t v93 = objc_msgSend_threadExecutionWidth(*(void **)(a1 + 8), v62, v65);
              unint64_t v96 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 8), v94, v95);
              uint64_t v111 = v91;
              uint64_t v112 = v92;
              *(void *)&v113.f64[0] = 1;
              v115[0] = v93;
              v115[1] = v96 / v93;
              v115[2] = 1;
              objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v58, v97, (uint64_t)&v111, v115);
              objc_msgSend_endEncoding(v58, v98, v99);

              if (*(_DWORD *)(a1 + 192) == 4) {
                sub_24B6F4024(a1, v42, a3);
              }
              v109[0] = MEMORY[0x263EF8330];
              v109[1] = 3221225472;
              v109[2] = sub_24B6F41C4;
              v109[3] = &unk_2652DF070;
              v109[4] = a1;
              v109[5] = a6;
              objc_msgSend_addCompletedHandler_(v42, v100, (uint64_t)v109);
              objc_msgSend_commit(v42, v101, v102);
              objc_msgSend_waitUntilCompleted(v42, v103, v104);

              return 1;
            }
            id v64 = (uint64_t *)(a1 + 160);
          }
          else
          {
            id v64 = (uint64_t *)(a1 + 152);
          }
          objc_msgSend_setTexture_atIndex_(v58, v62, *v64, 1);
          int v63 = *(_DWORD *)(a1 + 192);
          goto LABEL_27;
        }
      }
    }
  }
  return result;
}

void sub_24B6F3FE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B6F4024(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = objc_msgSend_computeCommandEncoder(a2, (const char *)a2, a3);
  objc_msgSend_setLabel_(v5, v6, @"GOMDProcessEncoder");
  objc_msgSend_setComputePipelineState_(v5, v7, *(void *)(a1 + 24));
  objc_msgSend_setBuffer_offset_atIndex_(v5, v8, *(void *)(a1 + 456), 0, 0);
  objc_msgSend_setBytes_length_atIndex_(v5, v9, (uint64_t)&unk_24B72EB70, 4, 1);
  objc_msgSend_setBytes_length_atIndex_(v5, v10, a1 + 292, 4, 2);
  objc_msgSend_setBuffer_offset_atIndex_(v5, v11, *(void *)(a1 + 120), 0, 3);
  objc_msgSend_setBytes_length_atIndex_(v5, v12, a1 + 224, 64, 4);
  objc_msgSend_setBytes_length_atIndex_(v5, v13, a3, 16, 5);
  objc_msgSend_setBytes_length_atIndex_(v5, v14, a1 + 488, 4, 6);
  objc_msgSend_setBuffer_offset_atIndex_(v5, v15, *(void *)(a1 + 464), 0, 7);
  objc_msgSend_setBuffer_offset_atIndex_(v5, v16, *(void *)(a1 + 136), 0, 8);
  objc_msgSend_setBuffer_offset_atIndex_(v5, v17, *(void *)(a1 + 472), 0, 9);
  objc_msgSend_setBuffer_offset_atIndex_(v5, v18, *(void *)(a1 + 480), 0, 10);
  uint64_t v19 = *(unsigned int *)(a1 + 292);
  unint64_t v22 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 24), v20, v21);
  unint64_t v24 = *(unsigned int *)(a1 + 292);
  if (v22 < v24) {
    unint64_t v24 = v22;
  }
  uint64_t v29 = v19;
  int64x2_t v30 = vdupq_n_s64(1uLL);
  unint64_t v27 = v24;
  int64x2_t v28 = v30;
  objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v5, v23, (uint64_t)&v29, &v27);
  objc_msgSend_endEncoding(v5, v25, v26);
}

void sub_24B6F41B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B6F41C4(uint64_t a1)
{
  float v1 = *(const char **)(a1 + 40);
  if (v1) {
    sub_24B6F41DC(*(void *)(a1 + 32), v1, 0);
  }
}

void sub_24B6F41DC(uint64_t a1, const char *a2, uint64_t a3)
{
  switch(*(_DWORD *)(a1 + 192))
  {
    case 0:
      uint64_t v5 = objc_msgSend_contents(*(void **)(a1 + 136), a2, a3);
      size_t v6 = vcvtps_u32_f32((float)*(unsigned int *)(a1 + 292) / 500.0);
      v38[0] = MEMORY[0x263EF8330];
      v38[1] = 3221225472;
      v38[2] = sub_24B6F4510;
      v38[3] = &unk_2652DF218;
      v38[4] = a1;
      v38[5] = a2;
      v38[6] = v5;
      float32x4_t v7 = v38;
      goto LABEL_7;
    case 1:
      uint64_t v8 = objc_msgSend_contents(*(void **)(a1 + 136), a2, a3);
      uint64_t v11 = objc_msgSend_contents(*(void **)(a1 + 408), v9, v10);
      size_t v6 = vcvtps_u32_f32((float)*(unsigned int *)(a1 + 292) / 500.0);
      v37[0] = MEMORY[0x263EF8330];
      v37[1] = 3221225472;
      v37[2] = sub_24B6F45CC;
      v37[3] = &unk_2652DF090;
      v37[4] = a1;
      v37[5] = v11;
      v37[6] = a2;
      v37[7] = v8;
      float32x4_t v7 = v37;
      goto LABEL_7;
    case 2:
      uint64_t v12 = objc_msgSend_contents(*(void **)(a1 + 136), a2, a3);
      size_t v6 = vcvtps_u32_f32((float)*(unsigned int *)(a1 + 292) / 500.0);
      v36[0] = MEMORY[0x263EF8330];
      v36[1] = 3221225472;
      v36[2] = sub_24B6F4640;
      v36[3] = &unk_2652DF218;
      v36[4] = a1;
      v36[5] = a2;
      v36[6] = v12;
      float32x4_t v7 = v36;
      goto LABEL_7;
    case 3:
      uint64_t v13 = objc_msgSend_contents(*(void **)(a1 + 136), a2, a3);
      uint64_t v16 = objc_msgSend_contents(*(void **)(a1 + 424), v14, v15);
      uint64_t v19 = objc_msgSend_contents(*(void **)(a1 + 432), v17, v18);
      uint64_t v22 = objc_msgSend_contents(*(void **)(a1 + 440), v20, v21);
      uint64_t v25 = objc_msgSend_contents(*(void **)(a1 + 448), v23, v24);
      size_t v6 = vcvtps_u32_f32((float)*(unsigned int *)(a1 + 292) / 500.0);
      v35[0] = MEMORY[0x263EF8330];
      v35[1] = 3221225472;
      v35[2] = sub_24B6F49F4;
      v35[3] = &unk_2652DF0B0;
      v35[4] = a1;
      v35[5] = v16;
      v35[6] = a2;
      v35[7] = v13;
      v35[8] = v19;
      v35[9] = v22;
      v35[10] = v25;
      float32x4_t v7 = v35;
      goto LABEL_7;
    case 4:
      uint64_t v27 = objc_msgSend_contents(*(void **)(a1 + 136), a2, a3);
      uint64_t v30 = objc_msgSend_contents(*(void **)(a1 + 472), v28, v29);
      uint64_t v33 = objc_msgSend_contents(*(void **)(a1 + 464), v31, v32);
      size_t v6 = vcvtps_u32_f32((float)*(unsigned int *)(a1 + 292) / 500.0);
      block[0] = MEMORY[0x263EF8330];
      block[1] = 3221225472;
      block[2] = sub_24B6F4AEC;
      block[3] = &unk_2652DF0D0;
      void block[4] = a1;
      block[5] = v33;
      block[6] = a2;
      block[7] = v27;
      void block[8] = v30;
      block[9] = a3;
      float32x4_t v7 = block;
LABEL_7:
      dispatch_apply(v6, 0, v7);
      break;
    default:
      return;
  }
}

uint64_t sub_24B6F4510(uint64_t result, uint64_t a2)
{
  unint64_t v2 = 500 * a2;
  unint64_t v3 = *(unsigned int *)(*(void *)(result + 32) + 292);
  if (500 * a2 + 500 < v3) {
    unint64_t v3 = 500 * a2 + 500;
  }
  unint64_t v4 = v3 - v2;
  if (v3 > v2)
  {
    uint64_t v5 = *(void *)(result + 48);
    uint64_t v6 = **(void **)(result + 40);
    if (v4 > 7)
    {
      unint64_t v7 = v4 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v8 = 2000 * a2 + 16;
      float32x4_t v9 = (int8x16_t *)(v6 + v8);
      uint64_t v10 = (int32x4_t *)(v5 + v8);
      __asm { FMOV            V0.4S, #1.0 }
      unint64_t v16 = v4 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        int8x16_t v17 = vbicq_s8(_Q0, (int8x16_t)vceqzq_s32(*v10));
        v9[-1] = vbicq_s8(_Q0, (int8x16_t)vceqzq_s32(v10[-1]));
        int8x16_t *v9 = v17;
        v9 += 2;
        v10 += 2;
        v16 -= 8;
      }
      while (v16);
      if (v4 == v7) {
        return result;
      }
      v2 += v7;
    }
    unint64_t v18 = v3 - v2;
    uint64_t v19 = 4 * v2;
    float32x2_t v20 = (float *)(v6 + 4 * v2);
    uint64_t v21 = (_DWORD *)(v5 + v19);
    do
    {
      if (*v21++) {
        float v23 = 1.0;
      }
      else {
        float v23 = 0.0;
      }
      *v20++ = v23;
      --v18;
    }
    while (v18);
  }
  return result;
}

uint64_t sub_24B6F45CC(uint64_t result, uint64_t a2)
{
  unint64_t v2 = 500 * a2;
  unint64_t v3 = *(unsigned int *)(*(void *)(result + 32) + 292);
  if (500 * a2 + 500 < v3) {
    unint64_t v3 = 500 * a2 + 500;
  }
  if (v2 < v3)
  {
    uint64_t v4 = *(void *)(result + 40);
    uint64_t v5 = **(void **)(result + 48);
    do
    {
      unsigned int v7 = *(_DWORD *)(v4 + 4 * v2);
      if (v7) {
        float v6 = (float)((float)*(unsigned int *)(*(void *)(result + 56) + 4 * v2) / (float)v7) / 1000.0;
      }
      else {
        float v6 = 0.0;
      }
      *(float *)(v5 + 4 * v2++) = v6;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t sub_24B6F4640(uint64_t result, uint64_t a2, float32x4_t a3, float a4)
{
  unint64_t v4 = 500 * a2;
  unint64_t v5 = *(unsigned int *)(*(void *)(result + 32) + 292);
  if (500 * a2 + 500 < v5) {
    unint64_t v5 = 500 * a2 + 500;
  }
  if (v4 < v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)(result + 48);
    uint64_t v8 = **(void **)(result + 40);
    uint64_t v9 = (2000 * a2) | 4;
    uint64_t v10 = (32000 * a2) | 0x40;
    uint64_t v11 = v7 + 32000 * a2;
    uint64_t v12 = v8 + 2000 * a2;
    uint64_t v13 = v11;
    do
    {
      a3.i32[0] = *(_DWORD *)(v8 + 4 * v4);
      if (v12 + 4 * v6 >= (unint64_t)(v7 + v10 + (v6 << 6))
        || v11 + (v6 << 6) >= (unint64_t)(v8 + v9 + 4 * v6))
      {
        uint64_t v14 = v7 + (v4 << 6);
        int8x16_t v15 = *(int8x16_t *)(v14 + 16);
        float32x4_t v16 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v14, *(int8x8_t *)a3.f32) & 0xFF00FF00FF00FFLL)));
        a3.f32[0] = (float)((float)(a3.f32[0] + v16.f32[0]) + v16.f32[1]) + v16.f32[2];
        int8x8_t v17 = (int8x8_t)vextq_s8(*(int8x16_t *)v14, *(int8x16_t *)v14, 8uLL).u64[0];
        float32x4_t v18 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v14, *(int8x8_t *)a3.f32) & 0xFF00FF00FF00FFLL)));
        a3.f32[0] = (float)((float)((float)(a3.f32[0] + v16.f32[3]) + v18.f32[0]) + v18.f32[1]) + v18.f32[2];
        float32x4_t v19 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v17, *(int8x8_t *)a3.f32) & 0xFF00FF00FF00FFLL)));
        float32x4_t v20 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v17, *(int8x8_t *)a3.f32) & 0xFF00FF00FF00FFLL)));
        a3.f32[0] = (float)((float)((float)((float)((float)((float)(a3.f32[0] + v18.f32[3]) + v20.f32[0]) + v20.f32[1])
                                          + v20.f32[2])
                                  + v20.f32[3])
                          + v19.f32[0])
                  + v19.f32[1];
        v19.i64[0] = vextq_s8(v15, v15, 8uLL).u64[0];
        a3.f32[0] = a3.f32[0] + v19.f32[2];
        float32x4_t v21 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v15.i8, *(int8x8_t *)a3.f32) & 0xFF00FF00FF00FFLL)));
        a3.f32[0] = (float)((float)((float)(a3.f32[0] + v19.f32[3]) + v21.f32[0]) + v21.f32[1]) + v21.f32[2];
        float32x4_t v22 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v19.f32, *(int8x8_t *)a3.f32) & 0xFF00FF00FF00FFLL)));
        float32x4_t v23 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v15.i8, *(int8x8_t *)a3.f32) & 0xFF00FF00FF00FFLL)));
        a3.f32[0] = (float)((float)((float)(a3.f32[0] + v21.f32[3]) + v23.f32[0]) + v23.f32[1]) + v23.f32[2];
        float32x4_t v24 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v19.f32, *(int8x8_t *)a3.f32) & 0xFF00FF00FF00FFLL)));
        v22.f32[0] = (float)((float)((float)((float)((float)((float)((float)((float)(a3.f32[0] + v23.f32[3]) + v24.f32[0])
                                                                   + v24.f32[1])
                                                           + v24.f32[2])
                                                   + v24.f32[3])
                                           + v22.f32[0])
                                   + v22.f32[1])
                           + v22.f32[2])
                   + v22.f32[3];
        uint64_t result = v7 + ((v4 << 6) | 0x20);
        int8x16_t v25 = *(int8x16_t *)(result + 16);
        float32x4_t v26 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)result, *(int8x8_t *)v25.i8) & 0xFF00FF00FF00FFLL)));
        v21.i64[0] = vextq_s8(*(int8x16_t *)result, *(int8x16_t *)result, 8uLL).u64[0];
        float32x4_t v27 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)result, *(int8x8_t *)v25.i8) & 0xFF00FF00FF00FFLL)));
        v22.f32[0] = (float)((float)((float)((float)((float)((float)(v22.f32[0] + v26.f32[0]) + v26.f32[1]) + v26.f32[2])
                                           + v26.f32[3])
                                   + v27.f32[0])
                           + v27.f32[1])
                   + v27.f32[2];
        float32x4_t v28 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v21.f32, *(int8x8_t *)v25.i8) & 0xFF00FF00FF00FFLL)));
        v27.f32[0] = (float)((float)((float)(v22.f32[0] + v27.f32[3]) + v28.f32[0]) + v28.f32[1]) + v28.f32[2];
        float32x4_t v29 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v21.f32, *(int8x8_t *)v25.i8) & 0xFF00FF00FF00FFLL)));
        v28.i32[0] = v29.i32[3];
        v27.f32[0] = (float)((float)((float)(v27.f32[0] + v28.f32[3]) + v29.f32[0]) + v29.f32[1]) + v29.f32[2];
        float32x4_t v30 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v25.i8, *(int8x8_t *)v25.i8) & 0xFF00FF00FF00FFLL)));
        v27.f32[0] = (float)((float)((float)(v27.f32[0] + v28.f32[0]) + v30.f32[0]) + v30.f32[1]) + v30.f32[2];
        v28.i64[0] = vextq_s8(v25, v25, 8uLL).u64[0];
        a3 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v25.i8, *(int8x8_t *)v25.i8) & 0xFF00FF00FF00FFLL)));
        v27.f32[0] = (float)((float)((float)(v27.f32[0] + v30.f32[3]) + a3.f32[0]) + a3.f32[1]) + a3.f32[2];
        float32x4_t v31 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v28.f32, *(int8x8_t *)a3.f32) & 0xFF00FF00FF00FFLL)));
        a3.f32[0] = (float)((float)((float)(v27.f32[0] + a3.f32[3]) + v31.f32[0]) + v31.f32[1]) + v31.f32[2];
        float32x4_t v32 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v28.f32, *(int8x8_t *)a3.f32) & 0xFF00FF00FF00FFLL)));
        a3.f32[0] = (float)((float)((float)(a3.f32[0] + v31.f32[3]) + v32.f32[0]) + v32.f32[1]) + v32.f32[2];
        a4 = v32.f32[3];
        *(float *)(v8 + 4 * v4) = a3.f32[0] + v32.f32[3];
      }
      else
      {
        for (uint64_t result = 0; result != 64; ++result)
        {
          LOBYTE(a4) = *(unsigned char *)(v13 + result);
          a4 = (float)LODWORD(a4);
          a3.f32[0] = a3.f32[0] + a4;
          *(_DWORD *)(v8 + 4 * v4) = a3.i32[0];
        }
      }
      ++v4;
      ++v6;
      v13 += 64;
    }
    while (v4 != v5);
  }
  return result;
}

uint64_t sub_24B6F49F4(uint64_t result, uint64_t a2)
{
  unint64_t v2 = 500 * a2;
  unint64_t v3 = *(unsigned int *)(*(void *)(result + 32) + 292);
  if (500 * a2 + 500 < v3) {
    unint64_t v3 = 500 * a2 + 500;
  }
  if (v2 < v3)
  {
    uint64_t v4 = 2000 * a2;
    uint64_t v5 = 8000 * a2;
    uint64_t v6 = 10000 * a2 + 16;
    do
    {
      if (*(unsigned char *)(*(void *)(result + 40) + v2))
      {
        uint64_t v7 = *(void *)(result + 56) + v6;
        *(float *)(**(void **)(result + 48) + v4) = *(float *)(v7 - 16) + *(float *)(**(void **)(result + 48) + v4);
        uint64_t v8 = *(void *)(result + 72);
        *(_DWORD *)(*(void *)(result + 64) + v4) = *(_DWORD *)(v7 - 12);
        *(float *)(v8 + v5) = *(float *)(v7 - 8) + *(float *)(v8 + v5);
        *(float *)(*(void *)(result + 72) + 4 * v4 + 4) = *(float *)(*(void *)(result + 56) + v6 - 4)
                                                          + *(float *)(*(void *)(result + 72) + 4 * v4 + 4);
        *(float *)(*(void *)(result + 72) + 4 * v4 + 8) = *(float *)(*(void *)(result + 56) + v6)
                                                          + *(float *)(*(void *)(result + 72) + 4 * v4 + 8);
        ++*(_DWORD *)(*(void *)(result + 80) + v4);
      }
      ++v2;
      v4 += 4;
      v5 += 16;
      v6 += 20;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t sub_24B6F4AEC(uint64_t result, uint64_t a2)
{
  unint64_t v2 = 500 * a2;
  unint64_t v3 = *(unsigned int *)(*(void *)(result + 32) + 292);
  if (500 * a2 + 500 < v3) {
    unint64_t v3 = 500 * a2 + 500;
  }
  if (v2 < v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)(result + 40);
    uint64_t v6 = (2000 * a2) | 4;
    uint64_t v7 = 256000 * a2;
    uint64_t v8 = (256000 * a2) | 0x10;
    uint64_t v9 = 64000 * a2;
    uint64_t v10 = 256000 * a2;
    do
    {
      uint64_t v11 = *(unsigned int *)(v5 + 4 * v2);
      if (v11)
      {
        uint64_t v12 = *(void *)(result + 56);
        uint64_t v13 = **(void **)(result + 48);
        uint64_t v14 = (float *)(v13 + 4 * v2);
        uint64_t v15 = *(void *)(result + 64);
        uint64_t v16 = *(void *)(result + 72);
        float v17 = *v14;
        if (v16)
        {
          unint64_t v18 = 0;
          int v19 = *(_DWORD *)(v16 + 4 * v2) + 1;
          uint64_t v20 = v15 + v10;
          uint64_t v21 = v12 + v10;
          do
          {
            float v17 = v17
                + (float)(*(float *)(v21 + 4 * v18) * (float)(*(float *)(v20 + 4 * v18) * *(float *)(v20 + 4 * v18)));
            *uint64_t v14 = v17;
            *(_DWORD *)(v16 + 4 * v2) = v19 + v18++;
          }
          while (v18 < *(unsigned int *)(v5 + 4 * v2));
        }
        else
        {
          if (v11 >= 0xC)
          {
            uint64_t v22 = 0;
            uint64_t v23 = v7 + (v4 << 9);
            unint64_t v24 = v13 + v6 + 4 * v4;
            unint64_t v25 = v12 + v23;
            uint64_t v26 = v23 + 4 * v11;
            unint64_t v27 = v12 + v26;
            unint64_t v28 = v15 + v23;
            BOOL v30 = (unint64_t)v14 < v15 + v26 && v28 < v24;
            if ((v25 >= v24 || (unint64_t)v14 >= v27) && !v30)
            {
              uint64_t v22 = v11 & 0xFFFFFFF8;
              float32x4_t v32 = (float32x4_t *)(v12 + v8);
              uint64_t v33 = (float32x4_t *)(v15 + v8);
              uint64_t v34 = v22;
              do
              {
                float32x4_t v35 = vmulq_f32(v32[-1], vmulq_f32(v33[-1], v33[-1]));
                float32x4_t v36 = vmulq_f32(*v32, vmulq_f32(*v33, *v33));
                float v17 = (float)((float)((float)((float)((float)((float)((float)(v17 + v35.f32[0]) + v35.f32[1])
                                                            + v35.f32[2])
                                                    + v35.f32[3])
                                            + v36.f32[0])
                                    + v36.f32[1])
                            + v36.f32[2])
                    + v36.f32[3];
                v32 += 2;
                v33 += 2;
                v34 -= 8;
              }
              while (v34);
              *uint64_t v14 = v17;
              if (v22 == v11) {
                goto LABEL_5;
              }
            }
          }
          else
          {
            uint64_t v22 = 0;
          }
          uint64_t v37 = v11 - v22;
          uint64_t v38 = 4 * (v22 + v9);
          float32x4_t v39 = (float *)(v15 + v38);
          unint64_t v40 = (float *)(v12 + v38);
          do
          {
            float v41 = *v40++;
            float v42 = v41;
            float v43 = *v39++;
            float v17 = v17 + (float)(v42 * (float)(v43 * v43));
            *uint64_t v14 = v17;
            --v37;
          }
          while (v37);
        }
      }
LABEL_5:
      ++v2;
      ++v4;
      v10 += 512;
      v8 += 512;
      v9 += 128;
    }
    while (v2 != v3);
  }
  return result;
}

uint64_t sub_24B6F4CD8(uint64_t a1, uint64_t *a2)
{
  if (*(_DWORD *)(a1 + 192) == 4)
  {
    unint64_t v3 = *(void **)(a1 + 128);
    if (v3)
    {
      if (*v3 && v3[1] && v3[2])
      {
        unint64_t v5 = *(unsigned int *)(a1 + 292);
        LODWORD(v146[0]) = 0;
        sub_24B6F3514((uint64_t)(v3 + 6), v5, (const float *)v146);
        uint64_t v8 = *(void **)(a1 + 128);
        unint64_t v9 = *(unsigned int *)(a1 + 292);
        uint64_t v10 = (char *)v8[9];
        LODWORD(v146[0]) = 0;
        uint64_t v11 = v8[11];
        if (v9 > (v11 - (uint64_t)v10) >> 2)
        {
          if (v10)
          {
            v8[10] = v10;
            operator delete(v10);
            uint64_t v11 = 0;
            v8[9] = 0;
            v8[10] = 0;
            v8[11] = 0;
          }
          uint64_t v12 = v11 >> 1;
          if (v11 >> 1 <= v9) {
            uint64_t v12 = v9;
          }
          BOOL v13 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL;
          unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v13) {
            unint64_t v14 = v12;
          }
          if (v14 >> 62) {
            abort();
          }
          uint64_t v15 = 4 * v14;
          uint64_t v16 = (int32x4_t *)operator new(4 * v14);
          v8[9] = v16;
          v8[11] = (char *)v16 + v15;
          float v17 = (int32x4_t *)((char *)v16 + 4 * v9);
          __int32 v18 = v146[0];
          unint64_t v19 = (v9 - 1) & 0x3FFFFFFFFFFFFFFFLL;
          if (v19 >= 7)
          {
            unint64_t v20 = v19 + 1;
            int32x4_t v21 = vdupq_n_s32(v146[0]);
            uint64_t v22 = v16 + 1;
            uint64_t v23 = v20 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              v22[-1] = v21;
              int32x4_t *v22 = v21;
              v22 += 2;
              v23 -= 8;
            }
            while (v23);
            if (v20 == (v20 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_46;
            }
            uint64_t v16 = (int32x4_t *)((char *)v16 + 4 * (v20 & 0x7FFFFFFFFFFFFFF8));
          }
          do
          {
            v16->i32[0] = v18;
            uint64_t v16 = (int32x4_t *)((char *)v16 + 4);
          }
          while (v16 != v17);
LABEL_46:
          v8[10] = v17;
LABEL_47:
          if (*a2 != a2[1])
          {
            uint64_t v37 = objc_msgSend_contents(*(void **)(a1 + 136), v6, v7);
            size_t v40 = objc_msgSend_length(*(void **)(a1 + 136), v38, v39);
            bzero(v37, v40);
            float v43 = objc_msgSend_contents(*(void **)(a1 + 464), v41, v42);
            size_t v46 = objc_msgSend_length(*(void **)(a1 + 464), v44, v45);
            bzero(v43, v46);
            uint64_t v49 = objc_msgSend_contents(*(void **)(a1 + 472), v47, v48);
            size_t v52 = objc_msgSend_length(*(void **)(a1 + 472), v50, v51);
            bzero(v49, v52);
            uint64_t v55 = objc_msgSend_contents(*(void **)(a1 + 480), v53, v54);
            size_t v58 = objc_msgSend_length(*(void **)(a1 + 480), v56, v57);
            bzero(v55, v58);
            uint64_t v59 = *a2;
            uint64_t v60 = a2[1];
            if (*a2 != v60)
            {
              uint64_t v61 = (float32x4_t *)MEMORY[0x263EF89A0];
              float32x4_t v140 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
              float32x2_t v62 = (float32x2_t)vdup_n_s32(0x38D1B717u);
              do
              {
                kdebug_trace();
                uint64_t v65 = objc_msgSend_contents(*(void **)(a1 + 456), v63, v64);
                size_t v68 = objc_msgSend_length(*(void **)(a1 + 456), v66, v67);
                bzero(v65, v68);
                long long v145 = *(_OWORD *)(v59 + 112);
                float32x4_t v142 = *(float32x4_t *)(v59 + 128);
                float32x4_t v143 = *(float32x4_t *)(v59 + 144);
                float32x4_t v144 = *(float32x4_t *)(v59 + 160);
                float32x4_t v141 = *(float32x4_t *)(v59 + 176);
                float v69 = atan2f((float)*(unsigned int *)(v59 + 4), *(float *)(v59 + 36) + *(float *)(v59 + 36));
                float32x4_t v70 = v61[1];
                float32x4_t v71 = v61[2];
                uint32x4_t v72 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v140, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v142, *(float32x2_t *)v142.f32, 1), v143, *(float32x2_t *)v143.f32, 1), v144, *(float32x2_t *)v144.f32, 1), v70)), (int8x16_t)vcgeq_f32(v140, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v142, v142.f32[0]), v143, v143.f32[0]),
                                                       v144,
                                                       v144.f32[0]),
                                                     *v61))),
                                    (int8x16_t)vcgeq_f32(v140, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v142, v142, 2), v143, v143, 2), v144, v144, 2), v71)));
                v72.i32[3] = v72.i32[2];
                if ((vminvq_u32(v72) & 0x80000000) == 0) {
                  return 0;
                }
                float32x4_t v73 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v143, 2);
                float32x4_t v74 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v142, (int32x4_t)v144), (int32x4_t)v73);
                float32x4_t v75 = (float32x4_t)vtrn2q_s32((int32x4_t)v142, (int32x4_t)v143);
                v75.i32[2] = v144.i32[1];
                float32x4_t v76 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v142, (int32x4_t)v144), (int32x4_t)v143);
                uint32x4_t v77 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v140, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v76, v143.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v143.f32, 1), v75), v73, v74), v70)), (int8x16_t)vcgeq_f32(v140, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v76, v142.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v142.f32, 1),
                                                         v75),
                                                       (float32x4_t)vdupq_laneq_s32((int32x4_t)v142, 2),
                                                       v74),
                                                     *v61))),
                                    (int8x16_t)vcgeq_f32(v140, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v76, v144.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v144.f32, 1), v75), (float32x4_t)vdupq_laneq_s32((int32x4_t)v144, 2), v74), v71)));
                v77.i32[3] = v77.i32[2];
                if ((vminvq_u32(v77) & 0x80000000) == 0) {
                  return 0;
                }
                float32x4_t v78 = vmulq_f32(v142, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v144, (int8x16_t)v144, 0xCuLL), (int8x16_t)v144, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v143, (int32x4_t)v143), (int8x16_t)v143, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v144, (int32x4_t)v144), (int8x16_t)v144, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v143, (int8x16_t)v143, 0xCuLL), (int8x16_t)v143, 8uLL)));
                if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v78, 2), vaddq_f32(v78, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v78.f32, 1))).f32[0]+ -1.0) > 0.000011)return 0; {
                float v79 = v69 + v69;
                }
                if (v79 >= 3.1416) {
                  return 0;
                }
                if (v79 <= 0.0) {
                  return 0;
                }
                uint32x2_t v80 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v62, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v144, (int8x16_t)v144, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v141, (int8x16_t)v141, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v62, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v142,
                                                                                                 (int8x16_t)v142,
                                                                                                 8uLL),
                                                                        (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v143, (int8x16_t)v143, 8uLL)))));
                if ((vpmin_u32(v80, v80).u32[0] & 0x80000000) == 0) {
                  return 0;
                }
                float v81 = (float)*(unint64_t *)(a1 + 208) / (float)*(unint64_t *)(a1 + 216);
                if (v81 < 0.001) {
                  return 0;
                }
                if (v79 < 0.0) {
                  return 0;
                }
                if (fabsf(v79) <= 0.000001) {
                  return 0;
                }
                float v82 = *(float *)(a1 + 200);
                float v83 = *(float *)(a1 + 204);
                if (v83 <= v82 || v83 < 0.001 || v82 < 0.001 || fabsf(v79 + -3.1416) <= 0.000032416) {
                  return 0;
                }
                float v84 = 1.0 / tanf(v79 * 0.5);
                *(float *)&unsigned int v85 = v84 / v81;
                LODWORD(v86) = 0;
                *((float *)&v86 + 1) = v84;
                v87.i64[0] = 0;
                v87.f32[2] = (float)-v83 / (float)(v83 - v82);
                v87.i32[3] = -1.0;
                v88.i64[0] = 0;
                v88.i32[3] = 0;
                v88.f32[2] = v87.f32[2] * v82;
                float32x4_t v89 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v142, COERCE_FLOAT(*(_OWORD *)(a1 + 224))), v143, *(float32x2_t *)(a1 + 224), 1), v144, *(float32x4_t *)(a1 + 224), 2), v141, *(float32x4_t *)(a1 + 224), 3);
                float32x4_t v90 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v142, COERCE_FLOAT(*(_OWORD *)(a1 + 240))), v143, *(float32x2_t *)(a1 + 240), 1), v144, *(float32x4_t *)(a1 + 240), 2), v141, *(float32x4_t *)(a1 + 240), 3);
                float32x4_t v91 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v142, COERCE_FLOAT(*(_OWORD *)(a1 + 256))), v143, *(float32x2_t *)(a1 + 256), 1), v144, *(float32x4_t *)(a1 + 256), 2), v141, *(float32x4_t *)(a1 + 256), 3);
                float32x4_t v92 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v142, COERCE_FLOAT(*(_OWORD *)(a1 + 272))), v143, *(float32x2_t *)(a1 + 272), 1), v144, *(float32x4_t *)(a1 + 272), 2), v141, *(float32x4_t *)(a1 + 272), 3);
                v146[0] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v85, v89.f32[0]), (float32x4_t)v86, *(float32x2_t *)v89.f32, 1), v87, v89, 2), v88, v89, 3);
                v146[1] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v85, v90.f32[0]), (float32x4_t)v86, *(float32x2_t *)v90.f32, 1), v87, v90, 2), v88, v90, 3);
                v146[2] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v85, v91.f32[0]), (float32x4_t)v86, *(float32x2_t *)v91.f32, 1), v87, v91, 2), v88, v91, 3);
                v146[3] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v85, v92.f32[0]), (float32x4_t)v86, *(float32x2_t *)v92.f32, 1), v87, v92, 2), v88, v92, 3);
                objc_msgSend_commandBuffer(*(void **)(*(void *)a1 + 8), v93, v94);
                id v95 = (id)objc_claimAutoreleasedReturnValue();
                uint64_t v98 = *(unsigned int *)objc_msgSend_contents(*(void **)(*(void *)(a1 + 128) + 16), v96, v97);
                float32x4_t v100 = objc_msgSend_renderCommandEncoderWithDescriptor_(v95, v99, *(void *)(a1 + 176));
                objc_msgSend_setLabel_(v100, v101, @"VisibleMeshVertexIndexRenderEncoder");
                objc_msgSend_setRenderPipelineState_(v100, v102, *(void *)(a1 + 40));
                objc_msgSend_setDepthStencilState_(v100, v103, *(void *)(a1 + 48));
                objc_msgSend_setVertexBuffer_offset_atIndex_(v100, v104, *(void *)(*(void *)(a1 + 128) + 24), 0, 0);
                objc_msgSend_setVertexBuffer_offset_atIndex_(v100, v105, *(void *)(*(void *)(a1 + 128) + 8), 0, 1);
                objc_msgSend_setVertexBytes_length_atIndex_(v100, v106, (uint64_t)v146, 64, 2);
                objc_msgSend_setVertexBytes_length_atIndex_(v100, v107, a1 + 224, 64, 3);
                objc_msgSend_drawPrimitives_vertexStart_vertexCount_(v100, v108, 3, 0, v98);
                uint64_t v147 = 0;
                uint64_t v148 = 0;
                float64x2_t v149 = vcvtq_f64_u64(*(uint64x2_t *)(a1 + 208));
                long long v150 = xmmword_24B72A670;
                objc_msgSend_setViewport_(v100, v109, (uint64_t)&v147);
                objc_msgSend_endEncoding(v100, v110, v111);

                id v112 = v95;
                uint64_t v115 = v112;
                if (*(_DWORD *)(a1 + 192) == 4)
                {
                  uint64_t v116 = objc_msgSend_computeCommandEncoder(v112, v113, v114);
                  objc_msgSend_setLabel_(v116, v117, @"FetchVisiblemeshVertexEncoder");
                  objc_msgSend_setComputePipelineState_(v116, v118, *(void *)(a1 + 16));
                  objc_msgSend_setTexture_atIndex_(v116, v119, *(void *)(a1 + 144), 0);
                  objc_msgSend_setBytes_length_atIndex_(v116, v120, a1 + 292, 4, 0);
                  objc_msgSend_setBuffer_offset_atIndex_(v116, v121, *(void *)(*(void *)(a1 + 128) + 16), 0, 1);
                  objc_msgSend_setBuffer_offset_atIndex_(v116, v122, *(void *)(*(void *)(a1 + 128) + 24), 0, 2);
                  objc_msgSend_setBuffer_offset_atIndex_(v116, v123, *(void *)(a1 + 456), 0, 3);
                  uint64_t v124 = *(void *)(a1 + 208);
                  uint64_t v125 = *(void *)(a1 + 216);
                  unint64_t v128 = objc_msgSend_threadExecutionWidth(*(void **)(a1 + 8), v126, v127);
                  unint64_t v131 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 8), v129, v130);
                  uint64_t v147 = v124;
                  uint64_t v148 = v125;
                  *(void *)&v149.f64[0] = 1;
                  v151[0] = v128;
                  v151[1] = v131 / v128;
                  v151[2] = 1;
                  objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v116, v132, (uint64_t)&v147, v151);
                  objc_msgSend_endEncoding(v116, v133, v134);
                }
                if (*(_DWORD *)(a1 + 192) == 4) {
                  sub_24B6F4024(a1, v115, (uint64_t)&v145);
                }
                objc_msgSend_commit(v115, v135, v136);
                objc_msgSend_waitUntilCompleted(v115, v137, v138);

                kdebug_trace();
                v59 += 192;
              }
              while (v59 != v60);
            }
            sub_24B6F41DC(a1, (const char *)(*(void *)(a1 + 128) + 48), *(void *)(*(void *)(a1 + 128) + 72));
          }
          return 1;
        }
        unint64_t v24 = (float32x4_t *)v8[10];
        unint64_t v25 = ((char *)v24 - v10) >> 2;
        if (v25 >= v9) {
          unint64_t v26 = v9;
        }
        else {
          unint64_t v26 = ((char *)v24 - v10) >> 2;
        }
        if (v26)
        {
          if (v26 < 8)
          {
            unint64_t v27 = v10;
            goto LABEL_34;
          }
          if (v10 < (char *)v146 + 4 && &v10[4 * v26] > (char *)v146)
          {
            unint64_t v27 = v10;
            goto LABEL_34;
          }
          unint64_t v27 = &v10[4 * (v26 & 0xFFFFFFF8)];
          unint64_t v28 = v10;
          uint64_t v29 = v26 & 0xFFFFFFF8;
          do
          {
            *(_OWORD *)unint64_t v28 = 0uLL;
            *((_OWORD *)v28 + 1) = 0uLL;
            v28 += 32;
            v29 -= 8;
          }
          while (v29);
          if (v26 != (v26 & 0xFFFFFFF8))
          {
            v26 &= 7u;
            do
            {
LABEL_34:
              *(_DWORD *)unint64_t v27 = v146[0];
              v27 += 4;
              --v26;
            }
            while (v26);
          }
        }
        BOOL v13 = v9 >= v25;
        unint64_t v30 = v9 - v25;
        if (v30 == 0 || !v13)
        {
          float v17 = (int32x4_t *)&v10[4 * v9];
          goto LABEL_46;
        }
        float32x4_t v31 = (float32x4_t *)((char *)v24 + 4 * v30);
        unint64_t v32 = 4 * v9 - (((char *)v24 - v10) & 0xFFFFFFFFFFFFFFFCLL) - 4;
        if (v32 >= 0x4C
          && (v24 >= (float32x4_t *)((char *)v146 + 4)
           || (char *)v24 + 4 * v9 - (((char *)v24 - v10) & 0xFFFFFFFFFFFFFFFCLL) <= (char *)v146))
        {
          uint64_t v33 = (v32 >> 2) + 1;
          float32x4_t v34 = vld1q_dup_f32((const float *)v146);
          float32x4_t v35 = v24 + 1;
          uint64_t v36 = v33 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v35[-1] = v34;
            float32x4_t *v35 = v34;
            v35 += 2;
            v36 -= 8;
          }
          while (v36);
          if (v33 == (v33 & 0x7FFFFFFFFFFFFFF8)) {
            goto LABEL_45;
          }
          unint64_t v24 = (float32x4_t *)((char *)v24 + 4 * (v33 & 0x7FFFFFFFFFFFFFF8));
        }
        do
        {
          v24->i32[0] = v146[0];
          unint64_t v24 = (float32x4_t *)((char *)v24 + 4);
        }
        while (v24 != v31);
LABEL_45:
        v8[10] = v31;
        goto LABEL_47;
      }
    }
  }
  return 0;
}

void sub_24B6F5670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B6F56B0(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[5];
  uint64_t v5 = a1[6];
  uint64_t v6 = objc_msgSend_contents(*(void **)(v3 + 136), a2, a3);
  size_t v7 = vcvtps_u32_f32((float)*(unsigned int *)(v3 + 292) / 500.0);
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 3221225472;
  v8[2] = sub_24B6F5760;
  void v8[3] = &unk_2652DF090;
  v8[4] = v3;
  v8[5] = v5;
  v8[6] = v4;
  v8[7] = v6;
  dispatch_apply(v7, 0, v8);
}

unint64_t sub_24B6F5760(unint64_t result, uint64_t a2, double a3, float a4, double a5, double a6, double a7, int8x16_t a8)
{
  unint64_t v8 = 500 * a2;
  unint64_t v9 = 500 * a2 + 500;
  if (v9 >= *(unsigned int *)(*(void *)(result + 32) + 292)) {
    unint64_t v9 = *(unsigned int *)(*(void *)(result + 32) + 292);
  }
  unint64_t v10 = v9 - v8;
  if (v9 > v8)
  {
    unint64_t v11 = *(void *)(result + 40);
    if (v11)
    {
      uint64_t v12 = *(void *)(result + 56);
      uint64_t v13 = **(void **)(result + 48);
      if (v11 < 8)
      {
        unint64_t v14 = (float *)(v13 + 2000 * a2);
        uint64_t v15 = (unsigned char *)(v12 + 64000 * a2 + 3);
        do
        {
          LOBYTE(a4) = *(v15 - 3);
          a4 = (float)LODWORD(a4);
          float v16 = *v14 + a4;
          *unint64_t v14 = v16;
          if (v11 != 1)
          {
            LOBYTE(a4) = *(v15 - 2);
            a4 = (float)LODWORD(a4);
            float v17 = v16 + a4;
            *unint64_t v14 = v17;
            if (v11 != 2)
            {
              LOBYTE(a4) = *(v15 - 1);
              a4 = (float)LODWORD(a4);
              float v18 = v17 + a4;
              *unint64_t v14 = v18;
              if (v11 != 3)
              {
                LOBYTE(a4) = *v15;
                a4 = (float)LODWORD(a4);
                float v19 = v18 + a4;
                *unint64_t v14 = v19;
                if (v11 != 4)
                {
                  LOBYTE(a4) = v15[1];
                  a4 = (float)LODWORD(a4);
                  float v20 = v19 + a4;
                  *unint64_t v14 = v20;
                  if (v11 != 5)
                  {
                    LOBYTE(a4) = v15[2];
                    a4 = (float)LODWORD(a4);
                    float v21 = v20 + a4;
                    *unint64_t v14 = v21;
                    if (v11 != 6)
                    {
                      LOBYTE(a4) = v15[3];
                      a4 = (float)LODWORD(a4);
                      *unint64_t v14 = v21 + a4;
                    }
                  }
                }
              }
            }
          }
          ++v14;
          v15 += 128;
          --v10;
        }
        while (v10);
        return result;
      }
      uint64_t v22 = 0;
      uint64_t v23 = 2000 * a2;
      uint64_t v24 = (2000 * a2) | 4;
      uint64_t v25 = 64000 * a2;
      unint64_t v26 = v11 + 64000 * a2;
      uint64_t result = v11 & 0xFFFFFFFFFFFFFFE0;
      unint64_t v27 = (int8x16_t *)(v12 + 64000 * a2);
      unint64_t v28 = v27 + 1;
      do
      {
        float v29 = *(float *)(v13 + 4 * v8);
        if (v13 + v23 + 4 * v22 >= v12 + v26 + (v22 << 7)
          || v12 + v25 + (v22 << 7) >= (unint64_t)(v13 + v24 + 4 * v22))
        {
          if (v11 < 0x20)
          {
            uint64_t v31 = 0;
LABEL_26:
            uint64_t v49 = v31 - (v11 & 0xFFFFFFFFFFFFFFF8);
            uint64_t v50 = (unint64_t *)((char *)v27->u64 + v31);
            do
            {
              unint64_t v51 = *v50++;
              a8.i64[0] = v51;
              uint32x4_t v52 = (uint32x4_t)vqtbl1q_s8(a8, (int8x16_t)xmmword_24B72A720);
              a8 = (int8x16_t)vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(a8, (int8x16_t)xmmword_24B72A730));
              float32x4_t v53 = vcvtq_f32_u32(v52);
              float v29 = (float)((float)((float)((float)((float)((float)((float)(v29 + v53.f32[0]) + v53.f32[1]) + v53.f32[2])
                                                  + v53.f32[3])
                                          + *(float *)a8.i32)
                                  + *(float *)&a8.i32[1])
                          + *(float *)&a8.i32[2])
                  + *(float *)&a8.i32[3];
              v49 += 8;
            }
            while (v49);
            *(float *)(v13 + 4 * v8) = v29;
            unint64_t v30 = v11 & 0xFFFFFFFFFFFFFFF8;
            if (v11 == (v11 & 0xFFFFFFFFFFFFFFF8)) {
              goto LABEL_16;
            }
            goto LABEL_29;
          }
          unint64_t v32 = v28;
          unint64_t v33 = v11 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            int8x16_t v34 = v32[-1];
            float32x4_t v35 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v34, (int8x16_t)xmmword_24B72A720));
            float32x4_t v36 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v34, (int8x16_t)xmmword_24B72A730));
            float v37 = (float)((float)((float)((float)((float)((float)(v29 + v35.f32[0]) + v35.f32[1]) + v35.f32[2])
                                        + v35.f32[3])
                                + v36.f32[0])
                        + v36.f32[1])
                + v36.f32[2];
            float32x4_t v38 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v34, (int8x16_t)xmmword_24B72A740));
            float v39 = (float)((float)((float)(v37 + v36.f32[3]) + v38.f32[0]) + v38.f32[1]) + v38.f32[2];
            int8x16_t v40 = *v32;
            v32 += 2;
            float32x4_t v41 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v34, (int8x16_t)xmmword_24B72A750));
            v38.i32[0] = v41.i32[3];
            float v42 = (float)((float)((float)(v39 + v38.f32[3]) + v41.f32[0]) + v41.f32[1]) + v41.f32[2];
            float32x4_t v43 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v40, (int8x16_t)xmmword_24B72A720));
            float v44 = (float)((float)((float)(v42 + v38.f32[0]) + v43.f32[0]) + v43.f32[1]) + v43.f32[2];
            float32x4_t v45 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v40, (int8x16_t)xmmword_24B72A730));
            float v46 = (float)((float)((float)(v44 + v43.f32[3]) + v45.f32[0]) + v45.f32[1]) + v45.f32[2];
            a8 = (int8x16_t)vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v40, (int8x16_t)xmmword_24B72A740));
            float v47 = (float)((float)((float)(v46 + v45.f32[3]) + *(float *)a8.i32) + *(float *)&a8.i32[1])
                + *(float *)&a8.i32[2];
            float32x4_t v48 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v40, (int8x16_t)xmmword_24B72A750));
            a8.i32[0] = v48.i32[3];
            float v29 = (float)((float)((float)((float)(v47 + *(float *)&a8.i32[3]) + v48.f32[0]) + v48.f32[1]) + v48.f32[2])
                + v48.f32[3];
            v33 -= 32;
          }
          while (v33);
          *(float *)(v13 + 4 * v8) = v29;
          if (v11 == result) {
            goto LABEL_16;
          }
          uint64_t v31 = v11 & 0xFFFFFFFFFFFFFFE0;
          unint64_t v30 = v11 & 0xFFFFFFFFFFFFFFE0;
          if ((v11 & 0x18) != 0) {
            goto LABEL_26;
          }
        }
        else
        {
          unint64_t v30 = 0;
        }
        do
        {
LABEL_29:
          a8.i8[0] = v27->i8[v30];
          *(float *)a8.i32 = (float)a8.u32[0];
          float v29 = v29 + *(float *)a8.i32;
          *(float *)(v13 + 4 * v8) = v29;
          ++v30;
        }
        while (v11 != v30);
LABEL_16:
        ++v8;
        ++v22;
        v28 += 8;
        v27 += 8;
      }
      while (v8 != v9);
    }
  }
  return result;
}

uint64_t sub_24B6F5B1C()
{
  return 0;
}

void sub_24B6F5B24()
{
}

uint64_t sub_24B6F5B3C()
{
  return 1;
}

void sub_24B6F5B44()
{
}

uint64_t sub_24B6F5B5C(uint64_t a1, void *a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = 0;
  if (!a2) {
    goto LABEL_23;
  }
  uint64_t v6 = 0;
  if (!*(unsigned char *)(a1 + 24)) {
    return v6 | v4;
  }
  if (!a2[1] || (unint64_t v7 = a2[3]) == 0)
  {
    uint64_t v4 = 0;
    uint64_t v6 = 0;
    return v6 | v4;
  }
  uint64_t v4 = 0;
  if (v7 <= a3)
  {
LABEL_23:
    uint64_t v6 = 0;
    return v6 | v4;
  }
  uint64_t v6 = 0;
  unint64_t v28 = a2[4];
  if (v28 > a4)
  {
    unint64_t v8 = *(void *)(a1 + 8);
    unint64_t v9 = v8 >> 1;
    int v10 = a4 - (v8 >> 1);
    float v11 = 0.0;
    int v29 = (v8 >> 1) + a4;
    if (v10 >= v29 || (int)v8 < 1)
    {
      float v14 = 0.0;
    }
    else
    {
      uint64_t v27 = a2[1];
      int v12 = a3 - v9;
      int v13 = v9 + a3;
      float v14 = 0.0;
      if ((int)a3 - (int)v9 < (int)v9 + (int)a3)
      {
        uint64_t v15 = 0;
        uint64_t v26 = a2[5];
        uint64_t v30 = v27 + v26 * a4;
        uint64_t v16 = (int)v8;
        do
        {
          if ((v10 & 0x80000000) == 0 && v10 < (int)v28)
          {
            uint64_t v17 = 0;
            uint64_t v18 = 1;
            do
            {
              int v19 = v12 + v18 - 1;
              if ((v19 & 0x80000000) == 0 && v19 < (int)v7)
              {
                float v20 = *(float *)(v27 + v26 * v10 + 4 * v19);
                float v21 = *(float *)(*(void *)(*(void *)(a1 + 32) + v17) + 4 * v15);
                float v22 = *(float *)(a1 + 20) * *(float *)(a1 + 20);
                float v23 = v21
                    * (float)((float)(expf((float)((float)((float)(*(float *)(v30 + 4 * a3) - v20)* (float)(*(float *)(v30 + 4 * a3) - v20))* -0.5)/ v22)* 0.15915)/ v22);
                float v11 = v11 + (float)(v23 * v20);
                float v14 = v14 + v23;
              }
              if (v12 + (int)v18 >= v13) {
                break;
              }
              v17 += 24;
            }
            while (v18++ < v16);
          }
          if (++v10 >= v29) {
            break;
          }
          ++v15;
        }
        while (v15 < v16);
      }
    }
    uint64_t v6 = COERCE_UNSIGNED_INT(v11 / v14);
    uint64_t v4 = 0x100000000;
  }
  return v6 | v4;
}

uint64_t sub_24B6F5D60(uint64_t a1, unint64_t a2)
{
  uint64_t result = 0;
  if (a2 >= 2 && (a2 & 1) != 0)
  {
    if (*(unsigned char *)(a1 + 24))
    {
      *(void *)(a1 + 8) = a2;
      sub_24B6F5DAC((void *)a1);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_24B6F5DAC(void *a1)
{
  uint64_t v3 = (void *)a1[4];
  unint64_t v2 = (void *)a1[5];
  if (v2 != v3)
  {
    uint64_t v4 = (void *)a1[5];
    do
    {
      uint64_t v6 = (void *)*(v4 - 3);
      v4 -= 3;
      uint64_t v5 = v6;
      if (v6)
      {
        *(v2 - 2) = v5;
        operator delete(v5);
      }
      unint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[5] = v3;
  unint64_t v7 = a1[1];
  if (v7)
  {
    if (v7 >> 62) {
      goto LABEL_75;
    }
    unint64_t v8 = (char *)operator new(4 * v7);
    bzero(v8, 4 * v7);
    unint64_t v9 = &v8[4 * v7];
  }
  else
  {
    unint64_t v8 = 0;
    unint64_t v9 = 0;
  }
  uint64_t v10 = a1[4];
  unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - v10) >> 3);
  unint64_t v12 = v7 - v11;
  if (v7 <= v11)
  {
    if (v7 < v11)
    {
      uint64_t v26 = (void *)(v10 + 24 * v7);
      if (v3 != v26)
      {
        uint64_t v27 = v3;
        do
        {
          int v29 = (void *)*(v27 - 3);
          v27 -= 3;
          unint64_t v28 = v29;
          if (v29)
          {
            *(v3 - 2) = v28;
            operator delete(v28);
          }
          uint64_t v3 = v27;
        }
        while (v27 != v26);
      }
      a1[5] = v26;
    }
    goto LABEL_47;
  }
  uint64_t v13 = a1[6];
  if (0xAAAAAAAAAAAAAAABLL * ((v13 - (uint64_t)v3) >> 3) < v12)
  {
    if (v7 <= 0xAAAAAAAAAAAAAAALL)
    {
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v13 - v10) >> 3);
      uint64_t v15 = 2 * v14;
      if (2 * v14 <= v7) {
        uint64_t v15 = v7;
      }
      if (v14 >= 0x555555555555555) {
        unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v16 = v15;
      }
      if (v16 > 0xAAAAAAAAAAAAAAALL) {
        sub_24B6BCD7C();
      }
      uint64_t v17 = 24 * v16;
      uint64_t v18 = (char *)operator new(24 * v16);
      int v19 = &v18[24 * v11];
      unint64_t v86 = &v18[v17];
      uint64_t v20 = 24 * v7;
      float v21 = &v18[24 * v7];
      unint64_t v22 = v20 - 24 * v11;
      float v23 = (char **)(v19 + 8);
      do
      {
        *(v23 - 1) = 0;
        *float v23 = 0;
        v23[1] = 0;
        if (v9 != v8)
        {
          if (v9 - v8 < 0) {
            goto LABEL_75;
          }
          uint64_t v24 = (char *)operator new(v9 - v8);
          *(v23 - 1) = v24;
          *float v23 = v24;
          uint64_t v25 = &v24[4 * ((v9 - v8) >> 2)];
          v23[1] = v25;
          memcpy(v24, v8, v9 - v8);
          *float v23 = v25;
        }
        v23 += 3;
        v22 -= 24;
      }
      while (v22);
      int8x16_t v34 = (void *)a1[4];
      float32x4_t v35 = (void *)a1[5];
      if (v35 == v34)
      {
        a1[4] = v19;
        a1[5] = v21;
        a1[6] = v86;
      }
      else
      {
        do
        {
          *((void *)v19 - 3) = 0;
          *((void *)v19 - 2) = 0;
          v19 -= 24;
          *((void *)v19 + 2) = 0;
          long long v36 = *(_OWORD *)(v35 - 3);
          v35 -= 3;
          *(_OWORD *)int v19 = v36;
          *((void *)v19 + 2) = v35[2];
          void *v35 = 0;
          v35[1] = 0;
          v35[2] = 0;
        }
        while (v35 != v34);
        float32x4_t v35 = (void *)a1[4];
        float v37 = (void *)a1[5];
        a1[4] = v19;
        a1[5] = v21;
        a1[6] = v86;
        if (v37 != v35)
        {
          float32x4_t v38 = v37;
          do
          {
            int8x16_t v40 = (void *)*(v38 - 3);
            v38 -= 3;
            float v39 = v40;
            if (v40)
            {
              *(v37 - 2) = v39;
              operator delete(v39);
            }
            float v37 = v38;
          }
          while (v38 != v35);
        }
      }
      if (v35) {
        operator delete(v35);
      }
      goto LABEL_47;
    }
LABEL_75:
    abort();
  }
  uint64_t v30 = &v3[3 * v12];
  uint64_t v31 = 24 * v7 - 8 * (((uint64_t)v3 - v10) >> 3);
  do
  {
    void *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
    if (v9 != v8)
    {
      if (v9 - v8 < 0) {
        goto LABEL_75;
      }
      unint64_t v32 = (char *)operator new(v9 - v8);
      void *v3 = v32;
      unint64_t v33 = &v32[4 * ((v9 - v8) >> 2)];
      v3[2] = v33;
      memcpy(v32, v8, v9 - v8);
      v3[1] = v33;
    }
    v3 += 3;
    v31 -= 24;
  }
  while (v31);
  a1[5] = v30;
LABEL_47:
  if (v8) {
    operator delete(v8);
  }
  unint64_t v41 = a1[1];
  unint64_t v42 = v41 >> 1;
  if (((v41 >> 1) & 0x80000000) == 0 && (int)v41 >= 1)
  {
    unsigned int v43 = -(int)v42;
    float v44 = (float *)(a1 + 2);
    uint64_t v77 = a1[4];
    uint64_t v45 = (int)v41;
    unint64_t v46 = (int)v41 - 1;
    unint64_t v47 = a1[1] & 0xFFFFFFFELL;
    if (v46 < v47) {
      unint64_t v47 = v46;
    }
    if (v47 < 3)
    {
      for (uint64_t i = 0; i < v45; ++i)
      {
        uint64_t v49 = 0;
        int v78 = v43;
        int v50 = v43 * v43;
        uint64_t v51 = *(void *)(v77 + 24 * i);
        do
        {
          float v52 = *v44 * *v44;
          *(float *)(v51 + 4 * v49) = (float)(expf((float)((float)(v50+ (v49 - v42) * (v49 - v42))* -0.5)/ v52)* 0.15915)/ v52;
          if ((int)v49 - (int)v42 >= (int)v42) {
            break;
          }
          ++v49;
        }
        while (v49 < v45);
        if (v78 >= (int)v42) {
          break;
        }
        unsigned int v43 = v78 + 1;
      }
      return;
    }
    uint64_t v53 = 0;
    float32x4_t v75 = (char *)a1 + 20;
    uint64_t v76 = 4 * v47 + 4;
    unint64_t v73 = v47 + 1;
    uint64_t v74 = (v47 + 1) & 0x1FFFFFFFCLL;
    int32x4_t v72 = vaddq_s32(vdupq_n_s32(v43), (int32x4_t)xmmword_24B72A700);
    int v54 = -(int)v42;
    float32x4_t v79 = (float32x4_t)vdupq_n_s32(0x3E22F983u);
    while (1)
    {
      unsigned int v55 = v54 * v54;
      unint64_t v56 = *(void *)(v77 + 24 * v53);
      if (v56 < (unint64_t)v75 && (unint64_t)v44 < v56 + v76) {
        break;
      }
      int32x4_t v58 = vdupq_n_s32(v55);
      int32x4_t v80 = v58;
      *(float *)v58.i32 = *v44 * *v44;
      float32x4_t v82 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.i8, 0);
      uint64_t v59 = *(float32x4_t **)(v77 + 24 * v53);
      uint64_t v60 = v74;
      int32x4_t v61 = v72;
      do
      {
        int32x4_t v81 = v61;
        v62.i64[0] = 0xBF000000BF000000;
        v62.i64[1] = 0xBF000000BF000000;
        float32x4_t v87 = vdivq_f32(vmulq_f32(vcvtq_f32_s32(vmlaq_s32(v80, v61, v61)), v62), v82);
        float v83 = expf(v87.f32[1]);
        v63.f32[0] = expf(v87.f32[0]);
        v63.f32[1] = v83;
        float32x4_t v84 = v63;
        float v64 = expf(v87.f32[2]);
        float32x4_t v65 = v84;
        v65.f32[2] = v64;
        float32x4_t v85 = v65;
        float v66 = expf(v87.f32[3]);
        float32x4_t v67 = v85;
        v67.f32[3] = v66;
        *v59++ = vdivq_f32(vmulq_f32(v67, v79), v82);
        v68.i64[0] = 0x400000004;
        v68.i64[1] = 0x400000004;
        int32x4_t v61 = vaddq_s32(v81, v68);
        v60 -= 4;
      }
      while (v60);
      uint64_t v69 = v74;
      int v70 = v74 - v42;
      if (v73 != v74) {
        goto LABEL_70;
      }
LABEL_72:
      unsigned int v43 = -(int)v42;
      if (v54 < (int)v42)
      {
        ++v54;
        if (++v53 < v45) {
          continue;
        }
      }
      return;
    }
    uint64_t v69 = 0;
    int v70 = v43;
    do
    {
LABEL_70:
      float v71 = *v44 * *v44;
      *(float *)(v56 + 4 * v69) = (float)(expf((float)((float)(int)(v55 + v70 * v70) * -0.5) / v71) * 0.15915) / v71;
      if (v70 >= (int)v42) {
        break;
      }
      ++v70;
      ++v69;
    }
    while (v69 < v45);
    goto LABEL_72;
  }
}

void sub_24B6F6358(void *a1)
{
  *a1 = &unk_26FE9CE00;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = a1[5];
    uint64_t v4 = (void *)a1[4];
    if (v3 != v2)
    {
      uint64_t v5 = a1[5];
      do
      {
        unint64_t v7 = *(void **)(v5 - 24);
        v5 -= 24;
        uint64_t v6 = v7;
        if (v7)
        {
          *(void *)(v3 - 16) = v6;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = (void *)a1[4];
    }
    a1[5] = v2;
    operator delete(v4);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B6F640C(void *a1)
{
  *a1 = &unk_26FE9CE00;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = a1[5];
    uint64_t v4 = (void *)a1[4];
    if (v3 != v2)
    {
      uint64_t v5 = a1[5];
      do
      {
        unint64_t v7 = *(void **)(v5 - 24);
        v5 -= 24;
        uint64_t v6 = v7;
        if (v7)
        {
          *(void *)(v3 - 16) = v6;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = (void *)a1[4];
    }
    a1[5] = v2;
    operator delete(v4);
  }
  return a1;
}

float *sub_24B6F64A0(float *result, float *a2, double a3)
{
  if (result != a2)
  {
    unint64_t v3 = (char *)a2 - (char *)result - 4;
    if (v3 >= 0x1C)
    {
      uint64_t v4 = (v3 >> 2) + 1;
      float32x4_t v5 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0);
      uint64_t v6 = (float32x4_t *)(result + 4);
      __asm { FMOV            V2.4S, #1.0 }
      uint64_t v12 = v4 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        float32x4_t v13 = vdivq_f32(v6[-1], v5);
        float32x4_t v14 = vdivq_f32(*v6, v5);
        v6[-1] = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v13, _Q2), (int8x16_t)_Q2, (int8x16_t)v13), (int8x16_t)vcltzq_f32(v13));
        *(int8x16_t *)uint64_t v6 = vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v14, _Q2), (int8x16_t)_Q2, (int8x16_t)v14), (int8x16_t)vcltzq_f32(v14));
        v6 += 2;
        v12 -= 8;
      }
      while (v12);
      if (v4 == (v4 & 0x7FFFFFFFFFFFFFF8)) {
        return result;
      }
      result += v4 & 0x7FFFFFFFFFFFFFF8;
    }
    do
    {
      float v15 = *result / *(float *)&a3;
      if (v15 <= 1.0) {
        float v16 = *result / *(float *)&a3;
      }
      else {
        float v16 = 1.0;
      }
      if (v15 >= 0.0) {
        float v17 = v16;
      }
      else {
        float v17 = 0.0;
      }
      *result++ = v17;
    }
    while (result != a2);
  }
  return result;
}

BOOL sub_24B6F6550(__CVBuffer *a1, CGRect *a2, void *a3, __CVBuffer *a4)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    if (qword_2697D11D8 != -1) {
      dispatch_once(&qword_2697D11D8, &unk_26FE9CE20);
    }
    uint64_t v13 = qword_2697D11D0;
    BOOL result = os_log_type_enabled((os_log_t)qword_2697D11D0, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(v17) = 0;
    uint64_t v12 = "Failed to crop and scale pixel buffer, pixel transfer session ref is nil!";
LABEL_11:
    float32x4_t v14 = v13;
    uint32_t v15 = 2;
LABEL_18:
    _os_log_error_impl(&dword_24B6B9000, v14, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v17, v15);
    return 0;
  }
  CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(*a2);
  CFStringRef v8 = (const __CFString *)*MEMORY[0x263F1EA10];
  OSStatus v9 = VTSessionSetProperty(a3, (CFStringRef)*MEMORY[0x263F1EA10], DictionaryRepresentation);
  CFRelease(DictionaryRepresentation);
  if (v9)
  {
    if (qword_2697D11D8 != -1) {
      dispatch_once(&qword_2697D11D8, &unk_26FE9CE20);
    }
    uint64_t v10 = qword_2697D11D0;
    BOOL result = os_log_type_enabled((os_log_t)qword_2697D11D0, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v17 = 67240192;
      OSStatus v18 = v9;
      uint64_t v12 = "Failed to crop and scaled pixel buffer, unable to initialize pixel transfer session for image cropping: %{public}d";
LABEL_17:
      float32x4_t v14 = v10;
      uint32_t v15 = 8;
      goto LABEL_18;
    }
    return result;
  }
  OSStatus v16 = VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)a3, a1, a4);
  if (VTSessionSetProperty(a3, v8, 0))
  {
    if (qword_2697D11D8 != -1) {
      dispatch_once(&qword_2697D11D8, &unk_26FE9CE20);
    }
    uint64_t v10 = qword_2697D11D0;
    BOOL result = os_log_type_enabled((os_log_t)qword_2697D11D0, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v17 = 67240192;
      OSStatus v18 = 0;
      uint64_t v12 = "Failed to crop and scaled pixel buffer, unable to unset crop rectangle for  pixel transfer session for image"
            " cropping: %{public}d";
      goto LABEL_17;
    }
    return result;
  }
  if (!v16) {
    return 1;
  }
  if (qword_2697D11D8 != -1) {
    dispatch_once(&qword_2697D11D8, &unk_26FE9CE20);
  }
  uint64_t v13 = qword_2697D11D0;
  BOOL result = os_log_type_enabled((os_log_t)qword_2697D11D0, OS_LOG_TYPE_ERROR);
  if (result)
  {
    LOWORD(v17) = 0;
    uint64_t v12 = "Failed to crop and scale image in VTPixelTransferSession";
    goto LABEL_11;
  }
  return result;
}

uint64_t sub_24B6F67CC()
{
  qword_2697D11D0 = (uint64_t)os_log_create("com.apple.CoreOCModules", "General");
  return MEMORY[0x270F9A758]();
}

uint64_t *sub_24B6F6810(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = sub_24B6F6858(v2);
    MEMORY[0x24C5D7790](v3, 0x10E0C40A317B3DBLL);
  }
  return a1;
}

uint64_t sub_24B6F6858(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_24B6F68EC(uint64_t a1, CVPixelBufferRef pixelBuffer, size_t a3, size_t a4)
{
  CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
  BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
  OSStatus v9 = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1uLL);
  size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
  size_t v11 = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1uLL);
  size_t Width = CVPixelBufferGetWidth(pixelBuffer);
  size_t Height = CVPixelBufferGetHeight(pixelBuffer);
  if (Width > a3 && BaseAddressOfPlane && v9 && BytesPerRowOfPlane && v11 && Height > a4)
  {
    uint32_t v15 = &v9[(a3 & 0xFFFFFFFFFFFFFFFELL) + v11 * (a4 >> 1)];
    LOBYTE(v14) = BaseAddressOfPlane[a3 + BytesPerRowOfPlane * a4];
    v16.f32[0] = (float)v14;
    float v17 = (float)(*v15 - 128);
    float32_t v18 = v16.f32[0] + (float)(v17 * -0.39176);
    float v19 = v16.f32[0] + (float)(v17 * 2.0172);
    v16.f32[1] = v18;
    float32x2_t v20 = vdiv_f32(vmla_n_f32(v16, (float32x2_t)0xBF501EA43FCC4A9ALL, (float)(v15[1] - 128)), (float32x2_t)vdup_n_s32(0x437F0000u));
    __asm { FMOV            V3.2S, #1.0 }
    *(int8x8_t *)&long long v14 = vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v20, _D3), (int8x8_t)_D3, (int8x8_t)v20), (int8x8_t)vcltz_f32(v20));
    float v26 = v19 / 255.0;
    float v27 = 1.0;
    if (v26 <= 1.0) {
      float v27 = v26;
    }
    _NF = v26 < 0.0;
    float v28 = 0.0;
    if (!_NF) {
      float v28 = v27;
    }
    *((float *)&v14 + 2) = v28;
    *(_OWORD *)a1 = v14;
    char v29 = 1;
  }
  else
  {
    char v29 = 0;
    *(unsigned char *)a1 = 0;
  }
  *(unsigned char *)(a1 + 16) = v29;
  return CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
}

CFMutableDictionaryRef sub_24B6F6A90(void *a1, CVPixelBufferPoolRef *a2)
{
  uint64_t v2 = a1 + 1;
  if (*a1) {
    BOOL v3 = a1[1] == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    uint64_t v6 = a1 + 3;
    unint64_t v5 = a1[3];
    if (v5)
    {
      if (a1[4] - 1 < v5)
      {
        OSStatus v9 = a1 + 2;
        int v8 = *((_DWORD *)a1 + 4);
        if (v8 == 1111970369 || v8 == 1717855600 || v8 == 1380410945)
        {
          CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
          CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
          CFMutableDictionaryRef cf = result;
          if (!result) {
            return result;
          }
          uint64_t v12 = result;
          CFNumberRef v13 = CFNumberCreate(v10, kCFNumberIntType, a1 + 4);
          if (v13
            && (CFNumberRef v14 = v13,
                CFDictionarySetValue(v12, (const void *)*MEMORY[0x263F041C0], v13),
                CFRelease(v14),
                (CFNumberRef v15 = CFNumberCreate(v10, kCFNumberIntType, v6)) != 0))
          {
            CFNumberRef v16 = v15;
            CFDictionarySetValue(v12, (const void *)*MEMORY[0x263F041A8], v15);
            CFRelease(v16);
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v10, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
            if (Mutable)
            {
              float32_t v18 = Mutable;
              CFNumberRef v19 = CFNumberCreate(v10, kCFNumberIntType, a1);
              if (v19)
              {
                CFNumberRef v20 = v19;
                CFDictionarySetValue(v18, (const void *)*MEMORY[0x263F04240], v19);
                CFRelease(v20);
                CFNumberRef v21 = CFNumberCreate(v10, kCFNumberIntType, v2);
                if (v21)
                {
                  CFNumberRef v22 = v21;
                  CFDictionarySetValue(v18, (const void *)*MEMORY[0x263F04118], v21);
                  CFRelease(v22);
                  CFNumberRef v23 = CFNumberCreate(v10, kCFNumberIntType, v9);
                  if (v23)
                  {
                    CFNumberRef v24 = v23;
                    CFDictionarySetValue(v18, (const void *)*MEMORY[0x263F04180], v23);
                    CFRelease(v24);
                    CVReturn v25 = CVPixelBufferPoolCreate(v10, v12, v18, a2);
                    CFRelease(v12);
                    CFRelease(v18);
                    return (CFMutableDictionaryRef)(v25 == 0);
                  }
                }
              }
              CFRelease(v12);
              float v26 = v18;
            }
            else
            {
              float v26 = v12;
            }
          }
          else
          {
            CFRelease(&cf);
            float v26 = cf;
          }
          CFRelease(v26);
        }
      }
    }
  }
  return 0;
}

void sub_24B6F6D14(unsigned char *a1, char *__s)
{
  uint64_t v2 = a1;
  if (!__s)
  {
    a1[23] = 0;
    *a1 = 0;
    return;
  }
  size_t v4 = strlen(__s);
  if (v4 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_127;
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_dst = (long long *)operator new(v7 + 1);
    *((void *)&__dst + 1) = v5;
    int64_t v70 = v8 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
  }
  else
  {
    HIBYTE(v70) = v4;
    p_dst = &__dst;
    if (!v4) {
      goto LABEL_11;
    }
  }
  memcpy(p_dst, __s, v5);
LABEL_11:
  *((unsigned char *)p_dst + v5) = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_2697D1220, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(qword_2697D1220))
  {
    sub_24B6F74E4();
  }
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  BOOL v78 = 0;
  long long v79 = 0uLL;
  BOOL v80 = 0;
  char v81 = 0;
  float32x4_t v82 = 0;
  std::string __p = 0;
  int32x4_t v72 = 0;
  if (v70 >= 0) {
    OSStatus v9 = &__dst;
  }
  else {
    OSStatus v9 = (long long *)__dst;
  }
  if (v70 >= 0) {
    uint64_t v10 = HIBYTE(v70);
  }
  else {
    uint64_t v10 = *((void *)&__dst + 1);
  }
  uint64_t v11 = (uint64_t)v9 + v10;
  int64_t v73 = 0;
  *(void *)&long long v74 = (char *)v9 + v10;
  *((void *)&v74 + 1) = (char *)v9 + v10;
  BOOL v75 = 0;
  sub_24B6F7568((uint64_t)&__p, (dword_2697D11FC + 1), &v74);
  uint64_t v76 = v9;
  uint64_t v77 = v9;
  BOOL v78 = 0;
  long long v79 = v74;
  BOOL v80 = v75;
  float32x4_t v82 = v9;
  char v81 = 1;
  if ((word_2697D11F8 & 0x1F0) != 0)
  {
    if (dword_2697D11FC)
    {
      if (((uint64_t (*)(long long *, char *, void **, void, uint64_t))loc_24B6F89C8)(v9, (char *)v9 + v10, &__p, 0, 1))goto LABEL_41; {
    }
      }
    else if (sub_24B6F7C34((uint64_t)v9, (uint64_t)v9 + v10, (uint64_t *)&__p, 0, 1))
    {
      goto LABEL_41;
    }
  }
  else if (((uint64_t (*)(std::locale *, long long *, char *, void **, void, uint64_t))loc_24B6F76F4)(&stru_2697D11E0, v9, (char *)v9 + v10, &__p, 0, 1))
  {
    goto LABEL_41;
  }
  if (!v10)
  {
LABEL_48:
    CFNumberRef v14 = (long long *)__p;
    CFNumberRef v19 = v76;
    int32x4_t v72 = (long long *)__p;
    CFNumberRef v15 = (long long *)__p;
    goto LABEL_49;
  }
  uint64_t v12 = v10 - 1;
  if (v10 != 1)
  {
    uint64_t v13 = (uint64_t)v9 + 1;
    do
    {
      sub_24B6F7568((uint64_t)&__p, 0xAAAAAAAAAAAAAAABLL * (((char *)v72 - (unsigned char *)__p) >> 3), &v74);
      if ((word_2697D11F8 & 0x1F0) != 0)
      {
        if (dword_2697D11FC)
        {
          if (((uint64_t (*)(uint64_t, uint64_t, void **, uint64_t, void))loc_24B6F89C8)(v13, v11, &__p, 128, 0))goto LABEL_41; {
        }
          }
        else if (sub_24B6F7C34(v13, v11, (uint64_t *)&__p, 128, 0))
        {
          goto LABEL_41;
        }
      }
      else if (((uint64_t (*)(std::locale *, uint64_t, uint64_t, void **, uint64_t, void))loc_24B6F76F4)(&stru_2697D11E0, v13, v11, &__p, 128, 0))
      {
        goto LABEL_41;
      }
      sub_24B6F7568((uint64_t)&__p, 0xAAAAAAAAAAAAAAABLL * (((char *)v72 - (unsigned char *)__p) >> 3), &v74);
      ++v13;
      --v12;
    }
    while (v12);
  }
  sub_24B6F7568((uint64_t)&__p, 0xAAAAAAAAAAAAAAABLL * (((char *)v72 - (unsigned char *)__p) >> 3), &v74);
  if ((word_2697D11F8 & 0x1F0) == 0)
  {
    if (((uint64_t (*)(std::locale *, uint64_t, uint64_t, void **, uint64_t, void))loc_24B6F76F4)(&stru_2697D11E0, v11, v11, &__p, 128, 0))goto LABEL_41; {
    goto LABEL_48;
    }
  }
  if (!dword_2697D11FC)
  {
    if (sub_24B6F7C34(v11, v11, (uint64_t *)&__p, 128, 0)) {
      goto LABEL_41;
    }
    goto LABEL_48;
  }
  if (!((uint64_t (*)(uint64_t, uint64_t, void **, uint64_t, void))loc_24B6F89C8)(v11, v11, &__p, 128, 0))goto LABEL_48; {
LABEL_41:
  }
  CFNumberRef v14 = (long long *)__p;
  CFNumberRef v15 = v72;
  if (v72 == __p) {
    CFNumberRef v16 = &v74;
  }
  else {
    CFNumberRef v16 = (long long *)__p;
  }
  float v17 = *(long long **)v16;
  uint64_t v77 = v17;
  float32_t v18 = (char *)__p + 8;
  if (v72 == __p) {
    float32_t v18 = (char *)&v74 + 8;
  }
  CFNumberRef v19 = v76;
  BOOL v78 = v76 != v17;
  *(void *)&long long v79 = *(void *)v18;
  BOOL v80 = (void)v79 != *((void *)&v79 + 1);
LABEL_49:
  if (v70 >= 0) {
    CFNumberRef v20 = &__dst;
  }
  else {
    CFNumberRef v20 = (long long *)__dst;
  }
  int64_t v21 = (char *)v15 - (char *)v14;
  if (v15 == v14)
  {
    CFNumberRef v24 = 0;
    BOOL v28 = 1;
  }
  else
  {
    uint64_t v22 = v21 / 24;
    if ((unint64_t)(v21 / 24) >= 0xAAAAAAAAAAAAAABLL) {
      goto LABEL_127;
    }
    CFNumberRef v23 = operator new(v21);
    CFNumberRef v24 = v23;
    uint64_t v25 = 24 * v22;
    float v26 = v23;
    do
    {
      void *v26 = 0;
      v26[1] = 0;
      *((unsigned char *)v26 + 16) = 0;
      v26 += 3;
      v25 -= 24;
    }
    while (v25);
    uint64_t v27 = 24 * v22;
    BOOL v28 = 24 * v22 == 0;
    if (v27)
    {
      uint64_t v29 = (unsigned __int128)(v27 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
      unint64_t v30 = (v29 >> 2) + ((unint64_t)v29 >> 63);
      if (v30 <= 1) {
        uint64_t v31 = 1;
      }
      else {
        uint64_t v31 = (v29 >> 2) + ((unint64_t)v29 >> 63);
      }
      if (v15 == v14) {
        unint64_t v32 = &v74;
      }
      else {
        unint64_t v32 = v14;
      }
      *CFNumberRef v23 = (char *)v20 + *(void *)v32 - (void)v19;
      CFNumberRef v14 = (long long *)__p;
      unint64_t v33 = v72;
      int8x16_t v34 = (char *)__p + 8;
      if (v72 == __p) {
        int8x16_t v34 = (char *)&v74 + 8;
      }
      uint64_t v35 = *(void *)v34;
      long long v36 = (BOOL *)__p + 16;
      if (v72 == __p) {
        long long v36 = &v75;
      }
      v23[1] = (char *)v20 + v35 - (void)v19;
      *((unsigned char *)v23 + 16) = *v36;
      if (v30 >= 2)
      {
        uint64_t v37 = 0;
        float32x4_t v38 = (char *)__p;
        float v39 = v72;
        unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * (((char *)v72 - (unsigned char *)__p) >> 3);
        unint64_t v41 = (char *)__p + 32;
        unint64_t v42 = 1;
        do
        {
          BOOL v43 = 0xAAAAAAAAAAAAAAABLL * (((char *)v33 - (char *)v14) >> 3) > v42;
          float v44 = &v24[v37];
          uint64_t v45 = &v41[v37];
          unint64_t v46 = &v38[v37];
          v37 += 24;
          unint64_t v47 = (long long *)((char *)v14 + v37);
          if (!v43) {
            unint64_t v47 = &v74;
          }
          *((void *)v44 + 3) = (char *)v20 + *(void *)v47 - (void)v19;
          if (v40 <= v42) {
            uint64_t v45 = (char *)&v74 + 8;
          }
          *((void *)v44 + 4) = (char *)v20 + *(void *)v45 - (void)v19;
          float32x4_t v48 = (BOOL *)(v46 + 40);
          if (v40 <= v42) {
            float32x4_t v48 = &v75;
          }
          v44[40] = *v48;
          ++v42;
          CFNumberRef v14 = (long long *)v38;
          unint64_t v33 = v39;
        }
        while (v31 != v42);
        CFNumberRef v14 = (long long *)v38;
      }
    }
  }
  if (v14)
  {
    int32x4_t v72 = v14;
    operator delete(v14);
  }
  if (!v28)
  {
    if (!v24[16])
    {
      std::string __p = 0;
      int32x4_t v72 = 0;
      unint64_t v53 = -1;
      int64_t v73 = 0;
LABEL_109:
      size_t v63 = HIBYTE(v73);
      if (v73 >= 0)
      {
        p_p = &__p;
      }
      else
      {
        size_t v63 = (size_t)v72;
        p_p = __p;
      }
      if (v63 >= v53) {
        size_t v65 = v53;
      }
      else {
        size_t v65 = v63;
      }
      if (v65 <= 0x7FFFFFFFFFFFFFF7)
      {
        if (v65 >= 0x17)
        {
          uint64_t v66 = (v65 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v65 | 7) != 0x17) {
            uint64_t v66 = v65 | 7;
          }
          uint64_t v67 = v66 + 1;
          int32x4_t v68 = operator new(v66 + 1);
          v2[1] = v65;
          v2[2] = v67 | 0x8000000000000000;
          void *v2 = v68;
          uint64_t v2 = v68;
        }
        else
        {
          *((unsigned char *)v2 + 23) = v65;
          if (!v65)
          {
LABEL_123:
            *((unsigned char *)v2 + v65) = 0;
            if (SHIBYTE(v73) < 0) {
              operator delete(__p);
            }
            goto LABEL_125;
          }
        }
        memmove(v2, p_p, v65);
        goto LABEL_123;
      }
LABEL_127:
      abort();
    }
    uint64_t v49 = *(char **)v24;
    int v50 = (char *)*((void *)v24 + 1);
    unint64_t v51 = (unint64_t)&v50[-*(void *)v24];
    if (v51 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_127;
    }
    if (v51 > 0x16)
    {
      uint64_t v54 = (v51 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v51 | 7) != 0x17) {
        uint64_t v54 = v51 | 7;
      }
      uint64_t v55 = v54 + 1;
      float v52 = operator new(v54 + 1);
      int32x4_t v72 = (long long *)v51;
      int64_t v73 = v55 | 0x8000000000000000;
      std::string __p = v52;
      if (v49 == v50) {
        goto LABEL_106;
      }
    }
    else
    {
      HIBYTE(v73) = (_BYTE)v50 - *v24;
      float v52 = &__p;
      if (v49 == v50)
      {
LABEL_106:
        unsigned char *v52 = 0;
        if (v24[16]) {
          unint64_t v53 = *((void *)v24 + 1) + ~*(void *)v24;
        }
        else {
          unint64_t v53 = -1;
        }
        goto LABEL_109;
      }
    }
    if (v51 < 0x20 || (unint64_t)(v52 - v49) < 0x20)
    {
      uint64_t v57 = v52;
    }
    else
    {
      uint64_t v56 = v51 & 0x7FFFFFFFFFFFFFE0;
      uint64_t v57 = &v52[v51 & 0xFFFFFFFFFFFFFFE0];
      int32x4_t v58 = (long long *)(v49 + 16);
      uint64_t v59 = v52 + 16;
      unint64_t v60 = v51 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v61 = *v58;
        *(v59 - 1) = *(v58 - 1);
        *uint64_t v59 = v61;
        v58 += 2;
        v59 += 2;
        v60 -= 32;
      }
      while (v60);
      if (v51 == v56)
      {
        v52 += v51 & 0xFFFFFFFFFFFFFFE0;
        goto LABEL_106;
      }
      v49 += v56;
    }
    float v52 = v57;
    do
    {
      char v62 = *v49++;
      *v52++ = v62;
    }
    while (v49 != v50);
    goto LABEL_106;
  }
  if (SHIBYTE(v70) < 0)
  {
    sub_24B6EEF48(v2, (void *)__dst, *((unint64_t *)&__dst + 1));
    if (!v24) {
      goto LABEL_90;
    }
  }
  else
  {
    *(_OWORD *)uint64_t v2 = __dst;
    v2[2] = v70;
    if (!v24)
    {
LABEL_90:
      if ((SHIBYTE(v70) & 0x80000000) == 0) {
        return;
      }
LABEL_126:
      operator delete((void *)__dst);
      return;
    }
  }
LABEL_125:
  operator delete(v24);
  if (SHIBYTE(v70) < 0) {
    goto LABEL_126;
  }
}

void sub_24B6F74E4()
{
  uint64_t v0 = (const std::locale *)MEMORY[0x24C5D76E0](&stru_2697D11E0);
  qword_2697D11E8 = (uint64_t)std::locale::use_facet(v0, MEMORY[0x263F8C108]);
  qword_2697D11F0 = (uint64_t)std::locale::use_facet(&stru_2697D11E0, MEMORY[0x263F8C130]);
  *(_OWORD *)&word_2697D11F8 = 0u;
  *(_OWORD *)&qword_2697D1208 = 0u;
  qword_2697D1218 = 0;
  sub_24B6FA278();
}

void *sub_24B6F7568(uint64_t a1, unint64_t a2, long long *a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  CFMutableDictionaryRef result = *(void **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)result) >> 3) < a2)
  {
    if (result)
    {
      *(void *)(a1 + 8) = result;
      operator delete(result);
      uint64_t v6 = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_26;
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    unint64_t v10 = v8 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v9;
    if (v10 > 0xAAAAAAAAAAAAAAALL) {
LABEL_26:
    }
      abort();
    uint64_t v11 = 3 * v10;
    CFMutableDictionaryRef result = operator new(24 * v10);
    *(void *)a1 = result;
    *(void *)(a1 + 8) = result;
    *(void *)(a1 + 16) = &result[v11];
    uint64_t v12 = 24 * a2;
    uint64_t v13 = &result[3 * a2];
    do
    {
      *(_OWORD *)CFMutableDictionaryRef result = *a3;
      result[2] = *((void *)a3 + 2);
      result += 3;
      v12 -= 24;
    }
    while (v12);
    goto LABEL_25;
  }
  uint64_t v14 = *(void *)(a1 + 8);
  unint64_t v15 = (v14 - (uint64_t)result) / 24;
  if (v15 >= a2) {
    uint64_t v16 = a2;
  }
  else {
    uint64_t v16 = (v14 - (uint64_t)result) / 24;
  }
  if (v16)
  {
    float v17 = result;
    do
    {
      *(_OWORD *)float v17 = *a3;
      *((unsigned char *)v17 + 16) = *((unsigned char *)a3 + 16);
      v17 += 3;
      --v16;
    }
    while (v16);
  }
  if (a2 <= v15)
  {
    uint64_t v13 = &result[3 * a2];
LABEL_25:
    *(void *)(a1 + 8) = v13;
    return result;
  }
  uint64_t v18 = v14 + 24 * (a2 - v15);
  uint64_t v19 = 24 * a2 - 24 * v15;
  do
  {
    long long v20 = *a3;
    *(void *)(v14 + 16) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v14 = v20;
    v14 += 24;
    v19 -= 24;
  }
  while (v19);
  *(void *)(a1 + 8) = v18;
  return result;
}

uint64_t sub_24B6F7C34(uint64_t a1, uint64_t a2, uint64_t *a3, int a4, char a5)
{
  long long v170 = 0u;
  long long v171 = 0u;
  long long v169 = 0u;
  uint64_t v5 = qword_2697D1208;
  if (!qword_2697D1208) {
    goto LABEL_141;
  }
  uint64_t v161 = a2 - a1;
  memset(&v163[4], 0, 24);
  sub_24B6F998C((uint64_t)&v169);
  unint64_t v9 = *(void *)(*((void *)&v169 + 1) + 8 * ((*((void *)&v171 + 1) + (void)v171) / 0x2AuLL))
     + 96 * ((*((void *)&v171 + 1) + (void)v171) % 0x2AuLL);
  *(_DWORD *)unint64_t v9 = 0;
  *(_OWORD *)(v9 + 4) = *(_OWORD *)v163;
  long long v10 = *(_OWORD *)&v163[12];
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 16) = v10;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)(v9 + 77) = 0u;
  uint64_t v11 = *((void *)&v171 + 1);
  uint64_t v12 = ++*((void *)&v171 + 1);
  uint64_t v13 = *((void *)&v169 + 1);
  unint64_t v14 = v171 + v11;
  unint64_t v15 = 8 * (v14 / 0x2A);
  unint64_t v16 = v14 % 0x2A;
  unint64_t v17 = 96 * (v14 % 0x2A);
  unint64_t v18 = *(void *)(*((void *)&v169 + 1) + v15) + v17;
  *(_DWORD *)unint64_t v18 = 0;
  *(void *)(v18 + 8) = a1;
  *(void *)(*(void *)(v13 + v15) + v17 + 16) = a1;
  *(void *)(*(void *)(v13 + v15) + v17 + 24) = a2;
  unint64_t v19 = *(void *)(v13 + v15) + v17;
  uint64_t v22 = *(void *)(v19 + 56);
  unint64_t v20 = v19 + 56;
  uint64_t v21 = v22;
  unint64_t v23 = (*(void *)(v20 + 8) - v22) >> 4;
  uint64_t v158 = a1;
  if (dword_2697D1200 <= v23)
  {
    if (dword_2697D1200 < v23) {
      *(void *)(v20 + 8) = v21 + 16 * dword_2697D1200;
    }
  }
  else
  {
    sub_24B6F983C((char **)v20, dword_2697D1200 - v23);
  }
  char v160 = 0;
  unsigned int v24 = 0;
  uint64_t v159 = 0;
  *(void *)(*(void *)(v13 + v15) + 96 * v16 + 80) = v5;
  uint64_t v25 = *(void *)(v13 + v15) + 96 * v16;
  *(_DWORD *)(v25 + 88) = a4;
  *(unsigned char *)(v25 + 92) = a5;
  uint64_t v26 = v161;
  while (2)
  {
    if ((++v24 & 0xFFF) == 0 && (int)(v24 >> 12) >= (int)v26)
    {
      sub_24B6F9974();
LABEL_156:
      abort();
    }
    unint64_t v28 = v12 + v171 - 1;
    uint64_t v29 = *(void *)(*((void *)&v169 + 1) + 8 * (v28 / 0x2A));
    unint64_t v30 = v28 % 0x2A;
    uint64_t v31 = v29 + 96 * (v28 % 0x2A);
    unint64_t v33 = (void *)(v31 + 80);
    uint64_t v32 = *(void *)(v31 + 80);
    if (v32) {
      (*(void (**)(uint64_t, unint64_t))(*(void *)v32 + 16))(v32, v29 + 96 * v30);
    }
    switch(*(_DWORD *)v31)
    {
      case 0xFFFFFC18:
        uint64_t v34 = *(void *)(v29 + 96 * v30 + 16);
        if ((a4 & 0x20) != 0 && v34 == v158)
        {
          unint64_t v35 = *((void *)&v171 + 1) + v171 - 1;
          uint64_t v36 = *(void *)(*((void *)&v169 + 1) + 8 * (v35 / 0x2A));
          unint64_t v37 = v35 % 0x2A;
          float32x4_t v38 = *(void **)(v36 + 96 * (v35 % 0x2A) + 56);
          if (v38)
          {
            *(void *)(v36 + 96 * v37 + 64) = v38;
            operator delete(v38);
          }
          float v39 = *(void **)(v36 + 96 * v37 + 32);
          if (v39)
          {
            *(void *)(v36 + 96 * v37 + 40) = v39;
            operator delete(v39);
          }
          uint64_t v40 = v170;
          BOOL v41 = (void)v170 == *((void *)&v169 + 1);
          uint64_t v42 = 42 * ((uint64_t)(v170 - *((void *)&v169 + 1)) >> 3) - 1;
LABEL_110:
          long long v116 = v171;
          --*((void *)&v171 + 1);
          if (v41) {
            uint64_t v42 = 0;
          }
          if ((unint64_t)(v42 - (*((void *)&v116 + 1) + v116) + 1) >= 0x54)
          {
            operator delete(*(void **)(v40 - 8));
            *(void *)&long long v170 = v170 - 8;
          }
          goto LABEL_8;
        }
        uint64_t v71 = v34 - *(void *)(v29 + 96 * v30 + 8);
        uint64_t v72 = v159;
        if ((v160 & (v159 >= v71)) == 0) {
          uint64_t v72 = v71;
        }
        if (v72 == v26)
        {
          int64_t v73 = (void **)*((void *)&v169 + 1);
          uint64_t v74 = v170;
          if ((void)v170 == *((void *)&v169 + 1))
          {
            uint64_t v74 = *((void *)&v169 + 1);
          }
          else
          {
            BOOL v75 = (void *)(*((void *)&v169 + 1) + 8 * ((unint64_t)v171 / 0x2A));
            uint64_t v76 = (void *)(*v75 + 96 * ((unint64_t)v171 % 0x2A));
            unint64_t v77 = *(void *)(*((void *)&v169 + 1) + 8 * ((*((void *)&v171 + 1) + (void)v171) / 0x2AuLL))
                + 96 * ((*((void *)&v171 + 1) + (void)v171) % 0x2AuLL);
            if (v76 != (void *)v77)
            {
              do
              {
                BOOL v78 = (void *)v76[7];
                if (v78)
                {
                  v76[8] = v78;
                  operator delete(v78);
                }
                long long v79 = (void *)v76[4];
                if (v79)
                {
                  v76[5] = v79;
                  operator delete(v79);
                }
                v76 += 12;
                if ((void *)((char *)v76 - *v75) == (void *)4032)
                {
                  BOOL v80 = (void *)v75[1];
                  ++v75;
                  uint64_t v76 = v80;
                }
              }
              while (v76 != (void *)v77);
              int64_t v73 = (void **)*((void *)&v169 + 1);
              uint64_t v74 = v170;
            }
          }
          *((void *)&v171 + 1) = 0;
          unint64_t v90 = v74 - (void)v73;
          if (v90 >= 0x11)
          {
            do
            {
              operator delete(*v73);
              int64_t v73 = (void **)(*((void *)&v169 + 1) + 8);
              *((void *)&v169 + 1) = v73;
              unint64_t v90 = v170 - (void)v73;
            }
            while ((void)v170 - (void)v73 > 0x10uLL);
          }
          if (v90 >> 3 == 1)
          {
            uint64_t v91 = 21;
LABEL_88:
            *(void *)&long long v171 = v91;
          }
          else if (v90 >> 3 == 2)
          {
            uint64_t v91 = 42;
            goto LABEL_88;
          }
          char v160 = 1;
          uint64_t v159 = v26;
          goto LABEL_8;
        }
        uint64_t v159 = v72;
        unint64_t v83 = *((void *)&v171 + 1) + v171 - 1;
        uint64_t v84 = *(void *)(*((void *)&v169 + 1) + 8 * (v83 / 0x2A));
        unint64_t v85 = v83 % 0x2A;
        unint64_t v86 = *(void **)(v84 + 96 * (v83 % 0x2A) + 56);
        if (v86)
        {
          *(void *)(v84 + 96 * v85 + 64) = v86;
          operator delete(v86);
        }
        float32x4_t v87 = *(void **)(v84 + 96 * v85 + 32);
        if (v87)
        {
          *(void *)(v84 + 96 * v85 + 40) = v87;
          operator delete(v87);
        }
        uint64_t v88 = 42 * ((uint64_t)(v170 - *((void *)&v169 + 1)) >> 3) - 1;
        long long v89 = v171;
        --*((void *)&v171 + 1);
        if ((void)v170 == *((void *)&v169 + 1)) {
          uint64_t v88 = 0;
        }
        if ((unint64_t)(v88 - (*((void *)&v89 + 1) + v89) + 1) >= 0x54)
        {
          operator delete(*(void **)(v170 - 8));
          *(void *)&long long v170 = v170 - 8;
        }
        char v160 = 1;
LABEL_8:
        uint64_t v12 = *((void *)&v171 + 1);
        if (*((void *)&v171 + 1)) {
          continue;
        }
        if (v160)
        {
          uint64_t v146 = *a3;
          *(void *)uint64_t v146 = v158;
          *(void *)(v146 + 8) = v158 + v159;
          uint64_t v147 = 1;
          *(unsigned char *)(v146 + 16) = 1;
          goto LABEL_142;
        }
LABEL_141:
        uint64_t v147 = 0;
LABEL_142:
        uint64_t v148 = (void **)*((void *)&v169 + 1);
        float64x2_t v149 = (void **)v170;
        *((void *)&v171 + 1) = 0;
        unint64_t v150 = v170 - *((void *)&v169 + 1);
        if ((void)v170 - *((void *)&v169 + 1) >= 0x11uLL)
        {
          do
          {
            operator delete(*v148);
            float64x2_t v149 = (void **)v170;
            uint64_t v148 = (void **)(*((void *)&v169 + 1) + 8);
            *((void *)&v169 + 1) = v148;
            unint64_t v150 = v170 - (void)v148;
          }
          while ((void)v170 - (void)v148 > 0x10uLL);
        }
        unint64_t v151 = v150 >> 3;
        if (v151 == 1)
        {
          uint64_t v152 = 21;
          goto LABEL_148;
        }
        if (v151 == 2)
        {
          uint64_t v152 = 42;
LABEL_148:
          *(void *)&long long v171 = v152;
        }
        if (v148 != v149)
        {
          do
          {
            unsigned int v153 = *v148++;
            operator delete(v153);
          }
          while (v148 != v149);
          if ((void)v170 != *((void *)&v169 + 1)) {
            *(void *)&long long v170 = v170 + ((*((void *)&v169 + 1) - v170 + 7) & 0xFFFFFFFFFFFFFFF8);
          }
        }
        if ((void)v169) {
          operator delete((void *)v169);
        }
        return v147;
      case 0xFFFFFC19:
      case 0xFFFFFC1E:
      case 0xFFFFFC21:
        goto LABEL_8;
      case 0xFFFFFC1D:
        unint64_t v43 = v171;
        float v44 = (uint64_t *)*((void *)&v169 + 1);
        uint64_t v45 = (uint64_t *)v170;
        if ((void)v171) {
          goto LABEL_101;
        }
        unint64_t v81 = (uint64_t)(v170 - *((void *)&v169 + 1)) >> 3;
        uint64_t v82 = 42 * v81 - 1;
        if ((void)v170 == *((void *)&v169 + 1)) {
          uint64_t v82 = 0;
        }
        if ((unint64_t)(v82 - *((void *)&v171 + 1)) >= 0x2A)
        {
          *(void *)&long long v171 = 42;
          *(void *)int v163 = *(void *)(v170 - 8);
          *(void *)&long long v170 = v170 - 8;
          sub_24B6F9EC8((void **)&v169, v163);
          goto LABEL_100;
        }
        if (v81 < (uint64_t)(*((void *)&v170 + 1) - v169) >> 3)
        {
          if (*((void *)&v169 + 1) == (void)v169)
          {
            *(void *)int v163 = operator new(0xFC0uLL);
            sub_24B6FA070((char **)&v169, v163);
            *(void *)int v163 = *(void *)(v170 - 8);
            *(void *)&long long v170 = v170 - 8;
          }
          else
          {
            *(void *)int v163 = operator new(0xFC0uLL);
          }
          sub_24B6F9EC8((void **)&v169, v163);
          uint64_t v97 = 21;
          if ((void)v170 - *((void *)&v169 + 1) != 8) {
            uint64_t v97 = v171 + 42;
          }
          *(void *)&long long v171 = v97;
          goto LABEL_100;
        }
        if (*((void *)&v170 + 1) == (void)v169) {
          unint64_t v92 = 1;
        }
        else {
          unint64_t v92 = (uint64_t)(*((void *)&v170 + 1) - v169) >> 2;
        }
        if (v92 >> 61) {
LABEL_158:
        }
          sub_24B6BCD7C();
        unint64_t v93 = (char *)operator new(8 * v92);
        uint64_t v94 = operator new(0xFC0uLL);
        if (v92)
        {
          id v95 = &v93[8 * v92];
          unint64_t v96 = v93;
        }
        else
        {
          uint64_t v98 = v94;
          uint64_t v99 = (char *)operator new(8uLL);
          id v95 = v99 + 8;
          operator delete(v93);
          uint64_t v94 = v98;
          float v44 = (uint64_t *)*((void *)&v169 + 1);
          uint64_t v45 = (uint64_t *)v170;
          unint64_t v96 = v99;
        }
        *(void *)unint64_t v96 = v94;
        float32x4_t v100 = v96 + 8;
        uint64_t v101 = v96;
        if (v44 == v45)
        {
LABEL_96:
          uint64_t v102 = (void *)v169;
          *(void *)&long long v169 = v96;
          *((void *)&v169 + 1) = v101;
          *(void *)&long long v170 = v100;
          *((void *)&v170 + 1) = v95;
          uint64_t v103 = v171 + 42;
          if (v100 - v101 == 8) {
            uint64_t v103 = 21;
          }
          *(void *)&long long v171 = v103;
          uint64_t v26 = v161;
          if (v102) {
            operator delete(v102);
          }
LABEL_100:
          unint64_t v43 = v171;
          float v44 = (uint64_t *)*((void *)&v169 + 1);
          uint64_t v45 = (uint64_t *)v170;
LABEL_101:
          uint64_t v104 = &v44[v43 / 0x2A];
          uint64_t v105 = *v104 + 96 * (v43 % 0x2A);
          if (v45 == v44) {
            uint64_t v105 = 0;
          }
          if (v105 == *v104) {
            uint64_t v105 = *(v104 - 1) + 4032;
          }
          long long v106 = *(_OWORD *)(v31 + 16);
          *(_OWORD *)(v105 - 96) = *(_OWORD *)v31;
          *(_OWORD *)(v105 - 80) = v106;
          uint64_t v107 = v29 + 96 * v30;
          *(void *)(v105 - 56) = 0;
          *(void *)(v105 - 48) = 0;
          *(void *)(v105 - 64) = 0;
          *(_OWORD *)(v105 - 64) = *(_OWORD *)(v107 + 32);
          *(void *)(v105 - 48) = *(void *)(v107 + 48);
          *(void *)(v107 + 32) = 0;
          *(void *)(v107 + 40) = 0;
          *(void *)(v107 + 48) = 0;
          *(void *)(v105 - 40) = 0;
          *(void *)(v105 - 32) = 0;
          *(void *)(v105 - 24) = 0;
          *(_OWORD *)(v105 - 40) = *(_OWORD *)(v107 + 56);
          *(void *)(v105 - 24) = *(void *)(v107 + 72);
          *(void *)(v107 + 56) = 0;
          *(void *)(v107 + 64) = 0;
          *(void *)(v107 + 72) = 0;
          uint64_t v108 = *v33;
          *(void *)(v105 - 11) = *(void *)(v31 + 85);
          *(void *)(v105 - 16) = v108;
          uint64_t v109 = *((void *)&v171 + 1);
          *(void *)&long long v171 = v171 - 1;
          ++*((void *)&v171 + 1);
          uint64_t v110 = v109 + v171;
          unint64_t v111 = (v109 + (uint64_t)v171) / 0x2AuLL;
          uint64_t v112 = *(void *)(*((void *)&v169 + 1) + 8 * v111);
          uint64_t v113 = v110 - 42 * v111;
          uint64_t v114 = *(void **)(v112 + 96 * v113 + 56);
          if (v114)
          {
            *(void *)(v112 + 96 * v113 + 64) = v114;
            operator delete(v114);
          }
          uint64_t v115 = *(void **)(v112 + 96 * v113 + 32);
          if (v115)
          {
            *(void *)(v112 + 96 * v113 + 40) = v115;
            operator delete(v115);
          }
          uint64_t v40 = v170;
          BOOL v41 = (void)v170 == *((void *)&v169 + 1);
          uint64_t v42 = 42 * ((uint64_t)(v170 - *((void *)&v169 + 1)) >> 3) - 1;
          goto LABEL_110;
        }
        break;
      case 0xFFFFFC1F:
        unint64_t v46 = *((void *)&v171 + 1) + v171 - 1;
        uint64_t v47 = *(void *)(*((void *)&v169 + 1) + 8 * (v46 / 0x2A));
        unint64_t v48 = v46 % 0x2A;
        uint64_t v49 = *(void **)(v47 + 96 * (v46 % 0x2A) + 56);
        if (v49)
        {
          *(void *)(v47 + 96 * v48 + 64) = v49;
          operator delete(v49);
        }
        int v50 = *(void **)(v47 + 96 * v48 + 32);
        if (v50)
        {
          *(void *)(v47 + 96 * v48 + 40) = v50;
          operator delete(v50);
        }
        uint64_t v40 = v170;
        BOOL v41 = (void)v170 == *((void *)&v169 + 1);
        uint64_t v42 = 42 * ((uint64_t)(v170 - *((void *)&v169 + 1)) >> 3) - 1;
        goto LABEL_110;
      case 0xFFFFFC20:
        long long v51 = *(_OWORD *)(v31 + 16);
        *(_OWORD *)int v163 = *(_OWORD *)v31;
        *(_OWORD *)&v163[16] = v51;
        uint64_t v52 = v29 + 96 * v30;
        v164[1] = 0;
        unsigned int v165 = 0;
        v164[0] = 0;
        uint64_t v54 = *(unsigned char **)(v52 + 32);
        unint64_t v53 = *(unsigned char **)(v52 + 40);
        int64_t v55 = v53 - v54;
        if (v53 == v54) {
          goto LABEL_34;
        }
        if (0xAAAAAAAAAAAAAAABLL * (v55 >> 3) >= 0xAAAAAAAAAAAAAABLL) {
          goto LABEL_156;
        }
        uint64_t v56 = (char *)operator new(v55);
        v164[0] = v56;
        v164[1] = v56;
        unsigned int v165 = &v56[8 * (v55 >> 3)];
        size_t v57 = 24 * ((v55 - 24) / 0x18uLL) + 24;
        memcpy(v56, v54, v57);
        v164[1] = &v56[v57];
LABEL_34:
        uint64_t v58 = v29 + 96 * v30;
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v167 = 0;
        unint64_t v60 = *(unsigned char **)(v58 + 56);
        uint64_t v59 = *(unsigned char **)(v58 + 64);
        uint64_t v61 = v59 - v60;
        if (v59 == v60) {
          goto LABEL_37;
        }
        if (v61 < 0) {
          goto LABEL_156;
        }
        char v62 = (char *)operator new(v59 - v60);
        __p[0] = v62;
        __p[1] = v62;
        uint64_t v167 = &v62[16 * (v61 >> 4)];
        size_t v63 = v61 & 0xFFFFFFFFFFFFFFF0;
        memcpy(v62, v60, v63);
        __p[1] = &v62[v63];
LABEL_37:
        uint64_t v64 = *v33;
        *(void *)((char *)v168 + 5) = *(void *)(v31 + 85);
        v168[0] = v64;
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v33 + 24))(*v33, 1, v31);
        (*(void (**)(void, void, unsigned char *))(*(void *)v168[0] + 24))(v168[0], 0, v163);
        uint64_t v65 = *((void *)&v169 + 1);
        if ((void)v170 == *((void *)&v169 + 1)) {
          uint64_t v66 = 0;
        }
        else {
          uint64_t v66 = 42 * ((uint64_t)(v170 - *((void *)&v169 + 1)) >> 3) - 1;
        }
        unint64_t v67 = *((void *)&v171 + 1) + v171;
        if (v66 == *((void *)&v171 + 1) + (void)v171)
        {
          sub_24B6F998C((uint64_t)&v169);
          uint64_t v65 = *((void *)&v169 + 1);
          unint64_t v67 = *((void *)&v171 + 1) + v171;
        }
        unint64_t v68 = *(void *)(v65 + 8 * (v67 / 0x2A)) + 96 * (v67 % 0x2A);
        long long v69 = *(_OWORD *)&v163[16];
        *(_OWORD *)unint64_t v68 = *(_OWORD *)v163;
        *(_OWORD *)(v68 + 16) = v69;
        *(void *)(v68 + 40) = 0;
        *(void *)(v68 + 48) = 0;
        *(void *)(v68 + 32) = 0;
        *(_OWORD *)(v68 + 32) = *(_OWORD *)v164;
        *(void *)(v68 + 48) = v165;
        v164[0] = 0;
        v164[1] = 0;
        unsigned int v165 = 0;
        *(void *)(v68 + 56) = 0;
        *(void *)(v68 + 64) = 0;
        *(void *)(v68 + 72) = 0;
        *(_OWORD *)(v68 + 56) = *(_OWORD *)__p;
        *(void *)(v68 + 72) = v167;
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v167 = 0;
        uint64_t v70 = v168[0];
        *(void *)(v68 + 85) = *(void *)((char *)v168 + 5);
        *(void *)(v68 + 80) = v70;
        ++*((void *)&v171 + 1);
        uint64_t v26 = v161;
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        if (v164[0])
        {
          v164[1] = v164[0];
          operator delete(v164[0]);
        }
        goto LABEL_8;
      default:
        sub_24B6F9974();
        goto LABEL_158;
    }
    break;
  }
  while (1)
  {
    if (v100 == v95)
    {
      if (v101 <= v96)
      {
        unint64_t v127 = (v100 - v96) >> 2;
        if (v100 == v96) {
          unint64_t v127 = 1;
        }
        if (v127 >> 61) {
          goto LABEL_158;
        }
        unint64_t v128 = v96;
        unint64_t v129 = v127 >> 2;
        uint64_t v157 = 8 * v127;
        uint64_t v130 = (char *)operator new(8 * v127);
        unint64_t v131 = v129;
        unint64_t v96 = v130;
        id v117 = &v130[8 * v129];
        id v118 = v117;
        int64_t v132 = v100 - v101;
        if (v100 != v101)
        {
          id v118 = &v117[v132 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v133 = v132 - 8;
          if (v133 >= 0x38)
          {
            uint64_t v135 = 8 * v131;
            if ((unint64_t)(&v130[8 * v131] - v101) < 0x20)
            {
              uint64_t v134 = v117;
              goto LABEL_136;
            }
            uint64_t v136 = (v133 >> 3) + 1;
            uint64_t v137 = 8 * (v136 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v134 = &v117[v137];
            uint64_t v138 = (long long *)(v101 + 16);
            float v139 = &v130[v135 + 16];
            uint64_t v140 = v136 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v141 = *v138;
              *((_OWORD *)v139 - 1) = *(v138 - 1);
              *(_OWORD *)float v139 = v141;
              v138 += 2;
              v139 += 32;
              v140 -= 4;
            }
            while (v140);
            if (v136 != (v136 & 0x3FFFFFFFFFFFFFFCLL))
            {
              v101 += v137;
              goto LABEL_136;
            }
          }
          else
          {
            uint64_t v134 = v117;
            do
            {
LABEL_136:
              uint64_t v142 = *(void *)v101;
              v101 += 8;
              *(void *)uint64_t v134 = v142;
              v134 += 8;
            }
            while (v134 != v118);
          }
        }
        float32x4_t v100 = &v130[v157];
        if (v128)
        {
          float32x4_t v143 = v128;
          float32x4_t v144 = v117;
          long long v145 = v96;
          operator delete(v143);
          id v117 = v144;
          unint64_t v96 = v145;
        }
        goto LABEL_115;
      }
      uint64_t v120 = (v101 - v96) >> 3;
      if (v120 >= -1) {
        uint64_t v121 = v120 + 1;
      }
      else {
        uint64_t v121 = v120 + 2;
      }
      uint64_t v122 = v121 >> 1;
      id v123 = &v101[-8 * (v121 >> 1)];
      uint64_t v124 = v100;
      int64_t v125 = v100 - v101;
      if (v100 != v101)
      {
        unint64_t v156 = v96;
        memmove(v123, v101, v100 - v101);
        int64_t v125 = v100 - v101;
        unint64_t v96 = v156;
        uint64_t v124 = v101;
      }
      uint64_t v126 = -v122;
      id v118 = &v123[v125];
      id v117 = &v124[8 * v126];
    }
    else
    {
      id v117 = v101;
      id v118 = v100;
      float32x4_t v100 = v95;
    }
LABEL_115:
    uint64_t v119 = *v44++;
    *(void *)id v118 = v119;
    uint64_t v101 = v117;
    id v95 = v100;
    float32x4_t v100 = v118 + 8;
    if (v44 == (uint64_t *)v170) {
      goto LABEL_96;
    }
  }
}

char *sub_24B6F94BC(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 5);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x2AAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5) >= 0x155555555555555) {
    unint64_t v6 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x2AAAAAAAAAAAAAALL) {
      sub_24B6BCD7C();
    }
    uint64_t v7 = (char *)operator new(96 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  long long v8 = *(_OWORD *)(a2 + 16);
  unint64_t v9 = &v7[96 * v2];
  *(_OWORD *)unint64_t v9 = *(_OWORD *)a2;
  *((_OWORD *)v9 + 1) = v8;
  long long v10 = &v7[96 * v6];
  *((_OWORD *)v9 + 2) = *(_OWORD *)(a2 + 32);
  *((void *)v9 + 6) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(v9 + 85) = *(void *)(a2 + 85);
  uint64_t v11 = *(void *)(a2 + 72);
  uint64_t v12 = *(void *)(a2 + 80);
  *((void *)v9 + 9) = 0;
  *((void *)v9 + 10) = v12;
  *(_OWORD *)(v9 + 56) = *(_OWORD *)(a2 + 56);
  *((void *)v9 + 9) = v11;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v13 = v9 + 96;
  unint64_t v14 = (char *)*a1;
  unint64_t v15 = (char *)a1[1];
  if (v15 == *a1)
  {
    *a1 = v9;
    a1[1] = v13;
    a1[2] = v10;
  }
  else
  {
    uint64_t v16 = 0;
    do
    {
      unint64_t v17 = &v9[v16];
      unint64_t v18 = &v15[v16];
      long long v19 = *(_OWORD *)&v15[v16 - 80];
      *((_OWORD *)v17 - 6) = *(_OWORD *)&v15[v16 - 96];
      *((_OWORD *)v17 - 5) = v19;
      *((void *)v17 - 7) = 0;
      *((void *)v17 - 6) = 0;
      *((_OWORD *)v17 - 4) = *(_OWORD *)&v15[v16 - 64];
      *((void *)v17 - 6) = *(void *)&v15[v16 - 48];
      *((void *)v18 - 8) = 0;
      *((void *)v18 - 7) = 0;
      *((void *)v18 - 6) = 0;
      *((void *)v17 - 4) = 0;
      *((void *)v17 - 3) = 0;
      *(_OWORD *)(v17 - 40) = *(_OWORD *)&v15[v16 - 40];
      *((void *)v17 - 3) = *(void *)&v15[v16 - 24];
      *((void *)v18 - 5) = 0;
      *((void *)v18 - 4) = 0;
      *((void *)v18 - 3) = 0;
      uint64_t v20 = *(void *)&v15[v16 - 16];
      *(void *)(v17 - 11) = *(void *)&v15[v16 - 11];
      *((void *)v17 - 2) = v20;
      v16 -= 96;
    }
    while (&v15[v16] != v14);
    unint64_t v15 = (char *)*a1;
    uint64_t v21 = (char *)a1[1];
    *a1 = &v9[v16];
    a1[1] = v13;
    a1[2] = v10;
    while (v21 != v15)
    {
      uint64_t v22 = (void *)*((void *)v21 - 5);
      if (v22)
      {
        *((void *)v21 - 4) = v22;
        operator delete(v22);
      }
      unint64_t v23 = (void *)*((void *)v21 - 8);
      if (v23)
      {
        *((void *)v21 - 7) = v23;
        operator delete(v23);
      }
      v21 -= 96;
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

void sub_24B6F968C(void **a1, unint64_t a2, long long *a3)
{
  uint64_t v7 = (char *)a1[1];
  unint64_t v6 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = &v7[24 * a2];
      uint64_t v14 = 24 * a2;
      do
      {
        long long v15 = *a3;
        *((void *)v7 + 2) = *((void *)a3 + 2);
        *(_OWORD *)uint64_t v7 = v15;
        v7 += 24;
        v14 -= 24;
      }
      while (v14);
      uint64_t v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (unsigned char *)*a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v6 - (unsigned char *)*a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 > 0xAAAAAAAAAAAAAAALL) {
        sub_24B6BCD7C();
      }
      uint64_t v12 = (char *)operator new(24 * v11);
    }
    else
    {
      uint64_t v12 = 0;
    }
    uint64_t v16 = &v12[24 * v8];
    uint64_t v17 = 24 * a2;
    unint64_t v18 = &v16[24 * a2];
    long long v19 = v16;
    do
    {
      long long v20 = *a3;
      *((void *)v19 + 2) = *((void *)a3 + 2);
      *(_OWORD *)long long v19 = v20;
      v19 += 24;
      v17 -= 24;
    }
    while (v17);
    uint64_t v21 = (char *)*a1;
    if (v7 != *a1)
    {
      do
      {
        long long v22 = *(_OWORD *)(v7 - 24);
        *((void *)v16 - 1) = *((void *)v7 - 1);
        *(_OWORD *)(v16 - 24) = v22;
        v16 -= 24;
        v7 -= 24;
      }
      while (v7 != v21);
      uint64_t v7 = (char *)*a1;
    }
    *a1 = v16;
    a1[1] = v18;
    a1[2] = &v12[24 * v11];
    if (v7)
    {
      operator delete(v7);
    }
  }
}

void sub_24B6F983C(char **a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  size_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      uint64_t v12 = 16 * a2;
      bzero(a1[1], 16 * a2);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    unint64_t v6 = *a1;
    uint64_t v7 = (v5 - *a1) >> 4;
    unint64_t v8 = v7 + a2;
    if ((v7 + a2) >> 60) {
      abort();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 60) {
        sub_24B6BCD7C();
      }
      unint64_t v11 = (char *)operator new(16 * v10);
    }
    else
    {
      unint64_t v11 = 0;
    }
    uint64_t v13 = &v11[16 * v7];
    size_t v14 = 16 * a2;
    long long v15 = &v11[16 * v10];
    bzero(v13, v14);
    uint64_t v16 = &v13[v14];
    if (v5 != v6)
    {
      do
      {
        *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
        v13 -= 16;
        v5 -= 16;
      }
      while (v5 != v6);
      uint64_t v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v15;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

uint64_t sub_24B6F9974()
{
  return sub_24B6F998C();
}

void sub_24B6F998C(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x2A;
  unint64_t v4 = v2 - 42;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    unint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_77:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v30 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v30 = 1;
      }
      if (!(v30 >> 61))
      {
        unint64_t v31 = v30 >> 2;
        uint64_t v32 = 8 * v30;
        unint64_t v33 = (char *)operator new(8 * v30);
        uint64_t v34 = &v33[8 * v31];
        unint64_t v35 = &v33[v32];
        int64_t v37 = v5 - v7;
        BOOL v36 = v5 == v7;
        uint64_t v5 = v34;
        if (!v36)
        {
          uint64_t v5 = &v34[v37 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v38 = v37 - 8;
          if ((unint64_t)(v37 - 8) >= 0x38)
          {
            uint64_t v72 = &v33[8 * v31];
            float v39 = v72;
            if ((unint64_t)(v72 - v7) >= 0x20)
            {
              uint64_t v73 = (v38 >> 3) + 1;
              uint64_t v74 = 8 * (v73 & 0x3FFFFFFFFFFFFFFCLL);
              float v39 = &v34[v74];
              BOOL v75 = (long long *)(v6 + 3);
              uint64_t v76 = v72 + 16;
              uint64_t v77 = v73 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v78 = *v75;
                *(v76 - 1) = *(v75 - 1);
                _OWORD *v76 = v78;
                v75 += 2;
                v76 += 2;
                v77 -= 4;
              }
              while (v77);
              if (v73 == (v73 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_75;
              }
              v7 += v74;
            }
          }
          else
          {
            float v39 = &v33[8 * v31];
          }
          do
          {
            uint64_t v79 = *(void *)v7;
            v7 += 8;
            *(void *)float v39 = v79;
            v39 += 8;
          }
          while (v39 != v5);
        }
        goto LABEL_75;
      }
LABEL_86:
      sub_24B6BCD7C();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    long long v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_77;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      uint64_t v88 = operator new(0xFC0uLL);
      sub_24B6FA070((char **)a1, &v88);
      return;
    }
    uint64_t v88 = operator new(0xFC0uLL);
    sub_24B6F9EC8((void **)a1, &v88);
    uint64_t v40 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v40 + 1);
    uint64_t v8 = *v40;
    *(void *)(a1 + 8) = v40 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_77;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v41 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v41 = 1;
      }
      if (!(v41 >> 61))
      {
        unint64_t v42 = v41 >> 2;
        uint64_t v43 = 8 * v41;
        unint64_t v33 = (char *)operator new(8 * v41);
        uint64_t v34 = &v33[8 * v42];
        unint64_t v35 = &v33[v43];
        int64_t v44 = v5 - v7;
        BOOL v36 = v5 == v7;
        uint64_t v5 = v34;
        if (!v36)
        {
          uint64_t v5 = &v34[v44 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v45 = v44 - 8;
          if ((unint64_t)(v44 - 8) >= 0x38)
          {
            BOOL v80 = &v33[8 * v42];
            unint64_t v46 = v80;
            if ((unint64_t)(v80 - v7) >= 0x20)
            {
              uint64_t v81 = (v45 >> 3) + 1;
              uint64_t v82 = 8 * (v81 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v46 = &v34[v82];
              unint64_t v83 = (long long *)(v40 + 3);
              uint64_t v84 = v80 + 16;
              uint64_t v85 = v81 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v86 = *v83;
                *(v84 - 1) = *(v83 - 1);
                *uint64_t v84 = v86;
                v83 += 2;
                v84 += 2;
                v85 -= 4;
              }
              while (v85);
              if (v81 == (v81 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_75;
              }
              v7 += v82;
            }
          }
          else
          {
            unint64_t v46 = &v33[8 * v42];
          }
          do
          {
            uint64_t v87 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v46 = v87;
            v46 += 8;
          }
          while (v46 != v5);
        }
LABEL_75:
        *(void *)a1 = v33;
        *(void *)(a1 + 8) = v34;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v35;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_77;
      }
      goto LABEL_86;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_86;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  uint64_t v26 = &v25[8 * v21];
  uint64_t v27 = &v25[8 * v24];
  unint64_t v28 = operator new(0xFC0uLL);
  if (v21 == v24)
  {
    if (v20 < 1)
    {
      unint64_t v47 = v20 >> 2;
      if (v18 == v19) {
        unint64_t v47 = 1;
      }
      if (v47 >> 61) {
        goto LABEL_86;
      }
      uint64_t v48 = 8 * v47;
      uint64_t v26 = (char *)operator new(8 * v47);
      uint64_t v27 = &v26[v48];
      operator delete(v25);
      uint64_t v19 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v26;
    }
    else
    {
      unint64_t v29 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v29 = v21 + 1;
      }
      v26 -= 8 * (v29 >> 1);
    }
  }
  *(void *)uint64_t v26 = v28;
  uint64_t v49 = v26 + 8;
  if (v18 != v19)
  {
    while (v26 != v25)
    {
      unint64_t v53 = v26;
      long long v51 = v49;
LABEL_48:
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      int v50 = v53 - 8;
      uint64_t v49 = v51;
      uint64_t v26 = v50;
      if (v18 == *(void *)(a1 + 8)) {
        goto LABEL_43;
      }
    }
    if (v49 < v27)
    {
      uint64_t v55 = (v27 - v49) >> 3;
      if (v55 >= -1) {
        unint64_t v56 = v55 + 1;
      }
      else {
        unint64_t v56 = v55 + 2;
      }
      long long v51 = &v49[8 * (v56 >> 1)];
      unint64_t v53 = &v26[8 * (v56 >> 1)];
      if (v49 == v26)
      {
        uint64_t v25 = v49;
      }
      else
      {
        memmove(&v26[8 * (v56 >> 1)], v26, v49 - v26);
        uint64_t v25 = v26;
      }
      goto LABEL_48;
    }
    unint64_t v57 = (v27 - v26) >> 2;
    if (v27 == v26) {
      unint64_t v57 = 1;
    }
    if (v57 >> 61) {
      goto LABEL_86;
    }
    unint64_t v58 = (v57 + 3) >> 2;
    uint64_t v59 = 8 * v57;
    unint64_t v60 = (char *)operator new(8 * v57);
    uint64_t v25 = v60;
    unint64_t v53 = &v60[8 * v58];
    long long v51 = v53;
    int64_t v61 = v49 - v26;
    if (v49 != v26)
    {
      long long v51 = &v53[v61 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v62 = v61 - 8;
      size_t v63 = &v60[8 * v58];
      uint64_t v64 = v26;
      if (v62 >= 0x38)
      {
        size_t v63 = &v60[8 * v58];
        uint64_t v64 = v26;
        if ((unint64_t)(v63 - v26) >= 0x20)
        {
          uint64_t v65 = (v62 >> 3) + 1;
          uint64_t v66 = 8 * (v65 & 0x3FFFFFFFFFFFFFFCLL);
          size_t v63 = &v53[v66];
          unint64_t v67 = (long long *)(v26 + 16);
          unint64_t v68 = &v60[8 * v58 + 16];
          uint64_t v69 = v65 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v70 = *v67;
            *((_OWORD *)v68 - 1) = *(v67 - 1);
            *(_OWORD *)unint64_t v68 = v70;
            v67 += 2;
            v68 += 32;
            v69 -= 4;
          }
          while (v69);
          if (v65 == (v65 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_67;
          }
          uint64_t v64 = &v26[v66];
        }
      }
      do
      {
        uint64_t v71 = *(void *)v64;
        v64 += 8;
        *(void *)size_t v63 = v71;
        v63 += 8;
      }
      while (v63 != v51);
    }
LABEL_67:
    uint64_t v27 = &v60[v59];
    operator delete(v26);
    goto LABEL_48;
  }
  int v50 = v26;
  long long v51 = v26 + 8;
LABEL_43:
  uint64_t v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v50;
  *(void *)(a1 + 16) = v51;
  *(void *)(a1 + 24) = v27;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_24B6F9EC8(void **a1, void *a2)
{
  unint64_t v4 = (char *)a1[1];
  if (v4 != *a1)
  {
    uint64_t v5 = (char *)a1[1];
    goto LABEL_25;
  }
  uint64_t v7 = a1[2];
  unint64_t v6 = a1[3];
  if (v7 >= v6)
  {
    uint64_t v13 = v6 - v4;
    BOOL v12 = v13 == 0;
    unint64_t v14 = v13 >> 2;
    if (v12) {
      unint64_t v14 = 1;
    }
    if (v14 >> 61) {
      sub_24B6BCD7C();
    }
    unint64_t v15 = (v14 + 3) >> 2;
    uint64_t v16 = 8 * v14;
    uint64_t v17 = (char *)operator new(8 * v14);
    uint64_t v5 = &v17[8 * v15];
    uint64_t v18 = &v17[v16];
    uint64_t v19 = v5;
    uint64_t v20 = v7 - v4;
    if (v7 != v4)
    {
      uint64_t v19 = &v5[v20 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v21 = v20 - 8;
      uint64_t v22 = &v17[8 * v15];
      uint64_t v23 = v4;
      if (v21 > 0x37)
      {
        unint64_t v24 = &v17[8 * v15];
        uint64_t v22 = v24;
        uint64_t v23 = v4;
        if ((unint64_t)(v24 - v4) >= 0x20)
        {
          uint64_t v25 = (v21 >> 3) + 1;
          uint64_t v26 = 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v22 = &v5[v26];
          uint64_t v27 = (long long *)(v4 + 16);
          unint64_t v28 = v24 + 16;
          uint64_t v29 = v25 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v30 = *v27;
            *(v28 - 1) = *(v27 - 1);
            *unint64_t v28 = v30;
            v27 += 2;
            v28 += 2;
            v29 -= 4;
          }
          while (v29);
          if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *a1 = v17;
            a1[1] = v5;
            a1[2] = v19;
            a1[3] = v18;
            goto LABEL_24;
          }
          uint64_t v23 = &v4[v26];
        }
      }
      do
      {
        uint64_t v31 = *(void *)v23;
        v23 += 8;
        *(void *)uint64_t v22 = v31;
        v22 += 8;
      }
      while (v22 != v19);
    }
    *a1 = v17;
    a1[1] = v5;
    a1[2] = v19;
    a1[3] = v18;
    if (!v4) {
      goto LABEL_25;
    }
LABEL_24:
    operator delete(v4);
    uint64_t v5 = (char *)a1[1];
    goto LABEL_25;
  }
  uint64_t v8 = (v6 - v7) >> 3;
  if (v8 >= -1) {
    uint64_t v9 = v8 + 1;
  }
  else {
    uint64_t v9 = v8 + 2;
  }
  uint64_t v10 = v9 >> 1;
  uint64_t v11 = &v7[8 * (v9 >> 1)];
  uint64_t v5 = &v11[-(v7 - v4)];
  if (v7 != v4)
  {
    memmove(&v11[-(v7 - v4)], v4, v7 - v4);
    unint64_t v4 = (char *)a1[2];
  }
  a1[1] = v5;
  a1[2] = &v4[8 * v10];
LABEL_25:
  *((void *)v5 - 1) = *a2;
  a1[1] = (char *)a1[1] - 8;
}

void sub_24B6FA070(char **a1, void *a2)
{
  unint64_t v4 = a1[2];
  if (v4 != a1[3]) {
    goto LABEL_23;
  }
  unint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  if (v5 > *a1)
  {
    uint64_t v7 = (v5 - *a1) >> 3;
    if (v7 >= -1) {
      uint64_t v8 = v7 + 1;
    }
    else {
      uint64_t v8 = v7 + 2;
    }
    uint64_t v9 = v8 >> 1;
    uint64_t v10 = -v9;
    uint64_t v11 = &v5[-8 * v9];
    int64_t v12 = v4 - v5;
    if (v4 != v5)
    {
      memmove(&v5[-8 * v9], a1[1], v4 - v5);
      unint64_t v4 = a1[1];
    }
    uint64_t v13 = &v4[8 * v10];
    unint64_t v4 = &v11[v12];
    a1[1] = v13;
    a1[2] = &v11[v12];
    goto LABEL_23;
  }
  unint64_t v14 = (v4 - v6) >> 2;
  if (v4 == v6) {
    unint64_t v14 = 1;
  }
  if (v14 >> 61) {
    sub_24B6BCD7C();
  }
  unint64_t v15 = v14 >> 2;
  uint64_t v16 = 8 * v14;
  uint64_t v17 = (char *)operator new(8 * v14);
  uint64_t v18 = &v17[8 * v15];
  int64_t v20 = v4 - v5;
  BOOL v19 = v4 == v5;
  unint64_t v4 = v18;
  if (!v19)
  {
    unint64_t v4 = &v18[v20 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v21 = v20 - 8;
    if ((unint64_t)(v20 - 8) < 0x38)
    {
      uint64_t v22 = &v17[8 * v15];
      goto LABEL_20;
    }
    uint64_t v23 = &v17[8 * v15];
    uint64_t v22 = v23;
    if ((unint64_t)(v23 - v5) < 0x20)
    {
      do
      {
LABEL_20:
        uint64_t v30 = *(void *)v5;
        v5 += 8;
        *(void *)uint64_t v22 = v30;
        v22 += 8;
      }
      while (v22 != v4);
      goto LABEL_21;
    }
    uint64_t v24 = (v21 >> 3) + 1;
    uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v22 = &v18[v25];
    uint64_t v26 = (long long *)(v5 + 16);
    uint64_t v27 = v23 + 16;
    uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v29 = *v26;
      *(v27 - 1) = *(v26 - 1);
      _OWORD *v27 = v29;
      v26 += 2;
      v27 += 2;
      v28 -= 4;
    }
    while (v28);
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
    {
      v5 += v25;
      goto LABEL_20;
    }
  }
LABEL_21:
  *a1 = v17;
  a1[1] = v18;
  a1[2] = v4;
  a1[3] = &v17[v16];
  if (v6)
  {
    operator delete(v6);
    unint64_t v4 = a1[2];
  }
LABEL_23:
  *(void *)unint64_t v4 = *a2;
  a1[2] += 8;
}

void sub_24B6FA1FC(std::locale *this)
{
  locale = (std::__shared_weak_count *)this[6].__locale_;
  if (locale && !atomic_fetch_add(&locale->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))locale->__on_zero_shared)(locale);
    std::__shared_weak_count::__release_weak(locale);
  }
  std::locale::~locale(this);
}

void sub_24B6FA278()
{
}

uint64_t sub_24B6FAAE4(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  BOOL v3 = a2;
  if (a2 == a3) {
    return (uint64_t)a2;
  }
  unint64_t v4 = a3;
  if (*a2 == 94) {
    operator new();
  }
  if (a2 != a3)
  {
    while (v3 != v4)
    {
      unint64_t v6 = v3;
      uint64_t v7 = (unsigned __int8 *)sub_24B701474(a1, v3, v4);
      if (v7 != v3)
      {
        BOOL v3 = (unsigned __int8 *)sub_24B701780(a1, v7, v4);
        if (v3 != v6) {
          continue;
        }
      }
      if (v6 + 1 == v4 && *v6 == 36) {
        operator new();
      }
      uint64_t v9 = sub_24B6F9974();
      return sub_24B6FAC84(v9);
    }
  }
  return (uint64_t)v4;
}

unsigned char *sub_24B6FAC84(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v6 = ((uint64_t (*)(void))loc_24B6FAE38)();
  if ((unsigned char *)v6 == a2) {
    goto LABEL_12;
  }
  do
  {
    uint64_t v7 = (unsigned char *)v6;
    uint64_t v6 = ((uint64_t (*)(uint64_t, uint64_t, unsigned char *))loc_24B6FAE38)(a1, v6, a3);
  }
  while ((unsigned char *)v6 != v7);
  if (v7 == a2) {
    goto LABEL_12;
  }
  if (v7 != a3)
  {
    if (*v7 == 124)
    {
      uint64_t v8 = v7 + 1;
      uint64_t v9 = ((uint64_t (*)(uint64_t, unsigned char *, unsigned char *))loc_24B6FAE38)(a1, v7 + 1, a3);
      if ((unsigned char *)v9 != v7 + 1)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = ((uint64_t (*)(uint64_t, uint64_t, unsigned char *))loc_24B6FAE38)(a1, v9, a3);
        }
        while (v9 != v10);
        if ((unsigned char *)v10 != v8) {
          operator new();
        }
      }
LABEL_12:
      sub_24B6F9974();
      JUMPOUT(0x24B6FAE38);
    }
    return v7;
  }
  return a3;
}

unsigned char *sub_24B6FB4FC(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 != a3) {
      operator new();
    }
    sub_24B6F9974();
    sub_24B6F9974();
    abort();
  }
  return a2;
}

char *sub_24B6FC498(uint64_t a1, char *a2, char *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v3 = *(_DWORD *)(a1 + 24) & 0x1F0;
  int v4 = *a2;
  if (v4 <= 62)
  {
    if (v4 == 42)
    {
      uint64_t v13 = a2 + 1;
      if (v3) {
        BOOL v14 = 1;
      }
      else {
        BOOL v14 = v13 == a3;
      }
      if (!v14 && *v13 == 63) {
        operator new();
      }
      operator new();
    }
    if (v4 == 43)
    {
      uint64_t v5 = a2 + 1;
      if (!v3 && v5 != a3 && *v5 == 63) {
        operator new();
      }
      operator new();
    }
    return a2;
  }
  if (v4 == 63)
  {
    unint64_t v15 = a2 + 1;
    if (v3) {
      BOOL v16 = 1;
    }
    else {
      BOOL v16 = v15 == a3;
    }
    if (!v16 && *v15 == 63) {
      operator new();
    }
    operator new();
  }
  if (v4 == 123)
  {
    uint64_t v6 = (unsigned __int8 *)(a2 + 1);
    if (a2 + 1 != a3)
    {
      int v7 = *v6;
      if ((v7 & 0xF8) == 0x30 || (v7 & 0xFE) == 0x38)
      {
        int v8 = v7 - 48;
        uint64_t v9 = (unsigned __int8 *)(a2 + 2);
        if (a2 + 2 == a3)
        {
LABEL_19:
          uint64_t v9 = (unsigned __int8 *)a3;
        }
        else
        {
          while (1)
          {
            int v10 = *v9;
            if ((v10 & 0xF8) != 0x30 && (v10 & 0xFE) != 0x38) {
              break;
            }
            if (v8 >= 214748364) {
              goto LABEL_69;
            }
            int v8 = v10 + 10 * v8 - 48;
            if (++v9 == (unsigned __int8 *)a3) {
              goto LABEL_19;
            }
          }
        }
        if (v9 != v6)
        {
          if (v9 == (unsigned __int8 *)a3) {
            goto LABEL_70;
          }
          int v11 = (char)*v9;
          if (v11 == 44)
          {
            uint64_t v18 = (char *)(v9 + 1);
            if (v9 + 1 != (unsigned __int8 *)a3)
            {
              int v19 = *v18;
              if (v19 == 125)
              {
                int64_t v20 = (char *)(v9 + 2);
                if (!v3 && v20 != a3 && *v20 == 63) {
                  sub_24B6FCE88();
                }
                operator new();
              }
              if ((v19 & 0xF8) != 0x30 && (v19 & 0xFE) != 0x38) {
                goto LABEL_70;
              }
              int v21 = v19 - 48;
              uint64_t v22 = (char *)(v9 + 2);
              if (v22 == a3)
              {
LABEL_58:
                uint64_t v22 = a3;
              }
              else
              {
                while (1)
                {
                  int v23 = *v22;
                  if ((v23 & 0xF8) != 0x30 && (v23 & 0xFE) != 0x38) {
                    break;
                  }
                  if (v21 >= 214748364) {
                    goto LABEL_69;
                  }
                  int v21 = v23 + 10 * v21 - 48;
                  if (++v22 == a3) {
                    goto LABEL_58;
                  }
                }
              }
              if (v22 == v18 || v22 == a3 || *v22 != 125)
              {
LABEL_70:
                sub_24B6F9974();
                sub_24B6FCD4C();
              }
              if (v21 >= v8)
              {
                uint64_t v24 = v22 + 1;
                if (v3 || v24 == a3 || *v24 != 63) {
                  operator new();
                }
LABEL_66:
                sub_24B6FCD4C();
              }
            }
          }
          else if (v11 == 125)
          {
            int64_t v12 = (char *)(v9 + 1);
            if (v3 || v12 == a3 || *v12 != 63) {
              operator new();
            }
            goto LABEL_66;
          }
        }
      }
    }
LABEL_69:
    sub_24B6F9974();
    goto LABEL_70;
  }
  return a2;
}

void sub_24B6FCD4C()
{
}

void sub_24B6FCE88()
{
}

uint64_t sub_24B6FCFC8(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -991;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_24B6FCFDC()
{
}

uint64_t sub_24B6FCFF4(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  if (*(unsigned __int8 *)(result + 52) == a2)
  {
    *(void *)(a3 + 80) = *(void *)(result + 16);
    return result;
  }
  *(void *)(a3 + 80) = *(void *)(result + 8);
  int v3 = *(_DWORD *)(result + 44);
  *(void *)(*(void *)(a3 + 56) + 16 * *(unsigned int *)(result + 40) + 8) = *(void *)(a3 + 16);
  int v4 = *(_DWORD *)(result + 48);
  if (v3 != v4)
  {
    uint64_t v5 = (v4 - 1);
    uint64_t v6 = (v3 - 1);
    uint64_t v7 = *(void *)(a3 + 24);
    uint64_t v8 = *(void *)(a3 + 32);
    uint64_t v9 = v5 - v6;
    if ((unint64_t)(v5 - v6) < 2) {
      goto LABEL_9;
    }
    unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v11 = v8 + 24 * v6 + 24;
    unint64_t v12 = v9 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      *(void *)(v11 - 24) = v7;
      *(void *)(v11 - 16) = v7;
      *(void *)uint64_t v11 = v7;
      *(void *)(v11 + 8) = v7;
      *(unsigned char *)(v11 - 8) = 0;
      *(unsigned char *)(v11 + 16) = 0;
      v11 += 48;
      v12 -= 2;
    }
    while (v12);
    if (v9 != v10)
    {
      v6 += v10;
LABEL_9:
      uint64_t v13 = v5 - v6;
      BOOL v14 = (unsigned char *)(v8 + 24 * v6 + 16);
      do
      {
        *((void *)v14 - 2) = v7;
        *((void *)v14 - 1) = v7;
        *BOOL v14 = 0;
        v14 += 24;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

uint64_t sub_24B6FD0B4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 40);
  uint64_t v3 = *(void *)(a2 + 56);
  int v4 = (unint64_t *)(v3 + 16 * v2);
  if (*(_DWORD *)a2 != -991)
  {
    unint64_t *v4 = 0;
    if (!*(void *)(result + 32))
    {
      *(_DWORD *)a2 = -994;
      goto LABEL_40;
    }
    if (*(void *)(result + 24))
    {
      *(_DWORD *)a2 = -994;
      *(void *)(a2 + 80) = *(void *)(result + 8);
      *(void *)(v3 + 16 * v2 + 8) = *(void *)(a2 + 16);
      int v24 = *(_DWORD *)(result + 44);
      int v25 = *(_DWORD *)(result + 48);
      if (v24 == v25) {
        return result;
      }
      uint64_t v26 = (v25 - 1);
      uint64_t v27 = (v24 - 1);
      uint64_t v28 = *(void *)(a2 + 24);
      uint64_t v29 = *(void *)(a2 + 32);
      uint64_t v30 = v26 - v27;
      if ((unint64_t)(v26 - v27) >= 2)
      {
        unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v32 = v29 + 24 * v27 + 24;
        unint64_t v33 = v30 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          *(void *)(v32 - 24) = v28;
          *(void *)(v32 - 16) = v28;
          *(void *)uint64_t v32 = v28;
          *(void *)(v32 + 8) = v28;
          *(unsigned char *)(v32 - 8) = 0;
          *(unsigned char *)(v32 + 16) = 0;
          v32 += 48;
          v33 -= 2;
        }
        while (v33);
        if (v30 == v31) {
          return result;
        }
        v27 += v31;
      }
      uint64_t v34 = v26 - v27;
      unint64_t v35 = (unsigned char *)(v29 + 24 * v27 + 16);
      do
      {
        *((void *)v35 - 2) = v28;
        *((void *)v35 - 1) = v28;
        unsigned char *v35 = 0;
        v35 += 24;
        --v34;
      }
      while (v34);
      return result;
    }
LABEL_38:
    *(_DWORD *)a2 = -992;
    return result;
  }
  unint64_t v5 = *v4 + 1;
  unint64_t *v4 = v5;
  unint64_t v6 = *(void *)(result + 24);
  unint64_t v7 = *(void *)(result + 32);
  BOOL v8 = v5 < v7;
  if (v5 < v7 && v5 >= v6) {
    BOOL v8 = v5 < v7 && *(void *)(v3 + 16 * v2 + 8) != *(void *)(a2 + 16);
  }
  if (v8 && v5 >= v6) {
    goto LABEL_38;
  }
  *(_DWORD *)a2 = -994;
  if (!v8)
  {
LABEL_40:
    *(void *)(a2 + 80) = *(void *)(result + 16);
    return result;
  }
  *(void *)(a2 + 80) = *(void *)(result + 8);
  *(void *)(v3 + 16 * v2 + 8) = *(void *)(a2 + 16);
  int v12 = *(_DWORD *)(result + 44);
  int v13 = *(_DWORD *)(result + 48);
  if (v12 == v13) {
    return result;
  }
  uint64_t v14 = (v13 - 1);
  uint64_t v15 = (v12 - 1);
  uint64_t v16 = *(void *)(a2 + 24);
  uint64_t v17 = *(void *)(a2 + 32);
  uint64_t v18 = v14 - v15;
  if ((unint64_t)(v14 - v15) < 2) {
    goto LABEL_24;
  }
  unint64_t v19 = v18 & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v20 = v17 + 24 * v15 + 24;
  unint64_t v21 = v18 & 0xFFFFFFFFFFFFFFFELL;
  do
  {
    *(void *)(v20 - 24) = v16;
    *(void *)(v20 - 16) = v16;
    *(void *)uint64_t v20 = v16;
    *(void *)(v20 + 8) = v16;
    *(unsigned char *)(v20 - 8) = 0;
    *(unsigned char *)(v20 + 16) = 0;
    v20 += 48;
    v21 -= 2;
  }
  while (v21);
  if (v18 != v19)
  {
    v15 += v19;
LABEL_24:
    uint64_t v22 = v14 - v15;
    int v23 = (unsigned char *)(v17 + 24 * v15 + 16);
    do
    {
      *((void *)v23 - 2) = v16;
      *((void *)v23 - 1) = v16;
      *int v23 = 0;
      v23 += 24;
      --v22;
    }
    while (v22);
  }
  return result;
}

void sub_24B6FD288(void *a1)
{
  *a1 = &unk_26FE9D1E8;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26FE9CEE8;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  JUMPOUT(0x24C5D7790);
}

void sub_24B6FD360(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B6FD3EC(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_24B6FD458(void *a1)
{
  *a1 = &unk_26FE9D1E8;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26FE9CEE8;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B6FD52C(void *a1)
{
  *a1 = &unk_26FE9D1E8;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26FE9CEE8;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

void *sub_24B6FD5E0(void *a1)
{
  *a1 = &unk_26FE9D1E8;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26FE9CEE8;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

uint64_t sub_24B6FD694(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  uint64_t v2 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1);
  *(void *)(v2 + 8) = *(void *)(a2 + 16);
  *(unsigned char *)(v2 + 16) = 1;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_24B6FD6CC(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B6FD758(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_24B6FD7C4(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(*(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1)) = *(void *)(a2 + 16);
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_24B6FD7F4(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B6FD880(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_24B6FD8EC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) && (*(unsigned char *)(a2 + 88) & 2) == 0
    || *(unsigned char *)(result + 16) && ((int v3 = *v2, v3 != 13) ? (v4 = v3 == 10) : (v4 = 1), v4))
  {
    *(_DWORD *)a2 = -994;
    *(void *)(a2 + 80) = *(void *)(result + 8);
  }
  else
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
  }
  return result;
}

void sub_24B6FD93C(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B6FD9C8(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_24B6FDA34(uint64_t result, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 92))
  {
    if (!*(unsigned char *)(result + 16)) {
      goto LABEL_12;
    }
    int v2 = *(unsigned __int8 *)(*(void *)(a2 + 16) - 1);
    if (v2 != 13 && v2 != 10) {
      goto LABEL_12;
    }
LABEL_11:
    *(_DWORD *)a2 = -994;
    *(void *)(a2 + 80) = *(void *)(result + 8);
    return result;
  }
  if (*(void *)(a2 + 16) == *(void *)(a2 + 8) && (*(unsigned char *)(a2 + 88) & 1) == 0) {
    goto LABEL_11;
  }
LABEL_12:
  *(_DWORD *)a2 = -993;
  *(void *)(a2 + 80) = 0;
  return result;
}

void sub_24B6FDA94(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B6FDB20(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_24B6FDB8C(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5, char a6)
{
  *(void *)a1 = &unk_26FE9D128;
  *(void *)(a1 + 8) = a3;
  uint64_t v11 = (const std::locale *)(a1 + 16);
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(unsigned char *)(a1 + 168) = a4;
  *(unsigned char *)(a1 + 169) = a5;
  *(unsigned char *)(a1 + 170) = a6;
  std::locale::locale(&v14, v11);
  std::locale::name(&v15, &v14);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
  {
    BOOL v12 = v15.__r_.__value_.__l.__size_ != 1 || *v15.__r_.__value_.__l.__data_ != 67;
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  else
  {
    BOOL v12 = SHIBYTE(v15.__r_.__value_.__r.__words[2]) != 1 || v15.__r_.__value_.__s.__data_[0] != 67;
  }
  std::locale::~locale(&v14);
  *(unsigned char *)(a1 + 171) = v12;
  return a1;
}

void sub_24B6FDCA8(uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (!*(unsigned char *)(a1 + 169))
  {
    unint64_t v5 = *(unsigned char **)(a1 + 48);
    unint64_t v12 = *(void *)(a1 + 56);
    if (*(unsigned char *)(a1 + 170))
    {
      if ((unint64_t)v5 < v12) {
        goto LABEL_22;
      }
      unint64_t v6 = *(unsigned char **)(a1 + 40);
      unint64_t v13 = v5 - v6;
      uint64_t v14 = v5 - v6 + 1;
      if (v14 >= 0)
      {
        unint64_t v15 = v12 - (void)v6;
        if (2 * v15 > v14) {
          uint64_t v14 = 2 * v15;
        }
        if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v16 = v14;
        }
        if (v16) {
          uint64_t v11 = operator new(v16);
        }
        else {
          uint64_t v11 = 0;
        }
        uint64_t v18 = (char *)v11 + v13;
        unint64_t v19 = (char *)v11 + v16;
        *((unsigned char *)v11 + v13) = v2;
        uint64_t v17 = (uint64_t)v11 + v13 + 1;
        if (v5 == v6) {
          goto LABEL_49;
        }
        if (v13 >= 8 && (unint64_t)(v6 - (unsigned char *)v11) >= 0x20)
        {
          if (v13 >= 0x20)
          {
            unint64_t v25 = v13 & 0xFFFFFFFFFFFFFFE0;
            unint64_t v35 = (long long *)(v5 - 16);
            BOOL v36 = (char *)v11 + v5 - 16 - v6;
            unint64_t v37 = v13 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v38 = *v35;
              *(v36 - 1) = *(v35 - 1);
              _OWORD *v36 = v38;
              v36 -= 2;
              v35 -= 2;
              v37 -= 32;
            }
            while (v37);
            if (v13 == v25) {
              goto LABEL_73;
            }
            if ((v13 & 0x18) == 0)
            {
              v18 -= v25;
              v5 -= v25;
              goto LABEL_80;
            }
          }
          else
          {
            unint64_t v25 = 0;
          }
          unint64_t v39 = v25 - (v13 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v40 = &v5[-v25 - 8];
          unint64_t v41 = (char *)(v40 - v6);
          do
          {
            uint64_t v42 = *(void *)v40;
            v40 -= 8;
            *(void *)&v41[(void)v11] = v42;
            v41 -= 8;
            v39 += 8;
          }
          while (v39);
          if (v13 == (v13 & 0xFFFFFFFFFFFFFFF8)) {
            goto LABEL_73;
          }
          v18 -= v13 & 0xFFFFFFFFFFFFFFF8;
          v5 -= v13 & 0xFFFFFFFFFFFFFFF8;
        }
LABEL_80:
        unint64_t v53 = v18 - 1;
        do
        {
          char v54 = *--v5;
          *v53-- = v54;
        }
        while (v5 != v6);
        goto LABEL_86;
      }
LABEL_90:
      abort();
    }
    if ((unint64_t)v5 < v12) {
      goto LABEL_22;
    }
    unint64_t v6 = *(unsigned char **)(a1 + 40);
    unint64_t v21 = v5 - v6;
    uint64_t v22 = v5 - v6 + 1;
    if (v22 < 0) {
      goto LABEL_90;
    }
    unint64_t v23 = v12 - (void)v6;
    if (2 * v23 > v22) {
      uint64_t v22 = 2 * v23;
    }
    if (v23 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v24 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v24 = v22;
    }
    if (v24) {
      uint64_t v11 = operator new(v24);
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v18 = (char *)v11 + v21;
    unint64_t v19 = (char *)v11 + v24;
    *((unsigned char *)v11 + v21) = v2;
    uint64_t v17 = (uint64_t)v11 + v21 + 1;
    if (v5 == v6) {
      goto LABEL_49;
    }
    if (v21 >= 8 && (unint64_t)(v6 - (unsigned char *)v11) >= 0x20)
    {
      if (v21 >= 0x20)
      {
        unint64_t v26 = v21 & 0xFFFFFFFFFFFFFFE0;
        uint64_t v43 = (long long *)(v5 - 16);
        int64_t v44 = (char *)v11 + v5 - 16 - v6;
        unint64_t v45 = v21 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v46 = *v43;
          *(v44 - 1) = *(v43 - 1);
          *int64_t v44 = v46;
          v44 -= 2;
          v43 -= 2;
          v45 -= 32;
        }
        while (v45);
        if (v21 == v26) {
          goto LABEL_73;
        }
        if ((v21 & 0x18) == 0)
        {
          v18 -= v26;
          v5 -= v26;
          goto LABEL_84;
        }
      }
      else
      {
        unint64_t v26 = 0;
      }
      unint64_t v47 = v26 - (v21 & 0xFFFFFFFFFFFFFFF8);
      uint64_t v48 = &v5[-v26 - 8];
      uint64_t v49 = (char *)(v48 - v6);
      do
      {
        uint64_t v50 = *(void *)v48;
        v48 -= 8;
        *(void *)&v49[(void)v11] = v50;
        v49 -= 8;
        v47 += 8;
      }
      while (v47);
      if (v21 == (v21 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_73;
      }
      v18 -= v21 & 0xFFFFFFFFFFFFFFF8;
      v5 -= v21 & 0xFFFFFFFFFFFFFFF8;
    }
LABEL_84:
    uint64_t v55 = v18 - 1;
    do
    {
      char v56 = *--v5;
      *v55-- = v56;
    }
    while (v5 != v6);
    goto LABEL_86;
  }
  char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
  unint64_t v5 = *(unsigned char **)(a1 + 48);
  unint64_t v4 = *(void *)(a1 + 56);
  if ((unint64_t)v5 < v4)
  {
LABEL_22:
    unsigned char *v5 = v2;
    uint64_t v17 = (uint64_t)(v5 + 1);
    goto LABEL_89;
  }
  unint64_t v6 = *(unsigned char **)(a1 + 40);
  unint64_t v7 = v5 - v6;
  uint64_t v8 = v5 - v6 + 1;
  if (v8 < 0) {
    goto LABEL_90;
  }
  unint64_t v9 = v4 - (void)v6;
  if (2 * v9 > v8) {
    uint64_t v8 = 2 * v9;
  }
  if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v10 = v8;
  }
  if (v10) {
    uint64_t v11 = operator new(v10);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v18 = (char *)v11 + v7;
  unint64_t v19 = (char *)v11 + v10;
  *((unsigned char *)v11 + v7) = v2;
  uint64_t v17 = (uint64_t)v11 + v7 + 1;
  if (v5 == v6)
  {
LABEL_49:
    uint64_t v11 = v18;
    goto LABEL_87;
  }
  if (v7 < 8 || (unint64_t)(v6 - (unsigned char *)v11) < 0x20) {
    goto LABEL_75;
  }
  if (v7 < 0x20)
  {
    unint64_t v20 = 0;
    goto LABEL_54;
  }
  unint64_t v20 = v7 & 0xFFFFFFFFFFFFFFE0;
  uint64_t v27 = (long long *)(v5 - 16);
  uint64_t v28 = (char *)v11 + v5 - 16 - v6;
  unint64_t v29 = v7 & 0xFFFFFFFFFFFFFFE0;
  do
  {
    long long v30 = *v27;
    *(v28 - 1) = *(v27 - 1);
    *uint64_t v28 = v30;
    v28 -= 2;
    v27 -= 2;
    v29 -= 32;
  }
  while (v29);
  if (v7 == v20) {
    goto LABEL_73;
  }
  if ((v7 & 0x18) != 0)
  {
LABEL_54:
    unint64_t v31 = v20 - (v7 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v32 = &v5[-v20 - 8];
    unint64_t v33 = (char *)(v32 - v6);
    do
    {
      uint64_t v34 = *(void *)v32;
      v32 -= 8;
      *(void *)&v33[(void)v11] = v34;
      v33 -= 8;
      v31 += 8;
    }
    while (v31);
    if (v7 != (v7 & 0xFFFFFFFFFFFFFFF8))
    {
      v18 -= v7 & 0xFFFFFFFFFFFFFFF8;
      v5 -= v7 & 0xFFFFFFFFFFFFFFF8;
      goto LABEL_75;
    }
LABEL_73:
    unint64_t v5 = v6;
    goto LABEL_87;
  }
  v18 -= v20;
  v5 -= v20;
LABEL_75:
  long long v51 = v18 - 1;
  do
  {
    char v52 = *--v5;
    *v51-- = v52;
  }
  while (v5 != v6);
LABEL_86:
  unint64_t v5 = *(unsigned char **)(a1 + 40);
LABEL_87:
  *(void *)(a1 + 40) = v11;
  *(void *)(a1 + 48) = v17;
  *(void *)(a1 + 56) = v19;
  if (v5) {
    operator delete(v5);
  }
LABEL_89:
  *(void *)(a1 + 48) = v17;
}

void sub_24B6FE0E8(uint64_t a1, uint64_t a2, unsigned char *__src, unsigned char *a4)
{
  size_t v4 = a4 - __src;
  if ((unint64_t)(a4 - __src) >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v4 <= 0x16)
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = (_BYTE)a4 - (_BYTE)__src;
    p_dst = &__dst;
    if (__src == a4) {
      goto LABEL_9;
    }
LABEL_8:
    memcpy(p_dst, __src, v4);
    p_dst = (std::string *)((char *)p_dst + v4);
    goto LABEL_9;
  }
  uint64_t v10 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v4 | 7) != 0x17) {
    uint64_t v10 = v4 | 7;
  }
  uint64_t v11 = v10 + 1;
  p_dst = (std::string *)operator new(v10 + 1);
  __dst.__r_.__value_.__l.__size_ = v4;
  __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  if (__src != a4) {
    goto LABEL_8;
  }
LABEL_9:
  p_dst->__r_.__value_.__s.__data_[0] = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__dst.__r_.__value_.__l.__size_) {
      goto LABEL_17;
    }
    unint64_t v12 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__dst.__r_.__value_.__s + 23)) {
      return;
    }
    unint64_t v12 = &__dst;
  }
  std::__get_collation_name(&v17, (const char *)v12);
  *(_OWORD *)a1 = *(_OWORD *)&v17.__r_.__value_.__l.__data_;
  unint64_t v13 = v17.__r_.__value_.__r.__words[2];
  *(void *)(a1 + 16) = *((void *)&v17.__r_.__value_.__l + 2);
  unint64_t v14 = HIBYTE(v13);
  if ((v14 & 0x80u) != 0) {
    unint64_t v14 = *(void *)(a1 + 8);
  }
  if (v14) {
    goto LABEL_17;
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__dst.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_17;
    }
  }
  else if (HIBYTE(__dst.__r_.__value_.__r.__words[2]) >= 3u)
  {
    return;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a2 + 16) + 32))(&v17);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(std::string *)a1 = v17;
  if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    int v15 = *(unsigned __int8 *)(a1 + 23);
    if (v15 != 12 && v15 != 1)
    {
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 23) = 0;
      goto LABEL_17;
    }
    goto LABEL_31;
  }
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 == 1 || v16 == 12)
  {
LABEL_31:
    std::string::operator=((std::string *)a1, &__dst);
    goto LABEL_17;
  }
  **(unsigned char **)a1 = 0;
  *(void *)(a1 + 8) = 0;
LABEL_17:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

unsigned char *sub_24B6FE2F8(int a1, unsigned char *a2, unsigned char *a3, std::string *this, uint64_t a5)
{
  if (a2 == a3)
  {
    sub_24B6F9974();
    goto LABEL_111;
  }
  switch(*a2)
  {
    case 'D':
      *(_DWORD *)(a5 + 164) |= 0x400u;
      return a2 + 1;
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'T':
    case 'U':
    case 'V':
    case 'X':
    case 'Y':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '^':
    case '_':
    case 'a':
    case 'c':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
    case 't':
    case 'u':
    case 'v':
      goto LABEL_6;
    case 'S':
      *(_DWORD *)(a5 + 164) |= 0x4000u;
      return a2 + 1;
    case 'W':
      *(_DWORD *)(a5 + 164) |= 0x500u;
      if (*(unsigned char *)(a5 + 169))
      {
        char v7 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a5 + 24) + 40))(*(void *)(a5 + 24), 95);
        char v8 = v7;
        uint64_t v10 = *(unsigned char **)(a5 + 72);
        unint64_t v9 = *(void *)(a5 + 80);
        if ((unint64_t)v10 < v9)
        {
          unsigned char *v10 = v7;
          *(void *)(a5 + 72) = v10 + 1;
          return a2 + 1;
        }
        unint64_t v19 = *(unsigned char **)(a5 + 64);
        unint64_t v20 = v10 - v19;
        uint64_t v21 = v10 - v19 + 1;
        if (v21 >= 0)
        {
          unint64_t v22 = v9 - (void)v19;
          if (2 * v22 > v21) {
            uint64_t v21 = 2 * v22;
          }
          if (v22 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v23 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v23 = v21;
          }
          if (v23) {
            size_t v24 = operator new(v23);
          }
          else {
            size_t v24 = 0;
          }
          unint64_t v25 = (char *)v24 + v20;
          unint64_t v26 = (char *)v24 + v23;
          *((unsigned char *)v24 + v20) = v8;
          uint64_t v27 = (uint64_t)v24 + v20 + 1;
          if (v10 == v19)
          {
            size_t v24 = (char *)v24 + v20;
LABEL_94:
            *(void *)(a5 + 64) = v24;
            *(void *)(a5 + 72) = v27;
            *(void *)(a5 + 80) = v26;
            if (v10) {
              operator delete(v10);
            }
            *(void *)(a5 + 72) = v27;
            return a2 + 1;
          }
          if (v20 >= 8 && (unint64_t)(v19 - (unsigned char *)v24) >= 0x20)
          {
            if (v20 >= 0x20)
            {
              unint64_t v28 = v20 & 0xFFFFFFFFFFFFFFE0;
              long long v38 = (long long *)(v10 - 16);
              unint64_t v39 = (char *)v24 + v10 - 16 - v19;
              unint64_t v40 = v20 & 0xFFFFFFFFFFFFFFE0;
              do
              {
                long long v41 = *v38;
                *(v39 - 1) = *(v38 - 1);
                *unint64_t v39 = v41;
                v39 -= 2;
                v38 -= 2;
                v40 -= 32;
              }
              while (v40);
              if (v20 == v28) {
                goto LABEL_72;
              }
              if ((v20 & 0x18) == 0)
              {
                v25 -= v28;
                v10 -= v28;
                goto LABEL_91;
              }
            }
            else
            {
              unint64_t v28 = 0;
            }
            unint64_t v42 = v28 - (v20 & 0xFFFFFFFFFFFFFFF8);
            uint64_t v43 = &v10[-v28 - 8];
            int64_t v44 = (char *)(v43 - v19);
            do
            {
              uint64_t v45 = *(void *)v43;
              v43 -= 8;
              *(void *)&v44[(void)v24] = v45;
              v44 -= 8;
              v42 += 8;
            }
            while (v42);
            if (v20 == (v20 & 0xFFFFFFFFFFFFFFF8))
            {
LABEL_72:
              uint64_t v10 = v19;
              goto LABEL_94;
            }
            v25 -= v20 & 0xFFFFFFFFFFFFFFF8;
            v10 -= v20 & 0xFFFFFFFFFFFFFFF8;
          }
LABEL_91:
          unint64_t v62 = v25 - 1;
          do
          {
            char v63 = *--v10;
            *v62-- = v63;
          }
          while (v10 != v19);
          uint64_t v10 = *(unsigned char **)(a5 + 64);
          goto LABEL_94;
        }
LABEL_111:
        abort();
      }
      unint64_t v12 = *(unsigned char **)(a5 + 72);
      unint64_t v11 = *(void *)(a5 + 80);
      if (!*(unsigned char *)(a5 + 170))
      {
        if ((unint64_t)v12 < v11) {
          goto LABEL_36;
        }
        unint64_t v13 = *(unsigned char **)(a5 + 64);
        unint64_t v29 = v12 - v13;
        uint64_t v30 = v12 - v13 + 1;
        if (v30 < 0) {
          goto LABEL_111;
        }
        unint64_t v31 = v11 - (void)v13;
        if (2 * v31 > v30) {
          uint64_t v30 = 2 * v31;
        }
        if (v31 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v32 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v32 = v30;
        }
        if (v32) {
          uint64_t v18 = operator new(v32);
        }
        else {
          uint64_t v18 = 0;
        }
        unint64_t v33 = (char *)v18 + v29;
        uint64_t v34 = (char *)v18 + v32;
        *((unsigned char *)v18 + v29) = 95;
        uint64_t v35 = (uint64_t)v18 + v29 + 1;
        if (v12 == v13) {
          goto LABEL_64;
        }
        if (v29 >= 8 && (unint64_t)(v13 - (unsigned char *)v18) >= 0x20)
        {
          if (v29 >= 0x20)
          {
            unint64_t v37 = v29 & 0xFFFFFFFFFFFFFFE0;
            char v54 = (long long *)(v12 - 16);
            uint64_t v55 = (char *)v18 + v12 - 16 - v13;
            unint64_t v56 = v29 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v57 = *v54;
              *(v55 - 1) = *(v54 - 1);
              _OWORD *v55 = v57;
              v55 -= 2;
              v54 -= 2;
              v56 -= 32;
            }
            while (v56);
            if (v29 == v37) {
              goto LABEL_89;
            }
            if ((v29 & 0x18) == 0)
            {
              v33 -= v37;
              v12 -= v37;
              goto LABEL_103;
            }
          }
          else
          {
            unint64_t v37 = 0;
          }
          unint64_t v58 = v37 - (v29 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v59 = &v12[-v37 - 8];
          unint64_t v60 = (char *)(v59 - v13);
          do
          {
            uint64_t v61 = *(void *)v59;
            v59 -= 8;
            *(void *)&v60[(void)v18] = v61;
            v60 -= 8;
            v58 += 8;
          }
          while (v58);
          if (v29 == (v29 & 0xFFFFFFFFFFFFFFF8)) {
            goto LABEL_89;
          }
          v33 -= v29 & 0xFFFFFFFFFFFFFFF8;
          v12 -= v29 & 0xFFFFFFFFFFFFFFF8;
        }
LABEL_103:
        uint64_t v66 = v33 - 1;
        do
        {
          char v67 = *--v12;
          *v66-- = v67;
        }
        while (v12 != v13);
        goto LABEL_105;
      }
      if ((unint64_t)v12 < v11)
      {
LABEL_36:
        unsigned char *v12 = 95;
        *(void *)(a5 + 72) = v12 + 1;
        return a2 + 1;
      }
      unint64_t v13 = *(unsigned char **)(a5 + 64);
      unint64_t v14 = v12 - v13;
      uint64_t v15 = v12 - v13 + 1;
      if (v15 < 0) {
        goto LABEL_111;
      }
      unint64_t v16 = v11 - (void)v13;
      if (2 * v16 > v15) {
        uint64_t v15 = 2 * v16;
      }
      if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v15;
      }
      if (v17) {
        uint64_t v18 = operator new(v17);
      }
      else {
        uint64_t v18 = 0;
      }
      unint64_t v33 = (char *)v18 + v14;
      uint64_t v34 = (char *)v18 + v17;
      *((unsigned char *)v18 + v14) = 95;
      uint64_t v35 = (uint64_t)v18 + v14 + 1;
      if (v12 != v13)
      {
        if (v14 < 8 || (unint64_t)(v13 - (unsigned char *)v18) < 0x20) {
          goto LABEL_99;
        }
        if (v14 < 0x20)
        {
          uint64_t v36 = 0;
LABEL_78:
          uint64_t v50 = v36 - (v14 & 0xFFFFFFFFFFFFFFF8);
          long long v51 = &v12[-v36 - 8];
          char v52 = (char *)(v51 - v13);
          do
          {
            uint64_t v53 = *(void *)v51;
            v51 -= 8;
            *(void *)&v52[(void)v18] = v53;
            v52 -= 8;
            v50 += 8;
          }
          while (v50);
          if (v14 != (v14 & 0xFFFFFFFFFFFFFFF8))
          {
            v33 -= v14 & 0xFFFFFFFFFFFFFFF8;
            v12 -= v14 & 0xFFFFFFFFFFFFFFF8;
            goto LABEL_99;
          }
          goto LABEL_89;
        }
        uint64_t v36 = v14 & 0xFFFFFFFFFFFFFFE0;
        long long v46 = (long long *)(v12 - 16);
        unint64_t v47 = (char *)v18 + v12 - 16 - v13;
        unint64_t v48 = v14 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v49 = *v46;
          *(v47 - 1) = *(v46 - 1);
          _OWORD *v47 = v49;
          v47 -= 2;
          v46 -= 2;
          v48 -= 32;
        }
        while (v48);
        if (v14 != v36)
        {
          if ((v14 & 0x18) == 0)
          {
            v33 -= v36;
            v12 -= v36;
LABEL_99:
            uint64_t v64 = v33 - 1;
            do
            {
              char v65 = *--v12;
              *v64-- = v65;
            }
            while (v12 != v13);
LABEL_105:
            unint64_t v12 = *(unsigned char **)(a5 + 64);
            goto LABEL_106;
          }
          goto LABEL_78;
        }
LABEL_89:
        unint64_t v12 = v13;
        goto LABEL_106;
      }
LABEL_64:
      uint64_t v18 = v33;
LABEL_106:
      *(void *)(a5 + 64) = v18;
      *(void *)(a5 + 72) = v35;
      *(void *)(a5 + 80) = v34;
      if (v12) {
        operator delete(v12);
      }
      *(void *)(a5 + 72) = v35;
      return a2 + 1;
    case 'b':
      std::string::operator=(this, 8);
      return a2 + 1;
    case 'd':
      *(_DWORD *)(a5 + 160) |= 0x400u;
      return a2 + 1;
    case 's':
      *(_DWORD *)(a5 + 160) |= 0x4000u;
      return a2 + 1;
    case 'w':
      *(_DWORD *)(a5 + 160) |= 0x500u;
      sub_24B6FDCA8(a5, 95);
      return a2 + 1;
    default:
      if (*a2)
      {
LABEL_6:
        JUMPOUT(0x24B6FF964);
      }
      std::string::operator=(this, 0);
      return a2 + 1;
  }
}

void sub_24B6FEC6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 169))
  {
    __int16 v10 = a2 | (unsigned __int16)((_WORD)a3 << 8);
    unint64_t v12 = *(char **)(a1 + 120);
    unint64_t v11 = *(void *)(a1 + 128);
    if (*(unsigned char *)(a1 + 170))
    {
      if ((unint64_t)v12 >= v11)
      {
        unint64_t v13 = *(char **)(a1 + 112);
        uint64_t v14 = v12 - v13;
        if (v12 - v13 <= -3) {
          goto LABEL_73;
        }
        uint64_t v15 = v14 >> 1;
        unint64_t v16 = v11 - (void)v13;
        if (v16 <= (v14 >> 1) + 1) {
          unint64_t v17 = v15 + 1;
        }
        else {
          unint64_t v17 = v16;
        }
        if (v16 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v18 = v17;
        }
        if (v18)
        {
          if (v18 < 0) {
            goto LABEL_74;
          }
          unint64_t v19 = operator new(2 * v18);
        }
        else
        {
          unint64_t v19 = 0;
        }
        uint64_t v43 = &v19[2 * v15];
        int64_t v44 = &v19[2 * v18];
        *uint64_t v43 = v10;
        unint64_t v9 = v43 + 1;
        if (v12 != v13)
        {
          unint64_t v45 = v12 - v13 - 2;
          if (v45 < 0x1E) {
            goto LABEL_77;
          }
          if (v12 - v19 - (v14 & 0xFFFFFFFFFFFFFFFELL) < 0x20) {
            goto LABEL_77;
          }
          uint64_t v46 = (v45 >> 1) + 1;
          unint64_t v47 = &v19[2 * v15 - 16];
          unint64_t v48 = v12 - 16;
          unint64_t v49 = v46 & 0xFFFFFFFFFFFFFFF0;
          do
          {
            long long v50 = *(_OWORD *)v48;
            *(v47 - 1) = *((_OWORD *)v48 - 1);
            _OWORD *v47 = v50;
            v47 -= 2;
            v48 -= 32;
            v49 -= 16;
          }
          while (v49);
          v43 -= v46 & 0xFFFFFFFFFFFFFFF0;
          v12 -= 2 * (v46 & 0xFFFFFFFFFFFFFFF0);
          if (v46 != (v46 & 0xFFFFFFFFFFFFFFF0))
          {
LABEL_77:
            do
            {
              __int16 v51 = *((_WORD *)v12 - 1);
              v12 -= 2;
              *--uint64_t v43 = v51;
            }
            while (v12 != v13);
LABEL_68:
            unint64_t v13 = *(char **)(a1 + 112);
            goto LABEL_70;
          }
          goto LABEL_70;
        }
        goto LABEL_69;
      }
    }
    else if ((unint64_t)v12 >= v11)
    {
      unint64_t v13 = *(char **)(a1 + 112);
      uint64_t v37 = v12 - v13;
      if (v12 - v13 <= -3) {
        goto LABEL_73;
      }
      uint64_t v38 = v37 >> 1;
      unint64_t v39 = v11 - (void)v13;
      if (v39 <= (v37 >> 1) + 1) {
        unint64_t v40 = v38 + 1;
      }
      else {
        unint64_t v40 = v39;
      }
      if (v39 >= 0x7FFFFFFFFFFFFFFELL) {
        uint64_t v41 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v41 = v40;
      }
      if (v41)
      {
        if (v41 < 0) {
          goto LABEL_74;
        }
        unint64_t v42 = operator new(2 * v41);
      }
      else
      {
        unint64_t v42 = 0;
      }
      uint64_t v43 = &v42[2 * v38];
      int64_t v44 = &v42[2 * v41];
      *uint64_t v43 = v10;
      unint64_t v9 = v43 + 1;
      if (v12 != v13)
      {
        unint64_t v52 = v12 - v13 - 2;
        if (v52 < 0x1E) {
          goto LABEL_78;
        }
        if (v12 - v42 - (v37 & 0xFFFFFFFFFFFFFFFELL) < 0x20) {
          goto LABEL_78;
        }
        uint64_t v53 = (v52 >> 1) + 1;
        char v54 = &v42[2 * v38 - 16];
        uint64_t v55 = v12 - 16;
        unint64_t v56 = v53 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          long long v57 = *(_OWORD *)v55;
          *(v54 - 1) = *((_OWORD *)v55 - 1);
          *char v54 = v57;
          v54 -= 2;
          v55 -= 32;
          v56 -= 16;
        }
        while (v56);
        v43 -= v53 & 0xFFFFFFFFFFFFFFF0;
        v12 -= 2 * (v53 & 0xFFFFFFFFFFFFFFF0);
        if (v53 != (v53 & 0xFFFFFFFFFFFFFFF0))
        {
LABEL_78:
          do
          {
            __int16 v58 = *((_WORD *)v12 - 1);
            v12 -= 2;
            *--uint64_t v43 = v58;
          }
          while (v12 != v13);
          goto LABEL_68;
        }
LABEL_70:
        *(void *)(a1 + 112) = v43;
        *(void *)(a1 + 120) = v9;
        *(void *)(a1 + 128) = v44;
        if (v13) {
          operator delete(v13);
        }
        goto LABEL_72;
      }
LABEL_69:
      unint64_t v13 = v12;
      goto LABEL_70;
    }
    *(_WORD *)unint64_t v12 = v10;
    unint64_t v9 = v12 + 2;
    goto LABEL_72;
  }
  unsigned __int8 v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
  __int16 v6 = v5 | (unsigned __int16)((*(unsigned __int16 (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a3) << 8);
  char v8 = *(char **)(a1 + 120);
  unint64_t v7 = *(void *)(a1 + 128);
  if ((unint64_t)v8 < v7)
  {
    *(_WORD *)char v8 = v6;
    unint64_t v9 = v8 + 2;
LABEL_72:
    *(void *)(a1 + 120) = v9;
    return;
  }
  unint64_t v20 = *(char **)(a1 + 112);
  uint64_t v21 = v8 - v20;
  if (v8 - v20 <= -3) {
LABEL_73:
  }
    abort();
  uint64_t v22 = v21 >> 1;
  unint64_t v23 = v7 - (void)v20;
  if (v23 <= (v21 >> 1) + 1) {
    unint64_t v24 = v22 + 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v23 >= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v25 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v25 = v24;
  }
  if (!v25)
  {
    unint64_t v26 = 0;
    goto LABEL_29;
  }
  if (v25 < 0) {
LABEL_74:
  }
    sub_24B6BCD7C();
  unint64_t v26 = operator new(2 * v25);
LABEL_29:
  uint64_t v27 = &v26[2 * v22];
  unint64_t v28 = &v26[2 * v25];
  _WORD *v27 = v6;
  unint64_t v29 = v27 + 1;
  if (v8 == v20)
  {
    unint64_t v20 = v8;
  }
  else
  {
    unint64_t v30 = v8 - v20 - 2;
    if (v30 < 0x1E) {
      goto LABEL_79;
    }
    if (v8 - v26 - (v21 & 0xFFFFFFFFFFFFFFFELL) < 0x20) {
      goto LABEL_79;
    }
    uint64_t v31 = (v30 >> 1) + 1;
    size_t v32 = &v26[2 * v22 - 16];
    unint64_t v33 = v8 - 16;
    unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      long long v35 = *(_OWORD *)v33;
      *(v32 - 1) = *((_OWORD *)v33 - 1);
      _OWORD *v32 = v35;
      v32 -= 2;
      v33 -= 32;
      v34 -= 16;
    }
    while (v34);
    v27 -= v31 & 0xFFFFFFFFFFFFFFF0;
    v8 -= 2 * (v31 & 0xFFFFFFFFFFFFFFF0);
    if (v31 != (v31 & 0xFFFFFFFFFFFFFFF0))
    {
LABEL_79:
      do
      {
        __int16 v36 = *((_WORD *)v8 - 1);
        v8 -= 2;
        *--uint64_t v27 = v36;
      }
      while (v8 != v20);
      unint64_t v20 = *(char **)(a1 + 112);
    }
  }
  *(void *)(a1 + 112) = v27;
  *(void *)(a1 + 120) = v29;
  *(void *)(a1 + 128) = v28;
  if (v20) {
    operator delete(v20);
  }
  *(void *)(a1 + 120) = v29;
}

void sub_24B6FF058(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  unint64_t v4 = a4 - a3;
  if ((unint64_t)(a4 - a3) >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  __int16 v6 = a3;
  if (v4 <= 0x16)
  {
    HIBYTE(v22) = (_BYTE)a4 - (_BYTE)a3;
    p_p = &__p;
    if (a3 == a4) {
      goto LABEL_18;
    }
LABEL_8:
    if (v4 < 0x20 || (unint64_t)(p_p - v6) < 0x20)
    {
      unint64_t v12 = p_p;
    }
    else
    {
      unint64_t v11 = v4 & 0xFFFFFFFFFFFFFFE0;
      unint64_t v12 = &p_p[v4 & 0xFFFFFFFFFFFFFFE0];
      unint64_t v13 = (long long *)(v6 + 16);
      uint64_t v14 = p_p + 16;
      unint64_t v15 = v4 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v16 = *v13;
        *(v14 - 1) = *(v13 - 1);
        *uint64_t v14 = v16;
        v13 += 2;
        v14 += 2;
        v15 -= 32;
      }
      while (v15);
      if (v4 == v11)
      {
        p_p += v4 & 0xFFFFFFFFFFFFFFE0;
        goto LABEL_18;
      }
      v6 += v11;
    }
    p_p = v12;
    do
    {
      char v17 = *v6++;
      *p_p++ = v17;
    }
    while (v6 != a4);
    goto LABEL_18;
  }
  uint64_t v9 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v4 | 7) != 0x17) {
    uint64_t v9 = v4 | 7;
  }
  uint64_t v10 = v9 + 1;
  p_p = operator new(v9 + 1);
  unint64_t v21 = v4;
  int64_t v22 = v10 | 0x8000000000000000;
  std::string __p = p_p;
  if (v6 != a4) {
    goto LABEL_8;
  }
LABEL_18:
  unsigned char *p_p = 0;
  unint64_t v18 = HIBYTE(v22);
  if (v22 >= 0) {
    unint64_t v19 = (char *)&__p;
  }
  else {
    unint64_t v19 = (char *)__p;
  }
  if (v22 < 0) {
    unint64_t v18 = v21;
  }
  (*(void (**)(void, char *, char *))(**(void **)(a2 + 16) + 32))(*(void *)(a2 + 16), v19, &v19[v18]);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p);
  }
}

char *sub_24B6FF1D0(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x555555555555555) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v6 = 0x555555555555555;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x555555555555555) {
      sub_24B6BCD7C();
    }
    unint64_t v7 = (char *)operator new(48 * v6);
  }
  else
  {
    unint64_t v7 = 0;
  }
  char v8 = &v7[48 * v2];
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  *(_OWORD *)char v8 = *(_OWORD *)a2;
  uint64_t v9 = &v7[48 * v6];
  long long v10 = *(_OWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_OWORD *)(v8 + 24) = v10;
  *((void *)v8 + 5) = *(void *)(a2 + 40);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  unint64_t v11 = v8 + 48;
  unint64_t v12 = (void **)*a1;
  unint64_t v13 = (void **)a1[1];
  if (v13 != *a1)
  {
    do
    {
      long long v14 = *((_OWORD *)v13 - 3);
      *((void *)v8 - 4) = *(v13 - 4);
      *((_OWORD *)v8 - 3) = v14;
      *(v13 - 5) = 0;
      *(v13 - 4) = 0;
      *(v13 - 6) = 0;
      long long v15 = *(_OWORD *)(v13 - 3);
      *((void *)v8 - 1) = *(v13 - 1);
      *(_OWORD *)(v8 - 24) = v15;
      v8 -= 48;
      *(v13 - 2) = 0;
      *(v13 - 1) = 0;
      *(v13 - 3) = 0;
      v13 -= 6;
    }
    while (v13 != v12);
    unint64_t v13 = (void **)*a1;
    long long v16 = (void **)a1[1];
    *a1 = v8;
    a1[1] = v11;
    a1[2] = v9;
    while (1)
    {
      if (v16 == v13) {
        goto LABEL_22;
      }
      if (*((char *)v16 - 1) < 0)
      {
        operator delete(*(v16 - 3));
        if ((*((char *)v16 - 25) & 0x80000000) == 0) {
          goto LABEL_14;
        }
      }
      else if ((*((char *)v16 - 25) & 0x80000000) == 0)
      {
        goto LABEL_14;
      }
      operator delete(*(v16 - 6));
LABEL_14:
      v16 -= 6;
    }
  }
  *a1 = v8;
  a1[1] = v11;
  a1[2] = v9;
LABEL_22:
  if (v13) {
    operator delete(v13);
  }
  return v11;
}

void sub_24B6FF36C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 24);
  if ((v1 & 1) == 0)
  {
    if ((v1 & 8) == 0) {
      operator new();
    }
    operator new();
  }
  operator new();
}

uint64_t sub_24B6FF4D8(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 16))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    *(void *)(a2 + 80) = *(void *)(result + 8);
  }
  return result;
}

void sub_24B6FF520(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B6FF5AC(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_24B6FF618(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 40))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    *(void *)(a2 + 80) = *(void *)(result + 8);
  }
  return result;
}

void sub_24B6FF660(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9D038;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x24C5D7790);
}

std::locale *sub_24B6FF70C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9D038;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

uint64_t sub_24B6FF798(uint64_t result, uint64_t a2)
{
  unint64_t v3 = *(char **)(a2 + 16);
  if (v3 == *(char **)(a2 + 24)
    || (uint64_t v4 = result,
        CFMutableDictionaryRef result = (*(uint64_t (**)(void, void))(**(void **)(result + 24) + 40))(*(void *)(result + 24), *v3), *(unsigned __int8 *)(v4 + 40) != result))
  {
    uint64_t v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    ++*(void *)(a2 + 16);
    uint64_t v5 = *(void *)(v4 + 8);
  }
  *(void *)(a2 + 80) = v5;
  return result;
}

void sub_24B6FF82C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9D008;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x24C5D7790);
}

std::locale *sub_24B6FF8D8(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9D008;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void sub_24B6FFD40(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = *(unsigned __int8 **)(a2 + 16);
  uint64_t v5 = *(unsigned __int8 **)(a2 + 24);
  if (v4 == v5)
  {
    uint64_t v11 = 0;
    int v12 = *(unsigned __int8 *)(a1 + 168);
    goto LABEL_208;
  }
  if (!*(unsigned char *)(a1 + 171) || v4 + 1 == v5) {
    goto LABEL_66;
  }
  unsigned __int8 v6 = *v4;
  __int16 v7 = v4[1];
  if (*(unsigned char *)(a1 + 169))
  {
    unsigned __int8 v6 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), (char)v6);
    __int16 v7 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), (char)v7);
  }
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 2;
  __int16 v8 = v6 | (unsigned __int16)(v7 << 8);
  LOWORD(__s.__r_.__value_.__l.__data_) = v8;
  __s.__r_.__value_.__s.__data_[2] = 0;
  std::__get_collation_name(&v148, (const char *)&__s);
  std::string __p = v148;
  std::string::size_type size = HIBYTE(v148.__r_.__value_.__r.__words[2]);
  int v10 = SHIBYTE(v148.__r_.__value_.__r.__words[2]);
  if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v148.__r_.__value_.__l.__size_;
  }
  if (size) {
    goto LABEL_9;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
  }
  else if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u)
  {
    goto LABEL_14;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 32) + 32))(&v148);
  if (v10 < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string __p = v148;
  if ((SHIBYTE(v148.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (HIBYTE(v148.__r_.__value_.__r.__words[2]) != 12 && HIBYTE(v148.__r_.__value_.__r.__words[2]) != 1)
    {
      __p.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      goto LABEL_9;
    }
    goto LABEL_153;
  }
  if (__p.__r_.__value_.__l.__size_ == 1 || __p.__r_.__value_.__l.__size_ == 12)
  {
LABEL_153:
    std::string::operator=(&__p, &__s);
    goto LABEL_9;
  }
  *__p.__r_.__value_.__l.__data_ = 0;
  __p.__r_.__value_.__l.__size_ = 0;
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
LABEL_14:
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
      goto LABEL_16;
    }
LABEL_66:
    int v39 = 0;
    uint64_t v11 = 1;
    goto LABEL_67;
  }
  std::string::size_type v41 = __p.__r_.__value_.__l.__size_;
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!v41) {
    goto LABEL_66;
  }
LABEL_16:
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v14 = *(void *)(a1 + 120) - v13;
  if (v14)
  {
    unint64_t v15 = v14 >> 1;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    long long v16 = (unsigned __int8 *)(v13 + 1);
    while (*(v16 - 1) != v6 || *v16 != v7)
    {
      v16 += 2;
      if (!--v15) {
        goto LABEL_24;
      }
    }
LABEL_289:
    int v12 = 1;
    uint64_t v11 = 2;
    goto LABEL_208;
  }
LABEL_24:
  if (!*(unsigned char *)(a1 + 170) || *(void *)(a1 + 88) == *(void *)(a1 + 96))
  {
    int v39 = 0;
    goto LABEL_160;
  }
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 2;
  __s.__r_.__value_.__s.__data_[0] = v6;
  __s.__r_.__value_.__s.__data_[1] = v7;
  __s.__r_.__value_.__s.__data_[2] = 0;
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 32) + 32))(&v148);
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  uint64_t v17 = *(void *)(a1 + 88);
  char v18 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
  uint64_t v19 = *(void *)(a1 + 96) - v17;
  if (v19)
  {
    __int16 v140 = v6 | (unsigned __int16)(v7 << 8);
    char v132 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
    unsigned __int8 v136 = v6;
    char v143 = v7;
    uint64_t v20 = 0;
    unint64_t v21 = v19 / 48;
    if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v22 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v22 = v148.__r_.__value_.__l.__size_;
    }
    if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v23 = &v148;
    }
    else {
      unint64_t v23 = (std::string *)v148.__r_.__value_.__r.__words[0];
    }
    if (v21 <= 1) {
      uint64_t v24 = 1;
    }
    else {
      uint64_t v24 = v19 / 48;
    }
    uint64_t v25 = (unsigned __int8 *)(v17 + 47);
    BOOL v26 = 1;
    do
    {
      int v27 = (char)*(v25 - 24);
      if (v27 >= 0) {
        size_t v28 = *(v25 - 24);
      }
      else {
        size_t v28 = *(void *)(v25 - 39);
      }
      if (v27 >= 0) {
        unint64_t v29 = (char *)(v25 - 47);
      }
      else {
        unint64_t v29 = *(char **)(v25 - 47);
      }
      if (v28 >= v22) {
        size_t v30 = v22;
      }
      else {
        size_t v30 = v28;
      }
      int v31 = memcmp(v23, v29, v30);
      BOOL v32 = v22 >= v28;
      if (v31) {
        BOOL v32 = v31 >= 0;
      }
      if (v32)
      {
        int v33 = (char)*v25;
        if (v33 >= 0) {
          size_t v34 = *v25;
        }
        else {
          size_t v34 = *(void *)(v25 - 15);
        }
        if (v33 >= 0) {
          long long v35 = (char *)(v25 - 23);
        }
        else {
          long long v35 = *(char **)(v25 - 23);
        }
        if (v22 >= v34) {
          size_t v36 = v34;
        }
        else {
          size_t v36 = v22;
        }
        int v37 = memcmp(v35, v23, v36);
        BOOL v38 = v34 >= v22;
        if (v37) {
          BOOL v38 = v37 >= 0;
        }
        if (v38)
        {
          int v39 = 1;
          int v40 = 5;
          goto LABEL_155;
        }
      }
      BOOL v26 = ++v20 < v21;
      v25 += 48;
    }
    while (v24 != v20);
    int v40 = 0;
    int v39 = 0;
LABEL_155:
    LOBYTE(v7) = v143;
    char v18 = v132;
    unsigned __int8 v6 = v136;
    __int16 v8 = v140;
  }
  else
  {
    BOOL v26 = 0;
    int v40 = 0;
    int v39 = 0;
  }
  if (v18 < 0) {
    operator delete(v148.__r_.__value_.__l.__data_);
  }
  if (!v26)
  {
LABEL_160:
    if (*(void *)(a1 + 136) == *(void *)(a1 + 144)) {
      goto LABEL_270;
    }
    *((unsigned char *)&__s.__r_.__value_.__s + 23) = 2;
    LOWORD(__s.__r_.__value_.__l.__data_) = v8;
    __s.__r_.__value_.__s.__data_[2] = 0;
    (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 32) + 32))(&v148);
    std::string::size_type v76 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
    if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v76 = v148.__r_.__value_.__l.__size_;
    }
    if (v76 != 1)
    {
      if (v76 == 12)
      {
        uint64_t v77 = &v148;
        if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v77 = (std::string *)v148.__r_.__value_.__r.__words[0];
        }
        v77->__r_.__value_.__s.__data_[11] = v77->__r_.__value_.__s.__data_[3];
      }
      else if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0)
      {
        *v148.__r_.__value_.__l.__data_ = 0;
        v148.__r_.__value_.__l.__size_ = 0;
      }
      else
      {
        v148.__r_.__value_.__s.__data_[0] = 0;
        *((unsigned char *)&v148.__r_.__value_.__s + 23) = 0;
      }
    }
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__s.__r_.__value_.__l.__data_);
    }
    uint64_t v98 = *(void *)(a1 + 136);
    int v99 = SHIBYTE(v148.__r_.__value_.__r.__words[2]);
    uint64_t v100 = *(void *)(a1 + 144) - v98;
    if (v100)
    {
      unint64_t v101 = v100 / 24;
      std::string::size_type v102 = v148.__r_.__value_.__l.__size_;
      if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v103 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v103 = v148.__r_.__value_.__l.__size_;
      }
      if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0)
      {
        int v135 = SHIBYTE(v148.__r_.__value_.__r.__words[2]);
        unsigned __int8 v139 = v6;
        char v146 = v7;
        int v142 = v39;
        uint64_t v112 = 0;
        uint64_t v113 = (const void *)v148.__r_.__value_.__r.__words[0];
        if (v101 <= 1) {
          uint64_t v114 = 1;
        }
        else {
          uint64_t v114 = v100 / 24;
        }
        BOOL v106 = 1;
        do
        {
          uint64_t v115 = *(unsigned __int8 *)(v98 + 23);
          int v116 = (char)v115;
          if ((v115 & 0x80u) != 0) {
            uint64_t v115 = *(void *)(v98 + 8);
          }
          if (v103 == v115)
          {
            unint64_t v117 = v101;
            id v118 = v116 >= 0 ? (const void *)v98 : *(const void **)v98;
            int v119 = memcmp(v113, v118, v102);
            unint64_t v101 = v117;
            if (!v119)
            {
              int v39 = 1;
              int v40 = 5;
              goto LABEL_251;
            }
          }
          BOOL v106 = ++v112 < v101;
          v98 += 24;
        }
        while (v114 != v112);
        int v40 = 0;
        int v39 = v142;
LABEL_251:
        LOBYTE(v7) = v146;
        int v99 = v135;
        unsigned __int8 v6 = v139;
LABEL_265:
        if (v99 < 0) {
          operator delete(v148.__r_.__value_.__l.__data_);
        }
        if (v106) {
          goto LABEL_268;
        }
LABEL_270:
        if ((v6 & 0x80) != 0)
        {
          int v131 = *(_DWORD *)(a1 + 164);
        }
        else
        {
          int v128 = *(_DWORD *)(a1 + 160);
          uint64_t v129 = *(void *)(*(void *)(a1 + 24) + 16);
          int v130 = *(_DWORD *)(v129 + 4 * v6);
          if (((v130 & v128) != 0 || v6 == 95 && (v128 & 0x80) != 0)
            && (v7 & 0x80) == 0
            && ((*(_DWORD *)(v129 + 4 * v7) & v128) != 0
             || (v128 & 0x80) != 0 && v7 == 95))
          {
            goto LABEL_289;
          }
          int v131 = *(_DWORD *)(a1 + 164);
          if ((v130 & v131) != 0 || v6 == 95 && (v131 & 0x80) != 0) {
            goto LABEL_287;
          }
        }
        if ((v7 & 0x80) != 0) {
          goto LABEL_289;
        }
        if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v7) & v131) == 0)
        {
          int v12 = 1;
          if (v7 != 95 || (v131 & 0x80) == 0)
          {
LABEL_288:
            uint64_t v11 = 2;
            goto LABEL_208;
          }
        }
LABEL_287:
        int v12 = v39;
        goto LABEL_288;
      }
      if (*((unsigned char *)&v148.__r_.__value_.__s + 23))
      {
        uint64_t v104 = 0;
        if (v101 <= 1) {
          uint64_t v105 = 1;
        }
        else {
          uint64_t v105 = v100 / 24;
        }
        BOOL v106 = 1;
        do
        {
          uint64_t v107 = (unsigned __int8 *)(v98 + 24 * v104);
          uint64_t v108 = v107[23];
          int v109 = (char)v108;
          if ((v108 & 0x80u) != 0) {
            uint64_t v108 = *((void *)v107 + 1);
          }
          if (v103 == v108)
          {
            if (v109 < 0) {
              uint64_t v107 = *(unsigned __int8 **)v107;
            }
            uint64_t v110 = &v148;
            uint64_t v111 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
            while (v110->__r_.__value_.__s.__data_[0] == *v107)
            {
              uint64_t v110 = (std::string *)((char *)v110 + 1);
              ++v107;
              if (!--v111) {
                goto LABEL_236;
              }
            }
          }
          BOOL v106 = ++v104 < v101;
        }
        while (v104 != v105);
      }
      else
      {
        uint64_t v120 = *(unsigned __int8 *)(v98 + 23);
        if ((v120 & 0x80u) != 0) {
          uint64_t v120 = *(void *)(v98 + 8);
        }
        if (v120 == HIBYTE(v148.__r_.__value_.__r.__words[2])) {
          goto LABEL_289;
        }
        unint64_t v121 = 0;
        if (v101 <= 1) {
          uint64_t v122 = 1;
        }
        else {
          uint64_t v122 = v101;
        }
        uint64_t v123 = v122 - 1;
        uint64_t v124 = (uint64_t *)(v98 + 32);
        while (v123 != v121)
        {
          ++v121;
          uint64_t v125 = *((unsigned __int8 *)v124 + 15);
          uint64_t v127 = *v124;
          v124 += 3;
          uint64_t v126 = v127;
          if ((v125 & 0x80u) != 0) {
            uint64_t v125 = v126;
          }
          if (v103 == v125)
          {
            BOOL v106 = v121 < v101;
LABEL_236:
            int v39 = 1;
            int v40 = 5;
            goto LABEL_265;
          }
        }
      }
    }
    BOOL v106 = 0;
    int v40 = 0;
    goto LABEL_265;
  }
LABEL_268:
  if (v40) {
    goto LABEL_287;
  }
  uint64_t v11 = 2;
LABEL_67:
  unsigned __int8 v42 = **(unsigned char **)(v2 + 16);
  if (*(unsigned char *)(a1 + 169)) {
    unsigned __int8 v42 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), (char)v42);
  }
  uint64_t v43 = *(unsigned __int8 **)(a1 + 40);
  unint64_t v44 = *(void *)(a1 + 48) - (void)v43;
  if (v44)
  {
    if (v44 <= 1) {
      unint64_t v44 = 1;
    }
    while (1)
    {
      int v45 = *v43++;
      if (v45 == v42) {
        break;
      }
      if (!--v44) {
        goto LABEL_74;
      }
    }
LABEL_206:
    int v39 = 1;
    goto LABEL_207;
  }
LABEL_74:
  unsigned int v46 = *(_DWORD *)(a1 + 164);
  if (v46 || *(void *)(a1 + 64) != *(void *)(a1 + 72))
  {
    if ((v42 & 0x80) != 0 || (*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v42) & v46) == 0) {
      int v47 = (v42 == 95) & (v46 >> 7);
    }
    else {
      LOBYTE(v47) = 1;
    }
    unint64_t v48 = *(void **)(a1 + 72);
    unint64_t v49 = memchr(*(void **)(a1 + 64), (char)v42, (size_t)v48 - *(void *)(a1 + 64));
    long long v50 = v49 ? v49 : v48;
    if ((v47 & 1) == 0 && v50 == v48) {
      goto LABEL_206;
    }
  }
  uint64_t v51 = *(void *)(a1 + 88);
  uint64_t v52 = *(void *)(a1 + 96);
  if (v51 != v52)
  {
    int v141 = v39;
    if (*(unsigned char *)(a1 + 170))
    {
      *((unsigned char *)&__s.__r_.__value_.__s + 23) = 1;
      LOWORD(__s.__r_.__value_.__l.__data_) = v42;
      (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 32) + 32))(&v148);
      if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__s.__r_.__value_.__l.__data_);
      }
      uint64_t v51 = *(void *)(a1 + 88);
      unsigned int v53 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
      uint64_t v54 = *(void *)(a1 + 96) - v51;
      if (v54) {
        goto LABEL_90;
      }
    }
    else
    {
      unsigned int v53 = 1;
      *((unsigned char *)&v148.__r_.__value_.__s + 23) = 1;
      LOWORD(v148.__r_.__value_.__l.__data_) = v42;
      uint64_t v54 = v52 - v51;
      if (v54)
      {
LABEL_90:
        uint64_t v144 = v11;
        uint64_t v137 = v2;
        uint64_t v55 = 0;
        unint64_t v56 = v54 / 48;
        char v133 = v53;
        if ((v53 & 0x80u) == 0) {
          std::string::size_type v57 = v53;
        }
        else {
          std::string::size_type v57 = v148.__r_.__value_.__l.__size_;
        }
        if ((v53 & 0x80u) == 0) {
          __int16 v58 = &v148;
        }
        else {
          __int16 v58 = (std::string *)v148.__r_.__value_.__r.__words[0];
        }
        if (v56 <= 1) {
          uint64_t v59 = 1;
        }
        else {
          uint64_t v59 = v54 / 48;
        }
        unint64_t v60 = (unsigned __int8 *)(v51 + 47);
        BOOL v61 = 1;
        do
        {
          int v62 = (char)*(v60 - 24);
          if (v62 >= 0) {
            size_t v63 = *(v60 - 24);
          }
          else {
            size_t v63 = *(void *)(v60 - 39);
          }
          if (v62 >= 0) {
            uint64_t v64 = (char *)(v60 - 47);
          }
          else {
            uint64_t v64 = *(char **)(v60 - 47);
          }
          if (v63 >= v57) {
            size_t v65 = v57;
          }
          else {
            size_t v65 = v63;
          }
          int v66 = memcmp(v58, v64, v65);
          BOOL v67 = v57 >= v63;
          if (v66) {
            BOOL v67 = v66 >= 0;
          }
          if (v67)
          {
            int v68 = (char)*v60;
            if (v68 >= 0) {
              size_t v69 = *v60;
            }
            else {
              size_t v69 = *(void *)(v60 - 15);
            }
            if (v68 >= 0) {
              long long v70 = (char *)(v60 - 23);
            }
            else {
              long long v70 = *(char **)(v60 - 23);
            }
            if (v57 >= v69) {
              size_t v71 = v69;
            }
            else {
              size_t v71 = v57;
            }
            int v72 = memcmp(v70, v58, v71);
            BOOL v73 = v69 >= v57;
            if (v72) {
              BOOL v73 = v72 >= 0;
            }
            if (v73)
            {
              int v39 = 1;
              uint64_t v2 = v137;
              goto LABEL_128;
            }
          }
          BOOL v61 = ++v55 < v56;
          v60 += 48;
        }
        while (v59 != v55);
        uint64_t v2 = v137;
        int v39 = v141;
LABEL_128:
        uint64_t v11 = v144;
        if ((v133 & 0x80) == 0) {
          goto LABEL_130;
        }
        goto LABEL_129;
      }
    }
    BOOL v61 = 0;
    if ((v53 & 0x80) == 0)
    {
LABEL_130:
      if (v61) {
        goto LABEL_207;
      }
      goto LABEL_131;
    }
LABEL_129:
    operator delete(v148.__r_.__value_.__l.__data_);
    goto LABEL_130;
  }
LABEL_131:
  if (*(void *)(a1 + 136) == *(void *)(a1 + 144)) {
    goto LABEL_201;
  }
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 1;
  LOWORD(__s.__r_.__value_.__l.__data_) = v42;
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 32) + 32))(&v148);
  std::string::size_type v74 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
  if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v74 = v148.__r_.__value_.__l.__size_;
  }
  if (v74 != 1)
  {
    if (v74 == 12)
    {
      BOOL v75 = &v148;
      if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        BOOL v75 = (std::string *)v148.__r_.__value_.__r.__words[0];
      }
      v75->__r_.__value_.__s.__data_[11] = v75->__r_.__value_.__s.__data_[3];
    }
    else if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0)
    {
      *v148.__r_.__value_.__l.__data_ = 0;
      v148.__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      v148.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&v148.__r_.__value_.__s + 23) = 0;
    }
  }
  uint64_t v145 = v11;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  uint64_t v78 = *(void *)(a1 + 136);
  uint64_t v79 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
  uint64_t v80 = *(void *)(a1 + 144) - v78;
  if (!v80)
  {
    if ((*((unsigned char *)&v148.__r_.__value_.__s + 23) & 0x80) != 0) {
      operator delete(v148.__r_.__value_.__l.__data_);
    }
    uint64_t v11 = v145;
LABEL_201:
    if ((v42 & 0x80) != 0) {
      goto LABEL_207;
    }
    unsigned int v94 = *(_DWORD *)(a1 + 160);
    if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v42) & v94) == 0)
    {
      int v95 = (v94 >> 7) & 1;
      if (v42 != 95) {
        int v95 = 0;
      }
      if (v95 != 1) {
        goto LABEL_207;
      }
    }
    goto LABEL_206;
  }
  uint64_t v81 = 0;
  unint64_t v82 = v80 / 24;
  long long v83 = *(_OWORD *)&v148.__r_.__value_.__l.__data_;
  if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v84 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v84 = v148.__r_.__value_.__l.__size_;
  }
  if (v82 <= 1) {
    uint64_t v85 = 1;
  }
  else {
    uint64_t v85 = v80 / 24;
  }
  BOOL v86 = 1;
  while (1)
  {
    uint64_t v88 = v78 + 24 * v81;
    uint64_t v89 = *(unsigned __int8 *)(v88 + 23);
    int v90 = (char)v89;
    if ((v89 & 0x80u) != 0) {
      uint64_t v89 = *(void *)(v88 + 8);
    }
    if (v84 != v89) {
      goto LABEL_182;
    }
    uint64_t v91 = v90 >= 0 ? (unsigned __int8 *)(v78 + 24 * v81) : *(unsigned __int8 **)v88;
    if ((v79 & 0x80) == 0) {
      break;
    }
    uint64_t v134 = v85;
    unint64_t v138 = v82;
    int v87 = memcmp((const void *)v83, v91, *((size_t *)&v83 + 1));
    uint64_t v85 = v134;
    unint64_t v82 = v138;
    if (!v87)
    {
      int v39 = 1;
      uint64_t v11 = v145;
      goto LABEL_195;
    }
LABEL_182:
    BOOL v86 = ++v81 < v82;
    if (v81 == v85)
    {
      uint64_t v11 = v145;
      if ((v79 & 0x80) == 0)
      {
LABEL_196:
        if (!v86) {
          goto LABEL_201;
        }
        goto LABEL_207;
      }
LABEL_195:
      operator delete(v148.__r_.__value_.__l.__data_);
      goto LABEL_196;
    }
  }
  if (v79)
  {
    unint64_t v92 = &v148;
    uint64_t v93 = v79;
    while (v92->__r_.__value_.__s.__data_[0] == *v91)
    {
      unint64_t v92 = (std::string *)((char *)v92 + 1);
      ++v91;
      if (!--v93)
      {
        int v39 = 1;
        uint64_t v11 = v145;
        if ((v79 & 0x80) == 0) {
          goto LABEL_196;
        }
        goto LABEL_195;
      }
    }
    goto LABEL_182;
  }
  int v39 = 1;
  uint64_t v11 = v145;
  if (!v86) {
    goto LABEL_201;
  }
LABEL_207:
  int v12 = v39;
LABEL_208:
  if (v12 == *(unsigned __int8 *)(a1 + 168))
  {
    uint64_t v96 = 0;
    int v97 = -993;
  }
  else
  {
    *(void *)(v2 + 16) += v11;
    uint64_t v96 = *(void *)(a1 + 8);
    int v97 = -995;
  }
  *(_DWORD *)uint64_t v2 = v97;
  *(void *)(v2 + 80) = v96;
}

void sub_24B700A28(std::locale *a1)
{
  sub_24B700A60(a1);
  JUMPOUT(0x24C5D7790);
}

std::locale *sub_24B700A60(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9D128;
  locale = a1[17].__locale_;
  if (locale)
  {
    unint64_t v3 = a1[18].__locale_;
    uint64_t v4 = a1[17].__locale_;
    if (v3 != locale)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*((void **)v3 - 3));
        }
        unint64_t v3 = (std::locale::__imp *)((char *)v3 - 24);
      }
      while (v3 != locale);
      uint64_t v4 = a1[17].__locale_;
    }
    a1[18].__locale_ = locale;
    operator delete(v4);
  }
  uint64_t v5 = a1[14].__locale_;
  if (v5)
  {
    a1[15].__locale_ = v5;
    operator delete(v5);
  }
  unsigned __int8 v6 = a1[11].__locale_;
  if (v6)
  {
    __int16 v7 = a1[12].__locale_;
    __int16 v8 = a1[11].__locale_;
    if (v7 == v6)
    {
LABEL_21:
      a1[12].__locale_ = v6;
      operator delete(v8);
      goto LABEL_22;
    }
    while (1)
    {
      if (*((char *)v7 - 1) < 0)
      {
        operator delete(*((void **)v7 - 3));
        if (*((char *)v7 - 25) < 0) {
LABEL_19:
        }
          operator delete(*((void **)v7 - 6));
      }
      else if (*((char *)v7 - 25) < 0)
      {
        goto LABEL_19;
      }
      __int16 v7 = (std::locale::__imp *)((char *)v7 - 48);
      if (v7 == v6)
      {
        __int16 v8 = a1[11].__locale_;
        goto LABEL_21;
      }
    }
  }
LABEL_22:
  uint64_t v9 = a1[8].__locale_;
  if (v9)
  {
    a1[9].__locale_ = v9;
    operator delete(v9);
  }
  int v10 = a1[5].__locale_;
  if (v10)
  {
    a1[6].__locale_ = v10;
    operator delete(v10);
  }
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  uint64_t v11 = a1[1].__locale_;
  if (v11) {
    (*(void (**)(std::locale::__imp *))(*(void *)v11 + 8))(v11);
  }
  return a1;
}

uint64_t sub_24B700BD8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned char **)(a2 + 16);
  if (v2 == *(unsigned char **)(a2 + 24) || !*v2)
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    *(void *)(a2 + 80) = *(void *)(result + 8);
  }
  return result;
}

void sub_24B700C18(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B700CA4(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_24B700D10(uint64_t a1, unsigned __int8 a2)
{
  if (((a2 & 0xF8) == 0x30 || (a2 & 0xFE) == 0x38) && a2 - 49 <= 8)
  {
    if (a2 - 48 <= *(_DWORD *)(a1 + 28)) {
      sub_24B700D74(a1);
    }
    uint64_t v3 = sub_24B6F9974();
    sub_24B700D74(v3);
  }
  return 0;
}

void sub_24B700D74(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 24);
  if ((v1 & 1) == 0)
  {
    if ((v1 & 8) == 0) {
      operator new();
    }
    operator new();
  }
  operator new();
}

void sub_24B700EA4(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 16);
  uint64_t v3 = *(void *)(a2 + 32);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a2 + 40) - v3) >> 3) < v2)
  {
    uint64_t v11 = (void *)sub_24B6F9974();
    sub_24B700F64(v11);
  }
  else
  {
    unsigned int v5 = v2 - 1;
    if (*(unsigned char *)(v3 + 24 * v5 + 16)
      && (uint64_t v7 = v3 + 24 * v5,
          int64_t v8 = *(void *)(v7 + 8) - *(void *)v7,
          uint64_t v9 = *(void *)(a2 + 16),
          *(void *)(a2 + 24) - v9 >= v8)
      && !memcmp(*(const void **)v7, *(const void **)(a2 + 16), v8))
    {
      *(_DWORD *)a2 = -994;
      *(void *)(a2 + 16) = v9 + v8;
      uint64_t v10 = *(void *)(a1 + 8);
    }
    else
    {
      uint64_t v10 = 0;
      *(_DWORD *)a2 = -993;
    }
    *(void *)(a2 + 80) = v10;
  }
}

void sub_24B700F64(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B700FF0(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_24B70105C(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 40) - 1;
  uint64_t v3 = *(void *)(a2 + 32);
  if (!*(unsigned char *)(v3 + 24 * v2 + 16)
    || (uint64_t v4 = (unsigned __int8 **)(v3 + 24 * v2),
        unsigned int v5 = *v4,
        uint64_t v6 = v4[1] - *v4,
        uint64_t v7 = *(void *)(a2 + 16),
        *(void *)(a2 + 24) - v7 < v6))
  {
LABEL_3:
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
    return result;
  }
  if (v6 >= 1)
  {
    uint64_t v8 = v6;
    uint64_t v9 = *(unsigned __int8 **)(a2 + 16);
    do
    {
      int v11 = *v5++;
      int v10 = v11;
      int v12 = *v9++;
      if (v10 != v12) {
        goto LABEL_3;
      }
    }
    while (--v8);
  }
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 16) = v7 + v6;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_24B7010EC(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9D0C8;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x24C5D7790);
}

std::locale *sub_24B701198(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9D0C8;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

uint64_t sub_24B701224(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 40) - 1);
  if (*(unsigned char *)(v3 + 16))
  {
    uint64_t v4 = *(void *)(v3 + 8) - *(void *)v3;
    uint64_t v5 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v5 >= v4)
    {
      uint64_t v7 = result;
      if (v4 < 1)
      {
LABEL_9:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v5 + v4;
        uint64_t v6 = *(void *)(v7 + 8);
        goto LABEL_10;
      }
      uint64_t v8 = 0;
      while (1)
      {
        int v9 = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)v3 + v8));
        CFMutableDictionaryRef result = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)(a2 + 16) + v8));
        if (v9 != result) {
          break;
        }
        if (v4 == ++v8)
        {
          uint64_t v5 = *(void *)(a2 + 16);
          goto LABEL_9;
        }
      }
    }
  }
  uint64_t v6 = 0;
  *(_DWORD *)a2 = -993;
LABEL_10:
  *(void *)(a2 + 80) = v6;
  return result;
}

void sub_24B70133C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9D098;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x24C5D7790);
}

std::locale *sub_24B7013E8(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9D098;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

uint64_t sub_24B701474(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    uint64_t v7 = a2 + 1;
    int v6 = *a2;
    if (a2 + 1 != a3 || v6 != 36)
    {
      if ((v6 - 46) > 0x2E || ((1 << (v6 - 46)) & 0x600000000001) == 0) {
        sub_24B6FF36C(a1);
      }
      if (v7 == a3 || v6 != 92)
      {
        if (v6 == 46) {
          operator new();
        }
      }
      else
      {
        unsigned int v13 = (char)*v7 - 36;
        if (v13 <= 0x3A && ((1 << v13) & 0x580000000000441) != 0) {
          sub_24B6FF36C(a1);
        }
      }
    }
  }
  uint64_t v8 = sub_24B6FB4FC(a1, a2, a3);
  int v9 = v8;
  if (v8 != a2 || v8 == a3) {
    return (uint64_t)v9;
  }
  if (a2 + 1 == a3 || *a2 != 92) {
    return (uint64_t)a2;
  }
  int v10 = a2[1];
  if (v10 == 40)
  {
    uint64_t v11 = (uint64_t)(a2 + 2);
    if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
      operator new();
    }
    do
    {
      if ((unsigned __int8 *)v11 == a3) {
        goto LABEL_38;
      }
      uint64_t v14 = (unsigned char *)v11;
      unint64_t v15 = (unsigned __int8 *)sub_24B701474(a1, v11, a3);
      if (v15 == (unsigned __int8 *)v11) {
        break;
      }
      uint64_t v11 = sub_24B701780(a1, v15, a3);
    }
    while ((unsigned char *)v11 != v14);
    if (v14 + 1 == a3 || *v14 != 92 || v14[1] != 41)
    {
LABEL_38:
      sub_24B6F9974();
      goto LABEL_39;
    }
    int v9 = &v14[2 * (v14[1] == 41)];
    if ((*(unsigned char *)(a1 + 24) & 2) == 0) {
      operator new();
    }
    return (uint64_t)v9;
  }
  if ((v10 & 0xF8) != 0x30 && (v10 & 0xFE) != 0x38 || (v10 - 49) > 8) {
    return (uint64_t)a2;
  }
  if ((v10 - 48) <= *(_DWORD *)(a1 + 28)) {
    sub_24B700D74(a1);
  }
LABEL_39:
  uint64_t v17 = sub_24B6F9974();
  return sub_24B701780(v17, v18, v19);
}

uint64_t sub_24B701780(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    return (uint64_t)a2;
  }
  int v3 = *a2;
  if (v3 == 42) {
    operator new();
  }
  if (a2 + 1 == a3 || v3 != 92 || a2[1] != 123) {
    return (uint64_t)a2;
  }
  uint64_t v5 = &a2[2 * (a2[1] == 123)];
  if (v5 != a3)
  {
    int v6 = *v5;
    if ((v6 & 0xF8) == 0x30 || (v6 & 0xFE) == 0x38)
    {
      int v7 = v6 - 48;
      uint64_t v8 = v5 + 1;
      if (v5 + 1 == a3)
      {
LABEL_16:
        uint64_t v8 = a3;
      }
      else
      {
        while (1)
        {
          int v9 = *v8;
          if ((v9 & 0xF8) != 0x30 && (v9 & 0xFE) != 0x38) {
            break;
          }
          if (v7 >= 214748364) {
            goto LABEL_43;
          }
          int v7 = v9 + 10 * v7 - 48;
          if (++v8 == a3) {
            goto LABEL_16;
          }
        }
      }
      if (v8 != v5)
      {
        if (v8 != a3)
        {
          int v10 = v8 + 1;
          int v11 = *v8;
          if (v11 != 44)
          {
            if (v10 != a3 && v11 == 92 && *v10 == 125) {
              operator new();
            }
            goto LABEL_41;
          }
          if (v10 != a3)
          {
            int v12 = *v10;
            if ((v12 & 0xF8) == 0x30 || (v12 & 0xFE) == 0x38)
            {
              int v10 = v8 + 2;
              if (v8 + 2 == a3) {
                goto LABEL_41;
              }
              int v13 = v12 - 48;
              while (1)
              {
                int v12 = *v10;
                if ((v12 & 0xF8) != 0x30 && (v12 & 0xFE) != 0x38) {
                  break;
                }
                if (v13 >= 214748364) {
                  goto LABEL_43;
                }
                int v13 = v12 + 10 * v13 - 48;
                if (++v10 == a3) {
                  goto LABEL_41;
                }
              }
            }
            else
            {
              int v13 = -1;
            }
            if (v10 != a3 && v10 + 1 != a3 && v12 == 92 && v10[1] == 125)
            {
              if (v13 != -1)
              {
                if (v13 >= v7) {
                  operator new();
                }
                goto LABEL_43;
              }
LABEL_42:
              operator new();
            }
          }
        }
LABEL_41:
        sub_24B6F9974();
        goto LABEL_42;
      }
    }
  }
LABEL_43:
  uint64_t v14 = sub_24B6F9974();
  return sub_24B701CBC(v14, v15);
}

uint64_t sub_24B701CBC(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_24B701CD0()
{
}

uint64_t sub_24B701CE8(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  uint64_t v3 = 8;
  if (a2) {
    uint64_t v3 = 16;
  }
  *(void *)(a3 + 80) = *(void *)(result + v3);
  return result;
}

void sub_24B701D0C(uint64_t a1, _DWORD *a2)
{
  *a2 = -992;
}

void sub_24B701D18(void *a1)
{
  *a1 = &unk_26FE9D1E8;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26FE9CEE8;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B701DEC(void *a1)
{
  *a1 = &unk_26FE9D1E8;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = &unk_26FE9CEE8;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

char *sub_24B701EA0(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3)
  {
    int v6 = *a2;
    if (v6 > 91)
    {
      if (v6 == 92)
      {
        if (a2 + 1 != a3)
        {
          int v13 = a2[1];
          if (v13 == 66) {
            operator new();
          }
          if (v13 == 98) {
            operator new();
          }
        }
      }
      else if (v6 == 94)
      {
        operator new();
      }
    }
    else
    {
      if (v6 == 36) {
        operator new();
      }
      BOOL v8 = v6 == 40;
      int v7 = a2 + 1;
      BOOL v8 = !v8 || v7 == a3;
      if (!v8)
      {
        BOOL v8 = *v7 == 63;
        int v9 = a2 + 2;
        if (v8 && v9 != a3)
        {
          int v11 = *v9;
          if (v11 == 33 || v11 == 61)
          {
            sub_24B702CD4((uint64_t)v14);
            v14[6] = *(_DWORD *)(a1 + 24);
            sub_24B6FA278(v14, a2 + 3, a3);
            sub_24B702D30();
          }
        }
      }
    }
  }
  return a2;
}

char *sub_24B70291C(uint64_t a1, char *a2, char *a3)
{
  int v6 = a2;
  do
  {
    int v7 = v6;
    int v6 = sub_24B701EA0(a1, v6, a3);
    if (v6 != v7) {
      continue;
    }
    BOOL v8 = (char *)((uint64_t (*)(uint64_t, char *, char *))loc_24B702198)(a1, v7, a3);
    if (v8 == v7) {
      break;
    }
    int v6 = sub_24B6FC498(a1, v8, a3);
  }
  while (v6 != v7);
  if (v7 == a2) {
    operator new();
  }
  if (v7 != a3)
  {
    if (*v7 == 124)
    {
      int v9 = v7 + 1;
      int v10 = v7 + 1;
      while (1)
      {
        int v11 = v10;
        int v10 = sub_24B701EA0(a1, v10, a3);
        if (v10 == v11)
        {
          int v12 = (char *)((uint64_t (*)(uint64_t, char *, char *))loc_24B702198)(a1, v11, a3);
          if (v12 == v11)
          {
LABEL_15:
            if (v11 == v9) {
              operator new();
            }
            operator new();
          }
          int v10 = sub_24B6FC498(a1, v12, a3);
        }
        if (v10 == v11) {
          goto LABEL_15;
        }
      }
    }
    return v7;
  }
  return a3;
}

void sub_24B702BDC(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B702C68(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_24B702CD4(uint64_t a1)
{
  uint64_t v2 = (const std::locale *)MEMORY[0x24C5D76E0]();
  *(void *)(a1 + 8) = std::locale::use_facet(v2, MEMORY[0x263F8C108]);
  *(void *)(a1 + 16) = std::locale::use_facet((const std::locale *)a1, MEMORY[0x263F8C130]);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 56) = 0;
  return a1;
}

void sub_24B702D30()
{
}

void sub_24B702E00(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  char v23 = 0;
  long long v24 = 0uLL;
  char v25 = 0;
  char v26 = 0;
  uint64_t v27 = 0;
  std::string __p = 0;
  uint64_t v17 = 0;
  uint64_t v4 = a1 + 16;
  unint64_t v5 = (*(_DWORD *)(a1 + 44) + 1);
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v18 = 0;
  *(void *)&long long v19 = v6;
  *((void *)&v19 + 1) = v6;
  char v20 = 0;
  sub_24B6F7568((uint64_t)&__p, v5, &v19);
  uint64_t v21 = v7;
  uint64_t v22 = v7;
  char v23 = 0;
  long long v24 = v19;
  char v25 = v20;
  uint64_t v27 = v7;
  char v26 = 1;
  if (*(unsigned __int8 *)(a1 + 84) == ((uint64_t (*)(uint64_t))loc_24B6F76F4)(v4))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
    BOOL v8 = (char *)__p;
    goto LABEL_7;
  }
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(a1 + 8);
  BOOL v8 = (char *)__p;
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v17 - (uint64_t)__p) >> 3);
  if (v9 < 2)
  {
LABEL_7:
    if (!v8) {
      return;
    }
    goto LABEL_8;
  }
  int v10 = *(_DWORD *)(a1 + 80);
  uint64_t v11 = *(void *)(a2 + 32);
  unsigned int v12 = 2;
  for (unint64_t i = 1; i < v9; unint64_t i = v12++)
  {
    uint64_t v14 = &v8[24 * i];
    uint64_t v15 = v11 + 24 * (v10 + v12 - 2);
    *(_OWORD *)uint64_t v15 = *(_OWORD *)v14;
    *(unsigned char *)(v15 + 16) = v14[16];
  }
LABEL_8:
  operator delete(v8);
}

void sub_24B702F90(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CFA8;
  uint64_t v2 = a1 + 2;
  locale = (std::__shared_weak_count *)a1[8].__locale_;
  if (locale && !atomic_fetch_add(&locale->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))locale->__on_zero_shared)(locale);
    std::__shared_weak_count::__release_weak(locale);
  }
  std::locale::~locale(v2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  uint64_t v4 = a1[1].__locale_;
  if (v4) {
    (*(void (**)(std::locale::__imp *))(*(void *)v4 + 8))(v4);
  }
  JUMPOUT(0x24C5D7790);
}

std::locale *sub_24B703094(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CFA8;
  uint64_t v2 = a1 + 2;
  locale = (std::__shared_weak_count *)a1[8].__locale_;
  if (locale && !atomic_fetch_add(&locale->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))locale->__on_zero_shared)(locale);
    std::__shared_weak_count::__release_weak(locale);
  }
  std::locale::~locale(v2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  uint64_t v4 = a1[1].__locale_;
  if (v4) {
    (*(void (**)(std::locale::__imp *))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

uint64_t sub_24B703178(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 8);
  uint64_t v3 = *(unsigned __int8 **)(a2 + 24);
  if (v2 == v3) {
    goto LABEL_18;
  }
  uint64_t v4 = *(unsigned __int8 **)(a2 + 16);
  if (v4 == v3)
  {
    if ((*(unsigned char *)(a2 + 88) & 8) == 0)
    {
      uint64_t v6 = *(v3 - 1);
      if (v6 != 95)
      {
LABEL_15:
        if ((v6 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v6) & 0x500) != 0) {
          goto LABEL_17;
        }
        goto LABEL_18;
      }
LABEL_17:
      int v10 = 1;
      goto LABEL_25;
    }
LABEL_18:
    int v10 = 0;
    goto LABEL_25;
  }
  if (v4 == v2)
  {
    int v5 = *(_DWORD *)(a2 + 88);
    if ((v5 & 0x80) == 0)
    {
      if ((v5 & 4) == 0)
      {
        uint64_t v6 = *v2;
        if (v6 != 95) {
          goto LABEL_15;
        }
        goto LABEL_17;
      }
      goto LABEL_18;
    }
  }
  uint64_t v7 = *(v4 - 1);
  uint64_t v8 = *v4;
  if (v7 == 95 || (v7 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v7) & 0x500) != 0)
  {
    int v9 = 1;
    if (v8 == 95) {
      goto LABEL_22;
    }
  }
  else
  {
    int v9 = 0;
    if (v8 == 95) {
      goto LABEL_22;
    }
  }
  if ((v8 & 0x80) != 0 || (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v8) & 0x500) == 0)
  {
    int v11 = 0;
    goto LABEL_24;
  }
LABEL_22:
  int v11 = 1;
LABEL_24:
  int v10 = v9 != v11;
LABEL_25:
  if (*(unsigned __int8 *)(result + 40) == v10)
  {
    uint64_t v12 = 0;
    int v13 = -993;
  }
  else
  {
    uint64_t v12 = *(void *)(result + 8);
    int v13 = -994;
  }
  *(_DWORD *)a2 = v13;
  *(void *)(a2 + 80) = v12;
  return result;
}

void sub_24B70329C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CF78;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x24C5D7790);
}

std::locale *sub_24B703348(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CF78;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&unk_26FE9CEE8;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

uint64_t sub_24B7033D8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_24B703408(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x24C5D7790);
}

uint64_t sub_24B703444(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_24B703458(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x24C5D7790);
}

void *sub_24B7034E4(void *a1)
{
  *a1 = &unk_26FE9CEE8;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_24B703550(uint64_t a1, _DWORD *a2)
{
  *a2 = -1000;
}

void sub_24B70355C()
{
}

uint64_t sub_24B703574(uint64_t result, uint64_t a2)
{
  uint64_t v2 = (_OWORD *)result;
  uint64_t v3 = **(float32x4_t ***)a2;
  if (v3 == (float32x4_t *)result || (uint64_t v4 = *(__int32 **)(a2 + 8), v4 == (__int32 *)result))
  {
    float32x4_t v10 = 0uLL;
    uint64_t result = sub_24B703574(&v10);
    float32x4_t v7 = v10;
  }
  else
  {
    uint64_t v5 = (4 * *(_DWORD *)(*(void *)a2 + 16));
    if (v5)
    {
      uint64_t v6 = 4 * v5;
      float32x4_t v7 = 0uLL;
      do
      {
        float32x4_t v8 = *v3++;
        float32x4_t v9 = v8;
        v8.i32[0] = *v4++;
        float32x4_t v7 = vmlaq_n_f32(v7, v9, v8.f32[0]);
        v6 -= 16;
      }
      while (v6);
    }
    else
    {
      float32x4_t v7 = 0uLL;
    }
  }
  _OWORD *v2 = v7;
  return result;
}

float32x4_t *sub_24B703600(float32x4_t *result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(float32x4_t **)a2;
  if (*(float32x4_t **)a2 == result || (uint64_t v4 = *(float **)(a2 + 8), v4 == (float *)result))
  {
    float32x4_t v9 = 0u;
    float32x4_t v10 = 0u;
    float32x4_t v7 = 0u;
    float32x4_t v8 = 0u;
    uint64_t result = (float32x4_t *)sub_24B703600(&v7);
    float32x4_t v6 = v8;
    float32x4_t *v2 = v7;
    v2[1] = v6;
    float32x4_t v5 = v10;
    v2[2] = v9;
  }
  else
  {
    *uint64_t result = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)0, *v3, *v4), v3[1], v4[1]), v3[2], v4[2]), v3[3], v4[3]);
    result[1] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)0, *v3, v4[4]), v3[1], v4[5]), v3[2], v4[6]), v3[3], v4[7]);
    result[2] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)0, *v3, v4[8]), v3[1], v4[9]), v3[2], v4[10]), v3[3], v4[11]);
    float32x4_t v5 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)0, *v3, v4[12]), v3[1], v4[13]), v3[2], v4[14]), v3[3], v4[15]);
  }
  v2[3] = v5;
  return result;
}

uint64_t sub_24B703708(float32x4_t *a1, float32x4_t *a2, uint64_t a3)
{
  kdebug_trace();
  float32x4_t v6 = *(char **)a3;
  *(void *)(a3 + 8) = *(void *)a3;
  v7.i32[0] = a1[1].i32[0];
  unsigned int v8 = vcvtms_s32_f32(0.04 / *(float *)v7.i32);
  v9.i64[0] = -1;
  v9.i32[2] = -1;
  if (a1[4].i32[0] && a1[4].i32[1] && a1[4].i32[2]) {
    int32x4_t v9 = vcvtq_s32_f32(vdivq_f32(vsubq_f32(*a2, a1[2]), (float32x4_t)vdupq_lane_s32(v7, 0)));
  }
  int v10 = v9.i32[0] - v8;
  unsigned __int32 v47 = v9.i32[0] + v8;
  if ((int)(v9.i32[0] - v8) <= (int)(v9.i32[0] + v8))
  {
    signed __int32 v11 = v9.i32[1] - v8;
    signed __int32 v12 = v9.i32[1] + v8;
    signed __int32 v13 = v9.i32[2] - v8;
    signed __int32 v14 = v9.i32[2] + v8;
    signed __int32 v46 = v11;
    int v48 = v12;
    signed __int32 v49 = v13;
    signed __int32 v54 = v14;
    if (v11 <= v12 && v13 <= v14)
    {
      uint64_t v51 = a2;
      while (1)
      {
        int v18 = v46;
        int v52 = v10;
        if ((v10 & 0x80000000) == 0) {
          break;
        }
LABEL_14:
        BOOL v17 = v10++ == v47;
        if (v17) {
          goto LABEL_10;
        }
      }
      while (1)
      {
        __int32 v19 = v49;
        int v50 = v18;
        if ((v18 & 0x80000000) == 0) {
          break;
        }
LABEL_17:
        int v18 = v50 + 1;
        if (v50 + 1 > v48) {
          goto LABEL_14;
        }
      }
      while (1)
      {
        float32x4_t v20 = a1[4];
        if (v10 < v20.i32[0] && (v19 & 0x80000000) == 0 && v50 < v20.i32[1] && v19 < v20.i32[2])
        {
          uint64_t v22 = a1[5].i64[0] + 24 * (v19 + (v50 + v20.i32[1] * v10) * v20.i32[2]);
          long long v24 = *(unsigned int **)v22;
          char v23 = *(unsigned int **)(v22 + 8);
          if (*(unsigned int **)v22 != v23) {
            break;
          }
        }
LABEL_20:
        BOOL v17 = v19++ == v54;
        if (v17) {
          goto LABEL_17;
        }
      }
      unsigned int v53 = *(unsigned int **)(v22 + 8);
      while (1)
      {
        int v26 = *v24;
        float32x4_t v27 = vsubq_f32(*(float32x4_t *)(a1->i64[1] + 48 * *v24), *a2);
        float32x4_t v28 = vmulq_f32(v27, v27);
        if (sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0]) > 0.04)goto LABEL_32; {
        unint64_t v29 = *(void *)(a3 + 16);
        }
        if ((unint64_t)v6 >= v29) {
          break;
        }
        *(_DWORD *)float32x4_t v6 = v26;
        char v25 = v6 + 4;
LABEL_31:
        *(void *)(a3 + 8) = v25;
        float32x4_t v6 = v25;
LABEL_32:
        if (++v24 == v23) {
          goto LABEL_20;
        }
      }
      size_t v30 = *(char **)a3;
      uint64_t v31 = (uint64_t)&v6[-*(void *)a3];
      uint64_t v32 = v31 >> 2;
      unint64_t v33 = (v31 >> 2) + 1;
      if (v33 >> 62) {
        abort();
      }
      uint64_t v34 = v29 - (void)v30;
      if (v34 >> 1 > v33) {
        unint64_t v33 = v34 >> 1;
      }
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v35 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v35 = v33;
      }
      if (v35)
      {
        if (v35 >> 62) {
          sub_24B6BCD7C();
        }
        size_t v36 = operator new(4 * v35);
        int v26 = *v24;
      }
      else
      {
        size_t v36 = 0;
      }
      int v37 = &v36[4 * v32];
      _DWORD *v37 = v26;
      char v25 = (char *)(v37 + 1);
      if (v6 != v30)
      {
        unint64_t v38 = v6 - 4 - v30;
        if (v38 >= 0xBC)
        {
          if (&v36[v31 - 4 - (v38 & 0xFFFFFFFFFFFFFFFCLL)] > &v36[v31 - 4])
          {
            int v39 = v6;
          }
          else if (&v6[-(v38 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v6 - 4)
          {
            int v39 = v6;
          }
          else if ((unint64_t)(v6 - v36 - v31) >= 0x20)
          {
            uint64_t v41 = (v38 >> 2) + 1;
            int v39 = &v6[-4 * (v41 & 0x7FFFFFFFFFFFFFF8)];
            unsigned __int8 v42 = &v36[4 * v32 - 16];
            uint64_t v43 = v6 - 16;
            uint64_t v44 = v41 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v45 = *(_OWORD *)v43;
              *(v42 - 1) = *((_OWORD *)v43 - 1);
              _OWORD *v42 = v45;
              v42 -= 2;
              v43 -= 32;
              v44 -= 8;
            }
            while (v44);
            v37 -= v41 & 0x7FFFFFFFFFFFFFF8;
            if (v41 == (v41 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_49;
            }
          }
          else
          {
            int v39 = v6;
          }
        }
        else
        {
          int v39 = v6;
        }
        do
        {
          int v40 = *((_DWORD *)v39 - 1);
          v39 -= 4;
          *--int v37 = v40;
        }
        while (v39 != v30);
      }
LABEL_49:
      *(void *)a3 = v37;
      *(void *)(a3 + 8) = v25;
      *(void *)(a3 + 16) = &v36[4 * v35];
      if (v30) {
        operator delete(v30);
      }
      a2 = v51;
      int v10 = v52;
      char v23 = v53;
      goto LABEL_31;
    }
  }
LABEL_10:
  return kdebug_trace();
}

id sub_24B703AD4(uint64_t a1)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v2 = sub_24B703D04(a1);
  float32x4_t v5 = v2;
  if (v2)
  {
    uint64_t v6 = objc_msgSend_width(v2, v3, v4);
    uint64_t v9 = objc_msgSend_height(v5, v7, v8);
    signed __int32 v12 = objc_msgSend_commandBuffer(*(void **)(*(void *)(a1 + 48) + 8), v10, v11);
    uint64_t v15 = objc_msgSend_blitCommandEncoder(v12, v13, v14);
    memset(v27, 0, sizeof(v27));
    v26[0] = v6;
    v26[1] = v9;
    v26[2] = 1;
    objc_msgSend_copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_destinationOffset_destinationBytesPerRow_destinationBytesPerImage_(v15, v16, (uint64_t)v5, 0, 0, v27, v26, *(void *)(a1 + 304), 0, 16 * v6, v9 * 16 * v6);
    objc_msgSend_endEncoding(v15, v17, v18);
    objc_msgSend_commit(v12, v19, v20);
    objc_msgSend_waitUntilCompleted(v12, v21, v22);
    id v23 = *(id *)(a1 + 304);
  }
  else
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    signed __int32 v12 = (id)qword_2697D1278;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "virtual id<MTLBuffer> oc::voxel_hashing::VoxelDepthRendererUsingMesh::normalBuffer()");
      char v25 = v29 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      uint64_t v31 = v25;
      __int16 v32 = 1026;
      int v33 = 230;
      _os_log_error_impl(&dword_24B6B9000, v12, OS_LOG_TYPE_ERROR, "%s:%{public}d Received invalid texture.", buf, 0x12u);
      if (v29 < 0) {
        operator delete(__p[0]);
      }
    }
    id v23 = 0;
  }

  return v23;
}

void sub_24B703CCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_24B703D04(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = a1 + 240;
    uint64_t v3 = *(NSObject **)(a1 + 288);
    block[0] = (void *)MEMORY[0x263EF8330];
    block[1] = (void *)3221225472;
    uint64_t v9 = sub_24B703EEC;
    int v10 = &unk_2652DF258;
    uint64_t v11 = v2;
    dispatch_sync(v3, block);
    id v4 = *(id *)(*(void *)(a1 + 240) + 8 * *(void *)(a1 + 280));
  }
  else
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v5 = (id)qword_2697D1278;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(block, "virtual id<MTLTexture> oc::voxel_hashing::VoxelDepthRendererUsingMesh::normalTexture()");
      int32x2_t v7 = SHIBYTE(v9) >= 0 ? block : (void **)block[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      signed __int32 v13 = v7;
      __int16 v14 = 1026;
      int v15 = 218;
      _os_log_error_impl(&dword_24B6B9000, v5, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get normal texture - VoxelDepthRendererUsingMesh not initialized.", buf, 0x12u);
      if (SHIBYTE(v9) < 0) {
        operator delete(block[0]);
      }
    }

    id v4 = 0;
  }
  return v4;
}

uint64_t sub_24B703EA8()
{
  qword_2697D1278 = (uint64_t)os_log_create("com.apple.CoreOCModules", "VoxelHashing");
  return MEMORY[0x270F9A758]();
}

int8x16_t sub_24B703EEC(uint64_t a1)
{
  uint64_t v1 = *(int8x16_t **)(a1 + 32);
  if (v1[3].i8[8])
  {
    int8x16_t result = vextq_s8(v1[2], v1[2], 8uLL);
    v1[2] = result;
    v1[3].i8[8] = 0;
  }
  return result;
}

id sub_24B703F0C(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  id v4 = sub_24B704148(a1);
  if (v4)
  {
    float32x4_t v5 = objc_msgSend_commandBuffer(*(void **)(*(void *)(a1 + 48) + 8), v2, v3);
    uint64_t v8 = objc_msgSend_width(v4, v6, v7);
    uint64_t v11 = objc_msgSend_height(v4, v9, v10);
    __int16 v14 = objc_msgSend_blitCommandEncoder(v5, v12, v13);
    memset(v26, 0, sizeof(v26));
    v25[0] = v8;
    v25[1] = v11;
    v25[2] = 1;
    objc_msgSend_copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_destinationOffset_destinationBytesPerRow_destinationBytesPerImage_(v14, v15, (uint64_t)v4, 0, 0, v26, v25, *(void *)(a1 + 232), 0, 4 * v8, v11 * 4 * v8);
    objc_msgSend_endEncoding(v14, v16, v17);
    objc_msgSend_commit(v5, v18, v19);
    objc_msgSend_waitUntilCompleted(v5, v20, v21);
    id v22 = *(id *)(a1 + 232);
  }
  else
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v5 = (id)qword_2697D1278;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "virtual id<MTLBuffer> oc::voxel_hashing::VoxelDepthRendererUsingMesh::depthBuffer()");
      long long v24 = v28 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      size_t v30 = v24;
      __int16 v31 = 1026;
      int v32 = 175;
      _os_log_error_impl(&dword_24B6B9000, v5, OS_LOG_TYPE_ERROR, "%s:%{public}d Received invalid texture.", buf, 0x12u);
      if (v28 < 0) {
        operator delete(__p[0]);
      }
    }
    id v22 = 0;
  }

  return v22;
}

void sub_24B704108(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_24B704148(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = a1 + 168;
    uint64_t v3 = *(NSObject **)(a1 + 216);
    block[0] = (void *)MEMORY[0x263EF8330];
    block[1] = (void *)3221225472;
    uint64_t v9 = sub_24B703EEC;
    uint64_t v10 = &unk_2652DF258;
    uint64_t v11 = v2;
    dispatch_sync(v3, block);
    id v4 = *(id *)(*(void *)(a1 + 168) + 8 * *(void *)(a1 + 208));
  }
  else
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v5 = (id)qword_2697D1278;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(block, "virtual id<MTLTexture> oc::voxel_hashing::VoxelDepthRendererUsingMesh::depthTexture()");
      uint64_t v7 = SHIBYTE(v9) >= 0 ? block : (void **)block[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      uint64_t v13 = v7;
      __int16 v14 = 1026;
      int v15 = 207;
      _os_log_error_impl(&dword_24B6B9000, v5, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get depth texture - VoxelDepthRendererUsingMesh not initialized.", buf, 0x12u);
      if (SHIBYTE(v9) < 0) {
        operator delete(block[0]);
      }
    }

    id v4 = 0;
  }
  return v4;
}

void sub_24B7042EC(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  uint64_t v125 = *MEMORY[0x263EF8340];
  sub_24B7220DC(*(void *)(a1 + 32));
  unsigned __int8 v8 = atomic_load((unsigned __int8 *)(a1 + 144));
  int v11 = sub_24B720B00(*(void *)(a1 + 32), v9, v10);
  int v12 = atomic_load((unsigned int *)(a1 + 148));
  if (v8)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    __int16 v14 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::canRenderDepthImage(const BOOL, const uint32_t, const int, const simd_float4x4 &, const simd_float3x3 &, const CGSize &)");
    if (v116.i8[7] >= 0) {
      int v32 = __p;
    }
    else {
      int v32 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v32;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 148;
    uint64_t v16 = "%s:%{public}d Failed to render depth image - rendering has been stopped.";
    goto LABEL_45;
  }
  if (!v11)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    uint64_t v13 = (id)qword_2697D1278;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::canRenderDepthImage(const BOOL, const uint32_t, const int, const simd_float4x4 &, const simd_float3x3 &, const CGSize &)");
      int v40 = v116.i8[7] >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v40;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = 154;
      _os_log_error_impl(&dword_24B6B9000, v13, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to render depth image - empty voxel blocks.", buf, 0x12u);
      if (v116.i8[7] < 0) {
        operator delete(__p[0]);
      }
    }
  }
  if (v12 >= 1)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    __int16 v14 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::canRenderDepthImage(const BOOL, const uint32_t, const int, const simd_float4x4 &, const simd_float3x3 &, const CGSize &)");
    if (v116.i8[7] >= 0) {
      int v15 = __p;
    }
    else {
      int v15 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 159;
    uint64_t v16 = "%s:%{public}d Failed to render depth image - rendering task already in pipeline.";
LABEL_45:
    _os_log_error_impl(&dword_24B6B9000, v14, OS_LOG_TYPE_ERROR, v16, buf, 0x12u);
    if (v116.i8[7] < 0) {
      operator delete(__p[0]);
    }
LABEL_18:

    return;
  }
  if (sub_24B705198(a2, a3, *a4, a4[1]))
  {
    uint64_t v17 = sub_24B721E6C(*(void *)(a1 + 32));
    int v20 = *(_DWORD *)objc_msgSend_contents(*(void **)(v17 + 16), v18, v19);
    if (*(_DWORD *)objc_msgSend_contents(*(void **)v17, v21, v22)) {
      _ZF = v20 == 0;
    }
    else {
      _ZF = 1;
    }
    if (_ZF)
    {
      if (qword_2697D1280 != -1) {
        dispatch_once(&qword_2697D1280, &unk_26FE9D318);
      }
      __int16 v14 = (id)qword_2697D1278;
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        goto LABEL_18;
      }
      sub_24B6F6D14(__p, "virtual void oc::voxel_hashing::VoxelDepthRendererUsingMesh::renderDepthImage(const simd_float4x4 &, const simd_float3x3 &, const CGSize &)");
      if (v116.i8[7] >= 0) {
        char v25 = __p;
      }
      else {
        char v25 = (void **)__p[0];
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v25;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = 123;
      uint64_t v16 = "%s:%{public}d Failed to render depth image - mesh is empty.";
    }
    else
    {
      int8x16_t v27 = *(int8x16_t *)a3;
      int8x16_t v26 = *(int8x16_t *)(a3 + 16);
      int8x16_t v28 = *(int8x16_t *)(a3 + 32);
      float32x2_t v29 = (float32x2_t)vdup_n_s32(0x38D1B717u);
      uint32x2_t v30 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v29, vabs_f32(vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v29, vabs_f32((float32x2_t)vext_s8(*(int8x8_t *)a3, (int8x8_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), 4uLL))));
      if ((vpmin_u32(v30, v30).u32[0] & 0x80000000) != 0)
      {
        double v33 = *a4;
        if (*a4 >= 0.0 && fabs(v33) > 0.000000999999997)
        {
          double v34 = a4[1];
          if (v34 >= 0.0 && fabs(v34) > 0.000000999999997)
          {
            double v35 = *(double *)(a1 + 56);
            if (v35 >= 0.0 && fabs(v35) > 0.000000999999997)
            {
              double v36 = *(double *)(a1 + 64);
              if (v36 >= 0.0 && fabs(v36) > 0.000000999999997)
              {
                *(float *)&uint64_t v37 = *(float *)v28.i32 + 0.5;
                float v38 = v34;
                float v39 = v38 - (float)(*(float *)&v28.i32[1] + 0.5);
                float64_t v108 = *(double *)(a1 + 64);
                float64_t v109 = *(double *)(a1 + 56);
                if (v33 == v35 && v34 == v36)
                {
                  int8x16_t v110 = *(int8x16_t *)a3;
                  long long v111 = *(_OWORD *)(a3 + 16);
                  *((float *)&v37 + 1) = v39;
                  objc_msgSend_commandBufferWithDescriptor_(*(void **)(*(void *)(a1 + 48) + 8), v23, *(void *)(a1 + 328), v37);
                }
                else
                {
                  double v41 = *(float *)v27.i32;
                  double v42 = *(float *)&v26.i32[1];
                  double v43 = *(float *)&v37;
                  double v44 = v39;
                  if (v35 / v36 >= v33 / v34)
                  {
                    double v45 = v35 / v33;
                    double v46 = v35 / v33 * v43;
                    double v47 = -(v36 - v34 * v45) * -0.5 + v44 * v45;
                  }
                  else
                  {
                    double v45 = v36 / v34;
                    double v46 = -(v35 - v33 * (v36 / v34)) * -0.5 + v43 * (v36 / v34);
                    double v47 = v36 / v34 * v44;
                  }
                  float v48 = v45 * v41;
                  float v49 = v48;
                  float v50 = v45 * v42;
                  *(float *)v110.i32 = v49;
                  *((float *)&v111 + 1) = v50;
                  *(float *)&unsigned int v51 = v46;
                  *(float *)&unsigned int v52 = v47;
                  __asm { FMOV            V2.4S, #1.0 }
                  objc_msgSend_commandBufferWithDescriptor_(*(void **)(*(void *)(a1 + 48) + 8), v23, *(void *)(a1 + 328), __PAIR64__(v52, v51));
                std::string::size_type v57 = };
                v58.f64[0] = v109;
                if (v57)
                {
                  v58.f64[1] = v108;
                  float32x2_t v59 = vcvt_f32_f64(v58);
                  v126.columns[1].i32[0] = 0;
                  v126.columns[1].i64[1] = 0;
                  v126.columns[0].i32[1] = 0;
                  v126.columns[0].i64[1] = 0;
                  v126.columns[0].f32[0] = (float)(*(float *)v110.i32 + *(float *)v110.i32) / v59.f32[0];
                  v126.columns[1].f32[1] = (float)(*((float *)&v111 + 1) + *((float *)&v111 + 1)) / v59.f32[1];
                  __asm { FMOV            V3.2S, #1.0 }
                  *(float32x2_t *)v126.columns[2].f32 = vsub_f32(_D3, vdiv_f32(vadd_f32(v107, v107), v59));
                  v126.columns[2].i64[1] = 0xBF800000BF80063ELL;
                  float32x4_t v61 = *(float32x4_t *)(a2 + 16);
                  float32x4_t v62 = *(float32x4_t *)(a2 + 32);
                  float32x4_t v63 = *(float32x4_t *)(a2 + 48);
                  float32x4_t v64 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)a2, COERCE_FLOAT(*(_OWORD *)(a1 + 96))), v61, *(float32x2_t *)(a1 + 96), 1), v62, *(float32x4_t *)(a1 + 96), 2), v63, *(float32x4_t *)(a1 + 96), 3);
                  float32x4_t v65 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)a2, COERCE_FLOAT(*(_OWORD *)(a1 + 112))), v61, *(float32x2_t *)(a1 + 112), 1), v62, *(float32x4_t *)(a1 + 112), 2), v63, *(float32x4_t *)(a1 + 112), 3);
                  float32x4_t v66 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)a2, COERCE_FLOAT(*(_OWORD *)(a1 + 128))), v61, *(float32x2_t *)(a1 + 128), 1), v62, *(float32x4_t *)(a1 + 128), 2), v63, *(float32x4_t *)(a1 + 128), 3);
                  *(float32x4_t *)std::string __p = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)a2, COERCE_FLOAT(*(_OWORD *)(a1 + 80))), v61, *(float32x2_t *)(a1 + 80), 1), v62, *(float32x4_t *)(a1 + 80), 2), v63, *(float32x4_t *)(a1 + 80), 3);
                  float32x4_t v116 = v64;
                  float32x4_t v117 = v65;
                  float32x4_t v118 = v66;
                  v126.columns[3] = (simd_float4)xmmword_24B72A780;
                  *(float32x4_t *)simd_float4x4 buf = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v126.columns[0].u32[0], *(float *)__p), (float32x4_t)v126.columns[1].u64[0], (float32x2_t)__p[0], 1), (float32x4_t)v126.columns[2], *(float32x4_t *)__p, 2), (float32x4_t)xmmword_24B72A780, *(float32x4_t *)__p, 3);
                  *(float32x4_t *)&uint8_t buf[16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v126.columns[0].u32[0], v64.f32[0]), (float32x4_t)v126.columns[1].u64[0], *(float32x2_t *)v64.f32, 1), (float32x4_t)v126.columns[2], v64, 2), (float32x4_t)xmmword_24B72A780, v64, 3);
                  float32x4_t v123 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v126.columns[0].u32[0], v65.f32[0]), (float32x4_t)v126.columns[1].u64[0], *(float32x2_t *)v65.f32, 1), (float32x4_t)v126.columns[2], v65, 2), (float32x4_t)xmmword_24B72A780, v65, 3);
                  float32x4_t v124 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v126.columns[0].u32[0], v66.f32[0]), (float32x4_t)v126.columns[1].u64[0], *(float32x2_t *)v66.f32, 1), (float32x4_t)v126.columns[2], v66, 2), (float32x4_t)xmmword_24B72A780, v66, 3);
                  simd_float4x4 v114 = __invert_f4(v126);
                  __int16 v14 = v57;
                  uint64_t v67 = *(void *)(*(void *)(a1 + 168) + 8 * *(void *)(a1 + 192));
                  long long v70 = objc_msgSend_colorAttachments(*(void **)(a1 + 320), v68, v69);
                  int v72 = objc_msgSend_objectAtIndexedSubscript_(v70, v71, 0);
                  objc_msgSend_setTexture_(v72, v73, v67);

                  uint64_t v74 = *(void *)(*(void *)(a1 + 240) + 8 * *(void *)(a1 + 264));
                  uint64_t v77 = objc_msgSend_colorAttachments(*(void **)(a1 + 320), v75, v76);
                  uint64_t v79 = objc_msgSend_objectAtIndexedSubscript_(v77, v78, 1);
                  objc_msgSend_setTexture_(v79, v80, v74);

                  uint64_t v83 = *(unsigned int *)objc_msgSend_contents(*(void **)(v17 + 16), v81, v82);
                  uint64_t v85 = objc_msgSend_renderCommandEncoderWithDescriptor_(v14, v84, *(void *)(a1 + 320));
                  objc_msgSend_setLabel_(v85, v86, @"RenderDepth Encoder");
                  objc_msgSend_setRenderPipelineState_(v85, v87, *(void *)(a1 + 152));
                  objc_msgSend_setDepthStencilState_(v85, v88, *(void *)(a1 + 312));
                  objc_msgSend_setVertexBuffer_offset_atIndex_(v85, v89, *(void *)(v17 + 8), 0, 0);
                  objc_msgSend_setVertexBytes_length_atIndex_(v85, v90, (uint64_t)buf, 64, 1);
                  objc_msgSend_setFragmentBytes_length_atIndex_(v85, v91, (uint64_t)&v114, 64, 0);
                  objc_msgSend_setFragmentBytes_length_atIndex_(v85, v92, (uint64_t)__p, 64, 1);
                  objc_msgSend_drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_(v85, v93, 3, v83, 1, *(void *)(v17 + 24), 0);
                  v119[0] = 0;
                  v119[1] = 0;
                  long long v120 = *(_OWORD *)(a1 + 56);
                  long long v121 = xmmword_24B72A670;
                  objc_msgSend_setViewport_(v85, v94, (uint64_t)v119);
                  objc_msgSend_setCullMode_(v85, v95, 2);
                  objc_msgSend_endEncoding(v85, v96, v97);

                  v113[0] = MEMORY[0x263EF8330];
                  v113[1] = 3221225472;
                  v113[2] = sub_24B704D58;
                  v113[3] = &unk_2652DF278;
                  v113[4] = a1;
                  objc_msgSend_addScheduledHandler_(v14, v98, (uint64_t)v113);
                  v112[0] = MEMORY[0x263EF8330];
                  v112[1] = 3221225472;
                  v112[2] = sub_24B704D6C;
                  v112[3] = &unk_2652DF278;
                  v112[4] = a1;
                  objc_msgSend_addCompletedHandler_(v14, v99, (uint64_t)v112);
                  unsigned __int8 v102 = atomic_load((unsigned __int8 *)(a1 + 144));
                  if ((v102 & 1) == 0)
                  {
                    objc_msgSend_commit(v14, v100, v101);
                    objc_msgSend_waitUntilCompleted(v14, v103, v104);
                  }
                }
                else
                {
                  if (qword_2697D1280 != -1) {
                    dispatch_once(&qword_2697D1280, &unk_26FE9D318);
                  }
                  uint64_t v105 = (id)qword_2697D1278;
                  if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
                  {
                    sub_24B6F6D14(__p, "virtual void oc::voxel_hashing::VoxelDepthRendererUsingMesh::renderDepthImage(const simd_float4x4 &, const simd_float3x3 &, const CGSize &)");
                    BOOL v106 = v116.i8[7] >= 0 ? __p : (void **)__p[0];
                    *(_DWORD *)simd_float4x4 buf = 136315394;
                    *(void *)&uint8_t buf[4] = v106;
                    *(_WORD *)&unsigned char buf[12] = 1026;
                    *(_DWORD *)&buf[14] = 138;
                    _os_log_error_impl(&dword_24B6B9000, v105, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to render depth image - failed to create command buffer.", buf, 0x12u);
                    if (v116.i8[7] < 0) {
                      operator delete(__p[0]);
                    }
                  }

                  __int16 v14 = 0;
                }
                goto LABEL_18;
              }
            }
          }
        }
      }
      if (qword_2697D1280 != -1) {
        dispatch_once(&qword_2697D1280, &unk_26FE9D318);
      }
      __int16 v14 = (id)qword_2697D1278;
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
        goto LABEL_18;
      }
      sub_24B6F6D14(__p, "virtual void oc::voxel_hashing::VoxelDepthRendererUsingMesh::renderDepthImage(const simd_float4x4 &, const simd_float3x3 &, const CGSize &)");
      if (v116.i8[7] >= 0) {
        __int16 v31 = __p;
      }
      else {
        __int16 v31 = (void **)__p[0];
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v31;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = 131;
      uint64_t v16 = "%s:%{public}d Failed to render depth image - projection matrix is invalid.";
    }
    goto LABEL_45;
  }
}

void sub_24B704CF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B704D58(uint64_t result)
{
  return result;
}

void sub_24B704D6C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = objc_msgSend_error(a2, (const char *)a2, a3);
  uint64_t v7 = v4;
  if (v4)
  {
    sub_24B704E84(v4, v5, v6);
  }
  else
  {
    unsigned __int8 v8 = *(NSObject **)(v3 + 216);
    uint64_t block = MEMORY[0x263EF8330];
    uint64_t v11 = 3221225472;
    int v12 = sub_24B705138;
    uint64_t v13 = &unk_2652DF258;
    uint64_t v14 = v3 + 168;
    dispatch_sync(v8, &block);
    uint64_t v9 = *(NSObject **)(v3 + 288);
    uint64_t block = MEMORY[0x263EF8330];
    uint64_t v11 = 3221225472;
    int v12 = sub_24B705138;
    uint64_t v13 = &unk_2652DF258;
    uint64_t v14 = v3 + 240;
    dispatch_sync(v9, &block);
  }

  atomic_fetch_add((atomic_uint *volatile)(v3 + 148), 0xFFFFFFFF);
}

void sub_24B704E74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B704E84(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v3 = objc_msgSend_userInfo(a1, a2, a3);
  float32x4_t v5 = objc_msgSend_objectForKeyedSubscript_(v3, v4, *MEMORY[0x263F125E8]);

  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  id v6 = v5;
  uint64_t v10 = objc_msgSend_countByEnumeratingWithState_objects_count_(v6, v7, (uint64_t)&v25, v31, 16);
  if (v10)
  {
    uint64_t v12 = *(void *)v26;
    *(void *)&long long v11 = 138543362;
    long long v24 = v11;
    do
    {
      for (uint64_t i = 0; i != v10; ++i)
      {
        if (*(void *)v26 != v12) {
          objc_enumerationMutation(v6);
        }
        uint64_t v14 = *(void **)(*((void *)&v25 + 1) + 8 * i);
        if (objc_msgSend_errorState(v14, v8, v9, v24, (void)v25) == 4)
        {
          if (qword_2697D1290 != -1) {
            dispatch_once(&qword_2697D1290, &unk_26FE9D338);
          }
          uint64_t v17 = (id)qword_2697D1288;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            int v20 = objc_msgSend_label(v14, v18, v19);
            *(_DWORD *)simd_float4x4 buf = v24;
            uint32x2_t v30 = v20;
            _os_log_error_impl(&dword_24B6B9000, v17, OS_LOG_TYPE_ERROR, "%{public}@ has faulted", buf, 0xCu);
          }
LABEL_4:

          continue;
        }
        if (objc_msgSend_errorState(v14, v15, v16) == 2)
        {
          if (qword_2697D1290 != -1) {
            dispatch_once(&qword_2697D1290, &unk_26FE9D338);
          }
          uint64_t v17 = (id)qword_2697D1288;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            id v23 = objc_msgSend_label(v14, v21, v22);
            *(_DWORD *)simd_float4x4 buf = v24;
            uint32x2_t v30 = v23;
            _os_log_error_impl(&dword_24B6B9000, v17, OS_LOG_TYPE_ERROR, "%{public}@ has been affected", buf, 0xCu);
          }
          goto LABEL_4;
        }
      }
      uint64_t v10 = objc_msgSend_countByEnumeratingWithState_objects_count_(v6, v8, (uint64_t)&v25, v31, 16);
    }
    while (v10);
  }
}

void sub_24B7050EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int8x16_t sub_24B705138(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int8x16_t result = vextq_s8(*(int8x16_t *)(v1 + 24), *(int8x16_t *)(v1 + 24), 8uLL);
  *(int8x16_t *)(v1 + 24) = result;
  *(unsigned char *)(v1 + 56) = 1;
  return result;
}

uint64_t sub_24B705154()
{
  qword_2697D1288 = (uint64_t)os_log_create("com.apple.CoreOCModules", "General");
  return MEMORY[0x270F9A758]();
}

uint64_t sub_24B705198(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  float32x4_t v4 = *(float32x4_t *)a1;
  float32x4_t v5 = *(float32x4_t *)(a1 + 16);
  float32x4_t v6 = *(float32x4_t *)(a1 + 32);
  float32x4_t v7 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v8 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v9 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v10 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v9, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v4, *(float32x2_t *)v4.f32, 1), v5, *(float32x2_t *)v5.f32, 1), v6, *(float32x2_t *)v6.f32, 1), v7)), (int8x16_t)vcgeq_f32(v9, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v4, v4.f32[0]), v5, v5.f32[0]),
                                         v6,
                                         v6.f32[0]),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v9, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v4, v4, 2), v5, v5, 2), v6, v6, 2), v8)));
  v10.i32[3] = v10.i32[2];
  if ((vminvq_u32(v10) & 0x80000000) == 0) {
    goto LABEL_5;
  }
  float32x4_t v11 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2);
  float32x4_t v12 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v4, (int32x4_t)v6), (int32x4_t)v11);
  float32x4_t v13 = (float32x4_t)vtrn2q_s32((int32x4_t)v4, (int32x4_t)v5);
  v13.i32[2] = HIDWORD(*(void *)(a1 + 32));
  float32x4_t v14 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v4, (int32x4_t)v6), (int32x4_t)v5);
  uint32x4_t v15 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v9, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v14, v5.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1), v13), v11, v12), v7)), (int8x16_t)vcgeq_f32(v9, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v14, v4.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1),
                                           v13),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2),
                                         v12),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v9, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v14, v6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1), v13), (float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), v12), v8)));
  v15.i32[3] = v15.i32[2];
  if ((vminvq_u32(v15) & 0x80000000) == 0
    || (v16 = vmulq_f32(v4, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v6, (int8x16_t)v6, 0xCuLL), (int8x16_t)v6, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v5, (int32x4_t)v5), (int8x16_t)v5, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), (int8x16_t)v6, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v5, (int8x16_t)v5, 0xCuLL), (int8x16_t)v5, 8uLL))), fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0]+ -1.0) > 0.000011)|| (float32x2_t v17 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL))), v18 = (float32x2_t)vdup_n_s32(0x38D1B717u),
        uint32x2_t v19 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v18, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v6, (int8x16_t)v6, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v18, v17)), (vpmin_u32(v19, v19).u32[0] & 0x80000000) == 0))
  {
LABEL_5:
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    int v20 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_8;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::isValidInputForRenderDepthImage(const simd_float4x4 &, const simd_float3x3 &, const CGSize &)");
    if (v28 >= 0) {
      uint64_t v22 = __p;
    }
    else {
      uint64_t v22 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint32x2_t v30 = v22;
    __int16 v31 = 1026;
    int v32 = 114;
    id v23 = "%s:%{public}d Failed to render depth image - invalid viewMatrix.";
LABEL_13:
    _os_log_error_impl(&dword_24B6B9000, v20, OS_LOG_TYPE_ERROR, v23, buf, 0x12u);
    if (v28 < 0) {
      operator delete(__p[0]);
    }
LABEL_8:

    return 0;
  }
  uint32x2_t v24 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v18, vabs_f32(vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)(a2 + 24), *(int32x2_t *)(a2 + 40)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v18, vabs_f32((float32x2_t)vext_s8(*(int8x8_t *)a2, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a2, *(int8x16_t *)a2, 8uLL), 4uLL))));
  if ((vpmin_u32(v24, v24).u32[0] & 0x80000000) == 0)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    int v20 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_8;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::isValidInputForRenderDepthImage(const simd_float4x4 &, const simd_float3x3 &, const CGSize &)");
    if (v28 >= 0) {
      long long v25 = __p;
    }
    else {
      long long v25 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint32x2_t v30 = v25;
    __int16 v31 = 1026;
    int v32 = 120;
    id v23 = "%s:%{public}d Failed to render depth image - invalid camera intrinsics.";
    goto LABEL_13;
  }
  if (a3 < 0.0 || fabs(a3) <= 0.000000999999997 || a4 < 0.0 || fabs(a4) <= 0.000000999999997)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    int v20 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_8;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::isValidInputForRenderDepthImage(const simd_float4x4 &, const simd_float3x3 &, const CGSize &)");
    if (v28 >= 0) {
      long long v26 = __p;
    }
    else {
      long long v26 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint32x2_t v30 = v26;
    __int16 v31 = 1026;
    int v32 = 127;
    id v23 = "%s:%{public}d Failed to render depth image - invalid render image size.";
    goto LABEL_13;
  }
  return 1;
}

uint64_t sub_24B705610(uint64_t a1, unint64_t a2, unint64_t a3, float32x4_t *a4, float a5)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  float32x4_t v5 = *(id **)(a1 + 48);
  if (!v5)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v8 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::init(const std::size_t, const std::size_t, const simd_float4x4 &, const float, const uint8_t)");
    if (v45 >= 0) {
      float32x4_t v12 = __p;
    }
    else {
      float32x4_t v12 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    double v47 = v12;
    __int16 v48 = 1026;
    int v49 = 52;
    uint32x4_t v10 = "%s:%{public}d Failed to initialize VoxelDepthRendererUsingMesh - failed to get MTLDeviceContext.";
    goto LABEL_43;
  }
  uint64_t v7 = *(void *)(a1 + 32);
  if (!v7 || !*(unsigned char *)(v7 + 8))
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v8 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::init(const std::size_t, const std::size_t, const simd_float4x4 &, const float, const uint8_t)");
    if (v45 >= 0) {
      float32x4_t v11 = __p;
    }
    else {
      float32x4_t v11 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    double v47 = v11;
    __int16 v48 = 1026;
    int v49 = 58;
    uint32x4_t v10 = "%s:%{public}d Failed to initialize VoxelDepthRendererUsingMesh - invalid init config.";
    goto LABEL_43;
  }
  if (!a2 || !a3)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v8 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::init(const std::size_t, const std::size_t, const simd_float4x4 &, const float, const uint8_t)");
    if (v45 >= 0) {
      float32x4_t v13 = __p;
    }
    else {
      float32x4_t v13 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    double v47 = v13;
    __int16 v48 = 1026;
    int v49 = 64;
    uint32x4_t v10 = "%s:%{public}d Failed to initialize VoxelDepthRendererUsingMesh - invalid image size.";
    goto LABEL_43;
  }
  if (a5 < 0.0001)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v8 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::init(const std::size_t, const std::size_t, const simd_float4x4 &, const float, const uint8_t)");
    if (v45 >= 0) {
      float32x4_t v9 = __p;
    }
    else {
      float32x4_t v9 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    double v47 = v9;
    __int16 v48 = 1026;
    int v49 = 70;
    uint32x4_t v10 = "%s:%{public}d Failed to initialize VoxelDepthRendererUsingMesh - invalid voxel dimension.";
    goto LABEL_43;
  }
  if (*(unsigned char *)(a1 + 8))
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v8 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::init(const std::size_t, const std::size_t, const simd_float4x4 &, const float, const uint8_t)");
    if (v45 >= 0) {
      float32x4_t v14 = __p;
    }
    else {
      float32x4_t v14 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    double v47 = v14;
    __int16 v48 = 1026;
    int v49 = 76;
    uint32x4_t v10 = "%s:%{public}d Failed to initialize VoxelDepthRendererUsingMesh - already been initialized.";
    goto LABEL_43;
  }
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a3;
  *(double *)(a1 + 56) = (double)a2;
  *(double *)(a1 + 64) = (double)a3;
  float32x4_t v15 = a4[1];
  float32x4_t v16 = a4[2];
  float32x4_t v17 = a4[3];
  float32x4_t v18 = vmulq_f32(*a4, (float32x4_t)0);
  float32x4_t v19 = vmlaq_f32(vmlaq_f32(vmlaq_n_f32(v18, v15, a5), (float32x4_t)0, v16), (float32x4_t)0, v17);
  float32x4_t v20 = vmlaq_f32(v18, (float32x4_t)0, v15);
  *(float32x4_t *)(a1 + 80) = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(*a4, a5), (float32x4_t)0, v15), (float32x4_t)0, v16), (float32x4_t)0, v17);
  *(float32x4_t *)(a1 + 96) = v19;
  *(float32x4_t *)(a1 + 112) = vmlaq_f32(vmlaq_n_f32(v20, v16, a5), (float32x4_t)0, v17);
  *(float32x4_t *)(a1 + 128) = vaddq_f32(v17, vmlaq_f32(v20, (float32x4_t)0, v16));
  id v21 = *v5;
  uint64_t v23 = objc_msgSend_newBufferWithLength_options_(v21, v22, 4 * *(void *)(a1 + 24) * *(void *)(a1 + 16), 0);
  uint32x2_t v24 = *(void **)(a1 + 232);
  *(void *)(a1 + 232) = v23;

  long long v26 = *(void **)(a1 + 232);
  if (!v26)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v8 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::createBuffers()");
    if (v45 >= 0) {
      int v40 = __p;
    }
    else {
      int v40 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    double v47 = v40;
    __int16 v48 = 1026;
    int v49 = 265;
    uint32x4_t v10 = "%s:%{public}d Failed to create depthImageBuffer.";
    goto LABEL_43;
  }
  objc_msgSend_setLabel_(v26, v25, @"depthImageBuffer");
  id v27 = **(id **)(a1 + 48);
  uint64_t v29 = objc_msgSend_newBufferWithLength_options_(v27, v28, 16 * *(void *)(a1 + 24) * *(void *)(a1 + 16), 0);
  uint32x2_t v30 = *(void **)(a1 + 304);
  *(void *)(a1 + 304) = v29;

  int v32 = *(void **)(a1 + 304);
  if (!v32)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v8 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::createBuffers()");
    if (v45 >= 0) {
      double v42 = __p;
    }
    else {
      double v42 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    double v47 = v42;
    __int16 v48 = 1026;
    int v49 = 275;
    uint32x4_t v10 = "%s:%{public}d Failed to create normalImageBuffer.";
    goto LABEL_43;
  }
  objc_msgSend_setLabel_(v32, v31, @"normalImageBuffer");
  if (sub_24B705D88(a1)
    && sub_24B706364(a1, v33)
    && sub_24B706900(a1)
    && sub_24B706B4C(a1))
  {
    id v34 = objc_alloc_init(MEMORY[0x263F12810]);
    double v35 = *(void **)(a1 + 328);
    *(void *)(a1 + 328) = v34;

    uint64_t v37 = *(void **)(a1 + 328);
    if (v37)
    {
      uint64_t v38 = 1;
      objc_msgSend_setErrorOptions_(v37, v36, 1);
      *(unsigned char *)(a1 + 8) = 1;
      float32x4_t v8 = sub_24B706E84();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::init(const std::size_t, const std::size_t, const simd_float4x4 &, const float, const uint8_t)");
        if (v45 >= 0) {
          float v39 = __p;
        }
        else {
          float v39 = (void **)__p[0];
        }
        *(_DWORD *)simd_float4x4 buf = 136315394;
        double v47 = v39;
        __int16 v48 = 1026;
        int v49 = 102;
        _os_log_debug_impl(&dword_24B6B9000, v8, OS_LOG_TYPE_DEBUG, "%s:%{public}d Successfully Initialized VoxelDepthRendererUsingMesh.", buf, 0x12u);
        if (v45 < 0) {
          operator delete(__p[0]);
        }
        uint64_t v38 = 1;
      }
      goto LABEL_71;
    }
    float32x4_t v8 = sub_24B706E84();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
LABEL_70:
      uint64_t v38 = 0;
LABEL_71:

      return v38;
    }
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::init(const std::size_t, const std::size_t, const simd_float4x4 &, const float, const uint8_t)");
    if (v45 >= 0) {
      double v43 = __p;
    }
    else {
      double v43 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    double v47 = v43;
    __int16 v48 = 1026;
    int v49 = 94;
    uint32x4_t v10 = "%s:%{public}d Failed to initialize VoxelDepthRendererUsingMesh - failed to create command buffer descriptor.";
LABEL_43:
    _os_log_error_impl(&dword_24B6B9000, v8, OS_LOG_TYPE_ERROR, v10, buf, 0x12u);
    if (v45 < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_70;
  }
  return 0;
}

void sub_24B705D70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B705D88(uint64_t a1)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  uint64_t v2 = objc_alloc_init(MEMORY[0x263F12A50]);
  uint64_t v33 = v2;
  if (!v2)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v4 = (id)qword_2697D1278;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(&v42, "BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::createTextures()");
      uint64_t v23 = v43 >= 0 ? (void **)&v42 : v42;
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v23;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = 290;
      _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create textureDescriptor.", buf, 0x12u);
      if (SHIBYTE(v43) < 0) {
        operator delete(v42);
      }
    }
    goto LABEL_21;
  }
  float32x4_t v4 = v2;
  objc_msgSend_setTextureType_(v2, v3, 2);
  objc_msgSend_setPixelFormat_(v4, v5, 252);
  objc_msgSend_setWidth_(v4, v6, *(void *)(a1 + 16));
  objc_msgSend_setHeight_(v4, v7, *(void *)(a1 + 24));
  objc_msgSend_setUsage_(v4, v8, 5);
  if (*(unsigned char *)(*(void *)(a1 + 48) + 24)) {
    objc_msgSend_setStorageMode_(v4, v9, 3);
  }
  else {
    objc_msgSend_setStorageMode_(v4, v9, 2);
  }
  id v10 = **(id **)(a1 + 48);
  uint64_t v12 = objc_msgSend_newTextureWithDescriptor_(v10, v11, (uint64_t)v4);
  float32x4_t v13 = *(void **)(a1 + 160);
  *(void *)(a1 + 160) = v12;

  float32x4_t v15 = *(void **)(a1 + 160);
  if (!v15)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    uint32x2_t v24 = (id)qword_2697D1278;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(&v42, "BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::createTextures()");
      int v32 = v43 >= 0 ? (void **)&v42 : v42;
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v32;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = 302;
      _os_log_error_impl(&dword_24B6B9000, v24, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create renderDepthTexture.", buf, 0x12u);
      if (SHIBYTE(v43) < 0) {
        operator delete(v42);
      }
    }

LABEL_21:
    uint64_t v25 = 0;
    goto LABEL_36;
  }
  objc_msgSend_setLabel_(v15, v14, @"renderDepthTexture");
  objc_msgSend_setTextureType_(v4, v16, 2);
  objc_msgSend_setPixelFormat_(v4, v17, 55);
  objc_msgSend_setWidth_(v4, v18, *(void *)(a1 + 16));
  objc_msgSend_setHeight_(v4, v19, *(void *)(a1 + 24));
  objc_msgSend_setUsage_(v4, v20, 5);
  objc_msgSend_setStorageMode_(v4, v21, 0);
  double v42 = (void **)&unk_26FE9D368;
  *(void *)&long long v43 = a1;
  *((void *)&v43 + 1) = &v33;
  double v44 = (void **)&v42;
  double v41 = (void **)&v39;
  float v39 = (void (**)(void **))&unk_26FE9D368;
  long long v40 = v43;
  sub_24B706ED8((void ***)(a1 + 168), (uint64_t)&v39);
  if (v41 == (void **)&v39)
  {
    v39[4]((void **)&v39);
  }
  else if (v41)
  {
    (*((void (**)(void))*v41 + 5))();
  }
  objc_msgSend_setTextureType_(v33, v22, 2);
  objc_msgSend_setPixelFormat_(v33, v26, 125);
  objc_msgSend_setWidth_(v33, v27, *(void *)(a1 + 16));
  objc_msgSend_setHeight_(v33, v28, *(void *)(a1 + 24));
  objc_msgSend_setUsage_(v33, v29, 5);
  objc_msgSend_setStorageMode_(v33, v30, 0);
  *(void *)simd_float4x4 buf = &unk_26FE9D3B0;
  *(void *)&uint8_t buf[8] = a1;
  *(void *)&uint8_t buf[16] = &v33;
  uint64_t v38 = buf;
  double v36 = (void **)&v34;
  id v34 = (void (**)(void **))&unk_26FE9D3B0;
  long long v35 = *(_OWORD *)&buf[8];
  sub_24B706ED8((void ***)(a1 + 240), (uint64_t)&v34);
  if (v36 == (void **)&v34)
  {
    v34[4]((void **)&v34);
  }
  else if (v36)
  {
    (*((void (**)(void))*v36 + 5))();
  }
  if (v38 == buf)
  {
    (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
  }
  else if (v38)
  {
    (*(void (**)(void))(*(void *)v38 + 40))();
  }
  if (v44 == (void **)&v42)
  {
    ((void (*)(void ***))v42[4])(&v42);
  }
  else if (v44)
  {
    (*((void (**)(void))*v44 + 5))();
  }
  uint64_t v25 = 1;
  float32x4_t v4 = v33;
LABEL_36:

  return v25;
}

void sub_24B706308(_Unwind_Exception *a1, uint64_t a2, void *a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_24B706FCC((uint64_t *)va);
  sub_24B706FCC(va1);
  sub_24B706FCC((void *)(v3 - 72));

  _Unwind_Resume(a1);
}

uint64_t sub_24B706364(uint64_t a1, const char *a2)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  float32x4_t v4 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)(a1 + 48) + 16), a2, @"oc::voxel_hashing::vertexShaderForMesh");
  if (v4)
  {
    uint64_t v5 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)(a1 + 48) + 16), v3, @"oc::voxel_hashing::fragmentShaderForMesh");
    if (!v5)
    {
      if (qword_2697D1280 != -1) {
        dispatch_once(&qword_2697D1280, &unk_26FE9D318);
      }
      long long v35 = (id)qword_2697D1278;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::createPipelines()");
        double v42 = (v60 & 0x80000000) == 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = v42;
        __int16 v53 = 1026;
        int v54 = 364;
        _os_log_error_impl(&dword_24B6B9000, v35, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find fragmentShaderForMesh fragment shader.", buf, 0x12u);
        if (SBYTE3(v60) < 0) {
          operator delete(*(void **)__p);
        }
      }
      uint64_t v38 = 0;
      goto LABEL_23;
    }
    id v6 = objc_alloc_init(MEMORY[0x263F129C0]);
    uint64_t v8 = v6;
    if (v6)
    {
      objc_msgSend_setVertexFunction_(v6, v7, (uint64_t)v4);
      objc_msgSend_setFragmentFunction_(v8, v9, (uint64_t)v5);
      uint64_t v12 = objc_msgSend_pixelFormat(*(void **)(*(void *)(a1 + 168) + 8 * *(void *)(a1 + 208)), v10, v11);
      float32x4_t v15 = objc_msgSend_colorAttachments(v8, v13, v14);
      float32x4_t v17 = objc_msgSend_objectAtIndexedSubscript_(v15, v16, 0);
      objc_msgSend_setPixelFormat_(v17, v18, v12);

      uint64_t v21 = objc_msgSend_pixelFormat(*(void **)(*(void *)(a1 + 240) + 8 * *(void *)(a1 + 280)), v19, v20);
      uint32x2_t v24 = objc_msgSend_colorAttachments(v8, v22, v23);
      long long v26 = objc_msgSend_objectAtIndexedSubscript_(v24, v25, 1);
      objc_msgSend_setPixelFormat_(v26, v27, v21);

      uint64_t v30 = objc_msgSend_pixelFormat(*(void **)(a1 + 160), v28, v29);
      objc_msgSend_setDepthAttachmentPixelFormat_(v8, v31, v30);
      id v32 = **(id **)(a1 + 48);
      id v51 = 0;
      uint64_t v34 = objc_msgSend_newRenderPipelineStateWithDescriptor_error_(v32, v33, (uint64_t)v8, &v51);
      long long v35 = v51;
      uint64_t v37 = *(void **)(a1 + 152);
      double v36 = (uint64_t *)(a1 + 152);
      uint64_t *v36 = v34;

      if (*v36)
      {
        uint64_t v38 = 1;
LABEL_22:

LABEL_23:
        goto LABEL_24;
      }
      if (qword_2697D1280 != -1) {
        dispatch_once(&qword_2697D1280, &unk_26FE9D318);
      }
      float v39 = (id)qword_2697D1278;
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::createPipelines()");
        int v44 = v55;
        uint64_t v45 = *(unsigned char **)buf;
        uint64_t v48 = objc_msgSend_localizedDescription(v35, v46, v47);
        int v49 = (void *)v48;
        if (v44 >= 0) {
          uint64_t v50 = buf;
        }
        else {
          uint64_t v50 = v45;
        }
        *(_DWORD *)std::string __p = 136315650;
        *(void *)&__p[4] = v50;
        __int16 v57 = 1026;
        int v58 = 382;
        __int16 v59 = 2114;
        uint64_t v60 = v48;
        _os_log_error_impl(&dword_24B6B9000, v39, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create render pipeline state. Error details: %{public}@", __p, 0x1Cu);

        if (v55 < 0) {
          operator delete(*(void **)buf);
        }
      }
    }
    else
    {
      if (qword_2697D1280 != -1) {
        dispatch_once(&qword_2697D1280, &unk_26FE9D318);
      }
      float v39 = (id)qword_2697D1278;
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::createPipelines()");
        long long v43 = (v60 & 0x80000000) == 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = v43;
        __int16 v53 = 1026;
        int v54 = 370;
        _os_log_error_impl(&dword_24B6B9000, v39, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create render pipeline descriptor.", buf, 0x12u);
        if (SBYTE3(v60) < 0) {
          operator delete(*(void **)__p);
        }
      }
      long long v35 = 0;
    }

    uint64_t v38 = 0;
    goto LABEL_22;
  }
  if (qword_2697D1280 != -1) {
    dispatch_once(&qword_2697D1280, &unk_26FE9D318);
  }
  uint64_t v5 = (id)qword_2697D1278;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::createPipelines()");
    double v41 = (v60 & 0x80000000) == 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v41;
    __int16 v53 = 1026;
    int v54 = 357;
    _os_log_error_impl(&dword_24B6B9000, v5, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find vertexShaderForMesh vertex shader.", buf, 0x12u);
    if (SBYTE3(v60) < 0) {
      operator delete(*(void **)__p);
    }
  }
  uint64_t v38 = 0;
LABEL_24:

  return v38;
}

void sub_24B70687C(_Unwind_Exception *a1)
{
  if (v7 < 0) {
    operator delete(v6);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_24B706900(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v2 = objc_alloc_init(MEMORY[0x263F128A0]);
  float32x4_t v4 = v2;
  if (!v2)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    uint64_t v11 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::createDepthStencilStates()");
    if (v17 >= 0) {
      uint64_t v12 = __p;
    }
    else {
      uint64_t v12 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float32x4_t v19 = v12;
    __int16 v20 = 1026;
    int v21 = 395;
    float32x4_t v13 = "%s:%{public}d Failed to create depth stencil descriptor.";
    goto LABEL_20;
  }
  objc_msgSend_setDepthCompareFunction_(v2, v3, 1);
  objc_msgSend_setDepthWriteEnabled_(v4, v5, 1);
  id v6 = **(id **)(a1 + 48);
  uint64_t v8 = objc_msgSend_newDepthStencilStateWithDescriptor_(v6, v7, (uint64_t)v4);
  uint64_t v9 = *(void **)(a1 + 312);
  *(void *)(a1 + 312) = v8;

  if (!*(void *)(a1 + 312))
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    uint64_t v11 = (id)qword_2697D1278;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::createDepthStencilStates()");
    if (v17 >= 0) {
      float32x4_t v15 = __p;
    }
    else {
      float32x4_t v15 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float32x4_t v19 = v15;
    __int16 v20 = 1026;
    int v21 = 404;
    float32x4_t v13 = "%s:%{public}d Failed to create depth stencil state.";
LABEL_20:
    _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, v13, buf, 0x12u);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
LABEL_14:

    uint64_t v10 = 0;
    goto LABEL_15;
  }
  uint64_t v10 = 1;
LABEL_15:

  return v10;
}

void sub_24B706B2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_24B706B4C(uint64_t a1)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  id v2 = objc_alloc_init(MEMORY[0x263F129A0]);
  uint64_t v3 = *(void **)(a1 + 320);
  *(void *)(a1 + 320) = v2;

  uint64_t v6 = *(void *)(a1 + 320);
  if (v6)
  {
    int v7 = objc_msgSend_depthAttachment(*(void **)(a1 + 320), v4, v5);
    objc_msgSend_setLoadAction_(v7, v8, 2);

    uint64_t v11 = objc_msgSend_depthAttachment(*(void **)(a1 + 320), v9, v10);
    objc_msgSend_setStoreAction_(v11, v12, 0);

    uint64_t v13 = *(void *)(a1 + 160);
    float32x4_t v16 = objc_msgSend_depthAttachment(*(void **)(a1 + 320), v14, v15);
    objc_msgSend_setTexture_(v16, v17, v13);

    __int16 v20 = objc_msgSend_colorAttachments(*(void **)(a1 + 320), v18, v19);
    uint64_t v22 = objc_msgSend_objectAtIndexedSubscript_(v20, v21, 0);
    objc_msgSend_setLoadAction_(v22, v23, 2);

    long long v26 = objc_msgSend_colorAttachments(*(void **)(a1 + 320), v24, v25);
    char v28 = objc_msgSend_objectAtIndexedSubscript_(v26, v27, 0);
    objc_msgSend_setClearColor_(v28, v29, v30, 0.0, 0.0, 0.0, 0.0);

    uint64_t v33 = objc_msgSend_colorAttachments(*(void **)(a1 + 320), v31, v32);
    long long v35 = objc_msgSend_objectAtIndexedSubscript_(v33, v34, 0);
    objc_msgSend_setStoreAction_(v35, v36, 1);

    float v39 = objc_msgSend_colorAttachments(*(void **)(a1 + 320), v37, v38);
    double v41 = objc_msgSend_objectAtIndexedSubscript_(v39, v40, 1);
    objc_msgSend_setLoadAction_(v41, v42, 2);

    uint64_t v45 = objc_msgSend_colorAttachments(*(void **)(a1 + 320), v43, v44);
    uint64_t v47 = objc_msgSend_objectAtIndexedSubscript_(v45, v46, 1);
    objc_msgSend_setClearColor_(v47, v48, v49, 0.0, 0.0, 0.0, 0.0);

    unsigned int v52 = objc_msgSend_colorAttachments(*(void **)(a1 + 320), v50, v51);
    int v54 = objc_msgSend_objectAtIndexedSubscript_(v52, v53, 1);
    objc_msgSend_setStoreAction_(v54, v55, 1);
  }
  else
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    unint64_t v56 = (id)qword_2697D1278;
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelDepthRendererUsingMesh::createRenderPassDescriptors()");
      if (v60 >= 0) {
        int v58 = __p;
      }
      else {
        int v58 = (void **)__p[0];
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      float32x4_t v62 = v58;
      __int16 v63 = 1026;
      int v64 = 415;
      _os_log_error_impl(&dword_24B6B9000, v56, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create render pass descriptor.", buf, 0x12u);
      if (v60 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  return v6 != 0;
}

void sub_24B706E28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_24B706E84()
{
  if (qword_2697D1280 != -1) {
    dispatch_once(&qword_2697D1280, &unk_26FE9D318);
  }
  uint64_t v0 = (void *)qword_2697D1278;
  return v0;
}

void *sub_24B706ED8(void ***a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    goto LABEL_7;
  }
  uint64_t v5 = (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
  uint64_t v6 = **a1;
  **a1 = (void *)v5;

  uint64_t v7 = *(void *)(a2 + 24);
  if (!v7) {
    goto LABEL_7;
  }
  uint64_t v8 = (*(void (**)(uint64_t))(*(void *)v7 + 48))(v7);
  uint64_t v9 = (*a1)[1];
  (*a1)[1] = (void *)v8;

  uint64_t v10 = *(void *)(a2 + 24);
  if (v10)
  {
    (*a1)[2] = (*(void (**)(uint64_t))(*(void *)v10 + 48))(v10);
    return (void *)MEMORY[0x270F9A758]();
  }
  else
  {
LABEL_7:
    sub_24B6EC38C();
    return sub_24B706FCC(v11);
  }
}

void *sub_24B706FCC(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

id sub_24B707050(uint64_t a1, const char *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v3 = objc_msgSend_newTextureWithDescriptor_(**(void ***)(*(void *)(a1 + 8) + 48), a2, **(void **)(a1 + 16));
  if (!v3)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v4 = qword_2697D1278;
    if (os_log_type_enabled((os_log_t)qword_2697D1278, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136315394;
      uint64_t v7 = "VoxelDepthRendererUsingMesh::createTextures";
      __int16 v8 = 1026;
      int v9 = 337;
      _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create depthTexture.", (uint8_t *)&v6, 0x12u);
    }
  }
  objc_msgSend_setLabel_(v3, v2, @"normalTexture");
  return v3;
}

void sub_24B707170(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 sub_24B707190(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26FE9D3B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_24B7071B8(uint64_t a1)
{
  id v2 = (char *)operator new(0x18uLL);
  *(void *)id v2 = &unk_26FE9D3B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_24B707204()
{
}

id sub_24B70721C(uint64_t a1, const char *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v3 = objc_msgSend_newTextureWithDescriptor_(**(void ***)(*(void *)(a1 + 8) + 48), a2, **(void **)(a1 + 16));
  if (!v3)
  {
    if (qword_2697D1280 != -1) {
      dispatch_once(&qword_2697D1280, &unk_26FE9D318);
    }
    float32x4_t v4 = qword_2697D1278;
    if (os_log_type_enabled((os_log_t)qword_2697D1278, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136315394;
      uint64_t v7 = "VoxelDepthRendererUsingMesh::createTextures";
      __int16 v8 = 1026;
      int v9 = 318;
      _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create depthTexture.", (uint8_t *)&v6, 0x12u);
    }
  }
  objc_msgSend_setLabel_(v3, v2, @"depthTexture");
  return v3;
}

void sub_24B70733C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 sub_24B70735C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26FE9D368;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_24B707384(uint64_t a1)
{
  id v2 = (char *)operator new(0x18uLL);
  *(void *)id v2 = &unk_26FE9D368;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_24B7073D0()
{
}

void sub_24B7073E8(uint64_t a1)
{
  sub_24B707420(a1);
  JUMPOUT(0x24C5D7790);
}

uint64_t sub_24B707420(uint64_t a1)
{
  atomic_store(1u, (unsigned __int8 *)(a1 + 144));
  int v2 = atomic_load((unsigned int *)(a1 + 148));
  if (v2 >= 1)
  {
    do
    {
      __ns.__rep_ = 1000000;
      std::this_thread::sleep_for (&__ns);
      int v3 = atomic_load((unsigned int *)(a1 + 148));
    }
    while (v3 > 0);
  }

  uint64_t v4 = *(void *)(a1 + 240);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 248);
    int v6 = *(void **)(a1 + 240);
    if (v5 != v4)
    {
      do
      {
        uint64_t v7 = *(void **)(v5 - 8);
        v5 -= 8;
      }
      while (v5 != v4);
      int v6 = *(void **)(a1 + 240);
    }
    *(void *)(a1 + 248) = v4;
    operator delete(v6);
  }

  uint64_t v8 = *(void *)(a1 + 168);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 176);
    uint64_t v10 = *(void **)(a1 + 168);
    if (v9 != v8)
    {
      do
      {
        uint64_t v11 = *(void **)(v9 - 8);
        v9 -= 8;
      }
      while (v9 != v8);
      uint64_t v10 = *(void **)(a1 + 168);
    }
    *(void *)(a1 + 176) = v8;
    operator delete(v10);
  }

  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 40);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  return a1;
}

void sub_24B70758C(_Unwind_Exception *a1)
{
  sub_24B7075E8((char **)(v1 + 240));
  sub_24B7075E8((char **)(v1 + 168));

  sub_24B6ED550(v1 + 32);
  _Unwind_Resume(a1);
}

char **sub_24B7075E8(char **a1)
{
  int v2 = *a1;
  if (*a1)
  {
    int v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (void *)*((void *)v3 - 1);
        v3 -= 8;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_24B707654(uint64_t a1)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = xmmword_24B72A790;
  *(void *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  int v2 = operator new(0x18uLL);
  void *v2 = 0;
  v2[1] = 0;
  v2[2] = 0;
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2 + 3;
  *(void *)(a1 + 16) = v2 + 3;
  dispatch_queue_t v3 = dispatch_queue_create("com.apple.coreocmodules.voxelHashing_tripleBuffer_serial_queue", 0);
  uint64_t v4 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = v3;

  return a1;
}

void sub_24B7076D4(_Unwind_Exception *exception_object)
{
  dispatch_queue_t v3 = (char *)*v1;
  if (*v1)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = *v1;
    if (v4 != v3)
    {
      do
      {
        int v6 = (void *)*((void *)v4 - 1);
        v4 -= 8;
      }
      while (v4 != v3);
      uint64_t v5 = *v1;
    }
    v1[1] = v3;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_24B707714(uint64_t a1, float32x2_t *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 8))
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    uint64_t v33 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
    sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::deintegratePointCloudInTruncationRegion(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
    if (v83.i8[15] >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = p_p;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 386;
    long long v35 = "%s:%{public}d VoxelIntegratorGPU not initialized.";
    goto LABEL_45;
  }
  uint64_t v5 = a5;
  uint64_t v6 = a4;
  if (sub_24B6F0650((uint64_t)a2, a3, a4, a5, *(_DWORD *)(a1 + 440)))
  {
    *(_DWORD *)(a1 + 408) = 0;
    float32x4_t v10 = *(float32x4_t *)(a1 + 224);
    float32x4_t v11 = *(float32x4_t *)(a1 + 240);
    float32x4_t v12 = *(float32x4_t *)(a1 + 256);
    float32x4_t v13 = *(float32x4_t *)(a1 + 272);
    float32x4_t v14 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2->f32)), v11, *a2, 1), v12, *(float32x4_t *)a2->f32, 2), v13, *(float32x4_t *)a2->f32, 3);
    float32x4_t v15 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2[2].f32)), v11, a2[2], 1), v12, *(float32x4_t *)a2[2].f32, 2), v13, *(float32x4_t *)a2[2].f32, 3);
    float32x4_t v16 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2[4].f32)), v11, a2[4], 1), v12, *(float32x4_t *)a2[4].f32, 2), v13, *(float32x4_t *)a2[4].f32, 3);
    float32x4_t v17 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2[6].f32)), v11, a2[6], 1), v12, *(float32x4_t *)a2[6].f32, 2), v13, *(float32x4_t *)a2[6].f32, 3);
    *(float32x4_t *)(a1 + 160) = v14;
    *(float32x4_t *)(a1 + 176) = v15;
    *(float32x4_t *)(a1 + 192) = v16;
    *(float32x4_t *)(a1 + 208) = v17;
    *(_OWORD *)(a1 + 80) = *(_OWORD *)a2[6].f32;
    if (sub_24B707F30(a1, a3, (float32x4_t *)v6, v5))
    {
      uint64_t v20 = objc_msgSend_contents(*(void **)(a1 + 448), v18, v19);
      uint64_t v23 = objc_msgSend_contents(*(void **)(a1 + 456), v21, v22);
      *(_DWORD *)(a1 + 444) = 0;
      if (a3)
      {
        unsigned int v25 = 0;
        unint64_t v26 = 0;
        id v27 = (unsigned int *)(a1 + 444);
        do
        {
          if ((*(void *)(*(void *)(a1 + 416) + ((v26 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v26))
          {
            char v28 = (float32x4_t *)(v20 + 48 * v25);
            float32x4_t v29 = *(float32x4_t *)v6;
            float32x4_t v30 = *(float32x4_t *)(v6 + 32);
            v28[1] = *(float32x4_t *)(v6 + 16);
            v28[2] = v30;
            *char v28 = v29;
            uint64_t v31 = v23 + 20 * *v27;
            long long v32 = *(_OWORD *)v5;
            *(_DWORD *)(v31 + 16) = *(_DWORD *)(v5 + 16);
            *(_OWORD *)uint64_t v31 = v32;
            unsigned int v25 = *v27 + 1;
            unsigned int *v27 = v25;
          }
          ++v26;
          v6 += 48;
          v5 += 20;
        }
        while (a3 != v26);
        if (v25)
        {
          uint64_t v33 = objc_msgSend_commandBufferWithDescriptor_(*(void **)(*(void *)(a1 + 32) + 8), v24, *(void *)(a1 + 400));
          if (v33)
          {
            sub_24B70851C(a1, v33);
            float v39 = objc_msgSend_computeCommandEncoder(v33, v37, v38);
            objc_msgSend_setLabel_(v39, v40, @"deintegrateVoxelsIntersectingRays Encoder");
            objc_msgSend_setComputePipelineState_(v39, v41, *(void *)(a1 + 376));
            objc_msgSend_setBytes_length_atIndex_(v39, v42, a1 + 48, 272, 0);
            objc_msgSend_setBytes_length_atIndex_(v39, v43, **(void **)(a1 + 320), *(void *)(*(void *)(a1 + 320) + 8) - **(void **)(a1 + 320), 1);
            objc_msgSend_setBytes_length_atIndex_(v39, v44, a1 + 408, 4, 2);
            uint64_t v45 = sub_24B721D2C(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v39, v46, (uint64_t)v45, 0, 3);

            objc_msgSend_setBytes_length_atIndex_(v39, v47, a1 + 444, 4, 4);
            objc_msgSend_setBuffer_offset_atIndex_(v39, v48, *(void *)(a1 + 448), 0, 5);
            objc_msgSend_setBuffer_offset_atIndex_(v39, v49, *(void *)(a1 + 456), 0, 6);
            uint64_t v50 = sub_24B720E24(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v39, v51, (uint64_t)v50, 0, 7);

            unsigned int v52 = sub_24B720F64(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v39, v53, (uint64_t)v52, 0, 8);

            objc_msgSend_setBuffer_offset_atIndex_(v39, v54, *(void *)(a1 + 488), 0, 9);
            char v55 = sub_24B7215B4(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v39, v56, (uint64_t)v55, 0, 10);

            __int16 v57 = sub_24B721470(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v39, v58, (uint64_t)v57, 0, 11);

            uint64_t v61 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 376), v59, v60);
            std::string __p = (void *)*v27;
            int64x2_t v83 = vdupq_n_s64(1uLL);
            *(void *)simd_float4x4 buf = v61;
            *(int64x2_t *)&uint8_t buf[8] = v83;
            objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v39, v62, (uint64_t)&__p, buf);
            objc_msgSend_endEncoding(v39, v63, v64);

            if (*(unsigned char *)(a1 + 636))
            {
              sub_24B708778((uint64_t *)a1, v33, v66);
              sub_24B70887C((uint64_t *)a1, v33, v67);
            }
            objc_msgSend_addCompletedHandler_(v33, v65, (uint64_t)&unk_26FE9D470);
            objc_msgSend_commit(v33, v68, v69);
            objc_msgSend_waitUntilCompleted(v33, v70, v71);
            if (sub_24B721AC0(*(void *)(a1 + 16), *(_DWORD *)(a1 + 408)))
            {
              kdebug_trace();
              if (sub_24B722294(*(void *)(a1 + 16), v72, v73))
              {
                kdebug_trace();
                uint64_t v36 = 1;
LABEL_28:

                return v36;
              }
              uint64_t v79 = sub_24B7089EC();
              if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
              {
                sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::deintegratePointCloudInTruncationRegion(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
                if (v83.i8[15] >= 0) {
                  uint64_t v81 = &__p;
                }
                else {
                  uint64_t v81 = __p;
                }
                *(_DWORD *)simd_float4x4 buf = 136315394;
                *(void *)&uint8_t buf[4] = v81;
                *(_WORD *)&unsigned char buf[12] = 1026;
                *(_DWORD *)&buf[14] = 446;
                _os_log_error_impl(&dword_24B6B9000, v79, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to erase hash entries with empty voxelblocks.", buf, 0x12u);
                if (v83.i8[15] < 0) {
                  operator delete(__p);
                }
              }

              kdebug_trace();
LABEL_27:
              uint64_t v36 = 0;
              goto LABEL_28;
            }
            if (qword_2697D12A0 != -1) {
              dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
            }
            BOOL v75 = (id)qword_2697D1298;
            if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
            {
LABEL_40:

              goto LABEL_27;
            }
            sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::deintegratePointCloudInTruncationRegion(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
            if (v83.i8[15] >= 0) {
              uint64_t v80 = &__p;
            }
            else {
              uint64_t v80 = __p;
            }
            *(_DWORD *)simd_float4x4 buf = 136315394;
            *(void *)&uint8_t buf[4] = v80;
            *(_WORD *)&unsigned char buf[12] = 1026;
            *(_DWORD *)&buf[14] = 436;
            uint64_t v77 = "%s:%{public}d Failed to setLastIntegratedSubmapID.";
          }
          else
          {
            if (qword_2697D12A0 != -1) {
              dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
            }
            BOOL v75 = (id)qword_2697D1298;
            if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
              goto LABEL_40;
            }
            sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::deintegratePointCloudInTruncationRegion(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
            if (v83.i8[15] >= 0) {
              uint64_t v76 = &__p;
            }
            else {
              uint64_t v76 = __p;
            }
            *(_DWORD *)simd_float4x4 buf = 136315394;
            *(void *)&uint8_t buf[4] = v76;
            *(_WORD *)&unsigned char buf[12] = 1026;
            *(_DWORD *)&buf[14] = 412;
            uint64_t v77 = "%s:%{public}d Failed to deintegrate pointcloud - Failed to create command buffer.";
          }
          _os_log_error_impl(&dword_24B6B9000, v75, OS_LOG_TYPE_ERROR, v77, buf, 0x12u);
          if (v83.i8[15] < 0) {
            operator delete(__p);
          }
          goto LABEL_40;
        }
      }
    }
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    uint64_t v33 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
    sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::deintegratePointCloudInTruncationRegion(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
    if (v83.i8[15] >= 0) {
      uint64_t v78 = &__p;
    }
    else {
      uint64_t v78 = __p;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v78;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 403;
    long long v35 = "%s:%{public}d Failed to deintegrate pointcloud - processed pointcloud is empty.";
LABEL_45:
    _os_log_error_impl(&dword_24B6B9000, v33, OS_LOG_TYPE_ERROR, v35, buf, 0x12u);
    if (v83.i8[15] < 0) {
      operator delete(__p);
    }
    goto LABEL_27;
  }
  return 0;
}

void sub_24B707EE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_24B707F30(uint64_t a1, unsigned int a2, float32x4_t *a3, uint64_t a4)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  *(_DWORD *)(a1 + 444) = 0;
  if (a2)
  {
    unint64_t v5 = 0;
    int v6 = 0;
    int v7 = 0;
    int v8 = 0;
    int v9 = 0;
    int v10 = 0;
    int v11 = 0;
    int v12 = 0;
    float v13 = *(float *)(a1 + 124);
    float v14 = *(float *)(a1 + 128);
    float v15 = *(float *)(a1 + 304);
    int v16 = *(_DWORD *)(a1 + 516);
    float32x4_t v17 = a3 + 1;
    uint64_t v18 = *(void *)(a1 + 416);
    uint64_t v19 = (float *)(a4 + 8);
    uint64_t v20 = a2;
    do
    {
      float v22 = -v17[-1].f32[2];
      BOOL v23 = v14 > v22;
      if (v13 < v22) {
        BOOL v23 = 1;
      }
      float v24 = v19[1];
      float v25 = fabsf(v24);
      BOOL v26 = v24 <= 1.0;
      if (fabsf(v24 + -1.0) <= 0.000011) {
        BOOL v26 = 1;
      }
      int v27 = v7 + v26;
      char v28 = !v26;
      BOOL v29 = v24 > 0.0 && v25 > 0.000001;
      if (v29) {
        int v7 = v27;
      }
      if (!v29) {
        char v28 = 1;
      }
      float v30 = *(v19 - 1);
      if (v30 >= v15) {
        ++v8;
      }
      if (v16 && (v16 != 1 || *(v19 - 2) <= 0.0))
      {
        char v31 = 1;
      }
      else
      {
        char v31 = 0;
        ++v10;
      }
      float32x4_t v32 = vmulq_f32(*v17, *v17);
      BOOL v33 = fabsf(sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).f32[0])+ -1.0) > 0.000011;
      if (fabsf(COERCE_FLOAT(HIDWORD(*(unsigned long long *)v17))) > 0.000001) {
        BOOL v33 = 1;
      }
      char v34 = v31 | v28;
      if (!*(unsigned char *)v19) {
        char v34 = 1;
      }
      char v35 = v34 | v23 | v33;
      unint64_t v36 = v5 >> 6;
      uint64_t v37 = 1 << v5;
      if ((v35 & 1) != 0 || v30 < v15)
      {
        uint64_t v21 = *(void *)(v18 + 8 * v36) & ~v37;
      }
      else
      {
        uint64_t v21 = *(void *)(v18 + 8 * v36) | v37;
        ++v12;
      }
      v6 += !v23;
      v9 += *(unsigned __int8 *)v19;
      v11 += !v33;
      *(void *)(v18 + 8 * v36) = v21;
      ++v5;
      v17 += 3;
      v19 += 5;
    }
    while (v20 != v5);
    if (v6)
    {
LABEL_37:
      if (v7) {
        goto LABEL_42;
      }
      goto LABEL_38;
    }
  }
  else
  {
    int v7 = 0;
    int v8 = 0;
    int v9 = 0;
    int v10 = 0;
    int v11 = 0;
    int v12 = 0;
  }
  if (qword_2697D12A0 != -1) {
    dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
  }
  uint64_t v38 = qword_2697D1298;
  if (!os_log_type_enabled((os_log_t)qword_2697D1298, OS_LOG_TYPE_ERROR)) {
    goto LABEL_37;
  }
  double v45 = *(float *)(a1 + 128);
  double v46 = *(float *)(a1 + 124);
  int v48 = 136315906;
  uint64_t v49 = "VoxelIntegratorGPU";
  __int16 v50 = 1026;
  int v51 = 801;
  __int16 v52 = 2050;
  double v53 = v45;
  __int16 v54 = 2050;
  double v55 = v46;
  _os_log_error_impl(&dword_24B6B9000, v38, OS_LOG_TYPE_ERROR, "%s:%{public}d No points with valid distance. Distance range: [%{public}f, %{public}f].", (uint8_t *)&v48, 0x26u);
  if (v7) {
    goto LABEL_42;
  }
LABEL_38:
  if (qword_2697D12A0 != -1) {
    dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
  }
  float v39 = qword_2697D1298;
  if (os_log_type_enabled((os_log_t)qword_2697D1298, OS_LOG_TYPE_ERROR))
  {
    int v48 = 136315394;
    uint64_t v49 = "VoxelIntegratorGPU";
    __int16 v50 = 1026;
    int v51 = 808;
    _os_log_error_impl(&dword_24B6B9000, v39, OS_LOG_TYPE_ERROR, "%s:%{public}d No points with valid angle of incidence. Angle of incidence range: [-pi, pi]", (uint8_t *)&v48, 0x12u);
  }
  if (v8) {
    goto LABEL_46;
  }
LABEL_42:
  if (qword_2697D12A0 != -1) {
    dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
  }
  long long v40 = qword_2697D1298;
  if (os_log_type_enabled((os_log_t)qword_2697D1298, OS_LOG_TYPE_ERROR))
  {
    double v47 = *(float *)(a1 + 304);
    int v48 = 136315650;
    uint64_t v49 = "VoxelIntegratorGPU";
    __int16 v50 = 1026;
    int v51 = 813;
    __int16 v52 = 2050;
    double v53 = v47;
    _os_log_error_impl(&dword_24B6B9000, v40, OS_LOG_TYPE_ERROR, "%s:%{public}d No points with valid confidence. Confidence threshold = %{public}f.", (uint8_t *)&v48, 0x1Cu);
    if (v10) {
      goto LABEL_51;
    }
  }
  else
  {
LABEL_46:
    if (v10) {
      goto LABEL_51;
    }
  }
  if (qword_2697D12A0 != -1) {
    dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
  }
  double v41 = qword_2697D1298;
  if (os_log_type_enabled((os_log_t)qword_2697D1298, OS_LOG_TYPE_ERROR))
  {
    int v48 = 136315394;
    uint64_t v49 = "VoxelIntegratorGPU";
    __int16 v50 = 1026;
    int v51 = 817;
    _os_log_error_impl(&dword_24B6B9000, v41, OS_LOG_TYPE_ERROR, "%s:%{public}d No points with valid weight", (uint8_t *)&v48, 0x12u);
  }
  if (v9) {
    goto LABEL_55;
  }
LABEL_51:
  if (qword_2697D12A0 != -1) {
    dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
  }
  double v42 = qword_2697D1298;
  if (os_log_type_enabled((os_log_t)qword_2697D1298, OS_LOG_TYPE_ERROR))
  {
    int v48 = 136315394;
    uint64_t v49 = "VoxelIntegratorGPU";
    __int16 v50 = 1026;
    int v51 = 821;
    _os_log_error_impl(&dword_24B6B9000, v42, OS_LOG_TYPE_ERROR, "%s:%{public}d No above plane points.", (uint8_t *)&v48, 0x12u);
    if (v11) {
      return v12 != 0;
    }
  }
  else
  {
LABEL_55:
    if (v11) {
      return v12 != 0;
    }
  }
  if (qword_2697D12A0 != -1) {
    dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
  }
  long long v43 = qword_2697D1298;
  if (os_log_type_enabled((os_log_t)qword_2697D1298, OS_LOG_TYPE_ERROR))
  {
    int v48 = 136315394;
    uint64_t v49 = "VoxelIntegratorGPU";
    __int16 v50 = 1026;
    int v51 = 825;
    _os_log_error_impl(&dword_24B6B9000, v43, OS_LOG_TYPE_ERROR, "%s:%{public}d No points with valid normals.", (uint8_t *)&v48, 0x12u);
  }
  return v12 != 0;
}

void sub_24B70851C(uint64_t a1, void *a2)
{
  id v3 = a2;
  *(_DWORD *)objc_msgSend_contents(*(void **)(a1 + 472), v4, v5) = 0;
  sub_24B7215B4(*(void *)(a1 + 16));
  id v6 = objc_claimAutoreleasedReturnValue();
  *(_DWORD *)objc_msgSend_contents(v6, v7, v8) = 0;

  sub_24B72183C(*(void *)(a1 + 16));
  id v9 = objc_claimAutoreleasedReturnValue();
  *(_DWORD *)objc_msgSend_contents(v9, v10, v11) = 0;

  uint64_t v14 = objc_msgSend_contents(*(void **)(a1 + 496), v12, v13);
  *(void *)uint64_t v14 = 0;
  *(_DWORD *)(v14 + 8) = 0;
  float32x4_t v17 = objc_msgSend_computeCommandEncoder(v3, v15, v16);
  objc_msgSend_setLabel_(v17, v18, @"resetAllHashBucketLocks Encoder");
  objc_msgSend_setComputePipelineState_(v17, v19, *(void *)(a1 + 328));
  objc_msgSend_setBytes_length_atIndex_(v17, v20, a1 + 96, 28, 0);
  objc_msgSend_setBuffer_offset_atIndex_(v17, v21, *(void *)(a1 + 464), 0, 1);
  uint64_t v43 = (*(_DWORD *)(a1 + 120) * *(_DWORD *)(a1 + 96));
  int64x2_t v44 = vdupq_n_s64(1uLL);
  long long v41 = xmmword_24B72A7A0;
  uint64_t v42 = 1;
  objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v17, v22, (uint64_t)&v43, &v41);
  objc_msgSend_endEncoding(v17, v23, v24);
  int v27 = objc_msgSend_computeCommandEncoder(v3, v25, v26);

  objc_msgSend_setLabel_(v27, v28, @"resetAllHashEntryLocks Encoder");
  objc_msgSend_setComputePipelineState_(v27, v29, *(void *)(a1 + 336));
  objc_msgSend_setBytes_length_atIndex_(v27, v30, a1 + 96, 28, 0);
  objc_msgSend_setBuffer_offset_atIndex_(v27, v31, *(void *)(a1 + 488), 0, 1);
  float32x4_t v32 = sub_24B720E24(*(void *)(a1 + 16));
  objc_msgSend_setBuffer_offset_atIndex_(v27, v33, (uint64_t)v32, 0, 2);

  uint64_t v39 = *(unsigned int *)(a1 + 108);
  int64x2_t v40 = vdupq_n_s64(1uLL);
  long long v37 = xmmword_24B72A7A0;
  uint64_t v38 = 1;
  objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v27, v34, (uint64_t)&v39, &v37);
  objc_msgSend_endEncoding(v27, v35, v36);
}

void sub_24B708730(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B708778(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_computeCommandEncoder(a2, (const char *)a2, a3);
  objc_msgSend_setLabel_(v4, v5, @"updateArgsForFindHashEntriesToErase Encoder");
  objc_msgSend_setComputePipelineState_(v4, v6, a1[48]);
  objc_msgSend_setBytes_length_atIndex_(v4, v7, (uint64_t)(a1 + 6), 272, 0);
  uint64_t v8 = sub_24B7215B4(a1[2]);
  objc_msgSend_setBuffer_offset_atIndex_(v4, v9, (uint64_t)v8, 0, 1);

  objc_msgSend_setBuffer_offset_atIndex_(v4, v10, a1[62], 0, 2);
  long long v16 = xmmword_24B72EBD0;
  uint64_t v17 = 1;
  uint64_t v15 = 1;
  long long v14 = xmmword_24B72EBD0;
  objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v4, v11, (uint64_t)&v16, &v14);
  objc_msgSend_endEncoding(v4, v12, v13);
}

void sub_24B70885C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B70887C(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_computeCommandEncoder(a2, (const char *)a2, a3);
  objc_msgSend_setLabel_(v4, v5, @"findHashEntriesToErase Encoder");
  objc_msgSend_setComputePipelineState_(v4, v6, a1[49]);
  objc_msgSend_setBytes_length_atIndex_(v4, v7, (uint64_t)(a1 + 6), 272, 0);
  uint64_t v8 = sub_24B720F64(a1[2]);
  objc_msgSend_setBuffer_offset_atIndex_(v4, v9, (uint64_t)v8, 0, 1);

  int v10 = sub_24B7215B4(a1[2]);
  objc_msgSend_setBuffer_offset_atIndex_(v4, v11, (uint64_t)v10, 0, 2);

  int v12 = sub_24B721470(a1[2]);
  objc_msgSend_setBuffer_offset_atIndex_(v4, v13, (uint64_t)v12, 0, 3);

  long long v14 = sub_24B720E24(a1[2]);
  objc_msgSend_setBuffer_offset_atIndex_(v4, v15, (uint64_t)v14, 0, 4);

  uint64_t v16 = a1[62];
  uint64_t v21 = 1;
  long long v20 = xmmword_24B72EBE8;
  objc_msgSend_dispatchThreadgroupsWithIndirectBuffer_indirectBufferOffset_threadsPerThreadgroup_(v4, v17, v16, 0, &v20);
  objc_msgSend_endEncoding(v4, v18, v19);
}

void sub_24B7089C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_24B7089EC()
{
  if (qword_2697D12A0 != -1) {
    dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
  }
  uint64_t v0 = (void *)qword_2697D1298;
  return v0;
}

void sub_24B708A40(uint64_t a1, void *a2, uint64_t a3)
{
  objc_msgSend_error(a2, (const char *)a2, a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  if (v5) {
    sub_24B704E84(v5, v3, v4);
  }
}

void sub_24B708A94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B708AA8()
{
  qword_2697D1298 = (uint64_t)os_log_create("com.apple.CoreOCModules", "VoxelHashing");
  return MEMORY[0x270F9A758]();
}

uint64_t sub_24B708AEC(uint64_t a1, float32x2_t *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v111 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 8))
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    char v34 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::integratePointCloudInTruncationRegion(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
    if (v109.i8[15] >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = p_p;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 282;
    uint64_t v36 = "%s:%{public}d VoxelIntegratorGPU not initialized.";
    goto LABEL_35;
  }
  uint64_t v5 = a5;
  uint64_t v6 = a4;
  if (!sub_24B6F0650((uint64_t)a2, a3, a4, a5, *(_DWORD *)(a1 + 440))) {
    return 0;
  }
  *(_DWORD *)(a1 + 408) = 0;
  float32x4_t v10 = *(float32x4_t *)(a1 + 224);
  float32x4_t v11 = *(float32x4_t *)(a1 + 240);
  float32x4_t v12 = *(float32x4_t *)(a1 + 256);
  float32x4_t v13 = *(float32x4_t *)(a1 + 272);
  float32x4_t v14 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2->f32)), v11, *a2, 1), v12, *(float32x4_t *)a2->f32, 2), v13, *(float32x4_t *)a2->f32, 3);
  float32x4_t v15 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2[2].f32)), v11, a2[2], 1), v12, *(float32x4_t *)a2[2].f32, 2), v13, *(float32x4_t *)a2[2].f32, 3);
  float32x4_t v16 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2[4].f32)), v11, a2[4], 1), v12, *(float32x4_t *)a2[4].f32, 2), v13, *(float32x4_t *)a2[4].f32, 3);
  float32x4_t v17 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2[6].f32)), v11, a2[6], 1), v12, *(float32x4_t *)a2[6].f32, 2), v13, *(float32x4_t *)a2[6].f32, 3);
  *(float32x4_t *)(a1 + 160) = v14;
  *(float32x4_t *)(a1 + 176) = v15;
  *(float32x4_t *)(a1 + 192) = v16;
  *(float32x4_t *)(a1 + 208) = v17;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)a2[6].f32;
  uint64_t v20 = 0;
  if (sub_24B707F30(a1, a3, (float32x4_t *)v6, v5))
  {
    if (!*(unsigned char *)(a1 + 639)) {
      sub_24B70953C(a1, a3, v6);
    }
    uint64_t v21 = objc_msgSend_contents(*(void **)(a1 + 448), v18, v19);
    uint64_t v24 = objc_msgSend_contents(*(void **)(a1 + 456), v22, v23);
    *(_DWORD *)(a1 + 444) = 0;
    if (a3)
    {
      unsigned int v26 = 0;
      unint64_t v27 = 0;
      char v28 = (unsigned int *)(a1 + 444);
      do
      {
        if ((*(void *)(*(void *)(a1 + 416) + ((v27 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v27))
        {
          BOOL v29 = (float32x4_t *)(v21 + 48 * v26);
          float32x4_t v30 = *(float32x4_t *)v6;
          float32x4_t v31 = *(float32x4_t *)(v6 + 32);
          v29[1] = *(float32x4_t *)(v6 + 16);
          v29[2] = v31;
          *BOOL v29 = v30;
          uint64_t v32 = v24 + 20 * *v28;
          long long v33 = *(_OWORD *)v5;
          *(_DWORD *)(v32 + 16) = *(_DWORD *)(v5 + 16);
          *(_OWORD *)uint64_t v32 = v33;
          unsigned int v26 = *v28 + 1;
          *char v28 = v26;
        }
        ++v27;
        v6 += 48;
        v5 += 20;
      }
      while (a3 != v27);
      if (v26)
      {
        char v34 = objc_msgSend_commandBufferWithDescriptor_(*(void **)(*(void *)(a1 + 32) + 8), v25, *(void *)(a1 + 400));
        if (v34)
        {
          sub_24B70851C(a1, v34);
          if (*v28)
          {
            uint64_t v39 = objc_msgSend_computeCommandEncoder(v34, v37, v38);
            objc_msgSend_setLabel_(v39, v40, @"integrateVoxelsUptoTruncationRegion Encoder");
            objc_msgSend_setComputePipelineState_(v39, v41, *(void *)(a1 + 360));
            objc_msgSend_setBytes_length_atIndex_(v39, v42, a1 + 48, 272, 0);
            objc_msgSend_setBytes_length_atIndex_(v39, v43, **(void **)(a1 + 320), *(void *)(*(void *)(a1 + 320) + 8) - **(void **)(a1 + 320), 1);
            objc_msgSend_setBytes_length_atIndex_(v39, v44, a1 + 408, 4, 2);
            double v45 = sub_24B721D2C(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v39, v46, (uint64_t)v45, 0, 3);

            objc_msgSend_setBytes_length_atIndex_(v39, v47, a1 + 444, 4, 4);
            objc_msgSend_setBuffer_offset_atIndex_(v39, v48, *(void *)(a1 + 448), 0, 5);
            objc_msgSend_setBuffer_offset_atIndex_(v39, v49, *(void *)(a1 + 456), 0, 6);
            __int16 v50 = sub_24B720E24(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v39, v51, (uint64_t)v50, 0, 7);

            __int16 v52 = sub_24B720F64(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v39, v53, (uint64_t)v52, 0, 8);

            objc_msgSend_setBuffer_offset_atIndex_(v39, v54, *(void *)(a1 + 488), 0, 9);
            double v55 = sub_24B7215B4(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v39, v56, (uint64_t)v55, 0, 10);

            __int16 v57 = sub_24B721470(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v39, v58, (uint64_t)v57, 0, 11);

            uint64_t v61 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 360), v59, v60);
            std::string __p = (void *)*v28;
            int64x2_t v109 = vdupq_n_s64(1uLL);
            *(void *)simd_float4x4 buf = v61;
            *(int64x2_t *)&uint8_t buf[8] = v109;
            objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v39, v62, (uint64_t)&__p, buf);
            objc_msgSend_endEncoding(v39, v63, v64);

            uint64_t v67 = objc_msgSend_computeCommandEncoder(v34, v65, v66);
            objc_msgSend_setLabel_(v67, v68, @"integrateVoxelsInTruncationRegion Encoder");
            objc_msgSend_setComputePipelineState_(v67, v69, *(void *)(a1 + 368));
            objc_msgSend_setBytes_length_atIndex_(v67, v70, a1 + 48, 272, 0);
            objc_msgSend_setBytes_length_atIndex_(v67, v71, **(void **)(a1 + 320), *(void *)(*(void *)(a1 + 320) + 8) - **(void **)(a1 + 320), 1);
            objc_msgSend_setBytes_length_atIndex_(v67, v72, a1 + 408, 4, 2);
            uint64_t v73 = sub_24B721D2C(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v67, v74, (uint64_t)v73, 0, 3);

            objc_msgSend_setBytes_length_atIndex_(v67, v75, a1 + 444, 4, 4);
            objc_msgSend_setBuffer_offset_atIndex_(v67, v76, *(void *)(a1 + 448), 0, 5);
            objc_msgSend_setBuffer_offset_atIndex_(v67, v77, *(void *)(a1 + 456), 0, 6);
            uint64_t v78 = sub_24B720E24(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v67, v79, (uint64_t)v78, 0, 7);

            uint64_t v80 = sub_24B720F64(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v67, v81, (uint64_t)v80, 0, 8);

            objc_msgSend_setBuffer_offset_atIndex_(v67, v82, *(void *)(a1 + 488), 0, 9);
            int64x2_t v83 = sub_24B7215B4(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v67, v84, (uint64_t)v83, 0, 10);

            uint64_t v85 = sub_24B721470(*(void *)(a1 + 16));
            objc_msgSend_setBuffer_offset_atIndex_(v67, v86, (uint64_t)v85, 0, 11);

            uint64_t v89 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 368), v87, v88);
            std::string __p = (void *)*v28;
            int64x2_t v109 = vdupq_n_s64(1uLL);
            *(void *)simd_float4x4 buf = v89;
            *(int64x2_t *)&uint8_t buf[8] = v109;
            objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v67, v90, (uint64_t)&__p, buf);
            objc_msgSend_endEncoding(v67, v91, v92);
          }
          if (*(unsigned char *)(a1 + 636))
          {
            sub_24B708778((uint64_t *)a1, v34, v38);
            sub_24B70887C((uint64_t *)a1, v34, v93);
          }
          objc_msgSend_addCompletedHandler_(v34, v37, (uint64_t)&unk_26FE9D450);
          objc_msgSend_commit(v34, v94, v95);
          objc_msgSend_waitUntilCompleted(v34, v96, v97);
          if (sub_24B721AC0(*(void *)(a1 + 16), *(_DWORD *)(a1 + 408)))
          {
            kdebug_trace();
            if (sub_24B722294(*(void *)(a1 + 16), v98, v99))
            {
              kdebug_trace();
              uint64_t v20 = 1;
LABEL_49:

              return v20;
            }
            uint64_t v105 = sub_24B7089EC();
            if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
            {
              sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::integratePointCloudInTruncationRegion(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
              if (v109.i8[15] >= 0) {
                float32x2_t v107 = &__p;
              }
              else {
                float32x2_t v107 = __p;
              }
              *(_DWORD *)simd_float4x4 buf = 136315394;
              *(void *)&uint8_t buf[4] = v107;
              *(_WORD *)&unsigned char buf[12] = 1026;
              *(_DWORD *)&buf[14] = 364;
              _os_log_error_impl(&dword_24B6B9000, v105, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to erase hash entries with empty voxelblocks.", buf, 0x12u);
              if (v109.i8[15] < 0) {
                operator delete(__p);
              }
            }

            kdebug_trace();
LABEL_48:
            uint64_t v20 = 0;
            goto LABEL_49;
          }
          if (qword_2697D12A0 != -1) {
            dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
          }
          uint64_t v101 = (id)qword_2697D1298;
          if (!os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
          {
LABEL_47:

            goto LABEL_48;
          }
          sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::integratePointCloudInTruncationRegion(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
          if (v109.i8[15] >= 0) {
            BOOL v106 = &__p;
          }
          else {
            BOOL v106 = __p;
          }
          *(_DWORD *)simd_float4x4 buf = 136315394;
          *(void *)&uint8_t buf[4] = v106;
          *(_WORD *)&unsigned char buf[12] = 1026;
          *(_DWORD *)&buf[14] = 354;
          std::string::size_type v103 = "%s:%{public}d Failed to setLastIntegratedSubmapID.";
        }
        else
        {
          if (qword_2697D12A0 != -1) {
            dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
          }
          uint64_t v101 = (id)qword_2697D1298;
          if (!os_log_type_enabled(v101, OS_LOG_TYPE_ERROR)) {
            goto LABEL_47;
          }
          sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::integratePointCloudInTruncationRegion(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
          if (v109.i8[15] >= 0) {
            unsigned __int8 v102 = &__p;
          }
          else {
            unsigned __int8 v102 = __p;
          }
          *(_DWORD *)simd_float4x4 buf = 136315394;
          *(void *)&uint8_t buf[4] = v102;
          *(_WORD *)&unsigned char buf[12] = 1026;
          *(_DWORD *)&buf[14] = 326;
          std::string::size_type v103 = "%s:%{public}d Failed to integrate pointcloud - Failed to create command buffer.";
        }
        _os_log_error_impl(&dword_24B6B9000, v101, OS_LOG_TYPE_ERROR, v103, buf, 0x12u);
        if (v109.i8[15] < 0) {
          operator delete(__p);
        }
        goto LABEL_47;
      }
    }
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    char v34 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::integratePointCloudInTruncationRegion(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
    if (v109.i8[15] >= 0) {
      uint64_t v100 = &__p;
    }
    else {
      uint64_t v100 = __p;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v100;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 317;
    uint64_t v36 = "%s:%{public}d Failed to integrate pointcloud - pointcloud does not intersect region of interest.";
LABEL_35:
    _os_log_error_impl(&dword_24B6B9000, v34, OS_LOG_TYPE_ERROR, v36, buf, 0x12u);
    if (v109.i8[15] < 0) {
      operator delete(__p);
    }
    goto LABEL_48;
  }
  return v20;
}

void sub_24B7094A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B70953C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  sub_24B721D2C(*(void *)(a1 + 16));
  id v6 = objc_claimAutoreleasedReturnValue();
  uint64_t v121 = objc_msgSend_contents(v6, v7, v8);

  sub_24B720E24(*(void *)(a1 + 16));
  id v9 = objc_claimAutoreleasedReturnValue();
  uint64_t v129 = objc_msgSend_contents(v9, v10, v11);

  sub_24B720F64(*(void *)(a1 + 16));
  id v12 = objc_claimAutoreleasedReturnValue();
  uint64_t v128 = objc_msgSend_contents(v12, v13, v14);

  sub_24B7210A4(*(void *)(a1 + 16));
  id v15 = objc_claimAutoreleasedReturnValue();
  uint64_t v18 = (unsigned int *)objc_msgSend_contents(v15, v16, v17);

  sub_24B7211E8(*(void *)(a1 + 16));
  id v19 = objc_claimAutoreleasedReturnValue();
  uint64_t v22 = objc_msgSend_contents(v19, v20, v21);

  sub_24B72132C(*(void *)(a1 + 16));
  id v23 = objc_claimAutoreleasedReturnValue();
  unsigned int v26 = (_DWORD *)objc_msgSend_contents(v23, v24, v25);

  sub_24B721980(*(void *)(a1 + 16));
  id v27 = objc_claimAutoreleasedReturnValue();
  uint64_t v30 = objc_msgSend_contents(v27, v28, v29);

  if (a2)
  {
    unint64_t v31 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    float32x4_t v123 = _Q0;
    uint64_t v36 = a2;
    uint64_t v119 = a2;
    uint64_t v120 = a3;
    while (1)
    {
      float32x4_t v37 = *(float32x4_t *)(a3 + 48 * v31);
      float v38 = -COERCE_FLOAT(*(void *)(a3 + 48 * v31 + 8));
      if (*(float *)(a1 + 128) <= v38 && *(float *)(a1 + 124) >= v38)
      {
        uint64_t v39 = *(void *)(a1 + 416);
        uint64_t v40 = *(void *)(v39 + 8 * (v31 >> 6));
        if ((v40 & (1 << v31)) != 0) {
          break;
        }
      }
LABEL_4:
      if (++v31 == v36) {
        return;
      }
    }
    float32x4_t v41 = *(float32x4_t *)(a3 + 48 * v31 + 16);
    float32x4_t v42 = vmulq_f32(v41, v41);
    if (fabsf(sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).f32[0])+ -1.0) > 0.000011)
    {
      int32x4_t v43 = (int32x4_t)vmulq_f32(v37, v37);
      v43.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v43, 2), vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v43.i8, 1))).u32[0];
      float32x2_t v44 = vrsqrte_f32((float32x2_t)v43.u32[0]);
      float32x2_t v45 = vmul_f32(v44, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v44, v44)));
      float32x4_t v41 = vmulq_n_f32(vnegq_f32(v37), vmul_f32(v45, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v45, v45))).f32[0]);
      v41.i32[3] = 0;
    }
    float v46 = 1.0 / (float)(*(float *)(a1 + 292) * 8.0);
    float32x4_t v47 = *(float32x4_t *)(a1 + 132);
    float32x4_t v48 = vmlaq_n_f32(v37, v41, v47.f32[0]);
    float32x4_t v49 = *(float32x4_t *)(a1 + 160);
    float32x4_t v50 = *(float32x4_t *)(a1 + 176);
    float32x4_t v51 = *(float32x4_t *)(a1 + 192);
    float32x4_t v52 = *(float32x4_t *)(a1 + 208);
    float32x4_t v53 = vmulq_n_f32(vaddq_f32(v52, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v49, v48.f32[0]), v50, *(float32x2_t *)v48.f32, 1), v51, v48, 2)), v46);
    float32x4_t v54 = vmulq_n_f32(vaddq_f32(v52, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v49, v37.f32[0]), v50, *(float32x2_t *)v37.f32, 1), v51, v37, 2)), v46);
    float v55 = vmuls_lane_f32(0.125, v47, 2);
    float v56 = vmuls_lane_f32(0.125, v47, 3);
    float32x4_t v57 = vsubq_f32(v53, v54);
    float v58 = fabsf(v57.f32[1]);
    float v59 = (float)(fabsf(v54.f32[1]) * 0.00001) + 0.000001;
    BOOL v60 = fabsf(v57.f32[0]) > (float)((float)(fabsf(v54.f32[0]) * 0.00001) + 0.000001) || v58 > v59;
    float v61 = fabsf(v57.f32[2]);
    float v62 = (float)(fabsf(v54.f32[2]) * 0.00001) + 0.000001;
    BOOL v63 = v60 || v61 > v62;
    float v64 = vabds_f32(v55, v56);
    float v65 = fabsf(v56);
    BOOL v66 = v63 && v64 > (float)((float)(v65 * 0.00001) + 0.000001);
    if (v66 && v46 > 0.0)
    {
      float32x4_t v67 = vsubq_f32(v54, v53);
      float32x4_t v68 = vmulq_f32(v67, v67);
      int32x2_t v69 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 2), vaddq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1))).u64[0];
      *(float *)v69.i32 = sqrtf(*(float *)v69.i32);
      int32x2_t v70 = 0;
      if (*(float *)v69.i32 >= 0.001) {
        float32x4_t v67 = vdivq_f32(v67, (float32x4_t)vdupq_lane_s32(v69, 0));
      }
      else {
        v69.i32[0] = 0;
      }
      float32x4_t v71 = vmulq_n_f32(*(float32x4_t *)(a1 + 48), v46);
      float32x4_t v72 = vmulq_n_f32(*(float32x4_t *)(a1 + 64), v46);
      float32x4_t v73 = vdivq_f32(v123, v67);
      float32x2_t v74 = (float32x2_t)vrev64_s32(*(int32x2_t *)v73.f32);
      int8x8_t v75 = (int8x8_t)vcgez_f32(v74);
      float32x2_t v76 = vmul_f32(v74, vsub_f32((float32x2_t)vbsl_s8(v75, (int8x8_t)vrev64_s32(*(int32x2_t *)v72.f32), (int8x8_t)vrev64_s32(*(int32x2_t *)v71.f32)), (float32x2_t)vrev64_s32(*(int32x2_t *)v53.f32)));
      float32x2_t v77 = vmul_f32(*(float32x2_t *)v73.f32, vsub_f32((float32x2_t)vbsl_s8((int8x8_t)vrev64_s32((int32x2_t)vmvn_s8(v75)), *(int8x8_t *)v72.f32, *(int8x8_t *)v71.f32), *(float32x2_t *)v53.f32));
      int32x2_t v78 = vcgt_f32(v76, v77);
      if (((v78.i32[1] | v78.i32[0]) & 1) == 0)
      {
        float v79 = fmaxf(v76.f32[1], v76.f32[0]);
        float v80 = fminf(v77.f32[0], v77.f32[1]);
        float v81 = v72.f32[2];
        if (v73.f32[2] >= 0.0) {
          float v82 = v72.f32[2];
        }
        else {
          float v82 = v71.f32[2];
        }
        if (v73.f32[2] >= 0.0) {
          float v81 = v71.f32[2];
        }
        float v83 = vmuls_lane_f32(v82 - v53.f32[2], v73, 2);
        float v84 = vmuls_lane_f32(v81 - v53.f32[2], v73, 2);
        if (v79 <= v84 && v83 <= v80)
        {
          *(float *)v70.i32 = v65 + *(float *)v69.i32;
          float v86 = fmaxf(v79, v83);
          float v87 = fminf(v80, v84);
          if (v86 > 0.0 || v87 < *(float *)v70.i32)
          {
            float v89 = fmaxf(v86, 0.0);
            float32x4_t v53 = vmlaq_n_f32(v53, v67, v89);
            *(float *)v70.i32 = fminf(*(float *)v70.i32, v87) - v89;
          }
        }
      }
      if (fabsf(*(float *)v70.i32) <= 0.000001 || *(float *)v70.i32 < 0.0)
      {
        *(void *)(v39 + 8 * (v31 >> 6)) = v40 & ~(1 << v31);
        goto LABEL_4;
      }
      int32x2_t v130 = v70;
      uint64_t v90 = *(unsigned int *)(a1 + 408);
      uint64_t v91 = (float32x4_t *)(v121 + (v90 << 8));
      float32x4_t v92 = v91[8];
      float32x4_t v93 = v91[9];
      float32x4_t v94 = v91[10];
      float32x4_t v95 = v91[11];
      float32x4_t v96 = vmlaq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v92, v67.f32[0]), v93, *(float32x2_t *)v67.f32, 1), v94, v67, 2), (float32x4_t)0, v95);
      int32x4_t v97 = (int32x4_t)vmulq_f32(v96, v96);
      v97.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v97, 2), vadd_f32(*(float32x2_t *)v97.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v97.i8, 1))).u32[0];
      float32x2_t v98 = vrsqrte_f32((float32x2_t)v97.u32[0]);
      float32x2_t v99 = vmul_f32(v98, vrsqrts_f32((float32x2_t)v97.u32[0], vmul_f32(v98, v98)));
      float32x4_t v124 = vmulq_n_f32(v96, vmul_f32(v99, vrsqrts_f32((float32x2_t)v97.u32[0], vmul_f32(v99, v99))).f32[0]);
      int32x4_t v100 = (int32x4_t)vaddq_f32(v95, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v92, v53.f32[0]), v93, *(float32x2_t *)v53.f32, 1), v94, v53, 2));
      float32x4_t v122 = (float32x4_t)v100;
      *(float32x2_t *)v53.f32 = vrndm_f32(*(float32x2_t *)v100.i8);
      v100.i32[0] = v100.i32[2];
      int v101 = vcvtms_s32_f32(*(float *)&v100.i32[2]);
      *(int32x2_t *)v53.f32 = vcvt_s32_f32(*(float32x2_t *)v53.f32);
      int32x2_t v132 = *(int32x2_t *)v53.f32;
      v53.i16[1] = v53.i16[2];
      v53.i16[2] = v101;
      int16x4_t v134 = *(int16x4_t *)v53.f32;
      sub_24B709D64((unsigned int *)(a1 + 96), **(void **)(a1 + 320), v90, &v134, *(unsigned char *)(a1 + 637), v129, v128, v18, (int8x16_t)v53, v100, (int8x16_t)v92, v22, v26, v30);
      if (v124.f32[0] >= 0.0) {
        __int16 v105 = 1;
      }
      else {
        __int16 v105 = -1;
      }
      if (v124.f32[1] >= 0.0) {
        int v106 = 1;
      }
      else {
        int v106 = -1;
      }
      int v126 = v106;
      __int16 v127 = v105;
      if (v124.f32[2] >= 0.0) {
        int v107 = 1;
      }
      else {
        int v107 = -1;
      }
      *(float32x2_t *)v102.f32 = vcvt_f32_s32(v132);
      v102.f32[2] = (float)v101;
      float32x4_t v108 = vsubq_f32(v122, v102);
      if (fabsf(v124.f32[0]) >= 1.1755e-38)
      {
        if (v124.f32[0] >= 0.0) {
          v104.f32[0] = (float)(1.0 - v108.f32[0]) / v124.f32[0];
        }
        else {
          v104.f32[0] = v108.f32[0] / (float)-v124.f32[0];
        }
      }
      else
      {
        v104.i32[0] = 2139095040;
      }
      if (fabsf(v124.f32[1]) >= 1.1755e-38)
      {
        if (v124.f32[1] >= 0.0) {
          float v109 = (float)(1.0 - v108.f32[1]) / v124.f32[1];
        }
        else {
          float v109 = v108.f32[1] / (float)-v124.f32[1];
        }
      }
      else
      {
        float v109 = INFINITY;
      }
      *(float *)v103.i32 = fabsf(v124.f32[2]);
      if (*(float *)v103.i32 >= 1.1755e-38)
      {
        if (v124.f32[2] >= 0.0)
        {
          float v110 = (float)(1.0 - v108.f32[2]) / v124.f32[2];
        }
        else
        {
          *(float *)v103.i32 = -v124.f32[2];
          float v110 = v108.f32[2] / (float)-v124.f32[2];
        }
      }
      else
      {
        float v110 = INFINITY;
      }
      v104.f32[1] = v109;
      v104.f32[2] = v110;
      int32x4_t v111 = (int32x4_t)v123;
      float32x4_t v112 = vdivq_f32(v123, vabsq_f32(v124));
      float v113 = v112.f32[2];
      float32x4_t v125 = v112;
      float v114 = v112.f32[1];
      float32x4_t v131 = (float32x4_t)vdupq_lane_s32(v130, 0);
      __int32 v115 = v132.i32[1];
      while (1)
      {
        int8x16_t v116 = (int8x16_t)vcgtq_f32(v131, v104);
        v116.i32[3] = v116.i32[2];
        if ((vmaxvq_u32((uint32x4_t)v116) & 0x80000000) == 0)
        {
          int32x4_t v117 = (int32x4_t)vmlaq_f32(v122, v124, v131);
          int8x16_t v118 = vextq_s8((int8x16_t)v117, (int8x16_t)v117, 4uLL);
          *(int32x2_t *)v118.i8 = vcvt_s32_f32(vrndm_f32(*(float32x2_t *)v118.i8));
          v117.i16[0] = vcvtms_s32_f32(*(float *)v117.i32);
          v117.i16[1] = v118.i16[0];
          v117.i16[2] = v118.i16[2];
          int16x4_t v134 = *(int16x4_t *)v117.i8;
          sub_24B709D64((unsigned int *)(a1 + 96), **(void **)(a1 + 320), *(_DWORD *)(a1 + 408), &v134, *(unsigned char *)(a1 + 637), v129, v128, v18, v118, v117, (int8x16_t)v131, v22, v26, v30);
          uint64_t v36 = v119;
          a3 = v120;
          goto LABEL_4;
        }
        v111.i32[0] = v104.i32[1];
        if (v104.f32[0] >= v104.f32[1]) {
          break;
        }
        if (v104.f32[0] >= v104.f32[2]) {
          goto LABEL_69;
        }
        *(int16x4_t *)v116.i8 = v134;
        v134.i16[0] += v127;
        int32x4_t v111 = (int32x4_t)v125;
        *(float *)v111.i32 = v125.f32[0] + v104.f32[0];
        v104.f32[0] = v125.f32[0] + v104.f32[0];
        float32x4_t v133 = v104;
        int v101 = v116.u16[2];
        __int32 v115 = v116.u16[1];
LABEL_71:
        sub_24B709D64((unsigned int *)(a1 + 96), **(void **)(a1 + 320), *(_DWORD *)(a1 + 408), &v134, *(unsigned char *)(a1 + 637), v129, v128, v18, v116, v111, v103, v22, v26, v30);
        float32x4_t v104 = v133;
      }
      if (v104.f32[1] >= v104.f32[2])
      {
LABEL_69:
        v101 += v107;
        v134.i16[2] = v101;
        *(float *)v116.i32 = v113 + v104.f32[2];
        v104.f32[2] = v113 + v104.f32[2];
      }
      else
      {
        v115 += v126;
        v134.i16[1] = v115;
        *(float *)v116.i32 = v114 + v104.f32[1];
        v104.f32[1] = v114 + v104.f32[1];
      }
      float32x4_t v133 = v104;
      goto LABEL_71;
    }
  }
}

void sub_24B709CD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B709CFC(uint64_t a1, void *a2, uint64_t a3)
{
  objc_msgSend_error(a2, (const char *)a2, a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  if (v5) {
    sub_24B704E84(v5, v3, v4);
  }
}

void sub_24B709D50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B709D64(unsigned int *a1, uint64_t a2, unsigned int a3, int16x4_t *a4, char a5, uint64_t a6, uint64_t a7, unsigned int *a8, int8x16_t a9, int32x4_t a10, int8x16_t a11, uint64_t a12, _DWORD *a13, uint64_t a14)
{
  int16x4_t v14 = *a4;
  a9.i32[0] = a4->i16[0];
  a11.i32[0] = HIWORD(a4->u32[0]);
  a11.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)a4);
  *(int32x2_t *)a11.i8 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)a11.i8, 0x10uLL), 0x10uLL);
  int32x4_t v15 = vmulq_s32((int32x4_t)vextq_s8(vextq_s8(a9, a9, 4uLL), a11, 0xCuLL), (int32x4_t)xmmword_24B72A710);
  int8x16_t v16 = veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 1), (int8x16_t)vdupq_laneq_s32(v15, 2));
  int8x16_t v17 = veorq_s8(v16, (int8x16_t)v15);
  unsigned int v18 = *a1;
  unsigned int v19 = a1[1];
  unsigned int v20 = v17.i32[0] % *a1;
  int v21 = *a1 * a3;
  uint64_t v22 = (v21 + v20) * v19;
  id v23 = (unsigned int *)(a2 + 8 * a3);
  unsigned int v25 = *v23;
  unsigned int v24 = v23[1];
  BOOL v26 = *v23 <= v22 && v24 > v22;
  if (!v26
    || ((v27 = v22 + v19, v27 <= v24) ? (BOOL v28 = v22 > v24 - v19) : (BOOL v28 = 1),
        v28))
  {
    unsigned int v29 = a1[3];
LABEL_12:
    LODWORD(v22) = v29;
LABEL_13:
    unsigned int v30 = v29;
    unsigned int v31 = v29;
    unsigned int v32 = v29;
    if (v22 < v29) {
      goto LABEL_17;
    }
    goto LABEL_14;
  }
  unsigned int v29 = a1[3];
  if (v22 >= v27) {
    goto LABEL_12;
  }
  unsigned int v30 = a1[3];
  unsigned int v31 = v30;
  unsigned int v32 = v30;
  do
  {
    if ((*(_DWORD *)(a6 + 24 * v22 + 12) & 0x80000000) != 0)
    {
      if (v30 == v29) {
        unsigned int v30 = v22;
      }
    }
    else
    {
      v17.i64[0] = *(void *)(a6 + 24 * v22);
      *(int16x4_t *)v16.i8 = vceq_s16(*(int16x4_t *)v17.i8, v14);
      v16.i16[3] = v16.i16[2];
      if ((vminv_u16(*(uint16x4_t *)v16.i8) & 0x8000) != 0) {
        goto LABEL_13;
      }
      v16.i32[0] = v17.i16[0];
      v17.i32[0] = v17.u16[1];
      v17.i32[1] = v17.u16[2];
      *(int32x2_t *)v17.i8 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)v17.i8, 0x10uLL), 0x10uLL);
      int32x4_t v35 = vmulq_s32((int32x4_t)vextq_s8(vextq_s8(v16, v16, 4uLL), v17, 0xCuLL), (int32x4_t)xmmword_24B72A710);
      int8x16_t v16 = veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v35.i8, 1), (int8x16_t)vdupq_laneq_s32(v35, 2));
      int8x16_t v17 = veorq_s8(v16, (int8x16_t)v35);
      if (v17.i32[0] % v18 == v20)
      {
        if (v32 == v29)
        {
          unsigned int v36 = *(_DWORD *)(a6 + 24 * v22 + 8);
          if (v25 <= v36)
          {
            if (v24 <= v36) {
              unsigned int v32 = a1[3];
            }
            else {
              unsigned int v32 = v22;
            }
          }
          else
          {
            unsigned int v32 = a1[3];
          }
        }
        unsigned int v31 = v22;
      }
    }
    ++v22;
  }
  while (v22 != v27);
  LODWORD(v22) = a1[3];
LABEL_14:
  if (v30 >= v29 && v31 >= v29 && v32 >= v29) {
    return 0xFFFFFFFFLL;
  }
LABEL_17:
  if (v25 <= v22 && v24 > v22) {
    return 0xFFFFFFFFLL;
  }
  if (v25 <= v30 && v24 > v30 && (*(_DWORD *)(a6 + 24 * v30 + 12) & 0x80000000) != 0)
  {
    uint64_t v62 = *a13;
    *a13 = v62 - 1;
    if ((v62 & 0x80000000) != 0)
    {
      uint64_t v63 = *a8;
      if (a1[4] >= (int)v63 + 1) {
        unsigned int v64 = v63 + 1;
      }
      else {
        unsigned int v64 = a1[4];
      }
      *a8 = v64;
    }
    else
    {
      uint64_t v63 = *(unsigned int *)(a12 + 4 * v62);
    }
    uint64_t v33 = 0xFFFFFFFFLL;
    if ((v63 & 0x80000000) == 0 && (int)v63 < (int)a1[4])
    {
      sub_24B70A260(a3, v30, a4, v63, a5, a6, a7, a14);
      return v63;
    }
  }
  else
  {
    if (v25 <= v32 && v24 > v32)
    {
      unsigned int v31 = v32;
      while (1)
      {
        unsigned int v37 = *(_DWORD *)(a6 + 24 * v31 + 8);
        if (v25 > v37 || v24 <= v37) {
          break;
        }
        uint16x4_t v39 = (uint16x4_t)vceq_s16(*(int16x4_t *)(a6 + 24 * v37), v14);
        v39.i16[3] = v39.i16[2];
        unsigned int v31 = *(_DWORD *)(a6 + 24 * v31 + 8);
        if ((vminv_u16(v39) & 0x8000) != 0) {
          return 0xFFFFFFFFLL;
        }
      }
    }
    uint64_t v33 = 0xFFFFFFFFLL;
    if (v25 <= v31 && v24 > v31)
    {
      uint64_t v40 = a6 + 24 * v31;
      unsigned int v43 = *(_DWORD *)(v40 + 8);
      float32x4_t v42 = (unsigned int *)(v40 + 8);
      unsigned int v41 = v43;
      BOOL v44 = v25 <= v43 && v24 > v41;
      if (v44 || (*(_DWORD *)(a6 + 24 * v31 + 12) & 0x80000000) != 0)
      {
LABEL_97:
        unsigned int v54 = v29;
      }
      else
      {
        unsigned int v45 = v31 / v19;
        if (v31 % v19 + 2 >= v19) {
          ++v45;
        }
        int v46 = v45 % v18;
        unsigned int v47 = v46;
        while (1)
        {
          uint64_t v48 = (v47 + v21) * v19;
          uint64_t v49 = v48 + v19;
          BOOL v53 = v25 <= v49
             && v25 <= v48
             && v24 > v48
             && v48 <= v24 - v19
             && v24 > v49;
          unsigned int v54 = v29;
          if (v53)
          {
            if (v48 < v49)
            {
              BOOL v55 = 0;
              int v56 = 0;
              float32x4_t v57 = (unsigned int *)(a6 + 8 + 24 * v48);
              unsigned int v54 = v29;
              while (1)
              {
                if ((v57[1] & 0x80000000) != 0)
                {
                  if (v54 == v29) {
                    unsigned int v54 = v48;
                  }
                  if (v56) {
                    goto LABEL_93;
                  }
                  int v56 = 1;
                }
                else if (v55)
                {
                  BOOL v55 = 1;
                }
                else if (v25 <= *v57 && v24 > *v57)
                {
                  a10.i32[0] = *((__int16 *)v57 - 4);
                  a10.i32[1] = *((__int16 *)v57 - 3);
                  a10.i32[2] = *((__int16 *)v57 - 2);
                  int32x4_t v59 = vmulq_s32(a10, (int32x4_t)xmmword_24B72A710);
                  a10 = (int32x4_t)veorq_s8(veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v59.i8, 1), (int8x16_t)vdupq_laneq_s32(v59, 2)), (int8x16_t)v59);
                  BOOL v55 = a10.i32[0] % v18 == v47;
                }
                else
                {
                  BOOL v55 = 0;
                }
                v57 += 6;
                if (v49 == ++v48) {
                  goto LABEL_91;
                }
              }
            }
            int v56 = 0;
            BOOL v55 = 0;
            unsigned int v54 = v29;
LABEL_91:
            if (!v55 || v56 == 0) {
              unsigned int v54 = v29;
            }
          }
LABEL_93:
          if (v25 <= v54 && v24 > v54) {
            break;
          }
          unsigned int v47 = (v47 + v21 + 1) % v18;
          if (v47 == v46) {
            goto LABEL_97;
          }
        }
      }
      uint64_t v33 = 0xFFFFFFFFLL;
      if (v25 <= v54 && v24 > v54)
      {
        uint64_t v60 = *a13;
        *a13 = v60 - 1;
        if ((v60 & 0x80000000) != 0)
        {
          uint64_t v61 = *a8;
          if (a1[4] >= (int)v61 + 1) {
            unsigned int v65 = v61 + 1;
          }
          else {
            unsigned int v65 = a1[4];
          }
          *a8 = v65;
        }
        else
        {
          uint64_t v61 = *(unsigned int *)(a12 + 4 * v60);
        }
        uint64_t v33 = 0xFFFFFFFFLL;
        if ((v61 & 0x80000000) == 0 && (int)v61 < (int)a1[4])
        {
          sub_24B70A260(a3, v54, a4, v61, a5, a6, a7, a14);
          unsigned int *v42 = v54;
          return v61;
        }
      }
    }
  }
  return v33;
}

double sub_24B70A260(int a1, unsigned int a2, void *a3, unsigned int a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a6 + 24 * a2;
  *(void *)uint64_t v8 = *a3;
  *(_DWORD *)(v8 + 12) = a4;
  uint64_t v9 = a7 + 17368 * a4;
  atomic_store(0, (unsigned int *)(v9 + 6144));
  if (a5)
  {
    uint64_t v10 = 0;
    uint64_t v11 = (unsigned int *)(a8 + 30852 * a4);
    atomic_store(0, v11);
    id v12 = (char *)v11 + 28834;
    uint64_t v13 = a7 + 17368 * a4 + 48;
    int16x4_t v14 = v11 + 7205;
    do
    {
      uint64_t v15 = 0;
      uint64_t v16 = v13;
      do
      {
        *(_WORD *)(v16 - 44) = 0;
        *(_DWORD *)(v16 - 48) = 0;
        *(_DWORD *)(v16 - 40) = 0;
        int8x16_t v17 = &v14[v15];
        *((_WORD *)v17 - 8) = 0;
        unsigned int v18 = &v12[v15 * 4];
        *((_WORD *)v18 - 14) = -1;
        *(_WORD *)(v16 - 32) = 0;
        *(_DWORD *)(v16 - 36) = 0;
        *(_DWORD *)(v16 - 28) = 0;
        *((_WORD *)v17 - 6) = 0;
        *((_WORD *)v18 - 12) = -1;
        *(_WORD *)(v16 - 20) = 0;
        *(_DWORD *)(v16 - 24) = 0;
        *(_DWORD *)(v16 - 16) = 0;
        *((_WORD *)v17 - 4) = 0;
        *((_WORD *)v18 - 10) = -1;
        *(_WORD *)(v16 - 8) = 0;
        *(_DWORD *)(v16 - 12) = 0;
        *(_DWORD *)(v16 - 4) = 0;
        *((_WORD *)v17 - 2) = 0;
        *((_WORD *)v18 - 8) = -1;
        *(_WORD *)(v16 + 4) = 0;
        *(_DWORD *)uint64_t v16 = 0;
        *(_DWORD *)(v16 + 8) = 0;
        *(_WORD *)int8x16_t v17 = 0;
        *((_WORD *)v18 - 6) = -1;
        *(_WORD *)(v16 + 16) = 0;
        *(_DWORD *)(v16 + 12) = 0;
        *(_DWORD *)(v16 + 20) = 0;
        *((_WORD *)v17 + 2) = 0;
        *((_WORD *)v18 - 4) = -1;
        *(_WORD *)(v16 + 28) = 0;
        *(_DWORD *)(v16 + 24) = 0;
        *(_DWORD *)(v16 + 32) = 0;
        *((_WORD *)v17 + 4) = 0;
        *((_WORD *)v18 - 2) = -1;
        *(_WORD *)(v16 + 40) = 0;
        *(_DWORD *)(v16 + 36) = 0;
        *(_DWORD *)(v16 + 44) = 0;
        *((_WORD *)v17 + 6) = 0;
        v15 += 8;
        v16 += 96;
        *(_WORD *)unsigned int v18 = -1;
      }
      while (v15 != 64);
      ++v10;
      v12 += 256;
      v13 += 768;
      v14 += 64;
    }
    while (v10 != 8);
  }
  else
  {
    uint64_t v19 = -6144;
    do
    {
      uint64_t v20 = v9 + v19;
      *(_WORD *)(v20 + 6148) = 0;
      *(_DWORD *)(v20 + 6144) = 0;
      *(_DWORD *)(v20 + 6152) = 0;
      *(_WORD *)(v20 + 6160) = 0;
      *(_DWORD *)(v20 + 6156) = 0;
      *(_DWORD *)(v20 + 6164) = 0;
      *(_WORD *)(v20 + 6172) = 0;
      *(_DWORD *)(v20 + 6168) = 0;
      *(_DWORD *)(v20 + 6176) = 0;
      *(_WORD *)(v20 + 6184) = 0;
      *(_DWORD *)(v20 + 6180) = 0;
      *(_DWORD *)(v20 + 6188) = 0;
      *(_WORD *)(v20 + 6196) = 0;
      *(_DWORD *)(v20 + 6192) = 0;
      *(_DWORD *)(v20 + 6200) = 0;
      *(_WORD *)(v20 + 6208) = 0;
      *(_DWORD *)(v20 + 6204) = 0;
      *(_DWORD *)(v20 + 6212) = 0;
      *(_WORD *)(v20 + 6220) = 0;
      *(_DWORD *)(v20 + 6216) = 0;
      *(_DWORD *)(v20 + 6224) = 0;
      *(_WORD *)(v20 + 6232) = 0;
      *(_DWORD *)(v20 + 6228) = 0;
      *(_DWORD *)(v20 + 6236) = 0;
      *(_WORD *)(v20 + 6244) = 0;
      *(_DWORD *)(v20 + 6240) = 0;
      *(_DWORD *)(v20 + 6248) = 0;
      *(_WORD *)(v20 + 6256) = 0;
      *(_DWORD *)(v20 + 6252) = 0;
      *(_DWORD *)(v20 + 6260) = 0;
      *(_WORD *)(v20 + 6268) = 0;
      *(_DWORD *)(v20 + 6264) = 0;
      *(_DWORD *)(v20 + 6272) = 0;
      *(_WORD *)(v20 + 6280) = 0;
      *(_DWORD *)(v20 + 6276) = 0;
      *(_DWORD *)(v20 + 6284) = 0;
      *(_WORD *)(v20 + 6292) = 0;
      *(_DWORD *)(v20 + 6288) = 0;
      *(_DWORD *)(v20 + 6296) = 0;
      *(_WORD *)(v20 + 6304) = 0;
      *(_DWORD *)(v20 + 6300) = 0;
      *(_DWORD *)(v20 + 6308) = 0;
      *(_WORD *)(v20 + 6316) = 0;
      *(_DWORD *)(v20 + 6312) = 0;
      *(_DWORD *)(v20 + 6320) = 0;
      *(_WORD *)(v20 + 6328) = 0;
      *(_DWORD *)(v20 + 6324) = 0;
      *(_DWORD *)(v20 + 6332) = 0;
      *(_WORD *)(v20 + 6340) = 0;
      *(_DWORD *)(v20 + 6336) = 0;
      *(_DWORD *)(v20 + 6344) = 0;
      *(_WORD *)(v20 + 6352) = 0;
      *(_DWORD *)(v20 + 6348) = 0;
      *(_DWORD *)(v20 + 6356) = 0;
      *(_WORD *)(v20 + 6364) = 0;
      *(_DWORD *)(v20 + 6360) = 0;
      *(_DWORD *)(v20 + 6368) = 0;
      *(_WORD *)(v20 + 6376) = 0;
      *(_DWORD *)(v20 + 6372) = 0;
      *(_DWORD *)(v20 + 6380) = 0;
      *(_WORD *)(v20 + 6388) = 0;
      *(_DWORD *)(v20 + 6384) = 0;
      *(_DWORD *)(v20 + 6392) = 0;
      *(_WORD *)(v20 + 6400) = 0;
      *(_DWORD *)(v20 + 6396) = 0;
      *(_DWORD *)(v20 + 6404) = 0;
      *(_WORD *)(v20 + 6412) = 0;
      *(_DWORD *)(v20 + 6408) = 0;
      *(_DWORD *)(v20 + 6416) = 0;
      *(_WORD *)(v20 + 6424) = 0;
      *(_DWORD *)(v20 + 6420) = 0;
      *(_DWORD *)(v20 + 6428) = 0;
      *(_WORD *)(v20 + 6436) = 0;
      *(_DWORD *)(v20 + 6432) = 0;
      *(_DWORD *)(v20 + 6440) = 0;
      *(_WORD *)(v20 + 6448) = 0;
      *(_DWORD *)(v20 + 6444) = 0;
      *(_DWORD *)(v20 + 6452) = 0;
      *(_WORD *)(v20 + 6460) = 0;
      *(_DWORD *)(v20 + 6456) = 0;
      *(_DWORD *)(v20 + 6464) = 0;
      *(_WORD *)(v20 + 6472) = 0;
      *(_DWORD *)(v20 + 6468) = 0;
      *(_DWORD *)(v20 + 6476) = 0;
      *(_WORD *)(v20 + 6484) = 0;
      *(_DWORD *)(v20 + 6480) = 0;
      *(_DWORD *)(v20 + 6488) = 0;
      *(_WORD *)(v20 + 6496) = 0;
      *(_DWORD *)(v20 + 6492) = 0;
      *(_DWORD *)(v20 + 6500) = 0;
      *(_WORD *)(v20 + 6508) = 0;
      *(_DWORD *)(v20 + 6504) = 0;
      *(_DWORD *)(v20 + 6512) = 0;
      *(_WORD *)(v20 + 6520) = 0;
      *(_DWORD *)(v20 + 6516) = 0;
      *(_DWORD *)(v20 + 6524) = 0;
      *(_WORD *)(v20 + 6532) = 0;
      *(_DWORD *)(v20 + 6528) = 0;
      *(_DWORD *)(v20 + 6536) = 0;
      *(_WORD *)(v20 + 6544) = 0;
      *(_DWORD *)(v20 + 6540) = 0;
      *(_DWORD *)(v20 + 6548) = 0;
      *(_WORD *)(v20 + 6556) = 0;
      *(_DWORD *)(v20 + 6552) = 0;
      *(_DWORD *)(v20 + 6560) = 0;
      *(_WORD *)(v20 + 6568) = 0;
      *(_DWORD *)(v20 + 6564) = 0;
      *(_DWORD *)(v20 + 6572) = 0;
      *(_WORD *)(v20 + 6580) = 0;
      *(_DWORD *)(v20 + 6576) = 0;
      *(_DWORD *)(v20 + 6584) = 0;
      *(_WORD *)(v20 + 6592) = 0;
      *(_DWORD *)(v20 + 6588) = 0;
      *(_DWORD *)(v20 + 6596) = 0;
      *(_WORD *)(v20 + 6604) = 0;
      *(_DWORD *)(v20 + 6600) = 0;
      *(_DWORD *)(v20 + 6608) = 0;
      *(_WORD *)(v20 + 6616) = 0;
      *(_DWORD *)(v20 + 6612) = 0;
      *(_DWORD *)(v20 + 6620) = 0;
      *(_WORD *)(v20 + 6628) = 0;
      *(_DWORD *)(v20 + 6624) = 0;
      *(_DWORD *)(v20 + 6632) = 0;
      *(_WORD *)(v20 + 6640) = 0;
      *(_DWORD *)(v20 + 6636) = 0;
      *(_DWORD *)(v20 + 6644) = 0;
      *(_WORD *)(v20 + 6652) = 0;
      *(_DWORD *)(v20 + 6648) = 0;
      *(_DWORD *)(v20 + 6656) = 0;
      *(_WORD *)(v20 + 6664) = 0;
      *(_DWORD *)(v20 + 6660) = 0;
      *(_DWORD *)(v20 + 6668) = 0;
      *(_WORD *)(v20 + 6676) = 0;
      *(_DWORD *)(v20 + 6672) = 0;
      *(_DWORD *)(v20 + 6680) = 0;
      *(_WORD *)(v20 + 6688) = 0;
      *(_DWORD *)(v20 + 6684) = 0;
      *(_DWORD *)(v20 + 6692) = 0;
      *(_WORD *)(v20 + 6700) = 0;
      *(_DWORD *)(v20 + 6696) = 0;
      *(_DWORD *)(v20 + 6704) = 0;
      *(_WORD *)(v20 + 6712) = 0;
      *(_DWORD *)(v20 + 6708) = 0;
      *(_DWORD *)(v20 + 6716) = 0;
      *(_WORD *)(v20 + 6724) = 0;
      *(_DWORD *)(v20 + 6720) = 0;
      *(_DWORD *)(v20 + 6728) = 0;
      *(_WORD *)(v20 + 6736) = 0;
      *(_DWORD *)(v20 + 6732) = 0;
      *(_DWORD *)(v20 + 6740) = 0;
      *(_WORD *)(v20 + 6748) = 0;
      *(_DWORD *)(v20 + 6744) = 0;
      *(_DWORD *)(v20 + 6752) = 0;
      *(_WORD *)(v20 + 6760) = 0;
      *(_DWORD *)(v20 + 6756) = 0;
      *(_DWORD *)(v20 + 6764) = 0;
      *(_WORD *)(v20 + 6772) = 0;
      *(_DWORD *)(v20 + 6768) = 0;
      *(_DWORD *)(v20 + 6776) = 0;
      *(_WORD *)(v20 + 6784) = 0;
      *(_DWORD *)(v20 + 6780) = 0;
      *(_DWORD *)(v20 + 6788) = 0;
      *(_WORD *)(v20 + 6796) = 0;
      *(_DWORD *)(v20 + 6792) = 0;
      *(_DWORD *)(v20 + 6800) = 0;
      *(_WORD *)(v20 + 6808) = 0;
      *(_DWORD *)(v20 + 6804) = 0;
      *(_DWORD *)(v20 + 6812) = 0;
      *(_WORD *)(v20 + 6820) = 0;
      *(_DWORD *)(v20 + 6816) = 0;
      *(_DWORD *)(v20 + 6824) = 0;
      *(_WORD *)(v20 + 6832) = 0;
      *(_DWORD *)(v20 + 6828) = 0;
      *(_DWORD *)(v20 + 6836) = 0;
      *(_WORD *)(v20 + 6844) = 0;
      *(_DWORD *)(v20 + 6840) = 0;
      *(_DWORD *)(v20 + 6848) = 0;
      *(_WORD *)(v20 + 6856) = 0;
      *(_DWORD *)(v20 + 6852) = 0;
      *(_DWORD *)(v20 + 6860) = 0;
      *(_WORD *)(v20 + 6868) = 0;
      *(_DWORD *)(v20 + 6864) = 0;
      *(_DWORD *)(v20 + 6872) = 0;
      *(_WORD *)(v20 + 6880) = 0;
      *(_DWORD *)(v20 + 6876) = 0;
      *(_DWORD *)(v20 + 6884) = 0;
      *(_WORD *)(v20 + 6892) = 0;
      *(_DWORD *)(v20 + 6888) = 0;
      *(_DWORD *)(v20 + 6896) = 0;
      *(_WORD *)(v20 + 6904) = 0;
      *(_DWORD *)(v20 + 6900) = 0;
      *(_DWORD *)(v20 + 6908) = 0;
      v19 += 768;
    }
    while (v19);
  }
  double result = *(double *)a3;
  uint64_t v22 = a7 + 17368 * a4;
  *(void *)(v22 + 17352) = *a3;
  *(_DWORD *)(v22 + 17360) = a1;
  *(unsigned char *)(v22 + 17364) = 0;
  return result;
}

uint64_t sub_24B70A6D0(uint64_t a1, float32x2_t *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 8))
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    uint64_t v33 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::integratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
    if (v86.i8[15] >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = p_p;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 183;
    int32x4_t v35 = "%s:%{public}d VoxelIntegratorGPU not initialized.";
    goto LABEL_33;
  }
  uint64_t v5 = a5;
  uint64_t v6 = a4;
  if (!sub_24B6F0650((uint64_t)a2, a3, a4, a5, *(_DWORD *)(a1 + 440))) {
    return 0;
  }
  *(_DWORD *)(a1 + 408) = 0;
  float32x4_t v10 = *(float32x4_t *)(a1 + 224);
  float32x4_t v11 = *(float32x4_t *)(a1 + 240);
  float32x4_t v12 = *(float32x4_t *)(a1 + 256);
  float32x4_t v13 = *(float32x4_t *)(a1 + 272);
  float32x4_t v14 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2->f32)), v11, *a2, 1), v12, *(float32x4_t *)a2->f32, 2), v13, *(float32x4_t *)a2->f32, 3);
  float32x4_t v15 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2[2].f32)), v11, a2[2], 1), v12, *(float32x4_t *)a2[2].f32, 2), v13, *(float32x4_t *)a2[2].f32, 3);
  float32x4_t v16 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2[4].f32)), v11, a2[4], 1), v12, *(float32x4_t *)a2[4].f32, 2), v13, *(float32x4_t *)a2[4].f32, 3);
  float32x4_t v17 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(*(_OWORD *)a2[6].f32)), v11, a2[6], 1), v12, *(float32x4_t *)a2[6].f32, 2), v13, *(float32x4_t *)a2[6].f32, 3);
  *(float32x4_t *)(a1 + 160) = v14;
  *(float32x4_t *)(a1 + 176) = v15;
  *(float32x4_t *)(a1 + 192) = v16;
  *(float32x4_t *)(a1 + 208) = v17;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)a2[6].f32;
  uint64_t v20 = 0;
  if (sub_24B707F30(a1, a3, (float32x4_t *)v6, v5))
  {
    if (!*(unsigned char *)(a1 + 639)) {
      sub_24B70953C(a1, a3, v6);
    }
    uint64_t v21 = objc_msgSend_contents(*(void **)(a1 + 448), v18, v19);
    uint64_t v24 = objc_msgSend_contents(*(void **)(a1 + 456), v22, v23);
    *(_DWORD *)(a1 + 444) = 0;
    if (a3)
    {
      unsigned int v26 = 0;
      unint64_t v27 = 0;
      do
      {
        if ((*(void *)(*(void *)(a1 + 416) + ((v27 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v27))
        {
          BOOL v28 = (float32x4_t *)(v21 + 48 * v26);
          float32x4_t v29 = *(float32x4_t *)v6;
          float32x4_t v30 = *(float32x4_t *)(v6 + 32);
          v28[1] = *(float32x4_t *)(v6 + 16);
          v28[2] = v30;
          *BOOL v28 = v29;
          uint64_t v31 = v24 + 20 * *(unsigned int *)(a1 + 444);
          long long v32 = *(_OWORD *)v5;
          *(_DWORD *)(v31 + 16) = *(_DWORD *)(v5 + 16);
          *(_OWORD *)uint64_t v31 = v32;
          unsigned int v26 = *(_DWORD *)(a1 + 444) + 1;
          *(_DWORD *)(a1 + 444) = v26;
        }
        ++v27;
        v6 += 48;
        v5 += 20;
      }
      while (a3 != v27);
      if (v26)
      {
        uint64_t v33 = objc_msgSend_commandBufferWithDescriptor_(*(void **)(*(void *)(a1 + 32) + 8), v25, *(void *)(a1 + 400));
        if (v33)
        {
          sub_24B70851C(a1, v33);
          unsigned int v36 = *(void **)(a1 + 448);
          unsigned int v37 = *(void **)(a1 + 456);
          int v87 = *(_DWORD *)(a1 + 444);
          id v38 = v36;
          id v39 = v37;
          float32x4_t v42 = objc_msgSend_computeCommandEncoder(v33, v40, v41);
          objc_msgSend_setLabel_(v42, v43, @"integrateVoxelsBetweenCameraAndEndPoints Encoder");
          objc_msgSend_setComputePipelineState_(v42, v44, *(void *)(a1 + 352));
          objc_msgSend_setBytes_length_atIndex_(v42, v45, a1 + 48, 272, 0);
          objc_msgSend_setBytes_length_atIndex_(v42, v46, **(void **)(a1 + 320), *(void *)(*(void *)(a1 + 320) + 8) - **(void **)(a1 + 320), 1);
          objc_msgSend_setBytes_length_atIndex_(v42, v47, a1 + 408, 4, 2);
          uint64_t v48 = sub_24B721D2C(*(void *)(a1 + 16));
          objc_msgSend_setBuffer_offset_atIndex_(v42, v49, (uint64_t)v48, 0, 3);

          objc_msgSend_setBytes_length_atIndex_(v42, v50, (uint64_t)&v87, 4, 4);
          objc_msgSend_setBuffer_offset_atIndex_(v42, v51, (uint64_t)v38, 0, 5);
          objc_msgSend_setBuffer_offset_atIndex_(v42, v52, (uint64_t)v39, 0, 6);
          BOOL v53 = sub_24B720E24(*(void *)(a1 + 16));
          objc_msgSend_setBuffer_offset_atIndex_(v42, v54, (uint64_t)v53, 0, 7);

          BOOL v55 = sub_24B720F64(*(void *)(a1 + 16));
          objc_msgSend_setBuffer_offset_atIndex_(v42, v56, (uint64_t)v55, 0, 8);

          objc_msgSend_setBuffer_offset_atIndex_(v42, v57, *(void *)(a1 + 488), 0, 9);
          float v58 = sub_24B7215B4(*(void *)(a1 + 16));
          objc_msgSend_setBuffer_offset_atIndex_(v42, v59, (uint64_t)v58, 0, 10);

          uint64_t v60 = sub_24B721470(*(void *)(a1 + 16));
          objc_msgSend_setBuffer_offset_atIndex_(v42, v61, (uint64_t)v60, 0, 11);

          uint64_t v64 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 352), v62, v63);
          std::string __p = (void *)*(unsigned int *)(a1 + 444);
          int64x2_t v86 = vdupq_n_s64(1uLL);
          *(void *)simd_float4x4 buf = v64;
          *(int64x2_t *)&uint8_t buf[8] = v86;
          objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v42, v65, (uint64_t)&__p, buf);
          objc_msgSend_endEncoding(v42, v66, v67);

          if (*(unsigned char *)(a1 + 636))
          {
            sub_24B708778((uint64_t *)a1, v33, v69);
            sub_24B70887C((uint64_t *)a1, v33, v70);
          }
          objc_msgSend_addCompletedHandler_(v33, v68, (uint64_t)&unk_26FE9D430);
          objc_msgSend_commit(v33, v71, v72);
          objc_msgSend_waitUntilCompleted(v33, v73, v74);
          if (sub_24B721AC0(*(void *)(a1 + 16), *(_DWORD *)(a1 + 408)))
          {
            kdebug_trace();
            if (sub_24B722294(*(void *)(a1 + 16), v75, v76))
            {
              kdebug_trace();
              uint64_t v20 = 1;
LABEL_47:

              return v20;
            }
            float v82 = sub_24B7089EC();
            if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
            {
              sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::integratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
              if (v86.i8[15] >= 0) {
                float v84 = &__p;
              }
              else {
                float v84 = __p;
              }
              *(_DWORD *)simd_float4x4 buf = 136315394;
              *(void *)&uint8_t buf[4] = v84;
              *(_WORD *)&unsigned char buf[12] = 1026;
              *(_DWORD *)&buf[14] = 260;
              _os_log_error_impl(&dword_24B6B9000, v82, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to erase hash entries with empty voxelblocks.", buf, 0x12u);
              if (v86.i8[15] < 0) {
                operator delete(__p);
              }
            }

            kdebug_trace();
LABEL_46:
            uint64_t v20 = 0;
            goto LABEL_47;
          }
          if (qword_2697D12A0 != -1) {
            dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
          }
          int32x2_t v78 = (id)qword_2697D1298;
          if (!os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
          {
LABEL_45:

            goto LABEL_46;
          }
          sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::integratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
          if (v86.i8[15] >= 0) {
            float v83 = &__p;
          }
          else {
            float v83 = __p;
          }
          *(_DWORD *)simd_float4x4 buf = 136315394;
          *(void *)&uint8_t buf[4] = v83;
          *(_WORD *)&unsigned char buf[12] = 1026;
          *(_DWORD *)&buf[14] = 250;
          float v80 = "%s:%{public}d Failed to setLastIntegratedSubmapID.";
        }
        else
        {
          if (qword_2697D12A0 != -1) {
            dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
          }
          int32x2_t v78 = (id)qword_2697D1298;
          if (!os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
            goto LABEL_45;
          }
          sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::integratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
          if (v86.i8[15] >= 0) {
            float v79 = &__p;
          }
          else {
            float v79 = __p;
          }
          *(_DWORD *)simd_float4x4 buf = 136315394;
          *(void *)&uint8_t buf[4] = v79;
          *(_WORD *)&unsigned char buf[12] = 1026;
          *(_DWORD *)&buf[14] = 226;
          float v80 = "%s:%{public}d Failed to integrate pointcloud - failed to create command buffer.";
        }
        _os_log_error_impl(&dword_24B6B9000, v78, OS_LOG_TYPE_ERROR, v80, buf, 0x12u);
        if (v86.i8[15] < 0) {
          operator delete(__p);
        }
        goto LABEL_45;
      }
    }
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    uint64_t v33 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      goto LABEL_46;
    }
    sub_24B6F6D14(&__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::integratePointCloud(const simd_float4x4 &, const uint32_t, const common::Point *, const common::PointSupplements *)");
    if (v86.i8[15] >= 0) {
      float32x2_t v77 = &__p;
    }
    else {
      float32x2_t v77 = __p;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v77;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 217;
    int32x4_t v35 = "%s:%{public}d Failed to integrate pointcloud - pointcloud does not intersect region of interest.";
LABEL_33:
    _os_log_error_impl(&dword_24B6B9000, v33, OS_LOG_TYPE_ERROR, v35, buf, 0x12u);
    if (v86.i8[15] < 0) {
      operator delete(__p);
    }
    goto LABEL_46;
  }
  return v20;
}

void sub_24B70AED4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B70AF4C(uint64_t a1, void *a2, uint64_t a3)
{
  objc_msgSend_error(a2, (const char *)a2, a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  if (v5) {
    sub_24B704E84(v5, v3, v4);
  }
}

void sub_24B70AFA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B70AFB4(float32x4_t *a1, float32x4_t *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (!a1->i8[8])
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    uint64_t v4 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      goto LABEL_13;
    }
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::reset(const VoxelIntegrator::ResetConfig &)");
    id v5 = v8 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float32x4_t v10 = v5;
    __int16 v11 = 1026;
    int v12 = 159;
    _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to reset VoxelIntegratorGPU - not initialized.", buf, 0x12u);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_23;
  }
  if (a2->f32[0] > 0.0 && a2->f32[1] > 0.0 && a2->f32[2] > 0.0)
  {
    v2.i64[0] = 0x3F0000003F000000;
    v2.i64[1] = 0x3F0000003F000000;
    a1[3] = vmulq_f32(*a2, v2);
    v2.i64[0] = 0xBF000000BF000000;
    v2.i64[1] = 0xBF000000BF000000;
    a1[4] = vmulq_f32(*a2, v2);
    a1[34] = *a2;
    return 1;
  }
  if (qword_2697D12A0 != -1) {
    dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
  }
  uint64_t v4 = (id)qword_2697D1298;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::reset(const VoxelIntegrator::ResetConfig &)");
    uint64_t v6 = v8 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float32x4_t v10 = v6;
    __int16 v11 = 1026;
    int v12 = 165;
    _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to reset VoxelIntegratorGPU - reset config is invalid.", buf, 0x12u);
    if (v8 < 0) {
LABEL_23:
    }
      operator delete(__p[0]);
  }
LABEL_13:

  return 0;
}

uint64_t sub_24B70B1F4(uint64_t a1, long long *a2)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  if (!sub_24B6F1A0C((uint64_t)a2))
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    __int16 v11 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::init(const InitConfig &)");
    uint64_t v24 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v24;
    __int16 v44 = 1026;
    int v45 = 45;
    _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to initialize VoxelIntegratorGPU - invalid init config.", buf, 0x12u);
    if ((__p[23] & 0x80000000) == 0) {
      goto LABEL_21;
    }
LABEL_56:
    operator delete(*(void **)__p);
LABEL_21:

    return 0;
  }
  long long v4 = *a2;
  long long v5 = a2[1];
  long long v6 = a2[3];
  *(_OWORD *)(a1 + 544) = a2[2];
  *(_OWORD *)(a1 + 560) = v6;
  *(_OWORD *)(a1 + 512) = v4;
  *(_OWORD *)(a1 + 528) = v5;
  long long v7 = a2[4];
  long long v8 = a2[5];
  long long v9 = a2[7];
  *(_OWORD *)(a1 + 608) = a2[6];
  *(_OWORD *)(a1 + 624) = v9;
  *(_OWORD *)(a1 + 576) = v7;
  *(_OWORD *)(a1 + 592) = v8;
  if (!*(void *)(a1 + 32))
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    __int16 v11 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::init(const InitConfig &)");
    int32x4_t v35 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v35;
    __int16 v44 = 1026;
    int v45 = 53;
    _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to initialize VoxelIntegratorGPU - failed to get MTLDeviceContext.", buf, 0x12u);
    if ((__p[23] & 0x80000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_56;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  if (!v10 || !*(unsigned char *)(v10 + 8))
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    __int16 v11 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::init(const InitConfig &)");
    char v34 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v34;
    __int16 v44 = 1026;
    int v45 = 60;
    _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to initialize VoxelIntegratorGPU - invalid voxelHashingData or it's not initialized.", buf, 0x12u);
    if ((__p[23] & 0x80000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_56;
  }
  if (*(unsigned char *)(a1 + 8))
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    __int16 v11 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::init(const InitConfig &)");
    unsigned int v36 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v36;
    __int16 v44 = 1026;
    int v45 = 66;
    _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to initialize VoxelIntegratorGPU - already initialized.", buf, 0x12u);
    if ((__p[23] & 0x80000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_56;
  }
  float v13 = *(float *)(a1 + 624);
  float32x4_t v14 = *(float32x4_t *)(a1 + 544);
  v15.i64[0] = 0x3F0000003F000000;
  v15.i64[1] = 0x3F0000003F000000;
  v16.i64[0] = 0xBF000000BF000000;
  v16.i64[1] = 0xBF000000BF000000;
  *(float32x4_t *)(a1 + 48) = vmulq_f32(v14, v15);
  *(float32x4_t *)(a1 + 64) = vmulq_f32(v14, v16);
  sub_24B720CD0((uint64_t)__p, v10);
  if (!v42)
  {
    __int16 v11 = sub_24B7089EC();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(buf, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::init(const InitConfig &)");
    if (v46 >= 0) {
      unsigned int v25 = buf;
    }
    else {
      unsigned int v25 = *(unsigned char **)buf;
    }
    *(_DWORD *)unsigned int v47 = 136315394;
    uint64_t v48 = v25;
    __int16 v49 = 1026;
    int v50 = 78;
    unsigned int v26 = "%s:%{public}d Failed to initialize VoxelIntegratorGPU - failed to get hash table parameters.";
LABEL_76:
    _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, v26, v47, 0x12u);
    if (v46 < 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_21;
  }
  *(_OWORD *)(a1 + 96) = *(_OWORD *)__p;
  *(_OWORD *)(a1 + 108) = *(_OWORD *)&__p[12];
  int8x16_t v17 = *(int8x16_t *)(a1 + 520);
  *(int8x16_t *)(a1 + 124) = vextq_s8(v17, v17, 8uLL);
  *(float32x2_t *)(a1 + 140) = vmul_n_f32(*(float32x2_t *)v17.i8, 1.0 / v13);
  *(_DWORD *)(a1 + 148) = 64;
  long long v18 = *(_OWORD *)(a1 + 576);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(a1 + 560);
  *(_OWORD *)(a1 + 240) = v18;
  long long v19 = *(_OWORD *)(a1 + 608);
  *(_OWORD *)(a1 + 256) = *(_OWORD *)(a1 + 592);
  *(_OWORD *)(a1 + 272) = v19;
  *(_DWORD *)(a1 + 288) = *(_DWORD *)&__p[16];
  *(void *)(a1 + 292) = *(void *)(a1 + 624);
  uint64_t v20 = *(unsigned int *)(a1 + 512);
  if (v20 > 5)
  {
    int v23 = 0;
    int v22 = 0;
  }
  else
  {
    uint64_t v21 = 4 * v20;
    int v22 = *(_DWORD *)((char *)&unk_24B72EC00 + v21);
    int v23 = *(_DWORD *)((char *)&unk_24B72EC18 + v21);
  }
  *(_DWORD *)(a1 + 300) = v22;
  *(_DWORD *)(a1 + 304) = *(_DWORD *)(a1 + 632);
  *(unsigned char *)(a1 + 308) = *(unsigned char *)(a1 + 638);
  *(_DWORD *)(a1 + 440) = v23;
  unint64_t v27 = *(uint64_t **)(a1 + 320);
  uint64_t v28 = *v27;
  uint64_t v29 = v27[1];
  if (v28 == v29 || *(_DWORD *)(a1 + 120) != ((unint64_t)(v29 - v28) >> 3))
  {
    __int16 v11 = sub_24B7089EC();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(buf, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::init(const InitConfig &)");
    if (v46 >= 0) {
      id v39 = buf;
    }
    else {
      id v39 = *(unsigned char **)buf;
    }
    *(_DWORD *)unsigned int v47 = 136315394;
    uint64_t v48 = v39;
    __int16 v49 = 1026;
    int v50 = 116;
    unsigned int v26 = "%s:%{public}d Failed to initialize VoxelIntegratorGPU - hashtable extents is empty.";
    goto LABEL_76;
  }
  if ((sub_24B70BA38(a1, (int *)(a1 + 516)) & 1) == 0)
  {
    __int16 v11 = sub_24B7089EC();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(buf, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::init(const InitConfig &)");
    if (v46 >= 0) {
      unsigned int v37 = buf;
    }
    else {
      unsigned int v37 = *(unsigned char **)buf;
    }
    *(_DWORD *)unsigned int v47 = 136315394;
    uint64_t v48 = v37;
    __int16 v49 = 1026;
    int v50 = 122;
    unsigned int v26 = "%s:%{public}d Failed to initialize VoxelIntegratorGPU - failed to create pipeline states.";
    goto LABEL_76;
  }
  if ((sub_24B70D170(a1) & 1) == 0)
  {
    __int16 v11 = sub_24B7089EC();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(buf, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::init(const InitConfig &)");
    if (v46 >= 0) {
      id v38 = buf;
    }
    else {
      id v38 = *(unsigned char **)buf;
    }
    *(_DWORD *)unsigned int v47 = 136315394;
    uint64_t v48 = v38;
    __int16 v49 = 1026;
    int v50 = 128;
    unsigned int v26 = "%s:%{public}d Failed to initialize VoxelIntegratorGPU - failed to create metal buffers.";
    goto LABEL_76;
  }
  if (!*(unsigned char *)(a1 + 639) || sub_24B70DA0C(a1))
  {
    id v30 = objc_alloc_init(MEMORY[0x263F12810]);
    uint64_t v31 = *(void **)(a1 + 400);
    *(void *)(a1 + 400) = v30;

    uint64_t v33 = *(void **)(a1 + 400);
    if (v33)
    {
      objc_msgSend_setErrorOptions_(v33, v32, 1);
      sub_24B70E070();
    }
    __int16 v11 = sub_24B7089EC();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(buf, "virtual BOOL oc::voxel_hashing::VoxelIntegratorGPU::init(const InitConfig &)");
    if (v46 >= 0) {
      uint64_t v40 = buf;
    }
    else {
      uint64_t v40 = *(unsigned char **)buf;
    }
    *(_DWORD *)unsigned int v47 = 136315394;
    uint64_t v48 = v40;
    __int16 v49 = 1026;
    int v50 = 141;
    unsigned int v26 = "%s:%{public}d Failed to initialize VoxelIntegratorGPU - failed to create command buffer descriptor.";
    goto LABEL_76;
  }
  return 0;
}

uint64_t sub_24B70BA38(uint64_t a1, int *a2)
{
  uint64_t v224 = *MEMORY[0x263EF8340];
  id v4 = objc_alloc_init(MEMORY[0x263F128B0]);
  int v214 = *a2;
  objc_msgSend_setConstantValue_type_atIndex_(v4, v5, (uint64_t)&v214, 33, 0);
  objc_msgSend_setConstantValue_type_atIndex_(v4, v6, a1 + 637, 53, 1);
  long long v8 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)(a1 + 32) + 16), v7, @"oc::voxel_hashing::resetAllHashBucketLocks");
  if (!v8)
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    long long v9 = (id)qword_2697D1298;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(v219, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
      uint64_t v91 = (v223 & 0x80000000) == 0 ? v219 : *(unsigned char **)v219;
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v91;
      __int16 v216 = 1026;
      int v217 = 479;
      _os_log_error_impl(&dword_24B6B9000, v9, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find resetAllHashBucketLocks compute shader.", buf, 0x12u);
      if (SBYTE3(v223) < 0) {
        operator delete(*(void **)v219);
      }
    }
  }
  id v10 = **(id **)(a1 + 32);
  id v213 = 0;
  uint64_t v12 = objc_msgSend_newComputePipelineStateWithFunction_error_(v10, v11, (uint64_t)v8, &v213);
  id v13 = v213;
  float32x4_t v14 = *(void **)(a1 + 328);
  *(void *)(a1 + 328) = v12;

  if (*(void *)(a1 + 328))
  {
    float32x4_t v16 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)(a1 + 32) + 16), v15, @"oc::voxel_hashing::resetAllHashEntryLocksAndHashEntryUpdateFlag");
    if (!v16)
    {
      if (qword_2697D12A0 != -1) {
        dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
      }
      int8x16_t v17 = (id)qword_2697D1298;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        sub_24B6F6D14(v219, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
        float32x2_t v99 = (v223 & 0x80000000) == 0 ? v219 : *(unsigned char **)v219;
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = v99;
        __int16 v216 = 1026;
        int v217 = 495;
        _os_log_error_impl(&dword_24B6B9000, v17, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find resetAllHashEntryLocksAndHashEntryUpdateFlag compute shader.", buf, 0x12u);
        if (SBYTE3(v223) < 0) {
          operator delete(*(void **)v219);
        }
      }
    }
    id v18 = **(id **)(a1 + 32);
    id v212 = v13;
    uint64_t v20 = objc_msgSend_newComputePipelineStateWithFunction_error_(v18, v19, (uint64_t)v16, &v212);
    id v21 = v212;

    int v22 = *(void **)(a1 + 336);
    *(void *)(a1 + 336) = v20;

    if (*(void *)(a1 + 336))
    {
      id v23 = *(id *)(*(void *)(a1 + 32) + 16);
      id v211 = v21;
      uint64_t v25 = objc_msgSend_newFunctionWithName_constantValues_error_(v23, v24, @"oc::voxel_hashing::allocateVoxelBlocksIntersectingRay", v4, &v211);
      id v26 = v211;

      if (v25)
      {
        id v27 = **(id **)(a1 + 32);
        id v210 = v26;
        uint64_t v29 = objc_msgSend_newComputePipelineStateWithFunction_error_(v27, v28, v25, &v210);
        id v30 = v210;

        uint64_t v31 = *(void **)(a1 + 344);
        *(void *)(a1 + 344) = v29;

        if (*(void *)(a1 + 344))
        {
          id v32 = *(id *)(*(void *)(a1 + 32) + 16);
          id v209 = v30;
          uint64_t v199 = objc_msgSend_newFunctionWithName_constantValues_error_(v32, v33, @"oc::voxel_hashing::integrateVoxelsBetweenCameraAndEndPoints", v4, &v209);
          id v34 = v209;

          uint64_t v35 = v199;
          if (!v199)
          {
            if (qword_2697D12A0 != -1) {
              dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
            }
            unsigned int v36 = (id)qword_2697D1298;
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            {
              sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
              int v123 = v218;
              float32x4_t v124 = *(unsigned char **)buf;
              uint64_t v127 = objc_msgSend_localizedDescription(v34, v125, v126);
              uint64_t v128 = (void *)v127;
              uint64_t v129 = buf;
              if (v123 < 0) {
                uint64_t v129 = v124;
              }
              *(_DWORD *)float32x4_t v219 = 136315650;
              *(void *)&v219[4] = v129;
              __int16 v220 = 1026;
              int v221 = 534;
              __int16 v222 = 2114;
              uint64_t v223 = v127;
              _os_log_error_impl(&dword_24B6B9000, v36, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find integrateVoxelsBetweenCameraAndEndPoints compute shader. Error details: %{public}@", v219, 0x1Cu);

              if (v218 < 0) {
                operator delete(*(void **)buf);
              }
            }

            uint64_t v35 = 0;
          }
          id v37 = **(id **)(a1 + 32);
          id v208 = v34;
          uint64_t v39 = objc_msgSend_newComputePipelineStateWithFunction_error_(v37, v38, v35, &v208);
          id v26 = v208;

          uint64_t v40 = *(void **)(a1 + 352);
          *(void *)(a1 + 352) = v39;

          if (*(void *)(a1 + 352))
          {
            id v41 = *(id *)(*(void *)(a1 + 32) + 16);
            id v207 = v26;
            uint64_t v198 = objc_msgSend_newFunctionWithName_constantValues_error_(v41, v42, @"oc::voxel_hashing::integrateVoxelsUptoTruncationRegion", v4, &v207);
            id v43 = v207;

            uint64_t v44 = v198;
            if (!v198)
            {
              if (qword_2697D12A0 != -1) {
                dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
              }
              int v45 = (id)qword_2697D1298;
              if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
              {
                sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
                int v137 = v218;
                unint64_t v138 = *(unsigned char **)buf;
                uint64_t v141 = objc_msgSend_localizedDescription(v43, v139, v140);
                int v142 = (void *)v141;
                char v143 = buf;
                if (v137 < 0) {
                  char v143 = v138;
                }
                *(_DWORD *)float32x4_t v219 = 136315650;
                *(void *)&v219[4] = v143;
                __int16 v220 = 1026;
                int v221 = 554;
                __int16 v222 = 2114;
                uint64_t v223 = v141;
                _os_log_error_impl(&dword_24B6B9000, v45, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find integrateVoxelsUptoTruncationRegion compute shader. Error details: %{public}@", v219, 0x1Cu);

                if (v218 < 0) {
                  operator delete(*(void **)buf);
                }
              }

              uint64_t v44 = 0;
            }
            id v46 = **(id **)(a1 + 32);
            id v206 = v43;
            uint64_t v48 = objc_msgSend_newComputePipelineStateWithFunction_error_(v46, v47, v44, &v206);
            id v26 = v206;

            __int16 v49 = *(void **)(a1 + 360);
            *(void *)(a1 + 360) = v48;

            if (*(void *)(a1 + 360))
            {
              id v50 = *(id *)(*(void *)(a1 + 32) + 16);
              id v205 = v26;
              uint64_t v197 = objc_msgSend_newFunctionWithName_constantValues_error_(v50, v51, @"oc::voxel_hashing::integrateVoxelsInTruncationRegion", v4, &v205);
              id v52 = v205;

              uint64_t v53 = v197;
              if (!v197)
              {
                if (qword_2697D12A0 != -1) {
                  dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
                }
                unsigned int v54 = (id)qword_2697D1298;
                if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
                {
                  sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
                  int v151 = v218;
                  uint64_t v152 = *(unsigned char **)buf;
                  uint64_t v155 = objc_msgSend_localizedDescription(v52, v153, v154);
                  unint64_t v156 = (void *)v155;
                  uint64_t v157 = buf;
                  if (v151 < 0) {
                    uint64_t v157 = v152;
                  }
                  *(_DWORD *)float32x4_t v219 = 136315650;
                  *(void *)&v219[4] = v157;
                  __int16 v220 = 1026;
                  int v221 = 573;
                  __int16 v222 = 2114;
                  uint64_t v223 = v155;
                  _os_log_error_impl(&dword_24B6B9000, v54, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find integrateVoxelsInTruncationRegion compute shader. Error details: %{public}@", v219, 0x1Cu);

                  if (v218 < 0) {
                    operator delete(*(void **)buf);
                  }
                }

                uint64_t v53 = 0;
              }
              id v55 = **(id **)(a1 + 32);
              id v204 = v52;
              uint64_t v57 = objc_msgSend_newComputePipelineStateWithFunction_error_(v55, v56, v53, &v204);
              id v26 = v204;

              float v58 = *(void **)(a1 + 368);
              *(void *)(a1 + 368) = v57;

              if (*(void *)(a1 + 368))
              {
                id v59 = *(id *)(*(void *)(a1 + 32) + 16);
                id v203 = v26;
                uint64_t v196 = objc_msgSend_newFunctionWithName_constantValues_error_(v59, v60, @"oc::voxel_hashing::deintegrateVoxelsInTruncationRegion", v4, &v203);
                id v61 = v203;

                uint64_t v62 = v196;
                if (!v196)
                {
                  uint64_t v63 = sub_24B7089EC();
                  if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
                  {
                    sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
                    int v165 = v218;
                    uint64_t v166 = *(unsigned char **)buf;
                    uint64_t v169 = objc_msgSend_localizedDescription(v61, v167, v168);
                    long long v170 = (void *)v169;
                    long long v171 = buf;
                    if (v165 < 0) {
                      long long v171 = v166;
                    }
                    *(_DWORD *)float32x4_t v219 = 136315650;
                    *(void *)&v219[4] = v171;
                    __int16 v220 = 1026;
                    int v221 = 592;
                    __int16 v222 = 2114;
                    uint64_t v223 = v169;
                    _os_log_error_impl(&dword_24B6B9000, v63, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find deintegrateVoxelsInTruncationRegion compute shader. Error details: %{public}@", v219, 0x1Cu);

                    if (v218 < 0) {
                      operator delete(*(void **)buf);
                    }
                  }

                  uint64_t v62 = 0;
                }
                id v64 = **(id **)(a1 + 32);
                id v202 = v61;
                uint64_t v66 = objc_msgSend_newComputePipelineStateWithFunction_error_(v64, v65, v62, &v202);
                id v67 = v202;

                float32x4_t v68 = *(void **)(a1 + 376);
                *(void *)(a1 + 376) = v66;

                if (!*(void *)(a1 + 376))
                {
                  uint64_t v70 = sub_24B7089EC();
                  if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
                  {
                    sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
                    int v172 = v218;
                    int16x4_t v173 = *(unsigned char **)buf;
                    uint64_t v176 = objc_msgSend_localizedDescription(v67, v174, v175);
                    float v177 = (void *)v176;
                    float v178 = buf;
                    if (v172 < 0) {
                      float v178 = v173;
                    }
                    *(_DWORD *)float32x4_t v219 = 136315650;
                    *(void *)&v219[4] = v178;
                    __int16 v220 = 1026;
                    int v221 = 600;
                    __int16 v222 = 2114;
                    uint64_t v223 = v176;
                    _os_log_error_impl(&dword_24B6B9000, v70, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for deintegrateVoxelsInTruncationRegion compute shader. Error details: %{public}@", v219, 0x1Cu);

                    if (v218 < 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                }
                uint64_t v71 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)(a1 + 32) + 16), v69, @"oc::voxel_hashing::updateArgsForFindHashEntriesToErase");
                if (!v71)
                {
                  uint64_t v72 = sub_24B7089EC();
                  if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
                  {
                    sub_24B6F6D14(v219, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
                    unsigned int v179 = (v223 & 0x80000000) == 0 ? v219 : *(unsigned char **)v219;
                    *(_DWORD *)simd_float4x4 buf = 136315394;
                    *(void *)&uint8_t buf[4] = v179;
                    __int16 v216 = 1026;
                    int v217 = 607;
                    _os_log_error_impl(&dword_24B6B9000, v72, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find updateArgsForFindHashEntriesToErase compute shader.", buf, 0x12u);
                    if (SBYTE3(v223) < 0) {
                      operator delete(*(void **)v219);
                    }
                  }

                  uint64_t v71 = 0;
                }
                id v73 = **(id **)(a1 + 32);
                id v201 = v67;
                float v195 = (void *)v71;
                uint64_t v75 = objc_msgSend_newComputePipelineStateWithFunction_error_(v73, v74, v71, &v201);
                id v26 = v201;

                uint64_t v76 = *(void **)(a1 + 384);
                *(void *)(a1 + 384) = v75;

                if (*(void *)(a1 + 384))
                {
                  int32x2_t v78 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)(a1 + 32) + 16), v77, @"oc::voxel_hashing::findHashEntriesToErase");
                  if (!v78)
                  {
                    float v79 = sub_24B7089EC();
                    if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
                    {
                      sub_24B6F6D14(v219, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
                      unint64_t v187 = (v223 & 0x80000000) == 0 ? v219 : *(unsigned char **)v219;
                      *(_DWORD *)simd_float4x4 buf = 136315394;
                      *(void *)&uint8_t buf[4] = v187;
                      __int16 v216 = 1026;
                      int v217 = 623;
                      _os_log_error_impl(&dword_24B6B9000, v79, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find findHashEntriesToErase compute shader.", buf, 0x12u);
                      if (SBYTE3(v223) < 0) {
                        operator delete(*(void **)v219);
                      }
                    }
                  }
                  id v80 = **(id **)(a1 + 32);
                  id v200 = v26;
                  uint64_t v82 = objc_msgSend_newComputePipelineStateWithFunction_error_(v80, v81, (uint64_t)v78, &v200);
                  id v83 = v200;

                  float v84 = *(void **)(a1 + 392);
                  *(void *)(a1 + 392) = v82;

                  if (*(void *)(a1 + 392))
                  {
                    uint64_t v85 = 1;
                  }
                  else
                  {
                    int v107 = sub_24B7089EC();
                    if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
                    {
                      sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
                      int v188 = v218;
                      float32x4_t v189 = *(unsigned char **)buf;
                      uint64_t v192 = objc_msgSend_localizedDescription(v83, v190, v191);
                      int16x4_t v193 = (void *)v192;
                      float v194 = buf;
                      if (v188 < 0) {
                        float v194 = v189;
                      }
                      *(_DWORD *)float32x4_t v219 = 136315650;
                      *(void *)&v219[4] = v194;
                      __int16 v220 = 1026;
                      int v221 = 631;
                      __int16 v222 = 2114;
                      uint64_t v223 = v192;
                      _os_log_error_impl(&dword_24B6B9000, v107, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for findHashEntriesToErase compute shader. Error details: %{public}@", v219, 0x1Cu);

                      if (v218 < 0) {
                        operator delete(*(void **)buf);
                      }
                    }

                    uint64_t v85 = 0;
                  }
                  id v26 = v83;
                }
                else
                {
                  int32x2_t v78 = sub_24B7089EC();
                  if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
                  {
                    sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
                    int v180 = v218;
                    unsigned int v181 = *(unsigned char **)buf;
                    uint64_t v184 = objc_msgSend_localizedDescription(v26, v182, v183);
                    unsigned int v185 = (void *)v184;
                    uint64_t v186 = v180 >= 0 ? buf : v181;
                    *(_DWORD *)float32x4_t v219 = 136315650;
                    *(void *)&v219[4] = v186;
                    __int16 v220 = 1026;
                    int v221 = 615;
                    __int16 v222 = 2114;
                    uint64_t v223 = v184;
                    _os_log_error_impl(&dword_24B6B9000, v78, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for updateArgsForFindHashEntriesToErase compute shader. Error details: %{public}@", v219, 0x1Cu);

                    if (v218 < 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                  uint64_t v85 = 0;
                }

                uint64_t v90 = v196;
              }
              else
              {
                if (qword_2697D12A0 != -1) {
                  dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
                }
                uint64_t v90 = (id)qword_2697D1298;
                if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
                {
                  sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
                  int v158 = v218;
                  uint64_t v159 = *(unsigned char **)buf;
                  uint64_t v162 = objc_msgSend_localizedDescription(v26, v160, v161);
                  int v163 = (void *)v162;
                  BOOL v164 = v158 >= 0 ? buf : v159;
                  *(_DWORD *)float32x4_t v219 = 136315650;
                  *(void *)&v219[4] = v164;
                  __int16 v220 = 1026;
                  int v221 = 581;
                  __int16 v222 = 2114;
                  uint64_t v223 = v162;
                  _os_log_error_impl(&dword_24B6B9000, v90, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for integrateVoxelsInTruncationRegion compute shader. Error details: %{public}@", v219, 0x1Cu);

                  if (v218 < 0) {
                    operator delete(*(void **)buf);
                  }
                }
                uint64_t v85 = 0;
              }

              uint64_t v89 = v197;
            }
            else
            {
              if (qword_2697D12A0 != -1) {
                dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
              }
              uint64_t v89 = (id)qword_2697D1298;
              if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
              {
                sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
                int v144 = v218;
                uint64_t v145 = *(unsigned char **)buf;
                uint64_t v148 = objc_msgSend_localizedDescription(v26, v146, v147);
                float64x2_t v149 = (void *)v148;
                unint64_t v150 = v144 >= 0 ? buf : v145;
                *(_DWORD *)float32x4_t v219 = 136315650;
                *(void *)&v219[4] = v150;
                __int16 v220 = 1026;
                int v221 = 562;
                __int16 v222 = 2114;
                uint64_t v223 = v148;
                _os_log_error_impl(&dword_24B6B9000, v89, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for integrateVoxelsUptoTruncationRegion compute shader. Error details: %{public}@", v219, 0x1Cu);

                if (v218 < 0) {
                  operator delete(*(void **)buf);
                }
              }
              uint64_t v85 = 0;
            }

            uint64_t v88 = v198;
          }
          else
          {
            if (qword_2697D12A0 != -1) {
              dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
            }
            uint64_t v88 = (id)qword_2697D1298;
            if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
            {
              sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
              int v130 = v218;
              float32x4_t v131 = *(unsigned char **)buf;
              uint64_t v134 = objc_msgSend_localizedDescription(v26, v132, v133);
              int v135 = (void *)v134;
              unsigned __int8 v136 = v130 >= 0 ? buf : v131;
              *(_DWORD *)float32x4_t v219 = 136315650;
              *(void *)&v219[4] = v136;
              __int16 v220 = 1026;
              int v221 = 543;
              __int16 v222 = 2114;
              uint64_t v223 = v134;
              _os_log_error_impl(&dword_24B6B9000, v88, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for integrateVoxelsBetweenCameraAndEndPoints compute shader. Error details: %{public}@", v219, 0x1Cu);

              if (v218 < 0) {
                operator delete(*(void **)buf);
              }
            }
            uint64_t v85 = 0;
          }

          int v87 = v199;
        }
        else
        {
          if (qword_2697D12A0 != -1) {
            dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
          }
          int v87 = (id)qword_2697D1298;
          if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
          {
            sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
            int v116 = v218;
            int32x4_t v117 = *(unsigned char **)buf;
            uint64_t v120 = objc_msgSend_localizedDescription(v30, v118, v119);
            uint64_t v121 = (void *)v120;
            float32x4_t v122 = v116 >= 0 ? buf : v117;
            *(_DWORD *)float32x4_t v219 = 136315650;
            *(void *)&v219[4] = v122;
            __int16 v220 = 1026;
            int v221 = 523;
            __int16 v222 = 2114;
            uint64_t v223 = v120;
            _os_log_error_impl(&dword_24B6B9000, v87, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for allocateVoxelBlocksIntersectingRay compute shader. Error details: %{public}@", v219, 0x1Cu);

            if (v218 < 0) {
              operator delete(*(void **)buf);
            }
          }
          uint64_t v85 = 0;
          id v26 = v30;
        }
      }
      else
      {
        if (qword_2697D12A0 != -1) {
          dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
        }
        int v87 = (id)qword_2697D1298;
        if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
        {
          sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
          int v109 = v218;
          float v110 = *(unsigned char **)buf;
          uint64_t v113 = objc_msgSend_localizedDescription(v26, v111, v112);
          float v114 = (void *)v113;
          __int32 v115 = v109 >= 0 ? buf : v110;
          *(_DWORD *)float32x4_t v219 = 136315650;
          *(void *)&v219[4] = v115;
          __int16 v220 = 1026;
          int v221 = 514;
          __int16 v222 = 2114;
          uint64_t v223 = v113;
          _os_log_error_impl(&dword_24B6B9000, v87, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find allocateVoxelBlocksIntersectingRay compute shader. Error details: %{public}@", v219, 0x1Cu);

          if (v218 < 0) {
            operator delete(*(void **)buf);
          }
        }
        uint64_t v85 = 0;
      }

      int64x2_t v86 = v25;
      id v21 = v26;
    }
    else
    {
      if (qword_2697D12A0 != -1) {
        dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
      }
      int64x2_t v86 = (id)qword_2697D1298;
      if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
      {
        sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
        int v100 = v218;
        int v101 = *(unsigned char **)buf;
        uint64_t v104 = objc_msgSend_localizedDescription(v21, v102, v103);
        __int16 v105 = (void *)v104;
        int v106 = v100 >= 0 ? buf : v101;
        *(_DWORD *)float32x4_t v219 = 136315650;
        *(void *)&v219[4] = v106;
        __int16 v220 = 1026;
        int v221 = 503;
        __int16 v222 = 2114;
        uint64_t v223 = v104;
        _os_log_error_impl(&dword_24B6B9000, v86, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelIntegratorGPU::createPipelineStates: Failed to create pipeline state for resetAllHashEntryLocksAndHashEntryUpdateFlag compute shader. Error details: %{public}@", v219, 0x1Cu);

        if (v218 < 0) {
          operator delete(*(void **)buf);
        }
      }
      uint64_t v85 = 0;
    }

    id v13 = v21;
  }
  else
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    float32x4_t v16 = (id)qword_2697D1298;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createPipelineStates(const VoxelHashingMode &)");
      int v92 = v218;
      float32x4_t v93 = *(unsigned char **)buf;
      uint64_t v96 = objc_msgSend_localizedDescription(v13, v94, v95);
      int32x4_t v97 = (void *)v96;
      float32x2_t v98 = v92 >= 0 ? buf : v93;
      *(_DWORD *)float32x4_t v219 = 136315650;
      *(void *)&v219[4] = v98;
      __int16 v220 = 1026;
      int v221 = 487;
      __int16 v222 = 2114;
      uint64_t v223 = v96;
      _os_log_error_impl(&dword_24B6B9000, v16, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for resetAllHashBucketLocks compute shader. Error details: %{public}@", v219, 0x1Cu);

      if (v218 < 0) {
        operator delete(*(void **)buf);
      }
    }
    uint64_t v85 = 0;
  }

  return v85;
}

void sub_24B70CEF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (v38 < 0) {
    operator delete(v41);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_24B70D170(uint64_t a1)
{
  uint64_t v68 = *MEMORY[0x263EF8340];
  id v2 = **(id **)(a1 + 32);
  uint64_t v4 = objc_msgSend_newBufferWithLength_options_(v2, v3, 48 * *(unsigned int *)(a1 + 440), 0);
  long long v5 = *(void **)(a1 + 448);
  *(void *)(a1 + 448) = v4;

  long long v7 = *(void **)(a1 + 448);
  if (!v7)
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    unsigned int v54 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createBuffers()");
    id v55 = v63 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    unsigned int v65 = v55;
    __int16 v66 = 1026;
    int v67 = 646;
    _os_log_error_impl(&dword_24B6B9000, v54, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create points buffer.", buf, 0x12u);
    if ((v63 & 0x80000000) == 0) {
      goto LABEL_48;
    }
    goto LABEL_83;
  }
  objc_msgSend_setLabel_(v7, v6, @"InputPoints Buffer");
  id v8 = **(id **)(a1 + 32);
  uint64_t v10 = objc_msgSend_newBufferWithLength_options_(v8, v9, 20 * *(unsigned int *)(a1 + 440), 0);
  __int16 v11 = *(void **)(a1 + 456);
  *(void *)(a1 + 456) = v10;

  id v13 = *(void **)(a1 + 456);
  if (!v13)
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    unsigned int v54 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createBuffers()");
    int v56 = v63 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    unsigned int v65 = v56;
    __int16 v66 = 1026;
    int v67 = 656;
    _os_log_error_impl(&dword_24B6B9000, v54, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pointSupplements buffer.", buf, 0x12u);
    if ((v63 & 0x80000000) == 0) {
      goto LABEL_48;
    }
    goto LABEL_83;
  }
  objc_msgSend_setLabel_(v13, v12, @"PointSupplements Buffer");
  unint64_t v14 = *(unsigned int *)(a1 + 440);
  if (v14)
  {
    unint64_t v15 = ((v14 - 1) >> 6) + 1;
    float32x4_t v16 = operator new(8 * v15);
    int8x16_t v17 = v16;
    if (v14 >= 0x41) {
      unint64_t v18 = (v14 - 1) >> 6;
    }
    else {
      unint64_t v18 = 0;
    }
    v16[v18] = 0;
    if (v14 >= 0x40) {
      bzero(v16, 8 * (v14 >> 6));
    }
    if ((v14 & 0x3F) != 0) {
      v17[v14 >> 6] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v14 & 0x3F));
    }
    long long v19 = *(void **)(a1 + 416);
    if (v19) {
      goto LABEL_12;
    }
  }
  else
  {
    unint64_t v15 = 0;
    int8x16_t v17 = 0;
    long long v19 = *(void **)(a1 + 416);
    if (v19)
    {
LABEL_12:
      operator delete(v19);
      *(void *)(a1 + 416) = 0;
      *(void *)(a1 + 424) = 0;
      *(void *)(a1 + 432) = 0;
    }
  }
  *(void *)(a1 + 416) = v17;
  *(void *)(a1 + 424) = v14;
  *(void *)(a1 + 432) = v15;
  unsigned int v20 = *(_DWORD *)(a1 + 120) * *(_DWORD *)(a1 + 96);
  id v21 = **(id **)(a1 + 32);
  uint64_t v23 = objc_msgSend_newBufferWithLength_options_(v21, v22, 4 * v20, 0);
  uint64_t v24 = *(void **)(a1 + 464);
  *(void *)(a1 + 464) = v23;

  id v26 = *(void **)(a1 + 464);
  if (!v26)
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    unsigned int v54 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createBuffers()");
    uint64_t v57 = v63 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    unsigned int v65 = v57;
    __int16 v66 = 1026;
    int v67 = 669;
    _os_log_error_impl(&dword_24B6B9000, v54, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create hashBucketLocks buffer.", buf, 0x12u);
    if ((v63 & 0x80000000) == 0) {
      goto LABEL_48;
    }
    goto LABEL_83;
  }
  objc_msgSend_setLabel_(v26, v25, @"HashBucketLocks Buffer");
  id v27 = **(id **)(a1 + 32);
  uint64_t v29 = objc_msgSend_newBufferWithLength_options_(v27, v28, 4, 0);
  id v30 = *(void **)(a1 + 472);
  *(void *)(a1 + 472) = v29;

  id v32 = *(void **)(a1 + 472);
  if (!v32)
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    unsigned int v54 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createBuffers()");
    float v58 = v63 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    unsigned int v65 = v58;
    __int16 v66 = 1026;
    int v67 = 678;
    _os_log_error_impl(&dword_24B6B9000, v54, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create numLockedBucketIdxs buffer.", buf, 0x12u);
    if ((v63 & 0x80000000) == 0) {
      goto LABEL_48;
    }
    goto LABEL_83;
  }
  objc_msgSend_setLabel_(v32, v31, @"NumLockedBucketIdxs Buffer");
  *(_DWORD *)objc_msgSend_contents(*(void **)(a1 + 472), v33, v34) = 0;
  id v35 = **(id **)(a1 + 32);
  uint64_t v37 = objc_msgSend_newBufferWithLength_options_(v35, v36, 4 * *(unsigned int *)(a1 + 96), 0);
  int v38 = *(void **)(a1 + 480);
  *(void *)(a1 + 480) = v37;

  uint64_t v40 = *(void **)(a1 + 480);
  if (!v40)
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    unsigned int v54 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createBuffers()");
    id v59 = v63 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    unsigned int v65 = v59;
    __int16 v66 = 1026;
    int v67 = 692;
    _os_log_error_impl(&dword_24B6B9000, v54, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create lockedBucketIdxs buffer.", buf, 0x12u);
    if ((v63 & 0x80000000) == 0) {
      goto LABEL_48;
    }
    goto LABEL_83;
  }
  objc_msgSend_setLabel_(v40, v39, @"LockedBucketIdxs Buffer");
  id v41 = **(id **)(a1 + 32);
  uint64_t v43 = objc_msgSend_newBufferWithLength_options_(v41, v42, 4 * *(unsigned int *)(a1 + 108), 0);
  uint64_t v44 = *(void **)(a1 + 488);
  *(void *)(a1 + 488) = v43;

  id v46 = *(void **)(a1 + 488);
  if (!v46)
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    unsigned int v54 = (id)qword_2697D1298;
    if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
      goto LABEL_48;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createBuffers()");
    uint64_t v60 = v63 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    unsigned int v65 = v60;
    __int16 v66 = 1026;
    int v67 = 702;
    _os_log_error_impl(&dword_24B6B9000, v54, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create hashEntryLocks buffer.", buf, 0x12u);
    if ((v63 & 0x80000000) == 0) {
      goto LABEL_48;
    }
    goto LABEL_83;
  }
  objc_msgSend_setLabel_(v46, v45, @"HashEntryLocks Buffer");
  id v47 = **(id **)(a1 + 32);
  uint64_t v49 = objc_msgSend_newBufferWithLength_options_(v47, v48, 12, 0);
  id v50 = *(void **)(a1 + 496);
  *(void *)(a1 + 496) = v49;

  id v52 = *(void **)(a1 + 496);
  if (v52)
  {
    objc_msgSend_setLabel_(v52, v51, @"IndirectArgsFindHashEntriesToErase Buffer");
    return 1;
  }
  if (qword_2697D12A0 != -1) {
    dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
  }
  unsigned int v54 = (id)qword_2697D1298;
  if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::createBuffers()");
    id v61 = v63 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    unsigned int v65 = v61;
    __int16 v66 = 1026;
    int v67 = 712;
    _os_log_error_impl(&dword_24B6B9000, v54, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create indirectArgsFindHashEntriesToErase buffer.", buf, 0x12u);
    if (v63 < 0) {
LABEL_83:
    }
      operator delete(__p[0]);
  }
LABEL_48:

  return 0;
}

void sub_24B70D9E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B70DA0C(uint64_t a1)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  v2.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  sub_24B720E24(*(void *)(a1 + 16));
  id v3 = objc_claimAutoreleasedReturnValue();
  uint64_t v60 = objc_msgSend_contents(v3, v4, v5);

  sub_24B720F64(*(void *)(a1 + 16));
  id v6 = objc_claimAutoreleasedReturnValue();
  uint64_t v59 = objc_msgSend_contents(v6, v7, v8);

  sub_24B7210A4(*(void *)(a1 + 16));
  id v9 = objc_claimAutoreleasedReturnValue();
  float v58 = (unsigned int *)objc_msgSend_contents(v9, v10, v11);

  sub_24B7211E8(*(void *)(a1 + 16));
  id v12 = objc_claimAutoreleasedReturnValue();
  uint64_t v15 = objc_msgSend_contents(v12, v13, v14);

  sub_24B72132C(*(void *)(a1 + 16));
  id v16 = objc_claimAutoreleasedReturnValue();
  long long v19 = (_DWORD *)objc_msgSend_contents(v16, v17, v18);

  sub_24B721980(*(void *)(a1 + 16));
  id v20 = objc_claimAutoreleasedReturnValue();
  uint64_t v23 = objc_msgSend_contents(v20, v21, v22);

  float32x4_t v24 = *(float32x4_t *)(a1 + 48);
  float32x4_t v25 = vaddq_f32(v24, v24);
  v24.f32[0] = *(float *)(a1 + 292) * 8.0;
  v26.i64[0] = 0x3F0000003F000000;
  v26.i64[1] = 0x3F0000003F000000;
  float32x4_t v30 = vmulq_f32(v25, v26);
  float32x4_t v27 = vdivq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0));
  v27.i32[3] = 0;
  int8x16_t v31 = (int8x16_t)vrndpq_f32(v27);
  *(int32x2_t *)v30.f32 = vcvt_s32_f32(*(float32x2_t *)v31.i8);
  __int32 v28 = v30.i32[1];
  __int32 v29 = v30.i32[0];
  v30.i16[1] = v30.i16[2];
  v30.i16[2] = (int)*(float *)&v31.i32[2];
  *(int16x4_t *)v31.i8 = vneg_s16(*(int16x4_t *)v30.f32);
  int v32 = 8 * v28 * v29 * (int)*(float *)&v31.i32[2];
  LOWORD(v33) = v31.i16[1];
  if (v31.i16[1] >= v28
    || ((__int16 v34 = v31.i16[2], v35 = v31.i16[0], v31.i16[2] < (int)*(float *)&v31.i32[2])
      ? (BOOL v36 = v29 <= v31.i16[0])
      : (BOOL v36 = 1),
        v36))
  {
    int v41 = 0;
  }
  else
  {
    float32x4_t v53 = v25;
    int v41 = 0;
    __int16 v42 = v29 - v31.i16[0];
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = v2.__d_.__rep_;
    int v54 = 8 * v28 * v29 * (int)*(float *)&v31.i32[2];
    __int16 v55 = v29 - v31.i16[0];
    __int16 v56 = v31.i16[0];
    int v57 = (int)*(float *)&v31.i32[2];
    __int16 v50 = v31.i16[2];
    __int32 v51 = v28;
    do
    {
      LOWORD(v43) = v34;
      while (2)
      {
        unsigned __int16 v44 = v42 + v41;
        do
        {
          v31.i16[0] = v35;
          v31.i16[1] = v33;
          v31.i16[2] = v43;
          int16x4_t v61 = *(int16x4_t *)v31.i8;
          if ((sub_24B709D64((unsigned int *)(a1 + 96), **(void **)(a1 + 320), *(_DWORD *)(a1 + 408), &v61, *(unsigned char *)(a1 + 637), v60, v59, v58, v31, (int32x4_t)v30, (int8x16_t)v25, v15, v19, v23) & 0x80000000) != 0)
          {
            if (qword_2697D12A0 != -1) {
              dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
            }
            int v45 = (id)qword_2697D1298;
            if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
            {
              sub_24B6F6D14(v70, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::allocateAllVoxelBlocksInBoundingBox()");
              uint64_t v49 = v73 >= 0 ? v70 : *(unsigned char **)v70;
              *(_DWORD *)simd_float4x4 buf = 136316162;
              *(void *)&uint8_t buf[4] = v49;
              __int16 v63 = 1026;
              int v64 = 756;
              __int16 v65 = 1026;
              LODWORD(v66) = v35;
              WORD2(v66) = 1026;
              *(_DWORD *)((char *)&v66 + 6) = (__int16)v33;
              WORD5(v66) = 1026;
              HIDWORD(v66) = (__int16)v43;
              _os_log_error_impl(&dword_24B6B9000, v45, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to allocate voxel block at position {%{public}d, %{public}d, %{public}d}", buf, 0x24u);
              if (v73 < 0) {
                operator delete(*(void **)v70);
              }
            }

            if (qword_2697D12A0 != -1) {
              dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
            }
            uint64_t v40 = (id)qword_2697D1298;
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
            {
              sub_24B6F6D14(v70, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::allocateAllVoxelBlocksInBoundingBox()");
              id v46 = v73 >= 0 ? v70 : *(unsigned char **)v70;
              *(_DWORD *)simd_float4x4 buf = 136316418;
              *(void *)&uint8_t buf[4] = v46;
              __int16 v63 = 1026;
              int v64 = 763;
              __int16 v65 = 1026;
              LODWORD(v66) = v54;
              WORD2(v66) = 2050;
              *(double *)((char *)&v66 + 6) = v53.f32[0];
              HIWORD(v66) = 2050;
              double v67 = v53.f32[1];
              __int16 v68 = 2050;
              double v69 = v53.f32[2];
              _os_log_impl(&dword_24B6B9000, v40, OS_LOG_TYPE_DEFAULT, "%s:%{public}d VoxelBlockPreallocation is enabled, ensure the voxelHashingCapacity is set to %{public}u to fill the bounding box of extents {%{public}f, %{public}f, %{public}f}", buf, 0x36u);
              if (v73 < 0) {
                operator delete(*(void **)v70);
              }
            }
            goto LABEL_35;
          }
          ++v41;
          ++v35;
        }
        while (v44 != (unsigned __int16)v41);
        int v43 = (__int16)(v43 + 1);
        __int16 v35 = v56;
        __int16 v42 = v55;
        if (v43 < v57) {
          continue;
        }
        break;
      }
      __int32 v33 = (__int16)(v33 + 1);
      __int16 v34 = v50;
      v2.__d_.__rep_ = rep;
      int v32 = v54;
    }
    while (v33 < v51);
  }
  if (v41 == v32)
  {
    v37.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    int v38 = (id)qword_2697D1298;
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      sub_24B6F6D14(v70, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::allocateAllVoxelBlocksInBoundingBox()");
      if (v73 >= 0) {
        id v47 = v70;
      }
      else {
        id v47 = *(unsigned char **)v70;
      }
      *(_DWORD *)simd_float4x4 buf = 136315650;
      *(void *)&uint8_t buf[4] = v47;
      __int16 v63 = 1026;
      int v64 = 782;
      __int16 v65 = 2050;
      *(double *)&long long v66 = (float)((float)((v37.__d_.__rep_ - v2.__d_.__rep_) / 1000) / 1000.0);
      _os_log_debug_impl(&dword_24B6B9000, v38, OS_LOG_TYPE_DEBUG, "%s:%{public}d VoxelBlockPreallocation took %{public}f ms", buf, 0x1Cu);
      if (v73 < 0) {
        operator delete(*(void **)v70);
      }
    }

    return 1;
  }
  else
  {
    if (qword_2697D12A0 != -1) {
      dispatch_once(&qword_2697D12A0, &unk_26FE9D490);
    }
    uint64_t v40 = (id)qword_2697D1298;
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelIntegratorGPU::allocateAllVoxelBlocksInBoundingBox()");
      uint64_t v48 = (SBYTE3(v66) & 0x80u) == 0 ? buf : *(unsigned char **)buf;
      *(_DWORD *)uint64_t v70 = 136315394;
      *(void *)&v70[4] = v48;
      __int16 v71 = 1026;
      int v72 = 775;
      _os_log_error_impl(&dword_24B6B9000, v40, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to pre-allocate all the voxel blocks in the bounding box", v70, 0x12u);
      if (SBYTE3(v66) < 0) {
        operator delete(*(void **)buf);
      }
    }
LABEL_35:

    return 0;
  }
}

void sub_24B70E048(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B70E070()
{
}

void sub_24B70E170(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_2697D1358);
  MEMORY[0x24C5D7790](v1, 0xE0C40BC9ECFC2);
  _Unwind_Resume(a1);
}

uint64_t *sub_24B70E1BC(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t v4 = *a1;
  *a1 = v3;
  if (v4)
  {

    MEMORY[0x24C5D7790](v4, 0xE0C40BC9ECFC2);
  }
  return a1;
}

uint64_t *sub_24B70E21C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {

    MEMORY[0x24C5D7790](v2, 0xE0C40BC9ECFC2);
  }
  return a1;
}

void sub_24B70E274(uint64_t a1)
{
  sub_24B70E2AC(a1);
  JUMPOUT(0x24C5D7790);
}

uint64_t sub_24B70E2AC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 640);
  *(void *)(a1 + 640) = 0;
  if (v2)
  {

    MEMORY[0x24C5D7790](v2, 0xE0C40BC9ECFC2);
  }

  uint64_t v3 = *(void **)(a1 + 416);
  if (v3) {
    operator delete(v3);
  }

  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

uint64_t sub_24B70E3E4(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  a6[1] = *a6;
  if (*a2) {
    operator new();
  }
  return 0;
}

BOOL sub_24B711914(float **a1)
{
  *(_OWORD *)id v9 = xmmword_24B72A5D0;
  uint64_t v14 = a1;
  float32x2_t v15 = (float32x2_t)4;
  int v2 = sub_24B711AE4((float *)v9, (uint64_t)&v14);
  float32x2_t v3 = 0;
  float v4 = 2.0;
  float v5 = 0.0;
  if (v2
    && (a1[6] & 0x7FFFFFFFu) <= 0x7F7FFFFF
    && (*((_DWORD *)a1 + 13) & 0x7FFFFFFFu) <= 0x7F7FFFFF
    && (a1[7] & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    float v5 = *(float *)&v9[4];
    float32x2_t v3 = *(float32x2_t *)&v9[8];
    float v4 = (float)(*(float *)v9 + *(float *)v9) + 0.0;
  }
  LODWORD(v14) = 0;
  HIDWORD(v14) = v3.i32[1];
  int v16 = 0;
  __int32 v18 = v3.i32[0];
  float v19 = -v5;
  float32x2_t v15 = vneg_f32(v3);
  float v17 = v5;
  int v20 = 0;
  *(float *)&unsigned int v6 = v3.f32[1] + v3.f32[1];
  *((float32x2_t *)&v11 + 1) = vmul_f32(v3, (float32x2_t)0xC0000000C0000000);
  float32x2_t v7 = (float32x2_t)vdup_lane_s32((int32x2_t)v3, 0);
  v7.f32[0] = v5;
  *(float32x2_t *)((char *)&v12 + 4) = vadd_f32(v7, v7);
  *(void *)&long long v11 = __PAIR64__(v6, LODWORD(v4));
  *(float *)&long long v12 = v4;
  *((float *)&v12 + 3) = v5 * -2.0;
  float v13 = v4;
  v21[0] = (float *)&v11;
  v21[1] = (float *)&v14;
  memset(v9, 0, sizeof(v9));
  sub_24B6EC5C0((uint64_t)v9, v21);
  long long v11 = *(_OWORD *)v9;
  long long v12 = *(_OWORD *)&v9[16];
  *(float *)&long long v11 = *(float *)v9 + 1.0;
  *(float *)&long long v12 = *(float *)&v9[16] + 1.0;
  float v13 = *(float *)&v9[32] + 1.0;
  v21[0] = (float *)&v11;
  uint64_t v14 = v21;
  float32x2_t v15 = (float32x2_t)&v11;
  memset(&v9[4], 0, 32);
  float v10 = 0.0;
  sub_24B711E54((uint64_t)&v9[4], (uint64_t)&v14);
  return fabsf((float)((float)(*(float *)&v9[4] + -1.0) + (float)(*(float *)&v9[20] + -1.0)) + (float)(v10 + -1.0)) < 0.1;
}

uint64_t sub_24B711AE4(float *a1, uint64_t a2)
{
  float v4 = &qword_2697D1000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D12B0, memory_order_acquire) & 1) == 0)
  {
    int v42 = __cxa_guard_acquire(&qword_2697D12B0);
    float v4 = &qword_2697D1000;
    if (v42)
    {
      dword_2697D12A8 = 968164595;
      __cxa_guard_release(&qword_2697D12B0);
      float v4 = &qword_2697D1000;
    }
  }
  float v5 = *((float *)v4 + 170);
  uint64_t v43 = a2;
  v44[0] = &v43;
  v44[1] = a2;
  long long v45 = 0u;
  long long v46 = 0u;
  float v47 = 0.0;
  sub_24B712000((uint64_t)&v45, (uint64_t)v44);
  uint64_t result = 0;
  float v7 = fabsf(*(float *)&v45 + -1.0);
  float v8 = fabsf(*((float *)&v45 + 1));
  if (v7 < v8) {
    float v7 = v8;
  }
  float v9 = fabsf(*((float *)&v45 + 2));
  if (v7 < v9) {
    float v7 = v9;
  }
  float v10 = fabsf(*((float *)&v45 + 3));
  if (v7 < v10) {
    float v7 = v10;
  }
  float v11 = fabsf(*(float *)&v46 + -1.0);
  if (v7 < v11) {
    float v7 = v11;
  }
  float v12 = fabsf(*((float *)&v46 + 1));
  if (v7 < v12) {
    float v7 = v12;
  }
  float v13 = fabsf(*((float *)&v46 + 2));
  if (v7 < v13) {
    float v7 = v13;
  }
  float v14 = fabsf(*((float *)&v46 + 3));
  if (v7 < v14) {
    float v7 = v14;
  }
  float v15 = fabsf(v47 + -1.0);
  if (v7 < v15) {
    float v7 = v15;
  }
  if (v7 <= v5)
  {
    int v16 = *(float **)a2;
    uint64_t v17 = *(unsigned int *)(a2 + 8);
    float v19 = **(float **)a2;
    float v18 = *(float *)(*(void *)a2 + 4);
    float v20 = *(float *)(*(void *)a2 + 8);
    uint64_t v21 = (v17 - 3);
    uint64_t v22 = (float *)(*(void *)a2 + v21 * 4);
    float v23 = v22[3];
    float v24 = v22[4];
    v22 += 3;
    float32x4_t v25 = &v22[v21];
    if (fabsf((float)((float)(v20 * (float)((float)(v25[4] * v23) - (float)(v24 * v25[3])))+ (float)((float)(v19 * (float)((float)(v25[5] * v24) - (float)(v22[2] * v25[4])))- (float)(v18 * (float)((float)(v25[5] * v23) - (float)(v22[2] * v25[3])))))+ -1.0) > v5)return 0; {
    float v26 = v16[(v17 + 1)];
    }
    int v27 = 2 * v17;
    float v28 = v16[(2 * v17 + 2)];
    float v29 = (float)((float)(v19 + 1.0) + v26) + v28;
    float v30 = (float)((float)(v19 + 1.0) - v26) - v28;
    float v31 = 1.0 - v19;
    float v32 = (float)((float)(1.0 - v19) + v26) - v28;
    float v33 = (float)(v31 - v26) + v28;
    if (v30 <= v29) {
      float v34 = v29;
    }
    else {
      float v34 = v30;
    }
    if (v32 <= v34) {
      float v35 = v34;
    }
    else {
      float v35 = v32;
    }
    if (v33 > v35)
    {
      float v36 = -sqrtf(v33);
      float v37 = (float)(v18 - v16[v17]) / v36;
      *a1 = v37;
      float v38 = (float)(v16[2] + v16[v27]) / v36;
      a1[1] = v38;
      float v39 = (float)(v16[v27 | 1] + v16[(v17 + 2)]) / v36;
LABEL_37:
      *a1 = v37 * 0.5;
      a1[1] = v38 * 0.5;
      a1[2] = v39 * 0.5;
      a1[3] = v36 * 0.5;
      return 1;
    }
    int v40 = v30 > v29;
    if (v32 > v34) {
      int v40 = 2;
    }
    float v37 = sqrtf(v35);
    float v38 = -v37;
    if (v40 == 2)
    {
      float v37 = (float)(v16[v27] - v20) / v38;
      *a1 = v37;
      float v41 = (float)(v16[v17] + v16[1]) / v38;
      a1[1] = v41;
      a1[2] = v38;
      float v36 = (float)(v16[v27 | 1] + v16[(v17 + 2)]) / v38;
      float v39 = v38;
    }
    else
    {
      if (v40 == 1)
      {
        float v37 = (float)(v16[(v17 + 2)] - v16[v27 | 1]) / v38;
        *a1 = v37;
        a1[1] = v38;
        float v39 = (float)(v16[v17] + v16[1]) / v38;
        a1[2] = v39;
        float v36 = (float)(v16[2] + v16[v27]) / v38;
        goto LABEL_37;
      }
      *a1 = v37;
      float v41 = (float)(v16[v27 | 1] - v16[(v17 + 2)]) / v38;
      a1[1] = v41;
      float v39 = (float)(v16[2] - v16[v27]) / v38;
      a1[2] = v39;
      float v36 = (float)(v16[v17] - v16[1]) / v38;
    }
    float v38 = v41;
    goto LABEL_37;
  }
  return result;
}

__n64 sub_24B711E54(uint64_t a1, uint64_t a2)
{
  float32x2_t v3 = *(float **)(a2 + 8);
  if (v3 == (float *)a1)
  {
    int v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    sub_24B711E54(&v7);
    result.n64_u64[0] = v7;
    long long v6 = v8;
    *(_OWORD *)a1 = v7;
    *(_OWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 32) = v9;
  }
  else
  {
    float v4 = **(float ***)a2;
    result.n64_u32[1] = 0;
    *(float *)a1 = (float)((float)((float)(v4[1] * v3[1]) + (float)(*v4 * *v3)) + 0.0) + (float)(v4[2] * v3[2]);
    *(float *)(a1 + 4) = (float)((float)((float)(v4[4] * v3[1]) + (float)(v4[3] * *v3)) + 0.0) + (float)(v4[5] * v3[2]);
    *(float *)(a1 + 8) = (float)((float)((float)(v4[7] * v3[1]) + (float)(v4[6] * *v3)) + 0.0) + (float)(v4[8] * v3[2]);
    *(float *)(a1 + 12) = (float)((float)((float)(v4[1] * v3[4]) + (float)(*v4 * v3[3])) + 0.0) + (float)(v4[2] * v3[5]);
    *(float *)(a1 + 16) = (float)((float)((float)(v4[4] * v3[4]) + (float)(v4[3] * v3[3])) + 0.0)
                        + (float)(v4[5] * v3[5]);
    *(float *)(a1 + 20) = (float)((float)((float)(v4[7] * v3[4]) + (float)(v4[6] * v3[3])) + 0.0)
                        + (float)(v4[8] * v3[5]);
    *(float *)(a1 + 24) = (float)((float)((float)(v4[1] * v3[7]) + (float)(*v4 * v3[6])) + 0.0) + (float)(v4[2] * v3[8]);
    *(float *)(a1 + 28) = (float)((float)((float)(v4[4] * v3[7]) + (float)(v4[3] * v3[6])) + 0.0)
                        + (float)(v4[5] * v3[8]);
    result.n64_f32[0] = (float)((float)((float)(v4[7] * v3[7]) + (float)(v4[6] * v3[6])) + 0.0) + (float)(v4[8] * v3[8]);
    *(_DWORD *)(a1 + 32) = result.n64_u32[0];
  }
  return result;
}

__n64 sub_24B712000(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  float v4 = *(float **)v3;
  if (*(void *)v3 - 4 * *(unsigned int *)(v3 + 12) == a1)
  {
    int v22 = 0;
    long long v20 = 0u;
    long long v21 = 0u;
    sub_24B712000(&v20);
    result.n64_u64[0] = v20;
    long long v19 = v21;
    *(_OWORD *)a1 = v20;
    *(_OWORD *)(a1 + 16) = v19;
    *(_DWORD *)(a1 + 32) = v22;
  }
  else
  {
    float v5 = **(unsigned int ***)a2;
    uint64_t v6 = *(unsigned int *)(v3 + 8);
    long long v7 = *(float **)v5;
    uint64_t v8 = v5[2];
    result.n64_u32[1] = 0;
    *(float *)a1 = (float)((float)((float)(*(float *)(*(void *)v5 + 4) * v4[1]) + (float)(**(float **)v5 * *v4))
                         + 0.0)
                 + (float)(*(float *)(*(void *)v5 + 8) * v4[2]);
    int v9 = &v7[v8];
    uint64_t v10 = (v8 + 2);
    *(float *)(a1 + 4) = (float)((float)((float)(v9[1] * v4[1]) + (float)(*v9 * *v4)) + 0.0) + (float)(v7[v10] * v4[2]);
    int v11 = 2 * v8;
    float v12 = &v7[(2 * v8)];
    uint64_t v13 = (v11 + 2);
    *(float *)(a1 + 8) = (float)((float)((float)(v12[1] * v4[1]) + (float)(*v12 * *v4)) + 0.0)
                       + (float)(v7[v13] * v4[2]);
    float v14 = &v4[v6];
    uint64_t v15 = (v6 + 2);
    *(float *)(a1 + 12) = (float)((float)((float)(v7[1] * v14[1]) + (float)(*v7 * *v14)) + 0.0)
                        + (float)(v7[2] * v4[v15]);
    *(float *)(a1 + 16) = (float)((float)((float)(v9[1] * v14[1]) + (float)(*v9 * *v14)) + 0.0)
                        + (float)(v7[v10] * v4[v15]);
    *(float *)(a1 + 20) = (float)((float)((float)(v12[1] * v14[1]) + (float)(*v12 * *v14)) + 0.0)
                        + (float)(v7[v13] * v4[v15]);
    LODWORD(v6) = 2 * v6;
    int v16 = &v4[v6];
    uint64_t v17 = (v6 + 2);
    *(float *)(a1 + 24) = (float)((float)((float)(v7[1] * v16[1]) + (float)(*v7 * *v16)) + 0.0)
                        + (float)(v7[2] * v4[v17]);
    *(float *)(a1 + 28) = (float)((float)((float)(v9[1] * v16[1]) + (float)(*v9 * *v16)) + 0.0)
                        + (float)(v7[v10] * v4[v17]);
    result.n64_f32[0] = (float)((float)((float)(v12[1] * v16[1]) + (float)(*v12 * *v16)) + 0.0)
                      + (float)(v7[v13] * v4[v17]);
    *(_DWORD *)(a1 + 32) = result.n64_u32[0];
  }
  return result;
}

__n128 sub_24B7121FC(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void sub_24B712220(uint64_t a1)
{
  int v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void sub_24B712238(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 500 * a2;
  unint64_t v3 = 500 * a2 + 500;
  if (v3 >= **(unsigned int **)(a1 + 40)) {
    unint64_t v3 = **(unsigned int **)(a1 + 40);
  }
  unint64_t v4 = v3 - v2;
  if (v3 > v2)
  {
    uint64_t v6 = **(void **)(a1 + 48);
    uint64_t v7 = 2000 * a2;
    uint64_t v8 = 24000 * a2;
    do
    {
      float32x4_t v9 = *(float32x4_t *)(*(void *)(*(void *)(a1 + 40) + 8) + v8);
      v9.i32[3] = -1.0;
      int8x16_t v10 = (int8x16_t)vmulq_f32(*(float32x4_t *)(*(void *)(a1 + 56) + 112), v9);
      *(float *)(v6 + 4 * v7 + 12) = vaddv_f32(vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL)));
      uint64_t v6 = **(void **)(a1 + 48);
      *(float *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + v7) = 1.0
                                                                                   / (float)(expf((float)(0.02 - *(float *)(v6 + 4 * v7 + 12))* 500.0)+ 1.0);
      v7 += 4;
      v8 += 48;
      --v4;
    }
    while (v4);
  }
}

void sub_24B712348(uint64_t a1, uint64_t a2)
{
  uint64_t v43 = 0;
  unsigned __int16 v44 = 0;
  uint64_t v45 = 0;
  unint64_t v2 = 500 * a2;
  if (500 * a2 + 500 >= (unint64_t)**(unsigned int **)(a1 + 40)) {
    unint64_t v3 = **(unsigned int **)(a1 + 40);
  }
  else {
    unint64_t v3 = 500 * a2 + 500;
  }
  if (v2 < v3)
  {
    float v5 = 0;
    v6.i32[3] = 0;
    do
    {
      uint64_t v8 = **(void **)(a1 + 48);
      long long v9 = *(_OWORD *)(v8 + 16 * v2);
      if (*((float *)&v9 + 3) < -0.025)
      {
        *(void *)&long long v7 = 0;
        DWORD2(v7) = 0;
        HIDWORD(v7) = HIDWORD(v9);
        *(_OWORD *)(v8 + 16 * v2) = v7;
      }
      else
      {
        __int32 v42 = v6.i32[3];
        sub_24B703708(*(float32x4_t **)(a1 + 56), (float32x4_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 48 * v2), (uint64_t)&v43);
        float v5 = v43;
        int v11 = v44;
        if (v43 == v44)
        {
          float32x2_t v12 = 0;
          _S0 = 0.0;
          float v13 = 0.0;
          float32x2_t v15 = 0;
          _Q6.i64[0] = 0;
          float32x2_t v16 = 0;
        }
        else
        {
          float32x2_t v12 = 0;
          float v13 = 0.0;
          float v14 = v43;
          float32x2_t v15 = 0;
          float32x2_t v16 = 0;
          do
          {
            unsigned int v17 = *v14++;
            uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8) + 48 * v17;
            _Q6 = *(float32x4_t *)(v18 + 16);
            _S7 = HIDWORD(*(void *)(v18 + 16));
            float32x2_t v15 = vmla_n_f32(v15, *(float32x2_t *)_Q6.f32, _Q6.f32[0]);
            _S16 = COERCE_FLOAT(*(void *)(v18 + 24));
            __asm { FMLA            S1, S7, V6.S[1] }
            float32x2_t v16 = vmla_laneq_f32(v16, *(float32x2_t *)_Q6.f32, _Q6, 2);
            __asm { FMLA            S0, S16, V6.S[2] }
            float32x2_t v12 = vadd_f32(*(float32x2_t *)_Q6.f32, v12);
            float v13 = _S16 + v13;
          }
          while (v14 != v44);
          if ((char *)v44 - (char *)v43 < 0) {
            abort();
          }
          _Q6.f32[0] = (float)((unint64_t)((char *)v44 - (char *)v43) >> 2);
        }
        v10.f32[0] = v13 / _Q6.f32[0];
        _D4 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q6.f32, 0);
        _D16 = vdiv_f32(v12, _D4);
        float32x2_t v30 = vdiv_f32(v16, _D4);
        float32x2_t v31 = vmls_lane_f32(vdiv_f32(v15, _D4), _D16, _D16, 0);
        _D4.i32[0] = _D16.i32[1];
        *(float32x2_t *)v6.f32 = _D16;
        v6.i64[1] = __PAIR64__(v42, v10.u32[0]);
        __asm { FMLS            S17, S4, V16.S[1] }
        *(float32x2_t *)v33.f32 = v31;
        v33.i64[1] = __PAIR64__(v41, vmls_lane_f32(v30, _D16, v10, 0).u32[0]);
        float32_t v34 = (float)(_S0 / _Q6.f32[0]) - (float)(v10.f32[0] * v10.f32[0]);
        float32x4_t v35 = vmulq_f32(v6, *(float32x4_t *)(*(void *)(a1 + 64) + 32));
        *(float *)(**(void **)(a1 + 48) + 16 * v2) = 1.0
                                                     - vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1))).f32[0];
        float32x4_t v36 = v33;
        v36.i32[1] = _S17;
        v36.f32[2] = v34;
        float32x4_t v37 = vmulq_f32(v36, v36);
        *(float *)(**(void **)(a1 + 48) + 16 * v2 + 4) = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).f32[0]);
        *(_DWORD *)(**(void **)(a1 + 48) + 16 * v2 + 8) = 0;
        if (v5 != v11)
        {
          float v38 = v5;
          do
          {
            unsigned int v39 = *v38++;
            uint64_t v40 = **(void **)(a1 + 48) + 16 * v2;
            *(float *)(v40 + 8) = *(float *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 4 * v39)
                                + *(float *)(v40 + 8);
          }
          while (v38 != v11);
        }
      }
      ++v2;
    }
    while (v2 != v3);
    if (v5)
    {
      operator delete(v5);
    }
  }
}

float32x4_t sub_24B712618(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 500 * a2;
  unint64_t v3 = 500 * a2 + 500;
  if (v3 >= **(unsigned int **)(a1 + 64)) {
    unint64_t v3 = **(unsigned int **)(a1 + 64);
  }
  if (v2 < v3)
  {
    do
    {
      uint64_t v4 = **(void **)(a1 + 72);
      float32x4_t result = *(float32x4_t *)(v4 + 16 * v2);
      float32x4_t v6 = vdivq_f32(vsubq_f32(result, *(float32x4_t *)(a1 + 32)), vsubq_f32(*(float32x4_t *)(a1 + 48), *(float32x4_t *)(a1 + 32)));
      v6.i32[3] = result.i32[3];
      *(float32x4_t *)(v4 + 16 * v2++) = v6;
    }
    while (v3 != v2);
  }
  return result;
}

void sub_24B712674(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 500 * a2;
  unint64_t v3 = 500 * a2 + 500;
  uint64_t v4 = **(void **)(a1 + 32);
  if ((*(void *)(*(void *)(a1 + 32) + 8) - v4) >> 4 < v3) {
    unint64_t v3 = (*(void *)(*(void *)(a1 + 32) + 8) - v4) >> 4;
  }
  unint64_t v5 = v3 - v2;
  if (v3 > v2)
  {
    float32x4_t v6 = (float *)(**(void **)(a1 + 40) + 2000 * a2);
    long long v7 = (float32x4_t *)(v4 + 8000 * a2);
    do
    {
      float v8 = v7->f32[3];
      float v9 = expf((float)(0.035 - v8) * 500.0) + 1.0;
      float v10 = (float)(v8 + 0.025) * 500.0;
      float v11 = 1.0 / v9;
      float v12 = expf(v10);
      float32x4_t v13 = *v7++;
      float32x4_t v14 = vmulq_f32(v13, (float32x4_t)xmmword_24B72A7E0);
      *v6++ = v11
            + (float)((float)(1.0 - (float)((float)(1.0 / (float)(v12 + 1.0)) + v11))
                    * vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0]);
      --v5;
    }
    while (v5);
  }
}

void sub_24B712790(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x55;
  unint64_t v4 = v2 - 85;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    float32x4_t v6 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    long long v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_86:
      *(void *)unint64_t v5 = v8;
      goto LABEL_87;
    }
    float v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v33 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v33 = 1;
      }
      if (!(v33 >> 61))
      {
        unint64_t v34 = v33 >> 2;
        uint64_t v35 = 8 * v33;
        float32x4_t v36 = (char *)operator new(8 * v33);
        float32x4_t v37 = &v36[8 * v34];
        float v38 = &v36[v35];
        int64_t v40 = v5 - v7;
        BOOL v39 = v5 == v7;
        unint64_t v5 = v37;
        if (!v39)
        {
          unint64_t v5 = &v37[v40 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v41 = v40 - 8;
          if ((unint64_t)(v40 - 8) >= 0x38)
          {
            float v84 = &v36[8 * v34];
            __int32 v42 = v84;
            if ((unint64_t)(v84 - v7) >= 0x20)
            {
              uint64_t v85 = (v41 >> 3) + 1;
              uint64_t v86 = 8 * (v85 & 0x3FFFFFFFFFFFFFFCLL);
              __int32 v42 = &v37[v86];
              int v87 = (long long *)(v6 + 3);
              uint64_t v88 = v84 + 16;
              uint64_t v89 = v85 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v90 = *v87;
                *(v88 - 1) = *(v87 - 1);
                *uint64_t v88 = v90;
                v87 += 2;
                v88 += 2;
                v89 -= 4;
              }
              while (v89);
              if (v85 == (v85 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_79;
              }
              v7 += v86;
            }
          }
          else
          {
            __int32 v42 = &v36[8 * v34];
          }
          do
          {
            uint64_t v91 = *(void *)v7;
            v7 += 8;
            *(void *)__int32 v42 = v91;
            v42 += 8;
          }
          while (v42 != v5);
        }
        goto LABEL_79;
      }
LABEL_103:
      sub_24B6BCD7C();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    float32x2_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      long long v7 = *(char **)(a1 + 8);
    }
    unint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_86;
  }
  uint64_t v18 = *(char **)(a1 + 16);
  unsigned int v17 = *(char **)(a1 + 24);
  long long v20 = *(char **)a1;
  long long v19 = *(char **)(a1 + 8);
  uint64_t v21 = v18 - v19;
  uint64_t v22 = (v18 - v19) >> 3;
  uint64_t v23 = (uint64_t)&v17[-*(void *)a1];
  if (v22 < (unint64_t)(v23 >> 3))
  {
    float v24 = operator new(0xFF0uLL);
    float32x4_t v25 = v24;
    if (v17 != v18)
    {
      *(void *)uint64_t v18 = v24;
LABEL_87:
      *(void *)(a1 + 16) += 8;
      return;
    }
    if (v19 != v20)
    {
      uint64_t v43 = v19;
      goto LABEL_85;
    }
    unint64_t v69 = (v17 - v19) >> 2;
    if (v18 == v19) {
      unint64_t v69 = 1;
    }
    if (v69 >> 61) {
      goto LABEL_103;
    }
    unint64_t v70 = (v69 + 3) >> 2;
    uint64_t v71 = 8 * v69;
    int v72 = (char *)operator new(8 * v69);
    uint64_t v43 = &v72[8 * v70];
    char v73 = &v72[v71];
    uint64_t v74 = v43;
    if (v18 != v19)
    {
      uint64_t v74 = &v43[8 * v22];
      uint64_t v75 = &v72[8 * v70];
      uint64_t v76 = v19;
      if ((unint64_t)(v21 - 8) > 0x37)
      {
        float32x2_t v77 = &v72[8 * v70];
        uint64_t v75 = v77;
        uint64_t v76 = v19;
        if ((unint64_t)(v77 - v19) >= 0x20)
        {
          unint64_t v78 = ((unint64_t)(v21 - 8) >> 3) + 1;
          uint64_t v79 = 8 * (v78 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v75 = &v43[v79];
          id v80 = (long long *)(v19 + 16);
          float v81 = v77 + 16;
          uint64_t v82 = v78 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v83 = *v80;
            *(v81 - 1) = *(v80 - 1);
            _OWORD *v81 = v83;
            v80 += 2;
            v81 += 2;
            v82 -= 4;
          }
          while (v82);
          if (v78 == (v78 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *(void *)a1 = v72;
            *(void *)(a1 + 8) = v43;
            *(void *)(a1 + 16) = v74;
            *(void *)(a1 + 24) = v73;
LABEL_84:
            operator delete(v19);
            uint64_t v43 = *(char **)(a1 + 8);
LABEL_85:
            *((void *)v43 - 1) = v25;
            long long v7 = *(char **)(a1 + 8);
            unint64_t v5 = *(char **)(a1 + 16);
            *(void *)(a1 + 8) = v7 - 8;
            uint64_t v8 = *((void *)v7 - 1);
            *(void *)(a1 + 8) = v7;
            if (v5 != *(char **)(a1 + 24)) {
              goto LABEL_86;
            }
            float v9 = *(char **)a1;
            uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
            if ((unint64_t)v7 <= *(void *)a1)
            {
              unint64_t v93 = (v5 - v9) >> 2;
              if (v5 == v9) {
                unint64_t v93 = 1;
              }
              if (!(v93 >> 61))
              {
                unint64_t v94 = v93 >> 2;
                uint64_t v95 = 8 * v93;
                float32x4_t v36 = (char *)operator new(8 * v93);
                float32x4_t v37 = &v36[8 * v94];
                float v38 = &v36[v95];
                int64_t v96 = v5 - v7;
                BOOL v39 = v5 == v7;
                unint64_t v5 = v37;
                if (!v39)
                {
                  unint64_t v5 = &v37[v96 & 0xFFFFFFFFFFFFFFF8];
                  unint64_t v97 = v96 - 8;
                  if ((unint64_t)(v96 - 8) >= 0x38)
                  {
                    float32x2_t v99 = &v36[8 * v94];
                    float32x2_t v98 = v99;
                    if ((unint64_t)(v99 - v7) >= 0x20)
                    {
                      uint64_t v100 = (v97 >> 3) + 1;
                      uint64_t v101 = 8 * (v100 & 0x3FFFFFFFFFFFFFFCLL);
                      float32x2_t v98 = &v37[v101];
                      float32x4_t v102 = (long long *)(v7 + 16);
                      uint64_t v103 = v99 + 16;
                      uint64_t v104 = v100 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        long long v105 = *v102;
                        *(v103 - 1) = *(v102 - 1);
                        *uint64_t v103 = v105;
                        v102 += 2;
                        v103 += 2;
                        v104 -= 4;
                      }
                      while (v104);
                      if (v100 == (v100 & 0x3FFFFFFFFFFFFFFCLL)) {
                        goto LABEL_79;
                      }
                      v7 += v101;
                    }
                  }
                  else
                  {
                    float32x2_t v98 = &v36[8 * v94];
                  }
                  do
                  {
                    uint64_t v106 = *(void *)v7;
                    v7 += 8;
                    *(void *)float32x2_t v98 = v106;
                    v98 += 8;
                  }
                  while (v98 != v5);
                }
LABEL_79:
                *(void *)a1 = v36;
                *(void *)(a1 + 8) = v37;
                *(void *)(a1 + 16) = v5;
                *(void *)(a1 + 24) = v38;
                if (v9)
                {
                  operator delete(v9);
                  unint64_t v5 = *(char **)(a1 + 16);
                }
                goto LABEL_86;
              }
              goto LABEL_103;
            }
            goto LABEL_5;
          }
          uint64_t v76 = &v19[v79];
        }
      }
      do
      {
        uint64_t v92 = *(void *)v76;
        v76 += 8;
        *(void *)uint64_t v75 = v92;
        v75 += 8;
      }
      while (v75 != v74);
    }
    *(void *)a1 = v72;
    *(void *)(a1 + 8) = v43;
    *(void *)(a1 + 16) = v74;
    *(void *)(a1 + 24) = v73;
    if (!v19) {
      goto LABEL_85;
    }
    goto LABEL_84;
  }
  uint64_t v26 = v23 >> 2;
  if (v17 == v20) {
    unint64_t v27 = 1;
  }
  else {
    unint64_t v27 = v26;
  }
  if (v27 >> 61) {
    goto LABEL_103;
  }
  float v28 = (char *)operator new(8 * v27);
  float v29 = &v28[8 * v22];
  float32x2_t v30 = &v28[8 * v27];
  float32x2_t v31 = operator new(0xFF0uLL);
  if (v22 == v27)
  {
    if (v21 < 1)
    {
      unint64_t v44 = v21 >> 2;
      if (v18 == v19) {
        unint64_t v44 = 1;
      }
      if (v44 >> 61) {
        goto LABEL_103;
      }
      uint64_t v45 = 8 * v44;
      float v29 = (char *)operator new(8 * v44);
      float32x2_t v30 = &v29[v45];
      operator delete(v28);
      long long v19 = *(char **)(a1 + 8);
      uint64_t v18 = *(char **)(a1 + 16);
      float v28 = v29;
    }
    else
    {
      unint64_t v32 = v22 + 2;
      if (v22 >= -1) {
        unint64_t v32 = v22 + 1;
      }
      v29 -= 8 * (v32 >> 1);
    }
  }
  *(void *)float v29 = v31;
  long long v46 = v29 + 8;
  if (v18 != v19)
  {
    while (v29 != v28)
    {
      __int16 v50 = v29;
      uint64_t v48 = v46;
LABEL_42:
      uint64_t v51 = *((void *)v18 - 1);
      v18 -= 8;
      *((void *)v50 - 1) = v51;
      float v47 = v50 - 8;
      long long v46 = v48;
      float v29 = v47;
      if (v18 == *(char **)(a1 + 8)) {
        goto LABEL_37;
      }
    }
    if (v46 < v30)
    {
      uint64_t v52 = (v30 - v46) >> 3;
      if (v52 >= -1) {
        unint64_t v53 = v52 + 1;
      }
      else {
        unint64_t v53 = v52 + 2;
      }
      uint64_t v48 = &v46[8 * (v53 >> 1)];
      __int16 v50 = &v29[8 * (v53 >> 1)];
      if (v46 == v29)
      {
        float v28 = v46;
      }
      else
      {
        memmove(&v29[8 * (v53 >> 1)], v29, v46 - v29);
        float v28 = v29;
      }
      goto LABEL_42;
    }
    unint64_t v54 = (v30 - v29) >> 2;
    if (v30 == v29) {
      unint64_t v54 = 1;
    }
    if (v54 >> 61) {
      goto LABEL_103;
    }
    unint64_t v55 = (v54 + 3) >> 2;
    uint64_t v56 = 8 * v54;
    int v57 = (char *)operator new(8 * v54);
    float v28 = v57;
    __int16 v50 = &v57[8 * v55];
    uint64_t v48 = v50;
    int64_t v58 = v46 - v29;
    if (v46 != v29)
    {
      uint64_t v48 = &v50[v58 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v59 = v58 - 8;
      uint64_t v60 = &v57[8 * v55];
      int16x4_t v61 = v29;
      if (v59 >= 0x38)
      {
        uint64_t v60 = &v57[8 * v55];
        int16x4_t v61 = v29;
        if ((unint64_t)(v60 - v29) >= 0x20)
        {
          uint64_t v62 = (v59 >> 3) + 1;
          uint64_t v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v60 = &v50[v63];
          int v64 = (long long *)(v29 + 16);
          __int16 v65 = &v57[8 * v55 + 16];
          uint64_t v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v67 = *v64;
            *((_OWORD *)v65 - 1) = *(v64 - 1);
            *(_OWORD *)__int16 v65 = v67;
            v64 += 2;
            v65 += 32;
            v66 -= 4;
          }
          while (v66);
          if (v62 == (v62 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_61;
          }
          int16x4_t v61 = &v29[v63];
        }
      }
      do
      {
        uint64_t v68 = *(void *)v61;
        v61 += 8;
        *(void *)uint64_t v60 = v68;
        v60 += 8;
      }
      while (v60 != v48);
    }
LABEL_61:
    float32x2_t v30 = &v57[v56];
    operator delete(v29);
    goto LABEL_42;
  }
  float v47 = v29;
  uint64_t v48 = v29 + 8;
LABEL_37:
  uint64_t v49 = *(char **)a1;
  *(void *)a1 = v28;
  *(void *)(a1 + 8) = v47;
  *(void *)(a1 + 16) = v48;
  *(void *)(a1 + 24) = v30;
  if (v49)
  {
    operator delete(v49);
  }
}

os_log_t sub_24B712DAC()
{
  os_log_t result = os_log_create("com.apple.CoreOCModules", "General");
  qword_2697D12B8 = (uint64_t)result;
  return result;
}

uint64_t sub_24B712DDC(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  long long v4 = a2[1];
  long long v5 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v5;
  *(_OWORD *)a1 = v3;
  *(_OWORD *)(a1 + 16) = v4;
  long long v6 = a2[4];
  long long v7 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  long long v9 = 0uLL;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1358, memory_order_acquire) & 1) == 0)
  {
    int v11 = __cxa_guard_acquire(&qword_2697D1358);
    long long v9 = 0uLL;
    if (v11)
    {
      qword_2697D1350 = sub_24B727BB4();
      __cxa_atexit((void (*)(void *))sub_24B727D84, &qword_2697D1350, &dword_24B6B9000);
      __cxa_guard_release(&qword_2697D1358);
      long long v9 = 0uLL;
    }
  }
  *(void *)(a1 + 192) = qword_2697D1350;
  *(_OWORD *)(a1 + 200) = v9;
  *(_OWORD *)(a1 + 216) = v9;
  *(_OWORD *)(a1 + 232) = v9;
  sub_24B6ECE9C(a1 + 248);
  *(_WORD *)(a1 + 480) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = xmmword_24B72A620;
  *(_OWORD *)(a1 + 552) = xmmword_24B72A630;
  *(_OWORD *)(a1 + 568) = xmmword_24B72A640;
  *(_OWORD *)(a1 + 584) = xmmword_24B72A650;
  *(void *)(a1 + 600) = 0;
  *(_DWORD *)(a1 + 608) = 0x40000000;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_DWORD *)(a1 + 680) = 3;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(void *)(a1 + 720) = 10;
  *(_DWORD *)(a1 + 728) = 1065353216;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(void *)(a1 + 784) = 0;
  return a1;
}

void sub_24B712F44(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_2697D1358);
  long long v4 = (void *)v1[19];
  if (v4)
  {
    v1[20] = v4;
    operator delete(v4);
    long long v5 = *v2;
    if (!*v2) {
LABEL_3:
    }
      _Unwind_Resume(a1);
  }
  else
  {
    long long v5 = *v2;
    if (!*v2) {
      goto LABEL_3;
    }
  }
  v1[17] = v5;
  operator delete(v5);
  _Unwind_Resume(a1);
}

uint64_t sub_24B712FC4(int *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4 = a1[5];
  if (a1[4] >= v4) {
    return 0;
  }
  float v6 = *((float *)a1 + 7);
  if (v6 <= 0.0) {
    return 0;
  }
  float v7 = *((float *)a1 + 8);
  if (v6 >= v7) {
    return 0;
  }
  *((void *)a1 + 22) = a2;
  *((void *)a1 + 23) = a3;
  if (!*((void *)a1 + 24)) {
    return 0;
  }
  int v8 = *((unsigned __int8 *)a1 + 480);
  BOOL v10 = v6 <= 0.0 || a3 == 0 || a2 == 0;
  uint64_t result = 0;
  if (!v10 && v8 == 0)
  {
    float v13 = *((float *)a1 + 31);
    if (v13 <= 1.0 && v6 < v7 && v13 >= 0.0)
    {
      uint64_t result = 0;
      float v15 = *((float *)a1 + 134);
      if (v15 >= 0.0 && v15 <= 1.0)
      {
        float v16 = *((float *)a1 + 135);
        if (v16 <= 0.0) {
          return 0;
        }
        float v17 = *((float *)a1 + 136);
        if ((float)(v16 + 0.1) > v17) {
          return 0;
        }
        float v18 = *((float *)a1 + 137);
        if (v16 >= v18 || v18 > (float)((float)(v16 + v17) * 0.5) || *((float *)a1 + 138) < 1.1) {
          return 0;
        }
        uint64_t result = 0;
        if (*((float *)a1 + 139) >= 0.0)
        {
          float v19 = *((float *)a1 + 140);
          if (v19 >= 0.0 && v19 <= 1.0)
          {
            uint64_t v145 = (unsigned int *)(a1 + 48);
            if (*((float *)a1 + 141) <= 0.0) {
              return 0;
            }
            float v20 = *(float *)a1;
            *((void *)a1 + 50) = a2;
            *((void *)a1 + 51) = a3;
            a1[97] = v4;
            *((float *)a1 + 98) = v6;
            *((float *)a1 + 99) = v7;
            *((float *)a1 + 124) = v13;
            *((float *)a1 + 96) = v20;
            uint64_t result = sub_24B6ECF50((uint64_t)(a1 + 62), v4);
            if (result)
            {
              if (*((unsigned char *)a1 + 284)) {
                id v21 = *((id *)a1 + 34);
              }
              else {
                id v21 = 0;
              }
              uint64_t v22 = (void *)*((void *)a1 + 38);
              *((void *)a1 + 38) = v21;

              if (!*((void *)a1 + 38)) {
                return 0;
              }
              switch(a1[96])
              {
                case 0:
                  uint64_t v23 = (a1[97] << 7);
                  id v24 = **((id **)a1 + 24);
                  uint64_t v26 = objc_msgSend_newBufferWithLength_options_(v24, v25, v23, 0);
                  goto LABEL_55;
                case 1:
                  uint64_t v69 = 48 * a1[97];
                  id v70 = **((id **)a1 + 24);
                  uint64_t v72 = objc_msgSend_newBufferWithLength_options_(v70, v71, v69, 0);
                  char v73 = (void *)*((void *)a1 + 39);
                  *((void *)a1 + 39) = v72;

                  uint64_t v75 = (void *)*((void *)a1 + 39);
                  if (v75)
                  {
                    objc_msgSend_setLabel_(v75, v74, @"SurfaceVoxelDataBuffer");
                    uint64_t v76 = (4 * a1[97]);
                    id v77 = **((id **)a1 + 24);
                    uint64_t v79 = objc_msgSend_newBufferWithLength_options_(v77, v78, v76, 0);
                    id v80 = (void *)*((void *)a1 + 41);
                    *((void *)a1 + 41) = v79;

                    uint64_t v82 = (void *)*((void *)a1 + 41);
                    if (v82)
                    {
                      objc_msgSend_setLabel_(v82, v81, @"SurfaceVoxelVisibilityBuffer");
                      uint64_t v83 = 4 * a1[97];
                      id v84 = **((id **)a1 + 24);
                      uint64_t v86 = objc_msgSend_newBufferWithLength_options_(v84, v85, v83, 0);
                      int v87 = (void *)*((void *)a1 + 75);
                      *((void *)a1 + 75) = v86;

                      uint64_t v89 = (void *)*((void *)a1 + 75);
                      if (v89) {
                        objc_msgSend_setLabel_(v89, v88, @"SurfaceVoxelWCCountBuffer");
                      }
                    }
                  }
                  goto LABEL_64;
                case 2:
                  uint64_t v90 = 48 * a1[97];
                  id v91 = **((id **)a1 + 24);
                  uint64_t v93 = objc_msgSend_newBufferWithLength_options_(v91, v92, v90, 0);
                  unint64_t v94 = (void *)*((void *)a1 + 39);
                  *((void *)a1 + 39) = v93;

                  int64_t v96 = (void *)*((void *)a1 + 39);
                  if (!v96) {
                    goto LABEL_64;
                  }
                  objc_msgSend_setLabel_(v96, v95, @"SurfaceVoxelDataBuffer");
                  uint64_t v97 = (a1[97] << 6);
                  id v24 = **((id **)a1 + 24);
                  uint64_t v26 = objc_msgSend_newBufferWithLength_options_(v24, v98, v97, 0);
LABEL_55:
                  float32x2_t v99 = (void *)*((void *)a1 + 41);
                  *((void *)a1 + 41) = v26;

                  uint64_t v101 = (void *)*((void *)a1 + 41);
                  if (v101) {
                    objc_msgSend_setLabel_(v101, v100, @"SurfaceVoxelVisibilityBuffer");
                  }
LABEL_64:
                  uint64_t result = sub_24B6F1ED0((uint64_t)v145);
                  if (result)
                  {
                    uint64_t result = sub_24B6F2158(v145, v144);
                    if (result)
                    {
                      uint64_t result = sub_24B6F2980((uint64_t)v145);
                      if (result)
                      {
                        uint64_t result = sub_24B6F2A34((uint64_t)v145);
                        if (result)
                        {
                          if (!*(unsigned char *)(*(void *)v145 + 24)
                            || (uint64_t result = sub_24B6F2D18((uint64_t)v145), result))
                          {
                            if (a1[96] != 1 || (uint64_t result = sub_24B6F2F10((uint64_t)v145), result))
                            {
                              uint64_t result = 1;
                              *((unsigned char *)a1 + 480) = 1;
                            }
                          }
                        }
                      }
                    }
                  }
                  break;
                case 3:
                  uint64_t v102 = 48 * a1[97];
                  id v103 = **((id **)a1 + 24);
                  uint64_t v105 = objc_msgSend_newBufferWithLength_options_(v103, v104, v102, 0);
                  uint64_t v106 = (void *)*((void *)a1 + 39);
                  *((void *)a1 + 39) = v105;

                  float32x4_t v108 = (void *)*((void *)a1 + 39);
                  if (v108)
                  {
                    objc_msgSend_setLabel_(v108, v107, @"SurfaceVoxelDataBuffer");
                    uint64_t v109 = (20 * a1[97]);
                    id v110 = **((id **)a1 + 24);
                    uint64_t v112 = objc_msgSend_newBufferWithLength_options_(v110, v111, v109, 0);
                    uint64_t v113 = (void *)*((void *)a1 + 41);
                    *((void *)a1 + 41) = v112;

                    __int32 v115 = (void *)*((void *)a1 + 41);
                    if (v115)
                    {
                      objc_msgSend_setLabel_(v115, v114, @"SurfaceVoxelVisibilityBuffer");
                      uint64_t v116 = a1[97];
                      id v117 = **((id **)a1 + 24);
                      uint64_t v119 = objc_msgSend_newBufferWithLength_options_(v117, v118, v116, 0);
                      uint64_t v120 = (void *)*((void *)a1 + 77);
                      *((void *)a1 + 77) = v119;

                      float32x4_t v122 = (void *)*((void *)a1 + 77);
                      if (v122)
                      {
                        objc_msgSend_setLabel_(v122, v121, @"SurfaceVoxelFisherCountBuffer");
                        uint64_t v123 = 4 * a1[97];
                        id v124 = **((id **)a1 + 24);
                        uint64_t v126 = objc_msgSend_newBufferWithLength_options_(v124, v125, v123, 0);
                        uint64_t v127 = (void *)*((void *)a1 + 78);
                        *((void *)a1 + 78) = v126;

                        uint64_t v129 = (void *)*((void *)a1 + 78);
                        if (v129)
                        {
                          objc_msgSend_setLabel_(v129, v128, @"SurfaceVoxelFisherKappaBuffer");
                          uint64_t v130 = 4 * a1[97];
                          id v131 = **((id **)a1 + 24);
                          uint64_t v133 = objc_msgSend_newBufferWithLength_options_(v131, v132, v130, 0);
                          uint64_t v134 = (void *)*((void *)a1 + 80);
                          *((void *)a1 + 80) = v133;

                          unsigned __int8 v136 = (void *)*((void *)a1 + 80);
                          if (v136)
                          {
                            objc_msgSend_setLabel_(v136, v135, @"SurfaceVoxelFisherPastViewDirCountBuffer");
                            uint64_t v137 = 16 * a1[97];
                            id v138 = **((id **)a1 + 24);
                            uint64_t v140 = objc_msgSend_newBufferWithLength_options_(v138, v139, v137, 0);
                            uint64_t v141 = (void *)*((void *)a1 + 79);
                            *((void *)a1 + 79) = v140;

                            char v143 = (void *)*((void *)a1 + 79);
                            if (v143) {
                              objc_msgSend_setLabel_(v143, v142, @"SurfaceVoxelFisherPastViewDirBuffer");
                            }
                          }
                        }
                      }
                    }
                  }
                  goto LABEL_64;
                case 4:
                  uint64_t v27 = 48 * a1[97];
                  id v28 = **((id **)a1 + 24);
                  uint64_t v30 = objc_msgSend_newBufferWithLength_options_(v28, v29, v27, 0);
                  float32x2_t v31 = (void *)*((void *)a1 + 39);
                  *((void *)a1 + 39) = v30;

                  unint64_t v33 = (void *)*((void *)a1 + 39);
                  if (v33)
                  {
                    objc_msgSend_setLabel_(v33, v32, @"SurfaceVoxelDataBuffer");
                    uint64_t v34 = (a1[97] << 9);
                    id v35 = **((id **)a1 + 24);
                    uint64_t v37 = objc_msgSend_newBufferWithLength_options_(v35, v36, v34, 0);
                    float v38 = (void *)*((void *)a1 + 41);
                    *((void *)a1 + 41) = v37;

                    int64_t v40 = (void *)*((void *)a1 + 41);
                    if (v40)
                    {
                      objc_msgSend_setLabel_(v40, v39, @"SurfaceVoxelVisibilityBuffer");
                      uint64_t v41 = a1[97];
                      id v42 = **((id **)a1 + 24);
                      uint64_t v44 = objc_msgSend_newBufferWithLength_options_(v42, v43, v41, 0);
                      uint64_t v45 = (void *)*((void *)a1 + 81);
                      *((void *)a1 + 81) = v44;

                      float v47 = (void *)*((void *)a1 + 81);
                      if (v47)
                      {
                        objc_msgSend_setLabel_(v47, v46, @"SurfaceVoxelGOMDCountBuffer");
                        uint64_t v48 = 4 * a1[97];
                        id v49 = **((id **)a1 + 24);
                        uint64_t v51 = objc_msgSend_newBufferWithLength_options_(v49, v50, v48, 0);
                        uint64_t v52 = (void *)*((void *)a1 + 82);
                        *((void *)a1 + 82) = v51;

                        unint64_t v54 = (void *)*((void *)a1 + 82);
                        if (v54)
                        {
                          objc_msgSend_setLabel_(v54, v53, @"SurfaceVoxelGOMDCameraNumBuffer");
                          uint64_t v55 = (unint64_t)a1[97] << 9;
                          id v56 = **((id **)a1 + 24);
                          uint64_t v58 = objc_msgSend_newBufferWithLength_options_(v56, v57, v55, 0);
                          unint64_t v59 = (void *)*((void *)a1 + 83);
                          *((void *)a1 + 83) = v58;

                          int16x4_t v61 = (void *)*((void *)a1 + 83);
                          if (v61)
                          {
                            objc_msgSend_setLabel_(v61, v60, @"SurfaceVoxelGOMDGoodnessBuffer");
                            uint64_t v62 = (unint64_t)a1[97] << 11;
                            id v63 = **((id **)a1 + 24);
                            uint64_t v65 = objc_msgSend_newBufferWithLength_options_(v63, v64, v62, 0);
                            uint64_t v66 = (void *)*((void *)a1 + 84);
                            *((void *)a1 + 84) = v65;

                            uint64_t v68 = (void *)*((void *)a1 + 84);
                            if (v68) {
                              objc_msgSend_setLabel_(v68, v67, @"SurfaceVoxelGOMDViewDirBuffer");
                            }
                          }
                        }
                      }
                    }
                  }
                  goto LABEL_64;
                default:
                  return 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void sub_24B71370C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B713774(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v5 = *(void *)(a3 + 80);
  if (v5)
  {
    float v6 = (uint64_t *)operator new(8uLL);
    int v8 = v6;
    uint64_t *v6 = 0;
    long long v9 = (char *)(v6 + 1);
    if (v5 != 1)
    {
      uint64_t v10 = 0;
      float32x4_t v12 = *(float32x4_t *)(a3 + 48);
      float32x4_t v11 = *(float32x4_t *)(a3 + 64);
      float v13 = *(float *)a3;
      uint64_t v14 = *(int **)(a3 + 88);
      float32x4_t v15 = *(float32x4_t *)(a3 + 16);
      float32x4_t v16 = *(float32x4_t *)(a3 + 32);
      float32x4_t v17 = vaddq_f32(v11, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v15, *(float *)a3 * (float)((float)*v14 + 0.5)), v16, *(float *)a3 * (float)((float)v14[1] + 0.5)), v12, *(float *)a3 * (float)((float)v14[2] + 0.5)));
      uint64_t v18 = 1;
      float v19 = (char *)(v6 + 1);
      float v20 = (char *)(v6 + 1);
      id v21 = (char *)v6;
      while (1)
      {
        float32x4_t v22 = vaddq_f32(v11, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v15, v13 * (float)((float)v14[12 * v18] + 0.5)), v16, v13 * (float)((float)v14[12 * v18 + 1] + 0.5)), v12, v13 * (float)((float)v14[12 * v18 + 2] + 0.5)));
        *(float *)v7.i32 = (float)(unint64_t)(v18 - v10);
        float32x4_t v23 = vsubq_f32(v22, vdivq_f32(v17, (float32x4_t)vdupq_lane_s32(v7, 0)));
        float32x4_t v24 = vmulq_f32(v23, v23);
        int32x2_t v7 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).u64[0];
        if (sqrtf(*(float *)v7.i32) >= (float)(v13 * 14.0)) {
          break;
        }
        float32x4_t v17 = vaddq_f32(v17, v22);
LABEL_5:
        if (++v18 >= v5) {
          goto LABEL_37;
        }
      }
      if (v19 < v20)
      {
        *(void *)float v19 = v18;
        long long v9 = v19 + 8;
LABEL_26:
        float32x4_t v15 = *(float32x4_t *)(a3 + 16);
        float32x4_t v16 = *(float32x4_t *)(a3 + 32);
        float32x4_t v12 = *(float32x4_t *)(a3 + 48);
        float32x4_t v11 = *(float32x4_t *)(a3 + 64);
        float32x4_t v17 = vaddq_f32(v11, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v15, v13 * (float)((float)v14[12 * v18] + 0.5)), v16, v13 * (float)((float)v14[12 * v18 + 1] + 0.5)), v12, v13 * (float)((float)v14[12 * v18 + 2] + 0.5)));
        unint64_t v5 = *(void *)(a3 + 80);
        float v19 = v9;
        uint64_t v10 = v18;
        goto LABEL_5;
      }
      uint64_t v25 = (v19 - v21) >> 3;
      unint64_t v26 = v25 + 1;
      if ((unint64_t)(v25 + 1) >> 61) {
        abort();
      }
      if ((v20 - v21) >> 2 > v26) {
        unint64_t v26 = (v20 - v21) >> 2;
      }
      if ((unint64_t)(v20 - v21) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v27 = v26;
      }
      if (v27)
      {
        if (v27 >> 61) {
          sub_24B6BCD7C();
        }
        id v28 = operator new(8 * v27);
      }
      else
      {
        id v28 = 0;
      }
      int v8 = (uint64_t *)&v28[8 * v25];
      uint64_t *v8 = v18;
      if (v19 == v21)
      {
        long long v9 = (char *)(v8 + 1);
        float v20 = &v28[8 * v27];
        if (!v21) {
          goto LABEL_25;
        }
        goto LABEL_24;
      }
      unint64_t v29 = v19 - 8 - v21;
      if (v29 < 0x168
        || &v28[v19 - v21 - 8 - (v29 & 0xFFFFFFFFFFFFFFF8)] > &v28[v19 - v21 - 8]
        || &v19[-(v29 & 0xFFFFFFFFFFFFFFF8) - 8] > v19 - 8
        || (unint64_t)(v21 - v28) < 0x20)
      {
        uint64_t v30 = v19;
        long long v9 = (char *)(v8 + 1);
      }
      else
      {
        uint64_t v32 = (v29 >> 3) + 1;
        uint64_t v30 = &v19[-8 * (v32 & 0x3FFFFFFFFFFFFFFCLL)];
        unint64_t v33 = &v28[8 * v25 - 16];
        uint64_t v34 = v19 - 16;
        uint64_t v35 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        long long v9 = (char *)(v8 + 1);
        do
        {
          long long v36 = *(_OWORD *)v34;
          *(v33 - 1) = *((_OWORD *)v34 - 1);
          *unint64_t v33 = v36;
          v33 -= 2;
          v34 -= 32;
          v35 -= 4;
        }
        while (v35);
        v8 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_23:
          float v20 = &v28[8 * v27];
          if (!v21)
          {
LABEL_25:
            id v21 = (char *)v8;
            goto LABEL_26;
          }
LABEL_24:
          operator delete(v21);
          uint64_t v14 = *(int **)(a3 + 88);
          float v13 = *(float *)a3;
          goto LABEL_25;
        }
      }
      do
      {
        uint64_t v31 = *((void *)v30 - 1);
        v30 -= 8;
        *--int v8 = v31;
      }
      while (v30 != v21);
      goto LABEL_23;
    }
  }
  else
  {
    int v8 = 0;
    long long v9 = 0;
  }
LABEL_37:
  uint64_t v61 = 0;
  uint64_t v62 = &v61;
  uint64_t v63 = 0x4812000000;
  int v64 = sub_24B714310;
  uint64_t v65 = sub_24B714334;
  uint64_t v66 = &unk_24B73E73E;
  uint64_t v38 = *a4;
  uint64_t v37 = a4[1];
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  long long v67 = 0;
  uint64_t v39 = v37 - v38;
  if (v37 != v38)
  {
    if (v39 < 0) {
      abort();
    }
    int64_t v40 = (char *)operator new(v37 - v38);
    uint64_t v41 = &v40[4 * (v39 >> 2)];
    long long v67 = v40;
    uint64_t v69 = v41;
    bzero(v40, v39 & 0xFFFFFFFFFFFFFFFCLL);
    uint64_t v68 = v41;
  }
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3321888768;
  block[2] = sub_24B71434C;
  block[3] = &unk_26FE9D4D8;
  block[5] = a2;
  block[6] = 50;
  int v57 = 0;
  uint64_t v58 = 0;
  std::string __p = 0;
  size_t v42 = v9 - (char *)v8;
  uint64_t v43 = (v9 - (char *)v8) >> 3;
  if (v9 != (char *)v8)
  {
    if ((v42 & 0x8000000000000000) != 0) {
      abort();
    }
    uint64_t v44 = (char *)operator new(v9 - (char *)v8);
    uint64_t v45 = &v44[8 * v43];
    std::string __p = v44;
    uint64_t v58 = v45;
    memcpy(v44, v8, v42);
    int v57 = v45;
  }
  uint64_t v59 = a3;
  uint64_t v60 = a4;
  void block[4] = &v61;
  dispatch_apply((unint64_t)ceilf((float)(unint64_t)v43 / 50.0), 0, block);
  long long v46 = v62;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  uint64_t v48 = (unsigned char *)v46[6];
  float v47 = (unsigned char *)v46[7];
  int64_t v49 = v47 - v48;
  if (v47 != v48)
  {
    if (v49 < 0) {
      abort();
    }
    __int16 v50 = (char *)operator new(v47 - v48);
    *a1 = v50;
    uint64_t v51 = &v50[4 * (v49 >> 2)];
    a1[2] = v51;
    memcpy(v50, v48, v49);
    a1[1] = v51;
  }
  if (__p)
  {
    int v57 = __p;
    operator delete(__p);
  }
  _Block_object_dispose(&v61, 8);
  if (v67)
  {
    uint64_t v68 = v67;
    operator delete(v67);
  }
  if (v8) {
    operator delete(v8);
  }
}

void sub_24B713C90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32)
{
  if (__p) {
    operator delete(__p);
  }
  _Block_object_dispose(&a25, 8);
  if (a31)
  {
    a32 = (uint64_t)a31;
    operator delete(a31);
    if (!v32) {
LABEL_5:
    }
      _Unwind_Resume(a1);
  }
  else if (!v32)
  {
    goto LABEL_5;
  }
  operator delete(v32);
  _Unwind_Resume(a1);
}

void sub_24B713CF4(uint64_t a1, uint64_t a2, void *a3, double a4, int8x16_t a5)
{
  *(void *)(a1 + 736) = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 136) - *(void *)(a1 + 128)) >> 6);
  size_t prime = *(void *)(a2 + 80);
  *(_OWORD *)uint64_t v31 = 0u;
  *(_OWORD *)std::string __p = 0u;
  *(void *)&__p[16] = prime;
  float v33 = 1.0;
  if (prime == 1)
  {
    size_t prime = 2;
LABEL_17:
    sub_24B6BD1F0((uint64_t)v31, prime);
    goto LABEL_18;
  }
  if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    long long v9 = v31[1];
    BOOL v10 = (void *)prime >= v31[1];
    if ((void *)prime > v31[1]) {
      goto LABEL_17;
    }
  }
  else
  {
    long long v9 = 0;
    BOOL v10 = 1;
    if (prime) {
      goto LABEL_17;
    }
  }
  if (!v10)
  {
    *(float *)a5.i32 = v33;
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)&__p[8] / v33);
    if ((unint64_t)v9 < 3
      || (uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime < (unint64_t)v9) {
      goto LABEL_17;
    }
  }
LABEL_18:
  if (*(void *)(a2 + 80))
  {
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    do
    {
      __int32 v16 = *(_DWORD *)(*a3 + 4 * v15);
      int32x4_t v30 = *(int32x4_t *)(*(void *)(a2 + 88) + v14);
      sub_24B713F8C((uint64_t)v31, (int32x2_t *)&v30, &v30, *(double *)v30.i64, a5)[2].i32[0] = v16;
      ++v15;
      v14 += 48;
    }
    while (v15 < *(void *)(a2 + 80));
  }
  float32x4_t v17 = *(void **)(a1 + 688);
  uint64_t v18 = v31[0];
  unint64_t v19 = (unint64_t)v31[1];
  *(void **)(a1 + 688) = v31[0];
  unint64_t v20 = *(void *)(a1 + 696);
  *(void *)(a1 + 696) = v19;
  v31[0] = v17;
  v31[1] = (void *)v20;
  id v21 = *(void **)(a1 + 704);
  uint64_t v22 = *(void *)__p;
  *(void *)(a1 + 704) = *(void *)__p;
  *(void *)std::string __p = v21;
  uint64_t v23 = *(void *)&__p[8];
  long long v24 = *(_OWORD *)(a1 + 712);
  *(_OWORD *)(a1 + 712) = *(_OWORD *)&__p[8];
  *(_OWORD *)&__p[8] = v24;
  float v25 = *(float *)(a1 + 728);
  *(float *)(a1 + 728) = v33;
  float v33 = v25;
  if (v23)
  {
    unint64_t v26 = *(void *)(v22 + 8);
    if ((v19 & (v19 - 1)) != 0)
    {
      if (v26 >= v19) {
        v26 %= v19;
      }
    }
    else
    {
      v26 &= v19 - 1;
    }
    v18[v26] = a1 + 704;
    id v21 = *(void **)__p;
  }
  if ((void)v24)
  {
    unint64_t v27 = v21[1];
    if ((v20 & (v20 - 1)) != 0)
    {
      if (v27 >= v20) {
        v27 %= v20;
      }
    }
    else
    {
      v27 &= v20 - 1;
    }
    *((void *)v31[0] + v27) = __p;
    id v21 = *(void **)__p;
  }
  if (v21)
  {
    do
    {
      id v28 = (void *)*v21;
      operator delete(v21);
      id v21 = v28;
    }
    while (v28);
  }
  unint64_t v29 = v31[0];
  v31[0] = 0;
  if (v29) {
    operator delete(v29);
  }
}

void sub_24B713F64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_24B7142C4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_24B713F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_24B7142C4((uint64_t)va);
  _Unwind_Resume(a1);
}

int32x4_t *sub_24B713F8C(uint64_t a1, int32x2_t *a2, int32x4_t *a3, double a4, int8x16_t a5)
{
  a5.i64[0] = 83492791 * a2[1].i32[0];
  int64x2_t v8 = vmull_s32(*a2, (int32x2_t)0x12740A50466F45DLL);
  unint64_t v9 = veorq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), veorq_s8(a5, (int8x16_t)v8)).u64[0] % *(void *)(a1 + 32);
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v5 = v9;
      if (v9 >= v10) {
        unint64_t v5 = v9 % v10;
      }
    }
    else
    {
      unint64_t v5 = (v10 - 1) & v9;
    }
    uint64_t v13 = *(int32x4_t ***)(*(void *)a1 + 8 * v5);
    if (v13)
    {
      uint64_t v14 = *v13;
      if (*v13)
      {
        int32x4_t v15 = *(int32x4_t *)a2->i8;
        if (v12 < 2)
        {
          while (1)
          {
            uint64_t v19 = v14->i64[1];
            if (v19 == v9)
            {
              uint32x4_t v18 = (uint32x4_t)vceqq_s32(v14[1], v15);
              v18.i32[3] = v18.i32[2];
              if ((vminvq_u32(v18) & 0x80000000) != 0) {
                return v14;
              }
            }
            else if ((v19 & (v10 - 1)) != v5)
            {
              goto LABEL_22;
            }
            uint64_t v14 = (int32x4_t *)v14->i64[0];
            if (!v14) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v17 = v14->u64[1];
          if (v17 == v9)
          {
            uint32x4_t v16 = (uint32x4_t)vceqq_s32(v14[1], v15);
            v16.i32[3] = v16.i32[2];
            if ((vminvq_u32(v16) & 0x80000000) != 0) {
              return v14;
            }
          }
          else
          {
            if (v17 >= v10) {
              v17 %= v10;
            }
            if (v17 != v5) {
              break;
            }
          }
          uint64_t v14 = (int32x4_t *)v14->i64[0];
        }
        while (v14);
      }
    }
  }
LABEL_22:
  uint64_t v14 = (int32x4_t *)operator new(0x30uLL);
  v14->i64[0] = 0;
  v14->i64[1] = v9;
  v14[1] = *a3;
  v14[2].i32[0] = 0;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 40);
  if (!v10 || (float)(v21 * (float)v10) < v20)
  {
    BOOL v22 = 1;
    if (v10 >= 3) {
      BOOL v22 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v10);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t prime = v24;
    }
    else {
      size_t prime = v23;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v10 = *(void *)(a1 + 8);
    }
    if (prime > v10) {
      goto LABEL_34;
    }
    if (prime < v10)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 40));
      if (v10 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (prime <= v26) {
        size_t prime = v26;
      }
      if (prime < v10) {
LABEL_34:
      }
        sub_24B6BD1F0(a1, prime);
    }
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v5 = v9 % v10;
      }
      else {
        unint64_t v5 = v9;
      }
    }
    else
    {
      unint64_t v5 = (v10 - 1) & v9;
    }
  }
  uint64_t v29 = *(void *)a1;
  int32x4_t v30 = *(int32x4_t ***)(*(void *)a1 + 8 * v5);
  if (v30)
  {
    v14->i64[0] = (uint64_t)*v30;
LABEL_58:
    char *v30 = v14;
    goto LABEL_59;
  }
  v14->i64[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  *(void *)(v29 + 8 * v5) = a1 + 16;
  if (v14->i64[0])
  {
    unint64_t v31 = *(void *)(v14->i64[0] + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v31 >= v10) {
        v31 %= v10;
      }
    }
    else
    {
      v31 &= v10 - 1;
    }
    int32x4_t v30 = (int32x4_t **)(*(void *)a1 + 8 * v31);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_24B7142B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_24B7142C4(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      long long v3 = (void *)*v2;
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  unsigned int v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

__n128 sub_24B714310(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void sub_24B714334(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_24B71434C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = v2 * a2;
  unint64_t v4 = v2 + v2 * a2;
  if ((uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 3 < v4) {
    unint64_t v4 = (uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 3;
  }
  unint64_t v111 = v4;
  if (v3 < v4)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    while (1)
    {
      uint64_t v7 = *(void *)(a1 + 56);
      unint64_t v112 = v3 + 1;
      if (v3 + 1 >= (*(void *)(a1 + 64) - v7) >> 3) {
        int64x2_t v8 = (uint64_t *)(*(void *)(a1 + 80) + 80);
      }
      else {
        int64x2_t v8 = (uint64_t *)(v7 + 8 * (v3 + 1));
      }
      unint64_t v9 = *(void *)(v7 + 8 * v3);
      uint64_t v10 = *v8;
      unint64_t v113 = *v8 - v9;
      if (*v8 <= v9) {
        goto LABEL_5;
      }
      unint64_t v11 = *(void *)(v7 + 8 * v3);
      unint64_t v114 = v11;
      if (v113 >= 2) {
        break;
      }
      uint64_t v12 = **(void **)(a1 + 88);
      unint64_t v13 = v9;
      do
        *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 48) + 4 * v13++) = *(_DWORD *)(v12 + 4 * v9);
      while (v10 != v13);
LABEL_5:
      unint64_t v3 = v112;
      if (v112 == v111) {
        return;
      }
    }
LABEL_16:
    int32x4_t v15 = *(float32x4_t **)(a1 + 80);
    __int32 v115 = *(uint64_t **)(a1 + 88);
    uint64_t v121 = 0;
    unint64_t v122 = 0;
    uint64_t v120 = (float *)&v121;
    if (v113 <= *(void *)(v6 + 104))
    {
      uint64_t v16 = 0;
      unint64_t v17 = v114;
      do
      {
        uint64_t v18 = v15[5].i64[1];
        uint64_t v19 = (int *)(v18 + 48 * v11);
        float32x4_t v116 = v15[1];
        float32x4_t v117 = v15[2];
        float32x4_t v118 = v15[4];
        float32x4_t v119 = v15[3];
        float v20 = v15->f32[0];
        int v21 = *v19;
        int v22 = v19[1];
        int v23 = v19[2];
        unint64_t v24 = (int *)(v18 + 48 * v17);
        int v26 = *v24;
        int v25 = v24[1];
        int v27 = v24[2];
        uint64_t v28 = (float *)operator new(0x30uLL);
        float32x4_t v29 = vsubq_f32(vaddq_f32(v118, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v116, v20 * (float)((float)v21 + 0.5)), v117, v20 * (float)((float)v22 + 0.5)), v119, v20 * (float)((float)v23 + 0.5))), vaddq_f32(v118, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v116, v20 * (float)((float)v26 + 0.5)), v117, v20 * (float)((float)v25 + 0.5)), v119, v20 * (float)((float)v27 + 0.5))));
        float32x4_t v30 = vmulq_f32(v29, v29);
        float v31 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0]);
        v28[8] = v31;
        *((void *)v28 + 5) = v17;
        uint64_t v32 = v121;
        float v33 = &v121;
        uint64_t v34 = &v121;
        if (v121)
        {
          do
          {
            while (1)
            {
              float v33 = (float **)v32;
              if (v31 <= v32[8]) {
                break;
              }
              uint64_t v32 = *(float **)v32;
              uint64_t v34 = v33;
              if (!*v33) {
                goto LABEL_28;
              }
            }
            uint64_t v32 = (float *)*((void *)v32 + 1);
          }
          while (v32);
          uint64_t v34 = v33 + 1;
        }
LABEL_28:
        *(void *)uint64_t v28 = 0;
        *((void *)v28 + 1) = 0;
        *((void *)v28 + 2) = v33;
        *uint64_t v34 = v28;
        if (*(void *)v120)
        {
          uint64_t v120 = *(float **)v120;
          uint64_t v28 = *v34;
        }
        uint64_t v35 = v121;
        BOOL v87 = v28 == v121;
        *((unsigned char *)v28 + 24) = v28 == v121;
        if (!v87)
        {
          do
          {
            uint64_t v36 = *((void *)v28 + 2);
            if (*(unsigned char *)(v36 + 24)) {
              break;
            }
            uint64_t v37 = *(float **)(v36 + 16);
            uint64_t v38 = *(void *)v37;
            if (*(void *)v37 == v36)
            {
              uint64_t v41 = *((void *)v37 + 1);
              if (!v41 || (v42 = *(unsigned __int8 *)(v41 + 24), uint64_t v39 = (unsigned char *)(v41 + 24), v42))
              {
                if (*(float **)v36 == v28)
                {
                  uint64_t v43 = (uint64_t *)*((void *)v28 + 2);
                }
                else
                {
                  uint64_t v43 = *(uint64_t **)(v36 + 8);
                  uint64_t v44 = *v43;
                  *(void *)(v36 + 8) = *v43;
                  if (v44)
                  {
                    *(void *)(v44 + 16) = v36;
                    uint64_t v37 = *(float **)(v36 + 16);
                  }
                  v43[2] = (uint64_t)v37;
                  *(void *)(*(void *)(v36 + 16) + 8 * (**(void **)(v36 + 16) != v36)) = v43;
                  *uint64_t v43 = v36;
                  *(void *)(v36 + 16) = v43;
                  uint64_t v37 = (float *)v43[2];
                  uint64_t v36 = *(void *)v37;
                }
                *((unsigned char *)v43 + 24) = 1;
                *((unsigned char *)v37 + 24) = 0;
                uint64_t v47 = *(void *)(v36 + 8);
                *(void *)uint64_t v37 = v47;
                if (v47) {
                  *(void *)(v47 + 16) = v37;
                }
                *(void *)(v36 + 16) = *((void *)v37 + 2);
                *(void *)(*((void *)v37 + 2) + 8 * (**((void **)v37 + 2) != (void)v37)) = v36;
                *(void *)(v36 + 8) = v37;
                goto LABEL_19;
              }
            }
            else if (!v38 || (v40 = *(unsigned __int8 *)(v38 + 24), uint64_t v39 = (unsigned char *)(v38 + 24), v40))
            {
              if (*(float **)v36 == v28)
              {
                uint64_t v45 = *((void *)v28 + 1);
                *(void *)uint64_t v36 = v45;
                if (v45)
                {
                  *(void *)(v45 + 16) = v36;
                  uint64_t v37 = *(float **)(v36 + 16);
                }
                *((void *)v28 + 2) = v37;
                *(void *)(*(void *)(v36 + 16) + 8 * (**(void **)(v36 + 16) != v36)) = v28;
                *((void *)v28 + 1) = v36;
                *(void *)(v36 + 16) = v28;
                uint64_t v37 = (float *)*((void *)v28 + 2);
              }
              else
              {
                uint64_t v28 = (float *)*((void *)v28 + 2);
              }
              *((unsigned char *)v28 + 24) = 1;
              *((unsigned char *)v37 + 24) = 0;
              uint64_t v36 = *((void *)v37 + 1);
              long long v46 = *(float **)v36;
              *((void *)v37 + 1) = *(void *)v36;
              if (v46) {
                *((void *)v46 + 2) = v37;
              }
              *(void *)(v36 + 16) = *((void *)v37 + 2);
              *(void *)(*((void *)v37 + 2) + 8 * (**((void **)v37 + 2) != (void)v37)) = v36;
              *(void *)uint64_t v36 = v37;
LABEL_19:
              *((void *)v37 + 2) = v36;
              break;
            }
            *(unsigned char *)(v36 + 24) = 1;
            uint64_t v28 = v37;
            *((unsigned char *)v37 + 24) = v37 == v35;
            *uint64_t v39 = 1;
          }
          while (v37 != v35);
        }
        unint64_t v122 = ++v16;
        ++v17;
      }
      while (v17 != v10);
      goto LABEL_178;
    }
LABEL_59:
    uint64_t v48 = v15[5].i64[1];
    float32x4_t v49 = v15[1];
    float32x4_t v50 = v15[2];
    float32x4_t v51 = vsubq_f32(vaddq_f32(v15[4], vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v49, v15->f32[0] * (float)((float)*(int *)(v48 + 48 * v11) + 0.5)), v50, v15->f32[0] * (float)((float)*(int *)(v48 + 48 * v11 + 4) + 0.5)), v15[3], v15->f32[0] * (float)((float)*(int *)(v48 + 48 * v11 + 8) + 0.5))), vaddq_f32(v15[4], vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v49, v15->f32[0] * (float)((float)*(int *)(v48 + 48 * v9) + 0.5)), v50, v15->f32[0] * (float)((float)*(int *)(v48 + 48 * v9 + 4) + 0.5)), v15[3], v15->f32[0] * (float)((float)*(int *)(v48 + 48 * v9 + 8) + 0.5))));
    float32x4_t v52 = vmulq_f32(v51, v51);
    float v53 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).f32[0]);
    unint64_t v54 = v122;
    if (v122 >= *(void *)(v6 + 104) && v53 >= v120[8]) {
      goto LABEL_58;
    }
    uint64_t v55 = (float *)operator new(0x30uLL);
    v55[8] = v53;
    *((void *)v55 + 5) = v9;
    id v56 = &v121;
    int v57 = &v121;
    uint64_t v58 = v121;
    if (v121)
    {
      do
      {
        while (1)
        {
          id v56 = (float **)v58;
          if (v53 <= v58[8]) {
            break;
          }
          uint64_t v58 = *(float **)v58;
          int v57 = v56;
          if (!*v56) {
            goto LABEL_68;
          }
        }
        uint64_t v58 = (float *)*((void *)v58 + 1);
      }
      while (v58);
      int v57 = v56 + 1;
    }
LABEL_68:
    *(void *)uint64_t v55 = 0;
    *((void *)v55 + 1) = 0;
    *((void *)v55 + 2) = v56;
    void *v57 = v55;
    if (*(void *)v120)
    {
      uint64_t v120 = *(float **)v120;
      uint64_t v55 = *v57;
    }
    uint64_t v59 = v121;
    BOOL v87 = v55 == v121;
    *((unsigned char *)v55 + 24) = v55 == v121;
    if (!v87)
    {
      do
      {
        uint64_t v60 = *((void *)v55 + 2);
        if (*(unsigned char *)(v60 + 24)) {
          break;
        }
        uint64_t v61 = *(float **)(v60 + 16);
        uint64_t v62 = *(void *)v61;
        if (*(void *)v61 == v60)
        {
          uint64_t v65 = *((void *)v61 + 1);
          if (!v65 || (int v66 = *(unsigned __int8 *)(v65 + 24), v63 = (unsigned char *)(v65 + 24), v66))
          {
            if (*(float **)v60 == v55)
            {
              long long v67 = (uint64_t *)*((void *)v55 + 2);
            }
            else
            {
              long long v67 = *(uint64_t **)(v60 + 8);
              uint64_t v68 = *v67;
              *(void *)(v60 + 8) = *v67;
              if (v68)
              {
                *(void *)(v68 + 16) = v60;
                uint64_t v61 = *(float **)(v60 + 16);
              }
              v67[2] = (uint64_t)v61;
              *(void *)(*(void *)(v60 + 16) + 8 * (**(void **)(v60 + 16) != v60)) = v67;
              uint64_t *v67 = v60;
              *(void *)(v60 + 16) = v67;
              uint64_t v61 = (float *)v67[2];
              uint64_t v60 = *(void *)v61;
            }
            *((unsigned char *)v67 + 24) = 1;
            *((unsigned char *)v61 + 24) = 0;
            uint64_t v71 = *(void *)(v60 + 8);
            *(void *)uint64_t v61 = v71;
            if (v71) {
              *(void *)(v71 + 16) = v61;
            }
            *(void *)(v60 + 16) = *((void *)v61 + 2);
            *(void *)(*((void *)v61 + 2) + 8 * (**((void **)v61 + 2) != (void)v61)) = v60;
            *(void *)(v60 + 8) = v61;
            goto LABEL_97;
          }
        }
        else if (!v62 || (int v64 = *(unsigned __int8 *)(v62 + 24), v63 = (unsigned char *)(v62 + 24), v64))
        {
          if (*(float **)v60 == v55)
          {
            uint64_t v69 = *((void *)v55 + 1);
            *(void *)uint64_t v60 = v69;
            if (v69)
            {
              *(void *)(v69 + 16) = v60;
              uint64_t v61 = *(float **)(v60 + 16);
            }
            *((void *)v55 + 2) = v61;
            *(void *)(*(void *)(v60 + 16) + 8 * (**(void **)(v60 + 16) != v60)) = v55;
            *((void *)v55 + 1) = v60;
            *(void *)(v60 + 16) = v55;
            uint64_t v61 = (float *)*((void *)v55 + 2);
          }
          else
          {
            uint64_t v55 = (float *)*((void *)v55 + 2);
          }
          *((unsigned char *)v55 + 24) = 1;
          *((unsigned char *)v61 + 24) = 0;
          uint64_t v60 = *((void *)v61 + 1);
          id v70 = *(float **)v60;
          *((void *)v61 + 1) = *(void *)v60;
          if (v70) {
            *((void *)v70 + 2) = v61;
          }
          *(void *)(v60 + 16) = *((void *)v61 + 2);
          *(void *)(*((void *)v61 + 2) + 8 * (**((void **)v61 + 2) != (void)v61)) = v60;
          *(void *)uint64_t v60 = v61;
LABEL_97:
          *((void *)v61 + 2) = v60;
          break;
        }
        *(unsigned char *)(v60 + 24) = 1;
        uint64_t v55 = v61;
        *((unsigned char *)v61 + 24) = v61 == v59;
        unsigned char *v63 = 1;
      }
      while (v61 != v59);
    }
    unint64_t v122 = v54 + 1;
    if (v54 + 1 <= *(void *)(v6 + 104)) {
      goto LABEL_58;
    }
    uint64_t v72 = v120;
    char v73 = (float *)*((void *)v120 + 1);
    uint64_t v74 = v73;
    uint64_t v75 = v120;
    if (v73)
    {
      do
      {
        uint64_t v76 = v74;
        uint64_t v74 = *(float **)v74;
      }
      while (v74);
    }
    else
    {
      do
      {
        uint64_t v76 = (float *)*((void *)v75 + 2);
        BOOL v87 = *(void *)v76 == (void)v75;
        uint64_t v75 = v76;
      }
      while (!v87);
    }
    uint64_t v120 = v76;
    unint64_t v122 = v54;
    if (*(void *)v72)
    {
      if (v73)
      {
        do
        {
          id v77 = v73;
          char v73 = *(float **)v73;
        }
        while (v73);
        char v73 = (float *)*((void *)v77 + 1);
        if (!v73) {
          goto LABEL_110;
        }
      }
      else
      {
        char v73 = *(float **)v72;
        id v77 = v72;
      }
    }
    else
    {
      id v77 = v72;
      if (!v73)
      {
LABEL_110:
        int v78 = 1;
LABEL_113:
        uint64_t v79 = v121;
        id v80 = (float **)*((void *)v77 + 2);
        float v81 = *v80;
        if (*v80 == v77)
        {
          *id v80 = v73;
          if (v77 == v79)
          {
            float v81 = 0;
            uint64_t v79 = v73;
          }
          else
          {
            float v81 = v80[1];
          }
        }
        else
        {
          v80[1] = v73;
        }
        int v82 = *((unsigned __int8 *)v77 + 24);
        if (v77 != v72)
        {
          uint64_t v83 = *((void *)v72 + 2);
          *((void *)v77 + 2) = v83;
          *(void *)(v83 + 8 * (**((void **)v72 + 2) != (void)v72)) = v77;
          id v84 = *(float **)v72;
          *(void *)id v77 = *(void *)v72;
          *((void *)v84 + 2) = v77;
          uint64_t v85 = *((void *)v72 + 1);
          *((void *)v77 + 1) = v85;
          if (v85) {
            *(void *)(v85 + 16) = v77;
          }
          *((unsigned char *)v77 + 24) = *((unsigned char *)v72 + 24);
          if (v79 == v72) {
            uint64_t v79 = v77;
          }
        }
        if (!v82 || !v79) {
          goto LABEL_57;
        }
        if (!v78)
        {
          *((unsigned char *)v73 + 24) = 1;
          goto LABEL_57;
        }
        while (1)
        {
          uint64_t v88 = (float *)*((void *)v81 + 2);
          if (*(float **)v88 != v81)
          {
            if (*((unsigned char *)v81 + 24))
            {
              uint64_t v89 = *(float **)v81;
              if (!*(void *)v81)
              {
LABEL_145:
                uint64_t v93 = (float *)*((void *)v81 + 1);
                if (v93 && !*((unsigned char *)v93 + 24)) {
                  goto LABEL_169;
                }
                *((unsigned char *)v81 + 24) = 0;
                uint64_t v86 = (float *)*((void *)v81 + 2);
                if (v86 == v79)
                {
                  *((unsigned char *)v79 + 24) = 1;
                  goto LABEL_57;
                }
                if (!*((unsigned char *)v86 + 24)) {
                  goto LABEL_56;
                }
                goto LABEL_131;
              }
            }
            else
            {
              *((unsigned char *)v81 + 24) = 1;
              *((unsigned char *)v88 + 24) = 0;
              id v91 = (float **)*((void *)v88 + 1);
              uint64_t v92 = *v91;
              *((void *)v88 + 1) = *v91;
              if (v92) {
                *((void *)v92 + 2) = v88;
              }
              v91[2] = (float *)*((void *)v88 + 2);
              *(void *)(*((void *)v88 + 2) + 8 * (**((void **)v88 + 2) != (void)v88)) = v91;
              unsigned char *v91 = v88;
              *((void *)v88 + 2) = v91;
              if (v79 == *(float **)v81) {
                uint64_t v79 = v81;
              }
              float v81 = *(float **)(*(void *)v81 + 8);
              uint64_t v89 = *(float **)v81;
              if (!*(void *)v81) {
                goto LABEL_145;
              }
            }
            if (!*((unsigned char *)v89 + 24))
            {
              uint64_t v93 = (float *)*((void *)v81 + 1);
              if (v93 && !*((unsigned char *)v93 + 24))
              {
LABEL_169:
                uint64_t v89 = v81;
              }
              else
              {
                *((unsigned char *)v89 + 24) = 1;
                *((unsigned char *)v81 + 24) = 0;
                uint64_t v97 = *((void *)v89 + 1);
                *(void *)float v81 = v97;
                if (v97) {
                  *(void *)(v97 + 16) = v81;
                }
                *((void *)v89 + 2) = *((void *)v81 + 2);
                *(void *)(*((void *)v81 + 2) + 8 * (**((void **)v81 + 2) != (void)v81)) = v89;
                *((void *)v89 + 1) = v81;
                *((void *)v81 + 2) = v89;
                uint64_t v93 = v81;
              }
              uint64_t v98 = *((void *)v89 + 2);
              *((unsigned char *)v89 + 24) = *(unsigned char *)(v98 + 24);
              *(unsigned char *)(v98 + 24) = 1;
              *((unsigned char *)v93 + 24) = 1;
              float32x2_t v99 = *(uint64_t **)(v98 + 8);
              uint64_t v100 = *v99;
              *(void *)(v98 + 8) = *v99;
              if (v100) {
                *(void *)(v100 + 16) = v98;
              }
              v99[2] = *(void *)(v98 + 16);
              *(void *)(*(void *)(v98 + 16) + 8 * (**(void **)(v98 + 16) != v98)) = v99;
              uint64_t *v99 = v98;
              goto LABEL_177;
            }
            goto LABEL_145;
          }
          if (*((unsigned char *)v81 + 24))
          {
            uint64_t v90 = *(float **)v81;
            if (*(void *)v81) {
              goto LABEL_155;
            }
          }
          else
          {
            *((unsigned char *)v81 + 24) = 1;
            *((unsigned char *)v88 + 24) = 0;
            unint64_t v94 = (void *)*((void *)v81 + 1);
            *(void *)uint64_t v88 = v94;
            if (v94) {
              v94[2] = v88;
            }
            *((void *)v81 + 2) = *((void *)v88 + 2);
            *(void *)(*((void *)v88 + 2) + 8 * (**((void **)v88 + 2) != (void)v88)) = v81;
            *((void *)v81 + 1) = v88;
            *((void *)v88 + 2) = v81;
            if (v79 == v88) {
              uint64_t v79 = v81;
            }
            float v81 = *(float **)v88;
            uint64_t v90 = **(float ***)v88;
            if (v90)
            {
LABEL_155:
              if (!*((unsigned char *)v90 + 24)) {
                goto LABEL_173;
              }
            }
          }
          uint64_t v95 = (uint64_t *)*((void *)v81 + 1);
          if (v95 && !*((unsigned char *)v95 + 24))
          {
            if (v90 && !*((unsigned char *)v90 + 24))
            {
LABEL_173:
              uint64_t v95 = (uint64_t *)v81;
            }
            else
            {
              *((unsigned char *)v95 + 24) = 1;
              *((unsigned char *)v81 + 24) = 0;
              uint64_t v96 = *v95;
              *((void *)v81 + 1) = *v95;
              if (v96) {
                *(void *)(v96 + 16) = v81;
              }
              v95[2] = *((void *)v81 + 2);
              *(void *)(*((void *)v81 + 2) + 8 * (**((void **)v81 + 2) != (void)v81)) = v95;
              uint64_t *v95 = (uint64_t)v81;
              *((void *)v81 + 2) = v95;
              uint64_t v90 = v81;
            }
            uint64_t v98 = v95[2];
            *((unsigned char *)v95 + 24) = *(unsigned char *)(v98 + 24);
            *(unsigned char *)(v98 + 24) = 1;
            *((unsigned char *)v90 + 24) = 1;
            float32x2_t v99 = *(uint64_t **)v98;
            uint64_t v101 = *(void *)(*(void *)v98 + 8);
            *(void *)uint64_t v98 = v101;
            if (v101) {
              *(void *)(v101 + 16) = v98;
            }
            v99[2] = *(void *)(v98 + 16);
            *(void *)(*(void *)(v98 + 16) + 8 * (**(void **)(v98 + 16) != v98)) = v99;
            v99[1] = v98;
LABEL_177:
            *(void *)(v98 + 16) = v99;
LABEL_57:
            operator delete(v72);
LABEL_58:
            if (++v9 != v10) {
              goto LABEL_59;
            }
LABEL_178:
            uint64_t v102 = v120;
            if (v120 == (float *)&v121)
            {
              float v14 = NAN;
            }
            else
            {
              float v103 = (float)(*(float *)(v6 + 112) * v15->f32[0]) * (float)(*(float *)(v6 + 112) * v15->f32[0]);
              uint64_t v104 = *v115;
              float v105 = 0.0;
              float v106 = 0.0;
              do
              {
                float v107 = expf((float)((float)(v102[8] * v102[8]) * -0.5) / v103);
                float32x4_t v108 = (float *)*((void *)v102 + 1);
                uint64_t v109 = v102;
                if (v108)
                {
                  do
                  {
                    id v110 = (float **)v108;
                    float32x4_t v108 = *(float **)v108;
                  }
                  while (v108);
                }
                else
                {
                  do
                  {
                    id v110 = (float **)*((void *)v109 + 2);
                    BOOL v87 = *v110 == v109;
                    uint64_t v109 = (float *)v110;
                  }
                  while (!v87);
                }
                float v105 = v105 + (float)(v107 * *(float *)(v104 + 4 * *((void *)v102 + 5)));
                float v106 = v106 + v107;
                uint64_t v102 = (float *)v110;
              }
              while (v110 != &v121);
              float v14 = v105 / v106;
            }
            unint64_t v9 = v114;
            sub_24B6BD138(v121);
            *(float *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 48) + 4 * v11++) = v14;
            if (v11 == v10) {
              goto LABEL_5;
            }
            goto LABEL_16;
          }
          *((unsigned char *)v81 + 24) = 0;
          uint64_t v86 = (float *)*((void *)v81 + 2);
          if (*((unsigned char *)v86 + 24)) {
            BOOL v87 = v86 == v79;
          }
          else {
            BOOL v87 = 1;
          }
          if (v87)
          {
LABEL_56:
            *((unsigned char *)v86 + 24) = 1;
            goto LABEL_57;
          }
LABEL_131:
          float v81 = *(float **)(*((void *)v86 + 2) + 8 * (**((void **)v86 + 2) == (void)v86));
        }
      }
    }
    int v78 = 0;
    *((void *)v73 + 2) = *((void *)v77 + 2);
    goto LABEL_113;
  }
}

void sub_24B714F20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24)
{
}

void sub_24B714F38(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
}

void *sub_24B714F50(void *result, uint64_t a2)
{
  result[7] = 0;
  result[8] = 0;
  result[9] = 0;
  unint64_t v3 = *(unsigned char **)(a2 + 56);
  uint64_t v2 = *(unsigned char **)(a2 + 64);
  int64_t v4 = v2 - v3;
  if (v2 != v3)
  {
    if (v4 < 0) {
      abort();
    }
    unint64_t v5 = result;
    uint64_t v6 = (char *)operator new(v2 - v3);
    v5[7] = v6;
    v5[8] = v6;
    uint64_t v7 = &v6[8 * (v4 >> 3)];
    v5[9] = v7;
    __n128 result = memcpy(v6, v3, v4);
    v5[8] = v7;
  }
  return result;
}

void sub_24B714FBC(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, int8x16_t a10)
{
  unint64_t v12 = 500 * a2;
  unint64_t v13 = 500 * a2 + 500;
  uint64_t v14 = *(void *)(a1 + 40);
  if (*(void *)(v14 + 80) < v13) {
    unint64_t v13 = *(void *)(v14 + 80);
  }
  if (v12 < v13)
  {
    int32x4_t v15 = *(void **)(a1 + 32);
    unint64_t v16 = v15[87];
    uint64_t v17 = **(void **)(a1 + 48);
    if (v16)
    {
      uint64_t v18 = *(void *)(v14 + 88);
      unint64_t v19 = v15[90];
      uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
      v20.i16[0] = vaddlv_u8(v20);
      unint64_t v21 = v16 - 1;
      do
      {
        int32x4_t v23 = *(int32x4_t *)(v18 + 48 * v12);
        v24.i64[1] = v23.i32[3];
        v24.i64[0] = 83492791 * (int)*(void *)(v18 + 48 * v12 + 8);
        int64x2_t v25 = vmull_s32(*(int32x2_t *)v23.i8, (int32x2_t)0x12740A50466F45DLL);
        unint64_t v26 = veorq_s8((int8x16_t)vdupq_laneq_s64(v25, 1), veorq_s8(v24, (int8x16_t)v25)).u64[0];
        unint64_t v27 = v26 % v19;
        if (v20.u32[0] > 1uLL)
        {
          unint64_t v28 = v26 % v19;
          if (v27 >= v16) {
            unint64_t v28 = v27 % v16;
          }
        }
        else
        {
          unint64_t v28 = v21 & v27;
        }
        uint64_t v29 = v15[86];
        float32x4_t v30 = *(uint64_t ***)(v29 + 8 * v28);
        if (v30)
        {
          float v31 = *v30;
          if (v31)
          {
            if (v20.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v33 = v31[1];
                if (v27 == v33)
                {
                  uint32x4_t v32 = (uint32x4_t)vceqq_s32(*((int32x4_t *)v31 + 1), v23);
                  v32.i32[3] = v32.i32[2];
                  if ((vminvq_u32(v32) & 0x80000000) != 0) {
                    goto LABEL_6;
                  }
                }
                else if ((v33 & v21) != v28)
                {
                  goto LABEL_27;
                }
                float v31 = (uint64_t *)*v31;
                if (!v31) {
                  goto LABEL_27;
                }
              }
            }
            do
            {
              unint64_t v35 = v31[1];
              if (v27 == v35)
              {
                uint32x4_t v34 = (uint32x4_t)vceqq_s32(*((int32x4_t *)v31 + 1), v23);
                v34.i32[3] = v34.i32[2];
                if ((vminvq_u32(v34) & 0x80000000) != 0)
                {
LABEL_6:
                  float v22 = *((float *)v31 + 8);
                  goto LABEL_7;
                }
              }
              else
              {
                if (v35 >= v16) {
                  v35 %= v16;
                }
                if (v35 != v28) {
                  break;
                }
              }
              float v31 = (uint64_t *)*v31;
            }
            while (v31);
          }
        }
LABEL_27:
        uint64_t v36 = v23.i32[0] - 1;
        uint64_t v37 = v23.i32[0];
        if (v20.u32[0] >= 2uLL)
        {
          int v38 = 0;
          float v39 = 0.0;
          do
          {
            v25.i32[0] = v36;
            uint64_t v51 = v23.i32[1] - 1;
            do
            {
              int8x16_t v52 = (int8x16_t)v25;
              v52.i32[1] = v51;
              v53.i64[0] = v36;
              v53.i64[1] = v51;
              unint64_t v54 = vextq_s8(v53, v53, 8uLL).u64[0];
              uint64_t v55 = v23.i32[2] - 1;
              do
              {
                a10.i64[0] = 73856093 * v36;
                v11.i64[0] = 83492791 * v55;
                a10 = veorq_s8((int8x16_t)vdupq_n_s64(19349669 * v54), veorq_s8(v11, a10));
                unint64_t v56 = a10.i64[0] % v19;
                unint64_t v57 = a10.i64[0] % v19;
                if (a10.i64[0] % v19 >= v16) {
                  unint64_t v57 = v56 % v16;
                }
                uint64_t v58 = *(int32x4_t ***)(v29 + 8 * v57);
                if (v58)
                {
                  uint64_t v59 = *v58;
                  if (v59)
                  {
                    a10 = v52;
                    a10.i32[2] = v55;
                    do
                    {
                      unint64_t v60 = v59->u64[1];
                      if (v56 == v60)
                      {
                        int8x16_t v11 = (int8x16_t)vceqq_s32(v59[1], (int32x4_t)a10);
                        v11.i32[3] = v11.i32[2];
                        if ((vminvq_u32((uint32x4_t)v11) & 0x80000000) != 0)
                        {
                          ++v38;
                          float v39 = v39 + *(float *)v59[2].i32;
                          break;
                        }
                      }
                      else
                      {
                        if (v60 >= v16) {
                          v60 %= v16;
                        }
                        if (v60 != v57) {
                          break;
                        }
                      }
                      uint64_t v59 = (int32x4_t *)v59->i64[0];
                    }
                    while (v59);
                  }
                }
                BOOL v40 = v55++ <= v23.i32[2];
              }
              while (v40);
              BOOL v40 = v51++ <= v23.i32[1];
            }
            while (v40);
            BOOL v40 = v36++ <= v37;
          }
          while (v40);
        }
        else
        {
          int v38 = 0;
          float v39 = 0.0;
          do
          {
            v25.i32[0] = v36;
            uint64_t v41 = v23.i32[1] - 1;
            do
            {
              int8x16_t v42 = (int8x16_t)v25;
              v42.i32[1] = v41;
              v43.i64[0] = v36;
              v43.i64[1] = v41;
              unint64_t v44 = vextq_s8(v43, v43, 8uLL).u64[0];
              uint64_t v45 = v23.i32[2] - 1;
              do
              {
                a10.i64[0] = 73856093 * v36;
                v11.i64[0] = 83492791 * v45;
                a10 = veorq_s8((int8x16_t)vdupq_n_s64(19349669 * v44), veorq_s8(v11, a10));
                unint64_t v46 = a10.i64[0] % v19;
                unint64_t v47 = (a10.i64[0] % v19) & v21;
                uint64_t v48 = *(int32x4_t ***)(v29 + 8 * v47);
                if (v48)
                {
                  float32x4_t v49 = *v48;
                  if (v49)
                  {
                    a10 = v42;
                    a10.i32[2] = v45;
                    do
                    {
                      uint64_t v50 = v49->i64[1];
                      if (v46 == v50)
                      {
                        int8x16_t v11 = (int8x16_t)vceqq_s32(v49[1], (int32x4_t)a10);
                        v11.i32[3] = v11.i32[2];
                        if ((vminvq_u32((uint32x4_t)v11) & 0x80000000) != 0)
                        {
                          ++v38;
                          float v39 = v39 + *(float *)v49[2].i32;
                          break;
                        }
                      }
                      else if ((v50 & v21) != v47)
                      {
                        break;
                      }
                      float32x4_t v49 = (int32x4_t *)v49->i64[0];
                    }
                    while (v49);
                  }
                }
                BOOL v40 = v45++ <= v23.i32[2];
              }
              while (v40);
              BOOL v40 = v41++ <= v23.i32[1];
            }
            while (v40);
            BOOL v40 = v36++ <= v37;
          }
          while (v40);
        }
        float v22 = -1.0;
        if (v38 > 1) {
          float v22 = v39 / (float)v38;
        }
LABEL_7:
        *(float *)(v17 + 4 * v12++) = v22;
      }
      while (v12 != v13);
    }
    else
    {
      memset_pattern16((void *)(v17 + 2000 * a2), &unk_24B72A850, 4 * v13 - 2000 * a2);
    }
  }
}

void sub_24B715424(uint64_t a1, uint64_t a2)
{
  int64_t v4 = *(float32x4_t **)(a1 + 128);
  unint64_t v5 = *(float32x4_t **)(a1 + 136);
  if (v4 == v5)
  {
    float v9 = -1.0;
  }
  else
  {
    float32x4_t v6 = *(float32x4_t *)(a2 + 112);
    float32x4_t v7 = vsubq_f32(v6, v4[7]);
    float32x4_t v8 = vmulq_f32(v7, v7);
    float v9 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0]);
    do
    {
      float32x4_t v10 = vsubq_f32(v6, v4[7]);
      float32x4_t v11 = vmulq_f32(v10, v10);
      float v12 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
      if (v12 < v9) {
        float v9 = v12;
      }
      v4 += 12;
    }
    while (v4 != v5);
  }
  uint64_t v14 = *(float **)(a1 + 160);
  unint64_t v13 = *(void *)(a1 + 168);
  if ((unint64_t)v14 >= v13)
  {
    unint64_t v16 = *(float **)(a1 + 152);
    uint64_t v17 = v14 - v16;
    unint64_t v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) >> 62) {
      goto LABEL_88;
    }
    uint64_t v19 = v13 - (void)v16;
    if (v19 >> 1 > v18) {
      unint64_t v18 = v19 >> 1;
    }
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v18;
    }
    if (v20)
    {
      if (v20 >> 62) {
        goto LABEL_89;
      }
      unint64_t v21 = operator new(4 * v20);
    }
    else
    {
      unint64_t v21 = 0;
    }
    float v22 = (float *)&v21[4 * v17];
    int32x4_t v23 = &v21[4 * v20];
    float *v22 = v9;
    int32x4_t v15 = v22 + 1;
    if (v14 != v16)
    {
      unint64_t v24 = (char *)v14 - (char *)v16 - 4;
      if (v24 < 0x2C) {
        goto LABEL_92;
      }
      if ((unint64_t)((char *)v16 - v21) < 0x20) {
        goto LABEL_92;
      }
      uint64_t v25 = (v24 >> 2) + 1;
      unint64_t v26 = &v21[4 * v17 - 16];
      unint64_t v27 = v14 - 4;
      uint64_t v28 = v25 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        _OWORD *v26 = v29;
        v26 -= 2;
        v27 -= 8;
        v28 -= 8;
      }
      while (v28);
      v22 -= v25 & 0x7FFFFFFFFFFFFFF8;
      v14 -= v25 & 0x7FFFFFFFFFFFFFF8;
      if (v25 != (v25 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_92:
        do
        {
          int v30 = *((_DWORD *)v14-- - 1);
          *((_DWORD *)v22-- - 1) = v30;
        }
        while (v14 != v16);
      }
    }
    *(void *)(a1 + 152) = v22;
    *(void *)(a1 + 160) = v15;
    *(void *)(a1 + 168) = v23;
    if (v16)
    {
      operator delete(v16);
      unint64_t v5 = *(float32x4_t **)(a1 + 136);
    }
  }
  else
  {
    *uint64_t v14 = v9;
    int32x4_t v15 = v14 + 1;
  }
  *(void *)(a1 + 160) = v15;
  unint64_t v31 = *(void *)(a1 + 144);
  if ((unint64_t)v5 >= v31)
  {
    int8x16_t v42 = *(float32x4_t **)(a1 + 128);
    unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v42) >> 6) + 1;
    if (v43 > 0x155555555555555) {
      goto LABEL_88;
    }
    unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v31 - (void)v42) >> 6);
    if (2 * v44 > v43) {
      unint64_t v43 = 2 * v44;
    }
    if (v44 >= 0xAAAAAAAAAAAAAALL) {
      unint64_t v45 = 0x155555555555555;
    }
    else {
      unint64_t v45 = v43;
    }
    if (v45)
    {
      if (v45 > 0x155555555555555) {
        goto LABEL_89;
      }
      unint64_t v46 = (char *)operator new(192 * v45);
    }
    else
    {
      unint64_t v46 = 0;
    }
    long long v47 = *(_OWORD *)(a2 + 144);
    uint64_t v48 = &v46[64 * (((char *)v5 - (char *)v42) >> 6)];
    *((_OWORD *)v48 + 8) = *(_OWORD *)(a2 + 128);
    *((_OWORD *)v48 + 9) = v47;
    long long v49 = *(_OWORD *)(a2 + 176);
    *((_OWORD *)v48 + 10) = *(_OWORD *)(a2 + 160);
    *((_OWORD *)v48 + 11) = v49;
    long long v50 = *(_OWORD *)(a2 + 80);
    *((_OWORD *)v48 + 4) = *(_OWORD *)(a2 + 64);
    *((_OWORD *)v48 + 5) = v50;
    long long v51 = *(_OWORD *)(a2 + 112);
    *((_OWORD *)v48 + 6) = *(_OWORD *)(a2 + 96);
    *((_OWORD *)v48 + 7) = v51;
    long long v52 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)uint64_t v48 = *(_OWORD *)a2;
    *((_OWORD *)v48 + 1) = v52;
    long long v53 = *(_OWORD *)(a2 + 48);
    f32 = v48 + 192;
    *((_OWORD *)v48 + 2) = *(_OWORD *)(a2 + 32);
    *((_OWORD *)v48 + 3) = v53;
    if (v5 != v42)
    {
      do
      {
        float32x4_t v54 = v5[-12];
        float32x4_t v55 = v5[-11];
        float32x4_t v56 = v5[-9];
        *((float32x4_t *)v48 - 10) = v5[-10];
        *((float32x4_t *)v48 - 9) = v56;
        *((float32x4_t *)v48 - 12) = v54;
        *((float32x4_t *)v48 - 11) = v55;
        float32x4_t v57 = v5[-8];
        float32x4_t v58 = v5[-7];
        float32x4_t v59 = v5[-5];
        *((float32x4_t *)v48 - 6) = v5[-6];
        *((float32x4_t *)v48 - 5) = v59;
        *((float32x4_t *)v48 - 8) = v57;
        *((float32x4_t *)v48 - 7) = v58;
        float32x4_t v60 = v5[-4];
        float32x4_t v61 = v5[-3];
        float32x4_t v62 = v5[-1];
        *((float32x4_t *)v48 - 2) = v5[-2];
        *((float32x4_t *)v48 - 1) = v62;
        *((float32x4_t *)v48 - 4) = v60;
        *((float32x4_t *)v48 - 3) = v61;
        v48 -= 192;
        v5 -= 12;
      }
      while (v5 != v42);
      unint64_t v5 = *(float32x4_t **)(a1 + 128);
    }
    *(void *)(a1 + 128) = v48;
    *(void *)(a1 + 136) = f32;
    *(void *)(a1 + 144) = &v46[192 * v45];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    float32x4_t v32 = *(float32x4_t *)a2;
    float32x4_t v33 = *(float32x4_t *)(a2 + 16);
    float32x4_t v34 = *(float32x4_t *)(a2 + 48);
    v5[2] = *(float32x4_t *)(a2 + 32);
    v5[3] = v34;
    float32x4_t *v5 = v32;
    v5[1] = v33;
    float32x4_t v35 = *(float32x4_t *)(a2 + 64);
    float32x4_t v36 = *(float32x4_t *)(a2 + 80);
    float32x4_t v37 = *(float32x4_t *)(a2 + 112);
    v5[6] = *(float32x4_t *)(a2 + 96);
    v5[7] = v37;
    v5[4] = v35;
    v5[5] = v36;
    float32x4_t v38 = *(float32x4_t *)(a2 + 128);
    float32x4_t v39 = *(float32x4_t *)(a2 + 144);
    float32x4_t v40 = *(float32x4_t *)(a2 + 176);
    v5[10] = *(float32x4_t *)(a2 + 160);
    v5[11] = v40;
    v5[8] = v38;
    v5[9] = v39;
    f32 = (_OWORD *)v5[12].f32;
  }
  *(void *)(a1 + 136) = f32;
  if (*(unsigned char *)(a1 + 121) && !*(_DWORD *)a1)
  {
    long long v64 = *(_OWORD *)(a2 + 128);
    long long v63 = *(_OWORD *)(a2 + 144);
    long long v66 = *(_OWORD *)(a2 + 160);
    long long v65 = *(_OWORD *)(a2 + 176);
    long long v67 = *(char **)(a1 + 752);
    unint64_t v68 = *(void *)(a1 + 760);
    if ((unint64_t)v67 >= v68)
    {
      id v70 = *(char **)(a1 + 744);
      uint64_t v71 = (v67 - v70) >> 6;
      unint64_t v72 = v71 + 1;
      if ((unint64_t)(v71 + 1) >> 58) {
        goto LABEL_88;
      }
      uint64_t v73 = v68 - (void)v70;
      if (v73 >> 5 > v72) {
        unint64_t v72 = v73 >> 5;
      }
      if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFC0) {
        unint64_t v74 = 0x3FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v74 = v72;
      }
      if (v74)
      {
        long long v100 = *(_OWORD *)(a2 + 128);
        long long v101 = *(_OWORD *)(a2 + 144);
        long long v102 = *(_OWORD *)(a2 + 160);
        long long v103 = *(_OWORD *)(a2 + 176);
        if (v74 >> 58) {
          goto LABEL_89;
        }
        uint64_t v75 = (char *)operator new(v74 << 6);
        long long v66 = v102;
        long long v65 = v103;
        long long v64 = v100;
        long long v63 = v101;
      }
      else
      {
        uint64_t v75 = 0;
      }
      uint64_t v76 = &v75[64 * v71];
      *(_OWORD *)uint64_t v76 = v64;
      *((_OWORD *)v76 + 1) = v63;
      *((_OWORD *)v76 + 2) = v66;
      *((_OWORD *)v76 + 3) = v65;
      uint64_t v69 = v76 + 64;
      if (v67 != v70)
      {
        do
        {
          long long v77 = *((_OWORD *)v67 - 4);
          long long v78 = *((_OWORD *)v67 - 3);
          long long v79 = *((_OWORD *)v67 - 1);
          *((_OWORD *)v76 - 2) = *((_OWORD *)v67 - 2);
          *((_OWORD *)v76 - 1) = v79;
          *((_OWORD *)v76 - 4) = v77;
          *((_OWORD *)v76 - 3) = v78;
          v76 -= 64;
          v67 -= 64;
        }
        while (v67 != v70);
        long long v67 = *(char **)(a1 + 744);
      }
      *(void *)(a1 + 744) = v76;
      *(void *)(a1 + 752) = v69;
      *(void *)(a1 + 760) = &v75[64 * v74];
      if (v67) {
        operator delete(v67);
      }
    }
    else
    {
      *(_OWORD *)long long v67 = v64;
      *((_OWORD *)v67 + 1) = v63;
      uint64_t v69 = v67 + 64;
      *((_OWORD *)v67 + 2) = v66;
      *((_OWORD *)v67 + 3) = v65;
    }
    *(void *)(a1 + 752) = v69;
    float v80 = atan2f((float)*(unsigned int *)(a2 + 4), *(float *)(a2 + 36) + *(float *)(a2 + 36));
    float v81 = v80 + v80;
    int v82 = *(float **)(a1 + 776);
    unint64_t v83 = *(void *)(a1 + 784);
    if ((unint64_t)v82 < v83)
    {
      *int v82 = v81;
      id v84 = v82 + 1;
LABEL_86:
      *(void *)(a1 + 776) = v84;
      return;
    }
    uint64_t v85 = *(float **)(a1 + 768);
    uint64_t v86 = v82 - v85;
    unint64_t v87 = v86 + 1;
    if (!((unint64_t)(v86 + 1) >> 62))
    {
      uint64_t v88 = v83 - (void)v85;
      if (v88 >> 1 > v87) {
        unint64_t v87 = v88 >> 1;
      }
      if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v89 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v89 = v87;
      }
      if (!v89)
      {
        uint64_t v90 = 0;
LABEL_77:
        id v91 = (float *)&v90[4 * v86];
        uint64_t v92 = &v90[4 * v89];
        float *v91 = v81;
        id v84 = v91 + 1;
        if (v82 != v85)
        {
          unint64_t v93 = (char *)v82 - (char *)v85 - 4;
          if (v93 < 0x2C) {
            goto LABEL_93;
          }
          if ((unint64_t)((char *)v85 - v90) < 0x20) {
            goto LABEL_93;
          }
          uint64_t v94 = (v93 >> 2) + 1;
          uint64_t v95 = &v90[4 * v86 - 16];
          uint64_t v96 = v82 - 4;
          uint64_t v97 = v94 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v98 = *(_OWORD *)v96;
            *(v95 - 1) = *((_OWORD *)v96 - 1);
            _OWORD *v95 = v98;
            v95 -= 2;
            v96 -= 8;
            v97 -= 8;
          }
          while (v97);
          v91 -= v94 & 0x7FFFFFFFFFFFFFF8;
          v82 -= v94 & 0x7FFFFFFFFFFFFFF8;
          if (v94 != (v94 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_93:
            do
            {
              int v99 = *((_DWORD *)v82-- - 1);
              *((_DWORD *)v91-- - 1) = v99;
            }
            while (v82 != v85);
          }
        }
        *(void *)(a1 + 768) = v91;
        *(void *)(a1 + 776) = v84;
        *(void *)(a1 + 784) = v92;
        if (v85) {
          operator delete(v85);
        }
        goto LABEL_86;
      }
      if (!(v89 >> 62))
      {
        uint64_t v90 = operator new(4 * v89);
        goto LABEL_77;
      }
LABEL_89:
      sub_24B6BCD7C();
    }
LABEL_88:
    abort();
  }
}

void sub_24B715990(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 88) && *(unsigned char *)(a1 + 306))
  {
    uint64_t v2 = *(void *)(a1 + 472);
    sub_24B715424(v2, a2);
  }
  else
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    unint64_t v3 = (id)qword_2697D12C8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "virtual void oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::addCameraShot(const framing_guide::CoverageCamera &)");
      int64_t v4 = v6 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      float32x4_t v8 = v4;
      __int16 v9 = 1026;
      int v10 = 333;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to add camera shot - Coverage is not enabled.", buf, 0x12u);
      if (v6 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

uint64_t sub_24B715AF4()
{
  qword_2697D12C8 = (uint64_t)os_log_create("com.apple.CoreOCModules", "VoxelHashing");
  return MEMORY[0x270F9A758]();
}

uint64_t sub_24B715B38(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 88) && *(unsigned char *)(a1 + 306)) {
    return *(unsigned int *)(a1 + 444);
  }
  if (qword_2697D12D0 != -1) {
    dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
  }
  uint64_t v2 = (id)qword_2697D12C8;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "virtual uint32_t oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::cameraShotHeight()");
    if (v5 >= 0) {
      unint64_t v3 = __p;
    }
    else {
      unint64_t v3 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float32x4_t v7 = v3;
    __int16 v8 = 1026;
    int v9 = 323;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get camera shot width - coverage is not enabled.", buf, 0x12u);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }

  return 0;
}

uint64_t sub_24B715C6C(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 88) && *(unsigned char *)(a1 + 306)) {
    return *(unsigned int *)(a1 + 440);
  }
  if (qword_2697D12D0 != -1) {
    dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
  }
  uint64_t v2 = (id)qword_2697D12C8;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "virtual uint32_t oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::cameraShotWidth()");
    if (v5 >= 0) {
      unint64_t v3 = __p;
    }
    else {
      unint64_t v3 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float32x4_t v7 = v3;
    __int16 v8 = 1026;
    int v9 = 313;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get camera shot width - coverage is not enabled.", buf, 0x12u);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }

  return 0;
}

double sub_24B715DA0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 88))
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    unint64_t v20 = (id)qword_2697D12C8;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    sub_24B6F6D14(__p, "virtual VoxelHashingPipelineResults oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::results()");
    unint64_t v31 = v39 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint64_t v41 = v31;
    __int16 v42 = 1026;
    int v43 = 343;
    _os_log_error_impl(&dword_24B6B9000, v20, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get voxelhashing results - pipeline not initialized.", buf, 0x12u);
    if ((v39 & 0x80000000) == 0) {
      goto LABEL_24;
    }
LABEL_39:
    operator delete(__p[0]);
LABEL_24:

    *(_DWORD *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 64) = 0;
    double result = 0.0;
    *(_OWORD *)(a2 + 24) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_DWORD *)(a2 + 56) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 88) = 0u;
    *(_OWORD *)(a2 + 104) = 0u;
    *(_OWORD *)(a2 + 120) = 0u;
    *(void *)(a2 + 136) = 0;
    return result;
  }
  sub_24B7220DC(*(void *)(a1 + 8));
  uint64_t v4 = sub_24B721E6C(*(void *)(a1 + 8));
  int v9 = *(_DWORD *)objc_msgSend_contents(*(void **)v4, v5, v6);
  if (!v9)
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    unint64_t v20 = (id)qword_2697D12C8;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    sub_24B6F6D14(__p, "virtual VoxelHashingPipelineResults oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::results()");
    float32x4_t v32 = v39 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint64_t v41 = v32;
    __int16 v42 = 1026;
    int v43 = 354;
    _os_log_error_impl(&dword_24B6B9000, v20, OS_LOG_TYPE_ERROR, "%s:%{public}d Vertex buffer is empty.", buf, 0x12u);
    if ((v39 & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_39;
  }
  uint64_t v12 = objc_msgSend_contents(*(void **)(v4 + 8), v7, v8);
  if (!*(unsigned char *)(a1 + 208))
  {
    uint64_t v17 = 0;
    int v16 = 0;
    int v18 = *(_DWORD *)(v4 + 32);
    if (v18) {
      goto LABEL_6;
    }
LABEL_16:
    uint64_t v19 = 0;
    goto LABEL_17;
  }
  int v16 = *(_DWORD *)objc_msgSend_contents(*(void **)(v4 + 16), v10, v11);
  if (!v16)
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    unint64_t v20 = (id)qword_2697D12C8;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    sub_24B6F6D14(__p, "virtual VoxelHashingPipelineResults oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::results()");
    float32x4_t v33 = v39 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint64_t v41 = v33;
    __int16 v42 = 1026;
    int v43 = 366;
    _os_log_error_impl(&dword_24B6B9000, v20, OS_LOG_TYPE_ERROR, "%s:%{public}d Index buffer is empty.", buf, 0x12u);
    if ((v39 & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_39;
  }
  uint64_t v17 = objc_msgSend_contents(*(void **)(v4 + 24), v14, v15);
  int v18 = *(_DWORD *)(v4 + 32);
  if (!v18) {
    goto LABEL_16;
  }
LABEL_6:
  uint64_t v19 = objc_msgSend_contents(*(void **)(v4 + 40), v10, v11);
LABEL_17:
  unint64_t v21 = *(_OWORD **)(a1 + 8);
  long long v22 = v21[20];
  long long v23 = v21[21];
  long long v24 = v21[22];
  long long v25 = v21[23];
  *(_DWORD *)a2 = v9;
  *(void *)(a2 + 8) = v12;
  *(_DWORD *)(a2 + 16) = v16;
  *(void *)(a2 + 24) = v17;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  unint64_t v27 = *(unsigned char **)(v4 + 48);
  unint64_t v26 = *(unsigned char **)(v4 + 56);
  int64_t v28 = v26 - v27;
  if (v26 != v27)
  {
    long long v34 = v25;
    long long v35 = v24;
    long long v36 = v23;
    long long v37 = v22;
    if (v28 < 0) {
      abort();
    }
    long long v29 = (char *)operator new(v26 - v27);
    *(void *)(a2 + 32) = v29;
    int v30 = &v29[4 * (v28 >> 2)];
    *(void *)(a2 + 48) = v30;
    memcpy(v29, v27, v28);
    *(void *)(a2 + 40) = v30;
    long long v23 = v36;
    long long v22 = v37;
    long long v25 = v34;
    long long v24 = v35;
  }
  LODWORD(result) = *(_DWORD *)(v4 + 96);
  *(_DWORD *)(a2 + 56) = LODWORD(result);
  *(_DWORD *)(a2 + 64) = v18;
  *(void *)(a2 + 72) = v19;
  *(_OWORD *)(a2 + 80) = v22;
  *(_OWORD *)(a2 + 96) = v23;
  *(_OWORD *)(a2 + 112) = v24;
  *(_OWORD *)(a2 + 128) = v25;
  return result;
}

CVPixelBufferRef sub_24B7161B4(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  CVPixelBufferRef pixelBufferOut = 0;
  if (!*(unsigned char *)(a1 + 88))
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    unint64_t v3 = (id)qword_2697D12C8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "virtual CVPixelBufferRef oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::normalImage()");
      unint64_t v21 = v25 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      int v30 = v21;
      __int16 v31 = 1026;
      int v32 = 291;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get normal image - pipeline not initialized.", buf, 0x12u);
      if (SHIBYTE(v25) < 0) {
        operator delete(__p[0]);
      }
    }

    return 0;
  }
  if (CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x263EFFB08], *(CVPixelBufferPoolRef *)(a1 + 80), &pixelBufferOut))
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    uint64_t v2 = (id)qword_2697D12C8;
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
    sub_24B6F6D14(__p, "virtual CVPixelBufferRef oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::normalImage()");
    unint64_t v20 = v25 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    int v30 = v20;
    __int16 v31 = 1026;
    int v32 = 298;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get normal image - failed to create pixel buffer from pool.", buf, 0x12u);
    if ((SHIBYTE(v25) & 0x80000000) == 0) {
      goto LABEL_30;
    }
  }
  else
  {
    uint64_t v4 = *(void **)(a1 + 112);
    if (v4)
    {
      char v5 = pixelBufferOut;
      if (pixelBufferOut)
      {
        if (CVPixelBufferGetBytesPerRow(pixelBufferOut) >= 16 * v4[2])
        {
          CVPixelBufferLockBaseAddress(v5, 0);
          BaseAddress = CVPixelBufferGetBaseAddress(v5);
          float32x4_t v7 = (*(void (**)(void *))(*v4 + 48))(v4);
          uint64_t v10 = v7;
          if (v7)
          {
            uint64_t v11 = objc_msgSend_width(v7, v8, v9);
            uint64_t v14 = objc_msgSend_width(v10, v12, v13);
            uint64_t v17 = objc_msgSend_height(v10, v15, v16);
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v25 = 0;
            uint64_t v26 = v14;
            uint64_t v27 = v17;
            uint64_t v28 = 1;
            objc_msgSend_getBytes_bytesPerRow_fromRegion_mipmapLevel_(v10, v18, (uint64_t)BaseAddress, 16 * v11, __p, 0);
            CVPixelBufferUnlockBaseAddress(v5, 0);

            return pixelBufferOut;
          }
          CVPixelBufferUnlockBaseAddress(v5, 0);
          CVPixelBufferRelease(v5);
        }
      }
    }
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    uint64_t v2 = (id)qword_2697D12C8;
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
    sub_24B6F6D14(__p, "virtual CVPixelBufferRef oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::normalImage()");
    long long v22 = v25 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    int v30 = v22;
    __int16 v31 = 1026;
    int v32 = 304;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get normal image - failed to copy normal image to pixel buffer.", buf, 0x12u);
    if ((SHIBYTE(v25) & 0x80000000) == 0) {
      goto LABEL_30;
    }
  }
  operator delete(__p[0]);
LABEL_30:

  return 0;
}

void sub_24B71657C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CVPixelBufferRef sub_24B716594(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  CVPixelBufferRef pixelBufferOut = 0;
  if (!*(unsigned char *)(a1 + 88))
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    unint64_t v3 = (id)qword_2697D12C8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "virtual CVPixelBufferRef oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::depthImage()");
      unint64_t v21 = v25 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      int v30 = v21;
      __int16 v31 = 1026;
      int v32 = 267;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get depth image - pipeline not initialized.", buf, 0x12u);
      if (SHIBYTE(v25) < 0) {
        operator delete(__p[0]);
      }
    }

    return 0;
  }
  if (CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x263EFFB08], *(CVPixelBufferPoolRef *)(a1 + 72), &pixelBufferOut))
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    uint64_t v2 = (id)qword_2697D12C8;
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
    sub_24B6F6D14(__p, "virtual CVPixelBufferRef oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::depthImage()");
    unint64_t v20 = v25 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    int v30 = v20;
    __int16 v31 = 1026;
    int v32 = 274;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get depth image - failed to create pixel buffer from pool.", buf, 0x12u);
    if ((SHIBYTE(v25) & 0x80000000) == 0) {
      goto LABEL_30;
    }
  }
  else
  {
    uint64_t v4 = *(void **)(a1 + 112);
    if (v4)
    {
      char v5 = pixelBufferOut;
      if (pixelBufferOut)
      {
        if (CVPixelBufferGetBytesPerRow(pixelBufferOut) >= 4 * v4[2])
        {
          CVPixelBufferLockBaseAddress(v5, 0);
          BaseAddress = CVPixelBufferGetBaseAddress(v5);
          float32x4_t v7 = (*(void (**)(void *))(*v4 + 32))(v4);
          uint64_t v10 = v7;
          if (v7)
          {
            uint64_t v11 = objc_msgSend_width(v7, v8, v9);
            uint64_t v14 = objc_msgSend_width(v10, v12, v13);
            uint64_t v17 = objc_msgSend_height(v10, v15, v16);
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v25 = 0;
            uint64_t v26 = v14;
            uint64_t v27 = v17;
            uint64_t v28 = 1;
            objc_msgSend_getBytes_bytesPerRow_fromRegion_mipmapLevel_(v10, v18, (uint64_t)BaseAddress, 4 * v11, __p, 0);
            CVPixelBufferUnlockBaseAddress(v5, 0);

            return pixelBufferOut;
          }
          CVPixelBufferUnlockBaseAddress(v5, 0);
          CVPixelBufferRelease(v5);
        }
      }
    }
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    uint64_t v2 = (id)qword_2697D12C8;
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
    sub_24B6F6D14(__p, "virtual CVPixelBufferRef oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::depthImage()");
    long long v22 = v25 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    int v30 = v22;
    __int16 v31 = 1026;
    int v32 = 280;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get depth image - failed to copy depth image to pixel buffer.", buf, 0x12u);
    if ((SHIBYTE(v25) & 0x80000000) == 0) {
      goto LABEL_30;
    }
  }
  operator delete(__p[0]);
LABEL_30:

  return 0;
}

void sub_24B71695C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B716974(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v3 = *(void *)(a1 + 120);
    if (*(unsigned char *)(v3 + 160))
    {
      sub_24B7220DC(*(void *)v3);
      uint64_t v4 = sub_24B721E6C(*(void *)v3);
      int v7 = *(_DWORD *)(v4 + 32);
      if (v7)
      {
        *(_DWORD *)a2 = v7;
        *(void *)(a2 + 8) = objc_msgSend_contents(*(void **)(v4 + 40), v5, v6);
        *(_DWORD *)(a2 + 16) = *(_DWORD *)(v3 + 72);
        long long v8 = *(_OWORD *)(v3 + 96);
        *(_OWORD *)(a2 + 32) = *(_OWORD *)(v3 + 80);
        *(_OWORD *)(a2 + 48) = v8;
        long long v9 = *(_OWORD *)(v3 + 112);
        long long v10 = *(_OWORD *)(v3 + 128);
LABEL_18:
        *(_OWORD *)(a2 + 64) = v9;
        *(_OWORD *)(a2 + 80) = v10;
        return;
      }
      if (qword_2697D1188 != -1) {
        dispatch_once(&qword_2697D1188, &unk_26FE9CBC0);
      }
      uint64_t v13 = (id)qword_2697D1180;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        sub_24B6F6D14(__p, "common::PointCloudWithCoverageModelFrame oc::voxel_hashing::MeshSurfaceSamplerGPU::sampledPoints()");
        if (v20 >= 0) {
          int v18 = __p;
        }
        else {
          int v18 = (void **)__p[0];
        }
        *(_DWORD *)simd_float4x4 buf = 136315394;
        long long v22 = v18;
        __int16 v23 = 1026;
        int v24 = 126;
        _os_log_debug_impl(&dword_24B6B9000, v13, OS_LOG_TYPE_DEBUG, "%s:%{public}d No points sampled from mesh", buf, 0x12u);
        if (v20 < 0) {
          operator delete(__p[0]);
        }
      }

      *(_DWORD *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(v3 + 72);
    }
    else
    {
      if (qword_2697D1188 != -1) {
        dispatch_once(&qword_2697D1188, &unk_26FE9CBC0);
      }
      uint64_t v12 = (id)qword_2697D1180;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        sub_24B6F6D14(__p, "common::PointCloudWithCoverageModelFrame oc::voxel_hashing::MeshSurfaceSamplerGPU::sampledPoints()");
        uint64_t v17 = v20 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)simd_float4x4 buf = 136315394;
        long long v22 = v17;
        __int16 v23 = 1026;
        int v24 = 115;
        _os_log_error_impl(&dword_24B6B9000, v12, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get sampled points from mesh - MeshSurfaceSamplerGPU not initialized", buf, 0x12u);
        if (v20 < 0) {
          operator delete(__p[0]);
        }
      }

      *(_DWORD *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 16) = 0;
    }
    uint64_t v14 = MEMORY[0x263EF89A8];
    long long v15 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
    *(_OWORD *)(a2 + 32) = *MEMORY[0x263EF89A8];
    *(_OWORD *)(a2 + 48) = v15;
    long long v9 = *(_OWORD *)(v14 + 32);
    long long v10 = *(_OWORD *)(v14 + 48);
    goto LABEL_18;
  }
  if (qword_2697D12D0 != -1) {
    dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
  }
  uint64_t v11 = (id)qword_2697D12C8;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "virtual common::PointCloudWithCoverageModelFrame oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::sampledPointCloud()");
    uint64_t v16 = v20 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    long long v22 = v16;
    __int16 v23 = 1026;
    int v24 = 255;
    _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to sample points from mesh - pipeline not initialized.", buf, 0x12u);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }

  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
}

double sub_24B716CC8@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v3 = *(void (**)(void))(**(void **)(a1 + 104) + 40);
    v3();
  }
  else
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    char v5 = (id)qword_2697D12C8;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "virtual common::PointCloudModelFrame oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::surfacePointCloud()");
      uint64_t v6 = v8 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      long long v10 = v6;
      __int16 v11 = 1026;
      int v12 = 245;
      _os_log_error_impl(&dword_24B6B9000, v5, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get surface pointcloud - pipeline not initialized.", buf, 0x12u);
      if (v8 < 0) {
        operator delete(__p[0]);
      }
    }

    *(_DWORD *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    double result = 0.0;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
  }
  return result;
}

void sub_24B716E70(uint64_t a1@<X0>, float32x4_t *a2@<X8>)
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v3 = (uint64_t *)a1;
    sub_24B720F64(*(void *)(a1 + 8));
    id v4 = objc_claimAutoreleasedReturnValue();
    uint64_t v54 = objc_msgSend_contents(v4, v5, v6);

    unsigned int v9 = sub_24B720B00(v3[1], v7, v8);
    unsigned int v10 = v9;
    int v12 = (void **)(v3 + 6);
    __int16 v11 = (void *)v3[6];
    v3[7] = (uint64_t)v11;
    uint64_t v13 = v9 << 9;
    if (v13)
    {
      uint64_t v14 = (char *)operator new(48 * v13);
      long long v15 = &v14[48 * v13];
      int64x2_t v65 = vdupq_n_s64((unint64_t)v14);
      if (!v10) {
        goto LABEL_54;
      }
    }
    else
    {
      long long v15 = 0;
      uint64_t v14 = 0;
      int64x2_t v65 = 0u;
      if (!v9)
      {
LABEL_54:
        if (v11)
        {
          v3[7] = (uint64_t)v11;
          operator delete(v11);
          NSObject *v12 = 0;
          v12[1] = 0;
          v12[2] = 0;
        }
        *((int64x2_t *)v3 + 3) = v65;
        v3[8] = (uint64_t)v15;
        long long v47 = (float32x4_t *)v3[1];
        float32x4_t v59 = v47[20];
        float32x4_t v60 = v47[21];
        float32x4_t v62 = v47[22];
        unsigned __int32 v64 = v47[3].u32[2];
        float32x4_t v66 = v47[23];
        v74.columns[2].i64[0] = 0;
        v74.columns[0] = (simd_float4)v64;
        v74.columns[1].i32[0] = 0;
        v74.columns[1].i32[3] = 0;
        *(uint64_t *)((char *)v74.columns[1].i64 + 4) = v64;
        v74.columns[2].i64[1] = v64;
        v74.columns[3] = (simd_float4)xmmword_24B72A590;
        simd_float4x4 v75 = __invert_f4(v74);
        a2->i32[0] = v64;
        uint64_t v48 = v3[6];
        a2->i32[1] = -1431655765 * ((unint64_t)(v3[7] - v48) >> 4);
        a2->i64[1] = v48;
        a2[1] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v75.columns[0], v59.f32[0]), (float32x4_t)v75.columns[1], *(float32x2_t *)v59.f32, 1), (float32x4_t)v75.columns[2], v59, 2), (float32x4_t)v75.columns[3], v59, 3);
        a2[2] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v75.columns[0], v60.f32[0]), (float32x4_t)v75.columns[1], *(float32x2_t *)v60.f32, 1), (float32x4_t)v75.columns[2], v60, 2), (float32x4_t)v75.columns[3], v60, 3);
        a2[3] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v75.columns[0], v62.f32[0]), (float32x4_t)v75.columns[1], *(float32x2_t *)v62.f32, 1), (float32x4_t)v75.columns[2], v62, 2), (float32x4_t)v75.columns[3], v62, 3);
        a2[4] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v75.columns[0], v66.f32[0]), (float32x4_t)v75.columns[1], *(float32x2_t *)v66.f32, 1), (float32x4_t)v75.columns[2], v66, 2), (float32x4_t)v75.columns[3], v66, 3);
        return;
      }
    }
    long long v50 = (void **)(v3 + 6);
    long long v51 = v3;
    long long v52 = a2;
    uint64_t v17 = 0;
    v18.i32[3] = 1060320051;
    uint64_t v53 = v10;
    do
    {
      uint64_t v19 = 0;
      uint64_t v55 = v17;
      char v20 = (__int16 *)(v54 + 17368 * v17);
      v18.i32[0] = v20[8676];
      v18.i32[1] = v20[8677];
      v18.i32[2] = v20[8678];
      int32x4_t v18 = vshlq_n_s32(v18, 3uLL);
      int32x4_t v61 = v18;
      do
      {
        uint64_t v21 = 0;
        v18.i32[0] = v19;
        int32x4_t v56 = v18;
        do
        {
          uint64_t v22 = 0;
          __int16 v23 = (char *)v65.i64[0];
          int32x4_t v18 = v56;
          int32x4_t v24 = v56;
          v24.i32[1] = v21;
          v24.i32[2] = v56.i32[2];
          int32x4_t v63 = v24;
          do
          {
            if (LOBYTE(v20[384 * v19 + 1 + 48 * v21 + 6 * v22]))
            {
              _H2 = fabsl(*(short float *)&v20[384 * v19 + 48 * v21 + 6 * v22]);
              __asm { FCVT            S0, H2 }
              float v30 = (float)(_S0 / -12.0) + 1.0;
              if (v30 <= 1.0) {
                float v31 = v30;
              }
              else {
                float v31 = 1.0;
              }
              if (v30 >= 0.2) {
                *(float *)&long long v32 = v31;
              }
              else {
                *(float *)&long long v32 = 0.2;
              }
              BOOL v33 = _H2 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(12.0));
              long long v34 = xmmword_24B72A7F0;
              if (v33)
              {
                __asm { FCMP            H1, #0 }
                if (_NF != _VF)
                {
                  long long v34 = xmmword_24B72A800;
                  if (_NF)
                  {
                    DWORD1(v32) = 0;
                    *((void *)&v32 + 1) = 0x3F33333300000000;
                    long long v34 = v32;
                  }
                }
                else
                {
                  *(void *)&long long v34 = 0;
                  *((void *)&v34 + 1) = v32 | 0x3F33333300000000;
                }
              }
              int32x4_t v37 = v63;
              v37.i32[2] = v22;
              int32x4_t v38 = vaddq_s32(v37, v61);
              v38.i32[3] = 1;
              if (v14 < v15)
              {
                *(int32x4_t *)uint64_t v14 = v38;
                *((void *)v14 + 2) = 0;
                *((void *)v14 + 3) = 0;
                *((_OWORD *)v14 + 2) = v34;
                v14 += 48;
              }
              else
              {
                unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v23) >> 4) + 1;
                if (v39 > 0x555555555555555) {
                  abort();
                }
                if (0x5555555555555556 * ((v15 - v23) >> 4) > v39) {
                  unint64_t v39 = 0x5555555555555556 * ((v15 - v23) >> 4);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((v15 - v23) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
                  unint64_t v40 = 0x555555555555555;
                }
                else {
                  unint64_t v40 = v39;
                }
                if (v40)
                {
                  if (v40 > 0x555555555555555) {
                    sub_24B6BCD7C();
                  }
                  int32x4_t v57 = v38;
                  long long v58 = v34;
                  uint64_t v41 = (char *)operator new(48 * v40);
                  int32x4_t v38 = v57;
                  long long v34 = v58;
                }
                else
                {
                  uint64_t v41 = 0;
                }
                __int16 v42 = &v41[16 * ((v14 - v23) >> 4)];
                *(int32x4_t *)__int16 v42 = v38;
                *((void *)v42 + 2) = 0;
                *((void *)v42 + 3) = 0;
                *((_OWORD *)v42 + 2) = v34;
                if (v14 == v23)
                {
                  unint64_t v46 = &v41[16 * ((v14 - v23) >> 4)];
                }
                else
                {
                  int v43 = &v41[16 * ((v14 - v23) >> 4)];
                  do
                  {
                    long long v44 = *((_OWORD *)v14 - 3);
                    long long v45 = *((_OWORD *)v14 - 1);
                    unint64_t v46 = v43 - 48;
                    *((_OWORD *)v43 - 2) = *((_OWORD *)v14 - 2);
                    *((_OWORD *)v43 - 1) = v45;
                    *((_OWORD *)v43 - 3) = v44;
                    v14 -= 48;
                    v43 -= 48;
                  }
                  while (v14 != v23);
                }
                long long v15 = &v41[48 * v40];
                uint64_t v14 = v42 + 48;
                v65.i64[0] = (uint64_t)v46;
                if (v23) {
                  operator delete(v23);
                }
                __int16 v23 = v46;
              }
              v18.i64[0] = v65.i64[0];
              v18.i64[1] = (uint64_t)v14;
              int64x2_t v65 = (int64x2_t)v18;
            }
            ++v22;
          }
          while (v22 != 8);
          ++v21;
        }
        while (v21 != 8);
        ++v19;
      }
      while (v19 != 8);
      uint64_t v17 = v55 + 1;
    }
    while (v55 + 1 != v53);
    int v12 = v50;
    uint64_t v3 = v51;
    __int16 v11 = *v50;
    a2 = v52;
    goto LABEL_54;
  }
  if (qword_2697D12D0 != -1) {
    dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
  }
  uint64_t v16 = (id)qword_2697D12C8;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(v67, "virtual common::VoxelCloudModelFrame oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::debugVoxelCloud()");
    long long v49 = v68 >= 0 ? v67 : (void **)v67[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    id v70 = v49;
    __int16 v71 = 1026;
    int v72 = 221;
    _os_log_error_impl(&dword_24B6B9000, v16, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get debug voxelcloud - pipeline not initialized.", buf, 0x12u);
    if (v68 < 0) {
      operator delete(v67[0]);
    }
  }

  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
}

void sub_24B717444(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,long long a31)
{
}

double sub_24B717498@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 88))
  {
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 104) + 40))(&__p);
    int v4 = (int)__p;
    uint64_t v5 = v24;
    if (__p) {
      BOOL v6 = v24 == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6)
    {
      long long v15 = 0;
      int v7 = 0;
      uint64_t v8 = 0;
      unsigned int v9 = *(void **)(a1 + 24);
      if (!v9)
      {
LABEL_9:
        *(void *)(a1 + 24) = v15;
        *(void *)(a1 + 32) = v7;
        *(void *)(a1 + 40) = v8;
        *(_DWORD *)a2 = v25;
        *(_DWORD *)(a2 + 4) = v4;
        *(void *)(a2 + 8) = v15;
        long long v10 = v28;
        *(_OWORD *)(a2 + 16) = v27;
        *(_OWORD *)(a2 + 32) = v10;
        double result = *(double *)&v29;
        long long v12 = v30;
        *(_OWORD *)(a2 + 48) = v29;
        *(_OWORD *)(a2 + 64) = v12;
        return result;
      }
    }
    else
    {
      size_t v14 = 48 * __p;
      long long v15 = (char *)operator new(v14);
      size_t v16 = 48 * ((v14 - 48) / 0x30) + 48;
      bzero(v15, v16);
      uint64_t v17 = 0;
      do
      {
        *(int32x2_t *)&long long v18 = vcvt_s32_f32(vrndm_f32(*(float32x2_t *)(v5 + v17)));
        *((void *)&v18 + 1) = vcvtms_s32_f32(*(float *)(v5 + v17 + 8)) | 0x100000000;
        long long v19 = *(_OWORD *)(v5 + v17 + 16);
        long long v20 = *(_OWORD *)(v5 + v17 + 32);
        uint64_t v21 = &v15[v17];
        *(_OWORD *)uint64_t v21 = v18;
        *((_OWORD *)v21 + 1) = v19;
        *((_OWORD *)v21 + 2) = v20;
        v17 += 48;
      }
      while (v14 != v17);
      uint64_t v8 = &v15[48 * v4];
      int v7 = &v15[v16];
      unsigned int v9 = *(void **)(a1 + 24);
      if (!v9) {
        goto LABEL_9;
      }
    }
    *(void *)(a1 + 32) = v9;
    operator delete(v9);
    int v4 = (int)__p;
    goto LABEL_9;
  }
  if (qword_2697D12D0 != -1) {
    dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
  }
  uint64_t v13 = (id)qword_2697D12C8;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(&__p, "virtual common::VoxelCloudModelFrame oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::surfaceVoxelCloud()");
    uint64_t v22 = v26 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)simd_float4x4 buf = 136315394;
    long long v32 = v22;
    __int16 v33 = 1026;
    int v34 = 206;
    _os_log_error_impl(&dword_24B6B9000, v13, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to get surface voxelcloud - pipeline not initialized.", buf, 0x12u);
    if (v26 < 0) {
      operator delete(__p);
    }
  }

  double result = 0.0;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  return result;
}

uint64_t sub_24B71770C(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 88))
  {
    if (sub_24B705198(a2, a3, *a4, a4[1]))
    {
      kdebug_trace();
      (*(void (**)(void, uint64_t, uint64_t, double *))(**(void **)(a1 + 112) + 24))(*(void *)(a1 + 112), a2, a3, a4);
      kdebug_trace();
      return 0;
    }
    else
    {
      return 4;
    }
  }
  else
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    unsigned int v9 = (id)qword_2697D12C8;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "virtual VoxelHashingStatus oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::renderDepthImage(const simd_float4x4 &, const simd_float3x3 &, const CGSize &)");
      if (v12 >= 0) {
        long long v10 = __p;
      }
      else {
        long long v10 = (void **)__p[0];
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      size_t v14 = v10;
      __int16 v15 = 1026;
      int v16 = 183;
      _os_log_error_impl(&dword_24B6B9000, v9, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to render depth image - pipeline not initialized.", buf, 0x12u);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }

    return 1;
  }
}

uint64_t sub_24B7178E4(uint64_t a1, int a2)
{
  uint64_t v162 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 88))
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    __int16 v11 = (id)qword_2697D12C8;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(&__p, "virtual VoxelHashingStatus oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::sampleSurfacePoints(const uint32_t)");
    __int16 v33 = __p.columns[1].i8[7] >= 0 ? &__p : (simd_float4x4 *)__p.columns[0].i64[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v33;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 135;
    _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to sample surface points - pipeline not initialized.", buf, 0x12u);
    if ((__p.columns[1].i8[7] & 0x80000000) == 0) {
      goto LABEL_21;
    }
LABEL_61:
    operator delete((void *)__p.columns[0].i64[0]);
LABEL_21:

    return 1;
  }
  (*(void (**)(void))(**(void **)(a1 + 104) + 24))(*(void *)(a1 + 104));
  if (!*(unsigned char *)(a1 + 306)) {
    goto LABEL_76;
  }
  uint64_t v4 = sub_24B721FA4(*(void *)(a1 + 8));
  uint64_t v5 = *(void *)(a1 + 472);
  float v6 = *(float *)(a1 + 180);
  simd_float4x4 __p = __invert_f4(*(simd_float4x4 *)(a1 + 240));
  BOOL v9 = *(_DWORD *)(v5 + 4) != 1 || v4 == 0;
  if (v9
    || !*(void *)v4
    || !*(void *)(v4 + 8)
    || !*(void *)(v4 + 16)
    || *(_DWORD *)objc_msgSend_contents(*(void **)v4, v7, v8) < *(_DWORD *)(v5 + 16)
    || (uint64_t v13 = (uint64_t *)(v5 + 128), *(void *)(v5 + 128) != *(void *)(v5 + 136))
    && (!*(unsigned char *)(v5 + 480)
     || (uint64_t v14 = v5 + 192, (sub_24B6F3244(v14, (uint64_t)&__p, v4, v6) & 1) == 0)
     || (sub_24B6F4CD8(v14, v13) & 1) == 0))
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    long long v10 = (id)qword_2697D12C8;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(&__p, "BOOL oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::computeCoverage()");
      float v31 = __p.columns[1].i8[7] >= 0 ? &__p : (simd_float4x4 *)__p.columns[0].i64[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v31;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = 510;
      _os_log_error_impl(&dword_24B6B9000, v10, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to compute coverage scores.", buf, 0x12u);
      if (__p.columns[1].i8[7] < 0) {
        operator delete((void *)__p.columns[0].i64[0]);
      }
    }

    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    __int16 v11 = (id)qword_2697D12C8;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(&__p, "virtual VoxelHashingStatus oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::sampleSurfacePoints(const uint32_t)");
    long long v32 = __p.columns[1].i8[7] >= 0 ? &__p : (simd_float4x4 *)__p.columns[0].i64[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v32;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 143;
    _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to sample surface points - failed to compute coverage.", buf, 0x12u);
    if ((__p.columns[1].i8[7] & 0x80000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_61;
  }
  __int16 v15 = *(float **)(v4 + 48);
  int v16 = *(float **)(v4 + 56);
  if (v15 == v16)
  {
    float v35 = 0.0;
    goto LABEL_75;
  }
  uint64_t v17 = 0;
  int64_t v157 = (char *)v16 - (char *)v15;
  uint64_t v18 = *(void *)(v4 + 72);
  unsigned int v19 = *(_DWORD *)(a1 + 448) + 1;
  unsigned int v20 = *(_DWORD *)(a1 + 452) + 1;
  unint64_t v156 = v16 - v15;
  if (v156 <= 1) {
    uint64_t v21 = 1;
  }
  else {
    uint64_t v21 = v16 - v15;
  }
  do
  {
    unsigned int v29 = *(_DWORD *)(v18 + 4 * v17);
    if (v29 - 1 < *(_DWORD *)(a1 + 448))
    {
      uint64_t v22 = v17;
      float v23 = v15[v17];
      float v24 = *(float *)(a1 + 456);
LABEL_31:
      float v25 = v23 / v24;
      v15[v22] = v25;
      goto LABEL_32;
    }
    if (v29 >= v19 && v29 <= *(_DWORD *)(a1 + 452))
    {
      uint64_t v22 = v17;
      float v23 = v15[v17];
      float v24 = *(float *)(a1 + 460);
      goto LABEL_31;
    }
    float v25 = v15[v17];
    if (v29 >= v20)
    {
      float v25 = v25 / *(float *)(a1 + 464);
      v15[v17] = v25;
    }
LABEL_32:
    float v26 = powf(fmaxf(v25, 0.0), *(float *)(a1 + 468));
    if (v26 <= 1.0) {
      float v27 = v26;
    }
    else {
      float v27 = 1.0;
    }
    if (v26 >= 0.0) {
      float v28 = v27;
    }
    else {
      float v28 = 0.0;
    }
    v15[v17++] = v28;
  }
  while (v21 != v17);
  if ((unint64_t)(v157 - 4) >= 0x1C)
  {
    unint64_t v36 = ((unint64_t)(v157 - 4) >> 2) + 1;
    int32x4_t v37 = (float32x4_t *)(v15 + 4);
    int64x2_t v38 = 0uLL;
    float32x4_t v39 = (float32x4_t)vdupq_n_s32(0x3F4CCCCDu);
    int8x16_t v40 = (int8x16_t)vdupq_n_s64(1uLL);
    uint64_t v41 = v36 & 0x7FFFFFFFFFFFFFF8;
    int64x2_t v42 = 0uLL;
    int64x2_t v43 = 0uLL;
    int64x2_t v44 = 0uLL;
    do
    {
      int32x4_t v45 = vcgtq_f32(v37[-1], v39);
      v46.i64[0] = v45.u32[0];
      v46.i64[1] = v45.u32[1];
      int64x2_t v47 = (int64x2_t)vandq_s8(v46, v40);
      v46.i64[0] = v45.u32[2];
      v46.i64[1] = v45.u32[3];
      int64x2_t v48 = (int64x2_t)vandq_s8(v46, v40);
      int32x4_t v49 = vcgtq_f32(*v37, v39);
      v46.i64[0] = v49.u32[0];
      v46.i64[1] = v49.u32[1];
      int64x2_t v50 = (int64x2_t)vandq_s8(v46, v40);
      v46.i64[0] = v49.u32[2];
      v46.i64[1] = v49.u32[3];
      int64x2_t v42 = vaddq_s64(v42, v48);
      int64x2_t v38 = vaddq_s64(v38, v47);
      int64x2_t v44 = vaddq_s64(v44, (int64x2_t)vandq_s8(v46, v40));
      int64x2_t v43 = vaddq_s64(v43, v50);
      v37 += 2;
      v41 -= 8;
    }
    while (v41);
    unint64_t v34 = vaddvq_s64(vaddq_s64(vaddq_s64(v43, v38), vaddq_s64(v44, v42)));
    if (v36 != (v36 & 0x7FFFFFFFFFFFFFF8))
    {
      v15 += v36 & 0x7FFFFFFFFFFFFFF8;
      goto LABEL_70;
    }
    uint64_t v51 = v16 - v15;
  }
  else
  {
    unint64_t v34 = 0;
LABEL_70:
    uint64_t v51 = v156;
    do
    {
      float v52 = *v15++;
      if (v52 > 0.8) {
        ++v34;
      }
    }
    while (v15 != v16);
  }
  float v35 = (float)v34 / (float)(unint64_t)v51;
LABEL_75:
  *(float *)(v4 + 96) = v35;
LABEL_76:
  if (!a2) {
    goto LABEL_122;
  }
  kdebug_trace();
  uint64_t v53 = *(void *)(a1 + 120);
  if (!*(unsigned char *)(v53 + 160))
  {
    if (qword_2697D1188 != -1) {
      dispatch_once(&qword_2697D1188, &unk_26FE9CBC0);
    }
    id v84 = (id)qword_2697D1180;
    if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(&__p, "BOOL oc::voxel_hashing::MeshSurfaceSamplerGPU::samplePointsFromMesh(const uint32_t)");
      unsigned int v153 = __p.columns[1].i8[7] >= 0 ? &__p : (simd_float4x4 *)__p.columns[0].i64[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v153;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = 59;
      _os_log_error_impl(&dword_24B6B9000, v84, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to sample points from mesh - MeshSurfaceSamplerGPU not initialized", buf, 0x12u);
      if (__p.columns[1].i8[7] < 0) {
        operator delete((void *)__p.columns[0].i64[0]);
      }
    }

    kdebug_trace();
    return 1;
  }
  uint64_t v54 = sub_24B721FA4(*(void *)v53);
  if (!*(_DWORD *)objc_msgSend_contents(*(void **)(v54 + 16), v55, v56))
  {
    if (qword_2697D1188 != -1) {
      dispatch_once(&qword_2697D1188, &unk_26FE9CBC0);
    }
    uint64_t v85 = (id)qword_2697D1180;
    if (!os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_92;
    }
    sub_24B6F6D14(&__p, "BOOL oc::voxel_hashing::MeshSurfaceSamplerGPU::samplePointsFromMesh(const uint32_t)");
    uint64_t v155 = __p.columns[1].i8[7] >= 0 ? &__p : (simd_float4x4 *)__p.columns[0].i64[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v155;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 78;
    _os_log_debug_impl(&dword_24B6B9000, v85, OS_LOG_TYPE_DEBUG, "%s:%{public}d Can't sample points from mesh - triangle mesh is empty", buf, 0x12u);
    if ((__p.columns[1].i8[7] & 0x80000000) == 0) {
      goto LABEL_92;
    }
LABEL_148:
    operator delete((void *)__p.columns[0].i64[0]);
LABEL_92:

    goto LABEL_121;
  }
  float32x4_t v59 = objc_msgSend_contents(*(void **)(v53 + 56), v57, v58);
  memcpy(v59, *(const void **)(v54 + 48), *(void *)(v54 + 56) - *(void *)(v54 + 48));
  uint64_t v62 = objc_msgSend_contents(*(void **)(v53 + 40), v60, v61);
  uint64_t v65 = objc_msgSend_contents(*(void **)(v54 + 8), v63, v64);
  uint64_t v68 = objc_msgSend_contents(*(void **)(v54 + 24), v66, v67);
  unsigned int v72 = *(_DWORD *)objc_msgSend_contents(*(void **)(v54 + 16), v69, v70);
  if (!v72) {
    goto LABEL_116;
  }
  unsigned int v73 = 0;
  LODWORD(v74) = 0;
  do
  {
    float32x4_t v75 = *(float32x4_t *)(v65 + 48 * *(unsigned int *)(v68 + 4 * v73));
    float32x4_t v76 = vsubq_f32(*(float32x4_t *)(v65 + 48 * *(unsigned int *)(v68 + 4 * (v73 + 1))), v75);
    float32x4_t v77 = vsubq_f32(*(float32x4_t *)(v65 + 48 * *(unsigned int *)(v68 + 4 * (v73 + 2))), v75);
    float32x4_t v78 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v77, (int32x4_t)v77), (int8x16_t)v77, 0xCuLL), vnegq_f32(v76)), v77, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v76, (int32x4_t)v76), (int8x16_t)v76, 0xCuLL));
    float32x4_t v79 = vmulq_f32(v78, v78);
    int32x2_t v80 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v79, 2), v79)).u64[0];
    *(float *)(v62 + 4 * v74) = sqrtf(*(float *)v80.i32) * 0.5;
    uint64_t v74 = (v74 + 1);
    v73 += 3;
  }
  while (v73 < v72);
  if (!v74) {
    goto LABEL_116;
  }
  float v81 = *(float *)(*(void *)v53 + 56) * *(float *)(*(void *)v53 + 56);
  *(float *)v80.i32 = fminf(v81, 0.000049);
  if (v74 <= 7)
  {
    uint64_t v82 = 0;
    unsigned int v83 = 0;
    goto LABEL_96;
  }
  uint64_t v82 = v74 & 0xFFFFFFF8;
  float32x4_t v86 = (float32x4_t)vdupq_lane_s32(v80, 0);
  uint64_t v87 = v82;
  uint64_t v88 = (float32x4_t *)(v62 + 16);
  int32x4_t v89 = 0uLL;
  int32x4_t v90 = 0uLL;
  do
  {
    float32x4_t v91 = vrndpq_f32(vdivq_f32(vmulq_n_f32(v88[-1], v81), v86));
    float32x4_t v92 = vrndpq_f32(vdivq_f32(vmulq_n_f32(*v88, v81), v86));
    v88[-1] = v91;
    *uint64_t v88 = v92;
    int32x4_t v89 = vaddq_s32(v89, (int32x4_t)vcvtq_u32_f32(v91));
    int32x4_t v90 = vaddq_s32(v90, (int32x4_t)vcvtq_u32_f32(v92));
    v88 += 2;
    v87 -= 8;
  }
  while (v87);
  unsigned int v83 = vaddvq_s32(vaddq_s32(v90, v89));
  if (v82 != v74)
  {
LABEL_96:
    uint64_t v93 = v74 - v82;
    uint64_t v94 = (float *)(v62 + 4 * v82);
    do
    {
      float v95 = (float)(v81 * *v94) / *(float *)v80.i32;
      *v94++ = ceilf(v95);
      v83 += vcvtps_u32_f32(v95);
      --v93;
    }
    while (v93);
  }
  unsigned int v96 = *(_DWORD *)(v53 + 64);
  if (v83 > v96)
  {
    unsigned int v97 = 0;
    do
    {
      float v98 = *(float *)(v62 + 4 * v97);
      if (v98)
      {
        *(float *)(v62 + 4 * v97) = ceilf(v98 + -1.0);
        --v83;
      }
      ++v97;
    }
    while (v83 > v96);
  }
  if (!v83)
  {
LABEL_116:
    if (qword_2697D1188 != -1) {
      dispatch_once(&qword_2697D1188, &unk_26FE9CBC0);
    }
    uint64_t v85 = (id)qword_2697D1180;
    if (!os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_92;
    }
    sub_24B6F6D14(&__p, "BOOL oc::voxel_hashing::MeshSurfaceSamplerGPU::samplePointsFromMesh(const uint32_t)");
    uint64_t v154 = __p.columns[1].i8[7] >= 0 ? &__p : (simd_float4x4 *)__p.columns[0].i64[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v154;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 94;
    _os_log_debug_impl(&dword_24B6B9000, v85, OS_LOG_TYPE_DEBUG, "%s:%{public}d Can't sample points from mesh - num of computed points is 0", buf, 0x12u);
    if ((__p.columns[1].i8[7] & 0x80000000) == 0) {
      goto LABEL_92;
    }
    goto LABEL_148;
  }
  int v99 = objc_msgSend_commandBufferWithDescriptor_(*(void **)(*(void *)(v53 + 16) + 8), v71, *(void *)(v53 + 32));
  uint64_t v102 = objc_msgSend_contents(*(void **)(v53 + 48), v100, v101);
  uint64_t v105 = 0;
  unsigned int v106 = 0;
  v107.i64[0] = 0x400000004;
  v107.i64[1] = 0x400000004;
  v108.i64[0] = 0x800000008;
  v108.i64[1] = 0x800000008;
  do
  {
    unsigned int v109 = vcvtps_u32_f32(*(float *)(v62 + 4 * v105));
    if (!v109) {
      goto LABEL_105;
    }
    if (v109 <= 7 || __CFADD__(v106, v109 - 1))
    {
      for (unsigned int i = 0; i != v109; ++i)
      {
LABEL_111:
        id v110 = (_DWORD *)(v102 + 8 * v106);
        _DWORD *v110 = v105;
        v110[1] = i;
        ++v106;
      }
      goto LABEL_105;
    }
    unsigned int i = v109 & 0xFFFFFFF8;
    int32x4_t v112 = vdupq_n_s32(v105);
    uint64_t v113 = v109 & 0xFFFFFFF8;
    unsigned int v114 = v106;
    int32x4_t v115 = (int32x4_t)xmmword_24B72A700;
    do
    {
      int32x4_t v116 = vaddq_s32(v115, v107);
      float32x4_t v117 = (float *)(v102 + 8 * v114);
      int32x4_t v118 = v112;
      vst2q_f32(v117, *(float32x4x2_t *)(&v115 - 1));
      float32x4_t v119 = (float *)(v102 + 8 * (v114 + 4));
      vst2q_f32(v119, *(float32x4x2_t *)v112.i8);
      int32x4_t v115 = vaddq_s32(v115, v108);
      v114 += 8;
      v113 -= 8;
    }
    while (v113);
    v106 += i;
    if (i != v109) {
      goto LABEL_111;
    }
LABEL_105:
    ++v105;
  }
  while (v105 != v74);
  unsigned int v160 = v83;
  BOOL v159 = *(void *)(v54 + 48) != *(void *)(v54 + 56);
  uint64_t v120 = objc_msgSend_computeCommandEncoder(v99, v103, v104, COERCE_DOUBLE(0x100000000), COERCE_DOUBLE(0x400000004), COERCE_DOUBLE(0x800000008));
  objc_msgSend_setLabel_(v120, v121, @"SamplePointsFromTriangleMesh Encoder");
  objc_msgSend_setComputePipelineState_(v120, v122, *(void *)(v53 + 24));
  objc_msgSend_setBytes_length_atIndex_(v120, v123, v53 + 144, 16, 0);
  objc_msgSend_setBytes_length_atIndex_(v120, v124, v53 + 64, 4, 1);
  objc_msgSend_setBuffer_offset_atIndex_(v120, v125, *(void *)(v54 + 16), 0, 2);
  objc_msgSend_setBuffer_offset_atIndex_(v120, v126, *(void *)(v54 + 24), 0, 3);
  objc_msgSend_setBuffer_offset_atIndex_(v120, v127, *(void *)(v54 + 8), 0, 4);
  objc_msgSend_setBuffer_offset_atIndex_(v120, v128, *(void *)(v53 + 56), 0, 5);
  objc_msgSend_setBytes_length_atIndex_(v120, v129, (uint64_t)&v159, 1, 6);
  objc_msgSend_setBuffer_offset_atIndex_(v120, v130, *(void *)(v53 + 48), 0, 7);
  objc_msgSend_setBytes_length_atIndex_(v120, v131, (uint64_t)&v160, 4, 8);
  objc_msgSend_setBuffer_offset_atIndex_(v120, v132, *(void *)(v54 + 40), 0, 9);
  uint64_t v135 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(v53 + 24), v133, v134);
  __p.columns[0].i64[0] = v160;
  *(int64x2_t *)((char *)__p.columns + 8) = vdupq_n_s64(1uLL);
  *(void *)simd_float4x4 buf = v135;
  *(simd_float4 *)&uint8_t buf[8] = *(simd_float4 *)((char *)__p.columns + 8);
  objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v120, v136, (uint64_t)&__p, buf);
  objc_msgSend_endEncoding(v120, v137, v138);

  objc_msgSend_commit(v99, v139, v140);
  objc_msgSend_waitUntilCompleted(v99, v141, v142);
  *(_DWORD *)(v54 + 32) = v83;

LABEL_121:
  kdebug_trace();
LABEL_122:
  uint64_t v143 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v143 + 8))
  {
    int v144 = *(NSObject **)(v143 + 624);
    __p.columns[0].i64[0] = MEMORY[0x263EF8330];
    __p.columns[0].i64[1] = 3221225472;
    __p.columns[1].i64[0] = (uint64_t)sub_24B722278;
    __p.columns[1].i64[1] = (uint64_t)&unk_2652DF258;
    __p.columns[2].i64[0] = v143 + 576;
    dispatch_sync(v144, &__p);
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    uint64_t v145 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(&__p, "void oc::voxel_hashing::VoxelHashingDataGPU::updateMeshWriterBuffer()");
      if (__p.columns[1].i8[7] >= 0) {
        p_p = &__p;
      }
      else {
        p_p = (simd_float4x4 *)__p.columns[0].i64[0];
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = p_p;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = 436;
      _os_log_error_impl(&dword_24B6B9000, v145, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (__p.columns[1].i8[7] < 0) {
        operator delete((void *)__p.columns[0].i64[0]);
      }
    }
  }
  char v146 = (void **)sub_24B721FA4(*(void *)(a1 + 8));
  *(_DWORD *)objc_msgSend_contents(*v146, v147, v148) = 0;
  int v151 = (_DWORD *)objc_msgSend_contents(v146[2], v149, v150);
  uint64_t result = 0;
  _DWORD *v151 = 0;
  return result;
}

void sub_24B7186C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B7186F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 88))
  {
    kdebug_trace();
    LODWORD(a5) = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), a2, a3, a4, a5);
    kdebug_trace();
    return a5 ^ 1;
  }
  else
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    __int16 v11 = (id)qword_2697D12C8;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "virtual VoxelHashingStatus oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::integratePointCloud(const simd_float4x4 &, const uint32_t, const oc::common::Point *, const common::PointSupplements *)");
      if (v14 >= 0) {
        char v12 = __p;
      }
      else {
        char v12 = (void **)__p[0];
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      int v16 = v12;
      __int16 v17 = 1026;
      int v18 = 114;
      _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to integrate pointcloud - pipeline not initialized.", buf, 0x12u);
      if (v14 < 0) {
        operator delete(__p[0]);
      }
    }

    return 1;
  }
}

uint64_t sub_24B7188B8()
{
  return 2;
}

uint64_t sub_24B7188C0(uint64_t a1, const void *a2)
{
  uint64_t v117 = *MEMORY[0x263EF8340];
  if (sub_24B71A784((uint64_t)a2))
  {
    if (*(unsigned char *)(a1 + 88))
    {
      if (qword_2697D12D0 != -1) {
        dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
      }
      uint64_t v4 = (id)qword_2697D12C8;
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
        goto LABEL_77;
      }
      sub_24B6F6D14(__p, "virtual VoxelHashingStatus oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::init(const VoxelHashingPipelineConfig &)");
      if (v108 >= 0) {
        uint64_t v5 = __p;
      }
      else {
        uint64_t v5 = *(unsigned char **)__p;
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v5;
      __int16 v101 = 1026;
      int v102 = 37;
      float v6 = "%s:%{public}d Failed to initialize VoxelHashingPipelineGPU - already initialized.";
LABEL_88:
      _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, v6, buf, 0x12u);
      if (SHIBYTE(v108) < 0) {
        operator delete(*(void **)__p);
      }
LABEL_77:
      uint64_t v7 = 1;
      goto LABEL_78;
    }
    memcpy((void *)(a1 + 128), a2, 0x140uLL);
    if (*(unsigned char *)(a1 + 305))
    {
      if (qword_2697D12D0 != -1) {
        dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
      }
      uint64_t v8 = (id)qword_2697D12C8;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        sub_24B6F6D14(__p, "virtual VoxelHashingStatus oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::init(const VoxelHashingPipelineConfig &)");
        BOOL v9 = v108 >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = v9;
        __int16 v101 = 1026;
        int v102 = 46;
        _os_log_impl(&dword_24B6B9000, v8, OS_LOG_TYPE_INFO, "%s:%{public}d VoxelBlockPreallocation is enabled.", buf, 0x12u);
        if (SHIBYTE(v108) < 0) {
          operator delete(*(void **)__p);
        }
      }

      *(float *)v10.i32 = *(float *)(a1 + 180) * 8.0;
      v11.i64[0] = 0x3F0000003F000000;
      v11.i64[1] = 0x3F0000003F000000;
      float32x4_t v12 = vdivq_f32(vmulq_f32(*(float32x4_t *)(a1 + 160), v11), (float32x4_t)vdupq_lane_s32(v10, 0));
      v12.i32[3] = 0;
      float32x4_t v13 = vrndpq_f32(v12);
      int v14 = 8 * (int)v13.f32[1] * (int)v13.f32[0] * (int)v13.f32[2];
      if (*(_DWORD *)(a1 + 176) != v14)
      {
        if (qword_2697D12D0 != -1) {
          dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
        }
        __int16 v15 = (id)qword_2697D12C8;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          sub_24B6F6D14(buf, "virtual VoxelHashingStatus oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::init(const VoxelHashingPipelineConfig &)");
          uint64_t v53 = v103 >= 0 ? buf : *(unsigned char **)buf;
          int v54 = *(_DWORD *)(a1 + 176);
          double v55 = *(float *)(a1 + 160);
          double v56 = *(float *)(a1 + 164);
          double v57 = *(float *)(a1 + 168);
          *(_DWORD *)simd_float4x4 __p = 136316674;
          *(void *)&__p[4] = v53;
          __int16 __p_12 = 1026;
          int __p_14 = 57;
          __int16 v107 = 1026;
          int v108 = v54;
          __int16 v109 = 2050;
          double v110 = v55;
          __int16 v111 = 2050;
          double v112 = v56;
          __int16 v113 = 2050;
          double v114 = v57;
          __int16 v115 = 1026;
          int v116 = v14;
          _os_log_error_impl(&dword_24B6B9000, v15, OS_LOG_TYPE_ERROR, "%s:%{public}d Specified voxelHashingCapacity = %{public}d is insufficient/excessive to fill the bounding box with extents: [%{public}f, %{public}f, %{public}f], adjusted voxelHashingCapacity to %{public}d", __p, 0x3Cu);
          if (v103 < 0) {
            operator delete(*(void **)buf);
          }
        }

        *(_DWORD *)(a1 + 176) = v14;
      }
    }
    float v96 = *(float *)(a1 + 180);
    simd_float4x4 v95 = __invert_f4(*(simd_float4x4 *)(a1 + 240));
    int v16 = *(_DWORD *)(a1 + 132);
    if (v16) {
      unsigned int v17 = 0x8000;
    }
    else {
      unsigned int v17 = 0x10000;
    }
    int v18 = *(_DWORD *)(a1 + 176);
    uint64_t v97 = *(void *)(a1 + 200);
    float v98 = *(float *)(a1 + 180);
    float32x4_t v99 = *(float32x4_t *)(a1 + 160);
    uint64_t v19 = operator new(0x40uLL);
    uint64_t v20 = MEMORY[0x263EF89A8];
    long long v21 = *(_OWORD *)(MEMORY[0x263EF89A8] + 16);
    _OWORD *v19 = *MEMORY[0x263EF89A8];
    v19[1] = v21;
    long long v22 = *(_OWORD *)(v20 + 48);
    void v19[2] = *(_OWORD *)(v20 + 32);
    v19[3] = v22;
    char v23 = *(unsigned char *)(a1 + 208);
    int v24 = *(unsigned __int8 *)(a1 + 305);
    float v25 = (char *)operator new(0x2B0uLL);
    char v94 = v23;
    *((void *)v25 + 1) = 0;
    *((void *)v25 + 2) = 0;
    *(void *)float v25 = &unk_26FE9D5D0;
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1358, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_2697D1358))
    {
      qword_2697D1350 = sub_24B727BB4();
      __cxa_atexit((void (*)(void *))sub_24B727D84, &qword_2697D1350, &dword_24B6B9000);
      __cxa_guard_release(&qword_2697D1358);
    }
    *((void *)v25 + 4) = qword_2697D1350;
    v25[40] = 0;
    *((void *)v25 + 57) = 0;
    *((void *)v25 + 58) = 0;
    *((void *)v25 + 56) = 0;
    *((_OWORD *)v25 + 3) = 0u;
    *((_OWORD *)v25 + 4) = 0u;
    *((_OWORD *)v25 + 5) = 0u;
    *((_OWORD *)v25 + 6) = 0u;
    *((_OWORD *)v25 + 7) = 0u;
    *((_OWORD *)v25 + 8) = 0u;
    *((_OWORD *)v25 + 9) = 0u;
    *((_OWORD *)v25 + 10) = 0u;
    *((_OWORD *)v25 + 11) = 0u;
    *((_OWORD *)v25 + 12) = 0u;
    *((_OWORD *)v25 + 13) = 0u;
    *((_OWORD *)v25 + 14) = 0u;
    *((_OWORD *)v25 + 15) = 0u;
    *((_OWORD *)v25 + 16) = 0u;
    *((_OWORD *)v25 + 17) = 0u;
    *((_OWORD *)v25 + 18) = 0u;
    *((_OWORD *)v25 + 19) = 0u;
    *((_OWORD *)v25 + 20) = 0u;
    *((_OWORD *)v25 + 21) = 0u;
    *((_OWORD *)v25 + 22) = 0u;
    *((_OWORD *)v25 + 23) = 0u;
    *((_OWORD *)v25 + 24) = 0u;
    *((_OWORD *)v25 + 25) = 0u;
    *((_OWORD *)v25 + 26) = 0u;
    *(_OWORD *)(v25 + 428) = 0u;
    *(_OWORD *)(v25 + 556) = 0u;
    *((_OWORD *)v25 + 33) = 0u;
    *((_OWORD *)v25 + 34) = 0u;
    *((_OWORD *)v25 + 31) = 0u;
    *((_OWORD *)v25 + 32) = 0u;
    *((_OWORD *)v25 + 30) = 0u;
    *((void *)v25 + 72) = 0;
    *((void *)v25 + 74) = 0;
    *((void *)v25 + 73) = 0;
    *((_DWORD *)v25 + 150) = 0;
    *((_OWORD *)v25 + 38) = 0u;
    *((_OWORD *)v25 + 39) = 0u;
    *((_OWORD *)v25 + 40) = xmmword_24B72A790;
    *((void *)v25 + 82) = 0;
    v25[664] = 0;
    float v26 = operator new(0x138uLL);
    v26[38] = 0;
    *((_OWORD *)v26 + 17) = 0u;
    *((_OWORD *)v26 + 18) = 0u;
    *((_OWORD *)v26 + 15) = 0u;
    *((_OWORD *)v26 + 16) = 0u;
    *((_OWORD *)v26 + 13) = 0u;
    *((_OWORD *)v26 + 14) = 0u;
    *((_OWORD *)v26 + 11) = 0u;
    *((_OWORD *)v26 + 12) = 0u;
    *((_OWORD *)v26 + 9) = 0u;
    *((_OWORD *)v26 + 10) = 0u;
    *((_OWORD *)v26 + 7) = 0u;
    *((_OWORD *)v26 + 8) = 0u;
    *((_OWORD *)v26 + 5) = 0u;
    *((_OWORD *)v26 + 6) = 0u;
    *((_OWORD *)v26 + 3) = 0u;
    *((_OWORD *)v26 + 4) = 0u;
    *((_OWORD *)v26 + 1) = 0u;
    *((_OWORD *)v26 + 2) = 0u;
    *(_OWORD *)float v26 = 0u;
    *((void *)v25 + 76) = v26;
    *((void *)v25 + 77) = v26 + 39;
    *((void *)v25 + 78) = v26 + 39;
    dispatch_queue_t v27 = dispatch_queue_create("com.apple.coreocmodules.voxelHashing_tripleBuffer_serial_queue", 0);
    float v28 = (void *)*((void *)v25 + 82);
    *((void *)v25 + 82) = v27;

    uint64_t v30 = (uint64_t)(v25 + 32);
    *((_DWORD *)v25 + 168) = 2;
    v25[676] = 0;
    float v31 = *(std::__shared_weak_count **)(a1 + 16);
    *(void *)(a1 + 8) = v25 + 32;
    *(void *)(a1 + 16) = v25;
    if (v31)
    {
      if (!atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
      uint64_t v30 = *(void *)(a1 + 8);
      if (!v30)
      {
LABEL_71:
        if (qword_2697D12D0 != -1) {
          dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
        }
        int64x2_t v47 = (id)qword_2697D12C8;
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        {
          sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::configureVoxelHashingData(const VoxelHashingPipelineConfig &)");
          uint64_t v51 = v108 >= 0 ? __p : *(unsigned char **)__p;
          *(_DWORD *)simd_float4x4 buf = 136315394;
          *(void *)&uint8_t buf[4] = v51;
          __int16 v101 = 1026;
          int v102 = 401;
          _os_log_error_impl(&dword_24B6B9000, v47, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to configure VoxelHashingData.", buf, 0x12u);
          if (SHIBYTE(v108) < 0) {
            operator delete(*(void **)__p);
          }
        }

        operator delete(v19);
        if (qword_2697D12D0 != -1) {
          dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
        }
        uint64_t v4 = (id)qword_2697D12C8;
        if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
          goto LABEL_77;
        }
        sub_24B6F6D14(__p, "virtual VoxelHashingStatus oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::init(const VoxelHashingPipelineConfig &)");
        if (v108 >= 0) {
          int64x2_t v50 = __p;
        }
        else {
          int64x2_t v50 = *(unsigned char **)__p;
        }
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = v50;
        __int16 v101 = 1026;
        int v102 = 70;
        float v6 = "%s:%{public}d Failed to initialize VoxelHashingPipelineGPU - failed to initialize submodules.";
        goto LABEL_88;
      }
    }
    BOOL v32 = v18 > 0;
    if (v24)
    {
      *(float *)v29.i32 = v98 * 8.0;
      v33.i64[0] = 0x3F0000003F000000;
      v33.i64[1] = 0x3F0000003F000000;
      float32x4_t v34 = vdivq_f32(vmulq_f32(v99, v33), (float32x4_t)vdupq_lane_s32(v29, 0));
      v34.i32[3] = 0;
      float32x4_t v35 = vrndpq_f32(v34);
      BOOL v32 = v18 > 0 && v18 == 8 * (int)v35.f32[1] * (int)v35.f32[0] * (int)v35.f32[2];
    }
    BOOL v37 = v16 == 1 || v24 == 0;
    if (v37
      && v32
      && v97
      && HIDWORD(v97)
      && v98 >= 0.0001
      && v99.f32[0] > 0.0
      && (int8x16_t v38 = (int8x16_t)v99,
          v38.i32[0] = vextq_s8(v38, v38, 8uLL).u32[0],
          int32x2_t v39 = vcgtz_f32(*(float32x2_t *)v38.i8),
          (v39.i8[4] & 1) != 0)
      && (v39.i8[0] & 1) != 0
      && ((v40 = sub_24B720600((uint64_t)v19, (uint64_t)(v19 + 4)), v16 != 2) ? (BOOL v43 = v40) : (BOOL v43 = 0), v43))
    {
      if (*(unsigned char *)(v30 + 8))
      {
        if (qword_2697D12E0 != -1) {
          dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
        }
        int64x2_t v44 = (id)qword_2697D12D8;
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          goto LABEL_70;
        }
        sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::init(const InitConfig &)");
        if (v108 >= 0) {
          int32x4_t v45 = __p;
        }
        else {
          int32x4_t v45 = *(unsigned char **)__p;
        }
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = v45;
        __int16 v101 = 1026;
        int v102 = 37;
        int8x16_t v46 = "%s:%{public}d Failed to initialize VoxelHashingDataGPU - already initialized.";
        goto LABEL_99;
      }
      float32x4_t v58 = vmulq_f32((float32x4_t)v95.columns[0], (float32x4_t)0);
      float32x4_t v59 = vmlaq_f32(vmulq_n_f32((float32x4_t)v95.columns[0], v96), (float32x4_t)0, (float32x4_t)v95.columns[1]);
      float32x4_t v60 = vmlaq_n_f32(v58, (float32x4_t)v95.columns[1], v96);
      *(_DWORD *)(v30 + 388) = 2;
      *(_DWORD *)(v30 + 392) = v17;
      *(_DWORD *)(v30 + 384) = v17 >> 1;
      *(_DWORD *)(v30 + 400) = v18;
      if (v18 >= 0x3E8) {
        int v61 = 1000;
      }
      else {
        int v61 = v18;
      }
      *(_DWORD *)(v30 + 404) = v61;
      *(_DWORD *)(v30 + 408) = 1;
      *(float *)v42.i32 = v98 * 8.0;
      v62.i64[0] = 0x3F0000003F000000;
      v62.i64[1] = 0x3F0000003F000000;
      float32x4_t v63 = vdivq_f32(vmulq_f32(v99, v62), (float32x4_t)vdupq_lane_s32(v42, 0));
      v63.i32[3] = 0;
      *(_DWORD *)(v30 + 396) = v17;
      float32x4_t v64 = vrndpq_f32(v63);
      float32x4_t v65 = vaddq_f32(v64, v64);
      *(uint32x2_t *)v65.f32 = vcvt_u32_f32(*(float32x2_t *)v65.f32);
      v65.i32[2] = v65.f32[2];
      *(float32x4_t *)(v30 + 448) = v65;
      LODWORD(v66) = 0;
      HIDWORD(v69) = 0;
      *((float *)&v66 + 1) = 1.0 / v98;
      *(void *)&long long v67 = 0;
      HIDWORD(v67) = 0;
      *((float *)&v67 + 2) = 1.0 / v98;
      *(_OWORD *)(v30 + 64) = COERCE_UNSIGNED_INT(1.0 / v98);
      *(_OWORD *)(v30 + 80) = v66;
      LODWORD(v68) = 0;
      *((float *)&v68 + 1) = v98;
      *(_OWORD *)(v30 + 128) = LODWORD(v98);
      *(_OWORD *)(v30 + 144) = v68;
      LODWORD(v68) = 0;
      *((float *)&v68 + 1) = 1.0 / (float)(v98 * 8.0);
      *(void *)&long long v69 = 0;
      *((float *)&v69 + 2) = *((float *)&v68 + 1);
      v65.i64[0] = 0;
      v65.i64[1] = LODWORD(v98);
      *(float *)(v30 + 56) = v98;
      *(float *)(v30 + 60) = v98 * 8.0;
      float32x4_t v70 = vmlaq_f32(v58, (float32x4_t)0, (float32x4_t)v95.columns[1]);
      *(_OWORD *)(v30 + 96) = v67;
      *(_OWORD *)(v30 + 112) = xmmword_24B72A590;
      *(float32x4_t *)(v30 + 160) = v65;
      *(_OWORD *)(v30 + 176) = xmmword_24B72A590;
      float32x4_t v71 = vmlaq_f32(vmlaq_n_f32(v70, (float32x4_t)v95.columns[2], v96), (float32x4_t)0, (float32x4_t)v95.columns[3]);
      float32x4_t v72 = vaddq_f32((float32x4_t)v95.columns[3], vmlaq_f32(v70, (float32x4_t)0, (float32x4_t)v95.columns[2]));
      *(_OWORD *)(v30 + 192) = HIDWORD(v68);
      *(_OWORD *)(v30 + 208) = v68;
      v70.i32[0] = 0;
      v70.f32[1] = v98 * 8.0;
      v65.i64[0] = 0;
      *(_OWORD *)(v30 + 224) = v69;
      *(_OWORD *)(v30 + 240) = xmmword_24B72A590;
      v65.i64[1] = COERCE_UNSIGNED_INT(v98 * 8.0);
      *(_OWORD *)(v30 + 256) = COERCE_UNSIGNED_INT(v98 * 8.0);
      *(_OWORD *)(v30 + 272) = v70.u64[0];
      *(float32x4_t *)(v30 + 288) = v65;
      *(_OWORD *)(v30 + 304) = xmmword_24B72A590;
      *(float32x4_t *)(v30 + 320) = vmlaq_f32(vmlaq_f32(v59, (float32x4_t)0, (float32x4_t)v95.columns[2]), (float32x4_t)0, (float32x4_t)v95.columns[3]);
      *(float32x4_t *)(v30 + 336) = vmlaq_f32(vmlaq_f32(v60, (float32x4_t)0, (float32x4_t)v95.columns[2]), (float32x4_t)0, (float32x4_t)v95.columns[3]);
      *(float32x4_t *)(v30 + 352) = v71;
      *(float32x4_t *)(v30 + 368) = v72;
      *(_DWORD *)(v30 + 560) = v97;
      *(_DWORD *)(v30 + 564) = 3 * v97;
      *(_DWORD *)(v30 + 568) = HIDWORD(v97);
      *(_DWORD *)(v30 + 640) = v16;
      *(unsigned char *)(v30 + 644) = v94;
      if (*(void *)v30)
      {
        int v73 = *(_DWORD *)(v30 + 384);
        if (v73
          && (unsigned int v74 = *(_DWORD *)(v30 + 392), v75 = *(_DWORD *)(v30 + 388), v75 - 1 < v74)
          && v74 == v75 * v73
          && !(v74 % v75)
          && v17 == v74
          && v18 >= 1
          && v61 - 1 < v18)
        {
          if (sub_24B71E538(v30, v41))
          {
            if (sub_24B71E804(v30))
            {
              sub_24B71F54C(v30);
              id v76 = objc_alloc_init(MEMORY[0x263F12810]);
              float32x4_t v77 = *(void **)(v30 + 32);
              *(void *)(v30 + 32) = v76;

              objc_msgSend_setErrorOptions_(*(void **)(v30 + 32), v78, 1, a1 + 128);
              int64x2_t v44 = objc_msgSend_commandBufferWithDescriptor_(*(void **)(*(void *)v30 + 8), v79, *(void *)(v30 + 32));
              if (v44)
              {
                sub_24B71F73C(v30, v44, v80);
                objc_msgSend_addCompletedHandler_(v44, v81, (uint64_t)&unk_26FE9D6F0);
                objc_msgSend_commit(v44, v82, v83);
                objc_msgSend_waitUntilCompleted(v44, v84, v85);
                if (sub_24B71F80C(v30, 0, (uint64_t)v19)) {
                  sub_24B70E070();
                }
                int32x4_t v90 = sub_24B71F4F8();
                if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_154;
                }
                sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::init(const InitConfig &)");
                if (v108 >= 0) {
                  uint64_t v93 = __p;
                }
                else {
                  uint64_t v93 = *(unsigned char **)__p;
                }
                *(_DWORD *)simd_float4x4 buf = 136315394;
                *(void *)&uint8_t buf[4] = v93;
                __int16 v101 = 1026;
                int v102 = 130;
                float32x4_t v92 = "%s:%{public}d Failed to initialize VoxelHashingDataGPU - failed to update submap transforms.";
              }
              else
              {
                int32x4_t v90 = sub_24B71F4F8();
                if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
                {
LABEL_154:

                  goto LABEL_70;
                }
                sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::init(const InitConfig &)");
                if (v108 >= 0) {
                  float32x4_t v91 = __p;
                }
                else {
                  float32x4_t v91 = *(unsigned char **)__p;
                }
                *(_DWORD *)simd_float4x4 buf = 136315394;
                *(void *)&uint8_t buf[4] = v91;
                __int16 v101 = 1026;
                int v102 = 111;
                float32x4_t v92 = "%s:%{public}d Failed to initialize VoxelHashingDataGPU - failed to create command buffer.";
              }
              _os_log_error_impl(&dword_24B6B9000, v90, OS_LOG_TYPE_ERROR, v92, buf, 0x12u);
              if (SHIBYTE(v108) < 0) {
                operator delete(*(void **)__p);
              }
              goto LABEL_154;
            }
            int64x2_t v44 = sub_24B71F4F8();
            if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
LABEL_70:

              goto LABEL_71;
            }
            sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::init(const InitConfig &)");
            if (v108 >= 0) {
              int32x4_t v89 = __p;
            }
            else {
              int32x4_t v89 = *(unsigned char **)__p;
            }
            *(_DWORD *)simd_float4x4 buf = 136315394;
            *(void *)&uint8_t buf[4] = v89;
            __int16 v101 = 1026;
            int v102 = 100;
            int8x16_t v46 = "%s:%{public}d Failed to initialize VoxelHashingDataGPU - failed to create metal buffers.";
          }
          else
          {
            if (qword_2697D12E0 != -1) {
              dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
            }
            int64x2_t v44 = (id)qword_2697D12D8;
            if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
              goto LABEL_70;
            }
            sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::init(const InitConfig &)");
            if (v108 >= 0) {
              uint64_t v88 = __p;
            }
            else {
              uint64_t v88 = *(unsigned char **)__p;
            }
            *(_DWORD *)simd_float4x4 buf = 136315394;
            *(void *)&uint8_t buf[4] = v88;
            __int16 v101 = 1026;
            int v102 = 94;
            int8x16_t v46 = "%s:%{public}d Failed to initialize VoxelHashingDataGPU - failed to create pipeline states.";
          }
        }
        else
        {
          if (qword_2697D12E0 != -1) {
            dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
          }
          int64x2_t v44 = (id)qword_2697D12D8;
          if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
            goto LABEL_70;
          }
          sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::init(const InitConfig &)");
          if (v108 >= 0) {
            float32x4_t v86 = __p;
          }
          else {
            float32x4_t v86 = *(unsigned char **)__p;
          }
          *(_DWORD *)simd_float4x4 buf = 136315394;
          *(void *)&uint8_t buf[4] = v86;
          __int16 v101 = 1026;
          int v102 = 88;
          int8x16_t v46 = "%s:%{public}d Failed to initialize VoxelHashingDataGPU - hash table params are invalid.";
        }
      }
      else
      {
        if (qword_2697D12E0 != -1) {
          dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
        }
        int64x2_t v44 = (id)qword_2697D12D8;
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          goto LABEL_70;
        }
        sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::init(const InitConfig &)");
        if (v108 >= 0) {
          uint64_t v87 = __p;
        }
        else {
          uint64_t v87 = *(unsigned char **)__p;
        }
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = v87;
        __int16 v101 = 1026;
        int v102 = 82;
        int8x16_t v46 = "%s:%{public}d Failed to initialize VoxelHashingDataGPU - failed to get MTLDeviceContext.";
      }
    }
    else
    {
      if (qword_2697D12E0 != -1) {
        dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
      }
      int64x2_t v44 = (id)qword_2697D12D8;
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        goto LABEL_70;
      }
      sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::init(const InitConfig &)");
      if (v108 >= 0) {
        float v52 = __p;
      }
      else {
        float v52 = *(unsigned char **)__p;
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v52;
      __int16 v101 = 1026;
      int v102 = 31;
      int8x16_t v46 = "%s:%{public}d Failed to initialize VoxelHashingDataGPU - invalid config for VoxelHashingDataGPU.";
    }
LABEL_99:
    _os_log_error_impl(&dword_24B6B9000, v44, OS_LOG_TYPE_ERROR, v46, buf, 0x12u);
    if (SHIBYTE(v108) < 0) {
      operator delete(*(void **)__p);
    }
    goto LABEL_70;
  }
  if (qword_2697D12D0 != -1) {
    dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
  }
  uint64_t v4 = (id)qword_2697D12C8;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "virtual VoxelHashingStatus oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::init(const VoxelHashingPipelineConfig &)");
    int32x4_t v49 = v108 >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = v49;
    __int16 v101 = 1026;
    int v102 = 31;
    _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to initialize VoxelHashingPipelineGPU - invalid config.", buf, 0x12u);
    if (SHIBYTE(v108) < 0) {
      operator delete(*(void **)__p);
    }
  }
  uint64_t v7 = 4;
LABEL_78:

  return v7;
}

void sub_24B71A450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  __cxa_guard_abort(&qword_2697D1358);
  float32x4_t v33 = *(std::__shared_weak_count **)(v31 + 40);
  if (v33)
  {
    if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  sub_24B6ED550((uint64_t)&a31);
  MEMORY[0x24C5D7790](v31, 0x10E1C405E8DB06BLL);
  _Unwind_Resume(a1);
}

void sub_24B71A630(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_24B71A648()
{
  uint64_t v2 = *v1;
  if (*v1)
  {
    uint64_t v3 = *(void *)(v0 + 616);
    uint64_t v4 = *v1;
    if ((void *)v3 != v2)
    {
      do
      {
        v3 -= 104;
        sub_24B71BCD8(v3);
      }
      while ((void *)v3 != v2);
      uint64_t v4 = *v1;
    }
    *(void *)(v0 + 616) = v2;
    operator delete(v4);
  }

  uint64_t v5 = *(void **)(v0 + 448);
  if (v5)
  {
    *(void *)(v0 + 456) = v5;
    operator delete(v5);
  }

  uint64_t v6 = *(void *)(v0 + 48);
  *(void *)(v0 + 48) = 0;
  if (v6)
  {

    MEMORY[0x24C5D7790](v6, 0xE0C40BC9ECFC2);
  }
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)v0);
  operator delete(v7);
  JUMPOUT(0x24B71A770);
}

BOOL sub_24B71A784(uint64_t a1)
{
  float v2 = *(float *)(a1 + 8);
  float v3 = fabsf(v2);
  if (v2 < 0.0 && v3 > 0.000001)
  {
    char v6 = 1;
  }
  else
  {
    BOOL v5 = fabsf(v2 + -1.0) > 0.000011;
    char v6 = v2 > 1.0 && v5;
  }
  BOOL v7 = *(double *)(a1 + 88) <= 0.0 || *(double *)(a1 + 96) <= 0.0;
  float v8 = *(float *)(a1 + 60);
  BOOL v9 = v8 > 1.0 || v8 < 0.0;
  BOOL v11 = *(_DWORD *)(a1 + 200) < *(_DWORD *)(a1 + 204)
     && (float v10 = *(float *)(a1 + 212), v10 > 0.0)
     && v10 < *(float *)(a1 + 216)
     && *(_DWORD *)(a1 + 312)
     && *(_DWORD *)(a1 + 316) != 0;
  if (*(_DWORD *)a1 == 5) {
    return 0;
  }
  int v12 = *(_DWORD *)(a1 + 4);
  if (v12 == 2) {
    char v6 = 1;
  }
  if (v6) {
    return 0;
  }
  float v15 = *(float *)(a1 + 12);
  float v14 = *(float *)(a1 + 16);
  float v16 = fabsf(v15);
  BOOL v17 = v14 > 0.0;
  if (fabsf(v14) <= 0.000001) {
    BOOL v17 = 1;
  }
  BOOL v19 = v16 > 0.000001 && v15 < 0.0 || v14 <= v15;
  BOOL result = 0;
  if (!v19 && v17 && *(float *)(a1 + 32) > 0.0 && *(float *)(a1 + 36) > 0.0 && *(float *)(a1 + 40) > 0.0)
  {
    if (*(_DWORD *)(a1 + 48))
    {
      BOOL result = 0;
      if (*(float *)(a1 + 52) >= 0.0001)
      {
        if (*(unsigned char *)(a1 + 56))
        {
          BOOL v23 = *(float *)(a1 + 64) < 1.0 || *(_DWORD *)(a1 + 72) == 0 || *(_DWORD *)(a1 + 76) == 0;
          if (*(float *)(a1 + 84) < 0.0) {
            BOOL v23 = 1;
          }
          if (v23 || v7 || ((sub_24B6ED600(a1 + 112) ^ 1 | v9) & 1) != 0) {
            return 0;
          }
          if (*(unsigned char *)(a1 + 177)) {
            BOOL v24 = v12 == 1;
          }
          else {
            BOOL v24 = 1;
          }
          return v24 && v11;
        }
      }
    }
  }
  return result;
}

uint64_t sub_24B71A984(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  long long v13 = xmmword_24B72A660;
  uint64x2_t v11 = vcvtq_u64_f64(*(float64x2_t *)(a2 + 88));
  int v12 = 1717855600;
  if ((sub_24B6F6A90(&v11, (CVPixelBufferPoolRef *)(a1 + 72)) & 1) == 0)
  {
    if (qword_2697D12D0 != -1) {
      dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
    }
    BOOL v5 = (id)qword_2697D12C8;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::configureImageBufferPools(const VoxelHashingPipelineConfig &)");
    if (v10 >= 0) {
      char v6 = __p;
    }
    else {
      char v6 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v15 = v6;
    __int16 v16 = 1026;
    int v17 = 452;
    BOOL v7 = "%s:%{public}d Failed to create pixel buffer pool for depth image.";
    goto LABEL_19;
  }
  uint64x2_t v11 = vcvtq_u64_f64(*(float64x2_t *)(a2 + 88));
  int v12 = 1380410945;
  if (sub_24B6F6A90(&v11, (CVPixelBufferPoolRef *)(a1 + 80))) {
    return 1;
  }
  if (qword_2697D12D0 != -1) {
    dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
  }
  BOOL v5 = (id)qword_2697D12C8;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::configureImageBufferPools(const VoxelHashingPipelineConfig &)");
    if (v10 >= 0) {
      float v8 = __p;
    }
    else {
      float v8 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v15 = v8;
    __int16 v16 = 1026;
    int v17 = 462;
    BOOL v7 = "%s:%{public}d Failed to create pixel buffer pool for normal image.";
LABEL_19:
    _os_log_error_impl(&dword_24B6B9000, v5, OS_LOG_TYPE_ERROR, v7, buf, 0x12u);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_14:

  return 0;
}

void sub_24B71ABA8()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  operator new();
}

void sub_24B71B7B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  __cxa_guard_abort(&qword_2697D1358);
  uint64_t v18 = *v16;
  if (*v16)
  {
    if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  sub_24B6ED550((uint64_t)va);
  MEMORY[0x24C5D7790](v15, 0x10E0C40A317B3DBLL);
  _Unwind_Resume(a1);
}

void sub_24B71B830(_Unwind_Exception *a1)
{
  if (v5 < 0) {
    operator delete(v4);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_24B71B87C(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 200) < *(_DWORD *)(a2 + 204))
  {
    float v2 = *(float *)(a2 + 212);
    BOOL v3 = v2 > 0.0 && v2 < *(float *)(a2 + 216);
    if (v3 && *(_DWORD *)(a2 + 312) && *(_DWORD *)(a2 + 316)) {
      operator new();
    }
  }
  if (qword_2697D12D0 != -1) {
    dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
  }
  uint64_t v4 = (id)qword_2697D12C8;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::configureCoverage(const VoxelHashingPipelineConfig &)");
    if (v8 >= 0) {
      char v6 = __p;
    }
    else {
      char v6 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    char v10 = v6;
    __int16 v11 = 1026;
    int v12 = 486;
    _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to configure coverage - invalid coverage config.", buf, 0x12u);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }

  return 0;
}

void sub_24B71BAD8(_Unwind_Exception *a1)
{
  MEMORY[0x24C5D7790](v1, 0x10E0C40FDB0B8DBLL);
  _Unwind_Resume(a1);
}

id sub_24B71BB00()
{
  if (qword_2697D12D0 != -1) {
    dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
  }
  uint64_t v0 = (void *)qword_2697D12C8;
  return v0;
}

BOOL sub_24B71BB54(uint64_t a1)
{
  return *(float *)(a1 + 20) > 0.0
      && *(_DWORD *)a1
      && *(_DWORD *)(a1 + 4) > *(_DWORD *)a1
      && *(float *)(a1 + 8) > 0.0
      && *(float *)(a1 + 12) > 0.0
      && *(float *)(a1 + 16) > 0.0;
}

void sub_24B71BBA8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 608);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 616);
    uint64_t v4 = *(void **)(a1 + 608);
    if (v3 != v2)
    {
      do
      {
        v3 -= 104;
        sub_24B71BCD8(v3);
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 608);
    }
    *(void *)(a1 + 616) = v2;
    operator delete(v4);
  }

  int v5 = *(void **)(a1 + 448);
  if (v5)
  {
    *(void *)(a1 + 456) = v5;
    operator delete(v5);
  }

  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v6)
  {

    JUMPOUT(0x24C5D7790);
  }
}

void sub_24B71BCD8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 48);
  if (v3)
  {
    *(void *)(a1 + 56) = v3;
    operator delete(v3);
  }

  uint64_t v4 = *(void **)a1;
}

void sub_24B71BD4C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9D5D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x24C5D7790);
}

void sub_24B71BDA0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9D5D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_24B71BDC0(uint64_t a1)
{
  sub_24B71BDF8(a1);
  JUMPOUT(0x24C5D7790);
}

uint64_t sub_24B71BDF8(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  *(void *)a1 = &unk_26FE9D518;
  *(void *)(a1 + 8) = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  CVPixelBufferPoolRelease(*(CVPixelBufferPoolRef *)(a1 + 72));
  CVPixelBufferPoolRelease(*(CVPixelBufferPoolRef *)(a1 + 80));
  *(void *)(a1 + 72) = 0;
  if (qword_2697D12D0 != -1) {
    dispatch_once(&qword_2697D12D0, &unk_26FE9D5A0);
  }
  uint64_t v3 = (id)qword_2697D12C8;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    sub_24B6F6D14(__p, "virtual oc::voxel_hashing::VoxelHashingPipelineGPUSubmaps::~VoxelHashingPipelineGPUSubmaps()");
    uint64_t v4 = v17 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    BOOL v19 = v4;
    __int16 v20 = 1026;
    int v21 = 42;
    _os_log_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_DEFAULT, "%s:%{public}d Successfully destroyed VoxelHashingPipelineGPUSubmaps.", buf, 0x12u);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v5 = *(void *)(a1 + 472);
  *(void *)(a1 + 472) = 0;
  if (v5)
  {
    uint64_t v6 = sub_24B6D7E90(v5);
    MEMORY[0x24C5D7790](v6, 0x10E0C40FDB0B8DBLL);
  }
  uint64_t v7 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = 0;
  if (v7)
  {
    uint64_t v8 = sub_24B6F6858(v7);
    MEMORY[0x24C5D7790](v8, 0x10E0C40A317B3DBLL);
  }
  uint64_t v9 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  int v12 = *(void **)(a1 + 48);
  if (v12)
  {
    *(void *)(a1 + 56) = v12;
    operator delete(v12);
  }
  uint64_t v13 = *(void **)(a1 + 24);
  if (v13)
  {
    *(void *)(a1 + 32) = v13;
    operator delete(v13);
  }
  float v14 = *(std::__shared_weak_count **)(a1 + 16);
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  return a1;
}

void sub_24B71C0E0(_Unwind_Exception *a1)
{
  sub_24B71C1C8(v1 + 59);
  sub_24B6F6810(v1 + 15);
  uint64_t v4 = v1[14];
  v1[14] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = v1[13];
  v1[13] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = v1[12];
  v1[12] = 0;
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    uint64_t v7 = (void *)v1[6];
    if (!v7)
    {
LABEL_7:
      uint64_t v8 = (void *)v1[3];
      if (!v8) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v7 = (void *)v1[6];
    if (!v7) {
      goto LABEL_7;
    }
  }
  v1[7] = v7;
  operator delete(v7);
  uint64_t v8 = (void *)v1[3];
  if (!v8)
  {
LABEL_9:
    sub_24B6ED550(v2);
    _Unwind_Resume(a1);
  }
LABEL_8:
  v1[4] = v8;
  operator delete(v8);
  goto LABEL_9;
}

uint64_t *sub_24B71C1C8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = sub_24B6D7E90(v2);
    MEMORY[0x24C5D7790](v3, 0x10E0C40FDB0B8DBLL);
  }
  return a1;
}

float sub_24B71C214@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = a1 + 144;
  uint64_t v5 = *(NSObject **)(a1 + 192);
  uint64_t block = MEMORY[0x263EF8330];
  uint64_t v13 = 3221225472;
  float v14 = sub_24B71C33C;
  uint64_t v15 = &unk_2652DF258;
  uint64_t v16 = v4;
  dispatch_sync(v5, &block);
  uint64_t v6 = *(NSObject **)(a1 + 256);
  uint64_t block = MEMORY[0x263EF8330];
  uint64_t v13 = 3221225472;
  float v14 = sub_24B71C35C;
  uint64_t v15 = &unk_2652DF258;
  uint64_t v16 = a1 + 208;
  dispatch_sync(v6, &block);
  int v7 = *(_DWORD *)(*(void *)(a1 + 144) + 4 * *(void *)(a1 + 184));
  if (v7) {
    uint64_t v8 = *(void *)(*(void *)(a1 + 208) + 24 * *(void *)(a1 + 248));
  }
  else {
    uint64_t v8 = 0;
  }
  float result = *(float *)(a1 + 60);
  long long v10 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a2 + 48) = v10;
  long long v11 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(a2 + 80) = v11;
  *(_DWORD *)a2 = v7;
  *(void *)(a2 + 8) = v8;
  *(float *)(a2 + 16) = result;
  return result;
}

int8x16_t sub_24B71C33C(uint64_t a1)
{
  uint64_t v1 = *(int8x16_t **)(a1 + 32);
  if (v1[3].i8[8])
  {
    int8x16_t result = vextq_s8(v1[2], v1[2], 8uLL);
    v1[2] = result;
    v1[3].i8[8] = 0;
  }
  return result;
}

int8x16_t sub_24B71C35C(uint64_t a1)
{
  uint64_t v1 = *(int8x16_t **)(a1 + 32);
  if (v1[3].i8[8])
  {
    int8x16_t result = vextq_s8(v1[2], v1[2], 8uLL);
    v1[2] = result;
    v1[3].i8[8] = 0;
  }
  return result;
}

void sub_24B71C380(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 128);
  if (*(unsigned char *)v1)
  {
    size_t v3 = *(unsigned int *)(v1 + 4);
    uint64_t v4 = *(void *)(v1 + 48);
    uint64_t v5 = *(void *)(v1 + 64);
    BOOL v6 = !v3 || v4 == 0;
    if (!v6 && v5 != 0)
    {
      atomic_store(0, (unsigned int *)(a1 + 272));
      uint64_t v8 = *(NSObject **)(a1 + 280);
      v15[0] = MEMORY[0x263EF8330];
      v15[1] = 3221225472;
      void v15[2] = sub_24B71C4E8;
      v15[3] = &unk_2652DF218;
      long long v15[4] = a1;
      v15[5] = v4;
      v15[6] = v5;
      dispatch_apply(v3, v8, v15);
      unsigned int v9 = atomic_load((unsigned int *)(a1 + 272));
      uint64_t v12 = *(void *)(a1 + 144);
      long long v11 = (void *)(a1 + 144);
      uint64_t v10 = v12;
      if (*((_DWORD *)v11 - 26) < v9) {
        unsigned int v9 = *((_DWORD *)v11 - 26);
      }
      *(_DWORD *)(v10 + 4 * v11[3]) = v9;
      uint64_t v13 = v11[6];
      uint64_t block = MEMORY[0x263EF8330];
      uint64_t v17 = 3221225472;
      uint64_t v18 = sub_24B71D080;
      BOOL v19 = &unk_2652DF258;
      __int16 v20 = v11;
      dispatch_sync(v13, &block);
      float v14 = v11[14];
      uint64_t block = MEMORY[0x263EF8330];
      uint64_t v17 = 3221225472;
      uint64_t v18 = sub_24B71D09C;
      BOOL v19 = &unk_2652DF258;
      __int16 v20 = v11 + 8;
      dispatch_sync(v14, &block);
    }
  }
}

float32x4_t *sub_24B71C4E8(void *a1, int a2, int8x16_t a3, __n128 a4, double a5, double a6, double a7, __n128 a8)
{
  int v8 = 0;
  uint64_t v123 = *MEMORY[0x263EF8340];
  uint64_t v9 = a1[4];
  uint64_t v10 = a1[5];
  uint64_t v11 = a1[6];
  int v104 = a2 << 9;
  int8x16_t result = &v113;
  float v13 = 0.5;
  __asm { FMOV            V23.2S, #1.0 }
  while (2)
  {
    unsigned int v17 = v8 + v104;
    if ((v8 + v104) >= *(_DWORD *)(*(void *)(v9 + 128) + 4) << 9) {
      goto LABEL_2;
    }
    *(int8x8_t *)a3.i8 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v17), (uint32x2_t)0xFFFFFFFDFFFFFFFALL), (int8x8_t)0x700000007);
    unsigned int v18 = v17 >> 9;
    unint64_t v19 = v11 + 4104 * v18 + ((unint64_t)a3.u32[0] << 9) + ((unint64_t)a3.u32[1] << 6);
    if (!*(unsigned char *)(v19 + 8 * (v8 & 7) + 4)) {
      goto LABEL_2;
    }
    float v20 = *(float *)(v19 + 8 * (v8 & 7));
    if (v20 < -1.732 || v20 > 1.732) {
      goto LABEL_2;
    }
    unsigned int v22 = 0;
    a3.i16[1] = a3.i16[2];
    a3.i16[2] = v8 & 7;
    a4.n128_u64[0] = (unint64_t)vorr_s8((int8x8_t)vshl_n_s16(*(int16x4_t *)(v11 + 4104 * v18 + 4096), 3uLL), *(int8x8_t *)a3.i8);
    *(float *)a3.i32 = (float)a4.n128_i16[0];
    __n128 v105 = a4;
    a4.n128_u32[0] = a4.n128_u16[1];
    a4.n128_u32[1] = a4.n128_u16[2];
    char v103 = (void *)(*(void *)(v9 + 208) + 24 * *(void *)(v9 + 232));
    a4.n128_u64[0] = (unint64_t)vcvt_f32_s32(vshr_n_s32(vshl_n_s32((int32x2_t)a4.n128_u64[0], 0x10uLL), 0x10uLL));
    float32x4_t v23 = (float32x4_t)vextq_s8(vextq_s8(a3, a3, 4uLL), (int8x16_t)a4, 0xCuLL);
    a4.n128_u64[0] = 0x3F0000003F000000;
    a4.n128_u64[1] = 0x3F0000003F000000;
    float32x4_t v24 = vaddq_f32(v23, (float32x4_t)a4);
    unsigned int v25 = *(_DWORD *)(v9 + 12);
    int v26 = *(_DWORD *)(v9 + 16);
    unsigned int v27 = *(_DWORD *)(v9 + 20);
    v28.i64[0] = 0;
    float32x4_t v29 = 0uLL;
    while (2)
    {
      uint64_t v30 = 0;
      float32x4_t v24 = vmlsq_lane_f32(v24, v29, *(float32x2_t *)v28.f32, 0);
      float32x4_t v31 = v24;
      v31.i32[3] = 0;
      float32x4_t v32 = vrndmq_f32(v31);
      int16x4_t v33 = (int16x4_t)vcvt_s32_f32(*(float32x2_t *)v32.f32);
      v33.i16[1] = v33.i16[2];
      float32x4_t v34 = vsubq_f32(v24, v32);
      if (v34.f32[2] >= v13) {
        __int16 v35 = 0;
      }
      else {
        __int16 v35 = -1;
      }
      int8x8_t v36 = (int8x8_t)vcgt_f32((float32x2_t)0x3F0000003F000000, *(float32x2_t *)v34.f32);
      *(int8x8_t *)v32.f32 = v36;
      v32.i16[1] = v36.i16[2];
      v32.i16[2] = v35;
      v33.i16[2] = (int)v32.f32[2];
      *(int16x4_t *)v39.i8 = vadd_s16(*(int16x4_t *)v32.f32, v33);
      *(int16x4_t *)v40.f32 = vadd_s16(*(int16x4_t *)v39.i8, (int16x4_t)0x1000000010000);
      *(int16x4_t *)&long long v37 = vadd_s16(*(int16x4_t *)v39.i8, (int16x4_t)0x100000000);
      *(int16x4_t *)&long long v38 = vadd_s16(*(int16x4_t *)v39.i8, (int16x4_t)0x100010000);
      v39.u64[1] = (unint64_t)vadd_s16(*(int16x4_t *)v39.i8, (int16x4_t)1);
      *(int16x4_t *)&v40.u32[2] = vadd_s16(*(int16x4_t *)v39.i8, (int16x4_t)65537);
      v122[0] = v39;
      v122[1] = v40;
      *((int16x4_t *)&v37 + 1) = vadd_s16(*(int16x4_t *)v39.i8, (int16x4_t)0x100000001);
      *((int16x4_t *)&v38 + 1) = vadd_s16(*(int16x4_t *)v39.i8, (int16x4_t)0x1000100010001);
      v122[2] = v37;
      void v122[3] = v38;
      BOOL v41 = v34.f32[2] >= v13;
      int8x8_t v42 = vmvn_s8(v36);
      v106[0] = 0;
      float32x4_t v121 = 0uLL;
      uint64_t v108 = 0;
      float32x4_t v107 = 0uLL;
      uint64_t v110 = 0;
      float32x4_t v109 = 0uLL;
      uint64_t v112 = 0;
      float32x4_t v111 = 0uLL;
      uint64_t v114 = 0;
      float32x4_t v113 = 0uLL;
      uint64_t v116 = 0;
      float32x4_t v115 = 0uLL;
      uint64_t v118 = 0;
      float32x4_t v117 = 0uLL;
      float32x4_t v119 = 0uLL;
      uint64_t v120 = 0;
      while (2)
      {
        int16x4_t v45 = vshr_n_s16(*(int16x4_t *)((char *)v122 + 8 * v30), 3uLL);
        v39.i32[0] = v45.i16[0];
        a4.n128_u32[0] = v45.u16[1];
        a4.n128_u32[1] = v45.u16[2];
        a4.n128_u64[0] = (unint64_t)vshr_n_s32(vshl_n_s32((int32x2_t)a4.n128_u64[0], 0x10uLL), 0x10uLL);
        int32x4_t v46 = vmulq_s32((int32x4_t)vextq_s8(vextq_s8(v39, v39, 4uLL), (int8x16_t)a4, 0xCuLL), (int32x4_t)xmmword_24B72A710);
        int8x16_t v47 = (int8x16_t)vdupq_laneq_s32(v46, 2);
        int8x16_t v39 = veorq_s8(veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v46.i8, 1), v47), (int8x16_t)v46);
        unsigned int v48 = v39.i32[0] % v25;
        uint64_t v49 = v39.i32[0] % v25 * v26;
        uint64_t v50 = (v49 + v26);
        a4 = 0uLL;
        v39.i64[0] = 0;
        if (v49 >= v50 || v49 >= v27 || v50 > v27)
        {
LABEL_17:
          float v43 = 0.0;
          goto LABEL_18;
        }
        LODWORD(v53) = v27;
        while ((*(_DWORD *)(v10 + 16 * v49 + 12) & 0x80000000) != 0)
        {
LABEL_27:
          if (++v49 == v50)
          {
            if (v27 > v53)
            {
              while (1)
              {
                uint64_t v53 = *(unsigned int *)(v10 + 16 * v53 + 8);
                if (v53 >= v27) {
                  break;
                }
                uint16x4_t v57 = (uint16x4_t)vceq_s16(*(int16x4_t *)(v10 + 16 * v53), v45);
                v57.i16[3] = v57.i16[2];
                if ((vminv_u16(v57) & 0x8000) != 0)
                {
                  uint64_t v58 = v10 + 16 * v53;
                  goto LABEL_44;
                }
              }
            }
            goto LABEL_17;
          }
        }
        v47.i64[0] = *(void *)(v10 + 16 * v49);
        a8.n128_u64[0] = (unint64_t)vceq_s16(*(int16x4_t *)v47.i8, v45);
        a8.n128_u16[3] = a8.n128_u16[2];
        if ((vminv_u16((uint16x4_t)a8.n128_u64[0]) & 0x8000) == 0)
        {
          a8.n128_u32[0] = v47.i16[0];
          v54.i32[0] = v47.u16[1];
          v54.i32[1] = v47.u16[2];
          *(int32x2_t *)v47.i8 = vshr_n_s32(vshl_n_s32(v54, 0x10uLL), 0x10uLL);
          int32x4_t v55 = vmulq_s32((int32x4_t)vextq_s8(vextq_s8((int8x16_t)a8, (int8x16_t)a8, 4uLL), v47, 0xCuLL), (int32x4_t)xmmword_24B72A710);
          a8 = (__n128)veorq_s8((int8x16_t)vdupq_lane_s32(*(int32x2_t *)v55.i8, 1), (int8x16_t)vdupq_laneq_s32(v55, 2));
          int8x16_t v47 = veorq_s8((int8x16_t)a8, (int8x16_t)v55);
          if (v47.i32[0] % v25 == v48 && v53 == v27)
          {
            if (*(_DWORD *)(v10 + 16 * v49 + 8) >= v27) {
              LODWORD(v53) = v27;
            }
            else {
              LODWORD(v53) = v49;
            }
          }
          goto LABEL_27;
        }
        if (v27 <= v49) {
          goto LABEL_17;
        }
        uint64_t v58 = v10 + 16 * v49;
LABEL_44:
        unsigned int v59 = *(_DWORD *)(v58 + 12);
        float v43 = 0.0;
        if ((v59 & 0x80000000) == 0)
        {
          unint64_t v60 = v11
              + 4104 * v59
              + ((*((void *)v122 + v30) & 7) << 9)
              + ((unint64_t)(WORD1(*((void *)v122 + v30)) & 7) << 6)
              + 8 * (HIDWORD(*((void *)v122 + v30)) & 7);
          v39.i32[0] = *(_DWORD *)v60;
          a4.n128_u8[0] = *(unsigned char *)(v60 + 4);
          float v43 = (float)a4.n128_u32[0];
          v61.i32[0] = *(unsigned __int8 *)(v60 + 5);
          v61.i32[1] = *(unsigned __int8 *)(v60 + 6);
          float32x2_t v62 = (float32x2_t)vdup_n_s32(0x437F0000u);
          a4.n128_u64[0] = (unint64_t)vdiv_f32(vcvt_f32_u32(v61), v62);
          v62.i8[0] = *(unsigned char *)(v60 + 7);
          a4.n128_f32[2] = (float)v62.u32[0] / 255.0;
          a4.n128_u32[3] = 1.0;
        }
LABEL_18:
        int64x2_t v44 = (__n128 *)&v106[4 * v30];
        v44->n128_u32[0] = v39.i32[0];
        v44->n128_f32[1] = v43;
        v44->n128_u64[1] = 0;
        v44[1] = a4;
        if (++v30 != 8) {
          continue;
        }
        break;
      }
      float v63 = 0.0;
      if (v34.f32[2] < v13) {
        float v63 = 1.0;
      }
      a4.n128_u64[0] = (unint64_t)vand_s8(v36, _D23);
      *(float32x2_t *)v40.f32 = vcvt_f32_u32((uint32x2_t)vand_s8(v42, (int8x8_t)0x100000001));
      a4.n128_f32[2] = v63;
      v64.i64[0] = 0x3F0000003F000000;
      v64.i64[1] = 0x3F0000003F000000;
      float32x4_t v65 = vmlaq_f32(v34, v64, (float32x4_t)a4);
      v40.f32[2] = (float)v41;
      a3.i64[0] = 0xBF000000BF000000;
      a3.i64[1] = 0xBF000000BF000000;
      float32x4_t v66 = vmlaq_f32(v65, (float32x4_t)a3, v40);
      float v67 = *((float *)v106 + 1);
      if (*((float *)v106 + 1) <= 0.0)
      {
        float v67 = 0.0;
        a8 = 0uLL;
        if (v66.f32[0] > 1.0 || v66.f32[0] < 0.0)
        {
LABEL_58:
          float v69 = 0.0;
        }
        else
        {
          float v69 = 0.0;
          if (*((float *)&v108 + 1) > 0.0)
          {
            a8 = (__n128)v109;
            float v69 = v66.f32[0] * *(float *)&v108;
            float v67 = *((float *)&v108 + 1);
          }
        }
      }
      else
      {
        if (v66.f32[0] < 0.0 || v66.f32[0] > 1.0)
        {
          float v67 = 0.0;
          a8 = 0uLL;
          goto LABEL_58;
        }
        float v70 = 1.0 - v66.f32[0];
        if (*((float *)&v108 + 1) <= 0.0)
        {
          a8 = (__n128)v107;
          float v69 = v70 * *(float *)v106;
        }
        else
        {
          float v69 = (float)(v66.f32[0] * *(float *)&v108) + (float)(*(float *)v106 * v70);
          float v67 = (float)(v66.f32[0] * *((float *)&v108 + 1)) + (float)(*((float *)v106 + 1) * v70);
          a4 = (__n128)v107;
          a8 = (__n128)vmlaq_n_f32(vmulq_n_f32(v109, v66.f32[0]), v107, v70);
        }
      }
      float v71 = *((float *)&v112 + 1);
      if (*((float *)&v112 + 1) <= 0.0)
      {
        float v71 = 0.0;
        float32x4_t v73 = 0uLL;
        if (v66.f32[0] > 1.0 || v66.f32[0] < 0.0)
        {
LABEL_72:
          float v74 = 0.0;
        }
        else
        {
          float v74 = 0.0;
          if (*((float *)&v110 + 1) > 0.0)
          {
            float32x4_t v73 = v111;
            float v74 = v66.f32[0] * *(float *)&v110;
            float v71 = *((float *)&v110 + 1);
          }
        }
      }
      else
      {
        if (v66.f32[0] < 0.0 || v66.f32[0] > 1.0)
        {
          float v71 = 0.0;
          float32x4_t v73 = 0uLL;
          goto LABEL_72;
        }
        float v75 = 1.0 - v66.f32[0];
        if (*((float *)&v110 + 1) <= 0.0)
        {
          float32x4_t v73 = v113;
          float v74 = v75 * *(float *)&v112;
        }
        else
        {
          float v74 = (float)(v66.f32[0] * *(float *)&v110) + (float)(*(float *)&v112 * v75);
          float v71 = (float)(v66.f32[0] * *((float *)&v110 + 1)) + (float)(*((float *)&v112 + 1) * v75);
          a4 = (__n128)v113;
          float32x4_t v73 = vmlaq_n_f32(vmulq_n_f32(v111, v66.f32[0]), v113, v75);
        }
      }
      float v76 = *((float *)&v114 + 1);
      if (*((float *)&v114 + 1) <= 0.0)
      {
        float v76 = 0.0;
        float32x4_t v28 = 0uLL;
        if (v66.f32[0] > 1.0 || v66.f32[0] < 0.0)
        {
LABEL_86:
          float v78 = 0.0;
        }
        else
        {
          float v78 = 0.0;
          if (*((float *)&v116 + 1) > 0.0)
          {
            float32x4_t v28 = v117;
            float v78 = v66.f32[0] * *(float *)&v116;
            float v76 = *((float *)&v116 + 1);
          }
        }
      }
      else
      {
        if (v66.f32[0] < 0.0 || v66.f32[0] > 1.0)
        {
          float v76 = 0.0;
          float32x4_t v28 = 0uLL;
          goto LABEL_86;
        }
        float v79 = 1.0 - v66.f32[0];
        if (*((float *)&v116 + 1) <= 0.0)
        {
          float32x4_t v28 = v115;
          float v78 = v79 * *(float *)&v114;
        }
        else
        {
          float v78 = (float)(v66.f32[0] * *(float *)&v116) + (float)(*(float *)&v114 * v79);
          float v76 = (float)(v66.f32[0] * *((float *)&v116 + 1)) + (float)(*((float *)&v114 + 1) * v79);
          a4 = (__n128)v115;
          float32x4_t v28 = vmlaq_n_f32(vmulq_n_f32(v117, v66.f32[0]), v115, v79);
        }
      }
      float v80 = *((float *)&v120 + 1);
      if (*((float *)&v120 + 1) <= 0.0)
      {
        float v80 = 0.0;
        float32x4_t v82 = 0uLL;
        if (v66.f32[0] > 1.0 || v66.f32[0] < 0.0)
        {
LABEL_100:
          float v83 = 0.0;
        }
        else
        {
          float v83 = 0.0;
          if (*((float *)&v118 + 1) > 0.0)
          {
            float32x4_t v82 = v119;
            float v83 = v66.f32[0] * *(float *)&v118;
            float v80 = *((float *)&v118 + 1);
          }
        }
      }
      else
      {
        if (v66.f32[0] < 0.0 || v66.f32[0] > 1.0)
        {
          float v80 = 0.0;
          float32x4_t v82 = 0uLL;
          goto LABEL_100;
        }
        float v84 = 1.0 - v66.f32[0];
        if (*((float *)&v118 + 1) <= 0.0)
        {
          float32x4_t v82 = v121;
          float v83 = v84 * *(float *)&v120;
        }
        else
        {
          float v83 = (float)(v66.f32[0] * *(float *)&v118) + (float)(*(float *)&v120 * v84);
          float v80 = (float)(v66.f32[0] * *((float *)&v118 + 1)) + (float)(*((float *)&v120 + 1) * v84);
          a4 = (__n128)v121;
          float32x4_t v82 = vmlaq_n_f32(vmulq_n_f32(v119, v66.f32[0]), v121, v84);
        }
      }
      float v85 = 1.0 - v66.f32[1];
      if (v67 <= 0.0)
      {
        float v67 = 0.0;
        a8 = 0uLL;
        if (v66.f32[1] > 1.0 || v66.f32[1] < 0.0)
        {
LABEL_115:
          float v87 = 0.0;
          if (v71 > 0.0) {
            goto LABEL_125;
          }
          goto LABEL_116;
        }
        float v87 = 0.0;
        if (v76 > 0.0)
        {
          float v87 = v66.f32[1] * v78;
          a8 = (__n128)v28;
          float v67 = v76;
          if (v71 > 0.0) {
            goto LABEL_125;
          }
          goto LABEL_116;
        }
LABEL_124:
        if (v71 > 0.0) {
          goto LABEL_125;
        }
LABEL_116:
        float v71 = 0.0;
        float32x4_t v73 = 0uLL;
        if (v66.f32[1] > 1.0 || v66.f32[1] < 0.0)
        {
LABEL_130:
          float v88 = 0.0;
        }
        else
        {
          float v88 = 0.0;
          if (v80 > 0.0)
          {
            float v88 = v66.f32[1] * v83;
            float32x4_t v73 = v82;
            float v71 = v80;
          }
        }
        goto LABEL_134;
      }
      if (v66.f32[1] < 0.0 || v66.f32[1] > 1.0)
      {
        float v67 = 0.0;
        a8 = 0uLL;
        goto LABEL_115;
      }
      if (v76 <= 0.0)
      {
        float v87 = v85 * v69;
        goto LABEL_124;
      }
      float v87 = (float)(v66.f32[1] * v78) + (float)(v69 * v85);
      float v67 = (float)(v66.f32[1] * v76) + (float)(v67 * v85);
      float32x4_t v28 = vmlaq_n_f32(vmulq_lane_f32(v28, *(float32x2_t *)v66.f32, 1), (float32x4_t)a8, v85);
      a8 = (__n128)v28;
      if (v71 <= 0.0) {
        goto LABEL_116;
      }
LABEL_125:
      if (v66.f32[1] < 0.0 || v66.f32[1] > 1.0)
      {
        float v71 = 0.0;
        float32x4_t v73 = 0uLL;
        goto LABEL_130;
      }
      if (v80 <= 0.0)
      {
        float v88 = v85 * v74;
      }
      else
      {
        float v88 = (float)(v66.f32[1] * v83) + (float)(v74 * v85);
        float v71 = (float)(v66.f32[1] * v80) + (float)(v71 * v85);
        float32x4_t v28 = vmlaq_n_f32(vmulq_lane_f32(v82, *(float32x2_t *)v66.f32, 1), v73, v85);
        float32x4_t v73 = v28;
      }
LABEL_134:
      float v90 = 1.0 - v66.f32[2];
      if (v67 <= 0.0)
      {
        float v67 = 0.0;
        a8 = 0uLL;
        if (v66.f32[2] > 1.0 || v66.f32[2] < 0.0)
        {
LABEL_144:
          v28.i64[0] = 0;
        }
        else
        {
          v28.i64[0] = 0;
          if (v71 > 0.0)
          {
            v28.f32[0] = v66.f32[2] * v88;
            a8 = (__n128)v73;
            float v67 = v71;
          }
        }
      }
      else
      {
        if (v66.f32[2] < 0.0 || v66.f32[2] > 1.0)
        {
          float v67 = 0.0;
          a8 = 0uLL;
          goto LABEL_144;
        }
        if (v71 <= 0.0)
        {
          v28.f32[0] = v90 * v87;
        }
        else
        {
          v28.f32[0] = (float)(v66.f32[2] * v88) + (float)(v87 * v90);
          float v67 = (float)(v66.f32[2] * v71) + (float)(v67 * v90);
          a8 = (__n128)vmlaq_n_f32(vmulq_laneq_f32(v73, v66, 2), (float32x4_t)a8, v90);
        }
      }
      a4.n128_f32[0] = (float)(v66.f32[2]
                             * (float)((float)(v66.f32[1] * (float)(*(float *)&v118 - *(float *)&v120))
                                     + (float)(v85 * (float)(*(float *)&v110 - *(float *)&v112))))
                     + (float)(v90
                             * (float)((float)(v66.f32[1] * (float)(*(float *)&v116 - *(float *)&v114))
                                     + (float)(v85 * (float)(*(float *)&v108 - *(float *)v106))));
      if (fabsf(a4.n128_f32[0]) <= 0.000001)
      {
        float v93 = fabsf(v88 - v87);
        float v92 = *(float *)(v9 + 48);
        if (fabsf((float)(v66.f32[2] * (float)(v83 - v74)) + (float)(v90 * (float)(v78 - v69))) > 0.000001
          || v93 > 0.000001)
        {
          float v13 = 0.5;
          if (v67 < v92) {
            goto LABEL_2;
          }
          goto LABEL_157;
        }
        a4.n128_f32[0] = fabsf(v28.f32[0]);
        float v13 = 0.5;
      }
      else
      {
        float v92 = *(float *)(v9 + 48);
        float v13 = 0.5;
        if (v67 < v92) {
          goto LABEL_2;
        }
LABEL_157:
        a4.n128_f32[1] = (float)(v66.f32[2] * (float)(v83 - v74)) + (float)(v90 * (float)(v78 - v69));
        a4.n128_f32[2] = v88 - v87;
        int32x4_t v95 = (int32x4_t)vmulq_f32((float32x4_t)a4, (float32x4_t)a4);
        v95.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v95, 2), vadd_f32(*(float32x2_t *)v95.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v95.i8, 1))).u32[0];
        float32x2_t v96 = vrsqrte_f32((float32x2_t)v95.u32[0]);
        float32x2_t v97 = vmul_f32(v96, vrsqrts_f32((float32x2_t)v95.u32[0], vmul_f32(v96, v96)));
        float32x4_t v29 = vmulq_n_f32((float32x4_t)a4, vmul_f32(v97, vrsqrts_f32((float32x2_t)v95.u32[0], vmul_f32(v97, v97))).f32[0]);
        a4.n128_f32[0] = fabsf(v28.f32[0]);
        if (a4.n128_f32[0] >= 0.01)
        {
          if (v22 <= 8) {
            goto LABEL_12;
          }
        }
        else
        {
          int32x2_t v98 = vcvt_s32_f32(vrndm_f32((float32x2_t)vext_s8(*(int8x8_t *)v24.f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v24, (int8x16_t)v24, 8uLL), 4uLL)));
          v97.i16[0] = vcvtms_s32_f32(v24.f32[0]);
          v97.i16[1] = v98.i16[0];
          v97.i16[2] = v98.i16[2];
          uint16x4_t v99 = (uint16x4_t)vceq_s16((int16x4_t)v97, (int16x4_t)v105.n128_u64[0]);
          v99.i16[3] = v99.i16[2];
          if ((vminv_u16(v99) & 0x8000) == 0 && v22 < 9)
          {
LABEL_12:
            ++v22;
            continue;
          }
        }
      }
      break;
    }
    if (v67 >= v92 && a4.n128_f32[0] < 0.01)
    {
      int32x2_t v100 = vcvt_s32_f32(vrndm_f32((float32x2_t)vext_s8(*(int8x8_t *)v24.f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v24, (int8x16_t)v24, 8uLL), 4uLL)));
      a4.n128_u16[0] = vcvtms_s32_f32(v24.f32[0]);
      a4.n128_u16[1] = v100.i16[0];
      a4.n128_u16[2] = v100.u16[2];
      a3.i64[1] = v105.n128_i64[1];
      *(int16x4_t *)a3.i8 = vceq_s16((int16x4_t)a4.n128_u64[0], (int16x4_t)v105.n128_u64[0]);
      a3.i16[3] = a3.i16[2];
      if ((vminv_u16(*(uint16x4_t *)a3.i8) & 0x8000) != 0)
      {
        unsigned int add = atomic_fetch_add((atomic_uint *volatile)(v9 + 272), 1u);
        if (add < *(_DWORD *)(v9 + 40))
        {
          a8.n128_u32[3] = 1.0;
          v24.i32[3] = 1.0;
          v29.i32[3] = 0;
          uint64_t v102 = *v103 + 48 * add;
          *(float32x4_t *)uint64_t v102 = v24;
          *(float32x4_t *)(v102 + 16) = v29;
          *(__n128 *)(v102 + 32) = a8;
        }
      }
    }
LABEL_2:
    if (++v8 != 512) {
      continue;
    }
    return result;
  }
}

int8x16_t sub_24B71D080(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int8x16_t result = vextq_s8(*(int8x16_t *)(v1 + 24), *(int8x16_t *)(v1 + 24), 8uLL);
  *(int8x16_t *)(v1 + 24) = result;
  *(unsigned char *)(v1 + 56) = 1;
  return result;
}

int8x16_t sub_24B71D09C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int8x16_t result = vextq_s8(*(int8x16_t *)(v1 + 24), *(int8x16_t *)(v1 + 24), 8uLL);
  *(int8x16_t *)(v1 + 24) = result;
  *(unsigned char *)(v1 + 56) = 1;
  return result;
}

BOOL sub_24B71D0B8(uint64_t a1, int *a2)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  if (*a2) {
    BOOL v2 = *((float *)a2 + 1) < 0.0001;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2 || *((unsigned char *)a2 + 8) == 0) {
    return 0;
  }
  float32x4_t v6 = *((float32x4_t *)a2 + 1);
  float32x4_t v7 = *((float32x4_t *)a2 + 2);
  uint64_t v5 = (long long *)(a2 + 4);
  float32x4_t v8 = *((float32x4_t *)a2 + 3);
  float32x4_t v9 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v10 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v11 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v12 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v6, *(float32x2_t *)v6.f32, 1), v7, *(float32x2_t *)v7.f32, 1), v8, *(float32x2_t *)v8.f32, 1), v9)), (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v6, v6.f32[0]), v7, v7.f32[0]),
                                         v8,
                                         v8.f32[0]),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v11, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v6, v6, 2), v7, v7, 2), v8, v8, 2), v10)));
  v12.i32[3] = v12.i32[2];
  if ((vminvq_u32(v12) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v13 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2);
  float32x4_t v14 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v6, (int32x4_t)v8), (int32x4_t)v13);
  float32x4_t v15 = (float32x4_t)vtrn2q_s32((int32x4_t)v6, (int32x4_t)v7);
  v15.i32[2] = HIDWORD(*((void *)a2 + 6));
  float32x4_t v16 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v6, (int32x4_t)v8), (int32x4_t)v7);
  float32x4_t v17 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v18 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1), v15), v13, v14), v9)), (int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v6.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1),
                                           v15),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2),
                                         v14),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v17, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v16, v8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1), v15), (float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), v14), v10)));
  v18.i32[3] = v18.i32[2];
  if ((vminvq_u32(v18) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v21 = vmulq_f32(v6, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL), (int8x16_t)v8, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v7, (int8x16_t)v7, 0xCuLL), (int8x16_t)v7, 8uLL)));
  BOOL v19 = 0;
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0]+ -1.0) <= 0.000011)
  {
    float32x2_t v22 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v6, (int8x16_t)v6, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v7, (int8x16_t)v7, 8uLL)));
    float32x2_t v23 = (float32x2_t)vdup_n_s32(0x38D1B717u);
    uint32x2_t v24 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v23, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v8, (int8x16_t)v8, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*((int8x16_t *)a2 + 4), *((int8x16_t *)a2 + 4), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v23, v22));
    if ((vpmin_u32(v24, v24).u32[0] & 0x80000000) != 0 && a2[20] != 2 && *((float *)a2 + 21) >= 0.0)
    {
      if (*(unsigned char *)(a1 + 8) || !*(void *)(a1 + 128)) {
        return 0;
      }
      int v42 = *a2;
      *(void *)uint64_t v50 = &unk_26FE9D648;
      *(void *)&v50[24] = v50;
      v49[3] = v49;
      v49[0] = &unk_26FE9D648;
      uint64_t v26 = *(void *)(a1 + 144);
      *(void *)uint64_t v26 = 0;
      *(_DWORD *)(v26 + 8) = 0;
      v47[0] = &unk_26FE9D690;
      v47[1] = &v42;
      unsigned int v48 = v47;
      int32x4_t v46 = v45;
      v45[0] = &unk_26FE9D690;
      v45[1] = &v42;
      sub_24B71D7AC((uint64_t)v45, &v43);
      uint64_t v27 = *(void *)(a1 + 208);
      float32x4_t v28 = *(void **)v27;
      if (*(void *)v27)
      {
        *(void *)(v27 + 8) = v28;
        operator delete(v28);
        *(void *)uint64_t v27 = 0;
        *(void *)(v27 + 8) = 0;
        *(void *)(v27 + 16) = 0;
      }
      *(_OWORD *)uint64_t v27 = v43;
      *(void *)(v27 + 16) = v44;
      if (!v46) {
        goto LABEL_40;
      }
      (*(void (**)(long long *__return_ptr))(*v46 + 48))(&v43);
      float32x4_t v29 = *(void **)(a1 + 208);
      uint64_t v30 = (void *)v29[3];
      if (v30)
      {
        v29[4] = v30;
        operator delete(v30);
      }
      *(_OWORD *)(v29 + 3) = v43;
      v29[5] = v44;
      if (!v46)
      {
LABEL_40:
        sub_24B6EC38C();
        _Unwind_Resume(v41);
      }
      (*(void (**)(long long *__return_ptr))(*v46 + 48))(&v43);
      float32x4_t v31 = *(void **)(a1 + 208);
      float32x4_t v32 = (void *)v31[6];
      if (v32)
      {
        v31[7] = v32;
        operator delete(v32);
      }
      *((_OWORD *)v31 + 3) = v43;
      v31[8] = v44;
      if (v46 == v45)
      {
        (*(void (**)(void *))(v45[0] + 32))(v45);
      }
      else if (v46)
      {
        (*(void (**)(void))(*v46 + 40))();
      }
      if (v48 == v47)
      {
        (*(void (**)(void *))(v47[0] + 32))(v47);
      }
      else if (v48)
      {
        (*(void (**)(void))(*v48 + 40))();
      }
      if (*(unsigned char **)&v50[24] == v50)
      {
        (*(void (**)(unsigned char *))(*(void *)v50 + 32))(v50);
      }
      else if (*(void *)&v50[24])
      {
        (*(void (**)(void))(**(void **)&v50[24] + 40))();
      }
      *(_DWORD *)(a1 + 60) = a2[1];
      long long v33 = *v5;
      long long v34 = v5[1];
      long long v35 = v5[3];
      *(_OWORD *)(a1 + 96) = v5[2];
      *(_OWORD *)(a1 + 112) = v35;
      *(_OWORD *)(a1 + 64) = v33;
      *(_OWORD *)(a1 + 80) = v34;
      uint64_t v36 = *(void *)(a1 + 128);
      BOOL v19 = *(unsigned char *)v36 != 0;
      if (*(unsigned char *)v36)
      {
        char v37 = *(unsigned char *)(v36 + 8);
        *(_OWORD *)uint64_t v50 = *(_OWORD *)(v36 + 9);
        *(_OWORD *)&v50[11] = *(_OWORD *)(v36 + 20);
        *(unsigned char *)(a1 + 12) = v37;
        *(_OWORD *)(a1 + 13) = *(_OWORD *)v50;
        unsigned int v38 = *(_DWORD *)&v50[11];
        *(_OWORD *)(a1 + 24) = *(_OWORD *)&v50[11];
        *(_DWORD *)(a1 + 40) = *a2;
        LOBYTE(v38) = *((unsigned char *)a2 + 8);
        *(float *)(a1 + 48) = (float)v38;
        uint64_t v39 = dispatch_get_global_queue(0, 0);
        float32x4_t v40 = *(void **)(a1 + 280);
        *(void *)(a1 + 280) = v39;

        *(unsigned char *)(a1 + 8) = 1;
      }
    }
  }
  return v19;
}

void sub_24B71D680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  sub_24B71D6A4((uint64_t *)va);
  sub_24B71D6A4((uint64_t *)va1);
  sub_24B71D728((void *)(v7 - 96));
  _Unwind_Resume(a1);
}

void *sub_24B71D6A4(void *a1)
{
  BOOL v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_24B71D728(void *a1)
{
  BOOL v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_24B71D7AC(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = **(unsigned int **)(a1 + 8);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  if (v3)
  {
    uint64_t v4 = 48 * v3;
    uint64_t v5 = (char *)operator new(48 * v3);
    *a2 = v5;
    a2[2] = &v5[v4];
    size_t v6 = 48 * ((v4 - 48) / 0x30uLL) + 48;
    bzero(v5, v6);
    a2[1] = &v5[v6];
  }
}

uint64_t sub_24B71D840(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26FE9D690;
  a2[1] = v2;
  return result;
}

void *sub_24B71D864(uint64_t a1)
{
  int8x16_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *int8x16_t result = &unk_26FE9D690;
  result[1] = v3;
  return result;
}

void sub_24B71D8AC()
{
}

uint64_t sub_24B71D8C4()
{
  return 0;
}

void sub_24B71D8D4(uint64_t a1, void *a2)
{
  *a2 = &unk_26FE9D648;
}

void *sub_24B71D8F4()
{
  int8x16_t result = operator new(0x10uLL);
  *int8x16_t result = &unk_26FE9D648;
  return result;
}

void sub_24B71D92C()
{
}

void sub_24B71D944(uint64_t a1)
{
  sub_24B71D97C(a1);
  JUMPOUT(0x24C5D7790);
}

uint64_t sub_24B71D97C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 208);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 216);
    uint64_t v4 = *(void **)(a1 + 208);
    if (v3 != v2)
    {
      uint64_t v5 = *(void *)(a1 + 216);
      do
      {
        uint64_t v7 = *(void **)(v5 - 24);
        v5 -= 24;
        size_t v6 = v7;
        if (v7)
        {
          *(void *)(v3 - 16) = v6;
          operator delete(v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = *(void **)(a1 + 208);
    }
    *(void *)(a1 + 216) = v2;
    operator delete(v4);
  }

  float32x4_t v8 = *(void **)(a1 + 144);
  if (v8)
  {
    *(void *)(a1 + 152) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 136);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return a1;
}

void sub_24B71DA68()
{
}

BOOL sub_24B71DA80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float32x2_t *a6)
{
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = *(_DWORD *)(a4 + 16);
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    return 0;
  }
  float v211 = 0.0;
  uint64_t v210 = 0;
  uint64_t v208 = 0;
  uint64_t v13 = *(float **)a2;
  float32x4_t v14 = *(float **)a2;
  float v15 = (float)v6;
  uint64_t v16 = 3 * v6;
  float32x4_t v17 = *(float **)a4;
  uint32x4_t v18 = *(float **)a4;
  uint64_t v19 = (3 * v7);
  size_t v20 = 4 * v16;
  if (v6 != 1)
  {
    uint64_t v26 = &v13[v20 / 4];
    uint64_t v27 = v14 + 3;
    float v28 = *v14;
    unint64_t v29 = v20 - 24;
    unint64_t v30 = (v20 - 24) / 0xC + 1;
    if (v7 == 1)
    {
      if (v29 >= 0xC)
      {
        float32x4_t v31 = v13 + 6;
        uint64_t v32 = v30 & 0x3FFFFFFFFFFFFFFELL;
        do
        {
          float v33 = *(v31 - 3);
          float v34 = *v31;
          v31 += 6;
          float v28 = (float)(v28 + v33) + v34;
          v32 -= 2;
        }
        while (v32);
        if (v30 == (v30 & 0x3FFFFFFFFFFFFFFELL))
        {
LABEL_17:
          float v21 = v28 / v15;
          *(float *)&uint64_t v210 = v28 / v15;
          float v22 = *v18 / v15;
          *(float *)&uint64_t v208 = v22;
          float v36 = v14[1];
          char v37 = v14 + 4;
          if (v29 >= 0xC)
          {
            unsigned int v38 = v13 + 7;
            uint64_t v39 = v30 & 0x3FFFFFFFFFFFFFFELL;
            do
            {
              float v40 = *(v38 - 3);
              float v41 = *v38;
              v38 += 6;
              float v36 = (float)(v36 + v40) + v41;
              v39 -= 2;
            }
            while (v39);
            if (v30 == (v30 & 0x3FFFFFFFFFFFFFFELL)) {
              goto LABEL_23;
            }
            v37 += 3 * (v30 & 0x3FFFFFFFFFFFFFFELL);
          }
          do
          {
            float v42 = *v37;
            v37 += 3;
            float v36 = v36 + v42;
          }
          while (v37 != &v14[v16 + 1]);
LABEL_23:
          float v24 = v36 / v15;
          *((float *)&v210 + 1) = v36 / v15;
          float v25 = v18[1] / v15;
          *((float *)&v208 + 1) = v25;
          float v44 = v14[2];
          long long v43 = v14 + 2;
          float v23 = v44;
          int16x4_t v45 = v43 + 3;
          if (v29 >= 0xC)
          {
            int32x4_t v46 = v13 + 8;
            uint64_t v47 = v30 & 0x3FFFFFFFFFFFFFFELL;
            do
            {
              float v48 = *(v46 - 3);
              float v49 = *v46;
              v46 += 6;
              float v23 = (float)(v23 + v48) + v49;
              v47 -= 2;
            }
            while (v47);
            if (v30 == (v30 & 0x3FFFFFFFFFFFFFFELL)) {
              goto LABEL_30;
            }
            v45 += 3 * (v30 & 0x3FFFFFFFFFFFFFFELL);
          }
          uint64_t v50 = &v43[v16];
          do
          {
            float v51 = *v45;
            v45 += 3;
            float v23 = v23 + v51;
          }
          while (v45 != v50);
LABEL_30:
          float v52 = v23 / v15;
          float v211 = v23 / v15;
          float v53 = v18[2];
          goto LABEL_89;
        }
        v27 += 3 * (v30 & 0x3FFFFFFFFFFFFFFELL);
      }
      do
      {
        float v35 = *v27;
        v27 += 3;
        float v28 = v28 + v35;
      }
      while (v27 != v26);
      goto LABEL_17;
    }
    if (v29 > 0xB)
    {
      float v79 = v13 + 6;
      uint64_t v80 = v30 & 0x3FFFFFFFFFFFFFFELL;
      do
      {
        float v81 = *(v79 - 3);
        float v82 = *v79;
        v79 += 6;
        float v28 = (float)(v28 + v81) + v82;
        v80 -= 2;
      }
      while (v80);
      if (v30 == (v30 & 0x3FFFFFFFFFFFFFFELL))
      {
LABEL_57:
        float v21 = v28 / v15;
        *(float *)&uint64_t v210 = v28 / v15;
        float v84 = v18 + 3;
        float v85 = *v18;
        unint64_t v86 = 4 * v19 - 24;
        unint64_t v87 = v86 / 0xC + 1;
        if (v86 >= 0xC)
        {
          float v88 = v17 + 6;
          uint64_t v89 = v87 & 0x3FFFFFFFFFFFFFFELL;
          do
          {
            float v90 = *(v88 - 3);
            float v91 = *v88;
            v88 += 6;
            float v85 = (float)(v85 + v90) + v91;
            v89 -= 2;
          }
          while (v89);
          if (v87 == (v87 & 0x3FFFFFFFFFFFFFFELL))
          {
LABEL_63:
            float v22 = v85 / v15;
            *(float *)&uint64_t v208 = v85 / v15;
            float v93 = v14[1];
            char v94 = v14 + 4;
            if (v29 >= 0xC)
            {
              int32x4_t v95 = v13 + 7;
              uint64_t v96 = v30 & 0x3FFFFFFFFFFFFFFELL;
              do
              {
                float v97 = *(v95 - 3);
                float v98 = *v95;
                v95 += 6;
                float v93 = (float)(v93 + v97) + v98;
                v96 -= 2;
              }
              while (v96);
              if (v30 == (v30 & 0x3FFFFFFFFFFFFFFELL))
              {
LABEL_69:
                float v24 = v93 / v15;
                *((float *)&v210 + 1) = v93 / v15;
                float v100 = v18[1];
                __int16 v101 = v18 + 4;
                if (v86 >= 0xC)
                {
                  uint64_t v102 = v17 + 7;
                  uint64_t v103 = v87 & 0x3FFFFFFFFFFFFFFELL;
                  do
                  {
                    float v104 = *(v102 - 3);
                    float v105 = *v102;
                    v102 += 6;
                    float v100 = (float)(v100 + v104) + v105;
                    v103 -= 2;
                  }
                  while (v103);
                  if (v87 == (v87 & 0x3FFFFFFFFFFFFFFELL))
                  {
LABEL_75:
                    float v25 = v100 / v15;
                    *((float *)&v208 + 1) = v100 / v15;
                    float v108 = v14[2];
                    float32x4_t v107 = v14 + 2;
                    float v109 = v108;
                    uint64_t v110 = v107 + 3;
                    if (v29 >= 0xC)
                    {
                      float32x4_t v111 = v13 + 8;
                      uint64_t v112 = v30 & 0x3FFFFFFFFFFFFFFELL;
                      do
                      {
                        float v113 = *(v111 - 3);
                        float v114 = *v111;
                        v111 += 6;
                        float v109 = (float)(v109 + v113) + v114;
                        v112 -= 2;
                      }
                      while (v112);
                      if (v30 == (v30 & 0x3FFFFFFFFFFFFFFELL)) {
                        goto LABEL_82;
                      }
                      v110 += 3 * (v30 & 0x3FFFFFFFFFFFFFFELL);
                    }
                    float32x4_t v115 = &v107[v16];
                    do
                    {
                      float v116 = *v110;
                      v110 += 3;
                      float v109 = v109 + v116;
                    }
                    while (v110 != v115);
LABEL_82:
                    float v52 = v109 / v15;
                    float v211 = v109 / v15;
                    float v118 = v18[2];
                    float32x4_t v117 = v18 + 2;
                    float v53 = v118;
                    float32x4_t v119 = v117 + 3;
                    if (v86 >= 0xC)
                    {
                      uint64_t v120 = v17 + 8;
                      uint64_t v121 = v87 & 0x3FFFFFFFFFFFFFFELL;
                      do
                      {
                        float v122 = *(v120 - 3);
                        float v123 = *v120;
                        v120 += 6;
                        float v53 = (float)(v53 + v122) + v123;
                        v121 -= 2;
                      }
                      while (v121);
                      if (v87 == (v87 & 0x3FFFFFFFFFFFFFFELL)) {
                        goto LABEL_89;
                      }
                      v119 += 3 * (v87 & 0x3FFFFFFFFFFFFFFELL);
                    }
                    id v124 = &v117[v19];
                    do
                    {
                      float v125 = *v119;
                      v119 += 3;
                      float v53 = v53 + v125;
                    }
                    while (v119 != v124);
                    goto LABEL_89;
                  }
                  v101 += 3 * (v87 & 0x3FFFFFFFFFFFFFFELL);
                }
                do
                {
                  float v106 = *v101;
                  v101 += 3;
                  float v100 = v100 + v106;
                }
                while (v101 != &v18[v19 + 1]);
                goto LABEL_75;
              }
              v94 += 3 * (v30 & 0x3FFFFFFFFFFFFFFELL);
            }
            do
            {
              float v99 = *v94;
              v94 += 3;
              float v93 = v93 + v99;
            }
            while (v94 != &v14[v16 + 1]);
            goto LABEL_69;
          }
          v84 += 3 * (v87 & 0x3FFFFFFFFFFFFFFELL);
        }
        do
        {
          float v92 = *v84;
          v84 += 3;
          float v85 = v85 + v92;
        }
        while (v84 != &v17[v19]);
        goto LABEL_63;
      }
      v27 += 3 * (v30 & 0x3FFFFFFFFFFFFFFELL);
    }
    do
    {
      float v83 = *v27;
      v27 += 3;
      float v28 = v28 + v83;
    }
    while (v27 != v26);
    goto LABEL_57;
  }
  float v21 = *v14 / v15;
  *(float *)&uint64_t v210 = v21;
  if (v7 == 1)
  {
    float v22 = *v18 / v15;
    float v23 = v14[2];
    float v24 = v14[1] / v15;
    *((float *)&v210 + 1) = v24;
    float v25 = v18[1] / v15;
    *(float *)&uint64_t v208 = v22;
    *((float *)&v208 + 1) = v25;
    goto LABEL_30;
  }
  int32x2_t v54 = v18 + 3;
  float v55 = *v18;
  unint64_t v56 = 4 * v19 - 24;
  unint64_t v57 = v56 / 0xC + 1;
  if (v56 <= 0xB) {
    goto LABEL_36;
  }
  uint64_t v58 = v17 + 6;
  uint64_t v59 = v57 & 0x3FFFFFFFFFFFFFFELL;
  do
  {
    float v60 = *(v58 - 3);
    float v61 = *v58;
    v58 += 6;
    float v55 = (float)(v55 + v60) + v61;
    v59 -= 2;
  }
  while (v59);
  if (v57 != (v57 & 0x3FFFFFFFFFFFFFFELL))
  {
    v54 += 3 * (v57 & 0x3FFFFFFFFFFFFFFELL);
    do
    {
LABEL_36:
      float v62 = *v54;
      v54 += 3;
      float v55 = v55 + v62;
    }
    while (v54 != &v17[v19]);
  }
  float v22 = v55 / v15;
  *(float *)&uint64_t v208 = v55 / v15;
  float v24 = v14[1] / v15;
  *((float *)&v210 + 1) = v24;
  float v63 = v18[1];
  float32x4_t v64 = v18 + 4;
  if (v56 >= 0xC)
  {
    float32x4_t v65 = v17 + 7;
    uint64_t v66 = v57 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      float v67 = *(v65 - 3);
      float v68 = *v65;
      v65 += 6;
      float v63 = (float)(v63 + v67) + v68;
      v66 -= 2;
    }
    while (v66);
    if (v57 == (v57 & 0x3FFFFFFFFFFFFFFELL)) {
      goto LABEL_43;
    }
    v64 += 3 * (v57 & 0x3FFFFFFFFFFFFFFELL);
  }
  do
  {
    float v69 = *v64;
    v64 += 3;
    float v63 = v63 + v69;
  }
  while (v64 != &v18[v19 + 1]);
LABEL_43:
  float v25 = v63 / v15;
  *((float *)&v208 + 1) = v63 / v15;
  float v52 = v14[2] / v15;
  float v211 = v52;
  float v71 = v18[2];
  float v70 = v18 + 2;
  float v53 = v71;
  float32x4_t v72 = v70 + 3;
  if (v56 >= 0xC)
  {
    float32x4_t v73 = v17 + 8;
    uint64_t v74 = v57 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      float v75 = *(v73 - 3);
      float v76 = *v73;
      v73 += 6;
      float v53 = (float)(v53 + v75) + v76;
      v74 -= 2;
    }
    while (v74);
    if (v57 == (v57 & 0x3FFFFFFFFFFFFFFELL)) {
      goto LABEL_89;
    }
    v72 += 3 * (v57 & 0x3FFFFFFFFFFFFFFELL);
  }
  float32x4_t v77 = &v70[v19];
  do
  {
    float v78 = *v72;
    v72 += 3;
    float v53 = v53 + v78;
  }
  while (v72 != v77);
LABEL_89:
  float v126 = v53 / v15;
  float v209 = v53 / v15;
  memptr[0] = 0;
  malloc_type_posix_memalign(memptr, 0x20uLL, (v20 + 31) & 0x7FFFFFFE0, 0x49090899uLL);
  uint64_t v127 = (char *)memptr[0];
  memcpy(memptr[0], *(const void **)a2, v20);
  int v128 = *(_DWORD *)(a4 + 16);
  memptr[0] = 0;
  malloc_type_posix_memalign(memptr, 0x20uLL, (4 * (3 * v128) + 31) & 0x7FFFFFFE0, 0x49090899uLL);
  uint64_t v129 = (char *)memptr[0];
  if (v128) {
    memcpy(memptr[0], *(const void **)a4, 4 * (3 * v128));
  }
  float v130 = 0.0;
  float v131 = 0.0;
  float v132 = 0.0;
  float v133 = 0.0;
  float v134 = 0.0;
  float v135 = 0.0;
  float v136 = 0.0;
  float v137 = 0.0;
  float v138 = 0.0;
  if (*(_DWORD *)(a2 + 16))
  {
    unsigned int v139 = 0;
    unint64_t v140 = 0;
    do
    {
      uint64_t v143 = 4 * v139;
      int v144 = (float *)(*(void *)a2 + v143);
      uint64_t v145 = (float *)&v127[v143];
      float v146 = *v144 - v21;
      if (*(char **)a2 == v127)
      {
        float v148 = v144[1] - v24;
        float v147 = v144[2] - v52;
        *uint64_t v145 = v146;
        v145[1] = v148;
      }
      else
      {
        *uint64_t v145 = v146;
        v145[1] = v144[1] - v24;
        float v147 = v144[2] - v52;
      }
      v145[2] = v147;
      float64x2_t v149 = (float *)(*(void *)a4 + v143);
      uint64_t v150 = (float *)&v129[v143];
      float v151 = *v149 - v22;
      if (*(char **)a4 == v129)
      {
        float v141 = v149[2];
        float v152 = v149[1] - v25;
        float *v150 = v151;
        v150[1] = v152;
      }
      else
      {
        float *v150 = v151;
        v150[1] = v149[1] - v25;
        float v141 = v149[2];
      }
      v150[2] = v141 - v126;
      ++v140;
      unint64_t v142 = *(unsigned int *)(a2 + 16);
      v139 += 3;
    }
    while (v140 < v142);
    float v130 = 0.0;
    float v131 = 0.0;
    float v132 = 0.0;
    float v133 = 0.0;
    float v134 = 0.0;
    float v135 = 0.0;
    float v136 = 0.0;
    float v137 = 0.0;
    float v138 = 0.0;
    if (v142)
    {
      uint64_t v153 = 0;
      uint64_t v154 = 3 * v142;
      do
      {
        uint64_t v155 = 4 * v153;
        unint64_t v156 = (float *)&v129[v155];
        int64_t v157 = (float *)&v127[v155];
        float v158 = v156[1];
        float v159 = v157[1];
        float v138 = v138 + (float)(*v156 * *v157);
        float v160 = v156[2];
        float v131 = v131 + (float)(*v156 * v159);
        float v137 = v137 + (float)(v158 * *v157);
        float v132 = v132 + (float)(v158 * v159);
        float v161 = v157[2];
        float v134 = v134 + (float)(*v156 * v161);
        float v130 = v130 + (float)(v160 * *v157);
        float v133 = v133 + (float)(v160 * v159);
        float v135 = v135 + (float)(v158 * v161);
        float v136 = v136 + (float)(v160 * v161);
        v153 += 3;
      }
      while (v154 != v153);
    }
  }
  long long v206 = 0u;
  memset(v207, 0, 29);
  long long v205 = 0u;
  memset(memptr, 0, sizeof(memptr));
  *(void *)&v207[5] = 0x300000003;
  *(void *)&v212[0] = __PAIR64__(LODWORD(v137), LODWORD(v138));
  *((void *)&v212[0] + 1) = __PAIR64__(LODWORD(v131), LODWORD(v130));
  *(void *)&v212[1] = __PAIR64__(LODWORD(v133), LODWORD(v132));
  *((void *)&v212[1] + 1) = __PAIR64__(LODWORD(v135), LODWORD(v134));
  float v213 = v136;
  sub_24B6EC49C((uint64_t)memptr);
  uint64_t v199 = 0;
  uint64_t v200 = 0x3F80000000000000;
  int v202 = 0;
  uint64_t v201 = 0;
  int v198 = 1065353216;
  float v162 = (float)((float)((float)(*((float *)&v205 + 1) * *((float *)memptr + 1)) + 0.0)
               + (float)(*((float *)&v205 + 2) * *(float *)&memptr[2]))
       + (float)(*((float *)&v205 + 3) * *((float *)&memptr[3] + 1));
  float v163 = (float)((float)((float)(*(float *)&v206 * *((float *)memptr + 1)) + 0.0)
               + (float)(*((float *)&v206 + 1) * *(float *)&memptr[2]))
       + (float)(*((float *)&v206 + 2) * *((float *)&memptr[3] + 1));
  float v164 = (float)((float)((float)(*((float *)&v206 + 3) * *((float *)memptr + 1)) + 0.0)
               + (float)(v207[0] * *(float *)&memptr[2]))
       + (float)(v207[1] * *((float *)&memptr[3] + 1));
  float v165 = (float)((float)((float)(*((float *)&v205 + 1) * *(float *)&memptr[1]) + 0.0)
               + (float)(*((float *)&v205 + 2) * *((float *)&memptr[2] + 1)))
       + (float)(*((float *)&v205 + 3) * *(float *)&v205);
  float v166 = (float)((float)((float)(*(float *)&v206 * *(float *)&memptr[1]) + 0.0)
               + (float)(*((float *)&v206 + 1) * *((float *)&memptr[2] + 1)))
       + (float)(*((float *)&v206 + 2) * *(float *)&v205);
  float v167 = (float)((float)((float)(*((float *)&v206 + 3) * *(float *)&memptr[1]) + 0.0)
               + (float)(v207[0] * *((float *)&memptr[2] + 1)))
       + (float)(v207[1] * *(float *)&v205);
  float v203 = (float)((float)((float)((float)((float)(*((float *)&v206 + 3) * *(float *)memptr) + 0.0)
                               + (float)(v207[0] * *((float *)&memptr[1] + 1)))
                       + (float)(v207[1] * *(float *)&memptr[3]))
               * (float)((float)(v166 * v162) - (float)(v163 * v165)))
       + (float)((float)((float)((float)((float)((float)(*((float *)&v205 + 1) * *(float *)memptr) + 0.0)
                                       + (float)(*((float *)&v205 + 2) * *((float *)&memptr[1] + 1)))
                               + (float)(*((float *)&v205 + 3) * *(float *)&memptr[3]))
                       * (float)((float)(v167 * v163) - (float)(v164 * v166)))
               - (float)((float)((float)((float)((float)(*(float *)&v206 * *(float *)memptr) + 0.0)
                                       + (float)(*((float *)&v206 + 1) * *((float *)&memptr[1] + 1)))
                               + (float)(*((float *)&v206 + 2) * *(float *)&memptr[3]))
                       * (float)((float)(v167 * v162) - (float)(v164 * v165))));
  uint64_t v191 = (char *)&v205 + 4;
  uint64_t v192 = (float32x2_t *)&v191;
  int16x4_t v193 = &v198;
  float v213 = 0.0;
  memset(v212, 0, sizeof(v212));
  *(__n64 *)v168.i8 = sub_24B711E54((uint64_t)v212, (uint64_t)&v192);
  v168.i32[0] = DWORD2(v212[0]);
  v169.i32[0] = DWORD1(v212[1]);
  *(float *)v170.i32 = v213;
  v171.i64[0] = (uint64_t)memptr[0];
  float32x4_t v172 = (float32x4_t)vzip1q_s32(v171, vdupq_lane_s32((int32x2_t)memptr[0], 1));
  v173.i64[0] = *(uint64_t *)((char *)&memptr[1] + 4);
  float32x4_t v174 = (float32x4_t)vzip1q_s32(v173, vdupq_lane_s32(*(int32x2_t *)((char *)&memptr[1] + 4), 1));
  v175.i64[0] = (uint64_t)memptr[3];
  v176.i64[0] = *(void *)&v212[0];
  v177.i64[0] = *(void *)((char *)v212 + 12);
  v178.i64[0] = *((void *)&v212[1] + 1);
  float32x2_t v179 = vmla_n_f32(vmla_n_f32(vmla_n_f32(0, *(float32x2_t *)&v212[0], *(float *)memptr), *(float32x2_t *)((char *)v212 + 12), *((float *)&memptr[1] + 1)), *(float32x2_t *)((char *)&v212[1] + 8), *(float *)&memptr[3]);
  float32x2_t v194 = v179;
  float32x4_t v180 = (float32x4_t)vextq_s8(vextq_s8(v168, v168, 4uLL), v176, 0xCuLL);
  v180.i32[3] = v180.i32[0];
  float32x4_t v181 = vmlaq_f32((float32x4_t)0, v172, v180);
  float32x4_t v182 = (float32x4_t)vextq_s8(vextq_s8(v169, v169, 4uLL), v177, 0xCuLL);
  v182.i32[3] = v182.i32[0];
  float32x4_t v183 = vmlaq_f32(v181, v174, v182);
  float32x4_t v184 = (float32x4_t)vextq_s8(vextq_s8(v170, v170, 4uLL), v178, 0xCuLL);
  v184.i32[3] = v184.i32[0];
  long long v190 = (__int128)vmlaq_f32(v183, (float32x4_t)vzip1q_s32(v175, vdupq_lane_s32((int32x2_t)memptr[3], 1)), v184);
  long long v195 = v190;
  float32x2_t v185 = vmla_n_f32(vmla_n_f32(vmla_n_f32(0, *(float32x2_t *)&v212[0], *(float *)&memptr[1]), *(float32x2_t *)((char *)v212 + 12), *((float *)&memptr[2] + 1)), *(float32x2_t *)((char *)&v212[1] + 8), *(float *)&v205);
  float32x2_t v196 = v185;
  float v186 = (float)((float)((float)(*((float *)v212 + 2) * *(float *)&memptr[1]) + 0.0)
               + (float)(*((float *)&v212[1] + 1) * *((float *)&memptr[2] + 1)))
       + (float)(v213 * *(float *)&v205);
  float v197 = v186;
  uint64_t v192 = &v194;
  int16x4_t v193 = (int *)&v208;
  *(void *)&v212[0] = &v210;
  *((void *)&v212[0] + 1) = 0;
  LODWORD(v212[1]) = 0;
  sub_24B6CE324((float *)v212 + 2, (float **)&v192);
  float32_t v187 = *(float *)(*(void *)&v212[0] + 8) - *(float *)&v212[1];
  float32x2_t v188 = vsub_f32(**(float32x2_t **)&v212[0], *(float32x2_t *)((char *)v212 + 8));
  *a6 = v179;
  a6[1] = (float32x2_t)v190;
  a6[2] = (float32x2_t)(v190 >> 32);
  a6[3].i32[0] = HIDWORD(v190);
  a6[3].i32[1] = 0;
  a6[4] = v185;
  a6[5].f32[0] = v186;
  a6[5].i32[1] = 0;
  a6[6] = v188;
  a6[7].f32[0] = v187;
  a6[7].i32[1] = 1065353216;
  BOOL v9 = sub_24B711914((float **)a6);
  free(v129);
  free(v127);
  return v9;
}

uint64_t sub_24B71E538(uint64_t a1, const char *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v3 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)a1 + 16), a2, @"oc::voxel_hashing::resetHashEntries");
  if (!v3)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    uint64_t v11 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createPipelineStates()");
      uint64_t v13 = (v30 & 0x80000000) == 0 ? __p : *(unsigned char **)__p;
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v13;
      __int16 v23 = 1026;
      int v24 = 520;
      _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find resetHashEntries compute shader.", buf, 0x12u);
      if (SBYTE3(v30) < 0) {
        operator delete(*(void **)__p);
      }
    }
    id v7 = 0;
    goto LABEL_11;
  }
  id v4 = **(id **)a1;
  id v21 = 0;
  uint64_t v6 = objc_msgSend_newComputePipelineStateWithFunction_error_(v4, v5, (uint64_t)v3, &v21);
  id v7 = v21;
  BOOL v9 = *(void **)(a1 + 24);
  BOOL v8 = (uint64_t *)(a1 + 24);
  uint64_t *v8 = v6;

  if (!*v8)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    uint64_t v11 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createPipelineStates()");
      int v14 = v25;
      float v15 = *(unsigned char **)buf;
      uint64_t v18 = objc_msgSend_localizedDescription(v7, v16, v17);
      uint64_t v19 = (void *)v18;
      if (v14 >= 0) {
        size_t v20 = buf;
      }
      else {
        size_t v20 = v15;
      }
      *(_DWORD *)simd_float4x4 __p = 136315650;
      *(void *)&__p[4] = v20;
      __int16 v27 = 1026;
      int v28 = 527;
      __int16 v29 = 2114;
      uint64_t v30 = v18;
      _os_log_error_impl(&dword_24B6B9000, v11, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for resetHashEntries compute shader. Error details: %{public}@", __p, 0x1Cu);

      if (v25 < 0) {
        operator delete(*(void **)buf);
      }
    }
LABEL_11:

    uint64_t v10 = 0;
    goto LABEL_12;
  }
  uint64_t v10 = 1;
LABEL_12:

  return v10;
}

void sub_24B71E7CC(_Unwind_Exception *a1)
{
  if (v5 < 0) {
    operator delete(v4);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_24B71E804(uint64_t a1)
{
  uint64_t v101 = *MEMORY[0x263EF8340];
  vm_size_t v92 = 0;
  host_t v2 = MEMORY[0x24C5D7A70]();
  host_page_size(v2, &v92);
  *(void *)(a1 + 40) = (v92 + 24 * *(unsigned int *)(a1 + 396) + 1) / v92 * v92;
  id v3 = **(id **)a1;
  uint64_t v5 = objc_msgSend_newBufferWithLength_options_(v3, v4, *(void *)(a1 + 40), 0);
  uint64_t v6 = *(void **)(a1 + 464);
  *(void *)(a1 + 464) = v5;

  BOOL v8 = *(void **)(a1 + 464);
  if (!v8)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    float32x4_t v73 = (id)qword_2697D12D8;
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_71;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createBuffers(const InitConfig &)");
    uint64_t v74 = v95 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v98 = v74;
    __int16 v99 = 1026;
    int v100 = 548;
    _os_log_error_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create hashEntries buffer.", buf, 0x12u);
    if ((v95 & 0x80000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_66;
  }
  objc_msgSend_setLabel_(v8, v7, @"HashEntries Buffer");
  *(void *)(a1 + 48) = (v92 + 17368 * *(unsigned int *)(a1 + 400) + 1) / v92 * v92;
  id v9 = **(id **)a1;
  uint64_t v11 = objc_msgSend_newBufferWithLength_options_(v9, v10, *(void *)(a1 + 48), 0);
  uint64_t v12 = *(void **)(a1 + 472);
  *(void *)(a1 + 472) = v11;

  int v14 = *(void **)(a1 + 472);
  if (!v14)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    float32x4_t v73 = (id)qword_2697D12D8;
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_71;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createBuffers(const InitConfig &)");
    float v75 = v95 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v98 = v75;
    __int16 v99 = 1026;
    int v100 = 560;
    _os_log_error_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create voxelBlocks buffer.", buf, 0x12u);
    if ((v95 & 0x80000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_66;
  }
  objc_msgSend_setLabel_(v14, v13, @"VoxelBlocks Buffer");
  id v15 = **(id **)a1;
  uint64_t v17 = objc_msgSend_newBufferWithLength_options_(v15, v16, 4, 0);
  uint64_t v18 = *(void **)(a1 + 480);
  *(void *)(a1 + 480) = v17;

  size_t v20 = *(void **)(a1 + 480);
  if (!v20)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    float32x4_t v73 = (id)qword_2697D12D8;
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_71;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createBuffers(const InitConfig &)");
    float v76 = v95 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v98 = v76;
    __int16 v99 = 1026;
    int v100 = 569;
    _os_log_error_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create nextAvailableVoxelBlockIdx buffer.", buf, 0x12u);
    if ((v95 & 0x80000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_66;
  }
  objc_msgSend_setLabel_(v20, v19, @"NextAvailableVoxelBlockIdx Buffer");
  *(_DWORD *)objc_msgSend_contents(*(void **)(a1 + 480), v21, v22) = 0;
  uint64_t v23 = 4 * *(unsigned int *)(a1 + 404);
  id v24 = **(id **)a1;
  uint64_t v26 = objc_msgSend_newBufferWithLength_options_(v24, v25, v23, 0);
  __int16 v27 = *(void **)(a1 + 488);
  *(void *)(a1 + 488) = v26;

  __int16 v29 = *(void **)(a1 + 488);
  if (!v29)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    float32x4_t v73 = (id)qword_2697D12D8;
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_71;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createBuffers(const InitConfig &)");
    float32x4_t v77 = v95 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v98 = v77;
    __int16 v99 = 1026;
    int v100 = 582;
    _os_log_error_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create voxelBlocksFreeStack buffer.", buf, 0x12u);
    if ((v95 & 0x80000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_66;
  }
  objc_msgSend_setLabel_(v29, v28, @"VoxelBlocksFreeStack Buffer");
  id v30 = **(id **)a1;
  uint64_t v32 = objc_msgSend_newBufferWithLength_options_(v30, v31, 4, 0);
  float v33 = *(void **)(a1 + 496);
  *(void *)(a1 + 496) = v32;

  float v35 = *(void **)(a1 + 496);
  if (!v35)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    float32x4_t v73 = (id)qword_2697D12D8;
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_71;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createBuffers(const InitConfig &)");
    float v85 = v95 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v98 = v85;
    __int16 v99 = 1026;
    int v100 = 591;
    _os_log_error_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create voxelBlocksFreeStackTop buffer.", buf, 0x12u);
    if ((v95 & 0x80000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_66;
  }
  objc_msgSend_setLabel_(v35, v34, @"VoxelBlocksFreeStackTop Buffer");
  *(_DWORD *)objc_msgSend_contents(*(void **)(a1 + 496), v36, v37) = -1;
  id v38 = **(id **)a1;
  uint64_t v40 = objc_msgSend_newBufferWithLength_options_(v38, v39, 12 * *(unsigned int *)(a1 + 392), 0);
  float v41 = *(void **)(a1 + 504);
  *(void *)(a1 + 504) = v40;

  long long v43 = *(void **)(a1 + 504);
  if (!v43)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    float32x4_t v73 = (id)qword_2697D12D8;
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_71;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createBuffers(const InitConfig &)");
    unint64_t v86 = v95 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v98 = v86;
    __int16 v99 = 1026;
    int v100 = 605;
    _os_log_error_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create updatedAndErasableHashEntries buffer.", buf, 0x12u);
    if ((v95 & 0x80000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_66;
  }
  objc_msgSend_setLabel_(v43, v42, @"UpdatedAndErasableHashEntries Buffer");
  id v44 = **(id **)a1;
  uint64_t v46 = objc_msgSend_newBufferWithLength_options_(v44, v45, 4, 0);
  uint64_t v47 = *(void **)(a1 + 512);
  *(void *)(a1 + 512) = v46;

  float v49 = *(void **)(a1 + 512);
  if (!v49)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    float32x4_t v73 = (id)qword_2697D12D8;
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_71;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createBuffers(const InitConfig &)");
    unint64_t v87 = v95 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v98 = v87;
    __int16 v99 = 1026;
    int v100 = 614;
    _os_log_error_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create numUpdatedAndErasableHashEntries buffer.", buf, 0x12u);
    if ((v95 & 0x80000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_66;
  }
  objc_msgSend_setLabel_(v49, v48, @"NumUpdatedAndErasableHashEntries Buffer");
  *(_DWORD *)objc_msgSend_contents(*(void **)(a1 + 512), v50, v51) = 0;
  id v52 = **(id **)a1;
  uint64_t v54 = objc_msgSend_newBufferWithLength_options_(v52, v53, 12 * *(unsigned int *)(a1 + 392), 0);
  float v55 = *(void **)(a1 + 520);
  *(void *)(a1 + 520) = v54;

  unint64_t v57 = *(void **)(a1 + 520);
  if (!v57)
  {
    float32x4_t v73 = sub_24B71F4F8();
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_71;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createBuffers(const InitConfig &)");
    float v88 = v95 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v98 = v88;
    __int16 v99 = 1026;
    int v100 = 626;
    _os_log_error_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create updatedHashEntries buffer.", buf, 0x12u);
    if ((v95 & 0x80000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_66;
  }
  objc_msgSend_setLabel_(v57, v56, @"UpdatedHashEntries Buffer");
  id v58 = **(id **)a1;
  uint64_t v60 = objc_msgSend_newBufferWithLength_options_(v58, v59, 4, 0);
  float v61 = *(void **)(a1 + 528);
  *(void *)(a1 + 528) = v60;

  float v63 = *(void **)(a1 + 528);
  if (!v63)
  {
    float32x4_t v73 = sub_24B71F4F8();
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_71;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createBuffers(const InitConfig &)");
    uint64_t v89 = v95 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v98 = v89;
    __int16 v99 = 1026;
    int v100 = 635;
    _os_log_error_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create numUpdatedHashEntries buffer.", buf, 0x12u);
    if ((v95 & 0x80000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_66;
  }
  objc_msgSend_setLabel_(v63, v62, @"NumUpdatedHashEntries Buffer");
  *(_DWORD *)objc_msgSend_contents(*(void **)(a1 + 528), v64, v65) = 0;
  id v66 = **(id **)a1;
  uint64_t v68 = objc_msgSend_newBufferWithLength_options_(v66, v67, (unint64_t)*(unsigned int *)(a1 + 408) << 8, 0);
  float v69 = *(void **)(a1 + 544);
  *(void *)(a1 + 544) = v68;

  float v71 = *(void **)(a1 + 544);
  if (!v71)
  {
    float32x4_t v73 = sub_24B71F4F8();
    if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
      goto LABEL_71;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createBuffers(const InitConfig &)");
    float v90 = v95 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v98 = v90;
    __int16 v99 = 1026;
    int v100 = 646;
    _os_log_error_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create submapsData buffer.", buf, 0x12u);
    if ((v95 & 0x80000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_66;
  }
  objc_msgSend_setLabel_(v71, v70, @"SubmapsData Buffer");
  if (*(unsigned char *)(a1 + 644)) {
    uint64_t v72 = 30852 * *(unsigned int *)(a1 + 400);
  }
  else {
    uint64_t v72 = 1;
  }
  id v78 = **(id **)a1;
  uint64_t v80 = objc_msgSend_newBufferWithLength_options_(v78, v79, v72, 0);
  float v81 = *(void **)(a1 + 552);
  *(void *)(a1 + 552) = v80;

  float v83 = *(void **)(a1 + 552);
  if (v83)
  {
    objc_msgSend_setLabel_(v83, v82, @"TriangleFacesInVoxelBlocks Buffer");
    __p[0] = &unk_26FE9D740;
    __p[1] = (void *)a1;
    uint64_t v96 = __p;
    sub_24B71FBE0((uint64_t)v93, (uint64_t)__p);
    sub_24B71FC78((uint64_t *)(a1 + 576), (uint64_t)v93);
    sub_24B71FE3C(v93);
    sub_24B71FE3C(__p);
    return 1;
  }
  float32x4_t v73 = sub_24B71F4F8();
  if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::createBuffers(const InitConfig &)");
    float v91 = v95 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float v98 = v91;
    __int16 v99 = 1026;
    int v100 = 662;
    _os_log_error_impl(&dword_24B6B9000, v73, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create triangleFacesInVoxelBlocks buffer.", buf, 0x12u);
    if (v95 < 0) {
LABEL_66:
    }
      operator delete(__p[0]);
  }
LABEL_71:

  return 0;
}

void sub_24B71F444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_24B71FE3C((uint64_t *)va);
  sub_24B71FE3C((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void sub_24B71F468(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_24B71F4F8()
{
  if (qword_2697D12E0 != -1) {
    dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
  }
  uint64_t v0 = (void *)qword_2697D12D8;
  return v0;
}

void sub_24B71F54C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 408))
  {
    unsigned int v2 = 0;
    id v3 = *(char **)(a1 + 424);
    while (1)
    {
      int v5 = *(_DWORD *)(a1 + 392);
      uint64_t v6 = v5 * v2++;
      uint64_t v7 = v5 * v2;
      unint64_t v8 = *(void *)(a1 + 432);
      if ((unint64_t)v3 >= v8) {
        break;
      }
      *(void *)id v3 = v6 | (v7 << 32);
      uint64_t v4 = v3 + 8;
LABEL_4:
      *(void *)(a1 + 424) = v4;
      id v3 = v4;
      if (v2 >= *(_DWORD *)(a1 + 408)) {
        return;
      }
    }
    id v9 = *(char **)(a1 + 416);
    uint64_t v10 = (v3 - v9) >> 3;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 61) {
      abort();
    }
    uint64_t v12 = v8 - (void)v9;
    if (v12 >> 2 > v11) {
      unint64_t v11 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      if (v13 >> 61) {
        sub_24B6BCD7C();
      }
      int v14 = operator new(8 * v13);
    }
    else
    {
      int v14 = 0;
    }
    id v15 = (uint64_t *)&v14[8 * v10];
    uint64_t *v15 = v6 | (v7 << 32);
    uint64_t v4 = (char *)(v15 + 1);
    if (v3 == v9)
    {
      id v9 = v3;
    }
    else
    {
      unint64_t v16 = v3 - 8 - v9;
      if (v16 < 0x168)
      {
        uint64_t v17 = v3;
        goto LABEL_29;
      }
      if (&v14[v3 - v9 - 8 - (v16 & 0xFFFFFFFFFFFFFFF8)] > &v14[v3 - v9 - 8])
      {
        uint64_t v17 = v3;
        goto LABEL_29;
      }
      if (&v3[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] > v3 - 8)
      {
        uint64_t v17 = v3;
        goto LABEL_29;
      }
      if ((unint64_t)(v9 - v14) < 0x20)
      {
        uint64_t v17 = v3;
        goto LABEL_29;
      }
      uint64_t v18 = (v16 >> 3) + 1;
      uint64_t v17 = &v3[-8 * (v18 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v19 = &v14[8 * v10 - 16];
      size_t v20 = v3 - 16;
      uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v22 = *(_OWORD *)v20;
        *(v19 - 1) = *((_OWORD *)v20 - 1);
        _OWORD *v19 = v22;
        v19 -= 2;
        v20 -= 32;
        v21 -= 4;
      }
      while (v21);
      v15 -= v18 & 0x3FFFFFFFFFFFFFFCLL;
      if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL))
      {
        do
        {
LABEL_29:
          uint64_t v23 = *((void *)v17 - 1);
          v17 -= 8;
          *--id v15 = v23;
        }
        while (v17 != v9);
        id v9 = *(char **)(a1 + 416);
      }
    }
    *(void *)(a1 + 416) = v15;
    *(void *)(a1 + 424) = v4;
    *(void *)(a1 + 432) = &v14[8 * v13];
    if (v9) {
      operator delete(v9);
    }
    goto LABEL_4;
  }
}

void sub_24B71F73C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = objc_msgSend_computeCommandEncoder(a2, (const char *)a2, a3);
  objc_msgSend_setLabel_(v4, v5, @"ResetHashEntries Encoder");
  objc_msgSend_setComputePipelineState_(v4, v6, *(void *)(a1 + 24));
  objc_msgSend_setBytes_length_atIndex_(v4, v7, a1 + 384, 28, 0);
  objc_msgSend_setBuffer_offset_atIndex_(v4, v8, *(void *)(a1 + 464), 0, 1);
  uint64_t v11 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 24), v9, v10);
  uint64_t v17 = *(unsigned int *)(a1 + 396);
  int64x2_t v18 = vdupq_n_s64(1uLL);
  uint64_t v15 = v11;
  int64x2_t v16 = v18;
  objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v4, v12, (uint64_t)&v17, &v15);
  objc_msgSend_endEncoding(v4, v13, v14);
}

void sub_24B71F7F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B71F80C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 408) <= a2) {
    return 0;
  }
  v5.columns[0] = *(simd_float4 *)a3;
  v5.columns[1] = *(simd_float4 *)(a3 + 16);
  v5.columns[2] = *(simd_float4 *)(a3 + 32);
  float32x4_t v4 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  v5.columns[3] = *(simd_float4 *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v6 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v7 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v6, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32((float32x4_t)v5.columns[0], *(float32x2_t *)v5.columns[0].f32, 1), (float32x4_t)v5.columns[1], *(float32x2_t *)v5.columns[1].f32, 1), (float32x4_t)v5.columns[2], *(float32x2_t *)v5.columns[2].f32, 1), v4)), (int8x16_t)vcgeq_f32(v6,
                                    vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)v5.columns[0], v5.columns[0].f32[0]), (float32x4_t)v5.columns[1], v5.columns[1].f32[0]), (float32x4_t)v5.columns[2], v5.columns[2].f32[0]), *MEMORY[0x263EF89A0]))), (int8x16_t)vcgeq_f32(v6, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32((float32x4_t)v5.columns[0], (float32x4_t)v5.columns[0], 2), (float32x4_t)v5.columns[1], (float32x4_t)v5.columns[1], 2), (float32x4_t)v5.columns[2], (float32x4_t)v5.columns[2],
                                      2),
                                    (float32x4_t)v5.columns[3])));
  v7.i32[3] = v7.i32[2];
  if ((vminvq_u32(v7) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v8 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v5.columns[1], 2);
  float32x4_t v9 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v5.columns[0], (int32x4_t)v5.columns[2]), (int32x4_t)v8);
  float32x4_t v10 = (float32x4_t)vtrn2q_s32((int32x4_t)v5.columns[0], (int32x4_t)v5.columns[1]);
  v10.i32[2] = HIDWORD(*(void *)(a3 + 32));
  float32x4_t v11 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v5.columns[0], (int32x4_t)v5.columns[2]), (int32x4_t)v5.columns[1]);
  uint32x4_t v12 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v6, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v11, v5.columns[1].f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.columns[1].f32, 1), v10), v8, v9), v4)), (int8x16_t)vcgeq_f32(v6, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v11, v5.columns[0].f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.columns[0].f32, 1),
                                           v10),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)v5.columns[0], 2),
                                         v9),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v6, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v11, v5.columns[2].f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.columns[2].f32, 1), v10), (float32x4_t)vdupq_laneq_s32((int32x4_t)v5.columns[2], 2), v9), (float32x4_t)v5.columns[3])));
  v12.i32[3] = v12.i32[2];
  if ((vminvq_u32(v12) & 0x80000000) == 0) {
    return 0;
  }
  float32x4_t v13 = vmulq_f32((float32x4_t)v5.columns[0], vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v5.columns[2], (int8x16_t)v5.columns[2], 0xCuLL), (int8x16_t)v5.columns[2], 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v5.columns[1], (int32x4_t)v5.columns[1]), (int8x16_t)v5.columns[1], 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v5.columns[2], (int32x4_t)v5.columns[2]), (int8x16_t)v5.columns[2], 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v5.columns[1], (int8x16_t)v5.columns[1], 0xCuLL), (int8x16_t)v5.columns[1], 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0]+ -1.0) > 0.000011)return 0; {
  v5.columns[3] = *(simd_float4 *)(a3 + 48);
  }
  float32x2_t v14 = (float32x2_t)vdup_n_s32(0x38D1B717u);
  uint32x2_t v15 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v14, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5.columns[2], (int8x16_t)v5.columns[2], 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5.columns[3], (int8x16_t)v5.columns[3], 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v14, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5.columns[0],
                                                                                   (int8x16_t)v5.columns[0],
                                                                                   8uLL),
                                                          (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5.columns[1], (int8x16_t)v5.columns[1], 8uLL)))));
  if ((vpmin_u32(v15, v15).u32[0] & 0x80000000) == 0) {
    return 0;
  }
  simd_float4x4 v41 = __invert_f4(v5);
  unint64_t v21 = objc_msgSend_contents(*(void **)(a1 + 544), v19, v20) + ((unint64_t)a2 << 8);
  long long v22 = *(_OWORD *)(a3 + 48);
  simd_float4 v24 = *(simd_float4 *)a3;
  long long v23 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(v21 + 32) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(v21 + 48) = v22;
  *(simd_float4 *)unint64_t v21 = v24;
  *(_OWORD *)(v21 + 16) = v23;
  *(simd_float4x4 *)(v21 + 64) = v41;
  float32x4_t v25 = *(float32x4_t *)(a1 + 192);
  float32x4_t v26 = *(float32x4_t *)(a1 + 208);
  float32x4_t v27 = *(float32x4_t *)(a1 + 224);
  float32x4_t v28 = *(float32x4_t *)(a1 + 240);
  float32x4_t v29 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v41.columns[0], COERCE_FLOAT(*(_OWORD *)(a1 + 256))), (float32x4_t)v41.columns[1], *(float32x2_t *)(a1 + 256), 1), (float32x4_t)v41.columns[2], *(float32x4_t *)(a1 + 256), 2), (float32x4_t)v41.columns[3], *(float32x4_t *)(a1 + 256), 3);
  float32x4_t v30 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v41.columns[0], COERCE_FLOAT(*(_OWORD *)(a1 + 272))), (float32x4_t)v41.columns[1], *(float32x2_t *)(a1 + 272), 1), (float32x4_t)v41.columns[2], *(float32x4_t *)(a1 + 272), 2), (float32x4_t)v41.columns[3], *(float32x4_t *)(a1 + 272), 3);
  float32x4_t v31 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v41.columns[0], COERCE_FLOAT(*(_OWORD *)(a1 + 288))), (float32x4_t)v41.columns[1], *(float32x2_t *)(a1 + 288), 1), (float32x4_t)v41.columns[2], *(float32x4_t *)(a1 + 288), 2), (float32x4_t)v41.columns[3], *(float32x4_t *)(a1 + 288), 3);
  float32x4_t v32 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v41.columns[0], COERCE_FLOAT(*(_OWORD *)(a1 + 304))), (float32x4_t)v41.columns[1], *(float32x2_t *)(a1 + 304), 1), (float32x4_t)v41.columns[2], *(float32x4_t *)(a1 + 304), 2), (float32x4_t)v41.columns[3], *(float32x4_t *)(a1 + 304), 3);
  *(float32x4_t *)(v21 + 128) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v25, v29.f32[0]), v26, *(float32x2_t *)v29.f32, 1), v27, v29, 2), v28, v29, 3);
  *(float32x4_t *)(v21 + 144) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v25, v30.f32[0]), v26, *(float32x2_t *)v30.f32, 1), v27, v30, 2), v28, v30, 3);
  *(float32x4_t *)(v21 + 160) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v25, v31.f32[0]), v26, *(float32x2_t *)v31.f32, 1), v27, v31, 2), v28, v31, 3);
  *(float32x4_t *)(v21 + 176) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v25, v32.f32[0]), v26, *(float32x2_t *)v32.f32, 1), v27, v32, 2), v28, v32, 3);
  float32x4_t v33 = *(float32x4_t *)(a1 + 64);
  float32x4_t v34 = *(float32x4_t *)(a1 + 80);
  float32x4_t v35 = *(float32x4_t *)(a1 + 96);
  float32x4_t v36 = *(float32x4_t *)(a1 + 112);
  float32x4_t v37 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v41.columns[0], COERCE_FLOAT(*(_OWORD *)(a1 + 128))), (float32x4_t)v41.columns[1], *(float32x2_t *)(a1 + 128), 1), (float32x4_t)v41.columns[2], *(float32x4_t *)(a1 + 128), 2), (float32x4_t)v41.columns[3], *(float32x4_t *)(a1 + 128), 3);
  float32x4_t v38 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v41.columns[0], COERCE_FLOAT(*(_OWORD *)(a1 + 144))), (float32x4_t)v41.columns[1], *(float32x2_t *)(a1 + 144), 1), (float32x4_t)v41.columns[2], *(float32x4_t *)(a1 + 144), 2), (float32x4_t)v41.columns[3], *(float32x4_t *)(a1 + 144), 3);
  float32x4_t v39 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v41.columns[0], COERCE_FLOAT(*(_OWORD *)(a1 + 160))), (float32x4_t)v41.columns[1], *(float32x2_t *)(a1 + 160), 1), (float32x4_t)v41.columns[2], *(float32x4_t *)(a1 + 160), 2), (float32x4_t)v41.columns[3], *(float32x4_t *)(a1 + 160), 3);
  float32x4_t v40 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v41.columns[0], COERCE_FLOAT(*(_OWORD *)(a1 + 176))), (float32x4_t)v41.columns[1], *(float32x2_t *)(a1 + 176), 1), (float32x4_t)v41.columns[2], *(float32x4_t *)(a1 + 176), 2), (float32x4_t)v41.columns[3], *(float32x4_t *)(a1 + 176), 3);
  *(float32x4_t *)(v21 + 192) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, v37.f32[0]), v34, *(float32x2_t *)v37.f32, 1), v35, v37, 2), v36, v37, 3);
  *(float32x4_t *)(v21 + 208) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, v38.f32[0]), v34, *(float32x2_t *)v38.f32, 1), v35, v38, 2), v36, v38, 3);
  *(float32x4_t *)(v21 + 224) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, v39.f32[0]), v34, *(float32x2_t *)v39.f32, 1), v35, v39, 2), v36, v39, 3);
  *(float32x4_t *)(v21 + 240) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, v40.f32[0]), v34, *(float32x2_t *)v40.f32, 1), v35, v40, 2), v36, v40, 3);
  return 1;
}

void sub_24B71FB78(uint64_t a1, void *a2, uint64_t a3)
{
  objc_msgSend_error(a2, (const char *)a2, a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  if (v5) {
    sub_24B704E84(v5, v3, v4);
  }
}

void sub_24B71FBCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B71FBE0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_24B71FC78(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    goto LABEL_17;
  }
  (*(void (**)(id *__return_ptr))(*(void *)v3 + 48))(&v8);
  sub_24B71FEC0(*a1, (uint64_t *)&v8);
  if (__p)
  {
    int64x2_t v16 = __p;
    operator delete(__p);
  }
  if (v13)
  {
    float32x2_t v14 = v13;
    operator delete(v13);
  }

  uint64_t v5 = *(void *)(a2 + 24);
  if (!v5) {
    goto LABEL_17;
  }
  (*(void (**)(id *__return_ptr))(*(void *)v5 + 48))(&v8);
  sub_24B71FEC0(*a1 + 104, (uint64_t *)&v8);
  if (__p)
  {
    int64x2_t v16 = __p;
    operator delete(__p);
  }
  if (v13)
  {
    float32x2_t v14 = v13;
    operator delete(v13);
  }

  uint64_t v6 = *(void *)(a2 + 24);
  if (v6)
  {
    (*(void (**)(id *__return_ptr))(*(void *)v6 + 48))(&v8);
    sub_24B71FEC0(*a1 + 208, (uint64_t *)&v8);
    if (__p)
    {
      int64x2_t v16 = __p;
      operator delete(__p);
    }
    if (v13)
    {
      float32x2_t v14 = v13;
      operator delete(v13);
    }
  }
  else
  {
LABEL_17:
    sub_24B6EC38C();
    sub_24B71FE3C(v7);
  }
}

void *sub_24B71FE3C(void *a1)
{
  unsigned int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_24B71FEC0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;

  uint64_t v6 = a2[1];
  a2[1] = 0;
  uint32x4_t v7 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = v6;

  uint64_t v8 = a2[2];
  a2[2] = 0;
  id v9 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = v8;

  uint64_t v10 = a2[3];
  a2[3] = 0;
  id v11 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = v10;

  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  uint64_t v12 = a2[5];
  a2[5] = 0;
  float32x4_t v13 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = v12;

  float32x2_t v14 = *(void **)(a1 + 48);
  if (v14)
  {
    *(void *)(a1 + 56) = v14;
    operator delete(v14);
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
  }
  *(_OWORD *)(a1 + 48) = *((_OWORD *)a2 + 3);
  *(void *)(a1 + 64) = a2[8];
  a2[6] = 0;
  a2[7] = 0;
  a2[8] = 0;
  uint32x2_t v15 = *(void **)(a1 + 72);
  if (v15)
  {
    *(void *)(a1 + 80) = v15;
    operator delete(v15);
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 9);
  *(void *)(a1 + 88) = a2[11];
  a2[9] = 0;
  a2[10] = 0;
  a2[11] = 0;
  *(_DWORD *)(a1 + 96) = *((_DWORD *)a2 + 24);
  return a1;
}

void sub_24B71FFD0(uint64_t a1@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = objc_msgSend_newBufferWithLength_options_(**(void ***)v4, a2, 4, 0);
  uint32x4_t v7 = v5;
  if (!v5)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    uint64_t v20 = qword_2697D12D8;
    if (os_log_type_enabled((os_log_t)qword_2697D12D8, OS_LOG_TYPE_ERROR))
    {
      int v28 = 136315394;
      float32x4_t v29 = "VoxelHashingDataGPU::createBuffers";
      __int16 v30 = 1026;
      int v31 = 672;
      _os_log_error_impl(&dword_24B6B9000, v20, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create numVertices in meshBuffer", (uint8_t *)&v28, 0x12u);
    }
    id v11 = 0;
    uint32x2_t v15 = 0;
    uint32x4_t v7 = 0;
    goto LABEL_22;
  }
  objc_msgSend_setLabel_(v5, v6, @"NumVertices Buffer");
  id v9 = objc_msgSend_newBufferWithLength_options_(**(void ***)v4, v8, 48 * *(unsigned int *)(v4 + 560), 0);
  id v11 = v9;
  if (!v9)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    unint64_t v21 = qword_2697D12D8;
    if (os_log_type_enabled((os_log_t)qword_2697D12D8, OS_LOG_TYPE_ERROR))
    {
      int v28 = 136315394;
      float32x4_t v29 = "VoxelHashingDataGPU::createBuffers";
      __int16 v30 = 1026;
      int v31 = 681;
      _os_log_error_impl(&dword_24B6B9000, v21, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create numVertices in meshBuffer", (uint8_t *)&v28, 0x12u);
    }
    id v11 = 0;
    goto LABEL_21;
  }
  objc_msgSend_setLabel_(v9, v10, @"Vertices Buffer");
  float32x4_t v13 = objc_msgSend_newBufferWithLength_options_(**(void ***)v4, v12, 4, 0);
  uint32x2_t v15 = v13;
  if (!v13)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    long long v22 = qword_2697D12D8;
    if (os_log_type_enabled((os_log_t)qword_2697D12D8, OS_LOG_TYPE_ERROR))
    {
      int v28 = 136315394;
      float32x4_t v29 = "VoxelHashingDataGPU::createBuffers";
      __int16 v30 = 1026;
      int v31 = 692;
      _os_log_error_impl(&dword_24B6B9000, v22, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create numTriangleVertexIdxs in meshBuffer", (uint8_t *)&v28, 0x12u);
    }
LABEL_21:
    uint32x2_t v15 = 0;
LABEL_22:
    uint64_t v19 = 0;
    goto LABEL_23;
  }
  objc_msgSend_setLabel_(v13, v14, @"NumTriangleVertexIdxs Buffer");
  if (!*(unsigned char *)(v4 + 644))
  {
    uint64_t v19 = 0;
    goto LABEL_26;
  }
  uint64_t v17 = objc_msgSend_newBufferWithLength_options_(**(void ***)v4, v16, 12 * *(unsigned int *)(v4 + 564), 0);
  uint64_t v19 = v17;
  if (!v17)
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    float32x4_t v27 = qword_2697D12D8;
    if (os_log_type_enabled((os_log_t)qword_2697D12D8, OS_LOG_TYPE_ERROR))
    {
      int v28 = 136315394;
      float32x4_t v29 = "VoxelHashingDataGPU::createBuffers";
      __int16 v30 = 1026;
      int v31 = 703;
      _os_log_error_impl(&dword_24B6B9000, v27, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create triangleVertexIdxs in meshBuffer", (uint8_t *)&v28, 0x12u);
    }
    goto LABEL_22;
  }
  objc_msgSend_setLabel_(v17, v18, @"TriangleVertexIdxs Buffer");
LABEL_26:
  long long v23 = objc_msgSend_newBufferWithLength_options_(**(void ***)v4, v16, 48 * *(unsigned int *)(v4 + 568), 0);
  float32x4_t v25 = v23;
  if (v23)
  {
    objc_msgSend_setLabel_(v23, v24, @"SampledPointsFromMesh Buffer");
    *(void *)a3 = v7;
    *(void *)(a3 + 8) = v11;
    *(void *)(a3 + 16) = v15;
    *(void *)(a3 + 24) = v19;
    *(_DWORD *)(a3 + 32) = 0;
    *(void *)(a3 + 40) = v25;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_DWORD *)(a3 + 96) = 0;
    id v11 = 0;
    uint32x2_t v15 = 0;
    uint32x4_t v7 = 0;
    uint64_t v19 = 0;
    goto LABEL_24;
  }
  if (qword_2697D12E0 != -1) {
    dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
  }
  float32x4_t v26 = qword_2697D12D8;
  if (os_log_type_enabled((os_log_t)qword_2697D12D8, OS_LOG_TYPE_ERROR))
  {
    int v28 = 136315394;
    float32x4_t v29 = "VoxelHashingDataGPU::createBuffers";
    __int16 v30 = 1026;
    int v31 = 714;
    _os_log_error_impl(&dword_24B6B9000, v26, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create sampledPointsFromMesh in meshBuffer", (uint8_t *)&v28, 0x12u);
  }
LABEL_23:
  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 84) = 0u;
LABEL_24:
}

void sub_24B7204BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B720538(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26FE9D740;
  a2[1] = v2;
  return result;
}

void *sub_24B72055C(uint64_t a1)
{
  int8x16_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *int8x16_t result = &unk_26FE9D740;
  result[1] = v3;
  return result;
}

void sub_24B7205A4()
{
}

uint64_t sub_24B7205BC()
{
  qword_2697D12D8 = (uint64_t)os_log_create("com.apple.CoreOCModules", "VoxelHashing");
  return MEMORY[0x270F9A758]();
}

BOOL sub_24B720600(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (a1 == a2) {
    return 1;
  }
  float32x4_t v2 = *(float32x4_t *)MEMORY[0x263EF89A0];
  float32x4_t v3 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v4 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v5 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  float32x2_t v6 = (float32x2_t)vdup_n_s32(0x38D1B717u);
  while (1)
  {
    float32x4_t v7 = *(float32x4_t *)a1;
    float32x4_t v8 = *(float32x4_t *)(a1 + 16);
    float32x4_t v9 = *(float32x4_t *)(a1 + 32);
    uint32x4_t v10 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v5, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v7, *(float32x2_t *)v7.f32, 1), v8, *(float32x2_t *)v8.f32, 1), v9, *(float32x2_t *)v9.f32, 1), v3)), (int8x16_t)vcgeq_f32(v5, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v7, v7.f32[0]), v8, v8.f32[0]),
                                           v9,
                                           v9.f32[0]),
                                         v2))),
                        (int8x16_t)vcgeq_f32(v5, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v7, v7, 2), v8, v8, 2), v9, v9, 2), v4)));
    v10.i32[3] = v10.i32[2];
    if ((vminvq_u32(v10) & 0x80000000) == 0) {
      break;
    }
    float32x4_t v11 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2);
    float32x4_t v12 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v7, (int32x4_t)v9), (int32x4_t)v11);
    float32x4_t v13 = (float32x4_t)vtrn2q_s32((int32x4_t)v7, (int32x4_t)v8);
    v13.i32[2] = HIDWORD(*(void *)(a1 + 32));
    float32x4_t v14 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v7, (int32x4_t)v9), (int32x4_t)v8);
    uint32x4_t v15 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v5, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v14, v8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1), v13), v11, v12), v3)), (int8x16_t)vcgeq_f32(v5, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v14, v7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1),
                                             v13),
                                           (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2),
                                           v12),
                                         v2))),
                        (int8x16_t)vcgeq_f32(v5, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v14, v9.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1), v13), (float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), v12), v4)));
    v15.i32[3] = v15.i32[2];
    if ((vminvq_u32(v15) & 0x80000000) == 0) {
      break;
    }
    float32x4_t v16 = vmulq_f32(v7, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v9, (int8x16_t)v9, 0xCuLL), (int8x16_t)v9, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL), (int8x16_t)v8, 8uLL)));
    if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0]+ -1.0) > 0.000011)break; {
    uint32x2_t v17 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v6, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v6, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v7,
    }
                                                                                     (int8x16_t)v7,
                                                                                     8uLL),
                                                            (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v8, (int8x16_t)v8, 8uLL)))));
    if ((vpmin_u32(v17, v17).u32[0] & 0x80000000) == 0) {
      break;
    }
    a1 += 64;
    if (a1 == a2) {
      return 1;
    }
  }
  if (qword_2697D12E0 != -1) {
    dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
  }
  uint64_t v19 = qword_2697D12D8;
  BOOL result = os_log_type_enabled((os_log_t)qword_2697D12D8, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v20 = 136315394;
    unint64_t v21 = "VoxelHashingDataGPU::InitConfig";
    __int16 v22 = 1026;
    int v23 = 113;
    _os_log_error_impl(&dword_24B6B9000, v19, OS_LOG_TYPE_ERROR, "%s:%{public}d Submap to world transform is invalid.", (uint8_t *)&v20, 0x12u);
    return 0;
  }
  return result;
}

uint64_t sub_24B7208A8(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8)) {
    return *(unsigned int *)(a1 + 560);
  }
  if (qword_2697D12E0 != -1) {
    dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
  }
  float32x4_t v2 = (id)qword_2697D12D8;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "uint32_t oc::voxel_hashing::VoxelHashingDataGPU::vertexCapacity() const");
    if (v5 >= 0) {
      float32x4_t v3 = __p;
    }
    else {
      float32x4_t v3 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float32x4_t v7 = v3;
    __int16 v8 = 1026;
    int v9 = 157;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }

  return 0;
}

uint64_t sub_24B7209D4(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8)) {
    return *(unsigned int *)(a1 + 564);
  }
  if (qword_2697D12E0 != -1) {
    dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
  }
  float32x4_t v2 = (id)qword_2697D12D8;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "uint32_t oc::voxel_hashing::VoxelHashingDataGPU::triangleCapacity() const");
    if (v5 >= 0) {
      float32x4_t v3 = __p;
    }
    else {
      float32x4_t v3 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float32x4_t v7 = v3;
    __int16 v8 = 1026;
    int v9 = 167;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }

  return 0;
}

uint64_t sub_24B720B00(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8)
    && *(void *)(a1 + 488)
    && *(void *)(a1 + 496)
    && (float32x4_t v4 = *(void **)(a1 + 480)) != 0
    && (int v5 = *(_DWORD *)(a1 + 384)) != 0
    && (unsigned int v6 = *(_DWORD *)(a1 + 392), v7 = *(_DWORD *)(a1 + 388), v7 - 1 < v6)
    && v6 == v7 * v5
    && !(v6 % v7)
    && (int v8 = *(_DWORD *)(a1 + 408), *(_DWORD *)(a1 + 396) == v8 * v6)
    && (int v9 = *(_DWORD *)(a1 + 400), v9 >= 1)
    && v8
    && *(_DWORD *)(a1 + 404) - 1 < v9)
  {
    int v10 = *(_DWORD *)objc_msgSend_contents(v4, a2, a3);
    int v13 = *(_DWORD *)objc_msgSend_contents(*(void **)(a1 + 496), v11, v12);
    if (v13 < 0) {
      int v13 = -1;
    }
    return (v10 + ~v13);
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    uint32x4_t v15 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "uint32_t oc::voxel_hashing::VoxelHashingDataGPU::numVoxelBlocks() const");
      float32x4_t v16 = v18 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      int v20 = v16;
      __int16 v21 = 1026;
      int v22 = 188;
      _os_log_error_impl(&dword_24B6B9000, v15, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
    }

    return 0;
  }
}

void sub_24B720CD0(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8))
  {
    *(_OWORD *)a1 = *(_OWORD *)(a2 + 384);
    *(_OWORD *)(a1 + 12) = *(_OWORD *)(a2 + 396);
    char v3 = 1;
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    float32x4_t v4 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "std::optional<HashTableParams> oc::voxel_hashing::VoxelHashingDataGPU::hashTableParams() const");
      if (v7 >= 0) {
        int v5 = __p;
      }
      else {
        int v5 = (void **)__p[0];
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      int v9 = v5;
      __int16 v10 = 1026;
      int v11 = 200;
      _os_log_error_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }

    char v3 = 0;
    *(unsigned char *)a1 = 0;
  }
  *(unsigned char *)(a1 + 28) = v3;
}

id sub_24B720E24(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8))
  {
    id v1 = *(id *)(a1 + 464);
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    float32x4_t v2 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "id<MTLBuffer> oc::voxel_hashing::VoxelHashingDataGPU::hashEntries()");
      float32x4_t v4 = v6 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      int v8 = v4;
      __int16 v9 = 1026;
      int v10 = 210;
      _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v6 < 0) {
        operator delete(__p[0]);
      }
    }

    id v1 = 0;
  }
  return v1;
}

id sub_24B720F64(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8))
  {
    id v1 = *(id *)(a1 + 472);
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    float32x4_t v2 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "id<MTLBuffer> oc::voxel_hashing::VoxelHashingDataGPU::voxelBlocks()");
      float32x4_t v4 = v6 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      int v8 = v4;
      __int16 v9 = 1026;
      int v10 = 220;
      _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v6 < 0) {
        operator delete(__p[0]);
      }
    }

    id v1 = 0;
  }
  return v1;
}

id sub_24B7210A4(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8) && (id v1 = *(void **)(a1 + 480)) != 0)
  {
    id v2 = v1;
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    char v3 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "id<MTLBuffer> oc::voxel_hashing::VoxelHashingDataGPU::nextAvailableVoxelBlockIdx()");
      int v5 = v7 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      __int16 v9 = v5;
      __int16 v10 = 1026;
      int v11 = 230;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }

    id v2 = 0;
  }
  return v2;
}

id sub_24B7211E8(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8) && (id v1 = *(void **)(a1 + 488)) != 0)
  {
    id v2 = v1;
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    char v3 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "id<MTLBuffer> oc::voxel_hashing::VoxelHashingDataGPU::voxelBlocksFreeStack()");
      int v5 = v7 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      __int16 v9 = v5;
      __int16 v10 = 1026;
      int v11 = 240;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }

    id v2 = 0;
  }
  return v2;
}

id sub_24B72132C(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8) && (id v1 = *(void **)(a1 + 496)) != 0)
  {
    id v2 = v1;
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    char v3 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "id<MTLBuffer> oc::voxel_hashing::VoxelHashingDataGPU::voxelBlocksFreeStackTopBuffer()");
      int v5 = v7 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      __int16 v9 = v5;
      __int16 v10 = 1026;
      int v11 = 250;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }

    id v2 = 0;
  }
  return v2;
}

id sub_24B721470(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8) && (id v1 = *(void **)(a1 + 504)) != 0)
  {
    id v2 = v1;
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    char v3 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "id<MTLBuffer> oc::voxel_hashing::VoxelHashingDataGPU::updatedAndErasableHashEntries()");
      int v5 = v7 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      __int16 v9 = v5;
      __int16 v10 = 1026;
      int v11 = 260;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }

    id v2 = 0;
  }
  return v2;
}

id sub_24B7215B4(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8) && (id v1 = *(void **)(a1 + 512)) != 0)
  {
    id v2 = v1;
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    char v3 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "id<MTLBuffer> oc::voxel_hashing::VoxelHashingDataGPU::numUpdatedAndErasableHashEntriesBuffer()");
      int v5 = v7 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      __int16 v9 = v5;
      __int16 v10 = 1026;
      int v11 = 270;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }

    id v2 = 0;
  }
  return v2;
}

id sub_24B7216F8(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8) && (id v1 = *(void **)(a1 + 520)) != 0)
  {
    id v2 = v1;
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    char v3 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "id<MTLBuffer> oc::voxel_hashing::VoxelHashingDataGPU::updatedHashEntries()");
      int v5 = v7 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      __int16 v9 = v5;
      __int16 v10 = 1026;
      int v11 = 280;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }

    id v2 = 0;
  }
  return v2;
}

id sub_24B72183C(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8) && (id v1 = *(void **)(a1 + 528)) != 0)
  {
    id v2 = v1;
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    char v3 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "id<MTLBuffer> oc::voxel_hashing::VoxelHashingDataGPU::numUpdatedHashEntriesBuffer()");
      int v5 = v7 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      __int16 v9 = v5;
      __int16 v10 = 1026;
      int v11 = 290;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }

    id v2 = 0;
  }
  return v2;
}

id sub_24B721980(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8))
  {
    id v1 = *(id *)(a1 + 552);
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    id v2 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "id<MTLBuffer> oc::voxel_hashing::VoxelHashingDataGPU::triangleFacesInVoxelBlocks()");
      float32x4_t v4 = v6 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      int v8 = v4;
      __int16 v9 = 1026;
      int v10 = 340;
      _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v6 < 0) {
        operator delete(__p[0]);
      }
    }

    id v1 = 0;
  }
  return v1;
}

uint64_t sub_24B721AC0(uint64_t a1, unsigned int a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8) && *(_DWORD *)(a1 + 408) > a2)
  {
    *(_DWORD *)(a1 + 536) = a2;
    return 1;
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    char v3 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::setLastIntegratedSubmapID(const SubmapID)");
      if (v6 >= 0) {
        float32x4_t v4 = __p;
      }
      else {
        float32x4_t v4 = (void **)__p[0];
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      int v8 = v4;
      __int16 v9 = 1026;
      int v10 = 350;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized or the submapID is invalid.", buf, 0x12u);
      if (v6 < 0) {
        operator delete(__p[0]);
      }
    }

    return 0;
  }
}

uint64_t sub_24B721BFC(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8)) {
    return *(unsigned int *)(a1 + 536) | 0x100000000;
  }
  if (qword_2697D12E0 != -1) {
    dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
  }
  id v2 = (id)qword_2697D12D8;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "std::optional<SubmapID> oc::voxel_hashing::VoxelHashingDataGPU::lastIntegratedSubmapID() const");
    if (v5 >= 0) {
      char v3 = __p;
    }
    else {
      char v3 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    char v7 = v3;
    __int16 v8 = 1026;
    int v9 = 361;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }

  return 0;
}

id sub_24B721D2C(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8))
  {
    id v1 = *(id *)(a1 + 544);
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    id v2 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "id<MTLBuffer> oc::voxel_hashing::VoxelHashingDataGPU::submapsData()");
      float32x4_t v4 = v6 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      __int16 v8 = v4;
      __int16 v9 = 1026;
      int v10 = 386;
      _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v6 < 0) {
        operator delete(__p[0]);
      }
    }

    id v1 = 0;
  }
  return v1;
}

uint64_t sub_24B721E6C(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8)) {
    return *(void *)(a1 + 576) + 104 * *(void *)(a1 + 616);
  }
  if (qword_2697D12E0 != -1) {
    dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
  }
  id v2 = (id)qword_2697D12D8;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "MeshBuffers *oc::voxel_hashing::VoxelHashingDataGPU::meshReaderBuffers()");
    if (v5 >= 0) {
      char v3 = __p;
    }
    else {
      char v3 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    char v7 = v3;
    __int16 v8 = 1026;
    int v9 = 406;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }

  return 0;
}

uint64_t sub_24B721FA4(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8)) {
    return *(void *)(a1 + 576) + 104 * *(void *)(a1 + 600);
  }
  if (qword_2697D12E0 != -1) {
    dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
  }
  id v2 = (id)qword_2697D12D8;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "MeshBuffers *oc::voxel_hashing::VoxelHashingDataGPU::meshWriterBuffers()");
    if (v5 >= 0) {
      char v3 = __p;
    }
    else {
      char v3 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    char v7 = v3;
    __int16 v8 = 1026;
    int v9 = 416;
    _os_log_error_impl(&dword_24B6B9000, v2, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }

  return 0;
}

void sub_24B7220DC(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v1 = a1 + 576;
    id v2 = *(NSObject **)(a1 + 624);
    block[0] = (void *)MEMORY[0x263EF8330];
    block[1] = (void *)3221225472;
    char v6 = sub_24B722258;
    char v7 = &unk_2652DF258;
    uint64_t v8 = v1;
    dispatch_sync(v2, block);
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    char v3 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(block, "void oc::voxel_hashing::VoxelHashingDataGPU::updateMeshReaderBuffer()");
      if (SHIBYTE(v6) >= 0) {
        float32x4_t v4 = block;
      }
      else {
        float32x4_t v4 = (void **)block[0];
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      uint64_t v10 = v4;
      __int16 v11 = 1026;
      int v12 = 426;
      _os_log_error_impl(&dword_24B6B9000, v3, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (SHIBYTE(v6) < 0) {
        operator delete(block[0]);
      }
    }
  }
}

int8x16_t sub_24B722258(uint64_t a1)
{
  uint64_t v1 = *(int8x16_t **)(a1 + 32);
  if (v1[3].i8[8])
  {
    int8x16_t result = vextq_s8(v1[2], v1[2], 8uLL);
    v1[2] = result;
    v1[3].i8[8] = 0;
  }
  return result;
}

int8x16_t sub_24B722278(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int8x16_t result = vextq_s8(*(int8x16_t *)(v1 + 24), *(int8x16_t *)(v1 + 24), 8uLL);
  *(int8x16_t *)(v1 + 24) = result;
  *(unsigned char *)(v1 + 56) = 1;
  return result;
}

BOOL sub_24B722294(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  int v56 = *(unsigned __int8 *)(a1 + 8);
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v4 = *(unsigned int *)objc_msgSend_contents(*(void **)(a1 + 512), a2, a3);
    char v7 = (unsigned int *)objc_msgSend_contents(*(void **)(a1 + 504), v5, v6);
    uint64_t v10 = (_DWORD *)objc_msgSend_contents(*(void **)(a1 + 528), v8, v9);
    _DWORD *v10 = 0;
    uint64_t v13 = objc_msgSend_contents(*(void **)(a1 + 520), v11, v12);
    uint64_t v55 = objc_msgSend_contents(*(void **)(a1 + 488), v14, v15);
    char v18 = (int *)objc_msgSend_contents(*(void **)(a1 + 496), v16, v17);
    __int16 v21 = v18;
    if (*v18 <= -2) {
      int *v18 = -1;
    }
    uint64_t v54 = objc_msgSend_contents(*(void **)(a1 + 472), v19, v20);
    uint64_t v24 = objc_msgSend_contents(*(void **)(a1 + 464), v22, v23);
    if (v4)
    {
      uint64_t v27 = v24;
      do
      {
        if (*v21 >= *(_DWORD *)(a1 + 404) - 1) {
          break;
        }
        if (*((unsigned char *)v7 + 8) && (unsigned int v30 = *v7, *(_DWORD *)(v27 + 24 * *v7 + 16) == 2))
        {
          uint64_t v31 = *(void *)(a1 + 416);
          uint64_t v32 = *(unsigned int *)(a1 + 536);
          if (*(_DWORD *)(v31 + 8 * v32) > v30 || *(_DWORD *)(v31 + 8 * v32 + 4) <= v30)
          {
            if (qword_2697D12E0 != -1) {
              dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
            }
            float32x4_t v40 = (id)qword_2697D12D8;
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            {
              sub_24B6F6D14(__p, "Pointer oc::voxel_hashing::VoxelHashingDataGPU::eraseHashEntry(const UpdatedHashEntry &)");
              uint64_t v50 = __p;
              if (v58 < 0) {
                uint64_t v50 = (void **)__p[0];
              }
              *(_DWORD *)simd_float4x4 buf = 136315394;
              uint64_t v60 = v50;
              __int16 v61 = 1026;
              int v62 = 765;
              _os_log_error_impl(&dword_24B6B9000, v40, OS_LOG_TYPE_ERROR, "%s:%{public}d Received invalid updatedHashEntry.", buf, 0x12u);
              if (v58 < 0) {
                operator delete(__p[0]);
              }
            }
          }
          else
          {
            uint64_t v33 = objc_msgSend_contents(*(void **)(a1 + 464), v25, v26);
            unsigned int v34 = *v7;
            unsigned int v35 = v7[1];
            unsigned int v36 = *(_DWORD *)(v33 + 24 * *v7 + 12);
            uint64_t v37 = *(void *)(a1 + 416);
            uint64_t v38 = *(unsigned int *)(a1 + 536);
            unsigned int v39 = *(_DWORD *)(v37 + 8 * v38);
            if (v39 > v35 || *(_DWORD *)(v37 + 8 * v38 + 4) <= v35)
            {
              uint64_t v41 = v33 + 24 * v34;
              unsigned int v44 = *(_DWORD *)(v41 + 8);
              long long v43 = (void *)(v41 + 8);
              unsigned int v42 = v44;
              if (v39 <= v44 && *(_DWORD *)(v37 + 8 * v38 + 4) > v42)
              {
                int16x4_t v45 = (void *)(v33 + 24 * v42);
                uint64_t v46 = v45[1];
                uint64_t v47 = v33 + 24 * v34;
                *(void *)uint64_t v47 = *v45;
                *long long v43 = v46;
                *(_DWORD *)(v47 + 16) = 0;
                unsigned int v34 = v42;
              }
            }
            else
            {
              *(_DWORD *)(v33 + 24 * v35 + 8) = *(_DWORD *)(v33 + 24 * v34 + 8);
            }
            uint64_t v48 = v33 + 24 * v34;
            *(_DWORD *)(v48 + 8) = *(_DWORD *)(a1 + 396);
            *(void *)(v48 + 12) = 0xFFFFFFFFLL;
            if ((v36 & 0x80000000) == 0)
            {
              uint64_t v49 = *v21 + 1;
              *__int16 v21 = v49;
              *(_DWORD *)(v55 + 4 * v49) = v36;
              *(unsigned char *)(v54 + 17368 * v36 + 17364) = 1;
            }
          }
        }
        else
        {
          uint64_t v28 = v13 + 12 * *v10;
          uint64_t v29 = *(void *)v7;
          *(unsigned char *)(v28 + 8) = *((unsigned char *)v7 + 8);
          *(void *)uint64_t v28 = v29;
          ++*v10;
        }
        v7 += 3;
        --v4;
      }
      while (v4);
    }
  }
  else
  {
    if (qword_2697D12E0 != -1) {
      dispatch_once(&qword_2697D12E0, &unk_26FE9D710);
    }
    uint64_t v51 = (id)qword_2697D12D8;
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelHashingDataGPU::eraseHashEntriesWithEmptyVoxelBlocks()");
      float v53 = v58 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      uint64_t v60 = v53;
      __int16 v61 = 1026;
      int v62 = 446;
      _os_log_error_impl(&dword_24B6B9000, v51, OS_LOG_TYPE_ERROR, "%s:%{public}d VoxelHashingDataGPU not initialized.", buf, 0x12u);
      if (v58 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  return v56 != 0;
}

uint64_t sub_24B7226A8()
{
  return 0;
}

uint64_t sub_24B7226B0()
{
  return 0;
}

uint64_t sub_24B7226B8()
{
  return 0;
}

double sub_24B7226C0@<D0>(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  return result;
}

void *sub_24B7226DC@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *((unsigned __int8 *)result + 40);
  if (*((unsigned char *)result + 40))
  {
    uint64_t v4 = result;
    double result = (*(void *(**)(void *__return_ptr))(*(void *)result[4] + 40))(v8);
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    int v3 = v8[0];
    uint64_t v5 = v8[1];
    long long v6 = v4[7];
    *(_OWORD *)(a2 + 80) = v4[6];
    *(_OWORD *)(a2 + 96) = v6;
    long long v7 = v4[9];
    *(_OWORD *)(a2 + 112) = v4[8];
    *(_OWORD *)(a2 + 128) = v7;
  }
  else
  {
    uint64_t v5 = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
  }
  *(_DWORD *)a2 = v3;
  *(void *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 56) = 0;
  *(_DWORD *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  return result;
}

uint64_t sub_24B722794()
{
  return 0;
}

double sub_24B72279C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (*(unsigned char *)(a1 + 40))
  {
    (*(void (**)(void))(**(void **)(a1 + 32) + 40))();
  }
  else
  {
    *(_DWORD *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    double result = 0.0;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
  }
  return result;
}

void sub_24B7227E8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    return;
  }
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(unsigned char *)v4) {
    uint64_t v37 = *(void *)(v4 + 64);
  }
  else {
    uint64_t v37 = 0;
  }
  uint64_t v5 = *(unsigned int *)(v4 + 4);
  long long v6 = *(void **)(a1 + 72);
  *(void *)(a1 + 80) = v6;
  uint64_t v38 = v5;
  unsigned int v7 = v5 << 9;
  if (v5 << 9)
  {
    uint64_t v8 = (int32x4_t *)operator new(48 * v7);
    uint64_t v9 = &v8[3 * v7];
    int64x2_t v10 = vdupq_n_s64((unint64_t)v8);
    if (!v38) {
      goto LABEL_52;
    }
LABEL_10:
    uint64_t v36 = v3;
    uint64_t v11 = 0;
    v12.i32[3] = 1060320051;
    do
    {
      uint64_t v13 = 0;
      uint64_t v39 = v11;
      float32x4_t v14 = (__int16 *)(v37 + 4104 * v11);
      v12.i32[0] = v14[2048];
      v12.i32[1] = v14[2049];
      v12.i32[2] = v14[2050];
      int32x4_t v12 = vshlq_n_s32(v12, 3uLL);
      int32x4_t v46 = v12;
      do
      {
        uint64_t v15 = 0;
        v12.i32[0] = v13;
        int32x4_t v40 = v12;
        do
        {
          uint64_t v16 = 0;
          uint64_t v17 = (int32x4_t *)v10.i64[0];
          int32x4_t v12 = v40;
          int32x4_t v18 = v40;
          v18.i32[1] = v15;
          v18.i32[2] = v40.i32[2];
          int32x4_t v48 = v18;
          do
          {
            uint64_t v19 = &v14[256 * v13 + 32 * v15];
            if (LOBYTE(v19[4 * v16 + 2]))
            {
              float v20 = *(float *)&v19[4 * v16];
              float v21 = fabsf(v20);
              float v22 = 1.0 - (float)(v21 / 12.0);
              if (v22 <= 1.0) {
                float v23 = 1.0 - (float)(v21 / 12.0);
              }
              else {
                float v23 = 1.0;
              }
              if (v22 >= 0.2) {
                *(float *)&long long v24 = v23;
              }
              else {
                *(float *)&long long v24 = 0.2;
              }
              BOOL v25 = v21 <= 12.0;
              long long v26 = xmmword_24B72A7F0;
              if (v25)
              {
                if (v20 >= 0.0)
                {
                  *(void *)&long long v26 = 0;
                  *((void *)&v26 + 1) = v24 | 0x3F33333300000000;
                }
                else
                {
                  DWORD1(v24) = 0;
                  *((void *)&v24 + 1) = 0x3F33333300000000;
                  long long v26 = v24;
                }
              }
              int32x4_t v27 = v48;
              v27.i32[2] = v16;
              int32x4_t v12 = vaddq_s32(v27, v46);
              v12.i32[3] = 1;
              if (v8 < v9)
              {
                int32x4_t *v8 = v12;
                v8[1].i64[0] = 0;
                v8[1].i64[1] = 0;
                v8[2] = (int32x4_t)v26;
                v8 += 3;
              }
              else
              {
                unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (v8 - v17) + 1;
                if (v28 > 0x555555555555555) {
                  abort();
                }
                if (0x5555555555555556 * (v9 - v17) > v28) {
                  unint64_t v28 = 0x5555555555555556 * (v9 - v17);
                }
                if (0xAAAAAAAAAAAAAAABLL * (v9 - v17) >= 0x2AAAAAAAAAAAAAALL) {
                  unint64_t v29 = 0x555555555555555;
                }
                else {
                  unint64_t v29 = v28;
                }
                if (v29)
                {
                  if (v29 > 0x555555555555555) {
                    sub_24B6BCD7C();
                  }
                  int32x4_t v41 = v12;
                  long long v42 = v26;
                  unsigned int v30 = (char *)operator new(48 * v29);
                  int32x4_t v12 = v41;
                  long long v26 = v42;
                }
                else
                {
                  unsigned int v30 = 0;
                }
                uint64_t v31 = (int32x4_t *)&v30[16 * (v8 - v17)];
                int32x4_t *v31 = v12;
                v31[1].i64[0] = 0;
                v31[1].i64[1] = 0;
                v31[2] = (int32x4_t)v26;
                if (v8 == v17)
                {
                  unsigned int v34 = (int32x4_t *)&v30[16 * (v8 - v17)];
                }
                else
                {
                  uint64_t v32 = (int32x4_t *)&v30[16 * (v8 - v17)];
                  do
                  {
                    int32x4_t v12 = v8[-3];
                    int32x4_t v33 = v8[-1];
                    unsigned int v34 = v32 - 3;
                    v32[-2] = v8[-2];
                    v32[-1] = v33;
                    v32[-3] = v12;
                    v8 -= 3;
                    v32 -= 3;
                  }
                  while (v8 != v17);
                }
                uint64_t v9 = (int32x4_t *)&v30[48 * v29];
                uint64_t v8 = v31 + 3;
                v10.i64[0] = (uint64_t)v34;
                if (v17)
                {
                  operator delete(v17);
                  v10.i64[0] = (uint64_t)v34;
                }
                uint64_t v17 = v34;
              }
              v10.i64[1] = (uint64_t)v8;
            }
            ++v16;
          }
          while (v16 != 8);
          ++v15;
        }
        while (v15 != 8);
        ++v13;
      }
      while (v13 != 8);
      uint64_t v11 = v39 + 1;
    }
    while (v39 + 1 != v38);
    uint64_t v3 = v36;
    long long v6 = *(void **)(v36 + 72);
    goto LABEL_52;
  }
  uint64_t v9 = 0;
  uint64_t v8 = 0;
  int64x2_t v10 = 0uLL;
  if (v5) {
    goto LABEL_10;
  }
LABEL_52:
  if (v6)
  {
    *(void *)(v3 + 80) = v6;
    int64x2_t v43 = v10;
    operator delete(v6);
    int64x2_t v10 = v43;
  }
  *(int64x2_t *)(v3 + 72) = v10;
  *(void *)(v3 + 88) = v9;
  float32x4_t v44 = *(float32x4_t *)(v3 + 96);
  float32x4_t v45 = *(float32x4_t *)(v3 + 112);
  float32x4_t v47 = *(float32x4_t *)(v3 + 128);
  float32x4_t v49 = *(float32x4_t *)(v3 + 144);
  v50.columns[2].i64[0] = 0;
  v50.columns[0] = (simd_float4)*(unsigned int *)(v3 + 44);
  v50.columns[1].i32[0] = 0;
  v50.columns[1].i32[3] = 0;
  *(uint64_t *)((char *)v50.columns[1].i64 + 4) = v50.columns[0].u32[0];
  v50.columns[2].i64[1] = v50.columns[0].u32[0];
  v50.columns[3] = (simd_float4)xmmword_24B72A590;
  simd_float4x4 v51 = __invert_f4(v50);
  *(_DWORD *)a2 = *(_DWORD *)(v3 + 44);
  uint64_t v35 = *(void *)(v3 + 72);
  *(_DWORD *)(a2 + 4) = -1431655765 * ((unint64_t)(*(void *)(v3 + 80) - v35) >> 4);
  *(void *)(a2 + 8) = v35;
  *(float32x4_t *)(a2 + 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v51.columns[0], v44.f32[0]), (float32x4_t)v51.columns[1], *(float32x2_t *)v44.f32, 1), (float32x4_t)v51.columns[2], v44, 2), (float32x4_t)v51.columns[3], v44, 3);
  *(float32x4_t *)(a2 + 32) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v51.columns[0], v45.f32[0]), (float32x4_t)v51.columns[1], *(float32x2_t *)v45.f32, 1), (float32x4_t)v51.columns[2], v45, 2), (float32x4_t)v51.columns[3], v45, 3);
  *(float32x4_t *)(a2 + 48) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v51.columns[0], v47.f32[0]), (float32x4_t)v51.columns[1], *(float32x2_t *)v47.f32, 1), (float32x4_t)v51.columns[2], v47, 2), (float32x4_t)v51.columns[3], v47, 3);
  *(float32x4_t *)(a2 + 64) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v51.columns[0], v49.f32[0]), (float32x4_t)v51.columns[1], *(float32x2_t *)v49.f32, 1), (float32x4_t)v51.columns[2], v49, 2), (float32x4_t)v51.columns[3], v49, 3);
}

double sub_24B722C58@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    double result = 0.0;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    return result;
  }
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 32) + 40))(&v21);
  int v4 = v21;
  uint64_t v5 = v22;
  if (v21) {
    BOOL v6 = v22 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    int32x4_t v12 = 0;
    unsigned int v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = *(void **)(a1 + 48);
    if (!v9) {
      goto LABEL_13;
    }
  }
  else
  {
    size_t v11 = 48 * v21;
    int32x4_t v12 = (char *)operator new(v11);
    size_t v13 = 48 * ((v11 - 48) / 0x30) + 48;
    bzero(v12, v13);
    uint64_t v14 = 0;
    do
    {
      *(int32x2_t *)&long long v15 = vcvt_s32_f32(vrndm_f32(*(float32x2_t *)(v5 + v14)));
      *((void *)&v15 + 1) = vcvtms_s32_f32(*(float *)(v5 + v14 + 8)) | 0x100000000;
      long long v16 = *(_OWORD *)(v5 + v14 + 16);
      long long v17 = *(_OWORD *)(v5 + v14 + 32);
      int32x4_t v18 = &v12[v14];
      *(_OWORD *)int32x4_t v18 = v15;
      *((_OWORD *)v18 + 1) = v16;
      *((_OWORD *)v18 + 2) = v17;
      v14 += 48;
    }
    while (v11 != v14);
    uint64_t v8 = &v12[48 * v4];
    unsigned int v7 = &v12[v13];
    uint64_t v9 = *(void **)(a1 + 48);
    if (!v9) {
      goto LABEL_13;
    }
  }
  *(void *)(a1 + 56) = v9;
  operator delete(v9);
  int v4 = v21;
LABEL_13:
  *(void *)(a1 + 48) = v12;
  *(void *)(a1 + 56) = v7;
  *(void *)(a1 + 64) = v8;
  *(_DWORD *)a2 = v23;
  *(_DWORD *)(a2 + 4) = v4;
  *(void *)(a2 + 8) = v12;
  long long v19 = v25;
  *(_OWORD *)(a2 + 16) = v24;
  *(_OWORD *)(a2 + 32) = v19;
  double result = *(double *)&v26;
  long long v20 = v27;
  *(_OWORD *)(a2 + 48) = v26;
  *(_OWORD *)(a2 + 64) = v20;
  return result;
}

uint64_t sub_24B722DD8()
{
  return 2;
}

uint64_t sub_24B722DE0(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 40)) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 41)) {
    return 0;
  }
  (*(void (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
  uint64_t result = 0;
  *(unsigned char *)(a1 + 41) = 1;
  return result;
}

uint64_t sub_24B722E54(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 40)
    || !(*(unsigned int (**)(void))(**(void **)(a1 + 24) + 32))(*(void *)(a1 + 24)))
  {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 41) = 0;
  return result;
}

uint64_t sub_24B722EB8()
{
  return 2;
}

uint64_t sub_24B722EC0(uint64_t a1, uint64_t a2)
{
  if (!sub_24B71A784(a2)) {
    return 4;
  }
  if (*(unsigned char *)(a1 + 40)) {
    return 1;
  }
  BOOL v6 = (char *)operator new(0x60uLL);
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *(void *)BOOL v6 = &unk_26FE9D820;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *((void *)v6 + 11) = 0;
  unsigned int v7 = *(std::__shared_weak_count **)(a1 + 16);
  *(_OWORD *)(v6 + 24) = 0u;
  uint64_t v8 = (int32x4_t *)(v6 + 24);
  *(void *)(a1 + 8) = v6 + 24;
  *(void *)(a1 + 16) = v6;
  if (v7)
  {
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    uint64_t v8 = *(int32x4_t **)(a1 + 8);
    if (!v8) {
      return 1;
    }
    int v9 = v8->u8[0];
  }
  else
  {
    int v9 = 0;
  }
  uint64_t v10 = *(unsigned int *)(a2 + 48);
  uint64_t v4 = 1;
  if (v10 >= 2 && !v9 && (v10 & 1) == 0)
  {
    vm_size_t v19 = 0;
    host_t v11 = MEMORY[0x24C5D7A70]();
    host_page_size(v11, &v19);
    vm_size_t v12 = (v19 + 16 * v10 - 1) / v19 * v19;
    v8[2].i64[1] = v12;
    size_t v13 = (vm_map_t *)MEMORY[0x263EF8960];
    if (vm_allocate(*MEMORY[0x263EF8960], (vm_address_t *)&v8[3], v12, 1))
    {
      uint64_t v14 = v8 + 3;
    }
    else
    {
      vm_size_t v15 = (v19 + 4104 * v10 - 1) / v19 * v19;
      v8[3].i64[1] = v15;
      vm_map_t v16 = *v13;
      uint64_t v14 = v8 + 4;
      if (!vm_allocate(v16, (vm_address_t *)&v8[4], v15, 1))
      {
        uint64_t v17 = v8[3].i64[0];
        int v18 = v10;
        do
        {
          *(void *)uint64_t v17 = 0;
          *(_DWORD *)(v17 + 8) = v10;
          *(_DWORD *)(v17 + 12) = -1;
          v17 += 16;
          --v18;
        }
        while (v18);
        v8->i32[2] = v10 >> 1;
        v8->i32[3] = 2;
        v8[2].i32[0] = 1;
        v8[1] = vdupq_n_s32(v10);
        v8->i8[0] = 1;
        operator new();
      }
    }
    v14->i64[0] = 0;
    return 1;
  }
  return v4;
}

void sub_24B723520(_Unwind_Exception *a1)
{
  uint64_t v4 = (char *)*v2;
  if (*v2)
  {
    uint64_t v5 = *(char **)(v1 + 216);
    BOOL v6 = *v2;
    if (v5 != v4)
    {
      unsigned int v7 = *(char **)(v1 + 216);
      do
      {
        int v9 = (void *)*((void *)v7 - 3);
        v7 -= 24;
        uint64_t v8 = v9;
        if (v9)
        {
          *((void *)v5 - 2) = v8;
          operator delete(v8);
        }
        uint64_t v5 = v7;
      }
      while (v7 != v4);
      BOOL v6 = *v2;
    }
    *(void *)(v1 + 216) = v4;
    operator delete(v6);
  }

  uint64_t v10 = *(void **)(v1 + 144);
  if (v10)
  {
    *(void *)(v1 + 152) = v10;
    operator delete(v10);
  }
  host_t v11 = *(std::__shared_weak_count **)(v1 + 136);
  if (v11)
  {
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_24B7235E4(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 72);
  if (v2) {
    uint64_t result = MEMORY[0x24C5D7E70](*MEMORY[0x263EF8960], v2, *(void *)(result + 64));
  }
  if (*(void *)(v1 + 88))
  {
    JUMPOUT(0x24C5D7E70);
  }
  return result;
}

void sub_24B72364C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9D820;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x24C5D7790);
}

void sub_24B7236A0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26FE9D820;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_24B7236C0(void *a1)
{
  sub_24B7236F8(a1);
  JUMPOUT(0x24C5D7790);
}

void *sub_24B7236F8(void *a1)
{
  uint64_t v2 = (void *)a1[9];
  if (v2)
  {
    a1[10] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }
  uint64_t v4 = a1[4];
  a1[4] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = a1[3];
  a1[3] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  BOOL v6 = (std::__shared_weak_count *)a1[2];
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  return a1;
}

BOOL sub_24B7237E8(float32x4_t *a1, float32x4_t *a2, int *a3, int *a4, int *a5, int *a6)
{
  char v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  m = 0;
  vm_size_t v12 = 0;
  v101[1] = *MEMORY[0x263EF8340];
  *a4 = 0x80000000;
  *a6 = 0x80000000;
  *a3 = 0x7FFFFFFF;
  *a5 = 0x7FFFFFFF;
  v101[0] = 0xBF0000003F000000;
  __asm { FMOV            V0.4S, #1.0 }
  long long v90 = _Q0;
  do
  {
    char v18 = v8;
    long long v19 = v90;
    LODWORD(v19) = *((_DWORD *)v101 + v9);
    long long v20 = v19;
    DWORD1(v20) = 0.5;
    long long v21 = v20;
    DWORD2(v21) = 0.5;
    long long v96 = v19;
    if (m >= v12)
    {
      uint64_t v23 = (m - v10) >> 4;
      unint64_t v24 = v23 + 1;
      if ((unint64_t)(v23 + 1) >> 60) {
        goto LABEL_111;
      }
      if ((v12 - v10) >> 3 > v24) {
        unint64_t v24 = (v12 - v10) >> 3;
      }
      if ((unint64_t)(v12 - v10) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v25 = v24;
      }
      long long v92 = v20;
      if (v25)
      {
        long long v86 = v21;
        if (v25 >> 60) {
          goto LABEL_112;
        }
        long long v26 = (char *)operator new(16 * v25);
        long long v19 = v96;
        long long v20 = v92;
        long long v21 = v86;
      }
      else
      {
        long long v26 = 0;
      }
      long long v27 = &v26[16 * v23];
      *(_OWORD *)long long v27 = v21;
      for (unsigned int i = v27 + 16; m != v10; v27 -= 16)
      {
        long long v28 = *((_OWORD *)m - 1);
        m -= 16;
        *((_OWORD *)v27 - 1) = v28;
      }
      vm_size_t v12 = &v26[16 * v25];
      if (v10)
      {
        operator delete(v10);
        long long v20 = v92;
        long long v19 = v96;
      }
      uint64_t v10 = v27;
    }
    else
    {
      *(_OWORD *)m = v21;
      unsigned int i = m + 16;
    }
    DWORD2(v20) = -0.5;
    if (i >= v12)
    {
      uint64_t v31 = (i - v10) >> 4;
      unint64_t v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 60) {
        goto LABEL_111;
      }
      if ((v12 - v10) >> 3 > v32) {
        unint64_t v32 = (v12 - v10) >> 3;
      }
      if ((unint64_t)(v12 - v10) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v33 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v33 = v32;
      }
      if (v33)
      {
        long long v93 = v20;
        if (v33 >> 60) {
          goto LABEL_112;
        }
        unsigned int v34 = (char *)operator new(16 * v33);
        long long v19 = v96;
        long long v20 = v93;
      }
      else
      {
        unsigned int v34 = 0;
      }
      unint64_t v29 = &v34[16 * v31];
      *(_OWORD *)unint64_t v29 = v20;
      for (CFIndex j = v29 + 16; i != v10; v29 -= 16)
      {
        long long v35 = *((_OWORD *)i - 1);
        i -= 16;
        *((_OWORD *)v29 - 1) = v35;
      }
      vm_size_t v12 = &v34[16 * v33];
      if (v10)
      {
        operator delete(v10);
        long long v19 = v96;
      }
    }
    else
    {
      *(_OWORD *)unsigned int i = v20;
      unint64_t v29 = v10;
      CFIndex j = i + 16;
    }
    DWORD1(v19) = -0.5;
    long long v36 = v19;
    DWORD2(v36) = 0.5;
    if (j >= v12)
    {
      uint64_t v39 = (j - v29) >> 4;
      unint64_t v40 = v39 + 1;
      if ((unint64_t)(v39 + 1) >> 60) {
        goto LABEL_111;
      }
      if ((v12 - v29) >> 3 > v40) {
        unint64_t v40 = (v12 - v29) >> 3;
      }
      if ((unint64_t)(v12 - v29) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v41 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v41 = v40;
      }
      long long v97 = v19;
      if (v41)
      {
        long long v94 = v36;
        if (v41 >> 60) {
          goto LABEL_112;
        }
        long long v42 = (char *)operator new(16 * v41);
        long long v19 = v97;
        long long v36 = v94;
      }
      else
      {
        long long v42 = 0;
      }
      uint64_t v37 = &v42[16 * v39];
      *(_OWORD *)uint64_t v37 = v36;
      for (k = v37 + 16; j != v29; v37 -= 16)
      {
        long long v43 = *((_OWORD *)j - 1);
        j -= 16;
        *((_OWORD *)v37 - 1) = v43;
      }
      vm_size_t v12 = &v42[16 * v41];
      if (v29)
      {
        operator delete(v29);
        long long v19 = v97;
      }
    }
    else
    {
      *(_OWORD *)CFIndex j = v36;
      uint64_t v37 = v29;
      k = j + 16;
    }
    DWORD2(v19) = -0.5;
    if (k < v12)
    {
      *(_OWORD *)k = v19;
      uint64_t v10 = v37;
      m = k + 16;
    }
    else
    {
      uint64_t v44 = (k - v37) >> 4;
      unint64_t v45 = v44 + 1;
      if ((unint64_t)(v44 + 1) >> 60) {
LABEL_111:
      }
        abort();
      if ((v12 - v37) >> 3 > v45) {
        unint64_t v45 = (v12 - v37) >> 3;
      }
      if ((unint64_t)(v12 - v37) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v46 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v46 = v45;
      }
      if (v46)
      {
        long long v98 = v19;
        if (v46 >> 60) {
LABEL_112:
        }
          sub_24B6BCD7C();
        float32x4_t v47 = (char *)operator new(16 * v46);
        long long v19 = v98;
      }
      else
      {
        float32x4_t v47 = 0;
      }
      uint64_t v10 = &v47[16 * v44];
      *(_OWORD *)uint64_t v10 = v19;
      for (m = v10 + 16; k != v37; v10 -= 16)
      {
        long long v48 = *((_OWORD *)k - 1);
        k -= 16;
        *((_OWORD *)v10 - 1) = v48;
      }
      vm_size_t v12 = &v47[16 * v46];
      if (v37) {
        operator delete(v37);
      }
    }
    char v8 = 1;
    uint64_t v9 = 1;
  }
  while ((v18 & 1) == 0);
  float32x4_t v49 = 0;
  simd_float4x4 v50 = 0;
  simd_float4x4 v51 = 0;
  for (uint64_t n = 0; n != 8; ++n)
  {
    float32x4_t v54 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a2, COERCE_FLOAT(*(_OWORD *)&v10[16 * n])), a2[1], *(float32x2_t *)&v10[16 * n], 1), a2[2], *(float32x4_t *)&v10[16 * n], 2), a2[3], *(float32x4_t *)&v10[16 * n], 3);
    if (v51 < v50)
    {
      float32x4_t *v51 = v54;
      iunsigned int i = v51 + 1;
    }
    else
    {
      uint64_t v55 = v51 - v49;
      unint64_t v56 = v55 + 1;
      if ((unint64_t)(v55 + 1) >> 60) {
        goto LABEL_111;
      }
      if (((char *)v50 - (char *)v49) >> 3 > v56) {
        unint64_t v56 = ((char *)v50 - (char *)v49) >> 3;
      }
      if ((unint64_t)((char *)v50 - (char *)v49) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v57 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v57 = v56;
      }
      if (v57)
      {
        float32x4_t v99 = v54;
        if (v57 >> 60) {
          goto LABEL_112;
        }
        char v58 = (char *)operator new(16 * v57);
        float32x4_t v54 = v99;
      }
      else
      {
        char v58 = 0;
      }
      uint64_t v59 = (float32x4_t *)&v58[16 * v55];
      *uint64_t v59 = v54;
      for (iunsigned int i = v59 + 1; v51 != v49; --v59)
      {
        float32x4_t v60 = v51[-1];
        --v51;
        v59[-1] = v60;
      }
      simd_float4x4 v50 = (float32x4_t *)&v58[16 * v57];
      if (v49) {
        operator delete(v49);
      }
      float32x4_t v49 = v59;
    }
    simd_float4x4 v51 = ii;
  }
  if (v10) {
    operator delete(v10);
  }
  uint64_t v61 = 0;
  int v62 = 0;
  do
  {
    float32x4_t v63 = a1[12];
    float32x4_t v64 = a1[13];
    float32x4_t v66 = a1[14];
    float32x4_t v65 = a1[15];
    float32x4_t v68 = a1[2];
    float32x4_t v67 = a1[3];
    float32x4_t v69 = a1[4];
    float32x4_t v70 = v49[v61];
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1330, memory_order_acquire) & 1) == 0)
    {
      float32x4_t v100 = v67;
      float32x4_t v91 = v68;
      float32x4_t v95 = v69;
      float32x4_t v87 = v70;
      float32x4_t v82 = v66;
      float32x4_t v83 = v65;
      float32x4_t v80 = v63;
      float32x4_t v81 = v64;
      int v78 = __cxa_guard_acquire(&qword_2697D1330);
      float32x4_t v63 = v80;
      float32x4_t v64 = v81;
      float32x4_t v66 = v82;
      float32x4_t v65 = v83;
      float32x4_t v70 = v87;
      float32x4_t v68 = v91;
      float32x4_t v69 = v95;
      float32x4_t v67 = v100;
      if (v78)
      {
        *(simd_float4x4 *)zmmword_2697D12F0 = __invert_f4(*(simd_float4x4 *)zmmword_24B72F120);
        __cxa_guard_release(&qword_2697D1330);
        float32x4_t v63 = v80;
        float32x4_t v64 = v81;
        float32x4_t v66 = v82;
        float32x4_t v65 = v83;
        float32x4_t v70 = v87;
        float32x4_t v68 = v91;
        float32x4_t v69 = v95;
        float32x4_t v67 = v100;
      }
    }
    float32x4_t v71 = vaddq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, v65.f32[0]), *(float32x4_t *)&zmmword_2697D12F0[16], *(float32x2_t *)v65.f32, 1), *(float32x4_t *)&zmmword_2697D12F0[32], v65, 2), *(float32x4_t *)&zmmword_2697D12F0[48], v65, 3), vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(
                        vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, v63.f32[0]),
                        *(float32x4_t *)&zmmword_2697D12F0[16],
                        *(float32x2_t *)v63.f32,
                        1),
                      *(float32x4_t *)&zmmword_2697D12F0[32],
                      v63,
                      2),
                    *(float32x4_t *)&zmmword_2697D12F0[48],
                    v63,
                    3),
                  v70.f32[0]),
                vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, v64.f32[0]), *(float32x4_t *)&zmmword_2697D12F0[16], *(float32x2_t *)v64.f32, 1), *(float32x4_t *)&zmmword_2697D12F0[32], v64, 2), *(float32x4_t *)&zmmword_2697D12F0[48], v64, 3), *(float32x2_t *)v70.f32, 1), vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)zmmword_2697D12F0, v66.f32[0]), *(float32x4_t *)&zmmword_2697D12F0[16],
                    *(float32x2_t *)v66.f32,
                    1),
                  *(float32x4_t *)&zmmword_2697D12F0[32],
                  v66,
                  2),
                *(float32x4_t *)&zmmword_2697D12F0[48],
                v66,
                3),
              v70,
              2));
    float v72 = fmaxf(fabsf(v71.f32[2]), 0.00000011921);
    if (v71.f32[2] >= 0.0) {
      float v73 = v72;
    }
    else {
      float v73 = -v72;
    }
    v71.i64[0] = vaddq_f32(v69, vmlaq_n_f32(vmulq_n_f32(v68, v71.f32[0] / v73), v67, v71.f32[1] / v73)).u64[0];
    if (v71.f32[2] < 0.0) {
      ++v62;
    }
    int v74 = (int)v71.f32[0];
    int v75 = (int)v71.f32[1];
    int v76 = *a3;
    if (*a3 >= (int)v71.f32[1]) {
      int v76 = (int)v71.f32[1];
    }
    *a3 = v76;
    if (*a4 > v75) {
      int v75 = *a4;
    }
    *a4 = v75;
    int v77 = *a5;
    if (*a5 >= v74) {
      int v77 = (int)v71.f32[0];
    }
    *a5 = v77;
    if (*a6 > v74) {
      int v74 = *a6;
    }
    *a6 = v74;
    ++v61;
  }
  while (v61 != 8);
  if (v49) {
    operator delete(v49);
  }
  return v62 != 8;
}

void sub_24B723E70(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  sub_24B7220DC(*(void *)(a1 + 128));
  uint64_t v4 = (void **)sub_24B721E6C(*(void *)(a1 + 128));
  int v9 = *(_DWORD *)objc_msgSend_contents(*v4, v5, v6);
  if (v9)
  {
    *(_DWORD *)a2 = v9;
    *(void *)(a2 + 8) = objc_msgSend_contents(v4[1], v7, v8);
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 60);
    long long v10 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 64);
    *(_OWORD *)(a2 + 48) = v10;
    long long v11 = *(_OWORD *)(a1 + 96);
    long long v12 = *(_OWORD *)(a1 + 112);
  }
  else
  {
    if (qword_2697D1340 != -1) {
      dispatch_once(&qword_2697D1340, &unk_26FE9D888);
    }
    size_t v13 = (id)qword_2697D1338;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      sub_24B6F6D14(__p, "virtual common::PointCloudModelFrame oc::voxel_hashing::VoxelSurfaceSamplerGPU::surfacePointCloud()");
      if (v18 >= 0) {
        vm_map_t v16 = __p;
      }
      else {
        vm_map_t v16 = (void **)__p[0];
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      long long v20 = v16;
      __int16 v21 = 1026;
      int v22 = 262;
      _os_log_debug_impl(&dword_24B6B9000, v13, OS_LOG_TYPE_DEBUG, "%s:%{public}d No mesh vertices found.", buf, 0x12u);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
    }

    *(_DWORD *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    uint64_t v14 = (_OWORD *)MEMORY[0x263EF89A8];
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 60);
    long long v15 = v14[1];
    *(_OWORD *)(a2 + 32) = *v14;
    *(_OWORD *)(a2 + 48) = v15;
    long long v11 = v14[2];
    long long v12 = v14[3];
  }
  *(_OWORD *)(a2 + 64) = v11;
  *(_OWORD *)(a2 + 80) = v12;
}

uint64_t sub_24B72400C()
{
  qword_2697D1338 = (uint64_t)os_log_create("com.apple.CoreOCModules", "VoxelHashing");
  return MEMORY[0x270F9A758]();
}

void sub_24B724054(uint64_t a1)
{
  uint64_t v135 = *MEMORY[0x263EF8340];
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(a1 + 228));
  if ((v1 & 1) != 0 || (int v3 = atomic_load((unsigned int *)(a1 + 232)), v3 >= 1))
  {
    if (qword_2697D1340 != -1) {
      dispatch_once(&qword_2697D1340, &unk_26FE9D888);
    }
    uint64_t v4 = (id)qword_2697D1338;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_6;
    }
    sub_24B6F6D14(&__p, "virtual void oc::voxel_hashing::VoxelSurfaceSamplerGPU::sampleSurfacePoints()");
    if (v132.i8[15] >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    *(void *)&uint8_t buf[4] = p_p;
    *(_WORD *)&unsigned char buf[12] = 1026;
    *(_DWORD *)&buf[14] = 187;
    float v125 = "%s:%{public}d Skipping sampling task because sampling has been stopped.";
LABEL_24:
    _os_log_debug_impl(&dword_24B6B9000, v4, OS_LOG_TYPE_DEBUG, v125, buf, 0x12u);
    if (v132.i8[15] < 0) {
      operator delete(__p);
    }
    goto LABEL_6;
  }
  sub_24B72183C(*(void *)(a1 + 128));
  id v5 = objc_claimAutoreleasedReturnValue();
  int v8 = *(_DWORD *)objc_msgSend_contents(v5, v6, v7);

  if (v8)
  {
    kdebug_trace();
    long long v10 = objc_msgSend_commandBufferWithDescriptor_(*(void **)(*(void *)(a1 + 144) + 8), v9, *(void *)(a1 + 192));
    uint64_t v4 = v10;
    if (v10)
    {
      long long v11 = v10;
      sub_24B72183C(*(void *)(a1 + 128));
      id v12 = objc_claimAutoreleasedReturnValue();
      long long v15 = (void *)*(unsigned int *)objc_msgSend_contents(v12, v13, v14);
      char v18 = objc_msgSend_computeCommandEncoder(v11, v16, v17);
      objc_msgSend_setLabel_(v18, v19, @"ResetMeshDataInUpdatedVoxelBlocks Encoder");
      objc_msgSend_setComputePipelineState_(v18, v20, *(void *)(a1 + 160));
      objc_msgSend_setBytes_length_atIndex_(v18, v21, a1 + 12, 48, 0);
      objc_msgSend_setBuffer_offset_atIndex_(v18, v22, (uint64_t)v12, 0, 1);
      uint64_t v23 = sub_24B7216F8(*(void *)(a1 + 128));
      objc_msgSend_setBuffer_offset_atIndex_(v18, v24, (uint64_t)v23, 0, 2);

      unint64_t v25 = sub_24B720E24(*(void *)(a1 + 128));
      objc_msgSend_setBuffer_offset_atIndex_(v18, v26, (uint64_t)v25, 0, 3);

      long long v27 = sub_24B720F64(*(void *)(a1 + 128));
      objc_msgSend_setBuffer_offset_atIndex_(v18, v28, (uint64_t)v27, 0, 4);

      unint64_t v29 = sub_24B721980(*(void *)(a1 + 128));
      objc_msgSend_setBuffer_offset_atIndex_(v18, v30, (uint64_t)v29, 0, 5);

      uint64_t v33 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 160), v31, v32);
      simd_float4x4 __p = v15;
      int64x2_t v132 = vdupq_n_s64(1uLL);
      *(void *)simd_float4x4 buf = v33;
      *(int64x2_t *)&uint8_t buf[8] = v132;
      objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v18, v34, (uint64_t)&__p, buf);
      objc_msgSend_endEncoding(v18, v35, v36);

      uint64_t v37 = v11;
      uint64_t v133 = sub_24B721BFC(*(void *)(a1 + 128));
      sub_24B72183C(*(void *)(a1 + 128));
      id v38 = objc_claimAutoreleasedReturnValue();
      unint64_t v41 = (void *)*(unsigned int *)objc_msgSend_contents(v38, v39, v40);
      uint64_t v44 = objc_msgSend_computeCommandEncoder(v37, v42, v43);
      objc_msgSend_setLabel_(v44, v45, @"GetVoxelBlocksSurroundingUpdatedVoxelBlocks Encoder");
      objc_msgSend_setComputePipelineState_(v44, v46, *(void *)(a1 + 168));
      objc_msgSend_setBytes_length_atIndex_(v44, v47, a1 + 12, 48, 0);
      objc_msgSend_setBytes_length_atIndex_(v44, v48, **(void **)(a1 + 152), *(void *)(*(void *)(a1 + 152) + 8) - **(void **)(a1 + 152), 1);
      objc_msgSend_setBytes_length_atIndex_(v44, v49, (uint64_t)&v133, 4, 2);
      simd_float4x4 v50 = sub_24B720E24(*(void *)(a1 + 128));
      objc_msgSend_setBuffer_offset_atIndex_(v44, v51, (uint64_t)v50, 0, 3);

      id v52 = sub_24B720F64(*(void *)(a1 + 128));
      objc_msgSend_setBuffer_offset_atIndex_(v44, v53, (uint64_t)v52, 0, 4);

      objc_msgSend_setBuffer_offset_atIndex_(v44, v54, (uint64_t)v38, 0, 5);
      uint64_t v55 = sub_24B7216F8(*(void *)(a1 + 128));
      objc_msgSend_setBuffer_offset_atIndex_(v44, v56, (uint64_t)v55, 0, 6);

      objc_msgSend_setBuffer_offset_atIndex_(v44, v57, *(void *)(a1 + 200), 0, 7);
      uint64_t v60 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 168), v58, v59);
      simd_float4x4 __p = v41;
      int64x2_t v132 = vdupq_n_s64(1uLL);
      *(void *)simd_float4x4 buf = v60;
      *(int64x2_t *)&uint8_t buf[8] = v132;
      objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v44, v61, (uint64_t)&__p, buf);
      objc_msgSend_endEncoding(v44, v62, v63);

      float32x4_t v64 = v37;
      sub_24B72183C(*(void *)(a1 + 128));
      id v65 = objc_claimAutoreleasedReturnValue();
      LODWORD(v41) = *(_DWORD *)objc_msgSend_contents(v65, v66, v67);
      float32x4_t v70 = objc_msgSend_computeCommandEncoder(v64, v68, v69);
      objc_msgSend_setLabel_(v70, v71, @"ComputeMeshVerticesInUpdatedVoxelBlocks Encoder");
      objc_msgSend_setComputePipelineState_(v70, v72, *(void *)(a1 + 176));
      objc_msgSend_setBytes_length_atIndex_(v70, v73, a1 + 12, 48, 0);
      objc_msgSend_setBuffer_offset_atIndex_(v70, v74, (uint64_t)v65, 0, 1);
      int v75 = sub_24B7216F8(*(void *)(a1 + 128));
      objc_msgSend_setBuffer_offset_atIndex_(v70, v76, (uint64_t)v75, 0, 2);

      int v77 = sub_24B720E24(*(void *)(a1 + 128));
      objc_msgSend_setBuffer_offset_atIndex_(v70, v78, (uint64_t)v77, 0, 3);

      objc_msgSend_setBuffer_offset_atIndex_(v70, v79, *(void *)(a1 + 200), 0, 4);
      objc_msgSend_setBuffer_offset_atIndex_(v70, v80, *(void *)(a1 + 216), 0, 5);
      objc_msgSend_setBuffer_offset_atIndex_(v70, v81, *(void *)(a1 + 208), 0, 6);
      float32x4_t v82 = sub_24B720F64(*(void *)(a1 + 128));
      objc_msgSend_setBuffer_offset_atIndex_(v70, v83, (uint64_t)v82, 0, 7);

      float v84 = sub_24B721980(*(void *)(a1 + 128));
      objc_msgSend_setBuffer_offset_atIndex_(v70, v85, (uint64_t)v84, 0, 8);

      simd_float4x4 __p = (void *)(729 * v41);
      int64x2_t v132 = vdupq_n_s64(1uLL);
      *(void *)&uint8_t buf[16] = 1;
      *(_OWORD *)simd_float4x4 buf = xmmword_24B72EC30;
      objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v70, v86, (uint64_t)&__p, buf);
      objc_msgSend_endEncoding(v70, v87, v88);

      if (*(unsigned char *)(a1 + 292))
      {
        long long v90 = v64;
        sub_24B72183C(*(void *)(a1 + 128));
        id v91 = objc_claimAutoreleasedReturnValue();
        int v94 = *(_DWORD *)objc_msgSend_contents(v91, v92, v93);
        uint64_t v133 = sub_24B721BFC(*(void *)(a1 + 128));
        long long v97 = objc_msgSend_computeCommandEncoder(v90, v95, v96);
        objc_msgSend_setLabel_(v97, v98, @"GenerateMeshFacesInUpdatedVoxelBlocks Encoder");
        objc_msgSend_setComputePipelineState_(v97, v99, *(void *)(a1 + 184));
        objc_msgSend_setBytes_length_atIndex_(v97, v100, a1 + 12, 48, 0);
        objc_msgSend_setBytes_length_atIndex_(v97, v101, **(void **)(a1 + 152), *(void *)(*(void *)(a1 + 152) + 8) - **(void **)(a1 + 152), 1);
        objc_msgSend_setBytes_length_atIndex_(v97, v102, (uint64_t)&v133, 4, 2);
        objc_msgSend_setBuffer_offset_atIndex_(v97, v103, (uint64_t)v91, 0, 3);
        float v104 = sub_24B7216F8(*(void *)(a1 + 128));
        objc_msgSend_setBuffer_offset_atIndex_(v97, v105, (uint64_t)v104, 0, 4);

        float v106 = sub_24B720E24(*(void *)(a1 + 128));
        objc_msgSend_setBuffer_offset_atIndex_(v97, v107, (uint64_t)v106, 0, 5);

        float v108 = sub_24B720F64(*(void *)(a1 + 128));
        objc_msgSend_setBuffer_offset_atIndex_(v97, v109, (uint64_t)v108, 0, 6);

        uint64_t v110 = sub_24B721980(*(void *)(a1 + 128));
        objc_msgSend_setBuffer_offset_atIndex_(v97, v111, (uint64_t)v110, 0, 7);

        uint64_t v114 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 184), v112, v113);
        simd_float4x4 __p = (void *)(v94 << 9);
        int64x2_t v132 = vdupq_n_s64(1uLL);
        *(void *)simd_float4x4 buf = v114;
        *(int64x2_t *)&uint8_t buf[8] = v132;
        objc_msgSend_dispatchThreads_threadsPerThreadgroup_(v97, v115, (uint64_t)&__p, buf);
        objc_msgSend_endEncoding(v97, v116, v117);
      }
      v130[0] = MEMORY[0x263EF8330];
      v130[1] = 3221225472;
      v130[2] = sub_24B724BF0;
      void v130[3] = &unk_2652DF278;
      v130[4] = a1;
      objc_msgSend_addScheduledHandler_(v64, v89, (uint64_t)v130);
      v129[0] = MEMORY[0x263EF8330];
      v129[1] = 3221225472;
      v129[2] = sub_24B724C04;
      void v129[3] = &unk_2652DF278;
      v129[4] = a1;
      objc_msgSend_addCompletedHandler_(v64, v118, (uint64_t)v129);
      unsigned __int8 v121 = atomic_load((unsigned __int8 *)(a1 + 228));
      if ((v121 & 1) == 0)
      {
        objc_msgSend_commit(v64, v119, v120);
        objc_msgSend_waitUntilCompleted(v64, v122, v123);
      }
    }
    else
    {
      if (qword_2697D1340 != -1) {
        dispatch_once(&qword_2697D1340, &unk_26FE9D888);
      }
      uint64_t v127 = (id)qword_2697D1338;
      if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
      {
        sub_24B6F6D14(&__p, "virtual void oc::voxel_hashing::VoxelSurfaceSamplerGPU::sampleSurfacePoints()");
        int v128 = v132.i8[15] >= 0 ? &__p : (void **)__p;
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = v128;
        *(_WORD *)&unsigned char buf[12] = 1026;
        *(_DWORD *)&buf[14] = 207;
        _os_log_error_impl(&dword_24B6B9000, v127, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to sample surface points - failed to create command buffer.", buf, 0x12u);
        if (v132.i8[15] < 0) {
          operator delete(__p);
        }
      }
    }
    kdebug_trace();
  }
  else
  {
    if (qword_2697D1340 != -1) {
      dispatch_once(&qword_2697D1340, &unk_26FE9D888);
    }
    uint64_t v4 = (id)qword_2697D1338;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      sub_24B6F6D14(&__p, "virtual void oc::voxel_hashing::VoxelSurfaceSamplerGPU::sampleSurfacePoints()");
      if (v132.i8[15] >= 0) {
        id v124 = &__p;
      }
      else {
        id v124 = __p;
      }
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v124;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = 196;
      float v125 = "%s:%{public}d Skipping sampling task because no updated hash entries.";
      goto LABEL_24;
    }
  }
LABEL_6:
}

void sub_24B724A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B724BF0(uint64_t result)
{
  return result;
}

void sub_24B724C04(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v110 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = objc_msgSend_error(a2, (const char *)a2, a3);
  uint64_t v7 = v4;
  if (v4)
  {
    sub_24B704E84(v4, v5, v6);
    goto LABEL_101;
  }
  sub_24B7210A4(*(void *)(v3 + 128));
  id v8 = objc_claimAutoreleasedReturnValue();
  uint64_t v11 = *(unsigned int *)objc_msgSend_contents(v8, v9, v10);

  uint64_t v99 = v3;
  if (!v11)
  {
    if (qword_2697D1340 != -1) {
      dispatch_once(&qword_2697D1340, &unk_26FE9D888);
    }
    long long v90 = (id)qword_2697D1338;
    if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
    {
      sub_24B6F6D14(block, "void oc::voxel_hashing::VoxelSurfaceSamplerGPU::copyMeshToOutputBuffers()");
      uint64_t v93 = SHIBYTE(v101) >= 0 ? block : (void **)block[0];
      *(_DWORD *)simd_float4x4 buf = 136315394;
      float32x4_t v107 = v93;
      __int16 v108 = 1026;
      int v109 = 575;
      _os_log_debug_impl(&dword_24B6B9000, v90, OS_LOG_TYPE_DEBUG, "%s:%{public}d Skipping copy task because no voxel blocks have been allocated.", buf, 0x12u);
      if (SHIBYTE(v101) < 0) {
        operator delete(block[0]);
      }
    }

    goto LABEL_101;
  }
  kdebug_trace();
  id v12 = (void **)sub_24B721FA4(*(void *)(v3 + 128));
  long long v98 = (_DWORD *)objc_msgSend_contents(*v12, v13, v14);
  long long v97 = (_DWORD *)objc_msgSend_contents(v12[2], v15, v16);
  size_t v19 = objc_msgSend_contents(v12[1], v17, v18);
  size_t v96 = v19;
  uint64_t v20 = 0;
  int v21 = 0;
  int v22 = *(char **)(v3 + 256);
  *(void *)(v3 + 264) = v22;
  do
  {
    uint64_t v25 = *(void *)(v3 + 240);
    if (*(unsigned char *)(v25 + 17368 * v20 + 17364)) {
      unsigned int v26 = 0;
    }
    else {
      unsigned int v26 = *(_DWORD *)(v25 + 17368 * v20 + 6144);
    }
    unint64_t v27 = *(void *)(v3 + 272);
    if ((unint64_t)v22 < v27)
    {
      *(_DWORD *)int v22 = v21;
      uint64_t v23 = v22 + 4;
      goto LABEL_6;
    }
    long long v28 = *(char **)(v3 + 256);
    uint64_t v29 = (v22 - v28) >> 2;
    unint64_t v30 = v29 + 1;
    if ((unint64_t)(v29 + 1) >> 62) {
      abort();
    }
    uint64_t v31 = v27 - (void)v28;
    if (v31 >> 1 > v30) {
      unint64_t v30 = v31 >> 1;
    }
    if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v32 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v32 = v30;
    }
    if (v32)
    {
      if (v32 >> 62) {
        sub_24B6BCD7C();
      }
      size_t v19 = (size_t)operator new(4 * v32);
    }
    else
    {
      size_t v19 = 0;
    }
    uint64_t v33 = (_DWORD *)(v19 + 4 * v29);
    *uint64_t v33 = v21;
    uint64_t v23 = (char *)(v33 + 1);
    if (v22 != v28)
    {
      unint64_t v34 = v22 - 4 - v28;
      if (v34 < 0xBC)
      {
        long long v35 = v22;
        goto LABEL_27;
      }
      if (v19 + v22 - v28 - 4 - (v34 & 0xFFFFFFFFFFFFFFFCLL) > v19 + v22 - v28 - 4)
      {
        long long v35 = v22;
        do
        {
LABEL_27:
          int v36 = *((_DWORD *)v35 - 1);
          v35 -= 4;
          *--uint64_t v33 = v36;
        }
        while (v35 != v28);
        goto LABEL_28;
      }
      if (&v22[-(v34 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v22 - 4)
      {
        long long v35 = v22;
        goto LABEL_27;
      }
      if ((unint64_t)&v28[-v19] < 0x20)
      {
        long long v35 = v22;
        goto LABEL_27;
      }
      uint64_t v38 = (v34 >> 2) + 1;
      long long v35 = &v22[-4 * (v38 & 0x7FFFFFFFFFFFFFF8)];
      uint64_t v39 = (_OWORD *)(v19 + 4 * v29 - 16);
      uint64_t v40 = v22 - 16;
      uint64_t v41 = v38 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v42 = *(_OWORD *)v40;
        *(v39 - 1) = *((_OWORD *)v40 - 1);
        *uint64_t v39 = v42;
        v39 -= 2;
        v40 -= 32;
        v41 -= 8;
      }
      while (v41);
      v33 -= v38 & 0x7FFFFFFFFFFFFFF8;
      if (v38 != (v38 & 0x7FFFFFFFFFFFFFF8)) {
        goto LABEL_27;
      }
    }
LABEL_28:
    size_t v37 = v19 + 4 * v32;
    uint64_t v3 = v99;
    *(void *)(v99 + 256) = v33;
    *(void *)(v99 + 264) = v23;
    *(void *)(v99 + 272) = v37;
    if (v28) {
      operator delete(v28);
    }
LABEL_6:
    *(void *)(v3 + 264) = v23;
    if (v26 >= 0x190) {
      int v24 = 400;
    }
    else {
      int v24 = v26;
    }
    v21 += v24;
    ++v20;
    int v22 = v23;
  }
  while (v20 != v11);
  if (!v21)
  {
    uint64_t v7 = 0;
    *long long v98 = 0;
    if (*(unsigned char *)(v3 + 292))
    {
      *long long v97 = 0;
      if (qword_2697D1340 != -1) {
        dispatch_once(&qword_2697D1340, &unk_26FE9D888);
      }
      id v91 = (id)qword_2697D1338;
      if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
      {
        sub_24B6F6D14(block, "void oc::voxel_hashing::VoxelSurfaceSamplerGPU::copyMeshToOutputBuffers()");
        if (SHIBYTE(v101) >= 0) {
          float32x4_t v95 = block;
        }
        else {
          float32x4_t v95 = (void **)block[0];
        }
        *(_DWORD *)simd_float4x4 buf = 136315394;
        float32x4_t v107 = v95;
        __int16 v108 = 1026;
        int v109 = 603;
        _os_log_debug_impl(&dword_24B6B9000, v91, OS_LOG_TYPE_DEBUG, "%s:%{public}d Skip copying triangle faces because no mesh vertices found.", buf, 0x12u);
        if (SHIBYTE(v101) < 0) {
          operator delete(block[0]);
        }
        uint64_t v3 = v99;
      }
    }
    goto LABEL_100;
  }
  LODWORD(v19) = vcvtps_u32_f32((float)v11 / 10.0);
  block[0] = (void *)MEMORY[0x263EF8330];
  block[1] = (void *)3221225472;
  uint64_t v101 = sub_24B725554;
  uint64_t v102 = &unk_2652DF298;
  int v105 = v11;
  uint64_t v103 = v3;
  size_t v104 = v96;
  dispatch_apply(v19, 0, block);
  *long long v98 = v21;
  uint64_t v7 = 0;
  if (!*(unsigned char *)(v3 + 292)) {
    goto LABEL_100;
  }
  uint64_t v45 = objc_msgSend_contents(v12[3], v43, v44);
  uint64_t v46 = 0;
  unsigned int v47 = 0;
  uint64_t v48 = 16;
  while (1)
  {
    uint64_t v49 = *(void *)(v3 + 248);
    LODWORD(v50) = *(unsigned char *)(*(void *)(v3 + 240) + 17368 * v46 + 17364) ? 0 : *(_DWORD *)(v49 + 30852 * v46);
    uint64_t v50 = v50 >= 0x4B0 ? 1200 : v50;
    if (v50) {
      break;
    }
LABEL_44:
    ++v46;
    v48 += 30852;
    if (v46 == v11) {
      goto LABEL_99;
    }
  }
  simd_float4x4 v51 = (unsigned __int8 *)(v49 + v48);
  while (2)
  {
    if (v47 < *(_DWORD *)(v3 + 44))
    {
      if (((char)*(v51 - 5) & 0x80000000) == 0)
      {
        unsigned int v52 = *((_DWORD *)v51 - 3);
        if ((v52 & 0x80000000) == 0 && v52 < *(_DWORD *)(v3 + 28))
        {
          float v53 = (unsigned int *)(*(void *)(v3 + 240) + 17368 * v52 + 6144);
          if (atomic_load(v53))
          {
            uint64_t v55 = *(void *)(v3 + 248);
            int v56 = *((_DWORD *)v51 - 3);
            uint64_t v57 = *(v51 - 8);
            uint64_t v58 = *(v51 - 7);
            uint64_t v59 = *(v51 - 6);
            if (!*(unsigned char *)(v55 + 30852 * v56 + (v57 << 8) + 32 * v58 + 4 * v59 + 28804)) {
              goto LABEL_54;
            }
            int v60 = *(__int16 *)(v55 + 30852 * v56 + (v57 << 8) + 32 * v58 + 4 * v59 + 28806);
            if (v60 < 0 || !*(unsigned char *)(v55 + 30852 * v56 + (v57 << 8) + 32 * v58 + 4 * v59 + 28805)) {
              goto LABEL_54;
            }
            unsigned int v61 = (char)*(v51 - 5) + v60;
            unsigned int v62 = atomic_load(v53);
            uint64_t v3 = v99;
            if (v61 < v62 && ((char)v51[3] & 0x80000000) == 0)
            {
              unsigned int v63 = *((_DWORD *)v51 - 1);
              if ((v63 & 0x80000000) == 0 && v63 < *(_DWORD *)(v99 + 28))
              {
                float32x4_t v64 = (unsigned int *)(*(void *)(v99 + 240) + 17368 * v63 + 6144);
                if (atomic_load(v64))
                {
                  uint64_t v66 = *(void *)(v99 + 248);
                  int v67 = *((_DWORD *)v51 - 1);
                  uint64_t v68 = *v51;
                  uint64_t v69 = v51[1];
                  uint64_t v70 = v51[2];
                  if (!*(unsigned char *)(v66 + 30852 * v67 + (v68 << 8) + 32 * v69 + 4 * v70 + 28804)) {
                    goto LABEL_54;
                  }
                  int v71 = *(__int16 *)(v66 + 30852 * v67 + (v68 << 8) + 32 * v69 + 4 * v70 + 28806);
                  if (v71 < 0 || !*(unsigned char *)(v66 + 30852 * v67 + (v68 << 8) + 32 * v69 + 4 * v70 + 28805)) {
                    goto LABEL_54;
                  }
                  unsigned int v72 = (char)v51[3] + v71;
                  unsigned int v73 = atomic_load(v64);
                  uint64_t v3 = v99;
                  if (v72 < v73 && ((char)v51[11] & 0x80000000) == 0)
                  {
                    unsigned int v74 = *((_DWORD *)v51 + 1);
                    if ((v74 & 0x80000000) == 0 && v74 < *(_DWORD *)(v99 + 28))
                    {
                      int v75 = *(_DWORD *)(*(void *)(v99 + 256) + 4 * *((int *)v51 - 1));
                      int v76 = (unsigned int *)(*(void *)(v99 + 240) + 17368 * v74 + 6144);
                      if (atomic_load(v76))
                      {
                        uint64_t v78 = *(void *)(v99 + 248);
                        int v79 = *((_DWORD *)v51 + 1);
                        uint64_t v80 = v51[8];
                        uint64_t v81 = v51[9];
                        uint64_t v82 = v51[10];
                        if (*(unsigned char *)(v78 + 30852 * v79 + (v80 << 8) + 32 * v81 + 4 * v82 + 28804))
                        {
                          int v83 = *(__int16 *)(v78 + 30852 * v79 + (v80 << 8) + 32 * v81 + 4 * v82 + 28806);
                          if ((v83 & 0x80000000) == 0)
                          {
                            if (*(unsigned char *)(v78 + 30852 * v79 + (v80 << 8) + 32 * v81 + 4 * v82 + 28805))
                            {
                              unsigned int v84 = (char)v51[11] + v83;
                              unsigned int v85 = atomic_load(v76);
                              if (v84 < v85)
                              {
                                unsigned int v86 = *(_DWORD *)(*(void *)(v99 + 256) + 4 * *((int *)v51 - 3)) + v61;
                                int v87 = v75 + v72;
                                if (v86 != v75 + v72)
                                {
                                  unsigned int v88 = *(_DWORD *)(*(void *)(v99 + 256) + 4 * *((int *)v51 + 1)) + v84;
                                  if (v86 != v88 && v87 != v88)
                                  {
                                    *(_DWORD *)(v45 + 4 * v47) = v86;
                                    unsigned int v89 = v47 + 2;
                                    *(_DWORD *)(v45 + 4 * (v47 + 1)) = v87;
                                    v47 += 3;
                                    *(_DWORD *)(v45 + 4 * v89) = v88;
                                  }
                                }
                              }
                              uint64_t v7 = 0;
                            }
                          }
                        }
LABEL_54:
                        uint64_t v3 = v99;
                      }
                      else
                      {
                        uint64_t v3 = v99;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v51 += 24;
      if (!--v50) {
        goto LABEL_44;
      }
      continue;
    }
    break;
  }
  if (qword_2697D1340 != -1) {
    dispatch_once(&qword_2697D1340, &unk_26FE9D888);
  }
  long long v92 = (id)qword_2697D1338;
  if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
  {
    sub_24B6F6D14(block, "uint32_t oc::voxel_hashing::VoxelSurfaceSamplerGPU::copyTrianglesFromVoxelBlocksToOutputBuffer(const uint32_t, uint32_t *)");
    if (SHIBYTE(v101) >= 0) {
      int v94 = block;
    }
    else {
      int v94 = (void **)block[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    float32x4_t v107 = v94;
    __int16 v108 = 1026;
    int v109 = 744;
    _os_log_debug_impl(&dword_24B6B9000, v92, OS_LOG_TYPE_DEBUG, "%s:%{public}d Stopping copy task because triangle faces buffer is full.", buf, 0x12u);
    if (SHIBYTE(v101) < 0) {
      operator delete(block[0]);
    }
    uint64_t v3 = v99;
  }

LABEL_99:
  *long long v97 = v47;
LABEL_100:
  kdebug_trace();
LABEL_101:

  atomic_fetch_add((atomic_uint *volatile)(v3 + 232), 0xFFFFFFFF);
}

void sub_24B725524(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B725554(uint64_t a1, int a2)
{
  uint64_t v3 = (10 * a2);
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 32);
  LODWORD(v5) = v3 + 10;
  unsigned int v6 = *(_DWORD *)(a1 + 48);
  if (v6 >= (int)v3 + 10) {
    unint64_t v5 = v5;
  }
  else {
    unint64_t v5 = v6;
  }
  unint64_t v28 = v5;
  for (uint64_t i = 17368 * v3 + 6175; ; i += 17368)
  {
    unsigned int v8 = *(_DWORD *)(*(void *)(v4 + 256) + 4 * v3);
    if (v8 >= *(_DWORD *)(v4 + 40)) {
      break;
    }
    uint64_t v9 = *(void *)(v4 + 240);
    if (!*(unsigned char *)(v9 + 17368 * v3 + 17364))
    {
      uint64_t v10 = v9 + 17368 * v3;
      uint64_t v11 = *(unsigned int *)(v10 + 6144);
      if (v11 >= 0x191)
      {
        if (qword_2697D1340 != -1) {
          dispatch_once(&qword_2697D1340, &unk_26FE9D888);
        }
        id v12 = (id)qword_2697D1338;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          sub_24B6F6D14(__p, "uint32_t oc::voxel_hashing::VoxelSurfaceSamplerGPU::copyVerticesFromVoxelBlocksToOutputBuffer(const uint32_t, common::Point *)_block_invoke");
          int v24 = __p;
          if (v30 < 0) {
            int v24 = (void **)__p[0];
          }
          *(_DWORD *)simd_float4x4 buf = 136315394;
          unint64_t v32 = v24;
          __int16 v33 = 1026;
          int v34 = 654;
          _os_log_debug_impl(&dword_24B6B9000, v12, OS_LOG_TYPE_DEBUG, "%s:%{public}d Number of vertices in voxel block is greater than the capacity, adjusted number of vertices to the capacity.", buf, 0x12u);
          if (v30 < 0) {
            operator delete(__p[0]);
          }
        }

        uint64_t v11 = 400;
LABEL_15:
        uint64_t v13 = 0;
        uint64_t v14 = (unsigned __int8 *)(v9 + i);
        long long v15 = (unsigned __int8 *)(v9 + i);
        while (1)
        {
          int v16 = *v15;
          v15 += 28;
          if (!v16)
          {
            *(_DWORD *)(v10 + 6144) = v13;
            goto LABEL_6;
          }
          uint64_t v17 = (_OWORD *)(*(void *)(a1 + 40) + 48 * (v8 + v13));
          long long v18 = *v17;
          long long v19 = v17[1];
          LODWORD(v18) = *(_DWORD *)(v14 - 27);
          *(_DWORD *)uint64_t v17 = v18;
          DWORD1(v18) = *(_DWORD *)(v14 - 23);
          *uint64_t v17 = v18;
          DWORD2(v18) = *(_DWORD *)(v14 - 19);
          HIDWORD(v18) = 1.0;
          *uint64_t v17 = v18;
          unsigned int v20 = *(_DWORD *)(v14 - 15);
          LODWORD(v19) = v20;
          *((_DWORD *)v17 + 4) = v20;
          DWORD1(v19) = *(_DWORD *)(v14 - 11);
          v17[1] = v19;
          *((void *)&v19 + 1) = *(unsigned int *)(v14 - 7);
          v17[1] = v19;
          LOBYTE(v20) = *(v14 - 3);
          float v21 = (float)v20 / 255.0;
          long long v22 = v17[2];
          *(float *)&long long v22 = v21;
          *((float *)v17 + 8) = v21;
          LOBYTE(v21) = *(v14 - 2);
          *(float *)&unsigned int v23 = (float)LODWORD(v21) / 255.0;
          DWORD1(v22) = v23;
          void v17[2] = v22;
          LOBYTE(v23) = *(v14 - 1);
          *((void *)&v22 + 1) = __PAIR64__(1.0, (float)v23 / 255.0);
          void v17[2] = v22;
          if (v8 + v13 + 1 >= *(_DWORD *)(v4 + 40)) {
            break;
          }
          ++v13;
          uint64_t v14 = v15;
          if (v11 == v13) {
            goto LABEL_6;
          }
        }
        if (qword_2697D1340 != -1) {
          dispatch_once(&qword_2697D1340, &unk_26FE9D888);
        }
        uint64_t v25 = (id)qword_2697D1338;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        {
          sub_24B6F6D14(__p, "uint32_t oc::voxel_hashing::VoxelSurfaceSamplerGPU::copyVerticesFromVoxelBlocksToOutputBuffer(const uint32_t, common::Point *)_block_invoke");
          if (v30 >= 0) {
            unsigned int v26 = __p;
          }
          else {
            unsigned int v26 = (void **)__p[0];
          }
          *(_DWORD *)simd_float4x4 buf = 136315394;
          unint64_t v32 = v26;
          __int16 v33 = 1026;
          int v34 = 677;
LABEL_40:
          _os_log_debug_impl(&dword_24B6B9000, v25, OS_LOG_TYPE_DEBUG, "%s:%{public}d Stopping copy task because vertex buffer is full.", buf, 0x12u);
          if (v30 < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_34;
        }
        goto LABEL_34;
      }
      if (*(_DWORD *)(v10 + 6144)) {
        goto LABEL_15;
      }
    }
LABEL_6:
    if (++v3 >= v28) {
      return;
    }
  }
  if (qword_2697D1340 != -1) {
    dispatch_once(&qword_2697D1340, &unk_26FE9D888);
  }
  uint64_t v25 = (id)qword_2697D1338;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
  {
    sub_24B6F6D14(__p, "uint32_t oc::voxel_hashing::VoxelSurfaceSamplerGPU::copyVerticesFromVoxelBlocksToOutputBuffer(const uint32_t, common::Point *)_block_invoke");
    if (v30 >= 0) {
      unint64_t v27 = __p;
    }
    else {
      unint64_t v27 = (void **)__p[0];
    }
    *(_DWORD *)simd_float4x4 buf = 136315394;
    unint64_t v32 = v27;
    __int16 v33 = 1026;
    int v34 = 636;
    goto LABEL_40;
  }
LABEL_34:
}

uint64_t sub_24B725984(uint64_t a1, uint64_t a2)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  float v2 = *(float *)(a2 + 4);
  if (*(_DWORD *)a2) {
    BOOL v3 = v2 < 0.0001;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3 || *(unsigned char *)(a2 + 8) == 0) {
    goto LABEL_11;
  }
  float32x4_t v7 = *(float32x4_t *)(a2 + 16);
  float32x4_t v8 = *(float32x4_t *)(a2 + 32);
  unsigned int v6 = (long long *)(a2 + 16);
  float32x4_t v9 = *(float32x4_t *)(a2 + 48);
  float32x4_t v10 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
  float32x4_t v11 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
  float32x4_t v12 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v13 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v12, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v7, *(float32x2_t *)v7.f32, 1), v8, *(float32x2_t *)v8.f32, 1), v9, *(float32x2_t *)v9.f32, 1), v10)), (int8x16_t)vcgeq_f32(v12, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v7, v7.f32[0]), v8, v8.f32[0]),
                                         v9,
                                         v9.f32[0]),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v12, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v7, v7, 2), v8, v8, 2), v9, v9, 2), v11)));
  v13.i32[3] = v13.i32[2];
  if ((vminvq_u32(v13) & 0x80000000) == 0) {
    goto LABEL_11;
  }
  float32x4_t v14 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2);
  float32x4_t v15 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v7, (int32x4_t)v9), (int32x4_t)v14);
  float32x4_t v16 = (float32x4_t)vtrn2q_s32((int32x4_t)v7, (int32x4_t)v8);
  v16.i32[2] = HIDWORD(*(void *)(a2 + 48));
  float32x4_t v17 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v7, (int32x4_t)v9), (int32x4_t)v8);
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
  uint32x4_t v19 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v18, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v17, v8.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1), v16), v14, v15), v10)), (int8x16_t)vcgeq_f32(v18, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v17, v7.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1),
                                           v16),
                                         (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2),
                                         v15),
                                       *MEMORY[0x263EF89A0]))),
                      (int8x16_t)vcgeq_f32(v18, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v17, v9.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1), v16), (float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), v15), v11)));
  v19.i32[3] = v19.i32[2];
  if ((vminvq_u32(v19) & 0x80000000) == 0) {
    goto LABEL_11;
  }
  float32x4_t v20 = vmulq_f32(v7, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v9, (int8x16_t)v9, 0xCuLL), (int8x16_t)v9, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL), (int8x16_t)v8, 8uLL)));
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0]+ -1.0) <= 0.000011&& (v24 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v7, (int8x16_t)v7, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v8, (int8x16_t)v8, 8uLL))), float32x2_t v25 = (float32x2_t)vdup_n_s32(0x38D1B717u), v26 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v25, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(
                                                                                    *(int8x16_t *)(a2 + 64),
                                                                                    *(int8x16_t *)(a2 + 64),
                                                                                    8uLL)),
                                            (float32x2_t)0xBF80000080000000))),
                            (int8x8_t)vcge_f32(v25, v24)),
        (vpmin_u32(v26, v26).u32[0] & 0x80000000) != 0)
    && *(_DWORD *)(a2 + 80) != 2
    && *(float *)(a2 + 84) >= 0.0)
  {
    if (*(void *)(a1 + 144))
    {
      uint64_t v28 = *(void *)(a1 + 128);
      if (v28 && *(unsigned char *)(v28 + 8))
      {
        if (!*(unsigned char *)(a1 + 8))
        {
          *(float *)(a1 + 60) = v2;
          long long v29 = *v6;
          long long v30 = v6[1];
          long long v31 = v6[3];
          *(_OWORD *)(a1 + 96) = v6[2];
          *(_OWORD *)(a1 + 112) = v31;
          *(_OWORD *)(a1 + 64) = v29;
          *(_OWORD *)(a1 + 80) = v30;
          sub_24B720CD0((uint64_t)__p, v28);
          if (v58)
          {
            *(_OWORD *)(a1 + 12) = *(_OWORD *)__p;
            *(_OWORD *)(a1 + 24) = *(_OWORD *)&__p[12];
            *(_DWORD *)(a1 + 40) = sub_24B7208A8(*(void *)(a1 + 128));
            *(_DWORD *)(a1 + 44) = sub_24B7209D4(*(void *)(a1 + 128));
            LOBYTE(v32) = *(unsigned char *)(a2 + 8);
            *(float *)(a1 + 48) = (float)v32;
            unsigned int v33 = *(_DWORD *)(a1 + 28);
            if (v33 >= 0xA) {
              unsigned int v33 = 10;
            }
            *(_DWORD *)(a1 + 52) = v33;
            *(_DWORD *)(a1 + 56) = 1024;
            *(_DWORD *)(a1 + 288) = *(_DWORD *)(a2 + 80);
            *(unsigned char *)(a1 + 292) = *(unsigned char *)(a2 + 88);
            if (**(void **)(a1 + 152) == *(void *)(*(void *)(a1 + 152) + 8))
            {
              float v21 = sub_24B726388();
              if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
                goto LABEL_14;
              }
              sub_24B6F6D14(buf, "virtual BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::init(const InitConfig &)");
              if (v62 >= 0) {
                unsigned int v52 = buf;
              }
              else {
                unsigned int v52 = *(unsigned char **)buf;
              }
              *(_DWORD *)unsigned int v63 = 136315394;
              float32x4_t v64 = v52;
              __int16 v65 = 1026;
              int v66 = 126;
              uint64_t v49 = "%s:%{public}d Failed to initialize VoxelSurfaceSamplerGPU - hashtable extents is empty.";
            }
            else if (sub_24B7263DC(a1))
            {
              if (sub_24B726F74(a1))
              {
                sub_24B727338(*(void **)(a1 + 208), v34, v35);
                if (*(_DWORD *)(a1 + 288) == 1)
                {
                  *(_DWORD *)(a1 + 224) = *(_DWORD *)(a2 + 84);
                  sub_24B7273B0(a1, v36, v37);
                }
                id v38 = objc_alloc_init(MEMORY[0x263F12810]);
                uint64_t v39 = *(void **)(a1 + 192);
                *(void *)(a1 + 192) = v38;

                uint64_t v41 = *(void **)(a1 + 192);
                if (v41)
                {
                  objc_msgSend_setErrorOptions_(v41, v40, 1);
                  sub_24B720F64(*(void *)(a1 + 128));
                  id v42 = objc_claimAutoreleasedReturnValue();
                  *(void *)(a1 + 240) = objc_msgSend_contents(v42, v43, v44);

                  if (*(unsigned char *)(a1 + 292))
                  {
                    sub_24B721980(*(void *)(a1 + 128));
                    id v45 = objc_claimAutoreleasedReturnValue();
                    *(void *)(a1 + 248) = objc_msgSend_contents(v45, v46, v47);
                  }
                  sub_24B70E070();
                }
                float v21 = sub_24B726388();
                if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_14;
                }
                sub_24B6F6D14(buf, "virtual BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::init(const InitConfig &)");
                if (v62 >= 0) {
                  int v56 = buf;
                }
                else {
                  int v56 = *(unsigned char **)buf;
                }
                *(_DWORD *)unsigned int v63 = 136315394;
                float32x4_t v64 = v56;
                __int16 v65 = 1026;
                int v66 = 152;
                uint64_t v49 = "%s:%{public}d Failed to initialize VoxelSurfaceSamplerGPU - failed to command buffer descriptor.";
              }
              else
              {
                float v21 = sub_24B726388();
                if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_14;
                }
                sub_24B6F6D14(buf, "virtual BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::init(const InitConfig &)");
                if (v62 >= 0) {
                  uint64_t v55 = buf;
                }
                else {
                  uint64_t v55 = *(unsigned char **)buf;
                }
                *(_DWORD *)unsigned int v63 = 136315394;
                float32x4_t v64 = v55;
                __int16 v65 = 1026;
                int v66 = 138;
                uint64_t v49 = "%s:%{public}d Failed to initialize VoxelSurfaceSamplerGPU - failed to create buffers.";
              }
            }
            else
            {
              float v21 = sub_24B726388();
              if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
                goto LABEL_14;
              }
              sub_24B6F6D14(buf, "virtual BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::init(const InitConfig &)");
              if (v62 >= 0) {
                float v53 = buf;
              }
              else {
                float v53 = *(unsigned char **)buf;
              }
              *(_DWORD *)unsigned int v63 = 136315394;
              float32x4_t v64 = v53;
              __int16 v65 = 1026;
              int v66 = 132;
              uint64_t v49 = "%s:%{public}d Failed to initialize VoxelSurfaceSamplerGPU - failed to create pipeline states.";
            }
          }
          else
          {
            float v21 = sub_24B726388();
            if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
              goto LABEL_14;
            }
            sub_24B6F6D14(buf, "virtual BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::init(const InitConfig &)");
            if (v62 >= 0) {
              uint64_t v48 = buf;
            }
            else {
              uint64_t v48 = *(unsigned char **)buf;
            }
            *(_DWORD *)unsigned int v63 = 136315394;
            float32x4_t v64 = v48;
            __int16 v65 = 1026;
            int v66 = 107;
            uint64_t v49 = "%s:%{public}d Failed to initialize VoxelSurfaceSamplerGPU - failed to get hash table parameters.";
          }
          _os_log_error_impl(&dword_24B6B9000, v21, OS_LOG_TYPE_ERROR, v49, v63, 0x12u);
          if (v62 < 0) {
            operator delete(*(void **)buf);
          }
          goto LABEL_14;
        }
        if (qword_2697D1340 != -1) {
          dispatch_once(&qword_2697D1340, &unk_26FE9D888);
        }
        float v21 = (id)qword_2697D1338;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::init(const InitConfig &)");
          float32x4_t v54 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
          *(_DWORD *)simd_float4x4 buf = 136315394;
          *(void *)&uint8_t buf[4] = v54;
          __int16 v60 = 1026;
          int v61 = 95;
          _os_log_error_impl(&dword_24B6B9000, v21, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to initialize VoxelSurfaceSamplerGPU - already initialized.", buf, 0x12u);
          if ((__p[23] & 0x80000000) != 0) {
LABEL_65:
          }
            operator delete(*(void **)__p);
        }
      }
      else
      {
        if (qword_2697D1340 != -1) {
          dispatch_once(&qword_2697D1340, &unk_26FE9D888);
        }
        float v21 = (id)qword_2697D1338;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::init(const InitConfig &)");
          uint64_t v50 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
          *(_DWORD *)simd_float4x4 buf = 136315394;
          *(void *)&uint8_t buf[4] = v50;
          __int16 v60 = 1026;
          int v61 = 89;
          _os_log_error_impl(&dword_24B6B9000, v21, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to initialize VoxelSurfaceSamplerGPU - invalid voxelHashingData or it's not initialized.", buf, 0x12u);
          if ((__p[23] & 0x80000000) != 0) {
            goto LABEL_65;
          }
        }
      }
    }
    else
    {
      if (qword_2697D1340 != -1) {
        dispatch_once(&qword_2697D1340, &unk_26FE9D888);
      }
      float v21 = (id)qword_2697D1338;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::init(const InitConfig &)");
        simd_float4x4 v51 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)simd_float4x4 buf = 136315394;
        *(void *)&uint8_t buf[4] = v51;
        __int16 v60 = 1026;
        int v61 = 82;
        _os_log_error_impl(&dword_24B6B9000, v21, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to initialize VoxelSurfaceSamplerGPU - failed to get MTLDeviceContext.", buf, 0x12u);
        if ((__p[23] & 0x80000000) != 0) {
          goto LABEL_65;
        }
      }
    }
  }
  else
  {
LABEL_11:
    if (qword_2697D1340 != -1) {
      dispatch_once(&qword_2697D1340, &unk_26FE9D888);
    }
    float v21 = (id)qword_2697D1338;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      sub_24B6F6D14(__p, "virtual BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::init(const InitConfig &)");
      unsigned int v23 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
      *(_DWORD *)simd_float4x4 buf = 136315394;
      *(void *)&uint8_t buf[4] = v23;
      __int16 v60 = 1026;
      int v61 = 76;
      _os_log_error_impl(&dword_24B6B9000, v21, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to initialize VoxelSurfaceSamplerGPU - invalid init config.", buf, 0x12u);
      if ((__p[23] & 0x80000000) != 0) {
        goto LABEL_65;
      }
    }
  }
LABEL_14:

  return 0;
}

void sub_24B726370(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_24B726388()
{
  if (qword_2697D1340 != -1) {
    dispatch_once(&qword_2697D1340, &unk_26FE9D888);
  }
  uint64_t v0 = (void *)qword_2697D1338;
  return v0;
}

uint64_t sub_24B7263DC(uint64_t a1)
{
  uint64_t v111 = *MEMORY[0x263EF8340];
  id v2 = objc_alloc_init(MEMORY[0x263F128B0]);
  int v99 = *(_DWORD *)(a1 + 288);
  objc_msgSend_setConstantValue_type_atIndex_(v2, v3, (uint64_t)&v99, 33, 0);
  objc_msgSend_setConstantValue_type_atIndex_(v2, v4, a1 + 292, 53, 1);
  id v5 = *(id *)(*(void *)(a1 + 144) + 16);
  id v98 = 0;
  float32x4_t v7 = objc_msgSend_newFunctionWithName_constantValues_error_(v5, v6, @"oc::voxel_hashing::resetMeshDataInUpdatedVoxelBlocks", v2, &v98);
  id v8 = v98;

  if (v7)
  {
    id v9 = **(id **)(a1 + 144);
    id v97 = v8;
    uint64_t v11 = objc_msgSend_newComputePipelineStateWithFunction_error_(v9, v10, (uint64_t)v7, &v97);
    id v12 = v97;

    uint32x4_t v13 = *(void **)(a1 + 160);
    *(void *)(a1 + 160) = v11;

    if (!*(void *)(a1 + 160))
    {
      if (qword_2697D1340 != -1) {
        dispatch_once(&qword_2697D1340, &unk_26FE9D888);
      }
      float32x4_t v15 = (id)qword_2697D1338;
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_22;
      }
      sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createPipelineState()");
      int v61 = v110;
      char v62 = *(unsigned char **)__p;
      uint64_t v65 = objc_msgSend_localizedDescription(v12, v63, v64);
      int v66 = (void *)v65;
      uint64_t v67 = v61 >= 0 ? __p : v62;
      *(_DWORD *)simd_float4x4 buf = 136315650;
      *(void *)&uint8_t buf[4] = v67;
      __int16 v101 = 1026;
      int v102 = 303;
      __int16 v103 = 2114;
      uint64_t v104 = v65;
      _os_log_error_impl(&dword_24B6B9000, v15, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for resetMeshDataInUpdatedVoxelBlocks compute shader. Error details: %{public}@", buf, 0x1Cu);

      if (v110 < 0)
      {
        operator delete(*(void **)__p);
        uint64_t v40 = 0;
      }
      else
      {
LABEL_22:
        uint64_t v40 = 0;
      }
      goto LABEL_74;
    }
    float32x4_t v15 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)(a1 + 144) + 16), v14, @"oc::voxel_hashing::getVoxelBlocksSurroundingUpdatedVoxelBlocks");
    if (!v15)
    {
      if (qword_2697D1340 != -1) {
        dispatch_once(&qword_2697D1340, &unk_26FE9D888);
      }
      uint64_t v41 = (id)qword_2697D1338;
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createPipelineState()");
        uint64_t v70 = (v104 & 0x80000000) == 0 ? buf : *(unsigned char **)buf;
        *(_DWORD *)simd_float4x4 __p = 136315394;
        *(void *)&__p[4] = v70;
        __int16 v108 = 1026;
        int v109 = 311;
        _os_log_error_impl(&dword_24B6B9000, v41, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to find getVoxelBlocksSurroundingUpdatedVoxelBlocks compute shader.", __p, 0x12u);
        if (SBYTE3(v104) < 0) {
          operator delete(*(void **)buf);
        }
      }
      uint64_t v40 = 0;
      goto LABEL_73;
    }
    id v16 = **(id **)(a1 + 144);
    id v96 = v12;
    uint64_t v18 = objc_msgSend_newComputePipelineStateWithFunction_error_(v16, v17, (uint64_t)v15, &v96);
    id v19 = v96;

    float32x4_t v20 = *(void **)(a1 + 168);
    *(void *)(a1 + 168) = v18;

    if (!*(void *)(a1 + 168))
    {
      if (qword_2697D1340 != -1) {
        dispatch_once(&qword_2697D1340, &unk_26FE9D888);
      }
      uint64_t v41 = (id)qword_2697D1338;
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createPipelineState()");
        int v72 = v110;
        unsigned int v73 = *(unsigned char **)__p;
        uint64_t v76 = objc_msgSend_localizedDescription(v19, v74, v75);
        int v77 = (void *)v76;
        uint64_t v78 = v72 >= 0 ? __p : v73;
        *(_DWORD *)simd_float4x4 buf = 136315650;
        *(void *)&uint8_t buf[4] = v78;
        __int16 v101 = 1026;
        int v102 = 321;
        __int16 v103 = 2114;
        uint64_t v104 = v76;
        _os_log_error_impl(&dword_24B6B9000, v41, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for getVoxelBlocksSurroundingUpdatedVoxelBlocks compute shader. Error details: %{public}@", buf, 0x1Cu);

        if (v110 < 0) {
          operator delete(*(void **)__p);
        }
      }
      uint64_t v40 = 0;
      id v12 = v19;
      goto LABEL_73;
    }
    id v21 = *(id *)(*(void *)(a1 + 144) + 16);
    id v95 = v19;
    uint64_t v23 = objc_msgSend_newFunctionWithName_constantValues_error_(v21, v22, @"oc::voxel_hashing::computeMeshVerticesInUpdatedVoxelBlocks", v2, &v95);
    id v12 = v95;

    if (!v23)
    {
      if (qword_2697D1340 != -1) {
        dispatch_once(&qword_2697D1340, &unk_26FE9D888);
      }
      unsigned int v33 = (id)qword_2697D1338;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createPipelineState()");
        int v79 = v110;
        uint64_t v80 = *(unsigned char **)__p;
        uint64_t v83 = objc_msgSend_localizedDescription(v12, v81, v82);
        unsigned int v84 = (void *)v83;
        unsigned int v85 = v79 >= 0 ? __p : v80;
        *(_DWORD *)simd_float4x4 buf = 136315650;
        *(void *)&uint8_t buf[4] = v85;
        __int16 v101 = 1026;
        int v102 = 333;
        __int16 v103 = 2114;
        uint64_t v104 = v83;
        _os_log_error_impl(&dword_24B6B9000, v33, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed find computeMeshVerticesInUpdatedVoxelBlocks compute shader. Error details: %{public}@", buf, 0x1Cu);

        if (v110 < 0) {
          operator delete(*(void **)__p);
        }
      }
      uint64_t v40 = 0;
      goto LABEL_72;
    }
    id v24 = **(id **)(a1 + 144);
    id v94 = v12;
    uint64_t v26 = objc_msgSend_newComputePipelineStateWithFunction_error_(v24, v25, v23, &v94);
    id v27 = v94;

    uint64_t v28 = *(void **)(a1 + 176);
    *(void *)(a1 + 176) = v26;

    long long v31 = *(void **)(a1 + 176);
    if (v31)
    {
      if ((unint64_t)objc_msgSend_maxTotalThreadsPerThreadgroup(v31, v29, v30) > 0x2D8)
      {
        unsigned int v33 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)(a1 + 144) + 16), v32, @"oc::voxel_hashing::generateMeshFacesInUpdatedVoxelBlocks");
        if (v33)
        {
          id v49 = **(id **)(a1 + 144);
          id v93 = v27;
          uint64_t v51 = objc_msgSend_newComputePipelineStateWithFunction_error_(v49, v50, (uint64_t)v33, &v93);
          id v12 = v93;

          float v53 = *(void **)(a1 + 184);
          unsigned int v52 = (uint64_t *)(a1 + 184);
          uint64_t *v52 = v51;

          if (*v52)
          {
            uint64_t v40 = 1;
LABEL_72:

            uint64_t v41 = v23;
LABEL_73:

LABEL_74:
            id v8 = v12;
            goto LABEL_75;
          }
          uint64_t v68 = sub_24B726388();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
          {
            sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createPipelineState()");
            int v86 = v110;
            int v87 = *(unsigned char **)__p;
            uint64_t v90 = objc_msgSend_localizedDescription(v12, v88, v89);
            id v91 = (void *)v90;
            long long v92 = __p;
            if (v86 < 0) {
              long long v92 = v87;
            }
            *(_DWORD *)simd_float4x4 buf = 136315650;
            *(void *)&uint8_t buf[4] = v92;
            __int16 v101 = 1026;
            int v102 = 370;
            __int16 v103 = 2114;
            uint64_t v104 = v90;
            _os_log_error_impl(&dword_24B6B9000, v68, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for generateMeshFacesInUpdatedVoxelBlocks compute shader. Error details: %{public}@", buf, 0x1Cu);

            if (v110 < 0) {
              operator delete(*(void **)__p);
            }
          }
          id v27 = v12;
        }
        else
        {
          uint64_t v68 = sub_24B726388();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
          {
            sub_24B6F6D14(buf, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createPipelineState()");
            uint64_t v69 = (v104 & 0x80000000) == 0 ? buf : *(unsigned char **)buf;
            *(_DWORD *)simd_float4x4 __p = 136315394;
            *(void *)&__p[4] = v69;
            __int16 v108 = 1026;
            int v109 = 361;
            _os_log_error_impl(&dword_24B6B9000, v68, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed find generateMeshFacesInUpdatedVoxelBlocks compute shader.", __p, 0x12u);
            if (SBYTE3(v104) < 0) {
              operator delete(*(void **)buf);
            }
          }
        }

LABEL_71:
        uint64_t v40 = 0;
        id v12 = v27;
        goto LABEL_72;
      }
      if (qword_2697D1340 != -1) {
        dispatch_once(&qword_2697D1340, &unk_26FE9D888);
      }
      unsigned int v33 = (id)qword_2697D1338;
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        goto LABEL_71;
      }
      sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createPipelineState()");
      int v34 = v110;
      uint64_t v35 = *(unsigned char **)__p;
      uint64_t v38 = objc_msgSend_maxTotalThreadsPerThreadgroup(*(void **)(a1 + 176), v36, v37);
      if (v34 >= 0) {
        uint64_t v39 = __p;
      }
      else {
        uint64_t v39 = v35;
      }
      *(_DWORD *)simd_float4x4 buf = 136315906;
      *(void *)&uint8_t buf[4] = v39;
      __int16 v101 = 1026;
      int v102 = 353;
      __int16 v103 = 2050;
      uint64_t v104 = v38;
      __int16 v105 = 1026;
      int v106 = 729;
      _os_log_error_impl(&dword_24B6B9000, v33, OS_LOG_TYPE_ERROR, "%s:%{public}d maxTotalThreadsPerThreadgroup = %{public}lu in computeMeshVerticesInUpdatedVoxelBlocks compute shader is less than the minimum required %{public}u", buf, 0x22u);
    }
    else
    {
      if (qword_2697D1340 != -1) {
        dispatch_once(&qword_2697D1340, &unk_26FE9D888);
      }
      unsigned int v33 = (id)qword_2697D1338;
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        goto LABEL_71;
      }
      sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createPipelineState()");
      int v42 = v110;
      uint64_t v43 = *(unsigned char **)__p;
      uint64_t v46 = objc_msgSend_localizedDescription(v27, v44, v45);
      uint64_t v47 = (void *)v46;
      if (v42 >= 0) {
        uint64_t v48 = __p;
      }
      else {
        uint64_t v48 = v43;
      }
      *(_DWORD *)simd_float4x4 buf = 136315650;
      *(void *)&uint8_t buf[4] = v48;
      __int16 v101 = 1026;
      int v102 = 343;
      __int16 v103 = 2114;
      uint64_t v104 = v46;
      _os_log_error_impl(&dword_24B6B9000, v33, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create pipeline state for computeMeshVerticesInUpdatedVoxelBlocks compute shader. Error details: %{public}@", buf, 0x1Cu);
    }
    if (v110 < 0) {
      operator delete(*(void **)__p);
    }
    goto LABEL_71;
  }
  if (qword_2697D1340 != -1) {
    dispatch_once(&qword_2697D1340, &unk_26FE9D888);
  }
  float32x4_t v15 = (id)qword_2697D1338;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createPipelineState()");
    int v54 = v110;
    uint64_t v55 = *(unsigned char **)__p;
    uint64_t v58 = objc_msgSend_localizedDescription(v8, v56, v57);
    uint64_t v59 = (void *)v58;
    __int16 v60 = v54 >= 0 ? __p : v55;
    *(_DWORD *)simd_float4x4 buf = 136315650;
    *(void *)&uint8_t buf[4] = v60;
    __int16 v101 = 1026;
    int v102 = 294;
    __int16 v103 = 2114;
    uint64_t v104 = v58;
    _os_log_error_impl(&dword_24B6B9000, v15, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed find resetMeshDataInUpdatedVoxelBlocks compute shader. Error details: %{public}@", buf, 0x1Cu);

    if (v110 < 0) {
      operator delete(*(void **)__p);
    }
  }
  uint64_t v40 = 0;
LABEL_75:

  return v40;
}

void sub_24B726E34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object)
{
  if (v15 < 0) {
    operator delete(v17);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_24B726F74(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 28) >= 0xFA0u) {
    int v2 = 4000;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 28);
  }
  id v3 = **(id **)(a1 + 144);
  uint64_t v5 = objc_msgSend_newBufferWithLength_options_(v3, v4, (108 * v2), 32);
  unsigned int v6 = *(void **)(a1 + 200);
  *(void *)(a1 + 200) = v5;

  id v8 = *(void **)(a1 + 200);
  if (!v8)
  {
    if (qword_2697D1340 != -1) {
      dispatch_once(&qword_2697D1340, &unk_26FE9D888);
    }
    uint64_t v23 = (id)qword_2697D1338;
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createBuffers()");
    id v24 = v28 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint64_t v30 = v24;
    __int16 v31 = 1026;
    int v32 = 386;
    _os_log_error_impl(&dword_24B6B9000, v23, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create neighborVoxelBlockIdxs Buffer.", buf, 0x12u);
    if ((v28 & 0x80000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_36;
  }
  objc_msgSend_setLabel_(v8, v7, @"NeighborVoxelBlockIdxs Buffer");
  id v9 = **(id **)(a1 + 144);
  uint64_t v11 = objc_msgSend_newBufferWithLength_options_(v9, v10, 11664, 0);
  id v12 = *(void **)(a1 + 208);
  *(void *)(a1 + 208) = v11;

  float32x4_t v14 = *(void **)(a1 + 208);
  if (!v14)
  {
    if (qword_2697D1340 != -1) {
      dispatch_once(&qword_2697D1340, &unk_26FE9D888);
    }
    uint64_t v23 = (id)qword_2697D1338;
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_21;
    }
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createBuffers()");
    float32x2_t v25 = v28 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint64_t v30 = v25;
    __int16 v31 = 1026;
    int v32 = 396;
    _os_log_error_impl(&dword_24B6B9000, v23, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create threadPosInThreadgroupToIdxInVoxelVerticesMap buffer.", buf, 0x12u);
    if ((v28 & 0x80000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_36;
  }
  objc_msgSend_setLabel_(v14, v13, @"ThreadPosInThreadgroupToIdxInVoxelVerticesMap Buffer");
  if (*(_DWORD *)(a1 + 288) != 1) {
    return 1;
  }
  uint64_t v15 = (4 * *(_DWORD *)(a1 + 52) * *(_DWORD *)(a1 + 56));
  id v16 = **(id **)(a1 + 144);
  uint64_t v18 = objc_msgSend_newBufferWithLength_options_(v16, v17, v15, 0);
  id v19 = *(void **)(a1 + 216);
  *(void *)(a1 + 216) = v18;

  id v21 = *(void **)(a1 + 216);
  if (v21)
  {
    objc_msgSend_setLabel_(v21, v20, @"RandomNumbers Buffer");
    return 1;
  }
  if (qword_2697D1340 != -1) {
    dispatch_once(&qword_2697D1340, &unk_26FE9D888);
  }
  uint64_t v23 = (id)qword_2697D1338;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    sub_24B6F6D14(__p, "BOOL oc::voxel_hashing::VoxelSurfaceSamplerGPU::createBuffers()");
    uint64_t v26 = v28 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)simd_float4x4 buf = 136315394;
    uint64_t v30 = v26;
    __int16 v31 = 1026;
    int v32 = 410;
    _os_log_error_impl(&dword_24B6B9000, v23, OS_LOG_TYPE_ERROR, "%s:%{public}d Failed to create randomNumbers buffer.", buf, 0x12u);
    if (v28 < 0) {
LABEL_36:
    }
      operator delete(__p[0]);
  }
LABEL_21:

  return 0;
}

void sub_24B72731C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B727338(void *a1, const char *a2, uint64_t a3)
{
  uint64_t result = objc_msgSend_contents(a1, a2, a3);
  for (uint64_t i = 0; i != 729; ++i)
  {
    LODWORD(v5) = (unsigned __int16)i / 0x51u;
    HIDWORD(v5) = (i - 81 * v5) / 9u;
    *(_DWORD *)(result + 8) = (unsigned __int16)i % 9u;
    *(void *)uint64_t result = v5;
    result += 16;
  }
  return result;
}

void sub_24B7273B0(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  float v4 = *(float *)(a1 + 224);
  uint64_t v34 = objc_msgSend_contents(*(void **)(a1 + 216), a2, a3);
  if (qword_2697D1340 != -1) {
    dispatch_once(&qword_2697D1340, &unk_26FE9D888);
  }
  uint64_t v5 = (id)qword_2697D1338;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    sub_24B6F6D14(__p, "void oc::voxel_hashing::VoxelSurfaceSamplerGPU::generateRandomNumbers()");
    uint64_t v30 = v37 >= 0 ? __p : (void **)__p[0];
    double v31 = *(float *)(a1 + 224);
    *(_DWORD *)simd_float4x4 buf = 136315650;
    uint64_t v39 = v30;
    __int16 v40 = 1026;
    int v41 = 441;
    __int16 v42 = 2050;
    double v43 = v31;
    _os_log_debug_impl(&dword_24B6B9000, v5, OS_LOG_TYPE_DEBUG, "%s:%{public}d Generating random numbers from normal distribution with stddev = %{public}f", buf, 0x1Cu);
    if (v37 < 0) {
      operator delete(__p[0]);
    }
  }

  int v32 = *(_DWORD *)(a1 + 52);
  if (v32)
  {
    uint64_t v35 = *(unsigned int *)(a1 + 56);
    if (v35)
    {
      int v7 = 0;
      int v8 = 0;
      unsigned int v9 = 1;
      do
      {
        uint64_t v10 = 0;
        int v33 = v7;
        int v11 = v35 * v7;
        while (1)
        {
          if (v8)
          {
            int v8 = 0;
            float v12 = v6;
          }
          else
          {
            do
            {
              unsigned int v15 = 48271 * (v9 % 0xADC8);
              unsigned int v16 = 3399 * (v9 / 0xADC8);
              BOOL v17 = v15 >= v16;
              unsigned int v18 = v15 - v16;
              if (v17) {
                int v19 = 0;
              }
              else {
                int v19 = 0x7FFFFFFF;
              }
              unsigned int v20 = v19 + v18;
              float v21 = (float)(v20 - 1) * 4.6566e-10;
              unsigned int v22 = v20 / 0xADC8;
              unsigned int v23 = 48271 * (v20 % 0xADC8);
              v22 *= 3399;
              BOOL v17 = v23 >= v22;
              unsigned int v24 = v23 - v22;
              if (v17) {
                int v25 = 0;
              }
              else {
                int v25 = 0x7FFFFFFF;
              }
              unsigned int v9 = v25 + v24;
              float v26 = (float)(v21 * 2.0) + -1.0;
              float v27 = (float)((float)((float)(v25 + v24 - 1) * 4.6566e-10) * 2.0) + -1.0;
              float v28 = (float)(v27 * v27) + (float)(v26 * v26);
            }
            while (v28 > 1.0 || v28 == 0.0);
            float v29 = sqrtf((float)(logf((float)(v27 * v27) + (float)(v26 * v26)) * -2.0) / v28);
            float v6 = v27 * v29;
            float v12 = v26 * v29;
            int v8 = 1;
          }
          float v13 = (float)(v12 * v4) + 0.0;
          if (v13 > -0.4 && v13 < 0.4)
          {
            *(float *)(v34 + 4 * (v11 + v10++)) = v13;
            if (v10 == v35) {
              break;
            }
          }
        }
        int v7 = v33 + 1;
      }
      while (v33 + 1 != v32);
    }
  }
}

void sub_24B727698(uint64_t a1)
{
  sub_24B7276D0(a1);
  JUMPOUT(0x24C5D7790);
}

uint64_t sub_24B7276D0(uint64_t a1)
{
  atomic_store(1u, (unsigned __int8 *)(a1 + 228));
  int v2 = atomic_load((unsigned int *)(a1 + 232));
  if (v2 >= 1)
  {
    do
    {
      __ns.__rep_ = 1000000;
      std::this_thread::sleep_for (&__ns);
      int v3 = atomic_load((unsigned int *)(a1 + 232));
    }
    while (v3 > 0);
  }
  uint64_t v4 = *(void *)(a1 + 280);
  *(void *)(a1 + 280) = 0;
  if (v4)
  {

    MEMORY[0x24C5D7790](v4, 0xE0C40BC9ECFC2);
  }
  uint64_t v5 = *(void **)(a1 + 256);
  if (v5)
  {
    *(void *)(a1 + 264) = v5;
    operator delete(v5);
  }

  float v6 = *(std::__shared_weak_count **)(a1 + 136);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  return a1;
}

void sub_24B727808(_Unwind_Exception *a1)
{
  sub_24B70E21C((uint64_t *)(v1 + 280));
  int v3 = *(void **)(v1 + 256);
  if (v3)
  {
    *(void *)(v1 + 264) = v3;
    operator delete(v3);
  }

  sub_24B6ED550(v1 + 128);
  _Unwind_Resume(a1);
}

uint64_t sub_24B727878(uint64_t result, long long *a2)
{
  long long v2 = a2[3];
  long long v4 = *a2;
  long long v3 = a2[1];
  *(_OWORD *)(result + 32) = a2[2];
  *(_OWORD *)(result + 48) = v2;
  *(_OWORD *)uint64_t result = v4;
  *(_OWORD *)(result + 16) = v3;
  *(void *)(result + 64) = 0;
  *(void *)(result + 72) = 0;
  *(void *)(result + 80) = 0;
  *(void *)(result + 88) = 0xBFF0000000000000;
  *(_DWORD *)(result + 96) = 0;
  if (*(unsigned char *)(result + 8)) {
    operator new();
  }
  if (*(unsigned char *)(result + 9)) {
    operator new();
  }
  if (*(unsigned char *)(result + 10)) {
    operator new();
  }
  return result;
}

uint64_t sub_24B7279CC(uint64_t a1, float32x4_t *a2, float32x2_t *a3, float32x4_t *a4)
{
  float32x4_t v6 = a4[1];
  float32x4_t v7 = a4[2];
  float32x4_t v8 = a4[3];
  float32x4_t v9 = *(float32x4_t *)a3[6].f32;
  float32x4_t v10 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a4, COERCE_FLOAT(*(_OWORD *)a3[2].f32)), v6, a3[2], 1), v7, *(float32x4_t *)a3[2].f32, 2), v8, *(float32x4_t *)a3[2].f32, 3);
  float32x4_t v11 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a4, COERCE_FLOAT(*(_OWORD *)a3[4].f32)), v6, a3[4], 1), v7, *(float32x4_t *)a3[4].f32, 2), v8, *(float32x4_t *)a3[4].f32, 3);
  float32x4_t v12 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a4, v9.f32[0]), v6, *(float32x2_t *)v9.f32, 1), v7, v9, 2);
  v33[0] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a4, COERCE_FLOAT(*(_OWORD *)a3->f32)), v6, *a3, 1), v7, *(float32x4_t *)a3->f32, 2), v8, *(float32x4_t *)a3->f32, 3);
  v33[1] = v10;
  void v33[2] = v11;
  void v33[3] = vmlaq_laneq_f32(v12, v8, v9, 3);
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  if (sub_24B7237E8(a2, v33, (int *)&v32 + 1, (int *)&v32, (int *)&v31 + 1, (int *)&v31))
  {
    int32x2_t v13 = vsub_s32((int32x2_t)__PAIR64__(v32, v31), (int32x2_t)__PAIR64__(HIDWORD(v32), HIDWORD(v31)));
    v14.i64[0] = v13.i32[0];
    v14.i64[1] = v13.i32[1];
    float64x2_t v15 = vcvtq_f64_s64(v14);
    uint64_t v16 = a2[17].i64[0];
    v14.i64[0] = v16;
    v14.i64[1] = HIDWORD(v16);
    float64x2_t v17 = vdivq_f64(v15, vcvtq_f64_u64((uint64x2_t)v14));
    if (*(unsigned char *)(a1 + 10))
    {
      uint64_t v18 = *(void *)(a1 + 80);
      if (*(unsigned char *)(v18 + 16))
      {
        *(float64x2_t *)(v18 + 24) = v17;
        *(unsigned char *)(v18 + 16) = 0;
      }
      else
      {
        float64x2_t v21 = *(float64x2_t *)(v18 + 24);
        if (*(unsigned char *)(v18 + 17))
        {
          float64x2_t v22 = *(float64x2_t *)(v18 + 40);
        }
        else
        {
          float64x2_t v22 = vsubq_f64(v17, v21);
          *(unsigned char *)(v18 + 17) = 1;
        }
        float64x2_t v23 = vaddq_f64(vmulq_n_f64(v17, *(double *)v18), vmulq_n_f64(vaddq_f64(v21, v22), 1.0 - *(double *)v18));
        float64x2_t v24 = vaddq_f64(vmulq_n_f64(vsubq_f64(v23, v21), *(double *)(v18 + 8)), vmulq_n_f64(v22, 1.0 - *(double *)(v18 + 8)));
        *(float64x2_t *)(v18 + 24) = v23;
        *(float64x2_t *)(v18 + 40) = v24;
        float64x2_t v17 = vaddq_f64(v23, v24);
      }
    }
    float v25 = v17.f64[0];
    float v26 = v17.f64[1];
    float v27 = v25 * v26;
    BOOL v29 = (v25 < 1.0 || v26 < 1.0) && v27 < *(float *)a1;
    BOOL v30 = *(_DWORD *)(a1 + 96) == 2 && v27 < *(float *)(a1 + 4);
    return v29 | v30;
  }
  else
  {
    uint64_t result = 0;
    if (*(unsigned char *)(a1 + 10))
    {
      uint64_t v20 = *(void *)(a1 + 80);
      *(_OWORD *)(v20 + 40) = 0u;
      *(_OWORD *)(v20 + 24) = 0u;
      *(_WORD *)(v20 + 16) = 1;
    }
  }
  return result;
}

uint64_t sub_24B727BB4()
{
  if (qword_2697D1348)
  {
    id v0 = (id)qword_2697D1348;
    goto LABEL_4;
  }
  if (MTLCreateSystemDefaultDevice()) {
LABEL_4:
  }
    operator new();

  return 0;
}

void sub_24B727D1C(_Unwind_Exception *a1)
{
  MEMORY[0x24C5D7790](v2, 0x1080C4097C26A9CLL);
  _Unwind_Resume(a1);
}

id **sub_24B727D84(id **a1)
{
  long long v2 = *a1;
  *a1 = 0;
  if (v2)
  {

    MEMORY[0x24C5D7790](v2, 0x1080C4097C26A9CLL);
  }
  return a1;
}

uint64_t sub_24B727DE4(uint64_t a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2697D1358, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2697D1358))
  {
    qword_2697D1350 = sub_24B727BB4();
    __cxa_atexit((void (*)(void *))sub_24B727D84, &qword_2697D1350, &dword_24B6B9000);
    __cxa_guard_release(&qword_2697D1358);
  }
  *(void *)a1 = qword_2697D1350;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_24B6ECE9C(a1 + 32);
  *(unsigned char *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 152) = 0;
  return a1;
}

void sub_24B727E98(_Unwind_Exception *a1)
{
}

void sub_24B727EB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B727ED4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t result = 0;
  if (!a5 || !a4 || !a3 || !a2 || *(unsigned char *)(a1 + 208)) {
    return result;
  }
  unsigned int v8 = *(_DWORD *)(a6 + 20);
  if (*(_DWORD *)(a6 + 16) >= v8) {
    return 0;
  }
  uint64_t result = 0;
  float v9 = *(float *)(a6 + 28);
  if (v9 <= 0.0) {
    return result;
  }
  float v10 = *(float *)(a6 + 32);
  if (v9 >= v10) {
    return result;
  }
  *(void *)(a1 + 176) = a2;
  *(void *)(a1 + 184) = a3;
  *(void *)(a1 + 192) = a4;
  *(void *)(a1 + 200) = a5;
  *(_DWORD *)(a1 + 160) = v8;
  *(float *)(a1 + 164) = v9;
  *(float *)(a1 + 168) = v10;
  uint64_t result = sub_24B6ECF50(a1 + 32, v8);
  if (!result) {
    return result;
  }
  id v11 = *(unsigned char *)(a1 + 68) ? *(id *)(a1 + 56) : 0;
  float32x4_t v12 = *(void **)(a1 + 88);
  *(void *)(a1 + 88) = v11;

  if (!*(void *)(a1 + 88)) {
    return 0;
  }
  uint64_t v13 = 4 * *(unsigned int *)(a1 + 160);
  id v14 = **(id **)a1;
  uint64_t v16 = objc_msgSend_newBufferWithLength_options_(v14, v15, v13, 0);
  float64x2_t v17 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = v16;

  uint64_t result = *(void *)(a1 + 96);
  if (result)
  {
    objc_msgSend_setLabel_((void *)result, v18, @"SurfaceVoxelCoverageScoreBuffer");
    id v19 = **(id **)a1;
    uint64_t v21 = objc_msgSend_newBufferWithBytes_length_options_(v19, v20, (uint64_t)&unk_24B72EC48, 64, 0);
    float64x2_t v22 = *(void **)(a1 + 104);
    *(void *)(a1 + 104) = v21;

    uint64_t result = *(void *)(a1 + 104);
    if (result)
    {
      objc_msgSend_setLabel_((void *)result, v23, @"ImagePlaneVertexBuffer");
      uint64_t result = sub_24B728084(a1);
      if (result)
      {
        uint64_t result = sub_24B7282E8(a1);
        if (result)
        {
          uint64_t result = sub_24B7284C8(a1);
          if (result)
          {
            uint64_t result = sub_24B7287F4(a1);
            if (result)
            {
              uint64_t result = sub_24B7288A8((uint64_t *)a1);
              if (result)
              {
                uint64_t result = 1;
                *(unsigned char *)(a1 + 208) = 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void sub_24B728070(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_24B728084(uint64_t a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F12A80]);
  long long v3 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = v2;

  uint64_t v6 = *(void *)(a1 + 112);
  if (v6)
  {
    float32x4_t v7 = objc_msgSend_attributes(*(void **)(a1 + 112), v4, v5);
    float v9 = objc_msgSend_objectAtIndexedSubscript_(v7, v8, 0);
    objc_msgSend_setFormat_(v9, v10, 29);

    uint64_t v13 = objc_msgSend_attributes(*(void **)(a1 + 112), v11, v12);
    float64x2_t v15 = objc_msgSend_objectAtIndexedSubscript_(v13, v14, 0);
    objc_msgSend_setOffset_(v15, v16, 0);

    id v19 = objc_msgSend_attributes(*(void **)(a1 + 112), v17, v18);
    uint64_t v21 = objc_msgSend_objectAtIndexedSubscript_(v19, v20, 0);
    objc_msgSend_setBufferIndex_(v21, v22, 0);

    float v25 = objc_msgSend_attributes(*(void **)(a1 + 112), v23, v24);
    float v27 = objc_msgSend_objectAtIndexedSubscript_(v25, v26, 1);
    objc_msgSend_setFormat_(v27, v28, 29);

    uint64_t v31 = objc_msgSend_attributes(*(void **)(a1 + 112), v29, v30);
    int v33 = objc_msgSend_objectAtIndexedSubscript_(v31, v32, 1);
    objc_msgSend_setOffset_(v33, v34, 8);

    char v37 = objc_msgSend_attributes(*(void **)(a1 + 112), v35, v36);
    uint64_t v39 = objc_msgSend_objectAtIndexedSubscript_(v37, v38, 1);
    objc_msgSend_setBufferIndex_(v39, v40, 0);

    double v43 = objc_msgSend_layouts(*(void **)(a1 + 112), v41, v42);
    uint64_t v45 = objc_msgSend_objectAtIndexedSubscript_(v43, v44, 0);
    objc_msgSend_setStride_(v45, v46, 16);

    id v49 = objc_msgSend_layouts(*(void **)(a1 + 112), v47, v48);
    uint64_t v51 = objc_msgSend_objectAtIndexedSubscript_(v49, v50, 0);
    objc_msgSend_setStepRate_(v51, v52, 1);

    uint64_t v55 = objc_msgSend_layouts(*(void **)(a1 + 112), v53, v54);
    uint64_t v57 = objc_msgSend_objectAtIndexedSubscript_(v55, v56, 0);
    objc_msgSend_setStepFunction_(v57, v58, 1);
  }
  return v6 != 0;
}

void sub_24B728284(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B7282E8(uint64_t a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F12A50]);
  long long v4 = v2;
  if (!v2) {
    goto LABEL_9;
  }
  objc_msgSend_setTextureType_(v2, v3, 2);
  objc_msgSend_setPixelFormat_(v4, v5, 80);
  objc_msgSend_setWidth_(v4, v6, *(void *)(a1 + 176));
  objc_msgSend_setHeight_(v4, v7, *(void *)(a1 + 184));
  objc_msgSend_setUsage_(v4, v8, 6);
  objc_msgSend_setStorageMode_(v4, v9, 0);
  id v10 = **(id **)a1;
  uint64_t v12 = objc_msgSend_newTextureWithDescriptor_(v10, v11, (uint64_t)v4);
  uint64_t v13 = *(void **)(a1 + 120);
  *(void *)(a1 + 120) = v12;

  float64x2_t v15 = *(void **)(a1 + 120);
  if (!v15) {
    goto LABEL_9;
  }
  objc_msgSend_setLabel_(v15, v14, @"CoverageHeatmapTexture");
  objc_msgSend_setPixelFormat_(v4, v16, 55);
  objc_msgSend_setWidth_(v4, v17, *(void *)(a1 + 192));
  objc_msgSend_setHeight_(v4, v18, *(void *)(a1 + 200));
  objc_msgSend_setUsage_(v4, v19, 7);
  id v20 = **(id **)a1;
  uint64_t v22 = objc_msgSend_newTextureWithDescriptor_(v20, v21, (uint64_t)v4);
  float64x2_t v23 = *(void **)(a1 + 128);
  *(void *)(a1 + 128) = v22;

  float v25 = *(void **)(a1 + 128);
  if (!v25) {
    goto LABEL_9;
  }
  objc_msgSend_setLabel_(v25, v24, @"CoverageScoreTexture");
  objc_msgSend_setTextureType_(v4, v26, 2);
  objc_msgSend_setPixelFormat_(v4, v27, 252);
  objc_msgSend_setUsage_(v4, v28, 4);
  if (*(unsigned char *)(*(void *)a1 + 24)) {
    objc_msgSend_setStorageMode_(v4, v29, 3);
  }
  else {
    objc_msgSend_setStorageMode_(v4, v29, 2);
  }
  id v30 = **(id **)a1;
  uint64_t v32 = objc_msgSend_newTextureWithDescriptor_(v30, v31, (uint64_t)v4);
  int v33 = *(void **)(a1 + 136);
  *(void *)(a1 + 136) = v32;

  uint64_t v35 = *(void **)(a1 + 136);
  if (v35)
  {
    objc_msgSend_setLabel_(v35, v34, @"DepthTexture");
    uint64_t v36 = 1;
  }
  else
  {
LABEL_9:
    uint64_t v36 = 0;
  }

  return v36;
}

void sub_24B7284A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_24B7284C8(uint64_t a1)
{
  id v3 = objc_alloc_init(MEMORY[0x263F129C0]);
  if (v3)
  {
    long long v4 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)a1 + 16), v2, @"coverageHeatmapVertexShader");
    uint64_t v6 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)a1 + 16), v5, @"coverageHeatmapFragmentShader");
    objc_msgSend_setVertexFunction_(v3, v7, (uint64_t)v4);
    objc_msgSend_setFragmentFunction_(v3, v8, (uint64_t)v6);
    objc_msgSend_setVertexDescriptor_(v3, v9, *(void *)(a1 + 112));
    uint64_t v12 = objc_msgSend_pixelFormat(*(void **)(a1 + 120), v10, v11);
    float64x2_t v15 = objc_msgSend_colorAttachments(v3, v13, v14);
    float64x2_t v17 = objc_msgSend_objectAtIndexedSubscript_(v15, v16, 0);
    objc_msgSend_setPixelFormat_(v17, v18, v12);

    id v19 = **(id **)a1;
    id v51 = 0;
    uint64_t v21 = objc_msgSend_newRenderPipelineStateWithDescriptor_error_(v19, v20, (uint64_t)v3, &v51);
    id v22 = v51;
    float64x2_t v23 = *(void **)(a1 + 8);
    *(void *)(a1 + 8) = v21;

    if (*(void *)(a1 + 8))
    {
      uint64_t v25 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)a1 + 16), v24, @"coverageScoreVertexShader");

      uint64_t v27 = objc_msgSend_newFunctionWithName_(*(void **)(*(void *)a1 + 16), v26, @"coverageScoreFragmentShader");
      objc_msgSend_setVertexFunction_(v3, v28, v25);
      objc_msgSend_setFragmentFunction_(v3, v29, v27);
      uint64_t v32 = objc_msgSend_pixelFormat(*(void **)(a1 + 128), v30, v31);
      uint64_t v35 = objc_msgSend_colorAttachments(v3, v33, v34);
      char v37 = objc_msgSend_objectAtIndexedSubscript_(v35, v36, 0);
      objc_msgSend_setPixelFormat_(v37, v38, v32);

      uint64_t v41 = objc_msgSend_pixelFormat(*(void **)(a1 + 136), v39, v40);
      objc_msgSend_setDepthAttachmentPixelFormat_(v3, v42, v41);
      id v43 = **(id **)a1;
      id v50 = v22;
      uint64_t v45 = objc_msgSend_newRenderPipelineStateWithDescriptor_error_(v43, v44, (uint64_t)v3, &v50);
      id v46 = v50;

      uint64_t v47 = *(void **)(a1 + 16);
      *(void *)(a1 + 16) = v45;

      BOOL v48 = *(void *)(a1 + 16) != 0;
      id v22 = v46;
      long long v4 = (void *)v25;
      uint64_t v6 = (void *)v27;
    }
    else
    {
      BOOL v48 = 0;
    }
  }
  else
  {
    id v22 = 0;
    BOOL v48 = 0;
  }

  return v48;
}

void sub_24B728764(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_24B7287F4(uint64_t a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F128A0]);
  long long v4 = v2;
  if (v2)
  {
    objc_msgSend_setDepthCompareFunction_(v2, v3, 1);
    objc_msgSend_setDepthWriteEnabled_(v4, v5, 1);
    id v6 = **(id **)a1;
    uint64_t v8 = objc_msgSend_newDepthStencilStateWithDescriptor_(v6, v7, (uint64_t)v4);
    float v9 = *(void **)(a1 + 24);
    *(void *)(a1 + 24) = v8;

    BOOL v10 = *(void *)(a1 + 24) != 0;
  }
  else
  {
    BOOL v10 = 0;
  }

  return v10;
}

void sub_24B72888C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B7288A8(uint64_t *a1)
{
  id v2 = objc_alloc_init(MEMORY[0x263F129A0]);
  id v3 = (void *)a1[18];
  a1[18] = (uint64_t)v2;

  uint64_t result = a1[18];
  if (result)
  {
    uint64_t v7 = a1[15];
    uint64_t v8 = objc_msgSend_colorAttachments((void *)result, v4, v5);
    BOOL v10 = objc_msgSend_objectAtIndexedSubscript_(v8, v9, 0);
    objc_msgSend_setTexture_(v10, v11, v7);

    uint64_t v14 = objc_msgSend_colorAttachments((void *)a1[18], v12, v13);
    uint64_t v16 = objc_msgSend_objectAtIndexedSubscript_(v14, v15, 0);
    objc_msgSend_setLoadAction_(v16, v17, 2);

    id v20 = objc_msgSend_colorAttachments((void *)a1[18], v18, v19);
    id v22 = objc_msgSend_objectAtIndexedSubscript_(v20, v21, 0);
    objc_msgSend_setClearColor_(v22, v23, v24, 0.0, 0.0, 0.0, 0.0);

    uint64_t v27 = objc_msgSend_colorAttachments((void *)a1[18], v25, v26);
    BOOL v29 = objc_msgSend_objectAtIndexedSubscript_(v27, v28, 0);
    objc_msgSend_setStoreAction_(v29, v30, 1);

    id v31 = objc_alloc_init(MEMORY[0x263F129A0]);
    uint64_t v32 = (void *)a1[19];
    a1[19] = (uint64_t)v31;

    uint64_t result = a1[19];
    if (result)
    {
      uint64_t v35 = a1[16];
      uint64_t v36 = objc_msgSend_colorAttachments((void *)result, v33, v34);
      uint64_t v38 = objc_msgSend_objectAtIndexedSubscript_(v36, v37, 0);
      objc_msgSend_setTexture_(v38, v39, v35);

      uint64_t v42 = objc_msgSend_colorAttachments((void *)a1[19], v40, v41);
      uint64_t v44 = objc_msgSend_objectAtIndexedSubscript_(v42, v43, 0);
      objc_msgSend_setLoadAction_(v44, v45, 2);

      BOOL v48 = objc_msgSend_colorAttachments((void *)a1[19], v46, v47);
      id v50 = objc_msgSend_objectAtIndexedSubscript_(v48, v49, 0);
      objc_msgSend_setClearColor_(v50, v51, v52, 0.0, 0.0, 0.0, 0.0);

      uint64_t v55 = objc_msgSend_colorAttachments((void *)a1[19], v53, v54);
      uint64_t v57 = objc_msgSend_objectAtIndexedSubscript_(v55, v56, 0);
      objc_msgSend_setStoreAction_(v57, v58, 1);

      uint64_t v59 = a1[17];
      char v62 = objc_msgSend_depthAttachment((void *)a1[19], v60, v61);
      objc_msgSend_setTexture_(v62, v63, v59);

      int v66 = objc_msgSend_depthAttachment((void *)a1[19], v64, v65);
      objc_msgSend_setLoadAction_(v66, v67, 2);

      uint64_t v70 = objc_msgSend_depthAttachment((void *)a1[19], v68, v69);
      objc_msgSend_setClearDepth_(v70, v71, v72, 1.0);

      uint64_t v75 = objc_msgSend_depthAttachment((void *)a1[19], v73, v74);
      objc_msgSend_setStoreAction_(v75, v76, 0);

      return 1;
    }
  }
  return result;
}

void sub_24B728B24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_24B728B88(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, int a5, float a6)
{
  uint64_t result = 0;
  if (*(unsigned char *)(a1 + 208) && *(float *)a2 > 0.0)
  {
    float32x4_t v10 = *(float32x4_t *)(a2 + 16);
    float32x4_t v11 = *(float32x4_t *)(a2 + 32);
    float32x4_t v12 = *(float32x4_t *)(a2 + 48);
    float32x4_t v14 = *(float32x4_t *)MEMORY[0x263EF89A0];
    float32x4_t v13 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 16);
    float32x4_t v15 = *(float32x4_t *)(MEMORY[0x263EF89A0] + 32);
    float32x4_t v16 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
    uint32x4_t v17 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v10, *(float32x2_t *)v10.f32, 1), v11, *(float32x2_t *)v11.f32, 1), v12, *(float32x2_t *)v12.f32, 1), v13)), (int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v10, v10.f32[0]), v11, v11.f32[0]),
                                           v12,
                                           v12.f32[0]),
                                         *MEMORY[0x263EF89A0]))),
                        (int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v10, v10, 2), v11, v11, 2), v12, v12, 2), v15)));
    v17.i32[3] = v17.i32[2];
    if ((vminvq_u32(v17) & 0x80000000) == 0) {
      return 0;
    }
    float32x4_t v18 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2);
    float32x4_t v19 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v10, (int32x4_t)v12), (int32x4_t)v18);
    float32x4_t v20 = (float32x4_t)vtrn2q_s32((int32x4_t)v10, (int32x4_t)v11);
    v20.i32[2] = HIDWORD(*(void *)(a2 + 48));
    float32x4_t v21 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v10, (int32x4_t)v12), (int32x4_t)v11);
    uint32x4_t v22 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v21, v11.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1), v20), v18, v19), v13)), (int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v21, v10.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1),
                                             v20),
                                           (float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2),
                                           v19),
                                         v14))),
                        (int8x16_t)vcgeq_f32(v16, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v21, v12.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1), v20), (float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), v19), v15)));
    v22.i32[3] = v22.i32[2];
    if ((vminvq_u32(v22) & 0x80000000) == 0) {
      return 0;
    }
    float32x4_t v23 = vmulq_f32(v10, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v12, (int8x16_t)v12, 0xCuLL), (int8x16_t)v12, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), (int8x16_t)v12, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v11, (int8x16_t)v11, 0xCuLL), (int8x16_t)v11, 8uLL)));
    uint64_t result = 0;
    if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0]+ -1.0) <= 0.000011)
    {
      float32x2_t v24 = vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v10, (int8x16_t)v10, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v11, (int8x16_t)v11, 8uLL)));
      float32x2_t v25 = (float32x2_t)vdup_n_s32(0x38D1B717u);
      uint32x2_t v26 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v25, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v12, (int8x16_t)v12, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a2 + 64), *(int8x16_t *)(a2 + 64), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v25, v24));
      if ((vpmin_u32(v26, v26).u32[0] & 0x80000000) != 0 && *(void *)(a2 + 80) && *(void *)(a2 + 88))
      {
        float32x4_t v28 = *(float32x4_t *)a4;
        float32x4_t v29 = *(float32x4_t *)(a4 + 16);
        float32x4_t v30 = *(float32x4_t *)(a4 + 32);
        float32x4_t v31 = (float32x4_t)vdupq_n_s32(0x38D1B717u);
        uint32x4_t v32 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v31, vabdq_f32(vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v28, *(float32x2_t *)v28.f32, 1), v29, *(float32x2_t *)v29.f32, 1), v30, *(float32x2_t *)v30.f32, 1), v13)), (int8x16_t)vcgeq_f32(v31, vabdq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v28, v28.f32[0]), v29, v29.f32[0]),
                                               v30,
                                               v30.f32[0]),
                                             v14))),
                            (int8x16_t)vcgeq_f32(v31, vabdq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v28, v28, 2), v29, v29, 2), v30, v30, 2), v15)));
        v32.i32[3] = v32.i32[2];
        if ((vminvq_u32(v32) & 0x80000000) == 0) {
          return 0;
        }
        float32x4_t v33 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2);
        float32x4_t v34 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v28, (int32x4_t)v30), (int32x4_t)v33);
        float32x4_t v35 = (float32x4_t)vtrn2q_s32((int32x4_t)v28, (int32x4_t)v29);
        v35.i32[2] = HIDWORD(*(void *)(a4 + 32));
        float32x4_t v36 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v28, (int32x4_t)v30), (int32x4_t)v29);
        uint32x4_t v37 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v31, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v36, v29.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1), v35), v33, v34), v13)), (int8x16_t)vcgeq_f32(v31, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v36, v28.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1),
                                                 v35),
                                               (float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2),
                                               v34),
                                             v14))),
                            (int8x16_t)vcgeq_f32(v31, vabdq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v36, v30.f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1), v35), (float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), v34), v15)));
        v37.i32[3] = v37.i32[2];
        if ((vminvq_u32(v37) & 0x80000000) == 0) {
          return 0;
        }
        float32x4_t v38 = vmulq_f32(v28, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v30, (int8x16_t)v30, 0xCuLL), (int8x16_t)v30, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29), (int8x16_t)v29, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), (int8x16_t)v30, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v29, (int8x16_t)v29, 0xCuLL), (int8x16_t)v29, 8uLL)));
        uint64_t result = 0;
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0]+ -1.0) <= 0.000011&& a6 < 3.1416&& a6 > 0.0)
        {
          float32x2_t v39 = (float32x2_t)vdup_n_s32(0x38D1B717u);
          uint32x2_t v40 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v39, vabs_f32(vadd_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a4 + 48), *(int8x16_t *)(a4 + 48), 8uLL)), (float32x2_t)0xBF80000080000000))), (int8x8_t)vcge_f32(v39, vabs_f32((float32x2_t)vzip2_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v28,
                                                                                           (int8x16_t)v28,
                                                                                           8uLL),
                                                                  (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v29, (int8x16_t)v29, 8uLL)))));
          if ((vpmin_u32(v40, v40).u32[0] & 0x80000000) != 0)
          {
            uint64_t result = sub_24B6ED0CC(a1 + 32, a2, (uint64_t)a3);
            if (result)
            {
              *(_DWORD *)(a1 + 288) = *(_DWORD *)(a1 + 76);
              uint64_t v45 = objc_msgSend_contents(*(void **)(a1 + 96), v43, v44);
              memcpy(v45, a3, 4 * *(unsigned int *)(a1 + 288));
              uint64_t result = 0;
              float32x4_t v46 = *(float32x4_t *)(a2 + 16);
              float32x4_t v47 = *(float32x4_t *)(a2 + 32);
              float32x4_t v48 = *(float32x4_t *)(a2 + 48);
              float32x4_t v49 = *(float32x4_t *)(a2 + 64);
              unint64_t v50 = *(void *)(a1 + 200);
              float v51 = (float)*(unint64_t *)(a1 + 192);
              float32x4_t v52 = vmlaq_f32(vmulq_n_f32(v46, *(float *)a2), (float32x4_t)0, v47);
              float32x4_t v53 = vmulq_f32(v46, (float32x4_t)0);
              float32x4_t v54 = vmlaq_n_f32(v53, v47, *(float *)a2);
              float32x4_t v55 = vmlaq_f32(v53, (float32x4_t)0, v47);
              float32x4_t v56 = vmlaq_f32(vmlaq_f32(v52, (float32x4_t)0, v48), (float32x4_t)0, v49);
              float32x4_t v57 = vmlaq_f32(vmlaq_f32(v54, (float32x4_t)0, v48), (float32x4_t)0, v49);
              float32x4_t v58 = vmlaq_f32(vmlaq_n_f32(v55, v48, *(float *)a2), (float32x4_t)0, v49);
              float32x4_t v59 = vaddq_f32(v49, vmlaq_f32(v55, (float32x4_t)0, v48));
              *(float32x4_t *)(a1 + 224) = v56;
              *(float32x4_t *)(a1 + 240) = v57;
              *(float32x4_t *)(a1 + 256) = v58;
              *(float32x4_t *)(a1 + 272) = v59;
              float v60 = v51 / (float)v50;
              if (v60 >= 0.001)
              {
                float32x4_t v100 = v59;
                if (a6 >= 0.0 && fabsf(a6) > 0.000001)
                {
                  uint64_t result = 0;
                  float v61 = *(float *)(a1 + 164);
                  float v62 = *(float *)(a1 + 168);
                  if (v62 > v61)
                  {
                    float v99 = *(float *)(a1 + 168);
                    if (v62 >= 0.001)
                    {
                      float v98 = *(float *)(a1 + 164);
                      if (v61 >= 0.001 && fabsf(a6 + -3.1416) > 0.000032416)
                      {
                        float32x4_t v96 = v57;
                        float32x4_t v97 = v58;
                        float32x4_t v95 = v56;
                        float v63 = 1.0 / tanf(a6 * 0.5);
                        *(float *)&unsigned int v64 = v63 / v60;
                        LODWORD(v65) = 0;
                        *((float *)&v65 + 1) = v63;
                        v66.i64[0] = 0;
                        v66.f32[2] = (float)-v99 / (float)(v99 - v98);
                        v67.i64[0] = 0;
                        v67.i32[3] = 0;
                        v66.i32[3] = -1.0;
                        v67.f32[2] = v66.f32[2] * v98;
                        float32x4_t v68 = *(float32x4_t *)(a4 + 16);
                        float32x4_t v69 = *(float32x4_t *)(a4 + 32);
                        float32x4_t v70 = *(float32x4_t *)(a4 + 48);
                        float32x4_t v71 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)a4, v95.f32[0]), v68, *(float32x2_t *)v95.f32, 1), v69, v95, 2), v70, v95, 3);
                        float32x4_t v72 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)a4, v96.f32[0]), v68, *(float32x2_t *)v96.f32, 1), v69, v96, 2), v70, v96, 3);
                        float32x4_t v73 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)a4, v97.f32[0]), v68, *(float32x2_t *)v97.f32, 1), v69, v97, 2), v70, v97, 3);
                        float32x4_t v74 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)a4, v100.f32[0]), v68, *(float32x2_t *)v100.f32, 1), v69, v100, 2), v70, v100, 3);
                        v101[0] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v64, v71.f32[0]), (float32x4_t)v65, *(float32x2_t *)v71.f32, 1), v66, v71, 2), v67, v71, 3);
                        v101[1] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v64, v72.f32[0]), (float32x4_t)v65, *(float32x2_t *)v72.f32, 1), v66, v72, 2), v67, v72, 3);
                        v101[2] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v64, v73.f32[0]), (float32x4_t)v65, *(float32x2_t *)v73.f32, 1), v66, v73, 2), v67, v73, 3);
                        void v101[3] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v64, v74.f32[0]), (float32x4_t)v65, *(float32x2_t *)v74.f32, 1), v66, v74, 2), v67, v74, 3);
                        int v77 = objc_msgSend_commandBuffer(*(void **)(*(void *)a1 + 8), v75, v76);
                        int v79 = objc_msgSend_renderCommandEncoderWithDescriptor_(v77, v78, *(void *)(a1 + 152));
                        objc_msgSend_setLabel_(v79, v80, @"CoverageScoreRenderEncoder");
                        objc_msgSend_setRenderPipelineState_(v79, v81, *(void *)(a1 + 16));
                        objc_msgSend_setDepthStencilState_(v79, v82, *(void *)(a1 + 24));
                        objc_msgSend_setVertexBuffer_offset_atIndex_(v79, v83, *(void *)(a1 + 88), 0, 0);
                        objc_msgSend_setVertexBytes_length_atIndex_(v79, v84, (uint64_t)v101, 64, 1);
                        objc_msgSend_setVertexBuffer_offset_atIndex_(v79, v85, *(void *)(a1 + 96), 0, 2);
                        objc_msgSend_setVertexBytes_length_atIndex_(v79, v86, a1 + 288, 4, 3);
                        objc_msgSend_drawPrimitives_vertexStart_vertexCount_(v79, v87, 3, 0, (36 * *(_DWORD *)(a1 + 288)));
                        v102[0] = 0;
                        v102[1] = 0;
                        float64x2_t v103 = vcvtq_f64_u64(*(uint64x2_t *)(a1 + 192));
                        long long v104 = xmmword_24B72A670;
                        objc_msgSend_setViewport_(v79, v88, (uint64_t)v102);
                        objc_msgSend_endEncoding(v79, v89, v90);

                        if (a5) {
                          sub_24B7292D4((uint64_t *)a1, v77);
                        }
                        objc_msgSend_commit(v77, v91, v92, *(_OWORD *)&v95, *(_OWORD *)&v96, *(_OWORD *)&v97);
                        objc_msgSend_waitUntilCompleted(v77, v93, v94);

                        return 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void sub_24B7292B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24B7292D4(uint64_t *a1, void *a2)
{
  objc_msgSend_renderCommandEncoderWithDescriptor_(a2, (const char *)a2, a1[18]);
  id v10 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend_setLabel_(v10, v3, @"CoverageHeatmapRenderEncoder");
  objc_msgSend_setRenderPipelineState_(v10, v4, a1[1]);
  objc_msgSend_setVertexBuffer_offset_atIndex_(v10, v5, a1[13], 0, 0);
  objc_msgSend_setFragmentTexture_atIndex_(v10, v6, a1[16], 0);
  objc_msgSend_drawPrimitives_vertexStart_vertexCount_(v10, v7, 4, 0, 4);
  objc_msgSend_endEncoding(v10, v8, v9);
}

void sub_24B72937C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x270EE4320](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x270EE4348]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x270EE4360](theArray, idx);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x270EE4528]();
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x270EE47F0](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x270EE4808](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x270EE4820](theData);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x270EE48F0](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x270EE4908](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4920](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x270EE4930](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x270EE4948]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x270EE4958](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x270EE4A18](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x270EE4A30](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x270EE4BE8](allocator, theType, valuePtr);
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x270EE4C70](number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x270EE4E10](cf);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x270EE5048](theString1, theString2, compareOptions);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x270EE5110](alloc, formatOptions, format);
}

uint64_t CGImageCreateEXIFJPEGData()
{
  return MEMORY[0x270EF4EC8]();
}

CFArrayRef CGImageMetadataCopyTags(CGImageMetadataRef metadata)
{
  return (CFArrayRef)MEMORY[0x270EF4F70](metadata);
}

CGImageMetadataRef CGImageMetadataCreateFromXMPData(CFDataRef data)
{
  return (CGImageMetadataRef)MEMORY[0x270EF4F78](data);
}

CGMutableImageMetadataRef CGImageMetadataCreateMutable(void)
{
  return (CGMutableImageMetadataRef)MEMORY[0x270EF4F80]();
}

CFDataRef CGImageMetadataCreateXMPData(CGImageMetadataRef metadata, CFDictionaryRef options)
{
  return (CFDataRef)MEMORY[0x270EF4F90](metadata, options);
}

BOOL CGImageMetadataRegisterNamespaceForPrefix(CGMutableImageMetadataRef metadata, CFStringRef xmlns, CFStringRef prefix, CFErrorRef *err)
{
  return MEMORY[0x270EF4FA0](metadata, xmlns, prefix, err);
}

BOOL CGImageMetadataSetTagWithPath(CGMutableImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path, CGImageMetadataTagRef tag)
{
  return MEMORY[0x270EF4FB0](metadata, parent, path, tag);
}

CFStringRef CGImageMetadataTagCopyName(CGImageMetadataTagRef tag)
{
  return (CFStringRef)MEMORY[0x270EF4FC8](tag);
}

CFStringRef CGImageMetadataTagCopyPrefix(CGImageMetadataTagRef tag)
{
  return (CFStringRef)MEMORY[0x270EF4FD0](tag);
}

CFTypeRef CGImageMetadataTagCopyValue(CGImageMetadataTagRef tag)
{
  return (CFTypeRef)MEMORY[0x270EF4FD8](tag);
}

CGImageMetadataTagRef CGImageMetadataTagCreate(CFStringRef xmlns, CFStringRef prefix, CFStringRef name, CGImageMetadataType type, CFTypeRef value)
{
  return (CGImageMetadataTagRef)MEMORY[0x270EF4FE0](xmlns, prefix, name, *(void *)&type, value);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return (CFDictionaryRef)MEMORY[0x270EE7188]((__n128)a1.origin, *(__n128 *)&a1.origin.y, (__n128)a1.size, *(__n128 *)&a1.size.height);
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  MEMORY[0x270EE71C0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  MEMORY[0x270EE71D0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  MEMORY[0x270EE71F8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  MEMORY[0x270EE7210]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

uint64_t CMPhotoCompressionSessionAddAuxiliaryImage()
{
  return MEMORY[0x270F12E28]();
}

uint64_t CMPhotoCompressionSessionAddCustomMetadata()
{
  return MEMORY[0x270F12E38]();
}

uint64_t CMPhotoCompressionSessionAddImage()
{
  return MEMORY[0x270F12E48]();
}

uint64_t CMPhotoCompressionSessionAddMetadataFromImageProperties()
{
  return MEMORY[0x270F12E58]();
}

uint64_t CMPhotoCompressionSessionAddThumbnail()
{
  return MEMORY[0x270F12E60]();
}

uint64_t CMPhotoCompressionSessionAddXMP()
{
  return MEMORY[0x270F12E68]();
}

uint64_t CMPhotoCompressionSessionCloseContainer()
{
  return MEMORY[0x270F12E70]();
}

uint64_t CMPhotoCompressionSessionCreate()
{
  return MEMORY[0x270F12E80]();
}

uint64_t CMPhotoCompressionSessionIsContainerOpen()
{
  return MEMORY[0x270F12EA0]();
}

uint64_t CMPhotoCompressionSessionOpenEmptyContainer()
{
  return MEMORY[0x270F12EA8]();
}

uint64_t CMPhotoCompressionSessionOpenExistingContainerForModification()
{
  return MEMORY[0x270F12EB0]();
}

uint64_t CMPhotoDecompressionContainerCopyAuxiliaryImageTypeURNForIndex()
{
  return MEMORY[0x270F12ED0]();
}

uint64_t CMPhotoDecompressionContainerCopyCustomMetadataForIndex()
{
  return MEMORY[0x270F12ED8]();
}

uint64_t CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndex()
{
  return MEMORY[0x270F12EE0]();
}

uint64_t CMPhotoDecompressionContainerCopyImagePropertiesForIndex()
{
  return MEMORY[0x270F12EE8]();
}

uint64_t CMPhotoDecompressionContainerCopyXMPForIndex()
{
  return MEMORY[0x270F12EF0]();
}

uint64_t CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex()
{
  return MEMORY[0x270F12EF8]();
}

uint64_t CMPhotoDecompressionContainerCreateImageForIndex()
{
  return MEMORY[0x270F12F08]();
}

uint64_t CMPhotoDecompressionContainerCreateThumbnailImageForIndex()
{
  return MEMORY[0x270F12F18]();
}

uint64_t CMPhotoDecompressionContainerGetAuxiliaryImageCountForIndex()
{
  return MEMORY[0x270F12F20]();
}

uint64_t CMPhotoDecompressionContainerGetAuxiliaryImageTypeForIndex()
{
  return MEMORY[0x270F12F28]();
}

uint64_t CMPhotoDecompressionContainerGetCustomMetadataCountForIndex()
{
  return MEMORY[0x270F12F30]();
}

uint64_t CMPhotoDecompressionContainerGetExifCountForIndex()
{
  return MEMORY[0x270F12F38]();
}

uint64_t CMPhotoDecompressionContainerGetImageCount()
{
  return MEMORY[0x270F12F40]();
}

uint64_t CMPhotoDecompressionContainerGetPrimaryItemIndex()
{
  return MEMORY[0x270F12F50]();
}

uint64_t CMPhotoDecompressionContainerGetThumbnailCountForIndex()
{
  return MEMORY[0x270F12F58]();
}

uint64_t CMPhotoDecompressionContainerGetXMPCountForIndex()
{
  return MEMORY[0x270F12F60]();
}

uint64_t CMPhotoDecompressionSessionCreate()
{
  return MEMORY[0x270F12F78]();
}

uint64_t CMPhotoDecompressionSessionCreateContainer()
{
  return MEMORY[0x270F12F80]();
}

uint64_t CMPhotoModifyHEIFInPlaceURL()
{
  return MEMORY[0x270F12FA0]();
}

uint64_t CMPointCloudFormatDescriptionGetNumberOfPoints()
{
  return MEMORY[0x270EE7BA8]();
}

CFTypeRef CVBufferCopyAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x270EE9FC0](buffer, key, attachmentMode);
}

void CVBufferRelease(CVBufferRef buffer)
{
}

CVBufferRef CVBufferRetain(CVBufferRef buffer)
{
  return (CVBufferRef)MEMORY[0x270EEA008](buffer);
}

void CVBufferSetAttachment(CVBufferRef buffer, CFStringRef key, CFTypeRef value, CVAttachmentMode attachmentMode)
{
}

uint64_t CVDataBufferCreateWithIOSurface()
{
  return MEMORY[0x270EEA038]();
}

uint64_t CVDataBufferGetDataFormatType()
{
  return MEMORY[0x270EEA040]();
}

uint64_t CVDataBufferGetDataSize()
{
  return MEMORY[0x270EEA048]();
}

uint64_t CVDataBufferGetIOSurface()
{
  return MEMORY[0x270EEA050]();
}

CVReturn CVMetalTextureCacheCreate(CFAllocatorRef allocator, CFDictionaryRef cacheAttributes, id metalDevice, CFDictionaryRef textureAttributes, CVMetalTextureCacheRef *cacheOut)
{
  return MEMORY[0x270EEA0E0](allocator, cacheAttributes, metalDevice, textureAttributes, cacheOut);
}

CVReturn CVMetalTextureCacheCreateTextureFromImage(CFAllocatorRef allocator, CVMetalTextureCacheRef textureCache, CVImageBufferRef sourceImage, CFDictionaryRef textureAttributes, MTLPixelFormat pixelFormat, size_t width, size_t height, size_t planeIndex, CVMetalTextureRef *textureOut)
{
  return MEMORY[0x270EEA0F0](allocator, textureCache, sourceImage, textureAttributes, pixelFormat, width, height, planeIndex);
}

void CVMetalTextureCacheFlush(CVMetalTextureCacheRef textureCache, CVOptionFlags options)
{
}

id CVMetalTextureGetTexture(CVMetalTextureRef image)
{
  return (id)MEMORY[0x270EEA110](image);
}

CVReturn CVPixelBufferCreate(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x270EEA150](allocator, width, height, *(void *)&pixelFormatType, pixelBufferAttributes, pixelBufferOut);
}

void *__cdecl CVPixelBufferGetBaseAddress(CVPixelBufferRef pixelBuffer)
{
  return (void *)MEMORY[0x270EEA190](pixelBuffer);
}

void *__cdecl CVPixelBufferGetBaseAddressOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return (void *)MEMORY[0x270EEA1A0](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetBytesPerRow(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA1B0](pixelBuffer);
}

size_t CVPixelBufferGetBytesPerRowOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x270EEA1C8](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetHeight(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA1E8](pixelBuffer);
}

size_t CVPixelBufferGetHeightOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x270EEA1F8](pixelBuffer, planeIndex);
}

OSType CVPixelBufferGetPixelFormatType(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA218](pixelBuffer);
}

size_t CVPixelBufferGetWidth(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA240](pixelBuffer);
}

size_t CVPixelBufferGetWidthOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x270EEA250](pixelBuffer, planeIndex);
}

CVReturn CVPixelBufferLockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags lockFlags)
{
  return MEMORY[0x270EEA260](pixelBuffer, lockFlags);
}

CVReturn CVPixelBufferPoolCreate(CFAllocatorRef allocator, CFDictionaryRef poolAttributes, CFDictionaryRef pixelBufferAttributes, CVPixelBufferPoolRef *poolOut)
{
  return MEMORY[0x270EEA278](allocator, poolAttributes, pixelBufferAttributes, poolOut);
}

CVReturn CVPixelBufferPoolCreatePixelBuffer(CFAllocatorRef allocator, CVPixelBufferPoolRef pixelBufferPool, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x270EEA288](allocator, pixelBufferPool, pixelBufferOut);
}

void CVPixelBufferPoolFlush(CVPixelBufferPoolRef pool, CVPixelBufferPoolFlushFlags options)
{
}

void CVPixelBufferPoolRelease(CVPixelBufferPoolRef pixelBufferPool)
{
}

void CVPixelBufferRelease(CVPixelBufferRef texture)
{
}

CVPixelBufferRef CVPixelBufferRetain(CVPixelBufferRef texture)
{
  return (CVPixelBufferRef)MEMORY[0x270EEA320](texture);
}

CVReturn CVPixelBufferUnlockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags unlockFlags)
{
  return MEMORY[0x270EEA330](pixelBuffer, unlockFlags);
}

uint64_t FigAspenCreateJPEGFromCVPixelBuffer()
{
  return MEMORY[0x270F15BB8]();
}

IOSurfaceRef IOSurfaceCreate(CFDictionaryRef properties)
{
  return (IOSurfaceRef)MEMORY[0x270EF4C28](properties);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return (void *)MEMORY[0x270EF4C58](buffer);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x270EF4E18](buffer, *(void *)&options, seed);
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x270EF4E88](buffer, *(void *)&options, seed);
}

id MTLCreateSystemDefaultDevice(void)
{
  return (id)MEMORY[0x270EF5E20]();
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x270EFDCB0](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x270EFDCD0](allocator);
}

OSStatus VTPixelTransferSessionCreate(CFAllocatorRef allocator, VTPixelTransferSessionRef *pixelTransferSessionOut)
{
  return MEMORY[0x270F067E0](allocator, pixelTransferSessionOut);
}

void VTPixelTransferSessionInvalidate(VTPixelTransferSessionRef session)
{
}

OSStatus VTPixelTransferSessionTransferImage(VTPixelTransferSessionRef session, CVPixelBufferRef sourceBuffer, CVPixelBufferRef destinationBuffer)
{
  return MEMORY[0x270F067F0](session, sourceBuffer, destinationBuffer);
}

OSStatus VTSessionSetProperty(VTSessionRef session, CFStringRef propertyKey, CFTypeRef propertyValue)
{
  return MEMORY[0x270F06820](session, propertyKey, propertyValue);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x270EE56F0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x270EE5700]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void cva::imageViewFromPixelBuffer<float>()
{
  while (1)
    ;
}

void cva::imageViewFromPixelBuffer<unsigned char>()
{
  while (1)
    ;
}

uint64_t cva::vecLib::gesvd<float>()
{
  return MEMORY[0x270F18AE8]();
}

uint64_t cva::imwrite<float>()
{
  return MEMORY[0x270F18AF8]();
}

uint64_t cva::imwrite<unsigned char>()
{
  return MEMORY[0x270F18B00]();
}

uint64_t H10ISP::H10ISPCreateEXIFDictFromMetadataDict(H10ISP *this, const __CFDictionary *a2)
{
  return MEMORY[0x270F306A8](this, a2);
}

std::string *__cdecl std::locale::name(std::string *__return_ptr retstr, const std::locale *this)
{
  return (std::string *)MEMORY[0x270F982D8](retstr, this);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x270F982E8](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x270F982F8](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x270F983B0](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x270F98428](this);
}

void std::this_thread::sleep_for (const std::chrono::nanoseconds *__ns)
{
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x270F98458](__n);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x270F98560](this, __str);
}

std::string *__cdecl std::string::operator=(std::string *this, std::string::value_type __c)
{
  return (std::string *)MEMORY[0x270F98568](this, __c);
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x270F98640]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x270F98650]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x270F98658]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x270F98740]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x270F98748]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x270F98758]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x270F98760]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x270F98770]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x270F987A0]();
}

{
  return MEMORY[0x270F987A8]();
}

uint64_t std::ofstream::open()
{
  return MEMORY[0x270F98878]();
}

std::regex_traits<char>::char_class_type std::__get_classname(const char *__s, BOOL __icase)
{
  return MEMORY[0x270F98890](__s, __icase);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

std::string *__cdecl std::__get_collation_name(std::string *__return_ptr retstr, const char *__s)
{
  return (std::string *)MEMORY[0x270F98A00](retstr, __s);
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
}

uint64_t std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>()
{
  return MEMORY[0x270F98BF0]();
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x270F98C18]();
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x270F98C70](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x270F98C78](this);
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x270F98DE8]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, double __val)
{
  return (std::string *)MEMORY[0x270F98DF8](retstr, __val);
}

std::bad_alloc *__cdecl std::bad_alloc::bad_alloc(std::bad_alloc *this)
{
  return (std::bad_alloc *)MEMORY[0x270F98E58](this);
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete(void *__p, const std::nothrow_t *a2)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new[](size_t __sz, const std::nothrow_t *a2)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x270ED7DA0](lpfunc, obj, lpdso_handle);
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x270F98F10](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

simd_float2x2 __invert_f2(simd_float2x2 a1)
{
  MEMORY[0x270ED7E10]((__n128)a1, *(__n128 *)((char *)&a1 + 8));
  result.columns[1] = v2;
  result.columns[0] = v1;
  return result;
}

simd_float3x3 __invert_f3(simd_float3x3 a1)
{
  MEMORY[0x270ED7E18]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2]);
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

simd_float4x4 __invert_f4(simd_float4x4 a1)
{
  MEMORY[0x270ED7E20]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2], (__n128)a1.columns[3]);
  result.columns[3].i64[1] = v8;
  result.columns[3].i64[0] = v7;
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x270ED7E90](a1);
  result.__float cosval = v2;
  result.__sinval = v1;
  return result;
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

float acosf(float a1)
{
  MEMORY[0x270ED8598](a1);
  return result;
}

float asinf(float a1)
{
  MEMORY[0x270ED8618](a1);
  return result;
}

float atan2f(float a1, float a2)
{
  MEMORY[0x270ED86B8](a1, a2);
  return result;
}

void bzero(void *a1, size_t a2)
{
}

float cbrtf(float a1)
{
  MEMORY[0x270ED87C0](a1);
  return result;
}

float cosf(float a1)
{
  MEMORY[0x270ED9130](a1);
  return result;
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
}

void dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *context, void (__cdecl *work)(void *, size_t))
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x270ED9318](identifier, flags);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x270ED9340]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x270ED9378](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x270ED9460](label, attr);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

float expf(float a1)
{
  MEMORY[0x270ED9870](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x270ED98C8](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x270ED99F0](__filename, __mode);
}

void free(void *a1)
{
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9B88](__ptr, __size, __nitems, __stream);
}

kern_return_t host_page_size(host_t a1, vm_size_t *a2)
{
  return MEMORY[0x270ED9E20](*(void *)&a1, a2);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x270ED9F50]();
}

float logf(float a1)
{
  MEMORY[0x270EDA0F8](a1);
  return result;
}

mach_port_t mach_host_self(void)
{
  return MEMORY[0x270EDA178]();
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x270EDA398](memptr, alignment, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x270EDA458](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x270F9A568](a1);
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x270F9A598](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x270F9A678](self, _cmd, offset, atomic);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x270F9A700]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A888](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A890](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDA9A0](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

float powf(float a1, float a2)
{
  MEMORY[0x270EDAD00](a1, a2);
  return result;
}

float sinf(float a1)
{
  MEMORY[0x270EDB4F0](a1);
  return result;
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

float tanf(float a1)
{
  MEMORY[0x270EDB818](a1);
  return result;
}

void vDSP_f3x3(const float *__A, vDSP_Length __NR, vDSP_Length __NC, const float *__F, float *__C)
{
}

void vDSP_normalize(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, float *__Mean, float *__StandardDeviation, vDSP_Length __N)
{
}

void vDSP_sve(const float *__A, vDSP_Stride __I, float *__C, vDSP_Length __N)
{
}

vImage_Error vImageConvert_Planar8toPlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, Pixel_F maxFloat, Pixel_F minFloat, vImage_Flags flags)
{
  return MEMORY[0x270EDF090](src, dest, *(void *)&flags, maxFloat, minFloat);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x270EDBA80](*(void *)&target_task, address, size, *(void *)&flags);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x270EDBA90](*(void *)&target_task, address, size);
}