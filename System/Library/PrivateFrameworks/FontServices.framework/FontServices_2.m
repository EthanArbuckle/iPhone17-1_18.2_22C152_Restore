void *sub_1B529985C@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2;
  BOOL v3;
  uint64_t v4;

  v2 = result[1];
  v3 = __OFADD__(v2, 1);
  v4 = v2 + 1;
  if (v3)
  {
    __break(1u);
  }
  else if (v4 >= *result)
  {
    *a2 = *result;
    a2[1] = v4;
    return result;
  }
  __break(1u);
  return result;
}

void *sub_1B5299884@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return sub_1B525BFB4(a1, a2);
}

uint64_t GlyphMetadataTable.glyphRanges.getter()
{
  return sub_1B52998E8();
}

uint64_t sub_1B52998E8()
{
  sub_1B529E2A0(v0, (uint64_t)v9);
  sub_1B529E2A0((uint64_t)v9, (uint64_t)v18);
  switch(v21)
  {
    case 1:
      if (__OFSUB__(*(void *)v18, 4)) {
        goto LABEL_17;
      }
      *(void *)v10 = *(void *)v18;
      *(_OWORD *)&v10[8] = *(_OWORD *)&v18[8];
      *(void *)&v10[24] = *(void *)&v18[24];
      *(void *)&long long v11 = v19;
      WORD4(v11) = 257;
      v12 = sub_1B529985C;
      uint64_t v13 = 0;
      v14 = (__n128 (*)@<Q0>(__n128 *@<X0>, __n128 *@<X8>))(*(void *)v18 - 4);
      LOBYTE(v15) = 1;
      v16 = sub_1B529C244;
      uint64_t v17 = 0;
      sub_1B529E2C8(v0, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B52148E8);
      swift_bridgeObjectRetain();
      uint64_t v4 = sub_1B5298D90((uint64_t)v10);
      goto LABEL_10;
    case 2:
      *(_OWORD *)&v23[16] = v19;
      *(_OWORD *)&v23[32] = v20;
      long long v22 = *(_OWORD *)v18;
      *(_OWORD *)v23 = *(_OWORD *)&v18[16];
      *(_OWORD *)v24 = *(_OWORD *)&v23[8];
      *(_OWORD *)&v24[16] = *(_OWORD *)&v23[24];
      uint64_t v25 = *((void *)&v20 + 1);
      if (__OFSUB__(*(void *)&v18[24], 4)) {
        goto LABEL_18;
      }
      *(void *)v10 = *(void *)&v18[24];
      *(_OWORD *)&v10[8] = *(_OWORD *)&v24[8];
      *(void *)&v10[24] = *(void *)&v24[24];
      *(void *)&long long v11 = v25;
      WORD4(v11) = 257;
      v12 = sub_1B529985C;
      uint64_t v13 = 0;
      v14 = (__n128 (*)@<Q0>(__n128 *@<X0>, __n128 *@<X8>))(*(void *)&v18[24] - 4);
      LOBYTE(v15) = 1;
      v16 = sub_1B529C244;
      uint64_t v17 = 0;
      sub_1B5268628((uint64_t)v24);
      sub_1B529E2C8(v0, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B52148E8);
      sub_1B5268628((uint64_t)v24);
      uint64_t v3 = sub_1B5298D90((uint64_t)v10);
      swift_bridgeObjectRelease();
      sub_1B51E00CC((uint64_t)v24);
      goto LABEL_11;
    case 3:
      if (__OFSUB__(*(void *)v18, 4)) {
        goto LABEL_19;
      }
      *(void *)v10 = *(void *)v18;
      *(_OWORD *)&v10[8] = *(_OWORD *)&v18[8];
      *(void *)&v10[24] = *(void *)&v18[24];
      *(void *)&long long v11 = v19;
      BYTE8(v11) = 1;
      v12 = (void *(*)@<X0>(void *@<X0>, void *@<X8>))(*(void *)v18 - 4);
      LOBYTE(v13) = 1;
      v14 = sub_1B529C2C4;
      uint64_t v15 = 0;
      sub_1B529E2C8(v0, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B52148E8);
      swift_bridgeObjectRetain();
      uint64_t v4 = sub_1B5299224((uint64_t)v10);
LABEL_10:
      uint64_t v3 = v4;
      swift_bridgeObjectRelease();
LABEL_11:
      sub_1B529E2C8(v0, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B5200BC8);
      break;
    case 4:
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47960);
      uint64_t v5 = swift_allocObject();
      uint64_t v3 = v5;
      long long v6 = xmmword_1B538C0E0;
      long long v7 = *(_OWORD *)v18;
      goto LABEL_14;
    case 5:
      *(_OWORD *)v10 = *(_OWORD *)v18;
      *(_OWORD *)&v10[16] = *(_OWORD *)&v18[16];
      long long v11 = v19;
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47960);
      uint64_t v5 = swift_allocObject();
      uint64_t v3 = v5;
      long long v6 = xmmword_1B538C0E0;
      long long v7 = *(_OWORD *)&v10[8];
LABEL_14:
      *(_OWORD *)(v5 + 16) = v6;
      *(_OWORD *)(v5 + 32) = v7;
      break;
    default:
      uint64_t v1 = *(void *)v18;
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47960);
      uint64_t v2 = swift_allocObject();
      *(_OWORD *)(v2 + 16) = xmmword_1B538C0E0;
      if (v1 < 0)
      {
        __break(1u);
LABEL_17:
        __break(1u);
LABEL_18:
        __break(1u);
LABEL_19:
        __break(1u);
        JUMPOUT(0x1B5299C28);
      }
      uint64_t v3 = v2;
      *(void *)(v2 + 32) = 0;
      *(void *)(v2 + 40) = v1;
      break;
  }
  return v3;
}

uint64_t *sub_1B5299C40(uint64_t a1)
{
  uint64_t v2 = v1;
  sub_1B529E2A0(v1, (uint64_t)v37);
  sub_1B529E2A0((uint64_t)v37, (uint64_t)v47);
  switch(v50)
  {
    case 1:
      if (__OFSUB__(*(void *)v47, 4))
      {
        __break(1u);
LABEL_34:
        __break(1u);
LABEL_35:
        __break(1u);
LABEL_36:
        __break(1u);
LABEL_37:
        __break(1u);
        JUMPOUT(0x1B529A18CLL);
      }
      uint64_t v34 = *(void *)&v47[8];
      *(void *)v38 = *(void *)v47;
      *(_OWORD *)&v38[8] = *(_OWORD *)&v47[8];
      *(void *)&v38[24] = *(void *)&v47[24];
      uint64_t v39 = *(void *)&v47[32];
      __int16 v40 = 257;
      v41 = sub_1B529985C;
      uint64_t v42 = 0;
      uint64_t v43 = *(void *)v47 - 4;
      char v44 = 1;
      v45 = sub_1B529C244;
      uint64_t v46 = 0;
      sub_1B529E2C8(v1, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B52148E8);
      swift_bridgeObjectRetain();
      uint64_t v5 = sub_1B52631DC(a1, (uint64_t)v38);
      if (v5 == v34)
      {
        swift_bridgeObjectRelease();
        goto LABEL_30;
      }
      uint64_t v15 = v5;
      uint64_t v16 = sub_1B529C428(v5);
      uint64_t v18 = v17;
      uint64_t v20 = v19;
      swift_bridgeObjectRelease();
      sub_1B529E2C8(v2, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B5200BC8);
      if (v15 < v18) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = 0;
      }
      if (v15 >= v16) {
        return (uint64_t *)v21;
      }
      else {
        return 0;
      }
    case 2:
      *(_OWORD *)v51 = *(_OWORD *)&v47[24];
      *(_OWORD *)&v51[16] = v48;
      uint64_t v52 = v49;
      if (__OFSUB__(*(void *)&v47[24], 4)) {
        goto LABEL_34;
      }
      *(void *)v38 = *(void *)v51;
      uint64_t v35 = *(void *)&v51[8];
      *(_OWORD *)&v38[8] = *(_OWORD *)&v51[8];
      *(void *)&v38[24] = *(void *)&v51[24];
      uint64_t v39 = v49;
      __int16 v40 = 257;
      v41 = sub_1B529985C;
      uint64_t v42 = 0;
      uint64_t v43 = *(void *)&v47[24] - 4;
      char v44 = 1;
      v45 = sub_1B529C244;
      uint64_t v46 = 0;
      sub_1B5268628((uint64_t)v51);
      sub_1B529E2C8(v1, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B52148E8);
      sub_1B5268628((uint64_t)v51);
      uint64_t v6 = sub_1B52631DC(a1, (uint64_t)v38);
      if (v6 == v35)
      {
        swift_bridgeObjectRelease();
        sub_1B51E00CC((uint64_t)v51);
        goto LABEL_30;
      }
      uint64_t v22 = v6;
      uint64_t v23 = sub_1B529C428(v6);
      uint64_t v25 = v24;
      uint64_t v27 = v26;
      swift_bridgeObjectRelease();
      sub_1B51E00CC((uint64_t)v51);
      if (v22 < v23 || v22 >= v25 || v27 < 0 || v27 + 0x4000000000000000 < 0)
      {
LABEL_30:
        sub_1B529E2C8(v2, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B5200BC8);
        return 0;
      }
      v36[0] = sub_1B53724C8();
      v36[1] = v30;
      v36[2] = v31;
      swift_bridgeObjectRetain();
      unsigned __int16 v33 = (unsigned __int16)sub_1B51F3E0C(v36, v32, 1);
      swift_bridgeObjectRelease();
      long long v7 = (uint64_t *)v33;
      swift_bridgeObjectRelease();
LABEL_11:
      sub_1B529E2C8(v2, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B5200BC8);
      return v7;
    case 3:
      *(_OWORD *)v38 = *(_OWORD *)v47;
      *(_OWORD *)&v38[16] = *(_OWORD *)&v47[16];
      uint64_t v39 = *(void *)&v47[32];
      sub_1B529E2C8(v1, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B52148E8);
      uint64_t v4 = sub_1B529AFFC(a1);
      goto LABEL_10;
    case 4:
      uint64_t v8 = a1 - *(void *)v47;
      if (__OFSUB__(a1, *(void *)v47)) {
        goto LABEL_35;
      }
      if (v8 < 0) {
        return 0;
      }
      if (v8 + 0x4000000000000000 < 0) {
        goto LABEL_36;
      }
      sub_1B529E2C8(v1, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B52148E8);
      *(void *)v38 = sub_1B53724C8();
      *(void *)&v38[8] = v9;
      *(void *)&v38[16] = v10;
      swift_bridgeObjectRetain();
      unsigned __int16 v29 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)v38, v11, 1);
      swift_bridgeObjectRelease();
      long long v7 = (uint64_t *)v29;
      swift_bridgeObjectRelease();
      goto LABEL_11;
    case 5:
      if (*(uint64_t *)&v47[8] > a1) {
        return 0;
      }
      if (a1 + 0x4000000000000000 < 0) {
        goto LABEL_37;
      }
      uint64_t v12 = *(void *)v47;
      sub_1B529E2C8(v2, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B52148E8);
      *(void *)v38 = sub_1B53724C8();
      *(void *)&v38[8] = v13;
      *(void *)&v38[16] = v14;
      long long v7 = sub_1B51FA4D0((uint64_t *)v38, v13, v12, 1);
      swift_bridgeObjectRelease();
      goto LABEL_11;
    default:
      sub_1B529E2C8(v1, (void (*)(void, void, void, void, void, void, void, void, char))sub_1B52148E8);
      uint64_t v4 = sub_1B529AF30(a1);
LABEL_10:
      long long v7 = (uint64_t *)v4;
      goto LABEL_11;
  }
}

uint64_t sub_1B529A1A4()
{
  return swift_bridgeObjectRelease();
}

uint64_t sub_1B529A2C0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void (*a5)(char *, uint64_t)@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v44 = a7;
  uint64_t v45 = a8;
  uint64_t v43 = a6;
  uint64_t v46 = a5;
  uint64_t v52 = a3;
  uint64_t v53 = a4;
  uint64_t v51 = a2;
  uint64_t v54 = a9;
  uint64_t v49 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D48E78);
  MEMORY[0x1F4188790](v49);
  uint64_t v11 = (uint64_t *)((char *)&v41 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v47 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A50);
  MEMORY[0x1F4188790](v47);
  uint64_t v13 = (char *)&v41 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v42 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A60);
  uint64_t v14 = *(void *)(v42 - 8);
  MEMORY[0x1F4188790](v42);
  uint64_t v16 = (char *)&v41 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A58);
  MEMORY[0x1F4188790](v17);
  uint64_t v19 = (void (**)(char *, uint64_t))((char *)&v41 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v20);
  uint64_t v22 = (char *)&v41 - v21;
  uint64_t v41 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A48);
  MEMORY[0x1F4188790](v41);
  uint64_t v24 = (char *)&v41 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v48 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D48E80);
  MEMORY[0x1F4188790](v48);
  uint64_t v26 = (uint64_t *)((char *)&v41 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v50 = a1;
  if (a1 == 2)
  {
    unsigned __int16 v33 = (void *)swift_allocObject();
    uint64_t v34 = v45;
    uint64_t v35 = v43;
    v33[2] = v46;
    v33[3] = v35;
    v33[4] = v44;
    v33[5] = v34;
    *uint64_t v13 = 1;
    *((void *)v13 + 1) = sub_1B529E514;
    *((void *)v13 + 2) = v33;
    *((void *)v13 + 3) = sub_1B529B100;
    *((void *)v13 + 4) = 0;
    swift_storeEnumTagMultiPayload();
    sub_1B5201384((uint64_t)v13, (uint64_t)v26, &qword_1E9D47A50);
    swift_storeEnumTagMultiPayload();
    uint64_t v31 = v53;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    if (a1 != 1)
    {
      sub_1B51DD5FC();
      v36 = (void *)swift_allocError();
      unsigned char *v37 = 11;
      *uint64_t v26 = v36;
      v26[1] = 0;
      v26[2] = 0;
      v26[3] = 0xE000000000000000;
      v26[4] = v36;
      swift_storeEnumTagMultiPayload();
      uint64_t v31 = v53;
      swift_bridgeObjectRetain();
      id v38 = v36;
      goto LABEL_7;
    }
    sub_1B53724E8();
    uint64_t v27 = (char *)v19 + *(int *)(v17 + 52);
    uint64_t v28 = v14;
    unsigned __int16 v29 = *(void (**)(char *, char *, uint64_t))(v14 + 16);
    uint64_t v30 = v42;
    v29(v27, v16, v42);
    *uint64_t v19 = v46;
    uint64_t v46 = *(void (**)(char *, uint64_t))(v28 + 8);
    uint64_t v31 = v53;
    swift_bridgeObjectRetain();
    v46(v16, v30);
    sub_1B5201994((uint64_t)v19, (uint64_t)v22, &qword_1E9D47A58);
    sub_1B5201384((uint64_t)v22, (uint64_t)v24, &qword_1E9D47A58);
    uint64_t v32 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))&v24[*(int *)(v41 + 44)];
    *uint64_t v32 = sub_1B529A7E4;
    v32[1] = 0;
    sub_1B51E0064((uint64_t)v22, &qword_1E9D47A58);
    sub_1B5201384((uint64_t)v24, (uint64_t)v13, &qword_1E9D47A48);
    swift_storeEnumTagMultiPayload();
    sub_1B51E0064((uint64_t)v24, &qword_1E9D47A48);
    sub_1B5201384((uint64_t)v13, (uint64_t)v26, &qword_1E9D47A50);
    swift_storeEnumTagMultiPayload();
  }
  sub_1B51E0064((uint64_t)v13, &qword_1E9D47A50);
LABEL_7:
  sub_1B5201384((uint64_t)v26, (uint64_t)v11 + *(int *)(v49 + 52), &qword_1E9D48E80);
  uint64_t v39 = v51;
  *uint64_t v11 = v50;
  v11[1] = v39;
  v11[2] = v52;
  v11[3] = v31;
  sub_1B51E0064((uint64_t)v26, &qword_1E9D48E80);
  return sub_1B5201994((uint64_t)v11, v54, &qword_1E9D48E78);
}

uint64_t sub_1B529A7E4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 24);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(void *)(a2 + 16) = v3;
  *(void *)(a2 + 24) = v2;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(unsigned char *)(a2 + 64) = 0;
  return swift_bridgeObjectRetain();
}

uint64_t GlyphInfo.codePoints.getter()
{
  return swift_bridgeObjectRetain();
}

uint64_t GlyphInfo.codePoints.setter(uint64_t a1)
{
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)(v1 + 40) = a1;
  return result;
}

uint64_t (*GlyphInfo.codePoints.modify())(void)
{
  return nullsub_1;
}

uint64_t GlyphInfo.glyphIdentifiers.getter()
{
  return swift_bridgeObjectRetain();
}

uint64_t GlyphInfo.glyphIdentifiers.setter(uint64_t a1)
{
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)(v1 + 48) = a1;
  return result;
}

uint64_t (*GlyphInfo.glyphIdentifiers.modify())(void)
{
  return nullsub_1;
}

BOOL GlyphInfo.isCanonical.getter()
{
  if (*(uint64_t *)(v0 + 32) >= 2) {
    return *(char *)(v0 + 25) < 0;
  }
  uint64_t v1 = *(void *)(v0 + 48);
  uint64_t v2 = *(void *)(v1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (unint64_t *)(v1 + 32);
  while (1)
  {
    unint64_t v5 = *v3;
    v3 += 3;
    unint64_t v4 = v5;
    if (v5 >> 61 == 3) {
      break;
    }
    if (!--v2) {
      return 0;
    }
  }
  return (v4 >> 7) & 1;
}

uint64_t static GlyphInfoFlags.isCanonical.getter()
{
  return 128;
}

uint64_t GlyphInfo.findName(kind:)(unsigned __int8 a1)
{
  uint64_t v2 = *(void *)(v1 + 48);
  uint64_t v3 = *(void *)(v2 + 16);
  if (!v3) {
    return 0;
  }
  for (uint64_t i = v2 + 48; *(void *)(i - 16) >> 61 || *(void *)(i - 16) != a1; i += 24)
  {
    if (!--v3) {
      return 0;
    }
  }
  uint64_t v6 = *(void *)(i - 8);
  swift_bridgeObjectRetain();
  return v6;
}

uint64_t GlyphInfo.findCID(kind:)(unsigned __int8 a1)
{
  uint64_t v2 = *(void *)(v1 + 48);
  uint64_t v3 = *(void *)(v2 + 16);
  if (!v3) {
    return 0;
  }
  for (uint64_t i = v2 + 40; *(void *)(i - 8) >> 61 != 1 || *(void *)(i - 8) != a1; i += 24)
  {
    if (!--v3) {
      return 0;
    }
  }
  return *(void *)i;
}

uint64_t GlyphInfo.findStringIndex(kind:)(unsigned __int8 a1)
{
  uint64_t v2 = *(void *)(v1 + 48);
  uint64_t v3 = *(void *)(v2 + 16);
  if (!v3) {
    return 0;
  }
  for (uint64_t i = v2 + 40; *(void *)(i - 8) >> 61 != 2 || *(void *)(i - 8) != a1; i += 24)
  {
    if (!--v3) {
      return 0;
    }
  }
  return *(void *)i;
}

int *sub_1B529AA34@<X0>(int *result@<X0>, uint64_t a2@<X8>)
{
  int v2 = *result;
  BOOL v3 = *result == -1;
  if (*result == -1) {
    int v2 = 0;
  }
  *(_DWORD *)a2 = v2;
  *(unsigned char *)(a2 + 4) = v3;
  return result;
}

unsigned int *sub_1B529AA50@<X0>(unsigned int *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *result;
  char v3 = *((unsigned char *)result + 4);
  if (v3) {
    uint64_t v2 = 0;
  }
  *(void *)a2 = v2;
  *(unsigned char *)(a2 + 8) = v3;
  return result;
}

uint64_t *sub_1B529AA6C@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *result;
  *(unsigned char *)a2 = 1;
  *(void *)(a2 + 8) = MEMORY[0x1E4FBC860];
  *(void *)(a2 + 16) = v2;
  *(void *)(a2 + 24) = sub_1B529AA9C;
  *(void *)(a2 + 32) = 0;
  return result;
}

uint64_t sub_1B529AA9C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = *(void *)a1 + 32;
  uint64_t v4 = *(void *)(*(void *)a1 + 16);
  type metadata accessor for RefcountCheck();
  swift_allocObject();
  uint64_t v5 = swift_retain();
  uint64_t v6 = sub_1B527500C(v5, v3, v4, 0);
  swift_release();
  if (swift_isUniquelyReferenced_nonNull_native())
  {
    uint64_t result = swift_release();
    *a2 = v6;
  }
  else
  {
    uint64_t result = sub_1B53730C8();
    __break(1u);
  }
  return result;
}

unsigned __int8 *(**sub_1B529AB84@<X0>(unsigned __int8 *(**result)@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X8>)@<X0>, unsigned __int8 *(**a2)@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X8>)@<X8>))@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *result;
  *a2 = sub_1B529E4C4;
  a2[1] = 0;
  a2[2] = (unsigned __int8 *(*)@<X0>(unsigned __int8 *@<X0>, uint64_t@<X8>))MEMORY[0x1E4FBC860];
  a2[3] = v2;
  return result;
}

uint64_t sub_1B529ABAC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  char v2 = *(unsigned char *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  char v4 = *(unsigned char *)(a1 + 24);
  char v5 = *(unsigned char *)(a1 + 25);
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 48);
  *(void *)a2 = *(void *)a1;
  *(unsigned char *)(a2 + 8) = v2;
  *(void *)(a2 + 16) = v3;
  *(unsigned char *)(a2 + 24) = v4;
  *(unsigned char *)(a2 + 25) = v5;
  *(void *)(a2 + 32) = v7;
  *(void *)(a2 + 40) = v6;
  *(void *)(a2 + 48) = v8;
  swift_bridgeObjectRetain();
  return swift_bridgeObjectRetain();
}

uint64_t GlyphIdentifier.NameKind.rawValue.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*GlyphIdentifier.NameKind.rawValue.modify())(void)
{
  return nullsub_1;
}

uint64_t static GlyphIdentifier.NameKind.universalPostScriptName.getter()
{
  return 0;
}

uint64_t static GlyphIdentifier.NameKind.applePostScriptName.getter()
{
  return 1;
}

uint64_t static GlyphIdentifier.NameKind.adobePostScriptName.getter()
{
  return 2;
}

uint64_t static GlyphIdentifier.NameKind.afiiPostScriptName.getter()
{
  return 3;
}

uint64_t static GlyphIdentifier.NameKind.unicodeName.getter()
{
  return 4;
}

uint64_t GlyphIdentifier.CIDKind.rawValue.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*GlyphIdentifier.CIDKind.rawValue.modify())(void)
{
  return nullsub_1;
}

uint64_t static GlyphIdentifier.CIDKind.japanese.getter()
{
  return 64;
}

uint64_t static GlyphIdentifier.CIDKind.chineseTraditional.getter()
{
  return 65;
}

uint64_t static GlyphIdentifier.CIDKind.chineseSimplified.getter()
{
  return 66;
}

uint64_t static GlyphIdentifier.CIDKind.korean.getter()
{
  return 67;
}

uint64_t GlyphIdentifier.NameEntryKind.rawValue.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*GlyphIdentifier.NameEntryKind.rawValue.modify())(void)
{
  return nullsub_1;
}

uint64_t static GlyphIdentifier.NameEntryKind.history.getter()
{
  return 68;
}

uint64_t static GlyphIdentifier.NameEntryKind.shortName.getter()
{
  return 69;
}

uint64_t static GlyphIdentifier.NameEntryKind.longName.getter()
{
  return 70;
}

uint64_t static GlyphIdentifier.NameEntryKind.usageNotes.getter()
{
  return 71;
}

uint64_t static GlyphIdentifier.NameEntryKind.historicalNotes.getter()
{
  return 72;
}

uint64_t GlyphIdentifier.kind.getter(unint64_t a1)
{
  uint64_t v1 = 127;
  if (a1 >> 61 != 3) {
    return a1;
  }
  return v1;
}

unsigned __int8 *sub_1B529AD54@<X0>(unsigned __int8 *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *result;
  if (v2 > 0x3F)
  {
    if (v2 > 0x43)
    {
      if (v2 > 0x7E)
      {
        uint64_t v3 = sub_1B529AEEC;
        uint64_t v8 = (uint64_t)sub_1B529AEDC;
        if (v2 == 127)
        {
          uint64_t v7 = 0;
          char v5 = 0;
          long long v6 = xmmword_1B5390830;
          __int16 v4 = 256;
          uint64_t v2 = 1;
        }
        else
        {
          uint64_t v8 = 0;
          uint64_t v7 = 0;
          uint64_t v3 = 0;
          __int16 v4 = 0;
          v2 |= 0x8000000000000000;
          long long v6 = 0uLL;
          char v5 = 1;
        }
      }
      else
      {
        uint64_t v7 = 0;
        uint64_t v3 = 0;
        char v5 = 0;
        v2 |= 0x100uLL;
        long long v6 = 0uLL;
        __int16 v4 = 256;
        uint64_t v8 = (uint64_t)sub_1B529AEC4;
      }
    }
    else
    {
      uint64_t v7 = 0;
      uint64_t v3 = 0;
      char v5 = 0;
      v2 |= 0x100uLL;
      long long v6 = 0uLL;
      __int16 v4 = 1;
      uint64_t v8 = (uint64_t)sub_1B529AEAC;
    }
  }
  else
  {
    uint64_t v3 = 0;
    __int16 v4 = 0;
    char v5 = 0;
    *((void *)&v6 + 1) = 0;
    *(void *)&long long v6 = sub_1B529AE84;
    uint64_t v7 = sub_1B51D2470;
    uint64_t v8 = 1;
  }
  *(void *)a2 = v2;
  *(void *)(a2 + 8) = v8;
  *(void *)(a2 + 16) = v7;
  *(void *)(a2 + 24) = v3;
  *(_OWORD *)(a2 + 32) = v6;
  *(_WORD *)(a2 + 48) = v4;
  *(unsigned char *)(a2 + 50) = v5;
  return result;
}

uint64_t sub_1B529AE84@<X0>(unsigned __int8 *a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *a1;
  uint64_t v4 = *((void *)a1 + 1);
  uint64_t v3 = *((void *)a1 + 2);
  *a2 = v2;
  a2[1] = v4;
  a2[2] = v3;
  return swift_bridgeObjectRetain();
}

unsigned __int8 *sub_1B529AEAC@<X0>(unsigned __int8 *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *((void *)result + 1);
  *a2 = *result | 0x2000000000000000;
  a2[1] = v2;
  a2[2] = 0;
  return result;
}

unsigned __int8 *sub_1B529AEC4@<X0>(unsigned __int8 *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *((void *)result + 1);
  *a2 = *result | 0x4000000000000000;
  a2[1] = v2;
  a2[2] = 0;
  return result;
}

uint64_t sub_1B529AEDC@<X0>(uint64_t result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = *(unsigned char *)(result + 1) & 0x80;
  return result;
}

unsigned __int8 *sub_1B529AEEC@<X0>(unsigned __int8 *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *result;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = v2 | 0x6000000000000000;
  return result;
}

uint64_t GlyphInfoFlags.rawValue.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*GlyphInfoFlags.rawValue.modify())(void)
{
  return nullsub_1;
}

uint64_t sub_1B529AF30(uint64_t result)
{
  if ((unint64_t)(result - 0x2000000000000000) >> 62 == 3)
  {
    v7[8] = v1;
    v7[9] = v2;
    v7[0] = sub_1B53724C8();
    v7[1] = v3;
    v7[2] = v4;
    swift_bridgeObjectRetain();
    unsigned int v6 = sub_1B51F3DDC(v7, v5, 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return v6;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t sub_1B529AFFC(uint64_t result)
{
  uint64_t v2 = *v1 - 4;
  if (__OFSUB__(*v1, 4))
  {
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  uint64_t v3 = result;
  uint64_t v4 = v1[3];
  uint64_t v5 = v1[4];
  uint64_t v14 = *v1;
  long long v15 = *(_OWORD *)(v1 + 1);
  uint64_t v13 = v15;
  uint64_t v16 = v4;
  uint64_t v17 = v5;
  char v18 = 1;
  uint64_t v19 = v2;
  char v20 = 1;
  uint64_t v21 = sub_1B529C2C4;
  uint64_t v22 = 0;
  swift_bridgeObjectRetain();
  uint64_t v6 = sub_1B52636C4(v3, (uint64_t)&v14);
  if (v6 == v13)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  uint64_t v7 = v6;
  uint64_t v8 = sub_1B529C5D8(v6);
  uint64_t v10 = v9;
  uint64_t result = swift_bridgeObjectRelease();
  uint64_t v11 = v8 + 1;
  if (__OFADD__(v8, 1)) {
    goto LABEL_14;
  }
  if (v11 < v8)
  {
LABEL_15:
    __break(1u);
    return result;
  }
  if (v7 < v11) {
    uint64_t v12 = v10;
  }
  else {
    uint64_t v12 = 0;
  }
  if (v7 < v8) {
    return 0;
  }
  else {
    return v12;
  }
}

uint64_t sub_1B529B100@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)a1;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v9 = *(void *)(a1 + 56);
  char v10 = *(unsigned char *)(a1 + 64);
  *(void *)a2 = *(void *)a1;
  *(void *)(a2 + 8) = v2;
  *(void *)(a2 + 16) = v4;
  *(void *)(a2 + 24) = v5;
  *(void *)(a2 + 32) = v6;
  *(void *)(a2 + 40) = v7;
  *(void *)(a2 + 48) = v8;
  *(void *)(a2 + 56) = v9;
  *(unsigned char *)(a2 + 64) = v10;
  return sub_1B52148E8(v3, v2, v4, v5, v6, v7, v8, v9, v10);
}

id sub_1B529B160@<X0>(_WORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  uint64_t v100 = a4;
  uint64_t v101 = a5;
  uint64_t v99 = a3;
  uint64_t v90 = a2;
  v116 = a1;
  v117 = a6;
  uint64_t v96 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47AE0);
  MEMORY[0x1F4188790](v96);
  uint64_t v98 = (uint64_t)&v85 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v95 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47AC0);
  MEMORY[0x1F4188790](v95);
  uint64_t v97 = (uint64_t)&v85 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v106 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A68);
  MEMORY[0x1F4188790](v106);
  uint64_t v107 = (uint64_t)&v85 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v88 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47AD0);
  MEMORY[0x1F4188790](v88);
  v94 = (char *)&v85 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v91 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47AD8);
  MEMORY[0x1F4188790](v91);
  uint64_t v93 = (uint64_t)&v85 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v89 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47AC8);
  MEMORY[0x1F4188790](v89);
  uint64_t v92 = (uint64_t)&v85 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v108 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47AB0);
  MEMORY[0x1F4188790](v108);
  v109 = (char *)&v85 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D48E88);
  MEMORY[0x1F4188790](v13 - 8);
  uint64_t v111 = (uint64_t)&v85 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v110 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47AB8);
  MEMORY[0x1F4188790](v110);
  uint64_t v112 = (uint64_t)&v85 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v102 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47AA8);
  MEMORY[0x1F4188790](v102);
  uint64_t v104 = (uint64_t)&v85 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v86 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A90);
  MEMORY[0x1F4188790](v86);
  uint64_t v87 = (uint64_t)&v85 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v103 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A70);
  MEMORY[0x1F4188790](v103);
  uint64_t v105 = (uint64_t)&v85 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v114 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A78);
  MEMORY[0x1F4188790](v114);
  uint64_t v115 = (uint64_t)&v85 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v113 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A60);
  uint64_t v20 = *(void *)(v113 - 8);
  MEMORY[0x1F4188790](v113);
  uint64_t v22 = (char *)&v85 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A58);
  MEMORY[0x1F4188790](v23);
  uint64_t v25 = (uint64_t *)((char *)&v85 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v26);
  uint64_t v28 = (char *)&v85 - v27;
  uint64_t v29 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47AA0);
  MEMORY[0x1F4188790](v29);
  uint64_t v31 = (char *)&v85 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v32 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A98);
  MEMORY[0x1F4188790](v32);
  uint64_t v34 = (char *)&v85 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0);
  switch(*v116)
  {
    case 0:
      sub_1B53724E8();
      uint64_t v35 = (char *)v25 + *(int *)(v23 + 52);
      uint64_t v36 = v113;
      (*(void (**)(char *, char *, uint64_t))(v20 + 16))(v35, v22, v113);
      *uint64_t v25 = v90;
      (*(void (**)(char *, uint64_t))(v20 + 8))(v22, v36);
      sub_1B5201994((uint64_t)v25, (uint64_t)v28, &qword_1E9D47A58);
      sub_1B5201384((uint64_t)v28, (uint64_t)v31, &qword_1E9D47A58);
      v37 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))&v31[*(int *)(v29 + 44)];
      unsigned char *v37 = sub_1B529C218;
      v37[1] = 0;
      sub_1B51E0064((uint64_t)v28, &qword_1E9D47A58);
      sub_1B5201384((uint64_t)v31, (uint64_t)v34, &qword_1E9D47AA0);
      id v38 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))&v34[*(int *)(v32 + 44)];
      *id v38 = sub_1B529A7E4;
      v38[1] = 0;
      sub_1B51E0064((uint64_t)v31, &qword_1E9D47AA0);
      uint64_t v39 = v105;
      sub_1B5201384((uint64_t)v34, v105, &qword_1E9D47A98);
      swift_storeEnumTagMultiPayload();
      sub_1B51E0064((uint64_t)v34, &qword_1E9D47A98);
      __int16 v40 = &qword_1E9D47A70;
      uint64_t v41 = v115;
      sub_1B5201384(v39, v115, &qword_1E9D47A70);
      swift_storeEnumTagMultiPayload();
      uint64_t v42 = v39;
      goto LABEL_9;
    case 2:
      sub_1B53724E8();
      uint64_t v47 = (uint64_t)v109;
      uint64_t v48 = v113;
      (*(void (**)(char *, char *, uint64_t))(v20 + 16))(&v109[*(int *)(v108 + 52)], v22, v113);
      *(unsigned char *)uint64_t v47 = 1;
      *(void *)(v47 + 8) = sub_1B529C414;
      *(void *)(v47 + 16) = 0;
      *(_DWORD *)(v47 + 24) = 16843009;
      (*(void (**)(char *, uint64_t))(v20 + 8))(v22, v48);
      uint64_t v49 = v111;
      sub_1B5201994(v47, v111, &qword_1E9D47AB0);
      uint64_t v50 = v112;
      sub_1B5201384(v49, v112, &qword_1E9D48E88);
      uint64_t v51 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v50 + *(int *)(v110 + 44));
      *uint64_t v51 = sub_1B529C2D0;
      v51[1] = 0;
      sub_1B51E0064(v49, &qword_1E9D48E88);
      uint64_t v52 = v104;
      sub_1B5201384(v50, v104, &qword_1E9D47AB8);
      uint64_t v53 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v52 + *(int *)(v102 + 44));
      *uint64_t v53 = sub_1B529C258;
      v53[1] = 0;
      sub_1B51E0064(v50, &qword_1E9D47AB8);
      uint64_t v54 = v87;
      sub_1B5201384(v52, v87, &qword_1E9D47AA8);
      v55 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v54 + *(int *)(v86 + 44));
      *v55 = sub_1B529C0FC;
      v55[1] = 0;
      sub_1B51E0064(v52, &qword_1E9D47AA8);
      uint64_t v56 = v105;
      sub_1B5201384(v54, v105, &qword_1E9D47A90);
      swift_storeEnumTagMultiPayload();
      sub_1B51E0064(v54, &qword_1E9D47A90);
      __int16 v40 = &qword_1E9D47A70;
      uint64_t v41 = v115;
      sub_1B5201384(v56, v115, &qword_1E9D47A70);
      goto LABEL_8;
    case 4:
      sub_1B53724E8();
      uint64_t v57 = (uint64_t)v109;
      uint64_t v58 = v113;
      (*(void (**)(char *, char *, uint64_t))(v20 + 16))(&v109[*(int *)(v108 + 52)], v22, v113);
      *(unsigned char *)uint64_t v57 = 1;
      *(void *)(v57 + 8) = sub_1B529C414;
      *(void *)(v57 + 16) = 0;
      *(_DWORD *)(v57 + 24) = 16843009;
      v59 = *(void (**)(char *, uint64_t))(v20 + 8);
      uint64_t v60 = v101;
      swift_bridgeObjectRetain();
      v59(v22, v58);
      uint64_t v61 = v111;
      sub_1B5201994(v57, v111, &qword_1E9D47AB0);
      uint64_t v62 = v112;
      sub_1B5201384(v61, v112, &qword_1E9D48E88);
      v63 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v62 + *(int *)(v110 + 44));
      *v63 = sub_1B529C2D0;
      v63[1] = 0;
      sub_1B51E0064(v61, &qword_1E9D48E88);
      uint64_t v64 = v104;
      sub_1B5201384(v62, v104, &qword_1E9D47AB8);
      v65 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v64 + *(int *)(v102 + 44));
      *v65 = sub_1B529C258;
      v65[1] = 0;
      sub_1B51E0064(v62, &qword_1E9D47AB8);
      v66 = v94;
      sub_1B5201384(v64, (uint64_t)&v94[*(int *)(v88 + 52)], &qword_1E9D47AA8);
      uint64_t v67 = v100;
      void *v66 = v99;
      v66[1] = v67;
      v66[2] = v60;
      sub_1B51E0064(v64, &qword_1E9D47AA8);
      uint64_t v68 = v93;
      sub_1B5201384((uint64_t)v66, v93, &qword_1E9D47AD0);
      v69 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v68 + *(int *)(v91 + 44));
      *v69 = sub_1B529C270;
      v69[1] = 0;
      sub_1B51E0064((uint64_t)v66, &qword_1E9D47AD0);
      uint64_t v70 = v92;
      sub_1B5201384(v68, v92, &qword_1E9D47AD8);
      v71 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v70 + *(int *)(v89 + 44));
      *v71 = sub_1B529C118;
      v71[1] = 0;
      sub_1B51E0064(v68, &qword_1E9D47AD8);
      v72 = &qword_1E9D47AC8;
      uint64_t v56 = v107;
      sub_1B5201384(v70, v107, &qword_1E9D47AC8);
      swift_storeEnumTagMultiPayload();
      uint64_t v73 = v70;
      goto LABEL_7;
    case 6:
      sub_1B53724E8();
      uint64_t v74 = (uint64_t)v109;
      uint64_t v75 = v113;
      (*(void (**)(char *, char *, uint64_t))(v20 + 16))(&v109[*(int *)(v108 + 52)], v22, v113);
      *(unsigned char *)uint64_t v74 = 1;
      *(void *)(v74 + 8) = sub_1B529C414;
      *(void *)(v74 + 16) = 0;
      *(_DWORD *)(v74 + 24) = 16843009;
      (*(void (**)(char *, uint64_t))(v20 + 8))(v22, v75);
      uint64_t v76 = v111;
      sub_1B5201994(v74, v111, &qword_1E9D47AB0);
      uint64_t v77 = v112;
      sub_1B5201384(v76, v112, &qword_1E9D48E88);
      v78 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v77 + *(int *)(v110 + 44));
      *v78 = sub_1B529C2D0;
      v78[1] = 0;
      sub_1B51E0064(v76, &qword_1E9D48E88);
      uint64_t v79 = v98;
      sub_1B5201384(v77, v98, &qword_1E9D47AB8);
      v80 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v79 + *(int *)(v96 + 44));
      *v80 = sub_1B529C258;
      v80[1] = 0;
      sub_1B51E0064(v77, &qword_1E9D47AB8);
      uint64_t v81 = v97;
      sub_1B5201384(v79, v97, &qword_1E9D47AE0);
      v82 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(v81 + *(int *)(v95 + 44));
      *v82 = sub_1B529C174;
      v82[1] = 0;
      sub_1B51E0064(v79, &qword_1E9D47AE0);
      v72 = &qword_1E9D47AC0;
      uint64_t v56 = v107;
      sub_1B5201384(v81, v107, &qword_1E9D47AC0);
      swift_storeEnumTagMultiPayload();
      uint64_t v73 = v81;
LABEL_7:
      sub_1B51E0064(v73, v72);
      __int16 v40 = &qword_1E9D47A68;
      uint64_t v41 = v115;
      sub_1B5201384(v56, v115, &qword_1E9D47A68);
LABEL_8:
      swift_storeEnumTagMultiPayload();
      uint64_t v42 = v56;
LABEL_9:
      sub_1B51E0064(v42, v40);
      sub_1B5201384(v41, (uint64_t)v117, &qword_1E9D47A78);
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A80);
      swift_storeEnumTagMultiPayload();
      return (id)sub_1B51E0064(v41, &qword_1E9D47A78);
    case 8:
      v83 = v117;
      void *v117 = 257;
      v83[1] = sub_1B5299884;
      v83[2] = 0;
      v83[3] = sub_1B529C2FC;
      v83[4] = 0;
      v83[5] = sub_1B529C2D0;
      v83[8] = 0;
      v83[9] = 0;
      v83[6] = 0;
      v83[7] = sub_1B529C190;
      *((_WORD *)v83 + 40) = 0;
      goto LABEL_12;
    case 0xA:
      v84 = v117;
      *(_OWORD *)v117 = xmmword_1B5390840;
      v84[2] = sub_1B5299884;
      v84[3] = 0;
      v84[4] = sub_1B529C374;
      v84[5] = 0;
      v84[6] = sub_1B529C3E8;
      v84[7] = 0;
      v84[8] = sub_1B529C1E0;
      v84[9] = 0;
      *((_WORD *)v84 + 40) = 1;
LABEL_12:
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A80);
      id result = (id)swift_storeEnumTagMultiPayload();
      break;
    default:
      sub_1B51DD5FC();
      uint64_t v43 = (void *)swift_allocError();
      *uint64_t v44 = 12;
      uint64_t v45 = v117;
      void *v117 = v43;
      v45[1] = 0;
      v45[2] = 0;
      v45[3] = 0xE000000000000000;
      v45[4] = v43;
      *(_OWORD *)(v45 + 5) = 0u;
      *(_OWORD *)(v45 + 7) = 0u;
      *(_OWORD *)((char *)v45 + 65) = 0u;
      *((unsigned char *)v45 + 81) = 1;
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A80);
      swift_storeEnumTagMultiPayload();
      id result = v43;
      break;
  }
  return result;
}

uint64_t sub_1B529C0FC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B529C1AC(a1, 1, a2);
}

uint64_t sub_1B529C118@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 56);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(void *)(a2 + 16) = v2;
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = v3;
  *(unsigned char *)(a2 + 64) = 2;
  swift_bridgeObjectRetain();
  return swift_bridgeObjectRetain();
}

uint64_t sub_1B529C174@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B529C1AC(a1, 3, a2);
}

uint64_t sub_1B529C190@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B529C1AC(a1, 4, a2);
}

uint64_t sub_1B529C1AC@<X0>(uint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(_OWORD *)(a3 + 16) = v4;
  *(void *)(a3 + 32) = v3;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  *(unsigned char *)(a3 + 64) = a2;
  return swift_bridgeObjectRetain();
}

uint64_t sub_1B529C1E0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v4;
  *(void *)(a2 + 32) = v3;
  *(void *)(a2 + 40) = v2;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(unsigned char *)(a2 + 64) = 5;
  return swift_bridgeObjectRetain();
}

uint64_t sub_1B529C218@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 24);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(void *)(a2 + 16) = v3;
  *(void *)(a2 + 24) = v2;
  return swift_bridgeObjectRetain();
}

__n128 sub_1B529C244@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  unint64_t v2 = a1[1].n128_u64[0];
  __n128 result = *a1;
  *a2 = *a1;
  a2[1].n128_u64[0] = v2;
  return result;
}

uint64_t sub_1B529C258@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B529C2D0(a1, a2);
}

uint64_t sub_1B529C270@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 56);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(void *)(a2 + 16) = v2;
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = v3;
  swift_bridgeObjectRetain();
  return swift_bridgeObjectRetain();
}

__n128 sub_1B529C2C4@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1B529C2D0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v3;
  *(void *)(a2 + 32) = v2;
  return swift_bridgeObjectRetain();
}

void *sub_1B529C2FC@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[1];
  uint64_t v3 = v2 - *result;
  if (__OFSUB__(v2, *result))
  {
    __break(1u);
  }
  else if (v3 + 0x4000000000000000 < 0)
  {
    sub_1B51D4F28();
    swift_allocError();
    return (void *)swift_willThrow();
  }
  else
  {
    *a2 = *result;
    a2[1] = v2;
    a2[2] = 2 * v3;
  }
  return result;
}

uint64_t sub_1B529C374@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)result;
  if (*(void *)result + 0x4000000000000000 < 0)
  {
    sub_1B51D4F28();
    swift_allocError();
    return swift_willThrow();
  }
  else
  {
    *(void *)a2 = v2;
    *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
    *(void *)(a2 + 24) = 2 * v2;
  }
  return result;
}

uint64_t sub_1B529C3E8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v4;
  *(void *)(a2 + 32) = v3;
  *(void *)(a2 + 40) = v2;
  return swift_bridgeObjectRetain();
}

BOOL sub_1B529C414(void *a1)
{
  return *a1 > 5;
}

uint64_t sub_1B529C428(uint64_t a1)
{
  long long v2 = *(_OWORD *)(v1 + 16);
  v14[0] = *(_OWORD *)v1;
  v14[1] = v2;
  uint64_t v15 = *(void *)(v1 + 32);
  if ((unsigned __int128)(a1 * (__int128)*(uint64_t *)&v14[0]) >> 64 == (a1 * *(void *)&v14[0]) >> 63)
  {
    long long v3 = *(_OWORD *)(v1 + 56);
    v10[0] = *(_OWORD *)(v1 + 40);
    v10[1] = v3;
    v10[2] = *(_OWORD *)(v1 + 72);
    uint64_t v11 = *(void *)(v1 + 88);
    v12[0] = v10[0];
    v12[1] = v3;
    char v13 = *(unsigned char *)(v1 + 72);
    sub_1B52685FC((uint64_t)v12);
    swift_retain();
    sub_1B5268628((uint64_t)v14);
    v9[0] = sub_1B53724C8();
    v9[1] = v4;
    v9[2] = v5;
    swift_bridgeObjectRetain();
    uint64_t v7 = sub_1B51F1A3C((uint64_t)v9, (char *)v10, v6);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    sub_1B51E00CC((uint64_t)v14);
    sub_1B5268654((uint64_t)v12);
    swift_release();
    return v7;
  }
  else
  {
    sub_1B51D4F28();
    swift_allocError();
    swift_willThrow();
    uint64_t result = swift_unexpectedError();
    __break(1u);
  }
  return result;
}

uint64_t sub_1B529C5D8(uint64_t a1)
{
  long long v2 = *(_OWORD *)(v1 + 16);
  v13[0] = *(_OWORD *)v1;
  v13[1] = v2;
  uint64_t v14 = *(void *)(v1 + 32);
  if ((unsigned __int128)(a1 * (__int128)*(uint64_t *)&v13[0]) >> 64 == (a1 * *(void *)&v13[0]) >> 63)
  {
    long long v3 = *(_OWORD *)(v1 + 56);
    v11[0] = *(_OWORD *)(v1 + 40);
    v11[1] = v3;
    uint64_t v12 = *(void *)(v1 + 72);
    sub_1B5268680((uint64_t)v11);
    sub_1B5268628((uint64_t)v13);
    *(void *)&long long v9 = sub_1B53724C8();
    *((void *)&v9 + 1) = v4;
    uint64_t v10 = v5;
    swift_bridgeObjectRetain();
    uint64_t v7 = sub_1B51F1BE4(&v9, (uint64_t)v11, v6);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    sub_1B51E00CC((uint64_t)v13);
    sub_1B52686AC((uint64_t)v11);
    return v7;
  }
  else
  {
    sub_1B51D4F28();
    swift_allocError();
    swift_willThrow();
    uint64_t result = swift_unexpectedError();
    __break(1u);
  }
  return result;
}

uint64_t sub_1B529C748@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v22 = a3;
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = *(void *)(v6 + 64);
  MEMORY[0x1F4188790](a1);
  uint64_t v9 = *(void *)(v8 + 32);
  uint64_t v19 = *(void *)(v8 + 24);
  uint64_t v10 = sub_1B5372548();
  uint64_t v20 = *(void *)(v10 - 8);
  uint64_t v21 = v10;
  double v11 = MEMORY[0x1F4188790](v10);
  char v13 = (char *)&v18 - v12;
  if ((unsigned __int128)(a1 * (__int128)*v3) >> 64 == (a1 * *v3) >> 63)
  {
    (*(void (**)(char *, uint64_t *, uint64_t, double))(v6 + 16))((char *)&v18 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v3, a2, v11);
    unint64_t v14 = (*(unsigned __int8 *)(v6 + 80) + 40) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80);
    uint64_t v15 = (char *)swift_allocObject();
    *((void *)v15 + 2) = v19;
    *((void *)v15 + 3) = v9;
    *((void *)v15 + 4) = *(void *)(a2 + 32);
    (*(void (**)(char *, char *, uint64_t))(v6 + 32))(&v15[v14], (char *)&v18 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), a2);
    sub_1B5372558();
    swift_release();
    uint64_t v16 = v21;
    swift_getWitnessTable();
    sub_1B5372528();
    return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v13, v16);
  }
  else
  {
    sub_1B51D4F28();
    swift_allocError();
    swift_willThrow();
    uint64_t result = swift_unexpectedError();
    __break(1u);
  }
  return result;
}

uint64_t sub_1B529CA18(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  double v11 = (char *)&v17 - v10;
  uint64_t v12 = type metadata accessor for BinarySearchLookup();
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v11, a1 + *(int *)(v12 + 44), a2);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v14 = MEMORY[0x1E4FBC848] + 8;
  MEMORY[0x1BA997DC0](v11, AssociatedTypeWitness, MEMORY[0x1E4FBC848] + 8, a2, a3);
  uint64_t v15 = *(void (**)(char *, uint64_t))(v6 + 8);
  v15(v11, a2);
  MEMORY[0x1BA997DB0](v8, AssociatedTypeWitness, v14, a2, a3);
  return ((uint64_t (*)(char *, uint64_t))v15)(v8, a2);
}

void sub_1B529CBBC(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1B529CBC4@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = sub_1B5243604();
  *a1 = result;
  return result;
}

void (*sub_1B529CBEC(uint64_t **a1, uint64_t *a2, uint64_t a3))(void *a1)
{
  uint64_t v6 = (uint64_t *)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (uint64_t)sub_1B529CC5C(v6, *a2, a3);
  return sub_1B52153C4;
}

void (*sub_1B529CC5C(uint64_t *a1, uint64_t a2, uint64_t a3))(void *a1)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  *a1 = AssociatedTypeWitness;
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  a1[1] = v7;
  uint64_t v8 = malloc(*(void *)(v7 + 64));
  a1[2] = (uint64_t)v8;
  sub_1B529C748(a2, a3, (uint64_t)v8);
  return sub_1B52154C4;
}

uint64_t sub_1B529CD2C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 32))(a2, v3, a1);
  swift_getWitnessTable();
  uint64_t result = sub_1B5373028();
  *(void *)(a2 + *(int *)(result + 36)) = 0;
  return result;
}

uint64_t sub_1B529CDB8(uint64_t a1)
{
  uint64_t WitnessTable = swift_getWitnessTable();
  return MEMORY[0x1F4184360](a1, WitnessTable);
}

uint64_t sub_1B529CE0C(uint64_t a1)
{
  uint64_t WitnessTable = swift_getWitnessTable();
  return MEMORY[0x1F4184380](a1, WitnessTable);
}

unint64_t sub_1B529CE64()
{
  unint64_t result = qword_1E9D48E40;
  if (!qword_1E9D48E40)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D48E40);
  }
  return result;
}

unint64_t sub_1B529CEBC()
{
  unint64_t result = qword_1E9D48E48;
  if (!qword_1E9D48E48)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D48E48);
  }
  return result;
}

unint64_t sub_1B529CF14()
{
  unint64_t result = qword_1E9D48E50;
  if (!qword_1E9D48E50)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D48E50);
  }
  return result;
}

unint64_t sub_1B529CF6C()
{
  unint64_t result = qword_1E9D48E58;
  if (!qword_1E9D48E58)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D48E58);
  }
  return result;
}

unint64_t sub_1B529CFC4()
{
  unint64_t result = qword_1E9D48E60;
  if (!qword_1E9D48E60)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D48E60);
  }
  return result;
}

unint64_t sub_1B529D01C()
{
  unint64_t result = qword_1E9D48E68;
  if (!qword_1E9D48E68)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D48E68);
  }
  return result;
}

unint64_t sub_1B529D074()
{
  unint64_t result = qword_1E9D48E70;
  if (!qword_1E9D48E70)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D48E70);
  }
  return result;
}

uint64_t destroy for GlyphMetadataTable(uint64_t a1)
{
  return sub_1B5200BC8(*(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88), *(void *)(a1 + 96), *(void *)(a1 + 104), *(void *)(a1 + 112), *(unsigned char *)(a1 + 120));
}

uint64_t initializeWithCopy for GlyphMetadataTable(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v3;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  uint64_t v13 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  uint64_t v4 = *(void *)(a2 + 64);
  uint64_t v5 = *(void *)(a2 + 72);
  uint64_t v6 = *(void *)(a2 + 80);
  uint64_t v7 = *(void *)(a2 + 88);
  uint64_t v8 = *(void *)(a2 + 96);
  uint64_t v9 = *(void *)(a2 + 104);
  uint64_t v10 = *(void *)(a2 + 112);
  char v11 = *(unsigned char *)(a2 + 120);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  sub_1B52148E8(v13, v4, v5, v6, v7, v8, v9, v10, v11);
  *(void *)(a1 + 56) = v13;
  *(void *)(a1 + 64) = v4;
  *(void *)(a1 + 72) = v5;
  *(void *)(a1 + 80) = v6;
  *(void *)(a1 + 88) = v7;
  *(void *)(a1 + 96) = v8;
  *(void *)(a1 + 104) = v9;
  *(void *)(a1 + 112) = v10;
  *(unsigned char *)(a1 + 120) = v11;
  return a1;
}

uint64_t assignWithCopy for GlyphMetadataTable(uint64_t a1, void *a2)
{
  uint64_t v2 = a2;
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = a2[1];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = a2[3];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 32) = v2[4];
  *(void *)(a1 + 40) = v2[5];
  *(void *)(a1 + 48) = v2[6];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v4 = v2[7];
  uint64_t v5 = v2[8];
  uint64_t v6 = v2[9];
  uint64_t v7 = v2[10];
  uint64_t v8 = v2[11];
  uint64_t v9 = v2[12];
  uint64_t v10 = v2[13];
  uint64_t v11 = v2[14];
  LOBYTE(v2) = *((unsigned char *)v2 + 120);
  sub_1B52148E8(v4, v5, v6, v7, v8, v9, v10, v11, (char)v2);
  uint64_t v12 = *(void *)(a1 + 56);
  uint64_t v13 = *(void *)(a1 + 64);
  uint64_t v14 = *(void *)(a1 + 72);
  uint64_t v15 = *(void *)(a1 + 80);
  uint64_t v16 = *(void *)(a1 + 88);
  uint64_t v17 = *(void *)(a1 + 96);
  uint64_t v18 = *(void *)(a1 + 104);
  uint64_t v19 = *(void *)(a1 + 112);
  char v20 = *(unsigned char *)(a1 + 120);
  *(void *)(a1 + 56) = v4;
  *(void *)(a1 + 64) = v5;
  *(void *)(a1 + 72) = v6;
  *(void *)(a1 + 80) = v7;
  *(void *)(a1 + 88) = v8;
  *(void *)(a1 + 96) = v9;
  *(void *)(a1 + 104) = v10;
  *(void *)(a1 + 112) = v11;
  *(unsigned char *)(a1 + 120) = (_BYTE)v2;
  sub_1B5200BC8(v12, v13, v14, v15, v16, v17, v18, v19, v20);
  return a1;
}

uint64_t assignWithTake for GlyphMetadataTable(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v4;
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRelease();
  char v5 = *(unsigned char *)(a2 + 120);
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = *(void *)(a1 + 72);
  uint64_t v9 = *(void *)(a1 + 80);
  uint64_t v10 = *(void *)(a1 + 88);
  uint64_t v11 = *(void *)(a1 + 96);
  uint64_t v12 = *(void *)(a1 + 104);
  uint64_t v13 = *(void *)(a1 + 112);
  char v14 = *(unsigned char *)(a1 + 120);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  *(unsigned char *)(a1 + 120) = v5;
  sub_1B5200BC8(v6, v7, v8, v9, v10, v11, v12, v13, v14);
  return a1;
}

uint64_t getEnumTagSinglePayload for GlyphMetadataTable(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 121)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for GlyphMetadataTable(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(unsigned char *)(result + 120) = 0;
    *(void *)unint64_t result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 121) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 121) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for GlyphMetadataTable()
{
  return &type metadata for GlyphMetadataTable;
}

uint64_t destroy for GlyphInfo()
{
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for GlyphInfo(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_WORD *)(a1 + 24) = *(_WORD *)(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v3;
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for GlyphInfo(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  *(void *)a1 = v4;
  uint64_t v5 = a2[2];
  *(unsigned char *)(a1 + 24) = *((unsigned char *)a2 + 24);
  *(void *)(a1 + 16) = v5;
  *(unsigned char *)(a1 + 25) = *((unsigned char *)a2 + 25);
  *(void *)(a1 + 32) = a2[4];
  *(void *)(a1 + 40) = a2[5];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 48) = a2[6];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy56_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for GlyphInfo(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_WORD *)(a1 + 24) = *(_WORD *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for GlyphInfo(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 56)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for GlyphInfo(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 56) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 40) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 56) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for GlyphInfo()
{
  return &type metadata for GlyphInfo;
}

unint64_t sub_1B529D6B4(unint64_t result)
{
  if (!(result >> 61)) {
    return swift_bridgeObjectRetain();
  }
  return result;
}

unint64_t destroy for GlyphIdentifier(unint64_t *a1)
{
  return sub_1B5200B60(*a1);
}

unint64_t *_s10FontParser15GlyphIdentifierOwCP_0(unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  unint64_t v5 = a2[2];
  sub_1B529D6B4(*a2);
  *a1 = v3;
  a1[1] = v4;
  a1[2] = v5;
  return a1;
}

unint64_t *assignWithCopy for GlyphIdentifier(unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  unint64_t v5 = a2[2];
  sub_1B529D6B4(*a2);
  unint64_t v6 = *a1;
  *a1 = v3;
  a1[1] = v4;
  a1[2] = v5;
  sub_1B5200B60(v6);
  return a1;
}

unint64_t *assignWithTake for GlyphIdentifier(unint64_t *a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 16);
  unint64_t v4 = *a1;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = v3;
  sub_1B5200B60(v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for GlyphIdentifier(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 24)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unsigned int v2 = *(_DWORD *)(a1 + 1);
  if (v2 > 0x80000000) {
    int v3 = ~v2;
  }
  else {
    int v3 = -1;
  }
  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for GlyphIdentifier(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 24) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      *(void *)__n128 result = (unint64_t)-a2 << 8;
      return result;
    }
    *(unsigned char *)(result + 24) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t sub_1B529D854(void *a1)
{
  return *a1 >> 61;
}

void *sub_1B529D860(void *result)
{
  *result &= 0x1FFFFFFFFFFFFFFFuLL;
  return result;
}

unint64_t *sub_1B529D870(unint64_t *result, uint64_t a2)
{
  *__n128 result = *(unsigned __int8 *)result | (unint64_t)(a2 << 61);
  return result;
}

ValueMetadata *type metadata accessor for GlyphIdentifier()
{
  return &type metadata for GlyphIdentifier;
}

ValueMetadata *type metadata accessor for GlyphIdentifier.NameKind()
{
  return &type metadata for GlyphIdentifier.NameKind;
}

ValueMetadata *type metadata accessor for GlyphIdentifier.CIDKind()
{
  return &type metadata for GlyphIdentifier.CIDKind;
}

ValueMetadata *type metadata accessor for GlyphIdentifier.NameEntryKind()
{
  return &type metadata for GlyphIdentifier.NameEntryKind;
}

ValueMetadata *type metadata accessor for GlyphInfoFlags()
{
  return &type metadata for GlyphInfoFlags;
}

uint64_t destroy for Format10()
{
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for Format10(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  swift_bridgeObjectRetain();
  return a1;
}

void *assignWithCopy for Format10(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  a1[5] = a2[5];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy48_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v3;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for Format10(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v3;
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v4;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for Format10(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 48)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Format10(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 40) = 0;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 48) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 40) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 48) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Format10()
{
  return &type metadata for Format10;
}

uint64_t initializeWithCopy for Format8(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v3;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  swift_bridgeObjectRetain();
  return a1;
}

ValueMetadata *type metadata accessor for Format8()
{
  return &type metadata for Format8;
}

ValueMetadata *type metadata accessor for Format6()
{
  return &type metadata for Format6;
}

uint64_t destroy for Format4()
{
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for Format4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

void *assignWithCopy for Format4(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[3] = a2[3];
  a1[4] = a2[4];
  a1[5] = a2[5];
  a1[6] = a2[6];
  a1[7] = a2[7];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy64_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for Format4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for Format4(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 64)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Format4(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 64) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 16) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 64) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Format4()
{
  return &type metadata for Format4;
}

ValueMetadata *type metadata accessor for Format2()
{
  return &type metadata for Format2;
}

uint64_t destroy for LookupTableBody()
{
  return swift_bridgeObjectRelease();
}

void *_s10FontParser15LookupTableBodyVwca_0(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t _s10FontParser15LookupTableBodyVwta_0(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v3;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t _s10FontParser15LookupTableBodyVwet_0(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 40)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t sub_1B529DE1C(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 40) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 32) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 40) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for LookupTableBody()
{
  return &type metadata for LookupTableBody;
}

__n128 __swift_memcpy65_8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v3 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t sub_1B529DEB0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t sub_1B529DEB8(uint64_t result, char a2)
{
  *(unsigned char *)(result + 64) = a2;
  return result;
}

ValueMetadata *type metadata accessor for LookupTableImpl()
{
  return &type metadata for LookupTableImpl;
}

uint64_t initializeWithCopy for Format0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v3;
  swift_bridgeObjectRetain();
  return a1;
}

void *assignWithCopy for Format0(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for Format0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v3;
  swift_bridgeObjectRelease();
  return a1;
}

ValueMetadata *type metadata accessor for Format0()
{
  return &type metadata for Format0;
}

uint64_t _s10FontParser15LookupTableImplOwxx_0(uint64_t a1)
{
  return sub_1B5200BC8(*(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(unsigned char *)(a1 + 64));
}

uint64_t _s10FontParser15LookupTableImplOwcp_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 32);
  uint64_t v8 = *(void *)(a2 + 40);
  uint64_t v9 = *(void *)(a2 + 48);
  uint64_t v10 = *(void *)(a2 + 56);
  char v11 = *(unsigned char *)(a2 + 64);
  sub_1B52148E8(*(void *)a2, v4, v5, v6, v7, v8, v9, v10, v11);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(void *)(a1 + 24) = v6;
  *(void *)(a1 + 32) = v7;
  *(void *)(a1 + 40) = v8;
  *(void *)(a1 + 48) = v9;
  *(void *)(a1 + 56) = v10;
  *(unsigned char *)(a1 + 64) = v11;
  return a1;
}

uint64_t _s10FontParser15LookupTableImplOwca_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 32);
  uint64_t v8 = *(void *)(a2 + 40);
  uint64_t v9 = *(void *)(a2 + 48);
  uint64_t v10 = *(void *)(a2 + 56);
  char v11 = *(unsigned char *)(a2 + 64);
  sub_1B52148E8(*(void *)a2, v4, v5, v6, v7, v8, v9, v10, v11);
  uint64_t v12 = *(void *)a1;
  uint64_t v13 = *(void *)(a1 + 8);
  uint64_t v14 = *(void *)(a1 + 16);
  uint64_t v15 = *(void *)(a1 + 24);
  uint64_t v16 = *(void *)(a1 + 32);
  uint64_t v17 = *(void *)(a1 + 40);
  uint64_t v18 = *(void *)(a1 + 48);
  uint64_t v19 = *(void *)(a1 + 56);
  char v20 = *(unsigned char *)(a1 + 64);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(void *)(a1 + 24) = v6;
  *(void *)(a1 + 32) = v7;
  *(void *)(a1 + 40) = v8;
  *(void *)(a1 + 48) = v9;
  *(void *)(a1 + 56) = v10;
  *(unsigned char *)(a1 + 64) = v11;
  sub_1B5200BC8(v12, v13, v14, v15, v16, v17, v18, v19, v20);
  return a1;
}

uint64_t _s10FontParser15LookupTableImplOwta_0(uint64_t a1, uint64_t a2)
{
  char v3 = *(unsigned char *)(a2 + 64);
  uint64_t v4 = *(void *)a1;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v11 = *(void *)(a1 + 56);
  char v12 = *(unsigned char *)(a1 + 64);
  long long v13 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v13;
  long long v14 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v14;
  *(unsigned char *)(a1 + 64) = v3;
  sub_1B5200BC8(v4, v6, v5, v7, v8, v9, v10, v11, v12);
  return a1;
}

uint64_t _s10FontParser15LookupTableImplOwet_0(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFB && *(unsigned char *)(a1 + 65)) {
    return (*(_DWORD *)a1 + 251);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 64);
  if (v3 <= 5) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t _s10FontParser15LookupTableImplOwst_0(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFA)
  {
    *(void *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(unsigned char *)(result + 64) = 0;
    *(void *)__n128 result = a2 - 251;
    if (a3 >= 0xFB) {
      *(unsigned char *)(result + 65) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFB) {
      *(unsigned char *)(result + 65) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 64) = -(char)a2;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for LookupTable()
{
  return &type metadata for LookupTable;
}

uint64_t sub_1B529E250()
{
  return swift_getOpaqueTypeConformance2();
}

_UNKNOWN **sub_1B529E26C()
{
  return &off_1F0DF9BC8;
}

uint64_t sub_1B529E278()
{
  return swift_getOpaqueTypeConformance2();
}

_UNKNOWN **sub_1B529E294()
{
  return &off_1F0DF9C08;
}

uint64_t sub_1B529E2A0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a2 = *(_OWORD *)a1;
  long long v2 = *(_OWORD *)(a1 + 16);
  long long v3 = *(_OWORD *)(a1 + 32);
  long long v4 = *(_OWORD *)(a1 + 48);
  *(unsigned char *)(a2 + 64) = *(unsigned char *)(a1 + 64);
  *(_OWORD *)(a2 + 32) = v3;
  *(_OWORD *)(a2 + 48) = v4;
  *(_OWORD *)(a2 + 16) = v2;
  return a2;
}

uint64_t sub_1B529E2C8(uint64_t a1, void (*a2)(void, void, void, void, void, void, void, void, char))
{
  char v4 = *(unsigned char *)(a1 + 64);
  a2(*(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), v4);
  return a1;
}

uint64_t sub_1B529E31C()
{
  uint64_t v1 = *(void *)(v0 + 16);
  long long v2 = (int *)(type metadata accessor for BinarySearchLookup() - 8);
  uint64_t v3 = *(unsigned __int8 *)(*(void *)v2 + 80);
  uint64_t v4 = (v3 + 40) & ~v3;
  uint64_t v5 = v4 + *(void *)(*(void *)v2 + 64);
  uint64_t v6 = v3 | 7;
  uint64_t v7 = v0 + v4;
  swift_bridgeObjectRelease();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v1 - 8) + 8))(v7 + v2[13], v1);
  return MEMORY[0x1F4186498](v0, v5, v6);
}

uint64_t type metadata accessor for BinarySearchLookup()
{
  return __swift_instantiateGenericMetadata();
}

uint64_t sub_1B529E428()
{
  uint64_t v1 = *(void *)(v0 + 16);
  uint64_t v2 = *(void *)(v0 + 24);
  uint64_t v3 = *(void *)(type metadata accessor for BinarySearchLookup() - 8);
  return sub_1B529CA18(v0 + ((*(unsigned __int8 *)(v3 + 80) + 40) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80)), v1, v2);
}

unsigned __int8 *sub_1B529E4C4@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B529AD54(a1, a2);
}

uint64_t sub_1B529E4DC()
{
  swift_bridgeObjectRelease();
  return MEMORY[0x1F4186498](v0, 48, 7);
}

id sub_1B529E514@<X0>(_WORD *a1@<X0>, void *a2@<X8>)
{
  return sub_1B529B160(a1, v2[2], v2[3], v2[4], v2[5], a2);
}

uint64_t sub_1B529E534@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = *(void *)(v1 + 16);
  sub_1B53724E8();
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D48E98);
  uint64_t v5 = a1 + *(int *)(result + 40);
  uint64_t v6 = a1 + *(int *)(result + 36);
  *(void *)(v6 + 8) = 0;
  *(void *)(v6 + 16) = 0;
  *(void *)uint64_t v6 = v3;
  *(unsigned char *)(v6 + 24) = 1;
  *(void *)uint64_t v5 = 0;
  *(unsigned char *)(v5 + 8) = 1;
  return result;
}

uint64_t sub_1B529E5A0()
{
  uint64_t result = swift_checkMetadataState();
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

void *sub_1B529E63C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = (void *)a1;
  uint64_t v4 = *(void *)(a3 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = *(_DWORD *)(v5 + 80);
  if (v6 > 7
    || (*(_DWORD *)(v5 + 80) & 0x100000) != 0
    || ((v6 + 40) & (unint64_t)~v6) + *(void *)(v5 + 64) > 0x18)
  {
    uint64_t v9 = *a2;
    *uint64_t v3 = *a2;
    uint64_t v3 = (void *)(v9 + ((v6 & 0xF8 ^ 0x1F8) & (v6 + 16)));
    swift_retain();
  }
  else
  {
    long long v10 = *((_OWORD *)a2 + 1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v10;
    *(void *)(a1 + 32) = a2[4];
    uint64_t v11 = (a1 + v6 + 40) & ~v6;
    uint64_t v12 = ((unint64_t)a2 + v6 + 40) & ~v6;
    long long v13 = *(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 16);
    swift_bridgeObjectRetain();
    v13(v11, v12, v4);
  }
  return v3;
}

uint64_t sub_1B529E750(uint64_t a1, uint64_t a2)
{
  swift_bridgeObjectRelease();
  uint64_t v4 = *(void *)(*(void *)(a2 + 16) - 8);
  uint64_t v5 = *(uint64_t (**)(unint64_t))(v4 + 8);
  unint64_t v6 = (a1 + *(unsigned __int8 *)(v4 + 80) + 40) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80);
  return v5(v6);
}

uint64_t sub_1B529E7C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  uint64_t v5 = *(void *)(a3 + 16);
  unint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16);
  uint64_t v7 = *(unsigned __int8 *)(*(void *)(v5 - 8) + 80);
  uint64_t v8 = (v7 + 40 + a1) & ~v7;
  uint64_t v9 = (v7 + 40 + a2) & ~v7;
  swift_bridgeObjectRetain();
  v6(v8, v9, v5);
  return a1;
}

void *sub_1B529E85C(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8);
  (*(void (**)(unint64_t, unint64_t))(v6 + 24))(((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 40) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 40) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80));
  return a1;
}

uint64_t sub_1B529E90C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8);
  (*(void (**)(unint64_t, unint64_t))(v5 + 32))((*(unsigned __int8 *)(v5 + 80) + 40 + a1) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80), (*(unsigned __int8 *)(v5 + 80) + 40 + a2) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80));
  return a1;
}

uint64_t sub_1B529E984(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v6 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v6;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  swift_bridgeObjectRelease();
  uint64_t v7 = *(void *)(*(void *)(a3 + 16) - 8);
  (*(void (**)(unint64_t, unint64_t))(v7 + 40))((*(unsigned __int8 *)(v7 + 80) + 40 + a1) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80), (*(unsigned __int8 *)(v7 + 80) + 40 + a2) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
  return a1;
}

uint64_t sub_1B529EA14(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  uint64_t v6 = *(unsigned __int8 *)(v4 + 80);
  if (v5 <= 0x7FFFFFFF) {
    unsigned int v7 = 0x7FFFFFFF;
  }
  else {
    unsigned int v7 = *(_DWORD *)(v4 + 84);
  }
  if (!a2) {
    return 0;
  }
  int v8 = a2 - v7;
  if (a2 <= v7) {
    goto LABEL_23;
  }
  uint64_t v9 = ((v6 + 40) & ~v6) + *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  char v10 = 8 * v9;
  if (v9 <= 3)
  {
    unsigned int v13 = ((v8 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v13))
    {
      int v11 = *(_DWORD *)((char *)a1 + v9);
      if (!v11) {
        goto LABEL_23;
      }
      goto LABEL_15;
    }
    if (v13 > 0xFF)
    {
      int v11 = *(unsigned __int16 *)((char *)a1 + v9);
      if (!*(unsigned __int16 *)((char *)a1 + v9)) {
        goto LABEL_23;
      }
      goto LABEL_15;
    }
    if (v13 < 2)
    {
LABEL_23:
      if ((v5 & 0x80000000) != 0) {
        return (*(uint64_t (**)(unint64_t))(v4 + 48))(((unint64_t)a1 + v6 + 40) & ~v6);
      }
      unint64_t v15 = *((void *)a1 + 4);
      if (v15 >= 0xFFFFFFFF) {
        LODWORD(v15) = -1;
      }
      return (v15 + 1);
    }
  }
  int v11 = *((unsigned __int8 *)a1 + v9);
  if (!*((unsigned char *)a1 + v9)) {
    goto LABEL_23;
  }
LABEL_15:
  int v14 = (v11 - 1) << v10;
  if (v9 > 3) {
    int v14 = 0;
  }
  if (v9)
  {
    if (v9 > 3) {
      LODWORD(v9) = 4;
    }
    switch((int)v9)
    {
      case 2:
        LODWORD(v9) = *a1;
        break;
      case 3:
        LODWORD(v9) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v9) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v9) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return v7 + (v9 | v14) + 1;
}

void sub_1B529EBB4(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  if (v7 <= 0x7FFFFFFF) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v6 + 84);
  }
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  size_t v10 = ((v9 + 40) & ~v9) + *(void *)(*(void *)(*(void *)(a4 + 16) - 8) + 64);
  BOOL v11 = a3 >= v8;
  unsigned int v12 = a3 - v8;
  if (v12 != 0 && v11)
  {
    if (v10 <= 3)
    {
      unsigned int v16 = ((v12 + ~(-1 << (8 * v10))) >> (8 * v10)) + 1;
      if (HIWORD(v16))
      {
        int v13 = 4;
      }
      else if (v16 >= 0x100)
      {
        int v13 = 2;
      }
      else
      {
        int v13 = v16 > 1;
      }
    }
    else
    {
      int v13 = 1;
    }
  }
  else
  {
    int v13 = 0;
  }
  if (v8 < a2)
  {
    unsigned int v14 = ~v8 + a2;
    if (v10 < 4)
    {
      int v15 = (v14 >> (8 * v10)) + 1;
      if (v10)
      {
        int v17 = v14 & ~(-1 << (8 * v10));
        bzero(a1, v10);
        if (v10 == 3)
        {
          *(_WORD *)a1 = v17;
          a1[2] = BYTE2(v17);
        }
        else if (v10 == 2)
        {
          *(_WORD *)a1 = v17;
        }
        else
        {
          *a1 = v17;
        }
      }
    }
    else
    {
      bzero(a1, v10);
      *(_DWORD *)a1 = v14;
      int v15 = 1;
    }
    switch(v13)
    {
      case 1:
        a1[v10] = v15;
        return;
      case 2:
        *(_WORD *)&a1[v10] = v15;
        return;
      case 3:
        goto LABEL_41;
      case 4:
        *(_DWORD *)&a1[v10] = v15;
        return;
      default:
        return;
    }
  }
  switch(v13)
  {
    case 1:
      a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 2:
      *(_WORD *)&a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 3:
LABEL_41:
      __break(1u);
      JUMPOUT(0x1B529EE20);
    case 4:
      *(_DWORD *)&a1[v10] = 0;
      goto LABEL_23;
    default:
LABEL_23:
      if (a2)
      {
LABEL_24:
        if ((v7 & 0x80000000) != 0)
        {
          unint64_t v18 = (unint64_t)&a1[v9 + 40] & ~v9;
          uint64_t v19 = *(void (**)(unint64_t))(v6 + 56);
          v19(v18);
        }
        else if ((a2 & 0x80000000) != 0)
        {
          *(_OWORD *)(a1 + 8) = 0u;
          *(_OWORD *)(a1 + 24) = 0u;
          *(void *)a1 = a2 ^ 0x80000000;
        }
        else
        {
          *((void *)a1 + 4) = a2 - 1;
        }
      }
      return;
  }
}

ValueMetadata *type metadata accessor for Format6.Entry()
{
  return &type metadata for Format6.Entry;
}

ValueMetadata *type metadata accessor for Format2.Entry()
{
  return &type metadata for Format2.Entry;
}

uint64_t sub_1B529EE68()
{
  return sub_1B52010C8(&qword_1E9D48F30, &qword_1E9D48F38);
}

uint64_t sub_1B529EEA4()
{
  return sub_1B52010C8(&qword_1E9D48F40, &qword_1E9D48F48);
}

uint64_t sub_1B529EEE0()
{
  return swift_getWitnessTable();
}

uint64_t static Platform.macintosh.getter()
{
  return 1;
}

Swift::UInt16_optional __swiftcall Platform.rawValue(encoding:)(FontParser::Encoding encoding)
{
  int v2 = encoding;
  if (v1 != 1)
  {
    if (v1) {
      uint64_t v4 = &unk_1F0DDD028;
    }
    else {
      uint64_t v4 = &unk_1F0DDD000;
    }
    if (v1)
    {
      if (v1 != 2)
      {
        if (v1 != 3)
        {
LABEL_24:
          LOWORD(v6) = 0;
          LODWORD(v9) = 1;
          return (Swift::UInt16_optional)((unsigned __int16)v6 | (v9 << 16));
        }
        uint64_t v4 = &unk_1F0DDD070;
        uint64_t v5 = qword_1F0DDD080;
        if (qword_1F0DDD080) {
          goto LABEL_17;
        }
LABEL_23:
        swift_bridgeObjectRelease();
        goto LABEL_24;
      }
      uint64_t v4 = &unk_1F0DDD0A0;
    }
    uint64_t v5 = v4[2];
    if (v5) {
      goto LABEL_17;
    }
    goto LABEL_23;
  }
  if (encoding - 10 < 4)
  {
    FontParser::Encoding v3 = FontParser_Encoding_roman;
LABEL_28:
    *(Swift::UInt16_optional *)&int v10 = Platform.rawValue(encoding:)(v3);
    LOWORD(v6) = v10;
    LODWORD(v9) = BYTE2(v10) & 1;
    return (Swift::UInt16_optional)((unsigned __int16)v6 | (v9 << 16));
  }
  if (encoding == FontParser_Encoding_farsi)
  {
LABEL_27:
    FontParser::Encoding v3 = FontParser_Encoding_arabic;
    goto LABEL_28;
  }
  if (encoding == FontParser_Encoding_ukrainian)
  {
    FontParser::Encoding v3 = FontParser_Encoding_cyrillic;
    goto LABEL_28;
  }
  uint64_t v4 = &unk_1F0DDD028;
  uint64_t v5 = qword_1F0DDD038;
  if (!qword_1F0DDD038) {
    goto LABEL_23;
  }
LABEL_17:
  unint64_t v6 = 0;
  while (1)
  {
    int v7 = *((unsigned __int8 *)v4 + v6 + 32);
    if (v7 != 56 && v7 == v2) {
      break;
    }
    if (v5 == ++v6) {
      goto LABEL_23;
    }
  }
  swift_bridgeObjectRelease();
  unint64_t v9 = v6 >> 16;
  if (v6 >> 16)
  {
    __break(1u);
    goto LABEL_27;
  }
  return (Swift::UInt16_optional)((unsigned __int16)v6 | (v9 << 16));
}

Swift::UInt16_optional __swiftcall Platform.rawValue(language:)(FontParser::Language language)
{
  int v2 = language;
  if (v1 == 3)
  {
    *(void *)&language = sub_1B523831C((uint64_t)&unk_1F0DDD180);
    int64_t v5 = 0;
    uint64_t v6 = language + 64;
    uint64_t v7 = 1 << *(unsigned char *)(language + 32);
    uint64_t v8 = -1;
    if (v7 < 64) {
      uint64_t v8 = ~(-1 << v7);
    }
    unint64_t v9 = v8 & *(void *)(language + 64);
    int64_t v10 = (unint64_t)(v7 + 63) >> 6;
    while (1)
    {
      if (v9)
      {
        unint64_t v11 = __clz(__rbit64(v9));
        v9 &= v9 - 1;
        unint64_t v12 = v11 | (v5 << 6);
      }
      else
      {
        int64_t v13 = v5 + 1;
        if (__OFADD__(v5, 1))
        {
          __break(1u);
          goto LABEL_44;
        }
        if (v13 >= v10) {
          goto LABEL_39;
        }
        unint64_t v14 = *(void *)(v6 + 8 * v13);
        ++v5;
        if (!v14)
        {
          int64_t v5 = v13 + 1;
          if (v13 + 1 >= v10) {
            goto LABEL_39;
          }
          unint64_t v14 = *(void *)(v6 + 8 * v5);
          if (!v14)
          {
            int64_t v5 = v13 + 2;
            if (v13 + 2 >= v10) {
              goto LABEL_39;
            }
            unint64_t v14 = *(void *)(v6 + 8 * v5);
            if (!v14)
            {
              int64_t v5 = v13 + 3;
              if (v13 + 3 >= v10) {
                goto LABEL_39;
              }
              unint64_t v14 = *(void *)(v6 + 8 * v5);
              if (!v14)
              {
                int64_t v5 = v13 + 4;
                if (v13 + 4 >= v10) {
                  goto LABEL_39;
                }
                unint64_t v14 = *(void *)(v6 + 8 * v5);
                if (!v14)
                {
                  int64_t v15 = v13 + 5;
                  if (v15 >= v10)
                  {
LABEL_39:
                    swift_release();
                    goto LABEL_40;
                  }
                  unint64_t v14 = *(void *)(v6 + 8 * v15);
                  if (!v14)
                  {
                    while (1)
                    {
                      int64_t v5 = v15 + 1;
                      if (__OFADD__(v15, 1)) {
                        break;
                      }
                      if (v5 >= v10) {
                        goto LABEL_39;
                      }
                      unint64_t v14 = *(void *)(v6 + 8 * v5);
                      ++v15;
                      if (v14) {
                        goto LABEL_29;
                      }
                    }
LABEL_45:
                    __break(1u);
                    goto LABEL_46;
                  }
                  int64_t v5 = v15;
                }
              }
            }
          }
        }
LABEL_29:
        unint64_t v9 = (v14 - 1) & v14;
        unint64_t v12 = __clz(__rbit64(v14)) + (v5 << 6);
      }
      if (*(unsigned __int8 *)(*(void *)(language + 56) + v12) == v2)
      {
        uint64_t v18 = *(void *)(*(void *)(language + 48) + 8 * v12);
        swift_release();
        LODWORD(v4) = 0;
        LODWORD(v3) = v18;
        goto LABEL_42;
      }
    }
  }
  if (v1 == 1)
  {
    if (qword_1F0DDD0D8)
    {
      unint64_t v3 = 0;
      while (1)
      {
        int v16 = *((unsigned __int8 *)&unk_1F0DDD0C8 + v3 + 32);
        if (v16 != 175 && v16 == language) {
          break;
        }
        if (qword_1F0DDD0D8 == ++v3) {
          goto LABEL_40;
        }
      }
      unint64_t v4 = v3 >> 16;
      if (v3 >> 16)
      {
LABEL_44:
        __break(1u);
        goto LABEL_45;
      }
    }
    else
    {
LABEL_40:
      LODWORD(v3) = 0;
      LODWORD(v4) = 1;
    }
  }
  else
  {
    LODWORD(v3) = 0;
    if (v1) {
      LODWORD(v4) = 1;
    }
    else {
      LODWORD(v4) = language != FontParser_Language_unicode;
    }
  }
LABEL_42:
  *(_DWORD *)&language = v3 | (v4 << 16);
LABEL_46:
  LOBYTE(result.value) = language;
  return result;
}

uint64_t static Platform.unicode.getter()
{
  return 0;
}

FontParser::Encoding_optional __swiftcall Platform.interpret(encoding:language:)(Swift::UInt16 encoding, Swift::UInt16_optional language)
{
  if (v2 > 3u) {
    goto LABEL_19;
  }
  unsigned __int16 v3 = v2;
  uint64_t v5 = (uint64_t)*(&off_1E60E16B8 + (__int16)v2);
  if (*(void *)(v5 + 16) <= (uint64_t)encoding)
  {
    swift_bridgeObjectRelease();
LABEL_19:
    LOBYTE(v7) = 56;
    return (FontParser::Encoding_optional)v7;
  }
  int v6 = *(_DWORD *)&language.value;
  int v7 = *(unsigned __int8 *)(v5 + encoding + 32);
  swift_bridgeObjectRelease();
  if (v3 == 1 && v7 != 56 && (v6 & 0x10000) == 0 && qword_1F0DDD0D8 > (unsigned __int16)v6)
  {
    int v9 = *((unsigned __int8 *)&unk_1F0DDD0C8 + (unsigned __int16)v6 + 32);
    if (v9 != 175)
    {
      switch(v7)
      {
        case 21:
          if (v9 == 163) {
            LOBYTE(v7) = 22;
          }
          else {
            LOBYTE(v7) = 21;
          }
          break;
        case 17:
          if (v9 == 40) {
            LOBYTE(v7) = 18;
          }
          else {
            LOBYTE(v7) = 17;
          }
          break;
        case 9:
          if (*((unsigned __int8 *)&unk_1F0DDD0C8 + (unsigned __int16)v6 + 32) > 0x74u)
          {
            if (v9 == 117)
            {
              LOBYTE(v7) = 13;
              return (FontParser::Encoding_optional)v7;
            }
            if (v9 == 160)
            {
              LOBYTE(v7) = 10;
              return (FontParser::Encoding_optional)v7;
            }
          }
          else
          {
            if (v9 == 28)
            {
              LOBYTE(v7) = 11;
              return (FontParser::Encoding_optional)v7;
            }
            if (v9 == 59)
            {
              LOBYTE(v7) = 12;
              return (FontParser::Encoding_optional)v7;
            }
          }
          LOBYTE(v7) = 9;
          break;
      }
    }
  }
  return (FontParser::Encoding_optional)v7;
}

unint64_t IntlQuery.init(platform:encoding:language:region:)(int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  return ((unint64_t)a3 << 32) | ((unint64_t)a4 << 40) | ((unint64_t)a2 << 24) | ((unint64_t)(BYTE2(a1) & 1) << 16) | (unsigned __int16)a1;
}

FontParser::Language_optional __swiftcall Platform.interpret(language:)(Swift::UInt16 language)
{
  if (v1 == 3)
  {
    unint64_t v5 = sub_1B523831C((uint64_t)&unk_1F0DDD180);
    if (*(void *)(v5 + 16))
    {
      unint64_t v6 = sub_1B5230620(language);
      if (v7)
      {
        v4.value = *(unsigned char *)(*(void *)(v5 + 56) + v6);
        swift_bridgeObjectRelease();
        return v4;
      }
    }
    swift_bridgeObjectRelease();
    return (FontParser::Language_optional)-81;
  }
  if (v1 == 1)
  {
    if (qword_1F0DDD0D8 > language) {
      return (FontParser::Language_optional)*((unsigned char *)&unk_1F0DDD0C8 + language + 32);
    }
    return (FontParser::Language_optional)-81;
  }
  if (language) {
    v3.value = FontParser_Language_unknownDefault;
  }
  else {
    v3.value = FontParser_Language_unicode;
  }
  if (v1) {
    return (FontParser::Language_optional)-81;
  }
  else {
    return v3;
  }
}

FontParser::Region_optional __swiftcall Platform.interpret(region:)(Swift::UInt16 region)
{
  if (v1 != 3) {
    return (FontParser::Region_optional)0x80;
  }
  unint64_t v3 = sub_1B5238328((uint64_t)&unk_1F0DDDE98);
  if (*(void *)(v3 + 16) && (unint64_t v4 = sub_1B5230620(region), (v5 & 1) != 0)) {
    v6.value = *(unsigned char *)(*(void *)(v3 + 56) + v4);
  }
  else {
    v6.value = FontParser_Region_unknownDefault;
  }
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t static Platform.windows.getter()
{
  return 3;
}

uint64_t IntlQuery.matches(platform:encoding:language:region:)(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, uint64_t a5)
{
  int v5 = HIWORD(a1) & 1;
  if ((unsigned __int16)a5 != (unsigned __int16)a1) {
    LOBYTE(v5) = 1;
  }
  if (a5 & 0x10000) == 0 && (v5) {
    return 0;
  }
  if ((a5 & 0xFF000000) == 0x38000000 || (uint64_t result = 0, a2 != 56) && BYTE3(a5) == a2)
  {
    if ((a5 & 0xFF00000000) == 0xAF00000000 || (uint64_t result = 0, a3 != 175) && BYTE4(a5) == a3)
    {
      BOOL v7 = a4 != 128 && a4 == BYTE5(a5);
      return (a5 & 0xFF0000000000) == 0x800000000000 || v7;
    }
  }
  return result;
}

uint64_t static IntlQuery.any.getter()
{
  return 0x80AF38010000;
}

uint64_t Language.rawValue.getter(uint64_t result)
{
  return result;
}

uint64_t sub_1B529F5E4@<X0>(uint64_t *a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t result = _s10FontParser8LanguageO8rawValueACSgSi_tcfC_0(*a1);
  *a2 = result;
  return result;
}

uint64_t Encoding.isUnicode.getter(unsigned __int8 a1)
{
  return (a1 < 0x38u) & (0x8200000000007FuLL >> a1);
}

BOOL static Region.__derived_enum_equals(_:_:)(char a1, char a2)
{
  return a1 == a2;
}

uint64_t Region.hash(into:)()
{
  return sub_1B5373308();
}

BOOL static Region.__derived_enum_less_than(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  return a1 < a2;
}

uint64_t _s10FontParser8EncodingO9hashValueSivg_0()
{
  return sub_1B5373358();
}

BOOL sub_1B529F6C8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 < *a2;
}

BOOL sub_1B529F6DC(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a2 >= *a1;
}

BOOL sub_1B529F6F0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 >= *a2;
}

BOOL sub_1B529F704(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a2 < *a1;
}

uint64_t Platform.rawValue.setter(uint64_t result)
{
  *__int16 v1 = result;
  return result;
}

uint64_t (*Platform.rawValue.modify())(void)
{
  return nullsub_1;
}

uint64_t static Platform.iso.getter()
{
  return 2;
}

BOOL static Platform.< infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  return a1 < a2;
}

Swift::UInt16_optional __swiftcall Platform.rawValue(region:)(FontParser::Region region)
{
  if (v1 != 3)
  {
LABEL_28:
    int v17 = 0;
    int v16 = 1;
LABEL_29:
    LODWORD(v3) = v17 | (v16 << 16);
    return (Swift::UInt16_optional)v3;
  }
  int v2 = region;
  unint64_t v3 = sub_1B5238328((uint64_t)&unk_1F0DDDE98);
  int64_t v4 = 0;
  unint64_t v5 = v3 + 64;
  uint64_t v6 = 1 << *(unsigned char *)(v3 + 32);
  uint64_t v7 = -1;
  if (v6 < 64) {
    uint64_t v7 = ~(-1 << v6);
  }
  unint64_t v8 = v7 & *(void *)(v3 + 64);
  int64_t v9 = (unint64_t)(v6 + 63) >> 6;
  while (v8)
  {
    unint64_t v10 = __clz(__rbit64(v8));
    v8 &= v8 - 1;
    unint64_t v11 = v10 | (v4 << 6);
LABEL_6:
    if (*(unsigned __int8 *)(*(void *)(v3 + 56) + v11) == v2)
    {
      uint64_t v15 = *(void *)(*(void *)(v3 + 48) + 8 * v11);
      swift_release();
      int v16 = 0;
      int v17 = v15 & 0xFF00;
      goto LABEL_29;
    }
  }
  int64_t v12 = v4 + 1;
  if (__OFADD__(v4, 1))
  {
    __break(1u);
    goto LABEL_31;
  }
  if (v12 >= v9) {
    goto LABEL_27;
  }
  unint64_t v13 = *(void *)(v5 + 8 * v12);
  ++v4;
  if (v13) {
    goto LABEL_25;
  }
  int64_t v4 = v12 + 1;
  if (v12 + 1 >= v9) {
    goto LABEL_27;
  }
  unint64_t v13 = *(void *)(v5 + 8 * v4);
  if (v13) {
    goto LABEL_25;
  }
  int64_t v4 = v12 + 2;
  if (v12 + 2 >= v9) {
    goto LABEL_27;
  }
  unint64_t v13 = *(void *)(v5 + 8 * v4);
  if (v13) {
    goto LABEL_25;
  }
  int64_t v4 = v12 + 3;
  if (v12 + 3 >= v9) {
    goto LABEL_27;
  }
  unint64_t v13 = *(void *)(v5 + 8 * v4);
  if (v13) {
    goto LABEL_25;
  }
  int64_t v4 = v12 + 4;
  if (v12 + 4 >= v9) {
    goto LABEL_27;
  }
  unint64_t v13 = *(void *)(v5 + 8 * v4);
  if (v13)
  {
LABEL_25:
    unint64_t v8 = (v13 - 1) & v13;
    unint64_t v11 = __clz(__rbit64(v13)) + (v4 << 6);
    goto LABEL_6;
  }
  int64_t v14 = v12 + 5;
  if (v14 >= v9)
  {
LABEL_27:
    swift_release();
    goto LABEL_28;
  }
  unint64_t v13 = *(void *)(v5 + 8 * v14);
  if (v13)
  {
    int64_t v4 = v14;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v4 = v14 + 1;
    if (__OFADD__(v14, 1)) {
      break;
    }
    if (v4 >= v9) {
      goto LABEL_27;
    }
    unint64_t v13 = *(void *)(v5 + 8 * v4);
    ++v14;
    if (v13) {
      goto LABEL_25;
    }
  }
LABEL_31:
  __break(1u);
  return (Swift::UInt16_optional)v3;
}

uint64_t sub_1B529F8E8()
{
  return sub_1B53729F8();
}

uint64_t sub_1B529F948()
{
  return sub_1B53729E8();
}

uint64_t static IntlQuery.Predicate.__derived_enum_equals(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v30 = a2;
  uint64_t v5 = *(void *)(a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v27 = (char *)&v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = v7;
  uint64_t v8 = type metadata accessor for IntlQuery.Predicate();
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1F4188790](v8);
  uint64_t v31 = (char *)&v26 - v10;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
  uint64_t v12 = *(void *)(TupleTypeMetadata2 - 8);
  double v13 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v15 = (char *)&v26 - v14;
  int v17 = (char *)&v26 + *(int *)(v16 + 48) - v14;
  uint64_t v29 = v9;
  uint64_t v18 = *(void (**)(char *, uint64_t, uint64_t, double))(v9 + 16);
  v18((char *)&v26 - v14, a1, v8, v13);
  ((void (*)(char *, uint64_t, uint64_t))v18)(v17, v30, v8);
  uint64_t v30 = v5;
  uint64_t v19 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v5 + 48);
  if (v19(v15, 1, a3) == 1)
  {
    char v20 = 1;
    if (v19(v17, 1, a3) == 1) {
      goto LABEL_8;
    }
  }
  else
  {
    ((void (*)(char *, char *, uint64_t))v18)(v31, v15, v8);
    if (v19(v17, 1, a3) != 1)
    {
      uint64_t v21 = v30;
      uint64_t v22 = v27;
      (*(void (**)(char *, char *, uint64_t))(v30 + 32))(v27, v17, a3);
      uint64_t v23 = v31;
      char v20 = sub_1B5372698();
      uint64_t v24 = *(void (**)(char *, uint64_t))(v21 + 8);
      v24(v22, a3);
      v24(v23, a3);
LABEL_8:
      uint64_t v12 = v29;
      goto LABEL_9;
    }
    (*(void (**)(char *, uint64_t))(v30 + 8))(v31, a3);
  }
  char v20 = 0;
  uint64_t v8 = TupleTypeMetadata2;
LABEL_9:
  (*(void (**)(char *, uint64_t))(v12 + 8))(v15, v8);
  return v20 & 1;
}

uint64_t IntlQuery.Predicate.hash(into:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v14 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  double v8 = MEMORY[0x1F4188790](v7);
  uint64_t v10 = (char *)&v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t, double))(v11 + 16))(v10, v12, a2, v8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v4 + 48))(v10, 1, v3) == 1) {
    return sub_1B5373308();
  }
  (*(void (**)(char *, char *, uint64_t))(v4 + 32))(v6, v10, v3);
  sub_1B5373308();
  sub_1B53725B8();
  return (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v6, v3);
}

uint64_t IntlQuery.Predicate.hashValue.getter(uint64_t a1)
{
  sub_1B53732F8();
  IntlQuery.Predicate.hash(into:)((uint64_t)v3, a1);
  return sub_1B5373358();
}

uint64_t sub_1B529FEE4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static IntlQuery.Predicate.__derived_enum_equals(_:_:)(a1, a2, *(void *)(a3 + 16));
}

uint64_t sub_1B529FEF8(uint64_t a1, uint64_t a2)
{
  sub_1B53732F8();
  IntlQuery.Predicate.hash(into:)((uint64_t)v4, a2);
  return sub_1B5373358();
}

uint64_t IntlQuery.platform.getter(int a1)
{
  return a1 & 0x1FFFF;
}

uint64_t IntlQuery.platform.setter(uint64_t result)
{
  *(_WORD *)uint64_t v1 = result;
  *(unsigned char *)(v1 + 2) = BYTE2(result) & 1;
  return result;
}

uint64_t (*IntlQuery.platform.modify())(void)
{
  return nullsub_1;
}

unint64_t IntlQuery.encoding.getter(unint64_t a1)
{
  return a1 >> 24;
}

uint64_t IntlQuery.encoding.setter(uint64_t result)
{
  *(unsigned char *)(v1 + 3) = result;
  return result;
}

uint64_t (*IntlQuery.encoding.modify())(void)
{
  return nullsub_1;
}

unint64_t IntlQuery.language.getter(unint64_t a1)
{
  return HIDWORD(a1);
}

uint64_t IntlQuery.language.setter(uint64_t result)
{
  *(unsigned char *)(v1 + 4) = result;
  return result;
}

uint64_t (*IntlQuery.language.modify())(void)
{
  return nullsub_1;
}

unint64_t IntlQuery.region.getter(unint64_t a1)
{
  return a1 >> 40;
}

uint64_t IntlQuery.region.setter(uint64_t result)
{
  *(unsigned char *)(v1 + 5) = result;
  return result;
}

uint64_t (*IntlQuery.region.modify())(void)
{
  return nullsub_1;
}

uint64_t _s10FontParser8LanguageO8rawValueACSgSi_tcfC_0(uint64_t a1)
{
  uint64_t v3 = 0;
  uint64_t result = 79;
  switch(a1)
  {
    case 0:
      goto LABEL_83;
    case 1:
      uint64_t v3 = 1;
      goto LABEL_83;
    case 2:
      uint64_t v3 = 2;
      goto LABEL_83;
    case 3:
      uint64_t v3 = 3;
      goto LABEL_83;
    case 4:
      uint64_t v3 = 4;
      goto LABEL_83;
    case 5:
      uint64_t v3 = 5;
      goto LABEL_83;
    case 6:
      uint64_t v3 = 6;
      goto LABEL_83;
    case 7:
      uint64_t v3 = 7;
      goto LABEL_83;
    case 8:
      uint64_t v3 = 8;
      goto LABEL_83;
    case 9:
      uint64_t v3 = 9;
      goto LABEL_83;
    case 10:
      uint64_t v3 = 10;
      goto LABEL_83;
    case 11:
      uint64_t v3 = 11;
      goto LABEL_83;
    case 12:
      uint64_t v3 = 12;
      goto LABEL_83;
    case 13:
      uint64_t v3 = 13;
      goto LABEL_83;
    case 14:
      uint64_t v3 = 14;
      goto LABEL_83;
    case 15:
      uint64_t v3 = 15;
      goto LABEL_83;
    case 16:
      uint64_t v3 = 16;
      goto LABEL_83;
    case 17:
      uint64_t v3 = 17;
      goto LABEL_83;
    case 18:
      uint64_t v3 = 18;
      goto LABEL_83;
    case 19:
      uint64_t v3 = 19;
      goto LABEL_83;
    case 20:
      uint64_t v3 = 20;
      goto LABEL_83;
    case 21:
      uint64_t v3 = 21;
      goto LABEL_83;
    case 22:
      uint64_t v3 = 22;
      goto LABEL_83;
    case 23:
      uint64_t v3 = 23;
      goto LABEL_83;
    case 24:
      uint64_t v3 = 24;
      goto LABEL_83;
    case 25:
      uint64_t v3 = 25;
      goto LABEL_83;
    case 26:
      uint64_t v3 = 26;
      goto LABEL_83;
    case 27:
      uint64_t v3 = 27;
      goto LABEL_83;
    case 28:
      uint64_t v3 = 28;
      goto LABEL_83;
    case 29:
      uint64_t v3 = 29;
      goto LABEL_83;
    case 30:
      uint64_t v3 = 30;
      goto LABEL_83;
    case 31:
      uint64_t v3 = 31;
      goto LABEL_83;
    case 32:
      uint64_t v3 = 32;
      goto LABEL_83;
    case 33:
      uint64_t v3 = 33;
      goto LABEL_83;
    case 34:
      uint64_t v3 = 34;
      goto LABEL_83;
    case 35:
      uint64_t v3 = 35;
      goto LABEL_83;
    case 36:
      uint64_t v3 = 36;
      goto LABEL_83;
    case 37:
      uint64_t v3 = 37;
      goto LABEL_83;
    case 38:
      uint64_t v3 = 38;
      goto LABEL_83;
    case 39:
      uint64_t v3 = 39;
      goto LABEL_83;
    case 40:
      uint64_t v3 = 40;
      goto LABEL_83;
    case 41:
      uint64_t v3 = 41;
      goto LABEL_83;
    case 42:
      uint64_t v3 = 42;
      goto LABEL_83;
    case 43:
      uint64_t v3 = 43;
      goto LABEL_83;
    case 44:
      uint64_t v3 = 44;
      goto LABEL_83;
    case 45:
      uint64_t v3 = 45;
      goto LABEL_83;
    case 46:
      uint64_t v3 = 46;
      goto LABEL_83;
    case 47:
      uint64_t v3 = 47;
      goto LABEL_83;
    case 48:
      uint64_t v3 = 48;
      goto LABEL_83;
    case 49:
      uint64_t v3 = 49;
      goto LABEL_83;
    case 50:
      uint64_t v3 = 50;
      goto LABEL_83;
    case 51:
      uint64_t v3 = 51;
      goto LABEL_83;
    case 52:
      uint64_t v3 = 52;
      goto LABEL_83;
    case 53:
      uint64_t v3 = 53;
      goto LABEL_83;
    case 54:
      uint64_t v3 = 54;
      goto LABEL_83;
    case 55:
      uint64_t v3 = 55;
      goto LABEL_83;
    case 56:
      uint64_t v3 = 56;
      goto LABEL_83;
    case 57:
      uint64_t v3 = 57;
      goto LABEL_83;
    case 58:
      uint64_t v3 = 58;
      goto LABEL_83;
    case 59:
      uint64_t v3 = 59;
      goto LABEL_83;
    case 60:
      uint64_t v3 = 60;
      goto LABEL_83;
    case 61:
      uint64_t v3 = 61;
      goto LABEL_83;
    case 62:
      uint64_t v3 = 62;
      goto LABEL_83;
    case 63:
      uint64_t v3 = 63;
      goto LABEL_83;
    case 64:
      uint64_t v3 = 64;
      goto LABEL_83;
    case 65:
      uint64_t v3 = 65;
      goto LABEL_83;
    case 66:
      uint64_t v3 = 66;
      goto LABEL_83;
    case 67:
      uint64_t v3 = 67;
      goto LABEL_83;
    case 68:
      uint64_t v3 = 68;
      goto LABEL_83;
    case 69:
      uint64_t v3 = 69;
      goto LABEL_83;
    case 70:
      uint64_t v3 = 70;
      goto LABEL_83;
    case 71:
      uint64_t v3 = 71;
      goto LABEL_83;
    case 72:
      uint64_t v3 = 72;
      goto LABEL_83;
    case 73:
      uint64_t v3 = 73;
      goto LABEL_83;
    case 74:
      uint64_t v3 = 74;
      goto LABEL_83;
    case 75:
      uint64_t v3 = 75;
      goto LABEL_83;
    case 76:
      uint64_t v3 = 76;
      goto LABEL_83;
    case 77:
      uint64_t v3 = 77;
      goto LABEL_83;
    case 78:
      uint64_t v3 = 78;
LABEL_83:
      uint64_t result = v3;
      break;
    case 79:
      return result;
    case 80:
      uint64_t result = 80;
      break;
    case 81:
      uint64_t result = 81;
      break;
    case 82:
      uint64_t result = 82;
      break;
    case 83:
      uint64_t result = 83;
      break;
    case 84:
      uint64_t result = 84;
      break;
    case 85:
      uint64_t result = 85;
      break;
    case 86:
      uint64_t result = 86;
      break;
    case 87:
      uint64_t result = 87;
      break;
    case 88:
      uint64_t result = 88;
      break;
    case 89:
      uint64_t result = 89;
      break;
    case 90:
      uint64_t result = 90;
      break;
    case 91:
      uint64_t result = 91;
      break;
    case 92:
      uint64_t result = 92;
      break;
    case 93:
      uint64_t result = 93;
      break;
    case 94:
      uint64_t result = 94;
      break;
    case 95:
      uint64_t result = 95;
      break;
    case 96:
      uint64_t result = 96;
      break;
    case 97:
      uint64_t result = 97;
      break;
    case 98:
      uint64_t result = 98;
      break;
    case 99:
      uint64_t result = 99;
      break;
    case 100:
      uint64_t result = 100;
      break;
    case 101:
      uint64_t result = 101;
      break;
    case 102:
      uint64_t result = 102;
      break;
    case 103:
      uint64_t result = 103;
      break;
    case 104:
      uint64_t result = 104;
      break;
    case 105:
      uint64_t result = 105;
      break;
    case 106:
      uint64_t result = 106;
      break;
    case 107:
      uint64_t result = 107;
      break;
    case 108:
      uint64_t result = 108;
      break;
    case 109:
      uint64_t result = 109;
      break;
    case 110:
      uint64_t result = 110;
      break;
    case 111:
      uint64_t result = 111;
      break;
    case 112:
      uint64_t result = 112;
      break;
    case 113:
      uint64_t result = 113;
      break;
    case 114:
      uint64_t result = 114;
      break;
    case 115:
      uint64_t result = 115;
      break;
    case 116:
      uint64_t result = 116;
      break;
    case 117:
      uint64_t result = 117;
      break;
    case 118:
      uint64_t result = 118;
      break;
    case 119:
      uint64_t result = 119;
      break;
    case 120:
      uint64_t result = 120;
      break;
    case 121:
      uint64_t result = 121;
      break;
    case 122:
      uint64_t result = 122;
      break;
    case 123:
      uint64_t result = 123;
      break;
    case 124:
      uint64_t result = 124;
      break;
    case 125:
      uint64_t result = 125;
      break;
    case 126:
      uint64_t result = 126;
      break;
    case 127:
      uint64_t result = 127;
      break;
    default:
      if ((unint64_t)(a1 - 128) >= 0x2F) {
        uint64_t result = 175;
      }
      else {
        uint64_t result = a1 | 0xFFFFFF80;
      }
      break;
  }
  return result;
}

uint64_t type metadata accessor for IntlQuery.Predicate()
{
  return __swift_instantiateGenericMetadata();
}

unint64_t sub_1B52A0668()
{
  unint64_t result = qword_1E9D48F50;
  if (!qword_1E9D48F50)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D48F50);
  }
  return result;
}

unint64_t sub_1B52A06C0()
{
  unint64_t result = qword_1E9D48F58;
  if (!qword_1E9D48F58)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D48F58);
  }
  return result;
}

unint64_t sub_1B52A0718()
{
  unint64_t result = qword_1E9D48F60;
  if (!qword_1E9D48F60)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D48F60);
  }
  return result;
}

unint64_t sub_1B52A0770()
{
  unint64_t result = qword_1E9D48F68[0];
  if (!qword_1E9D48F68[0])
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, qword_1E9D48F68);
  }
  return result;
}

uint64_t sub_1B52A07C4()
{
  return swift_getWitnessTable();
}

uint64_t getEnumTagSinglePayload for Language(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0x52) {
    goto LABEL_17;
  }
  if (a2 + 174 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 174) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 174;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 174;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 174;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0xAF;
  int v8 = v6 - 175;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for Language(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 174 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 174) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0x52) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0x51)
  {
    unsigned int v6 = ((a2 - 82) >> 8) + 1;
    *unint64_t result = a2 - 82;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1B52A093CLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 - 82;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Language()
{
  return &type metadata for Language;
}

uint64_t getEnumTagSinglePayload for Encoding(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xC9) {
    goto LABEL_17;
  }
  if (a2 + 55 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 55) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 55;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 55;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 55;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0x38;
  int v8 = v6 - 56;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for Encoding(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 55 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 55) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xC9) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xC8)
  {
    unsigned int v6 = ((a2 - 201) >> 8) + 1;
    *unint64_t result = a2 + 55;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1B52A0AD0);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 55;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Encoding()
{
  return &type metadata for Encoding;
}

uint64_t getEnumTagSinglePayload for Region(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0x81) {
    goto LABEL_17;
  }
  if (a2 + 127 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 127) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 127;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 127;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 127;
    }
  }
LABEL_17:
  int v6 = *a1;
  int v7 = (char)v6;
  int v8 = v6 - 128;
  if (v7 >= 0) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for Region(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 127 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 127) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0x81) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0x80)
  {
    unsigned int v6 = ((a2 - 129) >> 8) + 1;
    *unint64_t result = a2 + 127;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1B52A0C6CLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 127;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Region()
{
  return &type metadata for Region;
}

ValueMetadata *type metadata accessor for Platform()
{
  return &type metadata for Platform;
}

uint64_t getEnumTagSinglePayload for IntlQuery(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xC8 && *(unsigned char *)(a1 + 6)) {
    return (*(_DWORD *)a1 + 200);
  }
  if (*(unsigned __int8 *)(a1 + 3) <= 0x38u) {
    int v3 = 56;
  }
  else {
    int v3 = *(unsigned __int8 *)(a1 + 3);
  }
  int v4 = v3 - 57;
  if (*(unsigned __int8 *)(a1 + 3) < 0x38u) {
    int v5 = -1;
  }
  else {
    int v5 = v4;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for IntlQuery(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xC7)
  {
    *(_WORD *)(result + 4) = 0;
    *(_DWORD *)unint64_t result = a2 - 200;
    if (a3 >= 0xC8) {
      *(unsigned char *)(result + 6) = 1;
    }
  }
  else
  {
    if (a3 >= 0xC8) {
      *(unsigned char *)(result + 6) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 3) = a2 + 56;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for IntlQuery()
{
  return &type metadata for IntlQuery;
}

uint64_t sub_1B52A0D5C()
{
  uint64_t result = swift_checkMetadataState();
  if (v1 <= 0x3F)
  {
    swift_initEnumMetadataSinglePayload();
    return 0;
  }
  return result;
}

uint64_t *sub_1B52A0DD8(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  if (*(_DWORD *)(v6 + 84)) {
    size_t v7 = *(void *)(v6 + 64);
  }
  else {
    size_t v7 = *(void *)(v6 + 64) + 1;
  }
  uint64_t v8 = *(_DWORD *)(v6 + 80);
  if (v8 > 7 || (*(_DWORD *)(v6 + 80) & 0x100000) != 0 || v7 > 0x18)
  {
    uint64_t v11 = *a2;
    *a1 = *a2;
    a1 = (uint64_t *)(v11 + ((v8 + 16) & ~v8));
    swift_retain();
  }
  else if ((*(unsigned int (**)(uint64_t *, uint64_t, uint64_t))(v6 + 48))(a2, 1, v5))
  {
    memcpy(a1, a2, v7);
  }
  else
  {
    (*(void (**)(uint64_t *, uint64_t *, uint64_t))(v6 + 16))(a1, a2, v5);
    (*(void (**)(uint64_t *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0, 1, v5);
  }
  return a1;
}

uint64_t sub_1B52A0F14(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(v3 - 8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 48))(a1, 1, v3);
  if (!result)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 8);
    return v5(a1, v3);
  }
  return result;
}

void *sub_1B52A0FD8(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  if ((*(unsigned int (**)(const void *, uint64_t, uint64_t))(v6 + 48))(a2, 1, v5))
  {
    if (*(_DWORD *)(v6 + 84)) {
      size_t v7 = *(void *)(v6 + 64);
    }
    else {
      size_t v7 = *(void *)(v6 + 64) + 1;
    }
    memcpy(a1, a2, v7);
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v6 + 16))(a1, a2, v5);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0, 1, v5);
  }
  return a1;
}

void *sub_1B52A10D0(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  size_t v7 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v6 + 48);
  int v8 = v7(a1, 1, v5);
  int v9 = v7(a2, 1, v5);
  if (v8)
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 16))(a1, a2, v5);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0, 1, v5);
      return a1;
    }
    int v10 = *(_DWORD *)(v6 + 84);
    size_t v11 = *(void *)(v6 + 64);
  }
  else
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 24))(a1, a2, v5);
      return a1;
    }
    double v13 = *(void (**)(void *, uint64_t))(v6 + 8);
    uint64_t v12 = v6 + 8;
    v13(a1, v5);
    int v10 = *(_DWORD *)(v12 + 76);
    size_t v11 = *(void *)(v12 + 56);
  }
  if (v10) {
    size_t v14 = v11;
  }
  else {
    size_t v14 = v11 + 1;
  }
  memcpy(a1, a2, v14);
  return a1;
}

void *sub_1B52A123C(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  if ((*(unsigned int (**)(const void *, uint64_t, uint64_t))(v6 + 48))(a2, 1, v5))
  {
    if (*(_DWORD *)(v6 + 84)) {
      size_t v7 = *(void *)(v6 + 64);
    }
    else {
      size_t v7 = *(void *)(v6 + 64) + 1;
    }
    memcpy(a1, a2, v7);
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v6 + 32))(a1, a2, v5);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0, 1, v5);
  }
  return a1;
}

void *sub_1B52A1334(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  size_t v7 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v6 + 48);
  int v8 = v7(a1, 1, v5);
  int v9 = v7(a2, 1, v5);
  if (v8)
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 32))(a1, a2, v5);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0, 1, v5);
      return a1;
    }
    int v10 = *(_DWORD *)(v6 + 84);
    size_t v11 = *(void *)(v6 + 64);
  }
  else
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 40))(a1, a2, v5);
      return a1;
    }
    double v13 = *(void (**)(void *, uint64_t))(v6 + 8);
    uint64_t v12 = v6 + 8;
    v13(a1, v5);
    int v10 = *(_DWORD *)(v12 + 76);
    size_t v11 = *(void *)(v12 + 56);
  }
  if (v10) {
    size_t v14 = v11;
  }
  else {
    size_t v14 = v11 + 1;
  }
  memcpy(a1, a2, v14);
  return a1;
}

uint64_t sub_1B52A14A0(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  unsigned int v6 = v5 - 1;
  if (!v5) {
    unsigned int v6 = 0;
  }
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  if (!v5) {
    ++v7;
  }
  if (!a2) {
    return 0;
  }
  int v8 = a2 - v6;
  if (a2 > v6)
  {
    char v9 = 8 * v7;
    if (v7 > 3) {
      goto LABEL_8;
    }
    unsigned int v11 = ((v8 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      int v10 = *(_DWORD *)((char *)a1 + v7);
      if (v10) {
        goto LABEL_15;
      }
    }
    else
    {
      if (v11 <= 0xFF)
      {
        if (v11 < 2) {
          goto LABEL_25;
        }
LABEL_8:
        int v10 = *((unsigned __int8 *)a1 + v7);
        if (!*((unsigned char *)a1 + v7)) {
          goto LABEL_25;
        }
LABEL_15:
        int v12 = (v10 - 1) << v9;
        if (v7 > 3) {
          int v12 = 0;
        }
        if (v7)
        {
          if (v7 <= 3) {
            int v13 = v7;
          }
          else {
            int v13 = 4;
          }
          switch(v13)
          {
            case 2:
              int v14 = *a1;
              break;
            case 3:
              int v14 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
              break;
            case 4:
              int v14 = *(_DWORD *)a1;
              break;
            default:
              int v14 = *(unsigned __int8 *)a1;
              break;
          }
        }
        else
        {
          int v14 = 0;
        }
        return v6 + (v14 | v12) + 1;
      }
      int v10 = *(unsigned __int16 *)((char *)a1 + v7);
      if (*(unsigned __int16 *)((char *)a1 + v7)) {
        goto LABEL_15;
      }
    }
  }
LABEL_25:
  if (v5 < 2) {
    return 0;
  }
  unsigned int v16 = (*(uint64_t (**)(void))(v4 + 48))();
  if (v16 >= 2) {
    return v16 - 1;
  }
  else {
    return 0;
  }
}

void sub_1B52A1640(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  int v6 = 0;
  uint64_t v7 = *(void *)(*(void *)(a4 + 16) - 8);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  unsigned int v9 = v8 - 1;
  if (v8)
  {
    size_t v10 = *(void *)(v7 + 64);
  }
  else
  {
    unsigned int v9 = 0;
    size_t v10 = *(void *)(v7 + 64) + 1;
  }
  BOOL v11 = a3 >= v9;
  unsigned int v12 = a3 - v9;
  if (v12 == 0 || !v11)
  {
LABEL_13:
    if (v9 < a2) {
      goto LABEL_14;
    }
    goto LABEL_21;
  }
  if (v10 > 3)
  {
    int v6 = 1;
    if (v9 < a2) {
      goto LABEL_14;
    }
    goto LABEL_21;
  }
  unsigned int v13 = ((v12 + ~(-1 << (8 * v10))) >> (8 * v10)) + 1;
  if (!HIWORD(v13))
  {
    if (v13 >= 0x100) {
      int v6 = 2;
    }
    else {
      int v6 = v13 > 1;
    }
    goto LABEL_13;
  }
  int v6 = 4;
  if (v9 < a2)
  {
LABEL_14:
    unsigned int v14 = ~v9 + a2;
    if (v10 < 4)
    {
      int v15 = (v14 >> (8 * v10)) + 1;
      if (v10)
      {
        int v16 = v14 & ~(-1 << (8 * v10));
        bzero(a1, v10);
        if (v10 == 3)
        {
          *(_WORD *)a1 = v16;
          a1[2] = BYTE2(v16);
        }
        else if (v10 == 2)
        {
          *(_WORD *)a1 = v16;
        }
        else
        {
          *a1 = v16;
        }
      }
    }
    else
    {
      bzero(a1, v10);
      *(_DWORD *)a1 = v14;
      int v15 = 1;
    }
    switch(v6)
    {
      case 1:
        a1[v10] = v15;
        return;
      case 2:
        *(_WORD *)&a1[v10] = v15;
        return;
      case 3:
        goto LABEL_39;
      case 4:
        *(_DWORD *)&a1[v10] = v15;
        return;
      default:
        return;
    }
  }
LABEL_21:
  switch(v6)
  {
    case 1:
      a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_26;
    case 2:
      *(_WORD *)&a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_26;
    case 3:
LABEL_39:
      __break(1u);
      JUMPOUT(0x1B52A187CLL);
    case 4:
      *(_DWORD *)&a1[v10] = 0;
      goto LABEL_25;
    default:
LABEL_25:
      if (a2)
      {
LABEL_26:
        if (v8 >= 2)
        {
          int v17 = *(void (**)(void))(v7 + 56);
          v17();
        }
      }
      return;
  }
}

uint64_t sub_1B52A18A4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8) + 48))(a1, 1);
}

uint64_t sub_1B52A18D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a3 + 16) - 8) + 56))(a1, a2, 1);
}

unint64_t sub_1B52A1904()
{
  unint64_t result = qword_1E9D48FF0;
  if (!qword_1E9D48FF0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D48FF0);
  }
  return result;
}

uint64_t destroy for PostTable()
{
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for PostTable(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(unsigned char *)(a1 + 12) = *(unsigned char *)(a2 + 12);
  long long v3 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v3;
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for PostTable(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  *(_WORD *)(a1 + 10) = *(_WORD *)(a2 + 10);
  *(unsigned char *)(a1 + 12) = *(unsigned char *)(a2 + 12);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for PostTable(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(unsigned char *)(a1 + 12) = *(unsigned char *)(a2 + 12);
  long long v3 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v3;
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for PostTable(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 56)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 48);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for PostTable(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)unint64_t result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 56) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 48) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 56) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for PostTable()
{
  return &type metadata for PostTable;
}

uint64_t sub_1B52A1B4C(uint64_t a1)
{
  uint64_t v15 = MEMORY[0x1E4FBC860];
  sub_1B521CE50(0, 0, 0);
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t result = swift_bridgeObjectRetain();
  if (!v2)
  {
LABEL_13:
    swift_bridgeObjectRelease();
    return v15;
  }
  uint64_t v4 = 0;
  uint64_t v5 = a1 + 32;
  unint64_t v6 = 0x1E9D47000uLL;
  while (1)
  {
    uint64_t v7 = *(char *)(v5 + v4);
    uint64_t v8 = v4 + v7;
    if (__OFADD__(v4, v7)) {
      break;
    }
    if (*(void *)(v6 + 1736) == -1)
    {
      if (v8 < 0) {
        goto LABEL_9;
      }
    }
    else
    {
      swift_once();
      unint64_t v6 = 0x1E9D47000;
      if (v8 < 0)
      {
LABEL_9:
        sub_1B53731F8();
        sub_1B5372868();
        uint64_t result = swift_bridgeObjectRelease();
        unint64_t v6 = 0x1E9D47000;
        uint64_t v10 = 0x64696C61766E692ELL;
        unint64_t v11 = 0xE90000000000005FLL;
        goto LABEL_10;
      }
    }
    if (v8 >= *((void *)off_1E9D48FF8 + 2)) {
      goto LABEL_9;
    }
    unsigned int v9 = (char *)off_1E9D48FF8 + 16 * v8;
    uint64_t v10 = *((void *)v9 + 4);
    unint64_t v11 = *((void *)v9 + 5);
    uint64_t result = swift_bridgeObjectRetain();
LABEL_10:
    unint64_t v13 = *(void *)(v15 + 16);
    unint64_t v12 = *(void *)(v15 + 24);
    if (v13 >= v12 >> 1)
    {
      uint64_t result = (uint64_t)sub_1B521CE50((char *)(v12 > 1), v13 + 1, 1);
      unint64_t v6 = 0x1E9D47000;
    }
    ++v4;
    *(void *)(v15 + 16) = v13 + 1;
    uint64_t v14 = v15 + 16 * v13;
    *(void *)(v14 + 32) = v10;
    *(void *)(v14 + 40) = v11;
    if (v2 == v4) {
      goto LABEL_13;
    }
  }
  __break(1u);
  return result;
}

void *sub_1B52A1D00@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[1];
  if (v2 >= *result)
  {
    *a2 = *result;
    a2[1] = v2;
  }
  else
  {
    sub_1B51D4F7C();
    swift_allocError();
    return (void *)swift_willThrow();
  }
  return result;
}

uint64_t sub_1B52A1D60@<X0>(int *a1@<X0>, uint64_t a2@<X8>)
{
  int v3 = *a1;
  uint64_t v4 = sub_1B52A1F1C;
  if (*a1 == 0x20000)
  {
    unint64_t v6 = sub_1B52A1EEC;
    char v8 = 0;
    uint64_t result = 1;
    BOOL v7 = 1;
  }
  else if (v3 == 0x10000)
  {
    if (qword_1E9D476C8 != -1) {
      swift_once();
    }
    uint64_t result = swift_bridgeObjectRetain();
    unint64_t v6 = 0;
    uint64_t v4 = 0;
    BOOL v7 = 0;
    char v8 = 0;
  }
  else
  {
    BOOL v7 = v3 != 163840;
    if (v3 == 163840) {
      uint64_t result = 1;
    }
    else {
      uint64_t result = MEMORY[0x1E4FBC860];
    }
    if (v3 == 163840) {
      unint64_t v6 = sub_1B52A1F3C;
    }
    else {
      unint64_t v6 = 0;
    }
    if (v3 == 163840) {
      uint64_t v4 = sub_1B52A1F50;
    }
    else {
      uint64_t v4 = 0;
    }
    char v8 = 1;
  }
  *(_DWORD *)a2 = v3;
  *(_WORD *)(a2 + 4) = 257;
  *(unsigned char *)(a2 + 6) = 1;
  *(unsigned char *)(a2 + 8) = 1;
  *(void *)(a2 + 16) = sub_1B52A1ED8;
  *(void *)(a2 + 24) = 0;
  *(_WORD *)(a2 + 32) = 257;
  *(void *)(a2 + 40) = sub_1B52A1D00;
  *(void *)(a2 + 48) = 0;
  *(_WORD *)(a2 + 56) = 257;
  *(void *)(a2 + 64) = sub_1B52A1D00;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = result;
  *(void *)(a2 + 88) = v6;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = v4;
  *(void *)(a2 + 112) = 0;
  *(unsigned char *)(a2 + 120) = v7;
  *(unsigned char *)(a2 + 121) = v8;
  return result;
}

_DWORD *sub_1B52A1ED8@<X0>(_DWORD *result@<X0>, BOOL *a2@<X8>)
{
  *a2 = *result != 0;
  return result;
}

uint64_t *sub_1B52A1EEC@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *result;
  *(unsigned char *)a2 = 1;
  *(void *)(a2 + 8) = sub_1B52A1FAC;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = MEMORY[0x1E4FBC860];
  *(void *)(a2 + 32) = v2;
  return result;
}

uint64_t sub_1B52A1F1C@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  *a2 = *a1;
  return swift_bridgeObjectRetain();
}

uint64_t *sub_1B52A1F3C@<X0>(uint64_t *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *result;
  *a2 = MEMORY[0x1E4FBC860];
  a2[1] = v2;
  return result;
}

uint64_t sub_1B52A1F50@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v2 = swift_bridgeObjectRetain();
  uint64_t v3 = sub_1B52A1B4C(v2);
  uint64_t result = swift_bridgeObjectRelease();
  *a1 = v3;
  return result;
}

unsigned __int16 *sub_1B52A1FAC@<X0>(unsigned __int16 *result@<X0>, uint64_t a2@<X8>)
{
  unsigned int v3 = *result;
  if (qword_1E9D476C8 != -1) {
    uint64_t result = (unsigned __int16 *)swift_once();
  }
  unint64_t v4 = *((void *)off_1E9D48FF8 + 2);
  if (v4 >> 16)
  {
    __break(1u);
  }
  else
  {
    if (v3 < (unsigned __int16)v4)
    {
      char v5 = 0;
LABEL_13:
      *(_DWORD *)a2 = v3;
      *(unsigned char *)(a2 + 4) = v5;
      return result;
    }
    if ((v4 & 0x8000) == 0)
    {
      BOOL v6 = v3 > 0x7FFE;
      if (v3 <= 0x7FFE) {
        unsigned int v3 = (unsigned __int16)(v3 - v4) | 0x1010000;
      }
      else {
        unsigned int v3 = (unsigned __int16)(v3 - 0x7FFF) | 0x20000;
      }
      char v5 = v6;
      goto LABEL_13;
    }
  }
  __break(1u);
  return result;
}

void sub_1B52A2078(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  int64_t v5 = *(void *)(a3 + 16);
  BOOL v6 = (void *)MEMORY[0x1E4FBC860];
  BOOL v7 = sub_1B51E7F5C(0, v5, 0, MEMORY[0x1E4FBC860]);
  char v8 = sub_1B51E815C(0, v5, 0, v6);
  int64_t v54 = v5;
  if (!v5) {
    goto LABEL_64;
  }
  uint64_t v53 = a3 + 32;
  swift_bridgeObjectRetain();
  uint64_t v9 = 0;
  while (1)
  {
    uint64_t v55 = v9;
    uint64_t v56 = v7;
    int v17 = (unsigned __int16 *)(v53 + 4 * v9);
    unint64_t v18 = *v17;
    int v19 = *((unsigned __int8 *)v17 + 2);
    if (!v19)
    {
      if (qword_1E9D476C8 != -1) {
        swift_once();
      }
      if (*((void *)off_1E9D48FF8 + 2) <= v18) {
        goto LABEL_74;
      }
      uint64_t v46 = (char *)off_1E9D48FF8 + 16 * v18;
      uint64_t v10 = *((void *)v46 + 4);
      unint64_t v11 = *((void *)v46 + 5);
      BOOL v7 = v56;
      unint64_t v13 = *((void *)v56 + 2);
      unint64_t v47 = *((void *)v56 + 3);
      int64_t v14 = v13 + 1;
      swift_bridgeObjectRetain();
      if (v13 < v47 >> 1) {
        goto LABEL_4;
      }
      BOOL v48 = v47 > 1;
      goto LABEL_59;
    }
    if (v19 == 1) {
      break;
    }
    sub_1B53731F8();
    sub_1B5372868();
    swift_bridgeObjectRelease();
    uint64_t v10 = 0x657672657365722ELL;
    unint64_t v11 = 0xEA00000000005F64;
    BOOL v7 = v56;
    unint64_t v13 = *((void *)v56 + 2);
    unint64_t v12 = *((void *)v56 + 3);
    int64_t v14 = v13 + 1;
    if (v13 >= v12 >> 1)
    {
      BOOL v48 = v12 > 1;
LABEL_59:
      uint64_t v52 = v48;
      BOOL v7 = sub_1B51E7F5C((char *)v52, v14, 1, v7);
    }
LABEL_4:
    *((void *)v7 + 2) = v14;
    uint64_t v15 = &v7[16 * v13];
    *((void *)v15 + 4) = v10;
    int v16 = v15 + 32;
LABEL_5:
    *((void *)v16 + 1) = v11;
    uint64_t v9 = v55 + 1;
    if (v55 + 1 == v54)
    {
      swift_bridgeObjectRelease();
LABEL_64:
      swift_bridgeObjectRelease();
      return;
    }
  }
  unint64_t v20 = v8[2];
  if (v20 > v18)
  {
LABEL_9:
    if (v20 <= v18) {
      goto LABEL_73;
    }
    uint64_t v21 = &v8[2 * v18];
    if (v21[5])
    {
      uint64_t v22 = v21[4];
      unint64_t v11 = v21[5];
    }
    else
    {
      sub_1B53731F8();
      sub_1B5372868();
      swift_bridgeObjectRelease();
      uint64_t v22 = 0x64696C61766E692ELL;
      unint64_t v11 = 0xE90000000000005FLL;
    }
    BOOL v7 = v56;
    unint64_t v49 = *((void *)v56 + 2);
    unint64_t v50 = *((void *)v56 + 3);
    swift_bridgeObjectRetain();
    if (v49 >= v50 >> 1) {
      BOOL v7 = sub_1B51E7F5C((char *)(v50 > 1), v49 + 1, 1, v56);
    }
    *((void *)v7 + 2) = v49 + 1;
    uint64_t v51 = &v7[16 * v49];
    *((void *)v51 + 4) = v22;
    int v16 = v51 + 32;
    goto LABEL_5;
  }
  while (2)
  {
    unint64_t v23 = *a1;
    uint64_t v24 = a1[1];
    if (!__OFSUB__(v24, *a1))
    {
      unint64_t v25 = a1[2];
      if ((uint64_t)(v24 - *a1) > 0)
      {
        int64_t v26 = v23 + 1;
        if (v23 == 0x7FFFFFFFFFFFFFFFLL || v24 < v26) {
          goto LABEL_66;
        }
        if ((v23 & 0x8000000000000000) != 0) {
          goto LABEL_67;
        }
        unint64_t v28 = *(void *)(v25 + 16);
        if (v28 < v23 || v28 < v26) {
          goto LABEL_68;
        }
        uint64_t v30 = *(unsigned __int8 *)(v25 + 32 + v23);
        BOOL v31 = __OFSUB__(v24, v26);
        swift_bridgeObjectRetain();
        if (v31) {
          goto LABEL_69;
        }
        if (v24 - v26 >= v30)
        {
          uint64_t v36 = v26 + v30;
          if (__OFSUB__(v36, v26)) {
            goto LABEL_70;
          }
          if (v36 < v26 || v24 < v36 || v36 < v26) {
            goto LABEL_71;
          }
          if (__OFADD__(v26, v36 - v26)) {
            goto LABEL_72;
          }
          swift_bridgeObjectRetain();
          uint64_t v39 = sub_1B5372808();
          uint64_t v41 = v40;
          swift_bridgeObjectRelease_n();
          *a1 = v36;
          a1[1] = v24;
          a1[2] = v25;
        }
        else
        {
          swift_bridgeObjectRetain();
          sub_1B5372F98();
          swift_bridgeObjectRelease();
          sub_1B53731F8();
          sub_1B5372868();
          swift_bridgeObjectRelease();
          sub_1B51D4D34();
          uint64_t v32 = (void *)swift_allocError();
          *uint64_t v33 = 0;
          v33[1] = v26;
          v33[2] = 0xD000000000000024;
          v33[3] = 0x80000001B537CBF0;
          v33[4] = 0;
          swift_willThrow();
          swift_bridgeObjectRelease();
          id v34 = v32;
          __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47950);
          if (swift_dynamicCast())
          {

            swift_bridgeObjectRelease();
            sub_1B5200310((id)0xD000000000000024);
            swift_bridgeObjectRelease();
            uint64_t v35 = v57;
          }
          else
          {

            id v42 = v32;
            swift_bridgeObjectRelease();
            sub_1B5200310(v32);
            swift_bridgeObjectRelease();
            uint64_t v35 = v32;
          }

LABEL_44:
          uint64_t v39 = 0;
          uint64_t v41 = 0;
        }
        unint64_t v44 = v8[2];
        unint64_t v43 = v8[3];
        unint64_t v20 = v44 + 1;
        if (v44 >= v43 >> 1) {
          char v8 = sub_1B51E815C((void *)(v43 > 1), v44 + 1, 1, v8);
        }
        v8[2] = v20;
        uint64_t v45 = &v8[2 * v44];
        v45[4] = v39;
        v45[5] = v41;
        if (v44 >= v18) {
          goto LABEL_9;
        }
        continue;
      }
      swift_bridgeObjectRetain_n();
      sub_1B5372F98();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      goto LABEL_44;
    }
    break;
  }
  __break(1u);
LABEL_66:
  __break(1u);
LABEL_67:
  __break(1u);
LABEL_68:
  __break(1u);
LABEL_69:
  __break(1u);
LABEL_70:
  __break(1u);
LABEL_71:
  __break(1u);
LABEL_72:
  __break(1u);
LABEL_73:
  __break(1u);
LABEL_74:
  __break(1u);
}

void sub_1B52A2644(unint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  sub_1B52A2078(a1, a2, *v3);
  if (!v4) {
    *a3 = v6;
  }
}

void sub_1B52A2674()
{
  off_1E9D48FF8 = &unk_1F0DDAC38;
}

ValueMetadata *type metadata accessor for Name20ListParser()
{
  return &type metadata for Name20ListParser;
}

uint64_t __swift_memcpy3_2(uint64_t result, __int16 *a2)
{
  __int16 v2 = *a2;
  *(unsigned char *)(result + 2) = *((unsigned char *)a2 + 2);
  *(_WORD *)uint64_t result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for Name20Entry(unsigned __int16 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFE)
  {
    if ((a2 + 33554178) >> 24)
    {
      int v2 = *((unsigned __int8 *)a1 + 3);
      if (*((unsigned char *)a1 + 3)) {
        return (*a1 | (*((unsigned __int8 *)a1 + 2) << 16) | (v2 << 24)) - 16776962;
      }
    }
    else
    {
      int v2 = *(unsigned __int16 *)((char *)a1 + 3);
      if (*(unsigned __int16 *)((char *)a1 + 3)) {
        return (*a1 | (*((unsigned __int8 *)a1 + 2) << 16) | (v2 << 24)) - 16776962;
      }
    }
  }
  unsigned int v4 = *((unsigned __int8 *)a1 + 2);
  if (v4 <= 2) {
    int v5 = -1;
  }
  else {
    int v5 = v4 ^ 0xFF;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for Name20Entry(uint64_t result, unsigned int a2, unsigned int a3)
{
  if ((a3 + 33554178) >> 24) {
    int v3 = 1;
  }
  else {
    int v3 = 2;
  }
  if (a3 <= 0xFD) {
    int v3 = 0;
  }
  if (a2 > 0xFD)
  {
    *(_WORD *)uint64_t result = a2 - 254;
    *(unsigned char *)(result + 2) = (a2 - 254) >> 16;
    if (v3)
    {
      unsigned int v4 = ((a2 - 254) >> 24) + 1;
      if (v3 == 2) {
        *(_WORD *)(result + 3) = v4;
      }
      else {
        *(unsigned char *)(result + 3) = v4;
      }
    }
  }
  else
  {
    if (!v3) {
      goto LABEL_10;
    }
    if (v3 == 2)
    {
      *(_WORD *)(result + 3) = 0;
LABEL_10:
      if (!a2) {
        return result;
      }
LABEL_16:
      *(unsigned char *)(result + 2) = -(char)a2;
      return result;
    }
    *(unsigned char *)(result + 3) = 0;
    if (a2) {
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t sub_1B52A27AC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 2);
}

uint64_t sub_1B52A27B4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 2) = a2;
  return result;
}

ValueMetadata *type metadata accessor for Name20Entry()
{
  return &type metadata for Name20Entry;
}

uint64_t sub_1B52A27CC(char **a1)
{
  int v2 = *a1;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    int v2 = sub_1B51DA974((uint64_t)v2);
  }
  uint64_t v3 = *((void *)v2 + 2);
  v5[0] = v2 + 32;
  v5[1] = v3;
  uint64_t result = sub_1B52A60B8(v5);
  *a1 = v2;
  return result;
}

uint64_t sub_1B52A2838()
{
  uint64_t v1 = *(void *)v0;
  if (*(void *)v0)
  {
    long long v22 = *(_OWORD *)(v0 + 8);
    uint64_t v19 = *(void *)(v0 + 24);
    sub_1B5221910(v0);
    uint64_t v2 = 0;
    uint64_t v3 = (char *)MEMORY[0x1E4FBC860];
    for (uint64_t i = 0x199999999999999ALL; ; --i)
    {
      if (!i)
      {
        __break(1u);
LABEL_22:
        __break(1u);
LABEL_23:
        __break(1u);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease_n();
        goto LABEL_25;
      }
      long long v20 = v22;
      sub_1B5221910(v0);
      sub_1B51D4C10();
      uint64_t v6 = sub_1B53724D8();
      if (__OFADD__(v19, v2)) {
        break;
      }
      *(void *)&long long v20 = sub_1B53724B8();
      *((void *)&v20 + 1) = v7;
      uint64_t v21 = v8;
      swift_bridgeObjectRetain_n();
      unsigned int v10 = sub_1B51F9F5C((uint64_t *)&v20, v9, 3, 1);
      sub_1B51F3E0C((uint64_t *)&v20, v11, 1);
      swift_bridgeObjectRelease_n();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      unint64_t v12 = *((void *)v3 + 2);
      if (v12 && (unint64_t v13 = &v3[8 * v12 - 8], v10 - *((_DWORD *)v13 + 9) == 1))
      {
        unsigned int v14 = *((_DWORD *)v13 + 8);
        if (v10 < v14) {
          goto LABEL_22;
        }
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
          uint64_t v3 = sub_1B52935C4((uint64_t)v3);
        }
        if (v12 > *((void *)v3 + 2)) {
          goto LABEL_23;
        }
        int v5 = &v3[8 * v12 - 8];
        *((_DWORD *)v5 + 8) = v14;
      }
      else
      {
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
          uint64_t v3 = sub_1B51E9110(0, v12 + 1, 1, v3);
        }
        unint64_t v16 = *((void *)v3 + 2);
        unint64_t v15 = *((void *)v3 + 3);
        if (v16 >= v15 >> 1) {
          uint64_t v3 = sub_1B51E9110((char *)(v15 > 1), v16 + 1, 1, v3);
        }
        *((void *)v3 + 2) = v16 + 1;
        int v5 = &v3[8 * v16];
        *((_DWORD *)v5 + 8) = v10;
      }
      *((_DWORD *)v5 + 9) = v10;
      v2 += 5;
      if (!--v1)
      {
        sub_1B52A9E40(v0);
        return (uint64_t)v3;
      }
    }
    sub_1B51D4D34();
    swift_allocError();
    *unint64_t v18 = 2;
    v18[1] = v6;
    v18[2] = 0xD00000000000001DLL;
    v18[3] = 0x80000001B537BD80;
    v18[4] = 0;
    swift_willThrow();
LABEL_25:
    swift_bridgeObjectRelease();
    uint64_t result = swift_unexpectedError();
    __break(1u);
  }
  else
  {
    return MEMORY[0x1E4FBC860];
  }
  return result;
}

void sub_1B52A2B20()
{
  uint64_t v1 = *(void *)(v0 + 8);
  uint64_t v2 = *(void *)(v0 + 16);
  BOOL v3 = __OFSUB__(v2, v1);
  uint64_t v4 = v2 - v1;
  char v5 = v3;
  if (v4 >= 0) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = v4 + 1;
  }
  if (v5) {
    goto LABEL_27;
  }
  if ((unint64_t)(v4 + 1) < 3) {
    return;
  }
  if (v4 < 2) {
    goto LABEL_28;
  }
  uint64_t v7 = v6 >> 1;
  sub_1B5221874(v0);
  uint64_t v8 = 0;
  uint64_t v9 = (char *)MEMORY[0x1E4FBC860];
  while (1)
  {
    sub_1B52A3F0C(v8);
    int v12 = v11;
    unint64_t v13 = HIDWORD(v11);
    unint64_t v14 = *((void *)v9 + 2);
    if (!v14 || (unint64_t v15 = &v9[8 * v14 - 8], v11 - *((_DWORD *)v15 + 9) != 1))
    {
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
        uint64_t v9 = sub_1B51E9110(0, v14 + 1, 1, v9);
      }
      unint64_t v18 = *((void *)v9 + 2);
      unint64_t v17 = *((void *)v9 + 3);
      if (v18 >= v17 >> 1) {
        uint64_t v9 = sub_1B51E9110((char *)(v17 > 1), v18 + 1, 1, v9);
      }
      *((void *)v9 + 2) = v18 + 1;
      unsigned int v10 = &v9[8 * v18];
      *((_DWORD *)v10 + 8) = v12;
      goto LABEL_12;
    }
    unsigned int v16 = *((_DWORD *)v15 + 8);
    if (v16 > HIDWORD(v11)) {
      break;
    }
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
      uint64_t v9 = sub_1B52935C4((uint64_t)v9);
    }
    if (v14 > *((void *)v9 + 2)) {
      goto LABEL_26;
    }
    unsigned int v10 = &v9[8 * v14 - 8];
    *((_DWORD *)v10 + 8) = v16;
LABEL_12:
    *((_DWORD *)v10 + 9) = v13;
    if (v7 == ++v8)
    {
      sub_1B5200EB4(v0);
      return;
    }
  }
  __break(1u);
LABEL_26:
  __break(1u);
LABEL_27:
  __break(1u);
LABEL_28:
  __break(1u);
}

uint64_t sub_1B52A2CA8(void (*a1)(uint64_t), void (*a2)())
{
  long long v3 = *(_OWORD *)(v2 + 24);
  long long v42 = *(_OWORD *)(v2 + 8);
  long long v43 = v3;
  *(_OWORD *)unint64_t v44 = *(_OWORD *)(v2 + 40);
  *(void *)&v44[16] = *(void *)(v2 + 56);
  uint64_t v4 = v3;
  if ((void)v3)
  {
    uint64_t v34 = *((void *)&v43 + 1);
    long long v45 = *(_OWORD *)&v44[8];
    a1(v2);
    uint64_t v5 = 0;
    uint64_t v6 = (char *)MEMORY[0x1E4FBC860];
    for (uint64_t i = 0xAAAAAAAAAAAAAABLL; ; --i)
    {
      if (!i)
      {
        __break(1u);
LABEL_23:
        __break(1u);
LABEL_24:
        __break(1u);
        swift_bridgeObjectRelease();
        goto LABEL_27;
      }
      uint64_t v36 = v4;
      long long v40 = v45;
      sub_1B52218E0((uint64_t)&v42);
      sub_1B51D4C10();
      uint64_t v9 = sub_1B53724D8();
      uint64_t v35 = v5;
      if (__OFADD__(v34, v5))
      {
        sub_1B51D4D34();
        swift_allocError();
        *uint64_t v29 = 2;
        v29[1] = v9;
        v29[2] = 0xD00000000000001DLL;
        v29[3] = 0x80000001B537BD80;
        v29[4] = 0;
        swift_willThrow();
        goto LABEL_28;
      }
      uint64_t v10 = sub_1B53724B8();
      uint64_t v12 = v11;
      uint64_t v14 = v13;
      *(void *)&long long v40 = v10;
      *((void *)&v40 + 1) = v11;
      uint64_t v41 = v13;
      swift_bridgeObjectRetain();
      uint64_t v37 = v10;
      uint64_t v38 = v12;
      uint64_t v39 = v14;
      swift_bridgeObjectRetain_n();
      unsigned int v16 = sub_1B51F3DDC(&v37, v15, 1);
      unsigned int v18 = sub_1B51F3DDC(&v37, v17, 1);
      swift_bridgeObjectRelease();
      uint64_t v19 = v37;
      uint64_t v20 = v39;
      if (v18 < v16) {
        break;
      }
      uint64_t v21 = v38;
      swift_bridgeObjectRelease();
      *(void *)&long long v40 = v19;
      *((void *)&v40 + 1) = v21;
      uint64_t v41 = v20;
      sub_1B51F3DDC((uint64_t *)&v40, v22, 1);
      swift_bridgeObjectRelease_n();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      unint64_t v23 = *((void *)v6 + 2);
      if (v23 && (uint64_t v24 = &v6[8 * v23 - 8], v16 - *((_DWORD *)v24 + 9) == 1))
      {
        unsigned int v25 = *((_DWORD *)v24 + 8);
        if (v18 < v25) {
          goto LABEL_23;
        }
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
          uint64_t v6 = sub_1B52935C4((uint64_t)v6);
        }
        if (v23 > *((void *)v6 + 2)) {
          goto LABEL_24;
        }
        uint64_t v8 = &v6[8 * v23 - 8];
        *((_DWORD *)v8 + 8) = v25;
      }
      else
      {
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
          uint64_t v6 = sub_1B51E9110(0, v23 + 1, 1, v6);
        }
        unint64_t v27 = *((void *)v6 + 2);
        unint64_t v26 = *((void *)v6 + 3);
        if (v27 >= v26 >> 1) {
          uint64_t v6 = sub_1B51E9110((char *)(v26 > 1), v27 + 1, 1, v6);
        }
        *((void *)v6 + 2) = v27 + 1;
        uint64_t v8 = &v6[8 * v27];
        *((_DWORD *)v8 + 8) = v16;
      }
      *((_DWORD *)v8 + 9) = v18;
      uint64_t v5 = v35 + 12;
      uint64_t v4 = v36 - 1;
      if (v36 == 1)
      {
        a2();
        return (uint64_t)v6;
      }
    }
    sub_1B51D4F7C();
    uint64_t v30 = (void *)swift_allocError();
    swift_willThrow();
    sub_1B51D4D34();
    swift_allocError();
    *BOOL v31 = v30;
    v31[1] = v19;
    v31[2] = 0x7272652072657355;
    v31[3] = 0xEA0000000000726FLL;
    v31[4] = v30;
    id v32 = v30;
    swift_willThrow();
LABEL_27:
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease_n();
LABEL_28:
    swift_bridgeObjectRelease();
    uint64_t result = swift_unexpectedError();
    __break(1u);
  }
  else
  {
    return MEMORY[0x1E4FBC860];
  }
  return result;
}

uint64_t sub_1B52A30B8(uint64_t result, uint64_t a2, char a3)
{
  if (a3) {
    a2 = 0;
  }
  uint64_t v5 = *(void *)(v3 + 8);
  uint64_t v6 = *(void *)(v3 + 16);
  BOOL v7 = __OFSUB__(v6, v5);
  uint64_t v8 = v6 - v5;
  if (v7)
  {
    __break(1u);
LABEL_26:
    __break(1u);
    goto LABEL_27;
  }
  if (v8 >= 0) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = v8 + 1;
  }
  uint64_t v10 = v9 >> 1;
  if (v8 < -1 || v10 < a2) {
    goto LABEL_26;
  }
  if (a2 < 0)
  {
LABEL_27:
    __break(1u);
    return result;
  }
  uint64_t v12 = result;
  long long v13 = *(_OWORD *)(v3 + 80);
  long long v29 = *(_OWORD *)(v3 + 64);
  long long v30 = v13;
  long long v14 = *(_OWORD *)(v3 + 112);
  long long v31 = *(_OWORD *)(v3 + 96);
  long long v32 = v14;
  long long v15 = *(_OWORD *)(v3 + 16);
  long long v25 = *(_OWORD *)v3;
  long long v26 = v15;
  long long v16 = *(_OWORD *)(v3 + 48);
  long long v27 = *(_OWORD *)(v3 + 32);
  long long v28 = v16;
  v24[0] = a2;
  v24[1] = v9 >> 1;
  sub_1B5221874(v3);
  uint64_t v17 = sub_1B526244C(v12, v24);
  if (v17 != v10)
  {
    uint64_t v18 = sub_1B52A3F0C(v17);
    if (v19 <= v12 && v20 >= v12)
    {
      __int16 v23 = v21;
      if (v22)
      {
        if (v12 == 0xFFFF)
        {
          sub_1B5200EB4(v3);
          LOWORD(v12) = -1;
        }
        else
        {
          uint64_t v12 = sub_1B52A4208(v12, v18, v19, v21, v22);
          sub_1B5200EB4(v3);
          if ((v12 & 0x100000000) != 0) {
            return 0;
          }
        }
      }
      else
      {
        sub_1B5200EB4(v3);
      }
      return (unsigned __int16)(v12 + v23);
    }
  }
  sub_1B5200EB4(v3);
  return 0;
}

uint64_t sub_1B52A3208(unsigned int a1, uint64_t a2, char a3)
{
  uint64_t v4 = (uint64_t)v3;
  long long v5 = *v3;
  if (a3) {
    a2 = 0;
  }
  uint64_t v7 = *(void *)v3;
  if ((uint64_t)v5 < a2 || (v5 & 0x8000000000000000) != 0)
  {
    __break(1u);
    goto LABEL_15;
  }
  if (a2 < 0)
  {
LABEL_15:
    __break(1u);
    goto LABEL_16;
  }
  long long v9 = *(_OWORD *)(v4 + 16);
  uint64_t v10 = *(void *)(v4 + 32);
  v25[0] = a2;
  v25[1] = v5;
  long long v26 = v5;
  long long v27 = v9;
  uint64_t v28 = v10;
  sub_1B5221910(v4);
  uint64_t v11 = sub_1B5261EC8(a1, v25);
  if (v11 != v7)
  {
    if ((unsigned __int128)(v11 * (__int128)5) >> 64 == (5 * v11) >> 63)
    {
      v16[3] = 3;
      __int16 v17 = 257;
      uint64_t v18 = sub_1B5217CD8;
      uint64_t v19 = 0;
      long long v20 = *(_OWORD *)(v4 + 24);
      uint64_t v21 = 5 * v11;
      char v22 = 2;
      uint64_t v23 = 0;
      char v24 = 1;
      sub_1B5221910(v4);
      sub_1B51D4C10();
      v16[0] = sub_1B53724D8();
      v16[1] = v12;
      v16[2] = v13;
      uint64_t v14 = sub_1B51D26C8(v16, v12);
      swift_bridgeObjectRelease();
      sub_1B52A9E40(v4);
      if (v14 == a1) {
        return WORD2(v14);
      }
      return 0;
    }
LABEL_16:
    __break(1u);
    swift_bridgeObjectRelease();
    uint64_t result = swift_unexpectedError();
    __break(1u);
    return result;
  }
  sub_1B52A9E40(v4);
  return 0;
}

uint64_t sub_1B52A33B8(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4 = *(void *)(v3 + 24);
  if (a3) {
    a2 = 0;
  }
  if (v4 < a2 || v4 < 0)
  {
    __break(1u);
    goto LABEL_15;
  }
  if (a2 < 0)
  {
LABEL_15:
    __break(1u);
LABEL_16:
    __break(1u);
    swift_bridgeObjectRelease();
    uint64_t result = swift_unexpectedError();
    __break(1u);
    return result;
  }
  uint64_t v6 = v3;
  uint64_t v8 = *(void *)(v3 + 8);
  __int16 v9 = *(_WORD *)(v3 + 16);
  uint64_t v10 = *(void *)(v3 + 32);
  uint64_t v11 = *(void *)(v3 + 40);
  uint64_t v12 = *(void *)(v3 + 48);
  unint64_t v13 = *(void *)(v6 + 56);
  v34[0] = a2;
  v34[1] = v4;
  v34[2] = v8;
  __int16 v35 = v9;
  uint64_t v36 = v4;
  uint64_t v37 = v10;
  uint64_t v38 = v11;
  uint64_t v39 = v12;
  unint64_t v40 = v13;
  sub_1B52A9608(v6);
  uint64_t v14 = sub_1B5262640(a1, v34);
  if (v14 == v4)
  {
    sub_1B52A9638(v6);
    return 0;
  }
  if ((unsigned __int128)(v14 * (__int128)12) >> 64 != (12 * v14) >> 63) {
    goto LABEL_16;
  }
  __int16 v22 = 257;
  uint64_t v23 = sub_1B52A47FC;
  uint64_t v24 = 0;
  char v25 = 1;
  long long v26 = sub_1B52A485C;
  uint64_t v27 = 0;
  uint64_t v28 = v10;
  uint64_t v29 = v11;
  uint64_t v30 = 12 * v14;
  char v31 = 2;
  uint64_t v32 = 0;
  char v33 = 1;
  sub_1B51D4BB8(v12, v13);
  sub_1B51D4C10();
  v21[0] = sub_1B53724D8();
  v21[1] = v16;
  v21[2] = v17;
  uint64_t v18 = sub_1B51D2BC4(v21, v16);
  int v20 = v19;
  swift_bridgeObjectRelease();
  sub_1B52A9638(v6);
  uint64_t result = 0;
  if (v18 <= a1 && HIDWORD(v18) >= a1) {
    return (v20 + a1 - v18);
  }
  return result;
}

uint64_t sub_1B52A35B8(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4 = *(void *)(v3 + 24);
  if (a3) {
    a2 = 0;
  }
  if (v4 < a2 || v4 < 0)
  {
    __break(1u);
    goto LABEL_15;
  }
  if (a2 < 0)
  {
LABEL_15:
    __break(1u);
LABEL_16:
    __break(1u);
    swift_bridgeObjectRelease();
    uint64_t result = swift_unexpectedError();
    __break(1u);
    return result;
  }
  uint64_t v6 = v3;
  uint64_t v8 = *(void *)(v3 + 8);
  __int16 v9 = *(_WORD *)(v3 + 16);
  uint64_t v10 = *(void *)(v3 + 32);
  uint64_t v11 = *(void *)(v3 + 40);
  uint64_t v12 = *(void *)(v3 + 48);
  unint64_t v13 = *(void *)(v6 + 56);
  v34[0] = a2;
  v34[1] = v4;
  v34[2] = v8;
  __int16 v35 = v9;
  uint64_t v36 = v4;
  uint64_t v37 = v10;
  uint64_t v38 = v11;
  uint64_t v39 = v12;
  unint64_t v40 = v13;
  sub_1B52A9608(v6);
  uint64_t v14 = sub_1B5262640(a1, v34);
  if (v14 == v4)
  {
    sub_1B52A9638(v6);
    return 0;
  }
  if ((unsigned __int128)(v14 * (__int128)12) >> 64 != (12 * v14) >> 63) {
    goto LABEL_16;
  }
  __int16 v22 = 257;
  uint64_t v23 = sub_1B52A47FC;
  uint64_t v24 = 0;
  char v25 = 1;
  long long v26 = sub_1B52A485C;
  uint64_t v27 = 0;
  uint64_t v28 = v10;
  uint64_t v29 = v11;
  uint64_t v30 = 12 * v14;
  char v31 = 2;
  uint64_t v32 = 0;
  char v33 = 1;
  sub_1B51D4BB8(v12, v13);
  sub_1B51D4C10();
  v21[0] = sub_1B53724D8();
  v21[1] = v16;
  v21[2] = v17;
  uint64_t v18 = sub_1B51D2BC4(v21, v16);
  unsigned int v20 = v19;
  swift_bridgeObjectRelease();
  sub_1B52A9638(v6);
  uint64_t result = 0;
  if (v18 <= a1 && HIDWORD(v18) >= a1) {
    return v20;
  }
  return result;
}

uint64_t *sub_1B52A37B4@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *result;
  if (*result >= 262) {
    uint64_t v2 = 262;
  }
  BOOL v3 = __OFSUB__(v2, 4);
  uint64_t v4 = v2 - 4;
  if (v3) {
    __break(1u);
  }
  else {
    *a2 = v4;
  }
  return result;
}

unint64_t sub_1B52A37D8(unsigned __int16 a1, uint64_t a2, unsigned __int16 a3, Swift::UInt16 encoding)
{
  Swift::UInt16 v5 = encoding;
  unsigned __int16 v8 = a1;
  int v9 = a1 - 1;
  if (!a1) {
    int v9 = 0;
  }
  int v10 = v9 | ((a1 == 0) << 16);
  v11.value = Platform.interpret(encoding:language:)(encoding, (Swift::UInt16_optional)v10).value;
  if (v11.value == FontParser_Encoding_unknownDefault)
  {
    sub_1B51DD5FC();
    swift_allocError();
    *uint64_t v12 = 17;
    return swift_willThrow();
  }
  unint64_t result = sub_1B51D837C(v11.value);
  if (!v4)
  {
    uint64_t v14 = result;
    uint64_t v39 = (void *)sub_1B523861C(MEMORY[0x1E4FBC860]);
    __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D49008);
    sub_1B5372588();
    uint64_t v15 = *(void *)(v14 + 16);
    if (!v15 || (uint64_t v38 = *(void *)(a2 + 16)) == 0)
    {
LABEL_26:
      swift_bridgeObjectRelease();
      return a3 | ((unint64_t)v5 << 16) | ((unint64_t)v8 << 32);
    }
    unsigned __int16 v35 = a3;
    unsigned __int16 v40 = v8;
    Swift::UInt16 v36 = v5;
    unsigned int v16 = *(_DWORD *)(v14 + 32);
    swift_bridgeObjectRetain();
    uint64_t v17 = 0;
    uint64_t v37 = v14 + 36;
    while (1)
    {
      int v18 = *(unsigned __int8 *)(a2 + v17 + 32);
      if (!*(unsigned char *)(a2 + v17 + 32)) {
        goto LABEL_22;
      }
      uint64_t v19 = a2;
      uint64_t v20 = v14;
      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      unint64_t v23 = sub_1B52308DC(v16);
      uint64_t v24 = v39[2];
      BOOL v25 = (v22 & 1) == 0;
      uint64_t v26 = v24 + v25;
      if (__OFADD__(v24, v25)) {
        goto LABEL_28;
      }
      char v27 = v22;
      if (v39[3] >= v26)
      {
        if (isUniquelyReferenced_nonNull_native)
        {
          if ((v22 & 1) == 0) {
            goto LABEL_19;
          }
        }
        else
        {
          sub_1B523718C();
          if ((v27 & 1) == 0) {
            goto LABEL_19;
          }
        }
      }
      else
      {
        sub_1B5232F44(v26, isUniquelyReferenced_nonNull_native);
        unint64_t v28 = sub_1B52308DC(v16);
        if ((v27 & 1) != (v29 & 1)) {
          goto LABEL_30;
        }
        unint64_t v23 = v28;
        if ((v27 & 1) == 0)
        {
LABEL_19:
          v39[(v23 >> 6) + 8] |= 1 << v23;
          uint64_t v30 = 4 * v23;
          *(_DWORD *)(v39[6] + v30) = v16;
          *(_DWORD *)(v39[7] + v30) = v18;
          uint64_t v31 = v39[2];
          BOOL v32 = __OFADD__(v31, 1);
          uint64_t v33 = v31 + 1;
          if (v32) {
            goto LABEL_29;
          }
          v39[2] = v33;
          goto LABEL_21;
        }
      }
      *(_DWORD *)(v39[7] + 4 * v23) = v18;
LABEL_21:
      swift_bridgeObjectRelease();
      uint64_t v14 = v20;
      a2 = v19;
LABEL_22:
      if (v15 - 1 == v17) {
        goto LABEL_25;
      }
      uint64_t v34 = v17 + 1;
      if ((unint64_t)(v17 + 1) >= *(void *)(v14 + 16))
      {
        __break(1u);
LABEL_28:
        __break(1u);
LABEL_29:
        __break(1u);
LABEL_30:
        unint64_t result = sub_1B5373288();
        __break(1u);
        return result;
      }
      unsigned int v16 = *(_DWORD *)(v37 + 4 * v17++);
      if (v38 == v34)
      {
LABEL_25:
        swift_bridgeObjectRelease();
        a3 = v35;
        Swift::UInt16 v5 = v36;
        unsigned __int16 v8 = v40;
        goto LABEL_26;
      }
    }
  }
  return result;
}

uint64_t sub_1B52A3A9C(uint64_t a1, uint64_t a2)
{
  swift_bridgeObjectRetain();
  int v18 = (char *)sub_1B521CC60(a2);
  sub_1B52A27CC(&v18);
  swift_bridgeObjectRelease();
  uint64_t v3 = *((void *)v18 + 2);
  if (!v3)
  {
    Swift::UInt16 v5 = (char *)MEMORY[0x1E4FBC860];
LABEL_19:
    swift_release();
    return (uint64_t)v5;
  }
  uint64_t v4 = v18 + 32;
  Swift::UInt16 v5 = (char *)MEMORY[0x1E4FBC860];
  while (1)
  {
    unsigned int v9 = *(_DWORD *)v4;
    v4 += 4;
    unsigned int v8 = v9;
    unint64_t v10 = *((void *)v5 + 2);
    if (!v10)
    {
LABEL_14:
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
        Swift::UInt16 v5 = sub_1B51E9110(0, v10 + 1, 1, v5);
      }
      unint64_t v16 = *((void *)v5 + 2);
      unint64_t v15 = *((void *)v5 + 3);
      if (v16 >= v15 >> 1) {
        Swift::UInt16 v5 = sub_1B51E9110((char *)(v15 > 1), v16 + 1, 1, v5);
      }
      *((void *)v5 + 2) = v16 + 1;
      uint64_t v6 = &v5[8 * v16];
      *((_DWORD *)v6 + 8) = v8;
      uint64_t v7 = v6 + 36;
      goto LABEL_4;
    }
    unint64_t v11 = v10 - 1;
    unsigned int v12 = *(_DWORD *)&v5[8 * v10 + 28];
    BOOL v13 = v8 >= v12;
    unsigned int v14 = v8 - v12;
    if (!v13) {
      break;
    }
    if (v14 != 1) {
      goto LABEL_14;
    }
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
      Swift::UInt16 v5 = sub_1B52935C4((uint64_t)v5);
    }
    if (v10 > *((void *)v5 + 2)) {
      goto LABEL_20;
    }
    if (v8 < *(_DWORD *)&v5[8 * v11 + 32]) {
      goto LABEL_21;
    }
    uint64_t v7 = &v5[8 * v11 + 36];
LABEL_4:
    *(_DWORD *)uint64_t v7 = v8;
    if (!--v3) {
      goto LABEL_19;
    }
  }
  __break(1u);
LABEL_20:
  __break(1u);
LABEL_21:
  __break(1u);
  uint64_t result = swift_release();
  __break(1u);
  return result;
}

uint64_t sub_1B52A3C34()
{
  return *v0;
}

uint64_t sub_1B52A3C3C()
{
  return *(unsigned __int16 *)(v0 + 2);
}

uint64_t sub_1B52A3C44()
{
  return *(unsigned __int16 *)(v0 + 4);
}

uint64_t sub_1B52A3C4C(uint64_t a1)
{
  return sub_1B52A3A9C(a1, *(void *)(v1 + 8));
}

uint64_t sub_1B52A3C54(unsigned int a1)
{
  uint64_t v2 = *(void *)(v1 + 8);
  if (*(void *)(v2 + 16) && (unint64_t v3 = sub_1B52308DC(a1), (v4 & 1) != 0)) {
    return *(unsigned int *)(*(void *)(v2 + 56) + 4 * v3);
  }
  else {
    return 0;
  }
}

void *sub_1B52A3CA0@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (__OFSUB__(*result, 4)) {
    __break(1u);
  }
  else {
    *a2 = *result - 4;
  }
  return result;
}

uint64_t sub_1B52A3CB8@<X0>(__int16 a1@<W0>, uint64_t a2@<X1>, __int16 a3@<W2>, __int16 a4@<W3>, unsigned char *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v21 = a6;
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D49010);
  uint64_t v12 = v11 - 8;
  MEMORY[0x1F4188790](v11);
  unsigned int v14 = (char *)&v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A60);
  uint64_t v16 = *(void *)(v15 - 8);
  MEMORY[0x1F4188790](v15);
  int v18 = (char *)&v20 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  LOBYTE(a5) = *a5;
  sub_1B53724E8();
  (*(void (**)(char *, char *, uint64_t))(v16 + 16))(&v14[*(int *)(v12 + 60)], v18, v15);
  *(_WORD *)unsigned int v14 = a3;
  *((_WORD *)v14 + 1) = a4;
  *((_WORD *)v14 + 2) = a1;
  v14[6] = (char)a5;
  v14[7] = (char)a5;
  v14[8] = (char)a5;
  *((void *)v14 + 2) = a2;
  v14[24] = 1;
  *((void *)v14 + 4) = a2;
  *((void *)v14 + 5) = a2;
  *((void *)v14 + 6) = a2;
  (*(void (**)(char *, uint64_t))(v16 + 8))(v18, v15);
  return sub_1B52A87D0((uint64_t)v14, v21);
}

uint64_t sub_1B52A3E60@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int16 v2 = *(_WORD *)(a1 + 4);
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 72);
  uint64_t v6 = *(void *)(a1 + 96);
  uint64_t v7 = *(void *)(a1 + 120);
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_WORD *)(a2 + 4) = v2;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = v3;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  *(void *)(a2 + 48) = v4;
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 56);
  *(void *)(a2 + 72) = v5;
  *(_OWORD *)(a2 + 80) = *(_OWORD *)(a1 + 80);
  *(void *)(a2 + 96) = v6;
  *(_OWORD *)(a2 + 104) = *(_OWORD *)(a1 + 104);
  *(void *)(a2 + 120) = v7;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return swift_bridgeObjectRetain();
}

uint64_t sub_1B52A3F0C(uint64_t a1)
{
  if (a1 + 0x4000000000000000 < 0)
  {
    __break(1u);
    swift_unexpectedError();
    __break(1u);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t result = swift_unexpectedError();
    __break(1u);
  }
  else
  {
    uint64_t v15 = sub_1B53724C8();
    uint64_t v16 = v2;
    uint64_t v17 = v3;
    swift_bridgeObjectRetain();
    sub_1B51F3E0C(&v15, v4, 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v15 = sub_1B53724C8();
    uint64_t v16 = v5;
    uint64_t v17 = v6;
    swift_bridgeObjectRetain();
    sub_1B51F3E0C(&v15, v7, 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v15 = sub_1B53724C8();
    uint64_t v16 = v8;
    uint64_t v17 = v9;
    swift_bridgeObjectRetain();
    sub_1B51F3E0C(&v15, v10, 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v15 = sub_1B53724C8();
    uint64_t v16 = v11;
    uint64_t v17 = v12;
    swift_bridgeObjectRetain();
    sub_1B51F3E0C(&v15, v13, 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return a1;
  }
  return result;
}

uint64_t sub_1B52A4164(uint64_t a1, uint64_t a2, char a3)
{
  unsigned int v4 = a1;
  uint64_t result = sub_1B52A30B8(a1, a2, a3 & 1);
  if (v6)
  {
    if (v4 <= 0xFF
      && *v3 == 3
      && (int v7 = (unsigned __int16)v3[2],
          Platform.interpret(encoding:language:)(v3[1], (Swift::UInt16_optional)v7).value == FontParser_Encoding_symbol))
    {
      LODWORD(result) = sub_1B52A30B8(v4 + 61440, 0, 1);
      if (v8) {
        return 0;
      }
      else {
        return result;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1B52A4208(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = result - a3;
  if (result < a3)
  {
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v7 = *(void *)(v5 + 8);
  uint64_t v8 = *(void *)(v5 + 16);
  BOOL v9 = __OFSUB__(v8, v7);
  uint64_t v10 = v8 - v7;
  if (v9)
  {
LABEL_9:
    __break(1u);
    goto LABEL_10;
  }
  uint64_t v11 = v10 / 2;
  BOOL v9 = __OFSUB__(v11, a2);
  uint64_t v12 = v11 - a2;
  if (v9)
  {
LABEL_10:
    __break(1u);
    goto LABEL_11;
  }
  BOOL v9 = __OFSUB__(v6, v12);
  uint64_t v13 = v6 - v12;
  if (v9)
  {
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }
  if (v13 + 0x4000000000000000 < 0)
  {
LABEL_12:
    __break(1u);
    goto LABEL_13;
  }
  uint64_t result = a5 + 2 * v13;
  if (!__OFADD__(a5, 2 * v13))
  {
    v18[0] = sub_1B53724C8();
    v18[1] = v14;
    v18[2] = v15;
    swift_bridgeObjectRetain();
    unsigned __int16 v17 = (unsigned __int16)sub_1B51F3E0C(v18, v16, 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    LOBYTE(v18[0]) = 0;
    return v17;
  }
LABEL_13:
  __break(1u);
  return result;
}

void sub_1B52A4318(uint64_t *a1@<X8>)
{
  uint64_t v2 = *(void *)(v1 + 8);
  uint64_t v3 = *(void *)(v1 + 16);
  BOOL v4 = __OFSUB__(v3, v2);
  uint64_t v5 = v3 - v2;
  if (v4) {
    __break(1u);
  }
  else {
    *a1 = v5 / 2;
  }
}

void (*sub_1B52A433C(void *a1, uint64_t *a2))(void **a1)
{
  uint64_t v5 = malloc(0xA0uLL);
  *a1 = v5;
  uint64_t v6 = *a2;
  long long v7 = v2[5];
  v5[4] = v2[4];
  v5[5] = v7;
  long long v8 = v2[7];
  v5[6] = v2[6];
  v5[7] = v8;
  long long v9 = v2[1];
  *uint64_t v5 = *v2;
  v5[1] = v9;
  long long v10 = v2[3];
  void v5[2] = v2[2];
  v5[3] = v10;
  *((void *)v5 + 16) = sub_1B52A3F0C(v6);
  v5 += 8;
  *((_DWORD *)v5 + 2) = v11;
  *((_DWORD *)v5 + 3) = v12;
  *((_DWORD *)v5 + 4) = v13;
  *((void *)v5 + 3) = v14;
  return sub_1B52A43D4;
}

void sub_1B52A43D4(void **a1)
{
}

uint64_t *sub_1B52A43DC@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *result;
  uint64_t v3 = result[1];
  long long v5 = v2[1];
  long long v15 = *v2;
  long long v16 = v5;
  long long v6 = v2[5];
  long long v19 = v2[4];
  long long v20 = v6;
  long long v7 = v2[7];
  long long v21 = v2[6];
  long long v22 = v7;
  long long v8 = v2[3];
  long long v17 = v2[2];
  long long v18 = v8;
  uint64_t v9 = v16 - *((void *)&v15 + 1);
  if (__OFSUB__((void)v16, *((void *)&v15 + 1)))
  {
    __break(1u);
LABEL_10:
    __break(1u);
    goto LABEL_11;
  }
  if (v9 >= 0) {
    uint64_t v10 = v16 - *((void *)&v15 + 1);
  }
  else {
    uint64_t v10 = v9 + 1;
  }
  if (v9 < -1) {
    goto LABEL_10;
  }
  if (v4 < 0)
  {
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }
  if (v10 >> 1 >= v3)
  {
    long long v11 = v2[5];
    *(_OWORD *)(a2 + 80) = v2[4];
    *(_OWORD *)(a2 + 96) = v11;
    long long v12 = v2[7];
    *(_OWORD *)(a2 + 112) = v2[6];
    *(_OWORD *)(a2 + 128) = v12;
    long long v13 = v2[1];
    *(_OWORD *)(a2 + 16) = *v2;
    *(_OWORD *)(a2 + 32) = v13;
    long long v14 = v2[3];
    *(_OWORD *)(a2 + 48) = v2[2];
    *(_OWORD *)(a2 + 64) = v14;
    *(void *)a2 = v4;
    *(void *)(a2 + 8) = v3;
    return (uint64_t *)sub_1B5221874((uint64_t)&v15);
  }
LABEL_12:
  __break(1u);
  return result;
}

uint64_t sub_1B52A4484@<X0>(uint64_t a1@<X8>)
{
  long long v3 = v1[5];
  long long v14 = v1[4];
  long long v2 = v14;
  long long v15 = v3;
  long long v5 = v1[7];
  long long v16 = v1[6];
  long long v4 = v16;
  long long v17 = v5;
  long long v6 = v1[1];
  long long v10 = *v1;
  long long v11 = v6;
  long long v8 = v1[3];
  long long v12 = v1[2];
  long long v7 = v12;
  long long v13 = v8;
  *(_OWORD *)a1 = v10;
  *(_OWORD *)(a1 + 16) = v6;
  *(_OWORD *)(a1 + 32) = v7;
  *(_OWORD *)(a1 + 48) = v8;
  *(_OWORD *)(a1 + 64) = v2;
  *(_OWORD *)(a1 + 80) = v3;
  *(_OWORD *)(a1 + 96) = v4;
  *(_OWORD *)(a1 + 112) = v5;
  *(void *)(a1 + 128) = 0;
  if (__OFSUB__((void)v11, *((void *)&v10 + 1)))
  {
    __break(1u);
  }
  else
  {
    *(void *)(a1 + 136) = ((void)v11 - *((void *)&v10 + 1)) / 2;
    return sub_1B5221874((uint64_t)&v10);
  }
  return result;
}

BOOL sub_1B52A44FC()
{
  uint64_t v1 = *(void *)(v0 + 8);
  uint64_t v2 = *(void *)(v0 + 16);
  BOOL v3 = __OFSUB__(v2, v1);
  uint64_t v4 = v2 - v1;
  if (!v3) {
    return (unint64_t)(v4 + 1) < 3;
  }
  __break(1u);
  return result;
}

uint64_t *sub_1B52A4520@<X0>(uint64_t *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if ((a2 & 0x8000000000000000) == 0)
  {
    uint64_t v3 = *result;
    if (!a2)
    {
LABEL_6:
      *a3 = v3;
      return result;
    }
    unint64_t v4 = v3 ^ 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v5 = a2 - 1;
    while (v4 > v5)
    {
      ++v3;
      if (!--a2) {
        goto LABEL_6;
      }
    }
    __break(1u);
  }
  __break(1u);
  return result;
}

uint64_t sub_1B52A4558@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = sub_1B52A9668(*a1, a2, *a3);
  *(void *)a4 = result;
  *(unsigned char *)(a4 + 8) = v6 & 1;
  return result;
}

uint64_t *sub_1B52A4590(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = *a2;
  if (*a2 < *result)
  {
LABEL_10:
    __break(1u);
    goto LABEL_11;
  }
  if (*a2 == *result) {
    return 0;
  }
  unint64_t v4 = (uint64_t *)(v3 - v2);
  if (v3 > v2)
  {
    uint64_t result = 0;
    unint64_t v5 = v3 + ~v2;
    while (v5 <= 0x7FFFFFFFFFFFFFFELL)
    {
      uint64_t result = (uint64_t *)((char *)result + 1);
      if (v4 == result) {
        return result;
      }
    }
    __break(1u);
    goto LABEL_10;
  }
LABEL_11:
  __break(1u);
  return result;
}

uint64_t *sub_1B52A45E8(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = a2[1];
  if (*result >= *a2)
  {
    BOOL v5 = __OFSUB__(v2, v3);
    BOOL v4 = v2 - v3 < 0;
  }
  else
  {
    BOOL v5 = 0;
    BOOL v4 = 0;
  }
  if (v4 == v5) {
    __break(1u);
  }
  return result;
}

void *sub_1B52A4604(void *result, void *a2)
{
  if (*result < *a2 || a2[1] < *result) {
    __break(1u);
  }
  return result;
}

void *sub_1B52A4620(void *result, void *a2)
{
  if (*result < *a2 || a2[1] < result[1]) {
    __break(1u);
  }
  return result;
}

void sub_1B52A463C()
{
}

uint64_t sub_1B52A4688(uint64_t a1, uint64_t a2, char a3)
{
  return sub_1B52A4164(a1, a2, a3 & 1);
}

__n128 sub_1B52A46DC@<Q0>(uint64_t a1@<X8>)
{
  long long v2 = *(_OWORD *)(v1 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(v1 + 64);
  *(_OWORD *)(a1 + 80) = v2;
  long long v3 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v3;
  long long v4 = *(_OWORD *)(v1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v1;
  *(_OWORD *)(a1 + 16) = v4;
  __n128 result = *(__n128 *)(v1 + 32);
  long long v6 = *(_OWORD *)(v1 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v6;
  *(void *)(a1 + 128) = 0;
  return result;
}

uint64_t sub_1B52A4704()
{
  uint64_t v1 = *(void *)(v0 + 8);
  uint64_t v2 = *(void *)(v0 + 16);
  BOOL v3 = __OFSUB__(v2, v1);
  uint64_t v4 = v2 - v1;
  if (v3)
  {
    __break(1u);
    goto LABEL_10;
  }
  if (v4 < -1)
  {
LABEL_10:
    __break(1u);
    return result;
  }
  if (v4 >= 0) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v4 + 1;
  }
  uint64_t v6 = v5 >> 1;
  if ((unint64_t)(v4 + 1) >= 3) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t sub_1B52A473C()
{
  long long v1 = v0[5];
  v7[4] = v0[4];
  v7[5] = v1;
  long long v2 = v0[7];
  v7[6] = v0[6];
  v7[7] = v2;
  long long v3 = v0[1];
  v7[0] = *v0;
  v7[1] = v3;
  long long v4 = v0[3];
  v7[2] = v0[2];
  v7[3] = v4;
  uint64_t v5 = sub_1B521C770((uint64_t)v7);
  sub_1B5200EB4((uint64_t)v7);
  return v5;
}

uint64_t sub_1B52A4798(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1B527522C(a1, a2, a3);
}

void *sub_1B52A47E4@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (__OFSUB__(*result, 8)) {
    __break(1u);
  }
  else {
    *a2 = *result - 8;
  }
  return result;
}

unsigned int *sub_1B52A47FC@<X0>(unsigned int *result@<X0>, unsigned int *a2@<X8>)
{
  unsigned int v2 = result[1];
  if (v2 >= *result)
  {
    *a2 = *result;
    a2[1] = v2;
  }
  else
  {
    sub_1B51D4F7C();
    swift_allocError();
    return (unsigned int *)swift_willThrow();
  }
  return result;
}

double sub_1B52A485C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v2 = *(_DWORD *)(a1 + 8);
  double result = *(double *)a1;
  *(void *)a2 = *(void *)a1;
  *(_DWORD *)(a2 + 8) = v2;
  return result;
}

uint64_t sub_1B52A4870(uint64_t a1)
{
  if ((unsigned __int128)(a1 * (__int128)12) >> 64 == (12 * a1) >> 63)
  {
    __int16 v7 = 257;
    long long v8 = sub_1B52A47FC;
    uint64_t v9 = 0;
    char v10 = 1;
    long long v11 = sub_1B52A485C;
    uint64_t v12 = 0;
    long long v13 = *(_OWORD *)(v1 + 24);
    uint64_t v14 = 12 * a1;
    char v15 = 2;
    uint64_t v16 = 0;
    char v17 = 1;
    sub_1B52218E0(v1);
    sub_1B51D4C10();
    v6[0] = sub_1B53724D8();
    v6[1] = v2;
    v6[2] = v3;
    uint64_t v4 = sub_1B51D2BC4(v6, v2);
    swift_bridgeObjectRelease();
    return v4;
  }
  else
  {
    __break(1u);
    swift_bridgeObjectRelease();
    uint64_t result = swift_unexpectedError();
    __break(1u);
  }
  return result;
}

void sub_1B52A4994(void *a1@<X8>)
{
  *a1 = *(void *)(v1 + 16);
}

void (*sub_1B52A49A0(void *a1, uint64_t *a2))(void **a1)
{
  uint64_t v5 = malloc(0x44uLL);
  *a1 = v5;
  uint64_t v6 = *a2;
  long long v7 = *(_OWORD *)(v2 + 16);
  *uint64_t v5 = *(_OWORD *)v2;
  v5[1] = v7;
  void v5[2] = *(_OWORD *)(v2 + 32);
  *((void *)v5 + 6) = *(void *)(v2 + 48);
  *((void *)v5 + 7) = sub_1B52A4870(v6);
  *((_DWORD *)v5 + 16) = v8;
  return sub_1B52A43D4;
}

uint64_t *sub_1B52A4A28@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  long long v3 = *((_OWORD *)v2 + 1);
  uint64_t v4 = v2[2];
  if (v4 < 0)
  {
    __break(1u);
    goto LABEL_6;
  }
  uint64_t v5 = *result;
  if (*result < 0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }
  uint64_t v6 = result[1];
  if (v4 >= v6)
  {
    uint64_t v7 = *v2;
    __int16 v8 = *((_WORD *)v2 + 4);
    uint64_t v10 = v2[4];
    uint64_t v9 = v2[5];
    unint64_t v11 = v2[6];
    *(void *)(a2 + 8) = v6;
    *(void *)(a2 + 16) = v7;
    *(_WORD *)(a2 + 24) = v8;
    *(_OWORD *)(a2 + 32) = v3;
    *(void *)(a2 + 48) = v10;
    *(void *)(a2 + 56) = v9;
    *(void *)(a2 + 64) = v11;
    *(void *)a2 = v5;
    return (uint64_t *)sub_1B51D4BB8(v9, v11);
  }
LABEL_7:
  __break(1u);
  return result;
}

uint64_t sub_1B52A4A80@<X0>(uint64_t a1@<X8>)
{
  __int16 v2 = *(_WORD *)(v1 + 8);
  uint64_t v4 = *(void *)(v1 + 32);
  uint64_t v3 = *(void *)(v1 + 40);
  unint64_t v5 = *(void *)(v1 + 48);
  *(void *)a1 = *(void *)v1;
  *(_WORD *)(a1 + 8) = v2;
  long long v6 = *(_OWORD *)(v1 + 16);
  *(_OWORD *)(a1 + 16) = v6;
  *(void *)(a1 + 32) = v4;
  *(void *)(a1 + 40) = v3;
  *(void *)(a1 + 48) = v5;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = v6;
  return sub_1B51D4BB8(v3, v5);
}

BOOL sub_1B52A4AB0()
{
  return *(void *)(v0 + 16) == 0;
}

__n128 sub_1B52A4AC0@<Q0>(uint64_t a1@<X8>)
{
  __int16 v2 = *(_WORD *)(v1 + 8);
  uint64_t v3 = *(void *)(v1 + 48);
  *(void *)a1 = *(void *)v1;
  *(_WORD *)(a1 + 8) = v2;
  __n128 result = *(__n128 *)(v1 + 16);
  long long v5 = *(_OWORD *)(v1 + 32);
  *(__n128 *)(a1 + 16) = result;
  *(_OWORD *)(a1 + 32) = v5;
  *(void *)(a1 + 48) = v3;
  *(void *)(a1 + 56) = 0;
  return result;
}

uint64_t sub_1B52A4AE4()
{
  uint64_t result = *(void *)(v0 + 16);
  if (result < 0) {
    __break(1u);
  }
  return result;
}

uint64_t sub_1B52A4AF4()
{
  long long v1 = *(_OWORD *)(v0 + 16);
  v4[0] = *(_OWORD *)v0;
  v4[1] = v1;
  v4[2] = *(_OWORD *)(v0 + 32);
  uint64_t v5 = *(void *)(v0 + 48);
  uint64_t v2 = sub_1B521CAAC((uint64_t)v4);
  sub_1B52A9740((uint64_t)v4);
  return v2;
}

uint64_t sub_1B52A4B48(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  return sub_1B5275FC4(a1, a2, a3);
}

uint64_t sub_1B52A4B8C()
{
  return 12;
}

uint64_t sub_1B52A4B94()
{
  return *(unsigned __int16 *)(v0 + 16);
}

uint64_t sub_1B52A4B9C()
{
  return sub_1B52A2CA8((void (*)(uint64_t))sub_1B52A9608, (void (*)())sub_1B52A9638);
}

uint64_t sub_1B52A4C00(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  return sub_1B52A4C9C(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, void))sub_1B52A33B8);
}

uint64_t sub_1B52A4C18()
{
  return 13;
}

uint64_t sub_1B52A4C20()
{
  return sub_1B52A2CA8((void (*)(uint64_t))sub_1B52A9EF0, (void (*)())sub_1B52A9EF4);
}

uint64_t sub_1B52A4C84(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  return sub_1B52A4C9C(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, void))sub_1B52A35B8);
}

uint64_t sub_1B52A4C9C(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, void))
{
  return a6(a1, a2, a3 & 1);
}

uint64_t sub_1B52A4CE4()
{
  uint64_t v1 = MEMORY[0x1E4FBC860];
  uint64_t v52 = MEMORY[0x1E4FBC860];
  uint64_t v34 = *(void *)(v0 + 40);
  if (!v34) {
    return v1;
  }
  uint64_t v2 = v0;
  sub_1B5221844(v0);
  uint64_t v3 = 0;
  uint64_t v33 = v0;
  while (1)
  {
    uint64_t v4 = (uint64_t *)v2;
    sub_1B52A52C4(v3, (uint64_t)&v44);
    if (__OFADD__(v3++, 1))
    {
LABEL_44:
      __break(1u);
LABEL_45:
      __break(1u);
LABEL_46:
      sub_1B51D4D34();
      swift_allocError();
      *unint64_t v28 = 2;
      v28[1] = v4;
      v28[2] = 0xD00000000000001DLL;
      v28[3] = 0x80000001B537BD80;
      v28[4] = 0;
      swift_willThrow();
      goto LABEL_49;
    }
    int64_t v6 = v48;
    if (v48 < 0) {
      goto LABEL_45;
    }
    uint64_t v7 = v49;
    unint64_t v8 = v50;
    if (v48) {
      break;
    }
    sub_1B51D4C64(v46, v47);
    sub_1B51D4C64(v7, v8);
    uint64_t v23 = v1;
LABEL_3:
    sub_1B51D5BE4(v23);
    if (v3 == v34)
    {
      sub_1B52686D8(v2);
      return v52;
    }
  }
  unint64_t v35 = v47;
  uint64_t v36 = v46;
  uint64_t v37 = v3;
  int v9 = v44;
  uint64_t v41 = v51;
  uint64_t v42 = v49;
  uint64_t v43 = v1;
  uint64_t v4 = &v43;
  sub_1B521CF50(0, v48, 0);
  uint64_t v10 = 0;
  BOOL v11 = (v9 & 0xFFFFFFF0) == 65024;
  char v12 = v9 + 16;
  if ((v9 & 0xFFFFFFF0) == 0xFE00) {
    char v12 = v9;
  }
  char v38 = v12;
  if ((v9 - 917760) < 0xF0) {
    BOOL v11 = 1;
  }
  BOOL v40 = v11;
  uint64_t v13 = 0x199999999999999ALL;
  unint64_t v39 = v8;
  while (1)
  {
    if (!v6)
    {
      __break(1u);
LABEL_36:
      __break(1u);
LABEL_37:
      __break(1u);
LABEL_38:
      __break(1u);
LABEL_39:
      __break(1u);
LABEL_40:
      __break(1u);
LABEL_41:
      __break(1u);
LABEL_42:
      __break(1u);
LABEL_43:
      __break(1u);
      goto LABEL_44;
    }
    if (!v13) {
      goto LABEL_36;
    }
    uint64_t v44 = v42;
    int64_t v45 = v8;
    sub_1B51D4BB8(v42, v8);
    sub_1B51D4C10();
    uint64_t v4 = (uint64_t *)sub_1B53724D8();
    if (__OFADD__(v41, v10)) {
      goto LABEL_46;
    }
    uint64_t v14 = sub_1B53724B8();
    uint64_t v17 = v14;
    if (__OFSUB__(v15, v14)) {
      goto LABEL_37;
    }
    if (v15 - v14 <= 2)
    {
      uint64_t v44 = 0;
      int64_t v45 = 0xE000000000000000;
      swift_bridgeObjectRetain_n();
      sub_1B5372F98();
      swift_bridgeObjectRelease();
      uint64_t v44 = 0x6974736575716552;
      int64_t v45 = 0xEB0000000020676ELL;
      sub_1B53731F8();
      sub_1B5372868();
      swift_bridgeObjectRelease();
      sub_1B5372868();
      sub_1B53731F8();
      sub_1B5372868();
      swift_bridgeObjectRelease();
      sub_1B5372868();
      uint64_t v29 = v44;
      int64_t v30 = v45;
      sub_1B51D4D34();
      swift_allocError();
      *uint64_t v31 = 0;
      v31[1] = v17;
      v31[2] = v29;
      v31[3] = v30;
      v31[4] = 0;
      swift_willThrow();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease_n();
      goto LABEL_50;
    }
    uint64_t v44 = v14;
    int64_t v45 = v15;
    uint64_t v46 = v16;
    unsigned int v18 = sub_1B51FAA2C((unint64_t)&v44, 3, 1);
    uint64_t v19 = v44;
    if (__OFSUB__(v45, v44)) {
      goto LABEL_38;
    }
    if (v45 - v44 < 2) {
      break;
    }
    if (v44 > 0x7FFFFFFFFFFFFFFDLL || v45 < v44 + 2) {
      goto LABEL_39;
    }
    if (v44 < 0) {
      goto LABEL_40;
    }
    unint64_t v20 = *(void *)(v46 + 16);
    if (v20 < v44 || v20 < v44 + 2) {
      goto LABEL_41;
    }
    unsigned int v21 = v18;
    uint64_t v4 = (uint64_t *)(v46 + v44);
    swift_bridgeObjectRetain();
    unsigned int v22 = *((unsigned __int16 *)v4 + 16);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    if (HIBYTE(v21)) {
      goto LABEL_42;
    }
    if (!v40) {
      goto LABEL_43;
    }
    uint64_t v23 = v43;
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
    {
      uint64_t v4 = &v43;
      sub_1B521CF50(0, *(void *)(v23 + 16) + 1, 1);
      uint64_t v23 = v43;
    }
    unint64_t v25 = *(void *)(v23 + 16);
    unint64_t v24 = *(void *)(v23 + 24);
    if (v25 >= v24 >> 1)
    {
      uint64_t v4 = &v43;
      sub_1B521CF50((char *)(v24 > 1), v25 + 1, 1);
      uint64_t v23 = v43;
    }
    *(void *)(v23 + 16) = v25 + 1;
    uint64_t v26 = v23 + 16 * v25;
    *(unsigned char *)(v26 + 32) = BYTE2(v21);
    *(unsigned char *)(v26 + 33) = BYTE1(v21);
    *(unsigned char *)(v26 + 34) = v21;
    *(unsigned char *)(v26 + 35) = v38;
    *(unsigned char *)(v26 + 36) = 0;
    v10 += 5;
    --v13;
    *(void *)(v26 + 40) = bswap32(v22) >> 16;
    --v6;
    unint64_t v8 = v39;
    if (!v6)
    {
      sub_1B51D4C64(v36, v35);
      sub_1B51D4C64(v42, v39);
      uint64_t v1 = MEMORY[0x1E4FBC860];
      uint64_t v2 = v33;
      uint64_t v3 = v37;
      goto LABEL_3;
    }
  }
  uint64_t v44 = 0;
  int64_t v45 = 0xE000000000000000;
  swift_bridgeObjectRetain_n();
  sub_1B5372F98();
  swift_bridgeObjectRelease();
  sub_1B51D4D34();
  swift_allocError();
  *BOOL v32 = 0;
  v32[1] = v19;
  v32[2] = 0xD00000000000002BLL;
  v32[3] = 0x80000001B537BD30;
  v32[4] = 0;
  swift_willThrow();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease_n();
LABEL_49:
  swift_bridgeObjectRelease();
LABEL_50:
  uint64_t result = swift_unexpectedError();
  __break(1u);
  return result;
}

uint64_t sub_1B52A52C4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = 11 * a1;
  if ((unsigned __int128)(a1 * (__int128)11) >> 64 == (11 * a1) >> 63)
  {
    unint64_t v6 = v2[1];
    uint64_t v7 = v2[2];
    uint64_t v8 = *v2;
    *((void *)&v25 + 1) = v6;
    sub_1B5221844((uint64_t)v2);
    sub_1B51D4BB8(v8, v6);
    sub_1B51D4C10();
    uint64_t v3 = sub_1B53724D8();
    if (!__OFADD__(v7, v5))
    {
      *(void *)&long long v25 = sub_1B53724B8();
      *((void *)&v25 + 1) = v9;
      *(void *)&long long v26 = v10;
      swift_bridgeObjectRetain_n();
      unsigned int v12 = sub_1B52B3CE0(&v25, 3, 0x10101u, v11);
      uint64_t v14 = v13;
      uint64_t v16 = v15;
      swift_bridgeObjectRelease_n();
      sub_1B5221844((uint64_t)v2);
      sub_1B52A7030(v8, v6, v14, &v25);
      long long v23 = v26;
      long long v24 = v25;
      uint64_t v17 = v27;
      sub_1B5221844((uint64_t)v2);
      sub_1B52A7030(v8, v6, v16, &v25);
      long long v21 = v26;
      long long v22 = v25;
      uint64_t v18 = v27;
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      uint64_t result = sub_1B52686D8((uint64_t)v2);
      *(_DWORD *)a2 = v12;
      *(_OWORD *)(a2 + 8) = v24;
      *(_OWORD *)(a2 + 24) = v23;
      *(void *)(a2 + 40) = v17;
      *(_OWORD *)(a2 + 48) = v22;
      *(_OWORD *)(a2 + 64) = v21;
      *(void *)(a2 + 80) = v18;
      return result;
    }
  }
  else
  {
    __break(1u);
  }
  sub_1B51D4D34();
  swift_allocError();
  *unint64_t v20 = 2;
  v20[1] = v3;
  v20[2] = 0xD00000000000001DLL;
  v20[3] = 0x80000001B537BD80;
  v20[4] = 0;
  swift_willThrow();
  swift_bridgeObjectRelease();
  sub_1B52686D8((uint64_t)v2);
  uint64_t result = swift_unexpectedError();
  __break(1u);
  return result;
}

uint64_t sub_1B52A5520(unsigned int a1, unsigned int a2)
{
  uint64_t v5 = sub_1B5262C60(a2, v2);
  if (v5 == v2[5]) {
    return 0;
  }
  sub_1B52A52C4(v5, (uint64_t)&v19);
  uint64_t v7 = v21;
  unint64_t v6 = v22;
  uint64_t v9 = v26;
  unint64_t v8 = v27;
  if (v19 != a2)
  {
    sub_1B51D4C64((uint64_t)v21, v22);
    sub_1B51D4C64(v9, v8);
    return 0;
  }
  uint64_t v10 = v25;
  uint64_t v11 = v28;
  uint64_t v12 = v29;
  sub_1B51D4BB8((uint64_t)v21, v22);
  sub_1B51D4BB8(v9, v8);
  sub_1B51D4C64(v9, v8);
  sub_1B51D4C64((uint64_t)v7, v6);
  if (v10 < 0)
  {
    __break(1u);
LABEL_14:
    __break(1u);
    swift_bridgeObjectRelease();
    uint64_t result = swift_unexpectedError();
    __break(1u);
    return result;
  }
  v30[0] = 0;
  v30[1] = v10;
  v30[2] = v10;
  v30[3] = v9;
  v30[4] = v8;
  v30[5] = v11;
  v30[6] = v12;
  sub_1B51D4BB8(v9, v8);
  sub_1B51D4BB8(v9, v8);
  uint64_t v13 = sub_1B5261EC8(a1, v30);
  sub_1B51D4C64(v9, v8);
  if (v13 == v10)
  {
    sub_1B51D4C64(v9, v8);
    sub_1B51D4C64((uint64_t)v7, v6);
    sub_1B51D4C64(v9, v8);
    return 0;
  }
  if ((unsigned __int128)(v13 * (__int128)5) >> 64 != (5 * v13) >> 63) {
    goto LABEL_14;
  }
  uint64_t v19 = 3;
  __int16 v20 = 257;
  long long v21 = sub_1B5217CD8;
  unint64_t v22 = 0;
  uint64_t v23 = v11;
  uint64_t v24 = v12;
  uint64_t v25 = 5 * v13;
  LOBYTE(v26) = 2;
  unint64_t v27 = 0;
  LOBYTE(v28) = 1;
  sub_1B51D4BB8(v9, v8);
  sub_1B51D4C10();
  v18[0] = sub_1B53724D8();
  v18[1] = v15;
  v18[2] = v16;
  uint64_t v17 = sub_1B51D26C8(v18, v15);
  swift_bridgeObjectRelease();
  sub_1B51D4C64(v9, v8);
  sub_1B51D4C64((uint64_t)v7, v6);
  sub_1B51D4C64(v9, v8);
  if (v17 == a1) {
    return WORD2(v17);
  }
  else {
    return 0;
  }
}

void sub_1B52A5798(void *a1@<X8>)
{
  *a1 = *(void *)(v1 + 40);
}

void (*sub_1B52A57A4(void *a1, uint64_t *a2))(uint64_t a1)
{
  uint64_t v5 = (char *)malloc(0x88uLL);
  *a1 = v5;
  uint64_t v6 = *a2;
  long long v7 = v2[1];
  *(_OWORD *)(v5 + 88) = *v2;
  *(_OWORD *)(v5 + 104) = v7;
  *(_OWORD *)(v5 + 120) = v2[2];
  sub_1B52A52C4(v6, (uint64_t)&v14);
  long long v8 = v15;
  long long v9 = v16;
  long long v10 = v17;
  long long v11 = v18;
  long long v12 = v19;
  *(_DWORD *)uint64_t v5 = v14;
  *(_OWORD *)(v5 + 8) = v8;
  *(_OWORD *)(v5 + 24) = v9;
  *(_OWORD *)(v5 + 40) = v10;
  *(_OWORD *)(v5 + 56) = v11;
  *(_OWORD *)(v5 + 72) = v12;
  return sub_1B52A5854;
}

void sub_1B52A5854(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void *)(*(void *)a1 + 56);
  unint64_t v3 = *(void *)(*(void *)a1 + 64);
  sub_1B51D4C64(*(void *)(*(void *)a1 + 16), *(void *)(*(void *)a1 + 24));
  sub_1B51D4C64(v2, v3);
  free(v1);
}

uint64_t *sub_1B52A58A8@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(v2 + 40);
  if (v3 < 0)
  {
    __break(1u);
    goto LABEL_6;
  }
  uint64_t v4 = *result;
  if (*result < 0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }
  uint64_t v5 = result[1];
  if (v3 >= v5)
  {
    uint64_t v6 = *(void *)v2;
    long long v7 = *(_OWORD *)(v2 + 8);
    long long v8 = *(_OWORD *)(v2 + 24);
    *(void *)(a2 + 8) = v5;
    *(void *)(a2 + 16) = v6;
    *(_OWORD *)(a2 + 24) = v7;
    *(_OWORD *)(a2 + 40) = v8;
    *(void *)(a2 + 56) = v3;
    *(void *)a2 = v4;
    return (uint64_t *)sub_1B51D4BB8(v6, v7);
  }
LABEL_7:
  __break(1u);
  return result;
}

uint64_t sub_1B52A58F8@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(v1 + 40);
  *(void *)a1 = *(void *)v1;
  long long v4 = *(_OWORD *)(v1 + 8);
  *(_OWORD *)(a1 + 8) = v4;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(v1 + 24);
  *(void *)(a1 + 40) = v3;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = v3;
  return sub_1B51D4BB8(v2, v4);
}

BOOL sub_1B52A5924()
{
  return *(void *)(v0 + 40) == 0;
}

uint64_t sub_1B52A5934()
{
  return sub_1B52A4CE4();
}

uint64_t sub_1B52A5970(unsigned int a1, unsigned int a2)
{
  return sub_1B52A5520(a1, a2);
}

__n128 sub_1B52A59B0@<Q0>(uint64_t a1@<X8>)
{
  long long v2 = *(_OWORD *)(v1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v1;
  *(_OWORD *)(a1 + 16) = v2;
  __n128 result = *(__n128 *)(v1 + 32);
  *(__n128 *)(a1 + 32) = result;
  *(void *)(a1 + 48) = 0;
  return result;
}

uint64_t sub_1B52A59C8()
{
  uint64_t result = *(void *)(v0 + 40);
  if (result < 0) {
    __break(1u);
  }
  return result;
}

void *sub_1B52A59D8()
{
  long long v1 = v0[1];
  v4[0] = *v0;
  v4[1] = v1;
  v4[2] = v0[2];
  long long v2 = sub_1B521C9DC(v4);
  sub_1B52686D8((uint64_t)v4);
  return v2;
}

uint64_t sub_1B52A5A24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1B5275B8C(a1, a2, a3);
}

unint64_t sub_1B52A5A60(uint64_t a1)
{
  if ((unint64_t)(a1 - 0x2000000000000000) >> 62 == 3)
  {
    v13[4] = 3;
    __int16 v14 = 257;
    long long v15 = *(_OWORD *)(v1 + 24);
    uint64_t v16 = 4 * a1;
    char v17 = 2;
    uint64_t v18 = 0;
    char v19 = 1;
    sub_1B5221910(v1);
    sub_1B51D4C10();
    uint64_t v2 = sub_1B53724D8();
    v13[0] = v2;
    v13[1] = v3;
    _OWORD v13[2] = v4;
    swift_bridgeObjectRetain_n();
    uint64_t v6 = sub_1B51D2930(v13, v5);
    unsigned int v7 = v6;
    unsigned int v8 = v6 + HIDWORD(v6);
    if (!__CFADD__(v6, HIDWORD(v6)))
    {
      swift_bridgeObjectRelease_n();
      return v7 | ((unint64_t)v8 << 32);
    }
    sub_1B51D4F28();
    long long v10 = (void *)swift_allocError();
    swift_willThrow();
    sub_1B51D4D34();
    swift_allocError();
    *long long v11 = v10;
    v11[1] = v2;
    _OWORD v11[2] = 0x7272652072657355;
    v11[3] = 0xEA0000000000726FLL;
    v11[4] = v10;
    id v12 = v10;
    swift_willThrow();
  }
  else
  {
    __break(1u);
  }
  swift_bridgeObjectRelease_n();
  swift_bridgeObjectRelease();
  unint64_t result = swift_unexpectedError();
  __break(1u);
  return result;
}

void sub_1B52A5C10(void *a1@<X8>)
{
  *a1 = *v1;
}

void (*sub_1B52A5C1C(void *a1, uint64_t *a2))(void **a1)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  uint64_t v6 = *a2;
  long long v7 = *(_OWORD *)(v2 + 16);
  *uint64_t v5 = *(_OWORD *)v2;
  v5[1] = v7;
  *((void *)v5 + 4) = *(void *)(v2 + 32);
  *((void *)v5 + 5) = sub_1B52A5A60(v6);
  return sub_1B52A43D4;
}

BOOL sub_1B52A5C9C()
{
  return *v0 == 0;
}

__n128 sub_1B52A5CC4@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v2 = *(void *)(v1 + 32);
  __n128 result = *(__n128 *)v1;
  long long v4 = *(_OWORD *)(v1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v1;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = v2;
  *(void *)(a1 + 40) = 0;
  return result;
}

uint64_t sub_1B52A5CD8(uint64_t a1, uint64_t a2)
{
  return sub_1B52A6024(a1, a2, (uint64_t (*)(_OWORD *))sub_1B521C910, (void (*)(_OWORD *))sub_1B52A9E40);
}

uint64_t sub_1B52A5D04(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  return sub_1B5275824(a1, a2, a3);
}

uint64_t sub_1B52A5D40(uint64_t a1)
{
  if ((unsigned __int128)(a1 * (__int128)5) >> 64 == (5 * a1) >> 63)
  {
    uint64_t v6[4] = 3;
    __int16 v7 = 257;
    unsigned int v8 = sub_1B5217CD8;
    uint64_t v9 = 0;
    long long v10 = *(_OWORD *)(v1 + 24);
    uint64_t v11 = 5 * a1;
    char v12 = 2;
    uint64_t v13 = 0;
    char v14 = 1;
    sub_1B5221910(v1);
    sub_1B51D4C10();
    v6[0] = sub_1B53724D8();
    v6[1] = v2;
    v6[2] = v3;
    uint64_t v4 = sub_1B51D26C8(v6, v2);
    swift_bridgeObjectRelease();
    return v4 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    __break(1u);
    swift_bridgeObjectRelease();
    uint64_t result = swift_unexpectedError();
    __break(1u);
  }
  return result;
}

void (*sub_1B52A5E48(void *a1, uint64_t *a2))(void **a1)
{
  uint64_t v5 = malloc(0x2EuLL);
  *a1 = v5;
  uint64_t v6 = *a2;
  long long v7 = *(_OWORD *)(v2 + 16);
  *uint64_t v5 = *(_OWORD *)v2;
  v5[1] = v7;
  *((void *)v5 + 4) = *(void *)(v2 + 32);
  uint64_t v8 = sub_1B52A5D40(v6);
  *((_DWORD *)v5 + 10) = v8;
  *((_WORD *)v5 + 22) = WORD2(v8);
  return sub_1B52A43D4;
}

uint64_t *sub_1B52A5EC8@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *v2;
  if (*v2 < 0)
  {
    __break(1u);
    goto LABEL_6;
  }
  uint64_t v4 = *result;
  if (*result < 0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }
  uint64_t v5 = result[1];
  if (v3 >= v5)
  {
    uint64_t v6 = v2[1];
    long long v7 = *((_OWORD *)v2 + 1);
    uint64_t v8 = v2[4];
    *(void *)(a2 + 16) = v3;
    *(void *)(a2 + 24) = v6;
    *(_OWORD *)(a2 + 32) = v7;
    *(void *)(a2 + 48) = v8;
    *(void *)a2 = v4;
    *(void *)(a2 + 8) = v5;
    return (uint64_t *)sub_1B51D4BB8(v6, v7);
  }
LABEL_7:
  __break(1u);
  return result;
}

uint64_t sub_1B52A5F14@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v4 = v1[4];
  *(void *)a1 = *v1;
  *(void *)(a1 + 8) = v2;
  long long v5 = *((_OWORD *)v1 + 1);
  *(_OWORD *)(a1 + 16) = v5;
  *(void *)(a1 + 32) = v4;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = v3;
  return sub_1B51D4BB8(v2, v5);
}

uint64_t sub_1B52A5F38()
{
  return 14;
}

uint64_t sub_1B52A5F40()
{
  *(Swift::UInt16_optional *)&uint64_t result = Platform.rawValue(encoding:)(FontParser_Encoding_unicodeVariationSequences);
  if ((result & 0x10000) != 0) {
    __break(1u);
  }
  return result;
}

uint64_t sub_1B52A5F68()
{
  return sub_1B52A2838();
}

uint64_t sub_1B52A5FA4(unsigned int a1, uint64_t a2, char a3)
{
  return sub_1B52A3208(a1, a2, a3 & 1);
}

uint64_t sub_1B52A5FE8()
{
  uint64_t result = *v0;
  if (*v0 < 0) {
    __break(1u);
  }
  return result;
}

uint64_t sub_1B52A5FF8(uint64_t a1, uint64_t a2)
{
  return sub_1B52A6024(a1, a2, (uint64_t (*)(_OWORD *))sub_1B521C854, (void (*)(_OWORD *))sub_1B52A9EF8);
}

uint64_t sub_1B52A6024(uint64_t a1, uint64_t a2, uint64_t (*a3)(_OWORD *), void (*a4)(_OWORD *))
{
  long long v6 = *(_OWORD *)(v4 + 16);
  v9[0] = *(_OWORD *)v4;
  v9[1] = v6;
  uint64_t v10 = *(void *)(v4 + 32);
  uint64_t v7 = a3(v9);
  a4(v9);
  return v7;
}

uint64_t sub_1B52A607C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1B5275584(a1, a2, a3);
}

uint64_t sub_1B52A60B8(void *a1)
{
  uint64_t v2 = a1;
  uint64_t v3 = a1[1];
  uint64_t result = sub_1B53731D8();
  if (result >= v3)
  {
    if (v3 < 0) {
      goto LABEL_138;
    }
    if ((unint64_t)v3 >= 2)
    {
      uint64_t v76 = 0;
      uint64_t v77 = *v2;
      for (uint64_t i = 1; i != v3; ++i)
      {
        unsigned int v79 = *(_DWORD *)(v77 + 4 * i);
        uint64_t v80 = v76;
        do
        {
          unsigned int v81 = *(_DWORD *)(v77 + v80);
          if (v79 >= v81) {
            break;
          }
          if (!v77) {
            goto LABEL_142;
          }
          *(_DWORD *)(v77 + v80 + 4) = v81;
          *(_DWORD *)(v77 + v80) = v79;
          v80 -= 4;
        }
        while (v80 != -4);
        v76 += 4;
      }
    }
  }
  else
  {
    if (v3 >= 0) {
      uint64_t v5 = v3;
    }
    else {
      uint64_t v5 = v3 + 1;
    }
    if (v3 < -1) {
      goto LABEL_137;
    }
    uint64_t v93 = result;
    uint64_t v94 = v3;
    if (v3 > 1)
    {
      uint64_t v6 = v5 >> 1;
      uint64_t result = sub_1B5372A88();
      *(void *)(result + 16) = v6;
      uint64_t v3 = v94;
      uint64_t v92 = result;
      uint64_t v96 = (char *)(result + 32);
LABEL_13:
      uint64_t v8 = 0;
      uint64_t v9 = *v2;
      uint64_t v90 = v2;
      uint64_t v91 = *v2 - 4;
      uint64_t v10 = MEMORY[0x1E4FBC860];
      uint64_t v95 = *v2;
      while (1)
      {
        uint64_t v12 = v8++;
        if (v8 < v3)
        {
          unsigned int v13 = *(_DWORD *)(v9 + 4 * v8);
          unsigned int v14 = *(_DWORD *)(v9 + 4 * v12);
          uint64_t v8 = v12 + 2;
          if (v12 + 2 < v3)
          {
            unsigned int v15 = v13;
            while (1)
            {
              unsigned int v16 = *(_DWORD *)(v9 + 4 * v8);
              if (v13 < v14 == v16 >= v15) {
                break;
              }
              ++v8;
              unsigned int v15 = v16;
              if (v3 == v8)
              {
                uint64_t v8 = v3;
                break;
              }
            }
          }
          if (v13 < v14)
          {
            if (v8 < v12) {
              goto LABEL_139;
            }
            if (v12 < v8)
            {
              uint64_t v17 = v8 - 1;
              uint64_t v18 = v12;
              do
              {
                if (v18 != v17)
                {
                  if (!v9) {
                    goto LABEL_145;
                  }
                  int v19 = *(_DWORD *)(v9 + 4 * v18);
                  *(_DWORD *)(v9 + 4 * v18) = *(_DWORD *)(v9 + 4 * v17);
                  *(_DWORD *)(v9 + 4 * v17) = v19;
                }
                BOOL v58 = ++v18 < v17--;
              }
              while (v58);
            }
          }
        }
        if (v8 < v3)
        {
          if (__OFSUB__(v8, v12)) {
            goto LABEL_136;
          }
          if (v8 - v12 < v93)
          {
            uint64_t v20 = v12 + v93;
            if (__OFADD__(v12, v93)) {
              goto LABEL_140;
            }
            if (v20 >= v3) {
              uint64_t v20 = v3;
            }
            if (v20 < v12)
            {
LABEL_141:
              __break(1u);
LABEL_142:
              __break(1u);
LABEL_143:
              __break(1u);
LABEL_144:
              __break(1u);
LABEL_145:
              __break(1u);
LABEL_146:
              __break(1u);
              return result;
            }
            if (v8 != v20)
            {
              long long v21 = (unsigned int *)(v91 + 4 * v8);
              do
              {
                unsigned int v22 = *(_DWORD *)(v9 + 4 * v8);
                uint64_t v23 = v12;
                uint64_t v24 = v21;
                do
                {
                  unsigned int v25 = *v24;
                  if (v22 >= *v24) {
                    break;
                  }
                  if (!v9) {
                    goto LABEL_143;
                  }
                  *uint64_t v24 = v22;
                  v24[1] = v25;
                  --v24;
                  ++v23;
                }
                while (v8 != v23);
                ++v8;
                ++v21;
              }
              while (v8 != v20);
              uint64_t v8 = v20;
            }
          }
        }
        if (v8 < v12) {
          goto LABEL_131;
        }
        uint64_t result = swift_isUniquelyReferenced_nonNull_native();
        if ((result & 1) == 0)
        {
          uint64_t result = (uint64_t)sub_1B51DA83C(0, *(void *)(v10 + 16) + 1, 1, (char *)v10);
          uint64_t v10 = result;
        }
        unint64_t v27 = *(void *)(v10 + 16);
        unint64_t v26 = *(void *)(v10 + 24);
        unint64_t v11 = v27 + 1;
        uint64_t v9 = v95;
        if (v27 >= v26 >> 1)
        {
          uint64_t result = (uint64_t)sub_1B51DA83C((char *)(v26 > 1), v27 + 1, 1, (char *)v10);
          uint64_t v9 = v95;
          uint64_t v10 = result;
        }
        *(void *)(v10 + 16) = v11;
        uint64_t v28 = v10 + 32;
        uint64_t v29 = (uint64_t *)(v10 + 32 + 16 * v27);
        *uint64_t v29 = v12;
        v29[1] = v8;
        if (v27)
        {
          while (1)
          {
            unint64_t v30 = v11 - 1;
            if (v11 >= 4)
            {
              unint64_t v35 = v28 + 16 * v11;
              uint64_t v36 = *(void *)(v35 - 64);
              uint64_t v37 = *(void *)(v35 - 56);
              BOOL v41 = __OFSUB__(v37, v36);
              uint64_t v38 = v37 - v36;
              if (v41) {
                goto LABEL_120;
              }
              uint64_t v40 = *(void *)(v35 - 48);
              uint64_t v39 = *(void *)(v35 - 40);
              BOOL v41 = __OFSUB__(v39, v40);
              uint64_t v33 = v39 - v40;
              char v34 = v41;
              if (v41) {
                goto LABEL_121;
              }
              unint64_t v42 = v11 - 2;
              uint64_t v43 = (uint64_t *)(v28 + 16 * (v11 - 2));
              uint64_t v45 = *v43;
              uint64_t v44 = v43[1];
              BOOL v41 = __OFSUB__(v44, v45);
              uint64_t v46 = v44 - v45;
              if (v41) {
                goto LABEL_122;
              }
              BOOL v41 = __OFADD__(v33, v46);
              uint64_t v47 = v33 + v46;
              if (v41) {
                goto LABEL_124;
              }
              if (v47 >= v38)
              {
                v65 = (uint64_t *)(v28 + 16 * v30);
                uint64_t v67 = *v65;
                uint64_t v66 = v65[1];
                BOOL v41 = __OFSUB__(v66, v67);
                uint64_t v68 = v66 - v67;
                if (v41) {
                  goto LABEL_130;
                }
                BOOL v58 = v33 < v68;
                goto LABEL_84;
              }
            }
            else
            {
              if (v11 != 3)
              {
                uint64_t v59 = *(void *)(v10 + 32);
                uint64_t v60 = *(void *)(v10 + 40);
                BOOL v41 = __OFSUB__(v60, v59);
                uint64_t v52 = v60 - v59;
                char v53 = v41;
                goto LABEL_78;
              }
              uint64_t v32 = *(void *)(v10 + 32);
              uint64_t v31 = *(void *)(v10 + 40);
              BOOL v41 = __OFSUB__(v31, v32);
              uint64_t v33 = v31 - v32;
              char v34 = v41;
            }
            if (v34) {
              goto LABEL_123;
            }
            unint64_t v42 = v11 - 2;
            int64_t v48 = (uint64_t *)(v28 + 16 * (v11 - 2));
            uint64_t v50 = *v48;
            uint64_t v49 = v48[1];
            BOOL v51 = __OFSUB__(v49, v50);
            uint64_t v52 = v49 - v50;
            char v53 = v51;
            if (v51) {
              goto LABEL_125;
            }
            int64_t v54 = (uint64_t *)(v28 + 16 * v30);
            uint64_t v56 = *v54;
            uint64_t v55 = v54[1];
            BOOL v41 = __OFSUB__(v55, v56);
            uint64_t v57 = v55 - v56;
            if (v41) {
              goto LABEL_127;
            }
            if (__OFADD__(v52, v57)) {
              goto LABEL_129;
            }
            if (v52 + v57 >= v33)
            {
              BOOL v58 = v33 < v57;
LABEL_84:
              if (v58) {
                unint64_t v30 = v42;
              }
              goto LABEL_86;
            }
LABEL_78:
            if (v53) {
              goto LABEL_126;
            }
            uint64_t v61 = (uint64_t *)(v28 + 16 * v30);
            uint64_t v63 = *v61;
            uint64_t v62 = v61[1];
            BOOL v41 = __OFSUB__(v62, v63);
            uint64_t v64 = v62 - v63;
            if (v41) {
              goto LABEL_128;
            }
            if (v64 < v52) {
              goto LABEL_15;
            }
LABEL_86:
            unint64_t v69 = v30 - 1;
            if (v30 - 1 >= v11)
            {
              __break(1u);
LABEL_117:
              __break(1u);
LABEL_118:
              __break(1u);
LABEL_119:
              __break(1u);
LABEL_120:
              __break(1u);
LABEL_121:
              __break(1u);
LABEL_122:
              __break(1u);
LABEL_123:
              __break(1u);
LABEL_124:
              __break(1u);
LABEL_125:
              __break(1u);
LABEL_126:
              __break(1u);
LABEL_127:
              __break(1u);
LABEL_128:
              __break(1u);
LABEL_129:
              __break(1u);
LABEL_130:
              __break(1u);
LABEL_131:
              __break(1u);
LABEL_132:
              __break(1u);
LABEL_133:
              __break(1u);
LABEL_134:
              __break(1u);
LABEL_135:
              __break(1u);
LABEL_136:
              __break(1u);
LABEL_137:
              __break(1u);
LABEL_138:
              __break(1u);
LABEL_139:
              __break(1u);
LABEL_140:
              __break(1u);
              goto LABEL_141;
            }
            if (!v9) {
              goto LABEL_144;
            }
            uint64_t v70 = (uint64_t *)(v28 + 16 * v69);
            uint64_t v71 = *v70;
            uint64_t v72 = v28;
            uint64_t v73 = (void *)(v28 + 16 * v30);
            uint64_t v74 = v73[1];
            uint64_t result = sub_1B525C68C((char *)(v9 + 4 * *v70), (char *)(v9 + 4 * *v73), v9 + 4 * v74, v96);
            if (v1) {
              goto LABEL_114;
            }
            if (v74 < v71) {
              goto LABEL_117;
            }
            if (v30 > *(void *)(v10 + 16)) {
              goto LABEL_118;
            }
            *uint64_t v70 = v71;
            *(void *)(v72 + 16 * v69 + 8) = v74;
            unint64_t v75 = *(void *)(v10 + 16);
            if (v30 >= v75) {
              goto LABEL_119;
            }
            unint64_t v11 = v75 - 1;
            uint64_t result = (uint64_t)memmove(v73, v73 + 2, 16 * (v75 - 1 - v30));
            uint64_t v28 = v72;
            *(void *)(v10 + 16) = v75 - 1;
            uint64_t v9 = v95;
            if (v75 <= 2) {
              goto LABEL_15;
            }
          }
        }
        unint64_t v11 = 1;
LABEL_15:
        uint64_t v3 = v94;
        if (v8 >= v94)
        {
          uint64_t v7 = v92;
          uint64_t v2 = v90;
          goto LABEL_103;
        }
      }
    }
    uint64_t v7 = MEMORY[0x1E4FBC860];
    uint64_t v96 = (char *)(MEMORY[0x1E4FBC860] + 32);
    if (v3 == 1)
    {
      uint64_t v92 = MEMORY[0x1E4FBC860];
      goto LABEL_13;
    }
    unint64_t v11 = *(void *)(MEMORY[0x1E4FBC860] + 16);
    uint64_t v10 = MEMORY[0x1E4FBC860];
LABEL_103:
    uint64_t v92 = v7;
    if (v11 >= 2)
    {
      uint64_t v82 = *v2;
      do
      {
        unint64_t v83 = v11 - 2;
        if (v11 < 2) {
          goto LABEL_132;
        }
        if (!v82) {
          goto LABEL_146;
        }
        uint64_t v84 = v10;
        uint64_t v85 = v10 + 32;
        uint64_t v86 = *(void *)(v10 + 32 + 16 * v83);
        uint64_t v87 = *(void *)(v10 + 32 + 16 * (v11 - 1) + 8);
        uint64_t result = sub_1B525C68C((char *)(v82 + 4 * v86), (char *)(v82 + 4 * *(void *)(v85 + 16 * (v11 - 1))), v82 + 4 * v87, v96);
        if (v1) {
          break;
        }
        if (v87 < v86) {
          goto LABEL_133;
        }
        uint64_t result = swift_isUniquelyReferenced_nonNull_native();
        if ((result & 1) == 0)
        {
          uint64_t result = (uint64_t)sub_1B51DA938(v84);
          uint64_t v84 = result;
        }
        if (v83 >= *(void *)(v84 + 16)) {
          goto LABEL_134;
        }
        uint64_t v88 = (void *)(v84 + 32 + 16 * v83);
        *uint64_t v88 = v86;
        v88[1] = v87;
        unint64_t v89 = *(void *)(v84 + 16);
        if (v11 > v89) {
          goto LABEL_135;
        }
        uint64_t result = (uint64_t)memmove((void *)(v84 + 32 + 16 * (v11 - 1)), (const void *)(v84 + 32 + 16 * v11), 16 * (v89 - v11));
        uint64_t v10 = v84;
        *(void *)(v84 + 16) = v89 - 1;
        unint64_t v11 = v89 - 1;
      }
      while (v89 > 2);
    }
LABEL_114:
    swift_bridgeObjectRelease();
    *(void *)(v92 + 16) = 0;
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t sub_1B52A6700@<X0>(long long *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  void (*v10)(long long *__return_ptr, uint64_t *);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  long long v17;
  uint64_t v18;
  uint64_t result;
  long long v20;
  long long v21;
  long long v22;
  long long v23;
  long long v24;
  long long v25;
  long long v26;
  long long v27;
  long long v28;
  long long v29;
  long long v30;
  long long v31;
  long long v32;
  uint64_t v33;
  _OWORD v34[2];
  uint64_t v35;

  char v9 = *(unsigned char *)a2;
  uint64_t v10 = *(void (**)(long long *__return_ptr, uint64_t *))(a2 + 8);
  unint64_t v11 = *(void *)(a2 + 16);
  uint64_t v12 = *((void *)a1 + 2);
  uint64_t v24 = *a1;
  *(void *)&unsigned int v25 = v12;
  swift_bridgeObjectRetain();
  sub_1B52B24A0((uint64_t *)&v24, v9, v10, v11, a3);
  if (v4) {
    return swift_bridgeObjectRelease();
  }
  unsigned int v15 = v13;
  unsigned int v16 = v14;
  swift_bridgeObjectRelease();
  uint64_t v17 = *(_OWORD *)(a2 + 40);
  v34[0] = *(_OWORD *)(a2 + 24);
  v34[1] = v17;
  unint64_t v35 = *(void *)(a2 + 56);
  uint64_t v18 = v25;
  *a1 = v24;
  *((void *)a1 + 2) = v18;
  *(void *)&uint64_t v32 = v15;
  *((void *)&v32 + 1) = v16;
  uint64_t v33 = v18;
  swift_bridgeObjectRetain_n();
  sub_1B51F01D8(&v32, (unsigned __int8 *)v34, a3);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  uint64_t v20 = v29;
  a4[4] = v28;
  a4[5] = v20;
  long long v21 = v31;
  a4[6] = v30;
  a4[7] = v21;
  unsigned int v22 = v25;
  *a4 = v24;
  a4[1] = v22;
  uint64_t v23 = v27;
  a4[2] = v26;
  a4[3] = v23;
  return result;
}

uint64_t sub_1B52A6850(long long *a1, uint64_t a2, int a3, uint64_t (*a4)(__int16 *, __int16 *), uint64_t a5, char a6)
{
  uint64_t v12 = *((void *)a1 + 2);
  long long v17 = *a1;
  uint64_t v18 = v12;
  unsigned int v13 = a3 & 0xFFFF0001;
  swift_bridgeObjectRetain_n();
  sub_1B52A6AA4((uint64_t *)&v17, v13, a4, a5, a2);
  swift_bridgeObjectRelease();
  if (v6) {
    return swift_bridgeObjectRelease();
  }
  swift_bridgeObjectRetain();
  unsigned int v14 = sub_1B51F3DDC((uint64_t *)&v17, a2, a6 & 1);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  uint64_t v15 = v18;
  uint64_t result = v14;
  *a1 = v17;
  *((void *)a1 + 2) = v15;
  return result;
}

uint64_t *sub_1B52A6974(uint64_t a1, uint64_t *a2)
{
  void (*v10)(long long *__return_ptr, uint64_t *);
  uint64_t v11;
  uint64_t v13;
  long long v14;
  uint64_t v15;

  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(uint64_t (**)(int *))(v2 + 8);
  uint64_t v8 = *(void *)(v2 + 16);
  char v9 = *(unsigned char *)v2 & 1;
  unsigned int v14 = *(_OWORD *)a1;
  uint64_t v15 = v6;
  swift_bridgeObjectRetain_n();
  sub_1B51FB970(&v14, v9, v7, v8, (uint64_t)a2);
  swift_bridgeObjectRelease();
  if (v3)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v10 = *(void (**)(long long *__return_ptr, uint64_t *))(v2 + 24);
    unint64_t v11 = *(void *)(v2 + 32);
    swift_bridgeObjectRetain();
    a2 = (uint64_t *)sub_1B52B927C((uint64_t)&v14, v10, v11, a2);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    unsigned int v13 = v15;
    *(_OWORD *)a1 = v14;
    *(void *)(a1 + 16) = v13;
  }
  return a2;
}

uint64_t *sub_1B52A6AA4(uint64_t *a1, int a2, uint64_t (*a3)(__int16 *, __int16 *), uint64_t a4, uint64_t a5)
{
  __int16 v14 = HIWORD(a2);
  uint64_t v8 = sub_1B51F3E0C(a1, a5, a2 & 1);
  char v9 = v8;
  if (!v5)
  {
    __int16 v13 = (__int16)v8;
    if ((a3(&v13, &v14) & 1) == 0)
    {
      uint64_t v10 = *a1;
      sub_1B5372F98();
      sub_1B5372868();
      sub_1B5373018();
      sub_1B5372868();
      sub_1B5373018();
      sub_1B51D4D34();
      swift_allocError();
      *unint64_t v11 = 3;
      v11[1] = v10;
      _OWORD v11[2] = 0;
      v11[3] = 0xE000000000000000;
      v11[4] = 0;
      swift_willThrow();
    }
  }
  return v9;
}

uint64_t *sub_1B52A6C10(uint64_t *a1, uint64_t a2, uint64_t (*a3)(int *, int *), uint64_t a4, uint64_t a5)
{
  int v14 = HIDWORD(a2);
  uint64_t v8 = sub_1B51F3DDC(a1, a5, a2 & 1);
  char v9 = v8;
  if (!v5)
  {
    int v13 = (int)v8;
    if ((a3(&v13, &v14) & 1) == 0)
    {
      uint64_t v10 = *a1;
      sub_1B5372F98();
      sub_1B5372868();
      sub_1B5373018();
      sub_1B5372868();
      sub_1B5373018();
      sub_1B51D4D34();
      swift_allocError();
      *unint64_t v11 = 3;
      v11[1] = v10;
      _OWORD v11[2] = 0;
      v11[3] = 0xE000000000000000;
      v11[4] = 0;
      swift_willThrow();
    }
  }
  return v9;
}

char *sub_1B52A6D7C(void *a1, unsigned int a2, void (*a3)(uint64_t *__return_ptr, _WORD *), uint64_t a4, uint64_t a5)
{
  uint64_t v6 = v5;
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  if (*a1 == v8) {
    return (char *)MEMORY[0x1E4FBC860];
  }
  uint64_t v9 = a5;
  char v10 = a2;
  uint64_t v29 = a1;
  unint64_t v30 = (char *)MEMORY[0x1E4FBC860];
  int v27 = HIWORD(a2) & 1;
  int v28 = (a2 >> 8) & 1;
  char v24 = a2;
  while (1)
  {
    uint64_t v11 = a1[2];
    *(void *)&long long v31 = v7;
    *((void *)&v31 + 1) = v8;
    uint64_t v32 = v11;
    swift_bridgeObjectRetain_n();
    unsigned __int16 v12 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v31, v9, v10 & 1);
    if (v6) {
      break;
    }
    unsigned __int16 v13 = v12;
    uint64_t v6 = 0;
    unsigned __int16 v14 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v31, v9, v28);
    swift_bridgeObjectRelease();
    long long v33 = v31;
    uint64_t v34 = v32;
    unsigned __int16 v15 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v33, v9, v27);
    swift_bridgeObjectRelease();
    uint64_t v8 = *((void *)&v33 + 1);
    uint64_t v7 = v33;
    uint64_t v16 = v34;
    v35[0] = v13;
    v35[1] = v14;
    v35[2] = v15;
    a3(&v36, v35);
    swift_bridgeObjectRelease();
    __int16 v17 = v36;
    __int16 v18 = WORD1(v36);
    __int16 v19 = WORD2(v36);
    *uint64_t v29 = v7;
    v29[1] = v8;
    v29[2] = v16;
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
      unint64_t v30 = sub_1B51E9BD0(0, *((void *)v30 + 2) + 1, 1, v30);
    }
    unint64_t v21 = *((void *)v30 + 2);
    unint64_t v20 = *((void *)v30 + 3);
    if (v21 >= v20 >> 1) {
      unint64_t v30 = sub_1B51E9BD0((char *)(v20 > 1), v21 + 1, 1, v30);
    }
    a1 = v29;
    *((void *)v30 + 2) = v21 + 1;
    unsigned int v22 = &v30[6 * v21];
    *((_WORD *)v22 + 16) = v17;
    *((_WORD *)v22 + 17) = v18;
    *((_WORD *)v22 + 18) = v19;
    uint64_t v9 = a5;
    char v10 = v24;
    if (v7 == v8) {
      return v30;
    }
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v30;
}

uint64_t sub_1B52A7030@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v17 = a1;
  unint64_t v18 = a2;
  sub_1B51D4BB8(a1, a2);
  sub_1B51D4C10();
  uint64_t result = sub_1B53724D8();
  if (v9 < result)
  {
    __break(1u);
  }
  else
  {
    uint64_t v10 = result;
    uint64_t v11 = v9;
    if (!a3)
    {
      uint64_t result = swift_bridgeObjectRelease();
      uint64_t v15 = 0;
LABEL_5:
      *a4 = v15;
      a4[1] = a1;
      a4[2] = a2;
      a4[3] = v10;
      a4[4] = v11;
      return result;
    }
    sub_1B51D4BB8(a1, a2);
    uint64_t v17 = sub_1B53724C8();
    unint64_t v18 = v12;
    uint64_t v19 = v13;
    swift_bridgeObjectRetain_n();
    unsigned int v16 = sub_1B51F3DDC(&v17, v14, 1);
    swift_bridgeObjectRelease_n();
    uint64_t v10 = v17;
    uint64_t v11 = v18;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t result = sub_1B51D4C64(a1, a2);
    if (v11 >= v10)
    {
      uint64_t v15 = v16;
      goto LABEL_5;
    }
  }
  __break(1u);
  return result;
}

uint64_t sub_1B52A71A8@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  sub_1B51D4BB8(a1, a2);
  sub_1B51D4BB8(a1, a2);
  sub_1B51D4C10();
  *(void *)&long long v23 = sub_1B53724D8();
  *((void *)&v23 + 1) = v7;
  uint64_t v24 = v8;
  swift_bridgeObjectRetain_n();
  uint64_t v10 = sub_1B52A6850(&v23, v9, 917505, (uint64_t (*)(__int16 *, __int16 *))sub_1B522CD5C, 0, 1);
  if (v3)
  {
    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease();
LABEL_4:
    sub_1B51D4C64(a1, a2);
    return sub_1B51D4C64(a1, a2);
  }
  else
  {
    uint64_t v11 = v10;
    long long v21 = v23;
    uint64_t v22 = v24;
    swift_bridgeObjectRetain();
    unsigned int v14 = sub_1B51F3DDC((uint64_t *)&v21, v12, 1);
    unsigned int v25 = a3;
    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease();
    long long v15 = v21;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    if (*((uint64_t *)&v15 + 1) < (uint64_t)v15)
    {
      __break(1u);
LABEL_15:
      __break(1u);
LABEL_16:
      __break(1u);
      JUMPOUT(0x1B52A73ECLL);
    }
    switch(a2 >> 62)
    {
      case 1uLL:
        LODWORD(v16) = HIDWORD(a1) - a1;
        if (__OFSUB__(HIDWORD(a1), a1)) {
          goto LABEL_15;
        }
        uint64_t v16 = (int)v16;
LABEL_11:
        if (v16 < 11 * v14 + 10)
        {
LABEL_12:
          sub_1B52A877C();
          swift_allocError();
          swift_willThrow();
          goto LABEL_4;
        }
        uint64_t result = sub_1B51D4C64(a1, a2);
        unint64_t v20 = v25;
        *unsigned int v25 = a1;
        v20[1] = a2;
        *((_OWORD *)v20 + 1) = v15;
        v20[4] = v11;
        v20[5] = v14;
        break;
      case 2uLL:
        uint64_t v18 = *(void *)(a1 + 16);
        uint64_t v17 = *(void *)(a1 + 24);
        BOOL v19 = __OFSUB__(v17, v18);
        uint64_t v16 = v17 - v18;
        if (!v19) {
          goto LABEL_11;
        }
        goto LABEL_16;
      case 3uLL:
        goto LABEL_12;
      default:
        uint64_t v16 = BYTE6(a2);
        goto LABEL_11;
    }
  }
  return result;
}

uint64_t sub_1B52A73FC(uint64_t result)
{
  unint64_t v2 = *(void *)result;
  uint64_t v1 = *(void *)(result + 8);
  if (*(void *)result == v1) {
    return MEMORY[0x1E4FBC860];
  }
  if (!__OFSUB__(v1, v2))
  {
    if ((uint64_t)(v1 - v2) < 1)
    {
      uint64_t v3 = MEMORY[0x1E4FBC860];
LABEL_25:
      sub_1B5372F98();
      swift_bridgeObjectRelease();
      sub_1B51D4D34();
      swift_allocError();
      *uint64_t v13 = 0;
      v13[1] = v2;
      _OWORD v13[2] = 0xD00000000000002ALL;
      v13[3] = 0x80000001B537BD00;
      v13[4] = 0;
      swift_willThrow();
      swift_bridgeObjectRelease();
      return v3;
    }
    uint64_t v4 = (unint64_t *)result;
    uint64_t v3 = MEMORY[0x1E4FBC860];
    while (1)
    {
      unint64_t v5 = v2 + 1;
      if (v2 == 0x7FFFFFFFFFFFFFFFLL || v1 < (uint64_t)v5) {
        break;
      }
      unint64_t v7 = v4[2];
      *uint64_t v4 = v5;
      v4[1] = v1;
      if ((v2 & 0x8000000000000000) != 0) {
        goto LABEL_28;
      }
      unint64_t v8 = *(void *)(v7 + 16);
      if (v8 < v2 || v8 < v5) {
        goto LABEL_29;
      }
      char v10 = *(unsigned char *)(v7 + v2 + 32);
      uint64_t result = swift_isUniquelyReferenced_nonNull_native();
      if ((result & 1) == 0)
      {
        uint64_t result = (uint64_t)sub_1B51E8B68(0, *(void *)(v3 + 16) + 1, 1, (char *)v3);
        uint64_t v3 = result;
      }
      unint64_t v12 = *(void *)(v3 + 16);
      unint64_t v11 = *(void *)(v3 + 24);
      if (v12 >= v11 >> 1)
      {
        uint64_t result = (uint64_t)sub_1B51E8B68((char *)(v11 > 1), v12 + 1, 1, (char *)v3);
        uint64_t v3 = result;
      }
      *(void *)(v3 + 16) = v12 + 1;
      *(unsigned char *)(v3 + v12 + 32) = v10;
      unint64_t v2 = *v4;
      uint64_t v1 = v4[1];
      if (*v4 == v1) {
        return v3;
      }
      if (__OFSUB__(v1, v2)) {
        goto LABEL_30;
      }
      if ((uint64_t)(v1 - v2) < 1) {
        goto LABEL_25;
      }
    }
    __break(1u);
LABEL_28:
    __break(1u);
LABEL_29:
    __break(1u);
LABEL_30:
    __break(1u);
  }
  __break(1u);
  return result;
}

uint64_t *sub_1B52A75C4(long long *a1, char a2, void (*a3)(long long *__return_ptr, uint64_t *), uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v13 = *((void *)a1 + 2);
  long long v22 = *a1;
  uint64_t v23 = v13;
  swift_bridgeObjectRetain();
  sub_1B52B24A0((uint64_t *)&v22, a2, a3, a4, a6);
  if (v6)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v16 = v14;
    uint64_t v17 = v15;
    swift_bridgeObjectRelease();
    uint64_t v18 = v23;
    *a1 = v22;
    *((void *)a1 + 2) = v18;
    *(void *)&long long v22 = v16;
    *((void *)&v22 + 1) = v17;
    uint64_t v23 = v18;
    swift_bridgeObjectRetain_n();
    a5 = sub_1B51F3E0C((uint64_t *)&v22, a6, a5 & 1);
    long long v20 = v22;
    uint64_t v21 = v23;
    swift_bridgeObjectRetain();
    sub_1B52A73FC((uint64_t)&v20);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  return a5;
}

uint64_t sub_1B52A7728@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v9 = swift_allocObject();
  *(void *)(v9 + 16) = a1;
  char v29 = 1;
  unint64_t v30 = sub_1B52A8848;
  uint64_t v31 = v9;
  char v32 = 1;
  char v33 = 1;
  uint64_t v34 = sub_1B52A47E4;
  uint64_t v35 = 0;
  uint64_t v36 = sub_1B51D2460;
  uint64_t v37 = 0;
  char v38 = 1;
  *(void *)&long long v25 = a2;
  *((void *)&v25 + 1) = a3;
  sub_1B51D4BB8(a2, a3);
  sub_1B51D4C10();
  *(void *)&long long v27 = sub_1B53724D8();
  *((void *)&v27 + 1) = v10;
  uint64_t v28 = v11;
  swift_bridgeObjectRetain_n();
  uint64_t v13 = sub_1B51F6724((unsigned __int16 *)&v25, (uint64_t)&v27, v12);
  if (v4)
  {
    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease();
    sub_1B51D4C64(a2, a3);
    return swift_release();
  }
  else
  {
    uint64_t v14 = v13;
    uint64_t v24 = a4;
    __int16 v15 = v25;
    long long v25 = v27;
    *(void *)&long long v26 = v28;
    swift_bridgeObjectRetain_n();
    unsigned int v17 = sub_1B51F3DDC((uint64_t *)&v25, v16, 1);
    unsigned int v19 = v17;
    __int16 v22 = v15;
    uint64_t result = swift_bridgeObjectRelease();
    uint64_t v20 = *((void *)&v25 + 1);
    if (*((uint64_t *)&v25 + 1) < (uint64_t)v25)
    {
      __break(1u);
    }
    else
    {
      uint64_t v23 = v25;
      swift_bridgeObjectRetain();
      sub_1B52B8304((uint64_t *)&v25, v21, 12 * v19);
      swift_bridgeObjectRelease_n();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      uint64_t result = swift_release();
      *(void *)uint64_t v24 = v14;
      *(_WORD *)(v24 + 8) = v22;
      *(void *)(v24 + 16) = v19;
      *(void *)(v24 + 24) = v23;
      *(void *)(v24 + 32) = v20;
      *(void *)(v24 + 40) = a2;
      *(void *)(v24 + 48) = a3;
    }
  }
  return result;
}

uint64_t sub_1B52A7A9C(uint64_t a1, unint64_t a2)
{
  sub_1B51D4BB8(a1, a2);
  sub_1B51D4C10();
  *(void *)&long long v80 = sub_1B53724D8();
  *((void *)&v80 + 1) = v5;
  *(void *)&long long v81 = v6;
  swift_bridgeObjectRetain_n();
  sub_1B51F3E0C((uint64_t *)&v80, v7, 1);
  if (v2)
  {
    swift_bridgeObjectRelease_n();
    return swift_bridgeObjectRelease();
  }
  uint64_t v10 = sub_1B51F3E0C((uint64_t *)&v80, v8, 1);
  unsigned __int8 v76 = BYTE6(a2);
  swift_bridgeObjectRelease_n();
  uint64_t v11 = v81;
  if (!(_WORD)v10)
  {
    swift_bridgeObjectRelease();
    sub_1B51DD5FC();
    swift_allocError();
    unsigned char *v65 = 2;
    return swift_willThrow();
  }
  int v12 = 0;
  unint64_t v75 = (void *)MEMORY[0x1E4FBC860];
  unint64_t v72 = a2 >> 62;
  long long v13 = v80;
  unint64_t v78 = a2 >> 62;
  uint64_t v77 = (void *)MEMORY[0x1E4FBC860];
  while (2)
  {
    long long v80 = v13;
    *(void *)&long long v81 = v11;
    swift_bridgeObjectRetain_n();
    unsigned __int16 v15 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v80, v14, 1);
    Swift::UInt16 v17 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v80, v16, 1);
    uint64_t v18 = v10;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    unsigned int v20 = sub_1B51F3DDC((uint64_t *)&v80, v19, 1);
    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease();
    long long v79 = v80;
    uint64_t v116 = v81;
    int v21 = 0x10000;
    v22.FontParser::Encoding value = Platform.interpret(encoding:language:)(v17, (Swift::UInt16_optional)v21).value;
    if (v22.value == FontParser_Encoding_unknownDefault)
    {
      uint64_t v11 = v116;
      goto LABEL_8;
    }
    FontParser::Encoding value = v22.value;
    uint64_t v24 = v20;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = (int)a1;
    switch(v78)
    {
      case 1uLL:
        goto LABEL_13;
      case 2uLL:
        uint64_t v27 = *(void *)(a1 + 16);
LABEL_13:
        uint64_t v24 = v27 + v20;
        if (!__OFADD__(v27, v20))
        {
          uint64_t v26 = a1 >> 32;
          uint64_t v25 = (int)a1;
          if (v72 == 2)
          {
            uint64_t v25 = *(void *)(a1 + 16);
            uint64_t v26 = *(void *)(a1 + 24);
          }
          if (v26 < v25)
          {
            __break(1u);
LABEL_54:
            __break(1u);
            JUMPOUT(0x1B52A85A8);
          }
LABEL_17:
          if (v24 < v25 || v26 < v24)
          {
            sub_1B51D4ED4();
            swift_allocError();
            unsigned char *v66 = 2;
            goto LABEL_52;
          }
          uint64_t v28 = 0;
          uint64_t v29 = 0;
          switch(v78)
          {
            case 1uLL:
              uint64_t v28 = a1 >> 32;
              uint64_t v29 = (int)a1;
              break;
            case 2uLL:
              uint64_t v29 = *(void *)(a1 + 16);
              uint64_t v28 = *(void *)(a1 + 24);
              break;
            case 3uLL:
              break;
            default:
              uint64_t v29 = 0;
              uint64_t v28 = v76;
              break;
          }
          if (v28 < v24 || v28 < v29) {
            goto LABEL_54;
          }
          uint64_t v30 = sub_1B5372398();
          unint64_t v32 = v31;
          if (value == FontParser_Encoding_unicodeVariationSequences)
          {
            uint64_t v33 = v30;
            sub_1B51D4BB8(v30, v31);
            sub_1B52A71A8(v33, v32, (uint64_t *)v97);
            uint64_t v11 = v116;
            sub_1B5221844((uint64_t)v97);
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
              unint64_t v75 = sub_1B51E8C5C(0, v75[2] + 1, 1, v75);
            }
            unint64_t v48 = v75[2];
            unint64_t v47 = v75[3];
            if (v48 >= v47 >> 1) {
              unint64_t v75 = sub_1B51E8C5C((void *)(v47 > 1), v48 + 1, 1, v75);
            }
            *((void *)&v81 + 1) = &type metadata for Cmap14Collection;
            *(void *)&long long v82 = &off_1F0DFA690;
            uint64_t v49 = (_OWORD *)swift_allocObject();
            *(void *)&long long v80 = v49;
            long long v50 = v97[1];
            v49[1] = v97[0];
            v49[2] = v50;
            v49[3] = v97[2];
            v75[2] = v48 + 1;
            sub_1B51E0D0C(&v80, (uint64_t)&v75[5 * v48 + 4]);
            sub_1B51D4C64(v33, v32);
            sub_1B52686D8((uint64_t)v97);
            goto LABEL_8;
          }
          *(void *)&long long v80 = v30;
          *((void *)&v80 + 1) = v31;
          unint64_t v73 = v31;
          uint64_t v74 = v30;
          sub_1B51D4BB8(v30, v31);
          *(void *)&long long v95 = sub_1B53724D8();
          *((void *)&v95 + 1) = v34;
          uint64_t v96 = v35;
          unsigned __int16 v36 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v95, v34, 1);
          uint64_t v11 = v116;
          unsigned __int16 v37 = v36;
          if (!v36)
          {
            *((void *)&v81 + 1) = &type metadata for Cmap0;
            *(void *)&long long v82 = &off_1F0DFA6A8;
            long long v90 = v95;
            uint64_t v91 = v96;
            swift_bridgeObjectRetain_n();
            unsigned __int16 v52 = (unsigned __int16)sub_1B52A75C4(&v90, 1, (void (*)(long long *__return_ptr, uint64_t *))sub_1B52A37B4, 0, (uint64_t *)1, v51);
            uint64_t v54 = v53;
            swift_bridgeObjectRelease();
            uint64_t v67 = *((void *)&v90 + 1);
            uint64_t v68 = v90;
            uint64_t v70 = v91;
            unint64_t v55 = sub_1B52A37D8(v52, v54, v15, v17);
            uint64_t v57 = v56;
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            *(void *)&long long v95 = v68;
            *((void *)&v95 + 1) = v67;
            uint64_t v96 = v70;
            LODWORD(v80) = v55;
            WORD2(v80) = WORD2(v55);
            *((void *)&v80 + 1) = v57;
            swift_bridgeObjectRelease();
            sub_1B51E0D0C(&v80, (uint64_t)v94);
            uint64_t v11 = v116;
LABEL_42:
            sub_1B51DFF98((uint64_t)v94, (uint64_t)&v80);
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
              uint64_t v77 = sub_1B51E8B54(0, v77[2] + 1, 1, v77);
            }
            uint64_t v10 = v18;
            uint64_t v62 = v77;
            unint64_t v64 = v77[2];
            unint64_t v63 = v77[3];
            if (v64 >= v63 >> 1) {
              uint64_t v62 = sub_1B51E8B54((void *)(v63 > 1), v64 + 1, 1, v77);
            }
            v62[2] = v64 + 1;
            uint64_t v77 = v62;
            sub_1B51E0D0C(&v80, (uint64_t)&v62[5 * v64 + 4]);
            sub_1B51D4C64(v74, v73);
            __swift_destroy_boxed_opaque_existential_1((uint64_t)v94);
            goto LABEL_8;
          }
          if (v36 == 4)
          {
            uint64_t v38 = swift_allocObject();
            *(_WORD *)(v38 + 16) = v15;
            *(_WORD *)(v38 + 18) = v17;
            *(unsigned char *)(v38 + 20) = 1;
            uint64_t v39 = swift_allocObject();
            *(void *)(v39 + 16) = sub_1B52A8618;
            *(void *)(v39 + 24) = v38;
            v108[0] = 1;
            v109 = sub_1B52A3CA0;
            uint64_t v110 = 0;
            __int16 v111 = 257;
            uint64_t v112 = sub_1B52A8660;
            uint64_t v113 = v39;
            uint64_t v114 = sub_1B52A3E60;
            uint64_t v115 = 0;
            uint64_t v92 = &type metadata for Cmap4;
            uint64_t v93 = &off_1F0DFA6E0;
            uint64_t v40 = (_OWORD *)swift_allocObject();
            *(void *)&long long v90 = v40;
            long long v88 = v95;
            uint64_t v89 = v96;
            swift_bridgeObjectRetain();
            sub_1B52A6700(&v88, (uint64_t)v108, v41, &v80);
            swift_bridgeObjectRelease();
            long long v95 = v88;
            uint64_t v96 = v89;
            long long v42 = v85;
            v40[5] = v84;
            v40[6] = v42;
            long long v43 = v87;
            v40[7] = v86;
            v40[8] = v43;
            long long v44 = v81;
            v40[1] = v80;
            v40[2] = v44;
            long long v45 = v83;
            v40[3] = v82;
            v40[4] = v45;
            swift_bridgeObjectRelease();
            swift_release();
            uint64_t v46 = &v90;
LABEL_41:
            sub_1B51E0D0C(v46, (uint64_t)v94);
            goto LABEL_42;
          }
          swift_bridgeObjectRelease();
          if (v37 == 13)
          {
            sub_1B51D4BB8(v74, v73);
            sub_1B52A7728(13, v74, v73, (uint64_t)&v103);
            uint64_t v58 = v103;
            __int16 v59 = v104;
            long long v69 = v106;
            long long v71 = v105;
            uint64_t v60 = v107;
            *((void *)&v81 + 1) = &type metadata for Cmap13;
            *(void *)&long long v82 = &off_1F0DFA750;
            goto LABEL_40;
          }
          if (v37 == 12)
          {
            sub_1B51D4BB8(v74, v73);
            sub_1B52A7728(12, v74, v73, (uint64_t)&v98);
            uint64_t v58 = v98;
            __int16 v59 = v99;
            long long v69 = v101;
            long long v71 = v100;
            uint64_t v60 = v102;
            *((void *)&v81 + 1) = &type metadata for Cmap12;
            *(void *)&long long v82 = &off_1F0DFA718;
LABEL_40:
            uint64_t v61 = swift_allocObject();
            *(void *)&long long v80 = v61;
            *(_WORD *)(v61 + 16) = v15;
            *(_WORD *)(v61 + 18) = v17;
            *(void *)(v61 + 24) = v58;
            *(_WORD *)(v61 + 32) = v59;
            *(_OWORD *)(v61 + 40) = v71;
            *(_OWORD *)(v61 + 56) = v69;
            *(void *)(v61 + 72) = v60;
            uint64_t v11 = v116;
            uint64_t v46 = &v80;
            goto LABEL_41;
          }
          sub_1B51D4C64(v74, v73);
LABEL_8:
          ++v12;
          long long v13 = v79;
          if ((unsigned __int16)v12 == (unsigned __int16)v10)
          {
            swift_bridgeObjectRelease();
            return (uint64_t)v77;
          }
          continue;
        }
        sub_1B51D4F28();
        swift_allocError();
LABEL_52:
        swift_willThrow();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        return swift_bridgeObjectRelease();
      case 3uLL:
        goto LABEL_17;
      default:
        uint64_t v25 = 0;
        uint64_t v26 = v76;
        goto LABEL_17;
    }
  }
}

uint64_t objectdestroyTm_0()
{
  sub_1B51D4C64(*(void *)(v0 + 64), *(void *)(v0 + 72));
  return MEMORY[0x1F4186498](v0, 80, 7);
}

uint64_t sub_1B52A8608()
{
  return MEMORY[0x1F4186498](v0, 21, 7);
}

uint64_t sub_1B52A8618@<X0>(__int16 a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1B52A3CB8(a1, a2, *(_WORD *)(v3 + 16), *(_WORD *)(v3 + 18), (unsigned char *)(v3 + 20), a3);
}

uint64_t sub_1B52A8628()
{
  swift_release();
  return MEMORY[0x1F4186498](v0, 32, 7);
}

uint64_t sub_1B52A8660(unsigned __int16 *a1)
{
  return (*(uint64_t (**)(void, void))(v1 + 16))(*a1, *((void *)a1 + 1));
}

uint64_t sub_1B52A8698()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return MEMORY[0x1F4186498](v0, 144, 7);
}

uint64_t __swift_deallocate_boxed_opaque_existential_1(uint64_t result)
{
  if ((*(_DWORD *)(*(void *)(*(void *)(result + 24) - 8) + 80) & 0x20000) != 0) {
    JUMPOUT(0x1BA99A060);
  }
  return result;
}

uint64_t sub_1B52A8744()
{
  sub_1B51D4C64(*(void *)(v0 + 16), *(void *)(v0 + 24));
  return MEMORY[0x1F4186498](v0, 64, 7);
}

unint64_t sub_1B52A877C()
{
  unint64_t result = qword_1E9D49000;
  if (!qword_1E9D49000)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49000);
  }
  return result;
}

uint64_t sub_1B52A87D0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D49010);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

uint64_t sub_1B52A8838()
{
  return MEMORY[0x1F4186498](v0, 24, 7);
}

BOOL sub_1B52A8848(unsigned __int16 *a1)
{
  return *(void *)(v1 + 16) == *a1;
}

unsigned char *storeEnumTagSinglePayload for CmapError(unsigned char *result, int a2, int a3)
{
  if ((a3 + 1) >= 0x10000) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) < 0x100) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2)
  {
    switch(v5)
    {
      case 1:
        *unint64_t result = a2;
        return result;
      case 2:
        *(_WORD *)unint64_t result = a2;
        return result;
      case 3:
        goto LABEL_19;
      case 4:
        *(_DWORD *)unint64_t result = a2;
        return result;
      default:
        return result;
    }
  }
  switch(v5)
  {
    case 1:
      *unint64_t result = 0;
      break;
    case 2:
      *(_WORD *)unint64_t result = 0;
      break;
    case 3:
LABEL_19:
      __break(1u);
      JUMPOUT(0x1B52A88F8);
    case 4:
      *(_DWORD *)unint64_t result = 0;
      break;
    default:
      return result;
  }
  return result;
}

ValueMetadata *type metadata accessor for CmapError()
{
  return &type metadata for CmapError;
}

uint64_t destroy for Cmap14Collection(uint64_t a1)
{
  return sub_1B51D4C64(*(void *)a1, *(void *)(a1 + 8));
}

uint64_t initializeWithCopy for Cmap14Collection(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a2;
  unint64_t v5 = *(void *)(a2 + 8);
  sub_1B51D4BB8(*(void *)a2, v5);
  *(void *)a1 = v4;
  *(void *)(a1 + 8) = v5;
  long long v6 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v6;
  return a1;
}

uint64_t *assignWithCopy for Cmap14Collection(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  sub_1B51D4BB8(*a2, v5);
  uint64_t v6 = *a1;
  unint64_t v7 = a1[1];
  *a1 = v4;
  a1[1] = v5;
  sub_1B51D4C64(v6, v7);
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  a1[5] = a2[5];
  return a1;
}

uint64_t assignWithTake for Cmap14Collection(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = *(void *)(a1 + 8);
  *(_OWORD *)a1 = *a2;
  sub_1B51D4C64(v4, v5);
  long long v6 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v6;
  return a1;
}

uint64_t getEnumTagSinglePayload for Cmap14Collection(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xD && *(unsigned char *)(a1 + 48)) {
    return (*(_DWORD *)a1 + 13);
  }
  unsigned int v3 = (((*(void *)(a1 + 8) >> 60) >> 2) & 0xFFFFFFF3 | (4 * ((*(void *)(a1 + 8) >> 60) & 3))) ^ 0xF;
  if (v3 >= 0xC) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for Cmap14Collection(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xC)
  {
    *(void *)(result + 40) = 0;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)unint64_t result = a2 - 13;
    if (a3 >= 0xD) {
      *(unsigned char *)(result + 48) = 1;
    }
  }
  else
  {
    if (a3 >= 0xD) {
      *(unsigned char *)(result + 48) = 0;
    }
    if (a2)
    {
      *(void *)unint64_t result = 0;
      *(void *)(result + 8) = (unint64_t)(((-a2 >> 2) & 3) - 4 * a2) << 60;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Cmap14Collection()
{
  return &type metadata for Cmap14Collection;
}

uint64_t sub_1B52A8AFC(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for Cmap0(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(_WORD *)(a1 + 2) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for Cmap0(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRelease();
  return a1;
}

ValueMetadata *type metadata accessor for Cmap0()
{
  return &type metadata for Cmap0;
}

uint64_t destroy for Cmap4()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for Cmap4(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for Cmap4(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(_WORD *)(a1 + 2) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy128_8(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  __n128 result = (__n128)a2[4];
  long long v6 = a2[5];
  long long v7 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v7;
  *(__n128 *)(a1 + 64) = result;
  *(_OWORD *)(a1 + 80) = v6;
  return result;
}

uint64_t assignWithTake for Cmap4(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 2);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for Cmap4(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 128)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Cmap4(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 120) = 0;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 128) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 128) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Cmap4()
{
  return &type metadata for Cmap4;
}

uint64_t destroy for Cmap12(uint64_t a1)
{
  return sub_1B51D4C64(*(void *)(a1 + 48), *(void *)(a1 + 56));
}

ValueMetadata *type metadata accessor for Cmap12()
{
  return &type metadata for Cmap12;
}

uint64_t _s10FontParser6Cmap12Vwcp_0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  unint64_t v4 = *(void *)(a2 + 56);
  sub_1B51D4BB8(v3, v4);
  *(void *)(a1 + 48) = v3;
  *(void *)(a1 + 56) = v4;
  return a1;
}

uint64_t _s10FontParser6Cmap12Vwca_0(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(_WORD *)(a1 + 2) = *(_WORD *)(a2 + 2);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  uint64_t v3 = *(void *)(a2 + 48);
  unint64_t v4 = *(void *)(a2 + 56);
  sub_1B51D4BB8(v3, v4);
  uint64_t v5 = *(void *)(a1 + 48);
  unint64_t v6 = *(void *)(a1 + 56);
  *(void *)(a1 + 48) = v3;
  *(void *)(a1 + 56) = v4;
  sub_1B51D4C64(v5, v6);
  return a1;
}

uint64_t _s10FontParser6Cmap12Vwta_0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 56);
  uint64_t v4 = *(void *)(a1 + 48);
  unint64_t v5 = *(void *)(a1 + 56);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = v3;
  sub_1B51D4C64(v4, v5);
  return a1;
}

uint64_t _s10FontParser6Cmap12Vwet_0(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xD && *(unsigned char *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 13);
  }
  unsigned int v3 = (((*(void *)(a1 + 56) >> 60) >> 2) & 0xFFFFFFF3 | (4 * ((*(void *)(a1 + 56) >> 60) & 3))) ^ 0xF;
  if (v3 >= 0xC) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t _s10FontParser6Cmap12Vwst_0(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xC)
  {
    *(void *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 - 13;
    if (a3 >= 0xD) {
      *(unsigned char *)(result + 64) = 1;
    }
  }
  else
  {
    if (a3 >= 0xD) {
      *(unsigned char *)(result + 64) = 0;
    }
    if (a2)
    {
      *(void *)(result + 48) = 0;
      *(void *)(result + 56) = (unint64_t)(((-a2 >> 2) & 3) - 4 * a2) << 60;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Cmap13()
{
  return &type metadata for Cmap13;
}

unint64_t sub_1B52A91C8()
{
  unint64_t result = qword_1E9D49018;
  if (!qword_1E9D49018)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49018);
  }
  return result;
}

_UNKNOWN **sub_1B52A921C()
{
  return &off_1F0DFA670;
}

unint64_t sub_1B52A922C()
{
  unint64_t result = qword_1E9D49020;
  if (!qword_1E9D49020)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49020);
  }
  return result;
}

uint64_t sub_1B52A9280()
{
  return sub_1B52010C8(&qword_1E9D49028, &qword_1E9D49030);
}

uint64_t sub_1B52A92BC()
{
  return sub_1B52010C8(&qword_1E9D49038, &qword_1E9D49040);
}

uint64_t sub_1B52A92F8()
{
  return sub_1B52010C8(&qword_1E9D49048, &qword_1E9D49050);
}

uint64_t sub_1B52A9334()
{
  return sub_1B52010C8(&qword_1E9D49058, &qword_1E9D49060);
}

unint64_t sub_1B52A9374()
{
  unint64_t result = qword_1E9D49068;
  if (!qword_1E9D49068)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49068);
  }
  return result;
}

uint64_t sub_1B52A93C8()
{
  return sub_1B52010C8(&qword_1E9D49070, &qword_1E9D49078);
}

uint64_t sub_1B52A9404()
{
  return sub_1B52010C8(&qword_1E9D49080, &qword_1E9D49088);
}

unint64_t sub_1B52A9444()
{
  unint64_t result = qword_1E9D49090;
  if (!qword_1E9D49090)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49090);
  }
  return result;
}

_UNKNOWN **sub_1B52A9498()
{
  return &off_1F0DFA680;
}

uint64_t sub_1B52A94A4()
{
  return sub_1B52010C8(&qword_1E9D49098, &qword_1E9D490A0);
}

unint64_t sub_1B52A94E4()
{
  unint64_t result = qword_1E9D490A8;
  if (!qword_1E9D490A8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D490A8);
  }
  return result;
}

uint64_t sub_1B52A9538()
{
  return sub_1B52010C8(&qword_1E9D490B0, &qword_1E9D490B8);
}

uint64_t sub_1B52A9574()
{
  return sub_1B52010C8(&qword_1E9D490C0, &qword_1E9D490C8);
}

unint64_t sub_1B52A95B4()
{
  unint64_t result = qword_1E9D490D0;
  if (!qword_1E9D490D0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D490D0);
  }
  return result;
}

uint64_t sub_1B52A9608(uint64_t a1)
{
  return a1;
}

uint64_t sub_1B52A9638(uint64_t a1)
{
  return a1;
}

uint64_t sub_1B52A9668(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 < 0)
  {
LABEL_21:
    __break(1u);
    return result;
  }
  if (a2)
  {
    unint64_t v3 = a3 - result;
    if (a3 - result >= (unint64_t)(a2 - 1)) {
      unint64_t v3 = a2 - 1;
    }
    if (v3 >= (result ^ 0x7FFFFFFFFFFFFFFFuLL)) {
      unint64_t v3 = result ^ 0x7FFFFFFFFFFFFFFFLL;
    }
    unint64_t v4 = v3 + 1;
    if (v4 >= 5)
    {
      uint64_t v7 = v4 & 3;
      if ((v4 & 3) == 0) {
        uint64_t v7 = 4;
      }
      unint64_t v5 = v4 - v7;
      int64x2_t v8 = 0uLL;
      v9.i64[0] = 0;
      v9.i64[1] = result;
      int64x2_t v10 = vdupq_n_s64(1uLL);
      unint64_t v11 = v5;
      do
      {
        int64x2_t v8 = vaddq_s64(v8, v10);
        int64x2_t v9 = vaddq_s64(v9, v10);
        v11 -= 4;
      }
      while (v11);
      uint64_t v6 = vaddvq_s64(vaddq_s64(vzip1q_s64(v9, v8), vzip2q_s64(v9, v8)));
    }
    else
    {
      unint64_t v5 = 0;
      uint64_t v6 = result;
    }
    uint64_t v12 = v5 + result - 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v13 = v5 + result - a3;
    uint64_t v14 = a2 - v5;
    unint64_t result = v6;
    while (1)
    {
      if (!v13) {
        return 0;
      }
      if (!v12) {
        break;
      }
      ++result;
      ++v12;
      ++v13;
      if (!--v14) {
        return result;
      }
    }
    __break(1u);
    goto LABEL_21;
  }
  return result;
}

uint64_t sub_1B52A9740(uint64_t a1)
{
  return a1;
}

ValueMetadata *type metadata accessor for Cmap14NonDefaultUVSCollection()
{
  return &type metadata for Cmap14NonDefaultUVSCollection;
}

uint64_t _s10FontParser29Cmap14NonDefaultUVSCollectionVwcp_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  unint64_t v5 = *(void *)(a2 + 16);
  sub_1B51D4BB8(v4, v5);
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  return a1;
}

void *_s10FontParser29Cmap14NonDefaultUVSCollectionVwca_0(void *a1, void *a2)
{
  *a1 = *a2;
  uint64_t v4 = a2[1];
  unint64_t v5 = a2[2];
  sub_1B51D4BB8(v4, v5);
  uint64_t v6 = a1[1];
  unint64_t v7 = a1[2];
  a1[1] = v4;
  a1[2] = v5;
  sub_1B51D4C64(v6, v7);
  a1[3] = a2[3];
  a1[4] = a2[4];
  return a1;
}

uint64_t _s10FontParser29Cmap14NonDefaultUVSCollectionVwta_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_1B51D4C64(v4, v5);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  return a1;
}

uint64_t _s10FontParser29Cmap14NonDefaultUVSCollectionVwet_0(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xD && *(unsigned char *)(a1 + 40)) {
    return (*(_DWORD *)a1 + 13);
  }
  unsigned int v3 = (((*(void *)(a1 + 16) >> 60) >> 2) & 0xFFFFFFF3 | (4 * ((*(void *)(a1 + 16) >> 60) & 3))) ^ 0xF;
  if (v3 >= 0xC) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t _s10FontParser29Cmap14NonDefaultUVSCollectionVwst_0(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xC)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)unint64_t result = a2 - 13;
    if (a3 >= 0xD) {
      *(unsigned char *)(result + 40) = 1;
    }
  }
  else
  {
    if (a3 >= 0xD) {
      *(unsigned char *)(result + 40) = 0;
    }
    if (a2)
    {
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = (unint64_t)(((-a2 >> 2) & 3) - 4 * a2) << 60;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Cmap14DefaultUVSSet()
{
  return &type metadata for Cmap14DefaultUVSSet;
}

ValueMetadata *type metadata accessor for Cmap4.Entry()
{
  return &type metadata for Cmap4.Entry;
}

uint64_t __swift_memcpy12_4(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(_DWORD *)(result + 8) = *((_DWORD *)a2 + 2);
  *(void *)unint64_t result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for Cmap12Collection.Entry(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 12)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Cmap12Collection.Entry(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_DWORD *)(result + 8) = 0;
    *(void *)unint64_t result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 12) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Cmap12Collection.Entry()
{
  return &type metadata for Cmap12Collection.Entry;
}

uint64_t destroy for Cmap12Collection(uint64_t a1)
{
  return sub_1B51D4C64(*(void *)(a1 + 40), *(void *)(a1 + 48));
}

uint64_t initializeWithCopy for Cmap12Collection(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v3;
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  unint64_t v5 = *(void *)(a2 + 48);
  sub_1B51D4BB8(v4, v5);
  *(void *)(a1 + 40) = v4;
  *(void *)(a1 + 48) = v5;
  return a1;
}

uint64_t assignWithCopy for Cmap12Collection(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  uint64_t v3 = *(void *)(a2 + 40);
  unint64_t v4 = *(void *)(a2 + 48);
  sub_1B51D4BB8(v3, v4);
  uint64_t v5 = *(void *)(a1 + 40);
  unint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 40) = v3;
  *(void *)(a1 + 48) = v4;
  sub_1B51D4C64(v5, v6);
  return a1;
}

uint64_t assignWithTake for Cmap12Collection(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 48);
  uint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = *(void *)(a1 + 48);
  long long v6 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v6;
  *(void *)(a1 + 48) = v3;
  sub_1B51D4C64(v4, v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for Cmap12Collection(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xD && *(unsigned char *)(a1 + 56)) {
    return (*(_DWORD *)a1 + 13);
  }
  unsigned int v3 = (((*(void *)(a1 + 48) >> 60) >> 2) & 0xFFFFFFF3 | (4 * ((*(void *)(a1 + 48) >> 60) & 3))) ^ 0xF;
  if (v3 >= 0xC) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for Cmap12Collection(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xC)
  {
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)unint64_t result = a2 - 13;
    if (a3 >= 0xD) {
      *(unsigned char *)(result + 56) = 1;
    }
  }
  else
  {
    if (a3 >= 0xD) {
      *(unsigned char *)(result + 56) = 0;
    }
    if (a2)
    {
      *(void *)(result + 40) = 0;
      *(void *)(result + 48) = (unint64_t)(((-a2 >> 2) & 3) - 4 * a2) << 60;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Cmap12Collection()
{
  return &type metadata for Cmap12Collection;
}

ValueMetadata *type metadata accessor for Cmap14Collection.Cmap14()
{
  return &type metadata for Cmap14Collection.Cmap14;
}

uint64_t sub_1B52A9BC4()
{
  return sub_1B52010C8(&qword_1E9D490D8, &qword_1E9D490E0);
}

unint64_t sub_1B52A9C04()
{
  unint64_t result = qword_1E9D490E8;
  if (!qword_1E9D490E8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D490E8);
  }
  return result;
}

uint64_t sub_1B52A9C58()
{
  return sub_1B52010C8(&qword_1E9D490F0, &qword_1E9D490F8);
}

uint64_t sub_1B52A9C94()
{
  return sub_1B52010C8(&qword_1E9D49100, &qword_1E9D49108);
}

uint64_t sub_1B52A9CD0()
{
  return sub_1B52010C8(&qword_1E9D49110, &qword_1E9D49118);
}

unint64_t sub_1B52A9D10()
{
  unint64_t result = qword_1E9D49120;
  if (!qword_1E9D49120)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49120);
  }
  return result;
}

uint64_t sub_1B52A9D64()
{
  return sub_1B52010C8(&qword_1E9D49128, &qword_1E9D49130);
}

uint64_t sub_1B52A9DA0()
{
  return sub_1B52010C8(&qword_1E9D49138, &qword_1E9D49140);
}

unint64_t sub_1B52A9DE0()
{
  unint64_t result = qword_1E9D49148;
  if (!qword_1E9D49148)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49148);
  }
  return result;
}

_UNKNOWN **sub_1B52A9E34()
{
  return &off_1F0DFAAD8;
}

uint64_t sub_1B52A9E40(uint64_t a1)
{
  return a1;
}

ValueMetadata *type metadata accessor for Cmap14NonDefaultUVSMapping()
{
  return &type metadata for Cmap14NonDefaultUVSMapping;
}

uint64_t getEnumTagSinglePayload for Cmap12Collection.Cmap12Header(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 40)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Cmap12Collection.Cmap12Header(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)unint64_t result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 40) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Cmap12Collection.Cmap12Header()
{
  return &type metadata for Cmap12Collection.Cmap12Header;
}

uint64_t Fixed.init(floatLiteral:)(double a1)
{
  double v1 = round(a1 * 65536.0);
  if ((~*(void *)&v1 & 0x7FF0000000000000) == 0)
  {
    __break(1u);
    goto LABEL_6;
  }
  if (v1 <= -2147483650.0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }
  if (v1 < 2147483650.0) {
    return (int)v1;
  }
LABEL_7:
  __break(1u);
  return result;
}

Swift::Double __swiftcall Fixed.toFloat()()
{
  return (double)v0 * 0.0000152587891;
}

Swift::Double __swiftcall ShortFrac.toFloat()()
{
  return (double)v0 * 0.0000610351562;
}

uint64_t static FixedPointFraction<>.zero.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v5 = sub_1B5372CD8();
  MEMORY[0x1F4188790](v5 - 8);
  unint64_t v7 = (char *)&v10 - v6;
  sub_1B53730F8();
  sub_1B53729D8();
  uint64_t v8 = *(void *)(a1 - 8);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v8 + 48))(v7, 1, a1);
  if (result != 1) {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v8 + 32))(a2, v7, a1);
  }
  __break(1u);
  return result;
}

uint64_t static FixedPointFraction<>.+ infix(_:_:)@<X0>(uint64_t a1@<X2>, uint64_t a2@<X4>, uint64_t a3@<X8>)
{
  return sub_1B52AA160(a1, a2, MEMORY[0x1E4FBBCD0], a3);
}

uint64_t static FixedPointFraction<>.- infix(_:_:)@<X0>(uint64_t a1@<X2>, uint64_t a2@<X4>, uint64_t a3@<X8>)
{
  return sub_1B52AA160(a1, a2, MEMORY[0x1E4FBBCD8], a3);
}

uint64_t sub_1B52AA160@<X0>(uint64_t a1@<X2>, uint64_t a2@<X4>, void (*a3)(char *, char *, uint64_t, uint64_t)@<X5>, uint64_t a4@<X8>)
{
  uint64_t v21 = a2;
  FontParser::Encoding_optional v22 = a3;
  uint64_t v20 = a4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v8 = (char *)&v19 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  unint64_t v11 = (char *)&v19 - v10;
  MEMORY[0x1F4188790](v12);
  uint64_t v13 = sub_1B5372CD8();
  MEMORY[0x1F4188790](v13 - 8);
  unsigned __int16 v15 = (char *)&v19 - v14;
  sub_1B53729C8();
  sub_1B53729C8();
  v22(v11, v8, AssociatedTypeWitness, v21);
  uint64_t v16 = *(void (**)(char *, uint64_t))(v6 + 8);
  v16(v8, AssociatedTypeWitness);
  v16(v11, AssociatedTypeWitness);
  sub_1B53729D8();
  uint64_t v17 = *(void *)(a1 - 8);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v17 + 48))(v15, 1, a1);
  if (result != 1) {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v17 + 32))(v20, v15, a1);
  }
  __break(1u);
  return result;
}

uint64_t FixedPointFraction.description.getter(uint64_t a1, uint64_t a2)
{
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  double v5 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t, double))(a2 + 48))(a1, a2, v5);
  return sub_1B5372798();
}

uint64_t Fixed.rawValue.setter(uint64_t result)
{
  *double v1 = result;
  return result;
}

uint64_t (*Fixed.rawValue.modify())(void)
{
  return nullsub_1;
}

BOOL static Fixed.< infix(_:_:)(int a1, int a2)
{
  return a1 < a2;
}

double sub_1B52AA4C4@<D0>(double *a1@<X8>)
{
  double result = (double)*v1 * 0.0000152587891;
  *a1 = result;
  return result;
}

BOOL sub_1B52AA4E4(_DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

BOOL sub_1B52AA4F8(_DWORD *a1, _DWORD *a2)
{
  return *a2 >= *a1;
}

BOOL sub_1B52AA50C(_DWORD *a1, _DWORD *a2)
{
  return *a1 >= *a2;
}

BOOL sub_1B52AA520(_DWORD *a1, _DWORD *a2)
{
  return *a2 < *a1;
}

double *sub_1B52AA534@<X0>(double *result@<X0>, _DWORD *a2@<X8>)
{
  double v2 = round(*result * 65536.0);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0)
  {
    __break(1u);
    goto LABEL_6;
  }
  if (v2 <= -2147483650.0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }
  if (v2 < 2147483650.0)
  {
    *a2 = (int)v2;
    return result;
  }
LABEL_7:
  __break(1u);
  return result;
}

uint64_t sub_1B52AA594()
{
  return sub_1B5372798();
}

void sub_1B52AA5DC(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

_DWORD *sub_1B52AA5E4@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (__OFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result + *a2;
  }
  return result;
}

_DWORD *sub_1B52AA600(_DWORD *result, _DWORD *a2)
{
  if (__OFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result += *a2;
  }
  return result;
}

_DWORD *sub_1B52AA61C@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

_DWORD *sub_1B52AA638(_DWORD *result, _DWORD *a2)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

uint64_t static ShortFrac.min.getter()
{
  return 0x8000;
}

uint64_t static ShortFrac.max.getter()
{
  return 0x7FFFLL;
}

uint64_t ShortFrac.rawValue.setter(uint64_t result)
{
  *double v1 = result;
  return result;
}

uint64_t (*ShortFrac.rawValue.modify())(void)
{
  return nullsub_1;
}

uint64_t ShortFrac.init(floatLiteral:)(double a1)
{
  double v1 = round(a1 * 16384.0);
  if ((~*(void *)&v1 & 0x7FF0000000000000) == 0)
  {
    __break(1u);
    goto LABEL_6;
  }
  if (v1 <= -32769.0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }
  if (v1 < 32768.0) {
    return (int)v1;
  }
LABEL_7:
  __break(1u);
  return result;
}

BOOL static ShortFrac.< infix(_:_:)(__int16 a1, __int16 a2)
{
  return a1 < a2;
}

unint64_t sub_1B52AA6FC(void *a1)
{
  a1[1] = sub_1B52AA744();
  a1[2] = sub_1B52AA798();
  a1[3] = sub_1B52AA7EC();
  a1[4] = sub_1B52AA840();
  unint64_t result = sub_1B52AA894();
  a1[5] = result;
  return result;
}

unint64_t sub_1B52AA744()
{
  unint64_t result = qword_1E9D49150;
  if (!qword_1E9D49150)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49150);
  }
  return result;
}

unint64_t sub_1B52AA798()
{
  unint64_t result = qword_1E9D49158;
  if (!qword_1E9D49158)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49158);
  }
  return result;
}

unint64_t sub_1B52AA7EC()
{
  unint64_t result = qword_1E9D49160;
  if (!qword_1E9D49160)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49160);
  }
  return result;
}

unint64_t sub_1B52AA840()
{
  unint64_t result = qword_1E9D49168;
  if (!qword_1E9D49168)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49168);
  }
  return result;
}

unint64_t sub_1B52AA894()
{
  unint64_t result = qword_1E9D49170;
  if (!qword_1E9D49170)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49170);
  }
  return result;
}

unint64_t sub_1B52AA8EC()
{
  unint64_t result = qword_1E9D49178;
  if (!qword_1E9D49178)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49178);
  }
  return result;
}

uint64_t sub_1B52AA940()
{
  return MEMORY[0x1E4FBB450];
}

double sub_1B52AA94C@<D0>(double *a1@<X8>, int16x4_t a2@<D0>)
{
  a2.i16[0] = *v2;
  double result = (double)vmovl_s16(a2).i32[0] * 0.0000610351562;
  *a1 = result;
  return result;
}

unint64_t sub_1B52AA970(void *a1)
{
  a1[1] = sub_1B52AA9B8();
  a1[2] = sub_1B52AAA0C();
  a1[3] = sub_1B52AAA60();
  a1[4] = sub_1B52AAAB4();
  unint64_t result = sub_1B52AAB08();
  a1[5] = result;
  return result;
}

unint64_t sub_1B52AA9B8()
{
  unint64_t result = qword_1E9D49180;
  if (!qword_1E9D49180)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49180);
  }
  return result;
}

unint64_t sub_1B52AAA0C()
{
  unint64_t result = qword_1E9D49188;
  if (!qword_1E9D49188)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49188);
  }
  return result;
}

unint64_t sub_1B52AAA60()
{
  unint64_t result = qword_1E9D49190;
  if (!qword_1E9D49190)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49190);
  }
  return result;
}

unint64_t sub_1B52AAAB4()
{
  unint64_t result = qword_1E9D49198;
  if (!qword_1E9D49198)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49198);
  }
  return result;
}

unint64_t sub_1B52AAB08()
{
  unint64_t result = qword_1E9D491A0;
  if (!qword_1E9D491A0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D491A0);
  }
  return result;
}

unint64_t sub_1B52AAB60()
{
  unint64_t result = qword_1E9D491A8;
  if (!qword_1E9D491A8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D491A8);
  }
  return result;
}

BOOL sub_1B52AABB4(__int16 *a1, __int16 *a2)
{
  return *a1 < *a2;
}

BOOL sub_1B52AABC8(__int16 *a1, __int16 *a2)
{
  return *a2 >= *a1;
}

BOOL sub_1B52AABDC(__int16 *a1, __int16 *a2)
{
  return *a1 >= *a2;
}

BOOL sub_1B52AABF0(__int16 *a1, __int16 *a2)
{
  return *a2 < *a1;
}

double *sub_1B52AAC04@<X0>(double *result@<X0>, _WORD *a2@<X8>)
{
  double v2 = round(*result * 16384.0);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0)
  {
    __break(1u);
    goto LABEL_6;
  }
  if (v2 <= -32769.0)
  {
LABEL_6:
    __break(1u);
    goto LABEL_7;
  }
  if (v2 < 32768.0)
  {
    *a2 = (int)v2;
    return result;
  }
LABEL_7:
  __break(1u);
  return result;
}

uint64_t sub_1B52AAC64()
{
  return sub_1B5372798();
}

__int16 *sub_1B52AACB0@<X0>(__int16 *result@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result + *a2;
  if ((__int16)(*result + *a2) == v3) {
    *a3 = v3;
  }
  else {
    __break(1u);
  }
  return result;
}

__int16 *sub_1B52AACD4(__int16 *result, __int16 *a2)
{
  int v2 = *result + *a2;
  if ((__int16)(*result + *a2) == v2) {
    *unint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

__int16 *sub_1B52AACF8@<X0>(__int16 *result@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result - *a2;
  if ((__int16)(*result - *a2) == v3) {
    *a3 = v3;
  }
  else {
    __break(1u);
  }
  return result;
}

__int16 *sub_1B52AAD1C(__int16 *result, __int16 *a2)
{
  int v2 = *result - *a2;
  if ((__int16)(*result - *a2) == v2) {
    *unint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

ValueMetadata *type metadata accessor for Fixed()
{
  return &type metadata for Fixed;
}

ValueMetadata *type metadata accessor for ShortFrac()
{
  return &type metadata for ShortFrac;
}

uint64_t sub_1B52AAD60(char **a1)
{
  int v2 = *a1;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    int v2 = sub_1B51DA99C((uint64_t)v2);
  }
  uint64_t v3 = *((void *)v2 + 2);
  v5[0] = (uint64_t)(v2 + 32);
  v5[1] = v3;
  uint64_t result = sub_1B52AB0E0(v5);
  *a1 = v2;
  return result;
}

uint64_t sub_1B52AADCC@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v3 = a2;
  uint64_t v4 = result;
  unint64_t v6 = *(void *)(result + 16);
  if (v6 == a2)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0xF000000000000000;
    goto LABEL_16;
  }
  uint64_t v9 = (unint64_t *)(result + 16 * a2 + 40);
  while (2)
  {
    if (v3 >= v6)
    {
      __break(1u);
      goto LABEL_18;
    }
    unint64_t v10 = v3 + 1;
    if (__OFADD__(v3, 1))
    {
LABEL_18:
      __break(1u);
      JUMPOUT(0x1B52AAEDCLL);
    }
    uint64_t v7 = *(v9 - 1);
    unint64_t v8 = *v9;
    switch(*v9 >> 62)
    {
      case 1uLL:
        if ((int)v7 != v7 >> 32) {
          goto LABEL_13;
        }
        goto LABEL_6;
      case 2uLL:
        if (*(void *)(v7 + 16) == *(void *)(v7 + 24)) {
          goto LABEL_6;
        }
LABEL_13:
        uint64_t result = sub_1B51D4BB8(*(v9 - 1), *v9);
        goto LABEL_15;
      case 3uLL:
        goto LABEL_5;
      default:
        if ((v8 & 0xFF000000000000) != 0) {
          goto LABEL_15;
        }
LABEL_5:
        uint64_t result = sub_1B51D4C64(*(v9 - 1), *v9);
LABEL_6:
        unint64_t v6 = *(void *)(v4 + 16);
        ++v3;
        v9 += 2;
        if (v10 != v6) {
          continue;
        }
        uint64_t v7 = 0;
        unint64_t v8 = 0xF000000000000000;
LABEL_15:
        unint64_t v3 = v10;
        break;
    }
    break;
  }
LABEL_16:
  *a3 = v7;
  a3[1] = v8;
  a3[2] = v4;
  a3[3] = v3;
  return result;
}

uint64_t LaserWriterContainer.containerType.getter()
{
  return 3;
}

uint64_t LaserWriterContainer.fonts.getter()
{
  return swift_bridgeObjectRetain();
}

FontParser::LaserWriterContainer __swiftcall LaserWriterContainer.init(constructed:)(Swift::OpaquePointer constructed)
{
  FontParser::FontDataResidence v2 = FontParser_FontDataResidence_inMemory;
  result.type1.fonts = constructed;
  result.type1.dataResidence = v2;
  return result;
}

uint64_t LaserWriterContainer.init(data:residence:)(uint64_t a1, void *a2, uint64_t a3)
{
  sub_1B51D4BB8(a1, (unint64_t)a2);
  uint64_t v7 = sub_1B51D33B0(a1, a2);
  if (!v3) {
    a3 = sub_1B52ABA04((uint64_t)v7, a3);
  }
  sub_1B51D4C64(a1, (unint64_t)a2);
  return a3;
}

uint64_t LaserWriterContainer.encoded()()
{
  sub_1B5201CFC();
  swift_allocError();
  *__int16 v0 = 0;
  return swift_willThrow();
}

uint64_t sub_1B52AAFF4@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  sub_1B51D4BB8(a1, (unint64_t)a2);
  uint64_t v9 = sub_1B51D33B0(a1, a2);
  if (v4) {
    return sub_1B51D4C64(a1, (unint64_t)a2);
  }
  char v10 = sub_1B52ABA04((uint64_t)v9, a3);
  uint64_t v12 = v11;
  uint64_t result = sub_1B51D4C64(a1, (unint64_t)a2);
  *(unsigned char *)a4 = v10;
  *(void *)(a4 + 8) = v12;
  return result;
}

uint64_t sub_1B52AB094()
{
  sub_1B5201CFC();
  swift_allocError();
  *__int16 v0 = 0;
  return swift_willThrow();
}

uint64_t sub_1B52AB0E0(uint64_t *a1)
{
  uint64_t v3 = a1[1];
  uint64_t result = sub_1B53731D8();
  if (result >= v3)
  {
    if (v3 < 0) {
      goto LABEL_137;
    }
    if ((unint64_t)v3 >= 2)
    {
      uint64_t v91 = 0;
      uint64_t v92 = *a1;
      for (uint64_t i = 1; i != v3; ++i)
      {
        uint64_t v94 = *(void *)(v92 + 40 * i);
        uint64_t v95 = v91;
        do
        {
          uint64_t v96 = v92 + v95;
          if (v94 >= *(void *)(v92 + v95)) {
            break;
          }
          if (!v92) {
            goto LABEL_141;
          }
          uint64_t v97 = v92 + v95;
          long long v98 = *(_OWORD *)(v92 + v95 + 48);
          long long v99 = *(_OWORD *)(v92 + v95 + 64);
          long long v100 = *(_OWORD *)(v96 + 16);
          *(_OWORD *)(v92 + v95 + 40) = *(_OWORD *)v96;
          *(_OWORD *)(v92 + v95 + 56) = v100;
          *(void *)(v92 + v95 + 72) = *(void *)(v96 + 32);
          *(void *)uint64_t v97 = v94;
          *(_OWORD *)(v97 + 8) = v98;
          *(_OWORD *)(v97 + 24) = v99;
          v95 -= 40;
        }
        while (v95 != -40);
        v91 += 40;
      }
    }
  }
  else
  {
    if (v3 >= 0) {
      uint64_t v5 = v3;
    }
    else {
      uint64_t v5 = v3 + 1;
    }
    if (v3 < -1) {
      goto LABEL_136;
    }
    uint64_t v6 = result;
    v109 = a1;
    if (v3 > 1)
    {
      uint64_t v7 = v5 >> 1;
      uint64_t result = sub_1B5372A88();
      *(void *)(result + 16) = v7;
      uint64_t v111 = result;
      uint64_t v115 = (char *)(result + 32);
LABEL_13:
      uint64_t v9 = 0;
      uint64_t v10 = *a1;
      uint64_t v110 = *a1 + 80;
      uint64_t v108 = *a1 - 40;
      uint64_t v11 = MEMORY[0x1E4FBC860];
      uint64_t v112 = v6;
      uint64_t v113 = v3;
      uint64_t v114 = v10;
      while (1)
      {
        uint64_t v13 = v9++;
        if (v9 < v3)
        {
          uint64_t v14 = *(void *)(v10 + 40 * v9);
          uint64_t v15 = *(void *)(v10 + 40 * v13);
          uint64_t v9 = v13 + 2;
          if (v13 + 2 < v3)
          {
            uint64_t v16 = (uint64_t *)(v110 + 40 * v13);
            uint64_t v17 = v14;
            while (1)
            {
              uint64_t v19 = *v16;
              v16 += 5;
              uint64_t v18 = v19;
              if (v14 < v15 == v19 >= v17) {
                break;
              }
              ++v9;
              uint64_t v17 = v18;
              if (v3 == v9)
              {
                uint64_t v9 = v3;
                break;
              }
            }
          }
          if (v14 < v15)
          {
            if (v9 < v13) {
              goto LABEL_138;
            }
            if (v13 < v9)
            {
              uint64_t v20 = 40 * v9;
              uint64_t v21 = 40 * v13;
              uint64_t v22 = v9;
              uint64_t v23 = v13;
              do
              {
                if (v23 != --v22)
                {
                  if (!v10) {
                    goto LABEL_144;
                  }
                  uint64_t v24 = v10 + v21;
                  uint64_t v25 = *(void *)(v10 + v21 + 32);
                  uint64_t v26 = v10 + v20;
                  long long v27 = *(_OWORD *)(v10 + v21);
                  long long v28 = *(_OWORD *)(v10 + v21 + 16);
                  uint64_t v29 = *(void *)(v10 + v20 - 8);
                  long long v30 = *(_OWORD *)(v10 + v20 - 24);
                  *(_OWORD *)uint64_t v24 = *(_OWORD *)(v10 + v20 - 40);
                  *(_OWORD *)(v24 + 16) = v30;
                  *(void *)(v24 + 32) = v29;
                  *(_OWORD *)(v26 - 40) = v27;
                  *(_OWORD *)(v26 - 24) = v28;
                  *(void *)(v26 - 8) = v25;
                }
                ++v23;
                v20 -= 40;
                v21 += 40;
              }
              while (v23 < v22);
            }
          }
        }
        if (v9 < v3)
        {
          if (__OFSUB__(v9, v13)) {
            goto LABEL_135;
          }
          if (v9 - v13 < v6)
          {
            uint64_t v31 = v13 + v6;
            if (__OFADD__(v13, v6)) {
              goto LABEL_139;
            }
            if (v31 >= v3) {
              uint64_t v31 = v3;
            }
            if (v31 < v13)
            {
LABEL_140:
              __break(1u);
LABEL_141:
              __break(1u);
LABEL_142:
              __break(1u);
LABEL_143:
              __break(1u);
LABEL_144:
              __break(1u);
LABEL_145:
              __break(1u);
              return result;
            }
            if (v9 != v31)
            {
              uint64_t v32 = v108 + 40 * v9;
              do
              {
                uint64_t v33 = *(void *)(v10 + 40 * v9);
                uint64_t v34 = v13;
                uint64_t v35 = v32;
                do
                {
                  uint64_t v36 = v35 + 40;
                  if (v33 >= *(void *)v35) {
                    break;
                  }
                  if (!v10) {
                    goto LABEL_142;
                  }
                  long long v37 = *(_OWORD *)(v35 + 48);
                  long long v38 = *(_OWORD *)(v35 + 64);
                  long long v39 = *(_OWORD *)(v35 + 16);
                  *(_OWORD *)uint64_t v36 = *(_OWORD *)v35;
                  *(_OWORD *)(v35 + 56) = v39;
                  uint64_t v40 = *(void *)(v35 + 32);
                  *(void *)uint64_t v35 = v33;
                  *(_OWORD *)(v35 + 8) = v37;
                  *(_OWORD *)(v35 + 24) = v38;
                  v35 -= 40;
                  ++v34;
                  *(void *)(v36 + 32) = v40;
                }
                while (v9 != v34);
                ++v9;
                v32 += 40;
              }
              while (v9 != v31);
              uint64_t v9 = v31;
            }
          }
        }
        if (v9 < v13) {
          goto LABEL_130;
        }
        uint64_t result = swift_isUniquelyReferenced_nonNull_native();
        if ((result & 1) == 0)
        {
          uint64_t result = (uint64_t)sub_1B51DA83C(0, *(void *)(v11 + 16) + 1, 1, (char *)v11);
          uint64_t v11 = result;
        }
        unint64_t v42 = *(void *)(v11 + 16);
        unint64_t v41 = *(void *)(v11 + 24);
        unint64_t v12 = v42 + 1;
        uint64_t v10 = v114;
        if (v42 >= v41 >> 1)
        {
          uint64_t result = (uint64_t)sub_1B51DA83C((char *)(v41 > 1), v42 + 1, 1, (char *)v11);
          uint64_t v10 = v114;
          uint64_t v11 = result;
        }
        *(void *)(v11 + 16) = v12;
        uint64_t v43 = v11 + 32;
        long long v44 = (uint64_t *)(v11 + 32 + 16 * v42);
        *long long v44 = v13;
        v44[1] = v9;
        if (v42)
        {
          while (1)
          {
            unint64_t v45 = v12 - 1;
            if (v12 >= 4)
            {
              unint64_t v50 = v43 + 16 * v12;
              uint64_t v51 = *(void *)(v50 - 64);
              uint64_t v52 = *(void *)(v50 - 56);
              BOOL v56 = __OFSUB__(v52, v51);
              uint64_t v53 = v52 - v51;
              if (v56) {
                goto LABEL_119;
              }
              uint64_t v55 = *(void *)(v50 - 48);
              uint64_t v54 = *(void *)(v50 - 40);
              BOOL v56 = __OFSUB__(v54, v55);
              uint64_t v48 = v54 - v55;
              char v49 = v56;
              if (v56) {
                goto LABEL_120;
              }
              unint64_t v57 = v12 - 2;
              uint64_t v58 = (uint64_t *)(v43 + 16 * (v12 - 2));
              uint64_t v60 = *v58;
              uint64_t v59 = v58[1];
              BOOL v56 = __OFSUB__(v59, v60);
              uint64_t v61 = v59 - v60;
              if (v56) {
                goto LABEL_121;
              }
              BOOL v56 = __OFADD__(v48, v61);
              uint64_t v62 = v48 + v61;
              if (v56) {
                goto LABEL_123;
              }
              if (v62 >= v53)
              {
                long long v80 = (uint64_t *)(v43 + 16 * v45);
                uint64_t v82 = *v80;
                uint64_t v81 = v80[1];
                BOOL v56 = __OFSUB__(v81, v82);
                uint64_t v83 = v81 - v82;
                if (v56) {
                  goto LABEL_129;
                }
                BOOL v73 = v48 < v83;
                goto LABEL_83;
              }
            }
            else
            {
              if (v12 != 3)
              {
                uint64_t v74 = *(void *)(v11 + 32);
                uint64_t v75 = *(void *)(v11 + 40);
                BOOL v56 = __OFSUB__(v75, v74);
                uint64_t v67 = v75 - v74;
                char v68 = v56;
                goto LABEL_77;
              }
              uint64_t v47 = *(void *)(v11 + 32);
              uint64_t v46 = *(void *)(v11 + 40);
              BOOL v56 = __OFSUB__(v46, v47);
              uint64_t v48 = v46 - v47;
              char v49 = v56;
            }
            if (v49) {
              goto LABEL_122;
            }
            unint64_t v57 = v12 - 2;
            unint64_t v63 = (uint64_t *)(v43 + 16 * (v12 - 2));
            uint64_t v65 = *v63;
            uint64_t v64 = v63[1];
            BOOL v66 = __OFSUB__(v64, v65);
            uint64_t v67 = v64 - v65;
            char v68 = v66;
            if (v66) {
              goto LABEL_124;
            }
            long long v69 = (uint64_t *)(v43 + 16 * v45);
            uint64_t v71 = *v69;
            uint64_t v70 = v69[1];
            BOOL v56 = __OFSUB__(v70, v71);
            uint64_t v72 = v70 - v71;
            if (v56) {
              goto LABEL_126;
            }
            if (__OFADD__(v67, v72)) {
              goto LABEL_128;
            }
            if (v67 + v72 >= v48)
            {
              BOOL v73 = v48 < v72;
LABEL_83:
              if (v73) {
                unint64_t v45 = v57;
              }
              goto LABEL_85;
            }
LABEL_77:
            if (v68) {
              goto LABEL_125;
            }
            unsigned __int8 v76 = (uint64_t *)(v43 + 16 * v45);
            uint64_t v78 = *v76;
            uint64_t v77 = v76[1];
            BOOL v56 = __OFSUB__(v77, v78);
            uint64_t v79 = v77 - v78;
            if (v56) {
              goto LABEL_127;
            }
            if (v79 < v67) {
              goto LABEL_15;
            }
LABEL_85:
            unint64_t v84 = v45 - 1;
            if (v45 - 1 >= v12)
            {
              __break(1u);
LABEL_116:
              __break(1u);
LABEL_117:
              __break(1u);
LABEL_118:
              __break(1u);
LABEL_119:
              __break(1u);
LABEL_120:
              __break(1u);
LABEL_121:
              __break(1u);
LABEL_122:
              __break(1u);
LABEL_123:
              __break(1u);
LABEL_124:
              __break(1u);
LABEL_125:
              __break(1u);
LABEL_126:
              __break(1u);
LABEL_127:
              __break(1u);
LABEL_128:
              __break(1u);
LABEL_129:
              __break(1u);
LABEL_130:
              __break(1u);
LABEL_131:
              __break(1u);
LABEL_132:
              __break(1u);
LABEL_133:
              __break(1u);
LABEL_134:
              __break(1u);
LABEL_135:
              __break(1u);
LABEL_136:
              __break(1u);
LABEL_137:
              __break(1u);
LABEL_138:
              __break(1u);
LABEL_139:
              __break(1u);
              goto LABEL_140;
            }
            if (!v10) {
              goto LABEL_143;
            }
            uint64_t v85 = v11;
            long long v86 = (uint64_t *)(v43 + 16 * v84);
            uint64_t v87 = *v86;
            long long v88 = (void *)(v43 + 16 * v45);
            uint64_t v89 = v88[1];
            uint64_t result = sub_1B52AB7C4((char *)(v10 + 40 * *v86), (char *)(v10 + 40 * *v88), v10 + 40 * v89, v115);
            if (v1) {
              goto LABEL_93;
            }
            if (v89 < v87) {
              goto LABEL_116;
            }
            if (v45 > *(void *)(v85 + 16)) {
              goto LABEL_117;
            }
            *long long v86 = v87;
            *(void *)(v43 + 16 * v84 + 8) = v89;
            unint64_t v90 = *(void *)(v85 + 16);
            if (v45 >= v90) {
              goto LABEL_118;
            }
            uint64_t v11 = v85;
            unint64_t v12 = v90 - 1;
            uint64_t result = (uint64_t)memmove((void *)(v43 + 16 * v45), v88 + 2, 16 * (v90 - 1 - v45));
            *(void *)(v85 + 16) = v90 - 1;
            uint64_t v10 = v114;
            if (v90 <= 2) {
              goto LABEL_15;
            }
          }
        }
        unint64_t v12 = 1;
LABEL_15:
        uint64_t v6 = v112;
        uint64_t v3 = v113;
        if (v9 >= v113)
        {
          uint64_t v8 = v111;
          goto LABEL_102;
        }
      }
    }
    uint64_t v8 = MEMORY[0x1E4FBC860];
    uint64_t v115 = (char *)(MEMORY[0x1E4FBC860] + 32);
    if (v3 == 1)
    {
      uint64_t v111 = MEMORY[0x1E4FBC860];
      goto LABEL_13;
    }
    unint64_t v12 = *(void *)(MEMORY[0x1E4FBC860] + 16);
    uint64_t v11 = MEMORY[0x1E4FBC860];
LABEL_102:
    uint64_t result = v11;
    uint64_t v111 = v8;
    if (v12 >= 2)
    {
      uint64_t v101 = *v109;
      do
      {
        unint64_t v102 = v12 - 2;
        if (v12 < 2) {
          goto LABEL_131;
        }
        if (!v101) {
          goto LABEL_145;
        }
        uint64_t v103 = result;
        uint64_t v104 = *(void *)(result + 32 + 16 * v102);
        uint64_t v105 = *(void *)(result + 32 + 16 * (v12 - 1) + 8);
        uint64_t result = sub_1B52AB7C4((char *)(v101 + 40 * v104), (char *)(v101 + 40 * *(void *)(result + 32 + 16 * (v12 - 1))), v101 + 40 * v105, v115);
        if (v1) {
          break;
        }
        if (v105 < v104) {
          goto LABEL_132;
        }
        uint64_t result = swift_isUniquelyReferenced_nonNull_native();
        if ((result & 1) == 0)
        {
          uint64_t result = (uint64_t)sub_1B51DA938(v103);
          uint64_t v103 = result;
        }
        if (v102 >= *(void *)(v103 + 16)) {
          goto LABEL_133;
        }
        long long v106 = (void *)(v103 + 32 + 16 * v102);
        *long long v106 = v104;
        v106[1] = v105;
        unint64_t v107 = *(void *)(v103 + 16);
        if (v12 > v107) {
          goto LABEL_134;
        }
        memmove((void *)(v103 + 32 + 16 * (v12 - 1)), (const void *)(v103 + 32 + 16 * v12), 16 * (v107 - v12));
        uint64_t result = v103;
        *(void *)(v103 + 16) = v107 - 1;
        unint64_t v12 = v107 - 1;
      }
      while (v107 > 2);
    }
LABEL_93:
    swift_bridgeObjectRelease();
    *(void *)(v111 + 16) = 0;
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t sub_1B52AB7C4(char *__dst, char *__src, unint64_t a3, char *a4)
{
  uint64_t v4 = a4;
  uint64_t v6 = __src;
  uint64_t v7 = __dst;
  int64_t v8 = __src - __dst;
  int64_t v9 = (__src - __dst) / 40;
  uint64_t v10 = a3 - (void)__src;
  uint64_t v11 = (uint64_t)(a3 - (void)__src) / 40;
  if (v9 >= v11)
  {
    if (a4 != __src || &__src[40 * v11] <= a4) {
      memmove(a4, __src, 40 * v11);
    }
    unint64_t v12 = &v4[40 * v11];
    if (v7 >= v6 || v10 < 40) {
      goto LABEL_36;
    }
    unint64_t v17 = a3 - 40;
    while (1)
    {
      uint64_t v18 = (char *)(v17 + 40);
      uint64_t v19 = v6 - 40;
      if (*((void *)v12 - 5) >= *((void *)v6 - 5))
      {
        uint64_t v19 = v12 - 40;
        if (v18 != v12)
        {
          v12 -= 40;
          goto LABEL_33;
        }
        BOOL v20 = v17 >= (unint64_t)v12;
        v12 -= 40;
        if (v20) {
          goto LABEL_33;
        }
      }
      else
      {
        if (v18 != v6)
        {
          v6 -= 40;
LABEL_33:
          long long v21 = *(_OWORD *)v19;
          long long v22 = *((_OWORD *)v19 + 1);
          *(void *)(v17 + 32) = *((void *)v19 + 4);
          *(_OWORD *)unint64_t v17 = v21;
          *(_OWORD *)(v17 + 16) = v22;
          goto LABEL_34;
        }
        BOOL v20 = v17 >= (unint64_t)v6;
        v6 -= 40;
        if (v20) {
          goto LABEL_33;
        }
      }
LABEL_34:
      if (v6 > v7)
      {
        v17 -= 40;
        if (v12 > v4) {
          continue;
        }
      }
      goto LABEL_36;
    }
  }
  if (a4 != __dst || &__dst[40 * v9] <= a4) {
    memmove(a4, __dst, 40 * v9);
  }
  unint64_t v12 = &v4[40 * v9];
  if ((unint64_t)v6 < a3 && v8 >= 40)
  {
    while (*(void *)v6 < *(void *)v4)
    {
      uint64_t v13 = v6;
      BOOL v14 = v7 == v6;
      v6 += 40;
      if (!v14) {
        goto LABEL_12;
      }
LABEL_13:
      v7 += 40;
      if (v4 >= v12 || (unint64_t)v6 >= a3) {
        goto LABEL_15;
      }
    }
    uint64_t v13 = v4;
    BOOL v14 = v7 == v4;
    v4 += 40;
    if (v14) {
      goto LABEL_13;
    }
LABEL_12:
    long long v15 = *(_OWORD *)v13;
    long long v16 = *((_OWORD *)v13 + 1);
    *((void *)v7 + 4) = *((void *)v13 + 4);
    *(_OWORD *)uint64_t v7 = v15;
    *((_OWORD *)v7 + 1) = v16;
    goto LABEL_13;
  }
LABEL_15:
  uint64_t v6 = v7;
LABEL_36:
  uint64_t v23 = (unsigned __int128)((v12 - v4) * (__int128)0x6666666666666667) >> 64;
  uint64_t v24 = (v23 >> 4) + ((unint64_t)v23 >> 63);
  if (v6 != v4 || v6 >= &v4[40 * v24]) {
    memmove(v6, v4, 40 * v24);
  }
  return 1;
}

uint64_t sub_1B52ABA04(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 16) && (uint64_t v3 = a2, v5 = sub_1B5230664(1347375956), (v6 & 1) != 0))
  {
    uint64_t v7 = *(char **)(*(void *)(a1 + 56) + 8 * v5);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    uint64_t v33 = v7;
    swift_bridgeObjectRetain();
    sub_1B52AAD60(&v33);
    if (v2) {
      goto LABEL_25;
    }
    swift_bridgeObjectRelease();
    int64_t v8 = v33;
    int64_t v9 = *((void *)v33 + 2);
    if (v9)
    {
      unsigned int v38 = v3;
      uint64_t v33 = (char *)MEMORY[0x1E4FBC860];
      sub_1B521CED0(0, v9, 0);
      uint64_t v10 = v33;
      uint64_t v11 = (unint64_t *)(v8 + 64);
      while (1)
      {
        uint64_t v12 = *(v11 - 1);
        unint64_t v14 = *v11;
        v11 += 5;
        unint64_t v13 = v14;
        switch(v14 >> 62)
        {
          case 1uLL:
            uint64_t v15 = (int)v12;
            uint64_t v17 = (int)v12 + 2;
            uint64_t v16 = v12 >> 32;
            goto LABEL_11;
          case 2uLL:
            uint64_t v15 = *(void *)(v12 + 16);
            uint64_t v17 = v15 + 2;
            if (__OFADD__(v15, 2))
            {
              __break(1u);
LABEL_24:
              __break(1u);
LABEL_25:
              swift_release();
              __break(1u);
              JUMPOUT(0x1B52ABD80);
            }
            uint64_t v16 = *(void *)(v12 + 24);
LABEL_11:
            if (v16 < v15 || v16 < v17) {
              goto LABEL_24;
            }
            swift_bridgeObjectRetain();
            sub_1B51D4BB8(v12, v13);
            uint64_t v19 = sub_1B5372398();
            uint64_t v21 = v20;
            swift_bridgeObjectRelease();
            sub_1B51D4C64(v12, v13);
            uint64_t v33 = v10;
            unint64_t v23 = *((void *)v10 + 2);
            unint64_t v22 = *((void *)v10 + 3);
            if (v23 >= v22 >> 1)
            {
              sub_1B521CED0((char *)(v22 > 1), v23 + 1, 1);
              uint64_t v10 = v33;
            }
            *((void *)v10 + 2) = v23 + 1;
            uint64_t v24 = &v10[16 * v23];
            *((void *)v24 + 4) = v19;
            *((void *)v24 + 5) = v21;
            if (!--v9)
            {
              swift_release();
              uint64_t v3 = v38;
              goto LABEL_21;
            }
            break;
          case 3uLL:
            goto LABEL_24;
          default:
            uint64_t v15 = 0;
            uint64_t v16 = BYTE6(v13);
            uint64_t v17 = 2;
            goto LABEL_11;
        }
      }
    }
    swift_release();
    uint64_t v10 = (char *)MEMORY[0x1E4FBC860];
LABEL_21:
    sub_1B52AADCC((uint64_t)v10, 0, (uint64_t *)&v33);
    uint64_t v26 = v33;
    unint64_t v27 = v34;
    uint64_t v29 = v35;
    uint64_t v28 = v36;
    sub_1B520AB50((uint64_t)v33, v34);
    swift_bridgeObjectRetain();
    sub_1B52029D0((uint64_t)v26, v27, v29, v28, v37);
    uint64_t v31 = PSInterpreter.copyFonts()();
    MEMORY[0x1F4188790](v31);
    sub_1B520A634(v32, (void (*)(void *__return_ptr, unint64_t, uint64_t))sub_1B5203450);
    sub_1B51FE548((uint64_t)v26, v27);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    sub_1B520A898((uint64_t)v37);
    sub_1B51FE548((uint64_t)v26, v27);
    swift_bridgeObjectRelease();
  }
  else
  {
    swift_bridgeObjectRelease();
    sub_1B520AB64();
    swift_allocError();
    *uint64_t v25 = 1;
    swift_willThrow();
  }
  return v3;
}

ValueMetadata *type metadata accessor for LaserWriterContainer()
{
  return &type metadata for LaserWriterContainer;
}

uint64_t sub_1B52ABDA0()
{
  uint64_t v1 = sub_1B5372788();
  uint64_t v2 = *(void *)(v1 - 8);
  MEMORY[0x1F4188790](v1);
  uint64_t v4 = (char *)&v14 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1B5372758();
  uint64_t v5 = sub_1B53726F8();
  unint64_t v7 = v6;
  (*(void (**)(char *, uint64_t))(v2 + 8))(v4, v1);
  if (v7 >> 60 != 15)
  {
    uint64_t v9 = *(void *)(v0 + 72);
    if (*(void *)(v9 + 16))
    {
      sub_1B51D4BB8(v5, v7);
      uint64_t v10 = sub_1B5230668(v5, v7);
      if (v11)
      {
        uint64_t v12 = *(unsigned int *)(*(void *)(v9 + 56) + 4 * v10);
        sub_1B51FE548(v5, v7);
        unint64_t v8 = sub_1B52ABF1C(v12 | 0x3000000000000);
LABEL_8:
        sub_1B51FE548(v5, v7);
        return v8;
      }
      sub_1B51FE548(v5, v7);
    }
    unint64_t v8 = 0xFF000000000000;
    goto LABEL_8;
  }
  return 0xFF000000000000;
}

unint64_t sub_1B52ABF1C(unint64_t result)
{
  uint64_t v2 = v1;
  if (BYTE6(result) != 9)
  {
    if (BYTE6(result) == 4) {
      unint64_t v3 = result;
    }
    else {
      unint64_t v3 = result;
    }
    if (BYTE6(result) == 4) {
      LOBYTE(v4) = 3;
    }
    else {
      unint64_t v4 = HIWORD(result);
    }
    goto LABEL_8;
  }
  uint64_t v15 = *(void *)(v1 + 48);
  if ((unint64_t)result < *(void *)(v15 + 16))
  {
    uint64_t v16 = *(void *)(v1 + 72);
    if (!*(void *)(v16 + 16)) {
      return 0xFF000000000000;
    }
    uint64_t v17 = v15 + 16 * result;
    uint64_t v18 = *(void *)(v17 + 32);
    unint64_t v19 = *(void *)(v17 + 40);
    sub_1B51D4BB8(v18, v19);
    uint64_t v20 = sub_1B5230668(v18, v19);
    if ((v21 & 1) == 0)
    {
      sub_1B51D4C64(v18, v19);
      return 0xFF000000000000;
    }
    unint64_t v3 = *(unsigned int *)(*(void *)(v16 + 56) + 4 * v20);
    uint64_t result = sub_1B51D4C64(v18, v19);
    LOBYTE(v4) = 3;
LABEL_8:
    uint64_t v5 = *(void *)(v2 + 16);
    uint64_t v6 = *(void *)(v5 + 16);
    if (v6)
    {
      uint64_t v7 = *(void *)(v2 + 40);
      uint64_t v8 = v7 + 32;
      unint64_t v9 = *(void *)(v7 + 16);
      unint64_t v10 = v3 & 0xFFFFFFFFFFFFLL | ((unint64_t)v4 << 48);
      uint64_t v11 = v5 + 28;
      while (1)
      {
        unint64_t v12 = *(unsigned int *)(v11 + 4 * v6);
        if (v9 <= v12) {
          break;
        }
        uint64_t v13 = *(void *)(v8 + 8 * v12);
        if (*(void *)(v13 + 16))
        {
          uint64_t result = sub_1B5230728(v10);
          if (v14) {
            return *(unsigned int *)(*(void *)(v13 + 56) + 8 * result) | ((unint64_t)*(unsigned __int16 *)(*(void *)(v13 + 56) + 8 * result + 4) << 32) | ((unint64_t)*(unsigned __int8 *)(*(void *)(v13 + 56) + 8 * result + 6) << 48);
          }
        }
        if (!--v6) {
          return 0xFF000000000000;
        }
      }
      __break(1u);
      goto LABEL_22;
    }
    return 0xFF000000000000;
  }
LABEL_22:
  __break(1u);
  return result;
}

uint64_t sub_1B52AC064(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (BYTE6(result) == 9)
  {
    uint64_t v8 = *(void *)(v3 + 48);
    if ((unint64_t)result >= *(void *)(v8 + 16))
    {
LABEL_19:
      __break(1u);
      return result;
    }
    uint64_t v9 = v8 + 16 * result;
    uint64_t v10 = *(void *)(v9 + 32);
    unint64_t v11 = *(void *)(v9 + 40);
    sub_1B51D4BB8(v10, v11);
    unsigned int v12 = sub_1B527751C(v10, v11);
    sub_1B51D4C64(v10, v11);
    uint64_t v6 = v12;
    unsigned __int8 v7 = 3;
  }
  else
  {
    if (BYTE6(result) == 4) {
      uint64_t v6 = result;
    }
    else {
      uint64_t v6 = result;
    }
    if (BYTE6(result) == 4) {
      unsigned __int8 v7 = 3;
    }
    else {
      unsigned __int8 v7 = BYTE6(result);
    }
  }
  uint64_t v13 = *(void **)(v3 + 40);
  uint64_t result = swift_isUniquelyReferenced_nonNull_native();
  *(void *)(v3 + 40) = v13;
  if ((result & 1) == 0)
  {
    uint64_t result = (uint64_t)sub_1B5293538(v13);
    uint64_t v13 = (void *)result;
    *(void *)(v3 + 40) = result;
  }
  if (v13[2] <= (unint64_t)a3)
  {
    __break(1u);
    goto LABEL_19;
  }
  char v14 = &v13[a3 + 4];
  if ((~a2 & 0xFF000000000000) == 0) {
    return sub_1B5215CB0(v6 & 0xFFFFFFFFFFFFLL | ((unint64_t)v7 << 48));
  }
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v16 = *v14;
  *char v14 = 0x8000000000000000;
  sub_1B52374D4(a2 & 0xFFFFFFFFFFFFFFLL, v6 & 0xFFFFFFFFFFFFLL | ((unint64_t)v7 << 48), isUniquelyReferenced_nonNull_native);
  *char v14 = v16;
  return swift_bridgeObjectRelease();
}

unint64_t sub_1B52AC1E4(unint64_t result)
{
  uint64_t v2 = v1;
  if (BYTE6(result) != 9)
  {
    if (BYTE6(result) == 4) {
      unint64_t v3 = result;
    }
    else {
      unint64_t v3 = result;
    }
    if (BYTE6(result) == 4) {
      LOBYTE(v4) = 3;
    }
    else {
      unint64_t v4 = HIWORD(result);
    }
LABEL_8:
    uint64_t v5 = *(void *)(v2 + 16);
    uint64_t v6 = *(void *)(v5 + 16);
    if (v6)
    {
      uint64_t v7 = *(void *)(v2 + 40);
      uint64_t v8 = v7 + 32;
      unint64_t v9 = *(void *)(v7 + 16);
      unint64_t v10 = v3 & 0xFFFFFFFFFFFFLL | ((unint64_t)v4 << 48);
      uint64_t v11 = v5 + 28;
      while (1)
      {
        unint64_t v12 = *(unsigned int *)(v11 + 4 * v6);
        if (v9 <= v12) {
          break;
        }
        if (*(void *)(*(void *)(v8 + 8 * v12) + 16))
        {
          uint64_t result = sub_1B5230728(v10);
          if (v13)
          {
            unsigned __int8 v14 = 0;
            return v12 | ((unint64_t)v14 << 32);
          }
        }
        if (!--v6) {
          goto LABEL_20;
        }
      }
      __break(1u);
      goto LABEL_23;
    }
    goto LABEL_20;
  }
  uint64_t v15 = *(void *)(v1 + 48);
  if ((unint64_t)result >= *(void *)(v15 + 16))
  {
LABEL_23:
    __break(1u);
    return result;
  }
  uint64_t v16 = *(void *)(v1 + 72);
  if (*(void *)(v16 + 16))
  {
    uint64_t v17 = v15 + 16 * result;
    uint64_t v18 = *(void *)(v17 + 32);
    unint64_t v19 = *(void *)(v17 + 40);
    sub_1B51D4BB8(v18, v19);
    uint64_t v20 = sub_1B5230668(v18, v19);
    if ((v21 & 1) == 0)
    {
      sub_1B51D4C64(v18, v19);
      goto LABEL_20;
    }
    unint64_t v3 = *(unsigned int *)(*(void *)(v16 + 56) + 4 * v20);
    uint64_t result = sub_1B51D4C64(v18, v19);
    LOBYTE(v4) = 3;
    goto LABEL_8;
  }
LABEL_20:
  unint64_t v12 = 0;
  unsigned __int8 v14 = 1;
  return v12 | ((unint64_t)v14 << 32);
}

unint64_t sub_1B52AC32C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4 = v3;
  uint64_t v6 = sub_1B5372788();
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v6);
  unint64_t v9 = (char *)&v22 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_1B5372758();
  uint64_t v10 = sub_1B53726F8();
  unint64_t v12 = v11;
  (*(void (**)(char *, uint64_t))(v7 + 8))(v9, v6);
  if (v12 >> 60 == 15) {
    return 0xFF000000000000;
  }
  uint64_t v13 = *(void *)(v3 + 72);
  if (!*(void *)(v13 + 16)) {
    goto LABEL_9;
  }
  sub_1B51D4BB8(v10, v12);
  uint64_t v14 = sub_1B5230668(v10, v12);
  if ((v15 & 1) == 0)
  {
    sub_1B51FE548(v10, v12);
LABEL_9:
    sub_1B51FE548(v10, v12);
    return 0xFF000000000000;
  }
  uint64_t v16 = *(unsigned int *)(*(void *)(v13 + 56) + 4 * v14);
  sub_1B51FE548(v10, v12);
  unint64_t result = sub_1B51FE548(v10, v12);
  uint64_t v18 = *(void *)(v4 + 40);
  if (*(void *)(v18 + 16) <= (unint64_t)a3)
  {
    __break(1u);
    return result;
  }
  uint64_t v19 = *(void *)(v18 + 8 * a3 + 32);
  if (*(void *)(v19 + 16))
  {
    unint64_t v20 = sub_1B5230728(v16 | 0x3000000000000);
    if (v21) {
      return *(unsigned int *)(*(void *)(v19 + 56) + 8 * v20) | ((unint64_t)*(unsigned __int16 *)(*(void *)(v19 + 56) + 8 * v20 + 4) << 32) | ((unint64_t)*(unsigned __int8 *)(*(void *)(v19 + 56) + 8 * v20 + 6) << 48);
    }
  }
  return 0xFF000000000000;
}

unint64_t sub_1B52AC4EC(unint64_t result, uint64_t a2)
{
  if (BYTE6(result) != 9)
  {
    if (BYTE6(result) == 4) {
      unint64_t v4 = result;
    }
    else {
      unint64_t v4 = result;
    }
    if (BYTE6(result) == 4) {
      LOBYTE(v5) = 3;
    }
    else {
      unint64_t v5 = HIWORD(result);
    }
    if (*(void *)(a2 + 16))
    {
LABEL_9:
      unint64_t v6 = sub_1B5230728(v4 & 0xFFFFFFFFFFFFLL | ((unint64_t)v5 << 48));
      if (v7) {
        return *(unsigned int *)(*(void *)(a2 + 56) + 8 * v6) | ((unint64_t)*(unsigned __int16 *)(*(void *)(a2 + 56) + 8 * v6 + 4) << 32) | ((unint64_t)*(unsigned __int8 *)(*(void *)(a2 + 56) + 8 * v6 + 6) << 48);
      }
      return 0xFF000000000000;
    }
    return 0xFF000000000000;
  }
  uint64_t v8 = *(void *)(v2 + 48);
  if ((unint64_t)result < *(void *)(v8 + 16))
  {
    uint64_t v9 = *(void *)(v2 + 72);
    if (*(void *)(v9 + 16))
    {
      uint64_t v10 = v8 + 16 * result;
      uint64_t v11 = *(void *)(v10 + 32);
      unint64_t v12 = *(void *)(v10 + 40);
      sub_1B51D4BB8(v11, v12);
      uint64_t v13 = sub_1B5230668(v11, v12);
      if (v14)
      {
        unint64_t v4 = *(unsigned int *)(*(void *)(v9 + 56) + 4 * v13);
        sub_1B51D4C64(v11, v12);
        LOBYTE(v5) = 3;
        if (*(void *)(a2 + 16)) {
          goto LABEL_9;
        }
      }
      else
      {
        sub_1B51D4C64(v11, v12);
      }
    }
    return 0xFF000000000000;
  }
  __break(1u);
  return result;
}

uint64_t sub_1B52AC5F0(__int16 a1, uint64_t a2, unint64_t a3)
{
  switch(a3 >> 62)
  {
    case 1uLL:
      LODWORD(v3) = HIDWORD(a2) - a2;
      if (__OFSUB__(HIDWORD(a2), a2)) {
        goto LABEL_17;
      }
      uint64_t v3 = (int)v3;
LABEL_6:
      if (!a1) {
        goto LABEL_13;
      }
      if (a1 != 1) {
        goto LABEL_19;
      }
      uint64_t v7 = 4;
      goto LABEL_14;
    case 2uLL:
      uint64_t v5 = *(void *)(a2 + 16);
      uint64_t v4 = *(void *)(a2 + 24);
      BOOL v6 = __OFSUB__(v4, v5);
      uint64_t v3 = v4 - v5;
      if (!v6) {
        goto LABEL_6;
      }
      goto LABEL_18;
    case 3uLL:
      if (a1)
      {
        if (a1 != 1) {
          goto LABEL_19;
        }
        uint64_t v3 = 0;
        uint64_t v7 = 4;
      }
      else
      {
        uint64_t v3 = 0;
LABEL_13:
        uint64_t v7 = 2;
      }
LABEL_14:
      if (v3 / v7 < 1)
      {
        __break(1u);
LABEL_17:
        __break(1u);
LABEL_18:
        __break(1u);
LABEL_19:
        __break(1u);
        JUMPOUT(0x1B52AC69CLL);
      }
      return 0;
    default:
      uint64_t v3 = BYTE6(a3);
      goto LABEL_6;
  }
}

void *SfntTrueTypeFont.init(tables:residence:containerType:)@<X0>(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, void *a4@<X8>)
{
  unint64_t result = sub_1B52B8B80(a1, a2, a3, __src);
  if (!v4) {
    return memcpy(a4, __src, 0x1A4uLL);
  }
  return result;
}

uint64_t SfntTrueTypeFont.tableTags.getter@<X0>(void *a1@<X8>)
{
  *a1 = *v1;
  return swift_bridgeObjectRetain();
}

uint64_t SfntTrueTypeFont.data(tableTag:)(uint64_t a1)
{
  uint64_t v2 = *v1;
  if (!*(void *)(v2 + 16)) {
    return 0;
  }
  uint64_t v3 = sub_1B5230664(a1);
  if ((v4 & 1) == 0) {
    return 0;
  }
  uint64_t v5 = *(void *)(v2 + 56) + 16 * v3;
  uint64_t v6 = *(void *)v5;
  sub_1B51D4BB8(*(void *)v5, *(void *)(v5 + 8));
  return v6;
}

uint64_t sub_1B52AC768@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  int v5 = a1 & 1;
  uint64_t v6 = sub_1B5271738(a1 & 1);
  uint64_t v32 = 0x101010101010101;
  uint64_t v33 = 0x101010101010101;
  char v34 = 1;
  uint64_t v35 = sub_1B5215A0C;
  uint64_t v36 = 0;
  uint64_t result = sub_1B51E07A0(v6, (uint64_t)v27);
  long long v8 = 0uLL;
  if ((v29 & 1) != 0 || (uint64_t v9 = *v2, !*(void *)(*v3 + 16)))
  {
    uint64_t v19 = 0;
    long long v22 = 0uLL;
    long long v20 = 0uLL;
    long long v21 = 0uLL;
  }
  else
  {
    uint64_t v10 = v28;
    if (v5) {
      uint64_t v11 = 1986884728;
    }
    else {
      uint64_t v11 = 1752003704;
    }
    uint64_t result = sub_1B5230664(v11);
    if (v12)
    {
      uint64_t v13 = (void *)(*(void *)(v9 + 56) + 16 * result);
      unint64_t v15 = v13[1];
      *(void *)&v30[0] = *v13;
      uint64_t v14 = *(void *)&v30[0];
      *((void *)&v30[0] + 1) = v15;
      sub_1B51D4BB8(*(uint64_t *)&v30[0], v15);
      sub_1B51D4BB8(v14, v15);
      sub_1B51D4C10();
      uint64_t v16 = sub_1B53724D8();
      sub_1B5284968(v16, v17, v18, v10, v3[1], v30);
      long long v25 = v30[1];
      long long v26 = v30[0];
      long long v23 = v30[3];
      long long v24 = v30[2];
      uint64_t v19 = v31;
      uint64_t result = sub_1B51D4C64(v14, v15);
      long long v21 = v23;
      long long v20 = v24;
      long long v22 = v25;
      long long v8 = v26;
    }
    else
    {
      uint64_t v19 = 0;
      long long v22 = 0uLL;
      long long v20 = 0uLL;
      long long v21 = 0uLL;
      long long v8 = 0uLL;
    }
  }
  *(_OWORD *)a2 = v8;
  *(_OWORD *)(a2 + 16) = v22;
  *(_OWORD *)(a2 + 32) = v20;
  *(_OWORD *)(a2 + 48) = v21;
  *(void *)(a2 + 64) = v19;
  return result;
}

uint64_t SfntTrueTypeFont.recordGlyph<A>(glyphIndex:into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5 = v4;
  uint64_t v6 = *v4;
  if (!*(void *)(v6 + 16)) {
    goto LABEL_7;
  }
  uint64_t v11 = sub_1B5230664(1819239265);
  if ((v12 & 1) == 0) {
    goto LABEL_7;
  }
  if (!*(void *)(v6 + 16)) {
    goto LABEL_7;
  }
  uint64_t v13 = (uint64_t *)(*(void *)(v6 + 56) + 16 * v11);
  uint64_t v14 = *v13;
  unint64_t v15 = v13[1];
  uint64_t v16 = sub_1B5230664(1735162214);
  if ((v17 & 1) == 0) {
    goto LABEL_7;
  }
  uint64_t v18 = (uint64_t *)(*(void *)(v6 + 56) + 16 * v16);
  unint64_t v19 = v18[1];
  uint64_t v29 = *v18;
  __int16 v35 = 257;
  char v36 = 1;
  char v37 = 1;
  int v38 = 1594834165;
  long long v39 = sub_1B51D2364;
  uint64_t v40 = 0;
  char v42 = 1;
  v41[0] = 0x101010101010101;
  *(_DWORD *)((char *)v41 + 7) = 16843009;
  uint64_t v43 = sub_1B528724C;
  uint64_t v44 = 0;
  char v45 = 1;
  uint64_t v46 = sub_1B528725C;
  uint64_t v47 = 0;
  uint64_t v48 = sub_1B51E7B2C;
  uint64_t v49 = 0;
  sub_1B51D4BB8(v14, v15);
  sub_1B51D4BB8(v29, v19);
  sub_1B51E06BC(1751474532, (uint64_t)__src);
  if (BYTE10(__src[3]))
  {
    sub_1B51D4C64(v29, v19);
    sub_1B51D4C64(v14, v15);
LABEL_7:
    sub_1B51DD5FC();
    swift_allocError();
    *long long v20 = 2;
    return swift_willThrow();
  }
  long long v22 = 0uLL;
  if ((__src[1] & 0x20) != 0)
  {
    sub_1B52AC768(0, (uint64_t)v33);
    long long v22 = 0uLL;
    long long v24 = v33[0];
    long long v25 = v33[1];
    long long v26 = v33[2];
    long long v27 = v33[3];
    uint64_t v23 = v34;
  }
  else
  {
    uint64_t v23 = 0;
    long long v24 = 0uLL;
    long long v25 = 0uLL;
    long long v26 = 0uLL;
    long long v27 = 0uLL;
  }
  __int16 v28 = *((_WORD *)v5 + 208);
  char v32 = 1;
  char v50 = 1;
  *(void *)&__src[0] = v14;
  *((void *)&__src[0] + 1) = v15;
  *(void *)&__src[1] = v29;
  *((void *)&__src[1] + 1) = v19;
  __src[2] = v24;
  __src[3] = v25;
  __src[4] = v26;
  __src[5] = v27;
  *(void *)&__src[6] = v23;
  WORD4(__src[6]) = v28;
  *(void *)&__src[7] = 0;
  *((void *)&__src[7] + 1) = MEMORY[0x1E4FBC860];
  __src[8] = 0uLL;
  LOBYTE(__src[9]) = 1;
  *((void *)&__src[9] + 1) = 0;
  *(void *)&__src[10] = 0;
  BYTE8(__src[10]) = 1;
  __src[11] = xmmword_1B538DC00;
  __src[12] = v22;
  __src[13] = xmmword_1B538DC10;
  __src[14] = v22;
  __src[15] = v22;
  __src[16] = xmmword_1B538DC00;
  sub_1B51D4BB8(v14, v15);
  sub_1B51D4BB8(v29, v19);
  sub_1B5250A04(a2, a1, a3, a4);
  memcpy(__dst, __src, sizeof(__dst));
  sub_1B5256D68(__dst);
  sub_1B51D4C64(v14, v15);
  return sub_1B51D4C64(v29, v19);
}

void SfntTrueTypeFont.metadata.getter(uint64_t a1@<X8>)
{
  uint64_t v3 = *v1;
  long long v4 = 0uLL;
  if (!*(void *)(v3 + 16))
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    unint64_t v15 = 0;
    unint64_t v20 = 0;
LABEL_22:
    long long v16 = 0uLL;
    goto LABEL_23;
  }
  uint64_t v5 = sub_1B5230664(1835365473);
  if (v6)
  {
    uint64_t v7 = (uint64_t *)(*(void *)(v3 + 56) + 16 * v5);
    unint64_t v8 = v7[1];
    uint64_t v45 = *v7;
    sub_1B51D4BB8(v45, v8);
    sub_1B51D4C10();
    uint64_t v45 = sub_1B53724D8();
    *(void *)&long long v46 = v9;
    *((void *)&v46 + 1) = v10;
    swift_bridgeObjectRetain_n();
    sub_1B52B3760((uint64_t)&v45, 16843009, (void (*)(unsigned char *__return_ptr, void *))sub_1B52AFB30, 0, v11);
    uint64_t v18 = v17;
    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease();
    uint64_t v19 = MEMORY[0x1E4FBC860];
    sub_1B522DD1C(MEMORY[0x1E4FBC860]);
    unint64_t v20 = sub_1B522DD1C(v19);
    swift_bridgeObjectRelease();
    if (*(void *)(v18 + 16))
    {
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D481D8);
      uint64_t v21 = sub_1B5373138();
    }
    else
    {
      uint64_t v21 = MEMORY[0x1E4FBC868];
    }
    uint64_t v45 = v21;
    sub_1B52B968C(v18, 1, &v45);
    swift_bridgeObjectRelease();
    uint64_t v22 = v45;
    sub_1B52189C4("dlng", 4, (int *)&v45);
    if (*(void *)(v22 + 16) && (uint64_t v23 = sub_1B5230664(v45), (v24 & 1) != 0))
    {
      long long v25 = (uint64_t *)(*(void *)(v22 + 56) + 16 * v23);
      uint64_t v26 = *v25;
      unint64_t v27 = v25[1];
      sub_1B51D4BB8(*v25, v27);
      unint64_t v14 = sub_1B52BD860();
      *(void *)&long long v47 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47908);
      uint64_t v45 = v14;
      sub_1B5216C4C(&v45, v44);
      swift_bridgeObjectRetain();
      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      sub_1B5237998(v44, 0xD00000000000002ELL, 0x80000001B537CEF0, isUniquelyReferenced_nonNull_native);
      swift_bridgeObjectRelease();
      sub_1B51D4C64(v26, v27);
    }
    else
    {
      unint64_t v14 = MEMORY[0x1E4FBC860];
    }
    sub_1B52189C4("slng", 4, (int *)&v45);
    if (*(void *)(v22 + 16))
    {
      uint64_t v29 = sub_1B5230664(v45);
      if (v30)
      {
        uint64_t v31 = (uint64_t *)(*(void *)(v22 + 56) + 16 * v29);
        uint64_t v32 = *v31;
        unint64_t v33 = v31[1];
        sub_1B51D4BB8(*v31, v33);
        unint64_t v15 = sub_1B52BD860();
        swift_bridgeObjectRelease();
        *(void *)&long long v47 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47908);
        uint64_t v45 = v15;
        sub_1B5216C4C(&v45, v44);
        swift_bridgeObjectRetain();
        char v34 = swift_isUniquelyReferenced_nonNull_native();
        sub_1B5237998(v44, 0xD00000000000002ALL, 0x80000001B537CEC0, v34);
        swift_bridgeObjectRelease();
        sub_1B51D4C64(v32, v33);
        if (!*(void *)(v22 + 16)) {
          goto LABEL_21;
        }
      }
      else
      {
        unint64_t v15 = MEMORY[0x1E4FBC860];
        if (!*(void *)(v22 + 16)) {
          goto LABEL_21;
        }
      }
      uint64_t v35 = sub_1B5230664(1634758764);
      if (v36)
      {
        char v37 = (uint64_t *)(*(void *)(v22 + 56) + 16 * v35);
        uint64_t v38 = *v37;
        unint64_t v39 = v37[1];
        sub_1B51D4BB8(*v37, v39);
        swift_release();
        sub_1B51D4BB8(v38, v39);
        sub_1B52C1898(v38, v39, (uint64_t)&v45);
        sub_1B51D4C64(v38, v39);
        long long v42 = v47;
        long long v43 = v46;
        uint64_t v12 = v48;
        uint64_t v13 = v49;
        uint64_t v40 = v50;
        char v41 = swift_isUniquelyReferenced_nonNull_native();
        *(void *)&v44[0] = v20;
        sub_1B5215E68(v40, (uint64_t)sub_1B52AFC14, 0, v41, (uint64_t)v44);
        unint64_t v20 = *(void *)&v44[0];
        swift_bridgeObjectRelease();
        sub_1B51D4C64(v38, v39);
        long long v16 = v42;
        long long v4 = v43;
        goto LABEL_23;
      }
    }
    else
    {
      unint64_t v15 = MEMORY[0x1E4FBC860];
    }
LABEL_21:
    swift_release();
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    long long v4 = 0uLL;
    goto LABEL_22;
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  unint64_t v14 = 0;
  unint64_t v15 = 0;
  unint64_t v20 = 0;
  long long v16 = 0uLL;
  long long v4 = 0uLL;
LABEL_23:
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v16;
  *(void *)(a1 + 32) = v12;
  *(void *)(a1 + 40) = v13;
  *(void *)(a1 + 48) = v14;
  *(void *)(a1 + 56) = v15;
  *(void *)(a1 + 64) = v20;
}

char *SfntTrueTypeFont.allNames.getter()
{
  sub_1B5201994(v0 + 392, (uint64_t)v5, &qword_1E9D491B0);
  uint64_t v1 = sub_1B5201994((uint64_t)v5, (uint64_t)&v6, &qword_1E9D491B0);
  if (!v6) {
    return (char *)MEMORY[0x1E4FBC860];
  }
  MEMORY[0x1F4188790](v1);
  uint64_t v2 = swift_bridgeObjectRetain();
  uint64_t v3 = sub_1B52B8EE8(v2, (uint64_t (*)(void, void, void))sub_1B52167B8);
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t SfntTrueTypeFont.findCharacterMap(matchingQuery:)@<X0>(unint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  long long v4 = v2;
  uint64_t v6 = *v2;
  if (!*(void *)(v6 + 16) || (uint64_t v8 = sub_1B5230664(1668112752), (v9 & 1) == 0))
  {
    sub_1B51DD5FC();
    swift_allocError();
    *long long v16 = 2;
    return swift_willThrow();
  }
  unint64_t v73 = a1;
  uint64_t v10 = (uint64_t *)(*(void *)(v6 + 56) + 16 * v8);
  uint64_t v12 = *v10;
  unint64_t v11 = v10[1];
  sub_1B51D4BB8(*v10, v11);
  uint64_t v13 = sub_1B52A7A9C(v12, v11);
  if (v3) {
    return sub_1B51D4C64(v12, v11);
  }
  uint64_t v17 = v14;
  uint64_t v85 = 0;
  memset(v84, 0, sizeof(v84));
  uint64_t v71 = *(void *)(v13 + 16);
  if (!v71)
  {
    swift_bridgeObjectRelease();
    goto LABEL_80;
  }
  uint64_t v64 = v4;
  uint64_t v65 = a2;
  uint64_t v66 = v12;
  unint64_t v67 = v11;
  uint64_t v18 = 0;
  uint64_t v86 = v13 + 32;
  int64_t v70 = 0x8000000000000000;
  uint64_t v19 = v71;
  uint64_t v68 = v14;
  do
  {
    sub_1B51DFF98(v86 + 40 * v18, (uint64_t)&v74);
    uint64_t v20 = *((void *)&v75 + 1);
    uint64_t v21 = v76;
    __swift_project_boxed_opaque_existential_1(&v74, *((uint64_t *)&v75 + 1));
    unsigned __int16 v22 = (*(uint64_t (**)(uint64_t, uint64_t))(v21 + 16))(v20, v21);
    uint64_t v23 = *((void *)&v75 + 1);
    uint64_t v24 = v76;
    __swift_project_boxed_opaque_existential_1(&v74, *((uint64_t *)&v75 + 1));
    unsigned __int16 v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 24))(v23, v24);
    uint64_t v26 = *((void *)&v75 + 1);
    uint64_t v27 = v76;
    __swift_project_boxed_opaque_existential_1(&v74, *((uint64_t *)&v75 + 1));
    unsigned __int16 v28 = (*(uint64_t (**)(uint64_t, uint64_t))(v27 + 32))(v26, v27);
    if (v22 > 3u) {
      goto LABEL_9;
    }
    unsigned __int16 v29 = v28;
    uint64_t v30 = (uint64_t)*(&off_1E60E16D8 + (__int16)v22);
    if (*(void *)(v30 + 16) <= (uint64_t)v25)
    {
      swift_bridgeObjectRelease();
      goto LABEL_9;
    }
    int v31 = *(unsigned __int8 *)(v30 + v25 + 32);
    swift_bridgeObjectRelease();
    if (v22 == 1)
    {
      if (v31 == 56) {
        goto LABEL_9;
      }
      if (qword_1F0DDD0D8 <= v29) {
        goto LABEL_24;
      }
      int v32 = *((unsigned __int8 *)&unk_1F0DDD0C8 + v29 + 32);
      if (v32 == 175) {
        goto LABEL_24;
      }
      if (v31 == 21)
      {
        BOOL v57 = v32 == 163;
        int v58 = 21;
        goto LABEL_59;
      }
      if (v31 == 17)
      {
        BOOL v57 = v32 == 40;
        int v58 = 17;
LABEL_59:
        if (v57) {
          int v31 = v58 + 1;
        }
        else {
          int v31 = v58;
        }
        goto LABEL_24;
      }
      if (v31 != 9) {
        goto LABEL_24;
      }
      if (*((unsigned __int8 *)&unk_1F0DDD0C8 + v29 + 32) > 0x74u)
      {
        if (v32 == 117)
        {
          int v31 = 13;
          goto LABEL_24;
        }
        if (v32 == 160)
        {
          int v31 = 10;
          goto LABEL_24;
        }
      }
      else
      {
        if (v32 == 28)
        {
          int v31 = 11;
          goto LABEL_24;
        }
        if (v32 == 59)
        {
          int v31 = 12;
          goto LABEL_24;
        }
      }
      int v31 = 9;
    }
    else if (v31 == 56)
    {
      goto LABEL_9;
    }
LABEL_24:
    uint64_t v33 = *((void *)&v75 + 1);
    uint64_t v34 = v76;
    __swift_project_boxed_opaque_existential_1(&v74, *((uint64_t *)&v75 + 1));
    Swift::UInt16 v35 = (*(uint64_t (**)(uint64_t, uint64_t))(v34 + 32))(v33, v34);
    v36.FontParser::Language value = Platform.interpret(language:)(v35).value;
    uint64_t v37 = *((void *)&v75 + 1);
    uint64_t v38 = v76;
    __swift_project_boxed_opaque_existential_1(&v74, *((uint64_t *)&v75 + 1));
    unsigned __int16 v39 = (*(uint64_t (**)(uint64_t, uint64_t))(v38 + 32))(v37, v38);
    if (v22 != 3)
    {
      int v50 = 128;
      goto LABEL_38;
    }
    FontParser::Language value = v36.value;
    uint64_t v40 = qword_1F0DDDEA8;
    if (qword_1F0DDDEA8)
    {
      unsigned __int16 v69 = v39;
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D481C8);
      char v41 = (void *)sub_1B5373138();
      long long v42 = &byte_1F0DDDEC0;
      do
      {
        uint64_t v43 = *((void *)v42 - 1);
        char v44 = *v42;
        unint64_t v45 = sub_1B5230620(v43);
        if (v46)
        {
          __break(1u);
LABEL_87:
          __break(1u);
          JUMPOUT(0x1B52AD874);
        }
        *(void *)((char *)v41 + ((v45 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v45;
        *(void *)(v41[6] + 8 * v45) = v43;
        *(unsigned char *)(v41[7] + v45) = v44;
        uint64_t v47 = v41[2];
        BOOL v48 = __OFADD__(v47, 1);
        uint64_t v49 = v47 + 1;
        if (v48) {
          goto LABEL_87;
        }
        v42 += 16;
        void v41[2] = v49;
        --v40;
      }
      while (v40);
      uint64_t v17 = v68;
      unsigned __int16 v39 = v69;
      uint64_t v19 = v71;
      if (!v49)
      {
LABEL_36:
        int v50 = 128;
        goto LABEL_37;
      }
    }
    else
    {
      char v41 = (void *)MEMORY[0x1E4FBC868];
      if (!*(void *)(MEMORY[0x1E4FBC868] + 16)) {
        goto LABEL_36;
      }
    }
    unint64_t v51 = sub_1B5230620(v39);
    if ((v52 & 1) == 0) {
      goto LABEL_36;
    }
    int v50 = *(unsigned __int8 *)(v41[7] + v51);
LABEL_37:
    v36.FontParser::Language value = value;
    swift_release();
LABEL_38:
    if (v22 == (unsigned __int16)v73) {
      int v53 = 1;
    }
    else {
      int v53 = (v73 >> 16) & 1;
    }
    BOOL v55 = (v73 & 0xFF000000) == 0x38000000 || v31 == BYTE3(v73);
    if (v53 == 1
      && v55
      && ((v73 & 0xFF00000000) == 0xAF00000000
       || v36.value != FontParser_Language_unknownDefault && v36.value == BYTE4(v73))
      && ((v73 & 0xFF0000000000) == 0x800000000000 || v50 != 128 && v50 == BYTE5(v73)))
    {
      uint64_t v56 = 8;
      switch(v31)
      {
        case 0:
          uint64_t v56 = 1;
          break;
        case 1:
          uint64_t v56 = 2;
          break;
        case 2:
          uint64_t v56 = 3;
          break;
        case 3:
          uint64_t v56 = 4;
          break;
        case 4:
          uint64_t v56 = 6;
          break;
        case 6:
          uint64_t v56 = 7;
          break;
        case 48:
          uint64_t v56 = 0;
          break;
        case 49:
          uint64_t v56 = 5;
          break;
        case 55:
          break;
        default:
          uint64_t v56 = -1;
          break;
      }
      if (v70 < v56)
      {
        sub_1B51E0064((uint64_t)v84, &qword_1E9D491B8);
        sub_1B51DFF98((uint64_t)&v74, (uint64_t)v84);
        int64_t v70 = v56;
      }
    }
LABEL_9:
    ++v18;
    __swift_destroy_boxed_opaque_existential_1((uint64_t)&v74);
  }
  while (v18 != v19);
  swift_bridgeObjectRelease();
  unint64_t v11 = v67;
  a2 = v65;
  uint64_t v12 = v66;
  long long v4 = v64;
LABEL_80:
  sub_1B5201384((uint64_t)v84, (uint64_t)&v74, &qword_1E9D491B8);
  if (*((void *)&v75 + 1))
  {
    sub_1B51E0D0C(&v74, (uint64_t)v83);
    sub_1B51DFF98((uint64_t)v83, (uint64_t)v82);
    if (*(void *)(v17 + 16))
    {
      sub_1B51DFF98(v17 + 32, (uint64_t)v80);
    }
    else
    {
      uint64_t v81 = 0;
      memset(v80, 0, sizeof(v80));
    }
    swift_bridgeObjectRelease();
    uint64_t v60 = v4[1];
    long long v77 = 0u;
    long long v78 = 0u;
    *(void *)&long long v79 = 0;
    *((void *)&v79 + 1) = 2048;
    *(void *)&long long v74 = v60;
    sub_1B51E0D0C(v82, (uint64_t)&v74 + 8);
    sub_1B5283904((uint64_t)v80, (uint64_t)&v77);
    long long v61 = v77;
    a2[2] = v76;
    a2[3] = v61;
    long long v62 = v79;
    a2[4] = v78;
    a2[5] = v62;
    long long v63 = v75;
    *a2 = v74;
    a2[1] = v63;
    sub_1B51D4C64(v12, v11);
    __swift_destroy_boxed_opaque_existential_1((uint64_t)v83);
    return sub_1B51E0064((uint64_t)v84, &qword_1E9D491B8);
  }
  else
  {
    swift_bridgeObjectRelease();
    sub_1B51E0064((uint64_t)&v74, &qword_1E9D491B8);
    sub_1B51DD5FC();
    swift_allocError();
    *uint64_t v59 = 10;
    swift_willThrow();
    sub_1B51D4C64(v12, v11);
    return sub_1B51E0064((uint64_t)v84, &qword_1E9D491B8);
  }
}

uint64_t SfntTrueTypeFont.getHorizontalMetrics(glyphID:)(uint64_t a1)
{
  return sub_1B52AD964(a1, 0);
}

uint64_t SfntTrueTypeFont.getVerticalMetrics(glyphID:)(uint64_t a1)
{
  return sub_1B52AD964(a1, 1);
}

uint64_t SfntTrueTypeFont.encodingType.getter()
{
  return 0;
}

uint64_t SfntTrueTypeFont.parseGlyphMetadata()@<X0>(uint64_t a1@<X8>)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D491C0);
  MEMORY[0x1F4188790](v4 - 8);
  uint64_t v6 = (void *)((char *)v35 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v7 = sub_1B52AEF74(1516335206);
  if (v9)
  {
    uint64_t v10 = v7;
    uint64_t v11 = v8;
    uint64_t v12 = v9;
    uint64_t v13 = *(void (**)(char *, uint64_t))(v1 + 8);
    uint64_t v14 = (void *)swift_allocObject();
    _OWORD v14[2] = v10;
    v14[3] = v11;
    v14[4] = v12;
    *(void *)&long long v63 = v10;
    *((void *)&v63 + 1) = v11;
    uint64_t v64 = v12;
    swift_bridgeObjectRetain_n();
    uint64_t v16 = sub_1B51F812C(&v48, (uint64_t)&v63, v15, 257, 1, (uint64_t)sub_1B52B9938, (uint64_t)v14);
    if (v2)
    {
      swift_release();
      swift_bridgeObjectRelease_n();
      return swift_bridgeObjectRelease();
    }
    else
    {
      uint64_t v19 = v50;
      sub_1B529A2C0(v16, v48, v49, v50, v13, v10, v11, v12, (uint64_t)v6);
      long long v47 = v63;
      long long v61 = v63;
      uint64_t v62 = v64;
      swift_bridgeObjectRetain();
      sub_1B52B55FC((uint64_t)&v61, v6, v20, (uint64_t)&v48);
      swift_bridgeObjectRelease();
      v35[1] = v62;
      uint64_t v38 = v49;
      uint64_t v36 = v48;
      uint64_t v37 = v50;
      v35[0] = v19;
      uint64_t v45 = v51;
      uint64_t v41 = v52;
      uint64_t v40 = v53;
      uint64_t v44 = v54;
      uint64_t v39 = v55;
      uint64_t v43 = v56;
      uint64_t v42 = v57;
      *(void *)&long long v47 = v58;
      uint64_t v46 = v59;
      char v21 = v60;
      int v65 = v60;
      sub_1B51E0064((uint64_t)v6, &qword_1E9D491C0);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRetain();
      char v34 = v21;
      uint64_t v22 = v41;
      uint64_t v23 = v40;
      uint64_t v24 = v39;
      sub_1B52148E8(v41, v40, v44, v39, v43, v42, v47, v46, v34);
      swift_bridgeObjectRelease();
      uint64_t v25 = v22;
      uint64_t v26 = v23;
      uint64_t v27 = v44;
      uint64_t v28 = v24;
      uint64_t v29 = v43;
      uint64_t v30 = v42;
      sub_1B5200BC8(v25, v26, v44, v28, v43, v42, v47, v46, v65);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease_n();
      uint64_t result = swift_release();
      *(void *)a1 = v36;
      *(void *)(a1 + 8) = v10;
      *(void *)(a1 + 16) = v11;
      *(void *)(a1 + 24) = v12;
      uint64_t v31 = v37;
      *(void *)(a1 + 32) = v38;
      *(void *)(a1 + 40) = v31;
      uint64_t v32 = v41;
      *(void *)(a1 + 48) = v45;
      *(void *)(a1 + 56) = v32;
      *(void *)(a1 + 64) = v40;
      *(void *)(a1 + 72) = v27;
      *(void *)(a1 + 80) = v39;
      *(void *)(a1 + 88) = v29;
      uint64_t v33 = v47;
      *(void *)(a1 + 96) = v30;
      *(void *)(a1 + 104) = v33;
      *(void *)(a1 + 112) = v46;
      *(unsigned char *)(a1 + 120) = v65;
    }
  }
  else
  {
    sub_1B51DD5FC();
    swift_allocError();
    *uint64_t v18 = 2;
    return swift_willThrow();
  }
  return result;
}

uint64_t sub_1B52ADEB0(long long *a1, uint64_t a2)
{
  void (*v9)(uint64_t *__return_ptr, _WORD *);
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v20;
  long long v21;
  uint64_t v22;
  unsigned char v23[16];
  uint64_t v24[5];
  uint64_t v25;
  char v26;

  sub_1B5201994(v2, (uint64_t)v23, &qword_1E9D478E8);
  int v5 = *(unsigned __int8 *)(v2 + 16);
  int v6 = *(unsigned __int8 *)(v2 + 17);
  int v7 = *(unsigned __int8 *)(v2 + 18);
  uint64_t v9 = *(void (**)(uint64_t *__return_ptr, _WORD *))(v2 + 24);
  uint64_t v8 = *(void *)(v2 + 32);
  sub_1B5201994((uint64_t)v23, (uint64_t)&v25, &qword_1E9D478E8);
  if (v26)
  {
    uint64_t v10 = *((void *)a1 + 2);
    char v21 = *a1;
    uint64_t v22 = v10;
    swift_retain();
    sub_1B5268680(v2);
    if (v6) {
      uint64_t v11 = 256;
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = v11 | v5;
    if (v7) {
      uint64_t v13 = 0x10000;
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = v12 | v13;
    swift_bridgeObjectRetain();
    uint64_t v15 = sub_1B52A6D7C(&v21, v14, v9, v8, a2);
    if (!v20)
    {
      a2 = (uint64_t)v15;
LABEL_13:
      swift_bridgeObjectRelease();
      sub_1B52686AC(v2);
      sub_1B52686AC(v2);
      uint64_t v18 = v22;
      *a1 = v21;
      *((void *)a1 + 2) = v18;
      return a2;
    }
  }
  else
  {
    LOBYTE(v24[0]) = v5;
    BYTE1(v24[0]) = v6;
    BYTE2(v24[0]) = v7;
    v24[1] = (uint64_t)v9;
    uint64_t v24[2] = v8;
    v24[3] = MEMORY[0x1E4FBC860];
    v24[4] = v25;
    uint64_t v16 = *((void *)a1 + 2);
    char v21 = *a1;
    uint64_t v22 = v16;
    swift_retain();
    sub_1B5268680(v2);
    swift_bridgeObjectRetain();
    uint64_t v17 = sub_1B51F29E4((char *)&v21, v24, a2);
    if (!v20)
    {
      a2 = (uint64_t)v17;
      goto LABEL_13;
    }
  }
  swift_bridgeObjectRelease();
  sub_1B52686AC(v2);
  sub_1B52686AC(v2);
  return a2;
}

BOOL sub_1B52AE064(_DWORD *a1)
{
  int v1 = a1[1];
  return v1 >= *a1 && a1[2] >= v1;
}

_DWORD *sub_1B52AE07C@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  int v2 = result[2];
  if (v2 < *result)
  {
    __break(1u);
  }
  else
  {
    int v3 = result[1];
    *a2 = *result;
    a2[1] = v2;
    a2[2] = v3;
  }
  return result;
}

__n128 sub_1B52AE0A0@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  unsigned __int16 v2 = a1[1].n128_u16[0];
  unint64_t v3 = a1[1].n128_u64[1];
  __n128 result = *a1;
  *a2 = *a1;
  a2[1].n128_u16[0] = v2;
  a2[1].n128_u64[1] = v3;
  return result;
}

uint64_t sub_1B52AE0BC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int16 v2 = *(_WORD *)(a1 + 2);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  char v5 = *(unsigned char *)(a1 + 24);
  *(_WORD *)a2 = *(_WORD *)a1;
  *(void *)(a2 + 8) = v4;
  *(unsigned char *)(a2 + 16) = v5;
  *(_WORD *)(a2 + 18) = v2;
  *(void *)(a2 + 24) = v3;
  return swift_bridgeObjectRetain();
}

BOOL static SfntFontError.__derived_enum_equals(_:_:)(char a1, char a2)
{
  return a1 == a2;
}

uint64_t SfntFontError.hash(into:)()
{
  return sub_1B5373308();
}

uint64_t SfntFontError.hashValue.getter()
{
  return sub_1B5373358();
}

uint64_t SfntTrueTypeFont.fontInfo.getter@<X0>(uint64_t a1@<X8>)
{
  return sub_1B527CA48(v1 + 8, a1);
}

uint64_t SfntTrueTypeFont.fontInfo.setter(uint64_t a1)
{
  return sub_1B527CAAC(a1, v1 + 8);
}

uint64_t (*SfntTrueTypeFont.fontInfo.modify())(void)
{
  return nullsub_1;
}

uint64_t SfntTrueTypeFont.dataResidence.getter()
{
  return *(unsigned __int8 *)(v0 + 418);
}

uint64_t SfntTrueTypeFont.dataResidence.setter(uint64_t result)
{
  *(unsigned char *)(v1 + 418) = result;
  return result;
}

uint64_t (*SfntTrueTypeFont.dataResidence.modify())(void)
{
  return nullsub_1;
}

uint64_t SfntTrueTypeFont.containerType.getter()
{
  return *(unsigned __int8 *)(v0 + 419);
}

uint64_t SfntTrueTypeFont.containerType.setter(uint64_t result)
{
  *(unsigned char *)(v1 + 419) = result;
  return result;
}

uint64_t (*SfntTrueTypeFont.containerType.modify())(void)
{
  return nullsub_1;
}

uint64_t sub_1B52AE210@<X0>(uint64_t result@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  if (*(void *)(a2 + 16) && (__n128 result = sub_1B5230664(result), (v5 & 1) != 0))
  {
    sub_1B51D4BB8(*(void *)(*(void *)(a2 + 56) + 16 * result), *(void *)(*(void *)(a2 + 56) + 16 * result + 8));
    sub_1B51D4C10();
    *(void *)&long long v9 = sub_1B53724D8();
    *((void *)&v9 + 1) = v6;
    uint64_t v10 = v7;
    sub_1B51DBB90(&v9, v6, a3);
    __n128 result = swift_bridgeObjectRelease();
    char v8 = 0;
  }
  else
  {
    *(_OWORD *)(a3 + 42) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    char v8 = 1;
  }
  *(unsigned char *)(a3 + 58) = v8;
  return result;
}

uint64_t sub_1B52AE2F4@<X0>(uint64_t result@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  if (*(void *)(a2 + 16) && (__n128 result = sub_1B5230664(result), (v5 & 1) != 0))
  {
    sub_1B51D4BB8(*(void *)(*(void *)(a2 + 56) + 16 * result), *(void *)(*(void *)(a2 + 56) + 16 * result + 8));
    sub_1B51D4C10();
    *(void *)&long long v9 = sub_1B53724D8();
    *((void *)&v9 + 1) = v6;
    uint64_t v10 = v7;
    sub_1B51DB8AC(&v9, v6, a3);
    __n128 result = swift_bridgeObjectRelease();
    char v8 = 0;
  }
  else
  {
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    char v8 = 1;
  }
  *(unsigned char *)(a3 + 96) = v8;
  return result;
}

unint64_t sub_1B52AE3D8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  char v153 = 1;
  char v152 = 1;
  char v151 = 1;
  char v150 = 1;
  char v149 = 1;
  char v148 = 1;
  char v113 = 1;
  char v112 = 1;
  char v110 = 1;
  char v108 = 1;
  char v106 = 1;
  BOOL v103 = 1;
  char v94 = 1;
  *(_WORD *)uint64_t v95 = 257;
  memset(&v95[8], 0, 96);
  v95[104] = 1;
  uint64_t v96 = sub_1B51E7E00;
  uint64_t v97 = 0;
  *(void *)&long long v98 = sub_1B52BA600;
  *((void *)&v98 + 1) = swift_getKeyPath();
  v147[3] = *(_OWORD *)&v95[48];
  v147[2] = *(_OWORD *)&v95[32];
  v147[0] = *(_OWORD *)v95;
  v147[1] = *(_OWORD *)&v95[16];
  v147[8] = v98;
  v147[7] = (unint64_t)sub_1B51E7E00;
  v147[6] = *(_OWORD *)&v95[96];
  v147[4] = *(_OWORD *)&v95[64];
  v147[5] = *(_OWORD *)&v95[80];
  sub_1B52AF958(1835104368, v147, v4, a1, (uint64_t)v99);
  sub_1B51FDE40((uint64_t)v95);
  int v5 = v101;
  uint64_t v6 = v100;
  __int16 v132 = 257;
  char v133 = 1;
  char v134 = 1;
  int v135 = 1594834165;
  v136 = sub_1B51D2364;
  uint64_t v137 = 0;
  char v139 = 1;
  v138[0] = 0x101010101010101;
  *(_DWORD *)((char *)v138 + 7) = 16843009;
  v140 = sub_1B528724C;
  uint64_t v141 = 0;
  char v142 = 1;
  v143 = sub_1B528725C;
  uint64_t v144 = 0;
  v145 = sub_1B51E7B2C;
  uint64_t v146 = 0;
  sub_1B52AE210(1751474532, a1, (uint64_t)&v119);
  if (BYTE10(v122))
  {
    uint64_t v7 = 0;
    unint64_t v59 = 0;
    double v8 = 0.0;
    double v9 = 0.0;
    double v10 = 0.0;
    double v11 = 0.0;
  }
  else
  {
    uint64_t v12 = (uint64_t)(*((void *)&v121 + 1) << 16) >> 48;
    if (WORD1(v120) - 16385 >= 0xFFFFC00F) {
      uint64_t v7 = WORD1(v120);
    }
    else {
      uint64_t v7 = 0;
    }
    int v13 = v12 - SWORD4(v121);
    double v8 = 0.0;
    if (v13 == (__int16)(v12 - WORD4(v121)))
    {
      int v14 = (__int16)(HIWORD(v121) - WORD5(v121));
      double v9 = 0.0;
      double v10 = 0.0;
      double v11 = 0.0;
      if (v14 == (*((uint64_t *)&v121 + 1) >> 48) - (SDWORD2(v121) >> 16))
      {
        double v8 = (double)SWORD4(v121);
        double v9 = (double)SWORD5(v121);
        double v10 = (double)(__int16)v13;
        double v11 = (double)v14;
      }
    }
    else
    {
      double v9 = 0.0;
      double v10 = 0.0;
      double v11 = 0.0;
    }
    unint64_t v59 = ((uint64_t)((void)v122 << 62) >> 63) & 0xC02E000000000000;
    BOOL v103 = (v122 & 2) == 0;
  }
  uint64_t v127 = 0x101010101010101;
  uint64_t v128 = 0x101010101010101;
  char v129 = 1;
  v130 = sub_1B5215A0C;
  uint64_t v131 = 0;
  *(double *)&unint64_t result = COERCE_DOUBLE(sub_1B52AE2F4(1751672161, a1, (uint64_t)&v119));
  int v72 = v5;
  uint64_t v70 = v7;
  uint64_t v71 = v6;
  if (v125)
  {
    double v16 = v9 + v11;
    if ((~COERCE__INT64(v9 + v11) & 0x7FF0000000000000) != 0)
    {
      if (v16 > -9.22337204e18)
      {
        if (v16 < 9.22337204e18)
        {
          if ((~*(void *)&v9 & 0x7FF0000000000000) != 0)
          {
            if (v9 > -9.22337204e18)
            {
              if (v9 < 9.22337204e18)
              {
                if ((~*(void *)&v10 & 0x7FF0000000000000) != 0)
                {
                  if (v10 > -9.22337204e18)
                  {
                    if (v10 < 9.22337204e18)
                    {
                      *((void *)&v61 + 1) = 0;
                      uint64_t v62 = 0;
                      uint64_t v69 = (uint64_t)v16;
                      uint64_t v17 = (uint64_t)v9;
                      uint64_t v60 = 0;
                      *(void *)&long long v61 = (uint64_t)v10;
                      goto LABEL_23;
                    }
LABEL_56:
                    __break(1u);
                    goto LABEL_57;
                  }
LABEL_55:
                  __break(1u);
                  goto LABEL_56;
                }
LABEL_54:
                __break(1u);
                goto LABEL_55;
              }
LABEL_53:
              __break(1u);
              goto LABEL_54;
            }
LABEL_52:
            __break(1u);
            goto LABEL_53;
          }
LABEL_51:
          __break(1u);
          goto LABEL_52;
        }
LABEL_50:
        __break(1u);
        goto LABEL_51;
      }
    }
    else
    {
      __break(1u);
    }
    __break(1u);
    goto LABEL_50;
  }
  uint64_t v62 = v122;
  uint64_t v60 = *((void *)&v120 + 1);
  long long v61 = v121;
  uint64_t v17 = v120;
  uint64_t v69 = *((void *)&v119 + 1);
LABEL_23:
  *(void *)&long long v74 = 0x101010101010101;
  *((void *)&v74 + 1) = 0x101010101010101;
  long long v75 = sub_1B52AFA94;
  uint64_t v76 = 0;
  *(void *)&long long v77 = 0x101010101010101;
  *(void *)((char *)&v77 + 5) = 0x101010101010101;
  long long v78 = sub_1B52AFAA8;
  uint64_t v79 = 0;
  long long v80 = sub_1B52BAAB0;
  uint64_t v81 = 0;
  *(void *)&long long v82 = sub_1B52BA61C;
  *((void *)&v82 + 1) = swift_getKeyPath();
  *(void *)&long long v83 = sub_1B52BA638;
  *((void *)&v83 + 1) = swift_getKeyPath();
  *(void *)&long long v84 = sub_1B52BA654;
  *((void *)&v84 + 1) = swift_getKeyPath();
  long long v123 = (unint64_t)sub_1B52BAAB0;
  long long v124 = v82;
  long long v125 = v83;
  long long v126 = v84;
  long long v119 = v74;
  long long v120 = (unint64_t)sub_1B52AFA94;
  long long v121 = v77;
  long long v122 = (unint64_t)sub_1B52AFAA8;
  sub_1B52AF7FC(1330851634, (uint64_t)&v119, v18, a1, (uint64_t)&v85);
  sub_1B52BA670((uint64_t)&v74);
  if (v93)
  {
    uint64_t v20 = 0;
    uint64_t v67 = 0;
    uint64_t v68 = 0;
    uint64_t v66 = 0;
    unint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    LOBYTE(v25) = 0;
    float64x2_t v63 = 0u;
    int8x16_t v64 = 0u;
    double v26 = 0.0;
    double v27 = 0.0;
    double v28 = 0.0;
    double v29 = 0.0;
    float64x2_t v65 = 0u;
  }
  else
  {
    if (v92)
    {
      uint64_t v22 = 0;
      uint64_t v23 = 0;
    }
    else
    {
      uint64_t v22 = v91 << 16 >> 48;
      uint64_t v23 = (uint64_t)(int)v91 >> 16;
    }
    unint64_t v21 = HIWORD(v90);
    v30.i64[1] = v86.i64[1];
    uint64_t v24 = (uint64_t)(int)v85 >> 16;
    if (v103)
    {
      unint64_t v59 = 0;
      BOOL v103 = (v89 & 1) == 0;
    }
    LOBYTE(v25) = (v88 & 0xFF000000) == 150994944;
    uint64_t v20 = v89 >> 48;
    uint64_t v67 = (uint64_t)(int)v90 >> 16;
    uint64_t v68 = (__int16)v90;
    char v113 = 0;
    uint64_t v66 = WORD2(v90);
    char v112 = 0;
    float64x2_t v65 = vcvtq_f64_s64(vshrq_n_s64((int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v87), (uint64x2_t)xmmword_1B53920F0), 0x30uLL));
    char v106 = 0;
    double v26 = (double)(v86.i64[0] >> 48);
    double v27 = (double)(v86.i64[0] << 16 >> 48);
    int8x16_t v64 = (int8x16_t)vcvtq_f64_s64(vshrq_n_s64((int64x2_t)vshlq_u64(v86, (uint64x2_t)xmmword_1B5392100), 0x30uLL));
    double v28 = (double)(v86.i64[1] >> 48);
    char v110 = 0;
    v30.i64[0] = v87;
    float64x2_t v63 = vcvtq_f64_s64(vshrq_n_s64((int64x2_t)vshlq_u64(v30, (uint64x2_t)xmmword_1B5392110), 0x30uLL));
    double v29 = (double)(v86.i64[1] << 16 >> 48);
    char v108 = 0;
  }
  v114[0] = 1;
  uint64_t v115 = sub_1B51FE55C;
  uint64_t v116 = 0;
  v117 = sub_1B51E7B58;
  uint64_t v118 = 0;
  sub_1B52AF6F0(1886352244, (uint64_t)v114, v19, a1, (uint64_t)v73);
  if (!v73[6])
  {
    uint64_t v58 = v23;
    uint64_t v36 = swift_bridgeObjectRetain();
    uint64_t v37 = sub_1B524EEEC(v36);
    if (v38 >> 60 == 15)
    {
      unint64_t result = v59;
      uint64_t v35 = v69;
    }
    else
    {
      uint64_t v40 = v37;
      unint64_t v41 = v38;
      char v42 = v25;
      uint64_t v25 = v20;
      uint64_t v43 = v17;
      unint64_t v44 = v21;
      uint64_t v45 = v24;
      int v46 = sub_1B524EEB8(v37, v38, v39);
      sub_1B51FE548(v40, v41);
      double v47 = (double)v46;
      uint64_t v24 = v45;
      unint64_t v21 = v44;
      uint64_t v17 = v43;
      uint64_t v20 = v25;
      LOBYTE(v25) = v42;
      double v48 = v47 * 0.0000152587891;
      unint64_t result = v59;
      uint64_t v35 = v69;
      if (fabs(v48) > 0.00001)
      {
        unint64_t result = *(void *)&v48 ^ 0x8000000000000000;
        BOOL v103 = 0;
      }
    }
    if (!__OFSUB__(v17, v35))
    {
      if (v17 >= 0) {
        uint64_t v49 = v17;
      }
      else {
        uint64_t v49 = v17 + 1;
      }
      uint64_t v33 = v49 >> 1;
      uint64_t v34 = (v17 - v35) / 2;
      uint64_t v23 = v58;
      goto LABEL_45;
    }
LABEL_57:
    __break(1u);
    return result;
  }
  unint64_t v31 = v73[1];
  uint64_t v32 = SHIDWORD(v73[0]);
  swift_bridgeObjectRelease();
  uint64_t v33 = (__int16)v31;
  uint64_t v34 = (uint64_t)(int)v31 >> 16;
  uint64_t v25 = HIDWORD(v31) & 1;
  if (fabs((double)v32 * 0.0000152587891) <= 0.00001)
  {
    unint64_t result = v59;
  }
  else
  {
    *(double *)&unint64_t result = (double)v32 * 0.0000152587891;
    BOOL v103 = 0;
  }
  uint64_t v35 = v69;
LABEL_45:
  double v50 = (double)v34;
  uint64_t v51 = v71;
  if (v72) {
    uint64_t v51 = 0;
  }
  char v52 = v113;
  *(_DWORD *)(a2 + 65) = v73[0];
  *(_DWORD *)(a2 + 68) = *(_DWORD *)((char *)v73 + 3);
  char v53 = v112;
  *(_DWORD *)(a2 + 89) = *(_DWORD *)v111;
  *(_DWORD *)(a2 + 92) = *(_DWORD *)&v111[3];
  char v54 = v110;
  *(_DWORD *)(a2 + 129) = *(_DWORD *)v109;
  *(_DWORD *)(a2 + 132) = *(_DWORD *)&v109[3];
  char v55 = v108;
  int v56 = *(_DWORD *)v107;
  *(_DWORD *)(a2 + 172) = *(_DWORD *)&v107[3];
  *(_DWORD *)(a2 + 169) = v56;
  LOBYTE(v56) = v106;
  *(_DWORD *)(a2 + 289) = *(_DWORD *)v104;
  *(_DWORD *)(a2 + 292) = *(_DWORD *)&v104[3];
  BOOL v57 = v103;
  *(_DWORD *)(a2 + 305) = *(_DWORD *)v102;
  *(_DWORD *)(a2 + 308) = *(_DWORD *)&v102[3];
  *(void *)a2 = v51;
  *(void *)(a2 + 8) = v70;
  *(void *)(a2 + 16) = v35;
  *(void *)(a2 + 24) = v17;
  *(void *)(a2 + 32) = v60;
  *(void *)(a2 + 40) = v20;
  *(void *)(a2 + 48) = v68;
  *(void *)(a2 + 56) = v67;
  *(unsigned char *)(a2 + 64) = v52;
  *(void *)(a2 + 72) = v66;
  *(void *)(a2 + 80) = v21;
  *(unsigned char *)(a2 + 88) = v53;
  *(double *)(a2 + 96) = v26;
  *(int8x16_t *)(a2 + 104) = vextq_s8(v64, v64, 8uLL);
  *(double *)(a2 + 120) = v27;
  *(unsigned char *)(a2 + 128) = v54;
  *(double *)(a2 + 136) = v28;
  *(float64x2_t *)(a2 + 144) = v63;
  *(double *)(a2 + 160) = v29;
  *(unsigned char *)(a2 + 168) = v55;
  *(float64x2_t *)(a2 + 176) = v65;
  *(unsigned char *)(a2 + 192) = v56;
  *(_DWORD *)(a2 + 193) = v105[0];
  *(_DWORD *)(a2 + 196) = *(_DWORD *)((char *)v105 + 3);
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(void *)(a2 + 232) = 0;
  *(void *)(a2 + 240) = v22;
  *(void *)(a2 + 248) = v23;
  *(void *)(a2 + 256) = v61;
  *(void *)(a2 + 264) = v24;
  *(void *)(a2 + 272) = *((void *)&v61 + 1);
  *(void *)(a2 + 280) = v62;
  *(unsigned char *)(a2 + 288) = v25;
  *(double *)(a2 + 296) = *(double *)&result;
  *(unsigned char *)(a2 + 304) = v57;
  *(double *)(a2 + 312) = (double)v33;
  *(double *)(a2 + 320) = v50;
  *(double *)(a2 + 328) = v8;
  *(double *)(a2 + 336) = v9;
  *(double *)(a2 + 344) = v10;
  *(double *)(a2 + 352) = v11;
  *(void *)(a2 + 360) = 0;
  *(void *)(a2 + 368) = 0;
  *(unsigned char *)(a2 + 376) = 0;
  return result;
}

uint64_t SfntTrueTypeFont.string(name:matchingQuery:)(unint64_t a1, uint64_t a2)
{
  sub_1B5201994(v2 + 392, (uint64_t)v6, &qword_1E9D491B0);
  sub_1B5201994((uint64_t)v6, (uint64_t)v7, &qword_1E9D491B0);
  if (v7[0]) {
    return sub_1B526B518(a1, a2 & 0xFFFFFF00FFFFLL | ((unint64_t)(BYTE2(a2) & 1) << 16), v7[0], v7[1], v7[2]);
  }
  else {
    return 0;
  }
}

uint64_t sub_1B52AEDE8(uint64_t result, char a2)
{
  uint64_t v3 = v2[1];
  if (v3 < 0)
  {
    __break(1u);
    goto LABEL_20;
  }
  uint64_t v4 = result;
  unint64_t result = 0;
  if ((v4 & 0x8000000000000000) == 0 && v3 > v4)
  {
    int v5 = a2 & 1;
    uint64_t v6 = v2[3];
    uint64_t v7 = v2[4];
    sub_1B52AC768(a2 & 1, (uint64_t)v9);
    sub_1B5201994((uint64_t)v9, (uint64_t)v11, &qword_1E9D479A0);
    if (v12)
    {
      v13[0] = v11[0];
      v13[1] = v11[1];
      long long v14 = v11[2];
      long long v15 = v11[3];
      uint64_t v16 = v12;
      uint64_t v8 = v4;
      if (*(uint64_t *)&v11[0] <= v4)
      {
        if (*(uint64_t *)&v11[0] <= 0) {
          goto LABEL_9;
        }
        uint64_t v8 = *(void *)&v11[0] - 1;
      }
      sub_1B5284860(v8);
LABEL_9:
      sub_1B5284728(v4);
      sub_1B51FE574((uint64_t)v9);
      return v4;
    }
    SfntTrueTypeFont.getBoundingBox(glyphID:)(&v10, v4);
    unint64_t result = sub_1B5201994((uint64_t)&v10, (uint64_t)v13, &qword_1E9D47D68);
    if (v14) {
      return 0;
    }
    if (!v5 || !__OFSUB__(v6, v7)) {
      return v4;
    }
LABEL_20:
    __break(1u);
  }
  return result;
}

uint64_t sub_1B52AEF74(uint64_t a1)
{
  uint64_t v2 = *v1;
  if (!*(void *)(v2 + 16)) {
    return 0;
  }
  uint64_t v3 = sub_1B5230664(a1);
  if ((v4 & 1) == 0) {
    return 0;
  }
  sub_1B51D4BB8(*(void *)(*(void *)(v2 + 56) + 16 * v3), *(void *)(*(void *)(v2 + 56) + 16 * v3 + 8));
  sub_1B51D4C10();
  return sub_1B53724D8();
}

FontParser::Variations_optional __swiftcall SfntTrueTypeFont.parseVariations()()
{
  uint64_t v1 = *v0;
  if (!*(void *)(v1 + 16)) {
    goto LABEL_5;
  }
  uint64_t v2 = sub_1B5230664(1719034226);
  if ((v3 & 1) == 0) {
    goto LABEL_5;
  }
  char v4 = (void *)(*(void *)(v1 + 56) + 16 * v2);
  unint64_t v5 = v4[1];
  *(void *)&long long v62 = *v4;
  *((void *)&v62 + 1) = v5;
  sub_1B51D4BB8(v62, v5);
  sub_1B51D4C10();
  uint64_t v6 = (void *)sub_1B53724D8();
  if ((uint64_t)v7 < (uint64_t)v6)
  {
    __break(1u);
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }
  double v9 = v6;
  __C::CGRect_optional v10 = v7;
  uint64_t v11 = v8;
  uint64_t v12 = swift_allocObject();
  *(void *)(v12 + 16) = v9;
  *(void *)(v12 + 24) = v10;
  swift_bridgeObjectRetain();
  *(void *)&long long v62 = v9;
  *((void *)&v62 + 1) = v10;
  *(void *)&long long v63 = v11;
  swift_bridgeObjectRetain_n();
  sub_1B51F9BC0(&v44, &v62, v13, 0x10101010101);
  uint64_t v15 = v14;
  uint64_t v17 = v16;
  uint64_t v38 = v18;
  uint64_t v19 = v44;
  long long v44 = v62;
  *(void *)&long long v45 = v63;
  swift_bridgeObjectRetain();
  unsigned __int16 v23 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v44, v20, 1);
  swift_bridgeObjectRelease_n();
  uint64_t v6 = (void *)swift_bridgeObjectRelease();
  if ((unint64_t)(v15 - 0x2000000000000000) >> 62 != 3) {
    goto LABEL_22;
  }
  uint64_t v24 = v23 - 4 * v15;
  if (__OFSUB__(v23, 4 * v15))
  {
LABEL_23:
    __break(1u);
    goto LABEL_24;
  }
  long long v25 = v44;
  BOOL v26 = v24 > 5;
  BOOL v27 = v24 < 6;
  BOOL v28 = v24 < 6;
  uint64_t v29 = (uint64_t)sub_1B52699E8;
  BOOL v43 = v28;
  if (v27) {
    uint64_t v29 = 1;
  }
  *(void *)&long long v44 = v17;
  if (v27) {
    uint64x2_t v30 = 0;
  }
  else {
    uint64x2_t v30 = sub_1B5269A10;
  }
  BYTE8(v44) = 1;
  LOWORD(v45) = 257;
  BYTE2(v45) = 1;
  *((void *)&v45 + 1) = sub_1B52AE064;
  *(void *)&long long v46 = 0;
  *((void *)&v46 + 1) = sub_1B52AE07C;
  *(void *)&long long v47 = 0;
  WORD4(v47) = 257;
  double v48 = sub_1B52AE0A0;
  uint64_t v49 = 0;
  *(void *)&long long v50 = MEMORY[0x1E4FBC860];
  *((void *)&v50 + 1) = v15;
  *(void *)&long long v51 = v23;
  BYTE8(v51) = 1;
  char v52 = sub_1B52699C4;
  uint64_t v53 = 0;
  LOBYTE(v54) = 1;
  BYTE8(v54) = 1;
  *(void *)&long long v55 = MEMORY[0x1E4FBC860];
  *((void *)&v55 + 1) = v15;
  *(void *)&long long v56 = v26;
  *((void *)&v56 + 1) = v29;
  *(void *)&long long v57 = 0;
  *((void *)&v57 + 1) = v30;
  *(void *)&long long v58 = 0;
  BYTE8(v58) = v28;
  unint64_t v59 = sub_1B52AE0BC;
  uint64_t v60 = 0;
  *(void *)&long long v61 = MEMORY[0x1E4FBC860];
  *((void *)&v61 + 1) = v19;
  long long v62 = v44;
  long long v63 = v45;
  long long v66 = (unint64_t)sub_1B52AE0A0;
  long long v67 = v50;
  long long v64 = v46;
  long long v65 = v47;
  long long v75 = (unint64_t)sub_1B52AE0BC;
  long long v76 = v61;
  long long v73 = v57;
  long long v74 = v58;
  long long v71 = v55;
  long long v72 = v56;
  long long v69 = (unint64_t)sub_1B52699C4;
  long long v70 = v54;
  long long v68 = v51;
  if (!__OFADD__(v9, v38))
  {
    *(void *)&long long v39 = sub_1B53724B8();
    *((void *)&v39 + 1) = v33;
    uint64_t v40 = v34;
    uint64_t v21 = sub_1B51F9908((uint64_t *)&v42, &v39, v34);
    id v22 = v42;
    swift_bridgeObjectRelease();
    sub_1B52B9968((uint64_t)&v44);
    swift_bridgeObjectRelease();
    swift_release();
    swift_bridgeObjectRelease_n();
    goto LABEL_6;
  }
  sub_1B51D4D34();
  unint64_t v31 = (void *)swift_allocError();
  *uint64_t v32 = 2;
  v32[1] = v25;
  v32[2] = 0xD00000000000001DLL;
  v32[3] = 0x80000001B537BD80;
  v32[4] = 0;
  swift_willThrow();
  sub_1B52B9968((uint64_t)&v44);
  id v42 = v31;
  id v35 = v31;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47950);
  if (swift_dynamicCast())
  {

    unint64_t v31 = v41;
    swift_bridgeObjectRelease();
    swift_release();
    swift_bridgeObjectRelease();
    sub_1B5200310((id)v39);
    swift_bridgeObjectRelease();
  }
  else
  {

    id v36 = v31;
    swift_bridgeObjectRelease();
    swift_release();
    swift_bridgeObjectRelease();
  }
  swift_bridgeObjectRelease();
LABEL_5:
  uint64_t v21 = 0;
  id v22 = 0;
LABEL_6:
  uint64_t v6 = (void *)v21;
  uint64_t v7 = v22;
LABEL_24:
  result.value.namedVariations._rawValue = v7;
  result.value.axes._rawValue = v6;
  return result;
}

uint64_t sub_1B52AF47C()
{
  return *(unsigned __int8 *)(v0 + 418);
}

uint64_t sub_1B52AF484()
{
  return *(unsigned __int8 *)(v0 + 419);
}

uint64_t sub_1B52AF48C@<X0>(uint64_t a1@<X8>)
{
  return sub_1B527CA48(v1 + 8, a1);
}

uint64_t sub_1B52AF498@<X0>(uint64_t a1@<X8>)
{
  SfntTrueTypeFont.metadata.getter((uint64_t)v3);
  return sub_1B5201994((uint64_t)v3, a1, &qword_1E9D47DB0);
}

char *sub_1B52AF4DC(uint64_t a1)
{
  if (!*(void *)(v1 + 392)) {
    return (char *)MEMORY[0x1E4FBC860];
  }
  MEMORY[0x1F4188790](a1);
  uint64_t v2 = swift_bridgeObjectRetain();
  char v3 = sub_1B52B8EE8(v2, (uint64_t (*)(void, void, void))sub_1B52BA8D0);
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t sub_1B52AF588(unint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2[49];
  if (v3) {
    return sub_1B526B518(a1, a2 & 0xFFFFFF00FFFFLL | ((unint64_t)(BYTE2(a2) & 1) << 16), v3, v2[50], v2[51]);
  }
  else {
    return 0;
  }
}

uint64_t sub_1B52AF5D8@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  return SfntTrueTypeFont.findCharacterMap(matchingQuery:)(a1 & 0xFFFFFF00FFFFLL | ((unint64_t)(BYTE2(a1) & 1) << 16), a2);
}

uint64_t sub_1B52AF610(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1B52AF620(a1, a2, a3, 0);
}

uint64_t sub_1B52AF618(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1B52AF620(a1, a2, a3, 1);
}

uint64_t sub_1B52AF620(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  memcpy(__dst, v4, sizeof(__dst));
  return sub_1B52AEDE8(a1, a4);
}

uint64_t sub_1B52AF674(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  memcpy(__dst, v4, sizeof(__dst));
  return SfntTrueTypeFont.recordGlyph<A>(glyphIndex:into:)(a1, a2, a3, a4);
}

double sub_1B52AF6F0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (*(void *)(a4 + 16) && (uint64_t v9 = sub_1B5230664(a1), (v10 & 1) != 0))
  {
    uint64_t v11 = (uint64_t *)(*(void *)(a4 + 56) + 16 * v9);
    uint64_t v15 = *v11;
    unint64_t v16 = v11[1];
    sub_1B51D4BB8(*v11, v16);
    sub_1B51D4C10();
    *(void *)&long long v20 = sub_1B53724D8();
    *((void *)&v20 + 1) = v12;
    uint64_t v21 = v13;
    swift_bridgeObjectRetain();
    sub_1B51EF8B4(&v20, a2, a3);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    *(void *)a5 = v15;
    *(_DWORD *)(a5 + 8) = v16;
    *(unsigned char *)(a5 + 12) = BYTE4(v16);
    double result = *(double *)&v17;
    *(_OWORD *)(a5 + 16) = v17;
    *(_OWORD *)(a5 + 32) = v18;
    *(void *)(a5 + 48) = v19;
  }
  else
  {
    *(void *)(a5 + 48) = 0;
    double result = 0.0;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)a5 = 0u;
  }
  return result;
}

double sub_1B52AF7FC@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (*(void *)(a4 + 16) && (uint64_t v9 = sub_1B5230664(a1), (v10 & 1) != 0))
  {
    uint64_t v11 = (void *)(*(void *)(a4 + 56) + 16 * v9);
    unint64_t v12 = v11[1];
    *(void *)&v26[0] = *v11;
    *((void *)&v26[0] + 1) = v12;
    sub_1B51D4BB8(*(uint64_t *)&v26[0], v12);
    sub_1B51D4C10();
    v39[0] = sub_1B53724D8();
    v39[1] = v13;
    v39[2] = v14;
    swift_bridgeObjectRetain();
    sub_1B52B0C28((unint64_t)v39, a2, a3, (uint64_t)v26);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    __int16 v15 = v28;
    int v16 = v30;
    uint64_t v17 = v32;
    char v18 = v33;
    uint64_t v19 = v34;
    __int16 v20 = v35;
    char v21 = v36;
    int v22 = v37;
    unsigned __int8 v23 = v38;
    long long v24 = v26[1];
    *(_OWORD *)a5 = v26[0];
    *(_OWORD *)(a5 + 16) = v24;
    *(void *)(a5 + 32) = v27;
    *(_WORD *)(a5 + 40) = v15;
    *(_OWORD *)(a5 + 44) = v29;
    *(_DWORD *)(a5 + 60) = v16;
    double result = *(double *)&v31;
    *(_OWORD *)(a5 + 64) = v31;
    *(void *)(a5 + 80) = v17;
    *(unsigned char *)(a5 + 88) = v18;
    *(void *)(a5 + 90) = v19;
    *(_WORD *)(a5 + 98) = v20;
    *(unsigned char *)(a5 + 100) = v21;
    *(_DWORD *)(a5 + 102) = v22;
    *(_WORD *)(a5 + 106) = v23;
  }
  else
  {
    double result = 0.0;
    *(_OWORD *)(a5 + 91) = 0u;
    *(_OWORD *)(a5 + 64) = 0u;
    *(_OWORD *)(a5 + 80) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)(a5 + 48) = 0u;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    *(unsigned char *)(a5 + 107) = 1;
  }
  return result;
}

double sub_1B52AF958@<D0>(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (*(void *)(a4 + 16) && (uint64_t v9 = sub_1B5230664(a1), (v10 & 1) != 0))
  {
    uint64_t v11 = (uint64_t *)(*(void *)(a4 + 56) + 16 * v9);
    unint64_t v12 = v11[1];
    uint64_t v18 = *v11;
    *(void *)&long long v19 = v12;
    sub_1B51D4BB8(v18, v12);
    sub_1B51D4C10();
    v27[0] = sub_1B53724D8();
    v27[1] = v13;
    v27[2] = v14;
    swift_bridgeObjectRetain();
    sub_1B52B1E04((uint64_t)v27, a2, a3, (uint64_t)&v18);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v15 = v25;
    unsigned __int8 v16 = v26;
    *(_DWORD *)a5 = v18;
    *(_OWORD *)(a5 + 8) = v19;
    *(_OWORD *)(a5 + 24) = v20;
    *(_OWORD *)(a5 + 40) = v21;
    *(_OWORD *)(a5 + 56) = v22;
    *(_OWORD *)(a5 + 72) = v23;
    double result = *(double *)&v24;
    *(_OWORD *)(a5 + 88) = v24;
    *(void *)(a5 + 104) = v15;
    *(_WORD *)(a5 + 112) = v16;
  }
  else
  {
    double result = 0.0;
    *(_OWORD *)(a5 + 80) = 0u;
    *(_OWORD *)(a5 + 96) = 0u;
    *(_OWORD *)(a5 + 48) = 0u;
    *(_OWORD *)(a5 + 64) = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)a5 = 0u;
    *(_WORD *)(a5 + 112) = 256;
  }
  return result;
}

double sub_1B52AFA94@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int16 v2 = *(_WORD *)(a1 + 8);
  double result = *(double *)a1;
  *(void *)a2 = *(void *)a1;
  *(_WORD *)(a2 + 8) = v2;
  return result;
}

__n128 sub_1B52AFAA8@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int16 v2 = *(_WORD *)(a1 + 40);
  int v3 = *(_DWORD *)(a1 + 60);
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v4;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  *(_WORD *)(a2 + 40) = v2;
  *(_OWORD *)(a2 + 44) = *(_OWORD *)(a1 + 44);
  *(_DWORD *)(a2 + 60) = v3;
  __n128 result = *(__n128 *)(a1 + 64);
  *(__n128 *)(a2 + 64) = result;
  return result;
}

double sub_1B52AFADC@<D0>(double *a1@<X0>, void *a2@<X8>)
{
  double result = *a1;
  *a2 = *(void *)a1;
  return result;
}

_DWORD *sub_1B52AFAE8@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

uint64_t sub_1B52AFAF4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 24);
  unint64_t v2 = *(void *)(a1 + 32);
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  return sub_1B51D4BB8(v3, v2);
}

double sub_1B52AFB30@<D0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  double v4 = *a1;
  uint64_t v5 = *((void *)a1 + 1);
  uint64_t v6 = *((void *)a1 + 3);
  uint64_t v7 = swift_allocObject();
  *(double *)(v7 + 16) = v4;
  *(void *)(v7 + 24) = v5;
  double result = a1[2];
  *(double *)a2 = result;
  *(unsigned char *)(a2 + 8) = 1;
  *(_WORD *)(a2 + 16) = 257;
  *(void *)(a2 + 24) = sub_1B525BFB4;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = sub_1B52AFC00;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = sub_1B52BA4BC;
  *(void *)(a2 + 64) = v7;
  *(void *)(a2 + 72) = sub_1B52AFAF4;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = MEMORY[0x1E4FBC860];
  *(void *)(a2 + 96) = v6;
  return result;
}

__n128 sub_1B52AFC00@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = *(_DWORD *)a1;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1B52AFC14@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *a1;
  uint64_t v3 = a1[1];
  sub_1B5216CF4((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  *a2 = v4;
  a2[1] = v3;
  return swift_bridgeObjectRetain();
}

uint64_t sub_1B52AFC68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v8)(long long *__return_ptr, unsigned int *);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  void (*v17)(long long *__return_ptr, void *);
  uint64_t v18;
  long long v20;
  long long v21;
  void v22[2];
  char v23;
  unsigned char v24[120];

  uint64_t v5 = a2;
  char v7 = *(unsigned char *)a2;
  uint64_t v8 = *(void (**)(long long *__return_ptr, unsigned int *))(a2 + 8);
  uint64_t v9 = *(void *)(a2 + 16);
  char v10 = *(void *)(a1 + 16);
  long long v20 = *(_OWORD *)a1;
  *(void *)&long long v21 = v10;
  swift_bridgeObjectRetain();
  uint64_t v11 = sub_1B52B0144((uint64_t *)&v20, v7, v8, v9, a3);
  if (v3)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v14 = v11;
    uint64_t v15 = v12;
    unsigned __int8 v16 = v13;
    swift_bridgeObjectRelease();
    uint64_t v17 = *(void (**)(long long *__return_ptr, void *))(v5 + 24);
    uint64_t v18 = v21;
    *(_OWORD *)a1 = v20;
    *(void *)(a1 + 16) = v18;
    v22[0] = v14;
    v22[1] = v15;
    long long v23 = v16;
    v17(&v20, v22);
    sub_1B5201994((uint64_t)&v20, (uint64_t)v24, &qword_1E9D47CA0);
    uint64_t v5 = sub_1B51EBCB8(a1, a3);
    sub_1B52BA7D0((uint64_t)v24);
  }
  return v5;
}

uint64_t sub_1B52AFE94(long long *a1, char a2, void (*a3)(long long *__return_ptr, uint64_t *), uint64_t a4, uint64_t a5)
{
  uint64_t v11 = *((void *)a1 + 2);
  long long v20 = *a1;
  *(void *)&long long v21 = v11;
  swift_bridgeObjectRetain();
  unsigned int v12 = sub_1B51F3DDC((uint64_t *)&v20, a5, a2);
  if (v5)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned int v13 = v12;
    swift_bridgeObjectRelease();
    uint64_t v14 = v21;
    *a1 = v20;
    *((void *)a1 + 2) = v14;
    uint64_t v24 = v13;
    a3(&v20, &v24);
    *(_OWORD *)char v36 = v21;
    *(_OWORD *)&v36[16] = v22;
    long long v35 = v20;
    char v37 = v23;
    long long v19 = *(_OWORD *)&v36[8];
    uint64_t v15 = *((void *)&v22 + 1);
    uint64_t v16 = swift_allocObject();
    long long v17 = v21;
    *(_OWORD *)(v16 + 16) = v20;
    *(_OWORD *)(v16 + 32) = v17;
    *(_OWORD *)(v16 + 48) = v22;
    *(unsigned char *)(v16 + 64) = v23;
    char v25 = 1;
    unsigned __int8 v26 = sub_1B525BCC8;
    uint64_t v27 = 0;
    __int16 v28 = sub_1B525CF28;
    uint64_t v29 = v16;
    long long v30 = v19;
    uint64_t v31 = v15;
    char v32 = 2;
    uint64_t v33 = 0;
    char v34 = 1;
    sub_1B5221910((uint64_t)&v35);
    a4 = sub_1B51D247C(a1, a5);
    swift_release();
    sub_1B52A9E40((uint64_t)&v35);
  }
  return a4;
}

uint64_t sub_1B52B0144(uint64_t *a1, char a2, void (*a3)(long long *__return_ptr, unsigned int *), uint64_t a4, uint64_t a5)
{
  unsigned int v10 = sub_1B51F3DDC(a1, a5, a2);
  if (!v5)
  {
    unsigned int v14 = v10;
    a3(&v12, &v14);
    sub_1B5201994((uint64_t)&v12, (uint64_t)v13, &qword_1E9D47CB0);
    a4 = sub_1B51EBFC4((uint64_t)a1, a5);
    sub_1B52BA86C((uint64_t)v13);
  }
  return a4;
}

void sub_1B52B0314(uint64_t a1@<X0>, char a2@<W1>, void (*a3)(long long *__return_ptr, unsigned int *)@<X2>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v11 = *(void *)(a1 + 16);
  long long v16 = *(_OWORD *)a1;
  *(void *)&long long v17 = v11;
  swift_bridgeObjectRetain();
  unsigned int v12 = sub_1B51F3E3C((uint64_t *)&v16, a4, a2);
  if (v5)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned int v13 = v12;
    swift_bridgeObjectRelease();
    uint64_t v14 = v17;
    *(_OWORD *)a1 = v16;
    *(void *)(a1 + 16) = v14;
    unsigned int v23 = v13;
    a3(&v16, &v23);
    v24[4] = v20;
    v24[5] = v21;
    v25[0] = *(_OWORD *)v22;
    *(_OWORD *)((char *)v25 + 10) = *(_OWORD *)&v22[10];
    v24[0] = v16;
    v24[1] = v17;
    uint64_t v24[2] = v18;
    v24[3] = v19;
    int v15 = sub_1B52B7D28((_DWORD *)(a5 + 4), (_WORD *)(a5 + 8), (_WORD *)(a5 + 10), (unsigned char *)(a5 + 12), (uint64_t *)(a5 + 16), (uint64_t *)(a5 + 32), (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char))(a5 + 48), a1, a4);
    sub_1B52BA4E8((uint64_t)v24);
    *(_DWORD *)a5 = v15;
  }
}

uint64_t sub_1B52B055C(long long *a1, char a2, void (*a3)(id *__return_ptr, uint64_t *), uint64_t a4, uint64_t a5)
{
  uint64_t v11 = *((void *)a1 + 2);
  long long v20 = *a1;
  *(void *)&long long v21 = v11;
  swift_bridgeObjectRetain();
  unsigned __int16 v12 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v20, a5, a2);
  if (v5)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v13 = v12;
    swift_bridgeObjectRelease();
    long long v14 = v20;
    uint64_t v15 = v21;
    *a1 = v20;
    *((void *)a1 + 2) = v15;
    uint64_t v23 = v13;
    a3(v22, &v23);
    id v17 = v22[0];
    id v16 = v22[1];
    long long v20 = v14;
    *(void *)&long long v21 = v15;
    swift_bridgeObjectRetain();
    a4 = sub_1B51FCB20((uint64_t)&v20, (uint64_t)v17, (uint64_t)v16, a5);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v19 = v21;
    *a1 = v20;
    *((void *)a1 + 2) = v19;
  }
  return a4;
}

uint64_t sub_1B52B0798(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  void (*v8)(long long *__return_ptr, uint64_t *);
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(long long *__return_ptr, uint64_t *);
  unint64_t v14;
  uint64_t v16;
  long long v17;
  long long v18;
  uint64_t v19;

  uint64_t v5 = a2;
  char v7 = *(unsigned char *)a2;
  uint64_t v8 = *(void (**)(long long *__return_ptr, uint64_t *))(a2 + 8);
  uint64_t v9 = *(void *)(a2 + 16);
  unsigned int v10 = a1[2];
  id v17 = *(_OWORD *)a1;
  *(void *)&long long v18 = v10;
  swift_bridgeObjectRetain();
  uint64_t v11 = sub_1B52B09BC(&v17, v7, v8, v9, a3);
  if (!v3)
  {
    unsigned __int16 v12 = v11;
    swift_bridgeObjectRelease();
    unsigned __int16 v13 = *(void (**)(long long *__return_ptr, uint64_t *))(v5 + 24);
    long long v14 = v18;
    *(_OWORD *)a1 = v17;
    a1[2] = v14;
    uint64_t v19 = v12;
    v13(&v17, &v19);
    sub_1B52A2078(a1, a3, v17);
    uint64_t v5 = v16;
    swift_bridgeObjectRelease();
  }
  swift_bridgeObjectRelease();
  return v5;
}

uint64_t sub_1B52B09BC(long long *a1, char a2, void (*a3)(long long *__return_ptr, uint64_t *), uint64_t a4, uint64_t a5)
{
  uint64_t v11 = *((void *)a1 + 2);
  long long v20 = *a1;
  *(void *)&long long v21 = v11;
  swift_bridgeObjectRetain();
  unsigned __int16 v12 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v20, a5, a2);
  if (v5)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v13 = v12;
    swift_bridgeObjectRelease();
    long long v14 = v20;
    uint64_t v15 = v21;
    *a1 = v20;
    *((void *)a1 + 2) = v15;
    uint64_t v23 = v13;
    a3(&v20, &v23);
    v24[0] = v20;
    v24[1] = v21;
    uint64_t v25 = v22;
    long long v26 = v20;
    uint64_t v28 = *((void *)&v21 + 1);
    uint64_t v27 = v21;
    *(_OWORD *)long long v18 = v14;
    uint64_t v19 = v15;
    swift_bridgeObjectRetain();
    a4 = sub_1B51F269C((uint64_t)v18, (uint64_t *)v24);
    swift_bridgeObjectRelease();
    sub_1B5268654((uint64_t)&v26);
    sub_1B51DFEA8((uint64_t)&v28);
    uint64_t v17 = v19;
    *a1 = *(_OWORD *)v18;
    *((void *)a1 + 2) = v17;
  }
  return a4;
}

void sub_1B52B0C28(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v7 = a1;
  long long v9 = *(_OWORD *)(a2 + 80);
  v119[4] = *(_OWORD *)(a2 + 64);
  v119[5] = v9;
  v119[6] = *(_OWORD *)(a2 + 96);
  long long v10 = *(_OWORD *)(a2 + 16);
  v119[0] = *(_OWORD *)a2;
  v119[1] = v10;
  long long v11 = *(_OWORD *)(a2 + 48);
  v119[2] = *(_OWORD *)(a2 + 32);
  v119[3] = v11;
  uint64_t v12 = *(void *)(a1 + 16);
  *(_OWORD *)long long v64 = *(_OWORD *)a1;
  uint64_t v65 = v12;
  swift_bridgeObjectRetain();
  sub_1B52B122C((unint64_t)v64, (uint64_t)v119, a3, (uint64_t)&v97);
  if (v4)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    swift_bridgeObjectRelease();
    uint64_t v13 = v65;
    *(_OWORD *)unint64_t v7 = *(_OWORD *)v64;
    *(void *)(v7 + 16) = v13;
    v106[0] = v97;
    v106[1] = v98;
    unint64_t v107 = v99;
    __int16 v108 = *(_WORD *)v100;
    long long v109 = *(_OWORD *)&v100[4];
    int v110 = *(_DWORD *)&v100[20];
    long long v111 = v101;
    uint64_t v112 = v102;
    char v113 = v103[0];
    uint64_t v114 = *(void *)&v103[2];
    __int16 v115 = *(_WORD *)&v103[10];
    char v116 = v103[12];
    int v117 = *(_DWORD *)&v103[14];
    unsigned __int8 v118 = v104;
    (*(void (**)(long long *__return_ptr, _OWORD *))(a2 + 112))(&v97, v106);
    uint64_t v14 = v98;
    uint64_t v15 = *((void *)&v101 + 1);
    uint64_t v16 = v101;
    uint64_t v61 = v102;
    uint64_t v62 = *((void *)&v97 + 1);
    uint64_t v17 = *(void *)&v103[8];
    uint64_t v59 = *(void *)v103;
    unsigned int v60 = *(unsigned __int16 *)&v103[16] | (v104 << 16);
    uint64_t v63 = v97;
    uint64_t v124 = *((void *)&v98 + 1);
    if (v105)
    {
      unint64_t v55 = DWORD1(v97);
      unint64_t v56 = (unint64_t)v97 >> 16;
      uint64_t v53 = *((void *)&v97 + 1) >> 16;
      unint64_t v54 = WORD3(v97);
      uint64_t v51 = HIWORD(*((void *)&v97 + 1));
      uint64_t v52 = HIDWORD(*((void *)&v97 + 1));
      unint64_t v49 = DWORD1(v98);
      unint64_t v50 = (unint64_t)v98 >> 16;
      __int16 v57 = v98;
      uint64_t v47 = *((void *)&v98 + 1) >> 16;
      unint64_t v48 = WORD3(v98);
      uint64x2_t v18 = (uint64x2_t)vdupq_n_s64(v99);
      uint64_t v45 = HIWORD(*((void *)&v98 + 1));
      uint64_t v46 = HIDWORD(*((void *)&v98 + 1));
      int16x8_t v19 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v18, (uint64x2_t)xmmword_1B5392130), (int32x4_t)vshlq_u64(v18, (uint64x2_t)xmmword_1B5392120));
      *(int16x4_t *)v19.i8 = vmovn_s32((int32x4_t)v19);
      unint64_t v20 = v99 >> 40;
      unint64_t v21 = HIWORD(v99);
      char v22 = v99;
      unint64_t v23 = HIBYTE(v99);
      uint64_t v24 = *(void *)v100 >> 8;
      char v25 = v100[0];
      uint64_t v26 = HIDWORD(*(void *)v100);
      int v27 = *(_DWORD *)&v100[8];
      uint64_t v28 = HIDWORD(*(void *)&v100[8]);
      int v29 = *(_DWORD *)&v100[16];
      uint64_t v30 = HIDWORD(*(void *)&v100[16]);
      unint64_t v31 = (unint64_t)v101 >> 16;
      a3 = (uint64_t *)DWORD1(v101);
      __int16 v32 = v101;
      unint64_t v7 = WORD3(v101);
      uint64_t v16 = *((void *)&v101 + 1) >> 16;
      uint64_t v33 = HIDWORD(*((void *)&v101 + 1));
      __int16 v34 = WORD4(v101);
      uint64_t v35 = HIWORD(*((void *)&v101 + 1));
      uint64_t v36 = *(long long *)v103 >> 16;
      char v37 = v103[0] & 1;
      uint64_t v38 = *(void *)&v103[8] >> 16;
      uint64_t v39 = HIDWORD(*(void *)&v103[8]) & 1;
      int v40 = HIWORD(*(void *)&v103[8]) | (v60 << 16);
      int v41 = HIWORD(v60) & 1;
      uint64_t v42 = v102;
    }
    else
    {
      __int16 v120 = v97 & 0x101;
      uint64_t v121 = *((void *)&v97 + 1);
      long long v122 = v98;
      unint64_t v123 = v99;
      uint64_t v43 = v99;
      unint64_t v55 = *(void *)v100;
      unint64_t v56 = *(void *)&v100[8];
      uint64_t v58 = *(void *)&v100[16];
      swift_retain();
      swift_retain();
      sub_1B51DAE78(v7, (uint64_t)a3, (uint64_t)v64);
      swift_release();
      swift_release();
      sub_1B52BA6E8(v63, v62, v14, v124, v43, v55, v56, v58, v16, v15, v61, v59, v17, v60, 0);
      LOWORD(v63) = v64[0];
      LOWORD(v56) = WORD1(v64[0]);
      LOWORD(v55) = WORD2(v64[0]);
      LOWORD(v54) = HIWORD(v64[0]);
      LOWORD(v62) = v64[1];
      LOWORD(v53) = WORD1(v64[1]);
      LOWORD(v52) = WORD2(v64[1]);
      LOWORD(v51) = HIWORD(v64[1]);
      __int16 v57 = v65;
      LOWORD(v50) = WORD1(v65);
      LOWORD(v49) = WORD2(v65);
      LOWORD(v48) = HIWORD(v65);
      uint64_t v124 = v66;
      LOWORD(v47) = v67;
      LOWORD(v46) = v68;
      LOWORD(v45) = v69;
      char v22 = v70;
      v44.i32[0] = v71;
      int16x8_t v19 = (int16x8_t)vmovl_u8(v44);
      LOBYTE(v20) = v72;
      LOBYTE(v21) = v73;
      LOBYTE(v23) = v74;
      char v25 = v75;
      LOBYTE(v24) = v76;
      LODWORD(v26) = v77;
      int v27 = v78;
      LODWORD(v28) = v79;
      int v29 = v80;
      LODWORD(v30) = v81;
      __int16 v32 = v82;
      LOWORD(v31) = v83;
      LOWORD(a3) = v84;
      LOWORD(v7) = v85;
      __int16 v34 = v86;
      LOWORD(v16) = v87;
      LOWORD(v33) = v88;
      LOWORD(v35) = v89;
      uint64_t v42 = v90;
      char v37 = v91;
      uint64_t v36 = v92;
      LOWORD(v38) = v93;
      LOBYTE(v39) = v94;
      int v40 = v95;
      LOBYTE(v41) = v96;
    }
    *(_WORD *)a4 = v63;
    *(_WORD *)(a4 + 2) = v56;
    *(_WORD *)(a4 + 4) = v55;
    *(_WORD *)(a4 + 6) = v54;
    *(_WORD *)(a4 + 8) = v62;
    *(_WORD *)(a4 + 10) = v53;
    *(_WORD *)(a4 + 12) = v52;
    *(_WORD *)(a4 + 14) = v51;
    *(_WORD *)(a4 + 16) = v57;
    *(_WORD *)(a4 + 18) = v50;
    *(_WORD *)(a4 + 20) = v49;
    *(_WORD *)(a4 + 22) = v48;
    *(_WORD *)(a4 + 24) = v124;
    *(_WORD *)(a4 + 26) = v47;
    *(_WORD *)(a4 + 28) = v46;
    *(_WORD *)(a4 + 30) = v45;
    *(unsigned char *)(a4 + 32) = v22;
    *(_DWORD *)(a4 + 33) = vmovn_s16(v19).u32[0];
    *(unsigned char *)(a4 + 37) = v20;
    *(unsigned char *)(a4 + 38) = v21;
    *(unsigned char *)(a4 + 39) = v23;
    *(unsigned char *)(a4 + 40) = v25;
    *(unsigned char *)(a4 + 41) = v24;
    *(_DWORD *)(a4 + 44) = v26;
    *(_DWORD *)(a4 + 48) = v27;
    *(_DWORD *)(a4 + 52) = v28;
    *(_DWORD *)(a4 + 56) = v29;
    *(_DWORD *)(a4 + 60) = v30;
    *(_WORD *)(a4 + 64) = v32;
    *(_WORD *)(a4 + 66) = v31;
    *(_WORD *)(a4 + 68) = (_WORD)a3;
    *(_WORD *)(a4 + 70) = v7;
    *(_WORD *)(a4 + 72) = v34;
    *(_WORD *)(a4 + 74) = v16;
    *(_WORD *)(a4 + 76) = v33;
    *(_WORD *)(a4 + 78) = v35;
    *(void *)(a4 + 80) = v42;
    *(unsigned char *)(a4 + 88) = v37;
    *(void *)(a4 + 90) = v36;
    *(_WORD *)(a4 + 98) = v38;
    *(unsigned char *)(a4 + 100) = v39;
    *(_DWORD *)(a4 + 102) = v40;
    *(unsigned char *)(a4 + 106) = v41;
  }
}

void sub_1B52B122C(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v7 = a1;
  long long v9 = *(_OWORD *)(a2 + 48);
  v118[2] = *(_OWORD *)(a2 + 32);
  v118[3] = v9;
  long long v10 = *(_OWORD *)(a2 + 80);
  v118[4] = *(_OWORD *)(a2 + 64);
  v118[5] = v10;
  long long v11 = *(_OWORD *)(a2 + 16);
  v118[0] = *(_OWORD *)a2;
  v118[1] = v11;
  uint64_t v12 = *(void *)(a1 + 16);
  *(_OWORD *)uint64_t v63 = *(_OWORD *)a1;
  uint64_t v64 = v12;
  swift_bridgeObjectRetain();
  sub_1B52B18A0((long long *)v63, v118, a3, (uint64_t)&v96);
  if (v4)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    swift_bridgeObjectRelease();
    uint64_t v13 = v64;
    *(_OWORD *)unint64_t v7 = *(_OWORD *)v63;
    *(void *)(v7 + 16) = v13;
    v105[0] = v96;
    v105[1] = v97;
    unint64_t v106 = v98;
    __int16 v107 = *(_WORD *)v99;
    long long v108 = *(_OWORD *)&v99[4];
    int v109 = *(_DWORD *)&v99[20];
    long long v110 = v100;
    unint64_t v111 = v101;
    char v112 = v102[0];
    uint64_t v113 = *(void *)&v102[2];
    __int16 v114 = *(_WORD *)&v102[10];
    char v115 = v102[12];
    int v116 = *(_DWORD *)&v102[14];
    unsigned __int8 v117 = v103;
    (*(void (**)(long long *__return_ptr, _OWORD *))(a2 + 96))(&v96, v105);
    uint64_t v14 = v98;
    uint64_t v60 = *((void *)&v100 + 1);
    uint64_t v15 = v100;
    uint64_t v61 = *((void *)&v96 + 1);
    unint64_t v16 = v101;
    uint64_t v56 = *(void *)v102;
    unsigned int v57 = *(unsigned __int16 *)&v102[16] | (v103 << 16);
    uint64_t v62 = v96;
    uint64_t v58 = *((void *)&v97 + 1);
    uint64_t v124 = v97;
    uint64_t v59 = v101;
    if (v104)
    {
      unint64_t v54 = DWORD1(v96);
      unint64_t v55 = (unint64_t)v96 >> 16;
      uint64_t v52 = *((void *)&v96 + 1) >> 16;
      unint64_t v53 = WORD3(v96);
      uint64_t v50 = HIWORD(*((void *)&v96 + 1));
      uint64_t v51 = HIDWORD(*((void *)&v96 + 1));
      unint64_t v48 = DWORD1(v97);
      unint64_t v49 = (unint64_t)v97 >> 16;
      uint64_t v46 = *((void *)&v97 + 1) >> 16;
      unint64_t v47 = WORD3(v97);
      uint64_t v45 = HIDWORD(*((void *)&v97 + 1));
      uint64x2_t v17 = (uint64x2_t)vdupq_n_s64(v98);
      uint64_t v18 = HIWORD(*((void *)&v97 + 1));
      int16x8_t v19 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v17, (uint64x2_t)xmmword_1B5392130), (int32x4_t)vshlq_u64(v17, (uint64x2_t)xmmword_1B5392120));
      *(int16x4_t *)v19.i8 = vmovn_s32((int32x4_t)v19);
      unint64_t v16 = v98 >> 40;
      unint64_t v20 = HIWORD(v98);
      char v21 = v98;
      unint64_t v22 = HIBYTE(v98);
      uint64_t v23 = *(void *)v99 >> 8;
      char v24 = v99[0];
      uint64_t v25 = HIDWORD(*(void *)v99);
      int v26 = *(_DWORD *)&v99[8];
      uint64_t v27 = HIDWORD(*(void *)&v99[8]);
      int v28 = *(_DWORD *)&v99[16];
      uint64_t v29 = HIDWORD(*(void *)&v99[16]);
      unint64_t v30 = (unint64_t)v100 >> 16;
      a3 = (uint64_t *)DWORD1(v100);
      __int16 v31 = v100;
      unint64_t v7 = WORD3(v100);
      uint64_t v15 = *((void *)&v100 + 1) >> 16;
      uint64_t v32 = HIDWORD(*((void *)&v100 + 1));
      uint64_t v33 = HIWORD(*((void *)&v100 + 1));
      uint64_t v34 = *(long long *)v102 >> 16;
      char v35 = v102[0] & 1;
      uint64_t v36 = *(void *)&v102[8] >> 16;
      uint64_t v37 = HIDWORD(*(void *)&v102[8]) & 1;
      int v38 = HIWORD(*(void *)&v102[8]) | (v57 << 16);
      int v39 = HIWORD(v57) & 1;
    }
    else
    {
      char v119 = v96 & 1;
      uint64x2_t v40 = (uint64x2_t)vdupq_n_s64(v96);
      int16x8_t v41 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v40, (uint64x2_t)xmmword_1B5392130), (int32x4_t)vshlq_u64(v40, (uint64x2_t)xmmword_1B5392120));
      *(int8x8_t *)v41.i8 = vand_s8((int8x8_t)vmovn_s32((int32x4_t)v41), (int8x8_t)0x1000100010001);
      unsigned __int32 v120 = vmovn_s16(v41).u32[0];
      uint64_t v121 = *((void *)&v96 + 1);
      long long v122 = v97;
      unint64_t v123 = v98;
      unint64_t v54 = *(void *)&v99[16];
      unint64_t v55 = *(void *)v99;
      unint64_t v53 = *(void *)&v99[8];
      uint64_t v42 = *(void *)&v102[8];
      uint64_t v44 = *(void *)&v102[8];
      swift_retain();
      swift_retain();
      sub_1B51DB058(v7, (uint64_t)a3, (uint64_t)v63);
      sub_1B52BA6E8(v62, v61, v124, v58, v14, v55, v53, v54, v15, v60, v16, v56, v42, v57, 0);
      sub_1B52BA6E8(v62, v61, v124, v58, v14, v55, v53, v54, v15, v60, v59, v56, v44, v57, 0);
      LOWORD(v62) = v63[0];
      LOWORD(v55) = WORD1(v63[0]);
      LOWORD(v54) = WORD2(v63[0]);
      LOWORD(v53) = HIWORD(v63[0]);
      LOWORD(v61) = v63[1];
      LOWORD(v52) = WORD1(v63[1]);
      LOWORD(v51) = WORD2(v63[1]);
      LOWORD(v50) = HIWORD(v63[1]);
      uint64_t v124 = (unsigned __int16)v64;
      LOWORD(v49) = WORD1(v64);
      LOWORD(v48) = WORD2(v64);
      LOWORD(v47) = HIWORD(v64);
      LOWORD(v58) = v65;
      LOWORD(v46) = v66;
      LOWORD(v45) = v67;
      LOWORD(v18) = v68;
      char v21 = v69;
      v43.i32[0] = v70;
      int16x8_t v19 = (int16x8_t)vmovl_u8(v43);
      LOBYTE(v16) = v71;
      LOBYTE(v20) = v72;
      LOBYTE(v22) = v73;
      char v24 = v74;
      LOBYTE(v23) = v75;
      LODWORD(v25) = v76;
      int v26 = v77;
      LODWORD(v27) = v78;
      int v28 = v79;
      LODWORD(v29) = v80;
      __int16 v31 = v81;
      LOWORD(v30) = v82;
      LOWORD(a3) = v83;
      LOWORD(v7) = v84;
      LOWORD(v60) = v85;
      LOWORD(v15) = v86;
      LOWORD(v32) = v87;
      LOWORD(v33) = v88;
      uint64_t v59 = v89;
      char v35 = v90;
      uint64_t v34 = v91;
      LOWORD(v36) = v92;
      LOBYTE(v37) = v93;
      int v38 = v94;
      LOBYTE(v39) = v95;
    }
    *(_WORD *)a4 = v62;
    *(_WORD *)(a4 + 2) = v55;
    *(_WORD *)(a4 + 4) = v54;
    *(_WORD *)(a4 + 6) = v53;
    *(_WORD *)(a4 + 8) = v61;
    *(_WORD *)(a4 + 10) = v52;
    *(_WORD *)(a4 + 12) = v51;
    *(_WORD *)(a4 + 14) = v50;
    *(_WORD *)(a4 + 16) = v124;
    *(_WORD *)(a4 + 18) = v49;
    *(_WORD *)(a4 + 20) = v48;
    *(_WORD *)(a4 + 22) = v47;
    *(_WORD *)(a4 + 24) = v58;
    *(_WORD *)(a4 + 26) = v46;
    *(_WORD *)(a4 + 28) = v45;
    *(_WORD *)(a4 + 30) = v18;
    *(unsigned char *)(a4 + 32) = v21;
    *(_DWORD *)(a4 + 33) = vmovn_s16(v19).u32[0];
    *(unsigned char *)(a4 + 37) = v16;
    *(unsigned char *)(a4 + 38) = v20;
    *(unsigned char *)(a4 + 39) = v22;
    *(unsigned char *)(a4 + 40) = v24;
    *(unsigned char *)(a4 + 41) = v23;
    *(_DWORD *)(a4 + 44) = v25;
    *(_DWORD *)(a4 + 48) = v26;
    *(_DWORD *)(a4 + 52) = v27;
    *(_DWORD *)(a4 + 56) = v28;
    *(_DWORD *)(a4 + 60) = v29;
    *(_WORD *)(a4 + 64) = v31;
    *(_WORD *)(a4 + 66) = v30;
    *(_WORD *)(a4 + 68) = (_WORD)a3;
    *(_WORD *)(a4 + 70) = v7;
    *(_WORD *)(a4 + 72) = v60;
    *(_WORD *)(a4 + 74) = v15;
    *(_WORD *)(a4 + 76) = v32;
    *(_WORD *)(a4 + 78) = v33;
    *(void *)(a4 + 80) = v59;
    *(unsigned char *)(a4 + 88) = v35;
    *(void *)(a4 + 90) = v34;
    *(_WORD *)(a4 + 98) = v36;
    *(unsigned char *)(a4 + 100) = v37;
    *(_DWORD *)(a4 + 102) = v38;
    *(unsigned char *)(a4 + 106) = v39;
  }
}

void sub_1B52B18A0(long long *a1@<X0>, long long *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = (uint64_t)a3;
  uint64_t v7 = (uint64_t)a1;
  long long v9 = a2[3];
  long long v107 = a2[2];
  long long v108 = v9;
  long long v109 = a2[4];
  long long v10 = a2[1];
  long long v105 = *a2;
  long long v106 = v10;
  sub_1B51DB480(a1, a3, (uint64_t)v104);
  if (!v4)
  {
    (*((void (**)(unint64_t *__return_ptr, unsigned char *))a2 + 10))(&v89, v104);
    uint64_t v11 = v91;
    uint64_t v13 = v97;
    uint64_t v12 = v98;
    uint64_t v58 = v99;
    uint64_t v59 = v90;
    uint64_t v14 = *((void *)&v100 + 1);
    uint64_t v56 = v100;
    unsigned int v57 = v101 | (v102 << 16);
    uint64_t v60 = v89;
    unint64_t v115 = v92;
    if (v103)
    {
      uint64_t v52 = HIDWORD(v89);
      uint64_t v53 = v89 >> 16;
      unint64_t v50 = v90 >> 16;
      unint64_t v51 = HIWORD(v89);
      unint64_t v48 = HIWORD(v90);
      unint64_t v49 = HIDWORD(v90);
      unint64_t v46 = HIDWORD(v91);
      unint64_t v47 = v91 >> 16;
      __int16 v54 = v91;
      unint64_t v44 = v92 >> 16;
      unint64_t v45 = HIWORD(v91);
      uint64x2_t v15 = (uint64x2_t)vdupq_n_s64(v93);
      unint64_t v42 = HIWORD(v92);
      unint64_t v43 = HIDWORD(v92);
      int16x8_t v16 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v15, (uint64x2_t)xmmword_1B5392130), (int32x4_t)vshlq_u64(v15, (uint64x2_t)xmmword_1B5392120));
      *(int16x4_t *)v16.i8 = vmovn_s32((int32x4_t)v16);
      unint64_t v17 = v93 >> 40;
      unint64_t v18 = HIWORD(v93);
      char v19 = v93;
      unint64_t v20 = HIBYTE(v93);
      unint64_t v21 = v94 >> 8;
      char v22 = v94;
      unint64_t v23 = HIDWORD(v94);
      int v24 = v95;
      unint64_t v25 = HIDWORD(v95);
      int v26 = v96;
      unint64_t v27 = HIDWORD(v96);
      unint64_t v28 = v97 >> 16;
      uint64_t v5 = HIDWORD(v97);
      __int16 v29 = v97;
      uint64_t v7 = HIWORD(v97);
      uint64_t v13 = v98 >> 16;
      unint64_t v30 = HIDWORD(v98);
      __int16 v31 = v98;
      unint64_t v32 = HIWORD(v98);
      uint64_t v33 = v100 >> 16;
      char v34 = v100 & 1;
      uint64_t v35 = *((void *)&v100 + 1) >> 16;
      uint64_t v36 = HIDWORD(*((void *)&v100 + 1)) & 1;
      int v37 = HIWORD(*((void *)&v100 + 1)) | (v57 << 16);
      int v38 = HIWORD(v57) & 1;
      uint64_t v39 = v99;
    }
    else
    {
      __int16 v110 = v89 & 0x101;
      unint64_t v111 = v90;
      unint64_t v112 = v91;
      unint64_t v113 = v92;
      unint64_t v114 = v93;
      uint64_t v40 = v93;
      uint64_t v52 = v94;
      uint64_t v53 = v95;
      uint64_t v55 = v96;
      swift_retain();
      swift_retain();
      sub_1B51DB2A0(v7, v5, (uint64_t)v61);
      swift_release();
      swift_release();
      sub_1B52BA6E8(v60, v59, v11, v115, v40, v52, v53, v55, v13, v12, v58, v56, v14, v57, 0);
      LOWORD(v60) = v61[0];
      LOWORD(v53) = v61[1];
      LOWORD(v52) = v61[2];
      LOWORD(v51) = v61[3];
      LOWORD(v59) = v61[4];
      LOWORD(v50) = v61[5];
      LOWORD(v49) = v61[6];
      LOWORD(v48) = v61[7];
      __int16 v54 = v61[8];
      LOWORD(v47) = v61[9];
      LOWORD(v46) = v61[10];
      LOWORD(v45) = v61[11];
      unint64_t v115 = v61[12];
      LOWORD(v44) = v61[13];
      LOWORD(v43) = v61[14];
      LOWORD(v42) = v61[15];
      char v19 = v62;
      v41.i32[0] = v63;
      int16x8_t v16 = (int16x8_t)vmovl_u8(v41);
      LOBYTE(v17) = v64;
      LOBYTE(v18) = v65;
      LOBYTE(v20) = v66;
      char v22 = v67;
      LOBYTE(v21) = v68;
      LODWORD(v23) = v69;
      int v24 = v70;
      LODWORD(v25) = v71;
      int v26 = v72;
      LODWORD(v27) = v73;
      __int16 v29 = v74;
      LOWORD(v28) = v75;
      LOWORD(v5) = v76;
      LOWORD(v7) = v77;
      __int16 v31 = v78;
      LOWORD(v13) = v79;
      LOWORD(v30) = v80;
      LOWORD(v32) = v81;
      uint64_t v39 = v82;
      char v34 = v83;
      uint64_t v33 = v84;
      LOWORD(v35) = v85;
      LOBYTE(v36) = v86;
      int v37 = v87;
      LOBYTE(v38) = v88;
    }
    *(_WORD *)a4 = v60;
    *(_WORD *)(a4 + 2) = v53;
    *(_WORD *)(a4 + 4) = v52;
    *(_WORD *)(a4 + 6) = v51;
    *(_WORD *)(a4 + 8) = v59;
    *(_WORD *)(a4 + 10) = v50;
    *(_WORD *)(a4 + 12) = v49;
    *(_WORD *)(a4 + 14) = v48;
    *(_WORD *)(a4 + 16) = v54;
    *(_WORD *)(a4 + 18) = v47;
    *(_WORD *)(a4 + 20) = v46;
    *(_WORD *)(a4 + 22) = v45;
    *(_WORD *)(a4 + 24) = v115;
    *(_WORD *)(a4 + 26) = v44;
    *(_WORD *)(a4 + 28) = v43;
    *(_WORD *)(a4 + 30) = v42;
    *(unsigned char *)(a4 + 32) = v19;
    *(_DWORD *)(a4 + 33) = vmovn_s16(v16).u32[0];
    *(unsigned char *)(a4 + 37) = v17;
    *(unsigned char *)(a4 + 38) = v18;
    *(unsigned char *)(a4 + 39) = v20;
    *(unsigned char *)(a4 + 40) = v22;
    *(unsigned char *)(a4 + 41) = v21;
    *(_DWORD *)(a4 + 44) = v23;
    *(_DWORD *)(a4 + 48) = v24;
    *(_DWORD *)(a4 + 52) = v25;
    *(_DWORD *)(a4 + 56) = v26;
    *(_DWORD *)(a4 + 60) = v27;
    *(_WORD *)(a4 + 64) = v29;
    *(_WORD *)(a4 + 66) = v28;
    *(_WORD *)(a4 + 68) = v5;
    *(_WORD *)(a4 + 70) = v7;
    *(_WORD *)(a4 + 72) = v31;
    *(_WORD *)(a4 + 74) = v13;
    *(_WORD *)(a4 + 76) = v30;
    *(_WORD *)(a4 + 78) = v32;
    *(void *)(a4 + 80) = v39;
    *(unsigned char *)(a4 + 88) = v34;
    *(void *)(a4 + 90) = v33;
    *(_WORD *)(a4 + 98) = v35;
    *(unsigned char *)(a4 + 100) = v36;
    *(_DWORD *)(a4 + 102) = v37;
    *(unsigned char *)(a4 + 106) = v38;
  }
}

void sub_1B52B1E04(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  long long v9 = a2[5];
  long long v66 = a2[4];
  long long v67 = v9;
  long long v10 = a2[7];
  long long v68 = a2[6];
  long long v69 = v10;
  long long v11 = a2[1];
  long long v62 = *a2;
  long long v63 = v11;
  long long v12 = a2[3];
  long long v64 = a2[2];
  long long v65 = v12;
  sub_1B51DC18C(a1, a3, (uint64_t)v61);
  if (!v4)
  {
    (*((void (**)(unint64_t *__return_ptr, unsigned char *))a2 + 16))(&v45, v61);
    id v14 = (id)v46;
    int v13 = v45;
    id v16 = v47;
    id v15 = v48;
    id v17 = v49;
    id v18 = v50;
    id v19 = v51;
    id v20 = v52;
    id v21 = (id)v53;
    id v22 = v54;
    id v23 = v55;
    id v24 = v56;
    id v25 = v57;
    id v26 = v58;
    char v27 = v59;
    if (v60)
    {
      char v28 = v59 & 1;
    }
    else
    {
      char v70 = v45 & 1;
      uint64x2_t v29 = (uint64x2_t)vdupq_n_s64(v45);
      int16x8_t v30 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v29, (uint64x2_t)xmmword_1B5392130), (int32x4_t)vshlq_u64(v29, (uint64x2_t)xmmword_1B5392120));
      *(int8x8_t *)v30.i8 = vand_s8((int8x8_t)vmovn_s32((int32x4_t)v30), (int8x8_t)0x1000100010001);
      unsigned __int32 v71 = vmovn_s16(v30).u32[0];
      __int16 v72 = *(_WORD *)((unsigned char *)&v45 + 5) & 0x101;
      char v73 = HIBYTE(v45) & 1;
      int v74 = v46 & 0x1010101;
      __int16 v75 = v47;
      __int16 v76 = v48;
      __int16 v77 = v49;
      __int16 v78 = v50;
      uint64_t v41 = (uint64_t)v47;
      uint64_t v34 = (uint64_t)v50;
      uint64_t v35 = (uint64_t)v48;
      uint64_t v42 = (uint64_t)v49;
      uint64_t v36 = (uint64_t)v51;
      uint64_t v37 = (uint64_t)v52;
      uint64_t v79 = v53;
      uint64_t v39 = v45;
      uint64_t v40 = (uint64_t)v54;
      uint64_t v38 = (uint64_t)v55;
      uint64_t v32 = (uint64_t)v56;
      uint64_t v33 = v46;
      uint64_t v31 = (uint64_t)v58;
      swift_retain();
      swift_retain();
      sub_1B51DBD90(a1, a3, (uint64_t)v43);
      sub_1B52BA5B0(v39, v33, v41, v35, v42, v34, v36, v37, v79, v40, v38, (uint64_t)v24, (uint64_t)v25, (uint64_t)v26, v27, 0);
      sub_1B52BA5B0(v39, v33, v41, v35, v42, v34, v36, v37, v79, v40, v38, v32, (uint64_t)v25, v31, v27, 0);
      int v13 = (int)v43[0];
      id v14 = v43[1];
      id v16 = v43[2];
      id v15 = v43[3];
      id v17 = v43[4];
      id v18 = v43[5];
      id v19 = v43[6];
      id v20 = v43[7];
      id v21 = v43[8];
      id v22 = v43[9];
      id v23 = v43[10];
      id v24 = v43[11];
      id v25 = v43[12];
      id v26 = v43[13];
      char v28 = v44;
    }
    *(_DWORD *)a4 = v13;
    *(void *)(a4 + 8) = v14;
    *(void *)(a4 + 16) = v16;
    *(void *)(a4 + 24) = v15;
    *(void *)(a4 + 32) = v17;
    *(void *)(a4 + 40) = v18;
    *(void *)(a4 + 48) = v19;
    *(void *)(a4 + 56) = v20;
    *(void *)(a4 + 64) = v21;
    *(void *)(a4 + 72) = v22;
    *(void *)(a4 + 80) = v23;
    *(void *)(a4 + 88) = v24;
    *(void *)(a4 + 96) = v25;
    *(void *)(a4 + 104) = v26;
    *(unsigned char *)(a4 + 112) = v28;
  }
}

void sub_1B52B21A4(uint64_t a1@<X0>, __int16 a2@<W1>, void (*a3)(unsigned __int16 *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _WORD *a6@<X8>)
{
  *(void *)&long long v24 = a4;
  char v9 = HIBYTE(a2);
  char v12 = a2 & 1;
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D491E8);
  MEMORY[0x1F4188790](v13 - 8);
  id v15 = (char *)&v23 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = *(void *)(a1 + 16);
  long long v25 = *(_OWORD *)a1;
  *(void *)&long long v26 = v16;
  swift_bridgeObjectRetain();
  unsigned __int16 v17 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v25, a5, v12);
  if (v6)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v18 = v17;
    *(void *)&long long v23 = v15;
    uint64_t v31 = a6;
    long long v27 = v25;
    uint64_t v28 = v26;
    swift_bridgeObjectRetain();
    unsigned __int16 v19 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v27, a5, v9 & 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v20 = v28;
    *(_OWORD *)a1 = v27;
    *(void *)(a1 + 16) = v20;
    unsigned __int16 v29 = v18;
    uint64_t v30 = v19;
    uint64_t v21 = v23;
    a3(&v29);
    id v22 = v31;
    *id v22 = sub_1B52B7F44(v31 + 1, v31 + 2, (uint64_t)(v31 + 4), (uint64_t)(v31 + 16), (uint64_t)(v31 + 28), (uint64_t)(v31 + 40), (uint64_t)(v31 + 52), a1, a5);
    sub_1B51E0064(v21, &qword_1E9D491E8);
  }
}

void sub_1B52B24A0(uint64_t *a1, char a2, void (*a3)(long long *__return_ptr, uint64_t *), uint64_t a4, uint64_t a5)
{
  uint64_t v10 = a1[2];
  long long v14 = *(_OWORD *)a1;
  *(void *)&long long v15 = v10;
  swift_bridgeObjectRetain();
  unsigned __int16 v11 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v14, a5, a2);
  if (v5)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v12 = v11;
    swift_bridgeObjectRelease();
    uint64_t v13 = v15;
    *(_OWORD *)a1 = v14;
    a1[2] = v13;
    uint64_t v16 = v12;
    a3(&v14, &v16);
    sub_1B5256BB4(a1, a5, v14);
  }
}

void sub_1B52B2684(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *(*v8)(uint64_t *__return_ptr, unsigned __int16 *);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(long long *__return_ptr, uint64_t *);
  long long v14;
  uint64_t v15;
  long long v16;
  long long v17;
  uint64_t v18;

  char v7 = *(unsigned char *)a2;
  uint64_t v8 = *(void *(**)(uint64_t *__return_ptr, unsigned __int16 *))(a2 + 8);
  char v9 = *(void *)(a2 + 16);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v16 = *(_OWORD *)a1;
  *(void *)&unsigned __int16 v17 = v10;
  swift_bridgeObjectRetain();
  sub_1B51F063C(&v16, v7, v8, v9, a3);
  if (v3)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v12 = v11;
    swift_bridgeObjectRelease();
    uint64_t v13 = *(void (**)(long long *__return_ptr, uint64_t *))(a2 + 24);
    long long v14 = v16;
    long long v15 = v17;
    *(_OWORD *)a1 = v16;
    *(void *)(a1 + 16) = v15;
    unsigned __int16 v18 = v12;
    v13(&v16, &v18);
    *(_OWORD *)a1 = v14;
    *(void *)(a1 + 16) = v15;
  }
}

uint64_t sub_1B52B2870(uint64_t a1, char a2, void (*a3)(long long *__return_ptr, uint64_t *), uint64_t a4, uint64_t a5)
{
  uint64_t v11 = *(void *)(a1 + 16);
  long long v16 = *(_OWORD *)a1;
  *(void *)&long long v17 = v11;
  swift_bridgeObjectRetain();
  unsigned __int16 v12 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v16, a5, a2);
  if (v5)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v13 = v12;
    swift_bridgeObjectRelease();
    uint64_t v14 = v17;
    *(_OWORD *)a1 = v16;
    *(void *)(a1 + 16) = v14;
    uint64_t v21 = v13;
    a3(&v16, &v21);
    v19[0] = v16;
    v19[1] = v17;
    uint64_t v20 = v18;
    a4 = sub_1B52ADEB0((long long *)a1, a5);
    sub_1B52686AC((uint64_t)v19);
  }
  return a4;
}

void sub_1B52B2A74(uint64_t *a1@<X0>, char a2@<W1>, void (*a3)(unsigned __int16 *)@<X2>, uint64_t a4@<X4>, _OWORD *a5@<X8>)
{
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A80);
  MEMORY[0x1F4188790](v11 - 8);
  unsigned __int16 v13 = (char *)&v15 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  unsigned __int16 v14 = (unsigned __int16)sub_1B51F3E0C(a1, a4, a2);
  if (!v5)
  {
    unsigned __int16 v16 = v14;
    a3(&v16);
    sub_1B51ED834((uint64_t)a1, a4, a5);
    sub_1B51E0064((uint64_t)v13, &qword_1E9D47A80);
  }
}

void sub_1B52B2C7C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  void (*v18)(long long *__return_ptr, void *);
  uint64_t v19;
  long long v20;
  uint64_t v21;
  _OWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _OWORD *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(uint64_t *__return_ptr, void *);
  uint64_t v36;
  long long v37;
  uint64_t v38;
  uint64_t v39;
  id v40[2];
  uint64_t v41;
  void v42[3];
  _OWORD *v43;

  char v9 = *(unsigned char *)(a2 + 8);
  char v10 = *(unsigned char *)(a2 + 9);
  uint64_t v35 = *(void (**)(uint64_t *__return_ptr, void *))(a2 + 16);
  uint64_t v33 = *(void *)(a2 + 24);
  int v11 = *(_DWORD *)a2 & 1;
  uint64_t v12 = *(void *)(a1 + 16);
  *(_OWORD *)uint64_t v40 = *(_OWORD *)a1;
  uint64_t v41 = v12;
  swift_bridgeObjectRetain_n();
  unsigned __int16 v13 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)v40, a3, v11);
  if (v4)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v14 = v13;
    uint64_t v32 = a4;
    unint64_t v43 = (_OWORD *)a1;
    swift_bridgeObjectRelease();
    uint64_t v37 = *(_OWORD *)v40;
    uint64_t v38 = v41;
    uint64_t v15 = sub_1B51DC6A8(&v37, a3, v9 & 1 | ((v10 & 1u) << 8), v35, v33);
    uint64_t v17 = v16;
    swift_bridgeObjectRelease();
    uint64_t v18 = *(void (**)(long long *__return_ptr, void *))(a2 + 32);
    unsigned __int16 v19 = v14;
    uint64_t v20 = v37;
    uint64_t v21 = v38;
    id v22 = v43;
    *unint64_t v43 = v37;
    *((void *)v22 + 2) = v21;
    v42[0] = v19;
    v42[1] = v15;
    v42[2] = v17;
    v18(&v37, v42);
    uint64_t v36 = v37;
    long long v23 = v38;
    uint64_t v34 = *((void *)&v37 + 1);
    long long v24 = v39;
    *(_OWORD *)uint64_t v40 = v20;
    uint64_t v41 = v21;
    swift_bridgeObjectRetain();
    long long v25 = sub_1B52B8304((uint64_t *)v40, a3, v24);
    long long v27 = v26;
    unsigned __int16 v29 = v28;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    uint64_t v30 = v41;
    uint64_t v31 = v43;
    *unint64_t v43 = *(_OWORD *)v40;
    *((void *)v31 + 2) = v30;
    *uint64_t v32 = v36;
    v32[1] = v34;
    v32[2] = v23;
    v32[3] = v25;
    v32[4] = v27;
    v32[5] = v29;
  }
}

void sub_1B52B2F78(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void (*v12)(long long *__return_ptr, void *);
  long long v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  id v22[2];
  uint64_t v23;
  long long v24;
  long long v25;
  void v26[2];

  if (a2[1]) {
    __int16 v9 = 256;
  }
  else {
    __int16 v9 = 0;
  }
  uint64_t v10 = sub_1B51DC6A8((long long *)a1, a3, v9 | *a2, *((void (**)(uint64_t *__return_ptr, void *))a2 + 1), *((void *)a2 + 2));
  if (!v4)
  {
    uint64_t v12 = (void (*)(long long *__return_ptr, void *))*((void *)a2 + 3);
    v26[0] = v10;
    v26[1] = v11;
    v12(&v24, v26);
    unsigned __int16 v13 = v24;
    unsigned __int16 v14 = v25;
    uint64_t v15 = *(void *)(a1 + 16);
    *(_OWORD *)id v22 = *(_OWORD *)a1;
    long long v23 = v15;
    swift_bridgeObjectRetain();
    uint64_t v16 = sub_1B52B8304((uint64_t *)v22, a3, v14);
    uint64_t v18 = v17;
    uint64_t v20 = v19;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    uint64_t v21 = v23;
    *(_OWORD *)a1 = *(_OWORD *)v22;
    *(void *)(a1 + 16) = v21;
    *(_OWORD *)a4 = v13;
    *(void *)(a4 + 16) = v16;
    *(void *)(a4 + 24) = v18;
    *(void *)(a4 + 32) = v20;
  }
}

void sub_1B52B3198(long long *a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)&long long v26 = a3;
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D491E0);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1F4188790](v9);
  uint64_t v12 = (char *)&v23 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = *((void *)a1 + 2);
  long long v27 = *a1;
  uint64_t v28 = v13;
  swift_bridgeObjectRetain();
  unsigned int v14 = sub_1B51F3DDC((uint64_t *)&v27, a5, a2);
  if (v5)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned int v15 = v14;
    uint64_t v23 = v9;
    uint64_t v24 = a5;
    *(void *)&long long v25 = v10;
    swift_bridgeObjectRelease();
    uint64_t v16 = v28;
    *a1 = v27;
    *((void *)a1 + 2) = v16;
    uint64_t v32 = v15;
    ((void (*)(uint64_t *))v26)(&v32);
    uint64_t v17 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E9D48E90);
    uint64_t v18 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E9D48E98);
    uint64_t v19 = sub_1B52010C8(&qword_1E9D48EA0, &qword_1E9D48E90);
    uint64_t v20 = sub_1B52010C8(qword_1E9D48EA8, &qword_1E9D48E98);
    *(void *)&long long v27 = v17;
    *((void *)&v27 + 1) = MEMORY[0x1E4F83CE8];
    uint64_t v28 = v18;
    uint64_t v29 = v19;
    uint64_t v30 = v20;
    uint64_t OpaqueTypeConformance2 = swift_getOpaqueTypeConformance2();
    uint64_t v22 = v23;
    (*(void (**)(uint64_t *__return_ptr, long long *, uint64_t, uint64_t, uint64_t))(OpaqueTypeConformance2 + 24))(&v31, a1, v24, v23, OpaqueTypeConformance2);
    (*(void (**)(char *, uint64_t))(v25 + 8))(v12, v22);
  }
}

uint64_t sub_1B52B3500(long long *a1, char a2, void (*a3)(long long *__return_ptr, uint64_t *), uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *((void *)a1 + 2);
  long long v21 = *a1;
  *(void *)&long long v22 = v10;
  swift_bridgeObjectRetain();
  unsigned __int16 v11 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v21, a5, a2);
  if (v5)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v12 = v11;
    swift_bridgeObjectRelease();
    long long v13 = v21;
    uint64_t v14 = v22;
    *a1 = v21;
    *((void *)a1 + 2) = v14;
    uint64_t v23 = v12;
    a3(&v21, &v23);
    long long v15 = v21;
    long long v16 = v22;
    *(_OWORD *)uint64_t v19 = v13;
    uint64_t v20 = v14;
    swift_bridgeObjectRetain();
    a5 = sub_1B5200514((uint64_t)v19, (void (*)(void *__return_ptr, void))v15, *((uint64_t *)&v15 + 1), v16, *((uint64_t *)&v16 + 1), a5);
    swift_bridgeObjectRelease();
    swift_release();
    swift_bridgeObjectRelease();
    uint64_t v18 = v20;
    *a1 = *(_OWORD *)v19;
    *((void *)a1 + 2) = v18;
  }
  return a5;
}

void (*sub_1B52B3760(uint64_t a1, int a2, void (*a3)(unsigned char *__return_ptr, void *), uint64_t a4, uint64_t *a5))(unsigned char *__return_ptr, void *)
{
  void (*v23)(unsigned char *__return_ptr, void *);
  unsigned char v24[24];
  long long v25;
  long long v26;
  long long v27;
  long long v28;
  long long v29;
  id v30[2];
  uint64_t v31;
  void v32[4];
  _OWORD v33[7];
  void *v34;

  char v8 = HIBYTE(a2);
  uint64_t v10 = *(void *)(a1 + 16);
  *(_OWORD *)uint64_t v24 = *(_OWORD *)a1;
  *(void *)&v24[16] = v10;
  int v11 = a2 & 0x10101;
  swift_bridgeObjectRetain();
  unsigned __int16 v12 = sub_1B52B68D4(v24, (uint64_t)a5, v11);
  if (v5)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v15 = v13;
    uint64_t v16 = v14;
    uint64_t v34 = v12;
    uint64_t v23 = a3;
    *(_OWORD *)uint64_t v30 = *(_OWORD *)v24;
    uint64_t v31 = *(void *)&v24[16];
    swift_bridgeObjectRetain();
    unsigned int v18 = sub_1B51F3DDC((uint64_t *)v30, (uint64_t)a5, v8 & 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    id v19 = v30[0];
    id v20 = v30[1];
    uint64_t v21 = v31;
    *(id *)a1 = v30[0];
    *(void *)(a1 + 8) = v20;
    *(void *)(a1 + 16) = v21;
    v32[0] = v34;
    v32[1] = v15;
    v32[2] = v16;
    v32[3] = v18;
    v23(v24, v32);
    a3 = *(void (**)(unsigned char *__return_ptr, void *))v24;
    v33[2] = v26;
    v33[3] = v27;
    _OWORD v33[4] = v28;
    v33[5] = v29;
    v33[0] = *(_OWORD *)&v24[8];
    v33[1] = v25;
    v30[0] = v19;
    v30[1] = v20;
    uint64_t v31 = v21;
    swift_bridgeObjectRetain_n();
    sub_1B51F2CF0(v30, (uint64_t)v33, a5);
    swift_bridgeObjectRelease_n();
    sub_1B52BA444((uint64_t)v33);
    uint64_t v22 = v31;
    *(_OWORD *)a1 = *(_OWORD *)v30;
    *(void *)(a1 + 16) = v22;
  }
  return a3;
}

void sub_1B52B3A64(long long *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  void (*v17)(long long *__return_ptr, int *);
  long long v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  long long v23;
  uint64_t v24;
  uint64_t v25;
  long long v26;
  id v27[2];
  uint64_t v28;
  long long v29;
  uint64_t v30;
  long long v31;
  long long v32;
  long long v33;
  char v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  _OWORD v38[6];
  char v39;

  long long v9 = *(_OWORD *)(a2 + 16);
  v38[0] = *(_OWORD *)a2;
  v38[1] = v9;
  v38[2] = *(_OWORD *)(a2 + 32);
  uint64_t v10 = *((void *)a1 + 2);
  uint64_t v29 = *a1;
  uint64_t v30 = v10;
  swift_bridgeObjectRetain();
  int v11 = sub_1B51F1F34((uint64_t)&v29, (uint64_t)v38, (uint64_t)a3);
  if (v4)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    int v14 = v11;
    uint64_t v15 = v12;
    uint64_t v16 = v13;
    swift_bridgeObjectRelease();
    uint64_t v17 = *(void (**)(long long *__return_ptr, int *))(a2 + 48);
    unsigned int v18 = v29;
    id v19 = v30;
    *a1 = v29;
    long long v25 = v19;
    *((void *)a1 + 2) = v19;
    uint64_t v35 = v14;
    uint64_t v36 = v15;
    uint64_t v37 = v16;
    v17(&v29, &v35);
    id v20 = v29;
    uint64_t v21 = *((void *)&v29 + 1);
    uint64_t v22 = v30;
    v38[3] = v31;
    v38[4] = v32;
    v38[5] = v33;
    uint64_t v39 = v34;
    *(_OWORD *)long long v27 = v18;
    uint64_t v28 = v25;
    swift_bridgeObjectRetain();
    sub_1B51D3274((long long *)v27, a3, &v26);
    swift_bridgeObjectRelease();
    uint64_t v23 = v26;
    uint64_t v24 = v28;
    *a1 = *(_OWORD *)v27;
    *((void *)a1 + 2) = v24;
    *(_OWORD *)(a4 + 24) = v23;
    *(_DWORD *)a4 = v20;
    *(void *)(a4 + 8) = v21;
    *(void *)(a4 + 16) = v22;
  }
}

uint64_t *sub_1B52B3CE0(long long *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v9 = *((void *)a1 + 2);
  uint64_t v10 = (uint64_t *)(a3 & 1);
  long long v19 = *a1;
  uint64_t v20 = v9;
  swift_bridgeObjectRetain();
  int v11 = sub_1B51F9F5C((uint64_t *)&v19, a4, a2, (char)v10);
  if (v4)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v10 = v11;
    long long v17 = v19;
    uint64_t v18 = v20;
    swift_bridgeObjectRetain();
    sub_1B51F3DDC((uint64_t *)&v17, a4, BYTE1(a3) & 1);
    int v13 = HIWORD(a3) & 1;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    long long v14 = v17;
    uint64_t v15 = v18;
    *a1 = v17;
    *((void *)a1 + 2) = v15;
    long long v19 = v14;
    uint64_t v20 = v15;
    swift_bridgeObjectRetain();
    sub_1B51F3DDC((uint64_t *)&v19, a4, v13);
    swift_bridgeObjectRelease();
    uint64_t v16 = v20;
    *a1 = v19;
    *((void *)a1 + 2) = v16;
  }
  return v10;
}

uint64_t sub_1B52B3E4C@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  long long v9 = a2[11];
  long long v49 = a2[10];
  long long v50 = v9;
  uint64_t v51 = *((void *)a2 + 24);
  long long v10 = a2[7];
  long long v45 = a2[6];
  long long v46 = v10;
  long long v11 = a2[9];
  long long v47 = a2[8];
  long long v48 = v11;
  long long v12 = a2[3];
  long long v41 = a2[2];
  long long v42 = v12;
  long long v13 = a2[5];
  long long v43 = a2[4];
  long long v44 = v13;
  long long v14 = a2[1];
  long long v39 = *a2;
  long long v40 = v14;
  char v15 = *((unsigned char *)a2 + 200);
  uint64_t v16 = (uint64_t (*)(uint64_t *))*((void *)a2 + 26);
  uint64_t v17 = *((void *)a2 + 27);
  uint64_t v18 = *(void *)(a1 + 16);
  long long v37 = *(_OWORD *)a1;
  uint64_t v38 = v18;
  swift_bridgeObjectRetain();
  uint64_t v19 = sub_1B52B5AA4((uint64_t)&v37, a3);
  if (v4) {
    return swift_bridgeObjectRelease();
  }
  uint64_t v32 = v22;
  uint64_t v33 = v21;
  uint64_t v34 = v20;
  uint64_t v52 = v19;
  long long v35 = v37;
  uint64_t v36 = v38;
  swift_bridgeObjectRetain();
  uint64_t v23 = sub_1B51FB178(&v35, v15 & 1, v16, v17, a3);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  long long v24 = v35;
  uint64_t v25 = v36;
  *(_OWORD *)a1 = v35;
  *(void *)(a1 + 16) = v25;
  uint64_t v26 = *((unsigned __int8 *)a2 + 224);
  uint64_t v28 = (uint64_t (*)(uint64_t *))*((void *)a2 + 29);
  uint64_t v27 = *((void *)a2 + 30);
  long long v37 = v24;
  uint64_t v38 = v25;
  swift_bridgeObjectRetain();
  uint64_t v29 = sub_1B51FB178(&v37, v26, v28, v27, a3);
  uint64_t result = swift_bridgeObjectRelease();
  uint64_t v31 = v38;
  *(_OWORD *)a1 = v37;
  *(void *)(a1 + 16) = v31;
  *a4 = v52;
  a4[1] = v34;
  a4[2] = v33;
  a4[3] = v32;
  a4[4] = v23;
  a4[5] = v29;
  return result;
}

_OWORD *sub_1B52B401C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v7 = *(_OWORD *)(a2 + 16);
  v25[0] = *(_OWORD *)a2;
  v25[1] = v7;
  _OWORD v25[2] = *(_OWORD *)(a2 + 32);
  char v8 = *(unsigned char *)(a2 + 48);
  long long v10 = *(uint64_t (**)(uint64_t *))(a2 + 56);
  uint64_t v9 = *(void *)(a2 + 64);
  uint64_t v11 = *(void *)(a1 + 16);
  long long v23 = *(_OWORD *)a1;
  uint64_t v24 = v11;
  swift_bridgeObjectRetain();
  long long v12 = v25;
  uint64_t v13 = sub_1B51F435C((uint64_t *)&v21, &v23, a3);
  if (v3)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    long long v12 = (_OWORD *)v13;
    uint64_t v26 = v21;
    long long v21 = v23;
    uint64_t v22 = v24;
    swift_bridgeObjectRetain();
    sub_1B51FB320(&v21, v8 & 1, v10, v9, a3);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    long long v15 = v21;
    uint64_t v16 = v22;
    *(_OWORD *)a1 = v21;
    *(void *)(a1 + 16) = v16;
    uint64_t v17 = *(unsigned __int8 *)(a2 + 72);
    uint64_t v18 = *(uint64_t (**)(uint64_t *))(a2 + 80);
    uint64_t v19 = *(void *)(a2 + 88);
    long long v23 = v15;
    uint64_t v24 = v16;
    swift_bridgeObjectRetain();
    sub_1B51FB320(&v23, v17, v18, v19, a3);
    swift_bridgeObjectRelease();
    uint64_t v20 = v24;
    *(_OWORD *)a1 = v23;
    *(void *)(a1 + 16) = v20;
  }
  return v12;
}

unint64_t sub_1B52B41B8(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v7 = a1[2];
  uint64_t v8 = HIDWORD(a2) & 1;
  long long v14 = *(_OWORD *)a1;
  uint64_t v15 = v7;
  swift_bridgeObjectRetain_n();
  unsigned int v9 = sub_1B51F3E3C((uint64_t *)&v14, a3, v8);
  if (v3)
  {
    uint64_t v10 = v15;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned int v11 = v9;
    swift_bridgeObjectRelease_n();
    long long v16 = v14;
    uint64_t v17 = v15;
    sub_1B51F3F70((uint64_t *)&v16, a3, BYTE5(a2) & 1);
    swift_bridgeObjectRelease();
    uint64_t v13 = v17;
    *(_OWORD *)a1 = v16;
    a1[2] = v13;
    sub_1B51F3F70(a1, a3, BYTE6(a2) & 1);
    return a2 | ((unint64_t)v11 << 32);
  }
  return v10;
}

uint64_t sub_1B52B42F4@<X0>(long long *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v11 = *((void *)a1 + 2);
  long long v39 = *a1;
  uint64_t v40 = v11;
  uint64_t v12 = a2 & 0x101010101010101;
  uint64_t v13 = a3 & 0x101010101010101;
  swift_bridgeObjectRetain();
  sub_1B52B6A4C((uint64_t *)&v39, v12, v13, a5, (uint64_t)&v29);
  if (v6) {
    return swift_bridgeObjectRelease();
  }
  swift_bridgeObjectRelease();
  long long v14 = v39;
  uint64_t v15 = v40;
  *a1 = v39;
  *((void *)a1 + 2) = v15;
  int v16 = v29;
  uint64_t v17 = *((void *)&v29 + 1);
  uint64_t v18 = v30;
  uint64_t v41 = v31;
  uint64_t v27 = v33;
  uint64_t v28 = v32;
  uint64_t v25 = v35;
  uint64_t v26 = v34;
  uint64_t v23 = v37;
  uint64_t v24 = v36;
  uint64_t v22 = v38;
  long long v29 = v14;
  uint64_t v30 = v15;
  swift_bridgeObjectRetain();
  unsigned __int16 v19 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v29, a5, a4 & 1);
  uint64_t result = swift_bridgeObjectRelease();
  uint64_t v21 = v30;
  *a1 = v29;
  *((void *)a1 + 2) = v21;
  *(_DWORD *)a6 = v16;
  *(void *)(a6 + 8) = v17;
  *(void *)(a6 + 16) = v18;
  *(void *)(a6 + 24) = v41;
  *(void *)(a6 + 32) = v28;
  *(void *)(a6 + 40) = v27;
  *(void *)(a6 + 48) = v26;
  *(void *)(a6 + 56) = v25;
  *(void *)(a6 + 64) = v24;
  *(void *)(a6 + 72) = v23;
  *(void *)(a6 + 80) = v22;
  *(void *)(a6 + 88) = v19;
  return result;
}

uint64_t sub_1B52B447C@<X0>(long long *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  long long v9 = *(_OWORD *)(a2 + 48);
  v32[2] = *(_OWORD *)(a2 + 32);
  v32[3] = v9;
  uint64_t v33 = *(void *)(a2 + 64);
  long long v10 = *(_OWORD *)(a2 + 16);
  v32[0] = *(_OWORD *)a2;
  v32[1] = v10;
  uint64_t v11 = *((void *)a1 + 2);
  long long v30 = *a1;
  uint64_t v31 = v11;
  swift_bridgeObjectRetain();
  sub_1B52B45F4(&v30, (uint64_t)v32, a3, (uint64_t)&v25);
  if (v4) {
    return swift_bridgeObjectRelease();
  }
  swift_bridgeObjectRelease();
  long long v12 = v30;
  uint64_t v13 = v31;
  *a1 = v30;
  *((void *)a1 + 2) = v13;
  long long v14 = v25;
  __int16 v15 = v26;
  __int16 v16 = WORD1(v26);
  uint64_t v34 = v27;
  uint64_t v23 = v28;
  long long v24 = v29;
  uint64_t v17 = *(unsigned __int8 *)(a2 + 72);
  unsigned __int16 v19 = *(uint64_t (**)(__int16 *))(a2 + 80);
  uint64_t v18 = *(void *)(a2 + 88);
  long long v25 = v12;
  uint64_t v26 = v13;
  swift_bridgeObjectRetain();
  unsigned __int16 v20 = (unsigned __int16)sub_1B51FB4C8((uint64_t *)&v25, v17, v19, v18, (uint64_t)a3);
  uint64_t result = swift_bridgeObjectRelease();
  uint64_t v22 = v26;
  *a1 = v25;
  *((void *)a1 + 2) = v22;
  *(_OWORD *)a4 = v14;
  *(_WORD *)(a4 + 16) = v15;
  *(_WORD *)(a4 + 18) = v16;
  *(void *)(a4 + 24) = v34;
  *(void *)(a4 + 32) = v23;
  *(_OWORD *)(a4 + 40) = v24;
  *(_WORD *)(a4 + 56) = v20;
  return result;
}

uint64_t sub_1B52B45F4@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  long long v9 = *(_OWORD *)(a2 + 16);
  long long v45 = *(_OWORD *)a2;
  v46[0] = v9;
  *(_OWORD *)((char *)v46 + 9) = *(_OWORD *)(a2 + 25);
  char v10 = *(unsigned char *)(a2 + 41);
  char v11 = *(unsigned char *)(a2 + 42);
  uint64_t v12 = a1[1];
  uint64_t v13 = a1[2];
  *(void *)&long long v43 = *a1;
  *((void *)&v43 + 1) = v12;
  uint64_t v44 = v13;
  *(void *)&long long v39 = v43;
  *((void *)&v39 + 1) = v12;
  uint64_t v40 = v13;
  swift_bridgeObjectRetain_n();
  sub_1B52B483C(&v39, &v45, a3, (uint64_t)&v33);
  if (v4)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v29 = a4;
    swift_bridgeObjectRelease();
    char v14 = v10 & 1;
    long long v41 = v39;
    uint64_t v42 = v40;
    long long v32 = v33;
    __int16 v30 = v34;
    __int16 v31 = WORD1(v34);
    uint64_t v15 = v35;
    uint64_t v16 = v36;
    uint64_t v17 = v37;
    __int16 v18 = v38;
    unsigned __int16 v27 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v41, (uint64_t)a3, v14);
    uint64_t v28 = v15;
    swift_bridgeObjectRelease();
    long long v43 = v41;
    uint64_t v44 = v42;
    LOWORD(v15) = (unsigned __int16)sub_1B51F3F70((uint64_t *)&v43, (uint64_t)a3, v11 & 1);
    swift_bridgeObjectRelease();
    long long v20 = v43;
    uint64_t v21 = v44;
    *(_OWORD *)a1 = v43;
    a1[2] = v21;
    uint64_t v22 = *(unsigned __int8 *)(a2 + 48);
    long long v24 = *(uint64_t (**)(__int16 *))(a2 + 56);
    uint64_t v23 = *(void *)(a2 + 64);
    long long v33 = v20;
    uint64_t v34 = v21;
    swift_bridgeObjectRetain();
    unsigned __int16 v25 = (unsigned __int16)sub_1B51FB500(&v33, v22, v24, v23, (uint64_t)a3);
    uint64_t result = swift_bridgeObjectRelease();
    uint64_t v26 = v34;
    *(_OWORD *)a1 = v33;
    a1[2] = v26;
    *(_OWORD *)uint64_t v29 = v32;
    *(_WORD *)(v29 + 16) = v30;
    *(_WORD *)(v29 + 18) = v31;
    *(void *)(v29 + 24) = v28;
    *(void *)(v29 + 32) = v16;
    *(void *)(v29 + 40) = v17;
    *(_WORD *)(v29 + 48) = v18;
    *(_WORD *)(v29 + 50) = v27;
    *(_WORD *)(v29 + 52) = v15;
    *(_WORD *)(v29 + 54) = v25;
  }
  return result;
}

uint64_t sub_1B52B483C@<X0>(long long *a1@<X0>, long long *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  long long v9 = a2[1];
  long long v36 = *a2;
  v37[0] = v9;
  *(void *)((char *)v37 + 14) = *(void *)((char *)a2 + 30);
  char v10 = *((unsigned char *)a2 + 38);
  char v11 = *((unsigned char *)a2 + 39);
  uint64_t v12 = *((void *)a1 + 2);
  long long v32 = *a1;
  uint64_t v33 = v12;
  swift_bridgeObjectRetain_n();
  unsigned __int16 v13 = (unsigned __int16)sub_1B51F54D8((uint64_t *)&v27, &v32, a3);
  if (v4)
  {
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v14 = v13;
    unsigned int v38 = sub_1B51F3F70((uint64_t *)&v32, (uint64_t)a3, v10 & 1);
    swift_bridgeObjectRelease();
    long long v26 = v27;
    int v39 = (unsigned __int16)v28;
    __int16 v25 = WORD1(v28);
    uint64_t v23 = v30;
    uint64_t v24 = v29;
    __int16 v15 = v31;
    long long v34 = v32;
    uint64_t v35 = v33;
    unsigned __int16 v16 = (unsigned __int16)sub_1B51F3F70((uint64_t *)&v34, (uint64_t)a3, v11 & 1);
    swift_bridgeObjectRelease();
    long long v17 = v34;
    uint64_t v18 = v35;
    *a1 = v34;
    *((void *)a1 + 2) = v18;
    uint64_t v19 = *((unsigned char *)a2 + 40) & 1;
    long long v27 = v17;
    uint64_t v28 = v18;
    swift_bridgeObjectRetain();
    unsigned __int16 v20 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v27, (uint64_t)a3, v19);
    uint64_t result = swift_bridgeObjectRelease();
    uint64_t v22 = v28;
    *a1 = v27;
    *((void *)a1 + 2) = v22;
    *(_OWORD *)a4 = v26;
    *(_WORD *)(a4 + 16) = v39;
    *(_WORD *)(a4 + 18) = v25;
    *(void *)(a4 + 24) = v24;
    *(void *)(a4 + 32) = v23;
    *(_WORD *)(a4 + 40) = v15;
    *(_WORD *)(a4 + 42) = v14;
    *(_WORD *)(a4 + 44) = v38;
    *(_WORD *)(a4 + 46) = v16;
    *(_WORD *)(a4 + 48) = v20;
  }
  return result;
}

void *sub_1B52B4A44@<X0>(long long *a1@<X0>, long long *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void *(*v30)(long long *__return_ptr, long long *, uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  void *result;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  long long v45;
  uint64_t v46;
  uint64_t *v47[4];
  long long v48;
  uint64_t v49;
  long long v50;
  uint64_t v51;
  long long v52;
  long long v53;
  uint64_t v54;
  uint64_t *v55;

  long long v7 = a2[1];
  uint64_t v52 = *a2;
  uint64_t v53 = v7;
  uint64_t v8 = *((void *)a2 + 4);
  uint64_t v55 = (uint64_t *)*((void *)a2 + 5);
  __int16 v54 = v8;
  uint64_t v9 = *((void *)a2 + 6);
  uint64_t v10 = *((void *)a1 + 2);
  long long v48 = *a1;
  long long v49 = v10;
  swift_bridgeObjectRetain_n();
  uint64_t v11 = a3;
  uint64_t v12 = sub_1B51F6858(v47, &v48, a3);
  if (v4)
  {
    swift_bridgeObjectRelease();
    return (void *)swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v16 = v13;
    long long v17 = a1;
    uint64_t v42 = v14;
    long long v43 = v15;
    uint64_t v18 = v9;
    long long v41 = v12;
    uint64_t v19 = sub_1B52B8304((uint64_t *)&v48, v11, (uint64_t)v55);
    uint64_t v21 = v20;
    uint64_t v40 = v22;
    uint64_t v55 = v19;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    uint64_t v23 = v47[2];
    unsigned int v38 = v47[1];
    int v39 = v47[0];
    long long v50 = v48;
    uint64_t v51 = v49;
    uint64_t v24 = sub_1B52B8304((uint64_t *)&v50, v11, v18);
    long long v34 = v25;
    uint64_t v35 = v24;
    long long v36 = v23;
    uint64_t v37 = v21;
    uint64_t v27 = v26;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    uint64_t v28 = v51;
    *long long v17 = v50;
    *((void *)v17 + 2) = v28;
    __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D49010);
    uint64_t OpaqueTypeConformance2 = swift_getOpaqueTypeConformance2();
    uint64_t v30 = *(void *(**)(long long *__return_ptr, long long *, uint64_t, uint64_t, uint64_t))(OpaqueTypeConformance2
                                                                                                  + 24);
    __int16 v31 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A60);
    uint64_t result = v30(&v45, v17, v11, v31, OpaqueTypeConformance2);
    *(_DWORD *)a4 = v41;
    *(_WORD *)(a4 + 4) = WORD2(v41);
    *(void *)(a4 + 8) = v16;
    *(void *)(a4 + 16) = v42;
    *(void *)(a4 + 24) = v43;
    *(void *)(a4 + 32) = v39;
    *(void *)(a4 + 40) = v38;
    *(void *)(a4 + 48) = v36;
    *(void *)(a4 + 56) = v55;
    *(void *)(a4 + 64) = v40;
    *(void *)(a4 + 72) = v37;
    *(void *)(a4 + 80) = v35;
    *(void *)(a4 + 88) = v34;
    *(void *)(a4 + 96) = v27;
    uint64_t v33 = v46;
    *(_OWORD *)(a4 + 104) = v45;
    *(void *)(a4 + 120) = v33;
  }
  return result;
}

double sub_1B52B4D00(uint64_t a1, long long *a2, uint64_t a3)
{
  void *(*v10)(uint64_t *__return_ptr, unsigned __int16 *);
  uint64_t v11;
  uint64_t v12;
  double v13;
  long long v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *(*v19)(uint64_t *__return_ptr, unsigned __int16 *);
  uint64_t v20;
  long long v21;
  uint64_t v22;
  long long v23;
  uint64_t v24;
  long long v25;
  long long v26;
  long long v27;

  long long v8 = a2[1];
  uint64_t v25 = *a2;
  uint64_t v26 = v8;
  uint64_t v27 = a2[2];
  char v9 = *((unsigned char *)a2 + 48);
  uint64_t v10 = (void *(*)(uint64_t *__return_ptr, unsigned __int16 *))*((void *)a2 + 7);
  uint64_t v11 = *((void *)a2 + 8);
  uint64_t v12 = *(void *)(a1 + 16);
  uint64_t v23 = *(_OWORD *)a1;
  uint64_t v24 = v12;
  swift_bridgeObjectRetain();
  uint64_t v13 = sub_1B51F6FC4(&v21, (uint64_t)&v23, a3);
  if (v3)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    double v4 = v13;
    uint64_t v21 = v23;
    uint64_t v22 = v24;
    swift_bridgeObjectRetain();
    sub_1B51F063C(&v21, v9 & 1, v10, v11, a3);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v15 = v21;
    uint64_t v16 = v22;
    *(_OWORD *)a1 = v21;
    *(void *)(a1 + 16) = v16;
    long long v17 = *((unsigned __int8 *)a2 + 72);
    uint64_t v19 = (void *(*)(uint64_t *__return_ptr, unsigned __int16 *))*((void *)a2 + 10);
    uint64_t v18 = *((void *)a2 + 11);
    uint64_t v23 = v15;
    uint64_t v24 = v16;
    swift_bridgeObjectRetain();
    sub_1B51F063C(&v23, v17, v19, v18, a3);
    swift_bridgeObjectRelease();
    uint64_t v20 = v24;
    *(_OWORD *)a1 = v23;
    *(void *)(a1 + 16) = v20;
  }
  return v4;
}

double sub_1B52B4EA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *(*v8)(uint64_t *__return_ptr, unsigned __int16 *);
  uint64_t v9;
  uint64_t v10;
  int v11;
  double v12;
  char v13;
  uint64_t v14;
  void *(*v15)(uint64_t *__return_ptr, unsigned __int16 *);
  long long v16;
  uint64_t v17;
  uint64_t v19;
  long long v20;
  uint64_t v21;

  long long v8 = *(void *(**)(uint64_t *__return_ptr, unsigned __int16 *))(a2 + 8);
  char v9 = *(void *)(a2 + 16);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(_DWORD *)a2 & 1;
  uint64_t v20 = *(_OWORD *)a1;
  uint64_t v21 = v10;
  swift_bridgeObjectRetain_n();
  sub_1B51F063C(&v20, v11, v8, v9, a3);
  if (v3)
  {
    swift_bridgeObjectRelease_n();
    swift_bridgeObjectRelease();
  }
  else
  {
    double v4 = v12;
    swift_bridgeObjectRelease();
    uint64_t v13 = *(unsigned char *)(a2 + 40);
    uint64_t v15 = *(void *(**)(uint64_t *__return_ptr, unsigned __int16 *))(a2 + 48);
    uint64_t v14 = *(void *)(a2 + 56);
    swift_bridgeObjectRelease_n();
    uint64_t v16 = v20;
    long long v17 = v21;
    *(_OWORD *)a1 = v20;
    *(void *)(a1 + 16) = v17;
    uint64_t v20 = v16;
    uint64_t v21 = v17;
    swift_bridgeObjectRetain();
    sub_1B51F063C(&v20, v13, v15, v14, a3);
    swift_bridgeObjectRelease();
    uint64_t v19 = v21;
    *(_OWORD *)a1 = v20;
    *(void *)(a1 + 16) = v19;
  }
  return v4;
}

uint64_t sub_1B52B500C@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char a5@<W4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v15 = *(void *)(a1 + 16);
  long long v28 = *(_OWORD *)a1;
  uint64_t v29 = v15;
  swift_bridgeObjectRetain_n();
  uint64_t v16 = sub_1B51ED464(&v28, a6, a3, a4 & 0x1FF);
  if (v7)
  {
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v17 = v16;
    int v30 = a2;
    swift_bridgeObjectRelease_n();
    long long v18 = v28;
    uint64_t v19 = v29;
    *(_OWORD *)a1 = v28;
    *(void *)(a1 + 16) = v19;
    long long v28 = v18;
    uint64_t v29 = v19;
    swift_bridgeObjectRetain();
    char v31 = BYTE4(a4) & 1;
    if ((a4 & 0x10000000000) != 0) {
      uint64_t v20 = sub_1B51ED240(&v28, a6, BYTE3(a4) | (unsigned __int16)((BYTE4(a4) & 1) << 8));
    }
    else {
      uint64_t v20 = sub_1B51ED348(&v28, a6, BYTE3(a4) | (unsigned __int16)((BYTE4(a4) & 1) << 8));
    }
    uint64_t v21 = v20;
    char v31 = HIBYTE(a4) & 1;
    if (a5) {
      uint64_t v22 = sub_1B51ED240(&v28, a6, BYTE6(a4) | (unsigned __int16)((HIBYTE(a4) & 1) << 8));
    }
    else {
      uint64_t v22 = sub_1B51ED348(&v28, a6, BYTE6(a4) | (unsigned __int16)((HIBYTE(a4) & 1) << 8));
    }
    uint64_t v24 = v22;
    uint64_t v25 = v21;
    __int16 v26 = v30;
    uint64_t result = swift_bridgeObjectRelease();
    uint64_t v27 = v29;
    *(_OWORD *)a1 = v28;
    *(void *)(a1 + 16) = v27;
    *(_WORD *)a7 = v26;
    *(void *)(a7 + 8) = v17;
    *(unsigned char *)(a7 + 16) = BYTE2(a4) & 1;
    *(void *)(a7 + 24) = v25;
    *(void *)(a7 + 32) = v24;
  }
  return result;
}

uint64_t sub_1B52B51EC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  void (*v26)(long long *__return_ptr, uint64_t *);
  uint64_t v27;
  uint64_t result;
  uint64_t v29;
  char v30;
  char v32;
  char v33;
  char v34;
  char v35;
  char v36;
  char v37;
  char v38;
  int v39;
  uint64_t v40;
  long long v41;
  uint64_t v43;
  uint64_t v44;
  long long v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  long long v49;
  uint64_t v50;

  long long v36 = *(unsigned char *)(a2 + 1);
  uint64_t v35 = *(unsigned char *)(a2 + 2);
  long long v34 = *(unsigned char *)(a2 + 3);
  char v6 = *(unsigned char *)(a2 + 7);
  char v7 = *(unsigned char *)(a2 + 8);
  uint64_t v40 = *(void *)(a2 + 16);
  uint64_t v37 = *(unsigned char *)(a2 + 10);
  unsigned int v38 = *(unsigned char *)(a2 + 24);
  char v8 = *(unsigned char *)(a2 + 25);
  long long v32 = *(unsigned char *)(a2 + 26);
  uint64_t v33 = *(unsigned char *)(a2 + 9);
  int v30 = *(unsigned char *)(a2 + 27);
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = *(unsigned char *)a2 & 1;
  uint64_t v11 = *(unsigned char *)(a2 + 4) & 1;
  uint64_t v12 = *(unsigned char *)(a2 + 5) & 1;
  uint64_t v13 = *(unsigned char *)(a2 + 6) & 1;
  long long v49 = *(_OWORD *)a1;
  uint64_t v14 = v6 & 1;
  int v15 = v7 & 1;
  int v16 = v8 & 1;
  long long v50 = v9;
  swift_bridgeObjectRetain();
  unsigned int v17 = sub_1B51F7114((uint64_t)&v45, &v49, a3, v10 & 0xFFFFFFFFFEFEFEFFLL | ((v36 & 1) << 8) | ((unint64_t)(v35 & 1) << 16) & 0xFFFFFFFFFEFFFFFFLL | ((unint64_t)(v34 & 1) << 24) | (v11 << 32) | (v12 << 40) | (v13 << 48) | (v14 << 56), v15 & 0xFFFEFEFF | ((v33 & 1) << 8) | ((v37 & 1) << 16), v40, (v16 << 8) & 0xFFFEFFFE | ((v32 & 1) << 16) | v38 & 1);
  if (v43) {
    return swift_bridgeObjectRelease();
  }
  unsigned int v18 = v17;
  uint64_t v19 = a1;
  unsigned __int16 v20 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v49, (uint64_t)a3, v30 & 1);
  swift_bridgeObjectRelease();
  long long v41 = v45;
  uint64_t v21 = v46;
  int v39 = v47;
  uint64_t v44 = v48;
  long long v22 = v49;
  uint64_t v23 = v50;
  *(_OWORD *)uint64_t v19 = v49;
  *(void *)(v19 + 16) = v23;
  char v24 = *(unsigned char *)(a2 + 32);
  __int16 v26 = *(void (**)(long long *__return_ptr, uint64_t *))(a2 + 40);
  uint64_t v25 = *(void *)(a2 + 48);
  long long v45 = v22;
  long long v46 = v23;
  swift_bridgeObjectRetain();
  uint64_t v27 = sub_1B52B2870((uint64_t)&v45, v24, v26, v25, (uint64_t)a3);
  uint64_t result = swift_bridgeObjectRelease();
  uint64_t v29 = v46;
  *(_OWORD *)uint64_t v19 = v45;
  *(void *)(v19 + 16) = v29;
  *(_OWORD *)a4 = v41;
  *(void *)(a4 + 16) = v21;
  *(_DWORD *)(a4 + 24) = v39;
  *(void *)(a4 + 32) = v44;
  *(_DWORD *)(a4 + 40) = v18;
  *(_WORD *)(a4 + 44) = v20;
  *(void *)(a4 + 48) = v27;
  return result;
}

uint64_t sub_1B52B5458@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, unsigned int a5@<W4>, uint64_t *a6@<X5>, _OWORD *a7@<X8>)
{
  char v31 = a7;
  uint64_t v13 = a1[2];
  char v14 = a3 & 1;
  long long v27 = *(_OWORD *)a1;
  uint64_t v28 = v13;
  uint64_t v15 = a2 & 0x101010101010101;
  swift_bridgeObjectRetain_n();
  unsigned int v16 = sub_1B51F7290((uint64_t)&v26, &v27, a6, v15, v14);
  if (v7)
  {
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else
  {
    unsigned int v17 = v16;
    unsigned int v25 = sub_1B51F3DDC((uint64_t *)&v27, (uint64_t)a6, BYTE1(a3) & 1);
    swift_bridgeObjectRelease();
    long long v24 = v26;
    long long v29 = v27;
    uint64_t v30 = v28;
    unsigned int v19 = sub_1B51F3DDC((uint64_t *)&v29, (uint64_t)a6, BYTE2(a3) & 1);
    unsigned int v20 = v19;
    swift_bridgeObjectRelease();
    uint64_t v21 = v30;
    *(_OWORD *)a1 = v29;
    a1[2] = v21;
    int v22 = (a5 >> 8) & 1;
    if (a5) {
      uint64_t result = sub_1B52B80FC(a1, (uint64_t)a6, v22);
    }
    else {
      uint64_t result = sub_1B5255BCC((uint64_t)a1, (uint64_t)a6, v22, MEMORY[0x1E4FBC860], a4);
    }
    uint64_t v23 = v31;
    *char v31 = v24;
    *((_DWORD *)v23 + 4) = v17;
    *((_DWORD *)v23 + 5) = v25;
    *((_DWORD *)v23 + 6) = v20;
    *((void *)v23 + 4) = result;
  }
  return result;
}

__n128 sub_1B52B55FC@<Q0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47A50);
  MEMORY[0x1F4188790](v8 - 8);
  uint64_t v10 = (char *)&v28 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D48E80);
  MEMORY[0x1F4188790](v11);
  uint64_t v13 = (char *)&v28 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = *a2;
  uint64_t v34 = a2[1];
  uint64_t v15 = a2[3];
  uint64_t v29 = a2[2];
  *(void *)&long long v30 = v14;
  uint64_t v16 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D48E78);
  sub_1B5201384((uint64_t)a2 + *(int *)(v16 + 52), (uint64_t)v13, &qword_1E9D48E80);
  if (swift_getEnumCaseMultiPayload() == 1)
  {
    long long v17 = *(_OWORD *)v13;
    long long v30 = *((_OWORD *)v13 + 1);
    long long v31 = v17;
    uint64_t v18 = *((void *)v13 + 4);
    sub_1B51D4D34();
    swift_allocError();
    long long v19 = v30;
    *(_OWORD *)uint64_t v20 = v31;
    *(_OWORD *)(v20 + 16) = v19;
    *(void *)(v20 + 32) = v18;
    swift_willThrow();
  }
  else
  {
    sub_1B5201994((uint64_t)v13, (uint64_t)v10, &qword_1E9D47A50);
    swift_bridgeObjectRetain();
    uint64_t v22 = v31;
    sub_1B51ED574(a1, a3, (uint64_t)v32);
    sub_1B51E0064((uint64_t)v10, &qword_1E9D47A50);
    if (v22)
    {
      swift_bridgeObjectRelease();
    }
    else
    {
      char v23 = v33;
      __n128 result = (__n128)v32[0];
      long long v24 = v32[1];
      long long v25 = v32[2];
      long long v26 = v32[3];
      uint64_t v27 = v34;
      *(void *)a4 = v30;
      *(void *)(a4 + 8) = v27;
      *(void *)(a4 + 16) = v29;
      *(void *)(a4 + 24) = v15;
      *(__n128 *)(a4 + 32) = result;
      *(_OWORD *)(a4 + 48) = v24;
      *(_OWORD *)(a4 + 64) = v25;
      *(_OWORD *)(a4 + 80) = v26;
      *(unsigned char *)(a4 + 96) = v23;
    }
  }
  return result;
}

uint64_t (*sub_1B52B580C(uint64_t a1, int a2, uint64_t (*a3)(__int16 *, __int16 *), uint64_t a4, unsigned int a5, uint64_t a6))(__int16 *, __int16 *)
{
  uint64_t v12 = *(void *)(a1 + 16);
  long long v21 = *(_OWORD *)a1;
  uint64_t v22 = v12;
  unsigned int v13 = a2 & 0xFFFF0001;
  uint64_t v14 = (uint64_t *)(a5 & 0x101);
  swift_bridgeObjectRetain();
  uint64_t v15 = sub_1B51F9428(&v23, &v21, a6, v13, a3, a4, v14);
  if (v6)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    a3 = (uint64_t (*)(__int16 *, __int16 *))v15;
    sub_1B51F3E0C((uint64_t *)&v21, a6, BYTE2(a5) & 1);
    int v16 = HIBYTE(a5) & 1;
    swift_bridgeObjectRelease();
    long long v17 = v21;
    uint64_t v18 = v22;
    *(_OWORD *)a1 = v21;
    *(void *)(a1 + 16) = v18;
    long long v21 = v17;
    uint64_t v22 = v18;
    swift_bridgeObjectRetain();
    sub_1B51F3DDC((uint64_t *)&v21, a6, v16);
    swift_bridgeObjectRelease();
    uint64_t v20 = v22;
    *(_OWORD *)a1 = v21;
    *(void *)(a1 + 16) = v20;
  }
  return a3;
}

uint64_t sub_1B52B595C(void *a1, uint64_t a2, int a3)
{
  char v7 = a3 & 1;
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  *(void *)&long long v18 = *a1;
  *((void *)&v18 + 1) = v8;
  uint64_t v19 = v9;
  *(void *)&long long v14 = v18;
  *((void *)&v14 + 1) = v8;
  uint64_t v15 = v9;
  swift_bridgeObjectRetain_n();
  unsigned __int16 v10 = (unsigned __int16)sub_1B51F3E0C((uint64_t *)&v14, a2, v7);
  if (v3)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v11 = v10;
    swift_bridgeObjectRelease();
    long long v16 = v14;
    uint64_t v17 = v15;
    sub_1B51F3E0C((uint64_t *)&v16, a2, BYTE1(a3) & 1);
    swift_bridgeObjectRelease();
    long long v18 = v16;
    uint64_t v19 = v17;
    sub_1B51F3E0C((uint64_t *)&v18, a2, BYTE2(a3) & 1);
    swift_bridgeObjectRelease();
    uint64_t result = v11;
    uint64_t v13 = v19;
    *(_OWORD *)a1 = v18;
    a1[2] = v13;
  }
  return result;
}

uint64_t sub_1B52B5AA4(uint64_t a1, uint64_t a2)
{
  double v4 = v2;
  uint64_t v7 = *(void *)(a1 + 16);
  long long v8 = v2[7];
  long long v31 = v2[6];
  long long v32 = v8;
  long long v33 = v2[8];
  uint64_t v34 = *((void *)v2 + 18);
  long long v9 = v2[3];
  long long v27 = v2[2];
  long long v28 = v9;
  long long v10 = v2[5];
  long long v29 = v2[4];
  long long v30 = v10;
  long long v11 = v2[1];
  long long v25 = *v2;
  long long v26 = v11;
  char v12 = *((unsigned char *)v2 + 152);
  uint64_t v13 = (uint64_t (*)(uint64_t *))*((void *)v2 + 20);
  uint64_t v14 = *((void *)v2 + 21);
  long long v23 = *(_OWORD *)a1;
  uint64_t v24 = v7;
  swift_bridgeObjectRetain_n();
  uint64_t v15 = sub_1B52B5C74((uint64_t)&v23, a2);
  if (v3)
  {
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v35 = v15;
    long long v21 = v23;
    uint64_t v22 = v24;
    swift_bridgeObjectRetain();
    sub_1B51FB178(&v21, v12 & 1, v13, v14, a2);
    swift_bridgeObjectRelease();
    char v16 = *((unsigned char *)v2 + 176);
    uint64_t v17 = (uint64_t (*)(uint64_t *))*((void *)v4 + 23);
    uint64_t v18 = *((void *)v4 + 24);
    swift_bridgeObjectRelease();
    long long v23 = v21;
    uint64_t v24 = v22;
    swift_bridgeObjectRetain();
    sub_1B51FB178(&v23, v16 & 1, v17, v18, a2);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v19 = v24;
    *(_OWORD *)a1 = v23;
    *(void *)(a1 + 16) = v19;
    return v35;
  }
}

uint64_t sub_1B52B5C74(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void *)(a1 + 16);
  long long v7 = *(_OWORD *)(v2 + 80);
  v20[4] = *(_OWORD *)(v2 + 64);
  v20[5] = v7;
  long long v8 = *(_OWORD *)(v2 + 112);
  v20[6] = *(_OWORD *)(v2 + 96);
  v20[7] = v8;
  long long v9 = *(_OWORD *)(v2 + 16);
  v20[0] = *(_OWORD *)v2;
  v20[1] = v9;
  long long v10 = *(_OWORD *)(v2 + 48);
  v20[2] = *(_OWORD *)(v2 + 32);
  v20[3] = v10;
  long long v18 = *(_OWORD *)a1;
  uint64_t v19 = v6;
  swift_bridgeObjectRetain_n();
  uint64_t v11 = sub_1B51EF5DC((uint64_t)&v18, (uint64_t)v20, a2);
  if (v3)
  {
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v21 = v11;
    swift_bridgeObjectRelease();
    char v12 = *(unsigned char *)(v2 + 128);
    uint64_t v14 = *(uint64_t (**)(uint64_t *))(v2 + 136);
    uint64_t v13 = *(void *)(v2 + 144);
    char v15 = v12 & 1;
    swift_bridgeObjectRetain();
    sub_1B51FB320(&v18, v15, v14, v13, a2);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v16 = v19;
    *(_OWORD *)a1 = v18;
    *(void *)(a1 + 16) = v16;
    return v21;
  }
}

uint64_t sub_1B52B5DD4@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = a1[1];
  uint64_t v11 = a1[2];
  *(void *)&long long v44 = *a1;
  *((void *)&v44 + 1) = v10;
  uint64_t v45 = v11;
  *(void *)&long long v42 = v44;
  *((void *)&v42 + 1) = v10;
  *(void *)&long long v40 = v44;
  *((void *)&v40 + 1) = v10;
  uint64_t v41 = v11;
  uint64_t v12 = a3 & 0x101010101010101;
  __int16 v13 = a4 & 0x101;
  swift_bridgeObjectRetain_n();
  uint64_t v14 = sub_1B51F4BA4((uint64_t)&v31, &v40, a2, v12, v13);
  if (v5)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v15 = v14;
    long long v29 = v40;
    uint64_t v30 = v41;
    swift_bridgeObjectRetain();
    signed __int16 v27 = (unsigned __int16)sub_1B51F3F70((uint64_t *)&v29, a2, BYTE2(a4) & 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    int v28 = v31;
    uint64_t v46 = v32;
    uint64_t v25 = v34;
    uint64_t v26 = v33;
    uint64_t v23 = v36;
    uint64_t v24 = v35;
    uint64_t v16 = v39;
    uint64_t v21 = v38;
    uint64_t v22 = v37;
    long long v42 = v29;
    uint64_t v43 = v30;
    sub_1B51F3F70((uint64_t *)&v42, a2, BYTE3(a4) & 1);
    uint64_t v20 = v16;
    uint64_t v17 = v46;
    swift_bridgeObjectRelease();
    long long v44 = v42;
    uint64_t v45 = v43;
    sub_1B51F3F70((uint64_t *)&v44, a2, BYTE4(a4) & 1);
    uint64_t result = swift_bridgeObjectRelease();
    uint64_t v19 = v45;
    *(_OWORD *)a1 = v44;
    a1[2] = v19;
    *(_DWORD *)a5 = v28;
    *(void *)(a5 + 8) = v17;
    *(void *)(a5 + 16) = v26;
    *(void *)(a5 + 24) = v25;
    *(void *)(a5 + 32) = v24;
    *(void *)(a5 + 40) = v23;
    *(void *)(a5 + 48) = v22;
    *(void *)(a5 + 56) = v21;
    *(void *)(a5 + 64) = v20;
    *(void *)(a5 + 72) = v15;
    *(void *)(a5 + 80) = v27;
  }
  return result;
}

uint64_t sub_1B52B6010(void *a1, uint64_t a2, unint64_t a3, char a4)
{
  uint64_t v9 = a1[1];
  uint64_t v10 = a1[2];
  uint64_t v11 = HIWORD(a3) & 1;
  *(void *)&long long v18 = *a1;
  *((void *)&v18 + 1) = v9;
  uint64_t v19 = v10;
  *(void *)&long long v14 = v18;
  *((void *)&v14 + 1) = v9;
  uint64_t v15 = v10;
  swift_bridgeObjectRetain_n();
  sub_1B51F3E0C((uint64_t *)&v14, a2, v11);
  swift_bridgeObjectRelease();
  if (v4)
  {
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else
  {
    long long v16 = v14;
    uint64_t v17 = v15;
    sub_1B51F3E0C((uint64_t *)&v16, a2, HIBYTE(a3) & 1);
    swift_bridgeObjectRelease();
    long long v18 = v16;
    uint64_t v19 = v17;
    sub_1B51F3E0C((uint64_t *)&v18, a2, a4 & 1);
    swift_bridgeObjectRelease();
    uint64_t v13 = v19;
    *(_OWORD *)a1 = v18;
    a1[2] = v13;
    return a3 & 0xFFFFFFFFFFFFLL;
  }
}

uint64_t sub_1B52B615C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(int *, int *), uint64_t a5, uint64_t a6)
{
  __int16 v7 = WORD2(a6);
  uint64_t v12 = *(void *)(a1 + 16);
  long long v18 = *(_OWORD *)a1;
  uint64_t v19 = v12;
  unint64_t v13 = a3 & 0xFFFFFFFF00000001;
  int v14 = a6 & 0x1010101;
  swift_bridgeObjectRetain_n();
  uint64_t v15 = sub_1B52B62B8(&v18, a2, v13, a4, a5, v14);
  if (v6)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    sub_1B51F3DDC((uint64_t *)&v18, a2, v7 & 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    sub_1B51F3E3C((uint64_t *)&v18, a2, HIBYTE(v7) & 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v17 = v19;
    *(_OWORD *)a1 = v18;
    *(void *)(a1 + 16) = v17;
  }
  return v15;
}

uint64_t sub_1B52B62B8(long long *a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(int *, int *), uint64_t a5, int a6)
{
  __int16 v7 = HIWORD(a6);
  uint64_t v12 = *((void *)a1 + 2);
  long long v20 = *a1;
  uint64_t v21 = v12;
  unint64_t v13 = a3 & 0xFFFFFFFF00000001;
  int v14 = (uint64_t *)(a6 & 0x101);
  swift_bridgeObjectRetain_n();
  uint64_t v15 = sub_1B52B6434(&v20, a2, v13, a4, a5, v14);
  if (v6)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    a5 = (uint64_t)v15;
    long long v18 = v20;
    uint64_t v19 = v21;
    swift_bridgeObjectRetain();
    sub_1B51F3E0C((uint64_t *)&v18, a2, v7 & 1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    long long v22 = v18;
    uint64_t v23 = v19;
    sub_1B51F3E0C((uint64_t *)&v22, a2, HIBYTE(v7) & 1);
    swift_bridgeObjectRelease();
    uint64_t v17 = v23;
    *a1 = v22;
    *((void *)a1 + 2) = v17;
  }
  return a5;
}

uint64_t *sub_1B52B6434(void *a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(int *, int *), uint64_t a5, uint64_t *a6)
{
  uint64_t v12 = a1[1];
  uint64_t v13 = a1[2];
  *(void *)&long long v22 = *a1;
  *((void *)&v22 + 1) = v12;
  uint64_t v23 = v13;
  *(void *)&long long v18 = v22;
  *((void *)&v18 + 1) = v12;
  uint64_t v19 = v13;
  unint64_t v14 = a3 & 0xFFFFFFFF00000001;
  swift_bridgeObjectRetain_n();
  sub_1B52A6C10((uint64_t *)&v18, v14, a4, a5, a2);
  if (v6)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    char v15 = BYTE1(a6);
    swift_bridgeObjectRelease();
    long long v20 = v18;
    uint64_t v21 = v19;
    a6 = sub_1B51F3DDC((uint64_t *)&v20, a2, a6 & 1);
    swift_bridgeObjectRelease();
    long long v22 = v20;
    uint64_t v23 = v21;
    sub_1B51F3DDC((uint64_t *)&v22, a2, v15 & 1);
    swift_bridgeObjectRelease();
    uint64_t v17 = v23;
    *(_OWORD *)a1 = v22;
    a1[2] = v17;
  }
  return a6;
}

uint64_t sub_1B52B6598(void *a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(int *, int *), uint64_t a5, uint64_t a6)
{
  uint64_t v12 = a1[1];
  uint64_t v13 = a1[2];
  *(void *)&long long v25 = *a1;
  *((void *)&v25 + 1) = v12;
  uint64_t v26 = v13;
  *(void *)&long long v21 = v25;
  *((void *)&v21 + 1) = v12;
  uint64_t v22 = v13;
  unint64_t v14 = a3 & 0xFFFFFFFF00000001;
  char v15 = (uint64_t *)(a6 & 0x101);
  swift_bridgeObjectRetain_n();
  unsigned int v16 = sub_1B51F7E38(&v27, &v21, a2, v14, a4, a5, v15);
  if (v6)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else
  {
    unsigned int v17 = v16;
    uint64_t v18 = v27;
    sub_1B51F3E0C((uint64_t *)&v21, a2, BYTE2(a6) & 1);
    swift_bridgeObjectRelease();
    long long v23 = v21;
    uint64_t v24 = v22;
    sub_1B51F3E0C((uint64_t *)&v23, a2, BYTE3(a6) & 1);
    swift_bridgeObjectRelease();
    long long v25 = v23;
    uint64_t v26 = v24;
    sub_1B51F3DDC((uint64_t *)&v25, a2, BYTE4(a6) & 1);
    swift_bridgeObjectRelease();
    uint64_t v19 = v26;
    *(_OWORD *)a1 = v25;
    a1[2] = v19;
    return v17 | (unint64_t)(v18 << 32);
  }
}

uint64_t sub_1B52B673C(void *a1, uint64_t a2, char a3, uint64_t (*a4)(uint64_t *), uint64_t a5, int a6)
{
  uint64_t v13 = a1[1];
  uint64_t v14 = a1[2];
  char v15 = a6 & 1;
  *(void *)&long long v23 = *a1;
  *((void *)&v23 + 1) = v13;
  uint64_t v24 = v14;
  *(void *)&long long v19 = v23;
  *((void *)&v19 + 1) = v13;
  uint64_t v20 = v14;
  swift_bridgeObjectRetain_n();
  uint64_t v16 = sub_1B51F7FD8(&v25, (uint64_t)&v19, a2, a3, a4, a5, v15);
  if (v6)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    a5 = v16;
    sub_1B51F3E0C((uint64_t *)&v19, a2, BYTE1(a6) & 1);
    swift_bridgeObjectRelease();
    long long v21 = v19;
    uint64_t v22 = v20;
    sub_1B51F3E0C((uint64_t *)&v21, a2, BYTE2(a6) & 1);
    swift_bridgeObjectRelease();
    long long v23 = v21;
    uint64_t v24 = v22;
    sub_1B51F3E0C((uint64_t *)&v23, a2, HIBYTE(a6) & 1);
    swift_bridgeObjectRelease();
    uint64_t v18 = v24;
    *(_OWORD *)a1 = v23;
    a1[2] = v18;
  }
  return a5;
}

void *sub_1B52B68D4(void *result, uint64_t a2, int a3)
{
  uint64_t v4 = *result;
  uint64_t v5 = result[1];
  uint64_t v6 = result[2];
  *(void *)&long long v16 = v4;
  *((void *)&v16 + 1) = v5;
  uint64_t v17 = v6;
  *(void *)&long long v12 = v4;
  *((void *)&v12 + 1) = v5;
  uint64_t v13 = v6;
  if (v5 < v4)
  {
    __break(1u);
  }
  else
  {
    uint64_t v9 = result;
    char v10 = a3 & 1;
    swift_bridgeObjectRetain_n();
    sub_1B51F3DDC((uint64_t *)&v12, a2, v10);
    swift_bridgeObjectRelease();
    if (v3)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    else
    {
      long long v14 = v12;
      uint64_t v15 = v13;
      sub_1B51F3DDC((uint64_t *)&v14, a2, BYTE1(a3) & 1);
      swift_bridgeObjectRelease();
      long long v16 = v14;
      uint64_t v17 = v15;
      sub_1B51F3DDC((uint64_t *)&v16, a2, BYTE2(a3) & 1);
      swift_bridgeObjectRelease();
      uint64_t v11 = v17;
      *(_OWORD *)uint64_t v9 = v16;
      _OWORD v9[2] = v11;
    }
    return (void *)v4;
  }
  return result;
}

uint64_t *sub_1B52B6A4C@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  int v7 = HIDWORD(a3);
  uint64_t v10 = a1[2];
  long long v37 = *(_OWORD *)a1;
  uint64_t v38 = v10;
  uint64_t v11 = a2 & 0x101010101010101;
  uint64_t v12 = a3 & 0x101010101;
  swift_bridgeObjectRetain_n();
  sub_1B52B5DD4(&v37, a4, v11, v12, (uint64_t)&v26);
  if (v5)
  {
    swift_bridgeObjectRelease();
    return (uint64_t *)swift_bridgeObjectRelease();
  }
  else
  {
    sub_1B51F3F70((uint64_t *)&v37, a4, BYTE1(v7) & 1);
    swift_bridgeObjectRelease();
    int v41 = v26;
    uint64_t v24 = v27;
    uint64_t v25 = v28;
    uint64_t v22 = v30;
    uint64_t v23 = v29;
    uint64_t v20 = v32;
    uint64_t v21 = v31;
    uint64_t v13 = v35;
    uint64_t v18 = v34;
    uint64_t v19 = v33;
    uint64_t v14 = v36;
    long long v39 = v37;
    uint64_t v40 = v38;
    sub_1B51F3F70((uint64_t *)&v39, a4, BYTE2(v7) & 1);
    uint64_t v17 = v14;
    LODWORD(v14) = v41;
    swift_bridgeObjectRelease();
    uint64_t v15 = v40;
    *(_OWORD *)a1 = v39;
    a1[2] = v15;
    uint64_t result = sub_1B51F3F70(a1, a4, HIBYTE(v7) & 1);
    *(_DWORD *)a5 = v14;
    *(void *)(a5 + 8) = v24;
    *(void *)(a5 + 16) = v25;
    *(void *)(a5 + 24) = v23;
    *(void *)(a5 + 32) = v22;
    *(void *)(a5 + 40) = v21;
    *(void *)(a5 + 48) = v20;
    *(void *)(a5 + 56) = v19;
    *(void *)(a5 + 64) = v18;
    *(void *)(a5 + 72) = v13;
    *(void *)(a5 + 80) = v17;
  }
  return result;
}

unint64_t sub_1B52B6C20@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  uint64_t v75 = a1[2];
  uint64_t v74 = a1[3];
  uint64_t v69 = a1[8];
  uint64_t v66 = a1[9];
  uint64_t v62 = a1[10];
  uint64_t v64 = a1[11];
  uint64_t v61 = a1[12];
  uint64_t v73 = a1[13];
  uint64_t v6 = a1[14];
  uint64_t v71 = a1[15];
  uint64_t v70 = *((unsigned __int8 *)a1 + 32);
  uint64_t v68 = *((unsigned __int8 *)a1 + 33);
  uint64_t v67 = *((unsigned __int8 *)a1 + 34);
  uint64_t v65 = *((unsigned __int8 *)a1 + 35);
  uint64_t v63 = *((unsigned __int8 *)a1 + 36);
  uint64_t v80 = *((unsigned __int8 *)a1 + 37);
  uint64_t v79 = *((unsigned __int8 *)a1 + 38);
  uint64_t v78 = *((unsigned __int8 *)a1 + 39);
  uint64_t v81 = *((unsigned __int8 *)a1 + 40);
  uint64_t v77 = *((unsigned __int8 *)a1 + 41);
  uint64_t v76 = *((unsigned int *)a1 + 11);
  uint64_t v82 = *((unsigned int *)a1 + 13);
  uint64_t v72 = *((unsigned int *)a1 + 15);
  uint64_t v7 = a1[32];
  uint64_t v8 = a1[33];
  uint64_t v9 = a1[34];
  uint64_t v10 = a1[35];
  uint64_t v11 = a1[36];
  uint64_t v12 = a1[37];
  uint64_t v13 = a1[38];
  uint64_t v14 = a1[39];
  uint64_t v15 = *((void *)a1 + 10);
  uint64_t v16 = *((unsigned __int8 *)a1 + 88);
  uint64_t v17 = *(void *)(a1 + 45);
  uint64_t v18 = a1[49];
  int v19 = *((unsigned __int8 *)a1 + 100);
  uint64_t v20 = *(unsigned int *)(a1 + 51);
  int v21 = *((unsigned __int8 *)a1 + 106);
  if (v4 > 4)
  {
    char v84 = *((unsigned char *)a1 + 88);
    char v83 = *((unsigned char *)a1 + 100);
    char v85 = *((unsigned char *)a1 + 106);
    unsigned __int16 v56 = a1[37];
    unsigned __int16 v57 = a1[39];
    unsigned __int16 v52 = a1[36];
    unsigned __int16 v53 = a1[38];
    unsigned __int16 v51 = a1[34];
    int v40 = *a1;
    uint64_t v54 = *((void *)a1 + 10);
    uint64_t v55 = *(void *)(a1 + 45);
    unsigned __int16 v58 = a1[49];
    int v59 = *(_DWORD *)(a1 + 51);
    int v49 = *((_DWORD *)a1 + 14);
    unsigned __int16 v50 = a1[33];
    unsigned __int16 v48 = a1[32];
    int v41 = *((_DWORD *)a1 + 12);
    unsigned __int16 v42 = a1[4];
    unsigned __int16 v43 = a1[5];
    unsigned __int16 v44 = a1[6];
    unsigned __int16 v45 = a1[7];
    uint64_t v46 = swift_allocObject();
    __int16 v47 = v5;
    uint64_t v26 = v46;
    *(_WORD *)(v46 + 18) = v47;
    *(_WORD *)(v46 + 20) = v75;
    *(_WORD *)(v46 + 22) = v74;
    *(_WORD *)(v46 + 24) = v42;
    *(_WORD *)(v46 + 26) = v43;
    *(_WORD *)(v46 + 28) = v44;
    *(_WORD *)(v46 + 30) = v45;
    *(_WORD *)(v46 + 32) = v69;
    *(_WORD *)(v46 + 34) = v66;
    *(_WORD *)(v46 + 36) = v62;
    *(_WORD *)(v46 + 38) = v64;
    *(_WORD *)(v46 + 40) = v61;
    *(_WORD *)(v46 + 16) = v40;
    *(_WORD *)(v46 + 42) = v73;
    *(_WORD *)(v46 + 44) = v6;
    *(_WORD *)(v46 + 46) = v71;
    *(unsigned char *)(v46 + 48) = v70;
    *(unsigned char *)(v46 + 49) = v68;
    *(unsigned char *)(v46 + 50) = v67;
    *(unsigned char *)(v46 + 51) = v65;
    *(unsigned char *)(v46 + 52) = v63;
    *(unsigned char *)(v46 + 53) = v80;
    *(unsigned char *)(v46 + 54) = v79;
    *(unsigned char *)(v46 + 55) = v78;
    *(unsigned char *)(v46 + 56) = v81;
    *(unsigned char *)(v46 + 57) = v77;
    *(_DWORD *)(v46 + 60) = v76;
    *(_DWORD *)(v46 + 64) = v41;
    *(_DWORD *)(v46 + 68) = v82;
    *(_DWORD *)(v46 + 72) = v49;
    *(_DWORD *)(v46 + 76) = v72;
    *(_WORD *)(v46 + 80) = v48;
    *(_WORD *)(v46 + 82) = v50;
    *(_WORD *)(v46 + 84) = v51;
    *(_WORD *)(v46 + 86) = v10;
    *(_WORD *)(v46 + 88) = v52;
    *(_WORD *)(v46 + 90) = v56;
    *(_WORD *)(v46 + 92) = v53;
    *(_WORD *)(v46 + 94) = v57;
    *(void *)(v46 + 96) = v54;
    *(unsigned char *)(v46 + 104) = v84;
    *(void *)(v46 + 106) = v55;
    *(_WORD *)(v46 + 114) = v58;
    *(unsigned char *)(v46 + 116) = v83;
    *(_DWORD *)(v46 + 118) = v59;
    *(unsigned char *)(v46 + 122) = v85;
    *(void *)(v46 + 128) = a2;
    swift_retain();
    LODWORD(v4) = v40;
    uint64_t v23 = 0;
    uint64_t v27 = 0;
    unint64_t v28 = 0;
    unint64_t result = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v15 = 0;
    uint64_t v33 = 0;
    uint64_t v39 = 0;
    unsigned int v38 = 0;
    uint64_t v24 = sub_1B52BA770;
    unint64_t v22 = (unint64_t)sub_1B52AFAE8;
    uint64_t v25 = 257;
  }
  else
  {
    unint64_t v22 = a1[4] | ((unint64_t)a1[5] << 16) | ((unint64_t)a1[6] << 32) | ((unint64_t)a1[7] << 48);
    uint64_t v23 = v69 | (v66 << 16) | (v62 << 32) | (v64 << 48);
    uint64_t v24 = (double (*)@<D0>(uint64_t@<X8>))(v61 | (v73 << 16) | (v6 << 32) | (v71 << 48));
    uint64_t v25 = v4 | (v5 << 16) | (v75 << 32) | (v74 << 48);
    uint64_t v26 = v70 | (v68 << 8) | (v67 << 16) | (v65 << 24) | (v63 << 32) | (v80 << 40) | (v79 << 48) | (v78 << 56);
    uint64_t v27 = v81 | (v77 << 8) | (v76 << 32);
    unint64_t v28 = *((unsigned int *)a1 + 12) | (unint64_t)(v82 << 32);
    unint64_t result = *((unsigned int *)a1 + 14) | (unint64_t)(v72 << 32);
    uint64_t v30 = v7 | (v8 << 16) | (v9 << 32) | (v10 << 48);
    uint64_t v31 = v11 | (v12 << 16) | (v13 << 32) | (v14 << 48);
    BOOL v32 = v19 == 0;
    uint64_t v33 = v16 | (v17 << 16);
    uint64_t v34 = 0x100000000;
    if (v32) {
      uint64_t v34 = 0;
    }
    *((void *)&v35 + 1) = v18;
    *(void *)&long long v35 = v17;
    uint64_t v36 = v34 | (v35 >> 48);
    if (v21) {
      int v37 = 0x10000;
    }
    else {
      int v37 = 0;
    }
    unsigned int v38 = v37 & 0xFFFF0000 | WORD1(v20);
    uint64_t v39 = v36 | (v20 << 48);
  }
  *(void *)a3 = v25;
  *(void *)(a3 + 8) = v22;
  *(void *)(a3 + 16) = v23;
  *(void *)(a3 + 24) = v24;
  *(void *)(a3 + 32) = v26;
  *(void *)(a3 + 40) = v27;
  *(void *)(a3 + 48) = v28;
  *(void *)(a3 + 56) = result;
  *(void *)(a3 + 64) = v30;
  *(void *)(a3 + 72) = v31;
  *(void *)(a3 + 80) = v15;
  *(void *)(a3 + 88) = v33;
  *(void *)(a3 + 96) = v39;
  *(_WORD *)(a3 + 104) = v38;
  *(unsigned char *)(a3 + 106) = BYTE2(v38);
  *(unsigned char *)(a3 + 107) = v4 < 5;
  return result;
}

__n128 sub_1B52B70AC@<Q0>(long long *a1@<X1>, uint64_t a2@<X8>)
{
  long long v4 = *a1;
  long long v5 = a1[1];
  uint64_t v6 = *((void *)a1 + 4);
  __int16 v7 = *((_WORD *)a1 + 20);
  __n128 v8 = *(__n128 *)((char *)a1 + 44);
  int v9 = *((_DWORD *)a1 + 15);
  long long v10 = a1[4];
  uint64_t v11 = *((void *)a1 + 10);
  char v12 = *((unsigned char *)a1 + 88);
  uint64_t v13 = *(void *)((char *)a1 + 90);
  __int16 v14 = *((_WORD *)a1 + 49);
  char v15 = *((unsigned char *)a1 + 100);
  int v16 = *(_DWORD *)((char *)a1 + 102);
  char v17 = *((unsigned char *)a1 + 106);
  swift_setAtWritableKeyPath();
  __n128 result = v8;
  *(_OWORD *)a2 = v4;
  *(_OWORD *)(a2 + 16) = v5;
  *(void *)(a2 + 32) = v6;
  *(_WORD *)(a2 + 40) = v7;
  *(__n128 *)(a2 + 44) = v8;
  *(_DWORD *)(a2 + 60) = v9;
  *(_OWORD *)(a2 + 64) = v10;
  *(void *)(a2 + 80) = v11;
  *(unsigned char *)(a2 + 88) = v12;
  *(void *)(a2 + 90) = v13;
  *(_WORD *)(a2 + 98) = v14;
  *(unsigned char *)(a2 + 100) = v15;
  *(_DWORD *)(a2 + 102) = v16;
  *(unsigned char *)(a2 + 106) = v17;
  return result;
}

unint64_t sub_1B52B71CC@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  uint64_t v75 = a1[2];
  uint64_t v74 = a1[3];
  uint64_t v69 = a1[8];
  uint64_t v66 = a1[9];
  uint64_t v62 = a1[10];
  uint64_t v64 = a1[11];
  uint64_t v61 = a1[12];
  uint64_t v73 = a1[13];
  uint64_t v6 = a1[14];
  uint64_t v71 = a1[15];
  uint64_t v70 = *((unsigned __int8 *)a1 + 32);
  uint64_t v68 = *((unsigned __int8 *)a1 + 33);
  uint64_t v67 = *((unsigned __int8 *)a1 + 34);
  uint64_t v65 = *((unsigned __int8 *)a1 + 35);
  uint64_t v63 = *((unsigned __int8 *)a1 + 36);
  uint64_t v80 = *((unsigned __int8 *)a1 + 37);
  uint64_t v79 = *((unsigned __int8 *)a1 + 38);
  uint64_t v78 = *((unsigned __int8 *)a1 + 39);
  uint64_t v81 = *((unsigned __int8 *)a1 + 40);
  uint64_t v77 = *((unsigned __int8 *)a1 + 41);
  uint64_t v76 = *((unsigned int *)a1 + 11);
  uint64_t v82 = *((unsigned int *)a1 + 13);
  uint64_t v72 = *((unsigned int *)a1 + 15);
  uint64_t v7 = a1[32];
  uint64_t v8 = a1[33];
  uint64_t v9 = a1[34];
  uint64_t v10 = a1[35];
  uint64_t v11 = a1[36];
  uint64_t v12 = a1[37];
  uint64_t v13 = a1[38];
  uint64_t v14 = a1[39];
  uint64_t v15 = *((void *)a1 + 10);
  uint64_t v16 = *((unsigned __int8 *)a1 + 88);
  uint64_t v17 = *(void *)(a1 + 45);
  uint64_t v18 = a1[49];
  int v19 = *((unsigned __int8 *)a1 + 100);
  uint64_t v20 = *(unsigned int *)(a1 + 51);
  int v21 = *((unsigned __int8 *)a1 + 106);
  if (v4 > 1)
  {
    char v84 = *((unsigned char *)a1 + 88);
    char v83 = *((unsigned char *)a1 + 100);
    char v85 = *((unsigned char *)a1 + 106);
    unsigned __int16 v56 = a1[37];
    unsigned __int16 v57 = a1[39];
    unsigned __int16 v52 = a1[36];
    unsigned __int16 v53 = a1[38];
    unsigned __int16 v51 = a1[34];
    int v40 = *a1;
    uint64_t v54 = *((void *)a1 + 10);
    uint64_t v55 = *(void *)(a1 + 45);
    unsigned __int16 v58 = a1[49];
    int v59 = *(_DWORD *)(a1 + 51);
    int v49 = *((_DWORD *)a1 + 14);
    unsigned __int16 v50 = a1[33];
    unsigned __int16 v48 = a1[32];
    int v41 = *((_DWORD *)a1 + 12);
    unsigned __int16 v42 = a1[4];
    unsigned __int16 v43 = a1[5];
    unsigned __int16 v44 = a1[6];
    unsigned __int16 v45 = a1[7];
    uint64_t v46 = swift_allocObject();
    __int16 v47 = v5;
    uint64_t v26 = v46;
    *(_WORD *)(v46 + 18) = v47;
    *(_WORD *)(v46 + 20) = v75;
    *(_WORD *)(v46 + 22) = v74;
    *(_WORD *)(v46 + 24) = v42;
    *(_WORD *)(v46 + 26) = v43;
    *(_WORD *)(v46 + 28) = v44;
    *(_WORD *)(v46 + 30) = v45;
    *(_WORD *)(v46 + 32) = v69;
    *(_WORD *)(v46 + 34) = v66;
    *(_WORD *)(v46 + 36) = v62;
    *(_WORD *)(v46 + 38) = v64;
    *(_WORD *)(v46 + 40) = v61;
    *(_WORD *)(v46 + 16) = v40;
    *(_WORD *)(v46 + 42) = v73;
    *(_WORD *)(v46 + 44) = v6;
    *(_WORD *)(v46 + 46) = v71;
    *(unsigned char *)(v46 + 48) = v70;
    *(unsigned char *)(v46 + 49) = v68;
    *(unsigned char *)(v46 + 50) = v67;
    *(unsigned char *)(v46 + 51) = v65;
    *(unsigned char *)(v46 + 52) = v63;
    *(unsigned char *)(v46 + 53) = v80;
    *(unsigned char *)(v46 + 54) = v79;
    *(unsigned char *)(v46 + 55) = v78;
    *(unsigned char *)(v46 + 56) = v81;
    *(unsigned char *)(v46 + 57) = v77;
    *(_DWORD *)(v46 + 60) = v76;
    *(_DWORD *)(v46 + 64) = v41;
    *(_DWORD *)(v46 + 68) = v82;
    *(_DWORD *)(v46 + 72) = v49;
    *(_DWORD *)(v46 + 76) = v72;
    *(_WORD *)(v46 + 80) = v48;
    *(_WORD *)(v46 + 82) = v50;
    *(_WORD *)(v46 + 84) = v51;
    *(_WORD *)(v46 + 86) = v10;
    *(_WORD *)(v46 + 88) = v52;
    *(_WORD *)(v46 + 90) = v56;
    *(_WORD *)(v46 + 92) = v53;
    *(_WORD *)(v46 + 94) = v57;
    *(void *)(v46 + 96) = v54;
    *(unsigned char *)(v46 + 104) = v84;
    *(void *)(v46 + 106) = v55;
    *(_WORD *)(v46 + 114) = v58;
    *(unsigned char *)(v46 + 116) = v83;
    *(_DWORD *)(v46 + 118) = v59;
    *(unsigned char *)(v46 + 122) = v85;
    *(void *)(v46 + 128) = a2;
    swift_retain();
    LODWORD(v4) = v40;
    uint64_t v23 = 0;
    uint64_t v27 = 0;
    unint64_t v28 = 0;
    unint64_t result = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v15 = 0;
    uint64_t v33 = 0;
    uint64_t v39 = 0;
    unsigned int v38 = 0;
    uint64_t v24 = sub_1B52BA790;
    unint64_t v22 = (unint64_t)sub_1B52AFA94;
    uint64_t v25 = 0x101010101;
  }
  else
  {
    unint64_t v22 = a1[4] | ((unint64_t)a1[5] << 16) | ((unint64_t)a1[6] << 32) | ((unint64_t)a1[7] << 48);
    uint64_t v23 = v69 | (v66 << 16) | (v62 << 32) | (v64 << 48);
    uint64_t v24 = (double (*)@<D0>(uint64_t@<X8>))(v61 | (v73 << 16) | (v6 << 32) | (v71 << 48));
    uint64_t v25 = v4 | (v5 << 16) | (v75 << 32) | (v74 << 48);
    uint64_t v26 = v70 | (v68 << 8) | (v67 << 16) | (v65 << 24) | (v63 << 32) | (v80 << 40) | (v79 << 48) | (v78 << 56);
    uint64_t v27 = v81 | (v77 << 8) | (v76 << 32);
    unint64_t v28 = *((unsigned int *)a1 + 12) | (unint64_t)(v82 << 32);
    unint64_t result = *((unsigned int *)a1 + 14) | (unint64_t)(v72 << 32);
    uint64_t v30 = v7 | (v8 << 16) | (v9 << 32) | (v10 << 48);
    uint64_t v31 = v11 | (v12 << 16) | (v13 << 32) | (v14 << 48);
    BOOL v32 = v19 == 0;
    uint64_t v33 = v16 | (v17 << 16);
    uint64_t v34 = 0x100000000;
    if (v32) {
      uint64_t v34 = 0;
    }
    *((void *)&v35 + 1) = v18;
    *(void *)&long long v35 = v17;
    uint64_t v36 = v34 | (v35 >> 48);
    if (v21) {
      int v37 = 0x10000;
    }
    else {
      int v37 = 0;
    }
    unsigned int v38 = v37 & 0xFFFF0000 | WORD1(v20);
    uint64_t v39 = v36 | (v20 << 48);
  }
  *(void *)a3 = v25;
  *(void *)(a3 + 8) = v22;
  *(void *)(a3 + 16) = v23;
  *(void *)(a3 + 24) = v24;
  *(void *)(a3 + 32) = v26;
  *(void *)(a3 + 40) = v27;
  *(void *)(a3 + 48) = v28;
  *(void *)(a3 + 56) = result;
  *(void *)(a3 + 64) = v30;
  *(void *)(a3 + 72) = v31;
  *(void *)(a3 + 80) = v15;
  *(void *)(a3 + 88) = v33;
  *(void *)(a3 + 96) = v39;
  *(_WORD *)(a3 + 104) = v38;
  *(unsigned char *)(a3 + 106) = BYTE2(v38);
  *(unsigned char *)(a3 + 107) = v4 < 2;
  return result;
}

__n128 sub_1B52B765C@<Q0>(long long *a1@<X1>, uint64_t a2@<X8>)
{
  long long v4 = *a1;
  long long v5 = a1[1];
  uint64_t v6 = *((void *)a1 + 4);
  __int16 v7 = *((_WORD *)a1 + 20);
  __n128 v8 = *(__n128 *)((char *)a1 + 44);
  int v9 = *((_DWORD *)a1 + 15);
  long long v10 = a1[4];
  uint64_t v11 = *((void *)a1 + 10);
  char v12 = *((unsigned char *)a1 + 88);
  uint64_t v13 = *(void *)((char *)a1 + 90);
  __int16 v14 = *((_WORD *)a1 + 49);
  char v15 = *((unsigned char *)a1 + 100);
  int v16 = *(_DWORD *)((char *)a1 + 102);
  char v17 = *((unsigned char *)a1 + 106);
  swift_setAtWritableKeyPath();
  __n128 result = v8;
  *(_OWORD *)a2 = v4;
  *(_OWORD *)(a2 + 16) = v5;
  *(void *)(a2 + 32) = v6;
  *(_WORD *)(a2 + 40) = v7;
  *(__n128 *)(a2 + 44) = v8;
  *(_DWORD *)(a2 + 60) = v9;
  *(_OWORD *)(a2 + 64) = v10;
  *(void *)(a2 + 80) = v11;
  *(unsigned char *)(a2 + 88) = v12;
  *(void *)(a2 + 90) = v13;
  *(_WORD *)(a2 + 98) = v14;
  *(unsigned char *)(a2 + 100) = v15;
  *(_DWORD *)(a2 + 102) = v16;
  *(unsigned char *)(a2 + 106) = v17;
  return result;
}

unint64_t sub_1B52B7784@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *a1;
  uint64_t v5 = a1[1];
  uint64_t v74 = a1[2];
  uint64_t v73 = a1[3];
  uint64_t v68 = a1[8];
  uint64_t v65 = a1[9];
  uint64_t v61 = a1[10];
  uint64_t v63 = a1[11];
  uint64_t v60 = a1[12];
  uint64_t v72 = a1[13];
  uint64_t v71 = a1[14];
  uint64_t v70 = a1[15];
  uint64_t v69 = *((unsigned __int8 *)a1 + 32);
  uint64_t v67 = *((unsigned __int8 *)a1 + 33);
  uint64_t v66 = *((unsigned __int8 *)a1 + 34);
  uint64_t v64 = *((unsigned __int8 *)a1 + 35);
  uint64_t v62 = *((unsigned __int8 *)a1 + 36);
  uint64_t v79 = *((unsigned __int8 *)a1 + 37);
  uint64_t v78 = *((unsigned __int8 *)a1 + 38);
  uint64_t v77 = *((unsigned __int8 *)a1 + 39);
  uint64_t v80 = *((unsigned __int8 *)a1 + 40);
  uint64_t v76 = *((unsigned __int8 *)a1 + 41);
  uint64_t v75 = *((unsigned int *)a1 + 11);
  uint64_t v81 = *((unsigned int *)a1 + 13);
  uint64_t v6 = *((unsigned int *)a1 + 15);
  uint64_t v7 = a1[32];
  uint64_t v8 = a1[33];
  uint64_t v9 = a1[34];
  uint64_t v10 = a1[35];
  uint64_t v11 = a1[36];
  uint64_t v12 = a1[37];
  uint64_t v13 = a1[38];
  uint64_t v14 = a1[39];
  uint64_t v15 = *((void *)a1 + 10);
  uint64_t v16 = *((unsigned __int8 *)a1 + 88);
  uint64_t v17 = *(void *)(a1 + 45);
  uint64_t v18 = a1[49];
  int v19 = *((unsigned __int8 *)a1 + 100);
  uint64_t v20 = *(unsigned int *)(a1 + 51);
  int v21 = *((unsigned __int8 *)a1 + 106);
  if (*a1)
  {
    char v83 = *((unsigned char *)a1 + 88);
    char v82 = *((unsigned char *)a1 + 100);
    char v84 = *((unsigned char *)a1 + 106);
    unsigned __int16 v54 = a1[37];
    int v49 = *((_DWORD *)a1 + 14);
    unsigned __int16 v50 = a1[34];
    unsigned __int16 v52 = a1[39];
    unsigned __int16 v53 = a1[36];
    uint64_t v55 = *((void *)a1 + 10);
    uint64_t v56 = *(void *)(a1 + 45);
    unsigned __int16 v57 = a1[49];
    int v58 = *(_DWORD *)(a1 + 51);
    unsigned __int16 v51 = a1[35];
    unsigned __int16 v47 = a1[33];
    unsigned __int16 v48 = a1[32];
    int v22 = *((_DWORD *)a1 + 12);
    unsigned __int16 v23 = a1[4];
    unsigned __int16 v24 = a1[5];
    unsigned __int16 v25 = a1[6];
    unsigned __int16 v26 = a1[7];
    uint64_t v27 = swift_allocObject();
    __int16 v28 = v5;
    uint64_t v29 = v27;
    *(_WORD *)(v27 + 18) = v28;
    *(_WORD *)(v27 + 20) = v74;
    *(_WORD *)(v27 + 22) = v73;
    *(_WORD *)(v27 + 24) = v23;
    *(_WORD *)(v27 + 26) = v24;
    *(_WORD *)(v27 + 28) = v25;
    *(_WORD *)(v27 + 30) = v26;
    *(_WORD *)(v27 + 32) = v68;
    *(_WORD *)(v27 + 34) = v65;
    *(_WORD *)(v27 + 36) = v61;
    *(_WORD *)(v27 + 38) = v63;
    *(_WORD *)(v27 + 40) = v60;
    *(_WORD *)(v27 + 16) = v4;
    *(_WORD *)(v27 + 42) = v72;
    *(_WORD *)(v27 + 44) = v71;
    *(_WORD *)(v27 + 46) = v70;
    *(unsigned char *)(v27 + 48) = v69;
    *(unsigned char *)(v27 + 49) = v67;
    *(unsigned char *)(v27 + 50) = v66;
    *(unsigned char *)(v27 + 51) = v64;
    *(unsigned char *)(v27 + 52) = v62;
    *(unsigned char *)(v27 + 53) = v79;
    *(unsigned char *)(v27 + 54) = v78;
    *(unsigned char *)(v27 + 55) = v77;
    *(unsigned char *)(v27 + 56) = v80;
    *(unsigned char *)(v27 + 57) = v76;
    *(_DWORD *)(v27 + 60) = v75;
    *(_DWORD *)(v27 + 64) = v22;
    *(_DWORD *)(v27 + 68) = v81;
    *(_DWORD *)(v27 + 72) = v49;
    *(_DWORD *)(v27 + 76) = v6;
    *(_WORD *)(v27 + 80) = v48;
    *(_WORD *)(v27 + 82) = v47;
    *(_WORD *)(v27 + 84) = v50;
    *(_WORD *)(v27 + 86) = v51;
    *(_WORD *)(v27 + 88) = v53;
    *(_WORD *)(v27 + 90) = v54;
    *(_WORD *)(v27 + 92) = v13;
    *(_WORD *)(v27 + 94) = v52;
    *(void *)(v27 + 96) = v55;
    *(unsigned char *)(v27 + 104) = v83;
    *(void *)(v27 + 106) = v56;
    *(_WORD *)(v27 + 114) = v57;
    *(unsigned char *)(v27 + 116) = v82;
    *(_DWORD *)(v27 + 118) = v58;
    *(unsigned char *)(v27 + 122) = v84;
    *(void *)(v27 + 128) = a2;
    swift_retain();
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t result = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v15 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    unsigned int v38 = 0;
    uint64_t v39 = sub_1B52BA7B0;
    unint64_t v40 = (unint64_t)sub_1B52AFADC;
    uint64_t v41 = 257;
  }
  else
  {
    unint64_t v40 = a1[4] | ((unint64_t)a1[5] << 16) | ((unint64_t)a1[6] << 32) | ((unint64_t)a1[7] << 48);
    uint64_t v30 = v68 | (v65 << 16) | (v61 << 32) | (v63 << 48);
    uint64_t v39 = (double (*)@<D0>(uint64_t@<X8>))(v60 | (v72 << 16) | (v71 << 32) | (v70 << 48));
    uint64_t v41 = (v5 << 16) | (v74 << 32) | (v73 << 48);
    uint64_t v29 = v69 | (v67 << 8) | (v66 << 16) | (v64 << 24) | (v62 << 32) | (v79 << 40) | (v78 << 48) | (v77 << 56);
    uint64_t v31 = v80 | (v76 << 8) | (v75 << 32);
    unint64_t v32 = *((unsigned int *)a1 + 12) | (unint64_t)(v81 << 32);
    unint64_t result = *((unsigned int *)a1 + 14) | (unint64_t)(v6 << 32);
    uint64_t v34 = v7 | (v8 << 16) | (v9 << 32) | (v10 << 48);
    uint64_t v35 = v11 | (v12 << 16) | (v13 << 32) | (v14 << 48);
    BOOL v42 = v19 == 0;
    uint64_t v36 = v16 | (v17 << 16);
    uint64_t v43 = 0x100000000;
    if (v42) {
      uint64_t v43 = 0;
    }
    *((void *)&v44 + 1) = v18;
    *(void *)&long long v44 = v17;
    uint64_t v45 = v43 | (v44 >> 48);
    if (v21) {
      int v46 = 0x10000;
    }
    else {
      int v46 = 0;
    }
    unsigned int v38 = v46 & 0xFFFF0000 | WORD1(v20);
    uint64_t v37 = v45 | (v20 << 48);
  }
  *(void *)a3 = v41;
  *(void *)(a3 + 8) = v40;
  *(void *)(a3 + 16) = v30;
  *(void *)(a3 + 24) = v39;
  *(void *)(a3 + 32) = v29;
  *(void *)(a3 + 40) = v31;
  *(void *)(a3 + 48) = v32;
  *(void *)(a3 + 56) = result;
  *(void *)(a3 + 64) = v34;
  *(void *)(a3 + 72) = v35;
  *(void *)(a3 + 80) = v15;
  *(void *)(a3 + 88) = v36;
  *(void *)(a3 + 96) = v37;
  *(_WORD *)(a3 + 104) = v38;
  *(unsigned char *)(a3 + 106) = BYTE2(v38);
  *(unsigned char *)(a3 + 107) = v4 == 0;
  return result;
}

__n128 sub_1B52B7C08@<Q0>(long long *a1@<X1>, uint64_t a2@<X8>)
{
  long long v4 = *a1;
  long long v5 = a1[1];
  uint64_t v6 = *((void *)a1 + 4);
  __int16 v7 = *((_WORD *)a1 + 20);
  __n128 v8 = *(__n128 *)((char *)a1 + 44);
  int v9 = *((_DWORD *)a1 + 15);
  long long v10 = a1[4];
  uint64_t v11 = *((void *)a1 + 10);
  char v12 = *((unsigned char *)a1 + 88);
  uint64_t v13 = *(void *)((char *)a1 + 90);
  __int16 v14 = *((_WORD *)a1 + 49);
  char v15 = *((unsigned char *)a1 + 100);
  int v16 = *(_DWORD *)((char *)a1 + 102);
  char v17 = *((unsigned char *)a1 + 106);
  swift_setAtWritableKeyPath();
  __n128 result = v8;
  *(_OWORD *)a2 = v4;
  *(_OWORD *)(a2 + 16) = v5;
  *(void *)(a2 + 32) = v6;
  *(_WORD *)(a2 + 40) = v7;
  *(__n128 *)(a2 + 44) = v8;
  *(_DWORD *)(a2 + 60) = v9;
  *(_OWORD *)(a2 + 64) = v10;
  *(void *)(a2 + 80) = v11;
  *(unsigned char *)(a2 + 88) = v12;
  *(void *)(a2 + 90) = v13;
  *(_WORD *)(a2 + 98) = v14;
  *(unsigned char *)(a2 + 100) = v15;
  *(_DWORD *)(a2 + 102) = v16;
  *(unsigned char *)(a2 + 106) = v17;
  return result;
}

unint64_t sub_1B52B7D28(_DWORD *a1, _WORD *a2, _WORD *a3, unsigned char *a4, uint64_t *a5, uint64_t *a6, uint64_t (**a7)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6), uint64_t a8, uint64_t a9)
{
  uint64_t v56 = a7;
  long long v11 = v9[5];
  long long v48 = v9[4];
  long long v49 = v11;
  v50[0] = v9[6];
  *(_OWORD *)((char *)v50 + 10) = *(_OWORD *)((char *)v9 + 106);
  long long v12 = v9[1];
  long long v44 = *v9;
  long long v45 = v12;
  long long v13 = v9[3];
  long long v15 = *v9;
  long long v14 = v9[1];
  long long v46 = v9[2];
  long long v47 = v13;
  uint64_t v16 = *(void *)(a8 + 16);
  uint64_t v55 = *((void *)v9 + 6);
  long long v53 = v14;
  long long v54 = v46;
  long long v52 = v15;
  char v17 = BYTE8(v13);
  char v18 = BYTE9(v13);
  long long v19 = v48;
  long long v40 = *(_OWORD *)a8;
  uint64_t v41 = v16;
  swift_bridgeObjectRetain_n();
  unint64_t v21 = sub_1B51F44DC(v39, &v40, a9);
  if (v10)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v22 = v20;
    uint64_t v24 = sub_1B51DAD28(&v40, a9, v17 & 1 | ((v18 & 1u) << 8), (void (*)(uint64_t *__return_ptr, void *))v19, *((uint64_t *)&v19 + 1));
    uint64_t v31 = v25;
    uint64_t v26 = v22;
    swift_bridgeObjectRelease();
    uint64_t v27 = v39[0];
    uint64_t v28 = v39[1];
    long long v42 = v40;
    uint64_t v43 = v41;
    sub_1B5201994((uint64_t)&v49, (uint64_t)v51, &qword_1E9D47BF0);
    uint64_t v29 = sub_1B51ECAF8(&v42, a9);
    swift_bridgeObjectRelease();
    uint64_t v30 = v43;
    *(_OWORD *)a8 = v42;
    *(void *)(a8 + 16) = v30;
    *a1 = HIDWORD(v21);
    *a2 = v26;
    *a3 = WORD1(v26);
    *a4 = BYTE4(v26) & 1;
    *a5 = v27;
    a5[1] = v28;
    *a6 = v24;
    a6[1] = v31;
    *uint64_t v56 = v29;
  }
  return v21;
}

uint64_t sub_1B52B7F44(_WORD *a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  long long v11 = v9;
  long long v47 = a2;
  uint64_t v18 = *(void *)(a8 + 16);
  long long v45 = *(_OWORD *)a8;
  uint64_t v46 = v18;
  swift_bridgeObjectRetain();
  sub_1B52B4A44(&v45, v11, a9, (uint64_t)v34);
  if (v10) {
    return swift_bridgeObjectRelease();
  }
  swift_bridgeObjectRelease();
  uint64_t v20 = v46;
  *(_OWORD *)a8 = v45;
  *(void *)(a8 + 16) = v20;
  unsigned int v32 = v34[0];
  __int16 v21 = v34[2];
  uint64_t v22 = v36;
  uint64_t v23 = v38;
  uint64_t v24 = v40;
  uint64_t v25 = v42;
  uint64_t v26 = v44;
  long long v27 = v35;
  long long v28 = v37;
  long long v29 = v39;
  long long v30 = v41;
  long long v31 = v43;
  *a1 = v34[1];
  *long long v47 = v21;
  *(_OWORD *)a3 = v27;
  *(void *)(a3 + 16) = v22;
  *(_OWORD *)a4 = v28;
  *(void *)(a4 + 16) = v23;
  *(_OWORD *)a5 = v29;
  *(void *)(a5 + 16) = v24;
  *(_OWORD *)a6 = v30;
  *(void *)(a6 + 16) = v25;
  *(_OWORD *)a7 = v31;
  *(void *)(a7 + 16) = v26;
  swift_bridgeObjectRetain_n();
  swift_bridgeObjectRetain_n();
  swift_bridgeObjectRetain_n();
  swift_bridgeObjectRetain_n();
  swift_bridgeObjectRetain_n();
  swift_bridgeObjectRelease_n();
  swift_bridgeObjectRelease_n();
  swift_bridgeObjectRelease_n();
  swift_bridgeObjectRelease_n();
  swift_bridgeObjectRelease_n();
  return v32;
}

uint64_t sub_1B52B80FC(uint64_t *a1, uint64_t a2, char a3)
{
  uint64_t v4 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v5 = a1[2];
  if (*a1 == v3)
  {
    uint64_t v6 = MEMORY[0x1E4FBC860];
LABEL_21:
    *a1 = v4;
    a1[1] = v3;
    a1[2] = v5;
    return v6;
  }
  else
  {
    char v17 = a1;
    uint64_t result = swift_bridgeObjectRetain();
    uint64_t v6 = MEMORY[0x1E4FBC860];
    uint64_t v9 = v4;
    while (!__OFSUB__(v3, v9))
    {
      if (v3 - v9 <= 1)
      {
        sub_1B5372F98();
        swift_bridgeObjectRelease();
        sub_1B51D4D34();
        swift_allocError();
        *uint64_t v16 = 0;
        v16[1] = v9;
        v16[2] = 0xD00000000000002BLL;
        v16[3] = 0x80000001B537BD30;
        uint64_t v16[4] = 0;
        swift_willThrow();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        return v6;
      }
      if (v9 > 0x7FFFFFFFFFFFFFFDLL) {
        goto LABEL_24;
      }
      unint64_t v10 = v9 + 2;
      if (v3 < v9 + 2) {
        goto LABEL_24;
      }
      if (v4 < 0) {
        goto LABEL_25;
      }
      unint64_t v11 = *(void *)(v5 + 16);
      if (v11 < v9 || v11 < v10) {
        goto LABEL_26;
      }
      unsigned int v12 = bswap32(*(unsigned __int16 *)(v5 + v9 + 32)) >> 16;
      if (a3) {
        __int16 v13 = v12;
      }
      else {
        __int16 v13 = *(_WORD *)(v5 + v9 + 32);
      }
      uint64_t result = swift_isUniquelyReferenced_nonNull_native();
      if ((result & 1) == 0)
      {
        uint64_t result = (uint64_t)sub_1B51E9CE4(0, *(void *)(v6 + 16) + 1, 1, (char *)v6);
        uint64_t v6 = result;
      }
      unint64_t v15 = *(void *)(v6 + 16);
      unint64_t v14 = *(void *)(v6 + 24);
      if (v15 >= v14 >> 1)
      {
        uint64_t result = (uint64_t)sub_1B51E9CE4((char *)(v14 > 1), v15 + 1, 1, (char *)v6);
        uint64_t v6 = result;
      }
      *(void *)(v6 + 16) = v15 + 1;
      *(_WORD *)(v6 + 2 * v15 + 32) = v13;
      v9 += 2;
      if (v3 == v10)
      {
        swift_bridgeObjectRelease();
        uint64_t v4 = v3;
        a1 = v17;
        goto LABEL_21;
      }
    }
    __break(1u);
LABEL_24:
    __break(1u);
LABEL_25:
    __break(1u);
LABEL_26:
    __break(1u);
  }
  return result;
}

uint64_t *sub_1B52B8304(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *result;
  if (a3 < 0)
  {
    sub_1B5372F98();
    swift_bridgeObjectRelease();
    sub_1B53731F8();
    sub_1B5372868();
    swift_bridgeObjectRelease();
    unint64_t v5 = 0xD000000000000023;
    unint64_t v6 = 0x80000001B537CC20;
    sub_1B51D4D34();
    swift_allocError();
    *__int16 v7 = 2;
    goto LABEL_6;
  }
  uint64_t v4 = result[1];
  if (__OFSUB__(v4, v3))
  {
    __break(1u);
  }
  else
  {
    if (v4 - v3 < a3)
    {
      sub_1B5372F98();
      swift_bridgeObjectRelease();
      sub_1B53731F8();
      sub_1B5372868();
      swift_bridgeObjectRelease();
      unint64_t v5 = 0xD000000000000024;
      unint64_t v6 = 0x80000001B537CBF0;
      sub_1B51D4D34();
      swift_allocError();
      *__int16 v7 = 0;
LABEL_6:
      v7[1] = v3;
      v7[2] = v5;
      uint64_t v7[3] = v6;
      v7[4] = 0;
      swift_willThrow();
      return (uint64_t *)v3;
    }
    uint64_t v8 = v3 + a3;
    if (v3 + a3 >= v3 && v4 >= v8)
    {
      *uint64_t result = v8;
      return (uint64_t *)v3;
    }
  }
  __break(1u);
  return result;
}

uint64_t *sub_1B52B84BC(long long *a1, void (*a2)(id *__return_ptr, uint64_t *), uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *((void *)a1 + 2);
  long long v17 = *a1;
  *(void *)&long long v18 = v8;
  swift_bridgeObjectRetain();
  unsigned __int8 v9 = sub_1B51FC9AC((unint64_t *)&v17, a4);
  if (v4)
  {
    swift_bridgeObjectRelease();
    return (uint64_t *)a4;
  }
  unsigned __int8 v10 = v9;
  swift_bridgeObjectRelease();
  long long v11 = v17;
  uint64_t v12 = v18;
  *a1 = v17;
  *((void *)a1 + 2) = v12;
  uint64_t v20 = v10;
  a2(&v19, &v20);
  id v13 = v19;
  long long v17 = v11;
  *(void *)&long long v18 = v12;
  swift_bridgeObjectRetain();
  uint64_t result = sub_1B5256BB4((uint64_t *)&v17, a4, (uint64_t)v13);
  uint64_t v16 = v18;
  if (__OFSUB__(v15, result))
  {
    __break(1u);
    goto LABEL_12;
  }
  if (v15 < (uint64_t)result)
  {
LABEL_12:
    __break(1u);
    goto LABEL_13;
  }
  if (__OFSUB__(v15, result))
  {
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }
  if (__OFADD__(result, v15 - (void)result))
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  if (v15 >= (uint64_t)result)
  {
    swift_bridgeObjectRetain();
    a4 = sub_1B5372808();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    *a1 = v17;
    *((void *)a1 + 2) = v16;
    return (uint64_t *)a4;
  }
LABEL_15:
  __break(1u);
  return result;
}

uint64_t *sub_1B52B874C(long long *a1, uint64_t *a2)
{
  void (*v9)(uint64_t *__return_ptr, __int16 *);
  __int16 v10;
  __int16 v11;
  uint64_t v12;
  long long v13;
  uint64_t v14;

  uint64_t v5 = *((void *)a1 + 2);
  id v13 = *a1;
  unint64_t v14 = v5;
  swift_bridgeObjectRetain();
  unsigned __int8 v6 = sub_1B52BD17C((unint64_t *)&v13);
  if (v2)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    if (v6 == 255)
    {
      unsigned __int8 v10 = 0;
      uint64_t v8 = 1;
      unsigned __int8 v9 = (void (*)(uint64_t *__return_ptr, __int16 *))sub_1B5284CAC;
      long long v11 = 1;
    }
    else if (v6 == 254)
    {
      long long v11 = 0;
      uint64_t v8 = 1;
      unsigned __int8 v9 = (void (*)(uint64_t *__return_ptr, __int16 *))sub_1B5284C7C;
      unsigned __int8 v10 = 1;
    }
    else
    {
      if (v6 == 253) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = v6;
      }
      unsigned __int8 v9 = 0;
      unsigned __int8 v10 = v6 != 253;
      long long v11 = v10;
    }
    a2 = sub_1B51EC684((uint64_t *)&v13, (uint64_t)a2, v8, v9, 0, v10 | (unsigned __int16)(v11 << 8));
    sub_1B52BA4D8(v8, (uint64_t)v9, 0, v10, v11);
    swift_bridgeObjectRelease();
    uint64_t v12 = v14;
    *a1 = v13;
    *((void *)a1 + 2) = v12;
  }
  return a2;
}

void sub_1B52B89A4(uint64_t *a1, void (*a2)(long long *__return_ptr, uint64_t *), uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a1[2];
  long long v12 = *(_OWORD *)a1;
  *(void *)&long long v13 = v8;
  swift_bridgeObjectRetain();
  unsigned __int8 v9 = sub_1B51FC9AC((unint64_t *)&v12, a4);
  if (v4)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int8 v10 = v9;
    swift_bridgeObjectRelease();
    uint64_t v11 = v13;
    *(_OWORD *)a1 = v12;
    a1[2] = v11;
    uint64_t v14 = v10;
    a2(&v12, &v14);
    sub_1B5256BB4(a1, a4, v12);
  }
}

void *sub_1B52B8B80@<X0>(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, void *a4@<X8>)
{
  char v50 = 1;
  char v49 = 1;
  char v48 = 1;
  char v47 = 1;
  char v46 = 1;
  char v45 = 1;
  __int16 v31 = 257;
  char v32 = 1;
  char v33 = 1;
  int v34 = 1594834165;
  long long v35 = sub_1B51D2364;
  uint64_t v36 = 0;
  v37[16] = 1;
  memset(v37, 1, 11);
  uint64_t v38 = sub_1B528724C;
  uint64_t v39 = 0;
  char v40 = 1;
  long long v41 = sub_1B528725C;
  uint64_t v42 = 0;
  long long v43 = sub_1B51E7B2C;
  uint64_t v44 = 0;
  sub_1B52AE210(1751474532, a1, (uint64_t)v20);
  if (v22)
  {
    swift_bridgeObjectRelease();
    sub_1B51DD5FC();
    swift_allocError();
    *unsigned __int8 v9 = 2;
    swift_willThrow();
    memset(v18, 0, 64);
    LOBYTE(v18[4]) = 1;
    *(_DWORD *)((char *)&v18[4] + 1) = *(_DWORD *)v29;
    DWORD1(v18[4]) = *(_DWORD *)&v29[3];
    *((void *)&v18[4] + 1) = 0;
    *(void *)&v18[5] = 0;
    BYTE8(v18[5]) = 1;
    *(_DWORD *)((char *)&v18[5] + 9) = *(_DWORD *)v28;
    HIDWORD(v18[5]) = *(_DWORD *)&v28[3];
    memset(&v18[6], 0, 32);
    LOBYTE(v18[8]) = 1;
    *(_DWORD *)((char *)&v18[8] + 1) = *(_DWORD *)v27;
    DWORD1(v18[8]) = *(_DWORD *)&v27[3];
    *(_OWORD *)((char *)&v18[8] + 8) = 0u;
    *(_OWORD *)((char *)&v18[9] + 8) = 0u;
    BYTE8(v18[10]) = 1;
    *(_DWORD *)((char *)&v18[10] + 9) = *(_DWORD *)v26;
    HIDWORD(v18[10]) = *(_DWORD *)&v26[3];
    v18[11] = 0uLL;
    LOBYTE(v18[12]) = 1;
    *(_DWORD *)((char *)&v18[18] + 1) = *(_DWORD *)v24;
    DWORD1(v18[12]) = *(_DWORD *)&v25[3];
    *(_DWORD *)((char *)&v18[12] + 1) = *(_DWORD *)v25;
    *(_OWORD *)((char *)&v18[17] + 1) = 0u;
    *(_OWORD *)((char *)&v18[16] + 8) = 0u;
    *(_OWORD *)((char *)&v18[15] + 8) = 0u;
    *(_OWORD *)((char *)&v18[14] + 8) = 0u;
    *(_OWORD *)((char *)&v18[13] + 8) = 0u;
    *(_OWORD *)((char *)&v18[12] + 8) = 0u;
    DWORD1(v18[18]) = *(_DWORD *)&v24[3];
    *((void *)&v18[18] + 1) = 0;
    LOBYTE(v18[19]) = 1;
    *(_DWORD *)((char *)&v18[19] + 1) = *(_DWORD *)v23;
    DWORD1(v18[19]) = *(_DWORD *)&v23[3];
    *(_OWORD *)((char *)&v18[19] + 8) = 0u;
    *(_OWORD *)((char *)&v18[20] + 8) = 0u;
    *(_OWORD *)((char *)&v18[21] + 8) = 0u;
    *(_OWORD *)((char *)&v18[22] + 8) = 0u;
    BYTE8(v18[23]) = 0;
    sub_1B5216D50(v18, (void (*)(void, void, void, void, void))sub_1B51DD6D8);
    return (void *)sub_1B51DD71C(0, 0, 0);
  }
  else
  {
    __int16 v11 = HIWORD(v21);
    sub_1B52AE3D8(a1, (uint64_t)__src);
    memcpy(__dst, __src, sizeof(__dst));
    swift_bridgeObjectRetain_n();
    sub_1B5216D50(__src, (void (*)(void, void, void, void, void))sub_1B51DD570);
    long long v12 = sub_1B526D128(a1);
    if (v4)
    {

      uint64_t v15 = 0;
      uint64_t v16 = 0;
      uint64_t v17 = 0;
    }
    else
    {
      uint64_t v15 = v12;
      uint64_t v16 = v13;
      uint64_t v17 = v14;
    }
    *(void *)&v18[0] = a1;
    memcpy((char *)v18 + 8, __dst, 0x179uLL);
    *((void *)&v18[24] + 1) = v15;
    *(void *)&v18[25] = v16;
    *((void *)&v18[25] + 1) = v17;
    LOWORD(v18[26]) = v11;
    BYTE2(v18[26]) = a2;
    BYTE3(v18[26]) = a3;
    sub_1B51DD4E8(v18);
    sub_1B5216D50(__src, (void (*)(void, void, void, void, void))sub_1B51DD6D8);
    swift_bridgeObjectRelease();
    sub_1B51DD650(v18);
    return memcpy(a4, v18, 0x1A4uLL);
  }
}

char *sub_1B52B8EE8(uint64_t a1, uint64_t (*a2)(void, void, void))
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    return (char *)MEMORY[0x1E4FBC860];
  }
  uint64_t v3 = (void *)(swift_bridgeObjectRetain() + 48);
  uint64_t v4 = (char *)MEMORY[0x1E4FBC860];
  do
  {
    __int16 v6 = a2(*(v3 - 2), *(v3 - 1), *v3);
    if (v8)
    {
      __int16 v10 = v6;
      uint64_t v11 = v7;
      uint64_t v12 = v8;
      uint64_t v13 = v9;
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
        uint64_t v4 = sub_1B51EA388(0, *((void *)v4 + 2) + 1, 1, v4);
      }
      unint64_t v15 = *((void *)v4 + 2);
      unint64_t v14 = *((void *)v4 + 3);
      if (v15 >= v14 >> 1) {
        uint64_t v4 = sub_1B51EA388((char *)(v14 > 1), v15 + 1, 1, v4);
      }
      *((void *)v4 + 2) = v15 + 1;
      uint64_t v5 = &v4[32 * v15];
      *((_WORD *)v5 + 16) = v10;
      *((void *)v5 + 5) = v11;
      *((void *)v5 + 6) = v12;
      *((_DWORD *)v5 + 14) = v13;
      *((_WORD *)v5 + 30) = WORD2(v13);
    }
    v3 += 3;
    --v2;
  }
  while (v2);
  swift_bridgeObjectRelease();
  return v4;
}

uint64_t *sub_1B52B9028(uint64_t a1, void (*a2)(long long *__return_ptr, uint64_t *), uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  long long v20 = *(_OWORD *)a1;
  *(void *)&long long v21 = v8;
  swift_bridgeObjectRetain();
  unsigned __int16 v9 = (unsigned __int16)sub_1B52B874C(&v20, a4);
  if (v4)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v10 = v9;
    swift_bridgeObjectRelease();
    long long v11 = v20;
    uint64_t v12 = v21;
    *(_OWORD *)a1 = v20;
    *(void *)(a1 + 16) = v12;
    uint64_t v22 = v10;
    a2(&v20, &v22);
    char v13 = v20;
    uint64_t v14 = *((void *)&v20 + 1);
    uint64_t v15 = v21;
    *(_OWORD *)long long v18 = v11;
    uint64_t v19 = v12;
    swift_bridgeObjectRetain();
    sub_1B51F3DDC((uint64_t *)v18, (uint64_t)a4, v13);
    a4 = (uint64_t *)sub_1B5255F70((uint64_t)v18, (uint64_t)a4, v14, v15);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v17 = v19;
    *(_OWORD *)a1 = *(_OWORD *)v18;
    *(void *)(a1 + 16) = v17;
  }
  return a4;
}

uint64_t sub_1B52B927C(uint64_t a1, void (*a2)(long long *__return_ptr, uint64_t *), uint64_t a3, uint64_t *a4)
{
  unsigned __int16 v9 = *(void **)(a1 + 16);
  long long v14 = *(_OWORD *)a1;
  uint64_t v15 = v9;
  swift_bridgeObjectRetain();
  unsigned __int16 v10 = (unsigned __int16)sub_1B52B874C(&v14, a4);
  if (v4)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int16 v11 = v10;
    swift_bridgeObjectRelease();
    uint64_t v12 = v15;
    *(_OWORD *)a1 = v14;
    *(void *)(a1 + 16) = v12;
    uint64_t v17 = v11;
    a2(&v14, &v17);
    a3 = sub_1B5255DE8(a1, a4, (void (*)(long long *__return_ptr, uint64_t *))v14, *((uint64_t *)&v14 + 1), v15, v16);
    swift_bridgeObjectRelease();
    swift_release();
  }
  return a3;
}

uint64_t sub_1B52B947C(uint64_t a1, void (*a2)(long long *__return_ptr, uint64_t *), uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *(void *)(a1 + 16);
  long long v14 = *(_OWORD *)a1;
  *(void *)&long long v15 = v9;
  swift_bridgeObjectRetain();
  unsigned __int8 v10 = sub_1B51FC9AC((unint64_t *)&v14, a4);
  if (v4)
  {
    swift_bridgeObjectRelease();
  }
  else
  {
    unsigned __int8 v11 = v10;
    swift_bridgeObjectRelease();
    uint64_t v12 = v15;
    *(_OWORD *)a1 = v14;
    *(void *)(a1 + 16) = v12;
    uint64_t v22 = v11;
    a2(&v14, &v22);
    long long v17 = v14;
    long long v18 = v15;
    uint64_t v19 = v16;
    long long v20 = v14;
    uint64_t v21 = v15;
    a3 = sub_1B51DCC0C((long long *)a1, a4);
    sub_1B52BA418((uint64_t)&v20);
    swift_release();
  }
  return a3;
}

unint64_t sub_1B52B968C(uint64_t a1, char a2, void *a3)
{
  LOBYTE(v4) = a2;
  uint64_t v6 = *(void *)(a1 + 16);
  swift_bridgeObjectRetain();
  if (!v6) {
    return swift_bridgeObjectRelease();
  }
  uint64_t v7 = *(unsigned int *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  unint64_t v8 = *(void *)(a1 + 48);
  sub_1B51D4BB8(v9, v8);
  if (v8 >> 60 == 15) {
    return swift_bridgeObjectRelease();
  }
  unsigned __int8 v10 = (void *)*a3;
  unint64_t result = sub_1B5230664(v7);
  uint64_t v13 = v10[2];
  BOOL v14 = (v12 & 1) == 0;
  BOOL v15 = __OFADD__(v13, v14);
  uint64_t v16 = v13 + v14;
  if (v15)
  {
LABEL_25:
    __break(1u);
    goto LABEL_26;
  }
  char v17 = v12;
  if (v10[3] < v16)
  {
    sub_1B5232950(v16, v4 & 1);
    unint64_t result = sub_1B5230664(v7);
    if ((v17 & 1) == (v18 & 1)) {
      goto LABEL_8;
    }
LABEL_6:
    unint64_t result = sub_1B5373288();
    __break(1u);
  }
  if ((v4 & 1) == 0)
  {
    unint64_t v21 = result;
    sub_1B5236E30();
    unint64_t result = v21;
    uint64_t v19 = (void *)*a3;
    if (v17)
    {
LABEL_9:
      uint64_t v20 = v19[7] + 16 * result;
      sub_1B51D4C64(*(void *)v20, *(void *)(v20 + 8));
      *(void *)uint64_t v20 = v9;
      *(void *)(v20 + 8) = v8;
      if (--v6)
      {
LABEL_15:
        uint64_t v4 = (unint64_t *)(a1 + 72);
        do
        {
          uint64_t v7 = *((unsigned int *)v4 - 4);
          uint64_t v9 = *(v4 - 1);
          unint64_t v8 = *v4;
          sub_1B51D4BB8(v9, *v4);
          if (v8 >> 60 == 15) {
            break;
          }
          uint64_t v26 = (void *)*a3;
          unint64_t result = sub_1B5230664(v7);
          uint64_t v28 = v26[2];
          BOOL v29 = (v27 & 1) == 0;
          BOOL v15 = __OFADD__(v28, v29);
          uint64_t v30 = v28 + v29;
          if (v15) {
            goto LABEL_25;
          }
          char v17 = v27;
          if (v26[3] < v30)
          {
            sub_1B5232950(v30, 1);
            unint64_t result = sub_1B5230664(v7);
            if ((v17 & 1) != (v31 & 1)) {
              goto LABEL_6;
            }
          }
          char v32 = (void *)*a3;
          if (v17)
          {
            uint64_t v25 = v32[7] + 16 * result;
            sub_1B51D4C64(*(void *)v25, *(void *)(v25 + 8));
            *(void *)uint64_t v25 = v9;
            *(void *)(v25 + 8) = v8;
          }
          else
          {
            v32[(result >> 6) + 8] |= 1 << result;
            *(_DWORD *)(v32[6] + 4 * result) = v7;
            char v33 = (uint64_t *)(v32[7] + 16 * result);
            *char v33 = v9;
            v33[1] = v8;
            uint64_t v34 = v32[2];
            BOOL v15 = __OFADD__(v34, 1);
            uint64_t v35 = v34 + 1;
            if (v15) {
              goto LABEL_26;
            }
            v32[2] = v35;
          }
          v4 += 3;
        }
        while (--v6);
      }
      return swift_bridgeObjectRelease();
    }
    goto LABEL_12;
  }
LABEL_8:
  uint64_t v19 = (void *)*a3;
  if (v17) {
    goto LABEL_9;
  }
LABEL_12:
  v19[(result >> 6) + 8] |= 1 << result;
  *(_DWORD *)(v19[6] + 4 * result) = v7;
  uint64_t v22 = (uint64_t *)(v19[7] + 16 * result);
  *uint64_t v22 = v9;
  v22[1] = v8;
  uint64_t v23 = v19[2];
  BOOL v15 = __OFADD__(v23, 1);
  uint64_t v24 = v23 + 1;
  if (!v15)
  {
    id v19[2] = v24;
    if (--v6) {
      goto LABEL_15;
    }
    return swift_bridgeObjectRelease();
  }
LABEL_26:
  __break(1u);
  return result;
}

uint64_t sub_1B52B9900()
{
  swift_bridgeObjectRelease();
  return MEMORY[0x1F4186498](v0, 40, 7);
}

uint64_t sub_1B52B9938()
{
  return sub_1B529A1A4();
}

uint64_t sub_1B52B9958()
{
  return MEMORY[0x1F4186498](v0, 32, 7);
}

uint64_t sub_1B52B9968(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 160);
  uint64_t v3 = *(void *)(a1 + 168);
  uint64_t v4 = *(void *)(a1 + 176);
  uint64_t v5 = *(void *)(a1 + 184);
  uint64_t v6 = *(void *)(a1 + 192);
  char v8 = *(unsigned char *)(a1 + 200);
  swift_bridgeObjectRelease();
  swift_release();
  swift_bridgeObjectRelease();
  swift_release();
  swift_release();
  swift_release();
  sub_1B52017F4(v2, v3, v4, v5, v6, v8);
  swift_bridgeObjectRelease();
  swift_release();
  return a1;
}

unint64_t sub_1B52B9A48()
{
  unint64_t result = qword_1E9D491C8;
  if (!qword_1E9D491C8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D491C8);
  }
  return result;
}

uint64_t getEnumTagSinglePayload for SfntFontError(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xEF) {
    goto LABEL_17;
  }
  if (a2 + 17 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 17) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 17;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 17;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 17;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0x12;
  int v8 = v6 - 18;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for SfntFontError(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 17 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 17) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xEF) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xEE)
  {
    unsigned int v6 = ((a2 - 239) >> 8) + 1;
    *unint64_t result = a2 + 17;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1B52B9BF8);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 17;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for SfntFontError()
{
  return &type metadata for SfntFontError;
}

uint64_t destroy for SfntTrueTypeFont(void *a1)
{
  swift_bridgeObjectRelease();
  if (a1[27])
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  uint64_t result = a1[49];
  if (result)
  {
    swift_bridgeObjectRelease();
    uint64_t v3 = a1[50];
    unint64_t v4 = a1[51];
    return sub_1B51D4C64(v3, v4);
  }
  return result;
}

uint64_t initializeWithCopy for SfntTrueTypeFont(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 57) = *(_OWORD *)(a2 + 57);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(unsigned char *)(a1 + 96) = *(unsigned char *)(a2 + 96);
  long long v4 = *(_OWORD *)(a2 + 104);
  long long v5 = *(_OWORD *)(a2 + 120);
  *(unsigned char *)(a1 + 136) = *(unsigned char *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v5;
  *(_OWORD *)(a1 + 104) = v4;
  *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
  long long v6 = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 160) = v6;
  *(unsigned char *)(a1 + 200) = *(unsigned char *)(a2 + 200);
  *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
  uint64_t v7 = *(void *)(a2 + 216);
  swift_bridgeObjectRetain();
  if (v7)
  {
    *(void *)(a1 + 208) = *(void *)(a2 + 208);
    *(void *)(a1 + 216) = v7;
    uint64_t v8 = *(void *)(a2 + 232);
    *(void *)(a1 + 224) = *(void *)(a2 + 224);
    *(void *)(a1 + 232) = v8;
    *(void *)(a1 + 240) = *(void *)(a2 + 240);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 224);
    *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
    *(_OWORD *)(a1 + 224) = v9;
    *(void *)(a1 + 240) = *(void *)(a2 + 240);
  }
  *(_OWORD *)(a1 + 248) = *(_OWORD *)(a2 + 248);
  *(void *)(a1 + 264) = *(void *)(a2 + 264);
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  *(unsigned char *)(a1 + 296) = *(unsigned char *)(a2 + 296);
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  *(unsigned char *)(a1 + 312) = *(unsigned char *)(a2 + 312);
  long long v10 = *(_OWORD *)(a2 + 336);
  *(_OWORD *)(a1 + 320) = *(_OWORD *)(a2 + 320);
  *(_OWORD *)(a1 + 336) = v10;
  long long v11 = *(_OWORD *)(a2 + 368);
  *(_OWORD *)(a1 + 352) = *(_OWORD *)(a2 + 352);
  *(_OWORD *)(a1 + 368) = v11;
  *(unsigned char *)(a1 + 384) = *(unsigned char *)(a2 + 384);
  uint64_t v12 = *(void *)(a2 + 392);
  if (v12)
  {
    *(void *)(a1 + 392) = v12;
    uint64_t v13 = *(void *)(a2 + 400);
    unint64_t v14 = *(void *)(a2 + 408);
    swift_bridgeObjectRetain();
    sub_1B51D4BB8(v13, v14);
    *(void *)(a1 + 400) = v13;
    *(void *)(a1 + 408) = v14;
  }
  else
  {
    *(_OWORD *)(a1 + 392) = *(_OWORD *)(a2 + 392);
    *(void *)(a1 + 408) = *(void *)(a2 + 408);
  }
  *(_DWORD *)(a1 + 416) = *(_DWORD *)(a2 + 416);
  return a1;
}

uint64_t assignWithCopy for SfntTrueTypeFont(uint64_t a1, uint64_t a2)
{
  long long v4 = (unsigned char *)(a2 + 296);
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  long long v5 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 57) = *(_OWORD *)(a2 + 57);
  *(_OWORD *)(a1 + 48) = v5;
  long long v6 = *(_OWORD *)(a2 + 80);
  *(unsigned char *)(a1 + 96) = *(unsigned char *)(a2 + 96);
  *(_OWORD *)(a1 + 80) = v6;
  long long v7 = *(_OWORD *)(a2 + 104);
  long long v8 = *(_OWORD *)(a2 + 120);
  *(unsigned char *)(a1 + 136) = *(unsigned char *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v8;
  *(_OWORD *)(a1 + 104) = v7;
  long long v9 = *(_OWORD *)(a2 + 144);
  long long v10 = *(_OWORD *)(a2 + 160);
  *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
  *(_OWORD *)(a1 + 144) = v9;
  *(_OWORD *)(a1 + 160) = v10;
  long long v11 = *(_OWORD *)(a2 + 184);
  *(unsigned char *)(a1 + 200) = *(unsigned char *)(a2 + 200);
  *(_OWORD *)(a1 + 184) = v11;
  uint64_t v12 = (_OWORD *)(a1 + 208);
  uint64_t v13 = (_OWORD *)(a2 + 208);
  uint64_t v14 = *(void *)(a2 + 216);
  if (*(void *)(a1 + 216))
  {
    if (v14)
    {
      *(void *)(a1 + 208) = *(void *)(a2 + 208);
      *(void *)(a1 + 216) = *(void *)(a2 + 216);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 224) = *(void *)(a2 + 224);
      *(void *)(a1 + 232) = *(void *)(a2 + 232);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 240) = *(void *)(a2 + 240);
    }
    else
    {
      sub_1B51FFB2C(a1 + 208);
      uint64_t v15 = *(void *)(a2 + 240);
      long long v16 = *(_OWORD *)(a2 + 224);
      *uint64_t v12 = *v13;
      *(_OWORD *)(a1 + 224) = v16;
      *(void *)(a1 + 240) = v15;
    }
  }
  else if (v14)
  {
    *(void *)(a1 + 208) = *(void *)(a2 + 208);
    *(void *)(a1 + 216) = *(void *)(a2 + 216);
    *(void *)(a1 + 224) = *(void *)(a2 + 224);
    *(void *)(a1 + 232) = *(void *)(a2 + 232);
    *(void *)(a1 + 240) = *(void *)(a2 + 240);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v17 = *v13;
    long long v18 = *(_OWORD *)(a2 + 224);
    *(void *)(a1 + 240) = *(void *)(a2 + 240);
    *uint64_t v12 = v17;
    *(_OWORD *)(a1 + 224) = v18;
  }
  *(void *)(a1 + 248) = *(void *)(a2 + 248);
  *(void *)(a1 + 256) = *(void *)(a2 + 256);
  *(void *)(a1 + 264) = *(void *)(a2 + 264);
  *(void *)(a1 + 272) = *(void *)(a2 + 272);
  *(void *)(a1 + 280) = *(void *)(a2 + 280);
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  *(unsigned char *)(a1 + 296) = *v4;
  uint64_t v19 = *(void *)(a2 + 304);
  *(unsigned char *)(a1 + 312) = *(unsigned char *)(a2 + 312);
  *(void *)(a1 + 304) = v19;
  *(void *)(a1 + 320) = *(void *)(a2 + 320);
  *(void *)(a1 + 328) = *(void *)(a2 + 328);
  *(void *)(a1 + 336) = *(void *)(a2 + 336);
  *(void *)(a1 + 344) = *(void *)(a2 + 344);
  *(void *)(a1 + 352) = *(void *)(a2 + 352);
  *(void *)(a1 + 360) = *(void *)(a2 + 360);
  *(void *)(a1 + 368) = *(void *)(a2 + 368);
  *(void *)(a1 + 376) = *(void *)(a2 + 376);
  *(unsigned char *)(a1 + 384) = v4[88];
  uint64_t v20 = (_OWORD *)(a1 + 392);
  unint64_t v21 = (_OWORD *)(a2 + 392);
  uint64_t v22 = *(void *)(a2 + 392);
  if (*(void *)(a1 + 392))
  {
    if (v22)
    {
      *(void *)(a1 + 392) = v22;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      uint64_t v23 = *(void *)(a2 + 400);
      unint64_t v24 = *(void *)(a2 + 408);
      sub_1B51D4BB8(v23, v24);
      uint64_t v25 = *(void *)(a1 + 400);
      unint64_t v26 = *(void *)(a1 + 408);
      *(void *)(a1 + 400) = v23;
      *(void *)(a1 + 408) = v24;
      sub_1B51D4C64(v25, v26);
    }
    else
    {
      sub_1B51FFB80(a1 + 392);
      uint64_t v29 = *(void *)(a2 + 408);
      *uint64_t v20 = *v21;
      *(void *)(a1 + 408) = v29;
    }
  }
  else if (v22)
  {
    *(void *)(a1 + 392) = v22;
    uint64_t v27 = *(void *)(a2 + 400);
    unint64_t v28 = *(void *)(a2 + 408);
    swift_bridgeObjectRetain();
    sub_1B51D4BB8(v27, v28);
    *(void *)(a1 + 400) = v27;
    *(void *)(a1 + 408) = v28;
  }
  else
  {
    long long v30 = *v21;
    *(void *)(a1 + 408) = *(void *)(a2 + 408);
    *uint64_t v20 = v30;
  }
  *(_WORD *)(a1 + 416) = *(_WORD *)(a2 + 416);
  *(unsigned char *)(a1 + 418) = *(unsigned char *)(a2 + 418);
  *(unsigned char *)(a1 + 419) = *(unsigned char *)(a2 + 419);
  return a1;
}

void *__swift_memcpy420_8(void *a1, const void *a2)
{
  return memcpy(a1, a2, 0x1A4uLL);
}

uint64_t assignWithTake for SfntTrueTypeFont(uint64_t a1, uint64_t a2)
{
  long long v4 = (unsigned char *)(a2 + 296);
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 57) = *(_OWORD *)(a2 + 57);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(unsigned char *)(a1 + 96) = *(unsigned char *)(a2 + 96);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(unsigned char *)(a1 + 136) = *(unsigned char *)(a2 + 136);
  *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
  long long v5 = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 160) = v5;
  *(unsigned char *)(a1 + 200) = *(unsigned char *)(a2 + 200);
  *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
  if (*(void *)(a1 + 216))
  {
    uint64_t v6 = *(void *)(a2 + 216);
    if (v6)
    {
      *(void *)(a1 + 208) = *(void *)(a2 + 208);
      *(void *)(a1 + 216) = v6;
      swift_bridgeObjectRelease();
      uint64_t v7 = *(void *)(a2 + 232);
      *(void *)(a1 + 224) = *(void *)(a2 + 224);
      *(void *)(a1 + 232) = v7;
      swift_bridgeObjectRelease();
      *(void *)(a1 + 240) = *(void *)(a2 + 240);
      goto LABEL_6;
    }
    sub_1B51FFB2C(a1 + 208);
  }
  long long v8 = *(_OWORD *)(a2 + 224);
  *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
  *(_OWORD *)(a1 + 224) = v8;
  *(void *)(a1 + 240) = *(void *)(a2 + 240);
LABEL_6:
  *(_OWORD *)(a1 + 248) = *(_OWORD *)(a2 + 248);
  *(void *)(a1 + 264) = *(void *)(a2 + 264);
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  *(unsigned char *)(a1 + 296) = *v4;
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  *(unsigned char *)(a1 + 312) = *(unsigned char *)(a2 + 312);
  long long v9 = *(_OWORD *)(a2 + 336);
  *(_OWORD *)(a1 + 320) = *(_OWORD *)(a2 + 320);
  *(_OWORD *)(a1 + 336) = v9;
  long long v10 = *(_OWORD *)(a2 + 368);
  *(_OWORD *)(a1 + 352) = *(_OWORD *)(a2 + 352);
  *(_OWORD *)(a1 + 368) = v10;
  *(unsigned char *)(a1 + 384) = v4[88];
  if (!*(void *)(a1 + 392))
  {
LABEL_10:
    *(_OWORD *)(a1 + 392) = *(_OWORD *)(a2 + 392);
    *(void *)(a1 + 408) = *(void *)(a2 + 408);
    goto LABEL_11;
  }
  uint64_t v11 = *(void *)(a2 + 392);
  if (!v11)
  {
    sub_1B51FFB80(a1 + 392);
    goto LABEL_10;
  }
  *(void *)(a1 + 392) = v11;
  swift_bridgeObjectRelease();
  uint64_t v12 = *(void *)(a1 + 400);
  unint64_t v13 = *(void *)(a1 + 408);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a2 + 400);
  sub_1B51D4C64(v12, v13);
LABEL_11:
  *(_DWORD *)(a1 + 416) = *(_DWORD *)(a2 + 416);
  return a1;
}

uint64_t getEnumTagSinglePayload for SfntTrueTypeFont(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 420)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SfntTrueTypeFont(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 408) = 0;
    *(_OWORD *)(result + 248) = 0u;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 392) = 0u;
    *(_DWORD *)(result + 416) = 0;
    *(_OWORD *)(result + 376) = 0u;
    *(_OWORD *)(result + 360) = 0u;
    *(_OWORD *)(result + 344) = 0u;
    *(_OWORD *)(result + 328) = 0u;
    *(_OWORD *)(result + 312) = 0u;
    *(_OWORD *)(result + 296) = 0u;
    *(_OWORD *)(result + 280) = 0u;
    *(_OWORD *)(result + 264) = 0u;
    *(void *)uint64_t result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 420) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)uint64_t result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 420) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for SfntTrueTypeFont()
{
  return &type metadata for SfntTrueTypeFont;
}

uint64_t sub_1B52BA3CC()
{
  return sub_1B52010C8(&qword_1E9D491D0, &qword_1E9D491D8);
}

ValueMetadata *type metadata accessor for SfntTableLookup()
{
  return &type metadata for SfntTableLookup;
}

uint64_t sub_1B52BA418(uint64_t a1)
{
  return a1;
}

uint64_t sub_1B52BA444(uint64_t a1)
{
  return a1;
}

uint64_t sub_1B52BA4AC()
{
  return MEMORY[0x1F4186498](v0, 32, 7);
}

uint64_t sub_1B52BA4BC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B52BE310(a1, *(void *)(v2 + 16), *(void *)(v2 + 24), a2);
}

uint64_t sub_1B52BA4D8(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5)
{
  char v5 = a4 & 1;
  if (a5) {
    return sub_1B5200F30(a1, a2, a3, v5);
  }
  else {
    return sub_1B5200F20(a1, a2, a3, v5);
  }
}

uint64_t sub_1B52BA4E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(a1 + 88);
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(void *)(a1 + 112);
  char v7 = *(unsigned char *)(a1 + 121);
  char v8 = *(unsigned char *)(a1 + 120);
  swift_release();
  swift_release();
  swift_release();
  sub_1B52BA8A8(v2, v3, v4, v5, v6, v8, v7, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5201270, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B52012C0);
  return a1;
}

uint64_t sub_1B52BA5B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, char a16)
{
  if ((a16 & 1) == 0)
  {
    swift_release();
    return swift_release();
  }
  return result;
}

unsigned int *sub_1B52BA600@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B51FBEF0(a1, v2, a2);
}

unint64_t sub_1B52BA61C@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B52B7784(a1, v2, a2);
}

unint64_t sub_1B52BA638@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B52B71CC(a1, v2, a2);
}

unint64_t sub_1B52BA654@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B52B6C20(a1, v2, a2);
}

uint64_t sub_1B52BA670(uint64_t a1)
{
  return a1;
}

uint64_t sub_1B52BA6E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, char a15)
{
  if ((a15 & 1) == 0)
  {
    swift_release();
    return swift_release();
  }
  return result;
}

uint64_t sub_1B52BA738()
{
  swift_release();
  return MEMORY[0x1F4186498](v0, 136, 7);
}

double sub_1B52BA770@<D0>(uint64_t a1@<X8>)
{
  *(void *)&double result = sub_1B52B70AC((long long *)(v1 + 16), a1).n128_u64[0];
  return result;
}

double sub_1B52BA790@<D0>(uint64_t a1@<X8>)
{
  *(void *)&double result = sub_1B52B765C((long long *)(v1 + 16), a1).n128_u64[0];
  return result;
}

double sub_1B52BA7B0@<D0>(uint64_t a1@<X8>)
{
  *(void *)&double result = sub_1B52B7C08((long long *)(v1 + 16), a1).n128_u64[0];
  return result;
}

uint64_t sub_1B52BA7D0(uint64_t a1)
{
  return a1;
}

uint64_t sub_1B52BA834()
{
  sub_1B51D4C64(*(void *)(v0 + 24), *(void *)(v0 + 32));
  return MEMORY[0x1F4186498](v0, 65, 7);
}

uint64_t sub_1B52BA86C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1B52BA8A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, char a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void), uint64_t (*a9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))
{
  if (a7) {
    return a9(a1, a2, a3, a4, a5, a6 & 1);
  }
  else {
    return a8(a1, a2, a3, a4, a5, a6 & 1);
  }
}

BOOL static CFFError.__derived_enum_equals(_:_:)(char a1, char a2)
{
  return a1 == a2;
}

uint64_t CFFError.hash(into:)()
{
  return sub_1B5373308();
}

uint64_t CFFError.hashValue.getter()
{
  return sub_1B5373358();
}

unint64_t sub_1B52BA958()
{
  unint64_t result = qword_1E9D491F0;
  if (!qword_1E9D491F0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D491F0);
  }
  return result;
}

unsigned char *storeEnumTagSinglePayload for CFFError(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 4 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 4) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFC) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFB)
  {
    unsigned int v6 = ((a2 - 252) >> 8) + 1;
    *unint64_t result = a2 + 4;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1B52BAA78);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 4;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for CFFError()
{
  return &type metadata for CFFError;
}

__n128 sub_1B52BAAB0@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int16 v2 = *(_WORD *)(a1 + 40);
  int v3 = *(_DWORD *)(a1 + 60);
  long long v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v4;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  *(_WORD *)(a2 + 40) = v2;
  *(_OWORD *)(a2 + 44) = *(_OWORD *)(a1 + 44);
  *(_DWORD *)(a2 + 60) = v3;
  __n128 result = *(__n128 *)(a1 + 64);
  *(__n128 *)(a2 + 64) = result;
  *(void *)(a2 + 80) = 0;
  *(unsigned char *)(a2 + 88) = 1;
  *(void *)(a2 + 90) = 0;
  *(_WORD *)(a2 + 98) = 0;
  *(unsigned char *)(a2 + 100) = 1;
  *(_DWORD *)(a2 + 102) = 0;
  *(unsigned char *)(a2 + 106) = 1;
  return result;
}

ValueMetadata *type metadata accessor for OS2Table.Selection()
{
  return &type metadata for OS2Table.Selection;
}

uint64_t __swift_memcpy10_1(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(_WORD *)(result + 8) = *((_WORD *)a2 + 4);
  *(void *)__n128 result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for OS2Table.PanoseClassification(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 10)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for OS2Table.PanoseClassification(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_WORD *)(result + 8) = 0;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 10) = v3;
  return result;
}

ValueMetadata *type metadata accessor for OS2Table.PanoseClassification()
{
  return &type metadata for OS2Table.PanoseClassification;
}

ValueMetadata *type metadata accessor for OS2Table.PanoseClassification.Proportion()
{
  return &type metadata for OS2Table.PanoseClassification.Proportion;
}

_DWORD *__swift_memcpy4_2(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

ValueMetadata *type metadata accessor for OS2Table.V5Fields()
{
  return &type metadata for OS2Table.V5Fields;
}

uint64_t __swift_memcpy10_2(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(_WORD *)(result + 8) = *((_WORD *)a2 + 4);
  *(void *)__n128 result = v2;
  return result;
}

ValueMetadata *type metadata accessor for OS2Table.V2Fields()
{
  return &type metadata for OS2Table.V2Fields;
}

void *__swift_memcpy8_4(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

ValueMetadata *type metadata accessor for OS2Table.V1Fields()
{
  return &type metadata for OS2Table.V1Fields;
}

__n128 __swift_memcpy107_4(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)a1 = v2;
  __n128 result = (__n128)a2[3];
  long long v5 = a2[4];
  long long v6 = a2[5];
  *(_OWORD *)(a1 + 91) = *(long long *)((char *)a2 + 91);
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 80) = v6;
  *(__n128 *)(a1 + 48) = result;
  return result;
}

uint64_t getEnumTagSinglePayload for OS2Table(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 107)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for OS2Table(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(unsigned char *)(result + 106) = 0;
    *(_WORD *)(result + 104) = 0;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 107) = v3;
  return result;
}

ValueMetadata *type metadata accessor for OS2Table()
{
  return &type metadata for OS2Table;
}

uint64_t sub_1B52BAC98()
{
  return MEMORY[0x1E4FBC468];
}

uint64_t sub_1B52BACA4()
{
  return swift_getOpaqueTypeConformance2();
}

uint64_t sub_1B52BACC0()
{
  return swift_getOpaqueTypeConformance2();
}

uint64_t sub_1B52BACDC()
{
  return swift_getOpaqueTypeConformance2();
}

unint64_t sub_1B52BACFC()
{
  unint64_t result = qword_1E9D491F8;
  if (!qword_1E9D491F8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D491F8);
  }
  return result;
}

unint64_t sub_1B52BAD54()
{
  unint64_t result = qword_1E9D49200;
  if (!qword_1E9D49200)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49200);
  }
  return result;
}

unint64_t sub_1B52BADAC()
{
  unint64_t result = qword_1E9D49208;
  if (!qword_1E9D49208)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49208);
  }
  return result;
}

unint64_t sub_1B52BAE04()
{
  unint64_t result = qword_1E9D49210;
  if (!qword_1E9D49210)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49210);
  }
  return result;
}

__n128 __swift_memcpy80_4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v3 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v4;
  *(__n128 *)(a1 + 16) = result;
  *(_OWORD *)(a1 + 32) = v3;
  return result;
}

uint64_t getEnumTagSinglePayload for OS2Table.V0Fields(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 80)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for OS2Table.V0Fields(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 72) = 0;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 80) = v3;
  return result;
}

ValueMetadata *type metadata accessor for OS2Table.V0Fields()
{
  return &type metadata for OS2Table.V0Fields;
}

uint64_t sub_1B52BAEE4()
{
  return sub_1B52BAFA0(&qword_1E9D49218, &qword_1E9D49220);
}

uint64_t sub_1B52BAF0C()
{
  return sub_1B52BAFA0(&qword_1E9D49228, &qword_1E9D49230);
}

uint64_t sub_1B52BAF34()
{
  return sub_1B52BAFA0(&qword_1E9D49238, &qword_1E9D49240);
}

uint64_t sub_1B52BAF5C()
{
  return swift_getOpaqueTypeConformance2();
}

uint64_t sub_1B52BAF78()
{
  return sub_1B52BAFA0(&qword_1E9D49248, &qword_1E9D49250);
}

uint64_t sub_1B52BAFA0(unint64_t *a1, uint64_t *a2)
{
  uint64_t result = *a1;
  if (!result)
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(a2);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_1B52BAFF4(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1B51D4BB8(a1, a2);
  sub_1B51D4C10();
  uint64_t v6 = sub_1B53724D8();
  v10[0] = (char *)MEMORY[0x1E4FBC860];
  v10[1] = 0;
  sub_1B52BB10C(v6, v7, v8, v10, a3, a4);
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

void *sub_1B52BB090@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = *result | 0x100;
  *(unsigned char *)(a2 + 8) = 0;
  return result;
}

unsigned __int8 *sub_1B52BB0A4@<X0>(unsigned __int8 *result@<X0>, unsigned __int8 a2@<W1>, void *a3@<X8>)
{
  if (((a2 - 247) & 0xFFFFFF00) != 0) {
    __break(1u);
  }
  else {
    *a3 = (*result | ((unint64_t)(a2 + 9) << 8)) + 108;
  }
  return result;
}

void *sub_1B52BB0CC@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = *result;
  *(unsigned char *)(a2 + 8) = 1;
  return result;
}

unsigned __int8 *sub_1B52BB0E0@<X0>(unsigned __int8 *result@<X0>, unsigned __int8 a2@<W1>, void *a3@<X8>)
{
  if (((a2 - 251) & 0xFFFFFF00) != 0) {
    __break(1u);
  }
  else {
    *a3 = -108 - (*result | ((unint64_t)(a2 + 5) << 8));
  }
  return result;
}

uint64_t sub_1B52BB10C(uint64_t result, int64_t a2, uint64_t a3, char **a4, uint64_t a5, uint64_t a6)
{
  if (result == a2) {
    return result;
  }
  int64_t v9 = a2;
  unint64_t v10 = result;
  v147 = v6;
  swift_bridgeObjectRetain();
  v145 = a4;
  while (2)
  {
    if (__OFSUB__(v9, v10))
    {
      __break(1u);
LABEL_137:
      __break(1u);
LABEL_138:
      __break(1u);
LABEL_139:
      __break(1u);
LABEL_140:
      __break(1u);
LABEL_141:
      __break(1u);
LABEL_142:
      __break(1u);
LABEL_143:
      __break(1u);
LABEL_144:
      __break(1u);
LABEL_145:
      __break(1u);
LABEL_146:
      __break(1u);
LABEL_147:
      __break(1u);
LABEL_148:
      __break(1u);
LABEL_149:
      __break(1u);
LABEL_150:
      __break(1u);
      __break(1u);
      JUMPOUT(0x1B52BCFDCLL);
    }
    if ((uint64_t)(v9 - v10) <= 0)
    {
      *(void *)&long long v153 = 0;
      *((void *)&v153 + 1) = 0xE000000000000000;
      swift_bridgeObjectRetain();
      sub_1B5372F98();
      swift_bridgeObjectRelease();
      sub_1B51D4D34();
      swift_allocError();
      *long long v125 = 0;
      v125[1] = v10;
      v125[2] = 0xD00000000000002ALL;
      v125[3] = 0x80000001B537BD00;
      v125[4] = 0;
LABEL_125:
      swift_willThrow();
      return swift_bridgeObjectRelease_n();
    }
    if (v10 == 0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_137;
    }
    unint64_t v11 = v10 + 1;
    if (v9 < (uint64_t)(v10 + 1)) {
      goto LABEL_137;
    }
    if ((v10 & 0x8000000000000000) != 0) {
      goto LABEL_138;
    }
    unint64_t v12 = *(void *)(a3 + 16);
    if (v12 < v10 || v12 < v11) {
      goto LABEL_139;
    }
    uint64_t v13 = *(unsigned __int8 *)(a3 + v10 + 32);
    swift_bridgeObjectRetain();
    if (v13 == 12)
    {
      sub_1B528374C(1, (uint64_t)sub_1B52BB090, 0, 0, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F68, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B52837B8, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B52837FC);
      *(void *)&long long v153 = v10 + 1;
      *((void *)&v153 + 1) = v9;
      *(void *)&long long v154 = a3;
      swift_bridgeObjectRetain();
      sub_1B528374C(1, (uint64_t)sub_1B52BB090, 0, 0, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F68, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B52837B8, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B52837FC);
      swift_bridgeObjectRetain();
      sub_1B528374C(1, (uint64_t)sub_1B52BB090, 0, 0, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F68, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B52837B8, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B52837FC);
      unsigned __int8 v15 = sub_1B51FC9AC((unint64_t *)&v153, v14);
      long long v16 = v147;
      if (!v147)
      {
        unsigned __int8 v17 = v15;
        swift_bridgeObjectRelease();
        uint64_t v18 = v17;
        int64_t v9 = *((void *)&v153 + 1);
        unint64_t v10 = v153;
        uint64_t v19 = v154;
        uint64_t v156 = v18;
        sub_1B52BB090(&v156, (uint64_t)&v151);
        v147 = 0;
        swift_bridgeObjectRelease();
        uint64_t v20 = v19;
        sub_1B528374C(1, (uint64_t)sub_1B52BB090, 0, 0, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
        sub_1B528374C(1, (uint64_t)sub_1B52BB090, 0, 0, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
        uint64_t v13 = (uint64_t)v151;
        char v21 = v152;
        sub_1B528379C(1, (uint64_t)sub_1B52BB090, 0, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658);
        uint64_t v22 = v20;
        sub_1B528379C(1, (uint64_t)sub_1B52BB090, 0, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658);
        goto LABEL_14;
      }
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      sub_1B528374C(1, (uint64_t)sub_1B52BB090, 0, 0, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
      sub_1B528374C(1, (uint64_t)sub_1B52BB090, 0, 0, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
      sub_1B528379C(1, (uint64_t)sub_1B52BB090, 0, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658);
      sub_1B528379C(1, (uint64_t)sub_1B52BB090, 0, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658);
      goto LABEL_122;
    }
    if (v13 < 0x20)
    {
      sub_1B528374C(v13, 0, 0, 1, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
      sub_1B528374C(v13, 0, 0, 1, 0, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
      sub_1B528379C(v13, 0, 0, 1, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658);
      swift_bridgeObjectRelease();
      ++v10;
      uint64_t v22 = a3;
      goto LABEL_18;
    }
    if (v13 < 0xF7)
    {
      v13 -= 139;
      sub_1B528374C(v13, 1, 0, 0, 256, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
      sub_1B528374C(v13, 1, 0, 0, 256, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
      sub_1B528379C(v13, 1, 0, 0, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658);
      swift_bridgeObjectRelease();
      ++v10;
      uint64_t v22 = a3;
LABEL_34:
      uint64_t v36 = *v145;
      unint64_t v37 = *((void *)*v145 + 2);
      if (v37 > 0x2F) {
        goto LABEL_119;
      }
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
        uint64_t v36 = sub_1B51E7F50(0, v37 + 1, 1, v36);
      }
      unint64_t v39 = *((void *)v36 + 2);
      unint64_t v38 = *((void *)v36 + 3);
      if (v39 >= v38 >> 1) {
        uint64_t v36 = sub_1B51E7F50((char *)(v38 > 1), v39 + 1, 1, v36);
      }
      *((void *)v36 + 2) = v39 + 1;
      *(void *)&v36[8 * v39 + 32] = v13;
      *v145 = v36;
      goto LABEL_3;
    }
    if (v13 >= 0xFB)
    {
      if (v13 == 255)
      {
        sub_1B528374C(1, (uint64_t)sub_1B52BD450, 0, 0, 1, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F68, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B52837B8, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B52837FC);
        *(void *)&long long v153 = v10 + 1;
        *((void *)&v153 + 1) = v9;
        *(void *)&long long v154 = a3;
        swift_bridgeObjectRetain();
        sub_1B528374C(1, (uint64_t)sub_1B52BD450, 0, 0, 1, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F68, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B52837B8, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B52837FC);
        swift_bridgeObjectRetain();
        sub_1B528374C(1, (uint64_t)sub_1B52BD450, 0, 0, 1, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F68, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B52837B8, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B52837FC);
        unsigned int v30 = sub_1B51F3E3C((uint64_t *)&v153, v29, 1);
        long long v16 = v147;
        if (!v147)
        {
          signed int v31 = v30;
          swift_bridgeObjectRelease();
          uint64_t v32 = v31;
          int64_t v9 = *((void *)&v153 + 1);
          unint64_t v10 = v153;
          uint64_t v33 = v154;
          uint64_t v156 = v32;
          sub_1B52BD450(&v156, (uint64_t)&v151);
          v147 = 0;
          swift_bridgeObjectRelease();
          sub_1B528374C(1, (uint64_t)sub_1B52BD450, 0, 0, 1, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
          uint64_t v22 = v33;
          sub_1B528374C(1, (uint64_t)sub_1B52BD450, 0, 0, 1, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
          uint64_t v13 = (uint64_t)v151;
          char v21 = v152;
          sub_1B528369C((void *)1, (uint64_t)sub_1B52BD450, 0, 0, (void *)1, 0);
          sub_1B528369C((void *)1, (uint64_t)sub_1B52BD450, 0, 0, (void *)1, 0);
LABEL_14:
          swift_bridgeObjectRelease();
          if (v21) {
            goto LABEL_34;
          }
          goto LABEL_18;
        }
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        sub_1B528374C(1, (uint64_t)sub_1B52BD450, 0, 0, 1, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
        sub_1B528374C(1, (uint64_t)sub_1B52BD450, 0, 0, 1, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
        sub_1B528369C((void *)1, (uint64_t)sub_1B52BD450, 0, 0, (void *)1, 0);
        uint64_t v133 = 1;
        char v134 = sub_1B52BD450;
        int v135 = 0;
        uint64_t v136 = 1;
      }
      else
      {
        uint64_t v34 = swift_allocObject();
        *(unsigned char *)(v34 + 16) = v13;
        *(void *)&long long v153 = v10 + 1;
        *((void *)&v153 + 1) = v9;
        *(void *)&long long v154 = a3;
        swift_bridgeObjectRetain();
        sub_1B528374C((uint64_t)sub_1B52BD288, v34, (uint64_t)sub_1B52BD450, 0, 0, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F68, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B52837B8, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B52837FC);
        swift_bridgeObjectRetain();
        sub_1B528374C((uint64_t)sub_1B52BD288, v34, (uint64_t)sub_1B52BD450, 0, 0, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F68, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B52837B8, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B52837FC);
        swift_retain();
        unsigned __int8 v35 = sub_1B52BD17C((unint64_t *)&v153);
        long long v16 = v147;
        if (!v147)
        {
          unsigned __int8 v149 = v35;
          sub_1B52BD288(&v149, &v150);
          swift_bridgeObjectRelease();
          int64_t v9 = *((void *)&v153 + 1);
          unint64_t v10 = v153;
          uint64_t v22 = v154;
          uint64_t v156 = v150;
          sub_1B52BD450(&v156, (uint64_t)&v151);
          v147 = 0;
          swift_release();
          swift_bridgeObjectRelease();
          sub_1B528374C((uint64_t)sub_1B52BD288, v34, (uint64_t)sub_1B52BD450, 0, 0, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
          uint64_t v13 = (uint64_t)v151;
          char v140 = v152;
          sub_1B528374C((uint64_t)sub_1B52BD288, v34, (uint64_t)sub_1B52BD450, 0, 0, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
          sub_1B528369C(sub_1B52BD288, v34, (uint64_t)sub_1B52BD450, 0, 0, 0);
          goto LABEL_33;
        }
        swift_release();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        sub_1B528374C((uint64_t)sub_1B52BD288, v34, (uint64_t)sub_1B52BD450, 0, 0, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
        sub_1B528374C((uint64_t)sub_1B52BD288, v34, (uint64_t)sub_1B52BD450, 0, 0, 0, 1, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
        uint64_t v133 = (uint64_t)sub_1B52BD288;
        char v134 = (void *(*)@<X0>(void *@<X0>, uint64_t@<X8>))v34;
        int v135 = sub_1B52BD450;
        uint64_t v136 = 0;
      }
      sub_1B528369C((void *)v133, (uint64_t)v134, (uint64_t)v135, 0, (void *)v136, 0);
LABEL_122:
      id v151 = v16;
      id v128 = v16;
      __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47950);
      if (swift_dynamicCast())
      {

        long long v146 = v154;
        long long v148 = v153;
        uint64_t v129 = v155;
        sub_1B51D4D34();
        swift_allocError();
        *(_OWORD *)uint64_t v130 = v148;
        *(_OWORD *)(v130 + 16) = v146;
        *(void *)(v130 + 32) = v129;
        swift_willThrow();

        return swift_bridgeObjectRelease_n();
      }

      sub_1B51D4D34();
      swift_allocError();
      *uint64_t v131 = v16;
      v131[1] = v11;
      v131[2] = 0x7272652072657355;
      v131[3] = 0xEA0000000000726FLL;
      v131[4] = v16;
      id v132 = v16;
      goto LABEL_125;
    }
    uint64_t v26 = swift_allocObject();
    *(unsigned char *)(v26 + 16) = v13;
    *(void *)&long long v153 = v10 + 1;
    *((void *)&v153 + 1) = v9;
    *(void *)&long long v154 = a3;
    swift_bridgeObjectRetain_n();
    sub_1B528374C((uint64_t)sub_1B52BD2C8, v26, (uint64_t)sub_1B52BB0CC, 0, 257, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F68, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B52837B8, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B52837FC);
    swift_retain();
    unsigned __int8 v27 = sub_1B52BD17C((unint64_t *)&v153);
    long long v16 = v147;
    if (v147)
    {
      swift_release();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      sub_1B528374C((uint64_t)sub_1B52BD2C8, v26, (uint64_t)sub_1B52BB0CC, 0, 257, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
      sub_1B528374C((uint64_t)sub_1B52BD2C8, v26, (uint64_t)sub_1B52BB0CC, 0, 257, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
      goto LABEL_122;
    }
    unsigned __int8 v149 = v27;
    sub_1B52BD2C8(&v149, &v150);
    swift_bridgeObjectRelease();
    int64_t v9 = *((void *)&v153 + 1);
    unint64_t v10 = v153;
    uint64_t v28 = v154;
    uint64_t v156 = v150;
    sub_1B52BB0CC(&v156, (uint64_t)&v151);
    v147 = 0;
    swift_release();
    swift_bridgeObjectRelease();
    uint64_t v139 = v26;
    sub_1B528374C((uint64_t)sub_1B52BD2C8, v26, (uint64_t)sub_1B52BB0CC, 0, 257, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
    uint64_t v13 = (uint64_t)v151;
    char v140 = v152;
    uint64_t v22 = v28;
    sub_1B528374C((uint64_t)sub_1B52BD2C8, v139, (uint64_t)sub_1B52BB0CC, 0, 257, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))sub_1B5200F30, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))sub_1B5283658, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B528369C);
LABEL_33:
    swift_bridgeObjectRelease();
    if (v140) {
      goto LABEL_34;
    }
LABEL_18:
    switch(v13)
    {
      case 1:
        uint64_t v23 = *v145;
        if (*((void *)*v145 + 2) <= 1uLL) {
          goto LABEL_119;
        }
        *v145 = (char *)MEMORY[0x1E4FBC860];
        uint64_t v24 = *((void *)v23 + 4);
        uint64_t v25 = *((void *)v23 + 5);
        swift_bridgeObjectRelease();
        (*(void (**)(uint64_t, uint64_t, uint64_t))(a6 + 88))(v24, v25, a5);
        goto LABEL_3;
      case 2:
      case 12:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
LABEL_133:
        swift_bridgeObjectRelease();
        sub_1B5283604();
        swift_allocError();
        *uint64_t v137 = 2;
        return swift_willThrow();
      case 3:
        char v40 = *v145;
        if (*((void *)*v145 + 2) <= 1uLL) {
          goto LABEL_119;
        }
        *v145 = (char *)MEMORY[0x1E4FBC860];
        uint64_t v41 = *((void *)v40 + 4);
        uint64_t v42 = *((void *)v40 + 5);
        swift_bridgeObjectRelease();
        (*(void (**)(uint64_t, uint64_t, uint64_t))(a6 + 104))(v41, v42, a5);
        goto LABEL_3;
      case 4:
        long long v43 = *v145;
        if (!*((void *)*v145 + 2)) {
          goto LABEL_119;
        }
        *v145 = (char *)MEMORY[0x1E4FBC860];
        uint64_t v44 = *((void *)v43 + 4);
        swift_bridgeObjectRelease();
        char v45 = *(void (**)(uint64_t, uint64_t, uint64_t))(a6 + 56);
        uint64_t v46 = 0;
        uint64_t v47 = v44;
        goto LABEL_50;
      case 5:
        char v48 = *v145;
        if (*((void *)*v145 + 2) <= 1uLL) {
          goto LABEL_119;
        }
        *v145 = (char *)MEMORY[0x1E4FBC860];
        uint64_t v49 = *((void *)v48 + 4);
        uint64_t v50 = *((void *)v48 + 5);
        swift_bridgeObjectRelease();
        char v45 = *(void (**)(uint64_t, uint64_t, uint64_t))(a6 + 48);
        uint64_t v46 = v49;
        uint64_t v47 = v50;
        goto LABEL_50;
      case 6:
        unsigned __int16 v51 = *v145;
        if (!*((void *)*v145 + 2)) {
          goto LABEL_119;
        }
        *v145 = (char *)MEMORY[0x1E4FBC860];
        uint64_t v52 = *((void *)v51 + 4);
        swift_bridgeObjectRelease();
        char v45 = *(void (**)(uint64_t, uint64_t, uint64_t))(a6 + 48);
        uint64_t v46 = v52;
        uint64_t v47 = 0;
        goto LABEL_50;
      case 7:
        long long v53 = *v145;
        if (!*((void *)*v145 + 2)) {
          goto LABEL_119;
        }
        *v145 = (char *)MEMORY[0x1E4FBC860];
        uint64_t v54 = *((void *)v53 + 4);
        swift_bridgeObjectRelease();
        char v45 = *(void (**)(uint64_t, uint64_t, uint64_t))(a6 + 48);
        uint64_t v46 = 0;
        uint64_t v47 = v54;
        goto LABEL_50;
      case 8:
        if (*((void *)*v145 + 2) > 5uLL) {
          goto LABEL_72;
        }
        goto LABEL_119;
      case 9:
        swift_bridgeObjectRelease();
        *v145 = (char *)MEMORY[0x1E4FBC860];
        (*(void (**)(uint64_t))(a6 + 72))(a5);
        goto LABEL_3;
      case 10:
        uint64_t v55 = *v145;
        if (!*((void *)*v145 + 2)) {
          goto LABEL_127;
        }
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
          uint64_t v55 = sub_1B529359C((uint64_t)v55);
        }
        uint64_t v56 = *((void *)v55 + 2);
        if (!v56) {
          goto LABEL_140;
        }
        uint64_t v57 = v56 - 1;
        uint64_t v58 = *(void *)&v55[8 * v57 + 32];
        *((void *)v55 + 2) = v57;
        *v145 = v55;
        uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(v58, a5);
        if (v147) {
          return swift_bridgeObjectRelease();
        }
        uint64_t v61 = v59;
        unint64_t v62 = v60;
        uint64_t v63 = (uint64_t)v145[1];
        if (v63 > 9)
        {
          sub_1B5283604();
          swift_allocError();
          unsigned char *v138 = 5;
          swift_willThrow();
          swift_bridgeObjectRelease();
          return sub_1B51D4C64(v61, v62);
        }
        v145[1] = (char *)(v63 + 1);
        sub_1B52BD0E0((uint64_t)v145, v144, v59, v60);
        v147 = 0;
        sub_1B51D4C64(v61, v62);
        uint64_t v64 = v145[1];
        BOOL v65 = __OFSUB__(v64, 1);
        uint64_t v66 = v64 - 1;
        if (v65) {
          goto LABEL_147;
        }
        v145[1] = v66;
        goto LABEL_3;
      case 11:
        return swift_bridgeObjectRelease();
      case 13:
        uint64_t v67 = *v145;
        if (*((void *)*v145 + 2) <= 1uLL) {
          goto LABEL_119;
        }
        *v145 = (char *)MEMORY[0x1E4FBC860];
        uint64_t v68 = *((void *)v67 + 4);
        uint64_t v69 = *((void *)v67 + 5);
        swift_bridgeObjectRelease();
        (*(void (**)(uint64_t, uint64_t, uint64_t))(a6 + 8))(v68, v69, a5);
        goto LABEL_3;
      case 14:
        swift_bridgeObjectRelease();
        *v145 = (char *)MEMORY[0x1E4FBC860];
        (*(void (**)(uint64_t))(a6 + 32))(a5);
        goto LABEL_3;
      case 21:
        uint64_t v70 = *v145;
        if (*((void *)*v145 + 2) <= 1uLL) {
          goto LABEL_119;
        }
        *v145 = (char *)MEMORY[0x1E4FBC860];
        uint64_t v71 = *((void *)v70 + 4);
        uint64_t v72 = *((void *)v70 + 5);
        swift_bridgeObjectRelease();
        char v45 = *(void (**)(uint64_t, uint64_t, uint64_t))(a6 + 56);
        uint64_t v46 = v71;
        uint64_t v47 = v72;
        goto LABEL_50;
      case 22:
        uint64_t v73 = *v145;
        if (!*((void *)*v145 + 2)) {
          goto LABEL_119;
        }
        *v145 = (char *)MEMORY[0x1E4FBC860];
        uint64_t v74 = *((void *)v73 + 4);
        swift_bridgeObjectRelease();
        char v45 = *(void (**)(uint64_t, uint64_t, uint64_t))(a6 + 56);
        uint64_t v46 = v74;
        uint64_t v47 = 0;
LABEL_50:
        v45(v46, v47, a5);
        goto LABEL_3;
      case 30:
        if (*((void *)*v145 + 2) > 3uLL) {
          goto LABEL_72;
        }
        goto LABEL_119;
      case 31:
        if (*((void *)*v145 + 2) <= 3uLL) {
          goto LABEL_119;
        }
LABEL_72:
        *v145 = (char *)MEMORY[0x1E4FBC860];
        swift_bridgeObjectRelease();
        (*(void (**)(void))(a6 + 64))();
        goto LABEL_3;
      default:
        switch(v13)
        {
          case 256:
            (*(void (**)(uint64_t))(a6 + 80))(a5);
            goto LABEL_3;
          case 257:
            uint64_t v75 = *v145;
            if (*((void *)*v145 + 2) <= 5uLL) {
              goto LABEL_119;
            }
            *v145 = (char *)MEMORY[0x1E4FBC860];
            uint64_t v76 = *((void *)v75 + 4);
            uint64_t v77 = *((void *)v75 + 5);
            uint64_t v78 = *((void *)v75 + 6);
            uint64_t v79 = *((void *)v75 + 7);
            uint64_t v80 = *((void *)v75 + 8);
            uint64_t v81 = *((void *)v75 + 9);
            swift_bridgeObjectRelease();
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 112))(v76, v77, v78, v79, v80, v81, a5);
            goto LABEL_3;
          case 258:
            char v82 = *v145;
            if (*((void *)*v145 + 2) <= 5uLL) {
              goto LABEL_119;
            }
            *v145 = (char *)MEMORY[0x1E4FBC860];
            uint64_t v83 = *((void *)v82 + 4);
            uint64_t v84 = *((void *)v82 + 5);
            uint64_t v85 = *((void *)v82 + 6);
            uint64_t v86 = *((void *)v82 + 7);
            uint64_t v87 = *((void *)v82 + 8);
            uint64_t v88 = *((void *)v82 + 9);
            swift_bridgeObjectRelease();
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v83, v84, v85, v86, v87, v88, a5);
            goto LABEL_3;
          case 262:
            unint64_t v89 = *v145;
            if (*((void *)*v145 + 2) <= 4uLL) {
              goto LABEL_119;
            }
            *v145 = (char *)MEMORY[0x1E4FBC860];
            uint64_t v90 = *((void *)v89 + 4);
            uint64_t v91 = *((void *)v89 + 5);
            uint64_t v92 = *((void *)v89 + 6);
            uint64_t v93 = *((void *)v89 + 7);
            uint64_t v94 = *((void *)v89 + 8);
            swift_bridgeObjectRelease();
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 16))(v90, v91, v92, v93, v94, a5);
            goto LABEL_3;
          case 263:
            unint64_t v95 = *v145;
            if (*((void *)*v145 + 2) <= 3uLL) {
              goto LABEL_119;
            }
            *v145 = (char *)MEMORY[0x1E4FBC860];
            uint64_t v96 = *((void *)v95 + 4);
            uint64_t v97 = *((void *)v95 + 5);
            uint64_t v98 = *((void *)v95 + 6);
            uint64_t v99 = *((void *)v95 + 7);
            swift_bridgeObjectRelease();
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 24))(v96, v97, v98, v99, a5);
            goto LABEL_3;
          case 268:
            long long v100 = *v145;
            if (!*((void *)*v145 + 2)) {
              goto LABEL_127;
            }
            if (swift_isUniquelyReferenced_nonNull_native())
            {
              unint64_t v101 = *((void *)v100 + 2);
              if (!v101) {
                goto LABEL_141;
              }
            }
            else
            {
              long long v100 = sub_1B529359C((uint64_t)v100);
              unint64_t v101 = *((void *)v100 + 2);
              if (!v101) {
                goto LABEL_141;
              }
            }
            unint64_t v102 = v101 - 1;
            uint64_t v103 = *(void *)&v100[8 * v101 + 24];
            *((void *)v100 + 2) = v101 - 1;
            *v145 = v100;
            if (v101 == 1) {
              goto LABEL_127;
            }
            unint64_t v104 = v101 - 2;
            uint64_t v105 = *(void *)&v100[8 * v101 + 16];
            *((void *)v100 + 2) = v101 - 2;
            *v145 = v100;
            if (!v103) {
              goto LABEL_143;
            }
            if (v105 == 0x8000000000000000 && v103 == -1) {
              goto LABEL_150;
            }
            if (v101 < 0x32)
            {
              unint64_t v106 = *((void *)v100 + 3);
              if (v102 > v106 >> 1) {
                long long v100 = sub_1B51E7F50((char *)(v106 > 1), v102, 1, v100);
              }
              *((void *)v100 + 2) = v102;
              *(void *)&v100[8 * v104 + 32] = v105 / v103;
              *v145 = v100;
              goto LABEL_3;
            }
LABEL_119:
            sub_1B5283604();
            swift_allocError();
            char v127 = 4;
            goto LABEL_120;
          case 272:
            long long v107 = *v145;
            if (!*((void *)*v145 + 2)) {
              goto LABEL_127;
            }
            if (swift_isUniquelyReferenced_nonNull_native())
            {
              uint64_t v108 = *((void *)v107 + 2);
              if (!v108) {
                goto LABEL_142;
              }
            }
            else
            {
              long long v107 = sub_1B529359C((uint64_t)v107);
              uint64_t v108 = *((void *)v107 + 2);
              if (!v108) {
                goto LABEL_142;
              }
            }
            uint64_t v109 = *(void *)&v107[8 * v108 + 24];
            *((void *)v107 + 2) = v108 - 1;
            *v145 = v107;
            if (v108 == 1)
            {
LABEL_127:
              sub_1B5283604();
              swift_allocError();
              char v127 = 1;
LABEL_120:
              *long long v126 = v127;
              swift_willThrow();
              return swift_bridgeObjectRelease();
            }
            uint64_t v110 = v108 - 2;
            unint64_t v111 = *(void *)&v107[8 * v110 + 32];
            *((void *)v107 + 2) = v110;
            *v145 = v107;
            uint64_t v112 = v110 - v111;
            if (__OFSUB__(v110, v111)) {
              goto LABEL_144;
            }
            if (v110 < v112) {
              goto LABEL_145;
            }
            if (v112 < 0) {
              goto LABEL_146;
            }
            uint64_t v113 = (2 * v110) | 1;
            uint64_t v141 = *(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 128);
            uint64_t v114 = swift_bridgeObjectRetain();
            v141(v114, v107 + 32, v112, v113, v109, a5, a6);
            if (!v147)
            {
              swift_bridgeObjectRelease();
              if (v111)
              {
                if ((v111 & 0x8000000000000000) != 0) {
                  goto LABEL_148;
                }
                unint64_t v115 = *((void *)v107 + 2);
                if (v115 < v111) {
                  goto LABEL_149;
                }
                sub_1B52398A8(v115 - v111, v115);
              }
LABEL_3:
              a3 = v22;
              if (v10 == v9) {
                return swift_bridgeObjectRelease();
              }
              continue;
            }
            swift_bridgeObjectRelease();
            return swift_bridgeObjectRelease();
          case 273:
            uint64_t v116 = (*(uint64_t (**)(uint64_t))(a6 + 136))(a5);
            if (v147) {
              return swift_bridgeObjectRelease();
            }
            unsigned __int8 v117 = *v145;
            unint64_t v118 = *((void *)*v145 + 2);
            if (v118 > 0x2F) {
              goto LABEL_119;
            }
            uint64_t v119 = v116;
            v147 = 0;
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
              unsigned __int8 v117 = sub_1B51E7F50(0, v118 + 1, 1, v117);
            }
            unint64_t v121 = *((void *)v117 + 2);
            unint64_t v120 = *((void *)v117 + 3);
            if (v121 >= v120 >> 1) {
              unsigned __int8 v117 = sub_1B51E7F50((char *)(v120 > 1), v121 + 1, 1, v117);
            }
            *((void *)v117 + 2) = v121 + 1;
            *(void *)&v117[8 * v121 + 32] = v119;
            *v145 = v117;
            goto LABEL_3;
          case 289:
            long long v122 = *v145;
            if (*((void *)*v145 + 2) <= 1uLL) {
              goto LABEL_119;
            }
            *v145 = (char *)MEMORY[0x1E4FBC860];
            uint64_t v123 = *((void *)v122 + 4);
            uint64_t v124 = *((void *)v122 + 5);
            swift_bridgeObjectRelease();
            (*(void (**)(uint64_t, uint64_t, uint64_t))(a6 + 40))(v123, v124, a5);
            goto LABEL_3;
          default:
            goto LABEL_133;
        }
    }
  }
}

uint64_t sub_1B52BD0E0(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  sub_1B51D4BB8(a3, a4);
  sub_1B51D4C10();
  uint64_t v4 = sub_1B53724D8();
  sub_1B52BB10C(v4);
  return swift_bridgeObjectRelease();
}

unint64_t *sub_1B52BD17C(unint64_t *result)
{
  unint64_t v2 = *result;
  uint64_t v1 = result[1];
  if (__OFSUB__(v1, *result))
  {
    __break(1u);
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  if ((uint64_t)(v1 - *result) < 1)
  {
    sub_1B5372F98();
    swift_bridgeObjectRelease();
    sub_1B51D4D34();
    swift_allocError();
    *uint64_t v8 = 0;
    v8[1] = v2;
    v8[2] = 0xD00000000000002ALL;
    v8[3] = 0x80000001B537BD00;
    v8[4] = 0;
    return (unint64_t *)swift_willThrow();
  }
  unint64_t v3 = v2 + 1;
  if (v2 == 0x7FFFFFFFFFFFFFFFLL || v1 < (uint64_t)v3) {
    goto LABEL_16;
  }
  unint64_t v5 = result[2];
  *uint64_t result = v3;
  if ((v2 & 0x8000000000000000) == 0)
  {
    unint64_t v6 = *(void *)(v5 + 16);
    if (v6 >= v2 && v6 >= v3) {
      return (unint64_t *)*(unsigned __int8 *)(v5 + v2 + 32);
    }
    goto LABEL_18;
  }
LABEL_17:
  __break(1u);
LABEL_18:
  __break(1u);
  return result;
}

uint64_t sub_1B52BD278()
{
  return MEMORY[0x1F4186498](v0, 17, 7);
}

unsigned __int8 *sub_1B52BD288@<X0>(unsigned __int8 *result@<X0>, void *a2@<X8>)
{
  if ((*(unsigned char *)(v2 + 16) + 5) == *(unsigned __int8 *)(v2 + 16) - 251) {
    *a2 = -108 - (*result | ((unint64_t)(*(unsigned char *)(v2 + 16) + 5) << 8));
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t sub_1B52BD2B8()
{
  return MEMORY[0x1F4186498](v0, 17, 7);
}

unsigned __int8 *sub_1B52BD2C8@<X0>(unsigned __int8 *result@<X0>, void *a2@<X8>)
{
  if ((*(unsigned char *)(v2 + 16) + 9) == *(unsigned __int8 *)(v2 + 16) - 247) {
    *a2 = (*result | ((unint64_t)(*(unsigned char *)(v2 + 16) + 9) << 8)) + 108;
  }
  else {
    __break(1u);
  }
  return result;
}

unsigned char *storeEnumTagSinglePayload for CharStringError(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 6 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 6) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFA) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF9)
  {
    unsigned int v6 = ((a2 - 250) >> 8) + 1;
    *uint64_t result = a2 + 6;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1B52BD3C0);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 6;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for CharStringError()
{
  return &type metadata for CharStringError;
}

unint64_t sub_1B52BD3FC()
{
  unint64_t result = qword_1E9D49258;
  if (!qword_1E9D49258)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49258);
  }
  return result;
}

void *sub_1B52BD450@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B52BB0CC(a1, a2);
}

ValueMetadata *type metadata accessor for MaxpTable.V1Fields()
{
  return &type metadata for MaxpTable.V1Fields;
}

__n128 __swift_memcpy113_8(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  __n128 result = (__n128)a2[4];
  long long v6 = a2[5];
  long long v7 = a2[6];
  *(unsigned char *)(a1 + 112) = *((unsigned char *)a2 + 112);
  *(_OWORD *)(a1 + 80) = v6;
  *(_OWORD *)(a1 + 96) = v7;
  *(__n128 *)(a1 + 64) = result;
  return result;
}

uint64_t getEnumTagSinglePayload for MaxpTable(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 113)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for MaxpTable(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 104) = 0;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(unsigned char *)(result + 112) = 0;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 113) = v3;
  return result;
}

ValueMetadata *type metadata accessor for MaxpTable()
{
  return &type metadata for MaxpTable;
}

unint64_t sub_1B52BD524()
{
  unint64_t result = qword_1E9D49260;
  if (!qword_1E9D49260)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49260);
  }
  return result;
}

uint64_t sub_1B52BD578()
{
  return swift_getOpaqueTypeConformance2();
}

unint64_t sub_1B52BD598()
{
  unint64_t result = qword_1E9D49268;
  if (!qword_1E9D49268)
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_1E9D49270);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49268);
  }
  return result;
}

ValueMetadata *type metadata accessor for MetadataKey()
{
  return &type metadata for MetadataKey;
}

char *sub_1B52BD604(unint64_t a1, unint64_t a2)
{
  unint64_t v3 = a1;
  unint64_t v4 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x1000000000000000) != 0) {
    goto LABEL_37;
  }
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v5 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
  }
LABEL_5:
  uint64_t v6 = MEMORY[0x1E4FBC860];
  if (!v5) {
    return (char *)v6;
  }
  uint64_t v20 = MEMORY[0x1E4FBC860];
  unint64_t result = sub_1B521CE30(0, v5 & ~(v5 >> 63), 0);
  if ((v5 & 0x8000000000000000) == 0)
  {
    uint64_t v8 = (v3 >> 59) & 1;
    if ((a2 & 0x1000000000000000) == 0) {
      LOBYTE(v8) = 1;
    }
    uint64_t v9 = 4 << v8;
    uint64_t v10 = v3 & 0xFFFFFFFFFFFFLL;
    if ((a2 & 0x2000000000000000) != 0) {
      uint64_t v10 = v4;
    }
    uint64_t v17 = v3;
    unint64_t v18 = v10;
    unint64_t v11 = 15;
    while (1)
    {
      unint64_t v12 = v11;
      if ((v11 & 0xC) == v9) {
        unint64_t v12 = sub_1B51D93B4(v11, v3, a2);
      }
      unint64_t v13 = v12 >> 16;
      if (v12 >> 16 >= v18)
      {
        __break(1u);
LABEL_36:
        __break(1u);
LABEL_37:
        uint64_t v5 = sub_1B5372898();
        goto LABEL_5;
      }
      if ((a2 & 0x1000000000000000) != 0)
      {
        char v15 = sub_1B53728D8();
      }
      else if ((a2 & 0x2000000000000000) != 0)
      {
        v19[0] = v3;
        v19[1] = a2 & 0xFFFFFFFFFFFFFFLL;
        char v15 = *((unsigned char *)v19 + v13);
      }
      else
      {
        uint64_t v14 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
        if ((v3 & 0x1000000000000000) == 0) {
          uint64_t v14 = sub_1B5372FB8();
        }
        char v15 = *(unsigned char *)(v14 + v13);
      }
      uint64_t v6 = v20;
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        sub_1B521CE30(0, *(void *)(v6 + 16) + 1, 1);
        uint64_t v6 = v20;
      }
      unint64_t v4 = *(void *)(v6 + 16);
      unint64_t v16 = *(void *)(v6 + 24);
      if (v4 >= v16 >> 1)
      {
        sub_1B521CE30((char *)(v16 > 1), v4 + 1, 1);
        uint64_t v6 = v20;
      }
      *(void *)(v6 + 16) = v4 + 1;
      *(unsigned char *)(v6 + v4 + 32) = v15;
      if ((v11 & 0xC) == v9)
      {
        unint64_t v3 = v17;
        unint64_t v11 = sub_1B51D93B4(v11, v17, a2);
        if ((a2 & 0x1000000000000000) == 0) {
          goto LABEL_12;
        }
LABEL_29:
        if (v18 <= v11 >> 16) {
          goto LABEL_36;
        }
        unint64_t v11 = sub_1B53728A8();
        if (!--v5) {
          return (char *)v6;
        }
      }
      else
      {
        unint64_t v3 = v17;
        if ((a2 & 0x1000000000000000) != 0) {
          goto LABEL_29;
        }
LABEL_12:
        unint64_t v11 = (v11 & 0xFFFFFFFFFFFF0000) + 65540;
        if (!--v5) {
          return (char *)v6;
        }
      }
    }
  }
  __break(1u);
  return result;
}

unint64_t sub_1B52BD860()
{
  uint64_t v95 = sub_1B53733A8();
  uint64_t v0 = *(void *)(v95 - 8);
  MEMORY[0x1F4188790](v95);
  uint64_t v94 = (char *)&v91 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v2 = sub_1B5372238();
  uint64_t v3 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](v2);
  unint64_t v102 = (char *)&v91 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = sub_1B5372788();
  MEMORY[0x1F4188790](v5 - 8);
  sub_1B5372768();
  uint64_t v6 = sub_1B5372708();
  if (!v7) {
    return MEMORY[0x1E4FBC860];
  }
  *(void *)&long long v105 = v6;
  *((void *)&v105 + 1) = v7;
  unint64_t v8 = sub_1B52BE52C();
  uint64_t v9 = MEMORY[0x1BA998690](44, 0xE100000000000000, 0x7FFFFFFFFFFFFFFFLL, 1, MEMORY[0x1E4FBB1A0], v8);
  unint64_t result = swift_bridgeObjectRelease();
  uint64_t v101 = *(void *)(v9 + 16);
  if (!v101)
  {
    swift_bridgeObjectRelease();
    return MEMORY[0x1E4FBC860];
  }
  unint64_t v11 = 0;
  uint64_t v99 = (void (**)(char *, uint64_t))(v3 + 8);
  uint64_t v100 = v9 + 32;
  uint64_t v92 = 0;
  uint64_t v93 = (void (**)(char *, uint64_t))(v0 + 8);
  unint64_t v12 = (char *)MEMORY[0x1E4FBC860];
  uint64_t v97 = v9;
  uint64_t v98 = v2;
  while (1)
  {
    if (v11 >= *(void *)(v9 + 16))
    {
LABEL_127:
      __break(1u);
LABEL_128:
      __break(1u);
LABEL_129:
      __break(1u);
      goto LABEL_130;
    }
    unint64_t v104 = v12;
    uint64_t v13 = v100 + 32 * v11;
    uint64_t v14 = *(void *)(v13 + 16);
    uint64_t v15 = *(void *)(v13 + 24);
    long long v105 = *(_OWORD *)v13;
    uint64_t v106 = v14;
    uint64_t v107 = v15;
    swift_bridgeObjectRetain();
    unint64_t v16 = v102;
    sub_1B5372208();
    sub_1B52BE580();
    uint64_t v17 = sub_1B5372DC8();
    unint64_t v19 = v18;
    (*v99)(v16, v2);
    swift_bridgeObjectRelease();
    if ((v19 & 0x2000000000000000) != 0) {
      uint64_t v20 = HIBYTE(v19) & 0xF;
    }
    else {
      uint64_t v20 = v17 & 0xFFFFFFFFFFFFLL;
    }
    if (!v20) {
      goto LABEL_4;
    }
    swift_bridgeObjectRetain();
    sub_1B5372848();
    unint64_t v21 = sub_1B5372948();
    unint64_t v23 = v22;
    uint64_t v25 = v24;
    uint64_t v27 = v26;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    uint64_t v28 = sub_1B5372D58();
    unint64_t result = swift_bridgeObjectRelease();
    unint64_t v103 = v11;
    if (v28 != 4) {
      goto LABEL_34;
    }
    if ((v21 ^ v23) < 0x4000) {
      goto LABEL_129;
    }
    swift_bridgeObjectRetain();
    uint64_t v96 = v25;
    unint64_t v29 = sub_1B5372D68();
    unint64_t v31 = v30;
    swift_bridgeObjectRelease();
    if (sub_1B53725E8())
    {
      unint64_t result = sub_1B52C1514(v29, v31);
      if ((result & 0x100000000) != 0) {
        goto LABEL_131;
      }
      uint64_t v32 = v94;
      sub_1B53733B8();
      char v33 = sub_1B5373388();
      (*v93)(v32, v95);
      if (v33) {
        goto LABEL_24;
      }
    }
    if ((sub_1B53725D8() & 1) == 0)
    {
      swift_bridgeObjectRelease();
LABEL_33:
      uint64_t v2 = v98;
LABEL_34:
      swift_bridgeObjectRelease();
      uint64_t v43 = sub_1B5372458();
      uint64_t v45 = v44;
      swift_bridgeObjectRelease();
      unint64_t v12 = v104;
      uint64_t v46 = *((void *)v104 + 2);
      uint64_t v9 = v97;
      if (v46)
      {
        if (*((void *)v104 + 4) == v43 && *((void *)v104 + 5) == v45) {
          goto LABEL_37;
        }
        unint64_t result = sub_1B5373228();
        unint64_t v11 = v103;
        if (result) {
          goto LABEL_54;
        }
        if (v46 != 1)
        {
          uint64_t v47 = v12 + 56;
          uint64_t v48 = 1;
          do
          {
            uint64_t v49 = v48 + 1;
            if (__OFADD__(v48, 1)) {
              goto LABEL_128;
            }
            if (*(v47 - 1) == v43 && *v47 == v45) {
              goto LABEL_37;
            }
            unint64_t result = sub_1B5373228();
            if (result) {
              goto LABEL_37;
            }
            v47 += 2;
            ++v48;
          }
          while (v49 != v46);
        }
      }
      swift_bridgeObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
        unint64_t v12 = sub_1B51E7F5C(0, v46 + 1, 1, v12);
      }
      unint64_t v11 = v103;
      unint64_t v52 = *((void *)v12 + 2);
      unint64_t v51 = *((void *)v12 + 3);
      if (v52 >= v51 >> 1) {
        unint64_t v12 = sub_1B51E7F5C((char *)(v51 > 1), v52 + 1, 1, v12);
      }
      *((void *)v12 + 2) = v52 + 1;
      long long v53 = &v12[16 * v52];
      *((void *)v53 + 4) = v43;
      *((void *)v53 + 5) = v45;
LABEL_54:
      unint64_t result = swift_bridgeObjectRelease();
      goto LABEL_5;
    }
    if (sub_1B53725E8())
    {
      unint64_t result = sub_1B52C1514(v29, v31);
      if ((result & 0x100000000) != 0) {
        goto LABEL_132;
      }
      uint64_t v34 = v94;
      sub_1B53733B8();
      char v35 = sub_1B5373398();
      (*v93)(v34, v95);
      if (v35) {
        goto LABEL_24;
      }
    }
    if ((sub_1B53725D8() & 1) == 0)
    {
LABEL_24:
      swift_bridgeObjectRelease();
    }
    else
    {
      char v36 = sub_1B53725C8();
      swift_bridgeObjectRelease();
      if (v36) {
        goto LABEL_33;
      }
    }
    uint64_t v2 = v98;
    if (qword_1E9D476D0 != -1) {
      swift_once();
    }
    unint64_t v37 = off_1E9D49278;
    unint64_t v11 = v103;
    uint64_t v38 = v96;
    if (*((void *)off_1E9D49278 + 2)) {
      break;
    }
LABEL_56:
    if (v17 == v38 && v19 == v27 && !(v21 >> 16) && v20 == v23 >> 16)
    {
      swift_bridgeObjectRelease();
      uint64_t v9 = v97;
LABEL_62:
      uint64_t v55 = sub_1B52BE5D4();
      unint64_t v12 = v104;
      if (v56)
      {
        uint64_t v57 = v55;
        unint64_t v58 = v56;
        swift_bridgeObjectRelease();
        uint64_t v17 = v57;
        unint64_t v19 = v58;
      }
      uint64_t v59 = *((void *)v12 + 2);
      if (v59)
      {
        unint64_t v60 = v12 + 40;
        uint64_t v61 = *((void *)v12 + 2);
        while (1)
        {
          BOOL v62 = *(v60 - 1) == v17 && *v60 == v19;
          if (v62 || (sub_1B5373228() & 1) != 0) {
            break;
          }
          v60 += 2;
          if (!--v61) {
            goto LABEL_72;
          }
        }
      }
      else
      {
LABEL_72:
        swift_bridgeObjectRetain();
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
          unint64_t v12 = sub_1B51E7F5C(0, v59 + 1, 1, v12);
        }
        unint64_t v64 = *((void *)v12 + 2);
        unint64_t v63 = *((void *)v12 + 3);
        if (v64 >= v63 >> 1) {
          unint64_t v12 = sub_1B51E7F5C((char *)(v63 > 1), v64 + 1, 1, v12);
        }
        *((void *)v12 + 2) = v64 + 1;
        BOOL v65 = &v12[16 * v64];
        *((void *)v65 + 4) = v17;
        *((void *)v65 + 5) = v19;
      }
      goto LABEL_54;
    }
    char v54 = sub_1B53731E8();
    swift_bridgeObjectRelease();
    uint64_t v9 = v97;
    if (v54) {
      goto LABEL_62;
    }
LABEL_4:
    unint64_t result = swift_bridgeObjectRelease();
    unint64_t v12 = v104;
LABEL_5:
    if (++v11 == v101)
    {
      swift_bridgeObjectRelease();
      return (unint64_t)v12;
    }
  }
  swift_bridgeObjectRetain();
  unint64_t v39 = sub_1B5230924(v21, v23, v38, v27);
  if ((v40 & 1) == 0)
  {
    swift_bridgeObjectRelease();
    goto LABEL_56;
  }
  uint64_t v41 = *(void *)(v37[7] + 8 * v39);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease_n();
  if (sub_1B5372938() == 45 && v42 == 0xE100000000000000)
  {
    swift_bridgeObjectRelease();
    uint64_t v9 = v97;
    unint64_t v12 = v104;
    goto LABEL_79;
  }
  char v66 = sub_1B5373228();
  swift_bridgeObjectRelease();
  uint64_t v9 = v97;
  unint64_t v12 = v104;
  if (v66)
  {
LABEL_79:
    swift_bridgeObjectRetain();
    uint64_t v67 = v92;
    uint64_t v68 = sub_1B52C16E0(v41);
    uint64_t v92 = v67;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v69 = (char *)v68;
  }
  else
  {
    uint64_t v69 = (char *)v41;
  }
  swift_bridgeObjectRelease();
  int64_t v70 = *((void *)v12 + 2);
  uint64_t v71 = *((void *)v69 + 2);
  int64_t v72 = v70 + v71;
  uint64_t v73 = v69;
  if (!__OFADD__(v70, v71))
  {
    char isUniquelyReferenced_nonNull_native = (char *)swift_isUniquelyReferenced_nonNull_native();
    if (!isUniquelyReferenced_nonNull_native || v72 > *((void *)v12 + 3) >> 1)
    {
      if (v70 <= v72) {
        int64_t v75 = v70 + v71;
      }
      else {
        int64_t v75 = v70;
      }
      unint64_t v12 = sub_1B51E7F5C(isUniquelyReferenced_nonNull_native, v75, 0, v12);
    }
    uint64_t v71 = *((void *)v69 + 2);
  }
  if (!v71)
  {
LABEL_37:
    unint64_t result = swift_bridgeObjectRelease();
LABEL_38:
    unint64_t v11 = v103;
    goto LABEL_5;
  }
  uint64_t v76 = v69 + 32;
  unint64_t result = swift_bridgeObjectRetain();
  unint64_t v77 = 0;
  unint64_t v104 = v69;
  while (2)
  {
    if (v77 >= *((void *)v73 + 2))
    {
      __break(1u);
      goto LABEL_127;
    }
    uint64_t v78 = &v76[2 * v77];
    uint64_t v80 = *v78;
    uint64_t v79 = v78[1];
    uint64_t v81 = *((void *)v12 + 2);
    if (!v81)
    {
LABEL_102:
      uint64_t v83 = v12;
LABEL_103:
      swift_bridgeObjectRetain_n();
      unint64_t v12 = v83;
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
        unint64_t v12 = sub_1B51E7F5C(0, v81 + 1, 1, v83);
      }
      uint64_t v2 = v98;
      unint64_t v85 = *((void *)v12 + 2);
      unint64_t v84 = *((void *)v12 + 3);
      uint64_t v73 = v104;
      if (v85 >= v84 >> 1) {
        unint64_t v12 = sub_1B51E7F5C((char *)(v84 > 1), v85 + 1, 1, v12);
      }
      *((void *)v12 + 2) = v85 + 1;
      uint64_t v86 = &v12[16 * v85];
      *((void *)v86 + 4) = v80;
      *((void *)v86 + 5) = v79;
      unint64_t result = swift_bridgeObjectRelease();
      goto LABEL_93;
    }
    unint64_t result = *((void *)v12 + 4);
    if (result == v80 && *((void *)v12 + 5) == v79) {
      goto LABEL_93;
    }
    unint64_t result = sub_1B5373228();
    if (result) {
      goto LABEL_93;
    }
    if (v81 == 1) {
      goto LABEL_102;
    }
    if ((unint64_t result = *((void *)v12 + 6), result == v80) && *((void *)v12 + 7) == v79
      || (unint64_t result = sub_1B5373228(), (result & 1) != 0))
    {
LABEL_93:
      if (++v77 == v71)
      {
        unint64_t result = swift_bridgeObjectRelease_n();
        uint64_t v9 = v97;
        goto LABEL_38;
      }
      continue;
    }
    break;
  }
  if (v81 == 2) {
    goto LABEL_102;
  }
  uint64_t v83 = v12;
  uint64_t v87 = v12 + 72;
  uint64_t v88 = 2;
  while (1)
  {
    uint64_t v89 = v88 + 1;
    if (__OFADD__(v88, 1)) {
      break;
    }
    unint64_t result = *(v87 - 1);
    BOOL v90 = result == v80 && *v87 == v79;
    if (v90 || (unint64_t result = sub_1B5373228(), (result & 1) != 0))
    {
      unint64_t v12 = v83;
      uint64_t v2 = v98;
      uint64_t v73 = v104;
      goto LABEL_93;
    }
    v87 += 2;
    ++v88;
    if (v89 == v81) {
      goto LABEL_103;
    }
  }
LABEL_130:
  __break(1u);
LABEL_131:
  __break(1u);
LABEL_132:
  __break(1u);
  return result;
}

uint64_t sub_1B52BE310@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *(void *)(result + 8);
  uint64_t v5 = *(void *)(result + 16);
  if (__OFSUB__(v5, v4))
  {
    __break(1u);
  }
  else
  {
    *(_DWORD *)a4 = *(_DWORD *)result;
    *(void *)(a4 + 8) = v4;
    *(void *)(a4 + 16) = v5;
    *(void *)(a4 + 24) = v5 - v4;
    *(void *)(a4 + 32) = a2;
    *(void *)(a4 + 40) = a3;
    *(void *)(a4 + 48) = v4;
    *(unsigned char *)(a4 + 56) = 2;
    *(void *)(a4 + 64) = 0;
    *(unsigned char *)(a4 + 72) = 1;
  }
  return result;
}

uint64_t sub_1B52BE34C(unsigned int a1)
{
  unint64_t v1 = 0xD000000000000010;
  if (a1 == 1634758764) {
    return 0xD000000000000017;
  }
  if (a1 == 1651076196) {
    return 0x726556206C6F6F54;
  }
  sub_1B52189C4("wtrm", 4, &v6);
  if (v6 == a1) {
    return 0x72616D7265746157;
  }
  sub_1B52189C4("dlng", 4, &v5);
  if (v5 != a1)
  {
    sub_1B52189C4("slng", 4, &v4);
    if (v4 == a1) {
      return 0xD000000000000013;
    }
    else {
      return _s10FontParser7SfntTagV11descriptionSSvg_0(a1);
    }
  }
  return v1;
}

uint64_t sub_1B52BE47C()
{
  return sub_1B52BE34C(*v0);
}

BOOL sub_1B52BE484(_DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

BOOL sub_1B52BE498(_DWORD *a1, _DWORD *a2)
{
  return *a2 >= *a1;
}

BOOL sub_1B52BE4AC(_DWORD *a1, _DWORD *a2)
{
  return *a1 >= *a2;
}

BOOL sub_1B52BE4C0(_DWORD *a1, _DWORD *a2)
{
  return *a2 < *a1;
}

unint64_t sub_1B52BE4D8()
{
  unint64_t result = qword_1E9D49288;
  if (!qword_1E9D49288)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49288);
  }
  return result;
}

unint64_t sub_1B52BE52C()
{
  unint64_t result = qword_1E9D49290;
  if (!qword_1E9D49290)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49290);
  }
  return result;
}

unint64_t sub_1B52BE580()
{
  unint64_t result = qword_1E9D49298;
  if (!qword_1E9D49298)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9D49298);
  }
  return result;
}

uint64_t sub_1B52BE5D4()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = sub_1B5372788();
  MEMORY[0x1F4188790](v0 - 8);
  uint64_t v2 = (char *)&v6 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = 761556597;
  unint64_t v8 = 0xE400000000000000;
  sub_1B5372868();
  LODWORD(v7) = 0;
  uint64_t v3 = sub_1B5372A88();
  *(void *)(v3 + 16) = 157;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(_OWORD *)(v3 + 112) = 0u;
  *(_OWORD *)(v3 + 128) = 0u;
  *(_OWORD *)(v3 + 144) = 0u;
  *(_OWORD *)(v3 + 160) = 0u;
  *(_OWORD *)(v3 + 173) = 0u;
  sub_1B53727A8();
  swift_bridgeObjectRelease();
  uloc_addLikelySubtags();
  swift_release();
  if ((int)v7 <= 0
    && (uint64_t v4 = sub_1B5372A88(),
        *(void *)(v4 + 16) = 12,
        *(_DWORD *)(v4 + 40) = 0,
        *(void *)(v4 + 32) = 0,
        uloc_getLanguage(),
        swift_bridgeObjectRelease(),
        (int)v7 <= 0))
  {
    sub_1B5372758();
    return sub_1B52BEF98(v4, v2);
  }
  else
  {
    swift_bridgeObjectRelease();
    return 0;
  }
}

void sub_1B52BE7A0(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = sub_1B5372328();
  uint64_t v7 = *(void *)(v6 - 8);
  v9.n128_f64[0] = MEMORY[0x1F4188790](v6);
  unint64_t v11 = (char *)&v46 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v13 = *a1;
  uint64_t v12 = a1[1];
  if (v12 < *a1)
  {
    __break(1u);
    goto LABEL_25;
  }
  if ((v13 & 0x8000000000000000) != 0)
  {
LABEL_25:
    __break(1u);
    goto LABEL_26;
  }
  uint64_t v14 = a1[2];
  unint64_t v15 = *(void *)(v14 + 16);
  if (v15 < v13 || (uint64_t)v15 < v12) {
LABEL_26:
  }
    __break(1u);
  uint64_t v49 = v3;
  int v47 = a3;
  uint64_t v17 = v14 + v13 + 32;
  uint64_t v18 = *MEMORY[0x1E4F27740];
  unint64_t v19 = *(void (**)(char *, uint64_t, uint64_t, __n128))(v7 + 104);
  uint64_t v48 = v8;
  v19(v11, v18, v8, v9);
  swift_bridgeObjectRetain();
  sub_1B5372318();
  uint64_t v20 = v12 - v13;
  if (v20)
  {
    sub_1B53722B8();
    swift_allocObject();
    swift_retain();
    uint64_t v24 = sub_1B5372248();
    uint64_t v22 = sub_1B52458E8(v24, v20);
    unint64_t v23 = v25;
    swift_release();
  }
  else
  {
    unint64_t v21 = (void (*)(uint64_t, void))sub_1B5372318();
    v21(v17, 0);
    swift_release();
    swift_release();
    uint64_t v22 = 0;
    unint64_t v23 = 0xC000000000000000;
  }
  (*(void (**)(char *, uint64_t))(v7 + 8))(v11, v48);
  uint64_t v26 = sub_1B5372348();
  unint64_t v28 = v27;
  sub_1B51D4C64(v22, v23);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRetain();
  uint64_t v29 = v49;
  uint64_t v30 = sub_1B53724A8();
  uint64_t v32 = v31;
  uint64_t v34 = v33;
  swift_bridgeObjectRelease();
  if (v29)
  {
    sub_1B51FE548(v26, v28);
    return;
  }
  swift_bridgeObjectRelease();
  *a1 = v30;
  a1[1] = v32;
  a1[2] = v34;
  if (v28 >> 60 == 15)
  {
    sub_1B522DD1C(MEMORY[0x1E4FBC860]);
    return;
  }
  uint64_t v51 = v26;
  unint64_t v52 = v28;
  sub_1B51D4BB8(v26, v28);
  sub_1B52BEC3C();
  if (v47)
  {
    char v40 = self;
    uint64_t v36 = v51;
    unint64_t v37 = v52;
    sub_1B51D4BB8(v51, v52);
    uint64_t v41 = (void *)sub_1B53723C8();
    sub_1B51D4C64(v36, v37);
    v50[0] = 0;
    id v42 = objc_msgSend(v40, sel_JSONObjectWithData_options_error_, v41, 0, v50);

    if (!v42)
    {
      id v44 = v50[0];
      uint64_t v45 = (void *)sub_1B53722D8();

      swift_willThrow();
LABEL_22:
      sub_1B522DD1C(MEMORY[0x1E4FBC860]);
LABEL_23:
      sub_1B51FE548(v26, v28);
      sub_1B51D4C64(v36, v37);
      return;
    }
    id v43 = v50[0];
    sub_1B5372EA8();
    swift_unknownObjectRelease();
    __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47DB8);
LABEL_19:
    if (swift_dynamicCast()) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  CFAllocatorRef v35 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v36 = v51;
  unint64_t v37 = v52;
  sub_1B51D4BB8(v51, v52);
  CFDataRef v38 = (const __CFData *)sub_1B53723C8();
  sub_1B51D4C64(v36, v37);
  CFPropertyListRef v39 = CFPropertyListCreateWithData(v35, v38, 0, 0, 0);

  if (v39)
  {
    v50[0] = (id)v39;
    __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47DB8);
    goto LABEL_19;
  }
  __break(1u);
}

void sub_1B52BEC3C()
{
  uint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  switch(v2 >> 62)
  {
    case 1uLL:
      if (__OFSUB__(HIDWORD(v1), v1))
      {
        __break(1u);
LABEL_47:
        __break(1u);
LABEL_48:
        __break(1u);
LABEL_49:
        __break(1u);
LABEL_50:
        __break(1u);
      }
      uint64_t v3 = (int)v1;
      uint64_t v4 = v1 >> 32;
LABEL_6:
      if (v4 < v3) {
        goto LABEL_43;
      }
LABEL_7:
      if (v3 != v4)
      {
        uint64_t v17 = v4;
        if (qword_1E9D476D8 != -1) {
          goto LABEL_44;
        }
        if (v3 >= v4) {
          goto LABEL_35;
        }
        while (1)
        {
          unint64_t v5 = 0;
          uint64_t v6 = off_1E9D49280;
          unint64_t v7 = *((void *)off_1E9D49280 + 2);
          uint64_t v8 = v4 - 1;
          uint64_t v9 = v3;
          uint64_t v16 = v3;
          while (2)
          {
            if (v5 < v7)
            {
              uint64_t v10 = v9 + 1;
              uint64_t v12 = *v0;
              unint64_t v11 = v0[1];
              switch(v11 >> 62)
              {
                case 1uLL:
                  if (v9 >= v12 >> 32 || v9 < (int)v12) {
                    goto LABEL_38;
                  }
                  uint64_t v14 = sub_1B5372268();
                  if (!v14) {
                    goto LABEL_49;
                  }
                  uint64_t v3 = v14;
                  if (!__OFSUB__(v9, sub_1B5372298())) {
                    goto LABEL_28;
                  }
                  goto LABEL_40;
                case 2uLL:
                  if (v9 < *(void *)(v12 + 16)) {
                    goto LABEL_39;
                  }
                  if (v9 >= *(void *)(v12 + 24)) {
                    goto LABEL_41;
                  }
                  uint64_t v15 = sub_1B5372268();
                  if (!v15) {
                    goto LABEL_50;
                  }
                  uint64_t v3 = v15;
                  if (__OFSUB__(v9, sub_1B5372298())) {
                    goto LABEL_42;
                  }
LABEL_28:
                  uint64_t v3 = v16;
LABEL_29:
                  sub_1B53723A8();
                  if (v8 == v9) {
                    return;
                  }
                  unint64_t v7 = v6[2];
                  if (v5 + 1 == v7) {
                    unint64_t v5 = 0;
                  }
                  else {
                    ++v5;
                  }
                  if (v10 < v3) {
                    goto LABEL_35;
                  }
                  ++v9;
                  if (v10 >= v17) {
                    goto LABEL_35;
                  }
                  continue;
                case 3uLL:
                  goto LABEL_48;
                default:
                  if (v9 < BYTE6(v11)) {
                    goto LABEL_29;
                  }
                  goto LABEL_37;
              }
            }
            break;
          }
          while (1)
          {
            __break(1u);
LABEL_37:
            __break(1u);
LABEL_38:
            __break(1u);
LABEL_39:
            __break(1u);
LABEL_40:
            __break(1u);
LABEL_41:
            __break(1u);
LABEL_42:
            __break(1u);
LABEL_43:
            __break(1u);
LABEL_44:
            swift_once();
            uint64_t v4 = v17;
            if (v3 < v17) {
              break;
            }
LABEL_35:
            __break(1u);
          }
        }
      }
      return;
    case 2uLL:
      uint64_t v3 = *(void *)(v1 + 16);
      uint64_t v4 = *(void *)(v1 + 24);
      if (!__OFSUB__(v4, v3)) {
        goto LABEL_6;
      }
      goto LABEL_47;
    case 3uLL:
      return;
    default:
      uint64_t v3 = 0;
      uint64_t v4 = BYTE6(v2);
      goto LABEL_7;
  }
}

uint64_t sub_1B52BEF98(uint64_t a1, char *a2)
{
  uint64_t v4 = sub_1B5372788();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4);
  unint64_t v7 = (char *)&v24 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v10 = (char *)&v24 - v9;
  sub_1B5372758();
  char v11 = sub_1B5372748();
  uint64_t v12 = *(void (**)(char *, uint64_t))(v5 + 8);
  v12(v10, v4);
  (*(void (**)(char *, char *, uint64_t))(v5 + 16))(v7, a2, v4);
  if (v11)
  {
    v12(v7, v4);
    goto LABEL_4;
  }
  sub_1B5372768();
  char v13 = sub_1B5372748();
  v12(v10, v4);
  v12(v7, v4);
  if (v13)
  {
LABEL_4:
    uint64_t v14 = sub_1B52C0018(0, a1);
    if ((v15 & 1) == 0)
    {
      if ((v14 & 0x8000000000000000) == 0)
      {
        swift_bridgeObjectRetain();
        uint64_t v16 = sub_1B53727B8();
        uint64_t v18 = v17;
        swift_unknownObjectRelease();
        if (v18)
        {
          sub_1B5372758();
          char v19 = sub_1B5372748();
          v12(v10, v4);
          if (v19 & 1) != 0 || (sub_1B5372F68())
          {
            swift_bridgeObjectRelease();
LABEL_15:
            v12(a2, v4);
            return v16;
          }
          swift_bridgeObjectRelease();
        }
        goto LABEL_11;
      }
      __break(1u);
    }
    __break(1u);
    goto LABEL_18;
  }
LABEL_11:
  uint64_t v20 = sub_1B52C0018(0, a1);
  if ((v21 & 1) == 0)
  {
    id v22 = objc_msgSend(objc_allocWithZone(NSString), sel_initWithBytes_length_encoding_, a1 + 32, v20, sub_1B5372778());
    swift_bridgeObjectRelease();
    if (v22)
    {
      uint64_t v16 = sub_1B53726E8();
    }
    else
    {
      uint64_t v16 = 0;
    }
    goto LABEL_15;
  }
LABEL_18:
  uint64_t result = sub_1B53730C8();
  __break(1u);
  return result;
}

void *sub_1B52BF2BC()
{
  uint64_t result = (void *)sub_1B52BF2DC();
  off_1E9D49278 = result;
  return result;
}

uint64_t sub_1B52BF2DC()
{
  v121[2] = *(char **)MEMORY[0x1E4F143B8];
  uint64_t v0 = sub_1B5372788();
  MEMORY[0x1F4188790](v0 - 8);
  unint64_t v104 = (char *)&v99 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v105 = sub_1B522E10C(MEMORY[0x1E4FBC860]);
  v121[1] = (char *)MEMORY[0x1E4FBC870];
  uint64_t v2 = sub_1B5372A88();
  *(void *)(v2 + 16) = 157;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 128) = 0u;
  *(_OWORD *)(v2 + 144) = 0u;
  *(_OWORD *)(v2 + 160) = 0u;
  *(_OWORD *)(v2 + 173) = 0u;
  v121[0] = (char *)v2;
  uint64_t v3 = sub_1B5372A88();
  *(void *)(v3 + 16) = 12;
  *(void *)(v3 + 32) = 0;
  *(_DWORD *)(v3 + 40) = 0;
  uint64_t v4 = sub_1B5372A88();
  *(void *)(v4 + 16) = 6;
  *(_DWORD *)(v4 + 32) = 0;
  uint64_t v106 = v4;
  *(_WORD *)(v4 + 36) = 0;
  uint64_t v5 = MEMORY[0x1BA997D00]();
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(v5 + 16);
  if (v7)
  {
    uint64_t v101 = 0;
    unint64_t v100 = 0;
    unint64_t v103 = 0;
    uint64_t v102 = 0;
    unint64_t v8 = 0;
    uint64_t v112 = 0;
    uint64_t v107 = v5 + 32;
    uint64_t v108 = v7;
    uint64_t v109 = v5;
    while (1)
    {
      if (v8 >= *(void *)(v6 + 16))
      {
        __break(1u);
LABEL_89:
        __break(1u);
LABEL_90:
        __break(1u);
LABEL_91:
        __break(1u);
LABEL_92:
        __break(1u);
      }
      swift_bridgeObjectRetain();
      unint64_t v12 = sub_1B5372948();
      unint64_t v14 = v13;
      unint64_t v16 = v15;
      unint64_t v18 = v17;
      swift_bridgeObjectRelease();
      unint64_t v19 = v18 >> 14;
      unint64_t v118 = v12;
      if (v12 >> 14 == v18 >> 14) {
        goto LABEL_34;
      }
      unint64_t v117 = v12 >> 14;
      swift_bridgeObjectRetain();
      unint64_t v115 = v18;
      unint64_t v116 = v14;
      BOOL v21 = sub_1B5372D68() == 95 && v20 == 0xE100000000000000;
      unint64_t v114 = v16;
      if (v21) {
        break;
      }
      char v22 = sub_1B5373228();
      swift_bridgeObjectRelease();
      if (v22) {
        goto LABEL_14;
      }
      unint64_t v18 = v115;
      unint64_t v14 = v116;
      unint64_t v78 = (unint64_t)sub_1B5372D48() >> 14;
      if (v78 != v19)
      {
        if (sub_1B5372D68() == 95 && v79 == 0xE100000000000000)
        {
LABEL_60:
          swift_bridgeObjectRelease();
        }
        else
        {
          while (1)
          {
            char v81 = sub_1B5373228();
            swift_bridgeObjectRelease();
            if (v81) {
              break;
            }
            unint64_t v18 = v115;
            unint64_t v14 = v116;
            unint64_t v16 = v114;
            unint64_t v78 = (unint64_t)sub_1B5372D48() >> 14;
            if (v78 == v19) {
              goto LABEL_51;
            }
            if (sub_1B5372D68() == 95 && v82 == 0xE100000000000000) {
              goto LABEL_60;
            }
          }
          unint64_t v16 = v114;
        }
        swift_bridgeObjectRelease();
        unint64_t v14 = v116;
        if (v78 < v117) {
          goto LABEL_89;
        }
        goto LABEL_15;
      }
LABEL_51:
      swift_bridgeObjectRelease();
      uint64_t v7 = v108;
      uint64_t v6 = v109;
LABEL_34:
      swift_bridgeObjectRetain();
      unint64_t v42 = v118;
      unint64_t v43 = v18;
      char v44 = sub_1B52C019C((uint64_t)v120, v118, v18, v14, v16);
      swift_bridgeObjectRelease();
      if ((v44 & 1) == 0) {
        goto LABEL_35;
      }
      int v119 = 0;
      swift_bridgeObjectRetain();
      uint64_t v9 = MEMORY[0x1BA998090](v42, v43, v14, v16);
      uint64_t v10 = v112;
      sub_1B52C15F4(v9, v11, v121);
      uint64_t v112 = v10;
      swift_bridgeObjectRelease_n();
      swift_bridgeObjectRelease();
      if (v119 > 0) {
        goto LABEL_4;
      }
      unint64_t v45 = *(void *)(v3 + 16);
      if (v45 >> 31) {
        goto LABEL_90;
      }
      swift_bridgeObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
        uint64_t v3 = (uint64_t)sub_1B51E8814(0, v45, 0, (char *)v3);
      }
      uloc_getLanguage();
      swift_bridgeObjectRelease();
      if (v119 > 0) {
        goto LABEL_4;
      }
      uint64_t v46 = (char *)v106;
      unint64_t v47 = *(void *)(v106 + 16);
      if (v47 >> 31) {
        goto LABEL_91;
      }
      swift_bridgeObjectRetain();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
        uint64_t v46 = sub_1B51E8814(0, v47, 0, v46);
      }
      uint64_t v106 = (uint64_t)v46;
      uloc_getScript();
      swift_bridgeObjectRelease();
      if (v119 > 0) {
        goto LABEL_4;
      }
      swift_bridgeObjectRetain();
      uint64_t v48 = v104;
      sub_1B5372758();
      uint64_t v49 = sub_1B52BEF98(v3, v48);
      if (!v50) {
        goto LABEL_4;
      }
      uint64_t v51 = v49;
      uint64_t v52 = v50;
      uint64_t v53 = v106;
      swift_bridgeObjectRetain();
      char v54 = v104;
      sub_1B5372758();
      uint64_t v55 = sub_1B52BEF98(v53, v54);
      if (v56)
      {
        uint64_t v57 = v55;
        uint64_t v58 = v56;
        unint64_t v110 = v8;
        uint64_t v111 = v3;
        swift_bridgeObjectRetain();
        uint64_t v59 = sub_1B5372948();
        unint64_t v61 = v60;
        uint64_t v63 = v62;
        uint64_t v65 = v64;
        swift_bridgeObjectRelease();
        uint64_t v66 = swift_allocObject();
        *(void *)(v66 + 16) = v57;
        *(void *)(v66 + 24) = v58;
        sub_1B51D4E64((uint64_t)v101);
        uint64_t v67 = swift_allocObject();
        *(void *)(v67 + 16) = sub_1B52C1834;
        *(void *)(v67 + 24) = v66;
        unint64_t v117 = v66;
        sub_1B51D4E64((uint64_t)v103);
        unint64_t v68 = v105;
        char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
        v120[0] = v68;
        unint64_t v118 = v65;
        unint64_t v71 = sub_1B5230924(v59, v61, v63, v65);
        uint64_t v72 = *(void *)(v68 + 16);
        BOOL v73 = (v70 & 1) == 0;
        uint64_t v74 = v72 + v73;
        if (__OFADD__(v72, v73)) {
          goto LABEL_92;
        }
        char v75 = v70;
        if (*(void *)(v68 + 24) >= v74)
        {
          if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
            sub_1B5236A88();
          }
        }
        else
        {
          sub_1B5232328(v74, isUniquelyReferenced_nonNull_native);
          unint64_t v76 = sub_1B5230924(v59, v61, v63, v118);
          if ((v75 & 1) != (v77 & 1))
          {
            uint64_t result = sub_1B5373288();
            __break(1u);
            return result;
          }
          unint64_t v71 = v76;
        }
        uint64_t v83 = (void *)v120[0];
        swift_bridgeObjectRelease();
        uint64_t v84 = swift_bridgeObjectRetain();
        if ((v75 & 1) == 0)
        {
          uint64_t v85 = (*(uint64_t (**)(uint64_t))(v67 + 16))(v84);
          sub_1B523335C(v71, v59, v61, v63, v118, v85, v83);
          swift_bridgeObjectRetain();
        }
        uint64_t v86 = v83[7];
        unint64_t v105 = (unint64_t)v83;
        swift_bridgeObjectRelease();
        uint64_t v87 = *(char **)(v86 + 8 * v71);
        uint64_t v88 = *((void *)v87 + 2);
        if (v88)
        {
          uint64_t v89 = v87 + 40;
          uint64_t v3 = v111;
          uint64_t v6 = v109;
          while (1)
          {
            BOOL v90 = *(v89 - 1) == v51 && v52 == *v89;
            if (v90 || (sub_1B5373228() & 1) != 0) {
              break;
            }
            v89 += 2;
            if (!--v88)
            {
              uint64_t v87 = *(char **)(v86 + 8 * v71);
              goto LABEL_79;
            }
          }
        }
        else
        {
          uint64_t v3 = v111;
          uint64_t v6 = v109;
LABEL_79:
          swift_bridgeObjectRetain();
          char v91 = swift_isUniquelyReferenced_nonNull_native();
          *(void *)(v86 + 8 * v71) = v87;
          uint64_t v92 = v6;
          if ((v91 & 1) == 0)
          {
            uint64_t v87 = sub_1B51E7F5C(0, *((void *)v87 + 2) + 1, 1, v87);
            *(void *)(v86 + 8 * v71) = v87;
          }
          unint64_t v94 = *((void *)v87 + 2);
          unint64_t v93 = *((void *)v87 + 3);
          if (v94 >= v93 >> 1)
          {
            uint64_t v87 = sub_1B51E7F5C((char *)(v93 > 1), v94 + 1, 1, v87);
            *(void *)(v86 + 8 * v71) = v87;
          }
          *((void *)v87 + 2) = v94 + 1;
          uint64_t v95 = &v87[16 * v94];
          *((void *)v95 + 4) = v51;
          *((void *)v95 + 5) = v52;
          uint64_t v6 = v92;
        }
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        unint64_t v103 = sub_1B52C184C;
        uint64_t v101 = sub_1B52C1834;
        unint64_t v100 = v117;
        uint64_t v102 = v67;
        uint64_t v7 = v108;
        unint64_t v8 = v110;
      }
      else
      {
LABEL_35:
        swift_bridgeObjectRelease();
      }
LABEL_4:
      if (++v8 == v7)
      {
        swift_bridgeObjectRelease();
        uint64_t v96 = v103;
        uint64_t v97 = v101;
        goto LABEL_87;
      }
    }
    swift_bridgeObjectRelease();
LABEL_14:
    swift_bridgeObjectRelease();
    unint64_t v14 = v116;
LABEL_15:
    unint64_t v110 = v8;
    uint64_t v111 = v3;
    swift_bridgeObjectRetain();
    unint64_t v23 = sub_1B5372D78();
    unint64_t v18 = v24;
    unint64_t v26 = v25;
    unint64_t v28 = v27;
    swift_bridgeObjectRelease();
    uint64_t v29 = 0;
    unint64_t v30 = v18 >> 14;
    unint64_t v117 = v23 >> 14;
    while (1)
    {
      unint64_t v31 = *((void *)&unk_1F0DF4DE0 + 2 * v29 + 5);
      uint64_t v32 = HIBYTE(v31) & 0xF;
      if ((v31 & 0x2000000000000000) == 0) {
        uint64_t v32 = *((void *)&unk_1F0DF4DE0 + 2 * v29 + 4) & 0xFFFFFFFFFFFFLL;
      }
      v120[0] = *((void *)&unk_1F0DF4DE0 + 2 * v29 + 4);
      v120[1] = v31;
      v120[2] = 0;
      v120[3] = v32;
      swift_bridgeObjectRetain_n();
      if (v117 != v30) {
        break;
      }
LABEL_27:
      sub_1B5372888();
      uint64_t v41 = v40;
      swift_bridgeObjectRelease();
      if (!v41) {
        goto LABEL_33;
      }
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
LABEL_29:
      if (++v29 == 3)
      {
        swift_arrayDestroy();
        swift_bridgeObjectRelease();
        unint64_t v118 = v23;
        unint64_t v14 = v26;
        unint64_t v16 = v28;
        unint64_t v8 = v110;
        uint64_t v3 = v111;
        uint64_t v7 = v108;
        uint64_t v6 = v109;
        goto LABEL_34;
      }
    }
    uint64_t v113 = v29;
    swift_bridgeObjectRetain();
    while (1)
    {
      uint64_t v34 = sub_1B5372D68();
      uint64_t v36 = v35;
      unint64_t v37 = sub_1B5372D48();
      uint64_t v38 = sub_1B5372888();
      if (!v39) {
        break;
      }
      if (v34 == v38 && v39 == v36)
      {
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (v30 == v37 >> 14)
        {
LABEL_26:
          swift_bridgeObjectRelease();
          uint64_t v29 = v113;
          unint64_t v16 = v114;
          unint64_t v14 = v116;
          goto LABEL_27;
        }
      }
      else
      {
        char v33 = sub_1B5373228();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if ((v33 & 1) == 0)
        {
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          uint64_t v29 = v113;
          unint64_t v16 = v114;
          unint64_t v14 = v116;
          goto LABEL_29;
        }
        if (v30 == v37 >> 14) {
          goto LABEL_26;
        }
      }
    }
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    unint64_t v16 = v114;
    unint64_t v14 = v116;
LABEL_33:
    swift_bridgeObjectRelease();
    swift_arrayDestroy();
    swift_bridgeObjectRelease();
    unint64_t v8 = v110;
    uint64_t v3 = v111;
    uint64_t v7 = v108;
    uint64_t v6 = v109;
    unint64_t v18 = v115;
    goto LABEL_34;
  }
  swift_bridgeObjectRelease();
  uint64_t v97 = 0;
  uint64_t v96 = 0;
LABEL_87:
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B51D4E64((uint64_t)v97);
  sub_1B51D4E64((uint64_t)v96);
  return v105;
}

void sub_1B52BFED4(uint64_t a1, char **a2)
{
  uint64_t v2 = *a2;
  unint64_t v3 = *((void *)*a2 + 2);
  if (v3 >> 31)
  {
    __break(1u);
  }
  else
  {
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    *a2 = v2;
    if ((isUniquelyReferenced_nonNull_native & 1) == 0) {
      uint64_t v2 = sub_1B51E8814(0, v3, 0, v2);
    }
    *a2 = v2;
    uloc_addLikelySubtags();
  }
}

uint64_t sub_1B52BFF68()
{
  uint64_t v0 = sub_1B52BE5D4();
  if (!v1) {
    return MEMORY[0x1E4FBC860];
  }
  uint64_t v2 = v0;
  uint64_t v3 = v1;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D47B20);
  uint64_t result = swift_allocObject();
  *(_OWORD *)(result + 16) = xmmword_1B538C0E0;
  *(void *)(result + 32) = v2;
  *(void *)(result + 40) = v3;
  return result;
}

char *sub_1B52BFFC8()
{
  uint64_t result = sub_1B52BD604(0xD000000000000CAALL, 0x80000001B537D010);
  off_1E9D49280 = result;
  return result;
}

uint64_t sub_1B52C0018(unsigned __int8 a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (!v2) {
    return 0;
  }
  if (*(unsigned __int8 *)(a2 + 32) == a1) {
    return 0;
  }
  if (v2 == 1) {
    return 0;
  }
  if (*(unsigned __int8 *)(a2 + 33) == a1) {
    return 1;
  }
  uint64_t v4 = 0;
  uint64_t v5 = v2 - 2;
  while (v5 != v4)
  {
    int v6 = *(unsigned __int8 *)(a2 + 34 + v4++);
    if (v6 == a1) {
      return v4 + 1;
    }
  }
  return 0;
}

uint64_t sub_1B52C00A0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = sub_1B53732E8();
  uint64_t v8 = -1 << *(unsigned char *)(v6 + 32);
  unint64_t v9 = v7 & ~v8;
  if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9) & 1) == 0)
  {
LABEL_7:
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    uint64_t v14 = *v3;
    *uint64_t v3 = 0x8000000000000000;
    sub_1B52C0954(a2, v9, isUniquelyReferenced_nonNull_native);
    *uint64_t v3 = v14;
    swift_bridgeObjectRelease();
    uint64_t result = 1;
    goto LABEL_8;
  }
  uint64_t v10 = *(void *)(v6 + 48);
  if (*(void *)(v10 + 8 * v9) != a2)
  {
    uint64_t v11 = ~v8;
    do
    {
      unint64_t v9 = (v9 + 1) & v11;
      if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v9) & 1) == 0) {
        goto LABEL_7;
      }
    }
    while (*(void *)(v10 + 8 * v9) != a2);
  }
  uint64_t result = 0;
LABEL_8:
  *a1 = a2;
  return result;
}

uint64_t sub_1B52C019C(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v11 = *v5;
  swift_bridgeObjectRetain();
  uint64_t v12 = sub_1B53725A8();
  uint64_t v13 = -1 << *(unsigned char *)(v11 + 32);
  unint64_t v14 = v12 & ~v13;
  uint64_t v32 = a1;
  if ((*(void *)(v11 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14))
  {
    uint64_t v15 = *(void *)(v11 + 48);
    unint64_t v16 = (void *)(v15 + 32 * v14);
    unint64_t v17 = a2 >> 16;
    unint64_t v18 = a3 >> 16;
    BOOL v21 = v16[2] == a4 && v16[3] == a5 && *v16 >> 16 == v17 && v16[1] >> 16 == v18;
    if (v21 || (sub_1B53731E8() & 1) != 0)
    {
LABEL_25:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      uint64_t v26 = *(void *)(*v31 + 48) + 32 * v14;
      uint64_t v28 = *(void *)(v26 + 16);
      uint64_t v27 = *(void *)(v26 + 24);
      *(_OWORD *)uint64_t v32 = *(_OWORD *)v26;
      *(void *)(v32 + 16) = v28;
      *(void *)(v32 + 24) = v27;
      swift_bridgeObjectRetain();
      return 0;
    }
    while (1)
    {
      unint64_t v14 = (v14 + 1) & ~v13;
      if (((*(void *)(v11 + 56 + ((v14 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v14) & 1) == 0) {
        break;
      }
      char v22 = (void *)(v15 + 32 * v14);
      BOOL v25 = v22[2] == a4 && v22[3] == a5 && *v22 >> 16 == v17 && v22[1] >> 16 == v18;
      if (v25 || (sub_1B53731E8() & 1) != 0) {
        goto LABEL_25;
      }
    }
  }
  swift_bridgeObjectRelease();
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v33 = *v31;
  *unint64_t v31 = 0x8000000000000000;
  swift_bridgeObjectRetain();
  sub_1B52C0A78(a2, a3, a4, a5, v14, isUniquelyReferenced_nonNull_native);
  *unint64_t v31 = v33;
  swift_bridgeObjectRelease();
  *(void *)uint64_t v32 = a2;
  *(void *)(v32 + 8) = a3;
  uint64_t result = 1;
  *(void *)(v32 + 16) = a4;
  *(void *)(v32 + 24) = a5;
  return result;
}

uint64_t sub_1B52C03C4()
{
  uint64_t v1 = v0;
  uint64_t v2 = *v0;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D492A8);
  uint64_t result = sub_1B5372F38();
  uint64_t v4 = result;
  if (*(void *)(v2 + 16))
  {
    int64_t v5 = 0;
    uint64_t v6 = (uint64_t *)(v2 + 56);
    uint64_t v7 = 1 << *(unsigned char *)(v2 + 32);
    uint64_t v26 = -1 << v7;
    uint64_t v27 = v1;
    if (v7 < 64) {
      uint64_t v8 = ~(-1 << v7);
    }
    else {
      uint64_t v8 = -1;
    }
    unint64_t v9 = v8 & *(void *)(v2 + 56);
    uint64_t v28 = 1 << *(unsigned char *)(v2 + 32);
    int64_t v10 = (unint64_t)(v7 + 63) >> 6;
    uint64_t v11 = result + 56;
    while (1)
    {
      if (v9)
      {
        unint64_t v13 = __clz(__rbit64(v9));
        v9 &= v9 - 1;
        unint64_t v14 = v13 | (v5 << 6);
      }
      else
      {
        int64_t v15 = v5 + 1;
        if (__OFADD__(v5, 1))
        {
LABEL_38:
          __break(1u);
LABEL_39:
          __break(1u);
          return result;
        }
        if (v15 >= v10) {
          goto LABEL_33;
        }
        unint64_t v16 = v6[v15];
        ++v5;
        if (!v16)
        {
          int64_t v5 = v15 + 1;
          if (v15 + 1 >= v10) {
            goto LABEL_33;
          }
          unint64_t v16 = v6[v5];
          if (!v16)
          {
            int64_t v5 = v15 + 2;
            if (v15 + 2 >= v10) {
              goto LABEL_33;
            }
            unint64_t v16 = v6[v5];
            if (!v16)
            {
              int64_t v17 = v15 + 3;
              if (v17 >= v10)
              {
LABEL_33:
                if (v28 >= 64) {
                  bzero((void *)(v2 + 56), 8 * v10);
                }
                else {
                  *uint64_t v6 = v26;
                }
                uint64_t v1 = v27;
                *(void *)(v2 + 16) = 0;
                break;
              }
              unint64_t v16 = v6[v17];
              if (!v16)
              {
                while (1)
                {
                  int64_t v5 = v17 + 1;
                  if (__OFADD__(v17, 1)) {
                    goto LABEL_39;
                  }
                  if (v5 >= v10) {
                    goto LABEL_33;
                  }
                  unint64_t v16 = v6[v5];
                  ++v17;
                  if (v16) {
                    goto LABEL_23;
                  }
                }
              }
              int64_t v5 = v17;
            }
          }
        }
LABEL_23:
        unint64_t v9 = (v16 - 1) & v16;
        unint64_t v14 = __clz(__rbit64(v16)) + (v5 << 6);
      }
      uint64_t v18 = *(void *)(*(void *)(v2 + 48) + 8 * v14);
      uint64_t result = sub_1B53732E8();
      uint64_t v19 = -1 << *(unsigned char *)(v4 + 32);
      unint64_t v20 = result & ~v19;
      unint64_t v21 = v20 >> 6;
      if (((-1 << v20) & ~*(void *)(v11 + 8 * (v20 >> 6))) != 0)
      {
        unint64_t v12 = __clz(__rbit64((-1 << v20) & ~*(void *)(v11 + 8 * (v20 >> 6)))) | v20 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v22 = 0;
        unint64_t v23 = (unint64_t)(63 - v19) >> 6;
        do
        {
          if (++v21 == v23 && (v22 & 1) != 0)
          {
            __break(1u);
            goto LABEL_38;
          }
          BOOL v24 = v21 == v23;
          if (v21 == v23) {
            unint64_t v21 = 0;
          }
          v22 |= v24;
          uint64_t v25 = *(void *)(v11 + 8 * v21);
        }
        while (v25 == -1);
        unint64_t v12 = __clz(__rbit64(~v25)) + (v21 << 6);
      }
      *(void *)(v11 + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v12;
      *(void *)(*(void *)(v4 + 48) + 8 * v12) = v18;
      ++*(void *)(v4 + 16);
    }
  }
  uint64_t result = swift_release();
  *uint64_t v1 = v4;
  return result;
}

uint64_t sub_1B52C0648()
{
  uint64_t v1 = v0;
  uint64_t v2 = *v0;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D492A0);
  uint64_t v3 = sub_1B5372F38();
  uint64_t v4 = v3;
  if (*(void *)(v2 + 16))
  {
    uint64_t v5 = 1 << *(unsigned char *)(v2 + 32);
    uint64_t v33 = (void *)(v2 + 56);
    if (v5 < 64) {
      uint64_t v6 = ~(-1 << v5);
    }
    else {
      uint64_t v6 = -1;
    }
    unint64_t v7 = v6 & *(void *)(v2 + 56);
    int64_t v32 = (unint64_t)(v5 + 63) >> 6;
    uint64_t v8 = v3 + 56;
    uint64_t result = swift_retain();
    int64_t v10 = 0;
    while (1)
    {
      if (v7)
      {
        unint64_t v13 = __clz(__rbit64(v7));
        v7 &= v7 - 1;
        unint64_t v14 = v13 | (v10 << 6);
      }
      else
      {
        int64_t v15 = v10 + 1;
        if (__OFADD__(v10, 1))
        {
LABEL_38:
          __break(1u);
LABEL_39:
          __break(1u);
          return result;
        }
        if (v15 >= v32) {
          goto LABEL_33;
        }
        unint64_t v16 = v33[v15];
        ++v10;
        if (!v16)
        {
          int64_t v10 = v15 + 1;
          if (v15 + 1 >= v32) {
            goto LABEL_33;
          }
          unint64_t v16 = v33[v10];
          if (!v16)
          {
            int64_t v10 = v15 + 2;
            if (v15 + 2 >= v32) {
              goto LABEL_33;
            }
            unint64_t v16 = v33[v10];
            if (!v16)
            {
              int64_t v17 = v15 + 3;
              if (v17 >= v32)
              {
LABEL_33:
                swift_release();
                uint64_t v1 = v0;
                uint64_t v31 = 1 << *(unsigned char *)(v2 + 32);
                if (v31 > 63) {
                  bzero(v33, ((unint64_t)(v31 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
                }
                else {
                  *uint64_t v33 = -1 << v31;
                }
                *(void *)(v2 + 16) = 0;
                break;
              }
              unint64_t v16 = v33[v17];
              if (!v16)
              {
                while (1)
                {
                  int64_t v10 = v17 + 1;
                  if (__OFADD__(v17, 1)) {
                    goto LABEL_39;
                  }
                  if (v10 >= v32) {
                    goto LABEL_33;
                  }
                  unint64_t v16 = v33[v10];
                  ++v17;
                  if (v16) {
                    goto LABEL_23;
                  }
                }
              }
              int64_t v10 = v17;
            }
          }
        }
LABEL_23:
        unint64_t v7 = (v16 - 1) & v16;
        unint64_t v14 = __clz(__rbit64(v16)) + (v10 << 6);
      }
      uint64_t v18 = v2;
      uint64_t v19 = (uint64_t *)(*(void *)(v2 + 48) + 32 * v14);
      uint64_t v21 = *v19;
      uint64_t v20 = v19[1];
      uint64_t v23 = v19[2];
      uint64_t v22 = v19[3];
      uint64_t result = sub_1B53725A8();
      uint64_t v24 = -1 << *(unsigned char *)(v4 + 32);
      unint64_t v25 = result & ~v24;
      unint64_t v26 = v25 >> 6;
      if (((-1 << v25) & ~*(void *)(v8 + 8 * (v25 >> 6))) != 0)
      {
        unint64_t v11 = __clz(__rbit64((-1 << v25) & ~*(void *)(v8 + 8 * (v25 >> 6)))) | v25 & 0x7FFFFFFFFFFFFFC0;
      }
      else
      {
        char v27 = 0;
        unint64_t v28 = (unint64_t)(63 - v24) >> 6;
        do
        {
          if (++v26 == v28 && (v27 & 1) != 0)
          {
            __break(1u);
            goto LABEL_38;
          }
          BOOL v29 = v26 == v28;
          if (v26 == v28) {
            unint64_t v26 = 0;
          }
          v27 |= v29;
          uint64_t v30 = *(void *)(v8 + 8 * v26);
        }
        while (v30 == -1);
        unint64_t v11 = __clz(__rbit64(~v30)) + (v26 << 6);
      }
      *(void *)(v8 + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v11;
      unint64_t v12 = (void *)(*(void *)(v4 + 48) + 32 * v11);
      *unint64_t v12 = v21;
      v12[1] = v20;
      _OWORD v12[2] = v23;
      v12[3] = v22;
      ++*(void *)(v4 + 16);
      uint64_t v2 = v18;
    }
  }
  uint64_t result = swift_release();
  *uint64_t v1 = v4;
  return result;
}

uint64_t sub_1B52C0954(uint64_t result, unint64_t a2, char a3)
{
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 > v6 && (a3 & 1) != 0) {
    goto LABEL_14;
  }
  if (a3)
  {
    sub_1B52C03C4();
  }
  else
  {
    if (v7 > v6)
    {
      uint64_t result = (uint64_t)sub_1B52C0C70();
      goto LABEL_14;
    }
    sub_1B52C0FC4();
  }
  uint64_t v8 = *v3;
  uint64_t result = sub_1B53732E8();
  uint64_t v9 = -1 << *(unsigned char *)(v8 + 32);
  a2 = result & ~v9;
  if ((*(void *)(v8 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2))
  {
    uint64_t v10 = *(void *)(v8 + 48);
    if (*(void *)(v10 + 8 * a2) == v5)
    {
LABEL_13:
      uint64_t result = sub_1B5373278();
      __break(1u);
    }
    else
    {
      uint64_t v11 = ~v9;
      while (1)
      {
        a2 = (a2 + 1) & v11;
        if (((*(void *)(v8 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a2) & 1) == 0) {
          break;
        }
        if (*(void *)(v10 + 8 * a2) == v5) {
          goto LABEL_13;
        }
      }
    }
  }
LABEL_14:
  uint64_t v12 = *v3;
  *(void *)(*v3 + 8 * (a2 >> 6) + 56) |= 1 << a2;
  *(void *)(*(void *)(v12 + 48) + 8 * a2) = v5;
  uint64_t v13 = *(void *)(v12 + 16);
  BOOL v14 = __OFADD__(v13, 1);
  uint64_t v15 = v13 + 1;
  if (v14) {
    __break(1u);
  }
  else {
    *(void *)(v12 + 16) = v15;
  }
  return result;
}

uint64_t sub_1B52C0A78(uint64_t result, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, char a6)
{
  unint64_t v7 = v6;
  unint64_t v11 = result;
  unint64_t v12 = *(void *)(*v6 + 16);
  unint64_t v13 = *(void *)(*v6 + 24);
  if (v13 > v12 && (a6 & 1) != 0) {
    goto LABEL_34;
  }
  if (a6)
  {
    sub_1B52C0648();
  }
  else
  {
    if (v13 > v12)
    {
      uint64_t result = (uint64_t)sub_1B52C0E08();
      goto LABEL_34;
    }
    sub_1B52C1228();
  }
  uint64_t v14 = *v6;
  uint64_t result = sub_1B53725A8();
  uint64_t v15 = -1 << *(unsigned char *)(v14 + 32);
  a5 = result & ~v15;
  uint64_t v16 = v14 + 56;
  if ((*(void *)(v14 + 56 + ((a5 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a5))
  {
    uint64_t v17 = *(void *)(v14 + 48);
    uint64_t v18 = (void *)(v17 + 32 * a5);
    unint64_t v19 = v11 >> 16;
    unint64_t v20 = a2 >> 16;
    BOOL v23 = v18[2] == a3 && v18[3] == a4 && *v18 >> 16 == v19 && v18[1] >> 16 == v20;
    if (v23 || (uint64_t result = sub_1B53731E8(), (result & 1) != 0))
    {
LABEL_33:
      uint64_t result = sub_1B5373278();
      __break(1u);
    }
    else
    {
      uint64_t v24 = ~v15;
      while (1)
      {
        a5 = (a5 + 1) & v24;
        if (((*(void *)(v16 + ((a5 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a5) & 1) == 0) {
          break;
        }
        unint64_t v25 = (void *)(v17 + 32 * a5);
        if (v25[2] != a3 || v25[3] != a4 || *v25 >> 16 != v19 || v25[1] >> 16 != v20)
        {
          uint64_t result = sub_1B53731E8();
          if ((result & 1) == 0) {
            continue;
          }
        }
        goto LABEL_33;
      }
    }
  }
LABEL_34:
  uint64_t v29 = *v7;
  *(void *)(*v7 + 8 * (a5 >> 6) + 56) |= 1 << a5;
  uint64_t v30 = (unint64_t *)(*(void *)(v29 + 48) + 32 * a5);
  *uint64_t v30 = v11;
  v30[1] = a2;
  v30[2] = a3;
  v30[3] = a4;
  uint64_t v31 = *(void *)(v29 + 16);
  BOOL v32 = __OFADD__(v31, 1);
  uint64_t v33 = v31 + 1;
  if (v32) {
    __break(1u);
  }
  else {
    *(void *)(v29 + 16) = v33;
  }
  return result;
}

void *sub_1B52C0C70()
{
  uint64_t v1 = v0;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D492A8);
  uint64_t v2 = *v0;
  uint64_t v3 = sub_1B5372F28();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_28:
    uint64_t result = (void *)swift_release();
    *uint64_t v1 = v4;
    return result;
  }
  uint64_t result = (void *)(v3 + 56);
  uint64_t v6 = v2 + 56;
  unint64_t v7 = (unint64_t)((1 << *(unsigned char *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 56 + 8 * v7) {
    uint64_t result = memmove(result, (const void *)(v2 + 56), 8 * v7);
  }
  int64_t v9 = 0;
  *(void *)(v4 + 16) = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 56);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v16 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_30;
    }
    if (v16 >= v13) {
      goto LABEL_28;
    }
    unint64_t v17 = *(void *)(v6 + 8 * v16);
    ++v9;
    if (!v17)
    {
      int64_t v9 = v16 + 1;
      if (v16 + 1 >= v13) {
        goto LABEL_28;
      }
      unint64_t v17 = *(void *)(v6 + 8 * v9);
      if (!v17)
      {
        int64_t v9 = v16 + 2;
        if (v16 + 2 >= v13) {
          goto LABEL_28;
        }
        unint64_t v17 = *(void *)(v6 + 8 * v9);
        if (!v17) {
          break;
        }
      }
    }
LABEL_27:
    unint64_t v12 = (v17 - 1) & v17;
    unint64_t v15 = __clz(__rbit64(v17)) + (v9 << 6);
LABEL_12:
    *(void *)(*(void *)(v4 + 48) + 8 * v15) = *(void *)(*(void *)(v2 + 48) + 8 * v15);
  }
  int64_t v18 = v16 + 3;
  if (v18 >= v13) {
    goto LABEL_28;
  }
  unint64_t v17 = *(void *)(v6 + 8 * v18);
  if (v17)
  {
    int64_t v9 = v18;
    goto LABEL_27;
  }
  while (1)
  {
    int64_t v9 = v18 + 1;
    if (__OFADD__(v18, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_28;
    }
    unint64_t v17 = *(void *)(v6 + 8 * v9);
    ++v18;
    if (v17) {
      goto LABEL_27;
    }
  }
LABEL_30:
  __break(1u);
  return result;
}

void *sub_1B52C0E08()
{
  uint64_t v1 = v0;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D492A0);
  uint64_t v2 = *v0;
  uint64_t v3 = sub_1B5372F28();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_28:
    uint64_t result = (void *)swift_release();
    *uint64_t v1 = v4;
    return result;
  }
  uint64_t result = (void *)(v3 + 56);
  uint64_t v6 = v2 + 56;
  unint64_t v7 = (unint64_t)((1 << *(unsigned char *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 56 + 8 * v7) {
    uint64_t result = memmove(result, (const void *)(v2 + 56), 8 * v7);
  }
  int64_t v9 = 0;
  *(void *)(v4 + 16) = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 56);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v21 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_30;
    }
    if (v21 >= v13) {
      goto LABEL_28;
    }
    unint64_t v22 = *(void *)(v6 + 8 * v21);
    ++v9;
    if (!v22)
    {
      int64_t v9 = v21 + 1;
      if (v21 + 1 >= v13) {
        goto LABEL_28;
      }
      unint64_t v22 = *(void *)(v6 + 8 * v9);
      if (!v22)
      {
        int64_t v9 = v21 + 2;
        if (v21 + 2 >= v13) {
          goto LABEL_28;
        }
        unint64_t v22 = *(void *)(v6 + 8 * v9);
        if (!v22) {
          break;
        }
      }
    }
LABEL_27:
    unint64_t v12 = (v22 - 1) & v22;
    unint64_t v15 = __clz(__rbit64(v22)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 32 * v15;
    uint64_t v17 = *(void *)(v2 + 48) + v16;
    uint64_t v19 = *(void *)(v17 + 16);
    uint64_t v18 = *(void *)(v17 + 24);
    uint64_t v20 = *(void *)(v4 + 48) + v16;
    *(_OWORD *)uint64_t v20 = *(_OWORD *)v17;
    *(void *)(v20 + 16) = v19;
    *(void *)(v20 + 24) = v18;
    uint64_t result = (void *)swift_bridgeObjectRetain();
  }
  int64_t v23 = v21 + 3;
  if (v23 >= v13) {
    goto LABEL_28;
  }
  unint64_t v22 = *(void *)(v6 + 8 * v23);
  if (v22)
  {
    int64_t v9 = v23;
    goto LABEL_27;
  }
  while (1)
  {
    int64_t v9 = v23 + 1;
    if (__OFADD__(v23, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_28;
    }
    unint64_t v22 = *(void *)(v6 + 8 * v9);
    ++v23;
    if (v22) {
      goto LABEL_27;
    }
  }
LABEL_30:
  __break(1u);
  return result;
}

uint64_t sub_1B52C0FC4()
{
  uint64_t v1 = v0;
  uint64_t v2 = *v0;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D492A8);
  uint64_t result = sub_1B5372F38();
  uint64_t v4 = result;
  if (!*(void *)(v2 + 16))
  {
    uint64_t result = swift_release();
LABEL_35:
    *uint64_t v1 = v4;
    return result;
  }
  unint64_t v26 = v1;
  int64_t v5 = 0;
  uint64_t v6 = v2 + 56;
  uint64_t v7 = 1 << *(unsigned char *)(v2 + 32);
  if (v7 < 64) {
    uint64_t v8 = ~(-1 << v7);
  }
  else {
    uint64_t v8 = -1;
  }
  unint64_t v9 = v8 & *(void *)(v2 + 56);
  int64_t v10 = (unint64_t)(v7 + 63) >> 6;
  uint64_t v11 = result + 56;
  while (1)
  {
    if (v9)
    {
      unint64_t v13 = __clz(__rbit64(v9));
      v9 &= v9 - 1;
      unint64_t v14 = v13 | (v5 << 6);
      goto LABEL_24;
    }
    int64_t v15 = v5 + 1;
    if (__OFADD__(v5, 1))
    {
LABEL_36:
      __break(1u);
      goto LABEL_37;
    }
    if (v15 >= v10) {
      goto LABEL_33;
    }
    unint64_t v16 = *(void *)(v6 + 8 * v15);
    ++v5;
    if (!v16)
    {
      int64_t v5 = v15 + 1;
      if (v15 + 1 >= v10) {
        goto LABEL_33;
      }
      unint64_t v16 = *(void *)(v6 + 8 * v5);
      if (!v16)
      {
        int64_t v5 = v15 + 2;
        if (v15 + 2 >= v10) {
          goto LABEL_33;
        }
        unint64_t v16 = *(void *)(v6 + 8 * v5);
        if (!v16) {
          break;
        }
      }
    }
LABEL_23:
    unint64_t v9 = (v16 - 1) & v16;
    unint64_t v14 = __clz(__rbit64(v16)) + (v5 << 6);
LABEL_24:
    uint64_t v18 = *(void *)(*(void *)(v2 + 48) + 8 * v14);
    uint64_t result = sub_1B53732E8();
    uint64_t v19 = -1 << *(unsigned char *)(v4 + 32);
    unint64_t v20 = result & ~v19;
    unint64_t v21 = v20 >> 6;
    if (((-1 << v20) & ~*(void *)(v11 + 8 * (v20 >> 6))) != 0)
    {
      unint64_t v12 = __clz(__rbit64((-1 << v20) & ~*(void *)(v11 + 8 * (v20 >> 6)))) | v20 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v22 = 0;
      unint64_t v23 = (unint64_t)(63 - v19) >> 6;
      do
      {
        if (++v21 == v23 && (v22 & 1) != 0)
        {
          __break(1u);
          goto LABEL_36;
        }
        BOOL v24 = v21 == v23;
        if (v21 == v23) {
          unint64_t v21 = 0;
        }
        v22 |= v24;
        uint64_t v25 = *(void *)(v11 + 8 * v21);
      }
      while (v25 == -1);
      unint64_t v12 = __clz(__rbit64(~v25)) + (v21 << 6);
    }
    *(void *)(v11 + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v12;
    *(void *)(*(void *)(v4 + 48) + 8 * v12) = v18;
    ++*(void *)(v4 + 16);
  }
  int64_t v17 = v15 + 3;
  if (v17 >= v10)
  {
LABEL_33:
    uint64_t result = swift_release();
    uint64_t v1 = v26;
    goto LABEL_35;
  }
  unint64_t v16 = *(void *)(v6 + 8 * v17);
  if (v16)
  {
    int64_t v5 = v17;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v5 = v17 + 1;
    if (__OFADD__(v17, 1)) {
      break;
    }
    if (v5 >= v10) {
      goto LABEL_33;
    }
    unint64_t v16 = *(void *)(v6 + 8 * v5);
    ++v17;
    if (v16) {
      goto LABEL_23;
    }
  }
LABEL_37:
  __break(1u);
  return result;
}

uint64_t sub_1B52C1228()
{
  uint64_t v1 = v0;
  uint64_t v2 = *v0;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1E9D492A0);
  uint64_t v3 = sub_1B5372F38();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
    uint64_t result = swift_release();
LABEL_35:
    *uint64_t v1 = v4;
    return result;
  }
  uint64_t v5 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v32 = v2 + 56;
  if (v5 < 64) {
    uint64_t v6 = ~(-1 << v5);
  }
  else {
    uint64_t v6 = -1;
  }
  unint64_t v7 = v6 & *(void *)(v2 + 56);
  int64_t v33 = (unint64_t)(v5 + 63) >> 6;
  uint64_t v8 = v3 + 56;
  uint64_t result = swift_retain();
  for (int64_t i = 0; ; int64_t i = v34)
  {
    if (v7)
    {
      unint64_t v13 = __clz(__rbit64(v7));
      v7 &= v7 - 1;
      int64_t v34 = i;
      unint64_t v14 = v13 | (i << 6);
      goto LABEL_24;
    }
    int64_t v15 = i + 1;
    if (__OFADD__(i, 1))
    {
LABEL_36:
      __break(1u);
      goto LABEL_37;
    }
    if (v15 >= v33) {
      goto LABEL_33;
    }
    unint64_t v16 = *(void *)(v32 + 8 * v15);
    int64_t v17 = i + 1;
    if (!v16)
    {
      int64_t v17 = i + 2;
      if (i + 2 >= v33) {
        goto LABEL_33;
      }
      unint64_t v16 = *(void *)(v32 + 8 * v17);
      if (!v16)
      {
        int64_t v17 = i + 3;
        if (i + 3 >= v33) {
          goto LABEL_33;
        }
        unint64_t v16 = *(void *)(v32 + 8 * v17);
        if (!v16) {
          break;
        }
      }
    }
LABEL_23:
    unint64_t v7 = (v16 - 1) & v16;
    int64_t v34 = v17;
    unint64_t v14 = __clz(__rbit64(v16)) + (v17 << 6);
LABEL_24:
    uint64_t v19 = v2;
    unint64_t v20 = (uint64_t *)(*(void *)(v2 + 48) + 32 * v14);
    uint64_t v22 = *v20;
    uint64_t v21 = v20[1];
    uint64_t v23 = v20[2];
    uint64_t v24 = v20[3];
    swift_bridgeObjectRetain();
    uint64_t result = sub_1B53725A8();
    uint64_t v25 = -1 << *(unsigned char *)(v4 + 32);
    unint64_t v26 = result & ~v25;
    unint64_t v27 = v26 >> 6;
    if (((-1 << v26) & ~*(void *)(v8 + 8 * (v26 >> 6))) != 0)
    {
      unint64_t v11 = __clz(__rbit64((-1 << v26) & ~*(void *)(v8 + 8 * (v26 >> 6)))) | v26 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v28 = 0;
      unint64_t v29 = (unint64_t)(63 - v25) >> 6;
      do
      {
        if (++v27 == v29 && (v28 & 1) != 0)
        {
          __break(1u);
          goto LABEL_36;
        }
        BOOL v30 = v27 == v29;
        if (v27 == v29) {
          unint64_t v27 = 0;
        }
        v28 |= v30;
        uint64_t v31 = *(void *)(v8 + 8 * v27);
      }
      while (v31 == -1);
      unint64_t v11 = __clz(__rbit64(~v31)) + (v27 << 6);
    }
    *(void *)(v8 + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v11;
    unint64_t v12 = (void *)(*(void *)(v4 + 48) + 32 * v11);
    *unint64_t v12 = v22;
    v12[1] = v21;
    _OWORD v12[2] = v23;
    v12[3] = v24;
    ++*(void *)(v4 + 16);
    uint64_t v2 = v19;
  }
  uint64_t v18 = i + 4;
  if (i + 4 >= v33)
  {
LABEL_33:
    uint64_t result = swift_release_n();
    uint64_t v1 = v0;
    goto LABEL_35;
  }
  unint64_t v16 = *(void *)(v32 + 8 * v18);
  if (v16)
  {
    int64_t v17 = i + 4;
    goto LABEL_23;
  }
  while (1)
  {
    int64_t v17 = v18 + 1;
    if (__OFADD__(v18, 1)) {
      break;
    }
    if (v17 >= v33) {
      goto LABEL_33;
    }
    unint64_t v16 = *(void *)(v32 + 8 * v17);
    ++v18;
    if (v16) {
      goto LABEL_23;
    }
  }
LABEL_37:
  __break(1u);
  return result;
}

unint64_t sub_1B52C1514(unint64_t a1, unint64_t a2)
{
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v2 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v2)
  {
    sub_1B51DA9B0(0xFuLL, a1, a2);
    if ((a2 & 0x1000000000000000) != 0)
    {
      unsigned int v5 = sub_1B5372F88();
    }
    else
    {
      if ((a2 & 0x2000000000000000) == 0 && (a1 & 0x1000000000000000) == 0) {
        sub_1B5372FB8();
      }
      unsigned int v5 = sub_1B5372FC8();
    }
  }
  else
  {
    unsigned int v5 = 0;
  }
  return v5 | ((unint64_t)(v2 == 0) << 32);
}

void sub_1B52C15F4(uint64_t a1, uint64_t a2, char **a3)
{
  if ((a2 & 0x1000000000000000) != 0 || !(a2 & 0x2000000000000000 | a1 & 0x1000000000000000))
  {
    sub_1B5372F58();
  }
  else if ((a2 & 0x2000000000000000) != 0)
  {
    v4[0] = a1;
    v4[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    sub_1B52BFED4((uint64_t)v4, a3);
  }
  else
  {
    if ((a1 & 0x1000000000000000) != 0) {
      uint64_t v3 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
    }
    else {
      uint64_t v3 = sub_1B5372FB8();
    }
    sub_1B52C187C(v3);
  }
}

uint64_t sub_1B52C16E0(uint64_t a1)
{
  int64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = MEMORY[0x1E4FBC860];
  if (v1)
  {
    uint64_t v11 = MEMORY[0x1E4FBC860];
    sub_1B521CE50(0, v1, 0);
    uint64_t v2 = v11;
    uint64_t v4 = (uint64_t *)(a1 + 40);
    do
    {
      uint64_t v9 = *(v4 - 1);
      uint64_t v10 = *v4;
      swift_bridgeObjectRetain_n();
      sub_1B5372868();
      sub_1B5372868();
      swift_bridgeObjectRelease();
      unint64_t v6 = *(void *)(v11 + 16);
      unint64_t v5 = *(void *)(v11 + 24);
      if (v6 >= v5 >> 1) {
        sub_1B521CE50((char *)(v5 > 1), v6 + 1, 1);
      }
      v4 += 2;
      *(void *)(v11 + 16) = v6 + 1;
      uint64_t v7 = v11 + 16 * v6;
      *(void *)(v7 + 32) = v9;
      *(void *)(v7 + 40) = v10;
      --v1;
    }
    while (v1);
  }
  return v2;
}

uint64_t sub_1B52C17FC()
{
  swift_bridgeObjectRelease();
  return MEMORY[0x1F4186498](v0, 32, 7);
}

uint64_t sub_1B52C1834()
{
  return sub_1B52BFF68();
}

uint64_t sub_1B52C183C()
{
  return MEMORY[0x1F4186498](v0, 32, 7);
}

uint64_t sub_1B52C184C@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void))(v1 + 16))();
  *a1 = result;
  return result;
}

void sub_1B52C187C(uint64_t a1)
{
  sub_1B52BFED4(a1, *(char ***)(v1 + 16));
}

uint64_t sub_1B52C1898@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_1B51D4BB8(a1, a2);
  sub_1B51D4C10();
  uint64_t result = sub_1B53724D8();
  *(void *)&long long v24 = result;
  *((void *)&v24 + 1) = v6;
  uint64_t v25 = v7;
  *(void *)unint64_t v20 = result;
  *(void *)&v20[8] = v6;
  *(void *)&v20[16] = v7;
  if (v6 < result)
  {
    __break(1u);
  }
  else
  {
    swift_bridgeObjectRetain_n();
    unsigned int v9 = sub_1B51F3DDC((uint64_t *)v20, v8, 1);
    if (v3)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease_n();
      return swift_bridgeObjectRelease();
    }
    else
    {
      unsigned int v10 = v9;
      swift_bridgeObjectRelease();
      long long v24 = *(_OWORD *)v20;
      uint64_t v25 = *(void *)&v20[16];
      uint64_t v12 = v10;
      if (v10 == 1)
      {
        LOBYTE(v10) = 0;
        unint64_t v13 = 1;
      }
      else if (v10)
      {
        unint64_t v13 = sub_1B522DD1C(MEMORY[0x1E4FBC860]);
        LOBYTE(v10) = 1;
      }
      else
      {
        unint64_t v13 = 0;
      }
      uint64_t v14 = sub_1B51F8618((uint64_t)v20, &v24, v11, (v12 << 32) | 0x101, 0x10101010101uLL, v13, v10);
      sub_1B52C1B50(v13, v10);
      swift_bridgeObjectRelease_n();
      int v15 = *(_DWORD *)v20;
      long long v18 = v21;
      long long v19 = *(_OWORD *)&v20[8];
      uint64_t v16 = v22;
      __int16 v17 = v23;
      swift_bridgeObjectRelease();
      uint64_t result = swift_bridgeObjectRelease();
      *(_DWORD *)a3 = v15;
      *(_OWORD *)(a3 + 8) = v19;
      *(_OWORD *)(a3 + 24) = v18;
      *(void *)(a3 + 40) = v16;
      *(_WORD *)(a3 + 48) = v17;
      *(void *)(a3 + 56) = v14;
    }
  }
  return result;
}

uint64_t sub_1B52C1B50(uint64_t a1, char a2)
{
  if (a2) {
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t TTRegisterStrike(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  return 0;
}

uint64_t TTGetStrikeSpecs(uint64_t a1, const TStrikeDescription *a2, uint64_t a3)
{
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v29[2] = v5;
  v29[3] = v5;
  v29[0] = v5;
  v29[1] = v5;
  cacheCallContext::cacheCallContext((uint64_t)v29, (uint64_t)a2, 0, 0);
  memset(__b, 170, sizeof(__b));
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)v29);
  unint64_t v27 = 0xAAAAAAAAAA000000;
  unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  long long v19 = __b;
  uint64_t v20 = 1358921729;
  uint64_t v21 = 1358921729;
  uint64_t v22 = 1358921729;
  uint64_t v23 = 0;
  uint64_t v25 = 1358921729;
  uint64_t v26 = 1358921729;
  __int16 v17 = (os_unfair_lock_s *)0xAAAAAAAAAAAAAAAALL;
  long long v18 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  ResolveCacheStrike(a2, &v17);
  uint64_t v6 = v17 + 2;
  os_unfair_lock_lock(v17 + 2);
  AssureStrikeBlocks(&v19, (memoryContext *)__b, v17);
  uint64_t v7 = (os_unfair_lock_s *)(v22 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(v22 + 208));
  SetUpProgramPtrs((uint64_t)&v19);
  GetFontMetrics((uint64_t)&v19, (memoryContext *)__b, (*(unsigned __int8 *)(*(void *)&v17[8]._os_unfair_lock_opaque + 16) >> 3) & 1, (char *)(a3 + 64));
  v16.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v16.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  GetScalerVariationInfo((uint64_t)&v19, (uint64_t)__b, *(_DWORD *)(*(void *)&v17[6]._os_unfair_lock_opaque + 16), &v16);
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v13 = v8;
  long long v14 = v8;
  GetScalerTransformInfo((uint64_t)&v19, (memoryContext *)__b, (uint64_t)&v13);
  uint64_t v9 = v21;
  int v10 = *(unsigned __int16 *)(v20 + 40);
  *(_DWORD *)(a3 + 60) = 1;
  if (*(unsigned char *)(v9 + 56))
  {
    unsigned int v30 = 0;
    TFontSurrogate::GetTableIndex((TFontSurrogate *)(__b[0] + 16), 1801810542, &v30);
    if (v30) {
      *(_DWORD *)(a3 + 60) |= 1u;
    }
  }
  long long v11 = v14;
  *(_OWORD *)a3 = v13;
  *(_OWORD *)(a3 + 16) = v11;
  *(void *)(a3 + 32) = v15;
  *(int32x4_t *)(a3 + 40) = v16;
  *(_DWORD *)(a3 + 56) = v10;
  ReleaseProgramPtrs((memoryContext *)__b, v22 + 208);
  os_unfair_lock_unlock(v7);
  os_unfair_lock_unlock(v6);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v18);
  }
  memoryContext::~memoryContext((memoryContext *)__b);
  UnCacheCurrentGlyph((cacheCallContext *)v29);
  return 0;
}

void sub_1B52C1D64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  os_unfair_lock_unlock(v29);
  os_unfair_lock_unlock(v28);
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:fe180100](a18);
  }
  memoryContext::~memoryContext((memoryContext *)&a28);
  UnCacheCurrentGlyph((cacheCallContext *)(v30 - 128));
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1B52C1D44);
  }
  _Unwind_Resume(a1);
}

uint64_t TTGetFontSpecs(TFont *a1, uint64_t a2)
{
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v24 = v3;
  long long v25 = v3;
  long long v22 = v3;
  long long v23 = v3;
  cacheCallContext::cacheCallContext((cacheCallContext *)&v22, a1, 0, 0);
  uint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  CreateFontCacheNode(*((const TFont **)&v23 + 1), &v21);
  uint64_t v4 = v21;
  if (v21)
  {
    memset(__b, 170, sizeof(__b));
    memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)&v22);
    unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v19 = 0xAAAAAAAAAA000000;
    long long v11 = __b;
    uint64_t v12 = 1358921729;
    uint64_t v13 = 1358921729;
    uint64_t v14 = 1358921729;
    uint64_t v15 = 0;
    uint64_t v17 = 1358921729;
    uint64_t v18 = 1358921729;
    AssureScalerFontBlock(&v11, (memoryContext *)__b, v4);
    __int16 v5 = *(_WORD *)(v4 + 16);
    *(_WORD *)(v4 + 16) = v5 + 1;
    uint64_t v6 = v12;
    *(_WORD *)(a2 + 4) = *(_WORD *)(v12 + 130);
    int v7 = (*(unsigned __int16 *)(v6 + 128) >> 7) & 0xF;
    *(_DWORD *)a2 = v7;
    if (*(unsigned char *)(v6 + 152)) {
      *(_DWORD *)a2 = v7 | 0x10;
    }
    *(_WORD *)(a2 + 8) = *(_WORD *)(v6 + 140);
    *(_WORD *)(a2 + 6) = *(_WORD *)(v6 + 40);
    *(_WORD *)(v4 + 16) = v5;
    memoryContext::~memoryContext((memoryContext *)__b);
    __int16 v8 = 0;
    uint64_t v9 = *(void *)(v4 + 8);
    if (v9) {
      free((void *)(v9 - 8));
    }
    MEMORY[0x1BA9994D0](v4, 0x1080C40587D25DELL);
  }
  else
  {
    __int16 v8 = 20;
  }
  UnCacheCurrentGlyph((cacheCallContext *)&v22);
  return v8;
}

void sub_1B52C1F4C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  memoryContext::~memoryContext((memoryContext *)va);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    if (!*(void *)(v12 - 104)) {
      JUMPOUT(0x1B52C1F2CLL);
    }
    JUMPOUT(0x1B52C1EFCLL);
  }
  std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100]((uint64_t *)(v12 - 104), 0);
  UnCacheCurrentGlyph((cacheCallContext *)(v12 - 96));
  _Unwind_Resume(a1);
}

uint64_t TTGetQuickDrawMetrics(const TStrikeDescription *a1, uint64_t a2, int32x2_t *a3)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[2] = v6;
  v20[3] = v6;
  v20[0] = v6;
  v20[1] = v6;
  cacheCallContext::cacheCallContext((uint64_t)v20, (uint64_t)a1, 0, 0);
  memset(__b, 170, sizeof(__b));
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)v20);
  unint64_t v18 = 0xAAAAAAAAAA000000;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  v12[0] = __b;
  v12[1] = 1358921729;
  _OWORD v12[2] = 1358921729;
  uint64_t v13 = 1358921729;
  uint64_t v14 = 0;
  uint64_t v16 = 1358921729;
  uint64_t v17 = 1358921729;
  int v10 = (os_unfair_lock_s *)0xAAAAAAAAAAAAAAAALL;
  long long v11 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  ResolveCacheStrike(a1, &v10);
  int v7 = v10 + 2;
  os_unfair_lock_lock(v10 + 2);
  AssureStrikeBlocks(v12, (memoryContext *)__b, v10);
  __int16 v8 = (os_unfair_lock_s *)(v13 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(v13 + 208));
  SetUpProgramPtrs((uint64_t)v12);
  ComputeQDMetrics((uint64_t)v12, a2, a3);
  ReleaseProgramPtrs((memoryContext *)__b, v13 + 208);
  os_unfair_lock_unlock(v8);
  os_unfair_lock_unlock(v7);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v11);
  }
  memoryContext::~memoryContext((memoryContext *)__b);
  UnCacheCurrentGlyph((cacheCallContext *)v20);
  return 0;
}

void sub_1B52C2130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  os_unfair_lock_unlock(v20);
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:fe180100](a10);
  }
  memoryContext::~memoryContext((memoryContext *)&a20);
  UnCacheCurrentGlyph((cacheCallContext *)(v21 - 112));
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1B52C2110);
  }
  _Unwind_Resume(a1);
}

uint64_t TTGetRenderingSpecs(uint64_t a1, const TStrikeDescription *a2, int *a3, int *a4)
{
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[2] = v7;
  v23[3] = v7;
  v23[0] = v7;
  v23[1] = v7;
  cacheCallContext::cacheCallContext((uint64_t)v23, (uint64_t)a2, 0, 0);
  memset(__b, 170, sizeof(__b));
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)v23);
  unint64_t v21 = 0xAAAAAAAAAA000000;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  v15[0] = __b;
  v15[1] = 1358921729;
  v15[2] = 1358921729;
  uint64_t v16 = 1358921729;
  uint64_t v17 = 0;
  uint64_t v19 = 1358921729;
  uint64_t v20 = 1358921729;
  uint64_t v13 = (os_unfair_lock_s *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  ResolveCacheStrike(a2, &v13);
  __int16 v8 = v13 + 2;
  os_unfair_lock_lock(v13 + 2);
  AssureStrikeBlocks(v15, (memoryContext *)__b, v13);
  uint64_t v9 = (os_unfair_lock_s *)(v16 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(v16 + 208));
  SetUpProgramPtrs((uint64_t)v15);
  ComputeRenderingSpecs((uint64_t)v15, (uint64_t)__b, a3[1] == 1651335536, *((void *)a3 + 1) != 0, a4);
  int v10 = *a3;
  if (*a3 == 1920298616 || v10 == 1919824760)
  {
    int v11 = 32 * *a4;
  }
  else
  {
    if (v10 != 1836343917) {
      goto LABEL_7;
    }
    int v11 = *a4 + 36;
  }
  *a4 = v11;
LABEL_7:
  ReleaseProgramPtrs((memoryContext *)__b, v16 + 208);
  os_unfair_lock_unlock(v9);
  os_unfair_lock_unlock(v8);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v14);
  }
  memoryContext::~memoryContext((memoryContext *)__b);
  UnCacheCurrentGlyph((cacheCallContext *)v23);
  return 0;
}

void sub_1B52C2370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  os_unfair_lock_unlock(v20);
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:fe180100](a10);
  }
  memoryContext::~memoryContext((memoryContext *)&a20);
  UnCacheCurrentGlyph((cacheCallContext *)(v21 - 112));
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1B52C2350);
  }
  _Unwind_Resume(a1);
}

uint64_t TTGetMetricSpecs(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  if (*a3 == 1835430499)
  {
    int v4 = 24;
    goto LABEL_5;
  }
  if (*a3 == 1836213362)
  {
    int v4 = 36;
LABEL_5:
    uint64_t result = 0;
    *a4 = v4;
    a4[1] = 1;
    return result;
  }
  return 12;
}

uint64_t TTGetGlyphMetrics(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!v3) {
    return 8;
  }
  if (!v5) {
    return 19;
  }
  long long v7 = v4;
  unsigned int v8 = v3;
  uint64_t v9 = v2;
  int v10 = (const TStrikeDescription *)v1;
  int v11 = **(_DWORD **)(v1 + 40);
  if (*v2 == 1836213362 && 36 * (unint64_t)v3 > v6) {
    return 19;
  }
  if (*v2 == 1835430499 && 24 * (unint64_t)v3 > v6) {
    return 19;
  }
  *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v43 = v13;
  v41[1] = v13;
  long long v42 = v13;
  v41[0] = v13;
  cacheCallContext::cacheCallContext((uint64_t)v41, v1, v5, v6);
  memset(__b, 170, sizeof(__b));
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)v41);
  uint64_t v14 = *((void *)&v42 + 1);
  unint64_t v39 = 0xAAAAAAAAAA000000;
  unint64_t v36 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v31 = __b;
  uint64_t v32 = 1358921729;
  uint64_t v33 = 1358921729;
  uint64_t v34 = 1358921729;
  uint64_t v35 = 0;
  uint64_t v37 = 1358921729;
  uint64_t v38 = 1358921729;
  unint64_t v29 = (os_unfair_lock_s *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v30 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  ResolveCacheStrike(v10, &v29);
  unint64_t v15 = v29 + 2;
  os_unfair_lock_lock(v29 + 2);
  AssureStrikeBlocks(&v31, (memoryContext *)__b, v29);
  uint64_t v16 = (os_unfair_lock_s *)(v34 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(v34 + 208));
  SetUpProgramPtrs((uint64_t)&v31);
  int v28 = 1;
  long long v27 = xmmword_1B539288C;
  memset(v44, 170, sizeof(v44));
  if (*v9 == 1835430499)
  {
    unsigned int v20 = *(_DWORD *)(v32 + 20);
    if (v20 < 0xA99) {
      uint64_t v19 = (size_t *)v44;
    }
    else {
      uint64_t v19 = ScalerNewScratch((memoryContext *)__b, v20 + 2408, 1);
    }
    unint64_t v36 = (unint64_t)v19;
    v19[6] = (size_t)(v19 + 301);
    do
    {
      memset(v25, 170, 24);
      LODWORD(v27) = *v7;
      AssureGlyphBlock((uint64_t)&v31, (memoryContext *)__b, (int *)&v27);
      ComputeGlyphFractionalMetrics(&v31, (uint64_t)__b, (int32x2_t *)v25);
      *(_OWORD *)uint64_t v14 = *(_OWORD *)v25;
      *(void *)(v14 + 16) = *(void *)&v25[16];
      ++v7;
      v14 += 24;
      --v8;
    }
    while (v8);
LABEL_31:
    __int16 v12 = 0;
    if (v19 && v19 != (size_t *)v44)
    {
      ScalerDisposeBlock((memoryContext *)__b, (char *)v19, -1);
      __int16 v12 = 0;
    }
    goto LABEL_34;
  }
  if (*v9 == 1836213362)
  {
    uint64_t v17 = *((void *)v9 + 1);
    LOWORD(v39) = v17 != 0;
    if (v17) {
      LOBYTE(v17) = *(unsigned char *)(v32 + 152) != 0;
    }
    BYTE2(v39) = v17;
    unsigned int v18 = *(_DWORD *)(v32 + 20);
    if (v18 < 0xA99) {
      uint64_t v19 = (size_t *)v44;
    }
    else {
      uint64_t v19 = ScalerNewScratch((memoryContext *)__b, v18 + 2408, 1);
    }
    unint64_t v36 = (unint64_t)v19;
    v19[6] = (size_t)(v19 + 301);
    do
    {
      int v26 = -1431655766;
      *(void *)&long long v21 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)long long v25 = v21;
      *(_OWORD *)&v25[16] = v21;
      memset(v24, 170, sizeof(v24));
      LODWORD(v27) = *v7;
      AssureGlyphBlock((uint64_t)&v31, (memoryContext *)__b, (int *)&v27);
      ComputeGlyphBoundsAndMetrics(&v31, (int32x2_t *)v25, v24);
      *(int32x2_t *)uint64_t v14 = v24[0];
      *(int32x2_t *)(v14 + 20) = v24[1];
      *(int32x2_t *)(v14 + 28) = v24[2];
      *(void *)(v14 + 8) = *(void *)&v25[8];
      LOWORD(v22) = *(_WORD *)&v25[28] - *(_WORD *)&v25[20];
      *(_WORD *)(v14 + 16) = *(_WORD *)&v25[28] - *(_WORD *)&v25[20];
      *(_WORD *)(v14 + 18) = *(_WORD *)&v25[24] - *(_WORD *)&v25[16];
      if ((v11 & 0x10) != 0)
      {
        int v22 = (unsigned __int16)v22;
        if (!*(_WORD *)(v34 + 492) && !*(_WORD *)(v34 + 494))
        {
          ComputeQDAscentDescent((uint64_t)&v31, (memoryContext *)__b, (_WORD *)(v34 + 492), (_WORD *)(v34 + 494));
          int v22 = *(unsigned __int16 *)(v14 + 16);
        }
        if (v22) {
          SquishGlyphMetrics(v14, *(__int16 *)(v34 + 492), *(__int16 *)(v34 + 494));
        }
      }
      ++v7;
      v14 += 36;
      --v8;
    }
    while (v8);
    goto LABEL_31;
  }
  __int16 v12 = 12;
LABEL_34:
  ReleaseProgramPtrs((memoryContext *)__b, v34 + 208);
  os_unfair_lock_unlock(v16);
  os_unfair_lock_unlock(v15);
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v30);
  }
  memoryContext::~memoryContext((memoryContext *)__b);
  UnCacheCurrentGlyph((cacheCallContext *)v41);
  return v12;
}

void sub_1B52C28A8(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  os_unfair_lock_unlock(v35);
  os_unfair_lock_unlock(v34);
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:fe180100](a24);
  }
  memoryContext::~memoryContext((memoryContext *)&a34);
  UnCacheCurrentGlyph((cacheCallContext *)&STACK[0x460]);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1B52C2864);
  }
  _Unwind_Resume(a1);
}

void ComputeQDAscentDescent(uint64_t a1, memoryContext *a2, _WORD *a3, _WORD *a4)
{
  uint64_t v8 = *(void *)(a1 + 24);
  if (*(unsigned char *)(v8 + 490))
  {
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v19[12] = v9;
    long long v18 = v9;
    *(_OWORD *)uint64_t v19 = v9;
    *(_OWORD *)uint64_t v17 = v9;
    uint64_t v10 = *(void *)(v8 + 80);
    if (v8 + 96 != v10)
    {
      long long v11 = *(_OWORD *)(v8 + 96);
      long long v12 = *(_OWORD *)(v8 + 112);
      *(_DWORD *)(v10 + 32) = *(_DWORD *)(v8 + 128);
      *(_OWORD *)uint64_t v10 = v11;
      *(_OWORD *)(v10 + 16) = v12;
    }
    if (sbit_FontMatch(a2, a1, (uint64_t)v17, *(unsigned __int8 *)(v8 + 484), 1)) {
      *(_WORD *)(v8 + 489) = 514;
    }
    int v13 = HIDWORD(v17[1]);
    *a3 = (HIDWORD(v17[0]) + 0x8000) >> 16;
    *a4 = -((v13 + 0x8000) >> 16);
  }
  else
  {
    v17[0] = (void *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v14 = *(__int16 *)(*(void *)(a1 + 8) + 130);
    ScalerGetFontTable(a2, 1751672161, 0, v17, 0, 36);
    int v15 = *(_DWORD *)(*(void *)(a1 + 24) + 112);
    uint64_t v16 = (unsigned __int16 *)v17[0];
    *a3 = (((__int16)(bswap32(*((unsigned __int16 *)v17[0] + 2)) >> 16) * (uint64_t)v15 / v14) + 0x8000) >> 16;
    *a4 = -((((__int16)(bswap32(v16[3]) >> 16) * (uint64_t)v15 / v14) + 0x8000) >> 16);
    ScalerReleaseFontTable(a2, v16);
  }
}

uint64_t SquishGlyphMetrics(uint64_t result, int a2, int a3)
{
  int v3 = *(_DWORD *)(result + 12);
  int v4 = *(unsigned __int16 *)(result + 16);
  int v5 = v4 - (v3 >> 16);
  if (a2 < v3 >> 16 || v5 > a3)
  {
    int v7 = v3 >> 16;
    int v8 = a2 - (v3 >> 16);
    BOOL v9 = a2 < v3 >> 16 && v5 < -((__int16)(HIWORD(v3) + (v3 >> 31)) >> 1);
    if (v9
      || (v5 >= 0 ? (int v10 = v4 - (v3 >> 16)) : (int v10 = v5 + 1),
          (int v11 = -(v10 >> 1), v8 = v5 - a3, v5 > a3) ? (v12 = v7 < v11) : (v12 = 0),
          v12))
    {
      *(_DWORD *)(result + 12) = v3 + (v8 << 16);
    }
    else
    {
      int v13 = *(unsigned __int16 *)(result + 16);
      if (v3 >= 0x10000 && a2 < v7)
      {
        *(_DWORD *)(result + 12) = a2 << 16;
        if (v4 >= v7) {
          int v13 = a2 - v7 + v4;
        }
        else {
          int v13 = ((a2 << 16) / v7 * v4) >> 16;
        }
      }
      if (v4 != v7 && v5 > a3)
      {
        int v14 = (a3 << 16) / v5;
        if (v3 < 0) {
          *(_DWORD *)(result + 12) = v14 * v7;
        }
        if (v13 >= v5) {
          LOWORD(v13) = a3 - v5 + v13;
        }
        else {
          int v13 = (v14 * v13) >> 16;
        }
      }
      *(_WORD *)(result + 16) = v13;
    }
  }
  return result;
}

uint64_t TTRenderGlyphs(uint64_t a1)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  if (!v3) {
    return 8;
  }
  int v8 = v7;
  uint64_t v9 = v4;
  int v10 = v3;
  uint64_t v11 = v2;
  BOOL v12 = (const TStrikeDescription *)v1;
  int v13 = *(_DWORD *)(v2 + 4);
  int v14 = **(_DWORD **)(v1 + 40);
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v98 = v15;
  long long v97 = v15;
  v96[1] = v15;
  v96[0] = v15;
  cacheCallContext::cacheCallContext((uint64_t)v96, v1, v5, v6);
  BYTE13(v98) = *(_DWORD *)v11 == 1836343917;
  __int16 v95 = 0;
  memset(__b, 170, 0x398uLL);
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)v96);
  unint64_t v93 = 0xAAAAAAAAAA000000;
  unint64_t v90 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v85 = __b;
  uint64_t v86 = 1358921729;
  uint64_t v87 = 1358921729;
  uint64_t v88 = 1358921729;
  uint64_t v89 = 0;
  uint64_t v91 = 1358921729;
  uint64_t v92 = 1358921729;
  uint64_t v83 = (os_unfair_lock_s *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v84 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  ResolveCacheStrike(v12, &v83);
  uint64_t v72 = v83 + 2;
  os_unfair_lock_lock(v83 + 2);
  AssureStrikeBlocks(&v85, (memoryContext *)__b, v83);
  lock = (os_unfair_lock_s *)(v88 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(v88 + 208));
  SetUpProgramPtrs((uint64_t)&v85);
  uint64_t v79 = 0;
  int v16 = *(_DWORD *)(v11 + 4);
  int v80 = 0;
  int v81 = v16;
  BOOL v82 = v13 != 1651335536;
  *int v8 = 0;
  uint64_t v17 = *(void *)(v11 + 8);
  LOWORD(v93) = v17 != 0;
  if (v17) {
    LOBYTE(v17) = *(unsigned char *)(v86 + 152) != 0;
  }
  BYTE2(v93) = v17;
  long long v18 = (size_t *)v100;
  memset(v100, 170, sizeof(v100));
  unsigned int v19 = *(_DWORD *)(v86 + 20);
  if (v19 >= 0xA99) {
    long long v18 = ScalerNewScratch((memoryContext *)__b, v19 + 2408, 1);
  }
  unint64_t v90 = (unint64_t)v18;
  v18[6] = (size_t)(v18 + 301);
  uint64_t v69 = (char *)v18;
  if (v13 == 1651335536)
  {
    int v22 = *(__int16 **)(v11 + 16);
    if (v22 && (int v23 = *v22, v24 = v22[1], v23 <= v24))
    {
      HIDWORD(v79) = v23;
      int v80 = v24;
      char v25 = 1;
    }
    else
    {
      char v25 = 0;
      HIDWORD(v79) = 0;
      int v80 = 0;
    }
    uint64_t v27 = 0;
    int v28 = v10;
    char v70 = v14;
    while (1)
    {
      LODWORD(v79) = *(unsigned __int16 *)(v9 + 2 * v27);
      AssureGlyphBlock((uint64_t)&v85, (memoryContext *)__b, (int *)&v79);
      memset(v78, 170, sizeof(v78));
      *(_DWORD *)&v77[16] = -1431655766;
      *(void *)&long long v29 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v76 = v29;
      *(_OWORD *)char v77 = v29;
      unsigned int v75 = -1431655766;
      *(_OWORD *)BOOL v73 = v29;
      long long v74 = v29;
      ComputeGlyphBoundsAndMetrics(&v85, (int32x2_t *)v73, v78);
      uint64_t v30 = (unsigned __int8 *)RenderBitmap((uint64_t)&v85, (memoryContext *)__b, &v79, (uint64_t)v73, 6);
      v73[0] = v30;
      if (*(_DWORD *)v11 == 1836343917)
      {
        *(_OWORD *)&v77[4] = *(_OWORD *)v78[1].i8;
        *(int32x2_t *)&long long v76 = v78[0];
        *((unsigned __int8 **)&v76 + 1) = v73[1];
        *(_WORD *)char v77 = WORD6(v74) - WORD2(v74);
        *(_WORD *)&v77[2] = WORD4(v74) - v74;
        if ((v14 & 0x10) != 0)
        {
          int v31 = (unsigned __int16)(WORD6(v74) - WORD2(v74));
          if (!*(_WORD *)(v88 + 492) && !*(_WORD *)(v88 + 494))
          {
            ComputeQDAscentDescent((uint64_t)&v85, (memoryContext *)__b, (_WORD *)(v88 + 492), (_WORD *)(v88 + 494));
            int v31 = *(unsigned __int16 *)v77;
          }
          if (v31) {
            SquishGlyphMetrics((uint64_t)&v76, *(__int16 *)(v88 + 492), *(__int16 *)(v88 + 494));
          }
        }
        uint64_t v30 = v73[0];
      }
      if (!v30)
      {
        if (*(_DWORD *)v11 == 1836343917)
        {
          uint64_t v33 = DWORD2(v98);
          DWORD1(v98) = 36;
          if ((int)v98 - DWORD2(v98) < 36 || (DWORD2(v98) += 36, !*((void *)&v97 + 1)))
          {
            exception = __cxa_allocate_exception(2uLL);
            _WORD *exception = 19;
            __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
          }
          uint64_t v34 = *((void *)&v97 + 1) + v33;
          long long v35 = v76;
          long long v36 = *(_OWORD *)v77;
          *(_DWORD *)(v34 + 32) = *(_DWORD *)&v77[16];
          *(_OWORD *)uint64_t v34 = v35;
          *(_OWORD *)(v34 + 16) = v36;
          if (v25) {
            goto LABEL_70;
          }
        }
        else
        {
          DWORD1(v98) = 0;
          if (v25) {
            goto LABEL_70;
          }
        }
LABEL_69:
        UnCacheCurrentGlyph((cacheCallContext *)v96);
        goto LABEL_70;
      }
      if (v25)
      {
        unsigned int v32 = 0;
        goto LABEL_68;
      }
      BOOL v37 = *(void *)(v11 + 8) == 0;
      unsigned int v38 = *(_DWORD *)v11 == 1836343917 ? PackBitmap((uint64_t)v73, v37, &v76) : PackBitmap((uint64_t)v73, v37, 0);
      unsigned int v32 = v38;
      if ((v14 & 0x10) != 0)
      {
        if (!*(_WORD *)(v88 + 492) && !*(_WORD *)(v88 + 494)) {
          ComputeQDAscentDescent((uint64_t)&v85, (memoryContext *)__b, (_WORD *)(v88 + 492), (_WORD *)(v88 + 494));
        }
        int v39 = HIDWORD(v74) - DWORD1(v74);
        if (SHIDWORD(v74) > SDWORD1(v74)) {
          break;
        }
      }
LABEL_68:
      *(int32x2_t *)((char *)&v98 + 4) = vsub_s32(*(int32x2_t *)((char *)&v98 + 4), vdup_n_s32(v32));
      if ((v25 & 1) == 0) {
        goto LABEL_69;
      }
LABEL_70:
      v8[v27 + 1] = DWORD1(v98);
      ++*v8;
      if (v28 == ++v27)
      {
LABEL_12:
        if (v69 && v69 != v100) {
          ScalerDisposeBlock((memoryContext *)__b, v69, -1);
        }
        ReleaseProgramPtrs((memoryContext *)__b, v88 + 208);
        goto LABEL_20;
      }
    }
    int v40 = *(__int16 *)(v88 + 492);
    int v41 = *(__int16 *)(v88 + 494);
    unsigned int v42 = v75;
    int v43 = HIDWORD(v73[1]);
    int v44 = v39 - (SHIDWORD(v73[1]) >> 16);
    if (v40 < SHIDWORD(v73[1]) >> 16 || v44 > v41)
    {
      int v46 = SHIDWORD(v73[1]) >> 16;
      int v47 = v40 - (SHIDWORD(v73[1]) >> 16);
      if (v40 >= SHIDWORD(v73[1]) >> 16 || v44 >= -((__int16)(HIWORD(v73[1]) + (HIDWORD(v73[1]) >> 31)) >> 1))
      {
        int v48 = v44 >= 0 ? v39 - (SHIDWORD(v73[1]) >> 16) : v44 + 1;
        int v47 = v44 - v41;
        if (v44 <= v41 || v46 >= -(v48 >> 1))
        {
          int v99 = -1431655766;
          uint64_t v49 = &v73[0][v46 * v75];
          int v64 = v39 - (SHIDWORD(v73[1]) >> 16);
          unsigned int v65 = v75;
          __src = v49;
          int v59 = SHIDWORD(v73[1]) >> 16;
          if (v40 >= v46)
          {
            int v51 = 0;
            if (SHIDWORD(v73[1]) < 0x10000) {
              uint64_t v52 = v73[0];
            }
            else {
              uint64_t v52 = &v73[0][v46 * v75];
            }
          }
          else
          {
            if (v39 >= v46) {
              int v50 = SHIDWORD(v73[1]) >> 16;
            }
            else {
              int v50 = HIDWORD(v74) - DWORD1(v74);
            }
            int v55 = v50;
            __dsta = v73[0];
            int v66 = HIDWORD(v74) - DWORD1(v74);
            int v60 = v41;
            SquishInPlace(v73[0], v75, v50, (v40 << 16) / v46, &v99);
            int v41 = v60;
            int v44 = v64;
            unsigned int v42 = v65;
            int v51 = v55 - v99;
            HIDWORD(v73[1]) += (v55 - v99) << 16;
            uint64_t v49 = __src;
            int v39 = v66 - (v55 - v99);
            uint64_t v52 = &__dsta[v99 * v65];
          }
          if (v44 > v41)
          {
            __dst = v52;
            int v61 = v51;
            int v67 = v39;
            int v56 = (v41 << 16) / v44;
            SquishInPlace(v49, v42, v44, v56, &v99);
            if (v43 < 0) {
              HIDWORD(v73[1]) = v56 * v59;
            }
            unsigned int v42 = v65;
            int v39 = v67 - (v64 - v99);
            int v51 = v64 - v99 + v61;
            int v44 = v99;
            uint64_t v49 = __src;
            uint64_t v52 = __dst;
          }
          LOBYTE(v14) = v70;
          if (v52 < v49 && v44 >= 1)
          {
            int v68 = v39;
            int v62 = v51;
            memmove(v52, v49, v44 * v42);
            int v51 = v62;
            unsigned int v42 = v65;
            int v39 = v68;
          }
          HIDWORD(v74) = SHIWORD(v73[1]);
          DWORD1(v74) = SHIWORD(v73[1]) - v39;
          int v45 = v51 * v42;
          goto LABEL_67;
        }
      }
      int v45 = 0;
      HIDWORD(v73[1]) += v47 << 16;
    }
    else
    {
      int v45 = 0;
    }
    LOBYTE(v14) = v70;
LABEL_67:
    v32 += v45;
    goto LABEL_68;
  }
  if (!*(unsigned char *)(v86 + 152) && !*(unsigned char *)(v88 + 490))
  {
    char v54 = __cxa_allocate_exception(2uLL);
    *char v54 = 4;
    __cxa_throw(v54, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t v20 = 0;
  while (1)
  {
    LODWORD(v79) = *(unsigned __int16 *)(v9 + 2 * v20);
    AssureGlyphBlock((uint64_t)&v85, (memoryContext *)__b, (int *)&v79);
    if (!RenderPath(&v85, (memoryContext *)__b, &v79, &v95)) {
      break;
    }
    UnCacheCurrentGlyph((cacheCallContext *)v96);
    v8[v20 + 1] = DWORD1(v98);
    ++*v8;
    if (v10 == ++v20) {
      goto LABEL_12;
    }
  }
LABEL_20:
  os_unfair_lock_unlock(lock);
  os_unfair_lock_unlock(v72);
  if (v84) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v84);
  }
  memoryContext::~memoryContext((memoryContext *)__b);
  __int16 v21 = v95;
  if (v95 == 19)
  {
    __int16 v21 = 0;
    if (!*v8) {
      v8[1] = DWORD1(v98);
    }
  }
  UnCacheCurrentGlyph((cacheCallContext *)v96);
  return v21;
}

void sub_1B52C338C(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void sub_1B52C33A4(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_unfair_lock_s *lock, os_unfair_lock_s *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,std::__shared_weak_count *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a37) {
    std::__shared_weak_count::__release_shared[abi:fe180100](a37);
  }
  memoryContext::~memoryContext((memoryContext *)&a47);
  if (a2 == 1)
  {
    LOWORD(STACK[0x4CE]) = *(_WORD *)__cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1B52C2EB8);
  }
  UnCacheCurrentGlyph((cacheCallContext *)&STACK[0x4D0]);
  JUMPOUT(0x1B52C3394);
}

uint64_t PackBitmap(uint64_t a1, int a2, long long *a3)
{
  if (a3)
  {
    int v3 = *(unsigned int **)a1;
    long long v4 = *a3;
    long long v5 = a3[1];
    *(v3 - 1) = *((_DWORD *)a3 + 8);
    *(_OWORD *)(v3 - 5) = v5;
    *(_OWORD *)(v3 - 9) = v4;
  }
  int v6 = *(unsigned int **)a1;
  int v8 = *(_DWORD *)(a1 + 24);
  int v7 = *(_DWORD *)(a1 + 28);
  int v10 = *(_DWORD *)(a1 + 16);
  int v9 = *(_DWORD *)(a1 + 20);
  unsigned int v11 = v7 - v9;
  unsigned int v12 = v8 - v10;
  if (a2)
  {
    if (v8 != v10)
    {
      if (v12 <= 8)
      {
        int v13 = (char *)v6 + 3;
        int v14 = v9 - v7;
        do
        {
          char v15 = *v13;
          v13 += 4;
          *(unsigned char *)int v6 = v15;
          int v6 = (unsigned int *)((char *)v6 + 1);
          BOOL v16 = __CFADD__(v14++, 1);
        }
        while (!v16);
        uint64_t v17 = 3 * v11 - (v11 & 1);
        int v18 = 1;
LABEL_19:
        *(_DWORD *)(a1 + 32) = v18;
        return v17;
      }
      if (v12 <= 0x10)
      {
        uint64_t v22 = 0;
        int v23 = v9 - v7;
        do
        {
          *(_WORD *)((char *)v6 + v22 * 2) = bswap32(HIWORD(v6[v22])) >> 16;
          ++v22;
          BOOL v16 = __CFADD__(v23++, 1);
        }
        while (!v16);
        uint64_t v17 = 2 * v11;
        int v18 = 2;
        goto LABEL_19;
      }
      unsigned int v25 = *(_DWORD *)(a1 + 32);
      if (v25 >> 30 || (unint64_t v26 = v11 * (unint64_t)(v25 >> 2), (v26 & 0xFFFFFFFF00000000) != 0))
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *(void *)exception = &unk_1F0DD4440;
        exception[2] = 4;
      }
      for (; v26; LODWORD(v26) = v26 - 1)
      {
        *int v6 = bswap32(*v6);
        ++v6;
      }
    }
  }
  else
  {
    unsigned int v19 = ((v12 + 7) >> 1) & 0x7FFFFFFC;
    *(_DWORD *)(a1 + 32) = v19;
    unsigned int v20 = v19 * v11;
    if (v20)
    {
      unsigned int v21 = v20 >> 2;
      do
      {
        *int v6 = bswap32(*v6);
        ++v6;
        --v21;
      }
      while (v21);
    }
  }
  return 0;
}

uint64_t TTKernGlyphs()
{
  return 1;
}

uint64_t TTFontRenderingQuery(uint64_t a1, unsigned int a2, uint64_t a3, _DWORD *a4)
{
  int v4 = 0;
  if (a2)
  {
    long long v5 = (int *)(a3 + 4);
    for (uint64_t i = a2; i; --i)
    {
      int v7 = *(v5 - 1);
      if (v7 == 1885434984)
      {
        *a4 = *v5 == 1735946356;
      }
      else
      {
        if (v7 != 1651335536) {
          goto LABEL_17;
        }
        int v8 = *v5;
        if (*v5 <= 1885960243)
        {
          if (v8 != 1668112752 && v8 != 1836343917)
          {
LABEL_17:
            *a4 = 0;
            ++v4;
            goto LABEL_18;
          }
LABEL_16:
          *a4 = 1;
          goto LABEL_18;
        }
        if (v8 == 1885960244) {
          goto LABEL_16;
        }
        if (v8 != 1920298616 && v8 != 1919824760) {
          goto LABEL_17;
        }
        *a4 = 2;
      }
LABEL_18:
      ++a4;
      v5 += 2;
    }
  }
  if (v4 == a2) {
    return 13;
  }
  else {
    return 0;
  }
}

uint64_t TTGetGlyphNameFromGlyphID(TFont *a1, uint64_t a2, unsigned __int16 *a3, unsigned int *a4, unsigned char *a5)
{
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v23 = v9;
  long long v24 = v9;
  long long v21 = v9;
  long long v22 = v9;
  cacheCallContext::cacheCallContext((cacheCallContext *)&v21, a1, 0, 0);
  uint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  CreateFontCacheNode(*((const TFont **)&v22 + 1), &v20);
  uint64_t v10 = v20;
  if (v20)
  {
    unsigned int v11 = *a4;
    unsigned int v19 = *a4;
    memset(__b, 170, 0x398uLL);
    memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)&v21);
    v17[8] = 0xAAAAAAAAAA000000;
    v17[5] = 0xAAAAAAAAAAAAAAAALL;
    v17[0] = __b;
    v17[1] = 1358921729;
    v17[2] = 1358921729;
    v17[3] = 1358921729;
    v17[4] = 0;
    v17[6] = 1358921729;
    v17[7] = 1358921729;
    AssureScalerFontBlock(v17, (memoryContext *)__b, v10);
    unsigned int v12 = 0;
    ++*(_WORD *)(v10 + 16);
    do
    {
      int GlyphNameFromGlyphID = GetGlyphNameFromGlyphID((uint64_t)v17, (memoryContext *)__b, a2, a3, &v19, a5);
      __int16 v14 = GlyphNameFromGlyphID;
      if (GlyphNameFromGlyphID) {
        break;
      }
      a5 += v19;
      ++a3;
      v11 -= v19;
      v12 += v19;
      unsigned int v19 = v11;
      a2 = (a2 - 1);
    }
    while (a2);
    *a4 = v12;
    --*(_WORD *)(v10 + 16);
    memoryContext::~memoryContext((memoryContext *)__b);
    uint64_t v15 = *(void *)(v10 + 8);
    if (v15) {
      free((void *)(v15 - 8));
    }
    MEMORY[0x1BA9994D0](v10, 0x1080C40587D25DELL);
  }
  else
  {
    __int16 v14 = 20;
  }
  UnCacheCurrentGlyph((cacheCallContext *)&v21);
  return v14;
}

void sub_1B52C3870(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  memoryContext::~memoryContext((memoryContext *)va);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    if (!*(void *)(v11 - 152)) {
      JUMPOUT(0x1B52C3844);
    }
    JUMPOUT(0x1B52C3814);
  }
  std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100]((uint64_t *)(v11 - 152), 0);
  UnCacheCurrentGlyph((cacheCallContext *)(v11 - 144));
  _Unwind_Resume(a1);
}

uint64_t TTGetGlyphIDFromGlyphName(TFont *a1, char *a2, unsigned int *a3, uint64_t a4)
{
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v17 = v7;
  long long v18 = v7;
  long long v15 = v7;
  long long v16 = v7;
  cacheCallContext::cacheCallContext((cacheCallContext *)&v15, a1, 0, 0);
  uint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  CreateFontCacheNode(*((const TFont **)&v16 + 1), &v14);
  uint64_t v8 = v14;
  if (v14)
  {
    memset(__b, 170, sizeof(__b));
    memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)&v15);
    v12[5] = 0xAAAAAAAAAAAAAAAALL;
    v12[8] = 0xAAAAAAAAAA000000;
    v12[0] = __b;
    v12[1] = 1358921729;
    _OWORD v12[2] = 1358921729;
    void v12[3] = 1358921729;
    v12[4] = 0;
    v12[6] = 1358921729;
    v12[7] = 1358921729;
    AssureScalerFontBlock(v12, (memoryContext *)__b, v8);
    ++*(_WORD *)(v8 + 16);
    __int16 GlyphIDFromGlyphName = GetGlyphIDFromGlyphName((uint64_t)v12, (memoryContext *)__b, a2, a3, a4);
    --*(_WORD *)(v8 + 16);
    memoryContext::~memoryContext((memoryContext *)__b);
    uint64_t v10 = *(void *)(v8 + 8);
    if (v10) {
      free((void *)(v10 - 8));
    }
    MEMORY[0x1BA9994D0](v8, 0x1080C40587D25DELL);
  }
  else
  {
    __int16 GlyphIDFromGlyphName = 20;
  }
  UnCacheCurrentGlyph((cacheCallContext *)&v15);
  return GlyphIDFromGlyphName;
}

void sub_1B52C3A58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    if (!*(void *)(v19 - 120)) {
      JUMPOUT(0x1B52C3A34);
    }
    JUMPOUT(0x1B52C3A04);
  }
  std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100]((uint64_t *)(v19 - 120), 0);
  UnCacheCurrentGlyph((cacheCallContext *)(v19 - 112));
  _Unwind_Resume(a1);
}

uint64_t TTGetVariationScalars(const TStrikeDescription *a1, int a2, uint64_t a3)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v15[2] = v6;
  void v15[3] = v6;
  v15[0] = v6;
  v15[1] = v6;
  cacheCallContext::cacheCallContext((uint64_t)v15, (uint64_t)a1, 0, 0);
  memset(__b, 170, sizeof(__b));
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)v15);
  v13[8] = 0xAAAAAAAAAA000000;
  uint64_t v13[5] = 0xAAAAAAAAAAAAAAAALL;
  v13[0] = __b;
  v13[1] = 1358921729;
  _OWORD v13[2] = 1358921729;
  v13[3] = 1358921729;
  v13[4] = 0;
  v13[6] = 1358921729;
  v13[7] = 1358921729;
  uint64_t v11 = (os_unfair_lock_s *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v12 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  ResolveCacheStrike(a1, &v11);
  long long v7 = v11 + 2;
  os_unfair_lock_lock(v11 + 2);
  AssureStrikeBlocks(v13, (memoryContext *)__b, v11);
  if (*(void *)&v11[4]._os_unfair_lock_opaque
    && *(void *)&v11[6]._os_unfair_lock_opaque
    && *(void *)&v11[8]._os_unfair_lock_opaque)
  {
    if (a2 >= 1)
    {
      uint64_t v8 = 0;
      do
      {
        *(_DWORD *)(a3 + 4 * v8) = GetVariationScalar((uint64_t)v13, (__int16)v8);
        ++v8;
      }
      while ((unsigned __int16)a2 != v8);
    }
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 20;
  }
  os_unfair_lock_unlock(v7);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v12);
  }
  memoryContext::~memoryContext((memoryContext *)__b);
  UnCacheCurrentGlyph((cacheCallContext *)v15);
  return v9;
}

void sub_1B52C3C4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  os_unfair_lock_unlock(v20);
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:fe180100](a10);
  }
  memoryContext::~memoryContext((memoryContext *)&a20);
  UnCacheCurrentGlyph((cacheCallContext *)(v21 - 112));
  _Unwind_Resume(a1);
}

uint64_t TTGetVariationValues(const TStrikeDescription *a1, uint64_t a2, void *a3)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[2] = v6;
  v23[3] = v6;
  v23[0] = v6;
  v23[1] = v6;
  cacheCallContext::cacheCallContext((uint64_t)v23, (uint64_t)a1, 0, 0);
  memset(__b, 170, sizeof(__b));
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)v23);
  unint64_t v21 = 0xAAAAAAAAAA000000;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  int v13 = __b;
  uint64_t v14 = 1358921729;
  uint64_t v15 = 1358921729;
  uint64_t v16 = 1358921729;
  uint64_t v17 = 0;
  uint64_t v19 = 1358921729;
  uint64_t v20 = 1358921729;
  uint64_t v11 = (os_unfair_lock_s *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v12 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  ResolveCacheStrike(a1, &v11);
  long long v7 = v11 + 2;
  os_unfair_lock_lock(v11 + 2);
  AssureStrikeBlocks(&v13, (memoryContext *)__b, v11);
  if (!*(void *)&v11[4]._os_unfair_lock_opaque
    || !*(void *)&v11[6]._os_unfair_lock_opaque
    || !*(void *)&v11[8]._os_unfair_lock_opaque)
  {
    int v8 = 6;
LABEL_10:
    uint64_t v9 = OFAErrors(v8);
    goto LABEL_11;
  }
  int v8 = 4;
  if (!a3 || *(_DWORD *)(v14 + 72) != a2) {
    goto LABEL_10;
  }
  if (a2) {
    memmove(a3, *(const void **)(v15 + 16), 2 * a2);
  }
  uint64_t v9 = 0;
LABEL_11:
  os_unfair_lock_unlock(v7);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v12);
  }
  memoryContext::~memoryContext((memoryContext *)__b);
  UnCacheCurrentGlyph((cacheCallContext *)v23);
  return v9;
}

void sub_1B52C3E00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  os_unfair_lock_unlock(v20);
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:fe180100](a10);
  }
  memoryContext::~memoryContext((memoryContext *)&a20);
  UnCacheCurrentGlyph((cacheCallContext *)(v21 - 112));
  _Unwind_Resume(a1);
}

uint64_t TTGetTupleCount(const TStrikeDescription *a1, _WORD *a2)
{
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v21[2] = v4;
  uint64_t v21[3] = v4;
  v21[0] = v4;
  v21[1] = v4;
  cacheCallContext::cacheCallContext((uint64_t)v21, (uint64_t)a1, 0, 0);
  memset(__b, 170, sizeof(__b));
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)v21);
  unint64_t v19 = 0xAAAAAAAAAA000000;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v11 = __b;
  uint64_t v12 = 1358921729;
  uint64_t v13 = 1358921729;
  uint64_t v14 = 1358921729;
  uint64_t v15 = 0;
  uint64_t v17 = 1358921729;
  uint64_t v18 = 1358921729;
  uint64_t v9 = (os_unfair_lock_s *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  ResolveCacheStrike(a1, &v9);
  long long v5 = v9 + 2;
  os_unfair_lock_lock(v9 + 2);
  AssureStrikeBlocks(&v11, (memoryContext *)__b, v9);
  if (*(void *)&v9[4]._os_unfair_lock_opaque
    && *(void *)&v9[6]._os_unfair_lock_opaque
    && *(void *)&v9[8]._os_unfair_lock_opaque)
  {
    if (a2)
    {
      uint64_t v6 = 0;
      *a2 = *(_DWORD *)(v12 + 76);
      goto LABEL_8;
    }
    int v7 = 4;
  }
  else
  {
    int v7 = 6;
  }
  uint64_t v6 = OFAErrors(v7);
LABEL_8:
  os_unfair_lock_unlock(v5);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v10);
  }
  memoryContext::~memoryContext((memoryContext *)__b);
  UnCacheCurrentGlyph((cacheCallContext *)v21);
  return v6;
}

void sub_1B52C3F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  os_unfair_lock_unlock(v20);
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:fe180100](a10);
  }
  memoryContext::~memoryContext((memoryContext *)&a20);
  UnCacheCurrentGlyph((cacheCallContext *)(v21 - 96));
  _Unwind_Resume(a1);
}

unsigned char *SquishInPlace(unsigned char *result, unsigned int a2, int a3, int a4, int *a5)
{
  if (a3 < 1)
  {
    int v11 = 0;
  }
  else
  {
    int v5 = 0;
    int v6 = 0;
    int v7 = &result[a2];
    int v8 = a2 * (a3 - 2) + 1;
    int v9 = 1;
    do
    {
      int v10 = v9;
      int v11 = (v9 * a4 + 0x8000) >> 16;
      if (v11 == v9 - v5)
      {
        result += a2;
        v7 += a2;
      }
      else
      {
        uint64_t v12 = v7;
        uint64_t v13 = result;
        if ((int)a2 >= 1)
        {
          unsigned int v14 = a2 + 1;
          uint64_t v13 = result;
          uint64_t v12 = v7;
          do
          {
            char v15 = *v12++;
            *v13++ |= v15;
            --v14;
          }
          while (v14 > 1);
        }
        if ((int)((a3 - 2 - v6) * a2) >= 1)
        {
          unsigned int v16 = v8;
          do
          {
            char v17 = *v12++;
            *v13++ = v17;
            --v16;
          }
          while (v16 > 1);
        }
        ++v5;
      }
      int v9 = v10 + 1;
      v8 -= a2;
      int v6 = v10;
    }
    while (v10 != a3);
  }
  *a5 = v11;
  return result;
}

void std::__shared_weak_count::__release_shared[abi:fe180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

uint64_t *std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 8);
    if (v3) {
      free((void *)(v3 - 8));
    }
    JUMPOUT(0x1BA9994D0);
  }
  return result;
}

size_t sfp_decompress_brotli(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  return compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_BROTLI);
}

uint64_t BytesToCard(const unsigned __int8 *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = a1;
  uint64_t result = *a1;
  if (a2 != 2)
  {
    if (a2 != 3)
    {
      if (a2 != 4) {
        return result;
      }
      int v4 = *++v2;
      LODWORD(result) = v4 | (result << 8);
    }
    int v5 = *++v2;
    LODWORD(result) = v5 | (result << 8);
  }
  return v2[1] | (result << 8);
}

unint64_t IntToPString(unint64_t result, unsigned __int8 *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if ((result & 0x80000000) != 0)
  {
    unsigned int v6 = -(int)result;
    unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
    int v12 = -1431655766;
    int v7 = (unint64_t *)&v10;
    do
    {
      *((unsigned char *)v7 + 1) = (v6 % 0xA) | 0x30;
      int v7 = (unint64_t *)((char *)v7 + 1);
      BOOL v3 = v6 > 9;
      v6 /= 0xAu;
    }
    while (v3);
    LOBYTE(v8) = (_BYTE)a2 + 2;
    if (v7 >= &v11)
    {
      int v8 = a2 + 2;
      do
      {
        unsigned __int8 v9 = *(unsigned char *)v7;
        int v7 = (unint64_t *)((char *)v7 - 1);
        *v8++ = v9;
      }
      while (v7 >= &v11);
    }
    *a2 = (_BYTE)v8 - ((_BYTE)a2 + 2) + 1;
    a2[1] = 45;
  }
  else
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
    int v12 = -1431655766;
    uint64_t v2 = (unint64_t *)&v10;
    do
    {
      *((unsigned char *)v2 + 1) = (result % 0xA) | 0x30;
      uint64_t v2 = (unint64_t *)((char *)v2 + 1);
      BOOL v3 = result > 9;
      uint64_t result = result / 0xAuLL;
    }
    while (v3);
    LOBYTE(v4) = (_BYTE)a2 + 1;
    if (v2 >= &v11)
    {
      int v4 = a2 + 1;
      do
      {
        unsigned __int8 v5 = *(unsigned char *)v2;
        uint64_t v2 = (unint64_t *)((char *)v2 - 1);
        *v4++ = v5;
      }
      while (v2 >= &v11);
    }
    *a2 = (_BYTE)v4 - ((_BYTE)a2 + 1);
  }
  return result;
}

uint64_t FixedToPString(unsigned int a1, int a2, unsigned __int8 *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  char v23 = -86;
  *(void *)&__n[1] = 0xAAAAAAAAAAAAAAAALL;
  __n[0] = 0;
  if ((a1 & 0x80000000) != 0)
  {
    unsigned int v7 = -a1;
    uint64_t result = -65536 * a1;
    if (result)
    {
      uint64_t result = FractionalToPString(result, a2, __n);
      int v8 = (unsigned __int16)result;
    }
    else
    {
      int v8 = 0;
    }
    unsigned int v16 = v8 + HIWORD(v7);
    unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
    int v25 = -1431655766;
    char v17 = &v23;
    do
    {
      *++char v17 = (v16 % 0xA) | 0x30;
      BOOL v11 = v16 > 9;
      v16 /= 0xAu;
    }
    while (v11);
    LOBYTE(v18) = (_BYTE)a3 + 2;
    if (v17 >= (char *)&v24)
    {
      uint64_t v18 = a3 + 2;
      do
      {
        unsigned __int8 v19 = *v17--;
        *v18++ = v19;
      }
      while (v17 >= (char *)&v24);
    }
    unsigned __int8 v15 = (_BYTE)v18 - ((_BYTE)a3 + 2) + 1;
    *a3 = v15;
    a3[1] = 45;
  }
  else
  {
    uint64_t result = a1 << 16;
    if (result)
    {
      uint64_t result = FractionalToPString(result, a2, __n);
      int v6 = (unsigned __int16)result;
    }
    else
    {
      int v6 = 0;
    }
    unsigned int v9 = v6 + HIWORD(a1);
    unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
    int v25 = -1431655766;
    char v10 = &v23;
    do
    {
      *++char v10 = (v9 % 0xA) | 0x30;
      BOOL v11 = v9 > 9;
      v9 /= 0xAu;
    }
    while (v11);
    char v12 = (_BYTE)a3 + 1;
    LOBYTE(v13) = (_BYTE)a3 + 1;
    if (v10 >= (char *)&v24)
    {
      uint64_t v13 = a3 + 1;
      do
      {
        unsigned __int8 v14 = *v10--;
        *v13++ = v14;
      }
      while (v10 >= (char *)&v24);
    }
    unsigned __int8 v15 = (_BYTE)v13 - v12;
    *a3 = (_BYTE)v13 - v12;
  }
  size_t v20 = __n[0];
  if (__n[0])
  {
    uint64_t v21 = &a3[v15];
    v21[1] = 46;
    uint64_t result = (uint64_t)memcpy(v21 + 2, &__n[1], v20);
    *a3 += v20 + 1;
  }
  return result;
}

BOOL FractionalToPString(int a1, int a2, unsigned __int8 *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = 1000000000;
  if (a1)
  {
    unsigned int v4 = 500000000;
    do
    {
      v3 += v4 & (a1 >> 31);
      a1 *= 2;
      if (!a1) {
        break;
      }
      BOOL v5 = v4 > 1;
      v4 >>= 1;
    }
    while (v5);
  }
  if (a2 <= 7)
  {
    int v6 = 0;
    uint32x4_t v7 = (uint32x4_t)vdupq_n_s32(7 - a2);
    int32x4_t v8 = (int32x4_t)xmmword_1B53928A0;
    v9.i64[0] = 0xA0000000ALL;
    v9.i64[1] = 0xA0000000ALL;
    do
    {
      int8x16_t v10 = (int8x16_t)v8;
      int32x4_t v8 = vmulq_s32(v8, v9);
      v6 += 4;
    }
    while (((11 - a2) & 0xFFFFFFFC) != v6);
    int8x16_t v11 = vbslq_s8((int8x16_t)vcgtq_u32((uint32x4_t)vorrq_s8((int8x16_t)vdupq_n_s32(v6 - 4), (int8x16_t)xmmword_1B53928B0), v7), v10, (int8x16_t)v8);
    *(int32x2_t *)v11.i8 = vmul_s32(*(int32x2_t *)v11.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL));
    v3 += v11.i32[0] * v11.i32[1];
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  __int16 v19 = -21846;
  char v12 = (unint64_t *)v17;
  unsigned int v13 = v3;
  do
  {
    *((unsigned char *)v12 + 3) = (v13 % 0xA) | 0x30;
    char v12 = (unint64_t *)((char *)v12 + 1);
    BOOL v5 = v13 > 9;
    v13 /= 0xAu;
  }
  while (v5);
  LOBYTE(v14) = (_BYTE)a3 + 1;
  if (a2 >= 1)
  {
    LOBYTE(v14) = (_BYTE)a3 + 1;
    if ((unint64_t *)((char *)v12 + 1) >= &v18)
    {
      LOWORD(v15) = 0;
      unsigned __int8 v14 = a3 + 1;
      do
      {
        *v14++ = *((unsigned char *)v12 + 1);
        if (v12 < &v18) {
          break;
        }
        int v15 = (__int16)(v15 + 1);
        char v12 = (unint64_t *)((char *)v12 - 1);
      }
      while (v15 < a2);
    }
  }
  BOOL result = v3 > 0x773593FF;
  *a3 = (_BYTE)v14 - ((_BYTE)a3 + 1);
  return result;
}

uint64_t FractToPString(unsigned int a1, int a2, unsigned __int8 *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unsigned __int8 __n[9] = -86;
  *(void *)&__n[1] = 0xAAAAAAAAAAAAAAAALL;
  __n[0] = 0;
  if ((a1 & 0x80000000) != 0)
  {
    unsigned int v7 = -a1;
    uint64_t result = -4 * a1;
    if (result)
    {
      uint64_t result = FractionalToPString(result, a2, __n);
      char v8 = result;
    }
    else
    {
      char v8 = 0;
    }
    a3[2] = (v8 + (v7 >> 30)) | 0x30;
    *(_WORD *)a3 = 11522;
    uint64_t v9 = 2;
  }
  else
  {
    uint64_t result = 4 * a1;
    if (result)
    {
      uint64_t result = FractionalToPString(result, a2, __n);
      char v6 = result;
    }
    else
    {
      char v6 = 0;
    }
    a3[1] = (v6 + (a1 >> 30)) | 0x30;
    uint64_t v9 = 1;
    *a3 = 1;
  }
  size_t v10 = __n[0];
  if (__n[0])
  {
    int8x16_t v11 = &a3[v9];
    v11[1] = 46;
    uint64_t result = (uint64_t)memcpy(v11 + 2, &__n[1], v10);
    *a3 += v10 + 1;
  }
  return result;
}

uint64_t StringToInt(const char *a1)
{
  int v1 = *(unsigned __int8 *)a1;
  if (v1 == 45 || v1 == 43)
  {
    BOOL v2 = v1 == 45;
    int v3 = *(unsigned __int8 *)++a1;
    int v1 = v3;
  }
  else
  {
    BOOL v2 = 0;
  }
  if ((v1 - 48) > 9)
  {
    unsigned int v4 = 0;
  }
  else
  {
    unsigned int v4 = 0;
    BOOL v5 = a1 + 1;
    do
    {
      unsigned int v4 = v1 + 10 * v4 - 48;
      int v6 = *(unsigned __int8 *)v5++;
      int v1 = v6;
    }
    while ((v6 - 48) < 0xA);
  }
  if (v2) {
    return -v4;
  }
  else {
    return v4;
  }
}

uint64_t HexToInt(const char *a1)
{
  char v1 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t result = 0;
  unsigned int v4 = a1 + 1;
  do
  {
    int v5 = v1;
    if ((v1 - 48) >= 0xAu)
    {
      if ((v1 - 65) >= 6)
      {
        if ((v1 - 97) > 5) {
          return result;
        }
        int v6 = -87;
      }
      else
      {
        int v6 = -55;
      }
    }
    else
    {
      int v6 = -48;
    }
    uint64_t result = (v5 + 16 * result + v6);
    int v7 = *(unsigned __int8 *)v4++;
    char v1 = v7;
  }
  while (v7);
  return result;
}

void *BlendHintBlock(unsigned __int16 *a1, uint64_t a2, void *__dst)
{
  if (a2 && (uint64_t v4 = a1[36], v4 >= 2))
  {
    uint64_t v5 = 0;
    int v6 = 0;
    uint64_t v62 = 0;
    int32x4_t v7 = 0uLL;
    memset(v61, 0, sizeof(v61));
    memset(v60, 0, sizeof(v60));
    long long v59 = 0u;
    int32x4_t v57 = 0u;
    memset(v58, 0, sizeof(v58));
    int32x4_t v55 = 0u;
    int32x4_t v56 = 0u;
    char v8 = a1 + 44;
    uint64_t v9 = a1[31];
    uint64_t v10 = a1[32];
    int8x16_t v11 = a1 + 70;
    uint64_t v12 = a1[33];
    uint64_t v13 = a1 + 94;
    unsigned __int8 v14 = a1 + 124;
    int v15 = a1 + 172;
    int32x4_t v16 = 0uLL;
    uint64_t v17 = a1[34];
    int32x4_t v18 = 0uLL;
    float64x2_t v19 = (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL);
    do
    {
      double v20 = (double)*(int *)(a2 + 4 * v5) * 0.0000152587891;
      uint64_t v21 = (int *)v11;
      long long v22 = (_DWORD *)v58 + 1;
      uint64_t v23 = v9;
      if (v9)
      {
        do
        {
          int v24 = *v21++;
          *v22++ += vcvtd_n_s64_f64(v20 * ((double)v24 * 0.0000152587891), 0x10uLL);
          --v23;
        }
        while (v23);
      }
      int v25 = (int *)v13;
      uint64_t v26 = (_DWORD *)&v58[3] + 1;
      uint64_t v27 = v10;
      if (v10)
      {
        do
        {
          int v28 = *v25++;
          *v26++ += vcvtd_n_s64_f64(v20 * ((double)v28 * 0.0000152587891), 0x10uLL);
          --v27;
        }
        while (v27);
      }
      long long v29 = &v8[180 * v5];
      long long v31 = *(_OWORD *)v29;
      long long v30 = *((_OWORD *)v29 + 1);
      long long v32 = *((_OWORD *)v29 + 2);
      int v33 = *((_DWORD *)v29 + 12);
      uint64_t v34 = &v8[180 * v5];
      uint64_t v35 = *(void *)(v34 + 74);
      v36.i64[0] = (int)v35;
      v36.i64[1] = SHIDWORD(v35);
      double v37 = (double)*((int *)v34 + 39);
      *(int32x2_t *)((char *)&v59 + 4) = vadd_s32(*(int32x2_t *)((char *)&v59 + 4), vmovn_s64(vcvtq_n_s64_f64(vmulq_n_f64(vmulq_f64(vcvtq_f64_s64(v36), v19), v20), 0x10uLL)));
      HIDWORD(v59) += vcvtd_n_s64_f64(v20 * (v37 * 0.0000152587891), 0x10uLL);
      unsigned int v38 = v14;
      int v39 = (int32x2_t *)v60;
      uint64_t v40 = v12;
      if (v12)
      {
        do
        {
          uint64_t v41 = *(void *)v38;
          v38 += 4;
          v42.i64[0] = (int)v41;
          v42.i64[1] = SHIDWORD(v41);
          *int v39 = vadd_s32(*v39, vmovn_s64(vcvtq_n_s64_f64(vmulq_n_f64(vmulq_f64(vcvtq_f64_s64(v42), v19), v20), 0x10uLL)));
          ++v39;
          --v40;
        }
        while (v40);
      }
      int v43 = v15;
      int v44 = (int32x2_t *)v61;
      uint64_t v45 = v17;
      if (v17)
      {
        do
        {
          uint64_t v46 = *(void *)v43;
          v43 += 4;
          v47.i64[0] = (int)v46;
          v47.i64[1] = SHIDWORD(v46);
          *int v44 = vadd_s32(*v44, vmovn_s64(vcvtq_n_s64_f64(vmulq_n_f64(vmulq_f64(vcvtq_f64_s64(v47), v19), v20), 0x10uLL)));
          ++v44;
          --v45;
        }
        while (v45);
      }
      v48.i64[0] = (int)v31;
      v48.i64[1] = SDWORD1(v31);
      float64x2_t v49 = vcvtq_f64_s64(v48);
      v48.i64[0] = SDWORD2(v31);
      v48.i64[1] = SHIDWORD(v31);
      int32x4_t v7 = vaddq_s32(v7, vuzp1q_s32((int32x4_t)vcvtq_n_s64_f64(vmulq_n_f64(vmulq_f64(v49, v19), v20), 0x10uLL), (int32x4_t)vcvtq_n_s64_f64(vmulq_n_f64(vmulq_f64(vcvtq_f64_s64(v48), v19), v20), 0x10uLL)));
      v48.i64[0] = (int)v30;
      v48.i64[1] = SDWORD1(v30);
      float64x2_t v50 = vcvtq_f64_s64(v48);
      v48.i64[0] = SDWORD2(v30);
      v48.i64[1] = SHIDWORD(v30);
      int32x4_t v16 = vaddq_s32(v16, vuzp1q_s32((int32x4_t)vcvtq_n_s64_f64(vmulq_n_f64(vmulq_f64(v50, v19), v20), 0x10uLL), (int32x4_t)vcvtq_n_s64_f64(vmulq_n_f64(vmulq_f64(vcvtq_f64_s64(v48), v19), v20), 0x10uLL)));
      v48.i64[0] = (int)v32;
      v48.i64[1] = SDWORD1(v32);
      float64x2_t v51 = vcvtq_f64_s64(v48);
      v48.i64[0] = SDWORD2(v32);
      v48.i64[1] = SHIDWORD(v32);
      v6 += vcvtd_n_s64_f64(v20 * ((double)v33 * 0.0000152587891), 0x10uLL);
      unsigned int v52 = vcvtd_n_s64_f64(v20 * ((double)*(int *)&v8[180 * v5++ + 176] * 0.0000152587891), 0x10uLL);
      v11 += 180;
      int32x4_t v18 = vaddq_s32(v18, vuzp1q_s32((int32x4_t)vcvtq_n_s64_f64(vmulq_n_f64(vmulq_f64(v51, v19), v20), 0x10uLL), (int32x4_t)vcvtq_n_s64_f64(vmulq_n_f64(vmulq_f64(vcvtq_f64_s64(v48), v19), v20), 0x10uLL)));
      LODWORD(v62) = v62 + v52;
      v13 += 180;
      v14 += 180;
      v15 += 180;
    }
    while (v5 != v4);
    int32x4_t v55 = v7;
    int32x4_t v56 = v16;
    int32x4_t v57 = v18;
    LODWORD(v58[0]) = v6;
    uint64_t v53 = &v55;
  }
  else
  {
    uint64_t v53 = (int32x4_t *)(a1 + 44);
  }
  uint64_t result = memcpy(__dst, v53, 0x168uLL);
  if ((*((_DWORD *)__dst + 4) & 0x80000000) != 0) {
    *((_DWORD *)__dst + 4) = 0;
  }
  if ((*((_DWORD *)__dst + 5) & 0x80000000) != 0) {
    *((_DWORD *)__dst + 5) = 0;
  }
  return result;
}

uint64_t ComputeUnscaledBounds(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(result + 4);
  int v3 = *(__int16 **)(result + 72);
  uint64_t v4 = *(__int16 **)(result + 80);
  *(void *)a2 = 0x800080007FFF7FFFLL;
  __int16 v5 = 0x7FFF;
  __int16 v6 = 0x8000;
  __int16 v7 = 0x8000;
  __int16 v8 = 0x7FFF;
  do
  {
    int v10 = *v3++;
    int v9 = v10;
    if (v10 < v8)
    {
      *(_WORD *)a2 = v9;
      __int16 v8 = v9;
    }
    if (v9 > v7)
    {
      *(_WORD *)(a2 + 4) = v9;
      __int16 v7 = v9;
    }
    int v12 = *v4++;
    int v11 = v12;
    if (v12 < v5)
    {
      *(_WORD *)(a2 + 2) = v11;
      __int16 v5 = v11;
    }
    if (v11 > v6)
    {
      *(_WORD *)(a2 + 6) = v11;
      __int16 v6 = v11;
    }
    --v2;
  }
  while (v2);
  return result;
}

uint64_t OffsetOutline(uint64_t result, _DWORD *a2, _DWORD *a3, int a4, int a5)
{
  int v5 = *(_DWORD *)(result + 4);
  if (v5 < 1)
  {
    if (!v5) {
      return result;
    }
LABEL_8:
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  if (v5 >= *(_DWORD *)(result + 112)) {
    goto LABEL_8;
  }
  if (a4 && a5)
  {
    do
    {
      *a2++ += a4;
      *a3++ += a5;
      --v5;
    }
    while (v5);
  }
  else if (a4)
  {
    do
    {
      *a2++ += a4;
      --v5;
    }
    while (v5);
  }
  else if (a5)
  {
    do
    {
      *a3++ += a5;
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t ScaleGlyphOutline(uint64_t result, float a2, float a3)
{
  int v3 = *(_DWORD *)(result + 4) + 8;
  uint64_t v4 = *(__int16 **)(result + 72);
  int v5 = *(__int16 **)(result + 80);
  __int16 v6 = *(_DWORD **)(result + 8);
  __int16 v7 = *(_DWORD **)(result + 16);
  do
  {
    int v8 = *v4++;
    *v6++ = llroundf((float)(v8 << 6) * a2);
    int v9 = *v5++;
    *v7++ = llroundf((float)(v9 << 6) * a3);
    --v3;
  }
  while (v3);
  return result;
}

uint64_t RoundPhantomPoints(uint64_t a1, int a2, int a3)
{
  uint64_t v5 = *(int *)(a1 + 4);
  __int16 v6 = *(_DWORD **)(a1 + 8);
  __int16 v7 = *(_DWORD **)(a1 + 16);
  int v8 = &v6[v5];
  int v9 = &v7[v5];
  int v10 = (unsigned int *)(*(void *)(a1 + 56) + 4 * v5);
  int v11 = (unsigned int *)(*(void *)(a1 + 64) + 4 * v5);
  unsigned int v12 = *v8;
  unsigned int v13 = (*v8 + 32) & 0xFFFFFFC0;
  *int v8 = v13;
  *int v10 = v13;
  v10[1] = v8[1] - v12 + *v8;
  v8[1] = *v8 + ((a2 + 32) & 0xFFFFFFC0);
  v11[3] = v9[3];
  unsigned int v14 = v9[2];
  v9[3] = (v9[3] + 32) & 0xFFFFFFC0;
  _OWORD v11[2] = v14;
  _OWORD v9[2] = v9[3] + ((a3 + 32) & 0xFFFFFFC0);
  *int v11 = *v9;
  unsigned int v15 = v9[1];
  *int v9 = (*v9 + 32) & 0xFFFFFFC0;
  v11[1] = v15;
  v9[1] = (v9[1] + 32) & 0xFFFFFFC0;
  v10[2] = v8[2];
  unsigned int v16 = v8[3];
  v8[2] = (v8[2] + 32) & 0xFFFFFFC0;
  _OWORD v10[3] = v16;
  v8[3] = (v8[3] + 32) & 0xFFFFFFC0;
  return OffsetOutline(a1, v6, v7, *v8 - v12, 0);
}

void UnfoldGlyphOutline(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned int a4, _WORD *a5, unsigned __int16 **a6)
{
  int v6 = bswap32(*a3);
  if (*(_DWORD *)(a2 + 108) < v6 >> 16
    || (int v7 = v6 >> 16, v7 < 0)
    || (v10 = *(unsigned __int16 **)(a2 + 24), int v9 = *(_WORD **)(a2 + 32), v9 - v10 < v7))
  {
LABEL_51:
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  if (!*a3)
  {
LABEL_49:
    *(void *)(a2 + 92) = 0;
    *a5 = 0;
    *a6 = 0;
    return;
  }
  unsigned __int16 v11 = 0;
  unsigned __int16 v12 = 0;
  *(_DWORD *)a2 = v7;
  *(_DWORD *)(a2 + 4) = 0;
  unsigned int v13 = a3 + 7;
  int v14 = v7;
  unint64_t v15 = (unint64_t)a3 + a4;
  do
  {
    unsigned __int16 v16 = v12;
    unsigned __int16 v12 = v11;
    if (v11 < v16) {
      goto LABEL_51;
    }
    *v10++ = v11;
    if ((unint64_t)v13 > v15) {
      goto LABEL_51;
    }
    unsigned int v17 = bswap32(*(v13 - 2)) >> 16;
    *int v9 = v17;
    if (v17 < v12) {
      goto LABEL_49;
    }
    ++v9;
    unsigned __int16 v11 = v17 + 1;
    ++v13;
    --v14;
  }
  while (v14);
  unsigned int v18 = bswap32(*(v13 - 3)) >> 16;
  uint64_t v19 = v18 + 1;
  *(_DWORD *)(a2 + 4) = v19;
  signed int v20 = *(_DWORD *)(a2 + 112);
  if (v20 <= (int)v18 || v20 - (int)v19 <= 7)
  {
    *(void *)a2 = 0;
    goto LABEL_49;
  }
  *(_WORD *)(a2 + 92) = bswap32(a3[1]) >> 16;
  *(_WORD *)(a2 + 94) = bswap32(a3[2]) >> 16;
  *(_WORD *)(a2 + 96) = bswap32(a3[3]) >> 16;
  *(_WORD *)(a2 + 98) = bswap32(a3[4]) >> 16;
  uint64_t v21 = &a3[(unsigned __int16)v7 + 5];
  unsigned int v23 = *v21;
  long long v22 = v21 + 1;
  int64_t v24 = bswap32(v23) >> 16;
  *a5 = v24;
  if ((char *)a3 + a4 - (char *)v22 < v24) {
    goto LABEL_51;
  }
  *a6 = v22;
  int v25 = *(unsigned char **)(a2 + 40);
  unint64_t v26 = (unint64_t)&v25[v19];
  uint64_t v27 = (unsigned __int8 *)v22 + v24;
  int v28 = v25;
  do
  {
    if ((unint64_t)v27 >= v15) {
      goto LABEL_51;
    }
    int v29 = *v27;
    *int v28 = v29;
    long long v30 = v28 + 1;
    if ((v29 & 8) != 0)
    {
      if ((unint64_t)(v27 + 1) >= v15) {
        goto LABEL_51;
      }
      int64_t v31 = v27[1];
      if ((uint64_t)(v26 - (void)v30) < v31) {
        goto LABEL_51;
      }
      v27 += 2;
      if (v31)
      {
        memset(v30, v29, v31);
        v28 += (v31 - 1) + 2;
        continue;
      }
    }
    else
    {
      ++v27;
    }
    ++v28;
  }
  while ((unint64_t)v28 < v26);
  long long v32 = *(char **)(a2 + 40);
  if (v28 - v32 != v19) {
    goto LABEL_51;
  }
  if ((unint64_t)v32 < v26)
  {
    int v33 = 0;
    uint64_t v34 = *(_WORD **)(a2 + 72);
    uint64_t v35 = &v25[v18] - v32 + 1;
    uint64_t v36 = v35;
    double v37 = *(char **)(a2 + 40);
    do
    {
      char v39 = *v37++;
      char v38 = v39;
      if ((v39 & 2) != 0)
      {
        if ((v38 & 0x10) != 0)
        {
          if ((unint64_t)v27 >= v15) {
            goto LABEL_51;
          }
          int v42 = *v27++;
          v33 += v42;
        }
        else
        {
          if ((unint64_t)v27 >= v15) {
            goto LABEL_51;
          }
          int v41 = *v27++;
          v33 -= v41;
        }
      }
      else if ((v38 & 0x10) == 0)
      {
        if ((unint64_t)(v27 + 1) >= v15) {
          goto LABEL_51;
        }
        unsigned int v40 = *(unsigned __int16 *)v27;
        v27 += 2;
        v33 += bswap32(v40) >> 16;
      }
      *v34++ = v33;
      --v36;
    }
    while (v36);
    int v43 = 0;
    int v44 = *(_WORD **)(a2 + 80);
    do
    {
      char v45 = *v32;
      if ((*v32 & 4) != 0)
      {
        if ((*v32 & 0x20) != 0)
        {
          if ((unint64_t)v27 >= v15) {
            goto LABEL_51;
          }
          int v48 = *v27++;
          v43 += v48;
        }
        else
        {
          if ((unint64_t)v27 >= v15) {
            goto LABEL_51;
          }
          int v47 = *v27++;
          v43 -= v47;
        }
      }
      else if ((*v32 & 0x20) == 0)
      {
        if ((unint64_t)(v27 + 1) >= v15) {
          goto LABEL_51;
        }
        unsigned int v46 = *(unsigned __int16 *)v27;
        v27 += 2;
        v43 += bswap32(v46) >> 16;
      }
      *v44++ = v43;
      *v32++ = v45 & 1;
      --v35;
    }
    while (v35);
  }
}

unsigned __int16 *UnfoldComponent(unsigned __int16 *a1, unint64_t a2, unsigned int a3, _WORD *a4, _WORD *a5, uint64_t a6, unsigned char *a7)
{
  uint64_t v8 = 1;
  if (a3) {
    uint64_t v8 = 2;
  }
  uint64_t v9 = v8 + ((a3 >> 3) & 1);
  if ((a3 & 0x40) != 0) {
    uint64_t v9 = v8 + 2;
  }
  uint64_t v10 = v8 | 4;
  if ((a3 & 0x80) == 0) {
    uint64_t v10 = v9;
  }
  unsigned __int16 v11 = &a1[v10];
  BOOL v12 = v11 < a1 || (unint64_t)v11 > a2;
  if (v12 && ((unint64_t)(a1 + 1) > a2 || (a2 - (unint64_t)a1) >> 1 != v10))
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3B0], 0);
  }
  if (a3)
  {
    *a4 = bswap32(*a1) >> 16;
    uint64_t result = a1 + 2;
    *a5 = bswap32(a1[1]) >> 16;
  }
  else
  {
    if ((a3 & 2) != 0)
    {
      *a4 = *(char *)a1;
      __int16 v13 = *((char *)a1 + 1);
    }
    else
    {
      *a4 = *(unsigned __int8 *)a1;
      __int16 v13 = *((unsigned __int8 *)a1 + 1);
    }
    *a5 = v13;
    uint64_t result = a1 + 1;
  }
  if ((a3 & 0xC8) != 0)
  {
    *a7 = 1;
    if ((long long *)a6 != &identityMatrix)
    {
      *(_OWORD *)a6 = identityMatrix;
      *(_OWORD *)(a6 + 16) = unk_1B54013C8;
      *(_DWORD *)(a6 + 32) = 0x40000000;
    }
    int v15 = 4 * ((int)bswap32(*result) >> 16);
    *(_DWORD *)a6 = v15;
    if ((a3 & 0x80) != 0)
    {
      *(_DWORD *)(a6 + 4) = 4 * ((int)bswap32(result[1]) >> 16);
      *(_DWORD *)(a6 + 12) = 4 * ((int)bswap32(result[2]) >> 16);
      unsigned int v16 = result[3];
      result += 4;
    }
    else
    {
      if ((a3 & 0x40) == 0)
      {
        *(_DWORD *)(a6 + 16) = v15;
        return ++result;
      }
      unsigned int v16 = result[1];
      result += 2;
    }
    *(_DWORD *)(a6 + 16) = 4 * ((int)bswap32(v16) >> 16);
  }
  else
  {
    *a7 = 0;
  }
  return result;
}

uint64_t AppendToGlyphOutline(uint64_t a1, void *a2)
{
  int v2 = HIDWORD(*(void *)a1);
  uint64_t v3 = *(void *)(a1 + 8) + 4 * v2;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  int32x2_t v6 = vsub_s32(*(int32x2_t *)(a1 + 108), *(int32x2_t *)a1);
  int v7 = *(void *)a1;
  uint64_t v8 = *(void *)(a1 + 24) + 2 * v7;
  uint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 64);
  uint64_t v11 = *(void *)(a1 + 32) + 2 * v7;
  uint64_t v13 = *(void *)(a1 + 72);
  uint64_t v12 = *(void *)(a1 + 80);
  uint64_t v14 = *(void *)(a1 + 16) + 4 * v2;
  uint64_t result = *(void *)(a1 + 120);
  a2[15] = result;
  a2[1] = v3;
  a2[2] = v14;
  a2[3] = v8;
  a2[4] = v11;
  a2[5] = v4 + v2;
  a2[6] = v5 + v2;
  a2[7] = v9 + 4 * v2;
  a2[8] = v10 + 4 * v2;
  a2[9] = v13 + 2 * v2;
  a2[10] = v12 + 2 * v2;
  *(int32x2_t *)((char *)a2 + 108) = v6;
  return result;
}

uint64_t MapF26Dot6(int a1, int *a2, int *a3, int *a4)
{
  int v7 = a1 + 8;
  uint64_t result = M3x3Flags(a4);
  if (result == 2)
  {
    int v10 = *a4;
    int v11 = a4[4];
    do
    {
      *a2 = (unint64_t)(*a2 * (uint64_t)v10 + 0x8000) >> 16;
      ++a2;
      *a3 = (unint64_t)(*a3 * (uint64_t)v11 + 0x8000) >> 16;
      ++a3;
      --v7;
    }
    while (v7);
  }
  else if (result == 4)
  {
    do
    {
      int v9 = ((unint64_t)(a4[4] * (uint64_t)*a3 + 0x8000) >> 16)
         + ((unint64_t)(a4[1] * (uint64_t)*a2 + 0x8000) >> 16);
      *a2 = ((unint64_t)(*a3 * (uint64_t)a4[3] + 0x8000) >> 16)
          + ((unint64_t)(*a2 * (uint64_t)*a4 + 0x8000) >> 16);
      ++a2;
      *a3++ = v9;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t MapOriginalOutline(uint64_t a1, int *a2)
{
  int v2 = *(_DWORD *)(a1 + 4);
  if (v2 > *(_DWORD *)(a1 + 112))
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t v4 = *(__int16 **)(a1 + 72);
  uint64_t v5 = *(__int16 **)(a1 + 80);
  uint64_t result = M3x3Flags(a2);
  if (result == 2)
  {
    int v13 = *a2;
    int v14 = a2[4];
    do
    {
      *uint64_t v4 = (*v4 * v13 + 0x8000) >> 16;
      ++v4;
      *uint64_t v5 = (*v5 * v14 + 0x8000) >> 16;
      ++v5;
      --v2;
    }
    while (v2);
  }
  else if (result == 4)
  {
    int v7 = *a2;
    int v8 = a2[1];
    int v9 = a2[3];
    int v10 = a2[4];
    do
    {
      int v11 = *v4;
      int v12 = *v5;
      *v4++ = ((v12 * v9 + 0x8000) >> 16) + ((v11 * v7 + 0x8000) >> 16);
      *v5++ = ((v12 * v10 + 0x8000) >> 16) + ((v11 * v8 + 0x8000) >> 16);
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t OffsetOriginalOutline(uint64_t result, int a2, int a3)
{
  uint64_t v3 = *(int *)(result + 4) + 4;
  if (*(_DWORD *)(result + 4) != -4)
  {
    if ((int)v3 >= *(_DWORD *)(result + 112)
      || (uint64_t v4 = *(_WORD **)(result + 80), (unint64_t)&v4[v3] >= *(void *)(result + 120)))
    {
      exception = __cxa_allocate_exception(2uLL);
      _WORD *exception = 5;
      __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
    }
    uint64_t v5 = *(_WORD **)(result + 72);
    if (a2 && a3)
    {
      do
      {
        *v5++ += a2;
        *v4++ += a3;
        LODWORD(v3) = v3 - 1;
      }
      while (v3);
    }
    else if (a2)
    {
      do
      {
        *v5++ += a2;
        LODWORD(v3) = v3 - 1;
      }
      while (v3);
    }
    else if (a3)
    {
      do
      {
        *v4++ += a3;
        LODWORD(v3) = v3 - 1;
      }
      while (v3);
    }
  }
  return result;
}

double ScaleAndMapOutline(uint64_t a1, int *a2, int a3, int a4)
{
  if (!a3)
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  int v8 = *(int **)(a1 + 56);
  int v7 = *(int **)(a1 + 64);
  int v10 = *(unsigned int **)(a1 + 8);
  int v9 = *(unsigned int **)(a1 + 16);
  uint64_t v11 = *(int *)(a1 + 4);
  uint64_t v12 = v11 + 8;
  int v14 = *(unsigned __int16 **)(a1 + 72);
  int v13 = *(unsigned __int16 **)(a1 + 80);
  int v15 = (int16x4_t *)&v14[v11];
  int16x4_t v16 = *v15;
  int16x4_t v17 = v15[1];
  unsigned int v18 = (int32x4_t *)&v8[v11];
  *unsigned int v18 = vshll_n_s16(v16, 6uLL);
  v18[1] = vshll_n_s16(v17, 6uLL);
  uint64_t v19 = *(int *)(a1 + 4);
  if (v19 != v11 + 8)
  {
    signed int v20 = &v7[v19];
    uint64_t v21 = &v13[v19];
    uint64_t v22 = 2 * v11 - 2 * v19 + 16;
    do
    {
      int v23 = (__int16)*v21++;
      *v20++ = v23 << 6;
      v22 -= 2;
    }
    while (v22);
  }
  unsigned int v24 = M3x3Flags(a2);
  if (v24 >= 4)
  {
    if (v24 - 4 >= 2)
    {
      if (v24 == 6)
      {
        unint64_t v37 = (unint64_t)(a2[8] + 0x2000) >> 14;
        uint64_t v38 = *(int *)(a1 + 4);
        if (v38)
        {
          uint64_t v39 = 4 * v38;
          uint64_t v40 = 4 * v38;
          int v41 = v14;
          do
          {
            int v42 = *v8++;
            int v43 = v42 + 32;
            unsigned int v44 = v42 + 95;
            if (v42 >= -32) {
              unsigned int v44 = v43;
            }
            *v41++ = v44 >> 6;
            v40 -= 4;
          }
          while (v40);
          char v45 = v13;
          do
          {
            int v46 = *v7++;
            int v47 = v46 + 32;
            unsigned int v48 = v46 + 95;
            if (v46 >= -32) {
              unsigned int v48 = v47;
            }
            *v45++ = v48 >> 6;
            v39 -= 4;
          }
          while (v39);
        }
        int v49 = a3 >> 1;
        int v50 = v37;
        OffsetOriginalOutline(a1, (__int16)-v14[(int)(v38 + 2 * (a4 != 0))], (__int16)-v13[(int)(v38 + 2 * (a4 != 0))]);
        do
        {
          int v51 = *v14++;
          int v52 = (v49 + (v51 << 16)) / a3;
          int v53 = *v13++;
          int v54 = (v49 + (v53 << 16)) / a3;
          double v55 = (double)(int)(((unint64_t)(a2[2] * (uint64_t)v52 + 0x20000000) >> 30)
                            + v50
                            + ((unint64_t)(a2[5] * (uint64_t)v54 + 0x20000000) >> 30))
              * 0.0000152587891;
          double result = (double)(int)(a2[7]
                               + ((unint64_t)(a2[1] * (uint64_t)v52 + 0x8000) >> 16)
                               + ((unint64_t)(a2[4] * (uint64_t)v54 + 0x8000) >> 16))
                 * 0.0000152587891
                 / v55;
          *v10++ = (vcvtd_n_s64_f64((double)(int)(a2[6]+ ((unint64_t)(*a2 * (uint64_t)v52 + 0x8000) >> 16)+ ((unint64_t)(a2[3] * (uint64_t)v54 + 0x8000) >> 16))* 0.0000152587891/ v55, 0x10uLL)+ 512) >> 10;
          *v9++ = (vcvtd_n_s64_f64(result, 0x10uLL) + 512) >> 10;
          LODWORD(v12) = v12 - 1;
        }
        while (v12);
      }
    }
    else
    {
      int v28 = *a2 / a3;
      int v29 = a2[3] / a3;
      int v30 = a2[1] / a3;
      int v31 = a2[4] / a3;
      do
      {
        int v33 = *v8++;
        int v32 = v33;
        int v34 = *v7++;
        *v10++ = ((unint64_t)(v29 * (uint64_t)v34 + 0x8000) >> 16)
               + ((unint64_t)(v28 * (uint64_t)v32 + 0x8000) >> 16);
        *v9++ = ((unint64_t)(v31 * (uint64_t)v34 + 0x8000) >> 16)
              + ((unint64_t)(v30 * (uint64_t)v32 + 0x8000) >> 16);
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
    }
  }
  else
  {
    int v26 = *a2 / a3;
    int v27 = a2[4] / a3;
    if (v26 == 0x10000 && a2[4] / a3 == 0x10000)
    {
      if (v12)
      {
        memmove(v10, v8, 4 * v12);
        memmove(v9, v7, 4 * v12);
      }
    }
    else
    {
      do
      {
        int v35 = *v8++;
        *v10++ = (unint64_t)(v26 * (uint64_t)v35 + 0x8000) >> 16;
        int v36 = *v7++;
        *v9++ = (unint64_t)(v27 * (uint64_t)v36 + 0x8000) >> 16;
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
    }
  }
  return result;
}

void GetHmtxData(uint64_t a1, int a2, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6)
{
  unsigned int v24 = (void *)0xAAAAAAAAAAAAAAAALL;
  int v25 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = *(void *)(a1 + 8);
  int v11 = *(unsigned __int16 *)(v10 + 146);
  *a5 = v11;
  if (a3 && v11)
  {
    if (v11 <= a2)
    {
      ScalerGetTableParts(*(memoryContext **)a1, *(_DWORD *)(v10 + 112), 4 * v11 - 4, 4u, &v25, 0);
      int v13 = (unsigned __int16 *)v25;
      *a3 = bswap32(*(unsigned __int16 *)v25) >> 16;
      int TableParts = ScalerGetTableParts(*(memoryContext **)a1, *(_DWORD *)(*(void *)(a1 + 8) + 112), 2 * (a2 - (unsigned __int16)*a5) + 4 * v11, 2u, &v24, 1);
      int16x4_t v16 = v24;
      if (TableParts) {
        BOOL v17 = v24 == 0;
      }
      else {
        BOOL v17 = 1;
      }
      if (v17)
      {
        a3[1] = 0;
      }
      else
      {
        a3[1] = bswap32(*(unsigned __int16 *)v24) >> 16;
        ScalerReleaseFontTable(*(memoryContext **)a1, v16);
      }
    }
    else
    {
      ScalerGetTableParts(*(memoryContext **)a1, *(_DWORD *)(v10 + 112), 4 * a2, 4u, &v25, 0);
      int v13 = (unsigned __int16 *)v25;
      *a3 = bswap32(*(unsigned __int16 *)v25) >> 16;
      a3[1] = bswap32(v13[1]) >> 16;
    }
    ScalerReleaseFontTable(*(memoryContext **)a1, v13);
  }
  int v18 = *(unsigned __int16 *)(v10 + 148);
  *a6 = v18;
  if (a4 && v18)
  {
    if (v18 <= a2)
    {
      ScalerGetTableParts(*(memoryContext **)a1, *(_DWORD *)(*(void *)(a1 + 8) + 116), 4 * v18 - 4, 4u, &v25, 0);
      uint64_t v19 = (unsigned __int16 *)v25;
      *a4 = bswap32(*(unsigned __int16 *)v25) >> 16;
      int v20 = ScalerGetTableParts(*(memoryContext **)a1, *(_DWORD *)(*(void *)(a1 + 8) + 116), 2 * (a2 - (unsigned __int16)*a6) + 4 * v18, 2u, &v24, 0);
      uint64_t v21 = v24;
      if (v20) {
        BOOL v22 = v24 == 0;
      }
      else {
        BOOL v22 = 1;
      }
      if (v22)
      {
        a4[1] = 0;
      }
      else
      {
        a4[1] = bswap32(*(unsigned __int16 *)v24) >> 16;
        ScalerReleaseFontTable(*(memoryContext **)a1, v21);
      }
    }
    else
    {
      ScalerGetTableParts(*(memoryContext **)a1, *(_DWORD *)(*(void *)(a1 + 8) + 116), 4 * a2, 4u, &v25, 0);
      uint64_t v19 = (unsigned __int16 *)v25;
      *a4 = bswap32(*(unsigned __int16 *)v25) >> 16;
      a4[1] = bswap32(v19[1]) >> 16;
    }
    int v23 = *(memoryContext **)a1;
    ScalerReleaseFontTable(v23, v19);
  }
}

uint64_t CountGlyphComponents(const __int16 *a1, unint64_t a2, unsigned int *a3)
{
  if (a3) {
    *a3 = 10;
  }
  LODWORD(v3) = 0;
  uint64_t v4 = a1;
  do
  {
    if (v4 < a1 || (unint64_t)(v4 + 1) > a2)
    {
      exception = __cxa_allocate_exception(2uLL);
      _WORD *exception = 5;
      __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
    }
    uint64_t v5 = v4 + 3;
    unsigned int v6 = bswap32(*(unsigned __int16 *)v4) >> 16;
    if (v6)
    {
      uint64_t v5 = v4 + 4;
    }
    else if (a3 && (v6 & 2) != 0)
    {
      *a3 += 2;
    }
    if ((v6 & 0x40) != 0) {
      uint64_t v7 = 2;
    }
    else {
      uint64_t v7 = 1;
    }
    uint64_t v4 = &v5[v7];
    if ((v6 & 0x80) != 0) {
      uint64_t v4 = v5 + 4;
    }
    if ((v6 & 0xC8) == 0) {
      uint64_t v4 = v5;
    }
    uint64_t v3 = (v3 + 1);
  }
  while ((v6 & 0x20) != 0);
  if (a3) {
    *a3 += v4 - a1;
  }
  return v3;
}

void StretchGlyph(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5, unsigned char *a6, unsigned int a7)
{
  uint64_t v150 = *MEMORY[0x1E4F143B8];
  int v116 = *(__int16 *)(a1[1] + 130);
  *(void *)a2 = 0;
  *a6 = 0;
  unsigned int v145 = -1431655766;
  unsigned int v146 = -1431655766;
  if ((GetSfntGlyph((uint64_t)a1, *(_DWORD *)(a2 + 88), &v146, &v145) & 1) == 0)
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t v144 = 0;
  uint64_t v13 = v145;
  if (!v145
    || (ScalerGetTableParts((memoryContext *)*a1, *(_DWORD *)(a1[1] + 104), v146, v145, &v144, 1), (int v14 = v144) == 0))
  {
    int v14 = 0;
    int v135 = 0;
    LOWORD(v123) = 0;
    *(void *)(a2 + 92) = 0;
LABEL_11:
    LoadGlyphMetrics((uint64_t)a1, a2);
    if (!*(unsigned char *)(a1[2] + 56) || !*(unsigned char *)(a1[1] + 156) || !ApplyFeaturesToOutline((uint64_t)a1, a2))
    {
      uint64_t v17 = *(int *)(a2 + 4);
      if (v17)
      {
        int v18 = *(__int16 **)(a2 + 72);
        uint64_t v19 = *(_DWORD **)(a2 + 56);
        uint64_t v20 = 2 * v17;
        do
        {
          int v21 = *v18++;
          *v19++ = llroundf((float)v21 * 64.0);
          v20 -= 2;
        }
        while (v20);
        uint64_t v22 = *(int *)(a2 + 4);
        if (v22)
        {
          int v23 = *(__int16 **)(a2 + 80);
          unsigned int v24 = *(_DWORD **)(a2 + 64);
          uint64_t v25 = 2 * v22;
          do
          {
            int v26 = *v23++;
            *v24++ = llroundf((float)v26 * 64.0);
            v25 -= 2;
          }
          while (v25);
        }
      }
    }
    ConstructPhantomPoints((_WORD *)a1[1], a2, (__int16)(*(_WORD *)(a2 + 92) - *(_WORD *)(a2 + 102)));
    if (a5)
    {
      uint64_t v27 = *(int *)(a2 + 4);
      uint64_t v28 = 2 * v27;
      uint64_t v29 = *(void *)(a2 + 80);
      int v30 = (int32x4_t *)(*(void *)(a2 + 56) + 4 * v27);
      int16x8_t v31 = *(int16x8_t *)(*(void *)(a2 + 72) + v28);
      float32x4_t v32 = (float32x4_t)vdupq_n_s32(0x42800000u);
      *int v30 = vcvtq_s32_f32(vrndaq_f32(vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v31.i8)), v32)));
      v30[1] = vcvtq_s32_f32(vrndaq_f32(vmulq_f32(vcvtq_f32_s32(vmovl_high_s16(v31)), v32)));
      int v33 = (int32x4_t *)(*(void *)(a2 + 64) + 4 * *(int *)(a2 + 4));
      int16x8_t v34 = *(int16x8_t *)(v29 + v28);
      *int v33 = vcvtq_s32_f32(vrndaq_f32(vmulq_f32(vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v34.i8)), v32)));
      v33[1] = vcvtq_s32_f32(vrndaq_f32(vmulq_f32(vcvtq_f32_s32(vmovl_high_s16(v34)), v32)));
      float v35 = (double)*(int *)(a3 + 36) * 0.0000152587891 / (double)v116;
      float v36 = (double)*(int *)(a3 + 52) * 0.0000152587891 / (double)v116;
      ScaleGlyphOutline(a2, v35, v36);
      RoundPhantomPoints(a2, llroundf((float)(v35 * (float)*(__int16 *)(a2 + 100)) * 64.0), llroundf((float)(v36 * (float)*(__int16 *)(a2 + 104)) * 64.0));
      if ((_WORD)v123)
      {
        size_t v37 = 4 * *(_DWORD *)(a2 + 4);
        memcpy(*(void **)(a2 + 56), *(const void **)(a2 + 8), v37);
        memcpy(*(void **)(a2 + 64), *(const void **)(a2 + 16), v37);
        RunGlyphProgram(a1, a2, a3, (unsigned __int16)v123, v135, 0);
      }
    }
    if (a4)
    {
      uint64_t v38 = *a4;
      *a4 = 0;
      if (v38) {
        MEMORY[0x1BA9994A0](v38, 0x1000C8052888210);
      }
    }
    goto LABEL_26;
  }
  int v15 = (unsigned __int16 *)((char *)v144 + v13);
  int16x4_t v16 = v144 + 1;
  if ((*v144 & 0x80) == 0)
  {
    int v135 = 0;
    LOWORD(v123) = 0;
    if (((unint64_t)v144 > 0xFFFFFFFFFFFFFFF5 || v144 + 5 > v15) && ((v13 & 0xFFFFFFFE) != 0xA || v16 > v15))
    {
      int v41 = __cxa_allocate_exception(2uLL);
      *int v41 = 5;
      __cxa_throw(v41, MEMORY[0x1E4FBA3C8], 0);
    }
    UnfoldGlyphOutline((uint64_t)a1, a2, v144, v13, &v123, (unsigned __int16 **)&v135);
    goto LABEL_11;
  }
  if (*(unsigned __int16 *)(a1[1] + 66) <= a7)
  {
    unint64_t v103 = __cxa_allocate_exception(2uLL);
    *unint64_t v103 = 5;
    __cxa_throw(v103, MEMORY[0x1E4FBA3C8], 0);
  }
  unint64_t v143 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v142 = v39;
  long long v141 = v39;
  long long v140 = v39;
  long long v139 = v39;
  long long v138 = v39;
  long long v137 = v39;
  long long v136 = v39;
  int v135 = 0;
  if (((unint64_t)v16 > 0xFFFFFFFFFFFFFFF7 || v144 + 5 > v15) && ((v13 & 0xFFFFFFFE) != 0xA || v144 + 2 > v15))
  {
    int v42 = __cxa_allocate_exception(2uLL);
    *int v42 = 5;
    __cxa_throw(v42, MEMORY[0x1E4FBA3C8], 0);
  }
  unsigned int v111 = a5;
  *(_WORD *)(a2 + 92) = bswap32(v144[1]) >> 16;
  *(_WORD *)(a2 + 94) = bswap32(v14[2]) >> 16;
  *(_WORD *)(a2 + 96) = bswap32(v14[3]) >> 16;
  uint64_t v40 = v14 + 5;
  uint64_t v144 = v14 + 5;
  *(_WORD *)(a2 + 98) = bswap32(v14[4]) >> 16;
  uint64_t v112 = a3;
  unint64_t v115 = (unint64_t)v14 + v13;
  if (*(unsigned char *)(a1[2] + 56))
  {
    CountGlyphComponents((const __int16 *)v14 + 5, (unint64_t)v15, 0);
    operator new[]();
  }
  uint64_t v113 = 0;
  uint64_t v114 = 0;
  int v108 = 0;
  char v43 = 0;
  unsigned int v110 = a7 + 1;
  double v44 = (double)(v116 << 10);
  int8x8_t v45 = (int8x8_t)0xAAAAAAAAAAAAAAAALL;
  int32x2_t v46 = (int32x2_t)0xAAAAAAAAAAAAAAAALL;
  v47.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v47.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  int32x4_t v107 = v47;
  do
  {
    if ((v14 > v40 || (unint64_t)v40 > 0xFFFFFFFFFFFFFFFBLL || (unint64_t)(v40 + 2) > v115)
      && (v14 > v40 || (unint64_t)(v40 + 1) > v115 || ((v115 - (void)v40) & 0xFFFFFFFFFFFFFFFELL) != 4))
    {
      uint64_t v144 = v40;
      goto LABEL_105;
    }
    char v134 = -86;
    char v133 = -86;
    int v132 = -1431655766;
    *(void *)&long long v48 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v48 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v130 = v48;
    long long v131 = v48;
    unsigned __int16 v129 = -21846;
    __int16 v128 = -21846;
    *(_OWORD *)&v127[28] = v48;
    *(_OWORD *)char v127 = v48;
    *(_OWORD *)&v127[16] = v48;
    long long v125 = v48;
    long long v126 = v48;
    long long v123 = v48;
    long long v124 = v48;
    int v49 = v40 + 2;
    unsigned int v50 = *v40;
    unsigned int v51 = bswap32(v40[1]) >> 16;
    int v52 = *(_DWORD *)(a2 + 88);
    LODWORD(v141) = v51;
    if (v52 == v51 || v51 >= *(unsigned __int16 *)(a1[1] + 40) || *(_DWORD *)(a2 + 4) > *(_DWORD *)(a2 + 112)) {
      goto LABEL_127;
    }
    unsigned int v53 = bswap32(v50) >> 16;
    int v54 = UnfoldComponent(v49, v115, v53, &v129, &v128, (uint64_t)&v130, &v134);
    uint64_t v40 = v54;
    if (v134)
    {
      *a6 = 1;
      if (v111)
      {
        long long v123 = v130;
        long long v124 = v131;
        LODWORD(v125) = v132;
        long long v147 = v130;
        long long v148 = v131;
        int v149 = v132;
        if (M3x3Concat((long long *)v112, -1, &v123, -1))
        {
          long long v123 = v147;
          long long v124 = v148;
          LODWORD(v125) = v149;
        }
        char v109 = 0;
        uint64_t v55 = DecomposeMapping((uint64_t)&v123, (*(unsigned __int8 *)(a1[1] + 128) >> 3) & 1) == 0;
        int32x4_t v56 = &v123;
      }
      else
      {
        char v109 = 1;
        uint64_t v55 = 0;
        int32x4_t v56 = 0;
      }
    }
    else
    {
      uint64_t v55 = v111;
      if (v111)
      {
        char v109 = 0;
        int32x4_t v56 = (long long *)v112;
      }
      else
      {
        int32x4_t v56 = 0;
        char v109 = 1;
      }
    }
    AppendToGlyphOutline(a2, &v135);
    bzero((char *)&v141 + 4, 8uLL);
    StretchGlyph(a1, &v135, v56, 0, v55, &v133, v110);
    if (v134)
    {
      if (v55)
      {
        int v122 = -1431655766;
        *(void *)&long long v57 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v57 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v121[0] = v57;
        v121[1] = v57;
        long long v118 = *(_OWORD *)&v127[8];
        long long v119 = *(_OWORD *)&v127[24];
        int v120 = *(_DWORD *)&v127[40];
        InvertRemainder((uint64_t)v121, (int *)(v112 + 72));
        long long v147 = *(_OWORD *)&v127[8];
        long long v148 = *(_OWORD *)&v127[24];
        int v149 = *(_DWORD *)&v127[40];
        if (M3x3Concat(v121, -1, &v118, -1))
        {
          long long v118 = v147;
          long long v119 = v148;
          int v120 = v149;
        }
        if (!CheckVitalElements((uint64_t)a1, (uint64_t)&v135))
        {
          uint64_t v144 = v54;
          unint64_t v104 = __cxa_allocate_exception(2uLL);
          *unint64_t v104 = 5;
          __cxa_throw(v104, MEMORY[0x1E4FBA3C8], 0);
        }
        MapF26Dot6(SHIDWORD(v135), (int *)v139, *((int **)&v139 + 1), (int *)&v118);
        MapF26Dot6(SHIDWORD(v135), (int *)v136, *((int **)&v136 + 1), (int *)&v118);
      }
      if (HIDWORD(v135)) {
        MapOriginalOutline((uint64_t)&v135, (int *)&v130);
      }
    }
    if ((v53 & 2) != 0)
    {
      if ((v53 & 0x1800) == 0x800 && v134)
      {
        uint64_t v62 = sqrt((double)(int)v130 * (double)(int)v130 + (double)SDWORD1(v130) * (double)SDWORD1(v130));
        LODWORD(v63) = (int)((double)(int)v130 * (double)(int)v131 / (double)(int)v62)
                     - (int)((double)SDWORD1(v130) * (double)SHIDWORD(v130) / (double)(int)v62);
        if ((int)v63 >= 0) {
          uint64_t v63 = v63;
        }
        else {
          uint64_t v63 = ((int)((double)SDWORD1(v130) * (double)SHIDWORD(v130) / (double)(int)v62)
        }
                             - (int)((double)(int)v130 * (double)(int)v131 / (double)(int)v62));
        unint64_t v64 = (unint64_t)(v62 * (__int16)v129 + 0x8000) >> 16;
        unsigned __int16 v129 = v64;
        unint64_t v65 = (unint64_t)(v63 * v128 + 0x8000) >> 16;
        __int16 v128 = v65;
        if (!v55)
        {
LABEL_86:
          unsigned int v60 = 0;
          int v61 = 0;
          goto LABEL_89;
        }
      }
      else
      {
        LOWORD(v64) = v129;
        LOWORD(v65) = v128;
        if (!v55) {
          goto LABEL_86;
        }
      }
      int v66 = (int)((double)(__int16)v64 * (double)*(int *)(v112 + 36) / v44);
      int v67 = (int)((double)(__int16)v65 * (double)*(int *)(v112 + 52) / v44);
      if ((v53 & 4) != 0) {
        unsigned int v60 = (v66 + 32) & 0xFFFFFFC0;
      }
      else {
        unsigned int v60 = v66;
      }
      if ((v53 & 4) != 0) {
        int v61 = (v67 + 32) & 0xFFFFFFC0;
      }
      else {
        int v61 = v67;
      }
      OffsetOutline((uint64_t)&v135, (_DWORD *)v136, *((_DWORD **)&v136 + 1), v60, v61);
      LOWORD(v64) = v129;
      LOWORD(v65) = v128;
    }
    else
    {
      signed __int16 v58 = v129;
      if ((v43 & ((v129 & 0x8000u) == 0)) != 1
        || *(_DWORD *)(a2 + 112) <= (int)v129
        || (__int16 v59 = v128, v128 < 0)
        || SDWORD2(v142) <= v128)
      {
        int v49 = v54;
LABEL_127:
        uint64_t v144 = v49;
        uint64_t v102 = __cxa_allocate_exception(2uLL);
        *uint64_t v102 = 5;
        __cxa_throw(v102, MEMORY[0x1E4FBA3C8], 0);
      }
      if (v55)
      {
        unsigned int v60 = *(_DWORD *)(*(void *)(a2 + 8) + 4 * v129) - *(_DWORD *)(v136 + 4 * (unsigned __int16)v128);
        int v61 = *(_DWORD *)(*(void *)(a2 + 16) + 4 * v129)
            - *(_DWORD *)(*((void *)&v136 + 1) + 4 * (unsigned __int16)v128);
        OffsetOutline((uint64_t)&v135, (_DWORD *)v136, *((_DWORD **)&v136 + 1), v60, v61);
        signed __int16 v58 = v129;
        __int16 v59 = v128;
      }
      else
      {
        unsigned int v60 = 0;
        int v61 = 0;
      }
      uint64_t v68 = v59;
      LOWORD(v64) = *(_WORD *)(*(void *)(a2 + 72) + 2 * v58) - *(_WORD *)(v140 + 2 * v59);
      LOWORD(v65) = *(_WORD *)(*(void *)(a2 + 80) + 2 * v58) - *(_WORD *)(*((void *)&v140 + 1) + 2 * v68);
      v113 += 4;
      v114 += 4;
    }
LABEL_89:
    OffsetOriginalOutline((uint64_t)&v135, (__int16)v64, (__int16)v65);
    int v71 = HIDWORD(v135);
    if ((v53 & 0x200) != 0 && v55)
    {
      v69.i32[0] = 0;
      uint64_t v72 = (int32x2_t *)(*((void *)&v136 + 1) + 4 * SHIDWORD(v135));
      int32x2_t v73 = *v72;
      int16x4_t v74 = (int16x4_t)v72[1];
      uint64_t v75 = a1[1];
      if (*(_WORD *)(v75 + 148)) {
        unsigned int v76 = 0;
      }
      else {
        unsigned int v76 = v60;
      }
      v70.i64[0] = __PAIR64__(v76, v60);
      int32x4_t v107 = vaddq_s32(*(int32x4_t *)(v136 + 4 * SHIDWORD(v135)), vzip1q_s32(v70, v70));
      int32x2_t v77 = vdup_n_s32(v61);
      int32x2_t v46 = vadd_s32((int32x2_t)v74, v77);
      v74.i16[0] = *(_WORD *)(v75 + 146);
      int8x8_t v45 = vbsl_s8((int8x8_t)vdup_lane_s16(vceq_s16(v74, v69), 0), (int8x8_t)vadd_s32(v73, v77), (int8x8_t)v73);
      int v108 = 1;
    }
    if (HIDWORD(v135))
    {
      uint64_t v79 = (_WORD *)*((void *)&v137 + 1);
      unint64_t v78 = (_WORD *)v137;
      int v80 = (int)v135;
      int v81 = *(_DWORD *)(a2 + 4);
      int v82 = (int)v135;
      do
      {
        *v78++ += v81;
        *v79++ += v81;
        --v82;
      }
      while (v82);
      *(_DWORD *)a2 += v80;
      *(_DWORD *)(a2 + 4) = v81 + v71;
    }
    char v43 = 1;
  }
  while ((v53 & 0x20) != 0);
  uint64_t v144 = v54;
  int v83 = *(_DWORD *)(a2 + 4);
  if (v83 >= 1)
  {
    if (v83 <= *(_DWORD *)(a1[1] + 32))
    {
      ComputeUnscaledBounds(a2, a2 + 92);
      goto LABEL_103;
    }
LABEL_105:
    uint64_t v84 = __cxa_allocate_exception(2uLL);
    _WORD *v84 = 5;
    __cxa_throw(v84, MEMORY[0x1E4FBA3C8], 0);
  }
LABEL_103:
  LoadGlyphMetrics((uint64_t)a1, a2);
  uint64_t v85 = *(__int16 **)(a2 + 72);
  uint64_t v86 = *(int *)(a2 + 4);
  if (v85 != &v85[v86 + 8])
  {
    uint64_t v87 = *(_DWORD **)(a2 + 56);
    uint64_t v88 = 2 * v86 + 16;
    do
    {
      int v89 = *v85++;
      *v87++ = llroundf((float)v89 * 64.0);
      v88 -= 2;
    }
    while (v88);
    uint64_t v86 = *(int *)(a2 + 4);
  }
  unint64_t v90 = *(__int16 **)(a2 + 80);
  if (v90 != &v90[v86 + 8])
  {
    uint64_t v91 = *(_DWORD **)(a2 + 64);
    uint64_t v92 = 2 * v86 + 16;
    do
    {
      int v93 = *v90++;
      *v91++ = llroundf((float)v93 * 64.0);
      v92 -= 2;
    }
    while (v92);
  }
  ConstructPhantomPoints((_WORD *)a1[1], a2, 0);
  if ((v109 & 1) == 0)
  {
    float v94 = (double)*(int *)(v112 + 36) * 0.0000152587891 / (double)v116;
    float v95 = (double)*(int *)(v112 + 52) * 0.0000152587891 / (double)v116;
    AppendToGlyphOutline(a2, &v135);
    HIDWORD(v135) = 0;
    ScaleGlyphOutline((uint64_t)&v135, v94, v95);
    RoundPhantomPoints((uint64_t)&v135, llroundf((float)(v94 * (float)*(__int16 *)(a2 + 100)) * 64.0), llroundf((float)(v95 * (float)*(__int16 *)(a2 + 104)) * 64.0));
    if (v108)
    {
      uint64_t v96 = a1[1];
      if (*(_WORD *)(v96 + 146))
      {
        *(int32x4_t *)long long v136 = v107;
        uint64_t v96 = a1[1];
      }
      if (*(_WORD *)(v96 + 148))
      {
        long long v97 = (int32x2_t *)*((void *)&v136 + 1);
        **((void **)&v136 + 1) = v45;
        v97[1] = v46;
      }
    }
    if ((v53 & 0x100) != 0)
    {
      if (v14 > v54 || (long long v98 = v54 + 1, (unint64_t)(v54 + 1) > v115))
      {
        unint64_t v105 = __cxa_allocate_exception(2uLL);
        *unint64_t v105 = 5;
        __cxa_throw(v105, MEMORY[0x1E4FBA3C8], 0);
      }
      uint64_t v99 = bswap32(*v54) >> 16;
      if ((unint64_t)v98 + v99 > v115 || (unsigned __int16 *)((char *)v98 + v99) < v98)
      {
        uint64_t v106 = __cxa_allocate_exception(2uLL);
        *uint64_t v106 = 5;
        __cxa_throw(v106, MEMORY[0x1E4FBA3C8], 0);
      }
      size_t v100 = 4 * *(_DWORD *)(a2 + 4);
      memcpy(*(void **)(a2 + 56), *(const void **)(a2 + 8), v100);
      memcpy(*(void **)(a2 + 64), *(const void **)(a2 + 16), v100);
      RunGlyphProgram(a1, a2, v112, v99, (unsigned __int8 *)v54 + 2, 1);
    }
  }
LABEL_26:
  if (v14) {
    ScalerReleaseFontTable((memoryContext *)*a1, v14);
  }
}

#error "1B52C6DA8: call analysis failed (funcsize=80)"

void sub_1B52C6E84()
{
}

BOOL CheckVitalElements(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(_DWORD *)a2 > *(_DWORD *)(v2 + 28)) {
    return 0;
  }
  BOOL result = 0;
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x80000000) == 0)
  {
    int v5 = *(_DWORD *)(v2 + 32);
    if (v5 >= v4 && v5 - v4 >= 8)
    {
      if (!*(void *)(a2 + 72) || !*(void *)(a2 + 80) || !*(void *)(a2 + 8)) {
        return 0;
      }
      return *(void *)(a2 + 16) != 0;
    }
  }
  return result;
}

void LoadGlyphMetrics(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 24);
  int v6 = *(_DWORD *)(a2 + 88);
  BOOL v7 = *(__int16 *)(a2 + 96) > *(__int16 *)(a2 + 92) && *(__int16 *)(a2 + 98) > *(__int16 *)(a2 + 94);
  __int16 v19 = -21846;
  __int16 v18 = -21846;
  if (v5) {
    BOOL v8 = v5 == 1358921729;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8 || !*(unsigned char *)(v5 + 488))
  {
    GetHmtxData(a1, v6, (_WORD *)(a2 + 100), 0, &v19, &v18);
LABEL_10:
    if (v19) {
      return;
    }
    __int16 v9 = *(_WORD *)(v4 + 142);
    *(_WORD *)(a2 + 102) = v9;
    if (v7)
    {
LABEL_12:
      *(_WORD *)(a2 + 100) = *(_WORD *)(a2 + 96) + 2 * v9 - *(_WORD *)(a2 + 92);
      return;
    }
    uint64_t v10 = (_WORD *)(a2 + 100);
    __int16 v14 = *(_WORD *)(a2 + 104);
    goto LABEL_20;
  }
  uint64_t v10 = (_WORD *)(a2 + 100);
  GetHmtxData(a1, v6, (_WORD *)(a2 + 100), (_WORD *)(a2 + 104), &v19, &v18);
  if (v18) {
    goto LABEL_10;
  }
  if (!v7)
  {
    __int16 v15 = *(_WORD *)(v4 + 142);
    *(_WORD *)(a2 + 106) = v15;
    __int16 v14 = *(_WORD *)(a2 + 100);
    *(_WORD *)(a2 + 104) = v14;
    if (v19) {
      return;
    }
    *(_WORD *)(a2 + 102) = v15;
LABEL_20:
    *uint64_t v10 = v14;
    return;
  }
  uint64_t v17 = (void *)0xAAAAAAAAAAAAAAAALL;
  unsigned int FontTable = ScalerGetFontTable(*(memoryContext **)a1, 1330851634, 0, &v17, 1, 0);
  if (v17)
  {
    if (FontTable < 0x48)
    {
      unsigned int v12 = 0;
      unsigned int v13 = 0;
    }
    else
    {
      unsigned int v12 = bswap32(*((unsigned __int16 *)v17 + 34)) >> 16;
      unsigned int v13 = bswap32(*((unsigned __int16 *)v17 + 35)) >> 16;
    }
    ScalerReleaseFontTable(*(memoryContext **)a1, v17);
  }
  else
  {
    unsigned int v12 = 0;
    unsigned int v13 = 0;
  }
  if (!(v12 | v13))
  {
    int16x4_t v16 = (void *)0xAAAAAAAAAAAAAAAALL;
    ScalerGetFontTable(*(memoryContext **)a1, 1751672161, 0, &v16, 1, 36);
    if (v16)
    {
      unsigned int v12 = bswap32(*((unsigned __int16 *)v16 + 2)) >> 16;
      unsigned int v13 = bswap32(*((unsigned __int16 *)v16 + 3)) >> 16;
      ScalerReleaseFontTable(*(memoryContext **)a1, v16);
    }
    else
    {
      LOWORD(v12) = 0;
      LOWORD(v13) = 0;
    }
  }
  *(_WORD *)(a2 + 106) = v12 - *(_WORD *)(a2 + 98);
  *(_WORD *)(a2 + 104) = v12 - v13;
  if (!v19)
  {
    __int16 v9 = *(_WORD *)(v4 + 142);
    *(_WORD *)(a2 + 102) = v9;
    goto LABEL_12;
  }
}

_WORD *ConstructPhantomPoints(_WORD *result, uint64_t a2, int a3)
{
  __int16 v3 = a3;
  uint64_t v5 = *(int *)(a2 + 4);
  int v6 = (_WORD *)(*(void *)(a2 + 72) + 2 * v5);
  BOOL v7 = (_WORD *)(*(void *)(a2 + 80) + 2 * v5);
  if (result[64]) {
    goto LABEL_5;
  }
  LOWORD(v8) = result[74];
  if (!(_WORD)v8) {
    goto LABEL_6;
  }
  int v9 = *(__int16 *)(a2 + 104);
  if (v9 < 1) {
LABEL_5:
  }
    LOWORD(v8) = 0;
  else {
    int v8 = *(unsigned __int16 *)(a2 + 98) - ((unsigned __int16)(v9 & 0xFFFE) >> 1) + *(unsigned __int16 *)(a2 + 106);
  }
LABEL_6:
  *int v6 = a3;
  *BOOL v7 = v8;
  uint64_t v6[4] = *(_WORD *)(a2 + 92);
  v7[4] = v8;
  v6[1] = *(_WORD *)(a2 + 100) + a3;
  v7[1] = v8;
  uint64_t v6[5] = *(_WORD *)(a2 + 96);
  v7[5] = v8;
  __int16 v10 = *(_WORD *)(a2 + 106) + *(_WORD *)(a2 + 98);
  if ((result[64] & 0x20) != 0)
  {
    LOWORD(v11) = 0;
  }
  else
  {
    LOWORD(v11) = result[73];
    if ((_WORD)v11) {
      int v11 = *(unsigned __int16 *)(a2 + 92) - *(unsigned __int16 *)(a2 + 102) + (*(__int16 *)(a2 + 100) >> 1);
    }
  }
  v6[2] = v11;
  v7[2] = v10;
  v6[6] = v11;
  v7[6] = *(_WORD *)(a2 + 98);
  v6[3] = v11;
  uint64_t v7[3] = v10 - *(_WORD *)(a2 + 104);
  v6[7] = v11;
  v7[7] = *(_WORD *)(a2 + 94);
  if (a3)
  {
    int v12 = -a3;
    OffsetOriginalOutline(a2, (__int16)-(__int16)a3, 0);
    BOOL result = (_WORD *)OffsetOutline(a2, *(_DWORD **)(a2 + 56), *(_DWORD **)(a2 + 64), v12 << 6, 0);
    *(_WORD *)(a2 + 92) -= v3;
    *(_WORD *)(a2 + 96) -= v3;
  }
  else if ((_WORD)v8)
  {
    if (v10)
    {
      OffsetOriginalOutline(a2, 0, (__int16)-v10);
      BOOL result = (_WORD *)OffsetOutline(a2, *(_DWORD **)(a2 + 56), *(_DWORD **)(a2 + 64), 0, -64 * v10);
      *(_WORD *)(a2 + 94) -= v10;
      *(_WORD *)(a2 + 98) -= v10;
    }
  }
  return result;
}

double CreateGlyphOutline(uint64_t *a1, int a2, unsigned int a3)
{
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[5];
  *(_DWORD *)(v6 + 272) = a2;
  StretchGlyph(a1, v6 + 184, v5 + 96, 0, a3, &v14, 0);
  if (!CheckVitalElements((uint64_t)a1, v6 + 184))
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  if (a3)
  {
    int v7 = *(_DWORD *)(v6 + 188);
    int v8 = *(int **)(v6 + 192);
    int v9 = *(int **)(v6 + 200);
    MapF26Dot6(v7, v8, v9, (int *)(v5 + 168));
  }
  else
  {
    int v11 = *(__int16 *)(a1[1] + 130);
    int v12 = *(unsigned __int8 *)(v5 + 488);
    return ScaleAndMapOutline(v6 + 184, (int *)(v5 + 96), v11, v12);
  }
  return result;
}

void TException::~TException(TException *this)
{
}

void THeap::THeap(THeap *this)
{
  *(void *)this = &unk_1F0DD4400;
}

void TDefaultHeap::~TDefaultHeap(TDefaultHeap *this)
{
}

void TDataReference::TDataReference(TDataReference *this, uint64_t a2)
{
  *(void *)this = &unk_1F0DD4218;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  TDataReference::operator=(this, a2);
}

{
  *(void *)this = &unk_1F0DD4218;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  TDataReference::operator=(this, a2);
}

void __clang_call_terminate(void *a1)
{
}

void TNameString::~TNameString(void **this)
{
  TStringRef::~TStringRef(this);
  JUMPOUT(0x1BA9994D0);
}

void TFontNameString::~TFontNameString(TFontNameString *this)
{
  *(void *)this = &unk_1F0DD4360;
  uint64_t v2 = (const void *)*((void *)this + 10);
  if (v2) {
    CFRelease(v2);
  }
  __int16 v3 = (const void *)*((void *)this + 11);
  if (v3) {
    CFRelease(v3);
  }
  TStringRef::~TStringRef((void **)this);
}

{
  uint64_t vars8;

  TFontNameString::~TFontNameString(this);
  JUMPOUT(0x1BA9994D0);
}

void TFontNameString::TFontNameString(TFontNameString *this, __int16 a2, CFStringRef theString, CFLocaleIdentifier a4, CFStringEncoding encoding)
{
  CStringPtr = CFStringGetCStringPtr(theString, encoding);
  CFIndex Length = CFStringGetLength(theString);
  *((void *)this + 1) = CStringPtr;
  *((void *)this + 2) = Length;
  *((unsigned char *)this + 24) = 0;
  *((void *)this + 4) = &unk_1F0DD4218;
  *((void *)this + 5) = 0;
  int v12 = (char *)this + 40;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((unsigned char *)this + 64) = 1;
  *(void *)this = &unk_1F0DD4360;
  *((_WORD *)this + 33) = a2;
  *((_DWORD *)this + 17) = -65536;
  if (a4)
  {
    unsigned __int16 v13 = 0;
    CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (1)
    {
      CFLocaleIdentifier v24 = (CFLocaleIdentifier)0xAAAAAAAAAAAAAAAALL;
      CFLocaleIdentifier CanonicalLocaleIdentifierFromScriptManagerCodes = CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(v14, v13, -128);
      CFLocaleIdentifier v24 = CanonicalLocaleIdentifierFromScriptManagerCodes;
      if (CanonicalLocaleIdentifierFromScriptManagerCodes)
      {
        if (CanonicalLocaleIdentifierFromScriptManagerCodes == a4
          || CFEqual(CanonicalLocaleIdentifierFromScriptManagerCodes, a4))
        {
          break;
        }
      }
      TCFString::~TCFString((const void **)&v24);
      unsigned int v16 = v13++;
      if (v16 >= 0x8B) {
        goto LABEL_7;
      }
    }
    TCFString::~TCFString((const void **)&v24);
  }
  else
  {
LABEL_7:
    unsigned __int16 v13 = -1;
  }
  *((_WORD *)this + 36) = v13;
  *((void *)this + 10) = CFRetain(theString);
  if (a4) {
    CFTypeRef v17 = CFRetain(a4);
  }
  else {
    CFTypeRef v17 = 0;
  }
  *((void *)this + 11) = v17;
  uint64_t v18 = *((void *)this + 1);
  if (v18)
  {
    if (encoding) {
      goto LABEL_19;
    }
  }
  else
  {
    if (!*(void *)v12) {
      goto LABEL_19;
    }
    uint64_t v19 = *(void *)(*(void *)v12 + 8);
    if (!v19) {
      goto LABEL_19;
    }
    uint64_t v18 = v19 + *((void *)this + 6);
    if (encoding) {
      goto LABEL_19;
    }
  }
  if (v18)
  {
    *((_DWORD *)this + 17) = 1;
    return;
  }
LABEL_19:
  CharactersPtr = CFStringGetCharactersPtr(theString);
  if (CharactersPtr)
  {
    CFIndex v21 = CFStringGetLength(theString);
    uint64_t v25 = (void *)CharactersPtr;
    uint64_t v26 = 2 * v21;
  }
  else
  {
    CFIndex v22 = CFStringGetLength(theString);
    int v23 = (UniChar *)malloc_type_malloc(2 * v22, 0x1000040BDFB0063uLL);
    v33.location = 0;
    v33.length = v22;
    CFStringGetCharacters(theString, v33, v23);
    uint64_t v25 = v23;
    uint64_t v26 = 2 * v22;
  }
  char v27 = 1;
  uint64_t v28 = &unk_1F0DD4218;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  CFLocaleIdentifier v24 = (CFLocaleIdentifier)&unk_1F0DD4380;
  char v32 = 2;
  TStringRef::operator=((uint64_t)this, (uint64_t)&v24);
  *((unsigned char *)this + 64) = v32;
  TStringRef::~TStringRef((void **)&v24);
}

void sub_1B52C786C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TStringRef::~TStringRef((void **)va);
  TStringRef::~TStringRef(v2);
  _Unwind_Resume(a1);
}

void MDataReference::~MDataReference(MDataReference *this)
{
}

void MDataReference::MDataReference(MDataReference *this, const MDataReference *a2, int a3, unint64_t a4)
{
  unint64_t v4 = *((void *)a2 + 2);
  uint64_t v5 = *((void *)a2 + 1) + a3;
  *(void *)this = &unk_1F0DD4340;
  *((void *)this + 1) = v5;
  *((void *)this + 2) = v4;
  if (v4)
  {
    BOOL v6 = v4 >= a3;
    BOOL v8 = v4 == a3;
    unint64_t v7 = v4 - a3;
    if (v8 || !v6)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 4;
    }
    BOOL v8 = v7 <= a4 || a4 == 0;
    if (!v8) {
      unint64_t v7 = a4;
    }
    *((void *)this + 2) = v7;
  }
}

void MFileReference::~MFileReference(MFileReference *this)
{
  *(void *)this = &unk_1F0DD4320;
  uint64_t v2 = (char *)*((void *)this + 1);
  if (v2 != (char *)this + 16) {
    free(v2);
  }
}

{
  char *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0DD4320;
  uint64_t v2 = (char *)*((void *)this + 1);
  if (v2 != (char *)this + 16) {
    free(v2);
  }
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TFragment::~TFragment(TFragment *this)
{
}

void TFileDescriptorContext::~TFileDescriptorContext(TFileDescriptorContext *this)
{
  if (*((unsigned char *)this + 4))
  {
    int v1 = *(_DWORD *)this;
    if ((v1 & 0x80000000) == 0) {
      close(v1);
    }
  }
}

void non-virtual thunk to'TFileFragmentReference::~TFileFragmentReference(TFileFragmentReference *this)
{
}

{
  uint64_t vars8;

  TFileFragmentReference::~TFileFragmentReference((TFileFragmentReference *)((char *)this - 24));
  JUMPOUT(0x1BA9994D0);
}

void *TFileFragmentReference::GetFileData@<X0>(void *this@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (this[1] && (unint64_t v4 = a3 + a2, !__CFADD__(a3, a2)) && v4 <= this[2])
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFF00;
    uint64_t v6 = (a3 + a2);
    if (!a3) {
      uint64_t v6 = 0;
    }
    return TDataReference::TDataReference(a4, (uint64_t)this, a2, v6 | v5, a3 != 0);
  }
  else
  {
    *a4 = &unk_1F0DD4218;
    a4[1] = 0;
    a4[2] = 0;
    a4[3] = 0;
  }
  return this;
}

uint64_t TFileFragmentReference::IsFileFragmentRef(TFileFragmentReference *this)
{
  return 1;
}

void TFileFragmentCachable::~TFileFragmentCachable(TFileFragmentCachable *this)
{
  uint64_t v2 = *(void *)this;
  if (v2 && !(*(unsigned int (**)(void))(*(void *)(v2 + 24) + 32))())
  {
    if (*(void *)this) {
      (*(void (**)(void))(**(void **)this + 8))(*(void *)this);
    }
  }
}

void TFileFragmentCache::~TFileFragmentCache(TFileFragmentCache *this)
{
  int v1 = (void **)((char *)this + 8);
  std::vector<TFileFragmentCachable>::__destroy_vector::operator()[abi:fe180100](&v1);
}

{
  void **v1;
  uint64_t vars8;

  int v1 = (void **)((char *)this + 8);
  std::vector<TFileFragmentCachable>::__destroy_vector::operator()[abi:fe180100](&v1);
  JUMPOUT(0x1BA9994D0);
}

void TFragmentCache::~TFragmentCache(TFragmentCache *this)
{
  *(void *)this = &unk_1F0DFB718;
  if (TFragmentCache::GetCache(void)const::once != -1) {
    dispatch_once(&TFragmentCache::GetCache(void)const::once, &__block_literal_global);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)TFragmentCache::GetCache(void)const::gFileFragmentCache + 8);
}

{
  uint64_t vars8;

  TFragmentCache::~TFragmentCache(this);
  JUMPOUT(0x1BA9994D0);
}

void PurgeFileFragmentCache(const char *a1)
{
  TFragmentCache::TFragmentCache((TFragmentCache *)v1);
  TFragmentCache::RemoveAll((TFragmentCache *)v1);
  TFragmentCache::~TFragmentCache((TFragmentCache *)v1);
}

void TFragmentCache::RemoveAll(TFragmentCache *this)
{
  if (TFragmentCache::GetCache(void)const::once != -1) {
    dispatch_once(&TFragmentCache::GetCache(void)const::once, &__block_literal_global);
  }
  int v1 = TFragmentCache::GetCache(void)const::gFileFragmentCache;
  uint64_t v3 = *((void *)TFragmentCache::GetCache(void)const::gFileFragmentCache + 1);
  for (uint64_t i = *((void *)TFragmentCache::GetCache(void)const::gFileFragmentCache + 2);
        i != v3;
  v1[2] = v3;
}

void dFPPrintFileFragmentCache(void)
{
  TFragmentCache::TFragmentCache((TFragmentCache *)v0);
  if (TFragmentCache::GetCache(void)const::once != -1) {
    dispatch_once(&TFragmentCache::GetCache(void)const::once, &__block_literal_global);
  }
  TFragmentCache::~TFragmentCache((TFragmentCache *)v0);
}

void TDataReference::DucRefCount(TDataReference *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2 && !(*(unsigned int (**)(void))(*(void *)(v2 + 24) + 32))())
  {
    if (!(*(unsigned int (**)(void))(**((void **)this + 1) + 16))(*((void *)this + 1))
      || (TFragmentCache::TFragmentCache((TFragmentCache *)v5),
          char v3 = TFragmentCache::RemoveValue((TFragmentCache *)v5, *((const TFileFragmentReference **)this + 1)),
          TFragmentCache::~TFragmentCache((TFragmentCache *)v5),
          (v3 & 1) == 0))
    {
      uint64_t v4 = *((void *)this + 1);
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      }
    }
    *((void *)this + 1) = 0;
  }
}

void sub_1B52C7F2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TFragmentCache::~TFragmentCache((TFragmentCache *)va);
  _Unwind_Resume(a1);
}

void *TDataReference::TDataReference(void *a1, uint64_t a2, int a3, unint64_t a4, char a5)
{
  *a1 = &unk_1F0DD4218;
  a1[1] = a2;
  a1[2] = a3;
  unint64_t v5 = *(void *)(a2 + 16);
  if (a5) {
    unint64_t v5 = a4;
  }
  a1[3] = v5;
  if (v5 < a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 2;
  }
  (*(void (**)(uint64_t))(*(void *)(a2 + 24) + 24))(a2 + 24);
  return a1;
}

uint64_t TDataReference::AddRefCount(TDataReference *this)
{
  uint64_t result = *((void *)this + 1);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 24) + 24))();
  }
  return result;
}

__n128 TDataReference::TDataReference(__n128 *a1, __n128 *a2)
{
  unint64_t v2 = a2->n128_u64[1];
  a2->n128_u64[1] = 0;
  a1->n128_u64[0] = (unint64_t)&unk_1F0DD4218;
  a1->n128_u64[1] = v2;
  __n128 result = a2[1];
  a1[1] = result;
  return result;
}

{
  unint64_t v2;
  __n128 result;

  unint64_t v2 = a2->n128_u64[1];
  a2->n128_u64[1] = 0;
  a1->n128_u64[0] = (unint64_t)&unk_1F0DD4218;
  a1->n128_u64[1] = v2;
  __n128 result = a2[1];
  a1[1] = result;
  return result;
}

void *TDataReference::TDataReference(void *a1, void *a2, int a3, uint64_t a4, char a5)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = a2[2];
  *a1 = &unk_1F0DD4218;
  a1[1] = v6;
  unint64_t v8 = v7 + a3;
  a1[2] = v8;
  unint64_t v9 = a2[2] + a4;
  if (!a5) {
    unint64_t v9 = a2[3];
  }
  a1[3] = v9;
  if (v6)
  {
    if (v8 > v9)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 4;
    }
    (*(void (**)(void))(*(void *)(v6 + 24) + 24))();
  }
  return a1;
}

void *TDataReference::SubdataFrom@<X0>(void *this@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v4 = this[2];
  BOOL v5 = __CFADD__(v4, a2);
  uint64_t v6 = v4 + a2;
  char v7 = v5;
  if (this[1] && (v7 & 1) == 0 && (unint64_t)(v6 + a3) <= this[3]) {
    return TDataReference::TDataReference(a4, this, a2, a2 + a3, 1);
  }
  *a4 = &unk_1F0DD4218;
  a4[1] = 0;
  a4[2] = 0;
  a4[3] = 0;
  return this;
}

uint64_t TFragmentCache::RemoveValue(TFragmentCache *this, const TFileFragmentReference *a2)
{
  if (TFragmentCache::GetCache(void)const::once != -1) {
    dispatch_once(&TFragmentCache::GetCache(void)const::once, &__block_literal_global);
  }
  uint64_t v3 = *((void *)TFragmentCache::GetCache(void)const::gFileFragmentCache + 1);
  uint64_t v4 = *((void *)TFragmentCache::GetCache(void)const::gFileFragmentCache + 2);
  if (v3 == v4) {
    return 0;
  }
  uint64_t v5 = 0;
  while (*(const TFileFragmentReference **)(v3 + v5) != a2)
  {
    v5 += 24;
    if (v3 + v5 == v4) {
      return 0;
    }
  }
  if (v5 < -23) {
    return 0;
  }
  TFileFragmentCache::RemoveIndex((TFileFragmentCache *)TFragmentCache::GetCache(void)const::gFileFragmentCache, 0xAAAAAAAAAAAAAAABLL * (v5 >> 3));
  return 1;
}

void TDataReference::Reset(TDataReference *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
}

BOOL TDataReference::operator==(void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a2[2];
  if (a1[3] - v2 != a2[3] - v3) {
    return 0;
  }
  uint64_t v4 = a1[1];
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 8);
    uint64_t v6 = v5 + v2;
    if (!v5) {
      uint64_t v6 = 0;
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = a2[1];
  if (v8)
  {
    uint64_t v9 = *(void *)(v8 + 8);
    uint64_t v10 = v9 + v3;
    if (!v9) {
      uint64_t v10 = 0;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  return v6 == v10;
}

BOOL TFileDataReference::Map(TFileDataReference *this, const char *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  v16[0] = 0xAAAAAA01AAAAAAAALL;
  v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v17.st_blksize = v4;
  *(timespec *)v17.st_qspare = v4;
  v17.st_birthtimespec = v4;
  *(timespec *)&v17.off_t st_size = v4;
  v17.st_mtimespec = v4;
  v17.st_ctimespec = v4;
  *(timespec *)&v17.st_uid = v4;
  v17.st_atimespec = v4;
  *(timespec *)&v17.st_dev = v4;
  int v5 = open(a2, 0, 0);
  if (v5 < 0)
  {
    if (*__error() != 1 || !FontServicesLibraryCore(0) || !getFSFontFileDescriptorForPathSymbolLoc()) {
      goto LABEL_20;
    }
    FSFontFileDescriptorForPathSymbolLoc = (uint64_t (*)(const char *))getFSFontFileDescriptorForPathSymbolLoc();
    if (!FSFontFileDescriptorForPathSymbolLoc)
    {
      dlerror();
      abort_report_np();
    }
    int v8 = FSFontFileDescriptorForPathSymbolLoc(a2);
    BYTE4(v16[0]) = 0;
    if ((v8 & 0x80000000) == 0)
    {
      int v6 = v8;
      if (!fstat(v8, &v17)) {
        goto LABEL_10;
      }
    }
    else
    {
LABEL_20:
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v14 = *__error();
        *(_DWORD *)buf = 136446466;
        uint64_t v19 = a2;
        __int16 v20 = 1024;
        int v21 = v14;
        _os_log_error_impl(&dword_1B51AD000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "FontParser could not open filePath %{public}s: %{errno}d", buf, 0x12u);
      }
    }
LABEL_16:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 3;
  }
  int v6 = v5;
  if (fstat(v5, &v17))
  {
    close(v6);
    goto LABEL_16;
  }
LABEL_10:
  LODWORD(v16[0]) = v6;
  off_t st_size = v17.st_size;
  v16[1] = v17.st_size;
  *((void *)this + 2) = v17.st_size;
  uint64_t v10 = mmap(0, st_size, 1, 16386, v6, 0);
  BOOL v11 = v10 != (void *)-1;
  if (v10 == (void *)-1) {
    int v12 = 0;
  }
  else {
    int v12 = v10;
  }
  *((void *)this + 1) = v12;
  TFileDescriptorContext::~TFileDescriptorContext((TFileDescriptorContext *)v16);
  return v11;
}

void sub_1B52C85CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TFileDescriptorContext::~TFileDescriptorContext((TFileDescriptorContext *)va);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'TFileDataReference::~TFileDataReference(TFileDataReference *this)
{
}

{
  uint64_t vars8;

  TFileDataReference::~TFileDataReference((TFileDataReference *)((char *)this - 24));
  JUMPOUT(0x1BA9994D0);
}

void TFileDataSurrogate::TFileDataSurrogate(TFileDataSurrogate *this, TFragmentCache *a2, timespec a3)
{
  __darwin_time_t tv_nsec = a3.tv_nsec;
  tv_sec = (char *)a3.tv_sec;
  *(void *)this = &unk_1F0DD4168;
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  TFragmentCache::TFragmentCache((TFragmentCache *)&v12);
  v13.tv_sec = tv_nsec;
  v13.__darwin_time_t tv_nsec = 0;
  uint64_t Value = TFragmentCache::FindValue(a2, tv_sec, v13);
  if (Value)
  {
LABEL_8:
    (*(void (**)(void))(*(void *)(Value + 24) + 24))();
    goto LABEL_9;
  }
  int v8 = operator new(0x78uLL, MEMORY[0x1E4FBA2D0]);
  if (v8)
  {
    uint64_t v9 = (TFileDataReference *)v8;
    v8[1] = 0;
    v8[2] = 0;
    *int v8 = &unk_1F0DD4258;
    v8[3] = &unk_1F0DD4288;
    v8[4] = 0;
    MFileReference::MFileReference((MFileReference *)(v8 + 5), (const char *)a2);
    *(void *)uint64_t v9 = &unk_1F0DD41B0;
    *((void *)v9 + 3) = &unk_1F0DD41E0;
    if (!TFileDataReference::Map(v9, (const char *)a2))
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 3;
    }
    v10.tv_sec = tv_nsec;
    uint64_t Value = TFragmentCache::AddValue(v9, (TFileFragmentReference *)tv_sec, v10);
    if (Value) {
      (*(void (**)(TFileDataReference *))(*(void *)v9 + 8))(v9);
    }
    else {
      uint64_t Value = (uint64_t)v9;
    }
    goto LABEL_8;
  }
  uint64_t Value = 0;
LABEL_9:
  TFragmentCache::~TFragmentCache((TFragmentCache *)&v12);
  *((void *)this + 1) = Value;
}

void sub_1B52C88A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TFragmentCache::~TFragmentCache((TFragmentCache *)va);
  _Unwind_Resume(a1);
}

void TFileDataSurrogate::TFileDataSurrogate(TFileDataSurrogate *this, const TFileFragmentReference *a2)
{
  *(void *)this = &unk_1F0DD4168;
  *((void *)this + 1) = a2;
  (*(void (**)(char *))(*((void *)a2 + 3) + 24))((char *)a2 + 24);
}

{
  *(void *)this = &unk_1F0DD4168;
  *((void *)this + 1) = a2;
}

{
  *(void *)this = &unk_1F0DD4168;
  *((void *)this + 1) = a2;
}

void TFileDataSurrogate::TFileDataSurrogate(TFileDataSurrogate *this)
{
  *(void *)this = &unk_1F0DD4168;
}

{
  *(void *)this = &unk_1F0DD4168;
}

uint64_t TFileDataSurrogate::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    if (!(*(unsigned int (**)(void))(*(void *)(*(void *)(a1 + 8) + 24) + 32))())
    {
      TFragmentCache::TFragmentCache((TFragmentCache *)v8);
      char v4 = TFragmentCache::RemoveValue((TFragmentCache *)v8, *(const TFileFragmentReference **)(a1 + 8));
      TFragmentCache::~TFragmentCache((TFragmentCache *)v8);
      if ((v4 & 1) == 0)
      {
        uint64_t v5 = *(void *)(a1 + 8);
        if (v5) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
    }
    uint64_t v6 = *(void *)(a2 + 8);
    *(void *)(a1 + 8) = v6;
    (*(void (**)(void))(*(void *)(v6 + 24) + 24))();
  }
  return a1;
}

void sub_1B52C8AEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TFragmentCache::~TFragmentCache((TFragmentCache *)va);
  _Unwind_Resume(a1);
}

void *TFileDataSurrogate::GetDataReference@<X0>(TFileDataSurrogate *this@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  return TFileFragmentReference::GetFileData(*((void **)this + 1), a2, a3, a4);
}

void TInMemoryDataReference::TInMemoryDataReference(void *a1)
{
  *a1 = &unk_1F0DD4120;
  operator new();
}

void sub_1B52C8BFC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9994D0](v1, 0x10C1C408451B1F9);
  _Unwind_Resume(a1);
}

void TInMemoryDataReference::~TInMemoryDataReference(TInMemoryDataReference *this)
{
  *(void *)this = &unk_1F0DD4120;
  uint64_t v2 = *((void *)this + 1);
  if (v2 && !(*(unsigned int (**)(void))(*(void *)(v2 + 24) + 32))())
  {
    uint64_t v3 = *((void *)this + 1);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
}

{
  uint64_t vars8;

  TInMemoryDataReference::~TInMemoryDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

void *TInMemoryDataReference::GetDataReference@<X0>(void *this@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = this[1];
  int v6 = a3 + a2;
  if (*(void *)(v5 + 8)) {
    BOOL v7 = v6 < (int)a3;
  }
  else {
    BOOL v7 = 1;
  }
  BOOL v8 = v7 || v6 < a2;
  if (v8 || v6 > *(_DWORD *)(v5 + 16))
  {
    *a4 = &unk_1F0DD4218;
    a4[1] = 0;
    a4[2] = 0;
    a4[3] = 0;
  }
  else
  {
    uint64_t v9 = (a3 + a2);
    uint64_t v10 = (int)(v6 & 0xFFFFFF00);
    if (!a3) {
      uint64_t v9 = 0;
    }
    return TDataReference::TDataReference(a4, v5, a2, v9 | v10, a3 != 0);
  }
  return this;
}

uint64_t TInMemoryDataReference::GetFileSize(TInMemoryDataReference *this)
{
  return *(void *)(*((void *)this + 1) + 16);
}

uint64_t TInMemoryDataReference::GetDataSize(TInMemoryDataReference *this)
{
  return *(void *)(*((void *)this + 1) + 16);
}

void TDataForkFileDataReference::~TDataForkFileDataReference(const TFileFragmentReference **this)
{
  TFileDataSurrogate::~TFileDataSurrogate(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TResourceForkFileReference::~TResourceForkFileReference(TResourceForkFileReference *this)
{
}

{
  uint64_t vars8;

  TResourceForkFileReference::~TResourceForkFileReference((TResourceForkFileReference *)((char *)this - 24));
  JUMPOUT(0x1BA9994D0);
}

uint64_t TResourceForkFileReference::IsResourceFile(TResourceForkFileReference *this)
{
  return 1;
}

uint64_t TResourceForkFileReference::GetMappedResourceFork(TResourceForkFileReference *this, unint64_t *a2)
{
  uint64_t result = *((void *)this + 1);
  if (result) {
    *a2 = *((void *)this + 2);
  }
  return result;
}

void TResourceForkSurrogate::TResourceForkSurrogate(TResourceForkSurrogate *this, TFragmentCache *a2, timespec a3, char a4)
{
  __darwin_time_t tv_nsec = a3.tv_nsec;
  tv_sec = (char *)a3.tv_sec;
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  TFragmentCache::TFragmentCache((TFragmentCache *)&v12);
  v13.tv_sec = tv_nsec;
  v13.__darwin_time_t tv_nsec = 1;
  uint64_t Value = TFragmentCache::FindValue(a2, tv_sec, v13);
  if (Value) {
    goto LABEL_7;
  }
  uint64_t v10 = (TResourceForkFileReference *)operator new(0x80uLL, MEMORY[0x1E4FBA2D0]);
  if (v10)
  {
    BOOL v11 = v10;
    TResourceForkFileReference::TResourceForkFileReference(v10, (const char *)a2, a4);
    v14.tv_sec = tv_nsec;
    uint64_t Value = TFragmentCache::AddValue(v11, (TFileFragmentReference *)tv_sec, v14);
    if (Value) {
      (*(void (**)(TFragmentCache *))(*(void *)v11 + 8))(v11);
    }
    else {
      uint64_t Value = (uint64_t)v11;
    }
LABEL_7:
    (*(void (**)(void))(*(void *)(Value + 24) + 24))();
    goto LABEL_8;
  }
  uint64_t Value = 0;
LABEL_8:
  TFragmentCache::~TFragmentCache((TFragmentCache *)&v12);
  *(void *)this = &unk_1F0DD4028;
  *((void *)this + 1) = Value;
}

void sub_1B52C9024(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TFragmentCache::~TFragmentCache((TFragmentCache *)va);
  _Unwind_Resume(a1);
}

void TResourceForkSurrogate::TResourceForkSurrogate(TResourceForkSurrogate *this, const TResourceForkFileReference *a2)
{
  *(void *)this = &unk_1F0DD4168;
  *((void *)this + 1) = a2;
  (*(void (**)(char *))(*((void *)a2 + 3) + 24))((char *)a2 + 24);
  *(void *)this = &unk_1F0DD4028;
}

{
  *(void *)this = &unk_1F0DD4168;
  *((void *)this + 1) = a2;
  (*(void (**)(char *))(*((void *)a2 + 3) + 24))((char *)a2 + 24);
  *(void *)this = &unk_1F0DD4028;
}

void TResourceForkSurrogate::~TResourceForkSurrogate(const TFileFragmentReference **this)
{
  TFileDataSurrogate::~TFileDataSurrogate(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TResourceFileDataReference::~TResourceFileDataReference(TResourceFileDataReference *this)
{
  *((void *)this - 3) = &unk_1F0DD3FC0;
  *(void *)this = &unk_1F0DD3FF0;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 2);
}

{
  uint64_t vars8;

  *((void *)this - 3) = &unk_1F0DD3FC0;
  *(void *)this = &unk_1F0DD3FF0;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 2);
  JUMPOUT(0x1BA9994D0);
}

void *TResourceFileDataReference::GetDataReference@<X0>(void *this@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (this[1] && (unint64_t v4 = a3 + a2, !__CFADD__(a3, a2)) && v4 <= this[2])
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFF00;
    uint64_t v6 = (a3 + a2);
    if (!a3) {
      uint64_t v6 = 0;
    }
    return TDataReference::TDataReference(a4, (uint64_t)this, a2, v6 | v5, a3 != 0);
  }
  else
  {
    *a4 = &unk_1F0DD4218;
    a4[1] = 0;
    a4[2] = 0;
    a4[3] = 0;
  }
  return this;
}

void TResourceFileDataSurrogate::TResourceFileDataSurrogate(TResourceFileDataSurrogate *this, const TResourceForkSurrogate *a2, unsigned int a3, const unsigned __int8 *a4)
{
  *(void *)this = &unk_1F0DD3F78;
  operator new();
}

void sub_1B52C94D8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9994D0](v1, 0x10E1C4062A34129);
  _Unwind_Resume(a1);
}

uint64_t TResourceFileDataSurrogate::GetDataReference(TResourceFileDataSurrogate *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 24))();
}

uint64_t TFileFragmentReference::IsResourceFile(TFileFragmentReference *this)
{
  return 0;
}

uint64_t TInMemoryDataReference::GetPath(TInMemoryDataReference *this)
{
  return 0;
}

uint64_t TInMemoryDataReference::GetSFNTDirectoryOffset(TInMemoryDataReference *this)
{
  return *((unsigned int *)this + 4);
}

void TCFString::~TCFString(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t FontServicesLibraryCore(char **a1)
{
  if (!FontServicesLibraryCore(char **)::frameworkLibrary) {
    FontServicesLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  return FontServicesLibraryCore(char **)::frameworkLibrary;
}

{
  if (!FontServicesLibraryCore(char **)::frameworkLibrary) {
    FontServicesLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  return FontServicesLibraryCore(char **)::frameworkLibrary;
}

uint64_t getFSFontFileDescriptorForPathSymbolLoc(void)
{
  uint64_t v3 = 0;
  unint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  uint64_t v0 = getFSFontFileDescriptorForPathSymbolLoc(void)::ptr;
  uint64_t v6 = getFSFontFileDescriptorForPathSymbolLoc(void)::ptr;
  if (!getFSFontFileDescriptorForPathSymbolLoc(void)::ptr)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 0x40000000;
    v2[2] = ___ZL39getFSFontFileDescriptorForPathSymbolLocv_block_invoke;
    v2[3] = &unk_1E60E1738;
    v2[4] = &v3;
    ___ZL39getFSFontFileDescriptorForPathSymbolLocv_block_invoke((uint64_t)v2);
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1B52C9734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL23FontServicesLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  FontServicesLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

void *___ZL39getFSFontFileDescriptorForPathSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v2 = (void *)FontServicesLibraryCore(&v5);
  uint64_t v3 = v5;
  if (!v2)
  {
    uint64_t v3 = (void *)abort_report_np();
    goto LABEL_5;
  }
  if (v5) {
LABEL_5:
  }
    free(v3);
  uint64_t result = dlsym(v2, "FSFontFileDescriptorForPath");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFSFontFileDescriptorForPathSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void std::vector<TFileFragmentCachable>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        TFileFragmentCachable::~TFileFragmentCachable((TFileFragmentCachable *)(v4 - 24));
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ___ZNK14TFragmentCache8GetCacheEv_block_invoke()
{
}

void TFragmentCache::TFragmentCache(TFragmentCache *this)
{
  *(void *)this = &unk_1F0DFB718;
  if (TFragmentCache::GetCache(void)const::once != -1) {
    dispatch_once(&TFragmentCache::GetCache(void)const::once, &__block_literal_global);
  }
  os_unfair_lock_lock((os_unfair_lock_t)TFragmentCache::GetCache(void)const::gFileFragmentCache + 8);
}

void TFileFragmentCache::RemoveIndex(TFileFragmentCache *this, uint64_t a2)
{
  if ((a2 & 0x8000000000000000) == 0)
  {
    unint64_t v4 = (uint64_t *)*((void *)this + 2);
    uint64_t v5 = (uint64_t *)(*((void *)this + 1) + 24 * a2);
    if (v4 == v5)
    {
      __break(1u);
    }
    else
    {
      std::__unwrap_and_dispatch[abi:fe180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,TFileFragmentCachable *,TFileFragmentCachable *,TFileFragmentCachable *,0>(v5 + 3, v4, v5);
      uint64_t v7 = v6;
      uint64_t v8 = *((void *)this + 2);
      if (v8 != v6)
      {
        do
          TFileFragmentCachable::~TFileFragmentCachable((TFileFragmentCachable *)(v8 - 24));
        while (v8 != v7);
      }
      *((void *)this + 2) = v7;
    }
  }
}

uint64_t *std::__unwrap_and_dispatch[abi:fe180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,TFileFragmentCachable *,TFileFragmentCachable *,TFileFragmentCachable *,0>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  if (result != a2)
  {
    do
    {
      if (result != a3)
      {
        uint64_t v3 = *a3;
        *a3 = *result;
        *uint64_t result = v3;
        long long v4 = *(_OWORD *)(a3 + 1);
        *(_OWORD *)(a3 + 1) = *(_OWORD *)(result + 1);
        *(_OWORD *)(result + 1) = v4;
      }
      result += 3;
      a3 += 3;
    }
    while (result != a2);
    return a2;
  }
  return result;
}

void std::vector<char,TInlineBufferAllocator<char,1024ul>>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = v1 + 131;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[131]) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

uint64_t TFragmentCache::FindValue(TFragmentCache *this, const char *a2, timespec a3)
{
  int tv_nsec = a3.tv_nsec;
  __darwin_time_t tv_sec = a3.tv_sec;
  if (TFragmentCache::GetCache(void)const::once != -1) {
    dispatch_once(&TFragmentCache::GetCache(void)const::once, &__block_literal_global);
  }
  v15.__darwin_time_t tv_sec = (__darwin_time_t)a2;
  v15.int tv_nsec = tv_sec;
  TFileFragmentCache::FindByKey((TFileFragmentCache *)TFragmentCache::GetCache(void)const::gFileFragmentCache, (const char *)this, v15);
  uint64_t v8 = v7;
  if (v7 && (*(unsigned int (**)(uint64_t))(*(void *)v7 + 24))(v7) != tv_nsec)
  {
    if (TFragmentCache::GetCache(void)const::once != -1) {
      dispatch_once(&TFragmentCache::GetCache(void)const::once, &__block_literal_global);
    }
    uint64_t v9 = (TFileFragmentCache *)TFragmentCache::GetCache(void)const::gFileFragmentCache;
    BOOL v11 = (TFileFragmentCachable *)*((void *)TFragmentCache::GetCache(void)const::gFileFragmentCache + 1);
    uint64_t v10 = (TFileFragmentCachable *)*((void *)TFragmentCache::GetCache(void)const::gFileFragmentCache + 2);
    uint64_t v12 = v10 - v11;
    while (v10 != v11)
    {
      uint64_t v10 = (TFileFragmentCachable *)((char *)v10 - 24);
      v16.__darwin_time_t tv_sec = (__darwin_time_t)a2;
      v16.int tv_nsec = tv_sec;
      v12 -= 24;
      if (TFileFragmentCachable::Compare(v10, (const char *)this, v16))
      {
        uint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (v12 >> 3);
        goto LABEL_12;
      }
    }
    uint64_t v13 = -1;
LABEL_12:
    TFileFragmentCache::RemoveIndex(v9, v13);
    return 0;
  }
  return v8;
}

uint64_t TFragmentCache::AddValue(TFragmentCache *this, TFileFragmentReference *a2, timespec a3)
{
  __darwin_time_t tv_sec = a3.tv_sec;
  uint64_t v6 = (const char *)*((void *)this + 6);
  if (TFragmentCache::GetCache(void)const::once != -1) {
    dispatch_once(&TFragmentCache::GetCache(void)const::once, &__block_literal_global);
  }
  v40.__darwin_time_t tv_sec = (__darwin_time_t)a2;
  v40.int tv_nsec = tv_sec;
  TFileFragmentCache::FindByKey((TFileFragmentCache *)TFragmentCache::GetCache(void)const::gFileFragmentCache, v6, v40);
  uint64_t v8 = v7;
  if (!v7)
  {
    if (TFragmentCache::GetCache(void)const::once != -1) {
      dispatch_once(&TFragmentCache::GetCache(void)const::once, &__block_literal_global);
    }
    uint64_t v9 = TFragmentCache::GetCache(void)const::gFileFragmentCache;
    uint64_t v10 = *((void *)TFragmentCache::GetCache(void)const::gFileFragmentCache + 1);
    BOOL v11 = (void *)*((void *)TFragmentCache::GetCache(void)const::gFileFragmentCache + 2);
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v11 - v10) >> 3);
    if (v12 <= 0x27)
    {
      unint64_t v13 = *((void *)TFragmentCache::GetCache(void)const::gFileFragmentCache + 3);
      if ((unint64_t)v11 < v13)
      {
        *BOOL v11 = this;
        v11[1] = a2;
        _OWORD v11[2] = tv_sec;
        (*(void (**)(char *))(*((void *)this + 3) + 24))((char *)this + 24);
        timespec v14 = v11 + 3;
        _OWORD v9[2] = v11 + 3;
LABEL_24:
        _OWORD v9[2] = v14;
        return v8;
      }
      unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - v10) >> 3);
      uint64_t v21 = 2 * v20;
      if (2 * v20 <= v12 + 1) {
        uint64_t v21 = v12 + 1;
      }
      if (v20 >= 0x555555555555555) {
        unint64_t v22 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v22 = v21;
      }
      long long v39 = (char *)TFragmentCache::GetCache(void)const::gFileFragmentCache + 24;
      if (v22 <= 0xAAAAAAAAAAAAAAALL)
      {
        uint64_t v23 = 3 * v22;
        CFLocaleIdentifier v24 = (TFragmentCache *)operator new(24 * v22);
        uint64_t v25 = (void *)((char *)v24 + 24 * v12);
        float v36 = v24;
        *(void *)&long long v37 = v25;
        *((void *)&v37 + 1) = v25;
        uint64_t v38 = (char *)v24 + 8 * v23;
        *uint64_t v25 = this;
        v25[1] = a2;
        _OWORD v25[2] = tv_sec;
        (*(void (**)(char *))(*((void *)this + 3) + 24))((char *)this + 24);
        uint64_t v26 = 0;
        uint64_t v27 = v37;
        *((void *)&v37 + 1) += 24;
        uint64_t v29 = v9[1];
        uint64_t v28 = v9[2];
        while (1)
        {
          uint64_t v30 = v28 + v26;
          if (v28 + v26 == v29) {
            break;
          }
          uint64_t v31 = v27 + v26;
          uint64_t v32 = *(void *)(v30 - 24);
          *(void *)(v31 - 24) = v32;
          *(_OWORD *)(v31 - 16) = *(_OWORD *)(v30 - 16);
          v26 -= 24;
          (*(void (**)(void))(*(void *)(v32 + 24) + 24))();
        }
        long long v33 = *(_OWORD *)(v9 + 1);
        v9[1] = v27 + v26;
        timespec v14 = (void *)*((void *)&v37 + 1);
        _OWORD v9[2] = *((void *)&v37 + 1);
        long long v37 = v33;
        int16x8_t v34 = (char *)v9[3];
        v9[3] = v38;
        uint64_t v38 = v34;
        float v36 = (TFragmentCache *)v33;
        std::__split_buffer<TFileFragmentCachable>::~__split_buffer((uint64_t)&v36);
        goto LABEL_24;
      }
LABEL_27:
      std::__throw_bad_array_new_length[abi:fe180100]();
    }
    float v36 = this;
    *(void *)&long long v37 = a2;
    *((void *)&v37 + 1) = tv_sec;
    (*(void (**)(void))(*((void *)this + 3) + 24))();
    uint64_t v15 = v9[1];
    if (v15 == v9[2])
    {
      __break(1u);
      goto LABEL_27;
    }
    if ((TFragmentCache **)v15 != &v36)
    {
      timespec v16 = *(TFragmentCache **)v15;
      *(void *)uint64_t v15 = this;
      float v36 = v16;
      long long v17 = *(_OWORD *)(v15 + 8);
      *(_OWORD *)(v15 + 8) = v37;
      long long v37 = v17;
    }
    TFileFragmentCachable::~TFileFragmentCachable((TFileFragmentCachable *)&v36);
    uint64_t v18 = (uint64_t *)v9[1];
    uint64_t v19 = (uint64_t *)v9[2];
    if (v18 + 3 != v19) {
      std::__rotate_forward[abi:fe180100]<std::_ClassicAlgPolicy,std::__wrap_iter<TFileFragmentCachable *>>(v18, v18 + 3, v19);
    }
  }
  return v8;
}

void sub_1B52C9EC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TFileFragmentCachable>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void TFileFragmentCache::FindByKey(TFileFragmentCache *this, const char *a2, timespec a3)
{
  uint64_t tv_nsec = a3.tv_nsec;
  __darwin_time_t tv_sec = a3.tv_sec;
  uint64_t v7 = 0;
  uint64_t v9 = (uint64_t *)*((void *)this + 1);
  uint64_t v8 = (uint64_t *)*((void *)this + 2);
  while (&v8[v7] != v9)
  {
    v7 -= 3;
    v10.__darwin_time_t tv_sec = tv_sec;
    v10.uint64_t tv_nsec = tv_nsec;
    if (TFileFragmentCachable::Compare((TFileFragmentCachable *)&v8[v7], a2, v10))
    {
      if (v7 != -3)
      {
        std::__rotate_forward[abi:fe180100]<std::_ClassicAlgPolicy,std::__wrap_iter<TFileFragmentCachable *>>(&v8[v7], &v8[v7 + 3], v8);
        uint64_t v9 = (uint64_t *)*((void *)this + 1);
        uint64_t v8 = (uint64_t *)*((void *)this + 2);
      }
      if (v9 == v8) {
        __break(1u);
      }
      return;
    }
  }
}

BOOL TFileFragmentCachable::Compare(TFileFragmentCachable *this, const char *a2, timespec a3)
{
  return *((void *)this + 1) == a3.tv_sec
      && *((void *)this + 2) == a3.tv_nsec
      && strcmp(*(const char **)(*(void *)this + 48), a2) == 0;
}

void std::__rotate_forward[abi:fe180100]<std::_ClassicAlgPolicy,std::__wrap_iter<TFileFragmentCachable *>>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  BOOL v4 = a2;
  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:fe180100]<std::__wrap_iter<TFileFragmentCachable *> &,std::__wrap_iter<TFileFragmentCachable *> &>(a1, a2);
  uint64_t v6 = a1 + 3;
  for (uint64_t i = v4 + 3; i != a3; i += 3)
  {
    if (v6 == v4) {
      BOOL v4 = i;
    }
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:fe180100]<std::__wrap_iter<TFileFragmentCachable *> &,std::__wrap_iter<TFileFragmentCachable *> &>(v6, i);
    v6 += 3;
  }
  if (v6 != v4)
  {
    uint64_t v8 = v4;
    do
    {
      while (1)
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:fe180100]<std::__wrap_iter<TFileFragmentCachable *> &,std::__wrap_iter<TFileFragmentCachable *> &>(v6, v4);
        v6 += 3;
        v4 += 3;
        if (v4 == a3) {
          break;
        }
        if (v6 == v8) {
          uint64_t v8 = v4;
        }
      }
      BOOL v4 = v8;
    }
    while (v6 != v8);
  }
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:fe180100]<std::__wrap_iter<TFileFragmentCachable *> &,std::__wrap_iter<TFileFragmentCachable *> &>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  uint64_t v6 = v2;
  long long v7 = *(_OWORD *)(a1 + 1);
  if (a1 != a2)
  {
    *a1 = *a2;
    *a2 = 0;
    long long v3 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = *(_OWORD *)(a2 + 1);
    *(_OWORD *)(a2 + 1) = v3;
  }
  if (&v6 != a2)
  {
    uint64_t v4 = *a2;
    *a2 = v2;
    uint64_t v6 = v4;
    long long v5 = *(_OWORD *)(a2 + 1);
    *(_OWORD *)(a2 + 1) = v7;
    long long v7 = v5;
  }
  TFileFragmentCachable::~TFileFragmentCachable((TFileFragmentCachable *)&v6);
}

void std::__throw_length_error[abi:fe180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:fe180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E60CEF58, MEMORY[0x1E4FBA1C8]);
}

void sub_1B52CA174(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:fe180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:fe180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

uint64_t std::__split_buffer<TFileFragmentCachable>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    TFileFragmentCachable::~TFileFragmentCachable((TFileFragmentCachable *)(i - 24));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::vector<char,TInlineBufferAllocator<char,1024ul>>::vector(void *a1, size_t a2, unsigned char *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[131] = a1 + 3;
  if (a2)
  {
    size_t v5 = a2;
    std::vector<char,TInlineBufferAllocator<char,1024ul>>::__vallocate[abi:fe180100](a1, a2);
    uint64_t v6 = (unsigned char *)a1[1];
    long long v7 = &v6[v5];
    do
    {
      *v6++ = *a3;
      --v5;
    }
    while (v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_1B52CA2C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<char,TInlineBufferAllocator<char,1024ul>>::__vallocate[abi:fe180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
  }
  uint64_t v4 = a1 + 131;
  uint64_t result = (char *)a1[131];
  if (&result[__sz] <= (char *)a1 + 1048) {
    *uint64_t v4 = &result[__sz];
  }
  else {
    uint64_t result = (char *)operator new(__sz);
  }
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]()
{
}

CFTypeRef FPFontCreateMemorySafeWithData(TFPFontSwift *a1, uint64_t a2, const __CFString *a3)
{
  CFMutableArrayRef v3 = TFPFontSwift::Create(a1, 0, a3);
  if (!v3)
  {
    CFArrayRef theArray = 0;
LABEL_7:
    TCFRetained<__CFArray const*>::~TCFRetained((const void **)&theArray);
    return 0;
  }
  CFArrayRef v4 = (const __CFArray *)CFRetain(v3);
  CFArrayRef theArray = v4;
  if (!v4 || CFArrayGetCount(v4) < 1) {
    goto LABEL_7;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
  if (ValueAtIndex) {
    CFTypeRef v6 = CFRetain(ValueAtIndex);
  }
  else {
    CFTypeRef v6 = 0;
  }
  TCFRetained<__CFArray const*>::~TCFRetained((const void **)&theArray);
  return v6;
}

void sub_1B52CA3D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TCFRetained<__CFArray const*>::~TCFRetained((const void **)va);
  _Unwind_Resume(a1);
}

CFMutableArrayRef TFPFontSwift::Create(TFPFontSwift *this, const __CFData *a2, const __CFString *a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  id v3 = +[AnyVectorFont anyVectorFontsWithData:this path:a2];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], [v3 count], &TFPFontImpl::GetArrayCallBacks(void)::sCFArrayCallBacks);
  memset(v6, 0, sizeof(v6));
  if ([v3 countByEnumeratingWithState:v6 objects:v7 count:16]) {
    operator new();
  }
  return Mutable;
}

void sub_1B52CA5F0(_Unwind_Exception *a1)
{
  TCFRetained<__CFString const*>::~TCFRetained(v2);
  TCFRetained<__CFData const*>::~TCFRetained((const void **)(v1 + 32));
  TCFRetained<TFPFontSwift const*>::~TCFRetained((const void **)(v1 + 24));
  MEMORY[0x1BA9994D0](v1, 0x10E1C4001F63121);
  _Unwind_Resume(a1);
}

CFMutableArrayRef FPFontCreateMemorySafeFontsFromData(TFPFontSwift *a1, uint64_t a2, const __CFString *a3)
{
  return TFPFontSwift::Create(a1, 0, a3);
}

TFPFontSwift *FPFontCreateMemorySafeFontsWithPath(const __CFData *a1)
{
  uint64_t result = (TFPFontSwift *)[MEMORY[0x1E4F1C9B8] dataWithContentsOfFile:a1];
  if (result)
  {
    return TFPFontSwift::Create(result, a1, v3);
  }
  return result;
}

void TFPFontSwift::~TFPFontSwift(TFPFontSwift *this)
{
  uint64_t v2 = *((void *)this + 29);
  if (v2)
  {
    CFStringRef v3 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x1BA9994D0](v2, 0x20C40960023A9);
  }
  uint64_t v4 = *((void *)this + 30);
  if (v4)
  {
    size_t v5 = *(void **)v4;
    if (*(void *)v4)
    {
      *(void *)(v4 + 8) = v5;
      operator delete(v5);
    }
    MEMORY[0x1BA9994D0](v4, 0x20C40960023A9);
  }
  uint64_t v6 = *((void *)this + 31);
  if (v6)
  {
    long long v7 = *(void **)v6;
    if (*(void *)v6)
    {
      *(void *)(v6 + 8) = v7;
      operator delete(v7);
    }
    MEMORY[0x1BA9994D0](v6, 0x10C402FEFCB83);
  }
  uint64_t v8 = (const void **)*((void *)this + 26);
  if (v8)
  {
    do
    {
      uint64_t v9 = (const void **)*v8;
      TCFRetained<CGPath const*>::~TCFRetained(v8 + 3);
      operator delete(v8);
      uint64_t v8 = v9;
    }
    while (v9);
  }
  timespec v10 = (void *)*((void *)this + 24);
  *((void *)this + 24) = 0;
  if (v10) {
    operator delete(v10);
  }
  TCFRetained<__CFString const*>::~TCFRetained((const void **)this + 5);
  TCFRetained<__CFData const*>::~TCFRetained((const void **)this + 4);
  TCFRetained<TFPFontSwift const*>::~TCFRetained((const void **)this + 3);
}

{
  uint64_t vars8;

  TFPFontSwift::~TFPFontSwift(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TFPFontSwift::CreateCopyWithVariation()
{
  return 0;
}

id TFPFontSwift::CreateVariationFromPostScriptNameSuffix(id *this, const __CFString *a2)
{
  uint64_t v2 = (void *)[this[2] variationWithPostScriptNameSuffix:a2];
  return v2;
}

uint64_t TFPFontSwift::IsSFNT(id *this)
{
  return [this[2] isSFNT];
}

id TFPFontSwift::CopySFNTData(id *this)
{
  uint64_t v1 = (void *)[this[2] sfntData];
  return v1;
}

__CFArray *TFPFontSwift::CopyTableTags(id *this)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (void *)[this[2] tableTags];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], [v1 count], 0);
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v3 = [v1 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v11;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v1);
        }
        CFNumberRef v7 = *(const __CFNumber **)(*((void *)&v10 + 1) + 8 * v6);
        valuePtr = (const void *)0xAAAAAAAAAAAAAAAALL;
        CFNumberGetValue(v7, kCFNumberCFIndexType, &valuePtr);
        CFArrayAppendValue(Mutable, valuePtr);
        ++v6;
      }
      while (v4 != v6);
      uint64_t v4 = [v1 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v4);
  }
  return Mutable;
}

uint64_t TFPFontSwift::CopyTable(id *this, uint64_t a2)
{
  return [this[2] copyTableDataWithTag:a2];
}

id TFPFontSwift::CopyMetadata(id *this)
{
  uint64_t v1 = (void *)[this[2] metadata];
  return v1;
}

uint64_t TFPFontSwift::GetPostScriptName(id *this)
{
  uint64_t v1 = (void *)[this[2] postScriptName];
  return [v1 UTF8String];
}

id TFPFontSwift::CopyPostScriptName(id *this)
{
  uint64_t v1 = (void *)[this[2] postScriptName];
  return v1;
}

id TFPFontSwift::CopyNameTablePostScriptName(id *this)
{
  uint64_t v1 = (void *)[this[2] nameTablePostScriptName];
  return v1;
}

id TFPFontSwift::CopyVariationPostScriptNamePrefix(id *this)
{
  uint64_t v1 = (void *)[this[2] variationPostScriptNamePrefix];
  return v1;
}

id TFPFontSwift::CopyAdditionalPostScriptNames(id *this)
{
  uint64_t v1 = (void *)[this[2] additionalPostScriptNames];
  return v1;
}

id TFPFontSwift::CopyAllNames(id *this)
{
  uint64_t v1 = (void *)[this[2] allNames];
  return v1;
}

id TFPFontSwift::CopyFullName(id *this)
{
  uint64_t v1 = (void *)[this[2] fullName];
  return v1;
}

id TFPFontSwift::CopyFamilyName(id *this)
{
  uint64_t v1 = (void *)[this[2] familyName];
  return v1;
}

CFTypeRef TFPFontSwift::CopyNames(id *this)
{
  uint64_t v1 = (const void *)[this[2] names];
  return CFRetain(v1);
}

uint64_t TFPFontSwift::GetDefaultInstance(TFPFontSwift *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    (*(void (**)(void))(*(void *)v1 + 24))(*((void *)this + 3));
  }
  return v1;
}

uint64_t TFPFontSwift::IsNamedInstanceAPI(id *this)
{
  return [this[2] isNamedInstance];
}

uint64_t TFPFontSwift::GetInstanceNameIDAPI(id *this)
{
  return [this[2] instanceNameID];
}

uint64_t TFPFontSwift::HasNamedInstanceWithOpticalSize(id *this)
{
  return [this[2] hasNamedInstanceWithOpticalSize];
}

uint64_t TFPFontSwift::GetVariations(TFPFontSwift *this, unint64_t *a2)
{
  return 0;
}

uint64_t TFPFontSwift::GetVariationAxes(TFPFontSwift *this, unint64_t *a2)
{
  return 0;
}

uint64_t TFPFontSwift::GetVariationAxisFlags(id *this, uint64_t a2)
{
  return [this[2] variationAxisFlagsWithTag:a2];
}

uint64_t TFPFontSwift::GetVariationAxisNameID(id *this, uint64_t a2)
{
  return [this[2] variationAxisNameIDWithTag:a2];
}

uint64_t TFPFontSwift::GetVariationValues(TFPFontSwift *this, unint64_t *a2)
{
  return 0;
}

uint64_t TFPFontSwift::GetVMetrics(TFPFontSwift *this, FPFontVMetrics *a2)
{
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3)
  {
    [v3 vMetrics];
  }
  else
  {
    CGFloat v9 = 0.0;
    long long v7 = 0u;
    long long v8 = 0u;
    long long v5 = 0u;
    long long v6 = 0u;
  }
  *(_OWORD *)&a2->var7 = v7;
  *(_OWORD *)&a2->var8.origin.y = v8;
  a2->var8.size.height = v9;
  *(_OWORD *)&a2->var0 = v5;
  *(_OWORD *)&a2->var4 = v6;
  return 1;
}

uint64_t TFPFontSwift::GetFontInfo(TFPFontSwift *this)
{
  return (uint64_t)this + 48;
}

uint64_t TFPFontSwift::GetNumberOfGlyphs(id *this)
{
  return [this[2] numberOfGlyphs];
}

uint64_t TFPFontSwift::GetUnitsPerEm(id *this)
{
  return [this[2] unitsPerEm];
}

double TFPFontSwift::GetTypoMetrics(id *this, double *a2, double *a3, double *a4)
{
  uint64_t v10 = -1;
  double v11 = NAN;
  uint64_t v9 = -1;
  if ([this[2] getTypoMetricsInto:&v9])
  {
    uint64_t v8 = v10;
    *(void *)a2 = v9;
    *(void *)a3 = v8;
    double result = v11;
    *a4 = v11;
  }
  return result;
}

double TFPFontSwift::GetWinMetrics(id *this, double *a2, double *a3)
{
  double v7 = NAN;
  uint64_t v8 = -1;
  if ([this[2] getWindowsMetricsInto:&v7])
  {
    double result = v7;
    uint64_t v6 = v8;
    *a2 = v7;
    *(void *)a3 = v6;
  }
  return result;
}

double TFPFontSwift::GetSubscriptX(id *this, double *a2, double *a3)
{
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  long long v8 = v5;
  long long v9 = v5;
  if ([this[2] getSubscriptInto:&v8])
  {
    double result = *(double *)&v9;
    uint64_t v7 = v8;
    *(void *)a2 = v9;
    *(void *)a3 = v7;
  }
  return result;
}

double TFPFontSwift::GetSubscriptY(id *this, double *a2, double *a3)
{
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  long long v8 = v5;
  long long v9 = v5;
  if ([this[2] getSubscriptInto:&v8])
  {
    double result = *((double *)&v9 + 1);
    uint64_t v7 = *((void *)&v8 + 1);
    *a2 = *((double *)&v9 + 1);
    *(void *)a3 = v7;
  }
  return result;
}

double TFPFontSwift::GetSuperscriptX(id *this, double *a2, double *a3)
{
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  long long v8 = v5;
  long long v9 = v5;
  if ([this[2] getSuperscriptInto:&v8])
  {
    double result = *(double *)&v9;
    uint64_t v7 = v8;
    *(void *)a2 = v9;
    *(void *)a3 = v7;
  }
  return result;
}

double TFPFontSwift::GetSuperscriptY(id *this, double *a2, double *a3)
{
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  long long v8 = v5;
  long long v9 = v5;
  if ([this[2] getSuperscriptInto:&v8])
  {
    double result = *((double *)&v9 + 1);
    uint64_t v7 = *((void *)&v8 + 1);
    *a2 = *((double *)&v9 + 1);
    *(void *)a3 = v7;
  }
  return result;
}

double TFPFontSwift::GetStrikeout(id *this, double *a2, double *a3)
{
  double v7 = NAN;
  uint64_t v8 = -1;
  if ([this[2] getStrikeoutInto:&v7])
  {
    double result = v7;
    uint64_t v6 = v8;
    *a3 = v7;
    *(void *)a2 = v6;
  }
  return result;
}

double TFPFontSwift::GetStems(id *this, double *a2, double *a3)
{
  double v7 = 0.0;
  uint64_t v8 = 0;
  [this[2] getStemsInto:&v7];
  double result = v7;
  uint64_t v6 = v8;
  *a2 = v7;
  *(void *)a3 = v6;
  return result;
}

uint64_t TFPFontSwift::CopyRegistryOrderingSupplement(id *this, const __CFString **a2, const __CFString **a3, int *a4)
{
  memset(v9, 170, sizeof(v9));
  uint64_t v7 = [this[2] getRegistryOrderingSupplement:&v9[3] :&v9[1] :v9];
  if (v7)
  {
    if (a2) {
      *a2 = (const __CFString *)*(id *)&v9[3];
    }
    if (a3) {
      *a3 = (const __CFString *)*(id *)&v9[1];
    }
    if (a4) {
      *a4 = v9[0];
    }
  }
  return v7;
}

uint64_t TFPFontSwift::IsBitmapOnly(id *this)
{
  return [this[2] isBitmapOnly];
}

uint64_t TFPFontSwift::IsSuitcase(id *this)
{
  return [this[2] isSuitcase];
}

CFTypeRef TFPFontSwift::CopyPath(TFPFontSwift *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 5);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

CFTypeRef TFPFontSwift::CopyCharacterSet(id *this)
{
  uint64_t v1 = (const void *)[this[2] characterSet];
  return CFRetain(v1);
}

uint64_t TFPFontSwift::GetOS2UnicodeRanges(id *this, unsigned int *a2, float a3)
{
  uint64_t result = objc_msgSend(this[2], "getOS2UnicodeRangesWithMinCoveragePercent:");
  *(void *)a2 = result;
  *((void *)a2 + 1) = v5;
  return result;
}

uint64_t TFPFontSwift::GetProtectionInfo(id *this)
{
  return [this[2] protectionInfo];
}

BOOL TFPFontSwift::GetType1Encoding(id *this, unsigned __int16 *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_msgSend((id)objc_msgSend(this[2], "type1Encoding"), "count");
  if (!v4) {
    return v4 != 0;
  }
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v5 = objc_msgSend(this[2], "type1Encoding", 0);
  uint64_t v6 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (!v6)
  {
    int v12 = 0;
LABEL_12:
    bzero((char *)a2 + (2 * v12), ((2 * v12) ^ 0x1FEu) + 2);
    return v4 != 0;
  }
  uint64_t v7 = v6;
  int v8 = 0;
  uint64_t v9 = *(void *)v15;
  do
  {
    uint64_t v10 = 0;
    int v11 = v8;
    do
    {
      if (*(void *)v15 != v9) {
        objc_enumerationMutation(v5);
      }
      a2[(v11 + v10)] = [*(id *)(*((void *)&v14 + 1) + 8 * v10) unsignedShortValue];
      ++v10;
    }
    while (v7 != v10);
    uint64_t v7 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
    int v8 = v11 + v10;
  }
  while (v7);
  int v12 = v11 + v10;
  if ((v11 + v10) <= 0xFF) {
    goto LABEL_12;
  }
  return v4 != 0;
}

uint64_t TFPFontSwift::GetTrueTypeEncoding(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return [*(id *)(a1 + 16) getTrueTypeEncodingWithPlatform:a2 script:a3 indexMap:a4];
}

uint64_t TFPFontSwift::GetUnicharsForGlyph(id *this, unsigned __int16 a2, unsigned __int16 *a3, uint64_t a4)
{
  return [this[2] getUnicharsWithGlyph:a2 unicodes:a3 count:a4];
}

uint64_t TFPFontSwift::GetGlyphsForText(id *this, FPEncoding a2, const char *a3, unsigned __int16 *a4, uint64_t a5)
{
  return [this[2] getGlyphsWithEncoding:*(void *)&a2.var0 & 0xFFFFFFFFFFFFLL text:a3 glyphs:a4 count:a5];
}

uint64_t TFPFontSwift::GetGlyphsForCharacters(id *this, const unsigned __int16 *a2, unsigned __int16 *a3, uint64_t a4)
{
  return [this[2] getGlyphsWithCharacters:a2 glyphs:a3 count:a4];
}

uint64_t TFPFontSwift::GetLongGlyphsForCharacters(id *this, const unsigned __int16 *a2, unsigned int *a3, uint64_t a4)
{
  return [this[2] getGlyphsWithCharacters:a2 longGlyphs:a3 count:a4];
}

uint64_t TFPFontSwift::GetGlyphsForCharacterRange(id *this, unsigned __int16 *a2, CFRange a3)
{
  return objc_msgSend(this[2], "getGlyphsWithCharacterRange:glyphs:", a3.location, a3.length, a2);
}

uint64_t TFPFontSwift::GetLongGlyphsForCharacterRange(id *this, unsigned int *a2, CFRange a3)
{
  return objc_msgSend(this[2], "getGlyphsWithCharacterRange:longGlyphs:", a3.location, a3.length, a2);
}

uint64_t TFPFontSwift::GetGlyphsForCIDs(id *this, const unsigned __int16 *a2, unsigned __int16 *a3, uint64_t a4)
{
  return [this[2] getGlyphsWithCids:a2 glyphs:a3 count:a4];
}

uint64_t TFPFontSwift::GetCIDsForGlyphs(id *this, const unsigned __int16 *a2, unsigned __int16 *a3, uint64_t a4)
{
  return [this[2] getCIDsWithGlyphs:a2 cids:a3 count:a4];
}

BOOL TFPFontSwift::GetFontSubsetFormat(id *this)
{
  return ![this[2] encodingType] && (objc_msgSend(this[2], "dataResidence") & 0xFFFFFFFFFFFFFFFDLL) == 0;
}

uint64_t TFPFontSwift::GetFormat(id *this)
{
  if ([this[2] encodingType]) {
    return 0;
  }
  uint64_t v3 = [this[2] dataResidence];
  if (v3 == 2) {
    unsigned int v4 = 9;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v3) {
    return v4;
  }
  else {
    return 11;
  }
}

id TFPFontSwift::CreateFontSubset(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __CFArray *a7)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a2 != 1) {
    return 0;
  }
  id v18 = 0;
  id v19 = 0;
  objc_msgSend(*(id *)(a1 + 16), "createSubsetWithName:glyphBits:glyphBitsSize:cmap_1_0:remapArray:data:", a3, a5, a4, a6, &v19, &v18);
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v8 = v19;
  uint64_t v9 = [v19 countByEnumeratingWithState:&v14 objects:v20 count:16];
  if (v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = *(void *)v15;
    do
    {
      uint64_t v12 = 0;
      do
      {
        if (*(void *)v15 != v11) {
          objc_enumerationMutation(v8);
        }
        CFArrayAppendValue(a7, (const void *)[*(id *)(*((void *)&v14 + 1) + 8 * v12++) unsignedIntValue]);
      }
      while (v10 != v12);
      uint64_t v10 = [v8 countByEnumeratingWithState:&v14 objects:v20 count:16];
    }
    while (v10);
  }
  return v18;
}

uint64_t TFPFontSwift::CanCreatePostScriptSubset(id *this, unsigned int a2)
{
  return [this[2] canCreatePostScriptSubsetWithFormat:a2];
}

id TFPFontSwift::CreatePostScriptSubset(id *this, const __CFString *a2, CGFontPostScriptFormat a3, const unsigned __int16 *a4, uint64_t a5, const unsigned __int16 *a6)
{
  uint64_t v6 = (void *)[this[2] createPostScriptSubsetWithFormat:a3 name:a2 glyphs:a4 glyphCount:a5 encoding:a6];
  return v6;
}

id TFPFontSwift::CreatePostScriptEncoding(id *this, const unsigned __int16 *a2)
{
  uint64_t v2 = (void *)[this[2] createPostScriptEncoding:a2];
  return v2;
}

uint64_t TFPFontSwift::GetGlyphsXo(id *this, unsigned __int16 *a2, unsigned __int16 *a3)
{
  return [this[2] getGlyphX:a2 o:a3];
}

uint64_t TFPFontSwift::GetGlyphsForGlyphNames(id *this, const char *const *a2, unsigned __int16 *a3, uint64_t a4)
{
  return [this[2] getGlyphsWithGlyphNames:a2 glyphs:a3 count:a4];
}

id TFPFontSwift::CopyGlyphNameForGlyph(id *this, unsigned __int16 a2)
{
  uint64_t v2 = (void *)[this[2] glyphNameWithGlyph:a2];
  return v2;
}

uint64_t TFPFontSwift::GetGlyphForGlyphName(id *this, CFStringRef theString)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v26 = v4;
  long long v27 = v4;
  long long v24 = v4;
  long long v25 = v4;
  long long v22 = v4;
  long long v23 = v4;
  long long v20 = v4;
  long long v21 = v4;
  long long v18 = v4;
  long long v19 = v4;
  long long v16 = v4;
  long long v17 = v4;
  long long v14 = v4;
  long long v15 = v4;
  long long v12 = v4;
  long long v13 = v4;
  long long v10 = v4;
  long long v11 = v4;
  *(_OWORD *)buffer = v4;
  long long v9 = v4;
  CStringPtr = (void *)CFStringGetCStringPtr(theString, 0x8000100u);
  if (!CStringPtr)
  {
    buffer[0] = 0;
    uint64_t result = CFStringGetCString(theString, buffer, 320, 0x8000100u);
    if (!result) {
      return result;
    }
    CStringPtr = buffer;
  }
  unsigned __int16 v6 = 0;
  [this[2] getGlyphsWithGlyphNames:&CStringPtr glyphs:&v6 count:1];
  return v6;
}

uint64_t TFPFontSwift::GetGlyphIdealAdvanceWidths(id *this, const unsigned __int16 *a2, double *a3, uint64_t a4)
{
  return [this[2] getGlyphIdealAdvanceWidthsWithGlyphs:a2 advances:a3 count:a4];
}

uint64_t TFPFontSwift::GetGlyphIdealAdvanceAndSideBearing(id *this, uint64_t a2, double *a3)
{
  uint64_t result = objc_msgSend(this[2], "getIdealAdvanceAndSideBearingWithGlyph:vertical:", a2);
  if (a3) {
    *(void *)a3 = v5;
  }
  return result;
}

uint64_t TFPFontSwift::GetGlyphIdealBounds(id *this, uint64_t a2)
{
  return [this[2] getIdealBoundsWithGlyph:a2];
}

uint64_t TFPFontSwift::GetGlyphIdealVerticalBounds(id *this, uint64_t a2)
{
  return [this[2] getIdealVerticalBoundsWithGlyph:a2];
}

uint64_t TFPFontSwift::GetGlyphDeviceAdvance(id *this, const CGAffineTransform *a2, uint64_t a3)
{
  return [this[2] getDeviceAdvanceWithGlyph:a3 transform:a2];
}

uint64_t TFPFontSwift::GetGlyphDeviceVerticalAdvance(id *this, const CGAffineTransform *a2, uint64_t a3)
{
  return [this[2] getVerticalDeviceAdvanceWithGlyph:a3 transform:a2];
}

uint64_t TFPFontSwift::GetGlyphDeviceBounds(id *this, const CGAffineTransform *a2, uint64_t a3)
{
  return [this[2] getDeviceBoundsWithGlyph:a3 transform:a2];
}

uint64_t TFPFontSwift::GetGlyphDeviceVerticalBounds(id *this, const CGAffineTransform *a2, uint64_t a3)
{
  return [this[2] getVerticalDeviceBoundsWithGlyph:a3 transform:a2];
}

uint64_t TFPFontSwift::CopyGlyphBitmap(id *this, const CGAffineTransform *a2, uint64_t a3, uint64_t a4, CGRect *a5, unint64_t *a6)
{
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = [this[2] copyBitmapWithGlyph:a3 transform:a2 options:a4 bounds:a5 bytesPerRow:&v8];
  if (a6) {
    *a6 = v8;
  }
  return result;
}

uint64_t TFPFontSwift::GetGlyphVerticalTranslate(id *this, uint64_t a2)
{
  return [this[2] getVerticalTranslateWithGlyph:a2];
}

CFTypeRef TFPFontSwift::CopyGlyphPath(id *this, float64x2_t *a2, uint64_t a3)
{
  float64x2_t v5 = *(float64x2_t *)(MEMORY[0x1E4F1DAB8] + 16);
  float64x2_t v11 = *(float64x2_t *)MEMORY[0x1E4F1DAB8];
  float64x2_t v12 = v5;
  long long v13 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
  if (a2)
  {
    unsigned __int16 v6 = (const CGAffineTransform *)a2;
    float64x2_t v7 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)objc_msgSend(this[2], "unitsPerEm", *(_OWORD *)&v11, *(_OWORD *)&v12, v13)), 0);
    float64x2_t v8 = vdivq_f64(*(float64x2_t *)&v6->a, v7);
    float64x2_t v9 = vdivq_f64(*(float64x2_t *)&v6->c, v7);
    float64x2_t v11 = v8;
    float64x2_t v12 = v9;
    long long v13 = *(_OWORD *)&v6->tx;
    a2 = &v11;
  }
  return TFPFontSwift::CopyOriginalGlyphPath((TFPFontSwift *)this, (const CGAffineTransform *)a2, a3);
}

CFTypeRef TFPFontSwift::CopyOriginalGlyphPath(TFPFontSwift *this, const CGAffineTransform *a2, uint64_t a3)
{
  unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
  unsigned __int16 v6 = (os_unfair_lock_s *)((char *)this + 184);
  os_unfair_lock_lock((os_unfair_lock_t)this + 46);
  unint64_t v7 = a3;
  unint64_t v8 = *((void *)this + 25);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = a3;
      if (v8 <= a3) {
        unint64_t v10 = a3 % v8;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & a3;
    }
    float64x2_t v11 = *(uint64_t ***)(*((void *)this + 24) + 8 * v10);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == a3)
        {
          if (*((_DWORD *)i + 4) == a3)
          {
            int v42 = (const void *)i[3];
            if (v42) {
              CFTypeRef v20 = CFRetain(v42);
            }
            else {
              CFTypeRef v20 = 0;
            }
            unint64_t v53 = (unint64_t)v20;
            os_unfair_lock_unlock(v6);
            if (!v20) {
              goto LABEL_101;
            }
LABEL_98:
            if (a2)
            {
              long long v49 = *(_OWORD *)&a2->c;
              *(_OWORD *)&v52.a = *(_OWORD *)&a2->a;
              *(_OWORD *)&v52.c = v49;
              *(_OWORD *)&v52.tx = *(_OWORD *)&a2->tx;
              if (!CGAffineTransformIsIdentity(&v52))
              {
                CFTypeRef v20 = (CFTypeRef)MEMORY[0x1BA999270](v20, a2);
                goto LABEL_101;
              }
            }
LABEL_100:
            unint64_t v53 = 0;
            goto LABEL_101;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v13 >= v8) {
              v13 %= v8;
            }
          }
          else
          {
            v13 &= v8 - 1;
          }
          if (v13 != v10) {
            break;
          }
        }
      }
    }
  }
  os_unfair_lock_unlock(v6);
  long long v14 = (void *)[*((id *)this + 2) copyOriginalPathWithGlyph:a3];
  if (!v14)
  {
    CFTypeRef v20 = 0;
    goto LABEL_100;
  }
  long long v15 = v14;
  uint64_t v54 = [v14 copyPath];

  os_unfair_lock_lock(v6);
  long long v16 = (const void *)v54;
  unint64_t v17 = *((void *)this + 25);
  if (v17)
  {
    uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v17);
    v18.i16[0] = vaddlv_u8(v18);
    if (v18.u32[0] > 1uLL)
    {
      unint64_t v19 = a3;
      if (v17 <= a3) {
        unint64_t v19 = a3 % v17;
      }
    }
    else
    {
      unint64_t v19 = (v17 - 1) & a3;
    }
    long long v21 = *(uint64_t ***)(*((void *)this + 24) + 8 * v19);
    if (v21)
    {
      for (j = *v21; j; j = (uint64_t *)*j)
      {
        unint64_t v23 = j[1];
        if (v23 == a3)
        {
          if (*((_DWORD *)j + 4) == a3) {
            goto LABEL_97;
          }
        }
        else
        {
          if (v18.u32[0] > 1uLL)
          {
            if (v23 >= v17) {
              v23 %= v17;
            }
          }
          else
          {
            v23 &= v17 - 1;
          }
          if (v23 != v19) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t v56 = 0xAAAAAAAAAAAAAA00;
  long long v24 = operator new(0x20uLL);
  long long v25 = (void *)((char *)this + 208);
  v55[0] = v24;
  v55[1] = (char *)this + 208;
  *long long v24 = 0;
  v24[1] = a3;
  *((_DWORD *)v24 + 4) = a3;
  if (v16) {
    CFTypeRef v26 = CFRetain(v16);
  }
  else {
    CFTypeRef v26 = 0;
  }
  int32x2_t v24[3] = v26;
  LOBYTE(v56) = 1;
  float v27 = (float)(unint64_t)(*((void *)this + 27) + 1);
  float v28 = *((float *)this + 56);
  if (!v17 || (float)(v28 * (float)v17) < v27)
  {
    BOOL v29 = 1;
    if (v17 >= 3) {
      BOOL v29 = (v17 & (v17 - 1)) != 0;
    }
    unint64_t v30 = v29 | (2 * v17);
    unint64_t v31 = vcvtps_u32_f32(v27 / v28);
    if (v30 <= v31) {
      int8x8_t prime = (int8x8_t)v31;
    }
    else {
      int8x8_t prime = (int8x8_t)v30;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v17 = *((void *)this + 25);
    if (*(void *)&prime > v17) {
      goto LABEL_51;
    }
    if (*(void *)&prime < v17)
    {
      unint64_t v39 = vcvtps_u32_f32((float)*((unint64_t *)this + 27) / *((float *)this + 56));
      if (v17 < 3 || (uint8x8_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v17), v40.i16[0] = vaddlv_u8(v40), v40.u32[0] > 1uLL))
      {
        unint64_t v39 = std::__next_prime(v39);
      }
      else
      {
        uint64_t v41 = 1 << -(char)__clz(v39 - 1);
        if (v39 >= 2) {
          unint64_t v39 = v41;
        }
      }
      if (*(void *)&prime <= v39) {
        int8x8_t prime = (int8x8_t)v39;
      }
      if (*(void *)&prime >= v17)
      {
        unint64_t v17 = *((void *)this + 25);
      }
      else
      {
        if (prime)
        {
LABEL_51:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:fe180100]();
          }
          long long v33 = operator new(8 * *(void *)&prime);
          int16x8_t v34 = (void *)*((void *)this + 24);
          *((void *)this + 24) = v33;
          if (v34) {
            operator delete(v34);
          }
          uint64_t v35 = 0;
          *((int8x8_t *)this + 25) = prime;
          do
            *(void *)(*((void *)this + 24) + 8 * v35++) = 0;
          while (*(void *)&prime != v35);
          float v36 = (void *)*v25;
          if (*v25)
          {
            unint64_t v37 = v36[1];
            uint8x8_t v38 = (uint8x8_t)vcnt_s8(prime);
            v38.i16[0] = vaddlv_u8(v38);
            if (v38.u32[0] > 1uLL)
            {
              if (v37 >= *(void *)&prime) {
                v37 %= *(void *)&prime;
              }
            }
            else
            {
              v37 &= *(void *)&prime - 1;
            }
            *(void *)(*((void *)this + 24) + 8 * v37) = v25;
            char v43 = (void *)*v36;
            if (*v36)
            {
              do
              {
                unint64_t v44 = v43[1];
                if (v38.u32[0] > 1uLL)
                {
                  if (v44 >= *(void *)&prime) {
                    v44 %= *(void *)&prime;
                  }
                }
                else
                {
                  v44 &= *(void *)&prime - 1;
                }
                if (v44 != v37)
                {
                  uint64_t v45 = *((void *)this + 24);
                  if (!*(void *)(v45 + 8 * v44))
                  {
                    *(void *)(v45 + 8 * v44) = v36;
                    goto LABEL_78;
                  }
                  void *v36 = *v43;
                  *char v43 = **(void **)(*((void *)this + 24) + 8 * v44);
                  **(void **)(*((void *)this + 24) + 8 * v44) = v43;
                  char v43 = v36;
                }
                unint64_t v44 = v37;
LABEL_78:
                float v36 = v43;
                char v43 = (void *)*v43;
                unint64_t v37 = v44;
              }
              while (v43);
            }
          }
          unint64_t v17 = (unint64_t)prime;
          goto LABEL_82;
        }
        unsigned int v51 = (void *)*((void *)this + 24);
        *((void *)this + 24) = 0;
        if (v51) {
          operator delete(v51);
        }
        unint64_t v17 = 0;
        *((void *)this + 25) = 0;
      }
    }
LABEL_82:
    if ((v17 & (v17 - 1)) != 0)
    {
      if (v17 <= v7) {
        unint64_t v19 = v7 % v17;
      }
      else {
        unint64_t v19 = v7;
      }
    }
    else
    {
      unint64_t v19 = (v17 - 1) & v7;
    }
  }
  int32x2_t v46 = *(void **)(*((void *)this + 24) + 8 * v19);
  uint64_t v47 = v55[0];
  if (v46)
  {
    *(void *)v55[0] = *v46;
LABEL_95:
    *int32x2_t v46 = v47;
    goto LABEL_96;
  }
  *(void *)v55[0] = *((void *)this + 26);
  *((void *)this + 26) = v47;
  *(void *)(*((void *)this + 24) + 8 * v19) = v25;
  if (*(void *)v47)
  {
    unint64_t v48 = *(void *)(*(void *)v47 + 8);
    if ((v17 & (v17 - 1)) != 0)
    {
      if (v48 >= v17) {
        v48 %= v17;
      }
    }
    else
    {
      v48 &= v17 - 1;
    }
    int32x2_t v46 = (void *)(*((void *)this + 24) + 8 * v48);
    goto LABEL_95;
  }
LABEL_96:
  v55[0] = 0;
  ++*((void *)this + 27);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,TCFRetained<CGPath const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,TCFRetained<CGPath const*>>,void *>>>>::reset[abi:fe180100]((uint64_t)v55);
  long long v16 = (const void *)v54;
LABEL_97:
  unint64_t v53 = (unint64_t)v16;
  uint64_t v54 = 0;
  os_unfair_lock_unlock(v6);
  TCFRetained<CGPath const*>::~TCFRetained((const void **)&v54);
  CFTypeRef v20 = v16;
  if (v16) {
    goto LABEL_98;
  }
LABEL_101:
  TCFRetained<CGPath const*>::~TCFRetained((const void **)&v53);
  return v20;
}

void sub_1B52CBCF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20,int a21,__int16 a22,char a23,char a24)
{
  os_unfair_lock_unlock(v24);
  _Unwind_Resume(a1);
}

id TFPFontSwift::CopySplicedStash(id *this)
{
  uint64_t v1 = (void *)[this[2] splicedStash];
  return v1;
}

uint64_t TFPFontSwift::GetVariationScalar(id *this, int a2)
{
  return [this[2] variationScalarWithTupleIndex:a2];
}

uint64_t TFPFontSwift::GetVariationScalars(id *this, int a2, double *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  float64x2_t v5 = (void *)[this[2] variationScalars];
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v6 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    __int16 v8 = 0;
    uint64_t v9 = *(void *)v18;
LABEL_3:
    uint64_t v10 = 0;
    __int16 v11 = v8;
    __int16 v12 = v8;
    if (v8 <= a2) {
      __int16 v12 = a2;
    }
    uint64_t v13 = (unsigned __int16)(v12 - v8);
    long long v14 = &a3[v8];
    while (1)
    {
      if (*(void *)v18 != v9) {
        objc_enumerationMutation(v5);
      }
      if (v13 == v10) {
        break;
      }
      [*(id *)(*((void *)&v17 + 1) + 8 * v10) doubleValue];
      v14[v10++] = v15;
      if (v7 == v10)
      {
        __int16 v8 = v11 + v10;
        uint64_t v7 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
        if (v7) {
          goto LABEL_3;
        }
        return 1;
      }
    }
  }
  return 1;
}

uint64_t TFPFontSwift::GetTupleCount(id *this)
{
  uint64_t v1 = objc_msgSend((id)objc_msgSend(this[2], "variationScalars"), "count");
  if (v1 ^ (__int16)v1 | ((uint64_t)(__int16)v1 >> 63)) {
    return 0x7FFF;
  }
  else {
    return (__int16)v1;
  }
}

uint64_t TFPFontSwift::GetControlPoints(id *this, uint64_t a2, unsigned int *a3, CGPoint *a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = *a3;
  uint64_t v7 = (void *)[this[2] controlPointsWithGlyph:a2];
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v8 = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v8)
  {
    uint64_t v9 = v8;
    unsigned int v10 = 0;
    uint64_t v11 = *(void *)v19;
LABEL_3:
    uint64_t v12 = 0;
    unsigned int v13 = v10;
    if (v6 >= v10) {
      uint64_t v14 = v6 - v10;
    }
    else {
      uint64_t v14 = 0;
    }
    double v15 = &a4[v10];
    while (1)
    {
      if (*(void *)v19 != v11) {
        objc_enumerationMutation(v7);
      }
      if (v14 == v12) {
        break;
      }
      [*(id *)(*((void *)&v18 + 1) + 8 * v12++) getValue:v15++ size:16];
      if (v9 == v12)
      {
        unsigned int v10 = v13 + v12;
        uint64_t v9 = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
        if (v9) {
          goto LABEL_3;
        }
        break;
      }
    }
    unsigned int v16 = v13 + v12;
  }
  else
  {
    unsigned int v16 = 0;
  }
  *a3 = v16;
  return 1;
}

const void **TCFRetained<CGPath const*>::~TCFRetained(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **TCFRetained<__CFArray const*>::~TCFRetained(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **TCFRetained<TFPFontSwift const*>::~TCFRetained(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **TCFRetained<__CFData const*>::~TCFRetained(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **TCFRetained<__CFString const*>::~TCFRetained(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,TCFRetained<CGPath const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,TCFRetained<CGPath const*>>,void *>>>>::reset[abi:fe180100](uint64_t a1)
{
  uint64_t v1 = *(const void ***)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      TCFRetained<CGPath const*>::~TCFRetained(v1 + 3);
    }
    operator delete(v1);
  }
}

void TType1PDTCFont::~TType1PDTCFont(TType1PDTCFont *this)
{
  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x1BA9994D0);
}

uint64_t TType1PDTCFont::GetFontDataTableTag(TType1PDTCFont *this)
{
  return 1346655299;
}

void *TType1LWFNParsingContext::CharStringIndex(TType1LWFNParsingContext *this, int a2, unsigned int a3, size_t __n, const char *__src)
{
  unsigned int v6 = __n;
  unsigned int v9 = *((_DWORD *)this + 230);
  int v10 = __n + 2;
  unint64_t v11 = v9 + __n + 2;
  *((void *)this + 107) = v11;
  if (*((void *)this + 108) >= v11)
  {
    uint64_t v15 = *((void *)this + 106);
  }
  else
  {
    uint64_t v12 = (*(uint64_t (**)(char *))(*((void *)this + 105) + 48))((char *)this + 840);
    uint64_t v13 = *((void *)this + 106);
    uint64_t v14 = *((void *)this + 105);
    if (v13) {
      uint64_t v15 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v14 + 40))((char *)this + 840, v13, v12);
    }
    else {
      uint64_t v15 = (*(uint64_t (**)(char *, uint64_t))(v14 + 16))((char *)this + 840, v12);
    }
    *((void *)this + 106) = v15;
    if (!v15)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 2;
    }
    *((void *)this + 108) = v12;
    unsigned int v9 = *((_DWORD *)this + 230);
  }
  uint64_t result = memcpy((void *)(v15 + v9), __src, v6);
  int v17 = *((_DWORD *)this + 230);
  long long v18 = (_DWORD *)(*((void *)this + 79) + 8 * a2);
  *long long v18 = v17;
  v18[1] = v6;
  *((_DWORD *)this + 230) = v17 + v10;
  return result;
}

BOOL TSortedStringTable::GetValue(const char ***this, const char *a2, unsigned int *a3)
{
  uint64_t v7 = a2;
  long long v4 = std::__equal_range[abi:fe180100]<std::_ClassicAlgPolicy,TSortedStringTable::LessThan &,std::pair<char const*,unsigned int> const*,std::pair<char const*,unsigned int> const*,char const*,std::__identity>(this[1], &this[1][2 * (void)*this], &v7);
  if (v4 != v5) {
    *a3 = *((_DWORD *)v4 + 2);
  }
  return v4 != v5;
}

uint64_t TType1LWFNParsingContext::BlendItalicAngle(TType1LWFNParsingContext *this, int a2, int a3)
{
  unint64_t v6 = 4 * *((unsigned __int16 *)this + 355);
  *((void *)this + 111) = v6;
  if (*((void *)this + 112) >= v6)
  {
    uint64_t v10 = *((void *)this + 110);
  }
  else
  {
    uint64_t v7 = (*(uint64_t (**)(char *))(*((void *)this + 109) + 48))((char *)this + 872);
    uint64_t v8 = *((void *)this + 110);
    uint64_t v9 = *((void *)this + 109);
    if (v8) {
      uint64_t v10 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v9 + 40))((char *)this + 872, v8, v7);
    }
    else {
      uint64_t v10 = (*(uint64_t (**)(char *, uint64_t))(v9 + 16))((char *)this + 872, v7);
    }
    *((void *)this + 110) = v10;
    if (!v10)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 2;
    }
    *((void *)this + 112) = v7;
  }
  *(_DWORD *)(v10 + 4 * a2) = a3;
  return 1;
}

void TLWFNType1Font::TLWFNType1Font(TLWFNType1Font *this, const TResourceForkSurrogate *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 28) = 0;
  *(void *)this = &unk_1F0DD4678;
  *((void *)this + 2) = &unk_1F0DD4890;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((void *)this + 32) = 850045863;
  *((void *)this + 39) = 0;
  *((void *)this + 40) = &unk_1F0DD4218;
  *((void *)this + 41) = 0;
  *((void *)this + 42) = 0;
  *((void *)this + 43) = 0;
  *((void *)this + 44) = 850045863;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((void *)this + 51) = 0;
  *((void *)this + 52) = &unk_1F0DD4218;
  *((void *)this + 53) = 0;
  *((void *)this + 54) = 0;
  *((void *)this + 55) = 0;
  TResourceFileDataSurrogate::TResourceFileDataSurrogate((TLWFNType1Font *)((char *)this + 448), a2);
}

void sub_1B52CCBD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  TType1LWFNParsingContext::~TType1LWFNParsingContext((TType1LWFNParsingContext *)va1);
  TResourceFileDataSurrogate::~TResourceFileDataSurrogate((TResourceFileDataSurrogate *)va);
  uint64_t v8 = v3 + 58;
  uint64_t v9 = v3[59];
  v3[59] = 0;
  if (v9) {
    MEMORY[0x1BA9994A0](v9, 0x1000C80BDFB0063);
  }
  uint64_t v10 = *v8;
  *uint64_t v8 = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  TResourceFileDataSurrogate::~TResourceFileDataSurrogate(v6);
  TDataReference::~TDataReference(v5);
  TDataReference::~TDataReference(v4);
  TType1Font::~TType1Font((TType1Font *)v3);
  _Unwind_Resume(a1);
}

void sub_1B52CCC8C()
{
}

unsigned __int8 *TLWFNType1Font::GetCharString@<X0>(TLWFNType1Font *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t result = (unsigned __int8 *)(*(uint64_t (**)(TLWFNType1Font *))(*(void *)this + 168))(this);
  if (result >= 0xFFFF) {
    unsigned int v7 = 0xFFFF;
  }
  else {
    unsigned int v7 = result;
  }
  if (v7 <= a2 || (uint64_t v8 = *((void *)this + 13)) == 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  size_t v9 = *(unsigned int *)(v8 + 8 * a2 + 4);
  if (v9)
  {
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)(a3 + 32) = v10;
    *(_OWORD *)(a3 + 48) = v10;
    *(_OWORD *)a3 = v10;
    *(_OWORD *)(a3 + 16) = v10;
    TCharString::TCharString((TCharString *)a3, a2, v9, 0);
    return LenIVDecrypt(*(unsigned __int8 **)(a3 + 8), (unsigned __int8 *)(*((void *)this + 29) + *(unsigned int *)(v8 + 8 * a2)), v9, *(__int16 *)(*((void *)this + 16) + 56));
  }
  else
  {
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = &unk_1F0DFF650;
    *(_DWORD *)(a3 + 24) = 0;
    *(unsigned char *)(a3 + 28) = 0;
    *(void *)(a3 + 32) = &unk_1F0DD4218;
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 48) = 0;
    *(void *)(a3 + 56) = 0;
  }
  return result;
}

void sub_1B52CCDF8(_Unwind_Exception *a1)
{
  TCharString::~TCharString(v1);
  _Unwind_Resume(a1);
}

BOOL TLWFNType1Font::GetType1Encoding(TLWFNType1Font *this, unsigned __int16 *__dst)
{
  uint64_t v2 = (const void *)*((void *)this + 31);
  if (v2) {
    memmove(__dst, v2, 0x200uLL);
  }
  return v2 != 0;
}

void non-virtual thunk to'TLWFNType1Font::~TLWFNType1Font(TLWFNType1Font *this)
{
}

{
  uint64_t vars8;

  TLWFNType1Font::~TLWFNType1Font((TLWFNType1Font *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

uint64_t TLWFNType1Font::GetVariationAxes(_WORD *a1, void **a2)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  if (!a1[74]) {
    return 0;
  }
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v108 = v3;
  long long v109 = v3;
  (*(void (**)(long long *__return_ptr))(*(void *)a1 + 480))(&v108);
  if (!*((void *)&v108 + 1)
    || ((uint64_t v4 = *(void *)(*((void *)&v108 + 1) + 8), v5 = v4 + v109, v4) ? (v6 = v4 + v109) : (v6 = 0), !v4))
  {
LABEL_119:
    TDataReference::~TDataReference((TDataReference *)&v108);
    return 0;
  }
  uint64_t v7 = v6 + *((void *)&v109 + 1) - v109;
  int v8 = bswap32(*(unsigned __int16 *)(v5 + 4));
  int v9 = v8 >> 16;
  uint64_t v10 = SHIWORD(v8);
  uint64_t v11 = SHIWORD(v8) + 3;
  if ((int)v11 <= (int)bswap32(*(unsigned __int16 *)(v5 + 12)) >> 16)
  {
    int v14 = *(unsigned __int16 *)(v5 + (int)bswap32(*(_DWORD *)(v5 + 4 * v10 + 22)));
    *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)unsigned int v110 = v15;
    long long v111 = v15;
    unsigned int v13 = *(unsigned __int16 *)(v5 + 10);
    if (!*(_WORD *)(v5 + 10))
    {
      if (!v14) {
        goto LABEL_123;
      }
      signed int v102 = bswap32(*(_DWORD *)(v5 + 4 * (int)v11 + 14));
      uint64_t v103 = *(unsigned __int8 *)(v5 + v102) + v5 + v102 + 1;
      uint64_t v17 = (unsigned __int8 *)(v103 + ((v103 ^ v5) & 1));
LABEL_13:
      LocalGetMMFondNameCoords(v17 + 1, v10, v110);
      goto LABEL_14;
    }
LABEL_11:
    unsigned int v16 = __rev16(v13);
    uint64_t v17 = (unsigned __int8 *)(v5 + (int)bswap32(*(_DWORD *)(v5 + 4 * v11 + 14)));
    do
    {
      --v16;
      v17 += *v17 + (((*v17 + (_BYTE)v17 + 1) ^ v5) & 1) + 1;
    }
    while ((_WORD)v16);
    goto LABEL_13;
  }
  *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v110 = v12;
  long long v111 = v12;
  unsigned int v13 = *(unsigned __int16 *)(v5 + 10);
  if (*(_WORD *)(v5 + 10)) {
    goto LABEL_11;
  }
LABEL_123:
  if (v9 >= 1)
  {
    uint64_t v104 = (unsigned __int16)v9;
    unint64_t v105 = (unsigned int *)(v109 + v4 + 14);
    uint64_t v106 = v110;
    do
    {
      unsigned int v107 = *v105++;
      *v106++ = bswap32(*(unsigned __int16 *)(v5 + 2 + (int)bswap32(v107))) >> 16;
      --v104;
    }
    while (v104);
  }
LABEL_14:
  unint64_t v18 = v7 - (v5 + (int)bswap32(*(_DWORD *)(v5 + 14)));
  int v19 = (v18 * (unsigned __int128)0x2492492492492493uLL) >> 64;
  LODWORD(v18) = v19 + ((v18 - v19) >> 1);
  unsigned int v20 = v18 >> 2;
  int v21 = (__int16)((int)v18 >> 2);
  if (v9 < (__int16)v20) {
    int v21 = v9;
  }
  if (v21 < 1) {
    goto LABEL_119;
  }
  uint64_t v22 = 0;
  uint64_t v23 = (unsigned __int16)v21;
  __int16 v24 = 256;
  do
  {
    uint64_t v25 = v5 + (int)bswap32(*(_DWORD *)(v5 + 4 * v22 + 14));
    unsigned int v26 = bswap32(*(unsigned __int16 *)(v25 + 2)) >> 16;
    unsigned int v27 = bswap32(*(unsigned __int16 *)(v25 + 4)) >> 16;
    if (v110[v22]) {
      __int16 v28 = v26;
    }
    else {
      __int16 v28 = v26 + 1;
    }
    if (v110[v22]) {
      __int16 v29 = v27;
    }
    else {
      __int16 v29 = v27 + 1;
    }
    if ((unsigned __int16)v110[v22] <= 1u) {
      __int16 v30 = 1;
    }
    else {
      __int16 v30 = v110[v22];
    }
    switch(*(unsigned char *)(v25 + 6))
    {
      case 5:
        if (*(_DWORD *)(v25 + 7) == 1952737623 && *(unsigned char *)(v25 + 11) == 104)
        {
          double v71 = (double)v30;
          double v49 = (double)v28 / v71;
          double v72 = (double)v29;
          unsigned int v51 = (char *)a2[1];
          int32x2_t v73 = (char *)a2[2];
          double v53 = v72 / v71;
          if (v51 < v73)
          {
            int v54 = 2003072104;
            goto LABEL_77;
          }
          uint64_t v77 = (v51 - (unsigned char *)*a2) >> 5;
          unint64_t v78 = v77 + 1;
          if ((unint64_t)(v77 + 1) >> 59) {
            std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v79 = v73 - (unsigned char *)*a2;
          if (v79 >> 4 > v78) {
            unint64_t v78 = v79 >> 4;
          }
          if ((unint64_t)v79 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v80 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v80 = v78;
          }
          unint64_t v64 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationAxis>>((uint64_t)(a2 + 2), v80);
          int v66 = &v64[32 * v77];
          *(_DWORD *)int v66 = 2003072104;
          *((_WORD *)v66 + 2) = 0;
          *((_WORD *)v66 + 3) = v24;
          *((double *)v66 + 1) = v49;
          *((double *)v66 + 2) = v53;
          *((void *)v66 + 3) = 0x3FF0000000000000;
          int v81 = (char *)*a2;
          int v67 = (char *)a2[1];
          int16x4_t v69 = v66;
          if (v67 != *a2)
          {
            do
            {
              long long v82 = *((_OWORD *)v67 - 1);
              *((_OWORD *)v69 - 2) = *((_OWORD *)v67 - 2);
              *((_OWORD *)v69 - 1) = v82;
              v69 -= 32;
              v67 -= 32;
            }
            while (v67 != v81);
            goto LABEL_113;
          }
          goto LABEL_114;
        }
        if (*(_DWORD *)(v25 + 7) == 1769104723 && *(unsigned char *)(v25 + 11) == 102)
        {
          double v74 = (double)v30;
          double v49 = (double)v28 / v74;
          double v75 = (double)v29;
          unsigned int v51 = (char *)a2[1];
          unsigned int v76 = (char *)a2[2];
          double v53 = v75 / v74;
          if (v51 < v76)
          {
            int v54 = 1936028262;
            goto LABEL_77;
          }
          uint64_t v89 = (v51 - (unsigned char *)*a2) >> 5;
          unint64_t v90 = v89 + 1;
          if ((unint64_t)(v89 + 1) >> 59) {
            std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v91 = v76 - (unsigned char *)*a2;
          if (v91 >> 4 > v90) {
            unint64_t v90 = v91 >> 4;
          }
          if ((unint64_t)v91 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v92 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v92 = v90;
          }
          unint64_t v64 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationAxis>>((uint64_t)(a2 + 2), v92);
          int v66 = &v64[32 * v89];
          *(_DWORD *)int v66 = 1936028262;
          *((_WORD *)v66 + 2) = 0;
          *((_WORD *)v66 + 3) = v24;
          *((double *)v66 + 1) = v49;
          *((double *)v66 + 2) = v53;
          *((void *)v66 + 3) = 0x3FF0000000000000;
          int v93 = (char *)*a2;
          int v67 = (char *)a2[1];
          int16x4_t v69 = v66;
          if (v67 != *a2)
          {
            do
            {
              long long v94 = *((_OWORD *)v67 - 1);
              *((_OWORD *)v69 - 2) = *((_OWORD *)v67 - 2);
              *((_OWORD *)v69 - 1) = v94;
              v69 -= 32;
              v67 -= 32;
            }
            while (v67 != v93);
            goto LABEL_113;
          }
          goto LABEL_114;
        }
        int v33 = *(_DWORD *)(v25 + 7);
        int v34 = *(unsigned __int8 *)(v25 + 11);
        if (v33 == 1819898963 && v34 == 101)
        {
          double v36 = (double)v28;
          double v37 = (double)v29;
          double v38 = (double)v30;
          unint64_t v39 = (char *)a2[1];
          uint8x8_t v40 = (char *)a2[2];
          if (v39 < v40)
          {
            int v41 = 1937013100;
            goto LABEL_63;
          }
          uint64_t v95 = (v39 - (unsigned char *)*a2) >> 5;
          unint64_t v96 = v95 + 1;
          if ((unint64_t)(v95 + 1) >> 59) {
            std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v97 = v40 - (unsigned char *)*a2;
          if (v97 >> 4 > v96) {
            unint64_t v96 = v97 >> 4;
          }
          if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v98 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v98 = v96;
          }
          unint64_t v64 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationAxis>>((uint64_t)(a2 + 2), v98);
          int v66 = &v64[32 * v95];
          *(_DWORD *)int v66 = 1937013100;
          *((_WORD *)v66 + 2) = 0;
          *((_WORD *)v66 + 3) = v24;
          *((double *)v66 + 1) = v36;
          *((double *)v66 + 2) = v37;
          *((double *)v66 + 3) = v38;
          uint64_t v99 = (char *)*a2;
          int v67 = (char *)a2[1];
          int16x4_t v69 = v66;
          if (v67 != *a2)
          {
            do
            {
              long long v100 = *((_OWORD *)v67 - 1);
              *((_OWORD *)v69 - 2) = *((_OWORD *)v67 - 2);
              *((_OWORD *)v69 - 1) = v100;
              v69 -= 32;
              v67 -= 32;
            }
            while (v67 != v99);
            goto LABEL_113;
          }
          goto LABEL_114;
        }
        break;
      case 6:
        int v45 = *(_DWORD *)(v25 + 7);
        int v46 = *(unsigned __int16 *)(v25 + 11);
        if (v45 == 1734960471 && v46 == 29800)
        {
          double v48 = (double)v30;
          double v49 = (double)v28 / v48;
          double v50 = (double)v29;
          unsigned int v51 = (char *)a2[1];
          CGAffineTransform v52 = (char *)a2[2];
          double v53 = v50 / v48;
          if (v51 < v52)
          {
            int v54 = 2003265652;
LABEL_77:
            *(_DWORD *)unsigned int v51 = v54;
            *((_WORD *)v51 + 2) = 0;
            *((_WORD *)v51 + 3) = v24;
            *((double *)v51 + 1) = v49;
            *((double *)v51 + 2) = v53;
            __int16 v59 = v51 + 32;
            *((void *)v51 + 3) = 0x3FF0000000000000;
            goto LABEL_116;
          }
          uint64_t v83 = (v51 - (unsigned char *)*a2) >> 5;
          unint64_t v84 = v83 + 1;
          if ((unint64_t)(v83 + 1) >> 59) {
            std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v85 = v52 - (unsigned char *)*a2;
          if (v85 >> 4 > v84) {
            unint64_t v84 = v85 >> 4;
          }
          if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v86 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v86 = v84;
          }
          unint64_t v64 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationAxis>>((uint64_t)(a2 + 2), v86);
          int v66 = &v64[32 * v83];
          *(_DWORD *)int v66 = 2003265652;
          *((_WORD *)v66 + 2) = 0;
          *((_WORD *)v66 + 3) = v24;
          *((double *)v66 + 1) = v49;
          *((double *)v66 + 2) = v53;
          *((void *)v66 + 3) = 0x3FF0000000000000;
          uint64_t v87 = (char *)*a2;
          int v67 = (char *)a2[1];
          int16x4_t v69 = v66;
          if (v67 != *a2)
          {
            do
            {
              long long v88 = *((_OWORD *)v67 - 1);
              *((_OWORD *)v69 - 2) = *((_OWORD *)v67 - 2);
              *((_OWORD *)v69 - 1) = v88;
              v69 -= 32;
              v67 -= 32;
            }
            while (v67 != v87);
            goto LABEL_113;
          }
          goto LABEL_114;
        }
        break;
      case 0xB:
        uint64_t v42 = *(void *)(v25 + 7);
        uint64_t v43 = *(void *)(v25 + 10);
        if (v42 == 0x536C61636974704FLL && v43 == 0x657A69536C616369) {
          goto LABEL_61;
        }
        break;
      case 0xC:
        uint64_t v55 = *(void *)(v25 + 7);
        int v56 = *(_DWORD *)(v25 + 15);
        if (v55 == 0x206C61636974704FLL && v56 == 1702521171)
        {
LABEL_61:
          double v36 = (double)v28;
          double v37 = (double)v29;
          double v38 = (double)v30;
          unint64_t v39 = (char *)a2[1];
          signed __int16 v58 = (char *)a2[2];
          if (v39 >= v58)
          {
            uint64_t v60 = (v39 - (unsigned char *)*a2) >> 5;
            unint64_t v61 = v60 + 1;
            if ((unint64_t)(v60 + 1) >> 59) {
              std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
            }
            uint64_t v62 = v58 - (unsigned char *)*a2;
            if (v62 >> 4 > v61) {
              unint64_t v61 = v62 >> 4;
            }
            if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v63 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v63 = v61;
            }
            unint64_t v64 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationAxis>>((uint64_t)(a2 + 2), v63);
            int v66 = &v64[32 * v60];
            *(_DWORD *)int v66 = 1869640570;
            *((_WORD *)v66 + 2) = 0;
            *((_WORD *)v66 + 3) = v24;
            *((double *)v66 + 1) = v36;
            *((double *)v66 + 2) = v37;
            *((double *)v66 + 3) = v38;
            uint64_t v68 = (char *)*a2;
            int v67 = (char *)a2[1];
            int16x4_t v69 = v66;
            if (v67 != *a2)
            {
              do
              {
                long long v70 = *((_OWORD *)v67 - 1);
                *((_OWORD *)v69 - 2) = *((_OWORD *)v67 - 2);
                *((_OWORD *)v69 - 1) = v70;
                v69 -= 32;
                v67 -= 32;
              }
              while (v67 != v68);
LABEL_113:
              int v67 = (char *)*a2;
            }
LABEL_114:
            __int16 v59 = v66 + 32;
            *a2 = v69;
            a2[1] = v66 + 32;
            a2[2] = &v64[32 * v65];
            if (v67) {
              operator delete(v67);
            }
          }
          else
          {
            int v41 = 1869640570;
LABEL_63:
            *(_DWORD *)unint64_t v39 = v41;
            *((_WORD *)v39 + 2) = 0;
            *((_WORD *)v39 + 3) = v24;
            *((double *)v39 + 1) = v36;
            *((double *)v39 + 2) = v37;
            __int16 v59 = v39 + 32;
            *((double *)v39 + 3) = v38;
          }
LABEL_116:
          a2[1] = v59;
          ++v24;
        }
        break;
      default:
        break;
    }
    ++v22;
  }
  while (v22 != v23);
  TDataReference::~TDataReference((TDataReference *)&v108);
  return 1;
}

void sub_1B52CD810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void TLWFNType1Font::GetVariationInstances(_WORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void **a4@<X8>)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  if (!a1[74]) {
    goto LABEL_12;
  }
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v64 = v7;
  long long v65 = v7;
  (*(void (**)(long long *__return_ptr))(*(void *)a1 + 480))(&v64);
  if (!*((void *)&v64 + 1)
    || (uint64_t v8 = *(void *)(*((void *)&v64 + 1) + 8)) == 0
    || (uint64_t v9 = v8 + v65, a2 != (__int16)(bswap32(*(unsigned __int16 *)(v8 + v65 + 4)) >> 16))
    || (uint64_t v10 = (int)a2 + 3, (int)v10 > (int)bswap32(*(unsigned __int16 *)(v9 + 12)) >> 16)
    || (signed int v11 = bswap32(*(_DWORD *)(v9 + (((a2 << 32) + 0x200000000) >> 30) + 14)),
        unsigned int v12 = *(unsigned __int16 *)(v9 + v11),
        !*(_WORD *)(v9 + v11)))
  {
    TDataReference::~TDataReference((TDataReference *)&v64);
LABEL_12:
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    return;
  }
  *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)int v66 = v13;
  long long v67 = v13;
  uint64_t v14 = v9 + 4 * (int)v10;
  if (*(_WORD *)(v9 + 10))
  {
    unsigned int v15 = __rev16(*(unsigned __int16 *)(v9 + 10));
    unsigned int v16 = (unsigned __int8 *)(v9 + (int)bswap32(*(_DWORD *)(v9 + 4 * v10 + 14)));
    do
    {
      --v15;
      v16 += *v16 + (((*v16 + (_BYTE)v16 + 1) ^ v9) & 1) + 1;
    }
    while ((_WORD)v15);
  }
  else
  {
    signed int v17 = bswap32(*(_DWORD *)(v14 + 14));
    uint64_t v18 = *(unsigned __int8 *)(v9 + v17) + v9 + v17 + 1;
    unsigned int v16 = (unsigned __int8 *)(v18 + ((v18 ^ v9) & 1));
  }
  uint64_t v61 = v9;
  LocalGetMMFondNameCoords(v16 + 1, (__int16)a2, v66);
  memset_pattern16(__b, &unk_1B5392B50, 0x20uLL);
  if (a2)
  {
    uint64_t v19 = 0;
    unint64_t v20 = 0;
    unsigned __int16 v21 = 256;
    do
    {
      __int16 v22 = 0;
      uint64_t v23 = v61 + (int)bswap32(*(_DWORD *)(v61 + (v19 >> 30) + 14));
      if ((unsigned __int16)v66[v20] <= 1u) {
        __int16 v24 = 1;
      }
      else {
        __int16 v24 = v66[v20];
      }
      switch(*(unsigned char *)(v23 + 6))
      {
        case 5:
          if (*(_DWORD *)(v23 + 7) == 1952737623 && *(unsigned char *)(v23 + 11) == 104) {
            goto LABEL_39;
          }
          if (*(_DWORD *)(v23 + 7) == 1769104723 && *(unsigned char *)(v23 + 11) == 102) {
            goto LABEL_39;
          }
          __int16 v22 = *(_DWORD *)(v23 + 7) == 1819898963 && *(unsigned char *)(v23 + 11) == 101;
          break;
        case 6:
          if (*(_DWORD *)(v23 + 7) != 1734960471 || *(_WORD *)(v23 + 11) != 29800) {
            goto LABEL_45;
          }
LABEL_39:
          if (v20 >= 0x10) {
            goto LABEL_97;
          }
          __b[v20] = v24;
LABEL_51:
          __int16 v22 = 1;
          break;
        case 0xB:
          if (*(void *)(v23 + 7) != 0x536C61636974704FLL || *(void *)(v23 + 10) != 0x657A69536C616369) {
            goto LABEL_45;
          }
          goto LABEL_51;
        case 0xC:
          if (*(void *)(v23 + 7) == 0x206C61636974704FLL && *(_DWORD *)(v23 + 15) == 1702521171) {
            goto LABEL_51;
          }
LABEL_45:
          __int16 v22 = 0;
          break;
        default:
          break;
      }
      v21 += v22;
      ++v20;
      v19 += 0x100000000;
    }
    while (a2 != v20);
  }
  else
  {
    unsigned __int16 v21 = 256;
  }
  a4[2] = 0;
  unsigned int v31 = __rev16(v12);
  *a4 = 0;
  a4[1] = 0;
  std::vector<TVariationInstance>::reserve(a4, (__int16)v31);
  std::vector<double>::reserve((void **)a3, (__int16)v31 * a2);
  unsigned __int8 v32 = v61;
  uint64_t v33 = v61 + (int)bswap32(*(_DWORD *)(v14 + 14));
  uint64_t v60 = a2 << 48;
  while (1)
  {
    uint64_t v62 = *(unsigned __int8 *)v33 + v33 + 1 + (((*(unsigned char *)v33 + v33 + 1) ^ v32) & 1);
    LocalGetMMFondNameCoords((unsigned __int8 *)(v62 + 1), (__int16)a2, v66);
    if (a2) {
      break;
    }
LABEL_76:
    double v48 = (unint64_t *)a4[1];
    unint64_t v47 = (unint64_t)a4[2];
    if ((unint64_t)v48 >= v47)
    {
      uint64_t v50 = ((char *)v48 - (unsigned char *)*a4) >> 3;
      if ((unint64_t)(v50 + 1) >> 61) {
        std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v51 = v47 - (void)*a4;
      uint64_t v52 = v51 >> 2;
      if (v51 >> 2 <= (unint64_t)(v50 + 1)) {
        uint64_t v52 = v50 + 1;
      }
      if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v53 = v52;
      }
      if (v53) {
        int v54 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationInstance>>((uint64_t)(a4 + 2), v53);
      }
      else {
        int v54 = 0;
      }
      uint64_t v55 = (unint64_t *)&v54[8 * v50];
      *uint64_t v55 = v60 | ((unint64_t)v21 << 16);
      double v49 = v55 + 1;
      long long v57 = (char *)*a4;
      int v56 = (char *)a4[1];
      if (v56 == *a4)
      {
        __int16 v59 = (unint64_t **)a4;
      }
      else
      {
        do
        {
          unint64_t v58 = *((void *)v56 - 1);
          v56 -= 8;
          *--uint64_t v55 = v58;
        }
        while (v56 != v57);
        __int16 v59 = (unint64_t **)a4;
        int v56 = (char *)*a4;
      }
      *__int16 v59 = v55;
      v59[1] = v49;
      v59[2] = (unint64_t *)&v54[8 * v53];
      if (v56) {
        operator delete(v56);
      }
    }
    else
    {
      *double v48 = v60 | ((unint64_t)v21 << 16);
      double v49 = v48 + 1;
    }
    unsigned __int8 v32 = v61;
    uint64_t v33 = v62;
    --v31;
    a4[1] = v49;
    ++v21;
    if (!(_WORD)v31)
    {
      TDataReference::~TDataReference((TDataReference *)&v64);
      return;
    }
  }
  uint64_t v34 = 0;
  while (v34 != 16)
  {
    double v35 = (double)v66[v34] / (double)(__int16)__b[v34];
    double v37 = *(double **)(a3 + 8);
    unint64_t v36 = *(void *)(a3 + 16);
    if ((unint64_t)v37 >= v36)
    {
      unint64_t v39 = *(double **)a3;
      uint64_t v40 = ((uint64_t)v37 - *(void *)a3) >> 3;
      unint64_t v41 = v40 + 1;
      if ((unint64_t)(v40 + 1) >> 61) {
        std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v42 = v36 - (void)v39;
      if (v42 >> 2 > v41) {
        unint64_t v41 = v42 >> 2;
      }
      if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v43 = v41;
      }
      if (v43)
      {
        unint64_t v44 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationInstance>>(a3 + 16, v43);
        unint64_t v39 = *(double **)a3;
        double v37 = *(double **)(a3 + 8);
      }
      else
      {
        unint64_t v44 = 0;
      }
      int v45 = (double *)&v44[8 * v40];
      *int v45 = v35;
      double v38 = v45 + 1;
      while (v37 != v39)
      {
        uint64_t v46 = *((void *)v37-- - 1);
        *((void *)v45-- - 1) = v46;
      }
      *(void *)a3 = v45;
      *(void *)(a3 + 8) = v38;
      *(void *)(a3 + 16) = &v44[8 * v43];
      if (v39) {
        operator delete(v39);
      }
    }
    else
    {
      double *v37 = v35;
      double v38 = v37 + 1;
    }
    *(void *)(a3 + 8) = v38;
    if (++v34 == a2) {
      goto LABEL_76;
    }
  }
LABEL_97:
  __break(1u);
}

void sub_1B52CDE38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  unsigned int v12 = *(void **)a7;
  if (*(void *)a7)
  {
    *(void *)(a7 + 8) = v12;
    operator delete(v12);
  }
  TDataReference::~TDataReference((TDataReference *)va);
  _Unwind_Resume(a1);
}

void std::vector<TVariationInstance>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationInstance>>(v3, a2);
    long long v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v9 = &v6[8 * v8];
    signed int v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    unsigned int v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void std::vector<double>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationInstance>>(v3, a2);
    long long v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v9 = &v6[8 * v8];
    uint64_t v10 = (char *)*a1;
    signed int v11 = (char *)a1[1];
    unsigned int v12 = v7;
    if (v11 != *a1)
    {
      unsigned int v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void TLWFNType1Font::GetNames(TLWFNType1Font *this@<X0>, void *a2@<X8>)
{
  memset(a2, 170, 24);
  TType1Font::GetNames((uint64_t)this, (uint64_t *)a2);
  if (*((_WORD *)this + 74))
  {
    *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v34 = v4;
    long long v35 = v4;
    (*(void (**)(long long *__return_ptr, TLWFNType1Font *))(*(void *)this + 480))(&v34, this);
    if (*((void *)&v34 + 1))
    {
      uint64_t v5 = *(void *)(*((void *)&v34 + 1) + 8);
      if (v5)
      {
        uint64_t v6 = v5 + v35;
        int v7 = bswap32(*(unsigned __int16 *)(v5 + v35 + 4));
        unsigned int v8 = HIWORD(v7);
        int v9 = v7 >> 16;
        uint64_t v33 = (__int16)v8 + 3;
        if ((int)v33 <= (int)bswap32(*(unsigned __int16 *)(v5 + v35 + 12)) >> 16) {
          unsigned int v10 = bswap32(*(unsigned __int16 *)(v6 + (int)bswap32(*(_DWORD *)(v6 + 4 * (__int16)v8 + 22)))) >> 16;
        }
        else {
          LOWORD(v10) = 0;
        }
        if (v9 < 1)
        {
          int v13 = 256;
        }
        else
        {
          uint64_t v11 = (unsigned __int16)v9;
          unsigned int v12 = (unsigned int *)(v35 + v5 + 14);
          int v13 = 256;
          do
          {
            unsigned int v14 = *v12++;
            uint64_t v15 = v6 + (int)bswap32(v14);
            unsigned int v16 = (unsigned __int8 *)(v15 + 6);
            switch(*(unsigned char *)(v15 + 6))
            {
              case 5:
                if (*(_DWORD *)(v15 + 7) == 1952737623 && *(unsigned char *)(v15 + 11) == 104) {
                  goto LABEL_37;
                }
                if (*(_DWORD *)(v15 + 7) == 1769104723 && *(unsigned char *)(v15 + 11) == 102) {
                  goto LABEL_37;
                }
                int v19 = *(_DWORD *)(v15 + 7);
                int v20 = *(unsigned __int8 *)(v15 + 11);
                BOOL v21 = v19 == 1819898963;
                int v22 = 101;
                goto LABEL_20;
              case 6:
                int v23 = *(_DWORD *)(v15 + 7);
                int v20 = *(unsigned __int16 *)(v15 + 11);
                BOOL v21 = v23 == 1734960471;
                int v22 = 29800;
LABEL_20:
                if (!v21 || v20 != v22) {
                  break;
                }
                goto LABEL_37;
              case 0xB:
                uint64_t v25 = *(void *)(v15 + 7);
                uint64_t v26 = *(void *)(v15 + 10);
                if (v25 != 0x536C61636974704FLL || v26 != 0x657A69536C616369) {
                  break;
                }
                goto LABEL_37;
              case 0xC:
                uint64_t v28 = *(void *)(v15 + 7);
                int v29 = *(_DWORD *)(v15 + 15);
                if (v28 != 0x206C61636974704FLL || v29 != 1702521171) {
                  break;
                }
LABEL_37:
                TType1Font::AddName((uint64_t *)a2, v16, v13++);
                break;
              default:
                break;
            }
            --v11;
          }
          while (v11);
        }
        if ((__int16)v10 > 0)
        {
          LOWORD(v31) = 0;
          unsigned __int8 v32 = (unsigned __int8 *)(v6 + (int)bswap32(*(_DWORD *)(v6 + 4 * v33 + 14)));
          do
          {
            v32 += *v32 + (((*v32 + (_BYTE)v32 + 1) ^ v6) & 1) + 1;
            TType1Font::AddName((uint64_t *)a2, v32, v13++);
            int v31 = (__int16)(v31 + 1);
          }
          while (v31 < (__int16)v10);
        }
      }
    }
    TDataReference::~TDataReference((TDataReference *)&v34);
  }
}

void sub_1B52CE2F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::vector<TFontNameString>::__destroy_vector::operator()[abi:fe180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t TParsingContext::IsCFF2(TParsingContext *this)
{
  return 0;
}

uint64_t TFont::GetSFNTFont(TFont *this)
{
  return 0;
}

void TFont::FindFontMetaData(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t TFont::GetRefCon(TFont *this)
{
  return 0;
}

const char **std::__equal_range[abi:fe180100]<std::_ClassicAlgPolicy,TSortedStringTable::LessThan &,std::pair<char const*,unsigned int> const*,std::pair<char const*,unsigned int> const*,char const*,std::__identity>(const char **a1, const char **a2, const char **a3)
{
  uint64_t v3 = a2;
  if (a2 != a1)
  {
    uint64_t v5 = a1;
    unint64_t v6 = ((char *)a2 - (char *)a1) >> 4;
    int v7 = *a3;
    while (1)
    {
      unint64_t v8 = v6 >> 1;
      int v9 = &v5[2 * (v6 >> 1)];
      unsigned int v10 = *v9;
      if (strcmp(*v9, v7) < 0)
      {
        uint64_t v5 = v9 + 2;
        unint64_t v8 = v6 + ~v8;
      }
      else
      {
        if ((strcmp(v7, v10) & 0x80000000) == 0)
        {
          uint64_t v5 = std::__lower_bound[abi:fe180100]<std::_ClassicAlgPolicy,std::pair<char const*,unsigned int> const*,std::pair<char const*,unsigned int> const*,char const*,std::__identity,TSortedStringTable::LessThan>(v5, &v5[2 * (v6 >> 1)], a3);
          std::__upper_bound[abi:fe180100]<std::_ClassicAlgPolicy,TSortedStringTable::LessThan &,std::pair<char const*,unsigned int> const*,std::pair<char const*,unsigned int> const*,char const*,std::__identity &>(v9 + 2, v3, a3);
          return v5;
        }
        uint64_t v3 = &v5[2 * (v6 >> 1)];
      }
      unint64_t v6 = v8;
      if (!v8) {
        return v5;
      }
    }
  }
  return a2;
}

const char **std::__lower_bound[abi:fe180100]<std::_ClassicAlgPolicy,std::pair<char const*,unsigned int> const*,std::pair<char const*,unsigned int> const*,char const*,std::__identity,TSortedStringTable::LessThan>(const char **a1, const char **a2, const char **a3)
{
  uint64_t v3 = a2;
  if (a2 != a1)
  {
    unint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
    uint64_t v5 = *a3;
    uint64_t v3 = a1;
    do
    {
      unint64_t v6 = &v3[2 * (v4 >> 1)];
      unint64_t v8 = *v6;
      int v7 = v6 + 2;
      if (strcmp(v8, v5) >= 0)
      {
        v4 >>= 1;
      }
      else
      {
        uint64_t v3 = v7;
        v4 += ~(v4 >> 1);
      }
    }
    while (v4);
  }
  return v3;
}

const char **std::__upper_bound[abi:fe180100]<std::_ClassicAlgPolicy,TSortedStringTable::LessThan &,std::pair<char const*,unsigned int> const*,std::pair<char const*,unsigned int> const*,char const*,std::__identity &>(const char **a1, const char **a2, const char **a3)
{
  uint64_t v3 = a2;
  if (a2 != a1)
  {
    unint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
    uint64_t v5 = *a3;
    uint64_t v3 = a1;
    do
    {
      unint64_t v6 = &v3[2 * (v4 >> 1)];
      unint64_t v8 = *v6;
      int v7 = v6 + 2;
      if (strcmp(v5, v8) < 0)
      {
        v4 >>= 1;
      }
      else
      {
        uint64_t v3 = v7;
        v4 += ~(v4 >> 1);
      }
    }
    while (v4);
  }
  return v3;
}

void *std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationAxis>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::__throw_bad_array_new_length[abi:fe180100]();
  }
  return operator new(32 * a2);
}

void *std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationInstance>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:fe180100]();
  }
  return operator new(8 * a2);
}

void TFontNameString::TFontNameString(TFontNameString *this, const TFontNameString *a2)
{
  TStringRef::TStringRef(this, a2);
  *(unsigned char *)(v4 + 64) = *((unsigned char *)a2 + 64);
  *(void *)uint64_t v4 = &unk_1F0DD4360;
  *(void *)(v4 + 66) = *(void *)((char *)a2 + 66);
  CFTypeRef v5 = (CFTypeRef)*((void *)a2 + 10);
  if (v5) {
    CFTypeRef v5 = CFRetain(v5);
  }
  *((void *)this + 10) = v5;
  CFTypeRef v6 = (CFTypeRef)*((void *)a2 + 11);
  if (v6) {
    CFTypeRef v6 = CFRetain(v6);
  }
  *((void *)this + 11) = v6;
}

void sub_1B52CE634(_Unwind_Exception *a1)
{
  TStringRef::~TStringRef(v1);
  _Unwind_Resume(a1);
}

void std::vector<TFontNameString>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    CFTypeRef v5 = **a1;
    if (v4 != v2)
    {
      CFTypeRef v6 = v4 - 96;
      int v7 = v4 - 96;
      unint64_t v8 = v4 - 96;
      do
      {
        int v9 = *(void (***)(char *))v8;
        v8 -= 96;
        (*v9)(v7);
        v6 -= 96;
        BOOL v10 = v7 == v2;
        int v7 = v8;
      }
      while (!v10);
      CFTypeRef v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ResolveCacheStrike(const TStrikeDescription *a1@<X0>, void *a2@<X8>)
{
  os_unfair_lock_lock((os_unfair_lock_t)&ResolveCacheStrike(TStrikeDescription const&)::lock);
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = *((void *)a1 + 1);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)a1 + 2);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *a2 = v5;
  a2[1] = v4;
  if (v5)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 8));
    int v6 = *((_DWORD *)a1 + 6);
    if (v6)
    {
      int v7 = (int *)*((void *)a1 + 4);
      int v8 = -2 * v6;
      int v9 = *((_DWORD *)a1 + 6);
      BOOL v10 = v7;
      do
      {
        int v11 = *v10++;
        v9 ^= v11;
        BOOL v12 = __CFADD__(v8++, 1);
      }
      while (!v12);
      int v13 = *(_DWORD **)(v5 + 24);
      if (*v13 == v9 && v13[4] == v6)
      {
        unsigned int v14 = v13 + 5;
        while (*v14 == *v7 && v14[1] == v7[1])
        {
          v14 += 2;
          v7 += 2;
          if (!--v6) {
            goto LABEL_14;
          }
        }
      }
    }
    else
    {
LABEL_14:
      uint64_t v15 = (char *)*((void *)a1 + 5);
      if (!v15) {
        goto LABEL_29;
      }
      uint64_t v16 = 0;
      int v17 = 0;
      do
      {
        v17 ^= *(_DWORD *)&v15[v16];
        v16 += 4;
      }
      while (v16 != 60);
      uint64_t v18 = *(_DWORD **)(v5 + 32);
      if (*v18 == v17 && !memcmp(v18 + 4, v15, 0x3CuLL))
      {
LABEL_29:
        os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 8));
        goto LABEL_46;
      }
    }
    *a2 = 0;
    a2[1] = 0;
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:fe180100](v4);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 8));
  }
  int v19 = operator new(0x28uLL, MEMORY[0x1E4FBA2D0]);
  if (v19)
  {
    int v20 = v19;
    *int v19 = &unk_1F0DFC3C8;
    *((_DWORD *)v19 + 2) = 0;
    void v19[2] = 0;
    BOOL v21 = v19 + 2;
    v19[3] = 0;
    v19[4] = 0;
    int v22 = operator new(0x18uLL, MEMORY[0x1E4FBA2D0]);
    if (v22)
    {
      int v23 = v22;
      uint64_t v24 = *((void *)a1 + 8);
      v23[8] = 0;
      *(_DWORD *)int v23 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 384))(v24);
      *((void *)v23 + 1) = 0;
      *BOOL v21 = v23;
      int v25 = *((_DWORD *)a1 + 6);
      uint64_t v26 = (uint64_t *)*((void *)a1 + 4);
      if (v25)
      {
        int v27 = -2 * v25;
        int v28 = *((_DWORD *)a1 + 6);
        int v29 = (int *)*((void *)a1 + 4);
        do
        {
          int v30 = *v29++;
          v28 ^= v30;
          BOOL v12 = __CFADD__(v27++, 1);
        }
        while (!v12);
      }
      else
      {
        int v28 = 0;
      }
      int v31 = (char *)malloc_type_calloc(1uLL, (8 * v25 + 36) + 8, 0x690B61C8uLL);
      if (v31)
      {
        *(void *)int v31 = (8 * v25 + 36) + 8;
        unsigned __int8 v32 = v31 + 8;
        *((_DWORD *)v31 + 6) = v25;
        if (v25)
        {
          uint64_t v33 = v31 + 28;
          do
          {
            uint64_t v34 = *v26++;
            *v33++ = v34;
            --v25;
          }
          while (v25);
        }
        *unsigned __int8 v32 = v28;
        v20[3] = v32;
        long long v35 = (long long *)*((void *)a1 + 5);
        if (v35)
        {
          uint64_t v36 = 0;
          int v37 = 0;
          do
          {
            v37 ^= *(_DWORD *)((char *)v35 + v36);
            v36 += 4;
          }
          while (v36 != 60);
          double v38 = (char *)malloc_type_calloc(1uLL, 0x58uLL, 0x690B61C8uLL);
          if (v38)
          {
            *(void *)double v38 = 88;
            long long v39 = *v35;
            long long v40 = v35[1];
            long long v41 = v35[2];
            long long v42 = *(long long *)((char *)v35 + 44);
            *((_DWORD *)v38 + 2) = v37;
            v38 += 8;
            *(_OWORD *)(v38 + 60) = v42;
            *((_OWORD *)v38 + 2) = v40;
            *((_OWORD *)v38 + 3) = v41;
            *((_OWORD *)v38 + 1) = v39;
          }
          _OWORD v20[4] = v38;
          if (!v38) {
            goto LABEL_44;
          }
LABEL_45:
          MScalerCache::SetCacheData((MCacheData *)v20, &v43);
        }
        if (v20[4]) {
          goto LABEL_45;
        }
LABEL_44:
        puts("ResolveCacheStrike: AssureStrikeNodes() failed!");
        goto LABEL_45;
      }
      BOOL v21 = v20 + 3;
    }
    *BOOL v21 = 0;
    goto LABEL_44;
  }
LABEL_46:
  os_unfair_lock_unlock((os_unfair_lock_t)&ResolveCacheStrike(TStrikeDescription const&)::lock);
}

void sub_1B52CEA54(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9994C0](v2, MEMORY[0x1E4FBA2D0]);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&ResolveCacheStrike(TStrikeDescription const&)::lock);
  _Unwind_Resume(a1);
}

void AssureScalerFontBlock(void *a1, memoryContext *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3)
  {
    a1[1] = v3;
    uint64_t v4 = v3 + *(unsigned int *)(v3 + 4);
    uint64_t v5 = v3 + *(unsigned int *)(v3 + 8);
    a1[6] = v4;
    a1[7] = v5;
  }
  else
  {
    ScalerFontBlock = CreateScalerFontBlock(a1, a2);
    *(void *)(a3 + 8) = ScalerFontBlock;
    ScalerDetachBlock(a2, ScalerFontBlock);
  }
}

void cacheStrike::~cacheStrike(cacheStrike *this)
{
  *(void *)this = &unk_1F0DFC3C8;
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 8);
    if (v3) {
      free((void *)(v3 - 8));
    }
    MEMORY[0x1BA9994D0](v2, 0x1080C40587D25DELL);
  }
  uint64_t v4 = (void *)*((void *)this + 4);
  if (v4) {
    DisposeBlockCacheNode(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 3);
  if (v5) {
    DisposeBlockCacheNode(v5);
  }
}

{
  uint64_t vars8;

  cacheStrike::~cacheStrike(this);
  JUMPOUT(0x1BA9994D0);
}

void DisposeBlockCacheNode(void *a1)
{
  CleanUpTransformBlock(a1);
  uint64_t v2 = a1[1];
  if (v2) {
    free((void *)(v2 - 8));
  }
  a1[1] = 0;
  free(a1 - 1);
}

uint64_t AssureStrikeBlocks(void *a1, memoryContext *a2, void *a3)
{
  if (!a3)
  {
    exception = __cxa_allocate_exception(2uLL);
    __int16 v15 = 1;
LABEL_14:
    _WORD *exception = v15;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t v4 = a3[2];
  if (!v4 || !a3[3] || !a3[4])
  {
    exception = __cxa_allocate_exception(2uLL);
    __int16 v15 = 20;
    goto LABEL_14;
  }
  AssureScalerFontBlock(a1, a2, v4);
  uint64_t v7 = a3[3];
  uint64_t v8 = *(void *)(v7 + 8);
  if (v8)
  {
    a1[2] = v8;
    *(void *)(v8 + 16) = v8 + *(unsigned int *)(v8 + 8);
    *(void *)(v8 + 32) = v8 + *(unsigned int *)(v8 + 24);
    *(void *)(v8 + 48) = v8 + *(unsigned int *)(v8 + 40);
  }
  else
  {
    ScalerVariationBlock = CreateScalerVariationBlock((uint64_t)a1, a2, *(_DWORD *)(v7 + 16), (uint64_t *)(v7 + 20));
    *(void *)(a3[3] + 8) = ScalerVariationBlock;
    ScalerDetachBlock(a2, ScalerVariationBlock);
  }
  uint64_t v10 = a3[4];
  uint64_t v11 = *(void *)(v10 + 8);
  if (v11)
  {
    a1[3] = v11;
    *(void *)(v11 + 16) = v11 + *(unsigned int *)(v11 + 8);
    *(void *)(v11 + 32) = v11 + *(unsigned int *)(v11 + 24);
    *(void *)(v11 + 48) = v11 + *(unsigned int *)(v11 + 40);
    *(void *)(v11 + 64) = v11 + *(unsigned int *)(v11 + 56);
    *(void *)(v11 + 80) = v11 + *(unsigned int *)(v11 + 72);
  }
  else
  {
    ScalerTransformBlock = CreateScalerTransformBlock(a1, a2, *(_DWORD *)(v10 + 16), *(_DWORD *)(v10 + 20), (long long *)(v10 + 24), (int *)(v10 + 60), (int *)(v10 + 68));
    *(void *)(a3[4] + 8) = ScalerTransformBlock;
    ScalerDetachBlock(a2, ScalerTransformBlock);
  }
  return 1;
}

uint64_t OFAErrors(int a1)
{
  if (a1 == 1028)
  {
    return 14;
  }
  else
  {
    __int16 v1 = 0;
    if (a1 && a1 <= 20)
    {
      if ((a1 - 5) > 0xF) {
        return 1;
      }
      else {
        return (__int16)word_1B541A0E2[a1 - 5];
      }
    }
  }
  return v1;
}

void AssureGlyphBlock(uint64_t a1, memoryContext *a2, int *a3)
{
  uint64_t v6 = *(void *)a2;
  int v7 = *(unsigned __int16 *)a3;
  if (!*(unsigned char *)(*(void *)(a1 + 24) + 490) || *(unsigned char *)(a1 + 66)) {
    v7 |= 0x80000000;
  }
  uint64_t v8 = *(void *)(v6 + 8);
  if (*(_DWORD *)v6 == v7)
  {
    if (v8)
    {
      *(void *)(a1 + 32) = v8;
      *(void *)(v8 + 8) = v8 + 136;
      SetupGlyphElementPointers(a1, v8, a3);
      return;
    }
  }
  else if (v8)
  {
    free((void *)(v8 - 8));
    *(void *)(v6 + 8) = 0;
  }
  ScalerGlyphBlock = CreateScalerGlyphBlock(a1, a2, a3);
  *(void *)(v6 + 8) = ScalerGlyphBlock;
  ScalerDetachBlock(a2, ScalerGlyphBlock);
}

void UnCacheCurrentGlyph(cacheCallContext *a1)
{
  CleanUpTransformBlock(a1);
  uint64_t v2 = *((void *)a1 + 1);
  if (v2) {
    free((void *)(v2 - 8));
  }
  *((void *)a1 + 1) = 0;
  *(_DWORD *)a1 = 0;
}

_WORD *CreateFontCacheNode@<X0>(const TFont *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = operator new(0x18uLL, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = (uint64_t)result;
  if (result)
  {
    result[8] = 0;
    uint64_t result = (_WORD *)(*(uint64_t (**)(const TFont *))(*(void *)a1 + 384))(a1);
    *(_DWORD *)uint64_t v5 = result;
    *(void *)(v5 + 8) = 0;
  }
  *a2 = v5;
  return result;
}

void sub_1B52CEF50(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9994C0](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

uint64_t woff2::Read255UShort(uint64_t *a1, unsigned int *a2)
{
  unint64_t v2 = a1[1];
  uint64_t v3 = a1[2];
  uint64_t v4 = v3 + 1;
  if (v3 + 1 > v2) {
    return 0;
  }
  uint64_t v6 = *a1;
  unsigned int v7 = *(unsigned __int8 *)(*a1 + v3);
  a1[2] = v4;
  switch(v7)
  {
    case 0xFFu:
      if (v3 + 2 <= v2)
      {
        int v9 = *(unsigned __int8 *)(v6 + v4);
        a1[2] = v3 + 2;
        unsigned int v7 = v9 + 253;
        break;
      }
      return 0;
    case 0xFEu:
      if (v3 + 2 <= v2)
      {
        int v10 = *(unsigned __int8 *)(v6 + v4);
        a1[2] = v3 + 2;
        unsigned int v7 = v10 + 506;
        break;
      }
      return 0;
    case 0xFDu:
      unint64_t v8 = v3 + 3;
      if (v8 <= v2)
      {
        unsigned int v7 = bswap32(*(unsigned __int16 *)(v6 + v4)) >> 16;
        a1[2] = v8;
        break;
      }
      return 0;
  }
  *a2 = v7;
  return 1;
}

uint64_t woff2::ReadBase128(void *a1, int *a2)
{
  unint64_t v2 = 0;
  unsigned int v3 = 0;
  unint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  BOOL v6 = 1;
  while (1)
  {
    unint64_t v7 = v5 + v2 + 1;
    if (v7 > v4
      || ((int v8 = *(unsigned __int8 *)(*a1 + v5 + v2), a1[2] = v7, v8 == 128) ? (v9 = v2 == 0) : (v9 = 0),
          !v9 ? (BOOL v10 = v3 >> 25 == 0) : (BOOL v10 = 0),
          !v10))
    {
LABEL_13:
      int v13 = 0;
      return v6 & v13;
    }
    char v11 = v8;
    int v12 = v8 & 0x7F | (v3 << 7);
    if ((v11 & 0x80) == 0) {
      break;
    }
    BOOL v6 = v2++ < 4;
    unsigned int v3 = v12;
    if (v2 == 5) {
      goto LABEL_13;
    }
  }
  *a2 = v12;
  int v13 = 1;
  return v6 & v13;
}

void std::vector<unsigned char>::__throw_length_error[abi:fe180100]()
{
}

int *ComputeDestBitmap(int *result, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a2 + 16);
  if (v5 == *(_DWORD *)(a2 + 24))
  {
    unsigned int v6 = 0;
    long long v7 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a2;
    *(_OWORD *)(a3 + 16) = v7;
  }
  else
  {
    int v8 = result;
    int v9 = M3x3Flags(result);
    __int32 v10 = *(_DWORD *)(a2 + 28) << 16;
    v25.i32[0] = v5 << 16;
    v25.i32[1] = v10;
    M3x3Mul(v8, v9, &v25, (const int *)1);
    int32x2_t v24 = vshl_n_s32(*(int32x2_t *)(a2 + 24), 0x10uLL);
    M3x3Mul(v8, v9, &v24, (const int *)1);
    int32x2_t v23 = vshl_n_s32(*(int32x2_t *)(a2 + 16), 0x10uLL);
    M3x3Mul(v8, v9, &v23, (const int *)1);
    int32x2_t v22 = vrev64_s32(vshl_n_s32(*(int32x2_t *)(a2 + 20), 0x10uLL));
    uint64_t result = (int *)M3x3Mul(v8, v9, &v22, (const int *)1);
    __int32 v11 = v25.i32[0];
    __int32 v12 = v25.i32[1];
    if (v25.i32[1] >= v24.i32[1]) {
      int v13 = v24.i32[1];
    }
    else {
      int v13 = v25.i32[1];
    }
    if (v25.i32[1] <= v24.i32[1]) {
      __int32 v12 = v24.i32[1];
    }
    if (v25.i32[0] >= v24.i32[0]) {
      int v14 = v24.i32[0];
    }
    else {
      int v14 = v25.i32[0];
    }
    if (v25.i32[0] <= v24.i32[0]) {
      __int32 v11 = v24.i32[0];
    }
    if (v23.i32[0] < v14) {
      int v14 = v23.i32[0];
    }
    if (v22.i32[0] < v14) {
      int v14 = v22.i32[0];
    }
    if (v23.i32[1] < v13) {
      int v13 = v23.i32[1];
    }
    if (v22.i32[1] < v13) {
      int v13 = v22.i32[1];
    }
    if (v23.i32[0] > v11) {
      __int32 v11 = v23.i32[0];
    }
    if (v22.i32[0] <= v11) {
      int v15 = v11;
    }
    else {
      int v15 = v22.i32[0];
    }
    if (v23.i32[1] <= v12) {
      __int32 v16 = v12;
    }
    else {
      __int32 v16 = v23.i32[1];
    }
    if (v22.i32[1] <= v16) {
      int v17 = v16;
    }
    else {
      int v17 = v22.i32[1];
    }
    unsigned int v18 = -((0x8000 - v14) >> 16);
    if (v14 >= 0) {
      unsigned int v18 = (v14 + 0x8000) >> 16;
    }
    unsigned int v19 = -((0x8000 - v15) >> 16);
    if (v15 >= 0) {
      unsigned int v19 = (v15 + 0x8000) >> 16;
    }
    unsigned int v20 = -((0x8000 - v13) >> 16);
    if (v13 >= 0) {
      unsigned int v20 = (v13 + 0x8000) >> 16;
    }
    *(_DWORD *)(a3 + 16) = v18;
    *(_DWORD *)(a3 + 20) = v20;
    unsigned int v21 = -((0x8000 - v17) >> 16);
    if (v17 >= 0) {
      unsigned int v21 = (v17 + 0x8000) >> 16;
    }
    *(_DWORD *)(a3 + 24) = v19;
    *(_DWORD *)(a3 + 28) = v21;
    if (v19 == v18)
    {
      unsigned int v19 = v18 + 1;
      *(_DWORD *)(a3 + 24) = v18 + 1;
    }
    if (v21 == v20) {
      *(_DWORD *)(a3 + 28) = v20 + 1;
    }
    unsigned int v6 = ((int)(v19 - v18 + 31) >> 3) & 0xFFFFFFFC;
  }
  *(_DWORD *)(a3 + 32) = v6;
  return result;
}

uint64_t TransformScalerBitmap(int *a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  int32x2_t v61 = (int32x2_t)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = M3x3Flags(a1);
  int v54 = *(_DWORD **)a3;
  uint64_t v57 = *a2;
  unint64_t v58 = a2;
  int v11 = *(_DWORD *)(a3 + 28);
  unint64_t v10 = *(unsigned int *)(a3 + 32);
  int v12 = v10 << 19;
  unint64_t v13 = v10 >> 2;
  int v14 = *((_DWORD *)a2 + 7);
  int v59 = 8 * *((_DWORD *)a2 + 8);
  int v15 = *((_DWORD *)a2 + 5);
  int v16 = *((_DWORD *)a2 + 6) << 16;
  int v17 = *((_DWORD *)a2 + 4) << 16;
  __int32 v18 = v14 << 16;
  int v19 = v15 << 16;
  int v20 = *(_DWORD *)(a3 + 16) << 16;
  int v21 = v20 + (v10 << 19);
  int v22 = v11 - a4;
  int v52 = v11 - a4 - a5;
  if (result)
  {
    if (a5 >= 1)
    {
      int v23 = result;
      int v55 = v20 | 0x8000;
      int v51 = v21 | 0x8000;
      float64x2_t v50 = (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL);
      uint64_t v49 = v13;
      unsigned int v24 = (v14 - v15) * v59;
      float64x2_t v48 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v12 * 0.0000152587891), 0);
      do
      {
        int32x2_t v25 = v54;
        int v53 = v22;
        int v26 = (v22 << 16) - 0x8000;
        int32x2_t v60 = (int32x2_t)__PAIR64__(v26, v55);
        M3x3Mul(a1, v23, &v60, (const int *)1);
        int32x2_t v61 = (int32x2_t)__PAIR64__(v26, v51);
        uint64_t result = M3x3Mul(a1, v23, &v61, (const int *)1);
        int v27 = 0;
        int32x2_t v28 = v60;
        int32x2_t v29 = vsub_s32(v61, v60);
        v30.i64[0] = v29.i32[0];
        v30.i64[1] = v29.i32[1];
        int32x2_t v31 = vmovn_s64(vcvtq_n_s64_f64(vdivq_f64(vmulq_f64(vcvtq_f64_s64(v30), v50), v48), 0x10uLL));
        v54 += v49;
        do
        {
          *int32x2_t v25 = 0;
          unsigned int v32 = 0x80000000;
          do
          {
            if (v28.i32[0] >= v17 && v28.i32[0] <= v16)
            {
              BOOL v33 = v28.i32[1] > v19 && v28.i32[1] <= v18;
              if (v33)
              {
                unsigned int v34 = (*((_DWORD *)v58 + 7) - ((v28.i32[1] + 0xFFFF) >> 16)) * v59 + (v28.i32[0] >> 16);
                if (v34 >= v24) {
                  unsigned int v34 = v24 - 1;
                }
                if (((bswap32(*(unsigned __int16 *)(v57 + 2 * (v34 >> 4))) >> 16 << (v34 & 0xF)) & 0x8000) != 0) {
                  *v25 |= v32;
                }
              }
            }
            if (v23 == 6)
            {
              v60.i32[0] = v55 + (++v27 << 16);
              v60.i32[1] = v26;
              uint64_t result = M3x3Mul(a1, 6, &v60, (const int *)1);
              int32x2_t v28 = v60;
            }
            else
            {
              int32x2_t v28 = vadd_s32(v28, v31);
            }
            BOOL v33 = v32 > 1;
            v32 >>= 1;
          }
          while (v33);
          ++v25;
        }
        while (v25 != v54);
        int v22 = v53 - 1;
      }
      while (v53 - 1 > v52);
    }
  }
  else if (a5 >= 1)
  {
    int v35 = v20 | 0x8000;
    double v36 = (double)v12 * 0.0000152587891;
    unsigned int v37 = vcvtd_n_s64_f64((double)((v21 | 0x8000) - v35) * 0.0000152587891 / v36, 0x10uLL);
    unsigned int v38 = vcvtd_n_s64_f64(0.0 / v36, 0x10uLL);
    int v39 = 32 * v38;
    int v40 = ((v11 << 16) - (a4 << 16)) | 0x7FFF;
    do
    {
      long long v41 = v54;
      int v42 = (v22 << 16) - 0x8000;
      v54 += v13;
      int v43 = v40;
      LODWORD(result) = v35;
      do
      {
        int v44 = 0;
        int v45 = 0;
        *long long v41 = 0;
        unsigned int v46 = 0x80000000;
        int v47 = result;
        do
        {
          if (v47 >= v17
            && v47 <= v16
            && v42 + v44 > v19
            && v42 + v44 <= v18
            && ((bswap32(*(unsigned __int16 *)(v57
                                             + 2
                                             * (((*((_DWORD *)v58 + 7) - ((v43 + v44) >> 16)) * v59
                                                             + (v47 >> 16)) >> 4))) >> 16 << (((*((unsigned char *)v58 + 28)
                                                                                              - ((v43 + v44) >> 16))
                                                                                             * v59
                                                                                             + BYTE2(v47)) & 0xF)) & 0x8000) != 0)
          {
            v45 |= v46;
            *long long v41 = v45;
          }
          v47 += v37;
          v44 += v38;
          BOOL v33 = v46 > 1;
          v46 >>= 1;
        }
        while (v33);
        uint64_t result = result + 32 * v37;
        v42 += v39;
        ++v41;
        v43 += v39;
      }
      while (v41 != v54);
      --v22;
      v40 -= 0x10000;
    }
    while (v22 > v52);
  }
  return result;
}

unsigned int *MoveBitsSmall(unsigned int *result, const void *a2, int a3, unsigned int *a4, int a5)
{
  if (a5)
  {
    int v5 = a5;
    long long v7 = (unsigned int *)(((unint64_t)result + (a3 >> 3)) & 0xFFFFFFFFFFFFFFFCLL);
    if (v7 < result) {
      long long v7 = result;
    }
    if (a3) {
      int v8 = v7;
    }
    else {
      int v8 = result;
    }
    if (a3) {
      int v9 = a3 + 8 * (result - v7);
    }
    else {
      int v9 = 0;
    }
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 0x40000000;
    int v16 = ___Z13MoveBitsSmallPKvS0_iPvi_block_invoke;
    int v17 = &__block_descriptor_tmp_0;
    __int32 v18 = a2;
    int v19 = 0;
    int v10 = -1 << v9;
    uint64_t result = (unsigned int *)___Z13MoveBitsSmallPKvS0_iPvi_block_invoke((uint64_t)v15, v8);
    int v11 = bswap32(*result) << v9;
    int v12 = v8 + 1;
    if (v5 < 33)
    {
      if (v5 <= 0) {
        return result;
      }
      int v14 = v5 - 32;
    }
    else
    {
      do
      {
        int v13 = v11;
        uint64_t result = (unsigned int *)v16((uint64_t)v15, v12);
        int v11 = __ROR4__(bswap32(*result), -(char)v9);
        *a4++ = bswap32(v11 & ~v10 | v13 & v10);
        ++v12;
        v5 -= 32;
        int v14 = v5 - 32;
      }
      while (v5 > 0x20);
    }
    if (v14 > -v9)
    {
      uint64_t result = (unsigned int *)v16((uint64_t)v15, v12);
      int v11 = __ROR4__(bswap32(*result), -(char)v9) & ~v10 | v11 & v10;
    }
    *a4 = bswap32(bswap32(*a4) & ~(-1 << -(char)v5) | v11 & (-1 << -(char)v5));
  }
  return result;
}

uint64_t ___Z13MoveBitsSmallPKvS0_iPvi_block_invoke(uint64_t a1, _DWORD *a2)
{
  unint64_t v3 = *(void *)(a1 + 32);
  if ((unint64_t)(a2 + 1) <= v3)
  {
    *(_DWORD *)(a1 + 40) = *a2;
  }
  else
  {
    if (v3 <= (unint64_t)a2)
    {
      exception = __cxa_allocate_exception(2uLL);
      _WORD *exception = 5;
      __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
    }
    memcpy((void *)(a1 + 40), a2, v3 - (void)a2);
  }
  return a1 + 40;
}

void MakeOutlineFromBitmap(memoryContext *a1, uint64_t a2, uint64_t a3, int *a4, int a5, int *a6, void *a7, int a8, int a9)
{
  int v14 = a4[2];
  int v13 = a4[3];
  int v16 = *a4;
  int v15 = a4[1];
  if (a5 >= -3) {
    int v17 = a5 + 3;
  }
  else {
    int v17 = a5 + 6;
  }
  v170.i32[0] = 0;
  v170.i32[1] = v13 << 16;
  int v163 = M3x3Flags(a6);
  M3x3Mul(a6, v163, &v170, (const int *)1);
  int v165 = a8;
  if (a8) {
    v170.i32[1] = -v170.i32[1];
  }
  if (!a3
    || ((v18 = v14 - v16, int v19 = v13 - v15, (_WORD)v18) ? (v20 = (unsigned __int16)(v13 - v15) == 0) : (v20 = 1), v20))
  {
    int v53 = ScalerNewBlock(a1, 28, a9, 0, 0, 0, 0);
    *int v53 = 0x200000001;
    *((_DWORD *)v53 + 2) = 0;
    *(int32x2_t *)&long long v54 = v170;
    *((int32x2_t *)&v54 + 1) = v170;
    *(_OWORD *)((char *)v53 + 12) = v54;
    *a7 = v53;
  }
  else
  {
    uint64_t v21 = a3;
    int v161 = (__int16)v13;
    __int16 v171 = -21846;
    int v168 = v18;
    int v22 = (char *)ScalerNewBlock(a1, 0x8000, -1, 0, 0, 0, 0);
    __int16 v23 = v168;
    unsigned int v24 = v22;
    int v25 = (__int16)v168;
    int v160 = v168 << 16;
    v157 = a7;
    if (v168 << 16 < 0)
    {
      int v29 = 0x8000;
      uint64_t v28 = 0;
      uint64_t v36 = 2048;
    }
    else
    {
      int v26 = 0;
      unsigned __int16 v27 = 0;
      uint64_t v28 = 0;
      int v29 = 0x8000;
      uint64_t v30 = 2048;
      do
      {
        if ((v27 & 0x8000) != 0
          || v25 <= (__int16)v27
          || ((bswap32(*(_DWORD *)(a3 + 4 * (v27 >> 5))) << v27) & 0x80000000) == 0)
        {
          uint64_t v36 = v30;
          uint64_t v30 = v28;
        }
        else
        {
          int32x2_t v31 = &v24[16 * (int)v28];
          *((_WORD *)v31 + 7) = 1;
          *(_DWORD *)int32x2_t v31 = v26;
          *((_DWORD *)v31 + 1) = v161;
          *((_WORD *)v31 + 4) = v28 + 1;
          *(_DWORD *)(v31 + 10) = 0x1FFFF;
          if ((int)(v28 << 16) >= 1)
          {
            uint64_t v32 = (unsigned __int16)v28 + 1;
            while (1)
            {
              if (*(_DWORD *)&v24[16 * (v32 - 2)] == *(_DWORD *)&v24[16 * (unsigned __int16)v28])
              {
                BOOL v33 = &v24[16 * (v32 - 2)];
                int v35 = *((__int16 *)v33 + 5);
                unsigned int v34 = v33 + 10;
                if (v35 == -1) {
                  break;
                }
              }
              if ((unint64_t)--v32 <= 1) {
                goto LABEL_26;
              }
            }
            *unsigned int v34 = v28;
            *(_WORD *)&v24[16 * (unsigned __int16)v28 + 10] = v32 - 2;
          }
LABEL_26:
          uint64_t v37 = (int)v28 + 1;
          if (v37 == v30)
          {
            int v38 = v29 + 0x4000;
            int v39 = (char *)ScalerNewBlock(a1, v29 + 0x4000, -1, v24, 0, 0, 0);
            int v25 = (__int16)v168;
            __int16 v23 = v168;
            unsigned int v24 = v39;
            int v29 = v38;
            uint64_t v30 = (v38 >> 4);
          }
          int v40 = v27;
          int v41 = (__int16)(v27 + 1);
          if (v25 <= v41) {
            ++v27;
          }
          else {
            unsigned __int16 v27 = v25;
          }
          int v42 = v41 - 1;
          while (1)
          {
            unsigned int v43 = 0x80000000 >> v40;
            if (v25 <= v40 || (bswap32(*(_DWORD *)(a3 + 4 * (v40 >> 5))) & v43) == 0) {
              break;
            }
            ++v40;
            ++v42;
            if ((__int16)v40 >= v23)
            {
              __int16 v44 = 0;
              int v40 = v42;
              goto LABEL_37;
            }
          }
          __int16 v44 = (bswap32(*(_DWORD *)(a3 + 4 * ((unsigned __int16)v40 >> 5))) & v43) != 0;
          unsigned __int16 v27 = v40;
LABEL_37:
          int v45 = &v24[16 * v37];
          *((_WORD *)v45 + 7) = v44;
          *(_DWORD *)int v45 = v40;
          *((_DWORD *)v45 + 1) = v161;
          *((_WORD *)v45 + 4) = v28;
          *(_DWORD *)(v45 + 10) = 0x1FFFF;
          if ((int)(v37 << 16) >= 1)
          {
            uint64_t v46 = (unsigned __int16)(v28 + 1);
            uint64_t v47 = v46 + 1;
            while (1)
            {
              if (*(_DWORD *)&v24[16 * (v47 - 2)] == *(_DWORD *)&v24[16 * (unsigned __int16)(v28 + 1)])
              {
                float64x2_t v48 = &v24[16 * (v47 - 2)];
                int v50 = *((__int16 *)v48 + 5);
                uint64_t v49 = v48 + 10;
                if (v50 == -1) {
                  break;
                }
              }
              if ((unint64_t)--v47 <= 1) {
                goto LABEL_44;
              }
            }
            *uint64_t v49 = v37;
            *(_WORD *)&v24[16 * v46 + 10] = v47 - 2;
          }
LABEL_44:
          if (v28 + 2 == v30)
          {
            int v51 = v29 + 0x4000;
            int v52 = (char *)ScalerNewBlock(a1, v29 + 0x4000, -1, v24, 0, 0, 0);
            int v25 = (__int16)v168;
            __int16 v23 = v168;
            unsigned int v24 = v52;
            int v29 = v51;
            uint64_t v36 = (v51 >> 4);
          }
          else
          {
            uint64_t v36 = v30;
            uint64_t v30 = (v28 + 2);
          }
        }
        uint64_t v28 = v30;
        int v26 = (__int16)++v27;
        uint64_t v30 = v36;
      }
      while (v25 >= (__int16)v27);
    }
    int v159 = (__int16)v19;
    if (v19 << 16 <= 0x10000)
    {
      uint64_t v64 = v36;
    }
    else
    {
      uint64_t v158 = v17 >> 2;
      int v55 = 1;
      int v56 = 1;
      do
      {
        int v162 = v56;
        a3 = v21 + 4 * v158;
        if (v160 < 0)
        {
          uint64_t v64 = v36;
        }
        else
        {
          int v57 = 0;
          LOWORD(v58) = 0;
          int v59 = v161 - v55;
          int v167 = v161 - v55;
          uint64_t v166 = v21 + 4 * v158;
          do
          {
            if ((v58 & 0x8000) != 0
              || v25 <= (__int16)v58
              || (uint64_t v60 = (unsigned __int16)v58 >> 5,
                  unsigned int v61 = 0x80000000 >> v58,
                  unsigned int v62 = bswap32(*(_DWORD *)(v21 + 4 * v60)) & (0x80000000 >> v58),
                  unsigned int v63 = bswap32(*(_DWORD *)(a3 + 4 * v60)) & (0x80000000 >> v58),
                  (v62 == 0) ^ (v63 != 0)))
            {
              uint64_t v64 = v36;
              uint64_t v36 = v28;
            }
            else
            {
              long long v65 = &v24[16 * (int)v28];
              *((_WORD *)v65 + 7) = v63 != 0;
              *(_DWORD *)long long v65 = v57;
              *((_DWORD *)v65 + 1) = v59;
              int v66 = v28 + 1;
              *((_WORD *)v65 + 4) = v28 + 1;
              *(_DWORD *)(v65 + 10) = 0x1FFFF;
              if ((int)(v28 << 16) >= 1)
              {
                uint64_t v67 = (unsigned __int16)v28 + 1;
                while (1)
                {
                  if (*(_DWORD *)&v24[16 * (v67 - 2)] == *(_DWORD *)&v24[16 * (unsigned __int16)v28])
                  {
                    uint64_t v68 = &v24[16 * (v67 - 2)];
                    int v70 = *((__int16 *)v68 + 5);
                    int16x4_t v69 = v68 + 10;
                    if (v70 == -1) {
                      break;
                    }
                  }
                  if ((unint64_t)--v67 <= 1) {
                    goto LABEL_66;
                  }
                }
                *int16x4_t v69 = v28;
                *(_WORD *)&v24[16 * (unsigned __int16)v28 + 10] = v67 - 2;
              }
LABEL_66:
              if (v66 == v36)
              {
                int v71 = v29 + 0x4000;
                double v72 = (char *)ScalerNewBlock(a1, v29 + 0x4000, -1, v24, 0, 0, 0);
                int v59 = v167;
                int v25 = (__int16)v168;
                __int16 v23 = v168;
                unsigned int v24 = v72;
                int v29 = v71;
                uint64_t v36 = (v71 >> 4);
                unsigned int v62 = bswap32(*(_DWORD *)(v21 + 4 * v60)) & v61;
                unsigned int v63 = bswap32(*(_DWORD *)(a3 + 4 * v60)) & v61;
              }
              int v73 = (unsigned __int16)v58;
              int v74 = v62 != 0;
              int v75 = v63 != 0;
              if (v25 > (unsigned __int16)v58 && v74 != v75)
              {
                int v58 = (unsigned __int16)v58;
                while (1)
                {
                  int v73 = (__int16)++v58;
                  if ((__int16)v58 >= v23)
                  {
                    __int16 v99 = 0;
                    LOWORD(v58) = v23;
                    goto LABEL_101;
                  }
                  uint64_t v60 = v58 >> 5;
                  unsigned int v61 = 0x80000000 >> v58;
                  int v76 = (bswap32(*(_DWORD *)(v21 + 4 * v60)) & (0x80000000 >> v58)) != 0;
                  int v77 = (bswap32(*(_DWORD *)(a3 + 4 * v60)) & (0x80000000 >> v58)) != 0;
                  if ((v74 & 1) != v76 && v76 != v77)
                  {
                    uint64_t v79 = &v24[16 * v66];
                    *((_WORD *)v79 + 7) = v77;
                    *(_DWORD *)uint64_t v79 = v58;
                    *((_DWORD *)v79 + 1) = v59;
                    *((_WORD *)v79 + 4) = v66 - 1;
                    *(_DWORD *)(v79 + 10) = 0x1FFFF;
                    if (v66 << 16 >= 1)
                    {
                      uint64_t v80 = (unsigned __int16)v66 + 1;
                      while (1)
                      {
                        if (*(_DWORD *)&v24[16 * (v80 - 2)] == *(_DWORD *)&v24[16 * (unsigned __int16)v66])
                        {
                          int v81 = &v24[16 * (v80 - 2)];
                          int v83 = *((__int16 *)v81 + 5);
                          long long v82 = v81 + 10;
                          if (v83 == -1) {
                            break;
                          }
                        }
                        if ((unint64_t)--v80 <= 1) {
                          goto LABEL_83;
                        }
                      }
                      *long long v82 = v66;
                      *(_WORD *)&v24[16 * (unsigned __int16)v66 + 10] = v80 - 2;
                    }
LABEL_83:
                    uint64_t v84 = v21;
                    uint64_t v85 = v66 + 1;
                    if (v85 == v36)
                    {
                      int v86 = v29 + 0x4000;
                      uint64_t v87 = (char *)ScalerNewBlock(a1, v29 + 0x4000, -1, v24, 0, 0, 0);
                      int v59 = v167;
                      unsigned int v24 = v87;
                      int v29 = v86;
                      uint64_t v88 = (v86 >> 4);
                    }
                    else
                    {
                      uint64_t v88 = v36;
                    }
                    uint64_t v89 = &v24[16 * v85];
                    *((_WORD *)v89 + 7) = v77;
                    *(_DWORD *)uint64_t v89 = v58;
                    *((_DWORD *)v89 + 1) = v59;
                    *((_WORD *)v89 + 4) = v66 + 2;
                    *(_DWORD *)(v89 + 10) = 0x1FFFF;
                    if ((int)(v85 << 16) >= 1)
                    {
                      uint64_t v90 = (unsigned __int16)(v66 + 1);
                      uint64_t v91 = v90 + 1;
                      while (1)
                      {
                        if (*(_DWORD *)&v24[16 * (v91 - 2)] == *(_DWORD *)&v24[16
                                                                                            * (unsigned __int16)(v66 + 1)])
                        {
                          unint64_t v92 = &v24[16 * (v91 - 2)];
                          int v94 = *((__int16 *)v92 + 5);
                          int v93 = v92 + 10;
                          if (v94 == -1) {
                            break;
                          }
                        }
                        if ((unint64_t)--v91 <= 1) {
                          goto LABEL_93;
                        }
                      }
                      *int v93 = v85;
                      *(_WORD *)&v24[16 * v90 + 10] = v91 - 2;
                    }
LABEL_93:
                    v66 += 2;
                    if (v66 == v88)
                    {
                      int v95 = v29 + 0x4000;
                      unint64_t v96 = (char *)ScalerNewBlock(a1, v29 + 0x4000, -1, v24, 0, 0, 0);
                      int v59 = v167;
                      unsigned int v24 = v96;
                      int v29 = v95;
                      uint64_t v36 = (v95 >> 4);
                      int v66 = v88;
                    }
                    else
                    {
                      uint64_t v36 = v88;
                    }
                    int v25 = (__int16)v168;
                    __int16 v23 = v168;
                    uint64_t v21 = v84;
                    a3 = v166;
                  }
                  LOBYTE(v74) = (bswap32(*(_DWORD *)(v21 + 4 * v60)) & v61) != 0;
                  BOOL v97 = (bswap32(*(_DWORD *)(a3 + 4 * v60)) & v61) != 0;
                  if (v25 <= v58) {
                    break;
                  }
                  char v98 = v74 ^ v97;
                  int v73 = v58;
                  if ((v98 & 1) == 0) {
                    goto LABEL_99;
                  }
                }
                int v73 = v58;
              }
LABEL_99:
              __int16 v99 = (bswap32(*(_DWORD *)(a3 + 4 * (v60 & 0x7FF))) & v61) != 0;
LABEL_101:
              long long v100 = &v24[16 * v66];
              *((_WORD *)v100 + 7) = v99;
              *(_DWORD *)long long v100 = v73;
              *((_DWORD *)v100 + 1) = v59;
              *((_WORD *)v100 + 4) = v66 - 1;
              *(_DWORD *)(v100 + 10) = 0x1FFFF;
              if (v66 << 16 >= 1)
              {
                uint64_t v101 = (unsigned __int16)v66 + 1;
                while (1)
                {
                  if (*(_DWORD *)&v24[16 * (v101 - 2)] == *(_DWORD *)&v24[16 * (unsigned __int16)v66])
                  {
                    signed int v102 = &v24[16 * (v101 - 2)];
                    int v104 = *((__int16 *)v102 + 5);
                    uint64_t v103 = v102 + 10;
                    if (v104 == -1) {
                      break;
                    }
                  }
                  if ((unint64_t)--v101 <= 1) {
                    goto LABEL_108;
                  }
                }
                *uint64_t v103 = v66;
                *(_WORD *)&v24[16 * (unsigned __int16)v66 + 10] = v101 - 2;
              }
LABEL_108:
              if (v66 + 1 == v36)
              {
                int v105 = v29 + 0x4000;
                uint64_t v106 = (char *)ScalerNewBlock(a1, v29 + 0x4000, -1, v24, 0, 0, 0);
                int v59 = v167;
                int v25 = (__int16)v168;
                __int16 v23 = v168;
                unsigned int v24 = v106;
                int v29 = v105;
                uint64_t v64 = (v105 >> 4);
              }
              else
              {
                uint64_t v64 = v36;
                uint64_t v36 = (v66 + 1);
              }
            }
            uint64_t v28 = v36;
            LOWORD(v58) = v58 + 1;
            int v57 = (__int16)v58;
            uint64_t v36 = v64;
          }
          while (v25 >= (__int16)v58);
        }
        int v56 = v162 + 1;
        int v55 = (__int16)(v162 + 1);
        uint64_t v21 = a3;
        uint64_t v36 = v64;
      }
      while (v159 > v55);
    }
    if (v160 < 0)
    {
      LOWORD(v110) = v28;
    }
    else
    {
      int v107 = 0;
      unsigned __int16 v108 = 0;
      int v109 = v161 - v159;
      uint64_t v110 = v28;
      do
      {
        if ((v108 & 0x8000) != 0
          || v25 <= (__int16)v108
          || ((bswap32(*(_DWORD *)(a3 + 4 * (v108 >> 5))) << v108) & 0x80000000) == 0)
        {
          uint64_t v116 = v64;
          uint64_t v64 = v110;
        }
        else
        {
          long long v111 = &v24[16 * (int)v110];
          *((_WORD *)v111 + 7) = 1;
          *(_DWORD *)long long v111 = v107;
          *((_DWORD *)v111 + 1) = v109;
          *((_WORD *)v111 + 4) = v110 + 1;
          *(_DWORD *)(v111 + 10) = 0x1FFFF;
          if ((int)(v110 << 16) >= 1)
          {
            uint64_t v112 = (unsigned __int16)v110 + 1;
            while (1)
            {
              if (*(_DWORD *)&v24[16 * (v112 - 2)] == *(_DWORD *)&v24[16 * (unsigned __int16)v110])
              {
                uint64_t v113 = &v24[16 * (v112 - 2)];
                int v115 = *((__int16 *)v113 + 5);
                uint64_t v114 = v113 + 10;
                if (v115 == -1) {
                  break;
                }
              }
              if ((unint64_t)--v112 <= 1) {
                goto LABEL_131;
              }
            }
            *uint64_t v114 = v110;
            *(_WORD *)&v24[16 * (unsigned __int16)v110 + 10] = v112 - 2;
          }
LABEL_131:
          uint64_t v117 = (int)v110 + 1;
          if (v117 == v64)
          {
            int v118 = v29 + 0x4000;
            long long v119 = (char *)ScalerNewBlock(a1, v29 + 0x4000, -1, v24, 0, 0, 0);
            int v25 = (__int16)v168;
            __int16 v23 = v168;
            unsigned int v24 = v119;
            int v29 = v118;
            uint64_t v64 = (v118 >> 4);
          }
          int v120 = v108;
          int v121 = (__int16)(v108 + 1);
          if (v25 <= v121) {
            ++v108;
          }
          else {
            unsigned __int16 v108 = v25;
          }
          int v122 = v121 - 1;
          while (1)
          {
            unsigned int v123 = 0x80000000 >> v120;
            if (v25 <= v120 || (bswap32(*(_DWORD *)(a3 + 4 * (v120 >> 5))) & v123) == 0) {
              break;
            }
            ++v120;
            ++v122;
            if ((__int16)v120 >= v23)
            {
              __int16 v124 = 0;
              int v120 = v122;
              goto LABEL_142;
            }
          }
          __int16 v124 = (bswap32(*(_DWORD *)(a3 + 4 * ((unsigned __int16)v120 >> 5))) & v123) != 0;
          unsigned __int16 v108 = v120;
LABEL_142:
          long long v125 = &v24[16 * v117];
          *((_WORD *)v125 + 7) = v124;
          *(_DWORD *)long long v125 = v120;
          *((_DWORD *)v125 + 1) = v109;
          *((_WORD *)v125 + 4) = v110;
          *(_DWORD *)(v125 + 10) = 0x1FFFF;
          if ((int)(v117 << 16) >= 1)
          {
            uint64_t v126 = (unsigned __int16)(v110 + 1);
            uint64_t v127 = v126 + 1;
            while (1)
            {
              if (*(_DWORD *)&v24[16 * (v127 - 2)] == *(_DWORD *)&v24[16 * (unsigned __int16)(v110 + 1)])
              {
                __int16 v128 = &v24[16 * (v127 - 2)];
                int v130 = *((__int16 *)v128 + 5);
                unsigned __int16 v129 = v128 + 10;
                if (v130 == -1) {
                  break;
                }
              }
              if ((unint64_t)--v127 <= 1) {
                goto LABEL_149;
              }
            }
            *unsigned __int16 v129 = v117;
            *(_WORD *)&v24[16 * v126 + 10] = v127 - 2;
          }
LABEL_149:
          if (v110 + 2 == v64)
          {
            int v131 = v29 + 0x4000;
            int v132 = (char *)ScalerNewBlock(a1, v29 + 0x4000, -1, v24, 0, 0, 0);
            int v25 = (__int16)v168;
            __int16 v23 = v168;
            unsigned int v24 = v132;
            int v29 = v131;
            uint64_t v116 = (v131 >> 4);
          }
          else
          {
            uint64_t v116 = v64;
            uint64_t v64 = (v110 + 2);
          }
        }
        uint64_t v110 = v64;
        int v107 = (__int16)++v108;
        uint64_t v64 = v116;
      }
      while (v25 >= (__int16)v108);
    }
    int v133 = (__int16)v110;
    int v134 = CountPointsInContour((uint64_t)v24, 2u, (__int16)v110, &v171);
    int v135 = 0;
    signed int v136 = 28;
    if (v134)
    {
      int v137 = a9;
      do
      {
        ++v135;
        int v138 = v134 + 31;
        if (v134 < -31) {
          int v138 = v134 + 62;
        }
        v136 += 8 * v134 + 4 * (v138 >> 5) + 4;
        int v134 = CountPointsInContour((uint64_t)v24, 2u, (__int16)v110, &v171);
      }
      while (v134);
    }
    else
    {
      int v137 = a9;
    }
    long long v139 = ScalerNewBlock(a1, v136, v137, 0, 0, 1, 0);
    long long v140 = v139;
    *(_DWORD *)long long v139 = v135 + 1;
    *(void *)((char *)v139 + 4) = 2;
    *(int32x2_t *)&long long v141 = v170;
    *((int32x2_t *)&v141 + 1) = v170;
    *(_OWORD *)((char *)v139 + 12) = v141;
    if ((_WORD)v135)
    {
      long long v142 = (int *)v139 + 7;
      do
      {
        int v143 = CountPointsInContour((uint64_t)v24, 3u, v133, &v171);
        int v144 = v143;
        uint64_t v145 = v171;
        *v142++ = v143;
        int v146 = v143 + 62;
        if (v143 >= -31) {
          int v146 = v143 + 31;
        }
        if (v143 >= 1)
        {
          int v147 = 0;
          int v148 = v146 >> 5;
          do
          {
            *v142++ = 0;
            ++v147;
          }
          while (v148 > (__int16)v147);
        }
        if (v143)
        {
          __int16 v149 = v145;
          char v150 = *(unsigned __int16 *)&v24[16 * v145 + 14] == 0;
          do
          {
            id v151 = v142;
            char v152 = (int32x2_t *)&v24[16 * v149];
            *char v152 = vshl_n_s32(*v152, 0x10uLL);
            M3x3Mul(a6, v163, v152, (const int *)1);
            if (v165) {
              v152->i32[1] = -v152->i32[1];
            }
            *long long v142 = v152->i32[0];
            long long v153 = &v24[16 * v149];
            v142[1] = *((_DWORD *)v153 + 1);
            *((_WORD *)v153 + 6) = 0;
            int v154 = *((__int16 *)v153 + 5);
            if (v154 < 0 || (int v155 = *((__int16 *)v153 + 4), v155 < 0))
            {
              exception = __cxa_allocate_exception(2uLL);
              _WORD *exception = 5;
              __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
            }
            if (v150) {
              __int16 v149 = v154;
            }
            else {
              __int16 v149 = v155;
            }
            v150 ^= 1u;
            v142 += 2;
            --v144;
          }
          while (v144);
          long long v142 = v151 + 2;
        }
        --v135;
      }
      while ((_WORD)v135);
    }
    void *v157 = v140;
    ScalerDisposeBlock(a1, v24, -1);
  }
}

uint64_t CountPointsInContour(uint64_t a1, unsigned __int16 a2, int a3, __int16 *a4)
{
  unint64_t v4 = (__int16 *)(a1 + 12);
  uint64_t v5 = -1;
  do
  {
    ++v5;
    int v7 = *v4;
    v4 += 8;
    int v6 = v7;
    if (v7) {
      BOOL v8 = v6 == a2;
    }
    else {
      BOOL v8 = 1;
    }
    char v9 = v8;
  }
  while (v5 < a3 && (v9 & 1) != 0);
  if (v5 >= a3) {
    return 0;
  }
  int v10 = 0;
  __int16 v11 = 0;
  *a4 = v5;
  do
  {
    uint64_t v12 = a1 + 16 * (__int16)v5;
    *(_WORD *)(v12 + 12) = a2;
    int v13 = *(__int16 *)(v12 + 10);
    if (v13 < 0 || (LODWORD(v5) = *(__int16 *)(a1 + 16 * (__int16)v5 + 8), (v5 & 0x80000000) != 0))
    {
      exception = __cxa_allocate_exception(2uLL);
      _WORD *exception = 5;
      __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
    }
    ++v11;
    if (v10) {
      LOWORD(v5) = v13;
    }
    v10 ^= 1u;
  }
  while (*a4 != (unsigned __int16)v5);
  return v11;
}

uint64_t ComputeRenderingSpecs(uint64_t result, uint64_t a2, int a3, int a4, int *a5)
{
  if (a3)
  {
    int v7 = (int *)(*(void *)(result + 24) + 96);
    int v8 = M3x3Flags(v7);
    long long v23 = xmmword_1B5392C80;
    long long v24 = xmmword_1B5392C90;
    uint64_t result = M3x3Mul(v7, v8, (int32x2_t *)&v23, (const int *)4);
    int v9 = v23;
    int v10 = DWORD1(v23);
    if (SDWORD1(v23) >= SDWORD1(v24)) {
      int v11 = DWORD1(v24);
    }
    else {
      int v11 = DWORD1(v23);
    }
    if (SDWORD1(v23) <= SDWORD1(v24)) {
      int v10 = DWORD1(v24);
    }
    if ((int)v23 >= (int)v24) {
      int v12 = v24;
    }
    else {
      int v12 = v23;
    }
    if ((int)v23 <= (int)v24) {
      int v9 = v24;
    }
    if (SDWORD2(v24) < v12) {
      int v12 = DWORD2(v24);
    }
    if (SDWORD2(v23) < v12) {
      int v12 = DWORD2(v23);
    }
    if (SHIDWORD(v24) < v11) {
      int v11 = HIDWORD(v24);
    }
    if (SHIDWORD(v23) < v11) {
      int v11 = HIDWORD(v23);
    }
    if (SDWORD2(v24) > v9) {
      int v9 = DWORD2(v24);
    }
    if (SDWORD2(v23) > v9) {
      int v9 = DWORD2(v23);
    }
    if (SHIDWORD(v24) > v10) {
      int v10 = HIDWORD(v24);
    }
    if (SHIDWORD(v23) > v10) {
      int v10 = HIDWORD(v23);
    }
    int v13 = v9 - v12;
    int v14 = v10 - v11 + 0x8000;
    int v15 = (v13 + 0x8000) >> 16;
    unsigned int v16 = ((v15 + 31) >> 3) & 0x1FFFFFFC;
    int v18 = v15 + 7;
    BOOL v17 = v15 < -7;
    int v19 = v15 + 14;
    if (!v17) {
      int v19 = v18;
    }
    int v20 = v19 >> 3;
    if (v13 < 1081344) {
      __int16 v21 = v20;
    }
    else {
      __int16 v21 = v16;
    }
    if (a4) {
      __int16 v21 = (v18 >> 1) & 0xFFFC;
    }
    int v22 = v21 * (v14 >> 16);
  }
  else
  {
    int v22 = 4 * *(_DWORD *)(*(void *)(result + 8) + 28)
        + 8 * *(_DWORD *)(*(void *)(result + 8) + 32)
        + 4 * ((*(_DWORD *)(*(void *)(result + 8) + 32) + 31) >> 5)
        + 4;
  }
  *a5 = v22;
  a5[1] = 0;
  return result;
}

uint64_t TType1SFNTFont::GetFontDataTableTag(TType1SFNTFont *this)
{
  return 1415139377;
}

void TType1Exception::~TType1Exception(TType1Exception *this)
{
}

void CreateGlyphElement(uint64_t a1, int a2, unsigned int a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 40);
  if (a3)
  {
    uint64_t v10 = *(void *)(a1 + 24);
    uint64_t v11 = *(unsigned __int16 *)(v8 + 52);
    *(_DWORD *)(v9 + 56) = 1;
    *(_DWORD *)(v9 + 60) = v11;
    uint64_t v12 = *(void *)(v10 + 48);
    uint64_t v13 = v12 + 4 * v11;
    *(void *)(v9 + 64) = v12;
    *(void *)(v9 + 72) = v13;
    uint64_t v14 = v13 + 4 * v11;
    *(void *)(v9 + 80) = v14;
    *(void *)(v9 + 88) = v14 + 2;
    uint64_t v15 = v14 + 4;
    uint64_t v16 = v14 + 4 + v11;
    *(void *)(v9 + 96) = v15;
    *(void *)(v9 + 104) = v16;
    *(_DWORD *)(v9 + 164) = 1;
    *(_DWORD *)(v9 + 168) = v11;
    if (v12)
    {
      uint64_t v17 = v16 + v11;
      uint64_t v18 = v17 + 4 * v11;
      uint64_t v19 = v18 + 4 * v11;
      uint64_t v20 = v19 + 2 * v11;
      uint64_t v21 = v20 + 2 * v11;
    }
    else
    {
      uint64_t v17 = 1358921729;
      uint64_t v18 = 1358921729;
      uint64_t v19 = 1358921729;
      uint64_t v20 = 1358921729;
      uint64_t v21 = 1358921729;
    }
    *(void *)(v9 + 112) = v17;
    *(void *)(v9 + 120) = v18;
    *(void *)(v9 + 128) = v19;
    *(void *)(v9 + 136) = v20;
    *(void *)(v9 + 176) = v21;
    *(void *)(v10 + 248) = gInstructionJumpTable;
    *(_OWORD *)(v10 + 256) = *(_OWORD *)(a1 + 48);
    uint64_t v22 = *(void *)(v10 + 16);
    *(void *)(v10 + 224) = *(void *)(v10 + 32);
    *(void *)(v10 + 232) = v22;
    *(void *)(v10 + 240) = *(void *)(*(void *)(a1 + 16) + 16);
    if (*(_DWORD *)(v8 + 120) && !*(unsigned char *)(v8 + 154))
    {
      RunFontProgram((uint64_t *)a1, 0);
      *(unsigned char *)(v8 + 154) = 1;
    }
    if (*(_WORD *)(v8 + 150) && !*(unsigned char *)(v10 + 487))
    {
      PrepareTheCVT(a1, (int)((double)*(int *)(v10 + 288) * 64.0 / (double)*(__int16 *)(v8 + 130)));
      *(unsigned char *)(v10 + 487) = 1;
    }
    if (*(_DWORD *)(v8 + 124) && !*(unsigned char *)(v10 + 486))
    {
      RunPreProgram((uint64_t *)a1, v10 + 96, 0);
      *(unsigned char *)(v10 + 486) = 1;
    }
  }
  if (a4)
  {
    if (*(unsigned __int16 *)(v8 + 40) <= a2) {
      unsigned __int16 v23 = 0;
    }
    else {
      unsigned __int16 v23 = a2;
    }
    CreateGlyphOutline((uint64_t *)a1, v23, a3);
  }
  *(void *)(v9 + 256) = 1358921729;
  *(void *)(v9 + 264) = 1358921729;
  *(void *)(v9 + 240) = 1358921729;
  *(void *)(v9 + 248) = 1358921729;
  *(void *)(v9 + 232) = 1358921729;
}

uint64_t SetupGlyphElementPointers(uint64_t result, uint64_t a2, _DWORD *a3)
{
  if (!*(unsigned char *)(a2 + 128)) {
    return sbit_IsThereAGlyphImage(result, (int *)(a2 + 120));
  }
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(v3 + 184) = *(void *)(a2 + 16);
  *(void *)(v3 + 276) = *(void *)(a2 + 24);
  *(_DWORD *)(v3 + 284) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(v3 + 288) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(v3 + 272) = *a3;
  uint64_t v4 = *(void *)(result + 8);
  uint64_t v6 = *(int *)(v4 + 28);
  uint64_t v5 = *(int *)(v4 + 32);
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v8 = v7 + 4 * v5;
  *(void *)(v3 + 192) = v7;
  *(void *)(v3 + 200) = v8;
  uint64_t v9 = v8 + 4 * v5;
  uint64_t v10 = v9 + 2 * v6;
  *(void *)(v3 + 208) = v9;
  *(void *)(v3 + 216) = v10;
  uint64_t v11 = v10 + 2 * v6;
  *(void *)(v3 + 224) = v11;
  *(void *)(v3 + 232) = v11 + v5;
  *(_DWORD *)(v3 + 292) = v6;
  *(_DWORD *)(v3 + 296) = v5;
  *(void *)(v3 + 240) = 1358921729;
  *(void *)(v3 + 248) = 1358921729;
  *(void *)(v3 + 256) = 1358921729;
  *(void *)(v3 + 264) = 1358921729;
  *(void *)(v3 + 304) = 1358921729;
  return result;
}

void *CreateScalerGlyphBlock(uint64_t a1, memoryContext *a2, int *a3)
{
  if (*(unsigned char *)(*(void *)(a1 + 24) + 490) && !*(unsigned char *)(a1 + 66))
  {
    uint64_t v6 = ScalerNewBlock(a2, 136, 4, 0, 0, 1, 0);
    *((_DWORD *)v6 + 30) = *a3;
    if (sbit_IsThereAGlyphImage(a1, (int *)v6 + 30))
    {
      char v22 = 0;
    }
    else
    {
      uint64_t v6 = ScalerNewBlock(a2, *(_DWORD *)(*(void *)(a1 + 8) + 24) + 136, 4, v6, 0, 1, 0);
      v6[1] = v6 + 17;
      uint64_t v24 = *(void *)(a1 + 40);
      *(_DWORD *)(v24 + 184) = 0;
      *(_DWORD *)(v24 + 188) = 0;
      uint64_t v25 = *(void *)(a1 + 8);
      uint64_t v27 = *(int *)(v25 + 28);
      uint64_t v26 = *(int *)(v25 + 32);
      uint64_t v28 = *(void *)(v24 + 48);
      uint64_t v29 = (uint64_t)v6 + 4 * v26 + 136;
      *(void *)(v24 + 192) = v6 + 17;
      *(void *)(v24 + 200) = v29;
      uint64_t v30 = v29 + 4 * v26;
      uint64_t v31 = v30 + 2 * v27;
      *(void *)(v24 + 208) = v30;
      *(void *)(v24 + 216) = v31;
      uint64_t v32 = v31 + 2 * v27;
      *(void *)(v24 + 224) = v32;
      *(void *)(v24 + 232) = v32 + v26;
      *(_DWORD *)(v24 + 292) = v27;
      *(_DWORD *)(v24 + 296) = v26;
      uint64_t v33 = 1358921729;
      uint64_t v34 = v28 + 4 * v26;
      uint64_t v35 = v34 + 4 * v26;
      uint64_t v36 = v35 + 2 * v26;
      uint64_t v37 = v36 + 2 * v26;
      if (v28)
      {
        uint64_t v33 = v37;
      }
      else
      {
        uint64_t v28 = 1358921729;
        uint64_t v34 = 1358921729;
        uint64_t v35 = 1358921729;
        uint64_t v36 = 1358921729;
      }
      *(void *)(v24 + 240) = v28;
      *(void *)(v24 + 248) = v34;
      *(void *)(v24 + 256) = v35;
      *(void *)(v24 + 264) = v36;
      *(void *)(v24 + 304) = v33;
      char v22 = 1;
      CreateGlyphElement(a1, *a3, *(unsigned __int8 *)(*(void *)(a1 + 24) + 484), 1);
      v6[2] = *(void *)(v24 + 184);
      v6[3] = *(void *)(v24 + 276);
      *((_DWORD *)v6 + 8) = *(_DWORD *)(v24 + 284);
      *((_DWORD *)v6 + 9) = *(_DWORD *)(v24 + 288);
      *((_DWORD *)v6 + 10) = *(_DWORD *)(*(void *)(a1 + 24) + 412);
      CalculateFractionalBounds(v6, (unsigned int *)(v24 + 184));
    }
  }
  else
  {
    uint64_t v6 = ScalerNewBlock(a2, *(_DWORD *)(*(void *)(a1 + 8) + 24) + 136, 4, 0, 0, 1, 0);
    *(_DWORD *)uint64_t v6 = 1735162214;
    v6[1] = v6 + 17;
    uint64_t v7 = *(void *)(a1 + 40);
    *(_DWORD *)(v7 + 184) = 0;
    *(_DWORD *)(v7 + 188) = 0;
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v10 = *(int *)(v8 + 28);
    uint64_t v9 = *(int *)(v8 + 32);
    uint64_t v11 = *(void *)(v7 + 48);
    uint64_t v12 = (uint64_t)v6 + 4 * v9 + 136;
    *(void *)(v7 + 192) = v6 + 17;
    *(void *)(v7 + 200) = v12;
    uint64_t v13 = v12 + 4 * v9;
    uint64_t v14 = v13 + 2 * v10;
    *(void *)(v7 + 208) = v13;
    *(void *)(v7 + 216) = v14;
    uint64_t v15 = v14 + 2 * v10;
    *(void *)(v7 + 224) = v15;
    *(void *)(v7 + 232) = v15 + v9;
    *(_DWORD *)(v7 + 292) = v10;
    *(_DWORD *)(v7 + 296) = v9;
    uint64_t v16 = 1358921729;
    uint64_t v17 = v11 + 4 * v9;
    uint64_t v18 = v17 + 4 * v9;
    uint64_t v19 = v18 + 2 * v9;
    uint64_t v20 = v19 + 2 * v9;
    if (v11)
    {
      uint64_t v16 = v20;
    }
    else
    {
      uint64_t v11 = 1358921729;
      uint64_t v17 = 1358921729;
      uint64_t v18 = 1358921729;
      uint64_t v19 = 1358921729;
    }
    *(void *)(v7 + 240) = v11;
    *(void *)(v7 + 248) = v17;
    *(void *)(v7 + 256) = v18;
    *(void *)(v7 + 264) = v19;
    *(void *)(v7 + 304) = v16;
    CreateGlyphElement(a1, *a3, *(unsigned __int8 *)(*(void *)(a1 + 24) + 484), 1);
    v6[2] = *(void *)(v7 + 184);
    v6[3] = *(void *)(v7 + 276);
    *((_DWORD *)v6 + 8) = *(_DWORD *)(v7 + 284);
    *((_DWORD *)v6 + 9) = *(_DWORD *)(v7 + 288);
    *((_DWORD *)v6 + 10) = *(_DWORD *)(*(void *)(a1 + 24) + 412);
    uint64_t v21 = *(void *)(a1 + 8);
    if (*(_DWORD *)(v7 + 184) > *(_DWORD *)(v21 + 28) || *(_DWORD *)(v7 + 188) > *(_DWORD *)(v21 + 32))
    {
      exception = __cxa_allocate_exception(2uLL);
      _WORD *exception = 5;
      __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
    }
    CalculateFractionalBounds(v6, (unsigned int *)(v7 + 184));
    char v22 = 1;
  }
  *((unsigned char *)v6 + 128) = v22;
  *(void *)(a1 + 32) = v6;
  v6[1] = v6 + 17;
  return v6;
}

_DWORD *CalculateFractionalBounds(_DWORD *result, unsigned int *a2)
{
  uint64_t v2 = *a2;
  if ((int)v2 <= 0)
  {
    int v18 = 0;
    int v17 = 0;
    result[26] = 0;
    result[28] = 0;
  }
  else
  {
    uint64_t v3 = 0;
    int v4 = 0;
    int v5 = 0;
    uint64_t v7 = *((void *)a2 + 3);
    uint64_t v6 = *((void *)a2 + 4);
    int v8 = 1;
    do
    {
      unsigned int v9 = *(unsigned __int16 *)(v6 + 2 * v3);
      uint64_t v10 = *(unsigned __int16 *)(v7 + 2 * v3);
      int v11 = v9 - v10;
      if (v9 < v10 || (int)a2[28] <= (int)v9)
      {
        exception = __cxa_allocate_exception(2uLL);
        _WORD *exception = 5;
        __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
      }
      if (v10 != v9)
      {
        uint64_t v12 = (int *)(*((void *)a2 + 1) + 4 * v10);
        if (v8)
        {
          int v4 = *v12;
          int v5 = *v12;
        }
        int v8 = v11 + 1;
        do
        {
          int v14 = *v12++;
          int v13 = v14;
          if (v14 >= v5) {
            int v15 = v5;
          }
          else {
            int v15 = v13;
          }
          if (v13 > v4) {
            int v4 = v13;
          }
          else {
            int v5 = v15;
          }
          --v8;
        }
        while (v8);
      }
      ++v3;
    }
    while (v3 != v2);
    uint64_t v16 = 0;
    int v17 = 0;
    int v18 = 0;
    result[26] = v5;
    result[28] = v4;
    int v19 = 1;
    do
    {
      unsigned int v20 = *(unsigned __int16 *)(v6 + 2 * v16);
      uint64_t v21 = *(unsigned __int16 *)(v7 + 2 * v16);
      if (v21 != v20)
      {
        char v22 = (int *)(*((void *)a2 + 2) + 4 * v21);
        if (v19)
        {
          int v18 = *v22;
          int v17 = *v22;
        }
        if (v21 <= v20)
        {
          int v19 = v20 - v21 + 1;
          do
          {
            int v24 = *v22++;
            int v23 = v24;
            if (v24 >= v18) {
              int v25 = v18;
            }
            else {
              int v25 = v23;
            }
            if (v23 > v17) {
              int v17 = v23;
            }
            else {
              int v18 = v25;
            }
            --v19;
          }
          while (v19);
        }
        else
        {
          int v19 = 0;
        }
      }
      ++v16;
    }
    while (v16 != v2);
  }
  result[27] = v18;
  result[29] = v17;
  return result;
}

uint64_t ComputeGlyphBoundsAndMetrics(void *a1, int32x2_t *a2, int32x2_t *a3)
{
  uint64_t v5 = a1[4];
  if (*(unsigned char *)(v5 + 128))
  {
    uint64_t v6 = a1[5];
    int v8 = *(_DWORD *)(v6 + 184);
    uint64_t v7 = v6 + 184;
    if (v8 >= 1 && (*(_DWORD *)(v5 + 104) || *(_DWORD *)(v5 + 112) || *(_DWORD *)(v5 + 108) || *(_DWORD *)(v5 + 116))) {
      CalculateGlyphImageBounds((uint64_t)a1, v7, (uint64_t)a2);
    }
    else {
      bzero(a2, 0x24uLL);
    }
    int v10 = *(unsigned __int8 *)(a1[3] + 484);
    return fs_FindMetrics((uint64_t)a1, v7, a3, v10);
  }
  else
  {
    int v12 = -1431655766;
    v11[0] = 2863311530;
    v11[1] = 0xAAAAAAAA00000000;
    return sbit_GetBitMapInfo(a1, (uint64_t)v11, *(_DWORD *)(v5 + 120), a2, a3, *(unsigned __int8 *)(a1[3] + 484));
  }
}

uint64_t CalculateGlyphImageBounds(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a2 + 4);
  int v7 = *(unsigned __int8 *)(a1 + 64);
  int v8 = *(_DWORD *)(*(void *)(a1 + 32) + 104);
  if (v7) {
    int v9 = 7;
  }
  else {
    int v9 = 31;
  }
  if (v7) {
    int v10 = 56;
  }
  else {
    int v10 = 32;
  }
  *(_DWORD *)(a3 + 16) = (int)CheckedF26Dot6Add(v8, v9) >> 6;
  *(_DWORD *)(a3 + 20) = (int)CheckedF26Dot6Add(*(_DWORD *)(*(void *)(a1 + 32) + 108), v9) >> 6;
  *(_DWORD *)(a3 + 24) = (int)CheckedF26Dot6Add(*(_DWORD *)(*(void *)(a1 + 32) + 112), v10) >> 6;
  uint64_t result = CheckedF26Dot6Add(*(_DWORD *)(*(void *)(a1 + 32) + 116), v10);
  int v12 = (int)result >> 6;
  *(_DWORD *)(a3 + 28) = (int)result >> 6;
  int v13 = *(_DWORD *)(a3 + 16);
  if (*(unsigned char *)(*(void *)(a1 + 24) + 488)) {
    int v14 = v6 + 2;
  }
  else {
    int v14 = v6;
  }
  uint64_t v15 = *(void *)(a2 + 16);
  *(_DWORD *)(a3 + 8) = (v13 << 16) - (*(_DWORD *)(*(void *)(a2 + 8) + 4 * v14) << 10);
  *(_DWORD *)(a3 + 12) = (v12 << 16) - (*(_DWORD *)(v15 + 4 * v14) << 10);
  int v16 = *(_DWORD *)(a3 + 24);
  if (v16 == v13)
  {
    int v16 = v13 + 1;
    *(_DWORD *)(a3 + 24) = v13 + 1;
  }
  if (v12 == *(_DWORD *)(a3 + 20)) {
    *(_DWORD *)(a3 + 28) = v12 + 1;
  }
  unsigned int v17 = ((v16 - v13 + 31) >> 3) & 0xFFFFFFFC;
  if (!v17) {
    unsigned int v17 = 4;
  }
  *(_DWORD *)(a3 + 32) = v17;
  *(void *)a3 = 0;
  return result;
}

uint64_t fs_FindMetrics(uint64_t result, uint64_t a2, int32x2_t *a3, int a4)
{
  if (!a3) {
    return result;
  }
  uint64_t v6 = *(void *)(result + 24);
  uint64_t v7 = *(int *)(a2 + 4);
  if (!*(unsigned char *)(v6 + 488))
  {
    if (a4)
    {
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(a2 + 16);
      int v10 = v7 + 1;
      int v12 = v7 + 4;
      uint64_t v13 = *(unsigned char *)(v6 + 491) & 1;
      int v14 = (int *)a3;
      int v11 = v7;
      goto LABEL_7;
    }
    char v22 = (int *)(v6 + 96);
    a3->i32[0] = vcvtd_n_s64_f64((double)*(__int16 *)(a2 + 100)* 0.0000152587891/ ((double)*(__int16 *)(*(void *)(result + 8) + 130)* 0.0000152587891), 0x10uLL);
    a3->i32[1] = 0;
    int v23 = M3x3Flags((_DWORD *)(v6 + 96));
    uint64_t result = M3x3Mul(v22, v23, a3, (const int *)1);
    uint64_t v24 = *(void *)(a2 + 8);
    uint64_t v25 = *(void *)(a2 + 16);
    a3[1].i32[0] = (*(_DWORD *)(v24 + 4 * ((int)v7 + 4)) - *(_DWORD *)(v24 + 4 * v7)) << 10;
    a3[1].i32[1] = (*(_DWORD *)(v25 + 4 * ((int)v7 + 4)) - *(_DWORD *)(v25 + 4 * v7)) << 10;
    a3[2].i32[0] = (*(_DWORD *)(v24 + 4 * ((int)v7 + 5)) - *(_DWORD *)(v24 + 4 * ((int)v7 + 1))) << 10;
    int v20 = *(_DWORD *)(v25 + 4 * ((int)v7 + 5));
    int v21 = *(_DWORD *)(v25 + 4 * ((int)v7 + 1));
LABEL_12:
    a3[2].i32[1] = (v20 - v21) << 10;
    return result;
  }
  if (!a4)
  {
    uint64_t v15 = (int *)(v6 + 96);
    unsigned int v16 = -vcvtd_n_s64_f64((double)*(__int16 *)(a2 + 104)* 0.0000152587891/ ((double)*(__int16 *)(*(void *)(result + 8) + 130)* 0.0000152587891), 0x10uLL);
    a3->i32[0] = 0;
    a3->i32[1] = v16;
    int v17 = M3x3Flags(v15);
    uint64_t result = M3x3Mul(v15, v17, a3, (const int *)1);
    uint64_t v18 = *(void *)(a2 + 8);
    uint64_t v19 = *(void *)(a2 + 16);
    a3[1].i32[0] = (*(_DWORD *)(v18 + 4 * ((int)v7 + 6)) - *(_DWORD *)(v18 + 4 * ((int)v7 + 2))) << 10;
    a3[1].i32[1] = (*(_DWORD *)(v19 + 4 * ((int)v7 + 6)) - *(_DWORD *)(v19 + 4 * ((int)v7 + 2))) << 10;
    a3[2].i32[0] = (*(_DWORD *)(v18 + 4 * ((int)v7 + 7)) - *(_DWORD *)(v18 + 4 * ((int)v7 + 3))) << 10;
    int v20 = *(_DWORD *)(v19 + 4 * ((int)v7 + 7));
    int v21 = *(_DWORD *)(v19 + 4 * ((int)v7 + 3));
    goto LABEL_12;
  }
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v9 = *(void *)(a2 + 16);
  int v10 = v7 + 3;
  int v11 = v7 + 2;
  int v12 = v7 + 6;
  uint64_t v13 = *(unsigned char *)(v6 + 491) & 1;
  int v14 = (int *)a3;
LABEL_7:
  return fs_SetDeviceMetrics(v13, v14, v8, v9, v10, v11, v12);
}

uint64_t ComputeGlyphFractionalMetrics(void *a1, uint64_t a2, int32x2_t *a3)
{
  uint64_t v3 = a1[4];
  if (*(unsigned char *)(v3 + 128))
  {
    uint64_t v4 = a1[5] + 184;
    return fs_FindMetrics((uint64_t)a1, v4, a3, 0);
  }
  else
  {
    int v10 = -1431655766;
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[0] = v6;
    v9[1] = v6;
    int v8 = -1431655766;
    v7[0] = 2863311530;
    v7[1] = 0xAAAAAAAA00000000;
    return sbit_GetBitMapInfo(a1, (uint64_t)v7, *(_DWORD *)(v3 + 120), (int32x2_t *)v9, a3, 0);
  }
}

void *RenderBitmap(uint64_t a1, memoryContext *a2, _DWORD *a3, uint64_t a4, int a5)
{
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v9 + 128))
  {
    int v11 = *(_DWORD *)(v10 + 184);
    if (!v11) {
      return 0;
    }
    int v12 = *(_DWORD *)(v9 + 104);
    if (!v12 && !*(_DWORD *)(v9 + 112) && !*(_DWORD *)(v9 + 108) && !*(_DWORD *)(v9 + 116)) {
      return 0;
    }
    if (*(unsigned char *)(a1 + 64))
    {
      if (v11 >= 1)
      {
        uint64_t v13 = 0;
        int v14 = (*(unsigned char *)(a1 + 65) != 0) << 7;
        uint64_t v16 = *(void *)(v10 + 208);
        uint64_t v15 = *(void *)(v10 + 216);
        do
        {
          unsigned int v17 = *(unsigned __int16 *)(v15 + 2 * v13);
          uint64_t v18 = *(unsigned __int16 *)(v16 + 2 * v13);
          if (v18 < v17)
          {
            uint64_t v19 = (_DWORD *)(*(void *)(v10 + 200) + 4 * v18);
            int v20 = (_DWORD *)(*(void *)(v10 + 192) + 4 * v18);
            int v21 = v17 - v18 + 1;
            do
            {
              *int v20 = v14 + 4 * *v20;
              ++v20;
              *uint64_t v19 = v14 + 4 * *v19;
              ++v19;
              --v21;
            }
            while (v21);
            int v11 = *(_DWORD *)(v10 + 184);
          }
          ++v13;
        }
        while (v13 < v11);
        int v12 = *(_DWORD *)(v9 + 104);
      }
      int v22 = ((int)CheckedF26Dot6Add(v12, 7) >> 4) & 0xFFFFFFFC;
      int v23 = ((int)CheckedF26Dot6Add(*(_DWORD *)(*(void *)(a1 + 32) + 108), 7) >> 4) & 0xFFFFFFFC;
      int v24 = ((int)CheckedF26Dot6Add(*(_DWORD *)(*(void *)(a1 + 32) + 112), 56) >> 4) & 0xFFFFFFFC;
      int v25 = ((int)CheckedF26Dot6Add(*(_DWORD *)(*(void *)(a1 + 32) + 116), 56) >> 4) & 0xFFFFFFFC;
    }
    else
    {
      int v22 = (int)CheckedF26Dot6Add(v12, 31) >> 6;
      int v23 = (int)CheckedF26Dot6Add(*(_DWORD *)(*(void *)(a1 + 32) + 108), 31) >> 6;
      int v24 = (int)CheckedF26Dot6Add(*(_DWORD *)(*(void *)(a1 + 32) + 112), 32) >> 6;
      int v25 = (int)CheckedF26Dot6Add(*(_DWORD *)(*(void *)(a1 + 32) + 116), 32) >> 6;
    }
    if (v22 >= -32767 && v23 >= -32767 && v24 < 0x8000 && v25 < 0x8000)
    {
      *(_WORD *)(v9 + 92) = v24;
      *(_WORD *)(v9 + 88) = v22;
      *(_WORD *)(v9 + 94) = v25;
      *(_WORD *)(v9 + 90) = v23;
      *(_WORD *)(v9 + 100) = v25 - v23;
      __int16 v31 = (v24 - v22 + 31) & 0xFFE0;
      if (v24 == v22) {
        __int16 v31 = 32;
      }
      *(_WORD *)(v9 + 102) = v31;
      uint64_t v32 = *(void *)(a1 + 32);
      int v33 = fs_dropOutVal(*(_DWORD *)(*(void *)(a1 + 24) + 480), *(unsigned int *)(v32 + 40));
      sc_FindExtrema4(v10 + 184, (__int16 *)(v32 + 48), v33, (memoryContext **)a1);
      int v34 = a3[1];
      int v35 = a3[2];
      BOOL v36 = __OFSUB__(v34, v35);
      int v37 = v34 - v35;
      if ((v37 < 0) ^ v36 | (v37 == 0)) {
        LOWORD(v37) = *(_WORD *)(v32 + 100);
      }
      else {
        LOWORD(v37) = v37 + 1;
      }
      if ((v37 & 0xFFFE) != 0) {
        int v37 = (unsigned __int16)v37;
      }
      else {
        int v37 = 1;
      }
      BOOL v38 = (v37 & 3) != 0 && *(unsigned char *)(a1 + 64) == 1;
      int v39 = ((_WORD)v37 + 3) & 0xFFFC;
      if (!v38) {
        int v39 = v37;
      }
      int v40 = *(_DWORD **)(a1 + 40);
      *int v40 = v39 * (*(unsigned __int16 *)(v32 + 102) >> 3);
      v40[4] = (2 * *(unsigned __int16 *)(v32 + 98) + 12) * v39;
      if (v33) {
        int v41 = (2 * *(unsigned __int16 *)(v32 + 96) + 12) * (*(__int16 *)(v32 + 92) - *(__int16 *)(v32 + 88));
      }
      else {
        int v41 = 0;
      }
      v40[8] = v41;
      *(void *)(v10 + 24) = 0;
      if (*(unsigned char *)(*(void *)(a1 + 32) + 128)) {
        *(void *)(v10 + 24) = ScalerNewScratch(a2, *(_DWORD *)(v10 + 16), 0);
      }
      *(void *)(v10 + 8) = 0;
      if (*(_DWORD *)v10)
      {
        int v42 = *(unsigned char *)(a1 + 64) ? -1 : a5;
        *(void *)(v10 + 8) = ScalerNewBlock(a2, *(_DWORD *)v10, v42, 0, 0, 1, 0);
        if (*(_DWORD *)v10)
        {
          *(void *)(v10 + 40) = 0;
          signed int v43 = *(_DWORD *)(v10 + 32);
          if (v43)
          {
            __int16 v44 = (char *)ScalerNewBlock(a2, v43, -1, 0, 1, 0, 0);
            *(void *)(v10 + 40) = v44;
          }
          else
          {
            __int16 v44 = 0;
          }
          uint64_t v45 = *(void *)(a1 + 32);
          uint64_t v46 = *(void *)(a1 + 40);
          int v47 = *(__int16 *)(v45 + 92);
          int v48 = *(__int16 *)(v45 + 88);
          int v49 = fs_dropOutVal(*(_DWORD *)(*(void *)(a1 + 24) + 480), *(unsigned int *)(v45 + 40));
          int v51 = a3[1];
          signed int v50 = a3[2];
          int v52 = *(__int16 *)(v45 + 94);
          signed int v53 = *(__int16 *)(v45 + 90);
          if (v51 <= v50)
          {
            signed int v50 = *(__int16 *)(v45 + 90);
            int v51 = *(__int16 *)(v45 + 94);
          }
          long long v54 = (void *)(v45 + 48);
          if (v51 >= v52) {
            int v55 = *(__int16 *)(v45 + 94);
          }
          else {
            int v55 = v51;
          }
          if (v50 <= v53) {
            signed int v56 = *(__int16 *)(v45 + 90);
          }
          else {
            signed int v56 = v50;
          }
          unsigned int v57 = v55 - v56;
          if (v55 < v56) {
            goto LABEL_79;
          }
          BOOL v58 = v51 >= v52 && v50 <= v53;
          uint64_t v59 = *(void *)(v46 + 40);
          if (!v58 || v59 == 0) {
            int v61 = 0;
          }
          else {
            int v61 = v49;
          }
          *long long v54 = *(void *)(v46 + 8);
          if (v61)
          {
            unint64_t v62 = (unint64_t)(v47 - v48) << 32;
            *(void *)(v45 + 56) = v59;
            if ((unsigned __int16)v47 == (unsigned __int16)v48) {
              unint64_t v62 = 0x100000000;
            }
            *(void *)(v45 + 72) = v59 + ((uint64_t)((*(unsigned __int16 *)(v45 + 96) + 2) * v62) >> 31);
            unsigned int v57 = v52 - v53;
          }
          if (v57 <= 1) {
            int v63 = 1;
          }
          else {
            int v63 = v57;
          }
          uint64_t v64 = *(void *)(v46 + 24);
          *(void *)(v45 + 64) = v64;
          *(void *)(v45 + 80) = v64 + 2 * (*(unsigned __int16 *)(v45 + 98) + 2) * v63;
          if (!sc_ScanChar2((int *)(v10 + 184), (int *)(v46 + 312), v45 + 48, v56, v55, v61))
          {
            __int16 v44 = *(char **)(v10 + 40);
LABEL_79:
            uint64_t v30 = (void *)*v54;
            if (v44) {
              ScalerDisposeBlock(a2, v44, -1);
            }
            long long v65 = *(char **)(v10 + 24);
            if (v65) {
              ScalerDisposeBlock(a2, v65, -1);
            }
            if (*(unsigned char *)(a1 + 64))
            {
              int v66 = (int)CheckedF26Dot6Add(*(_DWORD *)(*(void *)(a1 + 32) + 116), 56) >> 6;
              int v67 = CheckedF26Dot6Add(*(_DWORD *)(*(void *)(a1 + 32) + 108), 7);
              if (v66 == v67 >> 6) {
                int v68 = 1;
              }
              else {
                int v68 = v66 - (v67 >> 6);
              }
              uint64_t v30 = ScalerNewBlock(a2, v68 * (*(unsigned __int16 *)(*(void *)(a1 + 32) + 102) >> 3), 6, 0, 0, 0, 0);
              int16x4_t v69 = *(char **)(v10 + 8);
              unint64_t v70 = (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 32) + 102) >> 3;
              int v71 = (unsigned int *)v69;
              double v72 = v30;
              do
              {
                int v73 = (unsigned int *)((char *)v71 + v70);
                int v74 = (unsigned int *)((char *)v71 + v70 + v70);
                int v75 = v71;
                int v71 = (unsigned int *)((char *)v74 + v70);
                int v76 = v73;
                do
                {
                  int v77 = 0;
                  unsigned int v78 = *v75;
                  unsigned int v79 = *v76;
                  unsigned int v80 = *v74;
                  unsigned int v81 = -4;
                  unsigned int v82 = *v71;
                  do
                  {
                    v81 += 4;
                    int v83 = gCount4Bits[v78 & 0xF];
                    v78 >>= 4;
                    int v84 = gCount4Bits[v79 & 0xF] + v83;
                    int v85 = gCount4Bits[v80 & 0xF];
                    v79 >>= 4;
                    v80 >>= 4;
                    int v86 = v85 + gCount4Bits[v82 & 0xF];
                    v82 >>= 4;
                    v77 |= (v84 + v86 - ((v84 + v86) >> 4)) << v81;
                  }
                  while (v81 < 0x19);
                  ++v75;
                  ++v76;
                  ++v74;
                  ++v71;
                  *v72++ = v77;
                }
                while (v75 < v73);
                --v68;
              }
              while (v68);
              ScalerDisposeBlock(a2, v69, -1);
            }
            return v30;
          }
        }
      }
    }
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  unsigned int v27 = *(_DWORD *)v10;
  if (*(_DWORD *)v10)
  {
    if (*(unsigned char *)(a1 + 64))
    {
      int v28 = *(_DWORD *)(a4 + 28) - *(_DWORD *)(a4 + 20);
      int v29 = *(_DWORD *)(a4 + 24) - *(_DWORD *)(a4 + 16);
      unsigned int v27 = (((4 * v29 + 31) >> 3) & 0x1FFFFFFC) * v28;
    }
    else
    {
      int v29 = 0;
      int v28 = 0;
    }
    uint64_t v87 = ScalerNewBlock(a2, v27, a5, 0, 0, 1, 0);
    uint64_t v10 = *(void *)(a1 + 40);
  }
  else
  {
    uint64_t v87 = 0;
    int v29 = 0;
    int v28 = 0;
  }
  *(void *)(v10 + 8) = v87;
  sbit_GetBitMapData(a1, a3, (void *)a4, 0, 1, 0);
  uint64_t v30 = *(void **)a4;
  if (*(unsigned char *)(a1 + 64) && v30 && v28)
  {
    int v88 = 0;
    unsigned int v89 = (v29 + 7) >> 3;
    unsigned int v90 = ((v29 + 31) >> 3) & 0x1FFFFFFC;
    unsigned int v91 = ((4 * v29 + 31) >> 3) & 0x1FFFFFFC;
    uint64_t v92 = -(uint64_t)(v90 - v89);
    int v93 = (char *)v30 + v90 * v28 - 1;
    int v94 = (_WORD *)((char *)v30 + v91 * v28 - 2);
    if (v89 <= 1) {
      unsigned int v89 = 1;
    }
    do
    {
      v93 += v92;
      v94 -= (v91 - 4 * ((v29 + 7) >> 3)) >> 1;
      if ((v29 + 7) >= 8)
      {
        unsigned int v95 = v89;
        do
        {
          _WORD *v94 = ExpandTo4Bits(void *,unsigned int,unsigned int)::expandedValues[*v93 & 0xF];
          unsigned int v96 = *v93--;
          BOOL v97 = v94 - 2;
          *(v94 - 1) = *(_WORD *)((char *)ExpandTo4Bits(void *,unsigned int,unsigned int)::expandedValues
                                + (((unint64_t)v96 >> 3) & 0x1E));
          v94 -= 2;
          --v95;
        }
        while (v95);
        int v94 = v97;
      }
      ++v88;
    }
    while (v88 != v28);
  }
  return v30;
}

void *RenderPath(void *a1, memoryContext *a2, _DWORD *a3, _WORD *a4)
{
  uint64_t v6 = a1[4];
  if (*(unsigned char *)(v6 + 128))
  {
    uint64_t v7 = (unsigned int *)(a1[5] + 184);
    LOWORD(v12[0]) = 0;
    uint64_t result = OutlineToPath(a2, v7, v12);
    *a4 = v12[0];
  }
  else
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)(a1[5] + 8) = 0;
    if (!*(unsigned char *)(v6 + 124))
    {
      int v13 = -1431655766;
      *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v12[0] = v10;
      v12[1] = v10;
      memset(v11, 170, sizeof(v11));
      sbit_GetBitMapInfo(a1, (uint64_t)a3, *(_DWORD *)(v6 + 120), (int32x2_t *)v12, v11, *(unsigned __int8 *)(a1[3] + 484));
    }
    sbit_GetBitMapData((uint64_t)a1, a3, 0, &v14, 1, 5);
    return (void *)v14;
  }
  return result;
}

void sub_1B52D1BC4(void *a1)
{
  *uint64_t v1 = *(_WORD *)__cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B52D1BB0);
}

uint64_t CheckedF26Dot6Add(int a1, int a2)
{
  BOOL v2 = __OFADD__(a1, a2);
  uint64_t result = (a1 + a2);
  if (v2)
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  return result;
}

uint64_t fs_SetDeviceMetrics(uint64_t result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  int v7 = (*(_DWORD *)(a3 + 4 * a5) - *(_DWORD *)(a3 + 4 * a6)) << 10;
  *a2 = v7;
  int v8 = (*(_DWORD *)(a4 + 4 * a5) - *(_DWORD *)(a4 + 4 * a6)) << 10;
  a2[1] = v8;
  int v9 = (*(_DWORD *)(a3 + 4 * a7) - *(_DWORD *)(a3 + 4 * a6)) << 10;
  a2[2] = v9;
  int v10 = (*(_DWORD *)(a4 + 4 * a7) - *(_DWORD *)(a4 + 4 * a6)) << 10;
  a2[3] = v10;
  uint64_t v11 = 4 * a7 + 4;
  int v12 = (*(_DWORD *)(a3 + v11) - *(_DWORD *)(a3 + 4 * a5)) << 10;
  a2[4] = v12;
  int v13 = (*(_DWORD *)(a4 + v11) - *(_DWORD *)(a4 + 4 * a5)) << 10;
  a2[5] = v13;
  if (result)
  {
    *a2 = (v7 + 0x8000) >> 16;
    a2[1] = (v8 + 0x8000) >> 16;
    a2[2] = (v9 + 0x8000) >> 16;
    a2[3] = (v10 + 0x8000) >> 16;
    a2[4] = (v12 + 0x8000) >> 16;
    a2[5] = (v13 + 0x8000) >> 16;
  }
  return result;
}

uint64_t fs_dropOutVal(__int16 a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if ((a2 & 0x3F00) != 0 && (a2 & 0xFFFF0000) != 0x20000)
  {
    if ((a2 & 0x800) != 0 && a1 > a2
      || (a2 & 0x1000) != 0 && (a1 & 0x400) == 0
      || (a2 & 0x2000) != 0 && (a1 & 0x1000) == 0)
    {
      return 0;
    }
    else if ((a2 & 0x100) != 0 {
           && (a2 == 255 || a1 <= a2)
    }
           || (a2 & 0x200) != 0 && (a1 & 0x400) != 0)
    {
      return a2;
    }
    else if ((a1 & 0x1000) == 0 || (a2 & 0x400) == 0)
    {
      return 0;
    }
    else
    {
      return a2;
    }
  }
  return v2;
}

uint64_t FPGetStandardEncodingSID(int a1)
{
  return (unsigned __int16)FPGetStandardEncodingSID(unsigned char)::gStdSIDs[a1];
}

void TCFF2ParsingContext::SwipeCFF2ResultsToFont(TCFF2ParsingContext *this, TSFNTOpenTypeCFF2Font *a2, const ItemVariationStore *a3)
{
  TParsingContext::SwipeResultsToFont(this, a2);
  uint64_t v5 = *((void *)a2 + 23);
  *((void *)a2 + 23) = 0;
  *((void *)a2 + 24) = 0;
  if (v5) {
    MEMORY[0x1BA9994A0](v5, 0x1000C8052888210);
  }
  uint64_t v6 = *((void *)this + 112);
  *((void *)this + 112) = 0;
  uint64_t v7 = *((void *)a2 + 36);
  *((void *)a2 + 36) = v6;
  if (v7)
  {
    MEMORY[0x1BA9994A0](v7, 0x1000C80BDFB0063);
    uint64_t v6 = *((void *)a2 + 36);
  }
  if (v6) {
    uint64_t v6 = *((void *)this + 98);
  }
  *((void *)a2 + 37) = v6;
  *((unsigned char *)a2 + 304) = *((unsigned char *)this + 792);
  *((unsigned char *)a2 + 305) = *((unsigned char *)this + 848);
  *((_WORD *)a2 + 153) = *((_WORD *)this + 425);
  *((_DWORD *)a2 + 77) = *((_DWORD *)this + 213);
  *((_DWORD *)a2 + 78) = *((_DWORD *)this + 214);
  *((unsigned char *)a2 + 316) = *(unsigned char *)(*((void *)this + 86) + 2);
  *((unsigned char *)a2 + 317) = *((unsigned char *)this + 861);
  *((_WORD *)a2 + 159) = *((_WORD *)this + 431);
  *((_OWORD *)a2 + 20) = *((_OWORD *)this + 55);
  uint64_t v8 = *((void *)this + 115);
  *((void *)this + 115) = 0;
  uint64_t v9 = *((void *)a2 + 76);
  *((void *)a2 + 76) = v8;
  if (v9) {
    std::default_delete<FDArrayEntity []>::operator()[abi:fe180100]<FDArrayEntity>((uint64_t)a2 + 608, v9);
  }
  *((_WORD *)a2 + 308) = *((_WORD *)this + 458);
  operator new[]();
}

void TOpenTypeFont::TOpenTypeFont(TOpenTypeFont *this, const TType1CFFDescriptor *a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 28) = 0;
  *(void *)this = &unk_1F0DD63E0;
  *((void *)this + 2) = &unk_1F0DD6600;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((_WORD *)this + 140) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((void *)this + 36) = 0;
  *((void *)this + 37) = 0;
  *((void *)this + 40) = 0;
  *((void *)this + 41) = 0;
  *((unsigned char *)this + 336) = 0;
  memset(v3, 170, sizeof(v3));
  TCFFParsingContext::TCFFParsingContext((TParsingContext *)v3, (const TType1CFFDescriptor *)((char *)a2 + 2952));
}

void sub_1B52D2110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TCFFParsingContext::~TCFFParsingContext((TCFFParsingContext *)&a9);
  uint64_t v11 = *((void *)v9 + 36);
  *((void *)v9 + 36) = 0;
  if (v11) {
    MEMORY[0x1BA9994A0](v11, 0x1000C80BDFB0063);
  }
  TType1Font::~TType1Font(v9);
  _Unwind_Resume(a1);
}

void TOpenTypeFont::~TOpenTypeFont(TOpenTypeFont *this)
{
  *(void *)this = &unk_1F0DD63E0;
  *((void *)this + 2) = &unk_1F0DD6600;
  *((void *)this + 14) = 0;
  uint64_t v2 = *((void *)this + 36);
  *((void *)this + 36) = 0;
  if (v2) {
    MEMORY[0x1BA9994A0](v2, 0x1000C80BDFB0063);
  }
  TType1Font::~TType1Font(this);
}

uint64_t TOpenTypeFont::GetCFFData(TOpenTypeFont *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

void TOpenTypeFont::GetCharString(TOpenTypeFont *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (*((_DWORD *)this + 35) <= a2 || (uint64_t v4 = *((void *)this + 13)) == 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  uint64_t v6 = v4 + 8 * a2;
  int v8 = *(_DWORD *)(v6 + 4);
  uint64_t v7 = (unsigned int *)(v6 + 4);
  if (v8)
  {
    (*(void (**)(void *__return_ptr))(*(void *)this + 520))(v10);
    TCharString::TCharString((TCharString *)a3, a2, (const TDataReference *)v10, *v7);
    TDataReference::~TDataReference((TDataReference *)v10);
  }
  else
  {
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = &unk_1F0DFF650;
    *(_DWORD *)(a3 + 24) = 0;
    *(unsigned char *)(a3 + 28) = 0;
    *(void *)(a3 + 32) = &unk_1F0DD4218;
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 48) = 0;
    *(void *)(a3 + 56) = 0;
  }
}

void sub_1B52D2364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL TOpenTypeFont::GetType1Encoding(TOpenTypeFont *this, unsigned __int16 *a2)
{
  uint64_t v2 = *((void *)this + 28);
  if (v2)
  {
    for (uint64_t i = 0; i != 256; ++i)
    {
      uint64_t v6 = *(int *)(v2 + 4 * i);
      if (v6)
      {
        uint64_t v7 = (*(uint64_t (**)(TOpenTypeFont *, uint64_t))(*(void *)this + 352))(this, v6 + *((void *)this + 28) + 1);
        if ((v7 & 0xFF00000000) != 0) {
          a2[i] = v7;
        }
      }
    }
  }
  return v2 != 0;
}

unint64_t TOpenTypeFont::GetStringOffsets(TOpenTypeFont *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 153) <= a2) {
    goto LABEL_15;
  }
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v23 = v3;
  long long v24 = v3;
  (*(void (**)(long long *__return_ptr))(*(void *)this + 520))(&v23);
  if (!*((void *)&v23 + 1) || (uint64_t v4 = *(void *)(*((void *)&v23 + 1) + 8)) == 0)
  {
    TDataReference::~TDataReference((TDataReference *)&v23);
LABEL_15:
    unint64_t v21 = 0;
    uint64_t v7 = 0xFFFFFFFFLL;
    return v21 | v7;
  }
  uint64_t v5 = (unsigned __int8 *)(v4 + v24);
  int v6 = *((unsigned __int8 *)this + 305);
  uint64_t v7 = 0xFFFFFFFFLL;
  int v8 = v6 - 1;
  int v9 = 0;
  int v10 = 0;
  switch(v8)
  {
    case 0:
      goto LABEL_8;
    case 1:
      goto LABEL_7;
    case 2:
      goto LABEL_6;
    case 3:
      int v11 = *v5++;
      int v9 = v11 << 8;
LABEL_6:
      int v12 = *v5++;
      int v10 = (v9 | v12) << 8;
LABEL_7:
      int v13 = *v5++;
      LODWORD(v7) = ((v10 | v13) << 8) - 1;
LABEL_8:
      int v14 = *v5++;
      uint64_t v7 = (v7 + v14);
      break;
    default:
      break;
  }
  int v15 = 0;
  int v16 = 0;
  int v17 = 0;
  switch(v8)
  {
    case 0:
      goto LABEL_13;
    case 1:
      goto LABEL_12;
    case 2:
      goto LABEL_11;
    case 3:
      int v18 = *v5++;
      int v15 = v18 << 8;
LABEL_11:
      int v19 = *v5++;
      int v16 = (v15 | v19) << 8;
LABEL_12:
      int v20 = *v5++;
      int v17 = (v16 | v20) << 8;
LABEL_13:
      unint64_t v21 = ((unint64_t)(v17 | *v5) << 32) - 0x100000000;
      break;
    default:
      unint64_t v21 = 0xFFFFFFFF00000000;
      break;
  }
  TDataReference::~TDataReference((TDataReference *)&v23);
  return v21 | v7;
}

void TOpenTypeFont::GetGlyphName(TOpenTypeFont *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *((void *)this + 36);
  if (!v4 || *((_DWORD *)this + 35) <= a2)
  {
LABEL_6:
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    goto LABEL_7;
  }
  unint64_t v6 = *(unsigned __int16 *)(v4 + 2 * a2);
  if (v6 > 0x186)
  {
    unint64_t StringOffsets = TOpenTypeFont::GetStringOffsets(this, (unsigned __int16)(v6 - 391));
    if (StringOffsets <= HIDWORD(StringOffsets))
    {
      uint64_t v10 = (HIDWORD(StringOffsets) - StringOffsets);
      (*(void (**)(void *__return_ptr, TOpenTypeFont *, void, uint64_t))(*(void *)this + 520))(v11, this, (*((_DWORD *)this + 78) + StringOffsets), v10);
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = v10;
      *(void *)a3 = &unk_1F0DD43A0;
      *(unsigned char *)(a3 + 24) = 0;
      *(void *)(a3 + 32) = &unk_1F0DD4218;
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 48) = 0;
      *(void *)(a3 + 56) = 0;
      TDataReference::operator=((TDataReference *)(a3 + 32), (uint64_t)v11);
      TDataReference::~TDataReference((TDataReference *)v11);
      return;
    }
    goto LABEL_6;
  }
  uint64_t v7 = *(const char **)(kStdStrs + 8 * v6);
  size_t v8 = strlen(v7);
  *(void *)(a3 + 8) = v7;
  *(void *)(a3 + 16) = v8;
LABEL_7:
  *(void *)a3 = &unk_1F0DD43A0;
  *(unsigned char *)(a3 + 24) = 0;
  *(void *)(a3 + 32) = &unk_1F0DD4218;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
}

void sub_1B52D2738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TOpenTypeFont::VerifyGlyphName(TOpenTypeFont *this, uint64_t a2, const char *__s2)
{
  uint64_t v3 = *((void *)this + 36);
  if (v3)
  {
    uint64_t v4 = a2;
    if (*((_DWORD *)this + 35) > a2)
    {
      unint64_t v7 = *(unsigned __int16 *)(v3 + 2 * a2);
      if (v7 > 0x186)
      {
        unint64_t StringOffsets = TOpenTypeFont::GetStringOffsets(this, (unsigned __int16)(v7 - 391));
        if (StringOffsets <= HIDWORD(StringOffsets))
        {
          size_t v9 = (HIDWORD(StringOffsets) - StringOffsets);
          (*(void (**)(uint64_t *__return_ptr, TOpenTypeFont *, void, size_t))(*(void *)this + 520))(&v13, this, (*((_DWORD *)this + 78) + StringOffsets), v9);
          uint64_t v10 = (const char *)v14;
          if (v14)
          {
            uint64_t v10 = (const char *)*((void *)v14 + 1);
            if (v10) {
              v10 += v15;
            }
          }
          if (v9 == *(unsigned __int8 *)v10)
          {
            int v11 = strncmp(__s2, v10 + 1, v9);
            TDataReference::~TDataReference((TDataReference *)&v13);
            if (!v11) {
              return v4;
            }
          }
          else
          {
            TDataReference::~TDataReference((TDataReference *)&v13);
          }
        }
      }
      else if (!strcmp(*(const char **)(kStdStrs + 8 * v7), __s2))
      {
        return v4;
      }
    }
  }
  return 0;
}

void TOpenTypeCIDFont::TOpenTypeCIDFont(TOpenTypeCIDFont *this, const TType1CFFDescriptor *a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 28) = 0;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((_WORD *)this + 140) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((void *)this + 36) = 0;
  *((void *)this + 37) = 0;
  *((void *)this + 40) = 0;
  *((void *)this + 41) = 0;
  *((unsigned char *)this + 336) = 0;
  *((_DWORD *)this + 101) = 0;
  *(void *)((char *)this + 388) = 0;
  *(void *)((char *)this + 396) = 0;
  *(void *)((char *)this + 412) = -1;
  *((void *)this + 53) = -1;
  *((_DWORD *)this + 108) = 65534;
  *(void *)this = &unk_1F0DD6140;
  *((void *)this + 2) = &unk_1F0DD6388;
  *((void *)this + 43) = &unk_1F0DD63A8;
  *((void *)this + 59) = 0;
  *((_DWORD *)this + 120) = 0;
  *((void *)this + 56) = 0;
  *((void *)this + 57) = 0;
  *((_DWORD *)this + 116) = 0;
  *((void *)this + 55) = 0;
  memset(__b, 170, sizeof(__b));
  TCFFCIDParsingContext::TCFFCIDParsingContext((TParsingContext *)__b, (const TType1CFFDescriptor *)((char *)a2 + 2952));
}

void sub_1B52D2A08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TCFFCIDParsingContext::~TCFFCIDParsingContext((TCFFCIDParsingContext *)va);
  uint64_t v5 = v2[57];
  v2[57] = 0;
  if (v5) {
    MEMORY[0x1BA9994A0](v5, 0x1000C8077774924);
  }
  unint64_t v6 = v2 + 55;
  uint64_t v7 = v2[56];
  v2[56] = 0;
  if (v7) {
    MEMORY[0x1BA9994A0](v7, 0x1000C8052888210);
  }
  uint64_t v8 = *v6;
  *unint64_t v6 = 0;
  if (v8) {
    MEMORY[0x1BA9994A0](v8, 0x1000C8052888210);
  }
  MType1CIDFont::~MType1CIDFont(v3);
  TOpenTypeFont::~TOpenTypeFont((TOpenTypeFont *)v2);
  _Unwind_Resume(a1);
}

void TOpenTypeCIDFont::~TOpenTypeCIDFont(TOpenTypeCIDFont *this)
{
  *(void *)this = &unk_1F0DD6140;
  *((void *)this + 2) = &unk_1F0DD6388;
  uint64_t v2 = (TOpenTypeCIDFont *)((char *)this + 344);
  *((void *)this + 43) = &unk_1F0DD63A8;
  uint64_t v3 = *((void *)this + 59);
  if (v3) {
    MEMORY[0x1BA9994A0](v3, 0x1000C80BDFB0063);
  }
  uint64_t v4 = *((void *)this + 57);
  *((void *)this + 57) = 0;
  if (v4) {
    MEMORY[0x1BA9994A0](v4, 0x1000C8077774924);
  }
  uint64_t v5 = *((void *)this + 56);
  *((void *)this + 56) = 0;
  if (v5) {
    MEMORY[0x1BA9994A0](v5, 0x1000C8052888210);
  }
  uint64_t v6 = *((void *)this + 55);
  *((void *)this + 55) = 0;
  if (v6) {
    MEMORY[0x1BA9994A0](v6, 0x1000C8052888210);
  }
  MType1CIDFont::~MType1CIDFont(v2);
  TOpenTypeFont::~TOpenTypeFont(this);
}

void TOpenTypeCIDFont::GetGlyphName(TOpenTypeCIDFont *this@<X0>, unsigned int a2@<W1>, TStringRef *a3@<X8>)
{
  unsigned __int16 v3 = a2;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v8 = v6;
  long long v9 = v6;
  v7[0] = v6;
  v7[1] = v6;
  TOpenTypeFont::GetGlyphName(this, a2, (uint64_t)v7);
  if (*((void *)&v7[0] + 1) || *((void *)&v8 + 1) && *(void *)(*((void *)&v8 + 1) + 8)) {
    TStringRef::TStringRef(a3, (const TStringRef *)v7);
  }
  else {
    MType1CIDFont::GetCIDGlyphName((TOpenTypeCIDFont *)((char *)this + 344), v3, (uint64_t)a3);
  }
  TStringRef::~TStringRef((void **)v7);
}

void sub_1B52D2C50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

uint64_t TOpenTypeCIDFont::GetGlyphID(TOpenTypeCIDFont *this, const char *a2)
{
  uint64_t CIDForGlyphName = MType1CIDFont::GetCIDForGlyphName((TOpenTypeCIDFont *)((char *)this + 344), a2);
  if ((CIDForGlyphName & 0xFF0000) == 0)
  {
LABEL_6:
    unsigned int v4 = 0;
    goto LABEL_7;
  }
  unsigned int v4 = *((_DWORD *)this + 35);
  if (!v4)
  {
LABEL_7:
    uint64_t v8 = 0;
    int v9 = 0;
    return v8 | v9 | v4;
  }
  unsigned __int16 v5 = CIDForGlyphName;
  uint64_t v6 = 0;
  int v7 = 0;
  while ((*(unsigned int (**)(TOpenTypeCIDFont *, uint64_t))(*(void *)this + 560))(this, v6) != v5)
  {
    uint64_t v6 = (unsigned __int16)++v7;
    if (*((_DWORD *)this + 35) <= (unsigned __int16)v7) {
      goto LABEL_6;
    }
  }
  unsigned int v4 = v6 & 0xFF00;
  int v9 = v6;
  uint64_t v8 = 0x100000000;
  return v8 | v9 | v4;
}

uint64_t TOpenTypeCIDFont::GetCID(atomic_ullong *this, unsigned int a2)
{
  if (*((_DWORD *)this + 35) <= a2)
  {
    LOWORD(v2) = 0;
  }
  else
  {
    unsigned int v2 = a2;
    unint64_t CFFCharSet = TOpenTypeCIDFont::GetCFFCharSet(this);
    if (CFFCharSet) {
      LOWORD(v2) = *(_WORD *)(CFFCharSet + 2 * v2);
    }
  }
  return (unsigned __int16)v2;
}

unint64_t TOpenTypeCIDFont::GetCFFCharSet(atomic_ullong *this)
{
  unint64_t explicit = atomic_load_explicit(this + 59, memory_order_acquire);
  if (!explicit)
  {
    uint64_t v2 = *((unsigned int *)this + 120);
    if (v2 && *((_DWORD *)this + 35))
    {
      *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v5 = v3;
      long long v6 = v3;
      (*(void (**)(long long *__return_ptr, atomic_ullong *, uint64_t, uint64_t))(*this + 520))(&v5, this, v2, 1);
      if (*((void *)&v5 + 1) && *(void *)(*((void *)&v5 + 1) + 8) && *((void *)&v6 + 1) != (void)v6)
      {
        ReadTypeInc<unsigned char>((TDataReference *)&v5);
        operator new[]();
      }
      unint64_t explicit = 0;
      TDataReference::~TDataReference((TDataReference *)&v5);
    }
    else
    {
      return 0;
    }
  }
  return explicit;
}

void sub_1B52D308C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  TDataReference::~TDataReference((TDataReference *)&a9);
  MEMORY[0x1BA9994A0](v13, 0x1000C80BDFB0063);
  TDataReference::~TDataReference((TDataReference *)&a13);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'TOpenTypeCIDFont::GetCID(atomic_ullong *this, unsigned int a2)
{
  if (*((_DWORD *)this - 51) <= a2)
  {
    LOWORD(v2) = 0;
  }
  else
  {
    unsigned int v2 = a2;
    unint64_t CFFCharSet = TOpenTypeCIDFont::GetCFFCharSet(this - 43);
    if (CFFCharSet) {
      LOWORD(v2) = *(_WORD *)(CFFCharSet + 2 * v2);
    }
  }
  return (unsigned __int16)v2;
}

void TOpenTypeCFFMemoryFont::TOpenTypeCFFMemoryFont(TOpenTypeCFFMemoryFont *this, const TType1CFFDescriptor *a2)
{
}

void sub_1B52D3264(_Unwind_Exception *a1)
{
  TOpenTypeFont::~TOpenTypeFont(v1);
  _Unwind_Resume(a1);
}

void TOpenTypeCFFMemoryFont::~TOpenTypeCFFMemoryFont(TOpenTypeCFFMemoryFont *this)
{
  *(void *)this = &unk_1F0DD5F00;
  *((void *)this + 2) = &unk_1F0DD6120;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeCFFMemoryFont *)((char *)this + 344));
  TOpenTypeFont::~TOpenTypeFont(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DD5F00;
  *((void *)this + 2) = &unk_1F0DD6120;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeCFFMemoryFont *)((char *)this + 344));
  TOpenTypeFont::~TOpenTypeFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeCFFMemoryFont::~TOpenTypeCFFMemoryFont(TOpenTypeCFFMemoryFont *this)
{
  uint64_t v1 = (TOpenTypeCFFMemoryFont *)((char *)this - 16);
  *((void *)this - 2) = &unk_1F0DD5F00;
  *(void *)this = &unk_1F0DD6120;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeCFFMemoryFont *)((char *)this + 328));
  TOpenTypeFont::~TOpenTypeFont(v1);
}

{
  TOpenTypeCFFMemoryFont::~TOpenTypeCFFMemoryFont((TOpenTypeCFFMemoryFont *)((char *)this - 16));
}

uint64_t TOpenTypeCFFMemoryFont::GetKind(TOpenTypeCFFMemoryFont *this)
{
  return 25;
}

uint64_t TOpenTypeCFFMemoryFont::GetFontRef(TOpenTypeCFFMemoryFont *this)
{
  return (uint64_t)this + 344;
}

void TOpenTypeCFFCIDMemoryFont::TOpenTypeCFFCIDMemoryFont(TOpenTypeCFFCIDMemoryFont *this, const TType1CFFDescriptor *a2)
{
}

void sub_1B52D3558(_Unwind_Exception *a1)
{
  TOpenTypeCIDFont::~TOpenTypeCIDFont(v1);
  _Unwind_Resume(a1);
}

void TOpenTypeCFFCIDMemoryFont::~TOpenTypeCFFCIDMemoryFont(TOpenTypeCFFCIDMemoryFont *this)
{
  *(void *)this = &unk_1F0DD5C60;
  *((void *)this + 2) = &unk_1F0DD5EA8;
  *((void *)this + 43) = &unk_1F0DD5EC8;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeCFFCIDMemoryFont *)((char *)this + 488));
  TOpenTypeCIDFont::~TOpenTypeCIDFont(this);
}

{
  uint64_t vars8;

  TOpenTypeCFFCIDMemoryFont::~TOpenTypeCFFCIDMemoryFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeCFFCIDMemoryFont::~TOpenTypeCFFCIDMemoryFont(TOpenTypeCFFCIDMemoryFont *this)
{
}

{
  TOpenTypeCFFCIDMemoryFont::~TOpenTypeCFFCIDMemoryFont((TOpenTypeCFFCIDMemoryFont *)((char *)this - 344));
}

{
  uint64_t vars8;

  TOpenTypeCFFCIDMemoryFont::~TOpenTypeCFFCIDMemoryFont((TOpenTypeCFFCIDMemoryFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

{
  uint64_t vars8;

  TOpenTypeCFFCIDMemoryFont::~TOpenTypeCFFCIDMemoryFont((TOpenTypeCFFCIDMemoryFont *)((char *)this - 344));
  JUMPOUT(0x1BA9994D0);
}

uint64_t TOpenTypeCFFCIDMemoryFont::GetKind(TOpenTypeCFFCIDMemoryFont *this)
{
  return 27;
}

uint64_t TOpenTypeCFFCIDMemoryFont::GetFontRef(TOpenTypeCFFCIDMemoryFont *this)
{
  return (uint64_t)this + 488;
}

void TOpenTypeFileDataFont::TOpenTypeFileDataFont(TOpenTypeFileDataFont *this, const TFileDataSurrogate *a2, const TType1CFFDescriptor *a3)
{
}

void sub_1B52D378C(_Unwind_Exception *a1)
{
  TOpenTypeFont::~TOpenTypeFont(v1);
  _Unwind_Resume(a1);
}

void TOpenTypeFileDataFont::~TOpenTypeFileDataFont(TOpenTypeFileDataFont *this)
{
  *(void *)this = &unk_1F0DD5A20;
  *((void *)this + 2) = &unk_1F0DD5C40;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 43);
  TOpenTypeFont::~TOpenTypeFont(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DD5A20;
  *((void *)this + 2) = &unk_1F0DD5C40;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 43);
  TOpenTypeFont::~TOpenTypeFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeFileDataFont::~TOpenTypeFileDataFont(TOpenTypeFileDataFont *this)
{
  uint64_t v1 = (TOpenTypeFileDataFont *)((char *)this - 16);
  *((void *)this - 2) = &unk_1F0DD5A20;
  *(void *)this = &unk_1F0DD5C40;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 41);
  TOpenTypeFont::~TOpenTypeFont(v1);
}

{
  TOpenTypeFileDataFont::~TOpenTypeFileDataFont((TOpenTypeFileDataFont *)((char *)this - 16));
}

uint64_t TOpenTypeFileDataFont::GetKind(TOpenTypeFileDataFont *this)
{
  return 26;
}

uint64_t TOpenTypeFileDataFont::GetFontRef(TOpenTypeFileDataFont *this)
{
  return (uint64_t)this + 344;
}

void TOpenTypeCIDFileDataFont::TOpenTypeCIDFileDataFont(TOpenTypeCIDFileDataFont *this, const TFileDataSurrogate *a2, const TType1CFFDescriptor *a3)
{
}

void sub_1B52D3A04(_Unwind_Exception *a1)
{
  TOpenTypeCIDFont::~TOpenTypeCIDFont(v1);
  _Unwind_Resume(a1);
}

void TOpenTypeCIDFileDataFont::~TOpenTypeCIDFileDataFont(TOpenTypeCIDFileDataFont *this)
{
  *(void *)this = &unk_1F0DD5780;
  *((void *)this + 2) = &unk_1F0DD59C8;
  *((void *)this + 43) = &unk_1F0DD59E8;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 61);
  TOpenTypeCIDFont::~TOpenTypeCIDFont(this);
}

{
  uint64_t vars8;

  TOpenTypeCIDFileDataFont::~TOpenTypeCIDFileDataFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeCIDFileDataFont::~TOpenTypeCIDFileDataFont(TOpenTypeCIDFileDataFont *this)
{
}

{
  TOpenTypeCIDFileDataFont::~TOpenTypeCIDFileDataFont((TOpenTypeCIDFileDataFont *)((char *)this - 344));
}

{
  uint64_t vars8;

  TOpenTypeCIDFileDataFont::~TOpenTypeCIDFileDataFont((TOpenTypeCIDFileDataFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

{
  uint64_t vars8;

  TOpenTypeCIDFileDataFont::~TOpenTypeCIDFileDataFont((TOpenTypeCIDFileDataFont *)((char *)this - 344));
  JUMPOUT(0x1BA9994D0);
}

uint64_t TOpenTypeCIDFileDataFont::GetKind(TOpenTypeCIDFileDataFont *this)
{
  return 28;
}

uint64_t TOpenTypeCIDFileDataFont::GetFontRef(TOpenTypeCIDFileDataFont *this)
{
  return (uint64_t)this + 488;
}

void non-virtual thunk to'TSFNTOpenTypeData::~TSFNTOpenTypeData(TSFNTOpenTypeData *this)
{
}

{
  uint64_t vars8;

  TSFNTFont::~TSFNTFont((TSFNTOpenTypeData *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

void TSFNTOpenTypeData::~TSFNTOpenTypeData(TSFNTOpenTypeData *this)
{
  TSFNTFont::~TSFNTFont(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TSFNTOpenTypeData::GetNumberOfGlyphs(TSFNTOpenTypeData *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 26) + 168))();
}

uint64_t TheadTable::GetUnitsPerEm(TheadTable *this)
{
  unsigned int v1 = bswap32(*(unsigned __int16 *)(TheadTable::GetHead(this) + 18));
  if ((unsigned __int16)(HIWORD(v1) - 16385) <= 0xC00Eu)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  return HIWORD(v1);
}

void OTFSetupHFMXAndVFMX(TSFNTFont *a1)
{
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v11 = v2;
  long long v12 = v2;
  long long v10 = v2;
  TsfntTable::TsfntTable((TsfntTable *)&v10, a1, 1751672161);
  if (*((void *)&v10 + 1) && *(void *)(*((void *)&v10 + 1) + 8))
  {
    unint64_t TableEnd = TsfntTable::GetTableEnd((TsfntTable *)&v10);
    uint64_t v4 = *((void *)&v10 + 1);
    if (*((void *)&v10 + 1))
    {
      uint64_t v4 = *(void *)(*((void *)&v10 + 1) + 8);
      if (v4) {
        v4 += v11;
      }
    }
    if (TableEnd - v4 > 0x23) {
      operator new[]();
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  TDataReference::~TDataReference((TDataReference *)&v10);
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v11 = v5;
  long long v12 = v5;
  long long v10 = v5;
  TsfntTable::TsfntTable((TsfntTable *)&v10, a1, 1986553185);
  if (*((void *)&v10 + 1) && *(void *)(*((void *)&v10 + 1) + 8))
  {
    unint64_t v6 = TsfntTable::GetTableEnd((TsfntTable *)&v10);
    uint64_t v7 = *((void *)&v10 + 1);
    if (*((void *)&v10 + 1))
    {
      uint64_t v7 = *(void *)(*((void *)&v10 + 1) + 8);
      if (v7) {
        v7 += v11;
      }
    }
    if (v6 - v7 > 0x23) {
      operator new[]();
    }
    int v9 = __cxa_allocate_exception(0x10uLL);
    *(void *)int v9 = &unk_1F0DD4440;
    _OWORD v9[2] = 4;
  }
  TDataReference::~TDataReference((TDataReference *)&v10);
}

void sub_1B52D3FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B52D4050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B52D4060()
{
}

void TSFNTOpenTypeFont::~TSFNTOpenTypeFont(TSFNTOpenTypeFont *this)
{
  *(void *)this = &unk_1F0DD5540;
  *((void *)this + 2) = &unk_1F0DD5760;
  uint64_t v2 = *((void *)this + 75);
  *((void *)this + 75) = 0;
  if (v2) {
    MEMORY[0x1BA9994A0](v2, 0x1000C80BDFB0063);
  }
  uint64_t v3 = *((void *)this + 74);
  *((void *)this + 74) = 0;
  if (v3) {
    MEMORY[0x1BA9994A0](v3, 0x1000C80BDFB0063);
  }
  TDataReference::~TDataReference((TSFNTOpenTypeFont *)((char *)this + 560));
  TSFNTFont::~TSFNTFont((TSFNTOpenTypeFont *)((char *)this + 344));
  TOpenTypeFont::~TOpenTypeFont(this);
}

void TSFNTOpenTypeFont::GetNames(TSFNTOpenTypeFont *this@<X0>, void *a2@<X8>)
{
}

void TSFNTOpenTypeFont::GetSomeNames(TSFNTOpenTypeFont *this@<X0>, uint64_t *a2@<X8>)
{
}

double TSFNTOpenTypeFont::GetCaretInfo(TSFNTOpenTypeFont *this, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  TSFNTFont::GetCaretInfo((TSFNTOpenTypeFont *)((char *)this + 344), a2, a3, a4);
  if (!*a3)
  {
    return TType1Font::GetCaretInfo(this, a2, a3, a4);
  }
  return result;
}

uint64_t TSFNTOpenTypeFont::GetHFMX(TSFNTOpenTypeFont *this)
{
  return *((void *)this + 74);
}

void *TSFNTOpenTypeFont::GetCFFData@<X0>(TSFNTOpenTypeFont *this@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  return TDataReference::SubdataFrom((void *)this + 70, a2, a3, a4);
}

void TSFNTOpenTypeFont::GetGlyphName(TSFNTOpenTypeFont *this@<X0>, unsigned int a2@<W1>, TStringRef *a3@<X8>)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v8 = v6;
  long long v9 = v6;
  v7[0] = v6;
  v7[1] = v6;
  TOpenTypeFont::GetGlyphName(this, a2, (uint64_t)v7);
  if (*((void *)&v7[0] + 1) || *((void *)&v8 + 1) && *(void *)(*((void *)&v8 + 1) + 8)) {
    TStringRef::TStringRef(a3, (const TStringRef *)v7);
  }
  else {
    TSFNTFont::GetGlyphName((TSFNTOpenTypeFont *)((char *)this + 344), a2, (uint64_t)a3);
  }
  TStringRef::~TStringRef((void **)v7);
}

void sub_1B52D4268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

uint64_t TSFNTOpenTypeFont::VerifyGlyphName(TSFNTOpenTypeFont *this, uint64_t a2, const char *a3)
{
  uint64_t result = TOpenTypeFont::VerifyGlyphName(this, a2, a3);
  if (!result)
  {
    return TSFNTFont::VerifyGlyphName((TSFNTOpenTypeFont *)((char *)this + 344), a2, a3);
  }
  return result;
}

uint64_t TSFNTOpenTypeFont::GetGlyphsForCharacterRange(atomic_uint *this, unsigned __int16 *a2, CFRange a3)
{
  return TSFNTFont::GetGlyphsForCharacterRange(this + 86, a2, a3);
}

uint64_t TSFNTOpenTypeFont::GetCharactersPerGlyphs(TSFNTOpenTypeFont *this, const unsigned __int16 *a2, unsigned __int16 *a3, unint64_t a4)
{
  return TSFNTFont::GetCharactersPerGlyphs((TSFNTOpenTypeFont *)((char *)this + 344), a2, a3, a4);
}

void TSFNTOpenTypeFont::CopyCharacterSet(TSFNTOpenTypeFont *this)
{
  unsigned int v1 = (TSFNTOpenTypeFont *)((char *)this + 344);
  CFMutableArrayRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  TSFNTFont::FillCharacterSet(v1, Mutable);
}

TSFNTFont *TSFNTOpenTypeFont::GetOS2UnicodeRanges(TSFNTOpenTypeFont *this, unsigned int a2, unsigned int *a3, __n128 a4)
{
  return TSFNTFont::GetOS2UnicodeRanges((TSFNTOpenTypeFont *)((char *)this + 344), a2, a3, a4);
}

uint64_t TSFNTOpenTypeFont::GetCharactersForGlyph(TSFNTOpenTypeFont *this, unsigned __int16 a2, unsigned __int16 *a3, unint64_t a4)
{
  return TSFNTFont::GetCharactersForGlyph((TSFNTOpenTypeFont *)((char *)this + 344), a2, a3, a4);
}

void TOpenTypeDataForkFont::~TOpenTypeDataForkFont(TOpenTypeDataForkFont *this)
{
  *(void *)this = &unk_1F0DD5300;
  *((void *)this + 2) = &unk_1F0DD5520;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 76);
  TSFNTOpenTypeFont::~TSFNTOpenTypeFont(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DD5300;
  *((void *)this + 2) = &unk_1F0DD5520;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 76);
  TSFNTOpenTypeFont::~TSFNTOpenTypeFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeDataForkFont::~TOpenTypeDataForkFont(TOpenTypeDataForkFont *this)
{
  unsigned int v1 = (TOpenTypeDataForkFont *)((char *)this - 16);
  *((void *)this - 2) = &unk_1F0DD5300;
  *(void *)this = &unk_1F0DD5520;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 74);
  TSFNTOpenTypeFont::~TSFNTOpenTypeFont(v1);
}

{
  TOpenTypeDataForkFont::~TOpenTypeDataForkFont((TOpenTypeDataForkFont *)((char *)this - 16));
}

uint64_t TOpenTypeDataForkFont::GetRefCon(TOpenTypeDataForkFont *this)
{
  return *((unsigned int *)this + 156);
}

void TOpenTypeMemoryFont::TOpenTypeMemoryFont(TSFNTOpenTypeFont *a1, uint64_t a2)
{
  TSFNTFont::TSFNTFont((TSFNTFont *)v4);
  v4[0] = &unk_1F0DD6988;
  void v4[2] = &unk_1F0DD6B90;
  v4[25] = a2;
  TSFNTOpenTypeFont::TSFNTOpenTypeFont(a1, (const TSFNTData *)v4);
}

void sub_1B52D45F4(_Unwind_Exception *a1)
{
  TInMemoryDataReference::~TInMemoryDataReference(v2);
  TSFNTOpenTypeFont::~TSFNTOpenTypeFont(v1);
  _Unwind_Resume(a1);
}

void TOpenTypeMemoryFont::~TOpenTypeMemoryFont(TOpenTypeMemoryFont *this)
{
  *(void *)this = &unk_1F0DD50C0;
  *((void *)this + 2) = &unk_1F0DD52E0;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeMemoryFont *)((char *)this + 608));
  TSFNTOpenTypeFont::~TSFNTOpenTypeFont(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DD50C0;
  *((void *)this + 2) = &unk_1F0DD52E0;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeMemoryFont *)((char *)this + 608));
  TSFNTOpenTypeFont::~TSFNTOpenTypeFont(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DD50C0;
  *((void *)this + 2) = &unk_1F0DD52E0;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeMemoryFont *)((char *)this + 608));
  TSFNTOpenTypeFont::~TSFNTOpenTypeFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeMemoryFont::~TOpenTypeMemoryFont(TOpenTypeMemoryFont *this)
{
  unsigned int v1 = (TOpenTypeMemoryFont *)((char *)this - 16);
  *((void *)this - 2) = &unk_1F0DD50C0;
  *(void *)this = &unk_1F0DD52E0;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeMemoryFont *)((char *)this + 592));
  TSFNTOpenTypeFont::~TSFNTOpenTypeFont(v1);
}

{
  TOpenTypeMemoryFont::~TOpenTypeMemoryFont((TOpenTypeMemoryFont *)((char *)this - 16));
}

uint64_t TOpenTypeMemoryFont::GetKind(TOpenTypeMemoryFont *this)
{
  return 18;
}

uint64_t TOpenTypeMemoryFont::GetFontRef(TOpenTypeMemoryFont *this)
{
  return (uint64_t)this + 608;
}

void TOpenTypeWOFFFont::TOpenTypeWOFFFont(TOpenTypeWOFFFont *this, CFDataRef theData)
{
  CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  uint64_t v3 = &unk_1F0DD4120;
  operator new();
}

void sub_1B52D4970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  TOpenTypeMemoryFont::~TOpenTypeMemoryFont(v10);
  _Unwind_Resume(a1);
}

void TOpenTypeWOFFFont::~TOpenTypeWOFFFont(TOpenTypeWOFFFont *this)
{
  *(void *)this = &unk_1F0DFC658;
  *((void *)this + 2) = &unk_1F0DFC878;
  CFRelease(*((CFTypeRef *)this + 79));
  *(void *)this = &unk_1F0DD50C0;
  *((void *)this + 2) = &unk_1F0DD52E0;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeWOFFFont *)((char *)this + 608));
  TSFNTOpenTypeFont::~TSFNTOpenTypeFont(this);
}

{
  uint64_t vars8;

  TOpenTypeWOFFFont::~TOpenTypeWOFFFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeWOFFFont::~TOpenTypeWOFFFont(TOpenTypeWOFFFont *this)
{
}

{
  uint64_t vars8;

  TOpenTypeWOFFFont::~TOpenTypeWOFFFont((TOpenTypeWOFFFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

void TOpenTypeCIDWOFFFont::TOpenTypeCIDWOFFFont(TOpenTypeCIDWOFFFont *this, CFDataRef theData)
{
  CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  uint64_t v3 = &unk_1F0DD4120;
  operator new();
}

void sub_1B52D4C38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  TOpenTypeCIDMemoryFont::~TOpenTypeCIDMemoryFont(v10);
  _Unwind_Resume(a1);
}

void TOpenTypeCIDMemoryFont::TOpenTypeCIDMemoryFont(TSFNTOpenTypeCIDFont *a1, uint64_t a2)
{
  TSFNTFont::TSFNTFont((TSFNTFont *)v4);
  v4[0] = &unk_1F0DD6988;
  void v4[2] = &unk_1F0DD6B90;
  v4[25] = a2;
  TSFNTOpenTypeCIDFont::TSFNTOpenTypeCIDFont(a1, (const TSFNTData *)v4);
}

void sub_1B52D4D9C(_Unwind_Exception *a1)
{
  TInMemoryDataReference::~TInMemoryDataReference(v2);
  TSFNTOpenTypeCIDFont::~TSFNTOpenTypeCIDFont(v1);
  _Unwind_Resume(a1);
}

void TOpenTypeCIDMemoryFont::~TOpenTypeCIDMemoryFont(TOpenTypeCIDMemoryFont *this)
{
  *(void *)this = &unk_1F0DD48E0;
  *((void *)this + 2) = &unk_1F0DD4B28;
  *((void *)this + 43) = &unk_1F0DD4B48;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeCIDMemoryFont *)((char *)this + 752));
  TSFNTOpenTypeCIDFont::~TSFNTOpenTypeCIDFont(this);
}

{
  uint64_t vars8;

  TOpenTypeCIDMemoryFont::~TOpenTypeCIDMemoryFont(this);
  JUMPOUT(0x1BA9994D0);
}

void TOpenTypeCIDWOFFFont::~TOpenTypeCIDWOFFFont(TOpenTypeCIDWOFFFont *this)
{
  *(void *)this = &unk_1F0DFC898;
  *((void *)this + 2) = &unk_1F0DFCAE0;
  *((void *)this + 43) = &unk_1F0DFCB00;
  CFRelease(*((CFTypeRef *)this + 97));
  TOpenTypeCIDMemoryFont::~TOpenTypeCIDMemoryFont(this);
}

{
  uint64_t vars8;

  TOpenTypeCIDWOFFFont::~TOpenTypeCIDWOFFFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeCIDWOFFFont::~TOpenTypeCIDWOFFFont(TOpenTypeCIDWOFFFont *this)
{
}

{
  TOpenTypeCIDWOFFFont::~TOpenTypeCIDWOFFFont((TOpenTypeCIDWOFFFont *)((char *)this - 344));
}

{
  uint64_t vars8;

  TOpenTypeCIDWOFFFont::~TOpenTypeCIDWOFFFont((TOpenTypeCIDWOFFFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

{
  uint64_t vars8;

  TOpenTypeCIDWOFFFont::~TOpenTypeCIDWOFFFont((TOpenTypeCIDWOFFFont *)((char *)this - 344));
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TSFNTOpenTypeCIDData::~TSFNTOpenTypeCIDData(TSFNTOpenTypeCIDData *this)
{
}

{
  uint64_t vars8;

  TSFNTFont::~TSFNTFont((TSFNTOpenTypeCIDData *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

void TSFNTOpenTypeCIDData::~TSFNTOpenTypeCIDData(TSFNTOpenTypeCIDData *this)
{
  TSFNTFont::~TSFNTFont(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TSFNTOpenTypeCIDData::GetNumberOfGlyphs(TSFNTOpenTypeCIDData *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 26) + 168))();
}

void TSFNTOpenTypeCIDFont::~TSFNTOpenTypeCIDFont(TSFNTOpenTypeCIDFont *this)
{
  *(void *)this = &unk_1F0DD4E20;
  *((void *)this + 2) = &unk_1F0DD5068;
  *((void *)this + 43) = &unk_1F0DD5088;
  uint64_t v2 = *((void *)this + 93);
  *((void *)this + 93) = 0;
  if (v2) {
    MEMORY[0x1BA9994A0](v2, 0x1000C80BDFB0063);
  }
  uint64_t v3 = *((void *)this + 92);
  *((void *)this + 92) = 0;
  if (v3) {
    MEMORY[0x1BA9994A0](v3, 0x1000C80BDFB0063);
  }
  TDataReference::~TDataReference((TSFNTOpenTypeCIDFont *)((char *)this + 704));
  TSFNTFont::~TSFNTFont((TSFNTOpenTypeCIDFont *)((char *)this + 488));
  TOpenTypeCIDFont::~TOpenTypeCIDFont(this);
}

uint64_t TSFNTOpenTypeCIDFont::GetCID(atomic_ullong *this, unsigned int a2)
{
  if (*((_DWORD *)this + 35) <= a2)
  {
    LOWORD(v2) = 0;
  }
  else
  {
    unsigned int v2 = a2;
    unint64_t CFFCharSet = TOpenTypeCIDFont::GetCFFCharSet(this);
    if (CFFCharSet) {
      LOWORD(v2) = *(_WORD *)(CFFCharSet + 2 * v2);
    }
  }
  return (unsigned __int16)v2;
}

uint64_t non-virtual thunk to'TSFNTOpenTypeCIDFont::GetCID(atomic_ullong *this, unsigned int a2)
{
  if (*((_DWORD *)this - 51) <= a2)
  {
    LOWORD(v2) = 0;
  }
  else
  {
    unsigned int v2 = a2;
    unint64_t CFFCharSet = TOpenTypeCIDFont::GetCFFCharSet(this - 43);
    if (CFFCharSet) {
      LOWORD(v2) = *(_WORD *)(CFFCharSet + 2 * v2);
    }
  }
  return (unsigned __int16)v2;
}

uint64_t TSFNTOpenTypeCIDFont::GetGlyphsForCIDs(os_unfair_lock_s *this, unsigned __int16 *a2, uint64_t a3, unsigned __int16 *a4)
{
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  CIDGTable = (_WORD *)TSFNTFont::GetCIDGTable(this + 122, &v14);
  if (CIDGTable && v14 >= 0x90 && !*CIDGTable)
  {
    unsigned int v10 = bswap32((unsigned __int16)CIDGTable[71]);
    unint64_t v11 = v14 >> 1;
    if (&CIDGTable[HIWORD(v10) + 72] <= (_WORD *)((char *)CIDGTable + v14)) {
      unint64_t v11 = HIWORD(v10);
    }
    if (v11)
    {
      for (; a3; --a3)
      {
        int v12 = *a2++;
        *a4++ = bswap32((unsigned __int16)CIDGTable[v12 + 72]) >> 16;
      }
    }
    else
    {
      for (; a3; --a3)
      {
        unsigned __int16 v13 = *a2++;
        *a4++ = v13;
      }
    }
  }
  else
  {
    TOpenTypeCIDFont::GetGlyphsForCIDs((TOpenTypeCIDFont *)this, a2, a3, a4);
  }
  return 1;
}

uint64_t TOpenTypeCIDFont::GetGlyphsForCIDs(TOpenTypeCIDFont *this, unsigned __int16 *a2, uint64_t a3, unsigned __int16 *a4)
{
  if (TOpenTypeCIDFont::GetCFFCharSet((atomic_ullong *)this))
  {
    for (; a3; --a3)
    {
      int v9 = *a2++;
      int v8 = v9;
      if (*((_DWORD *)this + 35))
      {
        uint64_t v10 = 0;
        while ((*(unsigned int (**)(TOpenTypeCIDFont *, uint64_t))(*(void *)this + 560))(this, v10) != v8)
        {
          uint64_t v10 = (v10 + 1);
          if (v10 >= *((_DWORD *)this + 35)) {
            goto LABEL_7;
          }
        }
      }
      else
      {
LABEL_7:
        LOWORD(v10) = -1;
      }
      *a4++ = v10;
    }
  }
  else
  {
    for (; a3; --a3)
    {
      unsigned __int16 v11 = *a2++;
      *a4++ = v11;
    }
  }
  return 1;
}

void TSFNTOpenTypeCIDFont::GetNames(TSFNTOpenTypeCIDFont *this@<X0>, void *a2@<X8>)
{
}

void TSFNTOpenTypeCIDFont::GetSomeNames(TSFNTOpenTypeCIDFont *this@<X0>, uint64_t *a2@<X8>)
{
}

double TSFNTOpenTypeCIDFont::GetCaretInfo(TSFNTOpenTypeCIDFont *this, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  TSFNTFont::GetCaretInfo((TSFNTOpenTypeCIDFont *)((char *)this + 488), a2, a3, a4);
  if (!*a3)
  {
    return TType1Font::GetCaretInfo(this, a2, a3, a4);
  }
  return result;
}

__n128 TSFNTOpenTypeCIDFont::GetVerticalMetrics(TSFNTOpenTypeCIDFont *this, int *a2, int *a3, int *a4, unsigned int *a5, int *a6, int *a7, int *a8, int *a9, double *a10, double *a11, double *a12, double *a13)
{
  TSFNTFont::GetVerticalMetrics((TSFNTOpenTypeCIDFont *)((char *)this + 488), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
  return result;
}

uint64_t TSFNTOpenTypeCIDFont::GetHFMX(TSFNTOpenTypeCIDFont *this)
{
  return *((void *)this + 92);
}

void *TSFNTOpenTypeCIDFont::GetCFFData@<X0>(TSFNTOpenTypeCIDFont *this@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  return TDataReference::SubdataFrom((void *)this + 88, a2, a3, a4);
}

void TSFNTOpenTypeCIDFont::GetGlyphName(TSFNTOpenTypeCIDFont *this@<X0>, unsigned int a2@<W1>, TStringRef *a3@<X8>)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v9 = v6;
  long long v10 = v6;
  long long v7 = v6;
  long long v8 = v6;
  TOpenTypeCIDFont::GetGlyphName(this, a2, (TStringRef *)&v7);
  if ((void)v8) {
    TStringRef::TStringRef(a3, (const TStringRef *)&v7);
  }
  else {
    TSFNTFont::GetGlyphName((TSFNTOpenTypeCIDFont *)((char *)this + 488), a2, (uint64_t)a3);
  }
  TStringRef::~TStringRef((void **)&v7);
}

void sub_1B52D54D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

uint64_t TSFNTOpenTypeCIDFont::VerifyGlyphName(TSFNTOpenTypeCIDFont *this, uint64_t a2, const char *a3)
{
  uint64_t result = TOpenTypeFont::VerifyGlyphName(this, a2, a3);
  if (!result)
  {
    return TSFNTFont::VerifyGlyphName((TSFNTOpenTypeCIDFont *)((char *)this + 488), a2, a3);
  }
  return result;
}

unint64_t TSFNTOpenTypeCIDFont::GetGlyphID(TSFNTOpenTypeCIDFont *this, const char *a2)
{
  unint64_t result = TOpenTypeCIDFont::GetGlyphID(this, a2);
  if (!HIDWORD(result))
  {
    return TSFNTFont::GetGlyphID((TSFNTOpenTypeCIDFont *)((char *)this + 488), a2);
  }
  return result;
}

uint64_t TSFNTOpenTypeCIDFont::GetGlyphsForCharacterRange(atomic_uint *this, unsigned __int16 *a2, CFRange a3)
{
  return TSFNTFont::GetGlyphsForCharacterRange(this + 122, a2, a3);
}

uint64_t TSFNTOpenTypeCIDFont::GetCharactersPerGlyphs(TSFNTOpenTypeCIDFont *this, const unsigned __int16 *a2, unsigned __int16 *a3, unint64_t a4)
{
  return TSFNTFont::GetCharactersPerGlyphs((TSFNTOpenTypeCIDFont *)((char *)this + 488), a2, a3, a4);
}

void TSFNTOpenTypeCIDFont::CopyCharacterSet(TSFNTOpenTypeCIDFont *this)
{
  unsigned int v1 = (TSFNTOpenTypeCIDFont *)((char *)this + 488);
  CFMutableArrayRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  TSFNTFont::FillCharacterSet(v1, Mutable);
}

TSFNTFont *TSFNTOpenTypeCIDFont::GetOS2UnicodeRanges(TSFNTOpenTypeCIDFont *this, unsigned int a2, unsigned int *a3, __n128 a4)
{
  return TSFNTFont::GetOS2UnicodeRanges((TSFNTOpenTypeCIDFont *)((char *)this + 488), a2, a3, a4);
}

uint64_t TSFNTOpenTypeCIDFont::GetCharactersForGlyph(TSFNTOpenTypeCIDFont *this, unsigned __int16 a2, unsigned __int16 *a3, unint64_t a4)
{
  return TSFNTFont::GetCharactersForGlyph((TSFNTOpenTypeCIDFont *)((char *)this + 488), a2, a3, a4);
}

void TOpenTypeCIDDataForkFont::~TOpenTypeCIDDataForkFont(TOpenTypeCIDDataForkFont *this)
{
  *(void *)this = &unk_1F0DD4B80;
  *((void *)this + 2) = &unk_1F0DD4DC8;
  *((void *)this + 43) = &unk_1F0DD4DE8;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 94);
  TSFNTOpenTypeCIDFont::~TSFNTOpenTypeCIDFont(this);
}

{
  uint64_t vars8;

  TOpenTypeCIDDataForkFont::~TOpenTypeCIDDataForkFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeCIDDataForkFont::~TOpenTypeCIDDataForkFont(TOpenTypeCIDDataForkFont *this)
{
}

{
  TOpenTypeCIDDataForkFont::~TOpenTypeCIDDataForkFont((TOpenTypeCIDDataForkFont *)((char *)this - 344));
}

{
  uint64_t vars8;

  TOpenTypeCIDDataForkFont::~TOpenTypeCIDDataForkFont((TOpenTypeCIDDataForkFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

{
  uint64_t vars8;

  TOpenTypeCIDDataForkFont::~TOpenTypeCIDDataForkFont((TOpenTypeCIDDataForkFont *)((char *)this - 344));
  JUMPOUT(0x1BA9994D0);
}

uint64_t TOpenTypeCIDDataForkFont::GetRefCon(TOpenTypeCIDDataForkFont *this)
{
  return *((unsigned int *)this + 192);
}

void non-virtual thunk to'TOpenTypeCIDMemoryFont::~TOpenTypeCIDMemoryFont(TOpenTypeCIDMemoryFont *this)
{
}

{
  TOpenTypeCIDMemoryFont::~TOpenTypeCIDMemoryFont((TOpenTypeCIDMemoryFont *)((char *)this - 344));
}

{
  uint64_t vars8;

  TOpenTypeCIDMemoryFont::~TOpenTypeCIDMemoryFont((TOpenTypeCIDMemoryFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

{
  uint64_t vars8;

  TOpenTypeCIDMemoryFont::~TOpenTypeCIDMemoryFont((TOpenTypeCIDMemoryFont *)((char *)this - 344));
  JUMPOUT(0x1BA9994D0);
}

uint64_t TOpenTypeCIDMemoryFont::GetKind(TOpenTypeCIDMemoryFont *this)
{
  return 19;
}

uint64_t TOpenTypeCIDMemoryFont::GetFontRef(TOpenTypeCIDMemoryFont *this)
{
  return (uint64_t)this + 752;
}

void TSFNTOpenTypeCFF2Font::TSFNTOpenTypeCFF2Font(TSFNTOpenTypeCFF2Font *this, const TSFNTData *a2)
{
  __b[374] = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 36) = 0;
  *((void *)this + 37) = 0;
  *((void *)this + 40) = 0;
  *((void *)this + 41) = 0;
  *((unsigned char *)this + 336) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((_WORD *)this + 140) = 0;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(void *)this = &unk_1F0DD5540;
  uint64_t v4 = (TSFNTOpenTypeCFF2Font *)((char *)this + 344);
  *((void *)this + 2) = &unk_1F0DD5760;
  TSFNTFont::TSFNTFont((TSFNTOpenTypeCFF2Font *)((char *)this + 344), a2);
  *((void *)this + 68) = *((void *)a2 + 25);
  *((void *)this + 43) = &unk_1F0DFC430;
  *((void *)this + 45) = &unk_1F0DFC638;
  *((void *)this + 69) = this;
  TSFNTFont::GetTable(v4, 1128678962, 0, (void *)this + 70);
  *((_OWORD *)this + 37) = 0u;
  if (TSFNTFont::GetFormat(a2) == 1330926671)
  {
    *((unsigned char *)this + 336) = 1;
    *(void *)this = &unk_1F0E01FB0;
    *((void *)this + 2) = &unk_1F0E021E0;
    *((void *)this + 76) = 0;
    *((_WORD *)this + 308) = 0;
    *((void *)this + 78) = 0;
    *((void *)this + 80) = 0;
    *((void *)this + 79) = 0;
    memset(__b, 170, 0xBB0uLL);
    TSFNTType1CFFDescriptor::TSFNTType1CFFDescriptor((TSFNTType1CFFDescriptor *)__b, a2, 1128678962, 1);
    __b[0] = &unk_1F0E008E8;
    memset(v6, 170, sizeof(v6));
    TCFF2ParsingContext::TCFF2ParsingContext((TParsingContext *)v6, (const TDataReference *)&__b[369]);
  }
  exception = __cxa_allocate_exception(0x10uLL);
  *(void *)exception = &unk_1F0DD4440;
  exception[2] = 4;
}

void sub_1B52D5B64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  TDataReference::~TDataReference((TDataReference *)&a9);
  TCFF2ParsingContext::~TCFF2ParsingContext((TCFF2ParsingContext *)&a16);
  STACK[0x3F8] = (unint64_t)&unk_1F0DD9500;
  TDataReference::~TDataReference(v17);
  int v19 = v16 + 78;
  uint64_t v20 = v16[79];
  v16[79] = 0;
  if (v20) {
    MEMORY[0x1BA9994A0](v20, 0x1000C8052888210);
  }
  unint64_t v21 = v16 + 76;
  uint64_t v22 = *v19;
  *int v19 = 0;
  if (v22) {
    MEMORY[0x1BA9994A0](v22, 0x1000C8052888210);
  }
  uint64_t v23 = *v21;
  *unint64_t v21 = 0;
  if (v23) {
    std::default_delete<FDArrayEntity []>::operator()[abi:fe180100]<FDArrayEntity>((uint64_t)(v16 + 76), v23);
  }
  TSFNTOpenTypeFont::~TSFNTOpenTypeFont((TSFNTOpenTypeFont *)v16);
  _Unwind_Resume(a1);
}

void TSFNTOpenTypeCFF2Font::~TSFNTOpenTypeCFF2Font(TSFNTOpenTypeCFF2Font *this)
{
  *(void *)this = &unk_1F0E01FB0;
  *((void *)this + 2) = &unk_1F0E021E0;
  uint64_t v2 = *((void *)this + 79);
  *((void *)this + 79) = 0;
  if (v2) {
    MEMORY[0x1BA9994A0](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 78);
  *((void *)this + 78) = 0;
  if (v3) {
    MEMORY[0x1BA9994A0](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 76);
  *((void *)this + 76) = 0;
  if (v4) {
    std::default_delete<FDArrayEntity []>::operator()[abi:fe180100]<FDArrayEntity>((uint64_t)this + 608, v4);
  }
  TSFNTOpenTypeFont::~TSFNTOpenTypeFont(this);
}

uint64_t TSFNTOpenTypeCFF2Font::GetHorizontalMetrics(TSFNTOpenTypeCFF2Font *this, int *a2, int *a3, int *a4, int *a5, int *a6, int *a7, int *a8, int *a9, int *a10, BOOL *a11, BOOL *a12, double *a13, int *a14, int *a15, double *a16, double *a17, double *a18, double *a19, __int16 *a20,__int16 *a21)
{
  return TType1Font::GetHorizontalMetrics(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
           a20,
           a21);
}

uint64_t TSFNTOpenTypeCFF2Font::GetNumberOfGlyphs(TSFNTOpenTypeCFF2Font *this)
{
  return *((unsigned int *)this + 35);
}

uint64_t TSFNTOpenTypeCFF2Font::GetKind(TSFNTOpenTypeCFF2Font *this)
{
  return 33;
}

void TOpenTypeCFF2MemoryFont::TOpenTypeCFF2MemoryFont(TSFNTOpenTypeCFF2Font *a1, uint64_t a2)
{
  TSFNTFont::TSFNTFont((TSFNTFont *)v4);
  v4[0] = &unk_1F0DD6988;
  void v4[2] = &unk_1F0DD6B90;
  v4[25] = a2;
  TSFNTOpenTypeCFF2Font::TSFNTOpenTypeCFF2Font(a1, (const TSFNTData *)v4);
}

void sub_1B52D5ED4(_Unwind_Exception *a1)
{
  TInMemoryDataReference::~TInMemoryDataReference(v2);
  TSFNTOpenTypeCFF2Font::~TSFNTOpenTypeCFF2Font(v1);
  _Unwind_Resume(a1);
}

void TOpenTypeCFF2MemoryFont::~TOpenTypeCFF2MemoryFont(TOpenTypeCFF2MemoryFont *this)
{
  *(void *)this = &unk_1F0DFCD60;
  *((void *)this + 2) = &unk_1F0DFCF90;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeCFF2MemoryFont *)((char *)this + 648));
  TSFNTOpenTypeCFF2Font::~TSFNTOpenTypeCFF2Font(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DFCD60;
  *((void *)this + 2) = &unk_1F0DFCF90;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeCFF2MemoryFont *)((char *)this + 648));
  TSFNTOpenTypeCFF2Font::~TSFNTOpenTypeCFF2Font(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DFCD60;
  *((void *)this + 2) = &unk_1F0DFCF90;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeCFF2MemoryFont *)((char *)this + 648));
  TSFNTOpenTypeCFF2Font::~TSFNTOpenTypeCFF2Font(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeCFF2MemoryFont::~TOpenTypeCFF2MemoryFont(TOpenTypeCFF2MemoryFont *this)
{
  unsigned int v1 = (TOpenTypeCFF2MemoryFont *)((char *)this - 16);
  *((void *)this - 2) = &unk_1F0DFCD60;
  *(void *)this = &unk_1F0DFCF90;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeCFF2MemoryFont *)((char *)this + 632));
  TSFNTOpenTypeCFF2Font::~TSFNTOpenTypeCFF2Font(v1);
}

{
  TOpenTypeCFF2MemoryFont::~TOpenTypeCFF2MemoryFont((TOpenTypeCFF2MemoryFont *)((char *)this - 16));
}

uint64_t TOpenTypeCFF2MemoryFont::GetFontRef(TOpenTypeCFF2MemoryFont *this)
{
  return (uint64_t)this + 648;
}

void TOpenTypeCFF2WOFFFont::TOpenTypeCFF2WOFFFont(TOpenTypeCFF2WOFFFont *this, CFDataRef theData)
{
  CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  uint64_t v3 = &unk_1F0DD4120;
  operator new();
}

void sub_1B52D6248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  TOpenTypeCFF2MemoryFont::~TOpenTypeCFF2MemoryFont(v10);
  _Unwind_Resume(a1);
}

void TOpenTypeCFF2WOFFFont::~TOpenTypeCFF2WOFFFont(TOpenTypeCFF2WOFFFont *this)
{
  *(void *)this = &unk_1F0DFCFB0;
  *((void *)this + 2) = &unk_1F0DFD1E0;
  CFRelease(*((CFTypeRef *)this + 84));
  *(void *)this = &unk_1F0DFCD60;
  *((void *)this + 2) = &unk_1F0DFCF90;
  TInMemoryDataReference::~TInMemoryDataReference((TOpenTypeCFF2WOFFFont *)((char *)this + 648));
  TSFNTOpenTypeCFF2Font::~TSFNTOpenTypeCFF2Font(this);
}

{
  uint64_t vars8;

  TOpenTypeCFF2WOFFFont::~TOpenTypeCFF2WOFFFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeCFF2WOFFFont::~TOpenTypeCFF2WOFFFont(TOpenTypeCFF2WOFFFont *this)
{
}

{
  uint64_t vars8;

  TOpenTypeCFF2WOFFFont::~TOpenTypeCFF2WOFFFont((TOpenTypeCFF2WOFFFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

void TOpenTypeCFF2DataForkFont::TOpenTypeCFF2DataForkFont(TOpenTypeCFF2DataForkFont *this, const TFileDataSurrogate *a2)
{
  TSFNTFont::TSFNTFont((TSFNTFont *)v4);
  v4[0] = &unk_1F0DD6988;
  void v4[2] = &unk_1F0DD6B90;
  v4[25] = a2;
  TSFNTOpenTypeCFF2Font::TSFNTOpenTypeCFF2Font(this, (const TSFNTData *)v4);
}

void sub_1B52D6530(_Unwind_Exception *a1)
{
  TFileDataSurrogate::~TFileDataSurrogate(v2);
  TSFNTOpenTypeCFF2Font::~TSFNTOpenTypeCFF2Font(v1);
  _Unwind_Resume(a1);
}

void TOpenTypeCFF2DataForkFont::~TOpenTypeCFF2DataForkFont(TOpenTypeCFF2DataForkFont *this)
{
  *(void *)this = &unk_1F0DFD200;
  *((void *)this + 2) = &unk_1F0DFD430;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 81);
  TSFNTOpenTypeCFF2Font::~TSFNTOpenTypeCFF2Font(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DFD200;
  *((void *)this + 2) = &unk_1F0DFD430;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 81);
  TSFNTOpenTypeCFF2Font::~TSFNTOpenTypeCFF2Font(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TOpenTypeCFF2DataForkFont::~TOpenTypeCFF2DataForkFont(TOpenTypeCFF2DataForkFont *this)
{
  unsigned int v1 = (TOpenTypeCFF2DataForkFont *)((char *)this - 16);
  *((void *)this - 2) = &unk_1F0DFD200;
  *(void *)this = &unk_1F0DFD430;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 79);
  TSFNTOpenTypeCFF2Font::~TSFNTOpenTypeCFF2Font(v1);
}

{
  TOpenTypeCFF2DataForkFont::~TOpenTypeCFF2DataForkFont((TOpenTypeCFF2DataForkFont *)((char *)this - 16));
}

uint64_t TOpenTypeCFF2DataForkFont::GetFontRef(TOpenTypeCFF2DataForkFont *this)
{
  return (uint64_t)this + 648;
}

uint64_t TSFNTOpenTypeCFF2Font::GetFDIndexCFF2(TSFNTOpenTypeCFF2Font *this, unsigned int a2)
{
  if (*((_DWORD *)this + 35) <= a2) {
    goto LABEL_34;
  }
  if (*((_DWORD *)this + 161))
  {
    *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v29 = v3;
    long long v30 = v3;
    (*(void (**)(long long *__return_ptr))(*(void *)this + 520))(&v29);
    if (!*((void *)&v29 + 1) || (uint64_t v4 = *(void *)(*((void *)&v29 + 1) + 8)) == 0)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 4;
    }
    long long v5 = (unsigned __int8 *)(v4 + v30);
    int v6 = *v5;
    if (!*v5)
    {
      uint64_t v15 = v5[a2 + 1];
LABEL_30:
      TDataReference::~TDataReference((TDataReference *)&v29);
      return v15;
    }
    if (v6 == 3)
    {
      unsigned int v16 = *(unsigned __int16 *)(v5 + 1);
      unint64_t v17 = __rev16(v16);
      int v18 = v5 + 3;
      if (v16)
      {
        int v19 = v18;
        do
        {
          unint64_t v20 = v17 >> 1;
          unint64_t v21 = &v19[3 * (v17 >> 1)];
          unsigned int v23 = *(unsigned __int16 *)v21;
          uint64_t v22 = (char *)(v21 + 3);
          v17 += ~(v17 >> 1);
          if (bswap32(v23) >> 16 > (unsigned __int16)a2) {
            unint64_t v17 = v20;
          }
          else {
            int v19 = (unsigned __int8 *)v22;
          }
        }
        while (v17);
      }
      else
      {
        int v19 = &v18[2 * v17 + v17];
      }
      if (v19 == v18)
      {
        unsigned int v27 = __cxa_allocate_exception(0x10uLL);
        *(void *)unsigned int v27 = &unk_1F0DD4440;
        v27[2] = 4;
      }
      uint64_t v15 = *(v19 - 1);
      goto LABEL_30;
    }
    if (v6 == 4)
    {
      unsigned int v7 = *(_DWORD *)(v5 + 1);
      unint64_t v8 = bswap32(v7);
      long long v9 = v5 + 5;
      if (v7)
      {
        long long v10 = v9;
        do
        {
          unint64_t v11 = v8 >> 1;
          int v12 = (unsigned int *)&v10[6 * (v8 >> 1)];
          unsigned int v14 = *v12;
          unsigned __int16 v13 = (char *)v12 + 6;
          v8 += ~(v8 >> 1);
          if (bswap32(v14) > (unsigned __int16)a2) {
            unint64_t v8 = v11;
          }
          else {
            long long v10 = (unsigned __int8 *)v13;
          }
        }
        while (v8);
      }
      else
      {
        long long v10 = &v9[6 * v8];
      }
      if (v10 == v9)
      {
        int v28 = __cxa_allocate_exception(0x10uLL);
        *(void *)int v28 = &unk_1F0DD4440;
        v28[2] = 4;
      }
      uint64_t v15 = bswap32(*((unsigned __int16 *)v10 - 1)) >> 16;
      goto LABEL_30;
    }
    TDataReference::~TDataReference((TDataReference *)&v29);
LABEL_34:
    uint64_t v26 = __cxa_allocate_exception(0x10uLL);
    *(void *)uint64_t v26 = &unk_1F0DD4440;
    _OWORD v26[2] = 4;
  }
  return 0;
}

void sub_1B52D69B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TSFNTOpenTypeCFF2Font::GetLocalSubrOffsetsAndData(TSFNTOpenTypeCFF2Font *this, unsigned int a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5, TDataReference *a6, TDataReference *a7)
{
  if ((int)a2 >= *((__int16 *)this + 308)) {
    goto LABEL_31;
  }
  uint64_t v8 = *((void *)this + 76);
  int v9 = *(unsigned __int16 *)(v8 + 488 * a2 + 4);
  *a3 = v9;
  if (!v9) {
    return 0;
  }
  uint64_t v13 = a2;
  uint64_t v14 = v8 + 488 * a2;
  *a4 = *(_WORD *)(v14 + 2);
  unsigned int v15 = *a3;
  if (v15 >= 0x846C) {
    __int16 v16 = 0x8000;
  }
  else {
    __int16 v16 = 1131;
  }
  if (v15 >= 0x4D8) {
    unsigned __int16 v17 = v16;
  }
  else {
    unsigned __int16 v17 = 107;
  }
  *a5 = v17;
  uint64_t v18 = *a4 + *a4 * *a3;
  (*(void (**)(long long *__return_ptr, TSFNTOpenTypeCFF2Font *, void, uint64_t))(*(void *)this + 520))(&v39, this, *(unsigned int *)(v14 + 8), v18);
  if (&v39 != (long long *)a6)
  {
    TDataReference::DucRefCount(a6);
    uint64_t v19 = *((void *)&v39 + 1);
    *((void *)&v39 + 1) = 0;
    *((void *)a6 + 1) = v19;
    *((_OWORD *)a6 + 1) = v40;
  }
  TDataReference::~TDataReference((TDataReference *)&v39);
  uint64_t v20 = *((void *)a6 + 1);
  if (!v20) {
    goto LABEL_31;
  }
  uint64_t v21 = *(void *)(v20 + 8);
  if (!v21) {
    goto LABEL_31;
  }
  unsigned int v22 = 0;
  unsigned int v23 = (unsigned __int8 *)(v21 + *((void *)a6 + 2));
  uint64_t v24 = *a4;
  int v25 = v23;
  switch(*a4)
  {
    case 1u:
      goto LABEL_17;
    case 2u:
      goto LABEL_16;
    case 3u:
      goto LABEL_15;
    case 4u:
      int v25 = v23 + 1;
      unsigned int v22 = *v23 << 8;
LABEL_15:
      int v26 = *v25++;
      unsigned int v22 = (v22 | v26) << 8;
LABEL_16:
      int v27 = *v25++;
      unsigned int v22 = (v22 | v27) << 8;
LABEL_17:
      v22 |= *v25;
      break;
    default:
      break;
  }
  unsigned int v28 = 0;
  int v29 = v24 - 1;
  long long v30 = &v23[v18 - v24];
  switch(v29)
  {
    case 0:
      goto LABEL_22;
    case 1:
      goto LABEL_21;
    case 2:
      goto LABEL_20;
    case 3:
      int v31 = *v30++;
      unsigned int v28 = v31 << 8;
LABEL_20:
      int v32 = *v30++;
      unsigned int v28 = (v28 | v32) << 8;
LABEL_21:
      int v33 = *v30++;
      unsigned int v28 = (v28 | v33) << 8;
LABEL_22:
      v28 |= *v30;
      break;
    default:
      break;
  }
  if (!v22 || (uint64_t v34 = v28 - v22, v28 <= v22))
  {
LABEL_31:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  *(void *)&long long v35 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v39 = v35;
  long long v40 = v35;
  (*(void (**)(long long *__return_ptr, TSFNTOpenTypeCFF2Font *, void, uint64_t))(*(void *)this + 520))(&v39, this, *(unsigned int *)(*((void *)this + 79) + 4 * v13), v34);
  if (!*((void *)&v39 + 1) || !*(void *)(*((void *)&v39 + 1) + 8))
  {
    TDataReference::~TDataReference((TDataReference *)&v39);
    goto LABEL_31;
  }
  TDataReference::operator=(a7, (uint64_t)&v39);
  uint64_t v36 = (v34 + v18);
  TDataReference::~TDataReference((TDataReference *)&v39);
  return v36;
}

void sub_1B52D6CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ReadTypeInc<unsigned char>(TDataReference *a1)
{
  uint64_t v2 = *((void *)a1 + 2);
  uint64_t v1 = *((void *)a1 + 3);
  if (v1 == v2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  uint64_t v4 = *(unsigned __int8 *)(*(void *)(*((void *)a1 + 1) + 8) + v2);
  TDataReference::SubdataFrom(a1, 1, v1 + ~v2, &v8);
  if (&v8 != (uint64_t *)a1)
  {
    TDataReference::DucRefCount(a1);
    uint64_t v5 = v9;
    uint64_t v9 = 0;
    *((void *)a1 + 1) = v5;
    *((_OWORD *)a1 + 1) = v10;
  }
  TDataReference::~TDataReference((TDataReference *)&v8);
  return v4;
}

void sub_1B52D6DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ReadTypeInc<unsigned short>(TDataReference *a1)
{
  uint64_t v1 = *((void *)a1 + 2);
  unint64_t v2 = *((void *)a1 + 3) - v1;
  if (v2 <= 1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  uint64_t v4 = (unsigned __int8 *)(*(void *)(*((void *)a1 + 1) + 8) + v1);
  int v5 = *v4;
  int v6 = v4[1];
  TDataReference::SubdataFrom(a1, 2, v2 - 2, &v10);
  if (&v10 != (uint64_t *)a1)
  {
    TDataReference::DucRefCount(a1);
    uint64_t v7 = v11;
    uint64_t v11 = 0;
    *((void *)a1 + 1) = v7;
    *((_OWORD *)a1 + 1) = v12;
  }
  TDataReference::~TDataReference((TDataReference *)&v10);
  return v6 | (v5 << 8);
}

void sub_1B52D6EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TOpenTypeCIDFont::GetLocalSubrOffsetsAndData(TOpenTypeCIDFont *this, unsigned int a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5, TDataReference *a6, TDataReference *a7)
{
  if ((int)a2 >= *((__int16 *)this + 181)) {
    goto LABEL_31;
  }
  uint64_t v8 = *((void *)this + 50);
  int v9 = *(unsigned __int16 *)(v8 + 488 * a2 + 4);
  *a3 = v9;
  if (!v9) {
    return 0;
  }
  uint64_t v13 = a2;
  *a4 = *(_WORD *)(v8 + 488 * a2 + 2);
  unsigned int v14 = *a3;
  if (v14 >= 0x846C) {
    __int16 v15 = 0x8000;
  }
  else {
    __int16 v15 = 1131;
  }
  if (v14 >= 0x4D8) {
    unsigned __int16 v16 = v15;
  }
  else {
    unsigned __int16 v16 = 107;
  }
  *a5 = v16;
  uint64_t v17 = *a4 + *a4 * *a3;
  (*(void (**)(long long *__return_ptr, TOpenTypeCIDFont *, void, uint64_t))(*(void *)this + 520))(&v38, this, *(unsigned int *)(*((void *)this + 55) + 4 * a2), v17);
  if (&v38 != (long long *)a6)
  {
    TDataReference::DucRefCount(a6);
    uint64_t v18 = *((void *)&v38 + 1);
    *((void *)&v38 + 1) = 0;
    *((void *)a6 + 1) = v18;
    *((_OWORD *)a6 + 1) = v39;
  }
  TDataReference::~TDataReference((TDataReference *)&v38);
  uint64_t v19 = *((void *)a6 + 1);
  if (!v19) {
    goto LABEL_31;
  }
  uint64_t v20 = *(void *)(v19 + 8);
  if (!v20) {
    goto LABEL_31;
  }
  unsigned int v21 = 0;
  unsigned int v22 = (unsigned __int8 *)(v20 + *((void *)a6 + 2));
  uint64_t v23 = *a4;
  uint64_t v24 = v22;
  switch(*a4)
  {
    case 1u:
      goto LABEL_17;
    case 2u:
      goto LABEL_16;
    case 3u:
      goto LABEL_15;
    case 4u:
      uint64_t v24 = v22 + 1;
      unsigned int v21 = *v22 << 8;
LABEL_15:
      int v25 = *v24++;
      unsigned int v21 = (v21 | v25) << 8;
LABEL_16:
      int v26 = *v24++;
      unsigned int v21 = (v21 | v26) << 8;
LABEL_17:
      v21 |= *v24;
      break;
    default:
      break;
  }
  unsigned int v27 = 0;
  int v28 = v23 - 1;
  int v29 = &v22[v17 - v23];
  switch(v28)
  {
    case 0:
      goto LABEL_22;
    case 1:
      goto LABEL_21;
    case 2:
      goto LABEL_20;
    case 3:
      int v30 = *v29++;
      unsigned int v27 = v30 << 8;
LABEL_20:
      int v31 = *v29++;
      unsigned int v27 = (v27 | v31) << 8;
LABEL_21:
      int v32 = *v29++;
      unsigned int v27 = (v27 | v32) << 8;
LABEL_22:
      v27 |= *v29;
      break;
    default:
      break;
  }
  if (!v21 || (uint64_t v33 = v27 - v21, v27 <= v21))
  {
LABEL_31:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  *(void *)&long long v34 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v38 = v34;
  long long v39 = v34;
  (*(void (**)(long long *__return_ptr, TOpenTypeCIDFont *, void, uint64_t))(*(void *)this + 520))(&v38, this, *(unsigned int *)(*((void *)this + 56) + 4 * v13), v33);
  if (!*((void *)&v38 + 1) || !*(void *)(*((void *)&v38 + 1) + 8))
  {
    TDataReference::~TDataReference((TDataReference *)&v38);
    goto LABEL_31;
  }
  TDataReference::operator=(a7, (uint64_t)&v38);
  uint64_t v35 = (v33 + v17);
  TDataReference::~TDataReference((TDataReference *)&v38);
  return v35;
}

void sub_1B52D71DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TOpenTypeCIDFont::GetCIDSubrData(TOpenTypeCIDFont *this, unsigned __int16 a2, unsigned __int16 *a3, unsigned __int16 *a4, unint64_t *a5)
{
  __int16 v11 = -21846;
  uint64_t v9 = (*(uint64_t (**)(TOpenTypeCIDFont *))(*(void *)this + 552))(this);
  return (*(uint64_t (**)(TOpenTypeCIDFont *, uint64_t, unsigned __int16 *, unsigned __int16 *, __int16 *, unint64_t *))(*(void *)this + 536))(this, v9, a3, a4, &v11, a5);
}

uint64_t non-virtual thunk to'TOpenTypeCIDFont::GetCIDSubrData(TOpenTypeCIDFont *this, unsigned __int16 a2, unsigned __int16 *a3, unsigned __int16 *a4, unint64_t *a5)
{
  uint64_t v8 = (char *)this - 344;
  __int16 v11 = -21846;
  uint64_t v9 = (*(uint64_t (**)(char *))(*((void *)this - 43) + 552))((char *)this - 344);
  return (*(uint64_t (**)(char *, uint64_t, unsigned __int16 *, unsigned __int16 *, __int16 *, unint64_t *))(*(void *)v8 + 536))(v8, v9, a3, a4, &v11, a5);
}

void TOpenTypeCIDFont::GetCharString(TOpenTypeCIDFont *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if ((2 * *((_DWORD *)this + 89)) > 8)
  {
LABEL_19:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v20 = v6;
  long long v21 = v6;
  (*(void (**)(long long *__return_ptr))(*(void *)this + 520))(&v20);
  if (!*((void *)&v20 + 1) || (uint64_t v7 = *(void *)(*((void *)&v20 + 1) + 8)) == 0)
  {
    TDataReference::~TDataReference((TDataReference *)&v20);
    goto LABEL_19;
  }
  int v8 = 0;
  uint64_t v9 = (unsigned __int8 *)(v7 + v21);
  switch((unsigned __int16)*((_DWORD *)this + 89))
  {
    case 1u:
      goto LABEL_8;
    case 2u:
      goto LABEL_7;
    case 3u:
      goto LABEL_6;
    case 4u:
      int v10 = *v9++;
      int v8 = v10 << 8;
LABEL_6:
      int v11 = *v9++;
      int v8 = (v8 | v11) << 8;
LABEL_7:
      int v12 = *v9++;
      int v8 = (v8 | v12) << 8;
LABEL_8:
      int v13 = *v9++;
      v8 |= v13;
      break;
    default:
      break;
  }
  int v14 = 0;
  switch((unsigned __int16)*((_DWORD *)this + 89))
  {
    case 1u:
      goto LABEL_13;
    case 2u:
      goto LABEL_12;
    case 3u:
      goto LABEL_11;
    case 4u:
      int v15 = *v9++;
      int v14 = v15 << 8;
LABEL_11:
      int v16 = *v9++;
      int v14 = (v14 | v16) << 8;
LABEL_12:
      int v17 = *v9++;
      int v14 = (v14 | v17) << 8;
LABEL_13:
      v14 |= *v9;
      break;
    default:
      break;
  }
  if (v14 - v8 < 1)
  {
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = &unk_1F0DFF650;
    *(_DWORD *)(a3 + 24) = 0;
    *(unsigned char *)(a3 + 28) = 0;
    *(void *)(a3 + 32) = &unk_1F0DD4218;
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 48) = 0;
    *(void *)(a3 + 56) = 0;
  }
  else
  {
    (*(void (**)(void *__return_ptr, TOpenTypeCIDFont *, void))(*(void *)this + 520))(v19, this, (v8 + *((_DWORD *)this + 91) - 1));
    TCharString::TCharString((TCharString *)a3, a2, (const TDataReference *)v19);
    TDataReference::~TDataReference((TDataReference *)v19);
  }
  TDataReference::~TDataReference((TDataReference *)&v20);
}

void sub_1B52D7600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t TOpenTypeFont::GetSFNTFont(TOpenTypeFont *this)
{
  return 0;
}

uint64_t TType1Font::GetHFMX(TType1Font *this)
{
  return 0;
}

uint64_t TOpenTypeCIDFont::GetStringBuffer(TOpenTypeCIDFont *this)
{
  return *((void *)this + 6);
}

uint64_t non-virtual thunk to'TOpenTypeCIDFont::GetStringBuffer(TOpenTypeCIDFont *this)
{
  return *((void *)this - 37);
}

uint64_t TSFNTOpenTypeFont::GetSFNTFont(TSFNTOpenTypeFont *this)
{
  return (uint64_t)this + 344;
}

void TSFNTOpenTypeFont::FindFontMetaData(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t TSFNTOpenTypeCIDFont::GetSFNTFont(TSFNTOpenTypeCIDFont *this)
{
  return (uint64_t)this + 488;
}

void TSFNTOpenTypeCIDFont::FindFontMetaData(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t TSFNTOpenTypeCFF2Font::GetInstanceNames(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 432))(a1) + 96);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetAscent(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 184);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetDescent(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 192);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetLineGap(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 200);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetMaxAdvance(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 208);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetAvgAdvance(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 216);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetXHeight(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 224);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetCapHeight(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 232);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetMinLeftSideBearing(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 240);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetMinRightSideBearing(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 248);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetStemH(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 256);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetStemV(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 264);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetCaretInfo(TSFNTOpenTypeCFF2Font *this, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 272);
  return v4();
}

uint64_t TSFNTOpenTypeCFF2Font::GetBounds(TSFNTOpenTypeCFF2Font *this, double *a2, double *a3, double *a4, double *a5)
{
  int v5 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 280);
  return v5();
}

uint64_t TSFNTOpenTypeCFF2Font::GetItalicAngle(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 288);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetUnderlinePosition(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 296);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetUnderlineThickness(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 304);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::IsMonospaced(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 312);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::IsItalic(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 320);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetVerticalMetrics(TSFNTOpenTypeCFF2Font *this, int *a2, int *a3, int *a4, int *a5, int *a6, int *a7, int *a8, int *a9, double *a10, double *a11, double *a12, double *a13)
{
  uint64_t v17 = (*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this);
  uint64_t v18 = *(uint64_t (**)(uint64_t, int *, int *, int *, int *))(*(void *)v17 + 328);
  return v18(v17, a2, a3, a4, a5);
}

uint64_t TSFNTOpenTypeCFF2Font::GetGlyphName(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 336);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::VerifyGlyphName(TSFNTOpenTypeCFF2Font *this, unsigned int a2, const char *a3)
{
  long long v3 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 344);
  return v3();
}

uint64_t TSFNTOpenTypeCFF2Font::GetGlyphID(TSFNTOpenTypeCFF2Font *this, const char *a2)
{
  unint64_t v2 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 352);
  return v2();
}

uint64_t TSFNTOpenTypeCFF2Font::GetVariationAxes(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 432))(a1) + 392);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetVariationInstances(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 432))(a1) + 400);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::Normalize(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 432))(a1) + 408);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetPostScriptNameSuffixForVariation(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 432))(a1) + 416);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GotTable(TSFNTOpenTypeCFF2Font *this)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 472);
  return v1();
}

uint64_t TSFNTOpenTypeCFF2Font::GetTable(TSFNTOpenTypeCFF2Font *this, unsigned int a2, unint64_t *a3)
{
  long long v3 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(TSFNTOpenTypeCFF2Font *))(*(void *)this + 432))(this)
                           + 480);
  return v3();
}

void std::vector<int,TInlineBufferAllocator<int,3ul>>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    long long v3 = (void **)((char *)v1 + 36);
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[5]) {
        v1[5] = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::default_delete<FDArrayEntity []>::operator()[abi:fe180100]<FDArrayEntity>(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 - 8);
    if (v2)
    {
      uint64_t v3 = a2 - 472;
      uint64_t v4 = 488 * v2;
      do
      {
        free(*(void **)(v3 + v4));
        v4 -= 488;
      }
      while (v4);
    }
    JUMPOUT(0x1BA9994A0);
  }
}

uint64_t TTPerformStreamingTypeQuery(uint64_t a1, unsigned int *a2)
{
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v14 = v3;
  long long v15 = v3;
  long long v12 = v3;
  long long v13 = v3;
  cacheCallContext::cacheCallContext((cacheCallContext *)&v12, *(const TFont **)(a1 + 64), 0, 0);
  uint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  CreateFontCacheNode(*((const TFont **)&v13 + 1), &v11);
  uint64_t v4 = v11;
  if (v11)
  {
    memset(__b, 170, sizeof(__b));
    memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)&v12);
    _DWORD v9[5] = 0xAAAAAAAAAAAAAAAALL;
    v9[8] = 0xAAAAAAAAAA000000;
    v9[0] = __b;
    v9[1] = 1358921729;
    _OWORD v9[2] = 1358921729;
    v9[3] = 1358921729;
    void v9[4] = 0;
    v9[6] = 1358921729;
    v9[7] = 1358921729;
    AssureScalerFontBlock(v9, (memoryContext *)__b, v4);
    ++*(_WORD *)(v4 + 16);
    int v5 = SelectStreamType((uint64_t)v9, (uint64_t)__b, a2);
    __int16 v6 = v5;
    if (!v5) {
      --*(_WORD *)(v4 + 16);
    }
    memoryContext::~memoryContext((memoryContext *)__b);
    uint64_t v7 = *(void *)(v4 + 8);
    if (v7) {
      free((void *)(v7 - 8));
    }
    MEMORY[0x1BA9994D0](v4, 0x1080C40587D25DELL);
  }
  else
  {
    __int16 v6 = 20;
  }
  UnCacheCurrentGlyph((cacheCallContext *)&v12);
  return v6;
}

void sub_1B52D87B4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  memoryContext::~memoryContext((memoryContext *)va);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    if (!*(void *)(v12 - 104)) {
      JUMPOUT(0x1B52D8794);
    }
    JUMPOUT(0x1B52D8764);
  }
  std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100]((uint64_t *)(v12 - 104), 0);
  UnCacheCurrentGlyph((cacheCallContext *)(v12 - 96));
  _Unwind_Resume(a1);
}

uint64_t TTPerformStreamingSizeQuery()
{
  return 1;
}

uint64_t TTPerformPrerequisiteQuery(uint64_t a1, unsigned int *a2, void *a3, int a4, _DWORD *a5)
{
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v28 = v8;
  long long v29 = v8;
  long long v26 = v8;
  long long v27 = v8;
  cacheCallContext::cacheCallContext((cacheCallContext *)&v26, *(const TFont **)(a1 + 64), a3, a4);
  uint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  CreateFontCacheNode(*((const TFont **)&v27 + 1), &v25);
  uint64_t v9 = v25;
  if (!v25)
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 20;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  memset(__b, 170, sizeof(__b));
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)&v26);
  v23[5] = 0xAAAAAAAAAAAAAAAALL;
  v23[8] = 0xAAAAAAAAAA000000;
  v23[0] = __b;
  v23[1] = 1358921729;
  v23[2] = 1358921729;
  v23[3] = 1358921729;
  _OWORD v23[4] = 0;
  v23[6] = 1358921729;
  unsigned char v23[7] = 1358921729;
  AssureScalerFontBlock(v23, (memoryContext *)__b, v9);
  __int16 v10 = *(_WORD *)(v9 + 16);
  *(_WORD *)(v9 + 16) = v10 + 1;
  int v22 = -1431655766;
  unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  v17[0] = *a2;
  v17[1] = 0;
  unsigned int v11 = *(_DWORD *)(a1 + 24);
  v17[2] = 0;
  unsigned char v17[3] = v11;
  uint64_t v18 = *(void *)(a1 + 32);
  int v19 = 0;
  uint64_t v20 = *((void *)&v28 + 1);
  int v12 = SelectStreamType((uint64_t)v23, (uint64_t)__b, v17);
  __int16 v13 = v12;
  if (!v12)
  {
    *a2 = v17[0];
    *a5 = 0;
    *(_WORD *)(v9 + 16) = v10;
  }
  memoryContext::~memoryContext((memoryContext *)__b);
  uint64_t v14 = *(void *)(v9 + 8);
  if (v14) {
    free((void *)(v14 - 8));
  }
  MEMORY[0x1BA9994D0](v9, 0x1080C40587D25DELL);
  UnCacheCurrentGlyph((cacheCallContext *)&v26);
  return v13;
}

void sub_1B52D89F0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  memoryContext::~memoryContext((memoryContext *)&a27);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    if (!*(void *)(v27 - 120)) {
      JUMPOUT(0x1B52D89A4);
    }
    JUMPOUT(0x1B52D897CLL);
  }
  std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100]((uint64_t *)(v27 - 120), 0);
  UnCacheCurrentGlyph((cacheCallContext *)(v27 - 112));
  _Unwind_Resume(a1);
}

uint64_t TTPerformStreamVariationQuery(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4)
{
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v40 = v8;
  long long v41 = v8;
  long long v38 = v8;
  long long v39 = v8;
  cacheCallContext::cacheCallContext((cacheCallContext *)&v38, *(const TFont **)(a1 + 64), 0, 0);
  uint64_t v37 = 0xAAAAAAAAAAAAAAAALL;
  CreateFontCacheNode(*((const TFont **)&v39 + 1), &v37);
  uint64_t v9 = v37;
  if (!v37)
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 20;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  memset(__b, 170, sizeof(__b));
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)&v38);
  unint64_t v35 = 0xAAAAAAAAAA000000;
  unint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v27 = __b;
  uint64_t v28 = 1358921729;
  uint64_t v29 = 1358921729;
  uint64_t v30 = 1358921729;
  uint64_t v31 = 0;
  uint64_t v33 = 1358921729;
  uint64_t v34 = 1358921729;
  AssureScalerFontBlock(&v27, (memoryContext *)__b, v9);
  ++*(_WORD *)(v9 + 16);
  int v10 = *a2;
  v18[0] = 0;
  v18[1] = a3;
  int v19 = v10;
  int v20 = 0;
  int v11 = *(_DWORD *)(a1 + 24);
  int v21 = 0;
  int v22 = v11;
  uint64_t v23 = *(void *)(a1 + 32);
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  memset(v17, 170, sizeof(v17));
  TStreamerContext::TStreamerContext(v17, (uint64_t)&v27, (memoryContext *)__b, (uint64_t)v18);
  BOOL v12 = (v19 & 1) == 0 && *(unsigned char *)(v28 + 155);
  LODWORD(v24) = v12;
  TStreamerContext::~TStreamerContext((TStreamerContext *)v17);
  int v13 = v24;
  *a2 = v19;
  *a4 = v13;
  --*(_WORD *)(v9 + 16);
  memoryContext::~memoryContext((memoryContext *)__b);
  uint64_t v14 = *(void *)(v9 + 8);
  if (v14) {
    free((void *)(v14 - 8));
  }
  MEMORY[0x1BA9994D0](v9, 0x1080C40587D25DELL);
  UnCacheCurrentGlyph((cacheCallContext *)&v38);
  return 0;
}

void sub_1B52D8C68(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  memoryContext::~memoryContext((memoryContext *)&a29);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    if (!*(void *)(v29 - 136)) {
      JUMPOUT(0x1B52D8C1CLL);
    }
    JUMPOUT(0x1B52D8BF4);
  }
  std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100]((uint64_t *)(v29 - 136), 0);
  UnCacheCurrentGlyph((cacheCallContext *)(v29 - 128));
  _Unwind_Resume(a1);
}

uint64_t TTPerformStreamingPSPrereqItem(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int a5)
{
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v25 = v8;
  long long v26 = v8;
  long long v23 = v8;
  long long v24 = v8;
  cacheCallContext::cacheCallContext((cacheCallContext *)&v23, *(const TFont **)(a1 + 64), 0, 0);
  uint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  CreateFontCacheNode(*((const TFont **)&v24 + 1), &v22);
  uint64_t v9 = v22;
  if (v22)
  {
    BYTE12(v26) = 1;
    memset(__b, 170, sizeof(__b));
    memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)&v23);
    v20[5] = 0xAAAAAAAAAAAAAAAALL;
    v20[8] = 0xAAAAAAAAAA000000;
    v20[0] = __b;
    v20[1] = 1358921729;
    v20[2] = 1358921729;
    v20[3] = 1358921729;
    _OWORD v20[4] = 0;
    v20[6] = 1358921729;
    v20[7] = 1358921729;
    AssureScalerFontBlock(v20, (memoryContext *)__b, v9);
    __int16 v10 = *(_WORD *)(v9 + 16);
    *(_WORD *)(v9 + 16) = v10 + 1;
    unsigned int v11 = *a2;
    unsigned int v12 = *(_DWORD *)(a1 + 24);
    v17[2] = 0;
    unsigned char v17[3] = v12;
    v17[0] = v11;
    v17[1] = 0;
    uint64_t v18 = *(void *)(a1 + 32);
    memset(&v19[4], 170, 20);
    *(_DWORD *)int v19 = a5;
    int v13 = SelectStreamType((uint64_t)v20, (uint64_t)__b, v17);
    __int16 v14 = v13;
    if (!v13)
    {
      *a2 = v17[0];
      *(_WORD *)(v9 + 16) = v10;
    }
    memoryContext::~memoryContext((memoryContext *)__b);
    uint64_t v15 = *(void *)(v9 + 8);
    if (v15) {
      free((void *)(v15 - 8));
    }
    MEMORY[0x1BA9994D0](v9, 0x1080C40587D25DELL);
  }
  else
  {
    __int16 v14 = 20;
  }
  UnCacheCurrentGlyph((cacheCallContext *)&v23);
  return v14;
}

void sub_1B52D8E94(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  memoryContext::~memoryContext((memoryContext *)&a27);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    if (!*(void *)(v27 - 136)) {
      JUMPOUT(0x1B52D8E6CLL);
    }
    JUMPOUT(0x1B52D8E3CLL);
  }
  std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100]((uint64_t *)(v27 - 136), 0);
  UnCacheCurrentGlyph((cacheCallContext *)(v27 - 128));
  _Unwind_Resume(a1);
}

uint64_t TTPerformStreamingPSVariationOperator(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v31 = v6;
  long long v32 = v6;
  long long v29 = v6;
  long long v30 = v6;
  cacheCallContext::cacheCallContext((cacheCallContext *)&v29, *(const TFont **)(a1 + 64), 0, 0);
  uint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
  CreateFontCacheNode(*((const TFont **)&v30 + 1), &v28);
  uint64_t v7 = v28;
  if (v28)
  {
    ++*(_WORD *)(v28 + 16);
    BYTE12(v32) = 1;
    memset(__b, 170, sizeof(__b));
    memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)&v29);
    *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v26 = v8;
    long long v25 = v8;
    WORD4(v26) = 0;
    BYTE10(v26) = 0;
    _OWORD v24[2] = (memoryContext *)1358921729;
    int32x2_t v24[3] = (memoryContext *)1358921729;
    v24[4] = 0;
    uint64_t v9 = *(unsigned int **)(v7 + 8);
    v24[0] = (memoryContext *)__b;
    v24[1] = (memoryContext *)v9;
    *((void *)&v25 + 1) = (char *)v9 + v9[1];
    *(void *)&long long v26 = (char *)v9 + v9[2];
    LODWORD(v9) = *a2;
    v15[0] = a3;
    v15[1] = 0;
    int v16 = (int)v9;
    int v17 = 0;
    LODWORD(v9) = *(_DWORD *)(a1 + 24);
    int v18 = 0;
    int v19 = (int)v9;
    uint64_t v20 = *(void *)(a1 + 32);
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    memset(v14, 170, sizeof(v14));
    TStreamerContext::TStreamerContext(v14, (uint64_t)v24, (memoryContext *)__b, (uint64_t)v15);
    if (v16)
    {
      __int16 v10 = ScalerNewScratch((memoryContext *)__b, 0x20030u, 0);
      *((_DWORD *)v10 + 32778) = 0;
      *__int16 v10 = (size_t)__b;
      v10[1] = (size_t)v15;
      v10[2] = 0;
      _OWORD v10[3] = (size_t)(v10 + 5);
      void v10[4] = (size_t)(v10 + 5);
      StreamVariationPSOperator(v24, (uint64_t)v10);
      DisposeStreamBuffer(v10);
    }
    TStreamerContext::~TStreamerContext((TStreamerContext *)v14);
    *a2 = v16;
    memoryContext::~memoryContext((memoryContext *)__b);
    __int16 v11 = 0;
    --*(_WORD *)(v7 + 16);
    uint64_t v12 = *(void *)(v7 + 8);
    if (v12) {
      free((void *)(v12 - 8));
    }
    MEMORY[0x1BA9994D0](v7, 0x1080C40587D25DELL);
  }
  else
  {
    __int16 v11 = 20;
  }
  UnCacheCurrentGlyph((cacheCallContext *)&v29);
  return v11;
}

void sub_1B52D911C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  memoryContext::~memoryContext((memoryContext *)&a29);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1B52D90BCLL);
  }
  std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100]((uint64_t *)(v29 - 120), 0);
  UnCacheCurrentGlyph((cacheCallContext *)(v29 - 112));
  _Unwind_Resume(a1);
}

uint64_t TTPerformStreamingPSEncoding(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v36 = v10;
  long long v37 = v10;
  long long v34 = v10;
  long long v35 = v10;
  cacheCallContext::cacheCallContext((cacheCallContext *)&v34, *(const TFont **)(a1 + 64), 0, 0);
  uint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  CreateFontCacheNode(*((const TFont **)&v35 + 1), &v33);
  uint64_t v11 = v33;
  if (v33)
  {
    BYTE12(v37) = 1;
    memset(__b, 170, sizeof(__b));
    memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)&v34);
    v31[8] = 0xAAAAAAAAAA000000;
    v31[5] = 0xAAAAAAAAAAAAAAAALL;
    v31[0] = __b;
    v31[1] = 1358921729;
    v31[2] = 1358921729;
    v31[3] = 1358921729;
    v31[4] = 0;
    v31[6] = 1358921729;
    v31[7] = 1358921729;
    AssureScalerFontBlock(v31, (memoryContext *)__b, v11);
    ++*(_WORD *)(v11 + 16);
    int v12 = *a2;
    v22[0] = a3;
    v22[1] = 0;
    int v23 = v12;
    int v24 = 0;
    int v13 = *(_DWORD *)(a1 + 24);
    int v25 = 0;
    int v26 = v13;
    uint64_t v27 = *(void *)(a1 + 32);
    uint64_t v28 = a5;
    uint64_t v29 = a4;
    uint64_t v30 = 0;
    memset(v21, 170, sizeof(v21));
    TStreamerContext::TStreamerContext(v21, (uint64_t)v31, (memoryContext *)__b, (uint64_t)v22);
    __int16 v14 = ScalerNewScratch((memoryContext *)__b, 0x20030u, 0);
    *__int16 v14 = (size_t)__b;
    v14[1] = (size_t)v22;
    *((_DWORD *)v14 + 32778) = 0;
    _OWORD v14[2] = 0;
    v14[3] = (size_t)(v14 + 5);
    v14[4] = (size_t)(v14 + 5);
    uint64_t v20 = (const void *)0xAAAAAAAAAAAAAAAALL;
    unsigned int FontTable = ScalerGetFontTable((memoryContext *)__b, 1886352244, 0, &v20, 1, 0);
    int v16 = v20;
    DumpFontEncoding((memoryContext *)__b, (uint64_t)v14, (uint64_t)v20, FontTable);
    if (v16) {
      ScalerReleaseFontTable((memoryContext *)__b, v16);
    }
    DisposeStreamBuffer(v14);
    TStreamerContext::~TStreamerContext((TStreamerContext *)v21);
    *a2 = v23;
    --*(_WORD *)(v11 + 16);
    memoryContext::~memoryContext((memoryContext *)__b);
    __int16 v17 = 0;
    uint64_t v18 = *(void *)(v11 + 8);
    if (v18) {
      free((void *)(v18 - 8));
    }
    MEMORY[0x1BA9994D0](v11, 0x1080C40587D25DELL);
  }
  else
  {
    __int16 v17 = 20;
  }
  UnCacheCurrentGlyph((cacheCallContext *)&v34);
  return v17;
}

void sub_1B52D93FC(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  memoryContext::~memoryContext((memoryContext *)&a31);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    if (!*(void *)(v31 - 136)) {
      JUMPOUT(0x1B52D93D4);
    }
    JUMPOUT(0x1B52D93A4);
  }
  std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100]((uint64_t *)(v31 - 136), 0);
  UnCacheCurrentGlyph((cacheCallContext *)(v31 - 128));
  _Unwind_Resume(a1);
}

uint64_t TTPerformStreamingFlatteningDownload(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v35 = v10;
  long long v36 = v10;
  long long v33 = v10;
  long long v34 = v10;
  cacheCallContext::cacheCallContext((cacheCallContext *)&v33, *(const TFont **)(a1 + 64), 0, 0);
  uint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
  CreateFontCacheNode(*((const TFont **)&v34 + 1), &v32);
  uint64_t v11 = v32;
  if (!v32)
  {
    __int16 v17 = 20;
    goto LABEL_11;
  }
  BYTE12(v36) = 1;
  memset(__b, 170, sizeof(__b));
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)&v33);
  v30[8] = (memoryContext *)0xAAAAAAAAAA000000;
  v30[5] = (memoryContext *)0xAAAAAAAAAAAAAAAALL;
  v30[0] = (memoryContext *)__b;
  v30[1] = (memoryContext *)1358921729;
  v30[2] = (memoryContext *)1358921729;
  v30[3] = (memoryContext *)1358921729;
  _OWORD v30[4] = 0;
  v30[6] = (memoryContext *)1358921729;
  uint64_t v30[7] = (memoryContext *)1358921729;
  AssureScalerFontBlock(v30, (memoryContext *)__b, v11);
  ++*(_WORD *)(v11 + 16);
  int v12 = *a2;
  v21[0] = a3;
  v21[1] = a4;
  int v22 = v12;
  int v23 = 0;
  int v13 = *(_DWORD *)(a1 + 24);
  int v24 = 0;
  int v25 = v13;
  uint64_t v26 = *(void *)(a1 + 32);
  uint64_t v27 = 0;
  uint64_t v28 = a5;
  uint64_t v29 = 0;
  memset(v20, 170, sizeof(v20));
  TStreamerContext::TStreamerContext(v20, (uint64_t)v30, (memoryContext *)__b, (uint64_t)v21);
  __int16 v14 = ScalerNewScratch((memoryContext *)__b, 0x20030u, 0);
  *__int16 v14 = (size_t)__b;
  v14[1] = (size_t)v21;
  *((_DWORD *)v14 + 32778) = 0;
  _OWORD v14[2] = 0;
  v14[3] = (size_t)(v14 + 5);
  v14[4] = (size_t)(v14 + 5);
  int v15 = v22 & 0xFFF;
  if (v15 == 64)
  {
    int v16 = 0;
    goto LABEL_7;
  }
  if (v15 == 128)
  {
    int v16 = 1;
LABEL_7:
    StreamFlatFont(v30, (uint64_t)v14, v16, 0, 0);
  }
  DisposeStreamBuffer(v14);
  TStreamerContext::~TStreamerContext((TStreamerContext *)v20);
  *a2 = v22;
  --*(_WORD *)(v11 + 16);
  memoryContext::~memoryContext((memoryContext *)__b);
  __int16 v17 = 0;
  uint64_t v18 = *(void *)(v11 + 8);
  if (v18) {
    free((void *)(v18 - 8));
  }
  MEMORY[0x1BA9994D0](v11, 0x1080C40587D25DELL);
LABEL_11:
  UnCacheCurrentGlyph((cacheCallContext *)&v33);
  return v17;
}

void sub_1B52D96CC(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  memoryContext::~memoryContext((memoryContext *)&a29);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    if (!*(void *)(v29 - 136)) {
      JUMPOUT(0x1B52D96A4);
    }
    JUMPOUT(0x1B52D967CLL);
  }
  std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100]((uint64_t *)(v29 - 136), 0);
  UnCacheCurrentGlyph((cacheCallContext *)(v29 - 128));
  _Unwind_Resume(a1);
}

uint64_t TTPerformStreamingPSDownload(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9, __CFArray *a10)
{
  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v43 = v18;
  long long v44 = v18;
  long long v41 = v18;
  long long v42 = v18;
  cacheCallContext::cacheCallContext((cacheCallContext *)&v41, *(const TFont **)(a1 + 64), 0, 0);
  uint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
  CreateFontCacheNode(*((const TFont **)&v42 + 1), &v40);
  uint64_t v19 = v40;
  if (!v40)
  {
    __int16 v24 = 20;
    goto LABEL_18;
  }
  BYTE12(v44) = 1;
  memset(__b, 170, sizeof(__b));
  memoryContext::memoryContext((memoryContext *)__b, (cacheCallContext *)&v41);
  v38[8] = (memoryContext *)0xAAAAAAAAAA000000;
  v38[5] = (memoryContext *)0xAAAAAAAAAAAAAAAALL;
  v38[0] = (memoryContext *)__b;
  v38[1] = (memoryContext *)1358921729;
  v38[2] = (memoryContext *)1358921729;
  v38[3] = (memoryContext *)1358921729;
  v38[4] = 0;
  v38[6] = (memoryContext *)1358921729;
  v38[7] = (memoryContext *)1358921729;
  AssureScalerFontBlock(v38, (memoryContext *)__b, v19);
  ++*(_WORD *)(v19 + 16);
  int v20 = *a2;
  v29[0] = a3;
  v29[1] = a4;
  int v30 = v20;
  int v31 = 0;
  int v21 = *(_DWORD *)(a1 + 24);
  int v32 = 0;
  int v33 = v21;
  uint64_t v34 = *(void *)(a1 + 32);
  uint64_t v35 = a7;
  uint64_t v36 = a6;
  uint64_t v37 = a5;
  memset(v28, 170, sizeof(v28));
  TStreamerContext::TStreamerContext(v28, (uint64_t)v38, (memoryContext *)__b, (uint64_t)v29);
  int v22 = ScalerNewScratch((memoryContext *)__b, 0x20030u, 0);
  *int v22 = (size_t)__b;
  v22[1] = (size_t)v29;
  *((_DWORD *)v22 + 32778) = 0;
  void v22[2] = 0;
  v22[3] = (size_t)(v22 + 5);
  v22[4] = (size_t)(v22 + 5);
  unsigned int v23 = v30 & 0xFFF;
  if (v23 <= 0x1F)
  {
    switch(v30 & 0xFFF)
    {
      case 1:
      case 8:
        StreamTTFont((uint64_t)v38, (uint64_t)v22, 0, a8);
        break;
      case 2:
        StreamT1Font((uint64_t)v38, (uint64_t)v22, 0);
        break;
      case 4:
        StreamT3Font((uint64_t)v38, (uint64_t)v22, a8);
        break;
      default:
        goto LABEL_15;
    }
    goto LABEL_15;
  }
  switch(v23)
  {
    case 0x20u:
      StreamPortableTTFont((uint64_t)v38, (uint64_t)v22);
      break;
    case 0x40u:
      int v25 = 0;
      goto LABEL_14;
    case 0x80u:
      int v25 = 1;
LABEL_14:
      StreamFlatFont(v38, (uint64_t)v22, v25, a9, a10);
      break;
  }
LABEL_15:
  DisposeStreamBuffer(v22);
  TStreamerContext::~TStreamerContext((TStreamerContext *)v28);
  *a2 = v30;
  --*(_WORD *)(v19 + 16);
  memoryContext::~memoryContext((memoryContext *)__b);
  __int16 v24 = 0;
  uint64_t v26 = *(void *)(v19 + 8);
  if (v26) {
    free((void *)(v26 - 8));
  }
  MEMORY[0x1BA9994D0](v19, 0x1080C40587D25DELL);
LABEL_18:
  UnCacheCurrentGlyph((cacheCallContext *)&v41);
  return v24;
}

void sub_1B52D9A38(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  memoryContext::~memoryContext((memoryContext *)&a29);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    if (!*(void *)(v29 - 168)) {
      JUMPOUT(0x1B52D9A0CLL);
    }
    JUMPOUT(0x1B52D99E4);
  }
  std::unique_ptr<fontBlockCacheNode>::reset[abi:fe180100]((uint64_t *)(v29 - 168), 0);
  UnCacheCurrentGlyph((cacheCallContext *)(v29 - 160));
  _Unwind_Resume(a1);
}

memoryContext **TStreamerContext::TStreamerContext(memoryContext **a1, uint64_t a2, memoryContext *a3, uint64_t a4)
{
  *a1 = a3;
  a1[1] = (memoryContext *)a4;
  int v8 = SelectStreamType(a2, (uint64_t)a3, (unsigned int *)(a4 + 16));
  if (v8)
  {
    __int16 v12 = v8;
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = v12;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  if (*(void *)(a4 + 48))
  {
    uint64_t v9 = 0;
  }
  else
  {
    size_t v10 = ((*(unsigned __int16 *)(*(void *)(a2 + 8) + 40) + 31) >> 3) & 0x3FFC;
    uint64_t v9 = ScalerNewScratch(a3, v10, 0);
    memset(v9, 255, v10);
    *(void *)(a4 + 48) = v9;
  }
  a1[2] = (memoryContext *)v9;
  return a1;
}

void TStreamerContext::~TStreamerContext(TStreamerContext *this)
{
  uint64_t v2 = (char *)*((void *)this + 2);
  if (v2)
  {
    ScalerDisposeBlock(*(memoryContext **)this, v2, -1);
    *(void *)(*((void *)this + 1) + 48) = 0;
  }
}

void TLWFNFontObjectSurrogate::TLWFNFontObjectSurrogate(TLWFNFontObjectSurrogate *this, const TFont *a2)
{
  *(void *)this = &unk_1F0DFD4F8;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = 0;
  if (a2)
  {
    if ((*(unsigned int (**)(const TFont *))(*(void *)a2 + 40))(a2) != 22)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DFC400;
      exception[4] = 4;
    }
  }
}

void sub_1B52D9CC8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  _Unwind_Resume(exception_object);
}

void TLWFNFontObjectSurrogate::~TLWFNFontObjectSurrogate(TLWFNFontObjectSurrogate *this)
{
  *(void *)this = &unk_1F0DFD4F8;
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0DFD4F8;
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x1BA9994D0);
}

uint64_t TLWFNFontObjectSurrogate::GetTableOffset(TLWFNFontObjectSurrogate *this, unsigned int a2, unsigned int *a3)
{
  return 0xFFFFFFFFLL;
}

uint64_t TLWFNFontObjectSurrogate::GetTable@<X0>(TLWFNFontObjectSurrogate *this@<X0>, unsigned int *a2@<X3>, int a3@<W1>, void *a4@<X8>)
{
  if (a3 != 1112297028)
  {
    if ((*(unsigned int (**)(TLWFNFontObjectSurrogate *))(*(void *)this + 16))(this) != a3)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DFC400;
      exception[4] = 4;
    }
    if (a2)
    {
      uint64_t v10 = (*(uint64_t (**)(void))(**((void **)this + 1) + 56))(*((void *)this + 1));
      *a2 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 24))(v10);
    }
    uint64_t v9 = *(uint64_t (**)(void))(**((void **)this + 1) + 48);
    return v9();
  }
  uint64_t v7 = *((void *)this + 2);
  if (v7)
  {
    if (!a2) {
      goto LABEL_7;
    }
    LODWORD(result) = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
LABEL_5:
    *a2 = result;
LABEL_6:
    uint64_t v7 = *((void *)this + 2);
LABEL_7:
    uint64_t v9 = *(uint64_t (**)(void))(*(void *)v7 + 32);
    return v9();
  }
  uint64_t v11 = (*(uint64_t (**)(void))(**((void **)this + 1) + 56))(*((void *)this + 1));
  uint64_t result = FPRMGetResourceCount(*(void *)(*(void *)(*(void *)(v11 + 8) + 48) + 120), 1112297028);
  if (result == 1)
  {
    __int16 v12 = (TResourceFileDataSurrogate *)operator new(0x10uLL, MEMORY[0x1E4FBA2D0]);
    if (v12)
    {
      uint64_t v13 = (*(uint64_t (**)(void))(**((void **)this + 1) + 56))(*((void *)this + 1));
      TResourceFileDataSurrogate::TResourceFileDataSurrogate(v12, (const TResourceForkSurrogate *)(*(void *)(v13 + 8) + 40));
    }
    uint64_t result = *((void *)this + 2);
    *((void *)this + 2) = 0;
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      __int16 v12 = (TResourceFileDataSurrogate *)*((void *)this + 2);
    }
    if (v12)
    {
      uint64_t result = (*(uint64_t (**)(TResourceFileDataSurrogate *))(*(void *)v12 + 24))(v12);
      if (result)
      {
        if (!a2) {
          goto LABEL_6;
        }
        goto LABEL_5;
      }
    }
  }
  *a4 = &unk_1F0DD4218;
  a4[1] = 0;
  a4[2] = 0;
  a4[3] = 0;
  return result;
}

void sub_1B52DA120(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9994C0](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

void TLWFNResourceReference::~TLWFNResourceReference(const TFileFragmentReference **this)
{
  *this = (const TFileFragmentReference *)&unk_1F0DFD558;
  TFileDataSurrogate::~TFileDataSurrogate(this + 3);
}

{
  uint64_t vars8;

  *this = (const TFileFragmentReference *)&unk_1F0DFD558;
  TFileDataSurrogate::~TFileDataSurrogate(this + 3);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TLWFNFontTableContext::GetData(TLWFNFontTableContext *this, unsigned int a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unsigned int v8 = *((_DWORD *)this + 79);
  if (v8 > a2 && *((_WORD *)this + 157))
  {
    *((_DWORD *)this + 79) = 0;
    *((_WORD *)this + 157) = 0;
    TLWFNResourceReference::TLWFNResourceReference((TLWFNResourceReference *)v15, *(const TResourceForkSurrogate **)this, 501);
    uint64_t v9 = v15[2];
    *((void *)this + 2) = v15[1];
    *((void *)this + 3) = v9;
    TFileDataSurrogate::operator=((uint64_t)this + 32, (uint64_t)v16);
    *((_DWORD *)this + 12) = v17;
    *(_OWORD *)((char *)this + 244) = v30;
    *(_OWORD *)((char *)this + 180) = v26;
    *(_OWORD *)((char *)this + 196) = v27;
    *(_OWORD *)((char *)this + 212) = v28;
    *(_OWORD *)((char *)this + 228) = v29;
    *(_OWORD *)((char *)this + 116) = v22;
    *(_OWORD *)((char *)this + 132) = v23;
    *(_OWORD *)((char *)this + 148) = v24;
    *(_OWORD *)((char *)this + 164) = v25;
    *(_OWORD *)((char *)this + 52) = v18;
    *(_OWORD *)((char *)this + 68) = v19;
    *(_OWORD *)((char *)this + 84) = v20;
    *(_OWORD *)((char *)this + 100) = v21;
    *(_OWORD *)((char *)this + 260) = v31;
    long long v10 = v33;
    *(_OWORD *)((char *)this + 276) = v32;
    *(_OWORD *)((char *)this + 292) = v10;
    v15[0] = &unk_1F0DFD558;
    TFileDataSurrogate::~TFileDataSurrogate(v16);
    *((_WORD *)this + 156) = *((void *)this + 3);
    unsigned int v8 = *((_DWORD *)this + 79);
  }
  unsigned int v11 = a2 - v8;
  unsigned int v12 = *((unsigned __int16 *)this + 156);
  if (v11 >= v12) {
    TType1LWFNResourceChain::GetNextResource(this);
  }
  unsigned int v13 = v12 - v11 - *a3;
  if (v12 - v11 < *a3)
  {
    unsigned int v13 = 0;
    *a3 = v12 - v11;
  }
  *a4 = v13;
  return *((void *)this + 2) + v11;
}

void sub_1B52DA3BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  TFileDataSurrogate::~TFileDataSurrogate(v10);
  _Unwind_Resume(a1);
}

void TType1LWFNFont::~TType1LWFNFont(TType1LWFNFont *this)
{
  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x1BA9994D0);
}

TLWFNFontObjectSurrogate *TType1LWFNFont::GetFontObject(TType1LWFNFont *this)
{
  uint64_t v1 = (TLWFNFontObjectSurrogate *)*((void *)this + 3);
  if (!v1)
  {
    uint64_t v3 = (TLWFNFontObjectSurrogate *)operator new(0x18uLL, MEMORY[0x1E4FBA2D0]);
    if (v3)
    {
      uint64_t v1 = v3;
      TLWFNFontObjectSurrogate::TLWFNFontObjectSurrogate(v3, *((const TFont **)this + 4));
      uint64_t v4 = *((void *)this + 3);
      *((void *)this + 3) = v1;
      if (!v4) {
        return v1;
      }
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      uint64_t v1 = (TLWFNFontObjectSurrogate *)*((void *)this + 3);
      if (v1) {
        return v1;
      }
    }
    else
    {
      *((void *)this + 3) = 0;
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  return v1;
}

void sub_1B52DA5C8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9994C0](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

uint64_t TType1LWFNFont::GetFontDataTableTag(TType1LWFNFont *this)
{
  return 1280788046;
}

uint64_t TType1LWFNFont::GetSubrCount(TType1LWFNFont *this)
{
  return *(unsigned __int16 *)(*((void *)this + 4) + 144);
}

uint64_t TType1LWFNFont::GetSubrData(TType1LWFNFont *this, const unsigned __int8 **a2, __int16 *a3, const unsigned __int8 **a4)
{
  uint64_t v4 = *((void *)this + 4);
  *a3 = *(_WORD *)(v4 + 146);
  uint64_t v7 = v4 + 112;
  int v5 = *(const unsigned __int8 **)(v4 + 112);
  uint64_t v6 = *(void *)(v7 + 8);
  *a2 = v5;
  *a4 = &v5[v6];
  return (uint64_t)*a2;
}

uint64_t TType1LWFNFont::GetGlobalSubrCount(TType1LWFNFont *this)
{
  return 0;
}

uint64_t TType1LWFNFont::GetGlobalSubrArrayAndObjectData(TType1LWFNFont *this, __int16 *a2, const unsigned __int8 **a3, const unsigned __int8 **a4, const unsigned __int8 **a5, const unsigned __int8 **a6)
{
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  return 0;
}

void TType1LWFNFont::GetCharOutline(TType1LWFNFont *this@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  unsigned int v6 = (*(uint64_t (**)(void))(**((void **)this + 4) + 168))(*((void *)this + 4));
  if (v6 >= 0xFFFF) {
    unsigned int v7 = 0xFFFF;
  }
  else {
    unsigned int v7 = v6;
  }
  if (v7 > a2)
  {
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    operator new[]();
  }
  exception = __cxa_allocate_exception(0x10uLL);
  *(void *)exception = &unk_1F0DFC400;
  exception[4] = 8;
}

void sub_1B52DA768(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  MEMORY[0x1BA9994A0](v2, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

BOOL TType1LWFNFont::GetFontEncoding(TType1LWFNFont *this, unsigned __int16 *__dst)
{
  uint64_t v2 = *((void *)this + 4);
  uint64_t v3 = *(void *)(v2 + 248);
  if (v3) {
    memcpy(__dst, *(const void **)(v2 + 248), 0x200uLL);
  }
  return v3 != 0;
}

void *TType1LWFNFont::FindCharName(TType1LWFNFont *this, unsigned int a2, unsigned __int8 *a3)
{
  uint64_t v3 = *((void *)this + 4);
  uint64_t v4 = *(unsigned int *)(*(void *)(v3 + 192) + 4 * a2);
  if ((v4 & 0x80000000) != 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  unsigned int v6 = (unsigned __int8 *)(*(void *)(v3 + 48) + v4);
  uint64_t result = memcpy(a3 + 2, v6 + 1, *v6);
  a3[1] = 47;
  *a3 = *v6 + 1;
  return result;
}

uint64_t TType1LWFNFont::GetGlyphName(TType1LWFNFont *this, unsigned int a2, unsigned int a3, char *a4)
{
  *a4 = 0;
  unsigned int v8 = (*(uint64_t (**)(void))(**((void **)this + 4) + 168))(*((void *)this + 4));
  if (v8 >= 0xFFFF) {
    unsigned int v9 = 0xFFFF;
  }
  else {
    unsigned int v9 = v8;
  }
  if (v9 <= a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    __int16 v17 = 8;
    goto LABEL_15;
  }
  if (a2)
  {
    uint64_t v10 = *((void *)this + 4);
    uint64_t v11 = *(unsigned int *)(*(void *)(v10 + 192) + 4 * a2);
    if ((v11 & 0x80000000) == 0)
    {
      uint64_t v12 = *(void *)(v10 + 48);
      unsigned int v13 = (char *)(v12 + v11 + 1);
      uint64_t v14 = *(unsigned __int8 *)(v12 + v11);
      if (!*(unsigned char *)(v12 + v11)) {
        return v14;
      }
      goto LABEL_10;
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    __int16 v17 = 5;
LABEL_15:
    exception[4] = v17;
  }
  uint64_t v14 = 7;
  unsigned int v13 = ".notdef";
LABEL_10:
  if (v14 < a3)
  {
    memcpy(a4, v13, v14);
    a4[v14] = 0;
  }
  return v14;
}

uint64_t TType1LWFNFont::SetupGlyphBits@<X0>(uint64_t this@<X0>, const unsigned int *a2@<X2>, void *a3@<X8>)
{
  if (a2)
  {
    uint64_t v5 = this;
    (*(void (**)(uint64_t))(*(void *)this + 40))(this);
    return TType1PSFont::SetupGlyphBits(v5, a2, a3);
  }
  else
  {
    *a3 = 0;
  }
  return this;
}

void TLWFNCharStringContext::~TLWFNCharStringContext(TLWFNCharStringContext *this)
{
  *(void *)this = &unk_1F0DFD6B0;
  uint64_t v2 = *((void *)this + 37);
  *((void *)this + 37) = 0;
  if (v2) {
    MEMORY[0x1BA9994A0](v2, 0x1000C8077774924);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0DFD6B0;
  uint64_t v2 = *((void *)this + 37);
  *((void *)this + 37) = 0;
  if (v2) {
    MEMORY[0x1BA9994A0](v2, 0x1000C8077774924);
  }
  JUMPOUT(0x1BA9994D0);
}

void TBufferedLWFNCharStringStreamingContext::~TBufferedLWFNCharStringStreamingContext(TBufferedLWFNCharStringStreamingContext *this)
{
  TBufferedCharStringStreamingContext::~TBufferedCharStringStreamingContext(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TBufferedLWFNCharStringStreamingContext::StreamDecryptedCharString(TBufferedLWFNCharStringStreamingContext *this, const TType1PSFont *a2, uint64_t a3, char *a4, int *a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v22[15] = v10;
  v22[14] = v10;
  v22[13] = v10;
  v22[12] = v10;
  v22[11] = v10;
  v22[10] = v10;
  v22[9] = v10;
  v22[8] = v10;
  v22[7] = v10;
  v22[5] = v10;
  v22[6] = v10;
  v22[3] = v10;
  v22[4] = v10;
  v22[1] = v10;
  void v22[2] = v10;
  v22[0] = v10;
  long long v23 = "/.notdef";
  uint64_t v24 = 8;
  unint64_t v25 = 0;
  unint64_t v26 = 0;
  long long v21 = &unk_1F0DFD6B0;
  uint64_t v27 = 0;
  (*(void (**)(const TType1PSFont *, uint64_t, _OWORD *))(*(void *)a2 + 232))(a2, a3, v22);
  long long v23 = (char *)v22 + 1;
  uint64_t v24 = LOBYTE(v22[0]);
  unint64_t v26 = *(unsigned int *)(*(void *)(*((void *)a2 + 4) + 104) + 8 * a3 + 4);
  __int16 v20 = -21846;
  unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(unint64_t *__return_ptr, const TType1PSFont *, uint64_t, __int16 *))(*(void *)a2 + 128))(&v19, a2, a3, &v20);
  unint64_t v11 = v19;
  unint64_t v25 = v19;
  if (*((__int16 *)a2 + 8) >= 1)
  {
    unint64_t v12 = *((unsigned __int16 *)a2 + 8);
    BOOL v13 = v26 >= v12;
    unint64_t v14 = v26 - v12;
    if (!v13)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DFC400;
      exception[4] = 5;
    }
    unint64_t v26 = v14;
  }
  unint64_t v19 = 0;
  uint64_t v15 = v27;
  uint64_t v27 = v11;
  if (v15)
  {
    MEMORY[0x1BA9994A0](v15, 0x1000C8077774924);
    unint64_t v16 = v19;
    unint64_t v19 = 0;
    if (v16) {
      MEMORY[0x1BA9994A0](v16, 0x1000C8077774924);
    }
  }
  TBufferedCharStringStreamingContext::DoCharString(this, (uint64_t)&v21, a4, (uint64_t)a5);
  uint64_t result = v27;
  long long v21 = &unk_1F0DFD6B0;
  uint64_t v27 = 0;
  if (result) {
    return MEMORY[0x1BA9994A0](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1B52DADD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49)
{
  if (a10) {
    MEMORY[0x1BA9994A0](a10, 0x1000C8077774924);
  }
  if (a49) {
    MEMORY[0x1BA9994A0](a49, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void TType1LWFNFont::StreamPSFont(uint64_t a1, uint64_t a2, char a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int *a9, uint64_t a10)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 48))(a1, *a9);
  *a9 = v15;
  unint64_t v37 = 0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(&v37, a1, v15, a8);
  unint64_t v16 = (__int32 *)v37;
  unsigned int v17 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 168))(*(void *)(a1 + 32));
  *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v50[31] = v20;
  if (v17 >= 0xFFFF) {
    uint64_t v21 = 0xFFFFLL;
  }
  else {
    uint64_t v21 = v17;
  }
  v50[30] = v20;
  v50[29] = v20;
  v50[28] = v20;
  v50[27] = v20;
  v50[26] = v20;
  v50[25] = v20;
  v50[24] = v20;
  v50[23] = v20;
  v50[22] = v20;
  v50[21] = v20;
  v50[20] = v20;
  v50[19] = v20;
  v50[18] = v20;
  v50[17] = v20;
  v50[16] = v20;
  v50[15] = v20;
  v50[14] = v20;
  v50[13] = v20;
  v50[12] = v20;
  v50[11] = v20;
  v50[10] = v20;
  v50[9] = v20;
  v50[8] = v20;
  v50[7] = v20;
  v50[6] = v20;
  v50[5] = v20;
  id v50[4] = v20;
  v50[3] = v20;
  _OWORD v50[2] = v20;
  v50[1] = v20;
  v50[0] = v20;
  if (!a5) {
    TType1PSFont::SetEncoding(v21, v16, (const unsigned int *)v50, v19);
  }
  int v22 = *a9;
  if ((*a9 & 0x200) == 0)
  {
    if (*(_WORD *)(a1 + 8))
    {
      if (a4 & 1) != 0 || (TType1PSFont::PrinterIsBad(a2, v18))
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *(void *)exception = &unk_1F0DFC400;
        exception[4] = 8;
      }
      int v22 = *a9;
    }
    if ((v22 & 2) == 0) {
      goto LABEL_21;
    }
    if (!v16) {
      goto LABEL_20;
    }
    int v23 = 0;
    if (v21)
    {
      unsigned int v24 = (v21 + 31) >> 5;
      unint64_t v25 = v16;
      do
      {
        if (*v25)
        {
          LODWORD(v20) = *v25;
          *(int8x8_t *)&long long v20 = vcnt_s8(*(int8x8_t *)&v20);
          LOWORD(v20) = vaddlv_u8(*(uint8x8_t *)&v20);
          v23 += v20;
        }
        ++v25;
        --v24;
      }
      while (v24);
    }
    if (v23 == v21)
    {
LABEL_20:
      if ((a3 & 1) != 0 || (*(_WORD *)(a1 + 8) & 0x4000) == 0)
      {
LABEL_21:
        unint64_t v35 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v36 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&v34[1] = 0xAAAAAAAAAAAAAAAALL;
        TLWFNFontObjectSurrogate::TLWFNFontObjectSurrogate((TLWFNFontObjectSurrogate *)&v34[1], *(const TFont **)(a1 + 32));
        *(void *)&long long v26 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v26 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __b[18] = v26;
        __b[19] = v26;
        _WORD __b[16] = v26;
        __b[17] = v26;
        __b[14] = v26;
        __b[15] = v26;
        __b[12] = v26;
        __b[13] = v26;
        __b[10] = v26;
        __b[11] = v26;
        __b[8] = v26;
        __b[9] = v26;
        __b[6] = v26;
        __b[7] = v26;
        __b[4] = v26;
        __b[5] = v26;
        __b[2] = v26;
        __b[3] = v26;
        __b[0] = v26;
        __b[1] = v26;
        int v27 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
        *(void *)&__b[0] = *(void *)((*(uint64_t (**)(unint64_t))(*(void *)v35 + 56))(v35) + 8)
                           + 40;
        uint64_t v28 = (*(uint64_t (**)(unint64_t))(*(void *)v35 + 56))(v35);
        TLWFNResourceReference::TLWFNResourceReference((TLWFNResourceReference *)((char *)__b + 8), (const TResourceForkSurrogate *)(*(void *)(v28 + 8) + 40), 501);
        *((void *)&__b[19] + 1) = WORD4(__b[1]);
        if (v27 == 1280788046)
        {
          unint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v29 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v47[6] = v29;
          v47[7] = v29;
          v47[4] = v29;
          v47[5] = v29;
          v47[2] = v29;
          v47[3] = v29;
          v47[0] = v29;
          v47[1] = v29;
          TBufferedStreamingContext::TBufferedStreamingContext(v47, a1, (uint64_t)v16, a10);
        }
        long long v32 = __cxa_allocate_exception(0x10uLL);
        *(void *)long long v32 = &unk_1F0DFC400;
        _OWORD v32[4] = 5;
      }
    }
    memset(__b, 170, 0x2B8uLL);
    TBufferedCharStringStreamingContext::TBufferedCharStringStreamingContext(__b, a1, (uint64_t)v16, a10);
  }
  unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v44 = v30;
  long long v45 = v30;
  long long v42 = v30;
  long long v43 = v30;
  long long v40 = v30;
  long long v41 = v30;
  *(_OWORD *)long long v38 = v30;
  long long v39 = v30;
  TBufferedStreamingContext::TBufferedStreamingContext(v38, a1, (uint64_t)v16, a10);
}

void sub_1B52DB790()
{
}

void sub_1B52DB8F8(_Unwind_Exception *exception_object)
{
}

void sub_1B52DB900()
{
}

void sub_1B52DB918(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,__int16 a61)
{
  if (a2 == 1)
  {
    int v63 = __cxa_begin_catch(a1);
    a61 = v63[4];
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = v63[4];
  }
  TBufferedStreamingContext::~TBufferedStreamingContext((TBufferedStreamingContext *)&a53);
  *(void *)(v61 + 408) = &unk_1F0DFD558;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)&STACK[0x210]);
  if (a19) {
    (*(void (**)(uint64_t))(*(void *)a19 + 8))(a19);
  }
  if (a20) {
    MEMORY[0x1BA9994A0](a20, 0x1000C8052888210);
  }
  _Unwind_Resume(a1);
}

void sub_1B52DB984()
{
}

void sub_1B52DBA34(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1B52DBA3CLL);
  }
  __clang_call_terminate(a1);
}

void *TType1LWFNFont::StreamFontEncoding(void *result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result[4] + 248);
  if (v3) {
    return (void *)(*(uint64_t (**)(void *, uint64_t, void, uint64_t))(*result + 256))(result, v3, 0, a2);
  }
  return result;
}

void TLWFNResourceReference::TLWFNResourceReference(TLWFNResourceReference *this, const TResourceForkSurrogate *a2, int a3)
{
  *((void *)this + 2) = 0;
  uint64_t v5 = (unint64_t *)((char *)this + 16);
  *(void *)this = &unk_1F0DFD558;
  *((void *)this + 1) = 0;
  uint64_t v6 = *((void *)a2 + 1);
  *((void *)this + 3) = &unk_1F0DD4168;
  *((void *)this + 4) = v6;
  (*(void (**)(void))(*(void *)(v6 + 24) + 24))();
  *((void *)this + 3) = &unk_1F0DD4028;
  *((_DWORD *)this + 10) = a3;
  *((void *)this + 1) = TResourceForkFileReference::GetResource(*((unsigned int ***)this + 4), 1347375956, a3, v5, (unsigned __int8 *)this + 44);
}

void sub_1B52DBB84(_Unwind_Exception *a1)
{
  TFileDataSurrogate::~TFileDataSurrogate(v1);
  _Unwind_Resume(a1);
}

void TType1OTFFont::~TType1OTFFont(TType1OTFFont *this)
{
  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x1BA9994D0);
}

void TType1OTFFont::GetGlyphIDs(TType1OTFFont *this, int a2, const char *__s, unsigned __int16 *a4)
{
  int v8 = 0;
  if (a2)
  {
    uint64_t v9 = kStdStrs;
    while (1)
    {
      uint64_t v10 = 0;
      int v11 = strlen(__s);
      if (v11)
      {
        while (strlen(*(const char **)(v9 + 8 * v10)) != v11
             || strcmp(*(const char **)(v9 + 8 * v10), __s))
        {
          if (++v10 == 391) {
            goto LABEL_11;
          }
        }
        if ((unsigned __int16)v10 > 0x186u) {
          break;
        }
      }
      *a4++ = *(_WORD *)(*(void *)(*((void *)this + 4) + 296) + 2 * (unsigned __int16)v10);
      __s += (v11 + 1);
      if (++v8 == a2)
      {
        int v8 = a2;
        break;
      }
    }
  }
LABEL_11:
  int v12 = a2 - v8;
  if (a2 == v8) {
    return;
  }
  uint64_t v13 = *((void *)this + 4);
  int v14 = *(unsigned __int8 *)(v13 + 305);
  unsigned int v15 = *(unsigned __int16 *)(v13 + 306) * v14;
  unint64_t v49 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v47[1] = v16;
  long long v48 = v16;
  v47[0] = v16;
  unsigned int v17 = (const TFontObjectSurrogate *)(*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 216))(this);
  uint64_t v18 = (*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 120))(this);
  TFontObjectTable::TFontObjectTable((TFontObjectTable *)v47, v17, v18, *(unsigned int *)(*((void *)this + 4) + 308), v15 + v14);
  unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v44[1] = v19;
  long long v45 = v19;
  v44[0] = v19;
  long long v20 = (const TFontObjectSurrogate *)(*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 216))(this);
  uint64_t v21 = (*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 120))(this);
  int v22 = BytesToCard((const unsigned __int8 *)(*((void *)&v48 + 1) + v15), v14);
  TFontObjectTable::TFontObjectTable((TFontObjectTable *)v44, v20, v21, *(unsigned int *)(*((void *)this + 4) + 312), v22);
  int v23 = 0;
  uint64_t v24 = *((void *)&v45 + 1);
  long long v39 = (unsigned __int8 *)*((void *)&v48 + 1);
  long long v40 = this;
  int v25 = v12;
  do
  {
    unsigned int v26 = strlen(__s);
    if (!v26) {
      goto LABEL_32;
    }
    int v42 = v25;
    long long v43 = a4;
    uint64_t v27 = *((void *)v40 + 4);
    uint64_t v41 = v27;
    uint64_t v28 = *(unsigned __int8 *)(v27 + 305);
    if (*(unsigned char *)(v27 + 305))
    {
      unsigned __int16 v29 = 0;
      unsigned int v30 = BytesToCard(v39, *(unsigned __int8 *)(v27 + 305)) - 1;
      long long v31 = &v39[v28];
      while (1)
      {
        unsigned int v32 = BytesToCard(v31, v28) - 1;
        if (v32 - v30 == v26 && !memcmp((const void *)(v24 + v30), __s, v26)) {
          break;
        }
        ++v29;
        v31 += v28;
        unsigned int v30 = v32;
        if (v28 <= v29) {
          goto LABEL_19;
        }
      }
      if (*(unsigned __int16 *)(v41 + 306) + 391 <= (unsigned __int16)(v29 + 391)) {
        unsigned __int16 v38 = 0;
      }
      else {
        unsigned __int16 v38 = *(_WORD *)(*(void *)(v41 + 296) + 2 * (unsigned __int16)(v29 + 391));
      }
      int v25 = v42;
      *long long v43 = v38;
      a4 = v43 + 1;
      goto LABEL_33;
    }
LABEL_19:
    if (!v23)
    {
      a4 = v43;
      int v25 = v42;
LABEL_32:
      *a4++ = 0;
LABEL_33:
      __s += v26 + 1;
      --v25;
      int v37 = v23 + 1;
      goto LABEL_34;
    }
    int v33 = 0;
    uint64_t v34 = kStdStrs;
    a4 = v43;
    while (1)
    {
      uint64_t v35 = 0;
      int v36 = strlen(__s);
      if (v36)
      {
        while (strlen(*(const char **)(v34 + 8 * v35)) != v36
             || strcmp(*(const char **)(v34 + 8 * v35), __s))
        {
          if (++v35 == 391) {
            goto LABEL_29;
          }
        }
        if ((unsigned __int16)v35 > 0x186u) {
          break;
        }
      }
      *a4++ = *(_WORD *)(*(void *)(v41 + 296) + 2 * (unsigned __int16)v35);
      __s += (v36 + 1);
      if (++v33 == v42)
      {
        int v33 = v42;
        break;
      }
    }
LABEL_29:
    int v23 = 0;
    int v37 = 0;
    int v25 = v42 - v33;
    if (!v33) {
      goto LABEL_32;
    }
LABEL_34:
    int v23 = v37;
  }
  while (v25);
  TDataReference::~TDataReference((TDataReference *)((char *)v44 + 8));
  TDataReference::~TDataReference((TDataReference *)((char *)v47 + 8));
}

void sub_1B52DC07C(_Unwind_Exception *a1)
{
  TDataReference::~TDataReference((TDataReference *)(v1 | 8));
  _Unwind_Resume(a1);
}

void TType1OTFFont::FindCharName(TType1OTFFont *this, unsigned int a2, char *a3)
{
  unsigned int v4 = 254;
  TType1OTFFont::FindGlyphName(this, a2, a3 + 2, &v4);
  a3[1] = 47;
  *a3 = v4 + 1;
}

void TType1OTFFont::FindGlyphName(TType1OTFFont *this, unsigned int a2, char *a3, unsigned int *a4)
{
  *a3 = 0;
  uint64_t v6 = *((void *)this + 4);
  unint64_t v7 = *(unsigned __int16 *)(*(void *)(v6 + 288) + 2 * a2);
  if (v7 > 0x186)
  {
    unsigned __int16 v10 = v7 - 391;
    if (*(unsigned __int16 *)(v6 + 306) <= v10)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DFC400;
      exception[4] = 8;
    }
    int v12 = v10;
    uint64_t v13 = *(unsigned __int8 *)(v6 + 305);
    unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v25 = v14;
    *(_OWORD *)__src = v14;
    long long v24 = v14;
    unsigned int v15 = (const TFontObjectSurrogate *)(*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 216))(this);
    uint64_t v16 = (*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 120))(this);
    TFontObjectTable::TFontObjectTable((TFontObjectTable *)&v24, v15, v16, (*(_DWORD *)(*((void *)this + 4) + 308) + v13 * v12), 2 * v13);
    unsigned int v17 = (const unsigned __int8 *)__src[1];
    int v18 = BytesToCard((const unsigned __int8 *)__src[1], v13);
    size_t v19 = BytesToCard(&v17[v13], v13) - v18;
    TDataReference::~TDataReference((TDataReference *)((char *)&v24 + 8));
    if (*a4 > v19)
    {
      *a4 = v19;
      unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v25 = v20;
      *(_OWORD *)__src = v20;
      long long v24 = v20;
      uint64_t v21 = (const TFontObjectSurrogate *)(*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 216))(this);
      uint64_t v22 = (*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 120))(this);
      TFontObjectTable::TFontObjectTable((TFontObjectTable *)&v24, v21, v22, (v18 + *(_DWORD *)(*((void *)this + 4) + 312) - 1), v19);
      memcpy(a3, __src[1], v19);
      TDataReference::~TDataReference((TDataReference *)((char *)&v24 + 8));
    }
  }
  else
  {
    int v8 = *(const char **)(kStdStrs + 8 * v7);
    unsigned int v9 = strlen(v8);
    if (*a4 > v9)
    {
      *a4 = v9;
      memcpy(a3, v8, v9);
    }
  }
}

uint64_t TType1OTFFont::GetGlyphName(TType1OTFFont *this, unsigned int a2, unsigned int a3, char *a4)
{
  unsigned int v11 = a3;
  if (!a4
    || ((unsigned int v7 = (*(uint64_t (**)(void))(**((void **)this + 4) + 168))(*((void *)this + 4)), v7 >= 0xFFFF)
      ? (unsigned int v8 = 0xFFFF)
      : (unsigned int v8 = v7),
        v8 <= a2))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 8;
  }
  TType1OTFFont::FindGlyphName(this, a2, a4, &v11);
  uint64_t result = v11;
  a4[v11] = 0;
  return result;
}

uint64_t TType1OTFFont::GetGlyphID(TType1OTFFont *this, const char *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v6 = 0;
    uint64_t v7 = kStdStrs;
    while (strlen(*(const char **)(v7 + 8 * v6)) != a3 || strcmp(*(const char **)(v7 + 8 * v6), a2))
    {
      if (++v6 == 391) {
        goto LABEL_9;
      }
    }
    if ((unsigned __int16)v6 < 0x187u) {
      return (unsigned __int16)v6;
    }
LABEL_9:
    uint64_t v8 = *((void *)this + 4);
    int v9 = *(unsigned __int8 *)(v8 + 305);
    int v10 = *(unsigned __int16 *)(v8 + 306) * v9;
    unint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v30[1] = v11;
    *(_OWORD *)long long v31 = v11;
    v30[0] = v11;
    int v12 = (const TFontObjectSurrogate *)(*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 216))(this);
    uint64_t v13 = (*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 120))(this);
    TFontObjectTable::TFontObjectTable((TFontObjectTable *)v30, v12, v13, *(unsigned int *)(*((void *)this + 4) + 308), v10 + v9);
    unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v27[1] = v14;
    long long v28 = v14;
    v27[0] = v14;
    unsigned int v15 = (const TFontObjectSurrogate *)(*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 216))(this);
    uint64_t v16 = (*(uint64_t (**)(TType1OTFFont *))(*(void *)this + 120))(this);
    int v17 = BytesToCard(&v31[1][v10], v9);
    TFontObjectTable::TFontObjectTable((TFontObjectTable *)v27, v15, v16, *(unsigned int *)(*((void *)this + 4) + 312), v17);
    unsigned __int16 v18 = v6 - 391;
    uint64_t v19 = *((void *)this + 4);
    uint64_t v20 = *(unsigned __int8 *)(v19 + 305);
    if (v20 <= v18) {
      goto LABEL_17;
    }
    uint64_t v21 = *((void *)&v28 + 1);
    uint64_t v22 = v31[1];
    unsigned int v23 = BytesToCard(v31[1], *(unsigned __int8 *)(v19 + 305)) - 1;
    long long v24 = &v22[v20];
    while (1)
    {
      unsigned int v25 = BytesToCard(v24, v20) - 1;
      if (v25 - v23 == a3 && !memcmp((const void *)(v21 + v23), a2, a3)) {
        break;
      }
      ++v18;
      v24 += v20;
      unsigned int v23 = v25;
      if (v20 <= v18) {
        goto LABEL_17;
      }
    }
    if (*(unsigned __int16 *)(v19 + 306) + 391 <= (unsigned __int16)(v18 + 391)) {
LABEL_17:
    }
      LOWORD(v6) = 0;
    else {
      LOWORD(v6) = *(_WORD *)(*(void *)(v19 + 296) + 2 * (unsigned __int16)(v18 + 391));
    }
    TDataReference::~TDataReference((TDataReference *)((char *)v27 + 8));
    TDataReference::~TDataReference((TDataReference *)((char *)v30 + 8));
  }
  else
  {
    LOWORD(v6) = 0;
  }
  return (unsigned __int16)v6;
}

void sub_1B52DC6D8(_Unwind_Exception *a1)
{
  TDataReference::~TDataReference((TDataReference *)(v1 | 8));
  _Unwind_Resume(a1);
}

uint64_t TType1OTFFont::GetFontDataTableTag(TType1OTFFont *this)
{
  return 1128678944;
}

void TType1OTFFont::FastSearchForSeac(TType1OTFFont *this, unsigned __int8 *a2, int a3, unsigned __int8 *a4, __int16 *a5)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  v17[0] = 0;
  if (a3 < 1) {
    return;
  }
  int v7 = 0;
  int v8 = 0;
  int v9 = (const unsigned __int8 **)&a2[a3];
  while (1)
  {
    int v10 = a2++;
    uint64_t v16 = a2;
    uint64_t v11 = *v10;
    if (v11 >= 0x20)
    {
      *(_DWORD *)((unint64_t)v17 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v8 & 1))) = TType1PSFont::EvaluateCharCode(v11, &v16, v9, a4);
      ++v7;
      a2 = v16;
      ++v8;
      goto LABEL_9;
    }
    if (v11 != 14)
    {
      int v7 = 0;
      goto LABEL_9;
    }
    if (v7 >= 4) {
      break;
    }
LABEL_9:
    if (a2 >= (unsigned __int8 *)v9) {
      return;
    }
  }
  __int16 v12 = v17[0];
  unsigned int v13 = HIDWORD(v17[0]);
  __int16 v14 = LOWORD(v17[0]) + 2412;
  if (BYTE1(v17[0]) > 0xFAu) {
    __int16 v14 = -1388 - LOWORD(v17[0]);
  }
  if (LODWORD(v17[0]) <= 0xFF) {
    __int16 v14 = LOWORD(v17[0]) - 139;
  }
  if (LODWORD(v17[0]) < 0x10000) {
    __int16 v12 = v14;
  }
  *(_WORD *)a4 = v12;
  if (BYTE1(v13) <= 0xFAu) {
    __int16 v15 = v13 + 2412;
  }
  else {
    __int16 v15 = -1388 - v13;
  }
  if (v13 <= 0xFF) {
    __int16 v15 = v13 - 139;
  }
  if (v13 >= 0x10000) {
    __int16 v15 = v13;
  }
  *a5 = v15;
}

uint64_t TType1OTFFont::GetFontEncoding(TType1OTFFont *this, unsigned __int16 *a2)
{
  if (*(unsigned char *)(*((void *)this + 4) + 304))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 24;
  }
  return 0;
}

uint64_t TType1OTFFont::GetStandardEncoding(uint64_t this, unsigned __int16 *a2)
{
  if (a2)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)(*(void *)(this + 32) + 296);
    do
    {
      a2[v2] = *(_WORD *)(v3
                        + 2
                        * (unsigned __int16)TType1OTFFont::GetStandardEncoding(unsigned short *)const::gStdSIDs[v2]);
      ++v2;
    }
    while (v2 != 256);
  }
  return this;
}

void TType1OTFFont::StreamFontEncoding(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 304);
  exception = __cxa_allocate_exception(0x10uLL);
  *(void *)exception = &unk_1F0DFC400;
  if (v1) {
    __int16 v3 = 24;
  }
  else {
    __int16 v3 = 23;
  }
  exception[4] = v3;
}

uint64_t TType1OTFFont::GetPSStreamType(TType1OTFFont *this, int a2)
{
  if ((a2 & 0x200) != 0) {
    return a2 & 0xFFFFF000 | 0x200;
  }
  else {
    return TType1PSFont::GetPSStreamType(this, a2);
  }
}

uint64_t TType1OTFFont::CheckSubrs(TType1OTFFont *this, unsigned int *a2)
{
  *a2 = 2;
  return 1;
}

void MCharStringConvertionState::~MCharStringConvertionState(MCharStringConvertionState *this)
{
}

void MCharStringConvertionState::MCharStringConvertionState(MCharStringConvertionState *this, const TType1SFNTFont *a2)
{
  *(void *)this = &unk_1F0DFD8D8;
  *((void *)this + 1) = a2;
  bzero((char *)this + 16, 0xD7CuLL);
  *((_DWORD *)this + 11) = 1;
  *((_WORD *)this + 24) = 257;
  *((_DWORD *)this + 451) = 0;
  uint64_t v4 = (*(uint64_t (**)(const TType1SFNTFont *))(*(void *)a2 + 40))(a2);
  *((_DWORD *)this + 478) = *(unsigned __int16 *)(v4 + 70);
  *((_DWORD *)this + 867) = *(_DWORD *)(v4 + 440);
  *((_DWORD *)this + 868) = *(_DWORD *)(v4 + 120);
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 14) = 0;
  *(void *)((char *)this + 1916) = 0x32000000000000;
}

void TType2ToType1CharStringConvertionContext::~TType2ToType1CharStringConvertionContext(TType2ToType1CharStringConvertionContext *this)
{
  *(void *)this = off_1F0DFD8F8;
  *((void *)this + 38) = &unk_1F0DFD930;
  free(*((void **)this + 35));
}

{
  uint64_t vars8;

  *(void *)this = off_1F0DFD8F8;
  *((void *)this + 38) = &unk_1F0DFD930;
  free(*((void **)this + 35));
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TType2ToType1CharStringConvertionContext::~TType2ToType1CharStringConvertionContext(TType2ToType1CharStringConvertionContext *this)
{
  *((void *)this - 38) = off_1F0DFD8F8;
  *(void *)this = &unk_1F0DFD930;
  free(*((void **)this - 3));
}

{
  TType2ToType1CharStringConvertionContext::~TType2ToType1CharStringConvertionContext((TType2ToType1CharStringConvertionContext *)((char *)this - 304));
}

void TType2ToType1CharStringConvertionContext::TType2ToType1CharStringConvertionContext(TType2ToType1CharStringConvertionContext *this, const TType1SFNTFont *a2)
{
  *((void *)this + 33) = "/.notdef";
  *((void *)this + 34) = 8;
  *((void *)this + 35) = 0;
  *((void *)this + 36) = 0;
  *(void *)this = &unk_1F0E00740;
  *((_DWORD *)this + 74) = 0;
  MCharStringConvertionState::MCharStringConvertionState((TType2ToType1CharStringConvertionContext *)((char *)this + 304), a2);
  *(void *)this = off_1F0DFD8F8;
  *((void *)this + 38) = &unk_1F0DFD930;
  uint64_t v4 = (*(uint64_t (**)(const TType1SFNTFont *))(*(void *)a2 + 216))(a2);
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(v4 + 8) + 56))(*(void *)(v4 + 8));
  *((void *)this + 490) = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5);
}

uint64_t TType2ToType1CharStringConvertionContext::ConvertT2ToT1CharString(uint64_t this, unsigned int a2, BOOL *a3)
{
  if (a2 > 0xA)
  {
LABEL_137:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  __int16 v3 = a3;
  uint64_t v4 = this;
  unint64_t v6 = *(void *)(this + 328);
  uint64_t v5 = *(unsigned __int8 **)(this + 336);
  int v122 = v5;
  unint64_t v7 = *(void *)(this + 320);
  int v8 = (char *)(v5 + 1);
  BOOL v9 = !*a3;
  if (v6 <= (unint64_t)v5 && (unint64_t)v8 <= v7 && !*a3)
  {
    int v12 = 0;
    unsigned int v13 = (int32x2_t *)(this + 364);
    unsigned __int16 v108 = a2 + 1;
    __int16 v14 = (int *)(this + 2220);
    uint64_t v117 = (int *)(this + 376);
    int v118 = (int *)(this + 368);
    uint64_t v112 = (int *)(this + 392);
    int v107 = (int *)(this + 2228);
    uint64_t v116 = (int *)(this + 372);
    uint64_t v114 = (int *)(this + 384);
    int v115 = (int *)(this + 380);
    uint64_t v113 = (int *)(this + 388);
    uint64_t v110 = (int *)(this + 2224);
    long long v111 = (int *)(this + 396);
    int v109 = (int *)(this + 404);
    int v105 = (int *)(this + 408);
    uint64_t v106 = (int *)(this + 400);
    uint64_t v103 = (_DWORD *)(this + 572);
    int v104 = (int *)(this + 412);
    while (1)
    {
      *(void *)(v4 + 336) = v8;
      unsigned int v15 = *v5;
      if (v15 < 0x20)
      {
        if (v15 == 12)
        {
          if ((unint64_t)v8 >= v7) {
            goto LABEL_137;
          }
          *(void *)(v4 + 336) = v5 + 2;
          LOWORD(v15) = *v8 | 0xC00;
        }
        else if (v15 == 28)
        {
          v5 += 3;
          *(void *)(v4 + 336) = v5;
          ++v12;
          goto LABEL_130;
        }
        *(_WORD *)(v4 + 354) = v15;
        uint64_t v16 = *(unsigned __int16 *)(v4 + 556);
        LOWORD(v17) = v12 + v16;
        if (v12 + (int)v16 > 48) {
          goto LABEL_137;
        }
        if (v12 >= 1)
        {
          do
          {
            this = TType2ToType1CharStringConvertionContext::ArgPtrToFixed((TType2ToType1CharStringConvertionContext *)&v122, *(const unsigned __int8 ***)(v4 + 320), (const unsigned __int8 *)a3);
            v13->i32[v16++] = this;
            uint64_t v17 = *(unsigned __int16 *)(v4 + 556) + (uint64_t)v12;
          }
          while (v16 < v17);
          LOWORD(v15) = *(_WORD *)(v4 + 354);
        }
        unsigned int v18 = (unsigned __int16)v17;
        *(_WORD *)(v4 + 556) = v17;
        switch((__int16)v15)
        {
          case 1:
          case 18:
            TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 0, 0, 1, v17 & 0xFFFE);
            this = TType2ToType1CharStringConvertionContext::AddToHintMap(v4, 1);
            goto LABEL_126;
          case 2:
          case 9:
          case 12:
          case 13:
          case 15:
          case 16:
          case 17:
          case 28:
            goto LABEL_137;
          case 3:
          case 23:
            this = TType2ToType1CharStringConvertionContext::WriteVStem((TType2ToType1CharStringConvertionContext *)v4);
            goto LABEL_126;
          case 4:
            TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 1, 1, 1, 1u);
            unsigned int v26 = (int *)v13 + *(unsigned __int16 *)(v4 + 556) - 1;
            unint64_t v27 = (TType2ToType1CharStringConvertionContext *)v4;
            long long v28 = v14;
            goto LABEL_75;
          case 5:
            this = (uint64_t)TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 2, 1, 0, 0);
            if (v18 >= 2)
            {
              unsigned int v29 = v18 >> 1;
              unsigned int v30 = 1;
              long long v31 = v118;
              do
              {
                this = (uint64_t)TType2ToType1CharStringConvertionContext::RLineTo((TType2ToType1CharStringConvertionContext *)v4, v31 - 1, v31);
                v31 += 2;
                BOOL v32 = v30++ >= v29;
              }
              while (!v32);
            }
            goto LABEL_126;
          case 6:
            int v33 = (TType2ToType1CharStringConvertionContext *)v4;
            char v34 = 1;
            goto LABEL_42;
          case 7:
            int v33 = (TType2ToType1CharStringConvertionContext *)v4;
            char v34 = 0;
LABEL_42:
            this = (uint64_t)TType2ToType1CharStringConvertionContext::WriteHLineToAndVLineTo(v33, v34);
            goto LABEL_126;
          case 8:
            if ((unsigned __int16)v17 >= 6u)
            {
              uint64_t v35 = 0;
              long long v119 = v13;
              int v36 = 1;
              int v120 = v14;
              do
              {
                TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 2, 1, 0, 0);
                unsigned int v13 = v119;
                __int16 v14 = v120;
                this = (uint64_t)TType2ToType1CharStringConvertionContext::RRCurveTo((TType2ToType1CharStringConvertionContext *)v4, (int *)(v4 + v35 + 364), (int *)(v4 + v35 + 368), (int *)(v4 + v35 + 372), (int *)(v4 + v35 + 376), (int *)(v4 + v35 + 380), (int *)(v4 + v35 + 384));
                v35 += 24;
                BOOL v32 = v36++ >= (715827883 * (unint64_t)v18) >> 32;
              }
              while (!v32);
            }
            goto LABEL_126;
          case 10:
            if (!(_WORD)v17) {
              goto LABEL_137;
            }
            this = (*(uint64_t (**)(uint64_t, void, BOOL *))(*(void *)v4 + 24))(v4, v108, v3);
            goto LABEL_126;
          case 11:
            if (!a2) {
              goto LABEL_137;
            }
            return this;
          case 14:
            if ((unsigned __int16)v17 > 3u)
            {
              TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 0, 0, 1, 4u);
              TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v4, v14);
              TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v4, (int *)v13);
              TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v4, v118);
              TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v4, v116);
              TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v4, v117);
              unsigned int v37 = 3078;
            }
            else
            {
              TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 1, 1, 1, 0);
              unsigned int v37 = 14;
            }
            this = (uint64_t)TCharStringConversionContext::WriteOpCode((TCharStringConversionContext *)v4, v37);
            goto LABEL_126;
          case 19:
            if ((_WORD)v17) {
              TType2ToType1CharStringConvertionContext::WriteVStem((TType2ToType1CharStringConvertionContext *)v4);
            }
            if (*(unsigned char *)(v4 + 353))
            {
              *(_DWORD *)(v4 + 348) = 1;
            }
            else
            {
              *(_DWORD *)__int16 v124 = 0x40000;
              *(_DWORD *)(v4 + 348) = 2;
              TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v4, (int *)v124);
              LOWORD(v123) = 2572;
              TCharStringConversionContext::WriteData((TCharStringConversionContext *)v4, (const unsigned __int8 *)&v123 + 1, 1u);
            }
            this = (uint64_t)TType2ToType1CharStringConvertionContext::WriteHints((_WORD *)v4, 0);
            *(_DWORD *)(v4 + 348) = 2;
            goto LABEL_126;
          case 20:
            if ((_WORD)v17) {
              this = TType2ToType1CharStringConvertionContext::WriteVStem((TType2ToType1CharStringConvertionContext *)v4);
            }
            uint64_t v38 = *(unsigned __int16 *)(v4 + 2096);
            if (!*(_WORD *)(v4 + 2096)) {
              goto LABEL_72;
            }
            unsigned int v39 = 0;
            int v40 = 0;
            uint64_t v41 = v103;
            break;
          case 21:
            TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 1, 1, 1, 2u);
            int v47 = (char *)v13 + 4 * *(unsigned __int16 *)(v4 + 556);
            long long v28 = (int *)(v47 - 8);
            unsigned int v26 = (int *)(v47 - 4);
            unint64_t v27 = (TType2ToType1CharStringConvertionContext *)v4;
            goto LABEL_75;
          case 22:
            TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 1, 1, 1, 1u);
            long long v28 = (int *)v13 + *(unsigned __int16 *)(v4 + 556) - 1;
            unint64_t v27 = (TType2ToType1CharStringConvertionContext *)v4;
            unsigned int v26 = v14;
LABEL_75:
            this = (uint64_t)TType2ToType1CharStringConvertionContext::RMoveTo(v27, v28, v26);
            goto LABEL_126;
          case 24:
            if ((unsigned __int16)v17 < 3u)
            {
              uint64_t v49 = 0;
              unsigned int v57 = (unsigned __int16)v17;
              unsigned int v51 = 2;
              uint64_t v58 = 1;
            }
            else
            {
              int v121 = v14;
              long long v48 = v3;
              LODWORD(v49) = 0;
              unsigned __int16 v50 = 0;
              unsigned int v51 = 2;
              do
              {
                int v52 = (int *)v13 + (v49 | 1);
                signed int v53 = (int *)v13 + v51;
                long long v54 = (int *)v13 + (v49 + 3);
                int v55 = (int *)v13 + (v49 + 4);
                signed int v56 = (int *)v13 + (v49 + 5);
                TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 2, 1, 0, 0);
                this = (uint64_t)TType2ToType1CharStringConvertionContext::RRCurveTo((TType2ToType1CharStringConvertionContext *)v4, (int *)&v13[v50 / 2u], v52, v53, v54, v55, v56);
                v50 += 6;
                uint64_t v49 = v50;
                unsigned int v51 = v50 + 2;
                unsigned int v57 = *(unsigned __int16 *)(v4 + 556);
              }
              while (v51 < v57);
              uint64_t v58 = v50 | 1u;
              __int16 v3 = v48;
              __int16 v14 = v121;
            }
            if (v51 <= v57) {
              this = (uint64_t)TType2ToType1CharStringConvertionContext::RLineTo((TType2ToType1CharStringConvertionContext *)v4, (int *)v13 + v49, (int *)v13 + v58);
            }
            goto LABEL_126;
          case 25:
            this = (uint64_t)TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 2, 1, 0, 0);
            unsigned int v59 = *(unsigned __int16 *)(v4 + 556);
            if (v59 < 7)
            {
              uint64_t v63 = 0;
              int v60 = 0;
              unsigned int v62 = 6;
            }
            else
            {
              int v60 = 0;
              unsigned __int16 v61 = 0;
              do
              {
                this = (uint64_t)TType2ToType1CharStringConvertionContext::RLineTo((TType2ToType1CharStringConvertionContext *)v4, (int *)&v13[v61 / 2u], (int *)v13 + (v60 | 1u));
                v61 += 2;
                int v60 = v61;
                unsigned int v62 = v61 + 6;
                unsigned int v59 = *(unsigned __int16 *)(v4 + 556);
              }
              while (v62 < v59);
              uint64_t v63 = v61;
            }
            if (v62 <= v59)
            {
              int v74 = (int *)v13 + v63;
              int v75 = (int *)v13 + (v60 | 1u);
              int v76 = (int *)v13 + (v60 + 2);
              int v77 = (int *)v13 + (v60 + 3);
              unsigned int v78 = v3;
              unsigned int v79 = (int *)v13 + (v60 + 4);
              unsigned int v80 = v14;
              unsigned int v81 = (int *)v13 + (v60 + 5);
              TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 2, 1, 0, 0);
              unsigned int v82 = v79;
              __int16 v3 = v78;
              int v83 = v81;
              __int16 v14 = v80;
              this = (uint64_t)TType2ToType1CharStringConvertionContext::RRCurveTo((TType2ToType1CharStringConvertionContext *)v4, v74, v75, v76, v77, v82, v83);
            }
            goto LABEL_126;
          case 26:
            if (v17)
            {
              TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 2, 1, 0, 0);
              this = (uint64_t)TType2ToType1CharStringConvertionContext::RRCurveTo((TType2ToType1CharStringConvertionContext *)v4, (int *)v13, v118, v116, v117, v14, v115);
              unsigned int v18 = *(unsigned __int16 *)(v4 + 556);
              unsigned int v64 = 5;
            }
            else
            {
              unsigned int v64 = 0;
            }
            LOWORD(v84) = v64 + 4;
            if (v64 + 4 <= v18)
            {
              do
              {
                int v85 = (int *)v13 + v64;
                int v86 = (int *)v13 + v64 + 1;
                uint64_t v87 = (int *)&v13[1] + v64;
                int v88 = (int *)&v13[1] + v64 + 1;
                TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 2, 1, 0, 0);
                this = (uint64_t)TType2ToType1CharStringConvertionContext::RRCurveTo((TType2ToType1CharStringConvertionContext *)v4, v14, v85, v86, v87, v14, v88);
                unsigned int v64 = (unsigned __int16)v84;
                unsigned int v84 = (unsigned __int16)v84 + 4;
              }
              while (v84 <= *(unsigned __int16 *)(v4 + 556));
            }
            goto LABEL_126;
          case 27:
            if (v17)
            {
              TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 2, 1, 0, 0);
              this = (uint64_t)TType2ToType1CharStringConvertionContext::RRCurveTo((TType2ToType1CharStringConvertionContext *)v4, v118, (int *)v13, v116, v117, v115, v14);
              unsigned int v18 = *(unsigned __int16 *)(v4 + 556);
              unsigned int v65 = 5;
            }
            else
            {
              unsigned int v65 = 0;
            }
            LOWORD(v89) = v65 + 4;
            if (v65 + 4 <= v18)
            {
              do
              {
                unsigned int v90 = (int *)v13 + v65;
                unsigned int v91 = (int *)v13 + v65 + 1;
                uint64_t v92 = (int *)&v13[1] + v65;
                int v93 = (int *)&v13[1] + v65 + 1;
                TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 2, 1, 0, 0);
                this = (uint64_t)TType2ToType1CharStringConvertionContext::RRCurveTo((TType2ToType1CharStringConvertionContext *)v4, v90, v14, v91, v92, v93, v14);
                unsigned int v65 = (unsigned __int16)v89;
                unsigned int v89 = (unsigned __int16)v89 + 4;
              }
              while (v89 <= *(unsigned __int16 *)(v4 + 556));
            }
            goto LABEL_126;
          case 29:
            if (!(_WORD)v17) {
              goto LABEL_137;
            }
            this = (*(uint64_t (**)(uint64_t, void, BOOL *))(*(void *)v4 + 32))(v4, v108, v3);
            goto LABEL_126;
          case 30:
            int v66 = (unsigned __int16 *)v4;
            char v67 = 0;
            goto LABEL_92;
          case 31:
            int v66 = (unsigned __int16 *)v4;
            char v67 = 1;
LABEL_92:
            this = (uint64_t)TType2ToType1CharStringConvertionContext::WriteHVorVHCurveTo(v66, v67);
            goto LABEL_126;
          default:
            switch((__int16)v15)
            {
              case 3106:
                if ((unsigned __int16)v17 != 7) {
                  goto LABEL_137;
                }
                *(_DWORD *)(v4 + 2228) = *(_DWORD *)(v4 + 2220) - *(_DWORD *)(v4 + 372);
                long long v100 = v14;
                uint64_t v101 = v110;
                char v98 = v107;
                __int16 v99 = v113;
                uint64_t v19 = v115;
                unsigned int v96 = v14;
                BOOL v97 = v114;
                uint64_t v20 = (TType2ToType1CharStringConvertionContext *)v4;
                uint64_t v21 = (int *)v13;
                uint64_t v22 = v14;
                long long v24 = v117;
                unsigned int v23 = v118;
                unsigned int v25 = v116;
                goto LABEL_100;
              case 3107:
                if ((unsigned __int16)v17 != 13) {
                  goto LABEL_137;
                }
                long long v100 = v105;
                uint64_t v101 = v104;
                int v68 = (unsigned __int8 *)v109;
                goto LABEL_122;
              case 3108:
                if ((unsigned __int16)v17 != 9) {
                  goto LABEL_137;
                }
                *(_DWORD *)(v4 + 2228) = *(_DWORD *)(v4 + 2220)
                                       - (*(_DWORD *)(v4 + 368)
                                        + *(_DWORD *)(v4 + 376))
                                       + *(_DWORD *)(v4 + 392);
                long long v100 = v107;
                uint64_t v101 = v110;
                char v98 = v112;
                __int16 v99 = v111;
                uint64_t v19 = v114;
                unsigned int v96 = v14;
                BOOL v97 = v113;
                uint64_t v20 = (TType2ToType1CharStringConvertionContext *)v4;
                uint64_t v21 = (int *)v13;
                unsigned int v25 = v117;
                uint64_t v22 = v118;
                unsigned int v23 = v116;
                long long v24 = v115;
LABEL_100:
                int16x4_t v69 = v14;
                goto LABEL_123;
              case 3109:
                if ((unsigned __int16)v17 != 11) {
                  goto LABEL_137;
                }
                int32x2_t v70 = vadd_s32(vadd_s32(vadd_s32(v13[1], *v13), vadd_s32(v13[2], v13[3])), v13[4]);
                int32x2_t v71 = vabs_s32(v70);
                if (vcgt_u32((uint32x2_t)v71, (uint32x2_t)vdup_lane_s32(v71, 1)).u8[0])
                {
                  int v72 = *v109;
                  int v73 = *v14 - v70.i32[1];
                }
                else
                {
                  int v72 = *v14 - v70.i32[0];
                  int v73 = *v109;
                }
                int v123 = v73;
                *(_DWORD *)__int16 v124 = v72;
                long long v100 = &v123;
                uint64_t v101 = v110;
                int v68 = v124;
LABEL_122:
                __int16 v99 = (int *)v68;
                BOOL v97 = v111;
                char v98 = v106;
                uint64_t v19 = v113;
                unsigned int v96 = v112;
                uint64_t v20 = (TType2ToType1CharStringConvertionContext *)v4;
                uint64_t v21 = (int *)v13;
                unsigned int v25 = v117;
                uint64_t v22 = v118;
                unsigned int v23 = v116;
                int16x4_t v69 = v114;
                long long v24 = v115;
LABEL_123:
                this = (uint64_t)TType2ToType1CharStringConvertionContext::WriteExpandedFlexCurveTo(v20, v21, v22, v23, v25, v24, v69, v19, v96, v97, v98, v99, v100, v101);
                break;
              default:
                if ((unsigned __int16)v15 != 3072 || (_WORD)v17) {
                  goto LABEL_137;
                }
                TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 1, 1, 0, 0);
                *(_WORD *)__int16 v124 = 12;
                this = (uint64_t)TCharStringConversionContext::WriteData((TCharStringConversionContext *)v4, v124, 2u);
                break;
            }
            goto LABEL_126;
        }
        do
        {
          if (!v39)
          {
            int v42 = *(unsigned __int8 **)(v4 + 336);
            long long v43 = v42 + 1;
            if (*(void *)(v4 + 328) > (unint64_t)v42 || (unint64_t)v43 > *(void *)(v4 + 320)) {
              goto LABEL_137;
            }
            *(void *)(v4 + 336) = v43;
            int v40 = *v42;
            unsigned int v39 = 128;
          }
          if ((v39 & v40) != 0)
          {
            unsigned int v45 = *(_DWORD *)(v4 + 2100);
            if (v45 > 0x1F) {
              goto LABEL_137;
            }
            *v41 |= 1 << v45;
            unsigned int v46 = v45 + 1;
            if (*((_WORD *)v41 - 2) == 1) {
              *(_DWORD *)(v4 + 2104) = v46;
            }
            else {
              *(_DWORD *)(v4 + 2108) = v46;
            }
          }
          v39 >>= 1;
          v41 += 4;
          --v38;
        }
        while (v38);
LABEL_72:
        ++*(_DWORD *)(v4 + 2100);
LABEL_126:
        unsigned int v94 = *(unsigned __int16 *)(v4 + 354);
        if (v94 > 0x1D || ((1 << v94) & 0x20010C00) == 0) {
          *(_WORD *)(v4 + 556) = 0;
        }
        uint64_t v5 = *(unsigned __int8 **)(v4 + 336);
        int v122 = v5;
        if (v94 == 14)
        {
          *__int16 v3 = 1;
          return this;
        }
        int v12 = 0;
        unint64_t v7 = *(void *)(v4 + 320);
        unint64_t v6 = *(void *)(v4 + 328);
      }
      else
      {
        ++v12;
        if (v15 == 255)
        {
          v5 += 5;
LABEL_20:
          *(void *)(v4 + 336) = v5;
          goto LABEL_130;
        }
        if (v15 >= 0xF7)
        {
          v5 += 2;
          goto LABEL_20;
        }
        uint64_t v5 = (unsigned __int8 *)v8;
      }
LABEL_130:
      BOOL v9 = !*v3;
      if (v6 <= (unint64_t)v5)
      {
        int v8 = (char *)(v5 + 1);
        if ((unint64_t)(v5 + 1) <= v7 && !*v3) {
          continue;
        }
      }
      break;
    }
  }
  if (v9) {
    goto LABEL_137;
  }
  return this;
}

int TType2ToType1CharStringConvertionContext::ArgPtrToFixed(TType2ToType1CharStringConvertionContext *this, const unsigned __int8 **a2, const unsigned __int8 *a3)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned __int8 **)this;
  unint64_t v6 = (const unsigned __int8 *)(*(void *)this + 1);
  unsigned int v5 = **(unsigned __int8 **)this;
  if (v5 < 0x20)
  {
    if (v5 == 30)
    {
      memset(v13, 170, 18);
      unint64_t v6 = BCDtoASCII(v6, (const unsigned __int8 *)a2, (char (*)[18])v13);
      int result = vcvtd_n_s64_f64(atof_l((const char *)v13, 0), 0x10uLL);
    }
    else
    {
      if (v5 == 29)
      {
        int v8 = v4[3];
        unint64_t v6 = v4 + 5;
        int v9 = v4[4];
      }
      else
      {
        if (v5 != 28)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *(void *)exception = &unk_1F0DFC400;
          exception[4] = 5;
        }
        int v8 = v4[1];
        unint64_t v6 = v4 + 3;
        int v9 = v4[2];
      }
      int result = (v8 << 24) | (v9 << 16);
    }
  }
  else
  {
    if (v5 > 0xF6)
    {
      if (v5 > 0xFA)
      {
        if (v5 == 255)
        {
          unint64_t v6 = v4 + 5;
          int result = bswap32(*(_DWORD *)(v4 + 1));
          goto LABEL_17;
        }
        unint64_t v6 = v4 + 2;
        int v10 = -9109504 - ((v4[1] << 16) | (v5 << 24));
        int v11 = -81854464;
      }
      else
      {
        unint64_t v6 = v4 + 2;
        int v10 = (v4[1] << 16) | (v5 << 24);
        int v11 = 158072832;
      }
      int result = v10 + v11;
      goto LABEL_17;
    }
    int result = (v5 << 16) - 9109504;
  }
LABEL_17:
  *(void *)this = v6;
  return result;
}

uint64_t TType2ToType1CharStringConvertionContext::WriteVStem(TType2ToType1CharStringConvertionContext *this)
{
  TType2ToType1CharStringConvertionContext::StateChange((int *)this, 0, 0, 1, *((_WORD *)this + 278) & 0xFFFE);
  return TType2ToType1CharStringConvertionContext::AddToHintMap((uint64_t)this, 3);
}

void *TType2ToType1CharStringConvertionContext::WriteHLineToAndVLineTo(TType2ToType1CharStringConvertionContext *this, char a2)
{
  int result = TType2ToType1CharStringConvertionContext::StateChange((int *)this, 2, 1, 0, 0);
  if (*((_WORD *)this + 278))
  {
    uint64_t v5 = 1;
    int v6 = 1;
    do
    {
      unint64_t v7 = (char *)this + 4 * v5 + 364;
      int v8 = (int *)(v7 - 4);
      if (a2)
      {
        int v9 = (int *)(v7 - 4);
        int v8 = (int *)((char *)this + 2220);
      }
      else
      {
        int v9 = (int *)((char *)this + 2220);
      }
      int result = TType2ToType1CharStringConvertionContext::RLineTo(this, v9, v8);
      a2 ^= 1u;
      uint64_t v5 = (unsigned __int16)++v6;
    }
    while (*((unsigned __int16 *)this + 278) >= (unsigned __int16)v6);
  }
  return result;
}

unsigned __int16 *TType2ToType1CharStringConvertionContext::WriteHVorVHCurveTo(unsigned __int16 *this, char a2)
{
  unsigned int v2 = this[278];
  if (v2 >= 4)
  {
    uint64_t v4 = (uint64_t)this;
    int v5 = 0;
    uint64_t v6 = 0;
    unint64_t v7 = (int *)(this + 1110);
    int v8 = (char *)(this + 182);
    unsigned int v9 = 4;
    do
    {
      if (v5 + 5 == v2)
      {
        int v10 = (int *)&v8[4 * v6];
        int v11 = (int *)&v8[4 * (v5 + 2)];
        TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 2, 1, 0, 0);
        if (a2)
        {
          this = (unsigned __int16 *)TType2ToType1CharStringConvertionContext::RRCurveTo((TType2ToType1CharStringConvertionContext *)v4, v10, v7, (int *)&v8[4 * (v5 + 1)], v11, (int *)&v8[4 * v9], (int *)&v8[4 * (v5 + 3)]);
          a2 = 1;
        }
        else
        {
          this = (unsigned __int16 *)TType2ToType1CharStringConvertionContext::RRCurveTo((TType2ToType1CharStringConvertionContext *)v4, v7, v10, (int *)&v8[4 * (v5 + 1)], v11, (int *)&v8[4 * (v5 + 3)], (int *)&v8[4 * v9]);
          a2 = 0;
        }
        LOWORD(v9) = v2;
      }
      else
      {
        TType2ToType1CharStringConvertionContext::StateChange((int *)v4, 2, 1, 0, 0);
        int v12 = (int *)&v8[4 * v6];
        unsigned int v13 = (int *)&v8[4 * (v5 + 3)];
        if (a2)
        {
          __int16 v14 = (int *)&v8[4 * v6];
          int v12 = v7;
          unsigned int v15 = v7;
        }
        else
        {
          __int16 v14 = v7;
          unsigned int v15 = (int *)&v8[4 * (v5 + 3)];
          unsigned int v13 = v7;
        }
        this = (unsigned __int16 *)TType2ToType1CharStringConvertionContext::RRCurveTo((TType2ToType1CharStringConvertionContext *)v4, v14, v12, (int *)&v8[4 * (v5 + 1)], (int *)&v8[4 * (v5 + 2)], v15, v13);
        a2 ^= 1u;
      }
      uint64_t v6 = (unsigned __int16)v9;
      int v5 = (unsigned __int16)v9;
      unsigned int v9 = (unsigned __int16)v9 + 4;
      unsigned int v2 = *(unsigned __int16 *)(v4 + 556);
    }
    while (v9 <= v2);
  }
  return this;
}

__n128 TType2ToType1CharStringConvertionContext::FlattenSubr(__n128 *this, unsigned int a2, BOOL *a3)
{
  unsigned __int16 v6 = this[34].n128_u16[6] - 1;
  this[34].n128_u16[6] = v6;
  unsigned __int16 v7 = this[244].n128_u16[2] + this[22].n128_u16[2 * v6 + 7];
  unsigned int v8 = (*(uint64_t (**)(unint64_t))(*(void *)this[19].n128_u64[1] + 144))(this[19].n128_u64[1]);
  if (v7 >= v8) {
    goto LABEL_23;
  }
  unsigned int v9 = v8;
  *(void *)&v33[1] = 0;
  v33[0] = -21846;
  unint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = (*(uint64_t (**)(unint64_t, unint64_t *, _WORD *, _WORD *))(*(void *)this[19].n128_u64[1]
                                                                                          + 136))(this[19].n128_u64[1], &v32, v33, &v33[1]);
  if (!v10 || v32 == 0) {
    goto LABEL_23;
  }
  int v12 = v33[0];
  int v13 = v12 + v12 * v9;
  unint64_t v14 = *(void *)&v33[1];
  unint64_t v15 = v32 + v13;
  BOOL v16 = v15 < v32 || v15 > *(void *)&v33[1];
  if (v16 || v33[0] * v7 < 0) {
    goto LABEL_23;
  }
  uint64_t v17 = (const unsigned __int8 *)(v32 + v33[0] * v7);
  unint64_t v18 = v32 + v13;
  uint64_t v19 = &v17[2 * v33[0]];
  BOOL v20 = v19 < v17 || (unint64_t)v19 > v18;
  if (v20
    || ((unint64_t v21 = v10,
         unsigned int v22 = BytesToCard(v17, v33[0]),
         int v23 = BytesToCard(&v17[v12], v12),
         unint64_t v24 = v21 + v22 - 1,
         unint64_t v25 = v24 + v23 - v22,
         v21 <= v24)
      ? (BOOL v26 = v25 >= v24)
      : (BOOL v26 = 0),
        v26 ? (BOOL v27 = v25 > v14) : (BOOL v27 = 1),
        v27))
  {
LABEL_23:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  unint64_t v28 = this[21].n128_u64[0];
  __n128 v31 = this[20];
  this[20].n128_u64[1] = v24;
  this[21].n128_u64[0] = v24;
  this[20].n128_u64[0] = v25;
  TType2ToType1CharStringConvertionContext::ConvertT2ToT1CharString((uint64_t)this, a2, a3);
  __n128 result = v31;
  this[20] = v31;
  this[21].n128_u64[0] = v28;
  return result;
}

__n128 TType2ToType1CharStringConvertionContext::FlattenGlobalSubr(__n128 *this, unsigned int a2, BOOL *a3)
{
  unsigned __int16 v3 = this[34].n128_u16[6] - 1;
  this[34].n128_u16[6] = v3;
  unsigned __int16 v4 = this[244].n128_u16[3] + this[22].n128_u16[2 * v3 + 7];
  if (this[244].n128_u16[4] <= v4) {
    goto LABEL_17;
  }
  memset(v26, 170, sizeof(v26));
  __int16 v25 = -21846;
  unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v8 = (*(uint64_t (**)(unint64_t, __int16 *, void *, unint64_t *, void *, void *))(*(void *)this[19].n128_u64[1] + 152))(this[19].n128_u64[1], &v25, &v26[2], &v24, &v26[1], v26);
  if (v26[2] < v8 || v26[2] > v26[0]) {
    goto LABEL_17;
  }
  int v10 = v4;
  uint64_t v11 = v25;
  unint64_t v12 = v8 + v25 * (uint64_t)v10;
  unint64_t v13 = v12 + 2 * v25;
  if (v13 > v26[2] || v25 * (uint64_t)v10 < 0 || v13 < v12) {
    goto LABEL_17;
  }
  unsigned int v14 = BytesToCard((const unsigned __int8 *)(v8 + v25 * (uint64_t)v10), v25);
  int v15 = BytesToCard((const unsigned __int8 *)(v12 + v11), v11);
  unint64_t v16 = v24 + v14 - 1;
  unint64_t v17 = v16 + v15 - v14;
  BOOL v18 = v24 <= v16 && v17 >= v16;
  if (!v18 || v17 > v26[1])
  {
LABEL_17:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  unint64_t v20 = this[21].n128_u64[0];
  __n128 v23 = this[20];
  this[20].n128_u64[1] = v16;
  this[21].n128_u64[0] = v16;
  this[20].n128_u64[0] = v17;
  TType2ToType1CharStringConvertionContext::ConvertT2ToT1CharString((uint64_t)this, a2, a3);
  __n128 result = v23;
  this[20] = v23;
  this[21].n128_u64[0] = v20;
  return result;
}

int *TType2ToType1CharStringConvertionContext::StateChange(int *this, int a2, int a3, int a4, unsigned int a5)
{
  uint64_t v8 = (uint64_t)this;
  if (a2 == 2)
  {
    if (!this[86]) {
      this = (int *)TType2ToType1CharStringConvertionContext::RMoveTo((TType2ToType1CharStringConvertionContext *)this, this + 555, this + 555);
    }
    int v9 = 2;
  }
  else
  {
    if (a2 != 1) {
      goto LABEL_10;
    }
    if (this[86] == 2)
    {
      __int16 v12 = 2316;
      this = (int *)TCharStringConversionContext::WriteData((TCharStringConversionContext *)this, (const unsigned __int8 *)&v12 + 1, 1u);
    }
    int v9 = 1;
  }
  *(_DWORD *)(v8 + 344) = v9;
LABEL_10:
  if (a3 == 1)
  {
    if (*(_DWORD *)(v8 + 348) == 1) {
      this = (int *)TType2ToType1CharStringConvertionContext::WriteHints((_WORD *)v8, 1);
    }
    *(_DWORD *)(v8 + 348) = 0;
  }
  if (*(unsigned char *)(v8 + 352) && a4)
  {
    *(unsigned char *)(v8 + 352) = 0;
    if (*(unsigned __int16 *)(v8 + 556) <= a5)
    {
      return (int *)TType2ToType1CharStringConvertionContext::Hsbw((TType2ToType1CharStringConvertionContext *)v8, (int *)(v8 + 2220), (int *)(v8 + 3776));
    }
    else
    {
      int v11 = *(_DWORD *)(v8 + 3772) + *(_DWORD *)(v8 + 364);
      this = (int *)TType2ToType1CharStringConvertionContext::Hsbw((TType2ToType1CharStringConvertionContext *)v8, (int *)(v8 + 2220), &v11);
      unint64_t v10 = *(unsigned __int16 *)(v8 + 556);
      if (v10 >= 2) {
        this = (int *)memmove((void *)(v8 + 364), (const void *)(v8 + 368), ((4 * v10 + 0x3FFFFFFF8) & 0x3FFFFFFFCLL) + 4);
      }
      *(_WORD *)(v8 + 556) = v10 - 1;
    }
  }
  return this;
}

void *TType2ToType1CharStringConvertionContext::RMoveTo(TType2ToType1CharStringConvertionContext *this, int *a2, int *a3)
{
  if (*a2)
  {
    int v6 = *a3;
    TCharStringConversionContext::WriteFixed(this, a2);
    if (!v6)
    {
      unsigned int v7 = 22;
      goto LABEL_7;
    }
    unsigned int v7 = 21;
  }
  else
  {
    unsigned int v7 = 4;
  }
  TCharStringConversionContext::WriteFixed(this, a3);
LABEL_7:
  __n128 result = TCharStringConversionContext::WriteOpCode(this, v7);
  *((_DWORD *)this + 89) += *a2;
  *((_DWORD *)this + 90) += *a3;
  return result;
}

_WORD *TType2ToType1CharStringConvertionContext::WriteHints(_WORD *this, char a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (this[1048])
  {
    uint64_t v3 = (uint64_t)this;
    unint64_t v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    unsigned int v7 = 0;
    int v8 = 0;
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v22 = v9;
    *(_OWORD *)__n128 v23 = v9;
    long long v20 = v9;
    *(_OWORD *)unint64_t v21 = v9;
    *(_OWORD *)BOOL v18 = v9;
    long long v19 = v9;
    unint64_t v10 = (char *)(this + 280);
    do
    {
      if ((a2 & 1) == 0 && !v7)
      {
        int v11 = *(unsigned __int8 **)(v3 + 336);
        __int16 v12 = v11 + 1;
        if (*(void *)(v3 + 328) > (unint64_t)v11 || (unint64_t)v12 > *(void *)(v3 + 320)) {
          goto LABEL_38;
        }
        *(void *)(v3 + 336) = v12;
        int v8 = *v11;
        unsigned int v7 = 128;
      }
      if ((a2 & 1) != 0 || (v7 & v8) != 0)
      {
        if (*((_DWORD *)v10 + 3) && !*(_DWORD *)(v3 + 2216))
        {
          if (*((_WORD *)v10 + 4) == 1)
          {
            if (v6 > 2) {
              goto LABEL_38;
            }
            *(_OWORD *)&v21[4 * v6++] = *(_OWORD *)v10;
          }
          else
          {
            if (v5 > 2) {
              goto LABEL_38;
            }
            *(_OWORD *)&v18[4 * v5++] = *(_OWORD *)v10;
          }
        }
        else
        {
          unsigned int v14 = (int *)(v10 + 4);
          if (*((_WORD *)v10 + 4) == 1) {
            this = TType2ToType1CharStringConvertionContext::HStem((TType2ToType1CharStringConvertionContext *)v3, (int *)v10, v14);
          }
          else {
            this = TType2ToType1CharStringConvertionContext::VStem((TType2ToType1CharStringConvertionContext *)v3, (int *)v10, v14);
          }
        }
      }
      v7 >>= 1;
      ++v4;
      v10 += 16;
    }
    while (v4 < *(unsigned __int16 *)(v3 + 2096));
    if (v6 >= 4)
    {
LABEL_38:
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DFC400;
      exception[4] = 5;
    }
    switch(v6)
    {
      case 1u:
        this = TType2ToType1CharStringConvertionContext::HStem((TType2ToType1CharStringConvertionContext *)v3, v21, &v21[1]);
        break;
      case 2u:
        TType2ToType1CharStringConvertionContext::HStem((TType2ToType1CharStringConvertionContext *)v3, v21, &v21[1]);
        this = TType2ToType1CharStringConvertionContext::HStem((TType2ToType1CharStringConvertionContext *)v3, (int *)&v22, (int *)&v22 + 1);
        break;
      case 3u:
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, v21);
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, &v21[1]);
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, (int *)&v22);
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, (int *)&v22 + 1);
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, v23);
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, &v23[1]);
        *(_WORD *)unint64_t v17 = 524;
        this = TCharStringConversionContext::WriteData((TCharStringConversionContext *)v3, v17, 2u);
        *(unsigned char *)(v3 + 353) = 0;
        break;
    }
    if (v5 > 3)
    {
      unint64_t v16 = __cxa_allocate_exception(0x10uLL);
      *(void *)unint64_t v16 = &unk_1F0DFC400;
      uint64_t v16[4] = 5;
    }
    switch(v5)
    {
      case 1u:
        return TType2ToType1CharStringConvertionContext::VStem((TType2ToType1CharStringConvertionContext *)v3, v18, &v18[1]);
      case 2u:
        TType2ToType1CharStringConvertionContext::VStem((TType2ToType1CharStringConvertionContext *)v3, v18, &v18[1]);
        return TType2ToType1CharStringConvertionContext::VStem((TType2ToType1CharStringConvertionContext *)v3, (int *)&v19, (int *)&v19 + 1);
      case 3u:
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, v18);
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, &v18[1]);
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, (int *)&v19);
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, (int *)&v19 + 1);
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, (int *)&v20);
        TCharStringConversionContext::WriteFixed((TCharStringConversionContext *)v3, (int *)&v20 + 1);
        *(_WORD *)unint64_t v17 = 268;
        this = TCharStringConversionContext::WriteData((TCharStringConversionContext *)v3, v17, 2u);
        *(unsigned char *)(v3 + 353) = 0;
        break;
    }
  }
  return this;
}

void *TType2ToType1CharStringConvertionContext::Hsbw(TType2ToType1CharStringConvertionContext *this, int *a2, int *a3)
{
  TCharStringConversionContext::WriteFixed(this, a2);
  TCharStringConversionContext::WriteFixed(this, a3);
  HIBYTE(v6) = 13;
  return TCharStringConversionContext::WriteData(this, (const unsigned __int8 *)&v6 + 1, 1u);
}

uint64_t TType2ToType1CharStringConvertionContext::AddToHintMap(uint64_t this, __int16 a2)
{
  unsigned int v2 = *(unsigned __int16 *)(this + 556);
  if (v2 >= 2)
  {
    int v3 = 0;
    unsigned int v4 = v2 >> 1;
    uint64_t v5 = *(unsigned __int16 *)(this + 2096);
    if (v5 <= 0x60) {
      uint64_t v6 = 96;
    }
    else {
      uint64_t v6 = *(unsigned __int16 *)(this + 2096);
    }
    unsigned int v7 = (int *)(this + 368);
    int v8 = (_DWORD *)(this + 16 * v5 + 572);
    unsigned int v9 = 1;
    do
    {
      if (v6 == v5)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *(void *)exception = &unk_1F0DFC400;
        exception[4] = 5;
      }
      int v10 = *(v7 - 1) + v3;
      int v11 = *v7;
      v7 += 2;
      *(v8 - 3) = v10;
      *(v8 - 2) = v11;
      *((_WORD *)v8 - 2) = a2;
      *int v8 = 0;
      v8 += 4;
      int v3 = v10 + v11;
      *(_WORD *)(this + 2096) = ++v5;
    }
    while (v9++ < v4);
  }
  return this;
}

void *TType2ToType1CharStringConvertionContext::RLineTo(TType2ToType1CharStringConvertionContext *this, int *a2, int *a3)
{
  if (*a2)
  {
    int v6 = *a3;
    TCharStringConversionContext::WriteFixed(this, a2);
    if (!v6)
    {
      unsigned int v7 = 6;
      goto LABEL_7;
    }
    unsigned int v7 = 5;
  }
  else
  {
    unsigned int v7 = 7;
  }
  TCharStringConversionContext::WriteFixed(this, a3);
LABEL_7:
  __n128 result = TCharStringConversionContext::WriteOpCode(this, v7);
  *((_DWORD *)this + 89) += *a2;
  *((_DWORD *)this + 90) += *a3;
  return result;
}

void *TType2ToType1CharStringConvertionContext::RRCurveTo(TType2ToType1CharStringConvertionContext *this, int *a2, int *a3, int *a4, int *a5, int *a6, int *a7)
{
  __int16 v12 = a2;
  if (!(*a3 | *a6))
  {
    unsigned int v18 = 31;
    unsigned int v14 = a4;
    int v15 = a5;
LABEL_6:
    unint64_t v16 = a7;
    goto LABEL_7;
  }
  if (*a2 | *a7)
  {
    TCharStringConversionContext::WriteFixed(this, a2);
    TCharStringConversionContext::WriteFixed(this, a3);
    unsigned int v18 = 8;
    a2 = a4;
    unsigned int v14 = a5;
    int v15 = a6;
    goto LABEL_6;
  }
  unsigned int v18 = 30;
  a2 = a3;
  unsigned int v14 = a4;
  int v15 = a5;
  unint64_t v16 = a6;
LABEL_7:
  TCharStringConversionContext::WriteFixed(this, a2);
  TCharStringConversionContext::WriteFixed(this, v14);
  TCharStringConversionContext::WriteFixed(this, v15);
  TCharStringConversionContext::WriteFixed(this, v16);
  __n128 result = TCharStringConversionContext::WriteOpCode(this, v18);
  *((_DWORD *)this + 89) += *a4 + *v12 + *a6;
  *((_DWORD *)this + 90) += *a5 + *a3 + *a7;
  return result;
}

void *TType2ToType1CharStringConvertionContext::WriteExpandedFlexCurveTo(TType2ToType1CharStringConvertionContext *this, int *a2, int *a3, int *a4, int *a5, int *a6, int *a7, int *a8, int *a9, int *a10, int *a11, int *a12, int *a13, int *a14)
{
  int v21 = *((_DWORD *)this + 89);
  int v22 = *a2 + v21;
  int v23 = v22 + *a4 + *a6;
  int v24 = v23 + *a8 + *a10 + *a12;
  int v25 = *((_DWORD *)this + 90);
  int v26 = *a3 + v25 + *a5 + *a7;
  int v27 = v26 + *a9 + *a11 + *a13;
  int v34 = v27;
  int v35 = v24;
  unsigned int v28 = v24 - v21;
  if (v24 - v21 < 0) {
    unsigned int v28 = v21 - v24;
  }
  unsigned int v29 = v27 - v25;
  if (v27 - v25 < 0) {
    unsigned int v29 = v25 - v27;
  }
  if (v28 <= v29) {
    int v23 = v24;
  }
  else {
    int v26 = v27;
  }
  int v33 = v23 - v21;
  int v32 = v26 - v25;
  *a2 = v22 - v23;
  *a3 += *((_DWORD *)this + 90) - v26;
  TType2ToType1CharStringConvertionContext::StateChange((int *)this, 2, 1, 0, 0);
  int v36 = 0x10000;
  TCharStringConversionContext::WriteFixed(this, &v36);
  __int16 v37 = 2572;
  TCharStringConversionContext::WriteData(this, (const unsigned __int8 *)&v37 + 1, 1u);
  TType2ToType1CharStringConvertionContext::WriteFlexCoordinate(this, &v33, &v32);
  TType2ToType1CharStringConvertionContext::WriteFlexCoordinate(this, a2, a3);
  TType2ToType1CharStringConvertionContext::WriteFlexCoordinate(this, a4, a5);
  TType2ToType1CharStringConvertionContext::WriteFlexCoordinate(this, a6, a7);
  TType2ToType1CharStringConvertionContext::WriteFlexCoordinate(this, a8, a9);
  TType2ToType1CharStringConvertionContext::WriteFlexCoordinate(this, a10, a11);
  TType2ToType1CharStringConvertionContext::WriteFlexCoordinate(this, a12, a13);
  TCharStringConversionContext::WriteFixed(this, a14);
  TCharStringConversionContext::WriteFixed(this, &v35);
  TCharStringConversionContext::WriteFixed(this, &v34);
  TCharStringConversionContext::WriteFixed(this, (int *)this + 555);
  __int16 v37 = 2572;
  __n128 result = TCharStringConversionContext::WriteData(this, (const unsigned __int8 *)&v37 + 1, 1u);
  *((_DWORD *)this + 89) = v35;
  *((_DWORD *)this + 90) = v34;
  return result;
}

void *TType2ToType1CharStringConvertionContext::HStem(TType2ToType1CharStringConvertionContext *this, int *a2, int *a3)
{
  TCharStringConversionContext::WriteFixed(this, a2);
  TCharStringConversionContext::WriteFixed(this, a3);
  HIBYTE(v6) = 1;
  __n128 result = TCharStringConversionContext::WriteData(this, (const unsigned __int8 *)&v6 + 1, 1u);
  *((unsigned char *)this + 353) = 0;
  return result;
}

void *TType2ToType1CharStringConvertionContext::VStem(TType2ToType1CharStringConvertionContext *this, int *a2, int *a3)
{
  TCharStringConversionContext::WriteFixed(this, a2);
  TCharStringConversionContext::WriteFixed(this, a3);
  HIBYTE(v6) = 3;
  __n128 result = TCharStringConversionContext::WriteData(this, (const unsigned __int8 *)&v6 + 1, 1u);
  *((unsigned char *)this + 353) = 0;
  return result;
}

void *TType2ToType1CharStringConvertionContext::WriteFlexCoordinate(TType2ToType1CharStringConvertionContext *this, int *a2, int *a3)
{
  if (*a2)
  {
    int v5 = *a3;
    TCharStringConversionContext::WriteFixed(this, a2);
    if (!v5)
    {
      unsigned int v6 = 22;
      goto LABEL_7;
    }
    unsigned int v6 = 21;
  }
  else
  {
    unsigned int v6 = 4;
  }
  TCharStringConversionContext::WriteFixed(this, a3);
LABEL_7:
  TCharStringConversionContext::WriteOpCode(this, v6);
  int v8 = 0x20000;
  TCharStringConversionContext::WriteFixed(this, &v8);
  __int16 v9 = 2572;
  return TCharStringConversionContext::WriteData(this, (const unsigned __int8 *)&v9 + 1, 1u);
}

void TT2T1ConvertingBufferedStreamingContext::~TT2T1ConvertingBufferedStreamingContext(TT2T1ConvertingBufferedStreamingContext *this)
{
  TBufferedCharStringStreamingContext::~TBufferedCharStringStreamingContext(this);
  JUMPOUT(0x1BA9994D0);
}

void TT2T1ConvertingBufferedStreamingContext::StreamCharString(TT2T1ConvertingBufferedStreamingContext *this, const TType1SFNTFont *a2, uint64_t a3, char *a4, int *a5)
{
  v29[491] = *MEMORY[0x1E4F143B8];
  memset(&v29[1], 170, 0xF50uLL);
  v29[33] = "/.notdef";
  v29[34] = 8;
  memset(&v29[35], 0, 20);
  MCharStringConvertionState::MCharStringConvertionState((MCharStringConvertionState *)&v29[38], a2);
  v29[0] = off_1F0DFD8F8;
  *int v10 = &unk_1F0DFD930;
  uint64_t v11 = (*(uint64_t (**)(const TType1SFNTFont *))(*(void *)a2 + 216))(a2);
  uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(v11 + 8) + 56))(*(void *)(v11 + 8));
  v29[490] = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 24))(v12);
  unsigned int v13 = (*(uint64_t (**)(const TType1SFNTFont *))(*(void *)a2 + 144))(a2);
  if (v13 >= 0x8408) {
    __int16 v14 = -1;
  }
  else {
    __int16 v14 = 1131;
  }
  if (v13 < 0x4D8) {
    __int16 v14 = 107;
  }
  WORD2(v29[488]) = v14;
  uint64_t v15 = *((void *)a2 + 4);
  unsigned int v16 = *(unsigned __int16 *)(v15 + 318);
  if (v16 >= 0x846C) {
    __int16 v17 = 0x8000;
  }
  else {
    __int16 v17 = 1131;
  }
  if (v16 < 0x4D8) {
    __int16 v17 = 107;
  }
  HIWORD(v29[488]) = v17;
  LOWORD(v29[489]) = v16;
  if (a3)
  {
    int v18 = (*(uint64_t (**)(const TType1SFNTFont *, uint64_t, uint64_t, char *))(*(void *)a2 + 184))(a2, a3, 127, (char *)&v29[472] + 5);
    BYTE4(v29[472]) = 47;
    v29[33] = (char *)&v29[472] + 4;
    v29[34] = (v18 + 1);
    uint64_t v15 = *((void *)a2 + 4);
  }
  uint64_t v19 = *(void *)(v15 + 104);
  unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v26[1] = v20;
  long long v27 = v20;
  v26[0] = v20;
  int v21 = (const TFontObjectSurrogate *)(*(uint64_t (**)(const TType1SFNTFont *))(*(void *)a2 + 216))(a2);
  uint64_t v22 = (*(uint64_t (**)(const TType1SFNTFont *))(*(void *)a2 + 120))(a2);
  int v23 = (unsigned int *)(v19 + 8 * a3);
  TFontObjectTable::TFontObjectTable((TFontObjectTable *)v26, v21, v22, *v23, v23[1]);
  v29[41] = *((void *)&v27 + 1);
  v29[42] = *((void *)&v27 + 1);
  uint64_t v24 = v23[1];
  v29[40] = *((void *)&v27 + 1) + v24;
  LODWORD(v29[37]) = malloc_good_size((4 * v24));
  v29[35] = AllocateMemory(LODWORD(v29[37]), 0);
  v29[36] = 0;
  BOOL v25 = 0;
  TType2ToType1CharStringConvertionContext::ConvertT2ToT1CharString((uint64_t)v29, 0, &v25);
  TDataReference::~TDataReference((TDataReference *)((char *)v26 + 8));
  TBufferedCharStringStreamingContext::DoCharString(this, (uint64_t)v29, a4, (uint64_t)a5);
  v29[0] = off_1F0DFD8F8;
  v29[38] = &unk_1F0DFD930;
  free((void *)v29[35]);
}

void sub_1B52DF084(_Unwind_Exception *a1)
{
  *(void *)(v2 + 304) = v1;
  free(*(void **)(v2 + 280));
  _Unwind_Resume(a1);
}

void TOTFCharStringContext::~TOTFCharStringContext(TOTFCharStringContext *this)
{
  *(void *)this = &unk_1F0DFD9A0;
  TDataReference::~TDataReference((TOTFCharStringContext *)((char *)this + 328));
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DFD9A0;
  TDataReference::~TDataReference((TOTFCharStringContext *)((char *)this + 328));
  JUMPOUT(0x1BA9994D0);
}

void TOTFCFFFontSet::~TOTFCFFFontSet(TOTFCFFFontSet *this)
{
  TCFFFontSet::~TCFFFontSet(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TOTFCFFFontSet::AddCharString(TOTFCFFFontSet *this, const TType1PSFont *a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[1] = v6;
  long long v20 = v6;
  long long v18 = v6;
  v19[0] = v6;
  long long v17 = v6;
  v12[15] = v6;
  v12[14] = v6;
  v12[13] = v6;
  v12[12] = v6;
  v12[11] = v6;
  v12[10] = v6;
  void v12[9] = v6;
  v12[8] = v6;
  v12[7] = v6;
  v12[6] = v6;
  v12[5] = v6;
  v12[4] = v6;
  void v12[3] = v6;
  _OWORD v12[2] = v6;
  v12[1] = v6;
  v12[0] = v6;
  unsigned int v13 = "/.notdef";
  *(void *)__int16 v14 = 8;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  *(void *)&long long v17 = (*(uint64_t (**)(const TType1PSFont *))(*(void *)a2 + 216))(a2);
  uint64_t v7 = *((void *)a2 + 4);
  *((void *)&v17 + 1) = *(void *)(v7 + 104) + 8 * a3;
  LOWORD(v18) = *(_WORD *)(*(void *)(v7 + 288) + 2 * a3);
  uint64_t v8 = (*(uint64_t (**)(const TType1PSFont *))(*(void *)a2 + 120))(a2);
  TFontObjectTable::TFontObjectTable((TFontObjectTable *)((char *)&v18 + 8), (const TFontObjectSurrogate *)v17, v8, **((_DWORD **)&v17 + 1), *(_DWORD *)(*((void *)&v17 + 1) + 4));
  unsigned int v9 = (*(uint64_t (**)(const TType1PSFont *, uint64_t, uint64_t, _OWORD *))(*(void *)a2 + 184))(a2, a3, 256, v12);
  if (v9)
  {
    unsigned int v13 = (char *)v12;
    *(void *)__int16 v14 = v9;
  }
  uint64_t v15 = v20;
  unsigned int v10 = *(_DWORD *)(*((void *)&v17 + 1) + 4);
  uint64_t v16 = v10;
  TCFFArray::Add((TOTFCFFFontSet *)((char *)this + 240), v10, (const unsigned __int8 *)v20);
  if (a3)
  {
    a3 = (unsigned __int16)v18;
    if ((unsigned __int16)v18 >= 0x187u) {
      a3 = TCFFStringArray::AddString((TOTFCFFFontSet *)((char *)this + 152), v14[0], v13);
    }
  }
  TDataReference::~TDataReference((TDataReference *)v19);
  return a3;
}

void sub_1B52DF3D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50)
{
}

void TOTFCFFFontSet::AddGlobalSubrs(TOTFCFFFontSet *this, const TType1PSFont *a2, unsigned __int8 a3, const unsigned __int8 *a4, const unsigned __int8 *a5)
{
}

void sub_1B52DF4D8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9994D0](v1, 0x1091C4015871C78);
  _Unwind_Resume(a1);
}

void TType1OTFFont::StreamPSFont(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9, uint64_t a10)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  ((void (*)(unint64_t *__return_ptr))(*a1)[30])(&v18);
  uint64_t v12 = (__int32 *)v18;
  *a9 = ((uint64_t (*)(void **, void))(*a1)[6])(a1, *a9);
  *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v53 = v13;
  long long v52 = v13;
  long long v51 = v13;
  long long v50 = v13;
  long long v49 = v13;
  long long v48 = v13;
  long long v47 = v13;
  long long v46 = v13;
  long long v45 = v13;
  long long v44 = v13;
  long long v43 = v13;
  long long v42 = v13;
  long long v41 = v13;
  long long v40 = v13;
  long long v39 = v13;
  long long v38 = v13;
  long long v37 = v13;
  long long v36 = v13;
  long long v35 = v13;
  long long v34 = v13;
  long long v33 = v13;
  long long v32 = v13;
  long long v31 = v13;
  long long v30 = v13;
  long long v28 = v13;
  long long v29 = v13;
  long long v26 = v13;
  long long v27 = v13;
  long long v24 = v13;
  long long v25 = v13;
  *(_OWORD *)uint64_t v22 = v13;
  long long v23 = v13;
  unsigned int v14 = (*(uint64_t (**)(void *))(*a1[4] + 168))(a1[4]);
  if (v14 >= 0xFFFF) {
    uint64_t v16 = 0xFFFFLL;
  }
  else {
    uint64_t v16 = v14;
  }
  if (!a5) {
    TType1PSFont::SetEncoding(v16, v12, v22, v15);
  }
  if ((*((unsigned char *)a9 + 1) & 2) == 0)
  {
    memset(__b, 170, 0x2B8uLL);
    TBufferedCharStringStreamingContext::TBufferedCharStringStreamingContext(__b, (uint64_t)a1, (uint64_t)v12, a10);
  }
  ((void (*)(void **))(*a1)[15])(a1);
  unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[6] = v17;
  v20[7] = v17;
  _OWORD v20[4] = v17;
  v20[5] = v17;
  v20[2] = v17;
  v20[3] = v17;
  v20[0] = v17;
  v20[1] = v17;
  TBufferedStreamingContext::TBufferedStreamingContext(v20, (uint64_t)a1, (uint64_t)v12, a10);
}

void sub_1B52DFA58(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  TDataReference::~TDataReference((TDataReference *)&a10);
  if (a2 == 1)
  {
    unint64_t v18 = __cxa_begin_catch(a1);
    LOWORD(STACK[0x340]) = v18[4];
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = v18[4];
  }
  TBufferedStreamingContext::~TBufferedStreamingContext((TBufferedStreamingContext *)&STACK[0x300]);
  uint64_t v20 = a16;
  a16 = 0;
  if (v20) {
    MEMORY[0x1BA9994A0](v20, 0x1000C8052888210);
  }
  _Unwind_Resume(a1);
}

uint64_t TType2ToType1CharStringConvertionContext::GetOutputType(TType2ToType1CharStringConvertionContext *this)
{
  return 1;
}

double ComputeVectorScalar(int a1, const __int16 *a2, const __int16 *a3)
{
  float v3 = 0.0;
  while (1)
  {
    unsigned int v4 = *(unsigned __int16 *)a3++;
    float v5 = (float)((int)bswap32(v4) >> 16) * 0.000061035;
    int v7 = *a2++;
    int v6 = v7;
    if (v5 != 0.0) {
      break;
    }
LABEL_3:
    *(float *)&double result = v3;
    if (!--a1) {
      return result;
    }
  }
  float v9 = (float)v6 * 0.000061035;
  double result = 0.0;
  if (v9 != 0.0 && ((LODWORD(v9) ^ LODWORD(v5)) & 0x80000000) == 0)
  {
    if (v5 >= 0.0)
    {
      if (v3 == 0.0)
      {
        float v3 = (float)v6 * 0.000061035;
      }
      else if (v9 != 1.0)
      {
        float v3 = v3 * v9;
      }
    }
    else if (v3 == 0.0)
    {
      float v3 = -v9;
    }
    else if (v9 != -1.0)
    {
      float v3 = -(float)(v9 * v3);
    }
    goto LABEL_3;
  }
  return result;
}

double ComputeTupleScalar(int a1, uint64_t a2, int a3, unint64_t a4, __int16 *a5, unint64_t a6)
{
  unsigned int v6 = bswap32(*(unsigned __int16 *)(a4 + 2)) >> 16;
  if ((v6 & 0x1000) != 0) {
    return 0.0;
  }
  if ((v6 & 0x8000) != 0)
  {
    int v7 = (const __int16 *)(a4 + 4);
    unint64_t v8 = a4 + 4 + 2 * a1;
    if (v8 < a4 + 4 || v8 > a6)
    {
      unint64_t v9 = a4 + 6 <= a6 ? (a6 - (unint64_t)v7) >> 1 : 0;
      if (v9 != a1) {
        goto LABEL_67;
      }
    }
  }
  else
  {
    if ((unsigned __int16)(v6 & 0xFFF) >= a3) {
      goto LABEL_67;
    }
    int v7 = (const __int16 *)(a2 + 2 * (int)((v6 & 0xFFF) * a1));
  }
  if ((v6 & 0x4000) == 0)
  {
    return ComputeVectorScalar(a1, a5, v7);
  }
  int v11 = (__int16)v6;
  uint64_t v12 = a1;
  if (v11 < 0) {
    uint64_t v13 = a1;
  }
  else {
    uint64_t v13 = 0;
  }
  unsigned int v14 = (unsigned __int16 *)(a4 + 2 * v13 + 4);
  uint64_t v15 = &v14[a1];
  if ((unint64_t)v14 < a4 || v15 < v14 || (unint64_t)v15 > a6)
  {
    BOOL v18 = (unint64_t)(v14 + 1) <= a6 && (unint64_t)v14 >= a4;
    unint64_t v19 = (a6 - (unint64_t)v14) >> 1;
    if (!v18) {
      unint64_t v19 = 0;
    }
    if (v19 != a1) {
      goto LABEL_67;
    }
  }
  unint64_t v20 = (unint64_t)&v15[a1];
  BOOL v21 = (unint64_t)v15 >= a4 && v20 >= (unint64_t)v15;
  if (!v21 || v20 > a6)
  {
    BOOL v23 = (unint64_t)(v15 + 1) <= a6 && (unint64_t)v15 >= a4;
    unint64_t v24 = (a6 - (unint64_t)v15) >> 1;
    if (!v23) {
      unint64_t v24 = 0;
    }
    if (v24 != a1)
    {
LABEL_67:
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 4;
    }
  }
  LODWORD(result) = 1.0;
  if (a1 >= 1)
  {
    do
    {
      unsigned int v25 = *(unsigned __int16 *)v7++;
      float v26 = (float)((int)bswap32(v25) >> 16) * 0.000061035;
      int v28 = *a5++;
      int v27 = v28;
      float v29 = (float)((int)bswap32(*v14) >> 16) * 0.000061035;
      float v30 = (float)((int)bswap32(v14[v12]) >> 16) * 0.000061035;
      if (v26 >= v29 && v30 >= v26)
      {
        BOOL v32 = v29 < 0.0;
        if (v30 <= 0.0) {
          BOOL v32 = 0;
        }
        if (v26 != 0.0 && !v32)
        {
          float v33 = (float)v27 * 0.000061035;
          if (v33 < v29 || v30 < v33) {
            return 0.0;
          }
          if (v33 != v26)
          {
            if (v33 >= v26) {
              float v29 = v30;
            }
            *(float *)&double result = *(float *)&result * (float)((float)(v33 - v29) / (float)(v26 - v29));
          }
        }
      }
      ++v14;
      --a1;
    }
    while (a1);
  }
  return result;
}

unsigned __int16 *ApplyFeaturesToComponents(uint64_t a1, int a2, __int16 *a3, unsigned int a4, void *a5, void *a6)
{
  unsigned int v14 = 0;
  double result = (unsigned __int16 *)GetGlyphVariationPtr(a1, a2, &v14);
  if (result)
  {
    uint64_t v12 = result;
    uint64_t v13 = ApplyVariationsToGlyph(*(_DWORD *)(*(void *)(a1 + 8) + 76), *(void *)(*(void *)(a1 + 16) + 32), v14, result, *(_DWORD *)(*(void *)(a1 + 8) + 72), a3, a4, a4, 0, a5, a6, 0, 0, 0, 0, a4 + 4);
    ScalerReleaseFontTable(*(memoryContext **)a1, v12);
    return (unsigned __int16 *)v13;
  }
  return result;
}

unint64_t GetGlyphVariationPtr(uint64_t a1, int a2, unsigned int *a3)
{
  int v27 = (void *)0xAAAAAAAAAAAAAAAALL;
  unsigned int FontTable = ScalerGetFontTable(*(memoryContext **)a1, 1735811442, 0, &v27, 1, *(_DWORD *)(*(void *)(a1 + 8) + 68));
  *a3 = FontTable;
  if (!v27) {
    return 0;
  }
  int v7 = (char *)v27 + 20;
  unint64_t v8 = (unsigned int *)((char *)v27 + FontTable);
  if ((*((_WORD *)v27 + 7) & 0x100) != 0)
  {
    uint64_t v15 = (unsigned int *)&v7[4 * a2];
    if (v27 > v15 || (unint64_t)v15 > 0xFFFFFFFFFFFFFFF7 || v15 + 2 > v8)
    {
      BOOL v18 = v27 > v15 || v15 + 1 > v8;
      if (v18 || (((char *)v8 - (char *)v15) & 0xFFFFFFFFFFFFFFFCLL) != 8)
      {
LABEL_18:
        exception = __cxa_allocate_exception(0x10uLL);
        *(void *)exception = &unk_1F0DD4440;
        exception[2] = 4;
      }
    }
    int v20 = bswap32(*v15);
    int v21 = bswap32(v15[1]) - v20;
  }
  else
  {
    unint64_t v9 = &v7[2 * a2];
    if (v27 > v9 || (unint64_t)v9 > 0xFFFFFFFFFFFFFFFBLL || v9 + 4 > (char *)v8)
    {
      BOOL v12 = v27 > v9 || v9 + 2 > (char *)v8;
      if (v12 || (((char *)v8 - v9) & 0xFFFFFFFFFFFFFFFELL) != 4) {
        goto LABEL_18;
      }
    }
    unsigned int v22 = bswap32(*(unsigned __int16 *)v9);
    int v20 = 2 * HIWORD(v22);
    int v21 = 2 * ((bswap32(*((unsigned __int16 *)v9 + 1)) >> 16) - HIWORD(v22));
  }
  unsigned int v23 = *((_DWORD *)v27 + 4);
  ScalerReleaseFontTable(*(memoryContext **)a1, v27);
  if (!v21) {
    return 0;
  }
  unsigned int v24 = bswap32(v23) + v20;
  unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
  ScalerGetFontTable(*(memoryContext **)a1, 1735811442, v24, &v26, 0, v21);
  *a3 -= v24;
  return v26;
}

uint64_t ApplyVariationsToGlyph(int a1, uint64_t a2, unsigned int a3, unsigned __int16 *a4, int a5, __int16 *a6, unsigned int a7, int a8, const unsigned __int16 *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, int a16)
{
  v97[1] = *MEMORY[0x1E4F143B8];
  *(void *)unsigned int v91 = a8 + 4;
  uint64_t __len = 4 * v91[0];
  if (a9 && a8 != -4)
  {
    memmove(a12, a10, __len);
    memmove(a13, a11, __len);
  }
  *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v96[12] = v19;
  v96[11] = v19;
  v96[10] = v19;
  v96[9] = v19;
  v96[8] = v19;
  v96[7] = v19;
  v96[6] = v19;
  v96[5] = v19;
  v96[4] = v19;
  v96[3] = v19;
  _OWORD v96[2] = v19;
  v96[1] = v19;
  v96[0] = v19;
  unsigned int v94 = 0;
  unsigned int v95 = 0;
  int v93 = 0;
  unsigned int v84 = (unsigned __int16 *)v96;
  v97[0] = v96;
  if (v91[0])
  {
    if (a8 <= -5) {
      std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
    }
    if ((void *)((char *)v96 + 4 * *(void *)v91) <= v97)
    {
      v97[0] = (char *)v96 + 4 * *(void *)v91;
      size_t v20 = 4 * *(void *)v91;
    }
    else
    {
      size_t v20 = 4 * *(void *)v91;
      unsigned int v84 = (unsigned __int16 *)operator new(4 * *(void *)v91);
    }
    int v93 = v84;
    unsigned int v95 = &v84[2 * *(void *)v91];
    bzero(v84, v20);
    unsigned int v94 = v95;
  }
  else
  {
    unsigned int v84 = 0;
  }
  if ((unint64_t)a4 > 0xFFFFFFFFFFFFFFFBLL || (int v21 = (char *)a4 + a3, a4 + 2 > (unsigned __int16 *)v21))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  int v83 = &v84[v91[0]];
  unsigned int v22 = bswap32(*a4);
  unsigned int v23 = (char *)a4 + (bswap32(a4[1]) >> 16);
  uint64_t v92 = v23;
  if ((v22 & 0x80000000) == 0) {
    goto LABEL_19;
  }
  if (v23 + 1 > v21)
  {
LABEL_85:
    unsigned int v78 = __cxa_allocate_exception(0x10uLL);
    *(void *)unsigned int v78 = &unk_1F0DD4440;
    v78[2] = 4;
  }
  int PackedShort = ReadPackedShort((const char **)&v92, (unint64_t)a4 + a3);
  if (PackedShort < 1 || (int v25 = (unsigned __int16)PackedShort, v91[0] < (unsigned __int16)PackedShort))
  {
    if (!PackedShort)
    {
LABEL_19:
      int v25 = 0;
      goto LABEL_20;
    }
    goto LABEL_85;
  }
  uint64_t v92 = (char *)UnpackPointNumbers((unsigned __int16)PackedShort, v83, v92, v91[0], (const char *)a4 + a3);
LABEL_20:
  int v86 = HIWORD(v22) & 0xFFF;
  if (!v86)
  {
    unsigned __int8 v28 = 0;
    goto LABEL_79;
  }
  int v85 = v25;
  int v26 = 0;
  int v27 = 0;
  int v82 = 0;
  unsigned __int8 v28 = 0;
  float v29 = a4 + 2;
  float v30 = v92;
  unsigned int v79 = a4;
  do
  {
    if (v30 < (char *)a4 || v30 + 1 > v21)
    {
      int v76 = __cxa_allocate_exception(0x10uLL);
      *(void *)int v76 = &unk_1F0DD4440;
      v76[2] = 4;
    }
    if (v29 < a4 || v29 + 4 > (unsigned __int16 *)v21)
    {
      int v75 = __cxa_allocate_exception(0x10uLL);
      *(void *)int v75 = &unk_1F0DD4440;
      v75[2] = 4;
    }
    double v31 = ComputeTupleScalar(a5, a2, a1, (unint64_t)v29, a6, (unint64_t)v21);
    float v32 = *(float *)&v31;
    if (*(float *)&v31 != 0.0)
    {
      if ((v29[1] & 0x20) != 0)
      {
        if (a9 && v82)
        {
          InterpolateOutline(a7, a9, (float *)a10, (float *)a11, (const float *)a12, (const float *)a13, v85, v83, a16);
          int v82 = 0;
        }
        int v48 = ReadPackedShort((const char **)&v92, (unint64_t)v21);
        if (v92 < (char *)a4 || v92 + 1 > v21)
        {
LABEL_80:
          int v74 = __cxa_allocate_exception(0x10uLL);
          *(void *)int v74 = &unk_1F0DD4440;
          v74[2] = 4;
        }
        if (v48)
        {
          int v49 = (unsigned __int16)v48;
          if (v91[0] < (unsigned __int16)v48) {
            goto LABEL_80;
          }
          long long v50 = UnpackPointNumbers((unsigned __int16)v48, v84, v92, v91[0], v21);
          long long v51 = v50;
          if (v50 < (const char *)a4 || v50 + 1 > v21) {
            goto LABEL_80;
          }
          if (a9)
          {
            if (v91[0])
            {
              memmove(a14, a12, __len);
              a4 = v79;
              memmove(a15, a13, __len);
            }
            long long v52 = (const char *)ApplySparsePointDeltas(v49, v84, (float *)a14, v51, v32, v21);
            if (v52 < (const char *)a4 || v52 + 1 > v21) {
              goto LABEL_80;
            }
            uint64_t v92 = (char *)ApplySparsePointDeltas(v49, v84, (float *)a15, v52, v32, v21);
            InterpolateOutline(a7, a9, (float *)a14, (float *)a15, (const float *)a12, (const float *)a13, v49, v84, a16);
            long long v53 = (float *)a10;
            uint64_t v54 = (float *)a12;
            int v55 = (float *)a14;
            int v56 = v91[0];
            do
            {
              float v57 = *v55++;
              float v58 = v57;
              float v59 = *v54++;
              *long long v53 = *v53 + (float)(v58 - v59);
              ++v53;
              --v56;
            }
            while (v56);
            unsigned __int16 v61 = (float *)a15;
            int v60 = (float *)a11;
            unsigned int v62 = (float *)a13;
            int v63 = v91[0];
            do
            {
              float v64 = *v61++;
              float v65 = v64;
              float v66 = *v62++;
              *int v60 = *v60 + (float)(v65 - v66);
              ++v60;
              --v63;
            }
            while (v63);
          }
          else
          {
            int32x2_t v70 = (char *)ApplySparsePointDeltas(v49, v84, (float *)a10, v50, v32, v21);
            uint64_t v92 = v70;
            if (v70 < (char *)a4 || v70 + 1 > v21) {
              goto LABEL_80;
            }
            ApplySparsePointDeltas(v49, v84, (float *)a11, v70, v32, v21);
          }
        }
        else
        {
          int v68 = (const char *)ApplyAllPointDeltas(v91[0], (float *)a10, v92, v32, v21);
          if (v68 < (const char *)a4 || v68 + 1 > v21) {
            goto LABEL_80;
          }
          ApplyAllPointDeltas(v91[0], (float *)a11, v68, v32, v21);
        }
        goto LABEL_71;
      }
      if (v85)
      {
        if (a9 && v27)
        {
          if (v91[0])
          {
            memmove(a14, a12, __len);
            memmove(a15, a13, __len);
          }
          float v33 = (const char *)ApplySparsePointDeltas(v85, v83, (float *)a14, v30, v32, v21);
          if (v33 < (const char *)a4 || v33 + 1 > v21) {
            goto LABEL_80;
          }
          uint64_t v92 = (char *)ApplySparsePointDeltas(v85, v83, (float *)a15, v33, v32, v21);
          InterpolateOutline(a7, a9, (float *)a14, (float *)a15, (const float *)a12, (const float *)a13, v85, v83, a16);
          long long v34 = (float *)a10;
          long long v35 = (float *)a12;
          long long v36 = (float *)a14;
          int v37 = v91[0];
          do
          {
            float v38 = *v36++;
            float v39 = v38;
            float v40 = *v35++;
            *long long v34 = *v34 + (float)(v39 - v40);
            ++v34;
            --v37;
          }
          while (v37);
          long long v42 = (float *)a15;
          long long v41 = (float *)a11;
          long long v43 = (float *)a13;
          int v44 = v91[0];
          do
          {
            float v45 = *v42++;
            float v46 = v45;
            float v47 = *v43++;
            *long long v41 = *v41 + (float)(v46 - v47);
            ++v41;
            --v44;
          }
          while (v44);
LABEL_71:
          unsigned __int8 v28 = 1;
          int v27 = 1;
          goto LABEL_72;
        }
        int16x4_t v69 = (const char *)ApplySparsePointDeltas(v85, v83, (float *)a10, v30, *(float *)&v31, v21);
        if (v69 < (const char *)a4 || v69 + 1 > v21) {
          goto LABEL_80;
        }
        ApplySparsePointDeltas(v85, v83, (float *)a11, v69, v32, v21);
        unsigned __int8 v28 = 1;
        int v82 = 1;
      }
      else
      {
        char v67 = (const char *)ApplyAllPointDeltas(v91[0], (float *)a10, v30, *(float *)&v31, v21);
        if (v67 < (const char *)a4 || v67 + 1 > v21) {
          goto LABEL_80;
        }
        ApplyAllPointDeltas(v91[0], (float *)a11, v67, v32, v21);
        unsigned __int8 v28 = 1;
      }
    }
LABEL_72:
    v30 += bswap32(*v29) >> 16;
    uint64_t v92 = v30;
    int v71 = bswap32(v29[1]);
    int v72 = 2 * a5 + 4;
    if (v71 >> 16 >= 0) {
      int v72 = 4;
    }
    float v29 = (unsigned __int16 *)((char *)v29 + ((4 * a5) & ((2 * v71) >> 31)) + v72);
    ++v26;
  }
  while (v26 != v86);
  if (a9 && v82) {
    InterpolateOutline(a7, a9, (float *)a10, (float *)a11, (const float *)a12, (const float *)a13, v85, v83, a16);
  }
LABEL_79:
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,104ul>>::__destroy_vector::operator()[abi:fe180100]((uint64_t)&v93);
  return v28;
}

void sub_1B52E0A78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

BOOL ApplyFeaturesToOutline(uint64_t a1, uint64_t a2)
{
  v68[1] = *MEMORY[0x1E4F143B8];
  unsigned int v63 = 0;
  unint64_t GlyphVariationPtr = GetGlyphVariationPtr(a1, *(_DWORD *)(a2 + 88), &v63);
  if (!GlyphVariationPtr) {
    return GlyphVariationPtr != 0;
  }
  uint64_t v5 = *(int *)(a2 + 4);
  uint64_t v6 = v5 + 4;
  int v7 = (float *)v67;
  memset(v67, 170, sizeof(v67));
  float v65 = 0;
  float v66 = 0;
  float v64 = 0;
  v68[0] = v67;
  unsigned __int16 v61 = (unsigned __int16 *)GlyphVariationPtr;
  uint64_t v62 = a1;
  if (v5 == -4)
  {
    int v7 = 0;
    unint64_t v8 = (float *)(4 * v6);
    unint64_t v9 = (float *)(8 * v6);
    uint64_t v60 = 12 * v6;
    unsigned int v10 = (void *)(16 * v6);
    uint64_t v59 = 20 * v6;
    uint64_t v11 = *(void *)(a1 + 16);
    goto LABEL_9;
  }
  if ((unint64_t)(6 * v6) >> 62) {
    std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
  }
  if (&v67[3 * v6] <= v68) {
    v68[0] = &v67[3 * v6];
  }
  else {
    int v7 = (float *)operator new(24 * v6);
  }
  float v64 = v7;
  float v66 = &v7[6 * v6];
  bzero(v7, 24 * (int)v5 + 96);
  float v65 = &v7[6 * v6];
  unint64_t v8 = &v7[v6];
  unint64_t v9 = &v8[v6];
  uint64_t v60 = (uint64_t)&v9[v6];
  unsigned int v10 = (void *)(v60 + 4 * v6);
  uint64_t v59 = (uint64_t)v10 + 4 * v6;
  uint64_t v11 = *(void *)(a1 + 16);
  if (v5)
  {
LABEL_9:
    ComputeUnscaledBounds(a2, a2 + 92);
    uint64_t v12 = *(int *)(a2 + 4);
    unsigned int v14 = (__int16 **)(a2 + 72);
    uint64_t v13 = *(__int16 **)(a2 + 72);
    uint64_t v15 = v12;
    *(void *)&v13[v15] = 0;
    long long v17 = (__int16 **)(a2 + 80);
    uint64_t v16 = *(__int16 **)(a2 + 80);
    *(void *)&v16[v15] = 0;
    if (v5 == -4) {
      goto LABEL_16;
    }
    goto LABEL_12;
  }
  LODWORD(v12) = 0;
  unsigned int v14 = (__int16 **)(a2 + 72);
  uint64_t v13 = *(__int16 **)(a2 + 72);
  *(void *)uint64_t v13 = 0;
  long long v17 = (__int16 **)(a2 + 80);
  uint64_t v16 = *(__int16 **)(a2 + 80);
  *(void *)uint64_t v16 = 0;
LABEL_12:
  uint64_t v18 = 2 * v5 + 8;
  long long v19 = v7;
  do
  {
    int v20 = *v13++;
    *v19++ = (float)v20;
    v18 -= 2;
  }
  while (v18);
  uint64_t v21 = 2 * v5 + 8;
  unsigned int v22 = v8;
  do
  {
    int v23 = *v16++;
    *v22++ = (float)v23;
    v21 -= 2;
  }
  while (v21);
LABEL_16:
  uint64_t v24 = *(void *)(v11 + 32);
  int v25 = *(__int16 **)(v11 + 16);
  unint64_t GlyphVariationPtr = (unint64_t)v61;
  ApplyVariationsToGlyph(*(_DWORD *)(*(void *)(v62 + 8) + 76), v24, v63, v61, *(_DWORD *)(*(void *)(v62 + 8) + 72), v25, *(_DWORD *)a2, v12, *(const unsigned __int16 **)(a2 + 32), v7, v8, v9, (void *)v60, v10, (void *)v59, v6);
  if (v5 == -4)
  {
    double v31 = *v14;
    long long v34 = *v17;
  }
  else
  {
    int v26 = *(_DWORD **)(a2 + 56);
    int v27 = v7;
    do
    {
      float v28 = *v27++;
      *v26++ = llroundf(v28 * 64.0);
    }
    while (v27 != v8);
    uint64_t v29 = 0;
    uint64_t v30 = *(void *)(a2 + 64);
    do
    {
      *(_DWORD *)(v30 + v29 * 4) = llroundf(v8[v29] * 64.0);
      ++v29;
    }
    while (&v8[v29] != v9);
    double v31 = *v14;
    float v32 = *v14;
    do
    {
      float v33 = *v7++;
      *v32++ = llroundf(v33);
    }
    while (v7 != v8);
    long long v34 = *v17;
    long long v35 = *v17;
    do
    {
      float v36 = *v8++;
      *v35++ = llroundf(v36);
    }
    while (v8 != v9);
  }
  int v37 = *(_DWORD *)(a2 + 4);
  if (v37)
  {
    uint64_t v38 = v37;
    unsigned __int16 v39 = 0x7FFF;
    LODWORD(v40) = 0x8000;
    unsigned __int16 v41 = 0x8000;
    unsigned __int16 v42 = 0x7FFF;
    __int16 v43 = 0x8000;
    __int16 v44 = 0x7FFF;
    __int16 v45 = 0x8000;
    __int16 v46 = 0x7FFF;
    float v47 = v31;
    int v48 = v34;
    do
    {
      int v50 = *v47++;
      int v49 = v50;
      BOOL v51 = v46 < v50;
      if (v46 > v50) {
        unsigned __int16 v42 = v49;
      }
      if (!v51) {
        __int16 v46 = v49;
      }
      if (v45 < v49) {
        unsigned __int16 v41 = v49;
      }
      if (v45 <= v49) {
        __int16 v45 = v49;
      }
      int v53 = *v48++;
      int v52 = v53;
      BOOL v54 = v44 < v53;
      if (v44 > v53) {
        unsigned __int16 v39 = v52;
      }
      if (!v54) {
        __int16 v44 = v52;
      }
      if (v43 >= v52) {
        uint64_t v40 = v40;
      }
      else {
        uint64_t v40 = v52;
      }
      if (v43 <= v52) {
        __int16 v43 = v52;
      }
      --v37;
    }
    while (v37);
    unint64_t v55 = ((unint64_t)v41 << 32) | (v40 << 48) | ((unint64_t)v39 << 16) | v42;
  }
  else
  {
    unint64_t v55 = 0;
    LOWORD(v40) = 0;
    unsigned __int16 v42 = 0;
    uint64_t v38 = 0;
  }
  int v56 = &v31[v38];
  float v57 = &v34[v38];
  *(_WORD *)(a2 + 102) += v42 - *(_WORD *)(a2 + 92) - *v56;
  *(_WORD *)(a2 + 100) += v56[1] - *v56;
  *(_WORD *)(a2 + 106) += *(_WORD *)(a2 + 98) - v40 + v57[2];
  *(_WORD *)(a2 + 104) += v57[2] - v57[3];
  *(void *)(a2 + 92) = v55;
  ScalerReleaseFontTable(*(memoryContext **)v62, v61);
  std::vector<float,TInlineBufferAllocator<float,312ul>>::__destroy_vector::operator()[abi:fe180100]((uint64_t)&v64);
  return GlyphVariationPtr != 0;
}

void sub_1B52E0ED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  std::vector<float,TInlineBufferAllocator<float,312ul>>::__destroy_vector::operator()[abi:fe180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ApplyVariationToCVT()
{
}

void sub_1B52E1358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

uint64_t ReadPackedShort(const char **a1, unint64_t a2)
{
  float v3 = (unsigned __int8 *)*a1;
  unsigned int v4 = *a1 + 1;
  *a1 = v4;
  uint64_t result = *v3;
  if ((char)*v3 < 0)
  {
    uint64_t v6 = (const char *)(v3 + 2);
    if ((unint64_t)v6 > a2)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 4;
    }
    *a1 = v6;
    return *(unsigned __int8 *)v4 | ((result & 0x7F) << 8);
  }
  return result;
}

const char *UnpackPointNumbers(int a1, unsigned __int16 *a2, const char *a3, int a4, const char *a5)
{
  int v5 = 0;
  int v6 = 0;
  int v7 = a3;
  unint64_t v8 = a3;
  do
  {
    char v10 = *v8++;
    char v9 = v10;
    int v11 = v10 & 0x7F;
    int v12 = v11 + 1;
    if (a1 > v11)
    {
      unint64_t v13 = (v11 + 1);
    }
    else
    {
      int v6 = v12 - a1;
      unint64_t v13 = a1;
    }
    if ((int)v13 < 1) {
      goto LABEL_40;
    }
    if ((v9 & 0x80000000) == 0)
    {
      BOOL v15 = &v8[v13] >= v8 && &v8[v13] <= a5 && v8 >= a3;
      BOOL v16 = v7 + 2 <= a5 && v8 >= a3;
      if (a5 - v8 != v13) {
        BOOL v16 = 0;
      }
      if (v15 || v16)
      {
        while (1)
        {
          v5 += *(unsigned __int8 *)v8;
          if (v5 < 0 || v5 >= a4) {
            break;
          }
          ++v8;
          *a2++ = v5;
          LODWORD(v13) = v13 - 1;
          if (!v13) {
            goto LABEL_36;
          }
        }
      }
LABEL_40:
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 4;
    }
    if (v8 < a3
      || ((unint64_t v17 = (unint64_t)&v8[2 * v13], v17 >= (unint64_t)v8)
        ? (BOOL v18 = v17 > (unint64_t)a5)
        : (BOOL v18 = 1),
          v18))
    {
      if (v8 < a3 || v7 + 3 > a5 || (unint64_t)(a5 - v8) >> 1 != v13) {
        goto LABEL_40;
      }
    }
    do
    {
      v5 += bswap32(*(unsigned __int16 *)v8) >> 16;
      if (v5 < 0 || v5 >= a4) {
        goto LABEL_40;
      }
      v8 += 2;
      *a2++ = v5;
      LODWORD(v13) = v13 - 1;
    }
    while (v13);
LABEL_36:
    if (a1 <= v11) {
      break;
    }
    int v7 = v8;
    BOOL v19 = __OFSUB__(a1, v12);
    a1 -= v12;
  }
  while (!((a1 < 0) ^ v19 | (a1 == 0)));
  return &v8[v6];
}

uint64_t ApplySparsePointDeltas(int a1, const unsigned __int16 *a2, float *a3, const char *a4, float a5, const char *a6)
{
  int v6 = 0;
  int v7 = a4;
  do
  {
    unint64_t v8 = (unsigned __int16 *)(v7 + 1);
    int v9 = *v7 & 0x3F;
    int v10 = v9 + 1;
    if (a1 > v9)
    {
      uint64_t v11 = (v9 + 1);
    }
    else
    {
      int v6 = v9 + 1 - a1;
      uint64_t v11 = a1;
    }
    if ((int)v11 < 1)
    {
LABEL_39:
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 4;
    }
    if ((*v7 & 0xC0) == 0x40)
    {
      if (v8 < (unsigned __int16 *)a4
        || ((unint64_t v19 = (unint64_t)&v8[v11], v19 >= (unint64_t)v8)
          ? (BOOL v20 = v19 > (unint64_t)a6)
          : (BOOL v20 = 1),
            v20))
      {
        if (v8 < (unsigned __int16 *)a4 || v7 + 3 > a6 || (unint64_t)(a6 - (const char *)v8) >> 1 != v11) {
          goto LABEL_39;
        }
      }
      do
      {
        unsigned int v21 = *v8++;
        float v22 = (float)((int)bswap32(v21) >> 16);
        int v23 = *a2++;
        a3[v23] = a3[v23] + (float)(a5 * v22);
        LODWORD(v11) = v11 - 1;
      }
      while (v11);
      v6 *= 2;
    }
    else if ((*v7 & 0xC0) != 0)
    {
      a2 += v11;
    }
    else
    {
      unint64_t v12 = (unint64_t)v8 + v11;
      BOOL v14 = v12 >= (unint64_t)v8 && v12 <= (unint64_t)a6 && v8 >= (unsigned __int16 *)a4;
      BOOL v15 = v7 + 2 <= a6 && v8 >= (unsigned __int16 *)a4;
      if (a6 - (const char *)v8 != v11) {
        BOOL v15 = 0;
      }
      if (!v14 && !v15) {
        goto LABEL_39;
      }
      do
      {
        int v16 = *(char *)v8;
        unint64_t v8 = (unsigned __int16 *)((char *)v8 + 1);
        float v17 = (float)v16;
        int v18 = *a2++;
        a3[v18] = a3[v18] + (float)(a5 * v17);
        LODWORD(v11) = v11 - 1;
      }
      while (v11);
    }
    int v7 = (const char *)v8;
    if (a1 <= v9) {
      break;
    }
    BOOL v24 = __OFSUB__(a1, v10);
    a1 -= v10;
  }
  while (!((a1 < 0) ^ v24 | (a1 == 0)));
  return (uint64_t)v8 + v6;
}

uint64_t ApplyAllPointDeltas(int a1, float *a2, const char *a3, float a4, const char *a5)
{
  int v5 = 0;
  int v6 = a3;
  do
  {
    int v7 = (unsigned __int16 *)(v6 + 1);
    int v8 = *v6 & 0x3F;
    int v9 = v8 + 1;
    if (a1 > v8)
    {
      uint64_t v10 = (v8 + 1);
    }
    else
    {
      int v5 = v8 + 1 - a1;
      uint64_t v10 = a1;
    }
    if ((int)v10 < 1)
    {
LABEL_39:
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 4;
    }
    if ((*v6 & 0xC0) == 0x40)
    {
      if (v7 < (unsigned __int16 *)a3
        || ((unint64_t v16 = (unint64_t)&v7[v10], v16 >= (unint64_t)v7)
          ? (BOOL v17 = v16 > (unint64_t)a5)
          : (BOOL v17 = 1),
            v17))
      {
        if (v7 < (unsigned __int16 *)a3 || v6 + 3 > a5 || (unint64_t)(a5 - (const char *)v7) >> 1 != v10) {
          goto LABEL_39;
        }
      }
      do
      {
        unsigned int v18 = *v7++;
        *a2 = *a2 + (float)(a4 * (float)((int)bswap32(v18) >> 16));
        ++a2;
        LODWORD(v10) = v10 - 1;
      }
      while (v10);
      v5 *= 2;
    }
    else if ((*v6 & 0xC0) != 0)
    {
      a2 += v10;
    }
    else
    {
      unint64_t v11 = (unint64_t)v7 + v10;
      BOOL v13 = v11 >= (unint64_t)v7 && v11 <= (unint64_t)a5 && v7 >= (unsigned __int16 *)a3;
      BOOL v14 = v6 + 2 <= a5 && v7 >= (unsigned __int16 *)a3;
      if (a5 - (const char *)v7 != v10) {
        BOOL v14 = 0;
      }
      if (!v13 && !v14) {
        goto LABEL_39;
      }
      do
      {
        int v15 = *(char *)v7;
        int v7 = (unsigned __int16 *)((char *)v7 + 1);
        *a2 = *a2 + (float)(a4 * (float)v15);
        ++a2;
        LODWORD(v10) = v10 - 1;
      }
      while (v10);
    }
    int v6 = (const char *)v7;
    if (a1 <= v8) {
      break;
    }
    BOOL v19 = __OFSUB__(a1, v9);
    a1 -= v9;
  }
  while (!((a1 < 0) ^ v19 | (a1 == 0)));
  return (uint64_t)v7 + v5;
}

void ApplyStyleToCVT(memoryContext **a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = 0xAAAAAAAAAAAAAAAALL;
  ScalerGetFontTable(v1, 1668702578, 0, &v2, 0, 8);
  ApplyVariationToCVT();
}

uint64_t InterpolateOutline(uint64_t result, const unsigned __int16 *a2, float *a3, float *a4, const float *a5, const float *a6, int a7, const unsigned __int16 *a8, int a9)
{
  if (result)
  {
    int v9 = a7;
    if (a7)
    {
      int v12 = result;
      unsigned int v13 = 0;
      do
      {
        int v15 = *a2++;
        unsigned int v14 = v15;
        if (v15 >= a9 || (int v16 = v14 - v13, (int)(v14 - v13) <= -2))
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *(void *)exception = &unk_1F0DD4440;
          exception[2] = 4;
        }
        if (v16 < a9) {
          uint64_t v17 = (v16 + 1);
        }
        else {
          uint64_t v17 = a9;
        }
        if (*a8 <= v14)
        {
          unsigned int v18 = a8;
          do
          {
            unsigned int v19 = v18[1];
            ++v18;
          }
          while (v19 <= v14 && v9-- != 1);
          if ((int)v17 >= 3 && v18 > a8)
          {
            InterpolateContour(v17, a3, a5, a8, v18 - 1, v13);
            uint64_t result = InterpolateContour(v17, a4, a6, a8, v18 - 1, v13);
          }
          a8 = v18;
        }
        if (!--v12) {
          break;
        }
        unsigned int v13 = v14 + 1;
      }
      while (v9);
    }
  }
  return result;
}

void std::vector<unsigned short,TInlineBufferAllocator<unsigned short,104ul>>::__destroy_vector::operator()[abi:fe180100](uint64_t a1)
{
  unint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    float v3 = (void *)(a1 + 232);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 232)) {
        *float v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

uint64_t InterpolateContour(uint64_t result, float *a2, const float *a3, const unsigned __int16 *a4, const unsigned __int16 *a5, unsigned int a6)
{
  unsigned int v8 = *a4;
  int v6 = a4 + 1;
  unint64_t v7 = v8;
  int v9 = &a2[v8];
  if (v6 <= a5)
  {
    uint64_t v10 = v9;
    do
    {
      unint64_t v11 = v10;
      uint64_t v12 = *v6;
      uint64_t v10 = &a2[v12];
      int64_t v13 = (char *)v11 - (char *)a2;
      float v15 = *v11;
      unsigned int v14 = v11 + 1;
      float v16 = v15;
      float v17 = *v10 - v15;
      float v18 = *(const float *)((char *)a3 + v13);
      float v19 = a3[v12];
      float v20 = v19 - v18;
      unsigned int v21 = (float *)((char *)a3 + (char *)v14 - (char *)a2);
      if (v17 == (float)(v19 - v18))
      {
        float v22 = v16 - v18;
        if (v22 != 0.0 && v14 < v10)
        {
          do
          {
            float v24 = *v21++;
            *v14++ = v22 + v24;
          }
          while (v14 < v10);
        }
      }
      else if (v20 != 0.0)
      {
        BOOL v25 = v19 <= v18;
        float v26 = *v10 - v19;
        if (v19 > v18) {
          float v27 = *(const float *)((char *)a3 + v13);
        }
        else {
          float v27 = v19;
        }
        if (v19 > v18)
        {
          float v28 = v16 - v18;
        }
        else
        {
          float v19 = *(const float *)((char *)a3 + v13);
          float v28 = v26;
        }
        if (v25) {
          float v26 = v16 - v18;
        }
        while (v14 < v10)
        {
          float v29 = *v21++;
          float v30 = v29;
          if (v29 >= v27)
          {
            if (v30 <= v19) {
              float v31 = v16 + (float)((float)(v17 * (float)(v30 - v18)) / v20);
            }
            else {
              float v31 = v26 + *v14;
            }
          }
          else
          {
            float v31 = v28 + *v14;
          }
          *v14++ = v31;
        }
      }
      ++v6;
    }
    while (v6 <= a5);
  }
  uint64_t v32 = *a5;
  float v33 = a2[v7];
  long long v34 = &a2[v32];
  float v35 = a3[v7];
  float v36 = a3[v32];
  float v37 = v33 - *v34;
  float v38 = v35 - v36;
  int v39 = a6 + result + ~v32;
  if (v37 == (float)(v35 - v36))
  {
    float v40 = v33 - v35;
    if (a6 < v7)
    {
      unsigned __int16 v41 = (float *)&a3[a6];
      unsigned __int16 v42 = &a2[a6];
      do
      {
        float v43 = *v41++;
        *v42++ = v40 + v43;
      }
      while (v42 < v9);
    }
    if (v39)
    {
      __int16 v44 = v34 + 1;
      __int16 v45 = (float *)((char *)a3 + (char *)(v34 + 1) - (char *)a2);
      do
      {
        float v46 = *v45++;
        *v44++ = v40 + v46;
        --v39;
      }
      while (v39);
    }
  }
  else if (v38 != 0.0)
  {
    BOOL v47 = v36 <= v35;
    float v48 = *v34 - v36;
    if (v36 > v35) {
      float v49 = a3[v7];
    }
    else {
      float v49 = v36;
    }
    if (v36 > v35)
    {
      float v50 = v33 - v35;
    }
    else
    {
      float v36 = a3[v7];
      float v50 = v48;
    }
    if (v47) {
      float v48 = v33 - v35;
    }
    if (a6 < v7)
    {
      BOOL v51 = &a2[a6];
      int v52 = (float *)&a3[a6];
      do
      {
        float v53 = *v52++;
        float v54 = v53;
        if (v53 >= v49)
        {
          if (v54 <= v36) {
            float v55 = v33 + (float)((float)(v37 * (float)(v54 - v35)) / v38);
          }
          else {
            float v55 = v48 + *v51;
          }
        }
        else
        {
          float v55 = v50 + *v51;
        }
        *v51++ = v55;
      }
      while (v51 < v9);
    }
    if (v39)
    {
      int v56 = v34 + 1;
      float v57 = (float *)((char *)a3 + (char *)(v34 + 1) - (char *)a2);
      do
      {
        float v58 = *v57++;
        float v59 = v58;
        if (v58 >= v49)
        {
          if (v59 <= v36) {
            float v60 = v33 + (float)((float)(v37 * (float)(v59 - v35)) / v38);
          }
          else {
            float v60 = v48 + *v56;
          }
        }
        else
        {
          float v60 = v50 + *v56;
        }
        *v56++ = v60;
        --v39;
      }
      while (v39);
    }
  }
  return result;
}

void std::vector<float,TInlineBufferAllocator<float,312ul>>::__destroy_vector::operator()[abi:fe180100](uint64_t a1)
{
  unint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    float v3 = (void *)(a1 + 1272);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 1272)) {
        *float v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

size_t *AllocRawMemory(unsigned int a1, int a2)
{
  size_t v2 = a1 + 8;
  if (a2)
  {
    uint64_t result = (size_t *)malloc_type_calloc(1uLL, v2, 0x690B61C8uLL);
    if (!result) {
      return result;
    }
  }
  else
  {
    uint64_t result = (size_t *)malloc_type_malloc(a1 + 8, 0x68FCFC2DuLL);
    if (!result) {
      return result;
    }
  }
  *result++ = v2;
  return result;
}

void *ResizeRawMemory(void *a1, unsigned int a2, int a3)
{
  if (a1) {
    unint64_t v4 = *(a1 - 1) - 8;
  }
  else {
    unint64_t v4 = 0;
  }
  if (a1) {
    BOOL v5 = (char *)(a1 - 1);
  }
  else {
    BOOL v5 = 0;
  }
  unint64_t v6 = a2;
  unint64_t v7 = malloc_type_realloc(v5, a2 + 8, 0xD048CD25uLL);
  if (v7)
  {
    *unint64_t v7 = v6;
    unsigned int v8 = v7 + 1;
    if (v6 > v4) {
      bzero((char *)v8 + v4, v6 - v4);
    }
  }
  else
  {
    if (!a3) {
      free(v5);
    }
    return 0;
  }
  return v8;
}

__CFData *TSFNTFont::CopyData(TSFNTFont *this)
{
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v36 = v2;
  long long v37 = v2;
  uint64_t v3 = (*(uint64_t (**)(TSFNTFont *))(*(void *)this + 56))(this);
  (*(void (**)(long long *__return_ptr))(*(void *)v3 + 32))(&v36);
  if (*((void *)&v36 + 1) && (uint64_t v4 = *(void *)(*((void *)&v36 + 1) + 8)) != 0) {
    BOOL v5 = (const UInt8 *)(v4 + v37);
  }
  else {
    BOOL v5 = 0;
  }
  long long v6 = v37;
  uint64_t v7 = (*(uint64_t (**)(TSFNTFont *))(*(void *)this + 56))(this);
  unint64_t v8 = *((void *)&v6 + 1) - v6;
  if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 48))(v7))
  {
    uint64_t Directory = TSFNTFont::GetDirectory(this);
    unsigned int v10 = *(unsigned __int16 *)(Directory + 4);
    unint64_t v11 = __rev16(v10);
    unsigned int v12 = __clz(v11) ^ 0x1F;
    if (*(_WORD *)(Directory + 4)) {
      __int16 v13 = v12;
    }
    else {
      __int16 v13 = 0;
    }
    CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (Mutable)
    {
      unsigned int v15 = (16 * v11) | 0xC;
      float v16 = (char *)malloc_type_malloc(v15, 0x4DB2EA94uLL);
      float v17 = v16;
      if (v16)
      {
        *(_DWORD *)float v16 = *(_DWORD *)Directory;
        *((_WORD *)v16 + 2) = v10;
        *((_WORD *)v16 + 3) = bswap32(16 << v13) >> 16;
        *((_WORD *)v16 + 4) = v13 << 8;
        *((_WORD *)v16 + 5) = bswap32(16 * v11 - (16 << v13)) >> 16;
        CFDataAppendBytes(Mutable, (const UInt8 *)v16, 12);
        float v18 = (int8x16_t *)(v17 + 12);
        if (v10)
        {
          uint64_t v19 = Directory + 12;
          float v20 = (unsigned int *)v19;
          unsigned int v21 = v17 + 12;
          do
          {
            unint64_t v22 = bswap32(v20[2]);
            uint64_t v23 = bswap32(v20[3]);
            BOOL v24 = v8 > v22 && v8 >= (v23 + v22);
            if (!v24 || (unsigned int v25 = v23 + v15, __CFADD__(v23, v15)))
            {
              unint64_t v26 = 0;
            }
            else
            {
              unint64_t v26 = v15 | (unint64_t)(v23 << 32);
              int v29 = v23 & 3;
              if (v29) {
                unsigned int v15 = v25 - v29 + 4;
              }
              else {
                unsigned int v15 = v25;
              }
            }
            uint64_t v27 = *v20;
            uint64_t v28 = v20[1];
            v20 += 4;
            *unsigned int v21 = bswap64(v28 | (v27 << 32));
            v21[1] = v26;
            v21 += 2;
          }
          while (v20 != (unsigned int *)(v19 + 16 * v11));
          std::__introsort<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *,false>((unint64_t)(v17 + 12), (unsigned int *)&v18[v11], 126 - 2 * __clz(v11), 1);
          unsigned int v30 = v11 + 1;
          do
          {
            *(int8x16_t *)bytes = vrev32q_s8(*v18);
            CFDataAppendBytes(Mutable, bytes, 16);
            ++v18;
            --v30;
          }
          while (v30 > 1);
          int v31 = v11 + 1;
          do
          {
            *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)bytes = v32;
            long long v39 = v32;
            TSFNTFont::GetTable(this, bswap32(*(_DWORD *)v19), 0, bytes);
            if (*(void *)&bytes[8] && (uint64_t v33 = *(void *)(*(void *)&bytes[8] + 8)) != 0) {
              long long v34 = (const UInt8 *)(v33 + v39);
            }
            else {
              long long v34 = 0;
            }
            CFDataAppendBytes(Mutable, v34, bswap32(*(_DWORD *)(v19 + 12)));
            if ((*(unsigned char *)(v19 + 15) & 3) != 0) {
              CFDataIncreaseLength(Mutable, 4 - (*(unsigned char *)(v19 + 15) & 3));
            }
            TDataReference::~TDataReference((TDataReference *)bytes);
            --v31;
            v19 += 16;
          }
          while (v31 > 1);
        }
        else
        {
          std::__introsort<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *,false>((unint64_t)(v17 + 12), (unsigned int *)&v18[v11], 0, 1);
        }
        free(v17);
      }
      else
      {
        CFRelease(Mutable);
        CFMutableArrayRef Mutable = 0;
      }
    }
  }
  else
  {
    CFMutableArrayRef Mutable = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, v8);
  }
  TDataReference::~TDataReference((TDataReference *)&v36);
  return Mutable;
}

void sub_1B52E2210(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TSFNTFont::GetTableOffset(TSFNTFont *this, int a2, unint64_t *a3)
{
  uint64_t Directory = TSFNTFont::GetDirectory(this);
  if (!Directory || !*(_WORD *)(Directory + 4)) {
    return 0xFFFFFFFFLL;
  }
  long long v6 = (unsigned int *)(Directory + 24);
  uint64_t v7 = 16 * __rev16(*(unsigned __int16 *)(Directory + 4));
  while (bswap32(*(v6 - 3)) != a2)
  {
    v6 += 4;
    v7 -= 16;
    if (!v7) {
      return 0xFFFFFFFFLL;
    }
  }
  if (a3) {
    *a3 = bswap32(*v6);
  }
  return bswap32(*(v6 - 1));
}

uint64_t TSFNTFont::EnumerateTableTags(TSFNTFont *a1, uint64_t a2)
{
  uint64_t result = TSFNTFont::GetDirectory(a1);
  if (result && *(_WORD *)(result + 4))
  {
    uint64_t v4 = (unsigned int *)(result + 12);
    uint64_t v5 = 16 * __rev16(*(unsigned __int16 *)(result + 4)) - 16;
    do
    {
      char v8 = 0;
      unsigned int v6 = *v4;
      v4 += 4;
      uint64_t result = std::function<void ()(unsigned int,BOOL *)>::operator()(a2, bswap32(v6), (uint64_t)&v8);
      if (v8) {
        BOOL v7 = 1;
      }
      else {
        BOOL v7 = v5 == 0;
      }
      v5 -= 16;
    }
    while (!v7);
  }
  return result;
}

uint64_t std::function<void ()(unsigned int,BOOL *)>::operator()(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = a2;
  uint64_t v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:fe180100]();
  }
  return (*(uint64_t (**)(uint64_t, int *, uint64_t *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

BOOL TSFNTFont::HasTableTags(TSFNTFont *a1, uint64_t a2, uint64_t a3)
{
  _OWORD v6[4] = *MEMORY[0x1E4F143B8];
  v5[0] = a2;
  v5[1] = a3;
  uint64_t v4 = a3;
  v6[0] = &unk_1F0DFDFA0;
  v6[1] = v5;
  v6[2] = &v4;
  v6[3] = v6;
  TSFNTFont::EnumerateTableTags(a1, (uint64_t)v6);
  std::__function::__value_func<void ()(unsigned int,BOOL *)>::~__value_func[abi:fe180100](v6);
  return v4 == 0;
}

void sub_1B52E2458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<void ()(unsigned int,BOOL *)>::~__value_func[abi:fe180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t TSFNTFont::GetTable@<X0>(TSFNTFont *this@<X0>, int a2@<W1>, int a3@<W2>, void *a4@<X8>)
{
  unint64_t v8 = 0;
  uint64_t result = TSFNTFont::GetTableOffset(this, a2, &v8);
  if (result != -1) {
    return (*(uint64_t (**)(TSFNTFont *, void, unint64_t))(*(void *)this + 48))(this, (result + a3), v8);
  }
  *a4 = &unk_1F0DD4218;
  a4[1] = 0;
  a4[2] = 0;
  a4[3] = 0;
  return result;
}

uint64_t TSFNTFont::FindPostscriptName(TSFNTFont *this, const unsigned __int16 *a2, uint64_t a3, const char *a4)
{
  TsfntTable::TsfntTable((TsfntTable *)v9, this, 1851878757);
  v9[0] = &unk_1F0DD6FF8;
  uint64_t PostscriptName = TnameTable::FindPostscriptName((TnameTable *)v9, a2, a3, a4);
  TDataReference::~TDataReference((TDataReference *)v9);
  return PostscriptName;
}

void sub_1B52E25A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TDataReference::~TDataReference((TDataReference *)va);
  _Unwind_Resume(a1);
}

void TSFNTFont::GetSomeNames(TSFNTFont *this@<X0>, uint64_t *a2@<X8>)
{
  TsfntTable::TsfntTable((TsfntTable *)v3, this, 1851878757);
  v3[0] = &unk_1F0DD6FF8;
  TnameTable::GetSomeNames((TnameTable *)v3, a2);
  TDataReference::~TDataReference((TDataReference *)v3);
}

void sub_1B52E2624(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TDataReference::~TDataReference((TDataReference *)va);
  _Unwind_Resume(a1);
}

void TSFNTFont::GetNames(TSFNTFont *this@<X0>, void *a2@<X8>)
{
  TsfntTable::TsfntTable((TsfntTable *)v3, this, 1851878757);
  v3[0] = &unk_1F0DD6FF8;
  TnameTable::GetAllNames((TnameTable *)v3, a2);
  TDataReference::~TDataReference((TDataReference *)v3);
}

void sub_1B52E26A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TDataReference::~TDataReference((TDataReference *)va);
  _Unwind_Resume(a1);
}

void TSFNTFont::GetInstanceNames(const TSFNTFont *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1] - *a2;
  if (v5)
  {
    *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v50[3] = v8;
    _OWORD v50[2] = v8;
    v50[1] = v8;
    v50[0] = v8;
    float v48 = 0;
    float v49 = 0;
    BOOL v47 = 0;
    BOOL v51 = v50;
    BOOL v9 = *(unsigned __int16 *)(v4 + 4) == 0;
    char v10 = 2;
    if (v9) {
      char v10 = 3;
    }
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve(&v47, v5 >> v10);
    uint64_t v11 = *a2;
    uint64_t v12 = a2[1];
    if (*a2 == v12)
    {
      __int16 v13 = v48;
    }
    else
    {
      __int16 v13 = v48;
      do
      {
        if (v13 >= v49)
        {
          unsigned int v14 = (void **)v47;
          uint64_t v15 = v13 - v47;
          if (v13 - v47 <= -3) {
            std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v16 = v15 >> 1;
          if (v49 - v47 <= (unint64_t)((v15 >> 1) + 1)) {
            uint64_t v17 = v16 + 1;
          }
          else {
            uint64_t v17 = v49 - v47;
          }
          if ((unint64_t)(v49 - v47) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v18 = v17;
          }
          float v46 = v50;
          if (v18)
          {
            uint64_t v19 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v50, v18);
            unsigned int v14 = (void **)v47;
            __int16 v13 = v48;
          }
          else
          {
            uint64_t v19 = 0;
          }
          float v20 = &v19[2 * v16];
          *(_WORD *)float v20 = *(_WORD *)(v11 + 2);
          if (v13 == (char *)v14)
          {
            unint64_t v22 = &v19[2 * v16];
          }
          else
          {
            unsigned int v21 = v13;
            unint64_t v22 = &v19[2 * v16];
            do
            {
              __int16 v23 = *((_WORD *)v21 - 1);
              v21 -= 2;
              *((_WORD *)v22 - 1) = v23;
              v22 -= 2;
            }
            while (v21 != (char *)v14);
          }
          BOOL v24 = v20 + 2;
          BOOL v47 = v22;
          float v48 = v20 + 2;
          unsigned int v25 = v49;
          float v49 = &v19[2 * v18];
          __int16 v44 = v13;
          __int16 v45 = v25;
          unsigned __int16 v42 = (char **)v14;
          float v43 = v14;
          std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v42);
          __int16 v13 = v24;
        }
        else
        {
          *(_WORD *)__int16 v13 = *(_WORD *)(v11 + 2);
          v13 += 2;
        }
        float v48 = v13;
        if (*(_WORD *)(v11 + 4))
        {
          __int16 v26 = *(_WORD *)(v11 + 4) - 1;
          if (v13 >= v49)
          {
            uint64_t v28 = (void **)v47;
            uint64_t v29 = v13 - v47;
            if (v13 - v47 <= -3) {
              std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
            }
            uint64_t v30 = v29 >> 1;
            if (v49 - v47 <= (unint64_t)((v29 >> 1) + 1)) {
              uint64_t v31 = v30 + 1;
            }
            else {
              uint64_t v31 = v49 - v47;
            }
            if ((unint64_t)(v49 - v47) >= 0x7FFFFFFFFFFFFFFELL) {
              uint64_t v32 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v32 = v31;
            }
            float v46 = v50;
            if (v32)
            {
              uint64_t v33 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v50, v32);
              uint64_t v28 = (void **)v47;
              __int16 v13 = v48;
            }
            else
            {
              uint64_t v33 = 0;
            }
            long long v34 = &v33[2 * v30];
            *(_WORD *)long long v34 = v26;
            if (v13 == (char *)v28)
            {
              long long v36 = &v33[2 * v30];
            }
            else
            {
              float v35 = v13;
              long long v36 = &v33[2 * v30];
              do
              {
                __int16 v37 = *((_WORD *)v35 - 1);
                v35 -= 2;
                *((_WORD *)v36 - 1) = v37;
                v36 -= 2;
              }
              while (v35 != (char *)v28);
            }
            uint64_t v27 = v34 + 2;
            BOOL v47 = v36;
            float v48 = v34 + 2;
            float v38 = v49;
            float v49 = &v33[2 * v32];
            __int16 v44 = v13;
            __int16 v45 = v38;
            unsigned __int16 v42 = (char **)v28;
            float v43 = v28;
            std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v42);
            __int16 v13 = v27;
          }
          else
          {
            *(_WORD *)__int16 v13 = v26;
            v13 += 2;
            uint64_t v27 = v13;
          }
          float v48 = v27;
        }
        v11 += 8;
      }
      while (v11 != v12);
    }
    if (v47 != v13)
    {
      long long v39 = v47 + 2;
      while (v39 != v13)
      {
        unsigned int v40 = *(unsigned __int16 *)v39;
        unsigned int v41 = *((unsigned __int16 *)v39 - 1);
        v39 += 2;
        if (v40 < v41)
        {
          LOBYTE(v42) = -86;
          std::__sort<std::__less<unsigned short,unsigned short> &,unsigned short *>();
          break;
        }
      }
    }
    TsfntTable::TsfntTable((TsfntTable *)&v42, a1, 1851878757);
    unsigned __int16 v42 = (char **)&unk_1F0DD6FF8;
    TnameTable::GetNames((TnameTable *)&v42, (const unsigned __int16 *)v47, (v48 - v47) >> 1, a3);
    TDataReference::~TDataReference((TDataReference *)&v42);
    unsigned __int16 v42 = &v47;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:fe180100]((void ***)&v42);
  }
  else
  {
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)(a3 + 32) = 1065353216;
  }
}

void sub_1B52E2A10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char *a16, char a17)
{
  a16 = &a17;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:fe180100]((void ***)&a16);
  _Unwind_Resume(a1);
}

char **std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve(char **result, unint64_t a2)
{
  if (a2 > (result[2] - *result) >> 1)
  {
    uint64_t v3 = result;
    if ((a2 & 0x8000000000000000) != 0) {
      std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v4 = result[1] - *result;
    v12[4] = result + 3;
    uint64_t v5 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)(result + 3), a2);
    BOOL v7 = *v3;
    int v6 = v3[1];
    long long v8 = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
    if (v6 != *v3)
    {
      BOOL v9 = v3[1];
      long long v8 = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
      do
      {
        __int16 v10 = *((_WORD *)v9 - 1);
        v9 -= 2;
        *((_WORD *)v8 - 1) = v10;
        v8 -= 2;
      }
      while (v9 != v7);
    }
    *uint64_t v3 = v8;
    v3[1] = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
    uint64_t v11 = v3[2];
    v3[2] = &v5[2 * a2];
    _OWORD v12[2] = v6;
    void v12[3] = v11;
    v12[0] = v7;
    v12[1] = v7;
    return (char **)std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v12);
  }
  return result;
}

uint64_t TSFNTFont::GetLongGlyphsPerCharacters(atomic_uint *this, const unsigned __int16 *a2, unsigned int *a3, unsigned int a4)
{
  unsigned int v12 = a4;
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[3] = v6;
  long long v10 = v6;
  v9[1] = v6;
  _OWORD v9[2] = v6;
  v9[0] = v6;
  TcmapUnicodeTable::TcmapUnicodeTable((TcmapUnicodeTable *)v9, this);
  if ((void)v10)
  {
    TcmapUnicodeTable::MapGlyphs<unsigned int>((uint64_t)v9, (uint64_t)a2, a3, &v12);
    uint64_t v7 = v12;
    TDataReference::~TDataReference((TDataReference *)v9);
  }
  else
  {
    TDataReference::~TDataReference((TDataReference *)v9);
    return 0;
  }
  return v7;
}

void sub_1B52E2B9C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TSFNTFont::GetGlyphsForCharacterRange(atomic_uint *this, unsigned __int16 *a2, CFRange a3)
{
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  TcmapUnicodeTable::TcmapUnicodeTable((TcmapUnicodeTable *)v8, this);
  v9.CFIndex location = location;
  v9.CFIndex length = length;
  uint64_t v6 = TcmapUnicodeTable::MapRange((TcmapUnicodeTable *)v8, v9, a2);
  TDataReference::~TDataReference((TDataReference *)v8);
  return v6;
}

void sub_1B52E2C28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TDataReference::~TDataReference((TDataReference *)va);
  _Unwind_Resume(a1);
}

uint64_t TSFNTFont::GetLongGlyphsForCharacterRange(atomic_uint *this, unsigned int *a2, CFRange a3)
{
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  TcmapUnicodeTable::TcmapUnicodeTable((TcmapUnicodeTable *)v8, this);
  v9.CFIndex location = location;
  v9.CFIndex length = length;
  uint64_t v6 = TcmapUnicodeTable::MapRange((TcmapUnicodeTable *)v8, v9, a2);
  TDataReference::~TDataReference((TDataReference *)v8);
  return v6;
}

void sub_1B52E2CA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TDataReference::~TDataReference((TDataReference *)va);
  _Unwind_Resume(a1);
}

unint64_t TSFNTFont::GetGlyphToUnicodeMap(TSFNTFont *this, const __CFDictionary **a2)
{
  if ((*((unsigned char *)this + 136) & 1) == 0)
  {
    (*(void (**)(TSFNTFont *))(*(void *)this + 168))(this);
    operator new[]();
  }
  if (a2) {
    *a2 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 19, memory_order_acquire);
  }
  return atomic_load_explicit((atomic_ullong *volatile)this + 18, memory_order_acquire);
}

void sub_1B52E2E68(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void TSFNTFont::FillCharacterSet(TSFNTFont *this, __CFCharacterSet *a2)
{
}

void sub_1B52E3084(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B52E3060);
}

void TSFNTFont::CopyCharacterSet(TSFNTFont *this)
{
  CFMutableArrayRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  TSFNTFont::FillCharacterSet(this, Mutable);
}

TSFNTFont *TSFNTFont::GetOS2UnicodeRanges(TSFNTFont *this, unsigned int a2, unsigned int *a3, __n128 a4)
{
  uint64_t v4 = 168;
  if (HIWORD(a2)) {
    uint64_t v4 = 176;
  }
  unint64_t explicit = (_DWORD *)atomic_load_explicit((atomic_ullong *volatile)((char *)this + v4), memory_order_acquire);
  if (!explicit)
  {
    uint64_t v6 = this;
    (*(void (**)(TSFNTFont *, __n128))(*(void *)this + 168))(this, a4);
    TSFNTFont::FillCharacterSet(v6, 0);
  }
  *a3 = explicit[2];
  a3[1] = explicit[3];
  a3[2] = explicit[4];
  a3[3] = explicit[5];
  return this;
}

uint64_t TSFNTFont::GetCharactersForGlyph(TSFNTFont *this, unsigned __int16 a2, unsigned __int16 *a3, unint64_t a4)
{
  if ((*(unsigned int (**)(TSFNTFont *, uint64_t))(*(void *)this + 472))(this, 1516335206))
  {
    TzapfTable::TzapfTable((TzapfTable *)v22, this);
    unint64_t v8 = TzapfTable::MapToCharacters((TzapfTable *)v22, a2, a3, a4);
  }
  else
  {
    unsigned int v25 = (__CFDictionary *)0xAAAAAAAAAAAAAAAALL;
    unint64_t GlyphToUnicodeMap = TSFNTFont::GetGlyphToUnicodeMap(this, &v25);
    if (!GlyphToUnicodeMap || !v25) {
      return 0;
    }
    long long v10 = (unsigned int *)GlyphToUnicodeMap;
    unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v22[3] = v11;
    long long v23 = v11;
    v22[1] = v11;
    void v22[2] = v11;
    v22[0] = v11;
    TcmapUnicodeTable::TcmapUnicodeTable((TcmapUnicodeTable *)v22, (atomic_uint *)this);
    if (!(void)v23)
    {
      unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v20[3] = v15;
      _OWORD v20[4] = v15;
      v20[1] = v15;
      v20[2] = v15;
      v20[0] = v15;
      uint64_t v16 = (*(uint64_t (**)(TSFNTFont *))(*(void *)this + 440))(this);
      TcmapEncodingTable::TcmapEncodingTable((uint64_t)v20, this, v16);
      uint64_t v17 = v25;
      unsigned int v18 = (*(uint64_t (**)(TSFNTFont *))(*(void *)this + 168))(this);
      uint64_t CharacterForGlyphUsingMap = GetCharacterForGlyphUsingMap(v10, v17, v18, (void *)a2, a3, a4);
      TDataReference::~TDataReference((TDataReference *)v20);
      goto LABEL_8;
    }
    unsigned int v12 = v25;
    unsigned int v13 = (*(uint64_t (**)(TSFNTFont *))(*(void *)this + 168))(this);
    unint64_t v8 = GetCharacterForGlyphUsingMap(v10, v12, v13, (void *)a2, a3, a4);
  }
  uint64_t CharacterForGlyphUsingMap = v8;
LABEL_8:
  TDataReference::~TDataReference((TDataReference *)v22);
  return CharacterForGlyphUsingMap;
}

uint64_t TSFNTFont::GetNumberOfGlyphs(TSFNTFont *this)
{
  uint64_t NumGlyphs = *((unsigned int *)this + 33);
  if (!NumGlyphs)
  {
    TsfntTable::TsfntTable((TsfntTable *)v4, this, 1835104368);
    v4[0] = &unk_1F0DD6EE0;
    uint64_t NumGlyphs = TmaxpTable::GetNumGlyphs((TmaxpTable *)v4);
    TDataReference::~TDataReference((TDataReference *)v4);
    *((_DWORD *)this + 33) = NumGlyphs;
  }
  return NumGlyphs;
}

void sub_1B52E34C0(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TDataReference::~TDataReference((TDataReference *)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1B52E34ACLL);
}

uint64_t TSFNTFont::GetMaxAdvance(TSFNTFont *this)
{
  ThmtxTable::ThmtxTable((uint64_t)v4, this, 0);
  uint64_t Hhea = ThmtxTable::GetHhea((ThmtxTable *)v4);
  if (Hhea) {
    uint64_t v2 = bswap32(*(unsigned __int16 *)(Hhea + 10)) >> 16;
  }
  else {
    uint64_t v2 = 0;
  }
  TDataReference::~TDataReference((TDataReference *)v4);
  return v2;
}

void sub_1B52E3548(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TSFNTFont::GetStemH(TSFNTFont *this)
{
  return 0;
}

uint64_t TSFNTFont::GetStemV(TSFNTFont *this)
{
  return 0;
}

void TSFNTFont::GetCaretInfo(TSFNTFont *this, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  ThmtxTable::ThmtxTable((uint64_t)v7, this, 0);
  ThmtxTable::GetCaretInfo((ThmtxTable *)v7, a2, a3, a4);
  TDataReference::~TDataReference((TDataReference *)v7);
}

void sub_1B52E35E4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TDataReference::~TDataReference((TDataReference *)&a9);
  __cxa_begin_catch(a1);
  *long long v11 = 1;
  *long long v10 = 0;
  *CFRange v9 = 0;
  __cxa_end_catch();
  JUMPOUT(0x1B52E35D0);
}

unsigned __int16 *ThmtxTable::GetCaretInfo(ThmtxTable *this, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  uint64_t result = (unsigned __int16 *)ThmtxTable::GetHhea(this);
  if (result)
  {
    *a2 = bswap32(result[9]) >> 16;
    *a3 = bswap32(result[10]) >> 16;
    unsigned int v8 = bswap32(result[11]) >> 16;
  }
  else
  {
    LOWORD(v8) = 0;
    *a2 = 1;
    *a3 = 0;
  }
  *a4 = v8;
  return result;
}

void TSFNTFont::GetBounds(TSFNTFont *this, double *a2, double *a3, double *a4, double *a5)
{
  TheadTable::TheadTable((TheadTable *)v9, this);
  TheadTable::GetBounds((TheadTable *)v9, a2, a3, a4, a5);
  TDataReference::~TDataReference((TDataReference *)v9);
}

void sub_1B52E3704(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TDataReference::~TDataReference((TDataReference *)va);
  __cxa_begin_catch(a1);
  *uint64_t v5 = 0;
  *uint64_t v4 = 0;
  *uint64_t v3 = 0;
  *uint64_t v2 = 0;
  __cxa_end_catch();
  JUMPOUT(0x1B52E36ECLL);
}

uint64_t TSFNTFont::GetUnderlinePosition(TSFNTFont *this)
{
  TpostTable::TpostTable((TpostTable *)v3, this);
  unsigned int v1 = bswap32(*(unsigned __int16 *)(TpostTable::GetPost((TpostTable *)v3) + 8)) >> 16;
  TpostTable::~TpostTable((TpostTable *)v3);
  return (__int16)v1;
}

void sub_1B52E3788(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TSFNTFont::GetUnderlineThickness(TSFNTFont *this)
{
  TpostTable::TpostTable((TpostTable *)v3, this);
  uint64_t v1 = bswap32(*(unsigned __int16 *)(TpostTable::GetPost((TpostTable *)v3) + 10)) >> 16;
  TpostTable::~TpostTable((TpostTable *)v3);
  return v1;
}

void sub_1B52E3800(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL TSFNTFont::IsMonospaced(TSFNTFont *this)
{
  TpostTable::TpostTable((TpostTable *)v3, this);
  BOOL v1 = *(_DWORD *)(TpostTable::GetPost((TpostTable *)v3) + 12) != 0;
  TpostTable::~TpostTable((TpostTable *)v3);
  return v1;
}

void sub_1B52E3878(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL TsfntTable::operator BOOL(TsfntTable *a1)
{
  uint64_t v1 = *((void *)a1 + 1);
  if (!v1 || !*(void *)(v1 + 8)) {
    return 0;
  }
  unint64_t TableEnd = TsfntTable::GetTableEnd(a1);
  uint64_t v4 = *((void *)a1 + 1);
  if (v4)
  {
    uint64_t v4 = *(void *)(v4 + 8);
    if (v4) {
      v4 += *((void *)a1 + 2);
    }
  }
  return TableEnd != v4;
}

void TSFNTFont::GetGlyphName(TSFNTFont *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)(a3 + 32) = v5;
  *(_OWORD *)(a3 + 48) = v5;
  *(_OWORD *)a3 = v5;
  *(_OWORD *)(a3 + 16) = v5;
  TpostTable::TpostTable((TpostTable *)v7, this);
  TpostTable::GetGlyphName((TpostTable *)v7, a2, a3);
  TpostTable::~TpostTable((TpostTable *)v7);
  if (!*(void *)(a3 + 8))
  {
    uint64_t v6 = *(void *)(a3 + 40);
    if (!v6 || !*(void *)(v6 + 8))
    {
      TStringRef::~TStringRef((void **)a3);
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(void *)a3 = &unk_1F0DD43A0;
      *(unsigned char *)(a3 + 24) = 0;
      *(void *)(a3 + 32) = &unk_1F0DD4218;
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 48) = 0;
      *(void *)(a3 + 56) = 0;
    }
  }
}

void sub_1B52E39C0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TSFNTFont::VerifyGlyphName(TSFNTFont *this, uint64_t a2, const char *a3)
{
  TpostTable::TpostTable((TpostTable *)v7, this);
  uint64_t v5 = TpostTable::VerifyGlyphName((TpostTable *)v7, a2, a3);
  TpostTable::~TpostTable((TpostTable *)v7);
  return v5;
}

void sub_1B52E3A3C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TSFNTFont::GetRegistryOrderingSupplementFromCIDG(os_unfair_lock_s *this, TStringRef *a2, TStringRef *a3, unsigned int *a4)
{
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t CIDGTable = TSFNTFont::GetCIDGTable(this, &v10);
  uint64_t result = 0;
  if (CIDGTable && v10 >= 0x90)
  {
    if (*(_WORD *)CIDGTable)
    {
      return 0;
    }
    else
    {
      TStringRef::TStringRef((TStringRef *)v9, 0x40uLL, (const char *)(CIDGTable + 10));
      TStringRef::operator=((uint64_t)a2, (uint64_t)v9);
      TStringRef::~TStringRef(v9);
      TStringRef::TStringRef((TStringRef *)v9, 0x40uLL, (const char *)(CIDGTable + 76));
      TStringRef::operator=((uint64_t)a3, (uint64_t)v9);
      TStringRef::~TStringRef(v9);
      *a4 = bswap32(*(unsigned __int16 *)(CIDGTable + 140)) >> 16;
      return 1;
    }
  }
  return result;
}

void sub_1B52E3B30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TStringRef::~TStringRef((void **)va);
  _Unwind_Resume(a1);
}

uint64_t TSFNTFont::GetCIDGTable(os_unfair_lock_s *this, unint64_t *a2)
{
  uint64_t v4 = this + 22;
  os_unfair_lock_lock(this + 22);
  if (!LOBYTE(this[32]._os_unfair_lock_opaque))
  {
    TSFNTFont::GetTable((TSFNTFont *)this, 1667851367, 0, &v10);
    if (&this[24] != (os_unfair_lock_s *)&v10)
    {
      TDataReference::DucRefCount((TDataReference *)&this[24]);
      uint64_t v5 = v11;
      uint64_t v11 = 0;
      *(void *)&this[26]._os_unfair_lock_opaque = v5;
      *(_OWORD *)&this[28]._os_unfair_lock_opaque = v12;
    }
    TDataReference::~TDataReference((TDataReference *)&v10);
    LOBYTE(this[32]._os_unfair_lock_opaque) = 1;
  }
  *a2 = *(void *)&this[30]._os_unfair_lock_opaque - *(void *)&this[28]._os_unfair_lock_opaque;
  uint64_t v6 = *(void *)&this[26]._os_unfair_lock_opaque;
  if (v6 && (uint64_t v7 = *(void *)(v6 + 8)) != 0) {
    uint64_t v8 = v7 + *(void *)&this[28]._os_unfair_lock_opaque;
  }
  else {
    uint64_t v8 = 0;
  }
  os_unfair_lock_unlock(v4);
  return v8;
}

void sub_1B52E3C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TDataReference::~TDataReference((TDataReference *)&a9);
  os_unfair_lock_unlock(v9);
  _Unwind_Resume(a1);
}

void TStringRef::TStringRef(TStringRef *this, size_t a2, const char *__s1)
{
  uint64_t v6 = strndup(__s1, a2);
  size_t v7 = strnlen(__s1, a2);
  *((void *)this + 1) = v6;
  *((void *)this + 2) = v7;
  *(void *)this = &unk_1F0DD43A0;
  *((unsigned char *)this + 24) = 1;
  *((void *)this + 4) = &unk_1F0DD4218;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
}

BOOL TSFNTFont::GetGlyphsForCIDs(TSFNTFont *this, const unsigned __int16 *a2, uint64_t a3, unsigned __int16 *a4)
{
  uint64_t v33 = 0;
  unint64_t v34 = 0xAAAAAAAAAAAAAA00;
  uint64_t v31 = &unk_1F0DD43A0;
  uint64_t v32 = 0;
  float v35 = &unk_1F0DD4218;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v25 = 0;
  unint64_t v26 = 0xAAAAAAAAAAAAAA00;
  long long v23 = &unk_1F0DD43A0;
  unint64_t v24 = 0;
  uint64_t v27 = &unk_1F0DD4218;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  int v22 = -1431655766;
  (*(void (**)(void))(*(void *)this + 360))();
  uint64_t v8 = v32;
  if (!v32)
  {
    if (v36 && (uint64_t v9 = *(void *)(v36 + 8)) != 0) {
      uint64_t v8 = (const char *)(v9 + v37);
    }
    else {
      uint64_t v8 = 0;
    }
  }
  uint64_t v10 = v24;
  if (!v24)
  {
    if (v28 && (uint64_t v11 = *(void *)(v28 + 8)) != 0) {
      uint64_t v10 = (const char *)(v11 + v29);
    }
    else {
      uint64_t v10 = 0;
    }
  }
  uint64_t v12 = DetermineROS(v8, v10);
  if ((v12 & 0xFF00000000) != 0
    && (v12 & 0xFFFFFFFC) == 0
    && (unint64_t v15 = 8 * (int)v12,
        uint64_t v16 = *(void *)&aLv[v15],
        uint64_t v17 = *(uint64_t *)((char *)&off_1E60E1798 + v15),
        v21[1] = off_1E60E17B8[v15 / 8],
        void v21[2] = v16,
        v21[0] = v17,
        a3))
  {
    uint64_t v18 = 0;
    do
    {
      unsigned int v19 = *a2++;
      int GlyphForCID = GetGlyphForCID((uint64_t)this, (uint64_t)v21, v19);
      *a4++ = GlyphForCID;
      if (GlyphForCID) {
        ++v18;
      }
      --a3;
    }
    while (a3);
    BOOL v13 = v18 != 0;
  }
  else
  {
    BOOL v13 = 0;
  }
  TStringRef::~TStringRef(&v23);
  TStringRef::~TStringRef(&v31);
  return v13;
}

void sub_1B52E3EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void *);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  TStringRef::~TStringRef((void **)va);
  TStringRef::~TStringRef((void **)va1);
  _Unwind_Resume(a1);
}

uint64_t GetGlyphForCID(uint64_t a1, uint64_t a2, unsigned int a3)
{
  v26[1] = *MEMORY[0x1E4F143B8];
  v26[0] = 0xAAAAAAAAAAAAAAAALL;
  if (*(unsigned __int16 *)(a2 + 16) <= a3) {
    return 0;
  }
  uint64_t v4 = (const char *)(*(void *)a2 + 4 * a3);
  int v5 = *v4;
  if (v5 < 0)
  {
    uint64_t v4 = (const char *)(*(void *)(a2 + 8) + bswap32(*(_DWORD *)v4 & 0xFFFFFF7F));
    size_t v6 = strlen(v4);
    LOBYTE(v5) = *v4;
  }
  else
  {
    size_t v6 = 4 * (v5 != 0);
  }
  unint64_t v7 = 16;
  if (v6 < 0x10) {
    unint64_t v7 = v6;
  }
  if (!(_BYTE)v5 || v7 == 0) {
    return 0;
  }
  uint64_t v9 = 0;
  __int16 v10 = 0;
  unint64_t v11 = 1;
  do
  {
    __int16 v12 = (char)v5;
    if ((v5 - 48) >= 0xAu)
    {
      if (((char)v5 - 65) >= 6)
      {
        if (((char)v5 - 97) > 5) {
          return 0;
        }
        __int16 v13 = -87;
      }
      else
      {
        __int16 v13 = -55;
      }
    }
    else
    {
      __int16 v13 = -48;
    }
    __int16 v10 = v12 + 16 * v10 + v13;
    if ((v11 & 3) == 0) {
      *((_WORD *)v26 + v9++) = v10;
    }
    if (v11 >= v7) {
      break;
    }
    int v5 = v4[v11++];
  }
  while (v5);
  if (!v9) {
    return 0;
  }
  if ((WORD1(v26[0]) & 0xFC00) == 0xDC00) {
    int v14 = 2;
  }
  else {
    int v14 = 1;
  }
  if ((v26[0] & 0xFC00) != 0xD800 || v9 == 1) {
    unsigned int v16 = 1;
  }
  else {
    unsigned int v16 = v14;
  }
  if (v16 == v9) {
    goto LABEL_44;
  }
  unsigned int v17 = v16 + 1;
  UChar32 v18 = *((unsigned __int16 *)v26 + v16);
  if ((v18 & 0xFC00) == 0xD800 && v17 != v9)
  {
    int v20 = *((unsigned __int16 *)v26 + v17);
    BOOL v21 = (v20 & 0xFC00) == 56320;
    int v22 = v20 + (v18 << 10) - 56613888;
    if (v21) {
      unsigned int v17 = v16 + 2;
    }
    else {
      unsigned int v17 = v16 + 1;
    }
    if (v21) {
      UChar32 v18 = v22;
    }
  }
  uint64_t result = u_hasBinaryProperty(v18, UCHAR_VARIATION_SELECTOR);
  LODWORD(v9) = v17;
  if (result)
  {
LABEL_44:
    unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
    int v24 = v9;
    (*(void (**)(uint64_t, void *, unint64_t *, int *, void))(*(void *)a1 + 120))(a1, v26, &v25, &v24, 0);
    if (v24 == v9) {
      return (unsigned __int16)v25;
    }
    return 0;
  }
  return result;
}

BOOL TSFNTFont::GetCIDsForGlyphs(atomic_ullong *this, const unsigned __int16 *a2, uint64_t a3, unsigned __int16 *a4)
{
  _OWORD v19[2] = 0;
  v19[3] = (void *)0xAAAAAAAAAAAAAA00;
  v19[0] = &unk_1F0DD43A0;
  v19[1] = 0;
  void v19[4] = &unk_1F0DD4218;
  memset(&v19[5], 0, 24);
  void v18[2] = 0;
  v18[3] = (void *)0xAAAAAAAAAAAAAA00;
  v18[0] = &unk_1F0DD43A0;
  v18[1] = 0;
  int v18[4] = &unk_1F0DD4218;
  memset(&v18[5], 0, 24);
  (*(void (**)(void))(*this + 360))();
  uint64_t v8 = DetermineROS(0, 0);
  if ((v8 & 0xFF00000000) != 0 && (v8 & 0xFFFFFFFC) == 0)
  {
    unsigned int v10 = (*(uint64_t (**)(atomic_ullong *))(*this + 168))(this);
    if (v10 >= 0xFFFF) {
      unsigned int v11 = 0xFFFF;
    }
    else {
      unsigned int v11 = v10;
    }
    unint64_t explicit = atomic_load_explicit(this + 20, memory_order_acquire);
    if (!explicit) {
      operator new[]();
    }
    for (uint64_t i = 0; a3; --a3)
    {
      *a4 = -1;
      unsigned int v15 = *a2++;
      uint64_t v14 = v15;
      if (v15 < v11)
      {
        int v16 = *(unsigned __int16 *)(explicit + 2 * v14);
        if (v16)
        {
          *a4 = v16 - 1;
          ++i;
        }
      }
      ++a4;
    }
    BOOL v9 = i != 0;
  }
  else
  {
    BOOL v9 = 0;
  }
  TStringRef::~TStringRef(v18);
  TStringRef::~TStringRef(v19);
  return v9;
}

void sub_1B52E4444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  size_t v6 = va_arg(va1, void *);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  TStringRef::~TStringRef((void **)va);
  TStringRef::~TStringRef((void **)va1);
  _Unwind_Resume(a1);
}

uint64_t TSFNTFont::GetVariationAxes(TSFNTFont *a1, void *a2)
{
  unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v43 = v3;
  long long v44 = v3;
  long long v42 = v3;
  TsfntTable::TsfntTable((TsfntTable *)&v42, a1, 1719034226);
  if (!*((void *)&v42 + 1)) {
    goto LABEL_29;
  }
  uint64_t v4 = *(void *)(*((void *)&v42 + 1) + 8);
  if (!v4) {
    goto LABEL_29;
  }
  uint64_t v5 = v43;
  unint64_t TableEnd = TsfntTable::GetTableEnd((TsfntTable *)&v42);
  unint64_t v7 = (unsigned __int16 *)(v4 + v5);
  if (v4 + v5 + 16 > TableEnd)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  if (!v7[4]) {
    goto LABEL_29;
  }
  unint64_t v8 = __rev16(v7[4]);
  if (v8 >= 0x101)
  {
    uint64_t v37 = __cxa_allocate_exception(0x10uLL);
    *(void *)uint64_t v37 = &unk_1F0DD4440;
    _OWORD v37[2] = 4;
  }
  uint64_t v9 = (int8x8_t *)((char *)v7 + (bswap32(v7[2]) >> 16));
  if ((unint64_t)&v9[2] + 4 > TableEnd)
  {
    uint64_t v38 = __cxa_allocate_exception(0x10uLL);
    *(void *)uint64_t v38 = &unk_1F0DD4440;
    v38[2] = 4;
  }
  unint64_t v10 = bswap32(v7[5]) >> 16;
  if (v10 <= 0x13)
  {
    long long v39 = __cxa_allocate_exception(0x10uLL);
    *(void *)long long v39 = &unk_1F0DD4440;
    uint64_t v39[2] = 4;
  }
  unint64_t v11 = (TableEnd - (unint64_t)v9) / v10 >= v8 ? v8 : (TableEnd - (unint64_t)v9) / v10;
  if (v11)
  {
    uint64_t v12 = 0;
    uint64_t v13 = a2 + 2;
    i8 = (char *)a2[1];
    float64x2_t v15 = (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL);
    float64x2_t v40 = v15;
    do
    {
      unsigned int v16 = bswap32(v9->i32[0]);
      unsigned int v17 = bswap32(v9[2].u16[0]) >> 16;
      unsigned int v18 = bswap32(v9[2].u16[1]) >> 16;
      double v19 = (double)(int)bswap32(v9->u32[1]) * 0.0000152587891;
      int8x8_t v20 = vrev32_s8(v9[1]);
      v21.i64[0] = v20.i32[0];
      v21.i64[1] = v20.i32[1];
      int8x16_t v22 = (int8x16_t)vmulq_f64(vcvtq_f64_s64(v21), v15);
      if ((unint64_t)i8 >= *v13)
      {
        int8x16_t v41 = v22;
        uint64_t v23 = (uint64_t)&i8[-*a2] >> 5;
        if ((unint64_t)(v23 + 1) >> 59) {
          std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
        }
        uint64_t v24 = *v13 - *a2;
        uint64_t v25 = v24 >> 4;
        if (v24 >> 4 <= (unint64_t)(v23 + 1)) {
          uint64_t v25 = v23 + 1;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v26 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v26 = v25;
        }
        uint64_t v27 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationAxis>>((uint64_t)(a2 + 2), v26);
        uint64_t v29 = (int8x16_t *)&v27[32 * v23];
        v29->i32[0] = v16;
        v29->i16[2] = v17;
        v29->i16[3] = v18;
        *(double *)&v29->i64[1] = v19;
        v29[1] = vextq_s8(v41, v41, 8uLL);
        uint64_t v31 = (char *)*a2;
        uint64_t v30 = (char *)a2[1];
        uint64_t v32 = v29;
        if (v30 != (char *)*a2)
        {
          do
          {
            int8x16_t v33 = *((int8x16_t *)v30 - 1);
            v32[-2] = *((int8x16_t *)v30 - 2);
            v32[-1] = v33;
            v32 -= 2;
            v30 -= 32;
          }
          while (v30 != v31);
          uint64_t v30 = (char *)*a2;
        }
        i8 = v29[2].i8;
        *a2 = v32;
        a2[1] = v29 + 2;
        a2[2] = &v27[32 * v28];
        if (v30) {
          operator delete(v30);
        }
        float64x2_t v15 = v40;
      }
      else
      {
        *(_DWORD *)i8 = v16;
        *((_WORD *)i8 + 2) = v17;
        *((_WORD *)i8 + 3) = v18;
        *((double *)i8 + 1) = v19;
        *((int8x16_t *)i8 + 1) = vextq_s8(v22, v22, 8uLL);
        i8 += 32;
      }
      a2[1] = i8;
      uint64_t v9 = (int8x8_t *)((char *)v9 + v10);
      ++v12;
    }
    while (v12 != v11);
    uint64_t v34 = 1;
  }
  else
  {
LABEL_29:
    uint64_t v34 = 0;
  }
  TDataReference::~TDataReference((TDataReference *)&v42);
  return v34;
}

void sub_1B52E4828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  TDataReference::~TDataReference((TDataReference *)va);
  _Unwind_Resume(a1);
}

void TSFNTFont::GetVariationInstances(TSFNTFont *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, void **a4@<X8>)
{
  unint64_t v72 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v70 = v7;
  long long v71 = v7;
  long long v69 = v7;
  TsfntTable::TsfntTable((TsfntTable *)&v69, a1, 1719034226);
  if (!*((void *)&v69 + 1)) {
    goto LABEL_71;
  }
  uint64_t v8 = *(void *)(*((void *)&v69 + 1) + 8);
  if (!v8) {
    goto LABEL_71;
  }
  uint64_t v9 = v70;
  unint64_t TableEnd = TsfntTable::GetTableEnd((TsfntTable *)&v69);
  unint64_t v11 = TableEnd;
  uint64_t v12 = (unsigned __int16 *)(v8 + v9);
  if ((unint64_t)(v12 + 8) > TableEnd) {
    goto LABEL_76;
  }
  if (bswap32(v12[4]) >> 16 != a2)
  {
LABEL_71:
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    goto LABEL_72;
  }
  if (a2 >= 0x101)
  {
LABEL_76:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  uint64_t v13 = (char *)v12 + (bswap32(v12[2]) >> 16);
  if ((unint64_t)(v13 + 20) > TableEnd)
  {
    float v57 = __cxa_allocate_exception(0x10uLL);
    *(void *)float v57 = &unk_1F0DD4440;
    v57[2] = 4;
  }
  uint64_t v14 = &v13[(bswap32(v12[5]) >> 16) * a2];
  if ((unint64_t)v14 > TableEnd)
  {
    float v58 = __cxa_allocate_exception(0x10uLL);
    *(void *)float v58 = &unk_1F0DD4440;
    v58[2] = 4;
  }
  if (!v12[7])
  {
    float v59 = __cxa_allocate_exception(0x10uLL);
    *(void *)float v59 = &unk_1F0DD4440;
    v59[2] = 4;
  }
  unint64_t v15 = __rev16(v12[7]);
  unint64_t v16 = bswap32(v12[6]) >> 16;
  unint64_t v68 = v15;
  if ((TableEnd - (unint64_t)v14) / v15 >= v16) {
    unint64_t v17 = v16;
  }
  else {
    unint64_t v17 = (TableEnd - (unint64_t)v14) / v15;
  }
  if (!v17) {
    goto LABEL_71;
  }
  a4[2] = 0;
  uint64_t v60 = (uint64_t)(a4 + 2);
  *a4 = 0;
  a4[1] = 0;
  float v65 = a4;
  std::vector<TVariationInstance>::reserve(a4, v17);
  std::vector<double>::reserve((void **)a3, v17 * a2);
  uint64_t v18 = 0;
  unint64_t v61 = v11;
  float v64 = v12;
  double v19 = (void *)(a3 + 16);
  unint64_t v62 = a2 << 48;
  unint64_t v63 = v17;
  do
  {
    int8x8_t v20 = (unsigned __int16 *)(v14 + 4);
    unint64_t v21 = (unint64_t)&v14[4 * a2 + 4];
    if (v12 > (unsigned __int16 *)v14 + 2 || v21 < (unint64_t)v20 || v21 > v11)
    {
      BOOL v24 = (unint64_t)(v14 + 8) > v11 || v12 > v20;
      unint64_t v25 = (v11 - (unint64_t)v20) >> 2;
      if (v24) {
        unint64_t v25 = 0;
      }
      if (v25 != a2)
      {
        float v55 = __cxa_allocate_exception(0x10uLL);
        *(void *)float v55 = &unk_1F0DD4440;
        void v55[2] = 4;
      }
    }
    unsigned int v66 = *(unsigned __int16 *)v14;
    unsigned int v67 = *((unsigned __int16 *)v14 + 1);
    if (a2)
    {
      uint64_t v26 = 0;
      uint64_t v27 = *(double **)(a3 + 8);
      do
      {
        double v28 = (double)(int)bswap32(*(_DWORD *)&v14[4 * v26 + 4]) * 0.0000152587891;
        if ((unint64_t)v27 >= *v19)
        {
          uint64_t v30 = *(double **)a3;
          uint64_t v31 = ((uint64_t)v27 - *(void *)a3) >> 3;
          unint64_t v32 = v31 + 1;
          if ((unint64_t)(v31 + 1) >> 61) {
            std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v33 = *v19 - (void)v30;
          if (v33 >> 2 > v32) {
            unint64_t v32 = v33 >> 2;
          }
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v34 = v32;
          }
          if (v34)
          {
            float v35 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationInstance>>(a3 + 16, v34);
            uint64_t v30 = *(double **)a3;
            uint64_t v27 = *(double **)(a3 + 8);
          }
          else
          {
            float v35 = 0;
          }
          uint64_t v36 = (double *)&v35[8 * v31];
          double *v36 = v28;
          uint64_t v29 = v36 + 1;
          while (v27 != v30)
          {
            uint64_t v37 = *((void *)v27-- - 1);
            *((void *)v36-- - 1) = v37;
          }
          *(void *)a3 = v36;
          *(void *)(a3 + 8) = v29;
          *(void *)(a3 + 16) = &v35[8 * v34];
          if (v30) {
            operator delete(v30);
          }
        }
        else
        {
          *uint64_t v27 = v28;
          uint64_t v29 = v27 + 1;
        }
        *(void *)(a3 + 8) = v29;
        ++v26;
        uint64_t v27 = v29;
      }
      while (v26 != a2);
    }
    if (4 * a2 + 6 <= v68) {
      unsigned int v38 = (bswap32(*(unsigned __int16 *)&v14[4 * a2 + 4]) >> 16) + 1;
    }
    else {
      LOWORD(v38) = 0;
    }
    unsigned int v39 = bswap32(v66) >> 16;
    uint64_t v40 = bswap32(v67) >> 16;
    long long v42 = (unint64_t *)v65[1];
    unint64_t v41 = (unint64_t)v65[2];
    if ((unint64_t)v42 >= v41)
    {
      uint64_t v46 = ((char *)v42 - (unsigned char *)*v65) >> 3;
      if ((unint64_t)(v46 + 1) >> 61) {
        std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v47 = v41 - (void)*v65;
      uint64_t v48 = v47 >> 2;
      if (v47 >> 2 <= (unint64_t)(v46 + 1)) {
        uint64_t v48 = v46 + 1;
      }
      if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v49 = v48;
      }
      if (v49) {
        float v50 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TVariationInstance>>(v60, v49);
      }
      else {
        float v50 = 0;
      }
      BOOL v51 = (unint64_t *)&v50[8 * v46];
      *BOOL v51 = ((unint64_t)v39 << 16) | ((unint64_t)(unsigned __int16)v38 << 32) | v40 | v62;
      long long v44 = v51 + 1;
      unint64_t v45 = v65;
      float v53 = (char *)*v65;
      uint64_t v52 = (char *)v65[1];
      if (v52 == *v65)
      {
        unint64_t v11 = v61;
      }
      else
      {
        unint64_t v11 = v61;
        do
        {
          unint64_t v54 = *((void *)v52 - 1);
          v52 -= 8;
          *--BOOL v51 = v54;
        }
        while (v52 != v53);
        uint64_t v52 = (char *)*v65;
      }
      float *v65 = v51;
      v65[1] = v44;
      v65[2] = &v50[8 * v49];
      if (v52) {
        operator delete(v52);
      }
    }
    else
    {
      unint64_t v43 = ((unint64_t)v39 << 16) | ((unint64_t)(unsigned __int16)v38 << 32);
      unint64_t v11 = v61;
      *long long v42 = v43 | v40 | v62;
      long long v44 = v42 + 1;
      unint64_t v45 = v65;
    }
    v45[1] = v44;
    v14 += v68;
    ++v18;
    uint64_t v12 = v64;
  }
  while (v18 != v63);
LABEL_72:
  TDataReference::~TDataReference((TDataReference *)&v69);
}

void sub_1B52E4DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  TDataReference::~TDataReference((TDataReference *)va);
  _Unwind_Resume(a1);
}

uint64_t TSFNTFont::Normalize(TSFNTFont *a1, uint64_t a2, uint64_t a3, _WORD *a4)
{
  v110[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v83 = v8;
    long long v84 = v8;
    TSFNTFont::GetTable(a1, 1719034226, 0, &v83);
    if (*((void *)&v83 + 1) && (uint64_t v9 = *(void *)(*((void *)&v83 + 1) + 8)) != 0) {
      uint64_t v10 = v9 + v84;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *((void *)&v84 + 1) - v84;
    if (*((void *)&v84 + 1) == (void)v84)
    {
      bzero(a4, 2 * a2);
      char v12 = 0;
LABEL_112:
      TDataReference::~TDataReference((TDataReference *)&v83);
      return v12 & 1;
    }
    *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v81 = v13;
    long long v82 = v13;
    TSFNTFont::GetTable(a1, 1635148146, 0, &v81);
    uint64_t v14 = (unsigned __int16 *)*((void *)&v81 + 1);
    if (*((void *)&v81 + 1))
    {
      uint64_t v14 = *(unsigned __int16 **)(*((void *)&v81 + 1) + 8);
      if (v14) {
        uint64_t v14 = (unsigned __int16 *)((char *)v14 + v82);
      }
    }
    BOOL v15 = *((void *)&v82 + 1) != (void)v82;
    BOOL v16 = v14 + 4 <= (unsigned __int16 *)((char *)v14 + *((void *)&v82 + 1) - v82);
    if (v15 && v16) {
      unint64_t v17 = (unint64_t)v14 + *((void *)&v82 + 1) - v82;
    }
    else {
      unint64_t v17 = 0;
    }
    if (v15 && v16) {
      uint64_t v18 = v14;
    }
    else {
      uint64_t v18 = 0;
    }
    if (a2 != bswap32(*(unsigned __int16 *)(v10 + 8)) >> 16)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 4;
    }
    *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v109[14] = v19;
    v109[13] = v19;
    int8x8_t v20 = v109;
    v109[12] = v19;
    v109[11] = v19;
    v109[10] = v19;
    v109[9] = v19;
    v109[8] = v19;
    unsigned char v109[7] = v19;
    v109[6] = v19;
    v109[5] = v19;
    v109[4] = v19;
    v109[3] = v19;
    v109[2] = v19;
    v109[1] = v19;
    v109[0] = v19;
    uint64_t v106 = 0;
    int v107 = 0;
    unsigned __int16 v108 = 0;
    v110[0] = v109;
    if ((void *)((char *)v109 + 8 * a2) <= v110)
    {
      v110[0] = (char *)v109 + 8 * a2;
      size_t v21 = 8 * a2;
    }
    else
    {
      size_t v21 = 8 * a2;
      int8x8_t v20 = operator new(8 * a2);
    }
    unint64_t v22 = v10 + v11;
    uint64_t v106 = v20;
    unsigned __int16 v108 = (char *)v20 + 8 * a2;
    bzero(v20, v21);
    int v107 = (char *)v20 + 8 * a2;
    uint64_t v23 = 16 * a2;
    BOOL v24 = (double *)(a3 + 8);
    unint64_t v25 = v20;
    do
    {
      unsigned int v26 = vcvtd_n_s64_f64(*v24, 0x10uLL);
      *unint64_t v25 = *((_DWORD *)v24 - 2);
      v25[1] = v26;
      v25 += 2;
      v24 += 2;
      v23 -= 16;
    }
    while (v23);
    uint64_t v27 = (unsigned int *)(v10 + (bswap32(*(unsigned __int16 *)(v10 + 4)) >> 16));
    double v28 = &v27[5 * a2];
    BOOL v29 = v28 < v27 || (unint64_t)v28 > v22;
    unint64_t v30 = a2;
    if (v29)
    {
      if ((unint64_t)(v27 + 5) > v22)
      {
        unint64_t v80 = a2;
        if (v18)
        {
          BOOL v32 = 0;
          unsigned int v79 = v18;
          float v35 = v18 + 4;
          goto LABEL_72;
        }
LABEL_118:
        char v12 = 0;
        goto LABEL_111;
      }
      unint64_t v30 = (v22 - (unint64_t)v27) / 0x14;
    }
    if (v18)
    {
      unsigned int v79 = v18;
      unint64_t v80 = a2;
      uint64_t v31 = v18 + 4;
      BOOL v32 = 0;
      if (v30)
      {
        uint64_t v33 = &v27[5 * v30];
        unint64_t v34 = a4;
        float v35 = v31;
        do
        {
          if (v31 > v35 || (uint64_t v36 = v35 + 1, (unint64_t)(v35 + 1) > v17))
          {
            int v76 = __cxa_allocate_exception(0x10uLL);
            *(void *)int v76 = &unk_1F0DD4440;
            v76[2] = 4;
          }
          int v37 = NormalizedAxisCoord(v27, v80, (uint64_t)v20);
          if (v37)
          {
            uint64_t v38 = bswap32(*v35) >> 16;
            unint64_t v39 = (unint64_t)&v36[2 * v38];
            BOOL v40 = v39 >= (unint64_t)v36;
            BOOL v41 = v39 <= v17;
            unsigned int v42 = (v17 - v36) >> 2;
            if ((unint64_t)(v35 + 3) > v17) {
              LOWORD(v42) = 0;
            }
            uint64_t v43 = (unsigned __int16)v42;
            if (v40 && v41) {
              uint64_t v43 = v38;
            }
            else {
              LOWORD(v38) = v42;
            }
            if ((unsigned __int16)v38 >= 2u)
            {
              int v44 = 4 * ((int)bswap32(v35[1]) >> 16);
              int v45 = 4 * ((int)bswap32(v35[2]) >> 16);
              uint64_t v46 = v43 - 1;
              uint64_t v47 = v35 + 4;
              while (1)
              {
                int v48 = 4 * ((int)bswap32(*(v47 - 1)) >> 16);
                int v49 = 4 * ((int)bswap32(*v47) >> 16);
                BOOL v50 = v48 < v37 || v48 <= v44;
                if (!v50 && v49 >= v45) {
                  break;
                }
                v47 += 2;
                BOOL v32 = 1;
                int v45 = v49;
                int v44 = v48;
                if (!--v46) {
                  goto LABEL_60;
                }
              }
              int v52 = v45 + (v49 - v45) * (uint64_t)(v37 - v44) / (v48 - v44);
              if (v52 >= 0x10000) {
                int v52 = 0x10000;
              }
              if (v52 <= -65536) {
                int v37 = -65536;
              }
              else {
                int v37 = v52;
              }
            }
            BOOL v32 = 1;
          }
LABEL_60:
          *unint64_t v34 = (v37 + 2) >> 2;
          uint64_t v53 = (4 * (bswap32(*v35) >> 16)) | 2;
          if ((unint64_t)v35 + v53 > v17 || (unsigned __int16 *)((char *)v35 + v53) < v35)
          {
            int v77 = __cxa_allocate_exception(0x10uLL);
            *(void *)int v77 = &unk_1F0DD4440;
            v77[2] = 4;
          }
          ++v34;
          float v35 = (unsigned __int16 *)((char *)v35 + v53);
          v27 += 5;
        }
        while (v27 != v33);
      }
      else
      {
        float v35 = v18 + 4;
      }
LABEL_72:
      if (bswap32(*v79) >> 16 >= 2 && v35 + 2 >= v79 && (unint64_t)(v35 + 4) <= v17)
      {
        unsigned int v57 = *((_DWORD *)v35 + 1);
        *(_OWORD *)int v86 = 0u;
        long long v87 = 0u;
        long long v85 = 0u;
        if (v57)
        {
          if (ItemVariationStore::Initialize(&v85, (uint64_t)v79 + bswap32(v57), v17))
          {
            if (*(_DWORD *)v35)
            {
              float v58 = (DeltaSetIndexMap *)((char *)v79 + bswap32(*(_DWORD *)v35));
              if ((unint64_t)v58 + 1 > v17) {
                goto LABEL_110;
              }
              int v59 = *(unsigned __int8 *)v58;
              uint64_t v60 = 6;
              if (v59 != 1) {
                uint64_t v60 = 0;
              }
              BOOL v74 = v59 == 0;
              uint64_t v61 = 4;
              if (!v74) {
                uint64_t v61 = v60;
              }
              unint64_t v62 = (char *)v58 + v61;
              if (v62 < (char *)v58 || (unint64_t)v62 > v17) {
                goto LABEL_110;
              }
            }
            else
            {
              float v58 = 0;
            }
            *(void *)&long long v64 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v64 + 1) = 0xAAAAAAAAAAAAAAAALL;
            long long v104 = v64;
            long long v105 = v64;
            long long v102 = v64;
            long long v103 = v64;
            long long v100 = v64;
            long long v101 = v64;
            long long v98 = v64;
            long long v99 = v64;
            long long v96 = v64;
            long long v97 = v64;
            long long v94 = v64;
            long long v95 = v64;
            long long v92 = v64;
            long long v93 = v64;
            long long v90 = v64;
            long long v91 = v64;
            *(_OWORD *)unsigned int v89 = v64;
            int v88 = 0;
            std::vector<double,TInlineBufferAllocator<double,30ul>>::vector(v89, (unint64_t)v86[0], &v88);
            if (v86[0])
            {
              uint64_t v65 = 0;
              unsigned int v66 = v89[0];
              do
              {
                v66[v65] = ItemVariationStore::VariationRegionList::ComputeScalar(v86[1], v65, v80, a4);
                ++v65;
              }
              while ((ItemVariationStore::VariationRegionList *)v65 != v86[0]);
            }
            for (uint64_t i = 0; i != v80; ++i)
            {
              int v68 = i;
              if (v58) {
                int v68 = DeltaSetIndexMap::IndexForValue(v58, i, v17);
              }
              unsigned int v69 = llround(ItemVariationStore::ValueForDeltaSet((ItemVariationStore *)&v85, HIWORD(v68), (unsigned __int16)v68, 0, 0, v89[0]));
              if (v69)
              {
                int v70 = (__int16)a4[i] + v69;
                if (v70 >= 0x4000) {
                  int v70 = 0x4000;
                }
                if (v70 <= -16384) {
                  LOWORD(v70) = -16384;
                }
                a4[i] = v70;
              }
            }
            uint64_t v71 = 2 * v80 - 2;
            do
            {
              int v73 = (unsigned __int16)*a4++;
              int v72 = v73;
              if (v73) {
                BOOL v74 = 1;
              }
              else {
                BOOL v74 = v71 == 0;
              }
              v71 -= 2;
            }
            while (!v74);
            BOOL v32 = v72 != 0;
            int v88 = v89;
            std::vector<double,TInlineBufferAllocator<double,30ul>>::__destroy_vector::operator()[abi:fe180100]((void ***)&v88);
          }
        }
      }
LABEL_110:
      char v12 = v32;
LABEL_111:
      std::vector<std::pair<unsigned int,int>,TInlineBufferAllocator<std::pair<unsigned int,int>,30ul>>::__destroy_vector::operator()[abi:fe180100]((uint64_t)&v106);
      TDataReference::~TDataReference((TDataReference *)&v81);
      goto LABEL_112;
    }
    if (v30)
    {
      char v12 = 0;
      uint64_t v55 = 20 * v30;
      do
      {
        int v56 = NormalizedAxisCoord(v27, a2, (uint64_t)v20);
        v12 |= v56 != 0;
        *a4++ = (v56 + 2) >> 2;
        v27 += 5;
        v55 -= 20;
      }
      while (v55);
      goto LABEL_111;
    }
    goto LABEL_118;
  }
  char v12 = 0;
  return v12 & 1;
}

void sub_1B52E5588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
}

BOOL TSFNTFont::HasBadvmtxTables(TSFNTFont *this)
{
  int v1 = *((_DWORD *)this + 46);
  if (v1 < 0)
  {
    *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v13 = v3;
    long long v14 = v3;
    TSFNTFont::GetTable(this, 1751672161, 0, &v13);
    uint64_t v4 = *((void *)&v13 + 1);
    if (*((void *)&v13 + 1))
    {
      uint64_t v4 = *(void *)(*((void *)&v13 + 1) + 8);
      if (v4) {
        v4 += v14;
      }
    }
    if (*((void *)&v14 + 1) - (void)v14 <= 0x23uLL) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = v4;
    }
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v11 = v6;
    long long v12 = v6;
    TSFNTFont::GetTable(this, 1986553185, 0, &v11);
    uint64_t v7 = *((void *)&v11 + 1);
    if (*((void *)&v11 + 1))
    {
      uint64_t v7 = *(void *)(*((void *)&v11 + 1) + 8);
      if (v7) {
        v7 += v12;
      }
    }
    if (*((void *)&v12 + 1) - (void)v12 >= 0x24uLL)
    {
      int v1 = 0;
      if (!v5 || !v7) {
        goto LABEL_21;
      }
      if (*(unsigned __int16 *)(v5 + 4) == *(unsigned __int16 *)(v7 + 4))
      {
        int v8 = (int)bswap32(*(unsigned __int16 *)(v5 + 6)) >> 16;
        int v9 = (int)bswap32(*(unsigned __int16 *)(v7 + 6)) >> 16;
        if (v8 < 0) {
          int v8 = -v8;
        }
        if (v9 < 0) {
          int v9 = -v9;
        }
        int v1 = (unsigned __int16)v8 == (unsigned __int16)v9;
        goto LABEL_21;
      }
    }
    int v1 = 0;
LABEL_21:
    *((_DWORD *)this + 46) = v1;
    TDataReference::~TDataReference((TDataReference *)&v11);
    TDataReference::~TDataReference((TDataReference *)&v13);
  }
  return v1 != 0;
}

void sub_1B52E572C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  TDataReference::~TDataReference((TDataReference *)va);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'TSFNTData::~TSFNTData(TSFNTData *this)
{
}

{
  uint64_t vars8;

  TSFNTFont::~TSFNTFont((TSFNTData *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

void TSFNTData::~TSFNTData(TSFNTData *this)
{
  TSFNTFont::~TSFNTFont(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TSFNTData::GetKind(TSFNTData *this)
{
  return 2;
}

BOOL TSBITFont::IsSBITFont(TSBITFont *this, TSFNTFont *a2, const TSFNTFont *a3)
{
  void v11[4] = *MEMORY[0x1E4F143B8];
  if (this != 0x10000 && this != 1954115633 && this != 1953658213) {
    return 0;
  }
  int v9 = 3;
  int v10 = 3;
  int v8 = 3;
  char v7 = 0;
  uint64_t v4 = operator new(0x28uLL);
  *uint64_t v4 = &unk_1F0DFE030;
  v4[1] = &v10;
  void v4[2] = &v9;
  _OWORD v4[3] = &v8;
  v4[4] = &v7;
  int32x2_t v11[3] = v4;
  TSFNTFont::EnumerateTableTags(a2, (uint64_t)v11);
  std::__function::__value_func<void ()(unsigned int,BOOL *)>::~__value_func[abi:fe180100](v11);
  if (v7 || v10) {
    return 0;
  }
  return !v9 || v8 == 0;
}

void sub_1B52E58D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<void ()(unsigned int,BOOL *)>::~__value_func[abi:fe180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'TSBITFont::~TSBITFont(TSBITFont *this)
{
}

{
  uint64_t vars8;

  TSFNTFont::~TSFNTFont((TSBITFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

void TSBITFont::~TSBITFont(TSBITFont *this)
{
  TSFNTFont::~TSFNTFont(this);
  JUMPOUT(0x1BA9994D0);
}

void TSBITFont::GetHorizontalMetrics(TSBITFont *this, int *a2, int *a3, int *a4, int *a5, int *a6, int *a7, int *a8, int *a9, int *a10, BOOL *a11, BOOL *a12, double *a13, int *a14, int *a15, double *a16, double *a17, double *a18, double *a19, __int16 *a20,__int16 *a21)
{
  (*(void (**)(TSBITFont *, double *, double *, double *, double *))(*(void *)this + 280))(this, a16, a17, a18, a19);
  *a2 = *((__int16 *)this + 112);
  *a3 = *((__int16 *)this + 113);
  *a4 = *((__int16 *)this + 114);
  *a7 = *((__int16 *)this + 115);
  *a9 = 0;
  *a10 = 0;
  *a5 = 0;
  *a6 = 0;
  *a8 = (*(uint64_t (**)(TSBITFont *))(*(void *)this + 216))(this);
  *(void *)&long long v29 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v31[2] = v29;
  v31[3] = v29;
  v31[0] = v29;
  v31[1] = v29;
  TpostTable::TpostTable((TpostTable *)v31, this);
  if (*((void *)&v31[0] + 1) && *(void *)(*((void *)&v31[0] + 1) + 8))
  {
    *a14 = (int)bswap32(*(unsigned __int16 *)(TpostTable::GetPost((TpostTable *)v31) + 8)) >> 16;
    *a15 = bswap32(*(unsigned __int16 *)(TpostTable::GetPost((TpostTable *)v31) + 10)) >> 16;
    BOOL v30 = *(_DWORD *)(TpostTable::GetPost((TpostTable *)v31) + 12) != 0;
  }
  else
  {
    BOOL v30 = 0;
    *a14 = *a3 / 2;
    *a15 = 0;
  }
  *a11 = v30;
  *a13 = (*(double (**)(TSBITFont *))(*(void *)this + 288))(this);
  *a12 = (*(uint64_t (**)(TSBITFont *))(*(void *)this + 320))(this);
  *a20 = (int)*((double *)this + 27);
  *a21 = (int)*((double *)this + 26);
  TpostTable::~TpostTable((TpostTable *)v31);
}

void sub_1B52E5BA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TpostTable::~TpostTable((TpostTable *)va);
  _Unwind_Resume(a1);
}

uint64_t TSBITFont::GetAscent(TSBITFont *this)
{
  return *((__int16 *)this + 112);
}

uint64_t TSBITFont::GetDescent(TSBITFont *this)
{
  return *((__int16 *)this + 113);
}

uint64_t TSBITFont::GetLineGap(TSBITFont *this)
{
  return *((__int16 *)this + 114);
}

uint64_t TSBITFont::GetMaxAdvance(TSBITFont *this)
{
  return *((unsigned __int16 *)this + 115);
}

uint64_t TSBITFont::GetAvgAdvance(TSBITFont *this)
{
  int AvgAdvance = TSFNTFont::GetAvgAdvance(this);
  if (AvgAdvance)
  {
    double v3 = *((double *)this + 26);
    if (v3 > (double)AvgAdvance) {
      int AvgAdvance = (int)(v3 * (double)AvgAdvance);
    }
  }
  else
  {
    LOWORD(AvgAdvance) = *((_WORD *)this + 115);
  }
  return (__int16)AvgAdvance;
}

uint64_t TSBITFont::GetStemH(TSBITFont *this)
{
  return (int)*((double *)this + 27);
}

uint64_t TSBITFont::GetStemV(TSBITFont *this)
{
  return (int)*((double *)this + 26);
}

_WORD *TSBITFont::GetCaretInfo(_WORD *this, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  *a2 = this[116];
  *a3 = this[117];
  *a4 = this[118];
  return this;
}

void TSBITFont::GetBounds(TSBITFont *this, double *a2, double *a3, double *a4, double *a5)
{
  TSFNTFont::GetBounds(this, a2, a3, a4, a5);
  if (*a4 == 0.0 || *a5 == 0.0)
  {
    *a2 = 0.0;
    *a3 = (double)*((__int16 *)this + 113);
    *a4 = (double)*((__int16 *)this + 115);
    double v10 = (double)*((__int16 *)this + 112) - *a3;
LABEL_4:
    *a5 = v10;
    return;
  }
  if (*a5 < *((double *)this + 27))
  {
    *a2 = *((double *)this + 26) * *a2;
    *a3 = *((double *)this + 27) * *a3;
    *a4 = *((double *)this + 26) * *a4;
    double v10 = *((double *)this + 27) * *a5;
    goto LABEL_4;
  }
}

uint64_t TSBITFont::GetKind(TSBITFont *this)
{
  return 5;
}

void TOS2UnicodeRanges::~TOS2UnicodeRanges(TOS2UnicodeRanges *this)
{
}

uint64_t TOS2UnicodeRanges::GetRangeBit(TOS2UnicodeRanges *this, unsigned int a2)
{
  for (unint64_t i = *((unsigned int *)this + 6); i > 0xAA; unint64_t i = 0)
LABEL_8:
    *((_DWORD *)this + 6) = 0;
  uint64_t v3 = 3 * i;
  do
  {
    if (kUnicodeRanges[v3 + 1] <= a2 && kUnicodeRanges[v3 + 2] >= a2)
    {
      uint64_t v4 = kUnicodeRanges[v3];
      *((_DWORD *)this + 6) = v4;
      return v4;
    }
    v3 += 3;
  }
  while (v3 != 513);
  if (i) {
    goto LABEL_8;
  }
  return 0xFFFFFFFFLL;
}

uint64_t TOS2UnicodeRanges::SetRangeBit(TOS2UnicodeRanges *this, CFRange a2)
{
  CFIndex length = a2.length;
  int location = a2.location;
  uint64_t result = TOS2UnicodeRanges::GetRangeBit(this, a2.location);
  int v6 = result;
  if (result != -1) {
    *((_DWORD *)this + (result >> 5) + 2) |= 1 << result;
  }
  unsigned int v7 = result;
  if (length >= 2)
  {
    uint64_t result = TOS2UnicodeRanges::GetRangeBit(this, location + (int)length - 1);
    unsigned int v7 = result;
    if (result != -1) {
      *((_DWORD *)this + (result >> 5) + 2) |= 1 << result;
    }
  }
  unsigned int v8 = v6 + 1;
  if (v6 + 1 < v7 && v7 - v6 - 3 <= 0x7D)
  {
    do
    {
      uint64_t result = TOS2UnicodeRanges::GetRangeBit(this, v8);
      if (result != -1) {
        *((_DWORD *)this + (result >> 5) + 2) |= 1 << result;
      }
      ++v8;
    }
    while (v7 != v8);
  }
  return result;
}

void TwOFFStream::TwOFFStream(TwOFFStream *this, const TFileReference *a2)
{
  uint64_t v3 = this;
  TSFNTFont::TSFNTFont(this);
  v4[25] = a2;
  *uint64_t v4 = &unk_1F0DFDAC0;
  void v4[2] = &unk_1F0DFDCC8;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v54 = v5;
  long long v55 = v5;
  (*(void (**)(long long *__return_ptr, const TFileReference *, void, void))(*(void *)a2 + 32))(&v54, a2, 0, 0);
  if (!*((void *)&v54 + 1)) {
    goto LABEL_4;
  }
  uint64_t v6 = *(void *)(*((void *)&v54 + 1) + 8);
  if (!v6) {
    goto LABEL_4;
  }
  uint64_t v7 = v55;
  uint64_t v8 = v6 + v55;
  if (*(_WORD *)(v6 + v55 + 14)) {
    goto LABEL_4;
  }
  unsigned int v9 = *(unsigned __int16 *)(v8 + 12);
  if (!*(_WORD *)(v8 + 12)) {
    goto LABEL_4;
  }
  unsigned int v10 = __rev16(v9);
  unint64_t v45 = *((void *)&v55 + 1) - v55;
  if (*((void *)&v55 + 1) - (void)v55 <= 20 * (unint64_t)v10 + 44)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  unint64_t v11 = 16 * (v10 - 1) + 28;
  unint64_t capacity = bswap32(*(_DWORD *)(v8 + 16));
  if (v11 < capacity
    && (Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], capacity), (long long v13 = Mutable) != 0))
  {
    unsigned int v42 = (const __CFData **)v3;
    *(void *)&v52[2] = 0;
    uint64_t v53 = 0;
    uint64_t v44 = v8;
    *(_DWORD *)bytes = *(_DWORD *)(v8 + 4);
    __int16 v49 = v9;
    __int16 v14 = __clz(v10) ^ 0x1F;
    __int16 v50 = bswap32(16 * (1 << v14)) >> 16;
    __int16 v51 = v14 << 8;
    unsigned int v43 = v10;
    *(void *)int v52 = bswap32(16 * (v10 - (1 << v14))) >> 16;
    CFDataAppendBytes(Mutable, bytes, 12);
    CFDataSetLength(v13, capacity);
    int v15 = 0;
    BOOL v16 = (int *)(v7 + v6 + 60);
    int v47 = 12;
    do
    {
      unsigned int v18 = *(v16 - 2);
      unsigned int v17 = *(v16 - 1);
      int v19 = *(v16 - 4);
      int v20 = *v16;
      size_t v21 = v13;
      size_t v22 = bswap32(v17);
      uint64_t v23 = &CFDataGetMutableBytePtr(v13)[v47];
      *(_DWORD *)uint64_t v23 = v19;
      *((_DWORD *)v23 + 1) = v20;
      *((_DWORD *)v23 + 2) = bswap32(v11);
      *((_DWORD *)v23 + 3) = v17;
      unsigned int v24 = (v22 + 3) & 0xFFFFFFFC;
      if (v24 < v22)
      {
        CFRelease(v13);
        int v37 = __cxa_allocate_exception(0x10uLL);
        *(void *)int v37 = &unk_1F0DD4440;
        _OWORD v37[2] = 4;
      }
      size_t v25 = bswap32(v18);
      unsigned int v26 = bswap32(*(v16 - 3));
      BOOL v27 = __CFADD__(v26, v25);
      BOOL v29 = v45 < v26 + v25 || v27 || (int)v25 - 1 >= v22;
      unint64_t v30 = v11 + v24;
      if (v29 || v30 > capacity)
      {
        CFRelease(v21);
        uint64_t v36 = __cxa_allocate_exception(0x10uLL);
        *(void *)uint64_t v36 = &unk_1F0DD4440;
        v36[2] = 4;
      }
      MutableBytePtr = CFDataGetMutableBytePtr(v21);
      uint64_t v33 = (const uint8_t *)(v44 + v26);
      unint64_t v34 = &MutableBytePtr[v11 & 0xFFFFFFFC];
      if (v18 == v17)
      {
        if (__CFADD__(v11, v25) || (int)v11 + (int)v25 > capacity)
        {
          CFRelease(v21);
          unint64_t v39 = __cxa_allocate_exception(0x10uLL);
          *(void *)unint64_t v39 = &unk_1F0DD4440;
          uint64_t v39[2] = 4;
        }
        memcpy(v34, v33, v25);
      }
      else
      {
        if (v25 <= 1)
        {
          CFRelease(v21);
          BOOL v40 = __cxa_allocate_exception(0x10uLL);
          *(void *)BOOL v40 = &unk_1F0DD4440;
          v40[2] = 4;
        }
        if (compression_decode_buffer(v34, v22, v33 + 2, (v25 - 2), 0, COMPRESSION_ZLIB) != v22)
        {
          CFRelease(v21);
          uint64_t v38 = __cxa_allocate_exception(0x10uLL);
          *(void *)uint64_t v38 = &unk_1F0DD4440;
          v38[2] = 4;
        }
      }
      v16 += 5;
      v47 += 16;
      ++v15;
      unint64_t v11 = v30;
      long long v13 = v21;
    }
    while (v43 > (unsigned __int16)v15);
    TDataReference::~TDataReference((TDataReference *)&v54);
    uint64_t v3 = (TwOFFStream *)v42;
    v42[26] = v21;
    CFDataGetBytePtr(v21);
    CFDataRef v35 = v42[26];
    if (v35) {
      CFDataGetLength(v35);
    }
  }
  else
  {
LABEL_4:
    TDataReference::~TDataReference((TDataReference *)&v54);
    *((void *)v3 + 26) = 0;
  }
  *((void *)v3 + 27) = &unk_1F0DD4120;
  operator new();
}

void sub_1B52E647C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, TSFNTFont *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  TDataReference::~TDataReference((TDataReference *)&a19);
  TSFNTFont::~TSFNTFont(v19);
  _Unwind_Resume(a1);
}

void TwOFFStream::~TwOFFStream(TwOFFStream *this)
{
  *(void *)this = &unk_1F0DFDAC0;
  *((void *)this + 2) = &unk_1F0DFDCC8;
  uint64_t v2 = (const void *)*((void *)this + 26);
  if (v2) {
    CFRelease(v2);
  }
  TInMemoryDataReference::~TInMemoryDataReference((TwOFFStream *)((char *)this + 216));
  TSFNTFont::~TSFNTFont(this);
}

{
  uint64_t vars8;

  TwOFFStream::~TwOFFStream(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TwOFFStream::~TwOFFStream(TwOFFStream *this)
{
}

{
  uint64_t vars8;

  TwOFFStream::~TwOFFStream((TwOFFStream *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

uint64_t TwOFFStream::GetKind(TwOFFStream *this)
{
  return 6;
}

uint64_t TwOFFStream::GetFontRef(TwOFFStream *this)
{
  return (uint64_t)this + 216;
}

void WOFF2CFDataOut::~WOFF2CFDataOut(WOFF2CFDataOut *this)
{
  *(void *)this = &unk_1F0DFDCE8;
  int v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  uint64_t vars8;

  WOFF2CFDataOut::~WOFF2CFDataOut(this);
  JUMPOUT(0x1BA9994D0);
}

void TwOFF2Stream::TwOFF2Stream(TwOFF2Stream *this, const TFileReference *a2)
{
  (*(void (**)(uint64_t *__return_ptr, const TFileReference *, void, void))(*(void *)a2 + 32))(&v10, a2, 0, 0);
  __int16 v14 = &unk_1F0DFDCE8;
  CFMutableDataRef Mutable = (CFMutableDataRef)0xAAAAAAAAAAAAAAAALL;
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (Mutable)
  {
    if (v11 && (uint64_t v4 = *(void *)(v11 + 8)) != 0) {
      uint64_t v5 = v4 + v12;
    }
    else {
      uint64_t v5 = 0;
    }
    woff2::ConvertWOFF2ToTTF(v5, v13 - v12, (uint64_t)&v14);
    if (v6)
    {
      CFDataRef v7 = Mutable;
      CFMutableDataRef Mutable = 0;
      WOFF2CFDataOut::~WOFF2CFDataOut((WOFF2CFDataOut *)&v14);
      TSFNTFont::TSFNTFont(this);
      *((void *)this + 25) = a2;
      *((void *)this + 26) = v7;
      *(void *)this = &unk_1F0DFDAC0;
      *((void *)this + 2) = &unk_1F0DFDCC8;
      if (v7)
      {
        CFDataGetBytePtr(v7);
        CFDataGetLength(v7);
      }
      *((void *)this + 27) = &unk_1F0DD4120;
      operator new();
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  uint64_t v8 = __cxa_allocate_exception(0x10uLL);
  *(void *)uint64_t v8 = &unk_1F0DD4440;
  v8[2] = 2;
}

void sub_1B52E693C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

void non-virtual thunk to'TwOFF2Stream::~TwOFF2Stream(TwOFF2Stream *this)
{
}

{
  uint64_t vars8;

  TwOFFStream::~TwOFFStream((TwOFF2Stream *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

void TwOFF2Stream::~TwOFF2Stream(TwOFF2Stream *this)
{
  TwOFFStream::~TwOFFStream(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TwOFF2Stream::GetKind(TwOFF2Stream *this)
{
  return 7;
}

uint64_t WOFF2CFDataOut::Write(CFMutableDataRef *this, const UInt8 *a2, CFIndex a3)
{
  return 1;
}

uint64_t WOFF2CFDataOut::Write(CFMutableDataRef *this, UInt8 *newBytes, CFIndex range, CFIndex newLength)
{
  v7.int location = range;
  v7.CFIndex length = newLength;
  CFDataReplaceBytes(this[1], v7, newBytes, newLength);
  return 1;
}

CFIndex WOFF2CFDataOut::Size(CFDataRef *this)
{
  return CFDataGetLength(this[1]);
}

void std::__introsort<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *,false>(unint64_t a1, unsigned int *a2, uint64_t a3, char a4)
{
LABEL_1:
  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    uint64_t v11 = (uint64_t)a2 - v10;
    unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 4;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unsigned int v46 = *(_DWORD *)v10;
          if (*(a2 - 4) < *(_DWORD *)v10)
          {
            unsigned int v47 = *(_DWORD *)(v10 + 12);
            uint64_t v48 = *(void *)(v10 + 4);
            *(_OWORD *)unint64_t v10 = *((_OWORD *)a2 - 1);
            *(a2 - 4) = v46;
            *(void *)(a2 - 3) = v48;
            *(a2 - 1) = v47;
          }
          break;
        case 3uLL:
          std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>((unsigned int *)v10, (unsigned int *)(v10 + 16), a2 - 4);
          break;
        case 4uLL:
          std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>(v10, v10 + 16, v10 + 32, (uint64_t)(a2 - 4));
          break;
        case 5uLL:
          __int16 v49 = (_OWORD *)(v10 + 16);
          __int16 v50 = (_OWORD *)(v10 + 32);
          __int16 v51 = (_OWORD *)(v10 + 48);
          std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>(v10, v10 + 16, v10 + 32, v10 + 48);
          unsigned int v52 = *(_DWORD *)(v10 + 48);
          if (*(a2 - 4) < v52)
          {
            unsigned int v53 = *(_DWORD *)(v10 + 60);
            uint64_t v54 = *(void *)(v10 + 52);
            *__int16 v51 = *((_OWORD *)a2 - 1);
            *(a2 - 4) = v52;
            *(void *)(a2 - 3) = v54;
            *(a2 - 1) = v53;
            unsigned int v55 = *(_DWORD *)(v10 + 32);
            if (*(_DWORD *)(v10 + 48) < v55)
            {
              int v56 = *(_DWORD *)(v10 + 44);
              uint64_t v57 = *(void *)(v10 + 36);
              *__int16 v50 = *v51;
              *(_DWORD *)(v10 + 48) = v55;
              *(void *)(v10 + 52) = v57;
              *(_DWORD *)(v10 + 60) = v56;
              unsigned int v58 = *(_DWORD *)(v10 + 16);
              if (*(_DWORD *)(v10 + 32) < v58)
              {
                int v59 = *(_DWORD *)(v10 + 28);
                uint64_t v60 = *(void *)(v10 + 20);
                *__int16 v49 = *v50;
                *(_DWORD *)(v10 + 32) = v58;
                *(void *)(v10 + 36) = v60;
                *(_DWORD *)(v10 + 44) = v59;
                unsigned int v61 = *(_DWORD *)v10;
                if (*(_DWORD *)(v10 + 16) < *(_DWORD *)v10)
                {
                  int v62 = *(_DWORD *)(v10 + 12);
                  uint64_t v63 = *(void *)(v10 + 4);
                  *(_OWORD *)unint64_t v10 = *v49;
                  *(_DWORD *)(v10 + 16) = v61;
                  *(void *)(v10 + 20) = v63;
                  *(_DWORD *)(v10 + 28) = v62;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 383) {
      break;
    }
    if (!a3)
    {
      if ((unsigned int *)v10 == a2) {
        return;
      }
      int64_t v76 = (v12 - 2) >> 1;
      int64_t v77 = v76;
      do
      {
        int64_t v78 = v77;
        if (v76 >= v77)
        {
          uint64_t v79 = (2 * v77) | 1;
          unint64_t v80 = (unsigned int *)(v10 + 16 * v79);
          if (2 * v78 + 2 < (uint64_t)v12)
          {
            unsigned int v82 = *v80;
            unsigned int v81 = v80[4];
            if (*v80 <= v81) {
              unsigned int v82 = v80[4];
            }
            if (*v80 < v81)
            {
              v80 += 4;
              uint64_t v79 = 2 * v78 + 2;
            }
          }
          else
          {
            unsigned int v82 = *v80;
          }
          unint64_t v83 = v10 + 16 * v78;
          unsigned int v84 = *(_DWORD *)v83;
          if (v82 >= *(_DWORD *)v83)
          {
            uint64_t v85 = *(void *)(v83 + 4);
            unsigned int v86 = *(_DWORD *)(v83 + 12);
            do
            {
              long long v87 = v80;
              *(_OWORD *)unint64_t v83 = *(_OWORD *)v80;
              if (v76 < v79) {
                break;
              }
              uint64_t v88 = (2 * v79) | 1;
              unint64_t v80 = (unsigned int *)(v10 + 16 * v88);
              uint64_t v79 = 2 * v79 + 2;
              if (v79 < (uint64_t)v12)
              {
                unsigned int v90 = *v80;
                unsigned int v89 = v80[4];
                if (*v80 <= v89) {
                  unsigned int v90 = v80[4];
                }
                if (*v80 >= v89) {
                  uint64_t v79 = v88;
                }
                else {
                  v80 += 4;
                }
              }
              else
              {
                unsigned int v90 = *v80;
                uint64_t v79 = v88;
              }
              unint64_t v83 = (unint64_t)v87;
            }
            while (v90 >= v84);
            *long long v87 = v84;
            *(void *)(v87 + 1) = v85;
            v87[3] = v86;
          }
        }
        int64_t v77 = v78 - 1;
      }
      while (v78);
      uint64_t v91 = (unint64_t)v11 >> 4;
      while (2)
      {
        uint64_t v92 = 0;
        long long v93 = a2;
        unsigned int v95 = *(_DWORD *)v10;
        unsigned int v94 = *(_DWORD *)(v10 + 4);
        unsigned int v96 = *(_DWORD *)(v10 + 8);
        unsigned int v97 = *(_DWORD *)(v10 + 12);
        long long v98 = (_OWORD *)v10;
        do
        {
          long long v99 = (unsigned int *)&v98[v92 + 1];
          uint64_t v100 = (2 * v92) | 1;
          uint64_t v101 = 2 * v92 + 2;
          if (v101 < v91 && *v99 < v99[4])
          {
            v99 += 4;
            uint64_t v100 = v101;
          }
          *long long v98 = *(_OWORD *)v99;
          long long v98 = v99;
          uint64_t v92 = v100;
        }
        while (v100 <= (uint64_t)((unint64_t)(v91 - 2) >> 1));
        a2 -= 4;
        if (v99 == v93 - 4)
        {
LABEL_130:
          *long long v99 = v95;
          v99[1] = v94;
          v99[2] = v96;
          v99[3] = v97;
        }
        else
        {
          *(_OWORD *)long long v99 = *(_OWORD *)a2;
          *(v93 - 4) = v95;
          *(v93 - 3) = v94;
          *(v93 - 2) = v96;
          *(v93 - 1) = v97;
          uint64_t v102 = (uint64_t)v99 - v10 + 16;
          if (v102 >= 17)
          {
            unint64_t v103 = (((unint64_t)v102 >> 4) - 2) >> 1;
            long long v104 = (unsigned int *)(v10 + 16 * v103);
            unsigned int v95 = *v99;
            if (*v104 < *v99)
            {
              unsigned int v94 = v99[1];
              unsigned int v96 = v99[2];
              long long v105 = v99;
              unsigned int v97 = v99[3];
              do
              {
                long long v99 = v104;
                *(_OWORD *)long long v105 = *(_OWORD *)v104;
                if (!v103) {
                  break;
                }
                unint64_t v103 = (v103 - 1) >> 1;
                long long v104 = (unsigned int *)(v10 + 16 * v103);
                long long v105 = v99;
              }
              while (*v104 < v95);
              goto LABEL_130;
            }
          }
        }
        if (v91-- <= 2) {
          return;
        }
        continue;
      }
    }
    unint64_t v13 = v12 >> 1;
    __int16 v14 = (unsigned int *)(v10 + 16 * (v12 >> 1));
    if ((unint64_t)v11 >= 0x801)
    {
      std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>((unsigned int *)a1, (unsigned int *)(a1 + 16 * (v12 >> 1)), a2 - 4);
      std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>((unsigned int *)(a1 + 16), v14 - 4, a2 - 8);
      std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>((unsigned int *)(a1 + 32), (unsigned int *)(a1 + 16 + 16 * v13), a2 - 12);
      std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>(v14 - 4, v14, (unsigned int *)(a1 + 16 + 16 * v13));
      long long v15 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)v14;
      *(_OWORD *)__int16 v14 = v15;
    }
    else
    {
      std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>((unsigned int *)(a1 + 16 * (v12 >> 1)), (unsigned int *)a1, a2 - 4);
    }
    --a3;
    unsigned int v16 = *(_DWORD *)a1;
    if ((a4 & 1) != 0 || *(_DWORD *)(a1 - 16) < v16)
    {
      uint64_t v17 = 0;
      uint64_t v18 = *(void *)(a1 + 4);
      int v19 = *(_DWORD *)(a1 + 12);
      do
      {
        int v20 = (unsigned int *)(a1 + v17 + 16);
        if (v20 == a2) {
          goto LABEL_143;
        }
        unsigned int v21 = *v20;
        v17 += 16;
      }
      while (*v20 < v16);
      unint64_t v22 = a1 + v17;
      uint64_t v23 = a2;
      if (v17 != 16)
      {
        while (v23 != (unsigned int *)a1)
        {
          unsigned int v24 = *(v23 - 4);
          v23 -= 4;
          if (v24 < v16) {
            goto LABEL_21;
          }
        }
        goto LABEL_143;
      }
      uint64_t v23 = a2;
      do
      {
        if (v22 >= (unint64_t)v23) {
          break;
        }
        unsigned int v25 = *(v23 - 4);
        v23 -= 4;
      }
      while (v25 >= v16);
LABEL_21:
      if (v22 >= (unint64_t)v23)
      {
        unint64_t v10 = a1 + v17;
      }
      else
      {
        unint64_t v26 = (unint64_t)v23;
        unint64_t v10 = v22;
        do
        {
          int v27 = *(_DWORD *)(v10 + 12);
          uint64_t v28 = *(void *)(v10 + 4);
          *(_OWORD *)unint64_t v10 = *(_OWORD *)v26;
          *(_DWORD *)unint64_t v26 = v21;
          *(void *)(v26 + 4) = v28;
          *(_DWORD *)(v26 + 12) = v27;
          BOOL v29 = (unsigned int *)(v10 + 16);
          do
          {
            if (v29 == a2) {
              goto LABEL_143;
            }
            unsigned int v30 = *v29;
            v29 += 4;
            unsigned int v21 = v30;
          }
          while (v30 < v16);
          unint64_t v10 = (unint64_t)(v29 - 4);
          do
          {
            if (v26 == a1) {
              goto LABEL_143;
            }
            unsigned int v31 = *(_DWORD *)(v26 - 16);
            v26 -= 16;
          }
          while (v31 >= v16);
        }
        while (v10 < v26);
      }
      if (v10 - 16 != a1) {
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 16);
      }
      *(_DWORD *)(v10 - 16) = v16;
      *(void *)(v10 - 12) = v18;
      *(_DWORD *)(v10 - 4) = v19;
      if (v22 < (unint64_t)v23) {
        goto LABEL_37;
      }
      BOOL v32 = std::__insertion_sort_incomplete[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>(a1, v10 - 16);
      if (std::__insertion_sort_incomplete[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>(v10, (uint64_t)a2))
      {
        a2 = (unsigned int *)(v10 - 16);
        if (v32) {
          return;
        }
        goto LABEL_1;
      }
      if (!v32)
      {
LABEL_37:
        std::__introsort<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *,false>(a1, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v33 = *(void *)(a1 + 4);
      int v34 = *(_DWORD *)(a1 + 12);
      if (v16 >= *(a2 - 4))
      {
        unint64_t v37 = a1 + 16;
        do
        {
          unint64_t v10 = v37;
          if (v37 >= (unint64_t)a2) {
            break;
          }
          v37 += 16;
        }
        while (v16 >= *(_DWORD *)v10);
      }
      else
      {
        CFDataRef v35 = (unsigned int *)(a1 + 16);
        do
        {
          if (v35 == a2) {
            goto LABEL_143;
          }
          unsigned int v36 = *v35;
          v35 += 4;
        }
        while (v16 >= v36);
        unint64_t v10 = (unint64_t)(v35 - 4);
      }
      uint64_t v38 = a2;
      if (v10 < (unint64_t)a2)
      {
        uint64_t v38 = a2;
        while (v38 != (unsigned int *)a1)
        {
          unsigned int v39 = *(v38 - 4);
          v38 -= 4;
          if (v16 >= v39) {
            goto LABEL_50;
          }
        }
LABEL_143:
        __break(1u);
        JUMPOUT(0x1B52E7274);
      }
LABEL_50:
      if (v10 < (unint64_t)v38)
      {
        unsigned int v40 = *(_DWORD *)v10;
        do
        {
          unsigned int v41 = *(_DWORD *)(v10 + 12);
          uint64_t v42 = *(void *)(v10 + 4);
          *(_OWORD *)unint64_t v10 = *(_OWORD *)v38;
          *uint64_t v38 = v40;
          *(void *)(v38 + 1) = v42;
          v38[3] = v41;
          unsigned int v43 = (unsigned int *)(v10 + 16);
          do
          {
            if (v43 == a2) {
              goto LABEL_143;
            }
            unsigned int v44 = *v43;
            v43 += 4;
            unsigned int v40 = v44;
          }
          while (v16 >= v44);
          unint64_t v10 = (unint64_t)(v43 - 4);
          do
          {
            if (v38 == (unsigned int *)a1) {
              goto LABEL_143;
            }
            unsigned int v45 = *(v38 - 4);
            v38 -= 4;
          }
          while (v16 < v45);
        }
        while (v10 < (unint64_t)v38);
      }
      BOOL v4 = v10 - 16 >= a1;
      BOOL v5 = v10 - 16 == a1;
      if (v10 - 16 != a1) {
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 16);
      }
      a4 = 0;
      *(_DWORD *)(v10 - 16) = v16;
      *(void *)(v10 - 12) = v33;
      *(_DWORD *)(v10 - 4) = v34;
    }
  }
  long long v64 = (unsigned int *)(v10 + 16);
  BOOL v66 = (unsigned int *)v10 == a2 || v64 == a2;
  if (a4)
  {
    if (!v66)
    {
      uint64_t v67 = 0;
      unint64_t v68 = v10;
      do
      {
        unsigned int v69 = v64;
        unsigned int v70 = *v64;
        if (v70 < *(_DWORD *)v68)
        {
          uint64_t v71 = *(void *)(v68 + 20);
          int v72 = *(_DWORD *)(v68 + 28);
          uint64_t v73 = v67;
          while (1)
          {
            *(_OWORD *)(v10 + v73 + 16) = *(_OWORD *)(v10 + v73);
            if (!v73) {
              break;
            }
            unsigned int v74 = *(_DWORD *)(v10 + v73 - 16);
            v73 -= 16;
            if (v70 >= v74)
            {
              uint64_t v75 = v10 + v73 + 16;
              goto LABEL_93;
            }
          }
          uint64_t v75 = v10;
LABEL_93:
          *(_DWORD *)uint64_t v75 = v70;
          *(void *)(v75 + 4) = v71;
          *(_DWORD *)(v75 + 12) = v72;
        }
        long long v64 = v69 + 4;
        v67 += 16;
        unint64_t v68 = (unint64_t)v69;
      }
      while (v69 + 4 != a2);
    }
  }
  else if (!v66)
  {
    uint64_t v107 = -2;
    uint64_t v108 = 1;
    unint64_t v109 = v10;
    do
    {
      unsigned int v110 = *v64;
      if (*v64 < *(_DWORD *)v109)
      {
        uint64_t v111 = *(void *)(v109 + 20);
        unsigned int v112 = *(_DWORD *)(v109 + 28);
        uint64_t v113 = v107;
        uint64_t v114 = v64;
        do
        {
          *(_OWORD *)uint64_t v114 = *((_OWORD *)v114 - 1);
          BOOL v4 = __CFADD__(v113++, 1);
          if (v4) {
            goto LABEL_143;
          }
          int v115 = v114 - 4;
          unsigned int v116 = *(v114 - 8);
          v114 -= 4;
        }
        while (v110 < v116);
        *int v115 = v110;
        *(void *)(v115 + 1) = v111;
        v115[3] = v112;
      }
      unint64_t v109 = v10 + 16 * v108++;
      v64 += 4;
      --v107;
    }
    while (v64 != a2);
  }
}

unsigned int *std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>(unsigned int *result, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *result;
  unsigned int v5 = *a3;
  if (*a2 >= *result)
  {
    if (v5 < v3)
    {
      int v9 = a2[3];
      uint64_t v10 = *(void *)(a2 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *a3 = v3;
      *(void *)(a3 + 1) = v10;
      a3[3] = v9;
      unsigned int v11 = *result;
      if (*a2 < *result)
      {
        int v12 = result[3];
        uint64_t v13 = *(void *)(result + 1);
        *(_OWORD *)uint64_t result = *(_OWORD *)a2;
        *a2 = v11;
        *(void *)(a2 + 1) = v13;
        a2[3] = v12;
      }
    }
  }
  else
  {
    int v7 = result[1];
    int v6 = result[2];
    int v8 = result[3];
    if (v5 >= v3)
    {
      *(_OWORD *)uint64_t result = *(_OWORD *)a2;
      *a2 = v4;
      a2[1] = v7;
      a2[2] = v6;
      a2[3] = v8;
      if (*a3 >= v4) {
        return result;
      }
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      *(_OWORD *)uint64_t result = *(_OWORD *)a3;
    }
    *a3 = v4;
    a3[1] = v7;
    a3[2] = v6;
    a3[3] = v8;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(_DWORD *)a1;
      if (*(_DWORD *)(a2 - 16) < *(_DWORD *)a1)
      {
        int v7 = *(_DWORD *)(a1 + 12);
        uint64_t v8 = *(void *)(a1 + 4);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 16);
        *(_DWORD *)(a2 - 16) = v6;
        *(void *)(a2 - 12) = v8;
        *(_DWORD *)(a2 - 4) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>((unsigned int *)a1, (unsigned int *)(a1 + 16), (unsigned int *)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      int v19 = (_OWORD *)(a1 + 16);
      int v20 = (_OWORD *)(a1 + 32);
      unsigned int v21 = (_OWORD *)(a1 + 48);
      std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>(a1, a1 + 16, a1 + 32, a1 + 48);
      unsigned int v22 = *(_DWORD *)(a1 + 48);
      if (*(_DWORD *)(a2 - 16) < v22)
      {
        int v23 = *(_DWORD *)(a1 + 60);
        uint64_t v24 = *(void *)(a1 + 52);
        *unsigned int v21 = *(_OWORD *)(a2 - 16);
        *(_DWORD *)(a2 - 16) = v22;
        *(void *)(a2 - 12) = v24;
        *(_DWORD *)(a2 - 4) = v23;
        unsigned int v25 = *(_DWORD *)(a1 + 32);
        if (*(_DWORD *)(a1 + 48) < v25)
        {
          int v26 = *(_DWORD *)(a1 + 44);
          uint64_t v27 = *(void *)(a1 + 36);
          *int v20 = *v21;
          *(_DWORD *)(a1 + 48) = v25;
          *(void *)(a1 + 52) = v27;
          *(_DWORD *)(a1 + 60) = v26;
          unsigned int v28 = *(_DWORD *)(a1 + 16);
          if (*(_DWORD *)(a1 + 32) < v28)
          {
            int v29 = *(_DWORD *)(a1 + 28);
            uint64_t v30 = *(void *)(a1 + 20);
            *int v19 = *v20;
            *(_DWORD *)(a1 + 32) = v28;
            *(void *)(a1 + 36) = v30;
            *(_DWORD *)(a1 + 44) = v29;
            unsigned int v31 = *(_DWORD *)a1;
            if (*(_DWORD *)(a1 + 16) < *(_DWORD *)a1)
            {
              int v32 = *(_DWORD *)(a1 + 12);
              uint64_t v33 = *(void *)(a1 + 4);
              *(_OWORD *)a1 = *v19;
              *(_DWORD *)(a1 + 16) = v31;
              *(void *)(a1 + 20) = v33;
              *(_DWORD *)(a1 + 28) = v32;
            }
          }
        }
      }
      return 1;
    default:
      int v9 = (_DWORD *)(a1 + 32);
      std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>((unsigned int *)a1, (unsigned int *)(a1 + 16), (unsigned int *)(a1 + 32));
      uint64_t v10 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    unsigned int v13 = *(_DWORD *)v10;
    if (*(_DWORD *)v10 < *v9)
    {
      uint64_t v14 = *(void *)(v10 + 4);
      int v15 = *(_DWORD *)(v10 + 12);
      uint64_t v16 = v11;
      while (1)
      {
        *(_OWORD *)(a1 + v16 + 48) = *(_OWORD *)(a1 + v16 + 32);
        if (v16 == -32) {
          break;
        }
        unsigned int v17 = *(_DWORD *)(a1 + v16 + 16);
        v16 -= 16;
        if (v13 >= v17)
        {
          uint64_t v18 = a1 + v16 + 48;
          goto LABEL_13;
        }
      }
      uint64_t v18 = a1;
LABEL_13:
      *(_DWORD *)uint64_t v18 = v13;
      *(void *)(v18 + 4) = v14;
      *(_DWORD *)(v18 + 12) = v15;
      if (++v12 == 8) {
        return v10 + 16 == a2;
      }
    }
    int v9 = (_DWORD *)v10;
    v11 += 16;
    v10 += 16;
    if (v10 == a2) {
      return 1;
    }
  }
}

double std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,TSFNTFont::CopyData(void)::$_1 &,sfntDirectoryEntry *>((unsigned int *)a1, (unsigned int *)a2, (unsigned int *)a3);
  unsigned int v9 = *(_DWORD *)a3;
  if (*(_DWORD *)a4 < *(_DWORD *)a3)
  {
    int v10 = *(_DWORD *)(a3 + 12);
    double result = *(double *)(a3 + 4);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_DWORD *)a4 = v9;
    *(double *)(a4 + 4) = result;
    *(_DWORD *)(a4 + 12) = v10;
    unsigned int v11 = *(_DWORD *)a2;
    if (*(_DWORD *)a3 < *(_DWORD *)a2)
    {
      int v12 = *(_DWORD *)(a2 + 12);
      double result = *(double *)(a2 + 4);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_DWORD *)a3 = v11;
      *(double *)(a3 + 4) = result;
      *(_DWORD *)(a3 + 12) = v12;
      unsigned int v13 = *(_DWORD *)a1;
      if (*(_DWORD *)a2 < *(_DWORD *)a1)
      {
        int v14 = *(_DWORD *)(a1 + 12);
        double result = *(double *)(a1 + 4);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_DWORD *)a2 = v13;
        *(double *)(a2 + 4) = result;
        *(_DWORD *)(a2 + 12) = v14;
      }
    }
  }
  return result;
}

void *TInlineBufferAllocator<unsigned int,30ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 120);
  uint64_t v2 = (unint64_t *)(a1 + 120);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 4 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >> 62) {
      std::__throw_bad_array_new_length[abi:fe180100]();
    }
    return operator new(4 * a2);
  }
}

uint64_t std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 3) & 0xFFFFFFFFFFFFFFFCLL);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    unsigned int v6 = (void *)(v5 + 120);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *unsigned int v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:fe180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    uint64_t v3 = (void *)(a1 + 144);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 144)) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void *TInlineBufferAllocator<unsigned short,30ul>::allocate(uint64_t a1, uint64_t a2)
{
  double result = *(void **)(a1 + 64);
  unint64_t v4 = (unint64_t)result + 2 * a2;
  if (v4 <= a1 + 60)
  {
    *(void *)(a1 + 64) = v4;
  }
  else
  {
    if (a2 < 0) {
      std::__throw_bad_array_new_length[abi:fe180100]();
    }
    return operator new(2 * a2);
  }
  return result;
}

uint64_t std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 1) & 0xFFFFFFFFFFFFFFFELL);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    if (v5 <= (unint64_t)v4 && v5 + 60 > (unint64_t)v4)
    {
      if (*(void *)(a1 + 24) == *(void *)(v5 + 64)) {
        *(void *)(v5 + 64) = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = (void **)((char *)v1 + 84);
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[11]) {
        v1[11] = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void TSFNTFont::FillCharacterSet(__CFCharacterSet *,unsigned int)const::$_0::__invoke(int a1, CFArrayRef theArray, void *a3)
{
  v5.CFIndex length = CFArrayGetCount(theArray);
  v5.int location = 0;
  CFArrayApplyFunction(theArray, v5, (CFArrayApplierFunction)TSFNTFont::FillCharacterSet(__CFCharacterSet *,unsigned int)::$_0::operator() const(void const*,void const*,void *)::{lambda(void const*,void *)#1}::__invoke, a3);
}

uint64_t TSFNTFont::FillCharacterSet(__CFCharacterSet *,unsigned int)::$_0::operator() const(void const*,void const*,void *)::{lambda(void const*,void *)#1}::__invoke(const __CFString *a1, CFMutableCharacterSetRef *a2)
{
  CFStringRef v7 = a1;
  unsigned int v3 = TCFStr::FirstCharacter(&v7);
  if (*a2) {
    BOOL v4 = HIWORD(v3) > 0x10u;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    v8.int location = v3;
    v8.CFIndex length = 1;
    CFCharacterSetAddCharactersInRange(*a2, v8);
  }
  CFRange v5 = a2[1];
  uint64_t result = TOS2UnicodeRanges::GetRangeBit(v5, v3);
  if (result != -1) {
    *((_DWORD *)v5 + (result >> 5) + 2) |= 1 << result;
  }
  return result;
}

uint64_t TCFStr::FirstCharacter(CFStringRef *this)
{
  CFStringRef v2 = *this;
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)buffer = -1431655766;
  CFIndex Length = CFStringGetLength(v2);
  if (Length >= 2) {
    CFIndex v4 = 2;
  }
  else {
    CFIndex v4 = Length;
  }
  v8.int location = 0;
  v8.CFIndex length = v4;
  CFStringGetCharacters(*this, v8, buffer);
  uint64_t result = buffer[0];
  if (v4 != 1 && (buffer[0] & 0xFC00) == 55296)
  {
    if ((buffer[1] & 0xFC00) == 0xDC00) {
      return buffer[1] + (buffer[0] << 10) - 56613888;
    }
    else {
      return buffer[0];
    }
  }
  return result;
}

uint64_t TmaxpTable::GetNumGlyphs(TmaxpTable *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!v1
    || (uint64_t v2 = *(void *)(v1 + 8)) == 0
    || (uint64_t v3 = v2 + *((void *)this + 2), v3 + 6 > TsfntTable::GetTableEnd(this)))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  return bswap32(*(unsigned __int16 *)(v3 + 4)) >> 16;
}

uint64_t ThmtxTable::GetHhea(ThmtxTable *this)
{
  unint64_t TableEnd = TsfntTable::GetTableEnd(this);
  uint64_t v3 = *((void *)this + 1);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 8);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4 + *((void *)this + 2);
  if (TableEnd - v5 >= 0x24) {
    return v5;
  }
  else {
    return 0;
  }
}

uint64_t NormalizedAxisCoord(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = bswap32(*a1);
  uint64_t v4 = (signed int *)(a3 + 4);
  uint64_t v5 = 8 * a2;
  while (*(v4 - 1) != v3)
  {
    v4 += 2;
    v5 -= 8;
    if (!v5) {
      return 0;
    }
  }
  signed int v6 = *v4;
  signed int v7 = bswap32(a1[1]);
  signed int v8 = bswap32(a1[3]);
  if (v6 <= v7) {
    signed int v6 = v7;
  }
  if (v6 >= v8) {
    signed int v6 = v8;
  }
  signed int v9 = bswap32(a1[2]);
  if (v6 == v9 || v9 < v7 || v8 < v9) {
    return 0;
  }
  BOOL v12 = __OFSUB__(v6, v9);
  int v13 = v6 - v9;
  if (v13 < 0 == v12)
  {
    if (!((v13 < 0) ^ v12 | (v13 == 0)))
    {
      int v14 = v8 - v9;
      goto LABEL_21;
    }
    return 0;
  }
  int v14 = v9 - v7;
LABEL_21:
  uint64_t v15 = ((uint64_t)v13 << 16) / v14;
  if ((int)v15 >= 0x10000) {
    LODWORD(v15) = 0x10000;
  }
  if ((int)v15 <= -65536) {
    return 4294901760;
  }
  else {
    return v15;
  }
}

uint64_t ItemVariationStore::Initialize(void *a1, uint64_t a2, unint64_t a3)
{
  if (!a2) {
    return 1;
  }
  unint64_t v3 = a2 + 8;
  if (a2 + 8 > a3) {
    return 0;
  }
  uint64_t v4 = bswap32(*(unsigned __int16 *)(a2 + 6)) >> 16;
  unint64_t v5 = v3 + 4 * v4;
  if (v5 < v3 || v5 > a3)
  {
    unint64_t v7 = a2 + 12 <= a3 ? (a3 - v3) >> 2 : 0;
    if (v7 != v4) {
      return 0;
    }
  }
  uint64_t v8 = *(unsigned int *)(a2 + 2);
  if (v8)
  {
    signed int v9 = (unsigned __int16 *)(a2 + bswap32(v8));
    if ((unint64_t)(v9 + 2) <= a3)
    {
      uint64_t v10 = bswap32(v9[1]) >> 16;
      unint64_t v11 = (unint64_t)&v9[3 * (bswap32(*v9) >> 16) * v10 + 2];
      if (v11 >= (unint64_t)v9 && v11 <= a3)
      {
        *a1 = a2;
        a1[1] = a3;
        a1[2] = v10;
        a1[3] = v9;
        uint64_t v8 = 1;
        a1[4] = v4;
        a1[5] = v3;
        return v8;
      }
    }
    return 0;
  }
  return v8;
}

uint64_t DeltaSetIndexMap::IndexForValue(DeltaSetIndexMap *this, uint64_t a2, unint64_t a3)
{
  if (*(unsigned char *)this == 1)
  {
    unsigned int v3 = bswap32(*(_DWORD *)((char *)this + 2));
    uint64_t v4 = (char *)this + 6;
    if (!v3) {
      return a2;
    }
  }
  else
  {
    if (*(unsigned char *)this) {
      return a2;
    }
    unsigned int v3 = bswap32(*((unsigned __int16 *)this + 1)) >> 16;
    uint64_t v4 = (char *)this + 4;
    if (!v3) {
      return a2;
    }
  }
  unsigned int v5 = v3 - 1;
  if (v5 >= a2) {
    a2 = a2;
  }
  else {
    a2 = v5;
  }
  unint64_t v6 = *((unsigned __int8 *)this + 1);
  uint64_t v7 = ((v6 >> 4) & 3) + 1;
  uint64_t v8 = (unsigned __int8 *)&v4[v7 * (unint64_t)a2];
  if (&v8[v7] >= v8 && (unint64_t)&v8[v7] <= a3)
  {
    unsigned int v10 = 0;
    do
    {
      int v11 = *v8++;
      unsigned int v10 = v11 | (v10 << 8);
      --v7;
    }
    while (v7);
    return v10 & ((-1 << ((v6 & 0xF) + 1)) & 0xFFFE ^ 0xFFFF) | (v10 >> ((v6 & 0xF) + 1) << 16);
  }
  return a2;
}

void std::vector<std::pair<unsigned int,int>,TInlineBufferAllocator<std::pair<unsigned int,int>,30ul>>::__destroy_vector::operator()[abi:fe180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    unsigned int v3 = (void *)(a1 + 264);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 264)) {
        *unsigned int v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void *std::vector<double,TInlineBufferAllocator<double,30ul>>::vector(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[33] = a1 + 3;
  if (a2)
  {
    std::vector<double,TInlineBufferAllocator<double,30ul>>::__vallocate[abi:fe180100](a1, a2);
    unint64_t v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1B52E7DE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<double,TInlineBufferAllocator<double,30ul>>::__vallocate[abi:fe180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
  }
  uint64_t result = (char *)TInlineBufferAllocator<double,30ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * a2];
  return result;
}

void *TInlineBufferAllocator<double,30ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 240);
  uint64_t v2 = (unint64_t *)(a1 + 240);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 8 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:fe180100]();
    }
    return operator new(8 * a2);
  }
}

void std::vector<double,TInlineBufferAllocator<double,30ul>>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = v1 + 33;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[33]) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

double ItemVariationStore::VariationRegionList::ComputeScalar(ItemVariationStore::VariationRegionList *this, uint64_t a2, unint64_t a3, const __int16 *a4)
{
  unint64_t v4 = bswap32(*(unsigned __int16 *)this) >> 16;
  if (v4 >= a3) {
    unint64_t v5 = a3;
  }
  else {
    unint64_t v5 = v4;
  }
  if (!v5) {
    return 1.0;
  }
  uint64_t v7 = (ItemVariationStore::VariationRegionList *)((char *)this + 6 * v4 * a2 + 4);
  double v8 = 1.0;
  while (1)
  {
    int v9 = *a4++;
    double v10 = ItemVariationStore::RegionAxisCoordinates::ComputeScalar(v7, v9);
    if (v10 == 0.0) {
      break;
    }
    double v8 = v8 * v10;
    uint64_t v7 = (ItemVariationStore::RegionAxisCoordinates *)((char *)v7 + 6);
    if (!--v5) {
      return v8;
    }
  }
  return 0.0;
}

double ItemVariationStore::RegionAxisCoordinates::ComputeScalar(ItemVariationStore::RegionAxisCoordinates *this, int a2)
{
  int v2 = bswap32(*(unsigned __int16 *)this);
  unsigned int v3 = *((unsigned __int16 *)this + 1);
  int v4 = (int)bswap32(v3) >> 16;
  double result = 1.0;
  if (v4 >= v2 >> 16)
  {
    int v6 = (int)bswap32(*((unsigned __int16 *)this + 2)) >> 16;
    if (v6 >= v4)
    {
      int v7 = v2 >> 16;
      BOOL v8 = v6 > 0 && v7 < 0;
      if (!v8 && v3 != 0)
      {
        double result = 0.0;
        if (v7 <= a2 && v6 >= a2)
        {
          double result = 1.0;
          if (v4 != a2)
          {
            if (v4 <= a2)
            {
              double v11 = (double)(v6 - a2);
              int v12 = v6 - v4;
            }
            else
            {
              double v11 = (double)(a2 - v7);
              int v12 = v4 - v7;
            }
            return v11 / (double)v12;
          }
        }
      }
    }
  }
  return result;
}

double ItemVariationStore::ValueForDeltaSet(ItemVariationStore *this, unsigned int a2, unsigned int a3, unint64_t a4, const __int16 *a5, const double *a6)
{
  double v6 = 0.0;
  if ((a3 & a2) != 0xFFFF)
  {
    unint64_t v8 = *(void *)this;
    if (*(void *)this)
    {
      if (*((void *)this + 4) > (unint64_t)a2)
      {
        unsigned int v9 = *(_DWORD *)(*((void *)this + 5) + 4 * a2);
        if (v9)
        {
          uint64_t v10 = bswap32(v9);
          double v11 = (unsigned __int16 *)(v8 + v10);
          unint64_t v12 = *((void *)this + 1);
          int v13 = (unsigned __int16 *)(v8 + v10 + 6);
          if ((unint64_t)v13 <= v12)
          {
            unint64_t v14 = bswap32(v11[2]) >> 16;
            unsigned int v15 = bswap32(*v11) >> 16;
            int v16 = bswap32(v11[1]);
            unint64_t v17 = HIWORD(v16) & 0x7FFF;
            unint64_t v18 = (v17 + v14) << (v16 < 0);
            unint64_t v19 = (unint64_t)&v11[v14 + 3] + v18 * (unint64_t)v15;
            BOOL v20 = v19 < (unint64_t)v11 || v19 > v12;
            if (!v20)
            {
              if (v15 <= a3)
              {
                unsigned int v25 = 0;
                unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
                int v24 = 170;
                unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
                unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
              }
              else
              {
                int v24 = v16 >> 31;
                unsigned int v25 = (unsigned int *)((char *)&v13[v14] + v18 * (unint64_t)a3);
              }
              int v26 = (char *)v25 + v18;
              if ((unint64_t)v26 <= v12 && v8 <= (unint64_t)v25 && v26 >= (char *)v25)
              {
                if (v24)
                {
                  if (v17)
                  {
                    __int16 v50 = &v25[v17];
                    uint64_t v52 = v10;
                    unint64_t v27 = v17;
                    while (1)
                    {
                      unsigned int v28 = *v13++;
                      unint64_t v29 = bswap32(v28) >> 16;
                      if (*((void *)this + 2) <= v29) {
                        break;
                      }
                      if (a6) {
                        double v30 = a6[v29];
                      }
                      else {
                        double v30 = ItemVariationStore::VariationRegionList::ComputeScalar(*((ItemVariationStore::VariationRegionList **)this + 3), v29, a4, a5);
                      }
                      unsigned int v31 = *v25++;
                      double v6 = v6 + v30 * (double)(int)bswap32(v31);
                      if (!--v27)
                      {
                        unsigned int v25 = v50;
                        uint64_t v10 = v52;
                        goto LABEL_24;
                      }
                    }
                  }
                  else
                  {
LABEL_24:
                    BOOL v20 = v14 > v17;
                    unint64_t v32 = v14 - v17;
                    if (!v20) {
                      return v6;
                    }
                    uint64_t v33 = (unsigned __int16 *)(v10 + 2 * v17 + v8 + 6);
                    while (1)
                    {
                      unsigned int v34 = *v33++;
                      unint64_t v35 = bswap32(v34) >> 16;
                      if (*((void *)this + 2) <= v35) {
                        break;
                      }
                      if (a6) {
                        double v36 = a6[v35];
                      }
                      else {
                        double v36 = ItemVariationStore::VariationRegionList::ComputeScalar(*((ItemVariationStore::VariationRegionList **)this + 3), v35, a4, a5);
                      }
                      unsigned int v37 = *(unsigned __int16 *)v25;
                      unsigned int v25 = (unsigned int *)((char *)v25 + 2);
                      double v6 = v6 + v36 * (double)((int)bswap32(v37) >> 16);
                      if (!--v32) {
                        return v6;
                      }
                    }
                  }
                }
                else if (v17)
                {
                  __int16 v51 = (unsigned int *)((char *)v25 + 2 * v17);
                  uint64_t v53 = v10;
                  unint64_t v38 = v17;
                  while (1)
                  {
                    unsigned int v39 = *v13++;
                    unint64_t v40 = bswap32(v39) >> 16;
                    if (*((void *)this + 2) <= v40) {
                      break;
                    }
                    if (a6) {
                      double v41 = a6[v40];
                    }
                    else {
                      double v41 = ItemVariationStore::VariationRegionList::ComputeScalar(*((ItemVariationStore::VariationRegionList **)this + 3), v40, a4, a5);
                    }
                    unsigned int v42 = *(unsigned __int16 *)v25;
                    unsigned int v25 = (unsigned int *)((char *)v25 + 2);
                    double v6 = v6 + v41 * (double)((int)bswap32(v42) >> 16);
                    if (!--v38)
                    {
                      unsigned int v25 = v51;
                      uint64_t v10 = v53;
                      goto LABEL_41;
                    }
                  }
                }
                else
                {
LABEL_41:
                  BOOL v20 = v14 > v17;
                  unint64_t v43 = v14 - v17;
                  if (!v20) {
                    return v6;
                  }
                  unsigned int v44 = (unsigned __int16 *)(v10 + 2 * v17 + v8 + 6);
                  while (1)
                  {
                    unsigned int v45 = *v44++;
                    unint64_t v46 = bswap32(v45) >> 16;
                    if (*((void *)this + 2) <= v46) {
                      break;
                    }
                    if (a6) {
                      double v47 = a6[v46];
                    }
                    else {
                      double v47 = ItemVariationStore::VariationRegionList::ComputeScalar(*((ItemVariationStore::VariationRegionList **)this + 3), v46, a4, a5);
                    }
                    int v48 = *(char *)v25;
                    unsigned int v25 = (unsigned int *)((char *)v25 + 1);
                    double v6 = v6 + v47 * (double)v48;
                    if (!--v43) {
                      return v6;
                    }
                  }
                }
                return 0.0;
              }
            }
          }
        }
      }
    }
  }
  return v6;
}

void std::__throw_bad_function_call[abi:fe180100]()
{
  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1BA9994D0);
}

void std::__function::__func<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0,std::allocator<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0>,void ()(unsigned int,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0,std::allocator<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0>,void ()(unsigned int,BOOL *)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = &unk_1F0DFDFA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0,std::allocator<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0>,void ()(unsigned int,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F0DFDFA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__int32 *std::__function::__func<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0,std::allocator<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0>,void ()(unsigned int,BOOL *)>::operator()(uint64_t a1, __int32 *a2, BOOL **a3)
{
  int v4 = *a3;
  uint64_t v5 = *(void *)(a1 + 8);
  size_t v6 = *(void *)(v5 + 8);
  uint64_t v7 = *(void *)v5 + 4 * v6;
  __n128 result = wmemchr(*(__int32 **)v5, *a2, v6);
  if (result) {
    uint64_t v9 = (uint64_t)result;
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9 != **(void **)(a1 + 8) + 4 * *(void *)(*(void *)(a1 + 8) + 8))
  {
    uint64_t v10 = *(void **)(a1 + 16);
    BOOL v12 = (*v10)-- == 1;
    *int v4 = v12;
  }
  return result;
}

uint64_t std::__function::__func<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0,std::allocator<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0>,void ()(unsigned int,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0,std::allocator<TSFNTFont::HasTableTags(std::initializer_list<unsigned int>)::$_0>,void ()(unsigned int,BOOL *)>::target_type()
{
}

BOOL std::type_info::operator==[abi:fe180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

void *std::__function::__value_func<void ()(unsigned int,BOOL *)>::~__value_func[abi:fe180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0,std::allocator<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0>,void ()(unsigned int,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0,std::allocator<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0>,void ()(unsigned int,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F0DFE030;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0,std::allocator<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0>,void ()(unsigned int,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F0DFE030;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0,std::allocator<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0>,void ()(unsigned int,BOOL *)>::operator()(uint64_t result, int *a2, unsigned char **a3)
{
  int v3 = *a2;
  if (*a2 <= 1668112751)
  {
    if (v3 <= 1650745715)
    {
      if (v3 == 1161970772 || v3 == 1161972803)
      {
LABEL_29:
        size_t v6 = *(_DWORD **)(result + 24);
        goto LABEL_30;
      }
    }
    else if (v3 == 1650745716 || v3 == 1651008868 || v3 == 1651273571)
    {
      size_t v6 = *(_DWORD **)(result + 16);
LABEL_30:
      --*v6;
    }
  }
  else
  {
    if (v3 <= 1819239264)
    {
      if (v3 != 1668112752)
      {
        if (v3 != 1735162214)
        {
          if (v3 != 1751474532) {
            return result;
          }
          goto LABEL_29;
        }
LABEL_31:
        uint64_t v9 = *a3;
        **(unsigned char **)(result + 32) = 1;
        *uint64_t v9 = 1;
        return result;
      }
LABEL_23:
      size_t v6 = *(_DWORD **)(result + 8);
      goto LABEL_30;
    }
    if (v3 == 1819239265) {
      goto LABEL_31;
    }
    if (v3 == 1851878757 || v3 == 1835104368) {
      goto LABEL_23;
    }
  }
  return result;
}

uint64_t std::__function::__func<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0,std::allocator<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0>,void ()(unsigned int,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0,std::allocator<TSBITFont::IsSBITFont(unsigned int,TSFNTFont const&)::$_0>,void ()(unsigned int,BOOL *)>::target_type()
{
}

void TsfntTable::~TsfntTable(TsfntTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

void TheadTable::~TheadTable(TheadTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

void TnameTable::~TnameTable(TnameTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

unint64_t TnameTable::EnumerateNames(TsfntTable *a1, uint64_t a2)
{
  unint64_t result = TsfntTable::GetTableEnd(a1);
  uint64_t v5 = *((void *)a1 + 1);
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 + 8);
    if (v6)
    {
      unint64_t v7 = v6 + *((void *)a1 + 2);
      if (result != v7)
      {
        unint64_t result = TsfntTable::GetTableEnd(a1);
        if (v7 + 6 > result) {
          goto LABEL_19;
        }
        unsigned int v8 = *(unsigned __int16 *)(v7 + 4);
        unsigned int v9 = *(unsigned __int16 *)(v7 + 2);
        char v23 = 0;
        if (!v9) {
          return result;
        }
        unint64_t v10 = result;
        unint64_t v11 = v7 + 18;
        if (v7 + 6 < v7 || v11 > result)
        {
LABEL_19:
          exception = __cxa_allocate_exception(0x10uLL);
          *(void *)exception = &unk_1F0DD4440;
          exception[2] = 4;
        }
        int v13 = 0;
        unsigned int v14 = bswap32(v8) >> 16;
        unsigned int v15 = __rev16(v9);
        while (1)
        {
          unsigned int v16 = *(unsigned __int16 *)(v11 - 2);
          unsigned int v17 = *(unsigned __int16 *)(v11 - 4);
          unint64_t result = TsfntTable::GetTableEnd(a1);
          uint64_t v18 = *((void *)a1 + 1);
          if (v18)
          {
            uint64_t v18 = *(void *)(v18 + 8);
            if (v18) {
              v18 += *((void *)a1 + 2);
            }
          }
          unsigned int v19 = bswap32(v17);
          unsigned int v20 = v14 + (bswap32(v16) >> 16);
          if (result - v18 >= v20 + HIWORD(v19))
          {
            uint64_t v21 = *(void *)(a2 + 24);
            unsigned int v26 = v20;
            int v24 = &v23;
            uint64_t v25 = HIWORD(v19);
            if (!v21) {
              std::__throw_bad_function_call[abi:fe180100]();
            }
            unint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, unsigned int *, uint64_t *, char **))(*(void *)v21 + 48))(v21, v11 - 12, &v26, &v25, &v24);
            if (v23) {
              break;
            }
          }
          if (v15 <= (unsigned __int16)++v13) {
            break;
          }
          v11 += 12;
          if (v11 > v10) {
            goto LABEL_19;
          }
        }
      }
    }
  }
  return result;
}

uint64_t TFontNameString::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    TStringRef::operator=(a1, a2);
    *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
    *(void *)(a1 + 66) = *(void *)(a2 + 66);
    int v4 = *(const void **)(a1 + 80);
    if (v4) {
      CFRelease(v4);
    }
    CFTypeRef v5 = *(CFTypeRef *)(a2 + 80);
    if (v5) {
      CFTypeRef v5 = CFRetain(v5);
    }
    *(void *)(a1 + 80) = v5;
    uint64_t v6 = *(const void **)(a1 + 88);
    if (v6) {
      CFRelease(v6);
    }
    CFTypeRef v7 = *(CFTypeRef *)(a2 + 88);
    if (v7) {
      CFTypeRef v7 = CFRetain(v7);
    }
    *(void *)(a1 + 88) = v7;
  }
  return a1;
}

uint64_t TnameTable::FindPostscriptName(TnameTable *this, const unsigned __int16 *a2, uint64_t a3, const char *a4)
{
  void v11[4] = *MEMORY[0x1E4F143B8];
  CFTypeRef v7 = &a2[a3];
  unsigned int v10 = -1442797056;
  unsigned int v8 = operator new(0x30uLL);
  *unsigned int v8 = &unk_1F0DFE2F8;
  v8[1] = this;
  v8[2] = &v10;
  v8[3] = a2;
  v8[4] = v7;
  v8[5] = a4;
  int32x2_t v11[3] = v8;
  TnameTable::EnumerateNames(this, (uint64_t)v11);
  std::__function::__value_func<void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::~__value_func[abi:fe180100](v11);
  return v10;
}

void sub_1B52E8B24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::~__value_func[abi:fe180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t TnameTable::GetNames@<X0>(TnameTable *this@<X0>, const unsigned __int16 *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void v13[4] = *MEMORY[0x1E4F143B8];
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(void *)(a4 + 32) = 0xAAAAAAAA3F800000;
  std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__rehash<true>(a4, (unint64_t)(float)a3);
  memset(v10, 0, sizeof(v10));
  int v11 = 1065353216;
  int v12 = -1431655766;
  unsigned int v8 = operator new(0x30uLL);
  *unsigned int v8 = &unk_1F0DFE3F8;
  v8[1] = this;
  v8[2] = a4;
  v8[3] = v10;
  v8[4] = a2;
  v8[5] = &a2[a3];
  v13[3] = v8;
  TnameTable::EnumerateNames(this, (uint64_t)v13);
  std::__function::__value_func<void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::~__value_func[abi:fe180100](v13);
  std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__node_handle_merge_unique[abi:fe180100]<std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>>((void *)a4, v10);
  return std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::~__hash_table((uint64_t)v10);
}

void sub_1B52E8C40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  std::__function::__value_func<void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::~__value_func[abi:fe180100](&a14);
  std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::~__hash_table((uint64_t)&a9);
  std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::~__hash_table(v14);
  _Unwind_Resume(a1);
}

void TnameTable::GetSomeNames(TnameTable *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4 = 0;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  do
  {
    __int16 v5 = word_1B5393DF8[v4];
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v15 = v6;
    long long v16 = v6;
    long long v13 = v6;
    long long v14 = v6;
    long long v11 = v6;
    long long v12 = v6;
    TnameTable::FindName(this, v5, 0, 4, 0, (uint64_t)&v11);
    if (TFontNameString::IsValid((TFontNameString *)&v11))
    {
      unint64_t v7 = a2[1];
      if (v7 >= a2[2]) {
        goto LABEL_12;
      }
    }
    else
    {
      TFontNameString::~TFontNameString((TFontNameString *)&v11);
      *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v15 = v8;
      long long v16 = v8;
      long long v13 = v8;
      long long v14 = v8;
      long long v11 = v8;
      long long v12 = v8;
      TnameTable::FindName(this, v5, 0, 3, 0, (uint64_t)&v11);
      if (TFontNameString::IsValid((TFontNameString *)&v11))
      {
        unint64_t v7 = a2[1];
        if (v7 >= a2[2]) {
          goto LABEL_12;
        }
      }
      else
      {
        TFontNameString::~TFontNameString((TFontNameString *)&v11);
        *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v15 = v9;
        long long v16 = v9;
        long long v13 = v9;
        long long v14 = v9;
        long long v11 = v9;
        long long v12 = v9;
        TnameTable::GetName(this, v5, 0xFFFF, 0xFFFF, 0xFFFF, (uint64_t)&v11);
        if (!TFontNameString::IsValid((TFontNameString *)&v11)) {
          goto LABEL_14;
        }
        unint64_t v7 = a2[1];
        if (v7 >= a2[2])
        {
LABEL_12:
          uint64_t v10 = std::vector<TFontNameString>::__push_back_slow_path<TFontNameString const&>(a2, (const TFontNameString *)&v11);
          goto LABEL_13;
        }
      }
    }
    TFontNameString::TFontNameString((TFontNameString *)a2[1], (const TFontNameString *)&v11);
    uint64_t v10 = v7 + 96;
    a2[1] = v7 + 96;
LABEL_13:
    a2[1] = v10;
LABEL_14:
    TFontNameString::~TFontNameString((TFontNameString *)&v11);
    ++v4;
  }
  while (v4 != 3);
}

void sub_1B52E8E20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  *(void *)(v9 + 8) = v10;
  TFontNameString::~TFontNameString((TFontNameString *)&a9);
  a9 = v9;
  std::vector<TFontNameString>::__destroy_vector::operator()[abi:fe180100]((void ***)&a9);
  _Unwind_Resume(a1);
}

BOOL TFontNameString::IsValid(TFontNameString *this)
{
  unint64_t v1 = *((unsigned __int8 *)this + 64);
  if (*((void *)this + 2) < v1) {
    return 0;
  }
  uint64_t v2 = (unsigned __int16 *)*((void *)this + 1);
  if (!v2)
  {
    uint64_t v2 = (unsigned __int16 *)*((void *)this + 5);
    if (v2)
    {
      uint64_t v2 = (unsigned __int16 *)*((void *)v2 + 1);
      if (v2) {
        uint64_t v2 = (unsigned __int16 *)((char *)v2 + *((void *)this + 6));
      }
    }
  }
  if (v1 == 4)
  {
    int v3 = *(_DWORD *)v2;
    return v3 != 0;
  }
  if (v1 == 2)
  {
    int v3 = *v2;
    return v3 != 0;
  }
  if (v1 != 1) {
    return 0;
  }
  int v3 = *(unsigned __int8 *)v2;
  return v3 != 0;
}

void *TnameTable::GetAllNames@<X0>(TnameTable *this@<X0>, void *a2@<X8>)
{
  v3[4] = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3[0] = &unk_1F0DFE478;
  v3[1] = this;
  v3[2] = a2;
  v3[3] = v3;
  TnameTable::EnumerateNames(this, (uint64_t)v3);
  return std::__function::__value_func<void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::~__value_func[abi:fe180100](v3);
}

void sub_1B52E8F6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10)
{
}

unint64_t TcmapUnicodeTable::GetUnicodeSubtable(TcmapUnicodeTable *this, unsigned int *a2, unsigned int *a3)
{
  unint64_t CMapHeader = TcmapTable::GetCMapHeader(this);
  unint64_t TableEnd = TsfntTable::GetTableEnd(this);
  if (!CMapHeader) {
    return 0;
  }
  unint64_t v8 = TableEnd;
  unint64_t v9 = CMapHeader + 4;
  if (CMapHeader + 4 > TableEnd) {
    return 0;
  }
  uint64_t v10 = *a2;
  if (v10 == -1)
  {
    unsigned int v14 = *(unsigned __int16 *)(CMapHeader + 2);
    LODWORD(v15) = __rev16(v14);
    unint64_t v16 = CMapHeader + 12 * v15;
    if (v16 < CMapHeader || v16 > TableEnd)
    {
      if (CMapHeader + 12 > TableEnd) {
        LODWORD(v15) = 0;
      }
      else {
        unint64_t v15 = (TableEnd - CMapHeader) / 0xC;
      }
      unsigned int v14 = bswap32(v15) >> 16;
    }
    if (!v14) {
      return 0;
    }
    uint64_t v25 = a2;
    unsigned int v18 = 0;
    int v19 = (v15 & 0xFFFE) != 0 ? (unsigned __int16)v15 : 1;
    unsigned int v20 = (unsigned int *)(CMapHeader + 8);
    unsigned int v12 = -1;
    int v21 = 0x10000;
    do
    {
      int EncodingWeight = TcmapUnicodeTable::GetEncodingWeight((TcmapUnicodeTable *)(bswap32(*((unsigned __int16 *)v20 - 2)) >> 16), bswap32(*((unsigned __int16 *)v20 - 1)) >> 16);
      if (EncodingWeight == 10)
      {
        uint64_t v23 = bswap32(*v20);
        *a3 = v23;
        uint64_t v24 = CMapHeader + v23;
        *((void *)this + 9) = v24;
        if (v24 + 2 > v8)
        {
          *((void *)this + 9) = 0;
          *a3 = 0;
        }
      }
      else if (EncodingWeight < v21)
      {
        *((unsigned char *)this + 80) = EncodingWeight == 8;
        unsigned int v12 = v18;
        int v21 = EncodingWeight;
      }
      ++v18;
      v20 += 2;
    }
    while (v19 != v18);
    a2 = v25;
    if (v12 == -1) {
      return 0;
    }
    uint64_t v10 = v12;
  }
  else
  {
    uint64_t v11 = *a3;
    if (v11) {
      *((void *)this + 9) = CMapHeader + v11;
    }
    if (TcmapUnicodeTable::GetEncodingWeight((TcmapUnicodeTable *)(bswap32(*(unsigned __int16 *)(v9 + 8 * v10)) >> 16), bswap32(*(unsigned __int16 *)(v9 + 8 * v10 + 2)) >> 16) == 8)*((unsigned char *)this + 80) = 1; {
    unsigned int v12 = v10;
    }
  }
  *a2 = v12;
  unint64_t result = CMapHeader + bswap32(*(_DWORD *)(v9 + 8 * v10 + 4));
  if (result + 2 > v8) {
    return 0;
  }
  return result;
}

void TcmapUnicodeTable::~TcmapUnicodeTable(TcmapUnicodeTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TcmapUnicodeTable::GetEncodingWeight(TcmapUnicodeTable *this, unsigned int a2)
{
  if (this != 3)
  {
    if (!this && a2 < 7) {
      return *(unsigned int *)&asc_1B53945E8[4 * (__int16)a2];
    }
    return 0x10000;
  }
  if (a2 == 10) {
    return 0;
  }
  if (a2 != 1)
  {
    if (!a2) {
      return 8;
    }
    return 0x10000;
  }
  return 3;
}

void TcmapTableFileData16::~TcmapTableFileData16(TcmapTableFileData16 *this)
{
}

void TcmapTableFileData32::~TcmapTableFileData32(TcmapTableFileData32 *this)
{
}

uint64_t TcmapUnicodeTable::MapGlyphs<unsigned short>(uint64_t a1, uint64_t a2, _WORD *a3, unsigned int *a4)
{
  v97[0] = &unk_1F0DD6FA8;
  memset(&v97[1], 170, 24);
  unint64_t TableEnd = TsfntTable::GetTableEnd((TsfntTable *)a1);
  uint64_t v9 = *(void *)(a1 + 64);
  v97[0] = &unk_1F0DD6F78;
  v97[1] = TableEnd;
  v97[2] = v9;
  if (v9) {
    uint64_t v10 = v9 + 6;
  }
  else {
    uint64_t v10 = 0;
  }
  void v97[3] = v10;
  unint64_t v95 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v96 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v94 = &unk_1F0DD6FA8;
  unint64_t v11 = TsfntTable::GetTableEnd((TsfntTable *)a1);
  unsigned int v12 = *(unsigned __int16 **)(a1 + 64);
  unint64_t v13 = *(void *)(a1 + 72);
  unsigned int v94 = &unk_1F0DD7208;
  unint64_t v95 = v11;
  unint64_t v96 = v13;
  if (v12)
  {
    switch(bswap32(*v12) >> 16)
    {
      case 2u:
        long long v92 = (unint64_t)v97;
        uint64_t v91 = &unk_1F0DFE240;
        unint64_t v14 = (*(uint64_t (**)(void *, void, uint64_t))(v97[0] + 16))(v97, 0, 4);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v92, v14, 256);
        unsigned int v15 = *a4;
        LODWORD(v93) = v15;
        HIDWORD(v93) = v15;
        if (v15)
        {
          unint64_t v16 = 0;
          uint64_t v85 = a3;
          unsigned int v17 = a3;
          do
          {
            unsigned int v18 = *(unsigned __int16 *)(a2 + 2 * v16);
            unsigned int v19 = bswap32(*(unsigned __int16 *)(v14 + 2 * (v18 >> 8))) >> 16;
            if (v18 < 0x100 || v19 >= 8)
            {
              int v21 = (unsigned __int16 *)(v14 + 512 + ((unsigned __int16)v19 & 0xFFFE));
              TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v92, (unint64_t)v21, 4);
              unsigned int v22 = bswap32(*v21);
              if (v18 < HIWORD(v22)) {
                goto LABEL_17;
              }
              unsigned int v23 = HIWORD(v22);
              if (v23 + (bswap32(v21[1]) >> 16) <= v18) {
                goto LABEL_17;
              }
              unsigned __int16 v24 = v18 - (_WORD)v23;
              unsigned int v26 = v21[3];
              uint64_t v25 = v21 + 3;
              unsigned int v27 = bswap32(*(v25 - 1));
              unint64_t v28 = (unint64_t)v25 + ((bswap32(v26) >> 16) & 0xFFFE);
              TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v92, v28, 1);
              unint64_t v29 = (unsigned __int16 *)(v28 + 2 * v24);
              TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v92, (unint64_t)v29, 1);
              unsigned int v30 = (bswap32(*v29) >> 16) + HIWORD(v27);
              if ((_WORD)v30)
              {
                *v17++ = v30;
              }
              else
              {
LABEL_17:
                *v17++ = 0;
                --HIDWORD(v93);
                if ((int)v93 > (unsigned __int16)v16) {
                  LODWORD(v93) = (unsigned __int16)v16;
                }
              }
            }
            ++v16;
          }
          while (v16 < *a4);
          uint64_t result = v93;
          unsigned int v15 = HIDWORD(v93);
          a3 = v85;
        }
        else
        {
          uint64_t result = 0;
        }
        *a4 = v15;
        goto LABEL_136;
      case 4u:
        uint64_t v91 = v97;
        *(void *)&long long v92 = &v94;
        goto LABEL_136;
      case 6u:
        uint64_t v91 = v97;
        *(void *)&long long v92 = 0;
        goto LABEL_136;
      case 0xCu:
        long long v92 = *(_OWORD *)&v97[1];
        uint64_t v93 = v97[3];
        uint64_t v91 = &unk_1F0DD6F48;
        if (v97[3]) {
          uint64_t v93 = v97[3] + 6;
        }
        long long v87 = &v91;
        uint64_t v88 = &v94;
        DataP = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v91, 0);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v87, (unint64_t)DataP, 1);
        uint64_t v33 = DataP + 1;
        LODWORD(v34) = bswap32(*DataP);
        unint64_t v35 = (unint64_t)&DataP[3 * v34 + 1];
        BOOL v37 = v35 >= (unint64_t)(DataP + 1) && v35 <= (unint64_t)v92;
        if (v13)
        {
          if (!v37)
          {
            if ((unint64_t)(DataP + 4) > (unint64_t)v92) {
              LODWORD(v34) = 0;
            }
            else {
              unint64_t v34 = ((void)v92 - (void)v33) / 0xCuLL;
            }
          }
          unsigned int v38 = *a4;
          int v89 = v38;
          unsigned int v90 = v38;
          if (v38)
          {
            unsigned int v39 = 0;
            unint64_t v40 = (unint64_t)&v33[3 * v34];
            unsigned int v86 = a3;
            while (1)
            {
              uint64_t v41 = v39;
              unsigned int v42 = *(unsigned __int16 *)(a2 + 2 * v39++);
              if (v39 != v38
                && (v42 & 0xFC00) == 0xD800
                && (int v43 = *(unsigned __int16 *)(a2 + 2 * v39), (v43 & 0xFC00) == 0xDC00))
              {
                unsigned int v39 = v41 + 2;
                unsigned int v42 = (v42 << 10) - 56613888 + v43;
              }
              else
              {
                if (v42 >> 9 < 0x7F) {
                  goto LABEL_56;
                }
                if (v42 >> 4 < 0xFE1)
                {
                  BOOL v44 = 1;
                  if (!v41) {
                    goto LABEL_56;
                  }
                  goto LABEL_46;
                }
              }
              BOOL v44 = v42 - 917760 < 0xF0;
              if (!v41) {
                goto LABEL_56;
              }
LABEL_46:
              if (!v44)
              {
LABEL_56:
                {
                  int v50 = v89;
                  if (v89 >= (unsigned __int16)v41) {
                    int v50 = (unsigned __int16)v41;
                  }
                  int v89 = v50;
                  --v90;
                }
                goto LABEL_60;
              }
              uint64_t v45 = v41 - 1;
              int v46 = *(unsigned __int16 *)(a2 + 2 * (v41 - 1));
              if (v41 >= 2 && (v46 & 0xFC00) == 0xDC00)
              {
                int v47 = *(unsigned __int16 *)(a2 + 2 * (v41 - 2));
                BOOL v48 = (v47 & 0xFC00) == 55296;
                int v49 = v46 - 56613888 + (v47 << 10);
                if (v48) {
                  uint64_t v45 = v41 - 2;
                }
                if (v48) {
                  int v46 = v49;
                }
              }
              *a3 = (__int16)((unsigned __int16)TFormat14UVSTable::Map<unsigned short>((uint64_t)v88[2], (unint64_t)v88[1], v46, v42, &a3[v45 - v41]) << 15) >> 15;
LABEL_60:
              if (v42 >= 0x10000)
              {
                a3[1] = 0;
                a3 += 2;
              }
              else
              {
                ++a3;
              }
              unsigned int v38 = *a4;
              if (v39 >= *a4) {
                goto LABEL_131;
              }
            }
          }
        }
        else
        {
          if (!v37)
          {
            if ((unint64_t)(DataP + 4) > (unint64_t)v92) {
              LODWORD(v34) = 0;
            }
            else {
              unint64_t v34 = ((void)v92 - (void)v33) / 0xCuLL;
            }
          }
          unsigned int v74 = *a4;
          int v89 = v74;
          unsigned int v90 = v74;
          if (v74)
          {
            unsigned int v75 = 0;
            unint64_t v76 = (unint64_t)&v33[3 * v34];
            unsigned int v86 = a3;
            do
            {
              unsigned int v77 = v75 + 1;
              unsigned int v78 = *(unsigned __int16 *)(a2 + 2 * v75);
              if (v75 + 1 != v74 && (v78 & 0xFC00) == 0xD800)
              {
                int v79 = *(unsigned __int16 *)(a2 + 2 * v77);
                BOOL v80 = (v79 & 0xFC00) == 56320;
                unsigned int v81 = (v78 << 10) - 56613888 + v79;
                unsigned int v77 = v80 ? v75 + 2 : v75 + 1;
                if (v80) {
                  unsigned int v78 = v81;
                }
              }
              {
                int v82 = v89;
                if (v89 >= (unsigned __int16)v75) {
                  int v82 = (unsigned __int16)v75;
                }
                int v89 = v82;
                --v90;
              }
              if (v78 >= 0x10000)
              {
                a3[1] = 0;
                a3 += 2;
              }
              else
              {
                ++a3;
              }
              unsigned int v74 = *a4;
              unsigned int v75 = v77;
            }
            while (v77 < *a4);
LABEL_131:
            unsigned int v83 = v90;
            a3 = v86;
            goto LABEL_135;
          }
        }
        unsigned int v83 = 0;
LABEL_135:
        *a4 = v83;
        uint64_t result = v89;
LABEL_136:
        if (result == -1) {
          goto LABEL_137;
        }
        return result;
      case 0xDu:
        long long v92 = *(_OWORD *)&v97[1];
        uint64_t v93 = v97[3];
        uint64_t v91 = &unk_1F0DD6F48;
        if (v97[3]) {
          uint64_t v93 = v97[3] + 6;
        }
        long long v87 = &v91;
        uint64_t v88 = 0;
        __int16 v51 = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v91, 0);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v87, (unint64_t)v51, 1);
        uint64_t v52 = v51 + 1;
        LODWORD(v53) = bswap32(*v51);
        unint64_t v54 = (unint64_t)&v51[3 * v53 + 1];
        if (v54 < (unint64_t)(v51 + 1) || v54 > (unint64_t)v92)
        {
          if ((unint64_t)(v51 + 4) > (unint64_t)v92) {
            LODWORD(v53) = 0;
          }
          else {
            unint64_t v53 = ((void)v92 - (void)v52) / 0xCuLL;
          }
        }
        unint64_t v55 = *a4;
        if (!v55)
        {
          uint64_t result = 0;
          unsigned int v57 = 0;
          goto LABEL_133;
        }
        unint64_t v56 = 0;
        uint64_t result = *a4;
        unsigned int v57 = *a4;
        unsigned int v58 = a3;
        break;
      default:
        goto LABEL_137;
    }
    while (1)
    {
      unint64_t v59 = v56 + 1;
      unsigned int v60 = *(unsigned __int16 *)(a2 + 2 * v56);
      if ((v60 & 0xFC00) == 0xD800 && v59 != v55)
      {
        int v62 = *(unsigned __int16 *)(a2 + 2 * v59);
        BOOL v63 = (v62 & 0xFC00) == 56320;
        unsigned int v64 = (v60 << 10) - 56613888 + v62;
        unint64_t v59 = (v62 & 0xFC00) == 0xDC00 ? v56 + 2 : v56 + 1;
        if (v63) {
          unsigned int v60 = v64;
        }
      }
      if (!v53) {
        goto LABEL_95;
      }
      unint64_t v65 = v53;
      BOOL v66 = v51 + 1;
      do
      {
        unint64_t v67 = v65 >> 1;
        unint64_t v68 = &v66[3 * (v65 >> 1)];
        unsigned int v70 = *v68;
        unsigned int v69 = v68 + 3;
        v65 += ~(v65 >> 1);
        if (bswap32(v70) > v60) {
          unint64_t v65 = v67;
        }
        else {
          BOOL v66 = v69;
        }
      }
      while (v65);
      uint64_t v71 = (uint64_t)(v66 == v52 ? v51 + 1 : v66 - 3);
      if (((unsigned int *)v71 != v52 || bswap32(*v52) <= v60) && bswap32(*(_DWORD *)(v71 + 4)) >= v60)
      {
        unsigned int v72 = bswap32(*(_DWORD *)(v71 + 8));
        BOOL v73 = v72 >= 0xFFFF;
        if (v72 >= 0xFFFF) {
          LOWORD(v72) = 0;
        }
        *unsigned int v58 = v72;
        if (!v73) {
          goto LABEL_99;
        }
      }
      else
      {
LABEL_95:
        *unsigned int v58 = 0;
      }
      --v57;
      if ((int)result >= (unsigned __int16)v56) {
        uint64_t result = (unsigned __int16)v56;
      }
      else {
        uint64_t result = result;
      }
LABEL_99:
      if (v60 >= 0x10000)
      {
        v58[1] = 0;
        v58 += 2;
      }
      else
      {
        ++v58;
      }
      unint64_t v56 = v59;
      if (v59 >= v55)
      {
LABEL_133:
        *a4 = v57;
        goto LABEL_136;
      }
    }
  }
LABEL_137:
  uint64_t v84 = *a4;
  if (v84) {
    bzero(a3, 2 * v84);
  }
  *a4 = 0;
  return 0xFFFFFFFFLL;
}

uint64_t TcmapUnicodeTable::MapGlyphs<unsigned int>(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int *a4)
{
  v197[0] = &unk_1F0DD6FA8;
  memset(&v197[1], 170, 24);
  unint64_t TableEnd = TsfntTable::GetTableEnd((TsfntTable *)a1);
  uint64_t v9 = *(void *)(a1 + 64);
  v197[0] = &unk_1F0DD6F78;
  v197[1] = TableEnd;
  v197[2] = v9;
  if (v9) {
    uint64_t v10 = v9 + 6;
  }
  else {
    uint64_t v10 = 0;
  }
  v197[3] = v10;
  unint64_t v195 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v196 = 0xAAAAAAAAAAAAAAAALL;
  v194 = &unk_1F0DD6FA8;
  unint64_t v11 = TsfntTable::GetTableEnd((TsfntTable *)a1);
  unsigned int v12 = *(unsigned __int16 **)(a1 + 64);
  unint64_t v13 = *(void *)(a1 + 72);
  v194 = &unk_1F0DD7208;
  unint64_t v195 = v11;
  unint64_t v196 = v13;
  if (v12)
  {
    switch(bswap32(*v12) >> 16)
    {
      case 2u:
        long long v192 = (unint64_t)v197;
        v191 = &unk_1F0DFE240;
        unint64_t v14 = (*(uint64_t (**)(void *, void, uint64_t))(v197[0] + 16))(v197, 0, 4);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v192, v14, 256);
        unsigned int v15 = *a4;
        LODWORD(v193) = v15;
        HIDWORD(v193) = v15;
        if (v15)
        {
          unint64_t v16 = 0;
          unint64_t v17 = v14 + 512;
          unsigned int v18 = a3;
          uint64_t v186 = a2;
          do
          {
            unsigned int v19 = *(unsigned __int16 *)(a2 + 2 * v16);
            unsigned int v20 = bswap32(*(unsigned __int16 *)(v14 + 2 * (v19 >> 8))) >> 16;
            if (v19 < 0x100 || v20 >= 8)
            {
              unsigned int v22 = (unsigned __int16 *)(v17 + ((unsigned __int16)v20 & 0xFFFE));
              TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v192, (unint64_t)v22, 4);
              unsigned int v23 = bswap32(*v22);
              if (v19 < HIWORD(v23)) {
                goto LABEL_17;
              }
              unsigned int v24 = HIWORD(v23);
              if (v24 + (bswap32(v22[1]) >> 16) <= v19) {
                goto LABEL_17;
              }
              unsigned __int16 v25 = v19 - (_WORD)v24;
              unsigned int v27 = v22[3];
              unsigned int v26 = v22 + 3;
              unint64_t v28 = v17;
              unint64_t v29 = a4;
              unsigned int v30 = a3;
              unsigned int v31 = bswap32(*(v26 - 1));
              unint64_t v32 = (unint64_t)v26 + ((bswap32(v27) >> 16) & 0xFFFE);
              TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v192, v32, 1);
              uint64_t v33 = (unsigned __int16 *)(v32 + 2 * v25);
              TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v192, (unint64_t)v33, 1);
              unsigned int v34 = (bswap32(*v33) >> 16) + HIWORD(v31);
              a3 = v30;
              a4 = v29;
              unint64_t v17 = v28;
              a2 = v186;
              if ((_WORD)v34)
              {
                *v18++ = (unsigned __int16)v34;
              }
              else
              {
LABEL_17:
                *v18++ = 0;
                --HIDWORD(v193);
                if ((int)v193 > (unsigned __int16)v16) {
                  LODWORD(v193) = (unsigned __int16)v16;
                }
              }
            }
            ++v16;
          }
          while (v16 < *a4);
          uint64_t v35 = v193;
          unsigned int v15 = HIDWORD(v193);
        }
        else
        {
          uint64_t v35 = 0;
        }
        goto LABEL_159;
      case 4u:
        v191 = v197;
        *(void *)&long long v192 = &v194;
        int v36 = *(unsigned __int8 *)(a1 + 80);
        uint64_t v35 = *a4;
        DWORD2(v192) = v35;
        HIDWORD(v192) = v35;
        if (v13)
        {
          if (v35)
          {
            BOOL v37 = (unsigned __int16 *)(*(uint64_t (**)(void *, void, uint64_t))(v197[0] + 16))(v197, 0, 4);
            TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v191, (unint64_t)v37, 1);
            uint64_t v38 = bswap32(*v37) >> 16;
            if ((v38 & 1) == 0)
            {
              unint64_t v39 = v197[1];
              unint64_t v40 = v37 + 4;
              if (v38 < 0x10)
              {
                unsigned int v43 = 0;
                unsigned int v183 = 0;
                LODWORD(v42) = 0;
                goto LABEL_168;
              }
              unsigned int v41 = __clz(v38);
              uint64_t v42 = (1 << (v41 ^ 0x1F));
              if ((unint64_t)v40 + v42 + 2 <= v197[1])
              {
                unsigned int v43 = 30 - v41;
                unsigned int v183 = bswap32(*(unsigned __int16 *)((char *)v40 + v42)) >> 16;
                BOOL v37 = (unsigned __int16 *)((char *)v40 + (v38 - v42));
LABEL_168:
                unint64_t v117 = *a4;
                unsigned int v103 = v35;
                if (!v117) {
                  goto LABEL_133;
                }
                unint64_t v118 = 0;
                uint64_t v119 = v38 >> 1;
                uint64_t v120 = (unsigned __int16)v38 & 0xFFFE;
                int v121 = a3;
                int v178 = v42;
                uint64_t v179 = v120;
                uint64_t v182 = v42;
                v185 = a3;
                unsigned int v181 = v43;
                uint64_t v180 = v119;
                while (1)
                {
                  unint64_t v122 = v118 + 1;
                  unsigned int v123 = *(unsigned __int16 *)(a2 + 2 * v118);
                  if (v118 + 1 != v117 && (v123 & 0xFC00) == 0xD800)
                  {
                    int v124 = *(unsigned __int16 *)(a2 + 2 * v122);
                    if ((v124 & 0xFC00) == 0xDC00) {
                      break;
                    }
                  }
                  if (v123 >> 9 < 0x7F) {
                    goto LABEL_186;
                  }
                  if (v123 >> 4 >= 0xFE1)
                  {
                    unsigned int v125 = *(unsigned __int16 *)(a2 + 2 * v118);
LABEL_179:
                    BOOL v126 = v125 - 917760 < 0xF0;
                    if (!v118) {
                      goto LABEL_186;
                    }
                    goto LABEL_180;
                  }
                  BOOL v126 = 1;
                  unsigned int v125 = *(unsigned __int16 *)(a2 + 2 * v118);
                  if (!v118) {
                    goto LABEL_186;
                  }
LABEL_180:
                  if (v126)
                  {
                    uint64_t v127 = v40;
                    uint64_t v128 = v38;
                    if (TFormat14UVSTable::Map<unsigned int>(*(void *)(v192 + 16), *(void *)(v192 + 8), *(unsigned __int16 *)(a2 + 2 * v118 - 2), v125, v121 - 1))int v129 = 0xFFFFFF; {
                    else
                    }
                      int v129 = 0;
                    *int v121 = v129;
                    if (v125 >= 0x10000)
                    {
                      v121[1] = 0;
                      v121 += 2;
                      unint64_t v122 = v118 + 2;
                    }
                    else
                    {
                      ++v121;
                    }
                    uint64_t v38 = v128;
                    unint64_t v40 = v127;
                    a3 = v185;
                    unsigned int v43 = v181;
                    uint64_t v120 = v179;
                    uint64_t v119 = v180;
                    goto LABEL_223;
                  }
LABEL_186:
                  int v130 = v40;
                  if (v38 >= 0x10)
                  {
                    if (v123 >= v183) {
                      int v130 = v37;
                    }
                    else {
                      int v130 = v40;
                    }
                    if ((unint64_t)v130 + v182 > v39) {
                      goto LABEL_131;
                    }
                    if (v43 >= 4)
                    {
                      unsigned int v131 = v43;
                      LODWORD(v132) = v178;
                      do
                      {
                        unint64_t v133 = v132;
                        unint64_t v132 = (unint64_t)v132 >> 1;
                        int v134 = (unsigned __int16 *)((char *)v130 + (v133 >> 1));
                        if (v123 > bswap32(*v134) >> 16) {
                          int v130 = v134;
                        }
                        --v131;
                      }
                      while (v131 > 3);
                    }
                  }
                  if ((unint64_t)(v130 + 1) <= v39)
                  {
                    do
                    {
                      int v135 = v130 + 1;
                      unsigned int v137 = *v130;
                      signed int v136 = v130 + 2;
                      BOOL v138 = v123 <= bswap32(v137) >> 16 || (unint64_t)v136 > v39;
                      int v130 = v135;
                    }
                    while (!v138);
                    int v130 = v135;
                  }
                  long long v139 = &v130[v119];
                  if ((unint64_t)&v139[v120 + 1] > v39 || (unsigned int v140 = bswap32(*v139), v123 < HIWORD(v140)))
                  {
LABEL_220:
                    *v121++ = 0;
                    unsigned int v148 = DWORD2(v192);
                    if (SDWORD2(v192) >= (unsigned __int16)v118) {
                      unsigned int v148 = (unsigned __int16)v118;
                    }
                    *((void *)&v192 + 1) = __PAIR64__(HIDWORD(v192), v148) - 0x100000000;
                    goto LABEL_223;
                  }
                  long long v141 = &v139[v119];
                  unsigned int v142 = bswap32(*v141) >> 16;
                  int v143 = &v141[v119];
                  if (*v143)
                  {
                    int v144 = (unsigned __int16 *)((char *)&v143[(unsigned __int16)(v123 - HIWORD(v140))] + __rev16(*v143));
                    if (v144 <= v40 || (unint64_t)(v144 + 1) > v39) {
                      goto LABEL_220;
                    }
                    unsigned int v146 = *v144;
                    BOOL v71 = v146 == 0;
                    unsigned int v123 = (unsigned __int16)(v142 + (bswap32(v146) >> 16));
                    if (v71 || v123 == 0) {
                      goto LABEL_220;
                    }
                  }
                  else
                  {
                    LOWORD(v123) = v142 + v123;
                    if (!(_WORD)v123) {
                      goto LABEL_220;
                    }
                    unsigned int v123 = (unsigned __int16)v123;
                  }
                  *v121++ = v123;
LABEL_223:
                  unint64_t v117 = *a4;
                  unint64_t v118 = v122;
                  if (v122 >= v117)
                  {
                    uint64_t v35 = DWORD2(v192);
                    unsigned int v103 = HIDWORD(v192);
                    goto LABEL_133;
                  }
                }
                unsigned int v125 = (v123 << 10) - 56613888 + v124;
                goto LABEL_179;
              }
              goto LABEL_131;
            }
LABEL_274:
            exception = __cxa_allocate_exception(0x10uLL);
            *(void *)exception = &unk_1F0DD4440;
            exception[2] = 4;
          }
LABEL_132:
          unsigned int v103 = 0;
          goto LABEL_133;
        }
        if (!v35) {
          goto LABEL_132;
        }
        unsigned int v97 = (unsigned __int16 *)(*(uint64_t (**)(void *, void, uint64_t))(v197[0] + 16))(v197, 0, 4);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v191, (unint64_t)v97, 1);
        unsigned int v98 = bswap32(*v97) >> 16;
        if (v98) {
          goto LABEL_274;
        }
        unint64_t v99 = v197[1];
        uint64_t v100 = v97 + 4;
        if (v98 < 0x10)
        {
          LODWORD(v102) = 0;
          unsigned int v149 = 0;
          unsigned int v150 = 0;
        }
        else
        {
          unsigned int v101 = __clz(v98);
          uint64_t v102 = (1 << (v101 ^ 0x1F));
          if ((unint64_t)v100 + v102 + 2 > v197[1])
          {
LABEL_131:
            uint64_t v35 = 0;
            goto LABEL_132;
          }
          unsigned int v149 = 30 - v101;
          unsigned int v150 = bswap32(*(unsigned __int16 *)((char *)v100 + v102)) >> 16;
          unsigned int v97 = (unsigned __int16 *)((char *)v100 + v98 - v102);
        }
        if (*a4)
        {
          unint64_t v151 = 0;
          uint64_t v152 = v98 >> 1;
          int v153 = v35;
          unsigned int v103 = v35;
          int v154 = a3;
          do
          {
            unsigned __int16 v155 = *(_WORD *)(a2 + 2 * v151);
            do
            {
              uint64_t v156 = v100;
              if (v98 >= 0x10)
              {
                if (v150 <= v155) {
                  uint64_t v156 = v97;
                }
                else {
                  uint64_t v156 = v100;
                }
                if ((unint64_t)v156 + v102 > v99) {
                  goto LABEL_131;
                }
                if (v149 >= 4)
                {
                  unsigned int v157 = v149;
                  LODWORD(v158) = v102;
                  do
                  {
                    unint64_t v159 = v158;
                    unint64_t v158 = (unint64_t)v158 >> 1;
                    int v160 = (unsigned __int16 *)((char *)v156 + (v159 >> 1));
                    if (v155 > bswap32(*v160) >> 16) {
                      uint64_t v156 = v160;
                    }
                    --v157;
                  }
                  while (v157 > 3);
                }
              }
              if ((unint64_t)(v156 + 1) <= v99)
              {
                do
                {
                  int v161 = v156 + 1;
                  unsigned int v163 = *v156;
                  int v162 = v156 + 2;
                  BOOL v164 = v155 <= bswap32(v163) >> 16 || (unint64_t)v162 > v99;
                  uint64_t v156 = v161;
                }
                while (!v164);
                uint64_t v156 = v161;
              }
              int v165 = &v156[v152];
              if ((unint64_t)&v165[(v98 & 0xFFFE) + 1] <= v99)
              {
                unsigned int v166 = bswap32(*v165) >> 16;
                if (v166 <= v155)
                {
                  int v167 = &v165[v152];
                  unsigned int v168 = bswap32(*v167) >> 16;
                  v169 = &v167[v152];
                  if (*v169)
                  {
                    int32x2_t v170 = (unsigned __int16 *)((char *)&v169[(unsigned __int16)(v155 - v166)] + __rev16(*v169));
                    if (v170 > v100 && (unint64_t)(v170 + 1) <= v99)
                    {
                      unsigned int v172 = *v170;
                      unsigned int v173 = (unsigned __int16)(v168 + (bswap32(v172) >> 16));
                      if (v172 && v173 != 0)
                      {
                        *int v154 = v173;
                        goto LABEL_267;
                      }
                    }
                  }
                  else
                  {
                    unsigned __int16 v175 = v168 + v155;
                    if (v175)
                    {
                      *int v154 = v175;
                      goto LABEL_267;
                    }
                  }
                }
              }
              if (!v36) {
                break;
              }
              unsigned int v176 = v155;
              v155 -= 4096;
            }
            while (v176 < 0x100);
            *int v154 = 0;
            --v103;
            if (v153 <= (unsigned __int16)v151) {
              uint64_t v35 = v35;
            }
            else {
              uint64_t v35 = (unsigned __int16)v151;
            }
            if (v153 >= (unsigned __int16)v151) {
              int v153 = (unsigned __int16)v151;
            }
LABEL_267:
            ++v154;
            ++v151;
          }
          while (v151 < *a4);
        }
        else
        {
          unsigned int v103 = v35;
        }
LABEL_133:
        *a4 = v103;
        goto LABEL_162;
      case 6u:
        v191 = v197;
        *(void *)&long long v192 = 0;
        BOOL v44 = (unsigned __int16 *)(*(uint64_t (**)(void *, void, uint64_t))(v197[0] + 16))(v197, 0, 4);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v191, (unint64_t)v44, 1);
        unsigned int v45 = *v44;
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v191, (unint64_t)(v44 + 1), 1);
        unsigned int v46 = v44[1];
        uint64_t v35 = *a4;
        DWORD2(v192) = v35;
        HIDWORD(v192) = v35;
        if (v35)
        {
          unint64_t v47 = 0;
          unsigned int v48 = bswap32(v45) >> 16;
          int v49 = v44 + 2;
          unsigned int v50 = bswap32(v46) >> 16;
          unsigned int v51 = v35;
          do
          {
            if (v50 <= (unsigned __int16)(*(_WORD *)(a2 + 2 * v47) - v48))
            {
              unsigned int v53 = 0;
              --v51;
              if ((int)v35 >= (unsigned __int16)v47) {
                uint64_t v35 = (unsigned __int16)v47;
              }
              else {
                uint64_t v35 = v35;
              }
              *((void *)&v192 + 1) = __PAIR64__(v51, v35);
            }
            else
            {
              uint64_t v52 = &v49[(unsigned __int16)(*(_WORD *)(a2 + 2 * v47) - v48)];
              TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v191, (unint64_t)v52, 1);
              unsigned int v53 = bswap32(*v52) >> 16;
            }
            a3[v47++] = v53;
          }
          while (v47 < *a4);
        }
        else
        {
          unsigned int v51 = 0;
        }
        *a4 = v51;
        goto LABEL_162;
      case 0xCu:
        long long v192 = *(_OWORD *)&v197[1];
        uint64_t v193 = v197[3];
        v191 = &unk_1F0DD6F48;
        if (v197[3]) {
          uint64_t v193 = v197[3] + 6;
        }
        v187 = &v191;
        v188 = &v194;
        DataP = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v191, 0);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v187, (unint64_t)DataP, 1);
        unint64_t v55 = DataP + 1;
        LODWORD(v56) = bswap32(*DataP);
        unint64_t v57 = (unint64_t)&DataP[3 * v56 + 1];
        BOOL v59 = v57 >= (unint64_t)(DataP + 1) && v57 <= (unint64_t)v192;
        if (v13)
        {
          if (!v59)
          {
            if ((unint64_t)(DataP + 4) > (unint64_t)v192) {
              LODWORD(v56) = 0;
            }
            else {
              unint64_t v56 = ((void)v192 - (void)v55) / 0xCuLL;
            }
          }
          int v60 = *a4;
          int v189 = v60;
          unsigned int v190 = v60;
          if (v60)
          {
            unsigned int v61 = 0;
            unint64_t v62 = (unint64_t)&v55[3 * v56];
            v184 = a3;
            BOOL v63 = a3;
            while (1)
            {
              uint64_t v64 = v61;
              unsigned int v65 = *(unsigned __int16 *)(a2 + 2 * v61++);
              if (v61 != v60
                && (v65 & 0xFC00) == 0xD800
                && (int v66 = *(unsigned __int16 *)(a2 + 2 * v61), (v66 & 0xFC00) == 0xDC00))
              {
                unsigned int v61 = v64 + 2;
                unsigned int v65 = (v65 << 10) - 56613888 + v66;
              }
              else
              {
                if (v65 >> 9 < 0x7F) {
                  goto LABEL_73;
                }
                if (v65 >> 4 < 0xFE1)
                {
                  BOOL v67 = 1;
                  if (!v64) {
                    goto LABEL_73;
                  }
                  goto LABEL_60;
                }
              }
              BOOL v67 = v65 - 917760 < 0xF0;
              if (!v64) {
                goto LABEL_73;
              }
LABEL_60:
              if (!v67)
              {
LABEL_73:
                {
                  int v74 = v189;
                  if (v189 >= (unsigned __int16)v64) {
                    int v74 = (unsigned __int16)v64;
                  }
                  int v189 = v74;
                  --v190;
                }
                goto LABEL_77;
              }
              uint64_t v68 = v64 - 1;
              int v69 = *(unsigned __int16 *)(a2 + 2 * (v64 - 1));
              if (v64 >= 2 && (v69 & 0xFC00) == 0xDC00)
              {
                int v70 = *(unsigned __int16 *)(a2 + 2 * (v64 - 2));
                BOOL v71 = (v70 & 0xFC00) == 55296;
                int v72 = v69 - 56613888 + (v70 << 10);
                if (v71) {
                  uint64_t v68 = v64 - 2;
                }
                if (v71) {
                  int v69 = v72;
                }
              }
              if (TFormat14UVSTable::Map<unsigned int>((uint64_t)v188[2], (unint64_t)v188[1], v69, v65, &v63[v68 - v64]))int v73 = 0xFFFFFF; {
              else
              }
                int v73 = 0;
              *BOOL v63 = v73;
LABEL_77:
              if (v65 >= 0x10000)
              {
                v63[1] = 0;
                v63 += 2;
              }
              else
              {
                ++v63;
              }
              int v60 = *a4;
              if (v61 >= *a4) {
                goto LABEL_157;
              }
            }
          }
        }
        else
        {
          if (!v59)
          {
            if ((unint64_t)(DataP + 4) > (unint64_t)v192) {
              LODWORD(v56) = 0;
            }
            else {
              unint64_t v56 = ((void)v192 - (void)v55) / 0xCuLL;
            }
          }
          int v104 = *a4;
          int v189 = v104;
          unsigned int v190 = v104;
          if (v104)
          {
            long long v105 = a3;
            unsigned int v106 = 0;
            unint64_t v107 = (unint64_t)&v55[3 * v56];
            v184 = v105;
            do
            {
              unsigned int v108 = v106 + 1;
              unsigned int v109 = *(unsigned __int16 *)(a2 + 2 * v106);
              if (v106 + 1 != v104 && (v109 & 0xFC00) == 0xD800)
              {
                int v110 = *(unsigned __int16 *)(a2 + 2 * v108);
                BOOL v111 = (v110 & 0xFC00) == 56320;
                unsigned int v112 = (v109 << 10) - 56613888 + v110;
                unsigned int v108 = v111 ? v106 + 2 : v106 + 1;
                if (v111) {
                  unsigned int v109 = v112;
                }
              }
              {
                int v113 = v189;
                if (v189 >= (unsigned __int16)v106) {
                  int v113 = (unsigned __int16)v106;
                }
                int v189 = v113;
                --v190;
              }
              if (v109 >= 0x10000)
              {
                v105[1] = 0;
                v105 += 2;
              }
              else
              {
                ++v105;
              }
              int v104 = *a4;
              unsigned int v106 = v108;
            }
            while (v108 < *a4);
LABEL_157:
            unsigned int v114 = v190;
            a3 = v184;
            goto LABEL_161;
          }
        }
        unsigned int v114 = 0;
LABEL_161:
        *a4 = v114;
        uint64_t v35 = v189;
        goto LABEL_162;
      case 0xDu:
        long long v192 = *(_OWORD *)&v197[1];
        uint64_t v193 = v197[3];
        v191 = &unk_1F0DD6F48;
        if (v197[3]) {
          uint64_t v193 = v197[3] + 6;
        }
        v187 = &v191;
        v188 = 0;
        unsigned int v75 = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v191, 0);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v187, (unint64_t)v75, 1);
        unint64_t v76 = v75 + 1;
        LODWORD(v77) = bswap32(*v75);
        unint64_t v78 = (unint64_t)&v75[3 * v77 + 1];
        if (v78 < (unint64_t)(v75 + 1) || v78 > (unint64_t)v192)
        {
          if ((unint64_t)(v75 + 4) > (unint64_t)v192) {
            LODWORD(v77) = 0;
          }
          else {
            unint64_t v77 = ((void)v192 - (void)v76) / 0xCuLL;
          }
        }
        unint64_t v79 = *a4;
        int v189 = v79;
        unsigned int v190 = v79;
        if (v79)
        {
          unint64_t v80 = 0;
          unsigned int v81 = a3;
          while (1)
          {
            unint64_t v82 = v80 + 1;
            unsigned int v83 = *(unsigned __int16 *)(a2 + 2 * v80);
            if ((v83 & 0xFC00) == 0xD800 && v82 != v79)
            {
              int v85 = *(unsigned __int16 *)(a2 + 2 * v82);
              BOOL v86 = (v85 & 0xFC00) == 56320;
              unsigned int v87 = (v83 << 10) - 56613888 + v85;
              unint64_t v82 = (v85 & 0xFC00) == 0xDC00 ? v80 + 2 : v80 + 1;
              if (v86) {
                unsigned int v83 = v87;
              }
            }
            if (!v77) {
              goto LABEL_112;
            }
            unint64_t v88 = v77;
            int v89 = v75 + 1;
            do
            {
              unint64_t v90 = v88 >> 1;
              uint64_t v91 = &v89[3 * (v88 >> 1)];
              unsigned int v93 = *v91;
              long long v92 = v91 + 3;
              v88 += ~(v88 >> 1);
              if (bswap32(v93) > v83) {
                unint64_t v88 = v90;
              }
              else {
                int v89 = v92;
              }
            }
            while (v88);
            uint64_t v94 = (uint64_t)(v89 == v76 ? v75 + 1 : v89 - 3);
            if (((unsigned int *)v94 != v76 || bswap32(*v76) <= v83) && bswap32(*(_DWORD *)(v94 + 4)) >= v83)
            {
              unsigned int v95 = bswap32(*(_DWORD *)(v94 + 8));
              BOOL v96 = v95 >= 0xFFFFFF;
              if (v95 >= 0xFFFFFF) {
                unsigned int v95 = 0;
              }
              *unsigned int v81 = v95;
              if (!v96) {
                goto LABEL_117;
              }
            }
            else
            {
LABEL_112:
              *unsigned int v81 = 0;
            }
            if (v189 >= (unsigned __int16)v80) {
              LODWORD(v80) = (unsigned __int16)v80;
            }
            else {
              LODWORD(v80) = v189;
            }
            int v189 = v80;
            --v190;
LABEL_117:
            if (v83 >= 0x10000)
            {
              v81[1] = 0;
              v81 += 2;
            }
            else
            {
              ++v81;
            }
            unint64_t v79 = *a4;
            unint64_t v80 = v82;
            if (v82 >= v79)
            {
              uint64_t v35 = v189;
              unsigned int v15 = v190;
              goto LABEL_159;
            }
          }
        }
        uint64_t v35 = 0;
        unsigned int v15 = 0;
LABEL_159:
        *a4 = v15;
LABEL_162:
        if (v35 == -1) {
          break;
        }
        return v35;
      default:
        break;
    }
  }
  uint64_t v115 = *a4;
  if (v115) {
    bzero(a3, 4 * v115);
  }
  *a4 = 0;
  return 0xFFFFFFFFLL;
}

uint64_t TcmapUnicodeTable::MapRange(TcmapUnicodeTable *this, CFRange a2, unsigned __int16 *a3)
{
  CFIndex length = a2.length;
  unint64_t location = a2.location;
  v108[0] = &unk_1F0DD6FA8;
  memset(&v108[1], 170, 24);
  unint64_t TableEnd = TsfntTable::GetTableEnd(this);
  unint64_t v8 = (unsigned __int16 *)*((void *)this + 8);
  v108[0] = &unk_1F0DD6F78;
  v108[1] = TableEnd;
  uint64_t v9 = v8 + 3;
  if (!v8) {
    uint64_t v9 = 0;
  }
  v108[2] = v8;
  v108[3] = v9;
  if (!v8) {
    return 0;
  }
  unsigned int v10 = bswap32(*v8) >> 16;
  if (v10 == 13)
  {
    unint64_t v103 = TableEnd;
    int v104 = v8;
    uint64_t v102 = &unk_1F0DD6F48;
    long long v105 = v8 + 6;
    unsigned int v106 = &v102;
    uint64_t v107 = 0;
    DataP = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v102, 0);
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v106, (unint64_t)DataP, 1);
    unsigned int v19 = DataP + 1;
    unint64_t v20 = bswap32(*DataP);
    unint64_t v21 = (unint64_t)&DataP[3 * v20 + 1];
    if (v21 < (unint64_t)(DataP + 1) || v21 > v103)
    {
      if ((unint64_t)(DataP + 4) > v103) {
        goto LABEL_177;
      }
      unint64_t v28 = (v103 - (unint64_t)v19) / 0xC;
      unint64_t v20 = v28;
    }
    else
    {
      LODWORD(v28) = v20;
    }
    unsigned int v29 = location + length - 1;
    if (v28)
    {
      unsigned int v30 = &v19[3 * v20];
      unsigned int v31 = bswap32(*(v30 - 2));
      if (v31 >= location)
      {
        unint64_t v32 = DataP + 1;
        do
        {
          unint64_t v33 = v20 >> 1;
          unsigned int v34 = &v32[3 * (v20 >> 1)];
          unsigned int v36 = *v34;
          uint64_t v35 = v34 + 3;
          v20 += ~(v20 >> 1);
          if (bswap32(v36) > location) {
            unint64_t v20 = v33;
          }
          else {
            unint64_t v32 = v35;
          }
        }
        while (v20);
        if (v31 >= v29) {
          unint64_t v37 = v29;
        }
        else {
          unint64_t v37 = v31;
        }
        if (v32 != v19) {
          unsigned int v19 = v32 - 3;
        }
        uint64_t v38 = v30;
        if (v30 != v19)
        {
          unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * (v30 - v19);
          uint64_t v38 = v19;
          do
          {
            unint64_t v40 = v39 >> 1;
            unsigned int v41 = &v38[3 * (v39 >> 1)];
            unsigned int v43 = *v41;
            uint64_t v42 = v41 + 3;
            v39 += ~(v39 >> 1);
            if (bswap32(v43) > v29) {
              unint64_t v39 = v40;
            }
            else {
              uint64_t v38 = v42;
            }
          }
          while (v39);
        }
        BOOL v44 = v38 - 3;
        if (v38 == v19) {
          BOOL v44 = v19;
        }
        unsigned int v45 = bswap32(v19[1]);
        if (v45 >= location)
        {
          unsigned int v47 = location;
          unsigned int v46 = v19;
          if (bswap32(*v19) < location)
          {
            if (v45 >= v37) {
              unsigned int v67 = v37;
            }
            else {
              unsigned int v67 = v45;
            }
            unsigned int v47 = location;
            if (v67 >= location)
            {
              unsigned int v68 = bswap32(v19[2]);
              if (v68 >= 0xFFFF) {
                unsigned __int16 v69 = 0;
              }
              else {
                unsigned __int16 v69 = v68;
              }
              unsigned int v47 = location;
              do
                a3[v47++ - location] = v69;
              while (v47 <= v67);
            }
            unsigned int v46 = v19 + 3;
          }
        }
        else
        {
          unsigned int v46 = v19 + 3;
          unsigned int v47 = location;
        }
        for (; v46 < v44; v46 += 3)
        {
          if (v47 <= v37)
          {
            unint64_t v70 = bswap32(*v46);
            if (v47 < v70)
            {
              uint64_t v71 = 0;
              uint64_t v72 = v47;
              int v73 = v47 - location;
              do
              {
                unint64_t v74 = v72 + v71;
                a3[(v73 + v71++)] = 0;
              }
              while (v74 < v37 && v74 + 1 < v70);
              unsigned int v47 = v72 + v71;
            }
          }
          unsigned int v75 = bswap32(v46[1]);
          if (v75 >= v37) {
            unsigned int v75 = v37;
          }
          if (v47 <= v75)
          {
            unsigned int v76 = bswap32(v46[2]);
            if (v76 >= 0xFFFF) {
              LOWORD(v76) = 0;
            }
            do
              a3[v47++ - location] = v76;
            while (v47 <= v75);
          }
        }
        if (v46 != v19)
        {
          if (v29 >= bswap32(*v44)) {
            uint64_t v77 = 0;
          }
          else {
            uint64_t v77 = -1;
          }
          unsigned int v19 = &v46[3 * v77];
        }
        if (v19 != v30)
        {
          if (v47 <= v37)
          {
            unint64_t v78 = bswap32(*v19);
            if (v47 < v78)
            {
              uint64_t v79 = 0;
              do
              {
                unint64_t v80 = v47 + v79;
                a3[v47 - location + v79++] = 0;
              }
              while (v80 < v37 && v80 + 1 < v78);
              v47 += v79;
            }
          }
          unsigned int v81 = bswap32(v19[1]);
          if (v81 < v37) {
            LODWORD(v37) = v81;
          }
          if (v47 <= v37)
          {
            unsigned int v82 = bswap32(v19[2]);
            if (v82 >= 0xFFFF) {
              LOWORD(v82) = 0;
            }
            do
              a3[v47++ - location] = v82;
            while (v47 <= v37);
          }
        }
        goto LABEL_64;
      }
    }
    goto LABEL_63;
  }
  if (v10 == 12)
  {
    unint64_t v103 = TableEnd;
    int v104 = v8;
    uint64_t v102 = &unk_1F0DD6F48;
    long long v105 = v8 + 6;
    unsigned int v106 = &v102;
    uint64_t v107 = 0;
    unsigned int v23 = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v102, 0);
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v106, (unint64_t)v23, 1);
    unsigned int v24 = v23 + 1;
    unint64_t v25 = bswap32(*v23);
    unint64_t v26 = (unint64_t)&v23[3 * v25 + 1];
    if (v26 >= (unint64_t)(v23 + 1) && v26 <= v103)
    {
      LODWORD(v48) = v25;
LABEL_61:
      unsigned int v29 = location + length - 1;
      if (v48)
      {
        int v49 = &v24[3 * v25];
        unsigned int v50 = bswap32(*(v49 - 2));
        if (v50 >= location)
        {
          uint64_t v52 = v23 + 1;
          do
          {
            unint64_t v53 = v25 >> 1;
            unint64_t v54 = &v52[3 * (v25 >> 1)];
            unsigned int v56 = *v54;
            unint64_t v55 = v54 + 3;
            v25 += ~(v25 >> 1);
            if (bswap32(v56) > location) {
              unint64_t v25 = v53;
            }
            else {
              uint64_t v52 = v55;
            }
          }
          while (v25);
          if (v50 >= v29) {
            unint64_t v57 = v29;
          }
          else {
            unint64_t v57 = v50;
          }
          if (v52 != v24) {
            unsigned int v24 = v52 - 3;
          }
          unsigned int v58 = v49;
          if (v49 != v24)
          {
            unint64_t v59 = 0xAAAAAAAAAAAAAAABLL * (v49 - v24);
            unsigned int v58 = v24;
            do
            {
              unint64_t v60 = v59 >> 1;
              unsigned int v61 = &v58[3 * (v59 >> 1)];
              unsigned int v63 = *v61;
              unint64_t v62 = v61 + 3;
              v59 += ~(v59 >> 1);
              if (bswap32(v63) > v29) {
                unint64_t v59 = v60;
              }
              else {
                unsigned int v58 = v62;
              }
            }
            while (v59);
          }
          uint64_t v64 = v58 - 3;
          if (v58 == v24) {
            uint64_t v64 = v24;
          }
          unsigned int v65 = bswap32(v24[1]);
          if (v65 >= location)
          {
            unsigned int v83 = bswap32(*v24);
            unsigned int v47 = location;
            int v66 = v24;
            if (v83 < location)
            {
              if (v65 >= v57) {
                unsigned int v84 = v57;
              }
              else {
                unsigned int v84 = v65;
              }
              unsigned int v47 = location;
              if (v84 >= location)
              {
                unsigned int v85 = bswap32(v24[2]) - v83;
                unsigned int v47 = location;
                do
                {
                  unsigned __int16 v86 = v85 + v47;
                  if (v85 + v47 >= 0xFFFF) {
                    unsigned __int16 v86 = 0;
                  }
                  a3[v47++ - location] = v86;
                }
                while (v47 <= v84);
              }
              int v66 = v24 + 3;
            }
          }
          else
          {
            int v66 = v24 + 3;
            unsigned int v47 = location;
          }
          for (; v66 < v64; v66 += 3)
          {
            unint64_t v87 = bswap32(*v66);
            if (v47 <= v57 && v47 < v87)
            {
              uint64_t v88 = 0;
              uint64_t v89 = v47;
              int v90 = v47 - location;
              do
              {
                unint64_t v91 = v89 + v88;
                a3[(v90 + v88++)] = 0;
              }
              while (v91 < v57 && v91 + 1 < v87);
              unsigned int v47 = v89 + v88;
            }
            unsigned int v92 = bswap32(v66[1]);
            if (v92 >= v57) {
              unsigned int v92 = v57;
            }
            if (v47 <= v92)
            {
              int v93 = bswap32(v66[2]) - v87;
              do
              {
                unsigned __int16 v94 = v93 + v47;
                if (v93 + v47 >= 0xFFFF) {
                  unsigned __int16 v94 = 0;
                }
                a3[v47++ - location] = v94;
              }
              while (v47 <= v92);
            }
          }
          if (v66 != v24)
          {
            if (v29 >= bswap32(*v64)) {
              uint64_t v95 = 0;
            }
            else {
              uint64_t v95 = -1;
            }
            unsigned int v24 = &v66[3 * v95];
          }
          if (v24 != v49)
          {
            unint64_t v96 = bswap32(*v24);
            if (v47 <= v57 && v47 < v96)
            {
              uint64_t v97 = 0;
              do
              {
                unint64_t v98 = v47 + v97;
                a3[v47 - location + v97++] = 0;
              }
              while (v98 < v57 && v98 + 1 < v96);
              v47 += v97;
            }
            unsigned int v99 = bswap32(v24[1]);
            if (v99 < v57) {
              LODWORD(v57) = v99;
            }
            if (v47 <= v57)
            {
              int v100 = bswap32(v24[2]) - v96;
              do
              {
                unsigned __int16 v101 = v100 + v47;
                if (v100 + v47 >= 0xFFFF) {
                  unsigned __int16 v101 = 0;
                }
                a3[v47++ - location] = v101;
              }
              while (v47 <= v57);
            }
          }
          goto LABEL_64;
        }
      }
LABEL_63:
      unsigned int v47 = location;
LABEL_64:
      if (v47 <= v29)
      {
        uint64_t v51 = v29 + 1;
        if (v51 != v47) {
          bzero(&a3[v47 - location], 2 * (v51 - v47));
        }
      }
      return 1;
    }
    if ((unint64_t)(v23 + 4) <= v103)
    {
      unint64_t v48 = (v103 - (unint64_t)v24) / 0xC;
      unint64_t v25 = v48;
      goto LABEL_61;
    }
LABEL_177:
    unsigned int v29 = location + length - 1;
    goto LABEL_63;
  }
  if (v10 != 4) {
    return 0;
  }
  uint64_t v102 = v108;
  unint64_t v103 = 0;
  v109.unint64_t location = location;
  v109.CFIndex length = length;
  if (*((unsigned char *)this + 80))
  {
    uint64_t v11 = 256;
    if ((uint64_t)(location + length) < 256) {
      uint64_t v11 = location + length;
    }
    if ((uint64_t)(location + length) > 0 && (uint64_t)location < 1) {
      CFIndex v13 = v11;
    }
    else {
      CFIndex v13 = 0;
    }
    CFIndex v14 = v11 - location;
    if (location <= 0xFF) {
      unint64_t v15 = location;
    }
    else {
      unint64_t v15 = 0;
    }
    if (location <= 0xFF) {
      v16.CFIndex length = v14;
    }
    else {
      v16.CFIndex length = v13;
    }
    if (v16.length >= 1)
    {
      uint64_t v102 = v108;
      unint64_t v103 = 0;
      v16.unint64_t location = v15 + 61440;
    }
  }
  return 1;
}

void anonymous namespace'::TFormat4UTF16cmapTable::MapRange(_anonymous_namespace_::TFormat4UTF16cmapTable *this, CFRange a2, unsigned __int16 *a3)
{
  int length = a2.length;
  CFIndex location = a2.location;
  unint64_t v7 = (unsigned __int16 *)(*(uint64_t (**)(void, void, uint64_t))(**(void **)this + 16))(*(void *)this, 0, 4);
  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(this, (unint64_t)v7, 1);
  unint64_t v8 = v7 + 4;
  uint64_t v9 = bswap32(*v7) >> 16;
  uint64_t v10 = (location + length - 1);
  unsigned int v11 = location;
  if ((v9 & 1) == 0)
  {
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(this, (unint64_t)v8 + v9 - 4, 1);
    unsigned int v12 = bswap32(*(unsigned __int16 *)((char *)v8 + v9 - 4));
    unsigned int v11 = location;
    if (location <= HIWORD(v12))
    {
      if (v10 >= HIWORD(v12)) {
        unint64_t v13 = HIWORD(v12);
      }
      else {
        unint64_t v13 = v10;
      }
      int v49 = (unsigned __int16 *)((char *)v8 + v9 + 2);
      unint64_t v14 = v9 >> 1;
      BOOL v44 = (char *)v49 + v9;
      unint64_t v48 = (unint64_t)v49 + v9 + v9;
      TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(this, v48, v14);
      unsigned int v15 = bswap32(*v49) >> 16;
      if (v9 < 2 || v15 > location)
      {
        LODWORD(v17) = 0;
        unint64_t v18 = v9 >> 1;
      }
      else
      {
        uint64_t v17 = 0;
        if (v14 <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v14;
        }
        unint64_t v20 = (unsigned __int16 *)((char *)v7 + v9 + 12);
        unint64_t v18 = v9 >> 1;
        while (1)
        {
          unsigned int v21 = bswap32(v7[v17 + 4]) >> 16;
          if (location >= bswap32(*(v20 - 1)) >> 16 && location <= v21) {
            break;
          }
          unint64_t v23 = v17 + 1;
          if (location > v21 && (v23 >= v14 || location < bswap32(*v20) >> 16))
          {
            LODWORD(v17) = v17 + 1;
            break;
          }
          ++v20;
          ++v17;
          if (v19 == v23)
          {
            unsigned int v11 = location;
            goto LABEL_3;
          }
        }
      }
      unsigned int v11 = location;
      unint64_t v25 = (char *)v49 + v9 + v9;
      uint64_t v24 = (uint64_t)v8 + v9 + 2;
      if (v17 < v18)
      {
        unsigned int v11 = location;
        if (v13 >= location)
        {
          unint64_t v26 = v17;
          CFIndex v27 = -location;
          unsigned int v11 = location;
          uint64_t v46 = v10;
          int v47 = location;
          unint64_t v45 = v18;
          do
          {
            unsigned int v28 = bswap32(*(unsigned __int16 *)(v24 + 2 * v26));
            unint64_t v29 = HIWORD(v28);
            if (v11 < HIWORD(v28))
            {
              uint64_t v30 = 0;
              uint64_t v31 = v11;
              int v32 = v27 + v11;
              do
              {
                unint64_t v33 = v31 + v30;
                a3[(v32 + v30++)] = 0;
              }
              while (v33 < v13 && v33 + 1 < v29);
              unsigned int v11 = v31 + v30;
            }
            unsigned int v34 = bswap32(v8[v26]) >> 16;
            uint64_t v35 = &v25[2 * v26];
            if (*(_WORD *)v35)
            {
              if (v34 >= v13) {
                unsigned int v34 = v13;
              }
              if (v11 <= v34)
              {
                unsigned int v36 = &v35[__rev16(*(unsigned __int16 *)v35) & 0xFFFE];
                unsigned int v50 = v34 + 1;
                unsigned int v37 = v34 + 1 - v11;
                CFIndex v38 = v27 + v11;
                int v39 = v11 - v29;
                do
                {
                  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(this, (unint64_t)&v36[2 * v39], 1);
                  a3[v38++] = bswap32(*(unsigned __int16 *)&v36[2 * v39++]) >> 16;
                  --v37;
                }
                while (v37);
                unsigned int v11 = v50;
                uint64_t v10 = v46;
                LODWORD(location) = v47;
                unint64_t v18 = v45;
                unint64_t v8 = v7 + 4;
                unint64_t v25 = (char *)v48;
                uint64_t v24 = (uint64_t)v49;
              }
            }
            else
            {
              if (v34 >= v13) {
                unsigned int v34 = v13;
              }
              if (v11 <= v34)
              {
                unsigned int v40 = bswap32(*(unsigned __int16 *)&v44[2 * v26]) >> 16;
                uint64_t v41 = v11;
                unsigned int v42 = v34 + 1;
                unsigned int v43 = v42 - v11;
                do
                {
                  a3[(v27 + v41)] = v40 + v41;
                  ++v41;
                  --v43;
                }
                while (v43);
                unsigned int v11 = v42;
              }
            }
            ++v26;
          }
          while (v26 < v18 && v11 <= v13);
        }
      }
    }
  }
LABEL_3:
  if (v11 <= v10 && v10 + 1 != v11)
  {
    bzero(&a3[v11 - location], 2 * (v10 + 1 - v11));
  }
}

uint64_t TcmapUnicodeTable::MapRange(TcmapUnicodeTable *this, CFRange a2, unsigned int *a3)
{
  int length = a2.length;
  unsigned int location = a2.location;
  uint64_t v102 = &unk_1F0DD6FA8;
  memset(v103, 170, sizeof(v103));
  unint64_t TableEnd = TsfntTable::GetTableEnd(this);
  unint64_t v8 = (unsigned __int16 *)*((void *)this + 8);
  uint64_t v102 = &unk_1F0DD6F78;
  v103[0] = TableEnd;
  uint64_t v9 = v8 + 3;
  if (!v8) {
    uint64_t v9 = 0;
  }
  v103[1] = v8;
  v103[2] = v9;
  if (!v8) {
    return 0;
  }
  unsigned int v10 = bswap32(*v8) >> 16;
  if (v10 == 13)
  {
    unint64_t v97 = TableEnd;
    unint64_t v98 = v8;
    unint64_t v96 = &unk_1F0DD6F48;
    unsigned int v99 = v8 + 6;
    int v100 = &v96;
    uint64_t v101 = 0;
    DataP = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v96, 0);
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v100, (unint64_t)DataP, 1);
    unint64_t v18 = DataP + 1;
    unint64_t v19 = bswap32(*DataP);
    unint64_t v20 = (unint64_t)&DataP[3 * v19 + 1];
    if (v20 < (unint64_t)(DataP + 1) || v20 > v97)
    {
      if ((unint64_t)(DataP + 4) > v97) {
        goto LABEL_159;
      }
      unint64_t v42 = (v97 - (unint64_t)v18) / 0xC;
      unint64_t v19 = v42;
    }
    else
    {
      LODWORD(v42) = v19;
    }
    unsigned int v23 = location + length - 1;
    if (v42)
    {
      unsigned int v43 = &v18[3 * v19];
      unsigned int v44 = bswap32(*(v43 - 2));
      if (v44 >= location)
      {
        uint64_t v46 = DataP + 1;
        do
        {
          unint64_t v47 = v19 >> 1;
          unint64_t v48 = &v46[3 * (v19 >> 1)];
          unsigned int v50 = *v48;
          int v49 = v48 + 3;
          v19 += ~(v19 >> 1);
          if (bswap32(v50) > location) {
            unint64_t v19 = v47;
          }
          else {
            uint64_t v46 = v49;
          }
        }
        while (v19);
        if (v44 >= v23) {
          unint64_t v51 = v23;
        }
        else {
          unint64_t v51 = v44;
        }
        if (v46 != v18) {
          unint64_t v18 = v46 - 3;
        }
        uint64_t v52 = v43;
        if (v43 != v18)
        {
          unint64_t v53 = 0xAAAAAAAAAAAAAAABLL * (v43 - v18);
          uint64_t v52 = v18;
          do
          {
            unint64_t v54 = v53 >> 1;
            unint64_t v55 = &v52[3 * (v53 >> 1)];
            unsigned int v57 = *v55;
            unsigned int v56 = v55 + 3;
            v53 += ~(v53 >> 1);
            if (bswap32(v57) > v23) {
              unint64_t v53 = v54;
            }
            else {
              uint64_t v52 = v56;
            }
          }
          while (v53);
        }
        unsigned int v58 = v52 - 3;
        if (v52 == v18) {
          unsigned int v58 = v18;
        }
        unsigned int v59 = bswap32(v18[1]);
        if (v59 >= location)
        {
          unsigned int v41 = location;
          unint64_t v60 = v18;
          if (bswap32(*v18) < location)
          {
            if (v59 >= v51) {
              unsigned int v80 = v51;
            }
            else {
              unsigned int v80 = v59;
            }
            unsigned int v41 = location;
            if (v80 >= location)
            {
              unsigned int v81 = bswap32(v18[2]);
              if (v81 >= 0xFFFFFF) {
                unsigned int v82 = 0;
              }
              else {
                unsigned int v82 = v81;
              }
              unsigned int v41 = location;
              do
                a3[v41++ - location] = v82;
              while (v41 <= v80);
            }
            unint64_t v60 = v18 + 3;
          }
        }
        else
        {
          unint64_t v60 = v18 + 3;
          unsigned int v41 = location;
        }
        for (; v60 < v58; v60 += 3)
        {
          if (v41 <= v51)
          {
            unint64_t v83 = bswap32(*v60);
            if (v41 < v83)
            {
              uint64_t v84 = 0;
              uint64_t v85 = v41;
              unsigned int v86 = v41 - location;
              do
              {
                unint64_t v87 = v85 + v84;
                a3[v86 + v84++] = 0;
              }
              while (v87 < v51 && v87 + 1 < v83);
              unsigned int v41 = v85 + v84;
            }
          }
          unsigned int v88 = bswap32(v60[1]);
          if (v88 >= v51) {
            unsigned int v88 = v51;
          }
          if (v41 <= v88)
          {
            unsigned int v89 = bswap32(v60[2]);
            if (v89 >= 0xFFFFFF) {
              unsigned int v89 = 0;
            }
            do
              a3[v41++ - location] = v89;
            while (v41 <= v88);
          }
        }
        if (v60 != v18)
        {
          if (v23 >= bswap32(*v58)) {
            uint64_t v90 = 0;
          }
          else {
            uint64_t v90 = -1;
          }
          unint64_t v18 = &v60[3 * v90];
        }
        if (v18 != v43)
        {
          if (v41 <= v51)
          {
            unint64_t v91 = bswap32(*v18);
            if (v41 < v91)
            {
              uint64_t v92 = 0;
              do
              {
                unint64_t v93 = v41 + v92;
                a3[v41 - location + v92++] = 0;
              }
              while (v93 < v51 && v93 + 1 < v91);
              v41 += v92;
            }
          }
          unsigned int v94 = bswap32(v18[1]);
          if (v94 < v51) {
            LODWORD(v51) = v94;
          }
          if (v41 <= v51)
          {
            unsigned int v95 = bswap32(v18[2]);
            if (v95 >= 0xFFFFFF) {
              unsigned int v95 = 0;
            }
            do
              a3[v41++ - location] = v95;
            while (v41 <= v51);
          }
        }
        goto LABEL_46;
      }
    }
    goto LABEL_45;
  }
  if (v10 != 12) {
    return 0;
  }
  unint64_t v97 = TableEnd;
  unint64_t v98 = v8;
  unint64_t v96 = &unk_1F0DD6F48;
  unsigned int v99 = v8 + 6;
  int v100 = &v96;
  uint64_t v101 = 0;
  unsigned int v11 = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v96, 0);
  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v100, (unint64_t)v11, 1);
  unsigned int v12 = v11 + 1;
  unint64_t v13 = bswap32(*v11);
  unint64_t v14 = (unint64_t)&v11[3 * v13 + 1];
  if (v14 < (unint64_t)(v11 + 1) || v14 > v97)
  {
    if ((unint64_t)(v11 + 4) <= v97)
    {
      unint64_t v22 = (v97 - (unint64_t)v12) / 0xC;
      unint64_t v13 = v22;
      goto LABEL_21;
    }
LABEL_159:
    unsigned int v23 = location + length - 1;
    goto LABEL_45;
  }
  LODWORD(v22) = v13;
LABEL_21:
  unsigned int v23 = location + length - 1;
  if (v22)
  {
    uint64_t v24 = &v12[3 * v13];
    unsigned int v25 = bswap32(*(v24 - 2));
    if (v25 >= location)
    {
      unint64_t v26 = v11 + 1;
      do
      {
        unint64_t v27 = v13 >> 1;
        unsigned int v28 = &v26[3 * (v13 >> 1)];
        unsigned int v30 = *v28;
        unint64_t v29 = v28 + 3;
        v13 += ~(v13 >> 1);
        if (bswap32(v30) > location) {
          unint64_t v13 = v27;
        }
        else {
          unint64_t v26 = v29;
        }
      }
      while (v13);
      if (v25 >= v23) {
        unint64_t v31 = v23;
      }
      else {
        unint64_t v31 = v25;
      }
      if (v26 != v12) {
        unsigned int v12 = v26 - 3;
      }
      int v32 = v24;
      if (v24 != v12)
      {
        unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * (v24 - v12);
        int v32 = v12;
        do
        {
          unint64_t v34 = v33 >> 1;
          uint64_t v35 = &v32[3 * (v33 >> 1)];
          unsigned int v37 = *v35;
          unsigned int v36 = v35 + 3;
          v33 += ~(v33 >> 1);
          if (bswap32(v37) > v23) {
            unint64_t v33 = v34;
          }
          else {
            int v32 = v36;
          }
        }
        while (v33);
      }
      CFIndex v38 = v32 - 3;
      if (v32 == v12) {
        CFIndex v38 = v12;
      }
      unsigned int v39 = bswap32(v12[1]);
      if (v39 >= location)
      {
        unsigned int v61 = bswap32(*v12);
        unsigned int v41 = location;
        unsigned int v40 = v12;
        if (v61 < location)
        {
          if (v39 >= v31) {
            unsigned int v62 = v31;
          }
          else {
            unsigned int v62 = v39;
          }
          unsigned int v41 = location;
          if (v62 >= location)
          {
            unsigned int v63 = bswap32(v12[2]) - v61;
            unsigned int v41 = location;
            do
            {
              unsigned int v64 = v63 + v41;
              if (v63 + v41 >= 0xFFFFFF) {
                unsigned int v64 = 0;
              }
              a3[v41++ - location] = v64;
            }
            while (v41 <= v62);
          }
          unsigned int v40 = v12 + 3;
        }
      }
      else
      {
        unsigned int v40 = v12 + 3;
        unsigned int v41 = location;
      }
      for (; v40 < v38; v40 += 3)
      {
        unint64_t v65 = bswap32(*v40);
        if (v41 <= v31 && v41 < v65)
        {
          uint64_t v66 = 0;
          uint64_t v67 = v41;
          unsigned int v68 = v41 - location;
          do
          {
            unint64_t v69 = v67 + v66;
            a3[v68 + v66++] = 0;
          }
          while (v69 < v31 && v69 + 1 < v65);
          unsigned int v41 = v67 + v66;
        }
        unsigned int v70 = bswap32(v40[1]);
        if (v70 >= v31) {
          unsigned int v70 = v31;
        }
        if (v41 <= v70)
        {
          int v71 = bswap32(v40[2]) - v65;
          do
          {
            unsigned int v72 = v71 + v41;
            if (v71 + v41 >= 0xFFFFFF) {
              unsigned int v72 = 0;
            }
            a3[v41++ - location] = v72;
          }
          while (v41 <= v70);
        }
      }
      if (v40 != v12)
      {
        if (v23 >= bswap32(*v38)) {
          uint64_t v73 = 0;
        }
        else {
          uint64_t v73 = -1;
        }
        unsigned int v12 = &v40[3 * v73];
      }
      if (v12 != v24)
      {
        unint64_t v74 = bswap32(*v12);
        if (v41 <= v31 && v41 < v74)
        {
          uint64_t v75 = 0;
          do
          {
            unint64_t v76 = v41 + v75;
            a3[v41 - location + v75++] = 0;
          }
          while (v76 < v31 && v76 + 1 < v74);
          v41 += v75;
        }
        unsigned int v77 = bswap32(v12[1]);
        if (v77 < v31) {
          LODWORD(v31) = v77;
        }
        if (v41 <= v31)
        {
          int v78 = bswap32(v12[2]) - v74;
          do
          {
            unsigned int v79 = v78 + v41;
            if (v78 + v41 >= 0xFFFFFF) {
              unsigned int v79 = 0;
            }
            a3[v41++ - location] = v79;
          }
          while (v41 <= v31);
        }
      }
      goto LABEL_46;
    }
  }
LABEL_45:
  unsigned int v41 = location;
LABEL_46:
  if (v41 <= v23)
  {
    uint64_t v45 = v23 + 1;
    if (v45 != v41) {
      bzero(&a3[v41 - location], 4 * (v45 - v41));
    }
  }
  return 1;
}

unsigned int *TcmapUnicodeTable::FillInverseMap(TcmapUnicodeTable *this, unsigned int *a2, __CFDictionary *a3, unsigned int a4)
{
  v99[0] = &unk_1F0DD6FA8;
  memset(&v99[1], 170, 24);
  unint64_t TableEnd = TsfntTable::GetTableEnd(this);
  uint64_t v9 = *((void *)this + 8);
  v99[0] = &unk_1F0DD6F78;
  v99[1] = TableEnd;
  v99[2] = v9;
  if (v9) {
    uint64_t v10 = v9 + 6;
  }
  else {
    uint64_t v10 = 0;
  }
  v99[3] = v10;
  unint64_t v97 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v98 = (_WORD *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v96 = &unk_1F0DD6FA8;
  unint64_t v11 = TsfntTable::GetTableEnd(this);
  unsigned int v12 = (unsigned __int16 *)*((void *)this + 8);
  unint64_t v13 = (_WORD *)*((void *)this + 9);
  unint64_t v96 = &unk_1F0DD7208;
  unint64_t v97 = v11;
  unint64_t v98 = v13;
  uint64_t result = 0;
  if (v12)
  {
    unsigned int v95 = a4;
    switch(bswap32(*v12) >> 16)
    {
      case 2u:
        uint64_t v90 = a3;
        uint64_t v92 = a2;
        *(void *)&long long v103 = v99;
        *((void *)&v103 + 1) = 0;
        uint64_t v102 = &unk_1F0DFE240;
        unint64_t v15 = (*(uint64_t (**)(void *, void, uint64_t))(v99[0] + 16))(v99, 0, 4);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v103, v15, 256);
        uint64_t v16 = 0;
        unint64_t v86 = v15 + 512;
        unsigned int v88 = (unsigned __int16 *)v15;
        unint64_t v84 = v15 + 518;
        break;
      case 4u:
        uint64_t v102 = v99;
        *(void *)&long long v103 = &v96;
        unsigned int v41 = (unsigned __int16 *)(*(uint64_t (**)(void *, void, uint64_t))(v99[0] + 16))(v99, 0, 4);
        unsigned int v42 = bswap32(*v41) >> 16;
        if (v42)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *(void *)exception = &unk_1F0DD4440;
          exception[2] = 4;
        }
        unsigned int v43 = v42 >> 1;
        unsigned int v89 = v41 + 4;
        unint64_t v44 = (unint64_t)&v41[(v42 >> 1) + 5];
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v102, v44, 1);
        unint64_t v87 = v44;
        unint64_t v45 = v44 + 2 * (v42 >> 1);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v102, v45, 1);
        unint64_t v91 = v45 + 2 * (v42 >> 1);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v102, v91, v42 >> 1);
        if (v42 >= 2)
        {
          uint64_t v46 = 0;
          LODWORD(v47) = 0;
          unsigned int v48 = 0;
          unint64_t v49 = v91 + 2 * v43;
          if (v43 <= 1) {
            uint64_t v50 = 1;
          }
          else {
            uint64_t v50 = v43;
          }
          uint64_t v85 = v50;
          int v83 = -v43;
          do
          {
            unsigned int v51 = v47;
            unsigned int v52 = bswap32(*(unsigned __int16 *)(v87 + 2 * v46));
            uint64_t v47 = bswap32(v89[v46]) >> 16;
            BOOL v53 = v48 > HIWORD(v52) || v51 > v47;
            if (v53) {
              break;
            }
            unsigned int v54 = HIWORD(v52);
            unsigned int v93 = HIWORD(v52);
            if (*(_WORD *)(v91 + 2 * v46))
            {
              if (v54 <= v47)
              {
                unsigned int v55 = v83 + (__rev16(*(unsigned __int16 *)(v91 + 2 * v46)) >> 1);
                uint64_t v56 = HIWORD(v52);
                do
                {
                  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v102, v49 + 2 * (unsigned __int16)(v46 + v55), 1);
                  a4 = v95;
                  unsigned int v57 = (void *)(bswap32(*(unsigned __int16 *)(v49 + 2 * (unsigned __int16)(v46 + v55))) >> 16);
                  if (v57 < v95) {
                    SetUVSForGlyphInMap(a2, a3, v57, v56, 0, v95);
                  }
                  ++v56;
                  LOWORD(v55) = v55 + 1;
                }
                while (v47 + 1 != v56);
              }
            }
            else if (v54 <= v47)
            {
              unsigned int v58 = HIWORD(v52);
              do
              {
                unint64_t v59 = (unsigned __int16)(v58 + (bswap32(*(unsigned __int16 *)(v45 + 2 * v46)) >> 16));
                if (v59 < a4) {
                  SetUVSForGlyphInMap(a2, a3, (void *)v59, v58, 0, a4);
                }
                ++v58;
              }
              while (v47 + 1 != v58);
            }
            ++v46;
            unsigned int v48 = v93;
          }
          while (v46 != v85);
        }
        if (!v98 || *v98 != 3584) {
          return a2;
        }
        int v100 = (void **)v98;
        uint64_t v101 = (void **)v97;
        unint64_t v60 = (TFormat14UVSTable *)&v100;
        unsigned int v61 = a2;
        CFDictionaryRef v62 = a3;
        unsigned int v63 = a4;
        goto LABEL_65;
      case 6u:
        uint64_t v102 = v99;
        *(void *)&long long v103 = 0;
        uint64_t v35 = (unsigned __int16 *)(*(uint64_t (**)(void *, void, uint64_t))(v99[0] + 16))(v99, 0, 4);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v102, (unint64_t)v35, 1);
        unsigned int v36 = *v35;
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v102, (unint64_t)(v35 + 1), 1);
        if (v35[1])
        {
          unsigned int v37 = __rev16(v35[1]);
          CFIndex v38 = v35 + 2;
          unsigned int v39 = __rev16(v36);
          do
          {
            --v37;
            TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v102, (unint64_t)v38, 1);
            unsigned int v40 = *v38++;
            SetUVSForGlyphInMap(a2, a3, (void *)(bswap32(v40) >> 16), (unsigned __int16)v39++, 0, a4);
          }
          while ((_WORD)v37);
        }
        return a2;
      case 0xCu:
        long long v103 = *(_OWORD *)&v99[1];
        uint64_t v104 = v99[3];
        uint64_t v102 = &unk_1F0DD6F48;
        if (v99[3]) {
          uint64_t v104 = v99[3] + 6;
        }
        int v100 = &v102;
        uint64_t v101 = &v96;
        DataP = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v102, 0);
        unsigned int v65 = (unsigned __int16)a4;
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v100, (unint64_t)DataP, 1);
        if (*DataP)
        {
          unsigned int v66 = bswap32(*DataP);
          uint64_t v67 = DataP + 1;
          do
          {
            TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v100, (unint64_t)v67, 3);
            unsigned int v68 = bswap32(*v67);
            unint64_t v69 = bswap32(v67[2]);
            int v70 = TcmapTableDataRef::RangeSizePerTuple((TcmapTableDataRef *)bswap32(v67[1]), v68, v69, v65);
            if (v68 <= 0x10FFFF && v70 != 0)
            {
              int v72 = v70 - 1;
              do
              {
                SetUVSForGlyphInMap(a2, a3, (void *)v69, v68, 0, v65);
                if (!v72) {
                  break;
                }
                unint64_t v69 = (v69 + 1);
                --v72;
                BOOL v53 = v68++ > 0x10FFFE;
              }
              while (!v53);
            }
            v67 += 3;
            --v66;
          }
          while (v66);
        }
        if (v98 && *v98 == 3584)
        {
          v105[0] = v98;
          v105[1] = v97;
          unint64_t v60 = (TFormat14UVSTable *)v105;
          unsigned int v61 = a2;
          CFDictionaryRef v62 = a3;
          unsigned int v63 = v65;
LABEL_65:
          TFormat14UVSTable::AddToInverseMap(v60, v61, v62, v63);
        }
        return a2;
      case 0xDu:
        long long v103 = *(_OWORD *)&v99[1];
        uint64_t v104 = v99[3];
        uint64_t v102 = &unk_1F0DD6F48;
        if (v99[3]) {
          uint64_t v104 = v99[3] + 6;
        }
        int v100 = &v102;
        uint64_t v101 = 0;
        uint64_t v73 = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v102, 0);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v100, (unint64_t)v73, 1);
        if (*v73)
        {
          unsigned int v74 = (unsigned __int16)a4;
          unsigned int v75 = bswap32(*v73);
          unint64_t v76 = v73 + 1;
          do
          {
            TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v100, (unint64_t)v76, 3);
            unsigned int v77 = bswap32(*v76);
            int v78 = (void *)bswap32(v76[2]);
            int v79 = TcmapTableDataRef::RangeSizePerFormat13Tuple((TcmapTableDataRef *)bswap32(v76[1]), v77, v78, v74);
            if (v77 <= 0x10FFFF && v79 != 0)
            {
              int v81 = v79 - 1;
              do
              {
                SetUVSForGlyphInMap(a2, a3, v78, v77, 0, v74);
                if (!v81) {
                  break;
                }
                --v81;
                BOOL v53 = v77++ > 0x10FFFE;
              }
              while (!v53);
            }
            v76 += 3;
            --v75;
          }
          while (v75);
        }
        return a2;
      default:
        return result;
    }
    while (1)
    {
      uint64_t v94 = v16;
      if (!v16) {
        break;
      }
      CFDictionaryRef v17 = v90;
      unsigned int v18 = bswap32(v88[v16]) >> 16;
      unsigned int v19 = v95;
      unint64_t v20 = v92;
      if (v18 >= 8) {
        goto LABEL_11;
      }
LABEL_17:
      uint64_t v16 = v94 + 1;
      if (v94 == 255) {
        return v92;
      }
    }
    CFDictionaryRef v17 = v90;
    unsigned int v18 = bswap32(*v88) >> 16;
    unsigned int v19 = v95;
    unint64_t v20 = v92;
LABEL_11:
    uint64_t v21 = v18 >> 1;
    unint64_t v22 = (unsigned __int16 *)(v86 + 2 * v21);
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v103, (unint64_t)v22, 4);
    unsigned int v23 = *v22;
    unsigned int v24 = v22[1];
    unsigned int v25 = v22[2];
    uint64_t v26 = bswap32(v22[3]) >> 17;
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v103, (unint64_t)&v22[v26 + 3], 1);
    if (v24)
    {
      uint64_t v27 = 0;
      uint64_t v28 = v21;
      uint64_t v29 = 0;
      unsigned int v30 = bswap32(v25) >> 16;
      unsigned int v31 = __rev16(v24);
      unsigned int v32 = __rev16(v23) + (v94 << 8);
      if (v31 <= 1) {
        uint64_t v33 = 1;
      }
      else {
        uint64_t v33 = v31;
      }
      unint64_t v34 = v84 + 2 * v28 + 2 * v26;
      do
      {
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v103, v34 + v27, 1);
        SetUVSForGlyphInMap(v20, v17, (void *)(unsigned __int16)(v30 + (bswap32(*(unsigned __int16 *)(v34 + 2 * v29)) >> 16)), (unsigned __int16)(v32 + v29), 0, v19);
        ++v29;
        v27 += 2;
      }
      while (v33 != v29);
    }
    goto LABEL_17;
  }
  return result;
}

uint64_t TcmapUnicodeTable::FillCharacterSet(TFormat14UVSTable **this, __CFCharacterSet *a2, unsigned int a3, TOS2UnicodeRanges *a4)
{
  v75[0] = &unk_1F0DD6FA8;
  memset(&v75[1], 170, 24);
  unint64_t TableEnd = TsfntTable::GetTableEnd((TsfntTable *)this);
  uint64_t v9 = this[8];
  v75[0] = &unk_1F0DD6F78;
  v75[1] = TableEnd;
  v75[2] = v9;
  if (v9) {
    uint64_t v10 = (uint64_t)v9 + 6;
  }
  else {
    uint64_t v10 = 0;
  }
  v75[3] = v10;
  unint64_t v73 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v74 = (TFormat14UVSTable *)0xAAAAAAAAAAAAAAAALL;
  int v72 = &unk_1F0DD6FA8;
  unint64_t v11 = TsfntTable::GetTableEnd((TsfntTable *)this);
  unsigned int v12 = this[8];
  unint64_t v13 = this[9];
  int v72 = &unk_1F0DD7208;
  unint64_t v73 = v11;
  unsigned int v74 = v13;
  uint64_t result = 0;
  if (v12)
  {
    switch(bswap32(*(unsigned __int16 *)v12) >> 16)
    {
      case 4u:
        unint64_t v76 = v75;
        *(void *)&long long v77 = &v72;
        unint64_t v15 = (unsigned __int16 *)(*(uint64_t (**)(void *, void, uint64_t))(v75[0] + 16))(v75, 0, 4);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v76, (unint64_t)v15, 1);
        unsigned int v16 = bswap32(*v15) >> 16;
        if (v16)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *(void *)exception = &unk_1F0DD4440;
          exception[2] = 4;
        }
        CFDictionaryRef v17 = v15 + 4;
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v76, (unint64_t)&v15[(v16 >> 1) + 5], 1);
        uint64_t v66 = (uint64_t)&v15[(v16 >> 1) + 5];
        unint64_t v18 = v66 + 2 * (v16 >> 1);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v76, v18, 1);
        unint64_t v62 = v18;
        unint64_t v19 = v18 + 2 * (v16 >> 1);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v76, v19, v16 >> 1);
        if (v16 < 2)
        {
          unint64_t v20 = &v72;
          goto LABEL_103;
        }
        unsigned int theRange_12 = a3;
        uint64_t v45 = 0;
        CFIndex v46 = 0;
        CFIndex v47 = 0;
        CFIndex v48 = 0;
        unint64_t v69 = a4;
        LODWORD(theRange) = 0;
        unsigned int v49 = v16 >> 1;
        unsigned int v50 = 0;
        if (v16 >> 1 <= 1) {
          uint64_t v51 = 1;
        }
        else {
          uint64_t v51 = v49;
        }
        uint64_t v67 = v51;
        theSet = a2;
        unsigned int v63 = v16 >> 1;
        unsigned int v64 = v17;
        unint64_t v65 = v19;
        unint64_t v52 = v19 + 2 * v49;
        uint64_t v53 = v66;
        break;
      case 6u:
        unint64_t v76 = v75;
        *(void *)&long long v77 = 0;
        unsigned int v30 = (unsigned __int16 *)(*(uint64_t (**)(void *, void, uint64_t))(v75[0] + 16))(v75, 0, 4);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v76, (unint64_t)v30, 1);
        unsigned int v31 = *v30;
        unsigned int v32 = v30 + 2;
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v76, (unint64_t)(v30 + 1), 1);
        unsigned int v33 = v30[1];
        uint64_t v34 = __rev16(v33);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v76, (unint64_t)(v30 + 2), v34);
        if (!v33) {
          return 1;
        }
        CFIndex v35 = 0;
        CFIndex v36 = 0;
        unsigned int v37 = __rev16(v31);
        do
        {
          ++v32;
          while (a3 > bswap32(*(v32 - 1)) >> 16)
          {
            if (*(v32 - 1))
            {
              if (!v36) {
                CFIndex v35 = (unsigned __int16)v37;
              }
              ++v36;
              break;
            }
            if (v36 < 1) {
              break;
            }
            if (a2)
            {
              v85.unsigned int location = v35;
              v85.int length = v36;
              CFCharacterSetAddCharactersInRange(a2, v85);
            }
            ++v32;
            v86.unsigned int location = v35;
            v86.int length = v36;
            TOS2UnicodeRanges::SetRangeBit(a4, v86);
            CFIndex v36 = 0;
            LODWORD(v34) = v34 - 1;
            ++v37;
            if (!(_WORD)v34) {
              return 1;
            }
          }
          LODWORD(v34) = v34 - 1;
          ++v37;
        }
        while ((_WORD)v34);
        if (v36 >= 1)
        {
          if (a2)
          {
            v87.unsigned int location = v35;
            v87.int length = v36;
            CFCharacterSetAddCharactersInRange(a2, v87);
          }
          v88.unsigned int location = v35;
          v88.int length = v36;
          TOS2UnicodeRanges::SetRangeBit(a4, v88);
        }
        return 1;
      case 0xCu:
        long long v77 = *(_OWORD *)&v75[1];
        uint64_t v78 = v75[3];
        unint64_t v76 = &unk_1F0DD6F48;
        if (v75[3]) {
          uint64_t v78 = v75[3] + 6;
        }
        int v79 = &v76;
        unsigned int v80 = &v72;
        DataP = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v76, 0);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v79, (unint64_t)DataP, 1);
        if (*DataP)
        {
          unsigned int v22 = bswap32(*DataP);
          unsigned int v23 = DataP + 1;
          do
          {
            TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v79, (unint64_t)v23, 3);
            CFIndex v24 = bswap32(*v23);
            unsigned int v25 = TcmapTableDataRef::RangeSizePerTuple((TcmapTableDataRef *)bswap32(v23[1]), v24, bswap32(v23[2]), a3);
            if (v25)
            {
              CFIndex v26 = v25;
              if (a2)
              {
                if (WORD1(v24) <= 0x10u && (v24 + v25 - 1) >> 16 <= 0x10)
                {
                  v83.unsigned int location = v24;
                  v83.int length = v25;
                  CFCharacterSetAddCharactersInRange(a2, v83);
                }
              }
              v84.unsigned int location = v24;
              v84.int length = v26;
              TOS2UnicodeRanges::SetRangeBit(a4, v84);
            }
            v23 += 3;
            --v22;
          }
          while (v22);
        }
        uint64_t v28 = v74;
        if (v74 && *(_WORD *)v74 == 3584)
        {
          uint64_t v29 = (__CFCharacterSet *)v73;
LABEL_106:
          TFormat14UVSTable::AddCharactersToSet(v28, v29, a2, a4);
        }
        return 1;
      case 0xDu:
        long long v77 = *(_OWORD *)&v75[1];
        uint64_t v78 = v75[3];
        unint64_t v76 = &unk_1F0DD6F48;
        if (v75[3]) {
          uint64_t v78 = v75[3] + 6;
        }
        int v79 = &v76;
        unsigned int v80 = 0;
        CFIndex v38 = (unsigned int *)TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)&v76, 0);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v79, (unint64_t)v38, 1);
        if (*v38)
        {
          unsigned int v39 = bswap32(*v38);
          unsigned int v40 = v38 + 1;
          do
          {
            TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(&v79, (unint64_t)v40, 3);
            CFIndex v41 = bswap32(*v40);
            unsigned int v42 = TcmapTableDataRef::RangeSizePerFormat13Tuple((TcmapTableDataRef *)bswap32(v40[1]), v41, bswap32(v40[2]), a3);
            if (v42)
            {
              CFIndex v43 = v42;
              if (a2)
              {
                if (WORD1(v41) <= 0x10u && (v41 + v42 - 1) >> 16 <= 0x10)
                {
                  v89.unsigned int location = v41;
                  v89.int length = v42;
                  CFCharacterSetAddCharactersInRange(a2, v89);
                }
              }
              v90.unsigned int location = v41;
              v90.int length = v43;
              TOS2UnicodeRanges::SetRangeBit(a4, v90);
            }
            v40 += 3;
            --v39;
          }
          while (v39);
        }
        return 1;
      default:
        return result;
    }
    while (1)
    {
      unsigned int v54 = v50;
      unsigned int v55 = bswap32(*(unsigned __int16 *)(v53 + 2 * v45));
      unsigned int v50 = bswap32(v17[v45]) >> 16;
      if (theRange > HIWORD(v55) || v54 > v50)
      {
LABEL_102:
        unint64_t v20 = (void **)v77;
        if (!(void)v77) {
          return 1;
        }
LABEL_103:
        uint64_t v28 = (TFormat14UVSTable *)v20[2];
        if (v28 && *(_WORD *)v28 == 3584)
        {
          uint64_t v29 = (__CFCharacterSet *)v20[1];
          goto LABEL_106;
        }
        return 1;
      }
      CFIndex theRange = HIWORD(v55);
      if ((v50 & theRange) == 0xFFFF)
      {
        v82[0] = v50;
        __int16 v81 = -21846;
        LODWORD(v79) = 1;
        if (v81)
        {
          if (a2)
          {
            v91.unsigned int location = v46;
            v91.int length = v47;
            CFCharacterSetAddCharactersInRange(a2, v91);
          }
          v92.unsigned int location = v46;
          v92.int length = v47;
          TOS2UnicodeRanges::SetRangeBit(a4, v92);
        }
        unsigned int v50 = 0xFFFF;
        goto LABEL_101;
      }
      if (!*(_WORD *)(v65 + 2 * v45))
      {
        if (theRange <= v50)
        {
          CFIndex v47 = v50 - theRange + 1;
          if (a2)
          {
            v93.unsigned int location = HIWORD(v55);
            v93.int length = v50 - theRange + 1;
            CFCharacterSetAddCharactersInRange(a2, v93);
          }
          v94.unsigned int location = theRange;
          v94.int length = v50 - theRange + 1;
          TOS2UnicodeRanges::SetRangeBit(a4, v94);
          int v59 = -(theRange + (bswap32(*(unsigned __int16 *)(v62 + 2 * v45)) >> 16));
          CFIndex v46 = theRange + (unsigned __int16)v59;
          if (v46 <= v50)
          {
            if (a2)
            {
              v99.unsigned int location = theRange + (unsigned __int16)v59;
              v99.int length = 1;
              CFCharacterSetRemoveCharactersInRange(a2, v99);
            }
            CFIndex v47 = 1;
          }
          else
          {
            CFIndex v46 = theRange;
          }
        }
        goto LABEL_100;
      }
      CFIndex v57 = HIWORD(v55);
      if (theRange <= v50) {
        break;
      }
      CFIndex v58 = v48;
LABEL_92:
      if (v58 > 0)
      {
        a2 = theSet;
        a4 = v69;
        uint64_t v53 = v66;
        if (theSet)
        {
          v97.unsigned int location = v46;
          v97.int length = v58;
          CFCharacterSetAddCharactersInRange(theSet, v97);
        }
        v98.unsigned int location = v46;
        v98.int length = v58;
        TOS2UnicodeRanges::SetRangeBit(v69, v98);
        CFIndex v48 = 0;
        CFIndex v47 = v58;
        CFDictionaryRef v17 = v64;
        goto LABEL_101;
      }
      CFIndex v48 = v58;
      a2 = theSet;
      a4 = v69;
      CFDictionaryRef v17 = v64;
LABEL_100:
      uint64_t v53 = v66;
LABEL_101:
      if (++v45 == v67) {
        goto LABEL_102;
      }
    }
    int v60 = v45 - v63 - theRange + (__rev16(*(unsigned __int16 *)(v65 + 2 * v45)) >> 1);
    while (1)
    {
      TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v76, v52 + 2 * (unsigned __int16)(v60 + v57), 1);
      if (theRange_12 > bswap32(*(unsigned __int16 *)(v52 + 2 * (unsigned __int16)(v60 + v57))) >> 16)
      {
        if (*(_WORD *)(v52 + 2 * (unsigned __int16)(v60 + v57)))
        {
          if (!v48) {
            CFIndex v46 = v57;
          }
          CFIndex v58 = v48 + 1;
          goto LABEL_90;
        }
        if (v48 >= 1)
        {
          if (theSet)
          {
            v95.unsigned int location = v46;
            v95.int length = v48;
            CFCharacterSetAddCharactersInRange(theSet, v95);
          }
          v96.unsigned int location = v46;
          v96.int length = v48;
          TOS2UnicodeRanges::SetRangeBit(v69, v96);
          CFIndex v58 = 0;
          goto LABEL_91;
        }
      }
      CFIndex v58 = v48;
LABEL_90:
      CFIndex v48 = v47;
LABEL_91:
      ++v57;
      CFIndex v47 = v48;
      CFIndex v48 = v58;
      if (v50 + 1 == v57) {
        goto LABEL_92;
      }
    }
  }
  return result;
}

uint64_t GetCharacterForGlyphUsingMap(unsigned int *a1, CFDictionaryRef theDict, unsigned int a3, void *key, unsigned __int16 *a5, unint64_t a6)
{
  if (key >= a3) {
    return 0;
  }
  uint64_t v9 = key;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)key);
  if (!Value)
  {
    unsigned int v15 = a1[v9];
    if (a5 && a6)
    {
      if (!HIWORD(v15))
      {
        *a5 = v15;
        return 1;
      }
      if (a6 < 2 || HIWORD(v15) > 0x10u)
      {
        a6 = 0;
        *a5 = -1;
        return a6;
      }
      *a5 = (v15 >> 10) - 10304;
      a5[1] = v15 & 0x3FF | 0xDC00;
    }
    else if (v15 - 0x10000 >= 0x100000)
    {
      return v15 < 0x10000;
    }
    return 2;
  }
  CFArrayRef v11 = Value;
  if (CFArrayGetCount(Value) < 1) {
    return 0;
  }
  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v11, 0);
  unint64_t Length = CFStringGetLength(ValueAtIndex);
  if (Length < a6) {
    a6 = Length;
  }
  v16.unsigned int location = 0;
  v16.int length = a6;
  CFStringGetCharacters(ValueAtIndex, v16, a5);
  return a6;
}

void TUVSTable::~TUVSTable(TUVSTable *this)
{
}

void TFormat14UVSTable::AddCharactersToSet(TFormat14UVSTable *this, __CFCharacterSet *a2, CFMutableCharacterSetRef theSet, TOS2UnicodeRanges *a4)
{
  uint64_t v4 = (TFormat14UVSTable *)((char *)this + 10);
  if ((TFormat14UVSTable *)((char *)this + 10) <= a2)
  {
    uint64_t v7 = bswap32(*(_DWORD *)((char *)this + 6));
    unint64_t v8 = (unint64_t)v4 + 11 * v7;
    if (v8 < (unint64_t)v4 || v8 > (unint64_t)a2)
    {
      if ((TFormat14UVSTable *)((char *)this + 21) > a2) {
        return;
      }
      uint64_t v7 = ((a2 - v4) / 0xBuLL);
      if (!((a2 - v4) / 0xBuLL)) {
        return;
      }
    }
    else if (!v7)
    {
      return;
    }
    uint64_t v10 = (unsigned __int8 *)this + 12;
    do
    {
      unsigned int v11 = (*(v10 - 2) << 16) | (*(v10 - 1) << 8);
      if (v11 >> 9 >= 0x7F)
      {
        unsigned int v12 = v11 | *v10;
        if (v12 >> 4 < 0xFE1 || v12 - 917760 <= 0xEF)
        {
          if (theSet)
          {
            v14.unsigned int location = v11 | *v10;
            v14.int length = 1;
            CFCharacterSetAddCharactersInRange(theSet, v14);
          }
          if (a4)
          {
            unsigned int RangeBit = TOS2UnicodeRanges::GetRangeBit(a4, v12);
            if (RangeBit != -1) {
              *((_DWORD *)a4 + (RangeBit >> 5) + 2) |= 1 << RangeBit;
            }
          }
        }
      }
      v10 += 11;
      --v7;
    }
    while (v7);
  }
}

void TFormat14UVSTable::AddToInverseMap(TFormat14UVSTable *this, unsigned int *a2, CFDictionaryRef theDict, unsigned int a4)
{
  uint64_t v5 = *(void *)this;
  unint64_t v4 = *((void *)this + 1);
  unint64_t v6 = *(void *)this + 10;
  if (v6 <= v4)
  {
    uint64_t v11 = bswap32(*(_DWORD *)(v5 + 6));
    unint64_t v12 = v6 + 11 * v11;
    if (v12 < v6 || v12 > v4)
    {
      if (v5 + 21 <= v4)
      {
        uint64_t v11 = ((v4 - v6) / 0xB);
        if (((v4 - v6) / 0xB)) {
          goto LABEL_11;
        }
      }
    }
    else if (v11)
    {
LABEL_11:
      uint64_t v14 = 0;
      while (1)
      {
        unsigned int v15 = (unsigned __int8 *)(v6 + 11 * v14);
        unsigned int v16 = *(_DWORD *)(v15 + 7);
        if (v16)
        {
          uint64_t v17 = bswap32(v16);
          unint64_t v18 = *((void *)this + 1);
          unint64_t v19 = (unsigned int *)(*(void *)this + v17);
          unint64_t v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) <= v18)
          {
            unint64_t v21 = bswap32(*v19);
            unint64_t v22 = (unint64_t)&v20[v21] + v21;
            if (v22 >= (unint64_t)v20 && v22 <= v18) {
              goto LABEL_21;
            }
            if ((unint64_t)v19 + 9 <= v18) {
              break;
            }
          }
        }
LABEL_24:
        if (++v14 == v11) {
          return;
        }
      }
      unint64_t v21 = (v18 - (unint64_t)v20) / 5;
LABEL_21:
      if (v21)
      {
        CFIndex v24 = (unsigned __int16 *)(*(void *)this + v17 + 7);
        do
        {
          SetUVSForGlyphInMap(a2, theDict, (void *)(bswap32(*v24) >> 16), (*((unsigned __int8 *)v24 - 3) << 16) | (*((unsigned __int8 *)v24 - 2) << 8) | *((unsigned __int8 *)v24 - 1), (*v15 << 16) | (v15[1] << 8) | v15[2], a4);
          CFIndex v24 = (unsigned __int16 *)((char *)v24 + 5);
          LODWORD(v21) = v21 - 1;
        }
        while (v21);
      }
      goto LABEL_24;
    }
  }
}

void TcmapEncodingTable::~TcmapEncodingTable(TcmapEncodingTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

void TFormat4cmapTable::~TFormat4cmapTable(TFormat4cmapTable *this)
{
}

uint64_t TFormat4cmapTable::DecomposeMacCmap(TFormat4cmapTable *this, unsigned __int8 *a2, int a3, unint64_t *a4, unsigned __int16 *a5, unint64_t *a6)
{
  uint64_t v11 = (void *)((char *)this + 8);
  unint64_t v12 = (unsigned __int16 *)(*(uint64_t (**)(void, void, uint64_t))(**((void **)this + 1) + 16))(*((void *)this + 1), 0, 4);
  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v11, (unint64_t)v12, 1);
  unsigned int v13 = bswap32(*v12) >> 16;
  if (v13)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  unint64_t v49 = *a6;
  *a6 = 0;
  LODWORD(v14) = a2;
  if (v13 >= 2)
  {
    unint64_t v44 = v11;
    unsigned int v15 = 0;
    unsigned int v16 = 0;
    unsigned int v17 = 0;
    unsigned int v46 = 0;
    unsigned int v18 = v13 >> 1;
    CFIndex v48 = &a2[a3];
    unint64_t v19 = 2 * (v13 >> 1);
    CFIndex v41 = v12 + 4;
    unsigned int v42 = a2;
    uint64_t v40 = (uint64_t)&v12[v19 / 2 + 5];
    unint64_t v36 = v40 + v19;
    unint64_t v38 = v40 + v19 + v19;
    unint64_t v47 = v38 + v19;
    unsigned int v39 = v18;
    int v37 = -v18;
    uint64_t v14 = a2;
    do
    {
      unsigned int v43 = v16;
      TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v44, v40 + 2 * v15, 1);
      unsigned int v20 = bswap32(*(unsigned __int16 *)(v40 + 2 * v15));
      TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v44, (unint64_t)&v41[v15], 1);
      unsigned int v21 = bswap32(v41[v15]) >> 16;
      if (v46 > HIWORD(v20) || v17 > v21) {
        break;
      }
      unsigned int v23 = v21;
      unsigned int v24 = HIWORD(v20);
      unsigned int v25 = (_WORD *)(v38 + 2 * v15);
      TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v44, (unint64_t)v25, 1);
      unsigned int v46 = HIWORD(v20);
      unsigned int v45 = v15;
      if (*v25)
      {
        unsigned int v17 = v23;
        if (v24 <= v23 && *a6 < v49 && v14 < v48)
        {
          unsigned int v28 = v37 + v43 + (__rev16((unsigned __int16)*v25) >> 1);
          unsigned int v29 = v24;
          do
          {
            TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v44, v47 + 2 * (unsigned __int16)v28, 1);
            unsigned int v30 = *(unsigned __int16 *)(v47 + 2 * (unsigned __int16)v28);
            if (a4) {
              *a4++ = v14 - v42;
            }
            if (a5) {
              *a5++ = bswap32(v30) >> 16;
            }
            if ((unsigned __int16)v29 < 0x100u)
            {
              *v14++ = v29;
            }
            else
            {
              *(_WORD *)uint64_t v14 = bswap32(v29) >> 16;
              v14 += 2;
            }
            unint64_t v31 = *a6 + 1;
            *a6 = v31;
            if (v29 >= v23) {
              break;
            }
            if (v31 >= v49) {
              break;
            }
            ++v29;
            LOWORD(v28) = v28 + 1;
          }
          while (v14 < v48);
        }
      }
      else
      {
        unsigned int v17 = v23;
        if (v24 <= v23 && *a6 < v49 && v14 < v48)
        {
          unsigned int v32 = (unsigned __int16 *)(v36 + 2 * v15);
          do
          {
            if (a4) {
              *a4++ = v14 - v42;
            }
            if (a5)
            {
              TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v44, (unint64_t)v32, 1);
              *a5++ = v24 + (bswap32(*v32) >> 16);
            }
            if ((unsigned __int16)v24 < 0x100u)
            {
              *v14++ = v24;
            }
            else
            {
              *(_WORD *)uint64_t v14 = bswap32(v24) >> 16;
              v14 += 2;
            }
            unint64_t v33 = *a6 + 1;
            *a6 = v33;
            if (v24 >= v23) {
              break;
            }
            if (v33 >= v49) {
              break;
            }
            ++v24;
          }
          while (v14 < v48);
        }
      }
      unsigned int v16 = v45 + 1;
      unsigned int v15 = (unsigned __int16)(v45 + 1);
    }
    while (v15 < v39);
    LODWORD(a2) = v42;
  }
  return (v14 - a2);
}

void TFormat4_816cmapTable::~TFormat4_816cmapTable(TFormat4_816cmapTable *this)
{
}

BOOL TFormat6cmapTable::VerifyCMAP(TFormat6cmapTable *this)
{
  uint64_t v2 = (*(uint64_t (**)(void, void, uint64_t))(**(void **)this + 16))(*(void *)this, 0, 4);
  unsigned int v3 = *(unsigned __int16 *)(v2 - 4);
  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(this, v2 + 2, 1);
  if (*(_WORD *)(v2 + 2)
    && (unint64_t v4 = v2 + 2 * __rev16(*(unsigned __int16 *)(v2 + 2)) + 4, v2 + (unint64_t)__rev16(v3) - 6 >= v4))
  {
    return v4 <= *(void *)(*(void *)this + 8);
  }
  else
  {
    return 0;
  }
}

uint64_t TcmapEncodingTable::Map<unsigned short>(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t a4, unsigned int *a5)
{
  v89[0] = &unk_1F0DD6FA8;
  memset(&v89[1], 170, 24);
  unint64_t TableEnd = TsfntTable::GetTableEnd((TsfntTable *)a1);
  uint64_t v11 = *(unsigned __int16 **)(a1 + 64);
  v89[0] = &unk_1F0DD6F78;
  v89[1] = TableEnd;
  unint64_t v12 = v11 + 3;
  if (!v11) {
    unint64_t v12 = 0;
  }
  v89[2] = v11;
  v89[3] = v12;
  if (!v11)
  {
LABEL_8:
    uint64_t v16 = *a5;
    if (v16)
    {
      size_t v15 = 2 * v16;
LABEL_10:
      bzero((void *)a4, v15);
    }
LABEL_11:
    uint64_t v14 = 0;
    *a5 = 0;
    return v14;
  }
  switch(bswap32(*v11) >> 16)
  {
    case 0u:
      uint64_t DataP = TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)v89, 0);
      uint64_t v14 = *a5;
      if ((unint64_t)(DataP + 256) <= v89[1])
      {
        if (v14 > a3)
        {
          *a5 = a3;
          uint64_t v14 = a3;
        }
        if (v14)
        {
          uint64_t v26 = (*(uint64_t (**)(void *, void, uint64_t))(v89[0] + 16))(v89, 0, 4);
          uint64_t v27 = *a5;
          if (v27)
          {
            uint64_t v28 = 0;
            uint64_t v29 = *a2;
            unsigned int v30 = v14;
            do
            {
              unsigned int v31 = *(unsigned __int8 *)(v26 + *(unsigned __int8 *)(v29 + v28));
              unsigned int v32 = (unsigned __int16)v28;
              if ((int)v14 < (unsigned __int16)v28) {
                unsigned int v32 = v14;
              }
              *(_WORD *)(a4 + 2 * v28) = v31;
              if (v31) {
                uint64_t v14 = v14;
              }
              else {
                uint64_t v14 = v32;
              }
              unsigned int v30 = (__PAIR64__(v30, v31) - 1) >> 32;
              ++v28;
            }
            while (v27 != v28);
          }
          else
          {
            unsigned int v30 = v14;
          }
        }
        else
        {
          unsigned int v30 = 0;
        }
        goto LABEL_148;
      }
      if (!v14) {
        goto LABEL_11;
      }
      size_t v15 = 2 * v14;
      goto LABEL_10;
    case 2u:
      CFRange v91 = v89;
      uint64_t v92 = 0;
      CFRange v90 = &unk_1F0DFE240;
      if (*(_WORD *)(a1 + 72) != 1)
      {
        unint64_t v19 = TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)v89, 0);
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v91, v19, 256);
        unint64_t v87 = v19 + 512;
        unsigned int v20 = (unsigned __int8 *)*a2;
        uint64_t v21 = *a5;
        unint64_t v22 = a4 + 2 * v21;
        goto LABEL_40;
      }
      int v18 = *(__int16 *)(a1 + 74);
      unint64_t v19 = TcmapTableFileData16::GetDataP((TcmapTableFileData16 *)v89, 0);
      TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v91, v19, 256);
      unint64_t v87 = v19 + 512;
      unsigned int v20 = (unsigned __int8 *)*a2;
      uint64_t v21 = *a5;
      unint64_t v22 = a4 + 2 * v21;
      if (v18 > 2)
      {
        if (v18 == 3)
        {
          char v83 = 0;
          unint64_t v33 = &gKoreanHighBytes;
          goto LABEL_64;
        }
        if (v18 == 25) {
          goto LABEL_43;
        }
LABEL_40:
        unint64_t v33 = 0;
        char v83 = 1;
        goto LABEL_64;
      }
      if (v18 == 1)
      {
        char v83 = 0;
        unint64_t v33 = &gJapaneseHighBytes;
        goto LABEL_64;
      }
      if (v18 != 2) {
        goto LABEL_40;
      }
LABEL_43:
      char v83 = 0;
      unint64_t v33 = &gSimplifiedChineseHighBytes;
LABEL_64:
      int v93 = v21;
      unsigned int v94 = v21;
      unint64_t v84 = a4;
      unint64_t v86 = v22;
      uint64_t v82 = v21;
      if (v21)
      {
        __int16 v81 = v33;
        unsigned int v41 = 0;
        while (1)
        {
          if ((int)v20 - *(_DWORD *)a2 >= a3)
          {
            --v94;
            if (v93 > (unsigned __int16)v41) {
              int v93 = (unsigned __int16)v41;
            }
            break;
          }
          unsigned int v42 = a5;
          unint64_t v44 = v20 + 1;
          uint64_t v43 = *v20;
          unsigned int v45 = (unsigned __int16 *)(v87 + ((bswap32(*(unsigned __int16 *)(v19 + 2 * v43)) >> 16) & 0xFFFE));
          TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v91, (unint64_t)v45, 4);
          unsigned int v46 = bswap32(*v45) >> 16;
          unsigned int v47 = bswap32(v45[1]) >> 16;
          if (*(_WORD *)(v19 + 2 * v43))
          {
            if ((int)v44 - *(_DWORD *)a2 >= a3)
            {
              a5 = v42;
              goto LABEL_93;
            }
            LODWORD(v43) = *v44;
            unsigned int v48 = v47 + v46;
            if (v46 > v43 || v48 <= v43) {
              goto LABEL_73;
            }
            unint64_t v44 = v20 + 2;
          }
          else
          {
            unsigned int v50 = v47 + v46;
            if (v46 > v43 || v50 <= v43)
            {
              *(_WORD *)a4 = 0;
              --v94;
              if (v93 > (unsigned __int16)v41) {
                int v93 = (unsigned __int16)v41;
              }
              goto LABEL_87;
            }
            if ((v83 & 1) == 0 && v81[v43])
            {
              unint64_t v44 = v20 + 2;
LABEL_73:
              *(_WORD *)a4 = 0;
              --v94;
              a5 = v42;
              if (v93 > (unsigned __int16)v41) {
                int v93 = (unsigned __int16)v41;
              }
              goto LABEL_88;
            }
          }
          unsigned __int16 v52 = v43 - v46;
          unsigned int v54 = v45[3];
          uint64_t v53 = v45 + 3;
          unsigned int v55 = *(v53 - 1);
          uint64_t v56 = (unsigned __int16 *)((char *)&v53[v52] + ((bswap32(v54) >> 16) & 0xFFFE));
          TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(&v91, (unint64_t)v56, 1);
          if (!*v56) {
            goto LABEL_73;
          }
          *(_WORD *)a4 = __rev16((unsigned __int16)*v56) + (bswap32(v55) >> 16);
LABEL_87:
          a5 = v42;
LABEL_88:
          a4 += 2;
          ++v41;
          unsigned int v20 = v44;
          if (v41 >= *a5) {
            goto LABEL_93;
          }
        }
      }
      unint64_t v44 = v20;
LABEL_93:
      if (a4 < v86)
      {
        unint64_t v57 = v84 + 2 * v82;
        if (v57 <= a4 + 2) {
          unint64_t v57 = a4 + 2;
        }
        bzero((void *)a4, ((v57 + ~a4) & 0xFFFFFFFFFFFFFFFELL) + 2);
      }
      *a2 = (uint64_t)v44;
      uint64_t v14 = v93;
      *a5 = v94;
      return v14;
    case 4u:
      int v23 = *(unsigned __int16 *)(a1 + 72);
      if (v23 == 3) {
        goto LABEL_21;
      }
      if (v23 != 1)
      {
        if (!*(_WORD *)(a1 + 72))
        {
LABEL_21:
          CFRange v90 = v89;
          CFRange v91 = 0;
          goto LABEL_26;
        }
        goto LABEL_50;
      }
      int v34 = *(unsigned __int16 *)(a1 + 74);
      if (v34 > 0x19 || ((1 << v34) & 0x200000E) == 0)
      {
LABEL_50:
        CFRange v91 = v89;
        uint64_t v92 = 0;
        CFRange v90 = &unk_1F0DD6F00;
        return TFormat4cmapTable::Map<unsigned short>((TFormat4cmapTable *)&v90, a2, a3, (_WORD *)a4, a5);
      }
      CFRange v91 = v89;
      uint64_t v92 = 0;
      CFRange v90 = &unk_1F0DD71C8;
      uint64_t v35 = *a5;
      if (v34 > 2)
      {
        if (v34 == 3)
        {
          unint64_t v36 = &gKoreanHighBytes;
          goto LABEL_109;
        }
        if (v34 == 25)
        {
LABEL_49:
          unint64_t v36 = &gSimplifiedChineseHighBytes;
LABEL_109:
          unint64_t v85 = a4;
          unint64_t v88 = a4 + 2 * v35;
          int v59 = a5;
          if (v35)
          {
            unsigned int v60 = 0;
            unint64_t v61 = a4;
            unsigned int v62 = 0;
            uint64_t v63 = *a2;
            uint64_t v14 = v35;
            do
            {
              unsigned int v64 = (unsigned __int8 *)*a2;
              if (*a2 - v63 >= (unint64_t)a3) {
                break;
              }
              *a2 = (uint64_t)(v64 + 1);
              uint64_t v65 = *v64;
              if (v36[v65])
              {
                if ((unint64_t)&v64[-v63 + 1] >= a3)
                {
                  *a2 = (uint64_t)v64;
                  break;
                }
                *a2 = (uint64_t)(v64 + 2);
                LODWORD(v65) = v64[1] | (v65 << 8);
              }
              int v66 = TFormat4cmapTable::ComputeIndex((TFormat4cmapTable *)&v90, v65);
              unsigned int v67 = *v59;
              if (v14 == *v59) {
                unsigned int v68 = v60;
              }
              else {
                unsigned int v68 = v14;
              }
              if (v66)
              {
                ++v62;
                uint64_t v14 = v14;
              }
              else
              {
                uint64_t v14 = v68;
              }
              *(_WORD *)unint64_t v61 = v66;
              v61 += 2;
              ++v60;
            }
            while (v60 < v67);
          }
          else
          {
            unint64_t v61 = a4;
            unsigned int v62 = 0;
            uint64_t v14 = 0;
          }
          if (v61 < v88)
          {
            unint64_t v69 = v85 + 2 * v35;
            if (v69 <= v61 + 2) {
              unint64_t v69 = v61 + 2;
            }
            bzero((void *)v61, ((v69 + ~v61) & 0xFFFFFFFFFFFFFFFELL) + 2);
          }
          *int v59 = v62;
          return v14;
        }
      }
      else
      {
        if (v34 == 1)
        {
          unint64_t v36 = &gJapaneseHighBytes;
          goto LABEL_109;
        }
        if (v34 == 2) {
          goto LABEL_49;
        }
      }
      unint64_t v36 = 0;
      goto LABEL_109;
    case 6u:
      int v25 = *(unsigned __int16 *)(a1 + 72);
      if (v25 == 3) {
        goto LABEL_25;
      }
      if (v25 != 1)
      {
        if (!*(_WORD *)(a1 + 72))
        {
LABEL_25:
          CFRange v90 = v89;
          CFRange v91 = 0;
LABEL_26:
          uint64_t v14 = v24;
          *a2 += 2 * *a5;
          return v14;
        }
        goto LABEL_58;
      }
      int v38 = *(unsigned __int16 *)(a1 + 74);
      if (v38 > 0x19 || ((1 << v38) & 0x200000E) == 0)
      {
LABEL_58:
        CFRange v90 = v89;
        CFRange v91 = 0;
        return TFormat6cmapTable::Map<unsigned short>((TFormat6cmapTable *)&v90, a2, a3, (_WORD *)a4, a5);
      }
      CFRange v90 = v89;
      CFRange v91 = 0;
      if (!TFormat6cmapTable::VerifyCMAP((TFormat6cmapTable *)&v90))
      {
        uint64_t v58 = *a5;
        if (v58) {
          bzero((void *)a4, 2 * v58);
        }
        goto LABEL_147;
      }
      unsigned int v39 = (unsigned __int16 *)(*(uint64_t (**)(void *, void, uint64_t))(v89[0] + 16))(v89, 0, 4);
      if (v38 > 2)
      {
        if (v38 != 3)
        {
          if (v38 == 25) {
            goto LABEL_57;
          }
LABEL_106:
          uint64_t v40 = 0;
          goto LABEL_132;
        }
        uint64_t v40 = &gKoreanHighBytes;
      }
      else
      {
        if (v38 != 1)
        {
          if (v38 == 2)
          {
LABEL_57:
            uint64_t v40 = &gSimplifiedChineseHighBytes;
            goto LABEL_132;
          }
          goto LABEL_106;
        }
        uint64_t v40 = &gJapaneseHighBytes;
      }
LABEL_132:
      uint64_t v70 = *a5;
      if (v70)
      {
        uint64_t v71 = 0;
        unsigned int v30 = 0;
        uint64_t v72 = *a2;
        unsigned int v73 = bswap32(*v39) >> 16;
        unsigned int v74 = v39 + 2;
        unsigned int v75 = bswap32(v39[1]) >> 16;
        uint64_t v14 = *a5;
        unint64_t v76 = (unsigned __int8 *)*a2;
        while (1)
        {
          if ((unint64_t)&v76[-v72] >= a3) {
            goto LABEL_148;
          }
          long long v77 = v76 + 1;
          *a2 = (uint64_t)(v76 + 1);
          uint64_t v78 = *v76;
          if (v40[v78])
          {
            if ((unint64_t)&v77[-v72] >= a3)
            {
              *a2 = (uint64_t)v76;
              goto LABEL_148;
            }
            long long v77 = v76 + 2;
            *a2 = (uint64_t)(v76 + 2);
            LOWORD(v78) = v76[1] | (unsigned __int16)((_WORD)v78 << 8);
          }
          unint64_t v76 = v77;
          unsigned __int16 v79 = v78 - v73;
          if (v75 <= v79) {
            break;
          }
          unsigned int v80 = v74[v79];
          if (!v80) {
            goto LABEL_142;
          }
          LOWORD(v80) = __rev16(v80);
          ++v30;
LABEL_145:
          *(_WORD *)(a4 + 2 * v71++) = v80;
          if (v70 == v71) {
            goto LABEL_148;
          }
        }
        LOWORD(v80) = 0;
LABEL_142:
        if (v14 == v70) {
          uint64_t v14 = v71;
        }
        else {
          uint64_t v14 = v14;
        }
        goto LABEL_145;
      }
LABEL_147:
      unsigned int v30 = 0;
      uint64_t v14 = 0;
LABEL_148:
      *a5 = v30;
      return v14;
    default:
      goto LABEL_8;
  }
}

void TmaxpTable::~TmaxpTable(TmaxpTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t ThmtxTable::ThmtxTable(uint64_t a1, const TSFNTFont *a2, uint64_t a3)
{
  TsfntTable::TsfntTable((TsfntTable *)a1, a2, 1751672161);
  *unint64_t v6 = &unk_1F0DD6EB0;
  if ((a3 & 0xFF00000000) == 0) {
    LODWORD(a3) = (*(uint64_t (**)(const TSFNTFont *))(*(void *)a2 + 168))(a2);
  }
  *(_DWORD *)(a1 + 56) = a3;
  uint64_t Hhea = ThmtxTable::GetHhea((ThmtxTable *)a1);
  if (Hhea) {
    unsigned int v8 = bswap32(*(unsigned __int16 *)(Hhea + 34)) >> 16;
  }
  else {
    unsigned int v8 = 0;
  }
  *(_DWORD *)(a1 + 60) = a3 - v8;
  *(_DWORD *)(a1 + 64) = TSFNTFont::GetTableOffset(a2, 1752003704, (unint64_t *)(a1 + 72));
  return a1;
}

void sub_1B52EE1B0(_Unwind_Exception *a1)
{
  TDataReference::~TDataReference(v1);
  _Unwind_Resume(a1);
}

uint64_t ThmtxTable::ThmtxTable(uint64_t a1, const TSFNTFont *a2, uint64_t a3, int a4, uint64_t a5)
{
  int v7 = a3;
  TsfntTable::TsfntTable((TsfntTable *)a1, a2, a3);
  *uint64_t v10 = &unk_1F0DD6EB0;
  if ((a5 & 0xFF00000000) == 0) {
    LODWORD(a5) = (*(uint64_t (**)(const TSFNTFont *))(*(void *)a2 + 168))(a2);
  }
  *(_DWORD *)(a1 + 56) = a5;
  uint64_t Hhea = ThmtxTable::GetHhea((ThmtxTable *)a1);
  if (Hhea) {
    unsigned int v12 = bswap32(*(unsigned __int16 *)(Hhea + 34)) >> 16;
  }
  else {
    unsigned int v12 = 0;
  }
  *(_DWORD *)(a1 + 60) = a5 - v12;
  if (v7 == 1986553185 && ThmtxTable::GetHhea((ThmtxTable *)a1) && TSFNTFont::HasBadvmtxTables(a2))
  {
    size_t v15 = &unk_1F0DD4218;
    uint64_t v16 = 0;
    long long v17 = 0uLL;
    if (&v15 != (void **)a1)
    {
      TDataReference::DucRefCount((TDataReference *)a1);
      uint64_t v13 = v16;
      uint64_t v16 = 0;
      *(void *)(a1 + 8) = v13;
      *(_OWORD *)(a1 + 16) = v17;
    }
    TDataReference::~TDataReference((TDataReference *)&v15);
  }
  else
  {
    *(_DWORD *)(a1 + 64) = TSFNTFont::GetTableOffset(a2, a4, (unint64_t *)(a1 + 72));
  }
  return a1;
}

void sub_1B52EE320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TDataReference::~TDataReference((TDataReference *)&a9);
  TDataReference::~TDataReference(v9);
  _Unwind_Resume(a1);
}

void ThmtxTable::~ThmtxTable(ThmtxTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t ThmtxTable::GetAdvance(ThmtxTable *this, unsigned int a2)
{
  TMetricsTableContext::TMetricsTableContext((TMetricsTableContext *)v5, this);
  uint64_t Advance = TMetricsTableContext::GetAdvance((TMetricsTableContext *)v5, a2);
  TDataReference::~TDataReference((TDataReference *)&v6);
  return Advance;
}

void sub_1B52EE3D0(_Unwind_Exception *a1)
{
  TDataReference::~TDataReference((TDataReference *)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t TMetricsTableContext::GetAdvance(TMetricsTableContext *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 6);
  unint64_t v3 = v2 + *(void *)(*(void *)this + 72);
  unsigned int v4 = *((_DWORD *)this + 2);
  if (v4 <= a2) {
    unsigned int v5 = v4 - 1;
  }
  else {
    unsigned int v5 = a2;
  }
  uint64_t v6 = (unsigned __int16 *)(v2 + 4 * v5);
  if ((unint64_t)(v6 + 2) > v3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  return bswap32(*v6) >> 16;
}

uint64_t ThmtxTable::GetRawMetrics(ThmtxTable *this, unsigned int a2, __int16 *a3)
{
  TMetricsTableContext::TMetricsTableContext((TMetricsTableContext *)v7, this);
  uint64_t RawMetrics = TMetricsTableContext::GetRawMetrics((TMetricsTableContext *)v7, a2, a3);
  TDataReference::~TDataReference((TDataReference *)&v8);
  return RawMetrics;
}

void sub_1B52EE4E0(_Unwind_Exception *a1)
{
  TDataReference::~TDataReference((TDataReference *)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t TMetricsTableContext::GetRawMetrics(TMetricsTableContext *this, unsigned int a2, __int16 *a3)
{
  uint64_t v3 = *((void *)this + 6);
  unint64_t v4 = v3 + *(void *)(*(void *)this + 72);
  uint64_t v5 = *((unsigned int *)this + 2);
  unsigned int v6 = v5 - 1;
  if (a2 >= v5) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = a2;
  }
  uint64_t v8 = (unsigned __int16 *)(v3 + 4 * v7);
  if ((unint64_t)(v8 + 2) > v4)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  uint64_t v9 = v3 + 4 * v5;
  uint64_t v10 = v3 + 4 * v6 + 2;
  unint64_t v11 = (v4 - v9) >> 1;
  unint64_t v12 = a2 - v5;
  if (v11 <= v12) {
    LODWORD(v12) = v11 - 1;
  }
  uint64_t v13 = (unsigned __int16 *)(v9 + 2 * v12);
  if (v9 + 2 <= v4 && v4 - v9 >= 2) {
    size_t v15 = v13;
  }
  else {
    size_t v15 = (unsigned __int16 *)v10;
  }
  uint64_t v16 = (unsigned __int16 *)(v3 + 4 * v7 + 2);
  if (v7 != a2) {
    uint64_t v16 = v15;
  }
  *a3 = bswap32(*v16) >> 16;
  return bswap32(*v8) >> 16;
}

void TvmtxTable::~TvmtxTable(TvmtxTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

void TVORGTable::~TVORGTable(TVORGTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

void TMVARTable::TMVARTable(TMVARTable *this, const TSFNTFont *a2, uint64_t a3, const __int16 *a4)
{
  TsfntTable::TsfntTable(this, a2, 1297498450);
  *(void *)uint64_t v7 = &unk_1F0DFE120;
  *(_OWORD *)(v7 + 88) = 0u;
  uint64_t v8 = (void *)(v7 + 88);
  *(_OWORD *)(v7 + 56) = 0u;
  *(_OWORD *)(v7 + 72) = 0u;
  *(_OWORD *)(v7 + 104) = 0u;
  *(_OWORD *)(v7 + 120) = 0u;
  uint64_t v9 = *(void *)(v7 + 8);
  if (v9)
  {
    uint64_t v10 = *(void *)(v9 + 8);
    if (v10)
    {
      uint64_t v11 = *((void *)this + 2);
      unint64_t TableEnd = TsfntTable::GetTableEnd(this);
      uint64_t v13 = (_WORD *)(v10 + v11);
      unint64_t v14 = v10 + v11 + 12;
      if (v14 > TableEnd)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *(void *)exception = &unk_1F0DD4440;
        exception[2] = 4;
      }
      if (*v13 == 256 && v13[3])
      {
        uint64_t v15 = __rev16((unsigned __int16)v13[3]);
        if (v15 < 8) {
          goto LABEL_17;
        }
        if (v13[4] && v13[5])
        {
          uint64_t v16 = __rev16((unsigned __int16)v13[4]);
          unint64_t v17 = v14 + v16 * (unint64_t)v15;
          if (v17 >= v14 && v17 <= TableEnd)
          {
            if (ItemVariationStore::Initialize(v8, (uint64_t)v13 + __rev16((unsigned __int16)v13[5]), TableEnd))
            {
              *((void *)this + 7) = a3;
              *((void *)this + 8) = a4;
              *((void *)this + 9) = v15;
              *((void *)this + 10) = v16;
            }
            return;
          }
LABEL_17:
          unsigned int v20 = __cxa_allocate_exception(0x10uLL);
          *(void *)unsigned int v20 = &unk_1F0DD4440;
          v20[2] = 4;
        }
      }
    }
  }
}

void sub_1B52EE80C(void *a1)
{
  __cxa_begin_catch(a1);
  TDataReference::DucRefCount(v1);
  *uint64_t v2 = 0;
  v2[1] = 0;
  v2[2] = 0;
  __cxa_end_catch();
  JUMPOUT(0x1B52EE758);
}

void sub_1B52EE830(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  TDataReference::~TDataReference(v1);
  _Unwind_Resume(a1);
}

void TMVARTable::~TMVARTable(TMVARTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TMVARTable::GetDeltaSetIndexForTag(TMVARTable *this, int a2)
{
  int __key = a2;
  uint64_t v2 = *((void *)this + 1);
  if (!v2) {
    goto LABEL_8;
  }
  uint64_t v2 = *(void *)(v2 + 8);
  if (!v2) {
    goto LABEL_8;
  }
  size_t v3 = *((void *)this + 10);
  if (!v3
    || (size_t v4 = *((void *)this + 9)) == 0
    || (uint64_t v5 = bsearch(&__key, (const void *)(v2 + *((void *)this + 2) + 12), v3, v4, (int (__cdecl *)(const void *, const void *))TMVARTable::GetDeltaSetIndexForTagconst::$_0::__invoke)) == 0)
  {
    uint64_t v2 = 0;
LABEL_8:
    int v8 = 0;
    unsigned int v7 = 0;
    return v2 | v7 | v8;
  }
  unsigned int v6 = bswap32(v5[1]);
  unsigned int v7 = v6 & 0xFFFFFF00;
  int v8 = v6;
  uint64_t v2 = 0x100000000;
  return v2 | v7 | v8;
}

void THVARTable::THVARTable(THVARTable *this, const TSFNTFont *a2, uint64_t a3, uint64_t a4)
{
  TsfntTable::TsfntTable(this, a2, a3);
  *(void *)uint64_t v6 = &unk_1F0DFE140;
  *(_OWORD *)(v6 + 56) = 0u;
  unsigned int v7 = (void *)(v6 + 56);
  *(_OWORD *)(v6 + 72) = 0u;
  *(_OWORD *)(v6 + 88) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  uint64_t v8 = *(void *)(v6 + 8);
  if (v8)
  {
    uint64_t v9 = *(void *)(v8 + 8);
    if (v9)
    {
      uint64_t v10 = *((void *)this + 2);
      unint64_t TableEnd = TsfntTable::GetTableEnd(this);
      unint64_t v12 = TableEnd;
      unint64_t v13 = v9 + v10;
      if (v13 + a4 < v13 || v13 + a4 > TableEnd)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *(void *)exception = &unk_1F0DD4440;
        exception[2] = 4;
      }
      if (*(_WORD *)v13 == 256
        && ItemVariationStore::Initialize(v7, v13 + bswap32(*(_DWORD *)(v13 + 4)), TableEnd))
      {
        unsigned int v15 = *(_DWORD *)(v13 + 8);
        BOOL v16 = v15 == 0;
        unint64_t v17 = (unsigned __int8 *)(v13 + bswap32(v15));
        if (!v16 && (unint64_t)(v17 + 1) <= v12)
        {
          int v22 = *v17;
          uint64_t v23 = 6;
          if (v22 != 1) {
            uint64_t v23 = 0;
          }
          BOOL v16 = v22 == 0;
          uint64_t v24 = 4;
          if (!v16) {
            uint64_t v24 = v23;
          }
          int v25 = &v17[v24];
          if (v25 >= v17 && (unint64_t)v25 <= v12) {
            *((void *)this + 13) = v17;
          }
        }
        unsigned int v19 = *(_DWORD *)(v13 + 12);
        BOOL v16 = v19 == 0;
        unsigned int v20 = (unsigned __int8 *)(v13 + bswap32(v19));
        if (!v16 && (unint64_t)(v20 + 1) <= v12)
        {
          int v27 = *v20;
          uint64_t v28 = 6;
          if (v27 != 1) {
            uint64_t v28 = 0;
          }
          BOOL v16 = v27 == 0;
          uint64_t v29 = 4;
          if (!v16) {
            uint64_t v29 = v28;
          }
          unsigned int v30 = &v20[v29];
          if (v30 >= v20 && (unint64_t)v30 <= v12) {
            *((void *)this + 14) = v20;
          }
        }
      }
    }
  }
}

void sub_1B52EEAE4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, long long a11)
{
  __cxa_begin_catch(a1);
  a9 = &unk_1F0DD4218;
  a10 = 0;
  a11 = 0uLL;
  if (&a9 != (void **)v11)
  {
    TDataReference::DucRefCount((TDataReference *)v11);
    uint64_t v12 = a10;
    a10 = 0;
    *(void *)(v11 + 8) = v12;
    *(_OWORD *)(v11 + 16) = a11;
  }
  TDataReference::~TDataReference((TDataReference *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x1B52EEA14);
}

void sub_1B52EEB44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TDataReference::~TDataReference((TDataReference *)&a9);
  __cxa_end_catch();
  TDataReference::~TDataReference(v9);
  _Unwind_Resume(a1);
}

void THVARTable::~THVARTable(THVARTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

double THVARTable::GetDelta(THVARTable *this, uint64_t a2, const DeltaSetIndexMap *a3, unint64_t a4, const __int16 *a5, const double *a6)
{
  if (a3)
  {
    unint64_t TableEnd = TsfntTable::GetTableEnd(this);
    LODWORD(a2) = DeltaSetIndexMap::IndexForValue(a3, a2, TableEnd);
  }
  return ItemVariationStore::ValueForDeltaSet((THVARTable *)((char *)this + 56), WORD1(a2), (unsigned __int16)a2, a4, a5, a6);
}

void TVVARTable::TVVARTable(TVVARTable *this, const TSFNTFont *a2)
{
  THVARTable::THVARTable(this, a2, 1448493394, 24);
  *size_t v3 = &unk_1F0DFE160;
  v3[15] = 0;
  if (v3[7])
  {
    uint64_t v4 = *((void *)this + 1);
    if (v4 && (uint64_t v5 = *(void *)(v4 + 8)) != 0) {
      uint64_t v6 = v5 + *((void *)this + 2);
    }
    else {
      uint64_t v6 = 0;
    }
    unsigned int v7 = *(_DWORD *)(v6 + 20);
    if (v7)
    {
      unint64_t TableEnd = TsfntTable::GetTableEnd(this);
      uint64_t v9 = (unsigned __int8 *)(v6 + bswap32(v7));
      if ((unint64_t)(v9 + 1) <= TableEnd)
      {
        int v10 = *v9;
        uint64_t v11 = 6;
        if (v10 != 1) {
          uint64_t v11 = 0;
        }
        BOOL v12 = v10 == 0;
        uint64_t v13 = 4;
        if (!v12) {
          uint64_t v13 = v11;
        }
        unint64_t v14 = &v9[v13];
        if (v14 >= v9 && (unint64_t)v14 <= TableEnd) {
          *((void *)this + 15) = v9;
        }
      }
    }
  }
}

void sub_1B52EED10(_Unwind_Exception *a1)
{
  TDataReference::~TDataReference(v1);
  _Unwind_Resume(a1);
}

void TVVARTable::~TVVARTable(TVVARTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

unint64_t TpostTable::GetGlyphName@<X0>(TpostTable *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unint64_t result = TpostTable::GetPost(this);
  HIDWORD(v7) = bswap32(*(_DWORD *)result);
  LODWORD(v7) = HIDWORD(v7) - 0x10000;
  switch((v7 >> 15))
  {
    case 0u:
      if (a2 > 0x101) {
        goto LABEL_40;
      }
      unsigned int v8 = (unsigned __int16)a2;
      goto LABEL_30;
    case 2u:
      uint64_t Post = TpostTable::GetPost(this);
      unint64_t result = TsfntTable::validate<FPBigEndianScalar<unsigned short>>(this, Post + 32, 0);
      unsigned int v10 = bswap32(*(unsigned __int16 *)(Post + 32));
      uint64_t v11 = HIWORD(v10);
      if (v11 <= a2) {
        goto LABEL_39;
      }
      TsfntTable::validate<FPBigEndianScalar<unsigned short>>(this, Post + 32, HIWORD(v10));
      if (!a2)
      {
        unsigned int v13 = 0;
LABEL_27:
        unsigned int v8 = v13;
LABEL_30:
        DefaultPostName = GetDefaultPostName(v8);
        unsigned int v25 = *DefaultPostName;
        unint64_t result = (unint64_t)(DefaultPostName + 1);
        uint64_t v24 = v25;
        *(void *)(a3 + 8) = result;
        goto LABEL_31;
      }
      uint64_t v12 = Post + 34;
      unsigned int v13 = bswap32(*(unsigned __int16 *)(Post + 34 + 2 * a2)) >> 16;
      if (v13 <= 0x101) {
        goto LABEL_27;
      }
      unint64_t result = TsfntTable::GetTableEnd(this);
      unint64_t v14 = (unsigned __int8 *)(v12 + 2 * v11);
      for (__int16 i = v13 - 258; i; --i)
      {
        if ((unint64_t)v14 >= result) {
          goto LABEL_39;
        }
        v14 += *v14 + 1;
      }
      if ((unint64_t)v14 < result)
      {
        uint64_t v26 = *v14;
        if (*v14 && (unint64_t)&v14[v26] < result)
        {
          unint64_t result = IsValidPostName(v14 + 1, v26);
          if (result)
          {
            uint64_t v24 = *v14;
            *(void *)(a3 + 8) = v14 + 1;
LABEL_31:
            *(void *)(a3 + 16) = v24;
            goto LABEL_42;
          }
        }
      }
LABEL_39:
      if (a2)
      {
LABEL_40:
        memset(__s1, 170, sizeof(__s1));
        snprintf_l(__s1, 0x10uLL, 0, "gid%d", a2);
        return TStringRef::TStringRef<16ul>(a3, __s1);
      }
LABEL_41:
      *(void *)(a3 + 8) = ".notdef";
      *(void *)(a3 + 16) = 7;
LABEL_42:
      *(void *)a3 = &unk_1F0DD43A0;
      *(unsigned char *)(a3 + 24) = 0;
      *(void *)(a3 + 32) = &unk_1F0DD4218;
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 48) = 0;
      *(void *)(a3 + 56) = 0;
      return result;
    case 3u:
      uint64_t v16 = TpostTable::GetPost(this);
      unint64_t result = TsfntTable::validate<FPBigEndianScalar<unsigned short>>(this, v16 + 32, 0);
      unsigned int v17 = bswap32(*(unsigned __int16 *)(v16 + 32)) >> 16;
      if (v17 >= 0x102) {
        unsigned int v17 = 258;
      }
      if (v17 <= a2) {
        goto LABEL_39;
      }
      unint64_t v18 = v16 + 34;
      TsfntTable::validate<signed char>(this, v18, v17 - 1);
      if (a2) {
        unsigned __int16 v19 = *(char *)(v18 + a2) + (_WORD)a2;
      }
      else {
        unsigned __int16 v19 = 0;
      }
      unsigned int v8 = v19;
      goto LABEL_30;
    case 6u:
      if (!a2) {
        goto LABEL_41;
      }
      unint64_t TableEnd = TsfntTable::GetTableEnd(this);
      uint64_t v21 = *((void *)this + 1);
      if (v21)
      {
        uint64_t v21 = *(void *)(v21 + 8);
        if (v21) {
          v21 += *((void *)this + 2);
        }
      }
      if (2 * (unint64_t)(a2 + 1) + 32 > TableEnd - v21) {
        goto LABEL_40;
      }
      unsigned int v22 = *(unsigned __int16 *)(TpostTable::GetPost(this) + 2 * a2 + 32);
      memset(__s1, 170, sizeof(__s1));
      if (v22 == 0xFFFF) {
        goto LABEL_40;
      }
      if (__rev16(v22) >= 0x100) {
        snprintf_l(__s1, 0x10uLL, 0, "a%04x");
      }
      else {
        snprintf_l(__s1, 0x10uLL, 0, "a%02x");
      }
      return TStringRef::TStringRef<16ul>(a3, __s1);
    default:
      goto LABEL_39;
  }
}

unint64_t TsfntTable::validate<FPBigEndianScalar<unsigned short>>(TsfntTable *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = *((void *)a1 + 1);
  if (v4 && (uint64_t v5 = *(void *)(v4 + 8)) != 0 && v5 + *((void *)a1 + 2) > a2
    || a2 + 2 * a3 + 2 > TsfntTable::GetTableEnd(a1))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  return a2;
}

BOOL IsValidPostName(const unsigned __int8 *a1, uint64_t a2)
{
  if (!a2) {
    return 1;
  }
  uint64_t v3 = a2 - 1;
  uint64_t v4 = MEMORY[0x1E4F14390];
  do
  {
    unsigned int v6 = *(char *)a1++;
    unsigned int v5 = v6;
    if ((v6 & 0x80000000) != 0) {
      int v7 = __maskrune(v5, 0x800uLL);
    }
    else {
      int v7 = *(_DWORD *)(v4 + 4 * v5 + 60) & 0x800;
    }
    BOOL result = v7 != 0;
    BOOL v10 = v3-- != 0;
  }
  while (v7 && v10);
  return result;
}

unint64_t TsfntTable::validate<signed char>(TsfntTable *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = *((void *)a1 + 1);
  if (v4 && (uint64_t v5 = *(void *)(v4 + 8)) != 0 && v5 + *((void *)a1 + 2) > a2
    || a2 + a3 + 1 > TsfntTable::GetTableEnd(a1))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  return a2;
}

uint64_t TStringRef::TStringRef<16ul>(uint64_t a1, char *__s1)
{
  uint64_t v4 = strndup(__s1, 0xFuLL);
  size_t v5 = strnlen(__s1, 0xFuLL);
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(void *)a1 = &unk_1F0DD43A0;
  *(unsigned char *)(a1 + 24) = 1;
  *(void *)(a1 + 32) = &unk_1F0DD4218;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  return a1;
}

uint64_t TpostTable::VerifyGlyphName(TpostTable *this, uint64_t a2, const char *a3)
{
  unsigned int v6 = bswap32(*(_DWORD *)TpostTable::GetPost(this));
  if (v6 == 163840)
  {
    uint64_t Post = TpostTable::GetPost(this);
    TsfntTable::validate<FPBigEndianScalar<unsigned short>>(this, Post + 32, 0);
    unsigned int v9 = bswap32(*(unsigned __int16 *)(Post + 32)) >> 16;
    if (v9 >= 0x102) {
      unsigned int v9 = 258;
    }
    if (v9 <= a2) {
      return 0;
    }
    unint64_t v10 = Post + 34;
    TsfntTable::validate<signed char>(this, v10, v9 - 1);
    if (a2) {
      unsigned __int16 v11 = *(char *)(v10 + a2) + (_WORD)a2;
    }
    else {
      unsigned __int16 v11 = 0;
    }
    unsigned int v7 = v11;
  }
  else if (v6 == 0x20000)
  {
    uint64_t v12 = TpostTable::GetPost(this);
    TsfntTable::validate<FPBigEndianScalar<unsigned short>>(this, v12 + 32, 0);
    unsigned int v13 = bswap32(*(unsigned __int16 *)(v12 + 32));
    uint64_t v14 = HIWORD(v13);
    if (v14 <= a2) {
      return 0;
    }
    TsfntTable::validate<FPBigEndianScalar<unsigned short>>(this, v12 + 32, HIWORD(v13));
    if (a2)
    {
      uint64_t v15 = v12 + 34;
      unsigned int v16 = bswap32(*(unsigned __int16 *)(v12 + 34 + 2 * a2)) >> 16;
      if (v16 > 0x101)
      {
        unint64_t TableEnd = TsfntTable::GetTableEnd(this);
        unint64_t v18 = (const char *)(v15 + 2 * v14);
        for (__int16 i = v16 - 258; i; --i)
        {
          if ((unint64_t)v18 >= TableEnd) {
            return 0;
          }
          v18 += *(unsigned __int8 *)v18 + 1;
        }
        if ((unint64_t)v18 >= TableEnd
          || (unint64_t)&v18[*(unsigned __int8 *)v18] >= TableEnd
          || !PStringCompare(v18, a3))
        {
          return 0;
        }
        return a2;
      }
    }
    else
    {
      unsigned int v16 = 0;
    }
    unsigned int v7 = v16;
  }
  else
  {
    if (v6 != 0x10000 || a2 > 0x101) {
      return 0;
    }
    unsigned int v7 = (unsigned __int16)a2;
  }
  DefaultPostName = GetDefaultPostName(v7);
  size_t v21 = *DefaultPostName;
  if (strlen(a3) != v21 || strncmp(a3, DefaultPostName + 1, v21)) {
    return 0;
  }
  return a2;
}

BOOL PStringCompare(const char *a1, const char *__s)
{
  size_t v4 = *(unsigned __int8 *)a1;
  return strlen(__s) == v4 && strncmp(__s, a1 + 1, v4) == 0;
}

void *TBinarySearch::DoBinarySearch(TBinarySearch *this, __int16 a2)
{
  __int16 __key = a2;
  uint64_t v2 = *(_WORD **)this;
  if (!**(_WORD **)this) {
    return 0;
  }
  size_t v3 = __rev16(**(unsigned __int16 **)this);
  size_t v4 = bswap32((unsigned __int16)v2[1]) >> 16;
  unint64_t v5 = (unint64_t)v2 + v4 * (unint64_t)v3 + 10;
  if (v5 < (unint64_t)(v2 + 5) || v5 > *((void *)this + 1)) {
    return 0;
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  v8[2] = ___ZNK13TBinarySearch14DoBinarySearchEt_block_invoke;
  v8[3] = &__block_descriptor_tmp_1;
  v8[4] = this;
  return bsearch_b(&__key, v2 + 5, v4, v3, v8);
}

uint64_t ___ZNK13TBinarySearch14DoBinarySearchEt_block_invoke(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = bswap32(*a3) >> 16;
  if (v4 < v3) {
    return 1;
  }
  BOOL v6 = v3 >= bswap32(a3[1]) >> 16;
  if (v3 < v4) {
    unsigned int v7 = -1;
  }
  else {
    unsigned int v7 = 1;
  }
  if (v6) {
    return 0;
  }
  else {
    return v7;
  }
}

void *TBinarySingleSearch::DoBinarySearch(TBinarySingleSearch *this, __int16 a2)
{
  __int16 __key = a2;
  uint64_t v2 = *(_WORD **)this;
  if (!**(_WORD **)this) {
    return 0;
  }
  size_t v3 = __rev16(**(unsigned __int16 **)this);
  size_t v4 = bswap32((unsigned __int16)v2[1]) >> 16;
  unint64_t v5 = (unint64_t)v2 + v4 * (unint64_t)v3 + 10;
  if (v5 < (unint64_t)(v2 + 5) || v5 > *((void *)this + 1)) {
    return 0;
  }
  else {
    return bsearch_b(&__key, v2 + 5, v4, v3, &__block_literal_global_0);
  }
}

uint64_t ___ZNK19TBinarySingleSearch14DoBinarySearchEt_block_invoke(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = bswap32(*a3);
  BOOL v5 = v3 == HIWORD(v4);
  if (v3 < HIWORD(v4)) {
    unsigned int v6 = -1;
  }
  else {
    unsigned int v6 = 1;
  }
  if (v5) {
    return 0;
  }
  else {
    return v6;
  }
}

void TzapfTable::~TzapfTable(TzapfTable *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

unint64_t TzapfTable::GetUnicharsForGlyph(TsfntTable *a1, uint64_t a2, _WORD *a3, unint64_t a4)
{
  if (!a2) {
    return 0;
  }
  unint64_t v5 = __rev16(*(unsigned __int16 *)(a2 + 8));
  if (a3 && *(_WORD *)(a2 + 8))
  {
    unsigned int v7 = (unsigned __int16 *)(a2 + 10);
    TsfntTable::validate<FPBigEndianScalar<unsigned short>>(a1, a2 + 10, v5);
    if (v5 >= a4) {
      unint64_t v5 = a4;
    }
    if (v5)
    {
      unsigned int v8 = a3;
      unint64_t v9 = v5;
      do
      {
        unsigned int v10 = *v7++;
        *v8++ = bswap32(v10) >> 16;
        --v9;
      }
      while (v9);
    }
    if ((a3[v5 - 1] & 0xFC00) == 0xD800) {
      a3[--v5] = -1;
    }
  }
  return v5;
}

unint64_t TsfntTable::validate<FPBigEndianScalar<unsigned int>>(TsfntTable *a1, unint64_t a2)
{
  uint64_t v3 = *((void *)a1 + 1);
  if (v3 && (uint64_t v4 = *(void *)(v3 + 8)) != 0 && v4 + *((void *)a1 + 2) > a2 || a2 + 4 > TsfntTable::GetTableEnd(a1))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  return a2;
}

unint64_t TzapfTable::Map(TzapfTable *this, const unsigned __int16 *a2, unsigned __int16 *a3, unint64_t *a4)
{
  unint64_t v5 = *a4;
  if (*a4)
  {
    unint64_t v9 = 0;
    unint64_t v10 = *a4;
    unint64_t v11 = *a4;
    while (1)
    {
      unsigned int v12 = a2[v9];
      if (v12 < *((unsigned __int16 *)this + 28)) {
        break;
      }
      *a3++ = -1;
LABEL_25:
      int v24 = *(a3 - 1);
      if (v11 >= v9) {
        unint64_t v25 = v9;
      }
      else {
        unint64_t v25 = v11;
      }
      BOOL v18 = v24 == 0xFFFF;
      uint64_t v26 = v24 == 0xFFFF;
      if (v18) {
        unint64_t v11 = v25;
      }
      v10 -= v26;
      if (++v9 >= v5) {
        goto LABEL_33;
      }
    }
    GlyphInfo = TzapfTable::GetGlyphInfo(this, v12);
    uint64_t v14 = a3;
    if (GlyphInfo)
    {
      if (**((_DWORD **)this + 8) == 512)
      {
        uint64_t v14 = a3;
        if (GlyphInfo[8] < 0)
        {
          int v15 = GlyphInfo[9];
          uint64_t v14 = a3;
          if (GlyphInfo[9])
          {
            unsigned int v16 = bswap32(*((unsigned __int16 *)GlyphInfo + 5)) >> 16;
            *a3 = v16;
            int v17 = v16 & 0xFC00;
            BOOL v18 = v15 != 1 && v17 == 55296;
            uint64_t v14 = a3;
            if (v18)
            {
              a3[1] = bswap32(*((unsigned __int16 *)GlyphInfo + 6)) >> 16;
              uint64_t v14 = a3 + 1;
            }
          }
        }
      }
      else
      {
        uint64_t v14 = a3;
        if (*((_WORD *)GlyphInfo + 4))
        {
          unsigned int v19 = bswap32(*((unsigned __int16 *)GlyphInfo + 5)) >> 16;
          *a3 = v19;
          int v20 = v19 & 0xFC00;
          BOOL v21 = bswap32(*((unsigned __int16 *)GlyphInfo + 4)) >> 16 >= 2 && v20 == 55296;
          unsigned int v22 = a3;
          if (v21)
          {
            a3[1] = bswap32(*((unsigned __int16 *)GlyphInfo + 6)) >> 16;
            unsigned int v22 = a3 + 1;
          }
          uint64_t v23 = v22 - a3 + 1;
          goto LABEL_24;
        }
      }
    }
    *uint64_t v14 = -1;
    uint64_t v23 = 1;
LABEL_24:
    a3 += v23;
    unint64_t v5 = *a4;
    goto LABEL_25;
  }
  unint64_t v11 = 0;
  unint64_t v10 = 0;
LABEL_33:
  *a4 = v10;
  return v11;
}

unint64_t TzapfTable::MapToCharacters(TzapfTable *this, unsigned int a2, unsigned __int16 *a3, unint64_t a4)
{
  if (*((unsigned __int16 *)this + 28) <= a2) {
    return 0;
  }
  GlyphInfo = TzapfTable::GetGlyphInfo(this, a2);
  return TzapfTable::GetUnicharsForGlyph(this, (uint64_t)GlyphInfo, a3, a4);
}

void Tos2Table::~Tos2Table(Tos2Table *this)
{
  TDataReference::~TDataReference(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t Tos2Table::GetSubscriptX(Tos2Table *this)
{
  return (bswap32(*(unsigned __int16 *)(TpostTable::GetPost(this) + 10)) >> 16) | 0x7362787300000000;
}

uint64_t Tos2Table::GetSubscriptY(Tos2Table *this)
{
  return (bswap32(*(unsigned __int16 *)(TpostTable::GetPost(this) + 12)) >> 16) | 0x7362797300000000;
}

uint64_t Tos2Table::GetSuperscriptX(Tos2Table *this)
{
  return (bswap32(*(unsigned __int16 *)(TpostTable::GetPost(this) + 18)) >> 16) | 0x7370787300000000;
}

uint64_t Tos2Table::GetSuperscriptY(Tos2Table *this)
{
  return (bswap32(*(unsigned __int16 *)(TpostTable::GetPost(this) + 20)) >> 16) | 0x7370797300000000;
}

uint64_t Tos2Table::GetStrikeout(Tos2Table *this)
{
  return (bswap32(*(unsigned __int16 *)(TpostTable::GetPost(this) + 26)) >> 16) | 0x7374727300000000;
}

uint64_t TcmapTableFileData16::GetDataP(TcmapTableFileData16 *this, int a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  return v2 + a2;
}

uint64_t TUVSTable::GetDataP(TUVSTable *this, int a2)
{
  return *((void *)this + 2) + a2;
}

uint64_t TUVSTable::GetHead(TUVSTable *this)
{
  return *((void *)this + 2);
}

uint64_t std::vector<TFontNameString>::__push_back_slow_path<TFontNameString const&>(uint64_t *a1, const TFontNameString *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x2AAAAAAAAAAAAAALL) {
    std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x155555555555555) {
    unint64_t v9 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  int v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TFontNameString>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  unsigned int v13 = v10;
  uint64_t v14 = (TFontNameString *)&v10[96 * v4];
  unsigned int v16 = &v10[96 * v9];
  TFontNameString::TFontNameString(v14, a2);
  int v15 = (char *)v14 + 96;
  std::vector<TFontNameString>::__swap_out_circular_buffer(a1, &v13);
  uint64_t v11 = a1[1];
  std::__split_buffer<TFontNameString>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_1B52EFDE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TFontNameString>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<TFontNameString>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:fe180100]<std::allocator<TFontNameString>,std::reverse_iterator<TFontNameString*>,std::reverse_iterator<TFontNameString*>,std::reverse_iterator<TFontNameString*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:fe180100]<std::allocator<TFontNameString>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:fe180100]();
  }
  return operator new(96 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:fe180100]<std::allocator<TFontNameString>,std::reverse_iterator<TFontNameString*>,std::reverse_iterator<TFontNameString*>,std::reverse_iterator<TFontNameString*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0;
  uint64_t v11 = a7 - 96;
  while (a3 + v10 != a5)
  {
    unsigned int v12 = (TFontNameString *)(v11 + v10);
    v10 -= 96;
    TFontNameString::TFontNameString(v12, (const TFontNameString *)(v10 + a3));
  }
  return a6;
}

uint64_t std::__split_buffer<TFontNameString>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    unint64_t v4 = *(void (***)(void))(i - 96);
    *(void *)(a1 + 16) = i - 96;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void anonymous namespace'::TFormat2cmapTable::~TFormat2cmapTable(_anonymous_namespace_::TFormat2cmapTable *this)
{
}

uint64_t anonymous namespace'::TFormat2cmapTable::DecomposeMacCmap(_anonymous_namespace_::TFormat2cmapTable *this, unsigned __int8 *a2, int a3, unint64_t *a4, unsigned __int16 *a5, unint64_t *a6)
{
  unint64_t v9 = (void *)((char *)this + 8);
  unint64_t v10 = (*(uint64_t (**)(void, void, uint64_t))(**((void **)this + 1) + 16))(*((void *)this + 1), 0, 4);
  int v38 = v9;
  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v9, v10, 256);
  uint64_t v11 = 0;
  unint64_t v12 = 0;
  unint64_t v33 = (unsigned __int16 *)v10;
  int v34 = a2;
  unint64_t v29 = v10 + 518;
  unint64_t v30 = v10 + 512;
  int v28 = a3;
  do
  {
    if (v11)
    {
      unsigned int v13 = bswap32(v33[v11]) >> 16;
      if (v13 < 8) {
        goto LABEL_27;
      }
    }
    else
    {
      unsigned int v13 = bswap32(*v33) >> 16;
    }
    uint64_t v32 = v13 >> 1;
    uint64_t v14 = (__int16 *)(v30 + 2 * v32);
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v38, (unint64_t)v14, 4);
    __int16 v15 = *v14;
    unsigned int v16 = (unsigned __int16)v14[1];
    unsigned int v31 = (unsigned __int16)v14[2];
    uint64_t v17 = bswap32((unsigned __int16)v14[3]) >> 17;
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v38, (unint64_t)&v14[v17 + 3], 1);
    if (v16) {
      BOOL v18 = a3 == 0;
    }
    else {
      BOOL v18 = 1;
    }
    if (!v18 && *a6 != 0)
    {
      char v37 = HIBYTE(v15);
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      unsigned int v22 = bswap32(v31) >> 16;
      unint64_t v23 = __rev16(v16);
      unint64_t v24 = v29 + 2 * v32 + 2 * v17;
      while (1)
      {
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v38, v24 + v20, 1);
        unsigned int v25 = v22 + (bswap32(*(unsigned __int16 *)(v24 + 2 * v21)) >> 16);
        if (!(_WORD)v25) {
          goto LABEL_24;
        }
        if (a4) {
          a4[v12] = a2 - v34;
        }
        if (a5) {
          a5[v12] = v25;
        }
        --*a6;
        ++v12;
        if (!v11) {
          break;
        }
        *a2++ = v11;
        --a3;
        char v26 = v37;
        if (a3) {
          goto LABEL_23;
        }
LABEL_24:
        if (++v21 < v23)
        {
          if (a3)
          {
            v20 += 2;
            if (*a6) {
              continue;
            }
          }
        }
        goto LABEL_27;
      }
      char v26 = v37;
LABEL_23:
      *a2++ = v21 + v26;
      --a3;
      goto LABEL_24;
    }
LABEL_27:
    ++v11;
  }
  while (v11 != 256);
  *a6 = v12;
  return (v28 - a3);
}

unint64_t TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(void *a1, unint64_t a2, uint64_t a3)
{
  if ((*(uint64_t (**)(void))(*(void *)*a1 + 24))(*a1) > a2 || a2 + 2 * a3 > *(void *)(*a1 + 8))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  return a2;
}

void SetUVSForGlyphInMap(unsigned int *a1, CFDictionaryRef theDict, void *key, unsigned int a4, int a5, unsigned int a6)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (key && HIWORD(a4) <= 0x10u && key < a6)
  {
    unint64_t v10 = key;
    if (!a5 && a1[key] == -1)
    {
      a1[key] = a4;
      return;
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAA00;
    CFArrayRef Value = (__CFArray *)CFDictionaryGetValue(theDict, (const void *)key);
    unsigned int v13 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (Value)
    {
      CFMutableArrayRef Mutable = Value;
    }
    else
    {
      CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      CFDictionaryAddValue(theDict, (const void *)v10, Mutable);
      CFRelease(Mutable);
      UChar32 v17 = a1[v10];
      if (v17 != -1)
      {
        int v18 = u_charType(v17);
        BOOL v15 = v18 == 17;
        if (v18 == 17) {
          unint64_t v11 = 0;
        }
        LOWORD(v34) = -21846;
        unsigned int v19 = a1[v10];
        if ((v19 - 0x10000) >> 20)
        {
          CFIndex v21 = 1;
          unsigned int v20 = a1[v10];
        }
        else
        {
          unsigned int v20 = ((v19 + 67043328) >> 10) - 10240;
          LOWORD(v34) = v19 & 0x3FF | 0xDC00;
          CFIndex v21 = 2;
        }
        UniChar chars = v20;
        CFStringRef v22 = CFStringCreateWithCharacters(v16, &chars, v21);
        CFArrayAppendValue(Mutable, v22);
        CFRelease(v22);
LABEL_17:
        CFIndex Count = CFArrayGetCount(Mutable);
        if (Count > 63) {
          return;
        }
        __int16 v35 = -21846;
        int v34 = -1431655766;
        if ((a4 - 0x10000) >> 20)
        {
          CFIndex v25 = 1;
          LOWORD(v24) = a4;
        }
        else
        {
          unsigned int v24 = ((a4 + 67043328) >> 10) - 10240;
          LOWORD(v34) = a4 & 0x3FF | 0xDC00;
          CFIndex v25 = 2;
        }
        UniChar chars = v24;
        if (a5)
        {
          if ((a5 - 0x10000) >> 20)
          {
            uint64_t v27 = 1;
            LOWORD(v26) = a5;
          }
          else
          {
            unsigned int v26 = ((a5 + 67043328) >> 10) - 10240;
            *(&chars + v25 + 1) = a5 & 0x3FF | 0xDC00;
            uint64_t v27 = 2;
          }
          *(&chars + v25) = v26;
          v25 += v27;
        }
        CFStringRef v28 = CFStringCreateWithCharacters(*v13, &chars, v25);
        if (!v15)
        {
          int v29 = u_charType(a4);
          if (Count < 1
            || v29 == 17
            || (CFStringRef ValueAtIndex = (CFStringRef)CFArrayGetValueAtIndex(Mutable, Count - 1),
                UChar32 v30 = TCFStr::FirstCharacter(&ValueAtIndex),
                u_charType(v30) != 17))
          {
            CFArrayAppendValue(Mutable, v28);
            goto LABEL_36;
          }
          unint64_t v11 = Count;
          while (v11 >= 2)
          {
            CFStringRef ValueAtIndex = (CFStringRef)CFArrayGetValueAtIndex(Mutable, v11 - 2);
            UChar32 v31 = TCFStr::FirstCharacter(&ValueAtIndex);
            --v11;
            if (u_charType(v31) != 17) {
              goto LABEL_27;
            }
          }
          unint64_t v11 = 0;
        }
LABEL_27:
        CFArrayInsertValueAtIndex(Mutable, v11, v28);
LABEL_36:
        CFRelease(v28);
        return;
      }
    }
    BOOL v15 = 0;
    goto LABEL_17;
  }
}

unint64_t TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned int>>(void *a1, unint64_t a2, uint64_t a3)
{
  if ((*(uint64_t (**)(void))(*(void *)*a1 + 24))(*a1) > a2 || a2 + 4 * a3 > *(void *)(*a1 + 8))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  return a2;
}

uint64_t TcmapTableDataRef::RangeSizePerTuple(TcmapTableDataRef *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (this < a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  unsigned int v4 = this - a2 + a3;
  if (v4 + 1 < a4) {
    unsigned int v5 = v4 + 1;
  }
  else {
    unsigned int v5 = a4;
  }
  unsigned int v6 = v5 - a3;
  if (a3 < a4) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t TcmapTableDataRef::RangeSizePerFormat13Tuple(TcmapTableDataRef *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (this < a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  if (a3 < a4) {
    return this - a2 + 1;
  }
  else {
    return 0;
  }
}

uint64_t anonymous namespace'::TFormat4UTF16cmapTable::MapT<false,unsigned short>(_DWORD *a1, uint64_t a2, _WORD *a3, unsigned int *a4, int a5)
{
  int v7 = *a4;
  a1[4] = *a4;
  a1[5] = v7;
  if (!*a4)
  {
LABEL_47:
    unsigned int v17 = a1[5];
    goto LABEL_48;
  }
  unint64_t v11 = (unsigned __int16 *)(*(uint64_t (**)(void))(**(void **)a1 + 16))();
  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(a1, (unint64_t)v11, 1);
  unsigned int v12 = bswap32(*v11) >> 16;
  if (v12)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  unint64_t v13 = *(void *)(*(void *)a1 + 8);
  uint64_t v14 = v11 + 4;
  if (v12 < 0x10)
  {
    LODWORD(v16) = 0;
    unsigned int v18 = 0;
    unsigned int v19 = 0;
    goto LABEL_8;
  }
  unsigned int v15 = __clz(v12);
  uint64_t v16 = (1 << (v15 ^ 0x1F));
  if ((unint64_t)v14 + v16 + 2 <= v13)
  {
    unsigned int v18 = 30 - v15;
    unsigned int v19 = bswap32(*(unsigned __int16 *)((char *)v14 + v16)) >> 16;
    unint64_t v11 = (unsigned __int16 *)((char *)v14 + v12 - v16);
LABEL_8:
    if (*a4)
    {
      unint64_t v20 = 0;
      uint64_t v21 = v12 >> 1;
      do
      {
        unsigned __int16 v22 = *(_WORD *)(a2 + 2 * v20);
        do
        {
          unint64_t v23 = v14;
          if (v12 >= 0x10)
          {
            if (v19 <= v22) {
              unint64_t v23 = v11;
            }
            else {
              unint64_t v23 = v14;
            }
            if ((unint64_t)v23 + v16 > v13) {
              goto LABEL_5;
            }
            if (v18 >= 4)
            {
              unsigned int v24 = v18;
              LODWORD(v25) = v16;
              do
              {
                unint64_t v26 = v25;
                unint64_t v25 = (unint64_t)v25 >> 1;
                uint64_t v27 = (unsigned __int16 *)((char *)v23 + (v26 >> 1));
                if (v22 > bswap32(*v27) >> 16) {
                  unint64_t v23 = v27;
                }
                --v24;
              }
              while (v24 > 3);
            }
          }
          if ((unint64_t)(v23 + 1) <= v13)
          {
            do
            {
              CFStringRef v28 = v23 + 1;
              unsigned int v30 = *v23;
              int v29 = v23 + 2;
              BOOL v31 = v22 <= bswap32(v30) >> 16 || (unint64_t)v29 > v13;
              unint64_t v23 = v28;
            }
            while (!v31);
            unint64_t v23 = v28;
          }
          uint64_t v32 = &v23[v21];
          if ((unint64_t)&v32[(v12 & 0xFFFE) + 1] <= v13)
          {
            unsigned int v33 = bswap32(*v32) >> 16;
            if (v33 <= v22)
            {
              int v34 = &v32[v21];
              unsigned int v35 = bswap32(*v34) >> 16;
              uint64_t v36 = &v34[v21];
              if (*v36)
              {
                char v37 = (unsigned __int16 *)((char *)&v36[(unsigned __int16)(v22 - v33)] + __rev16(*v36));
                if (v37 > v14 && (unint64_t)(v37 + 1) <= v13)
                {
                  unsigned int v39 = *v37;
                  v35 += bswap32(v39) >> 16;
                  if (v39 && (unsigned __int16)v35 != 0)
                  {
LABEL_45:
                    *a3 = v35;
                    goto LABEL_46;
                  }
                }
              }
              else
              {
                LOWORD(v35) = v35 + v22;
                if ((_WORD)v35) {
                  goto LABEL_45;
                }
              }
            }
          }
          if (!a5) {
            break;
          }
          unsigned int v41 = v22;
          v22 -= 4096;
        }
        while (v41 < 0x100);
        *a3 = 0;
        int v42 = a1[4];
        --a1[5];
        if (v42 > (unsigned __int16)v20) {
          a1[4] = (unsigned __int16)v20;
        }
LABEL_46:
        ++a3;
        ++v20;
      }
      while (v20 < *a4);
    }
    goto LABEL_47;
  }
LABEL_5:
  unsigned int v17 = 0;
  *((void *)a1 + 2) = 0;
LABEL_48:
  *a4 = v17;
  return a1[4];
}

void TMetricsTableContext::TMetricsTableContext(TMetricsTableContext *this, const ThmtxTable *a2)
{
  *(void *)this = a2;
  uint64_t Hhea = ThmtxTable::GetHhea(a2);
  if (Hhea) {
    unsigned int v5 = bswap32(*(unsigned __int16 *)(Hhea + 34)) >> 16;
  }
  else {
    unsigned int v5 = 0;
  }
  *((_DWORD *)this + 2) = v5;
  uint64_t v6 = *((unsigned int *)a2 + 16);
  if (v6 == -1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  (*(void (**)(void, uint64_t, void))(**((void **)a2 + 4) + 48))(*((void *)a2 + 4), v6, *((void *)a2 + 9));
  uint64_t v7 = *((void *)this + 3);
  if (!v7 || (uint64_t v8 = *(void *)(v7 + 8)) == 0)
  {
    *((void *)this + 6) = 0;
LABEL_10:
    unint64_t v9 = __cxa_allocate_exception(0x10uLL);
    *(void *)unint64_t v9 = &unk_1F0DD4440;
    _OWORD v9[2] = 4;
  }
  *((void *)this + 6) = v8 + *((void *)this + 4);
  if (!*((_DWORD *)this + 2)) {
    goto LABEL_10;
  }
}

void sub_1B52F0BD0(_Unwind_Exception *a1)
{
  TDataReference::~TDataReference(v1);
  _Unwind_Resume(a1);
}

uint64_t TMVARTable::GetDeltaSetIndexForTag(unsigned int)const::$_0::__invoke(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2 = bswap32(*a2);
  if (*a1 < v2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > v2;
  }
}

void TCFCharacterSet::~TCFCharacterSet(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

void std::__function::__func<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::__clone(uint64_t a1)
{
  unsigned int v2 = (char *)operator new(0x20uLL);
  *(void *)unsigned int v2 = &unk_1F0DFE268;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F0DFE268;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::operator()(uint64_t a1, unsigned __int16 *a2, int *a3, uint64_t *a4, unsigned char **a5)
{
  int v5 = *(unsigned __int16 *)(a1 + 24);
  if (v5 == bswap32(a2[3]) >> 16)
  {
    int v8 = *a3;
    uint64_t v9 = *a4;
    unint64_t v10 = *a5;
    unint64_t v11 = *(void **)(a1 + 8);
    int v12 = *(unsigned __int16 *)(a1 + 26);
    if (v12 == 0xFFFF || v12 == bswap32(*a2) >> 16)
    {
      int v13 = *(unsigned __int16 *)(a1 + 28);
      if (v13 == 0xFFFF || v13 == bswap32(a2[1]) >> 16)
      {
        int v14 = *(unsigned __int16 *)(a1 + 30);
        if (v14 == 0xFFFF || v14 == bswap32(a2[2]) >> 16)
        {
          *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
          unsigned int v17[4] = v15;
          v17[5] = v15;
          unsigned __int8 v17[2] = v15;
          unsigned char v17[3] = v15;
          v17[0] = v15;
          v17[1] = v15;
          TDataReference::TDataReference(v16, v11, v8, 0, 0);
          TFontNameString::TFontNameString((TFontNameString *)v17, v5, (const TDataReference *)v16, v9, bswap32(*a2) >> 16, bswap32(a2[1]) >> 16, bswap32(a2[2]) >> 16);
          TDataReference::~TDataReference((TDataReference *)v16);
          if (TFontNameString::IsValid((TFontNameString *)v17))
          {
            TFontNameString::operator=(*(void *)(a1 + 16), (uint64_t)v17);
            *unint64_t v10 = 1;
          }
          TFontNameString::~TFontNameString((TFontNameString *)v17);
        }
      }
    }
  }
}

void sub_1B52F0E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t std::__function::__func<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::FindName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::target_type()
{
}

void *std::__function::__value_func<void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::~__value_func[abi:fe180100](void *a1)
{
  unsigned int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0,std::allocator<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0,std::allocator<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::__clone(uint64_t a1)
{
  unsigned int v2 = (char *)operator new(0x30uLL);
  *(void *)unsigned int v2 = &unk_1F0DFE2F8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0,std::allocator<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F0DFE2F8;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0,std::allocator<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::operator()(uint64_t a1, unsigned __int16 *a2, int *a3, uint64_t *a4, unsigned char **a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int v5 = *(unsigned __int16 **)(a1 + 24);
  uint64_t v6 = *(unsigned __int16 **)(a1 + 32);
  if (v6 != v5)
  {
    int v9 = *a3;
    uint64_t v10 = *a4;
    unint64_t v11 = *a5;
    int v12 = *(void **)(a1 + 8);
    unsigned int v13 = bswap32(a2[3]) >> 16;
    unint64_t v14 = v6 - v5;
    do
    {
      unint64_t v15 = v14 >> 1;
      uint64_t v16 = &v5[v14 >> 1];
      unsigned int v18 = *v16;
      unsigned int v17 = v16 + 1;
      v14 += ~(v14 >> 1);
      if (v18 >= v13) {
        unint64_t v14 = v15;
      }
      else {
        int v5 = v17;
      }
    }
    while (v14);
    if (v5 != v6 && *v5 == v13)
    {
      *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
      _OWORD v22[4] = v19;
      v22[5] = v19;
      void v22[2] = v19;
      v22[3] = v19;
      v22[0] = v19;
      v22[1] = v19;
      TDataReference::TDataReference(v23, v12, v9, 0, 0);
      TFontNameString::TFontNameString((TFontNameString *)v22, v13, (const TDataReference *)v23, v10, bswap32(*a2) >> 16, bswap32(a2[1]) >> 16, bswap32(a2[2]) >> 16);
      TDataReference::~TDataReference((TDataReference *)v23);
      if (TFontNameString::IsValid((TFontNameString *)v22))
      {
        *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v23[2] = v20;
        v23[3] = v20;
        v23[0] = v20;
        v23[1] = v20;
        unsigned int v24 = 0;
        __s2 = (char *)v23;
        uint64_t v26 = 0;
        TPostScriptNameString::operator=((uint64_t)v23, (TFontNameString *)v22);
        if (!strcmp(*(const char **)(a1 + 40), __s2))
        {
          uint64_t v21 = *(void *)(a1 + 16);
          *(_WORD *)uint64_t v21 = v13;
          *(unsigned char *)(v21 + 2) = 1;
          *unint64_t v11 = 1;
        }
        free(v24);
      }
      TFontNameString::~TFontNameString((TFontNameString *)v22);
    }
  }
}

void sub_1B52F1158(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
}

uint64_t std::__function::__func<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0,std::allocator<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0,std::allocator<TnameTable::FindPostscriptName(unsigned short const*,unsigned long,char const*)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::target_type()
{
}

void std::__function::__func<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::__clone(uint64_t a1)
{
  unsigned int v2 = (char *)operator new(0x20uLL);
  *(void *)unsigned int v2 = &unk_1F0DFE378;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F0DFE378;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::operator()(uint64_t a1, unsigned __int16 *a2, int *a3, uint64_t *a4, unsigned char **a5)
{
  unsigned int v5 = bswap32(a2[3]) >> 16;
  if (v5 != *(unsigned __int16 *)(a1 + 24)) {
    return;
  }
  int v7 = *a3;
  uint64_t v8 = *a4;
  int v9 = *a5;
  uint64_t v10 = *(void **)(a1 + 8);
  unsigned int v11 = *a2;
  unsigned int v12 = a2[1];
  __int16 v13 = __rev16(a2[2]);
  if (v11 != 256)
  {
    if (v11 == 768 && v12 == 256 && v13 == 9) {
      goto LABEL_8;
    }
LABEL_9:
    if (TFontNameString::IsValid(*(TFontNameString **)(a1 + 16))) {
      return;
    }
    int v14 = 0;
    goto LABEL_11;
  }
  if (a2[2]) {
    goto LABEL_9;
  }
LABEL_8:
  int v14 = 1;
LABEL_11:
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v17[4] = v15;
  v17[5] = v15;
  unsigned __int8 v17[2] = v15;
  unsigned char v17[3] = v15;
  v17[0] = v15;
  v17[1] = v15;
  TDataReference::TDataReference(v16, v10, v7, 0, 0);
  TFontNameString::TFontNameString((TFontNameString *)v17, v5, (const TDataReference *)v16, v8, __rev16(v11), __rev16(v12), v13);
  TDataReference::~TDataReference((TDataReference *)v16);
  if (TFontNameString::IsValid((TFontNameString *)v17))
  {
    TFontNameString::operator=(*(void *)(a1 + 16), (uint64_t)v17);
    if (v14) {
      *int v9 = 1;
    }
  }
  TFontNameString::~TFontNameString((TFontNameString *)v17);
}

void sub_1B52F13C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t std::__function::__func<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0,std::allocator<TnameTable::GetName(unsigned short,unsigned short,unsigned short,unsigned short)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::target_type()
{
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  unsigned int v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    unsigned int v2 = a2;
    do
    {
      long long v3 = (void *)*v2;
      TFontNameString::~TFontNameString((TFontNameString *)(v2 + 3));
      operator delete(v2);
      unsigned int v2 = v3;
    }
    while (v3);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:fe180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      unsigned int v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *unsigned int v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            unsigned int v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          unsigned int v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    uint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void std::__function::__func<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0,std::allocator<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0,std::allocator<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::__clone(uint64_t a1)
{
  unsigned int v2 = (char *)operator new(0x30uLL);
  *(void *)unsigned int v2 = &unk_1F0DFE3F8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0,std::allocator<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F0DFE3F8;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0,std::allocator<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::operator()(void *a1, unsigned __int16 *a2, int *a3, uint64_t *a4)
{
  int v5 = *a3;
  uint64_t v6 = *a4;
  uint64_t v7 = (void *)a1[1];
  unsigned int v8 = bswap32(a2[3]);
  unsigned int v9 = HIWORD(v8);
  __int16 v24 = HIWORD(v8);
  uint64_t v10 = (unsigned __int16 *)a1[4];
  unsigned int v11 = (unsigned __int16 *)a1[5];
  if (v11 != v10)
  {
    unint64_t v13 = v11 - v10;
    do
    {
      unint64_t v14 = v13 >> 1;
      long long v15 = &v10[v13 >> 1];
      unsigned int v17 = *v15;
      uint64_t v16 = v15 + 1;
      v13 += ~(v13 >> 1);
      if (v17 >= v9) {
        unint64_t v13 = v14;
      }
      else {
        uint64_t v10 = v16;
      }
    }
    while (v13);
    if (v10 != v11 && *v10 == v9)
    {
      *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v22 = v18;
      long long v23 = v18;
      void v21[2] = v18;
      void v21[3] = v18;
      v21[0] = v18;
      v21[1] = v18;
      TDataReference::TDataReference(v20, v7, v5, 0, 0);
      TFontNameString::TFontNameString((TFontNameString *)v21, v9, (const TDataReference *)v20, v6, bswap32(*a2) >> 16, bswap32(a2[1]) >> 16, bswap32(a2[2]) >> 16);
      TDataReference::~TDataReference((TDataReference *)v20);
      if (!TFontNameString::IsValid((TFontNameString *)v21))
      {
LABEL_19:
        TFontNameString::~TFontNameString((TFontNameString *)v21);
        return;
      }
      if (WORD2(v22) == 1)
      {
        if (!WORD4(v22))
        {
LABEL_16:
          long long v19 = a1 + 2;
LABEL_18:
          std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<TFontNameString&>>(*v19, v9, &v24, (const TFontNameString *)v21);
          goto LABEL_19;
        }
      }
      else if (BYTE8(v22) == 9 && WORD2(v22) == 3 && WORD3(v22) == 1)
      {
        goto LABEL_16;
      }
      long long v19 = a1 + 3;
      goto LABEL_18;
    }
  }
}

void sub_1B52F1918(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t std::__function::__func<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0,std::allocator<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0,std::allocator<TnameTable::GetNames(unsigned short const*,unsigned long)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::target_type()
{
}

void std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<TFontNameString&>>(uint64_t a1, unsigned __int16 a2, _WORD *a3, const TFontNameString *a4)
{
  unint64_t v7 = a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = a2;
      if (v8 <= a2) {
        unint64_t v10 = a2 % v8;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & a2;
    }
    unsigned int v11 = *(uint64_t ****)(*(void *)a1 + 8 * v10);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v13 = (unint64_t)i[1];
        if (v13 == a2)
        {
          if (*((unsigned __int16 *)i + 8) == a2) {
            return;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v13 >= v8) {
              v13 %= v8;
            }
          }
          else
          {
            v13 &= v8 - 1;
          }
          if (v13 != v10) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  }
  uint64_t v14 = a1 + 16;
  unint64_t v25 = 0xAAAAAAAAAAAAAA00;
  long long v15 = operator new(0x78uLL);
  v24[0] = (uint64_t)v15;
  v24[1] = a1 + 16;
  *long long v15 = 0;
  v15[1] = v7;
  *((_WORD *)v15 + 8) = *a3;
  TFontNameString::TFontNameString((TFontNameString *)(v15 + 3), a4);
  LOBYTE(v25) = 1;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v8 || (float)(v17 * (float)v8) < v16)
  {
    BOOL v18 = 1;
    if (v8 >= 3) {
      BOOL v18 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v8);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__rehash<true>(a1, v21);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v10 = v7 % v8;
      }
      else {
        unint64_t v10 = v7;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v7;
    }
  }
  long long v22 = *(void **)(*(void *)a1 + 8 * v10);
  if (v22)
  {
    *(void *)v24[0] = *v22;
    *long long v22 = v24[0];
  }
  else
  {
    *(void *)v24[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24[0];
    *(void *)(*(void *)a1 + 8 * v10) = v14;
    if (*(void *)v24[0])
    {
      unint64_t v23 = *(void *)(*(void *)v24[0] + 8);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v23 >= v8) {
          v23 %= v8;
        }
      }
      else
      {
        v23 &= v8 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v24[0];
    }
  }
  v24[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned short,TFontNameString>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned short,TFontNameString>,void *>>>>::reset[abi:fe180100](v24, 0);
}

void sub_1B52F1BE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned short,TFontNameString>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned short,TFontNameString>,void *>>>>::reset[abi:fe180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned short,TFontNameString>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned short,TFontNameString>,void *>>>>::reset[abi:fe180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16)) {
      TFontNameString::~TFontNameString((TFontNameString *)(v2 + 24));
    }
    operator delete((void *)v2);
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__node_handle_merge_unique[abi:fe180100]<std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>>(void *result, void *a2)
{
  uint64_t v2 = (unsigned __int16 *)a2[2];
  if (v2)
  {
    int8x8_t v4 = result;
    do
    {
      unint64_t v5 = v2[8];
      __n128 result = std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__node_insert_unique_prepare[abi:fe180100]((uint64_t)v4, v5, v2 + 8);
      uint64_t v6 = *(unsigned __int16 **)v2;
      if (!result)
      {
        std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::remove(a2, v2, (uint64_t)v7);
        v7[0] = 0;
        std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned short,TFontNameString>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned short,TFontNameString>,void *>>>>::reset[abi:fe180100](v7, 0);
        *((void *)v2 + 1) = v5;
        __n128 result = std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__node_insert_unique_perform[abi:fe180100](v4, v2);
      }
      uint64_t v2 = v6;
    }
    while (v6);
  }
  return result;
}

uint64_t **std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__node_insert_unique_prepare[abi:fe180100](uint64_t a1, unint64_t a2, unsigned __int16 *a3)
{
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL) {
      uint64_t v5 = v3 <= a2 ? a2 % v3 : a2;
    }
    else {
      uint64_t v5 = (v3 - 1) & a2;
    }
    uint64_t v6 = *(uint64_t ****)(*(void *)a1 + 8 * v5);
    if (v6)
    {
      for (uint64_t i = *v6; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v8 = (unint64_t)i[1];
        if (v8 == a2)
        {
          if (*((unsigned __int16 *)i + 8) == *a3) {
            return i;
          }
        }
        else
        {
          if (v4.u32[0] > 1uLL)
          {
            if (v8 >= v3) {
              v8 %= v3;
            }
          }
          else
          {
            v8 &= v3 - 1;
          }
          if (v8 != v5) {
            break;
          }
        }
      }
    }
  }
  float v9 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v10 = *(float *)(a1 + 32);
  if (!v3 || (float)(v10 * (float)v3) < v9)
  {
    uint64_t v11 = 2 * v3;
    BOOL v12 = v3 < 3 || (v3 & (v3 - 1)) != 0;
    size_t v13 = v12 | v11;
    unint64_t v14 = vcvtps_u32_f32(v9 / v10);
    if (v13 <= v14) {
      size_t v15 = v14;
    }
    else {
      size_t v15 = v13;
    }
    std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__rehash<true>(a1, v15);
  }
  return 0;
}

void *std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::remove@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  uint64_t v6 = *(void **)(*result + 8 * v4);
  do
  {
    unint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  *unint64_t v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned short,TFontNameString>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,TFontNameString>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,TFontNameString>>>::__node_insert_unique_perform[abi:fe180100](void *result, void *a2)
{
  int8x8_t v2 = (int8x8_t)result[1];
  unint64_t v3 = a2[1];
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *(void *)&v2) {
      v3 %= *(void *)&v2;
    }
  }
  else
  {
    v3 &= *(void *)&v2 - 1;
  }
  uint8x8_t v5 = *(void **)(*result + 8 * v3);
  if (v5)
  {
    *a2 = *v5;
LABEL_13:
    *uint8x8_t v5 = a2;
    goto LABEL_14;
  }
  *a2 = result[2];
  result[2] = a2;
  *(void *)(*result + 8 * v3) = result + 2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v2) {
        v6 %= *(void *)&v2;
      }
    }
    else
    {
      v6 &= *(void *)&v2 - 1;
    }
    uint8x8_t v5 = (void *)(*result + 8 * v6);
    goto LABEL_13;
  }
LABEL_14:
  ++result[3];
  return result;
}

void std::__function::__func<TnameTable::GetAllNames(void)::$_0,std::allocator<TnameTable::GetAllNames(void)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TnameTable::GetAllNames(void)::$_0,std::allocator<TnameTable::GetAllNames(void)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::__clone(uint64_t a1)
{
  int8x8_t v2 = (char *)operator new(0x18uLL);
  *(void *)int8x8_t v2 = &unk_1F0DFE478;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TnameTable::GetAllNames(void)::$_0,std::allocator<TnameTable::GetAllNames(void)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F0DFE478;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TnameTable::GetAllNames(void)::$_0,std::allocator<TnameTable::GetAllNames(void)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::operator()(uint64_t a1, unsigned __int16 *a2, int *a3, uint64_t *a4)
{
  int v6 = *a3;
  uint64_t v7 = *a4;
  unint64_t v8 = *(void **)(a1 + 8);
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v15[4] = v9;
  v15[5] = v9;
  void v15[2] = v9;
  void v15[3] = v9;
  v15[0] = v9;
  v15[1] = v9;
  unsigned int v10 = bswap32(a2[3]) >> 16;
  TDataReference::TDataReference(v14, v8, v6, 0, 0);
  TFontNameString::TFontNameString((TFontNameString *)v15, v10, (const TDataReference *)v14, v7, bswap32(*a2) >> 16, bswap32(a2[1]) >> 16, bswap32(a2[2]) >> 16);
  TDataReference::~TDataReference((TDataReference *)v14);
  if (TFontNameString::IsValid((TFontNameString *)v15))
  {
    unint64_t v11 = *(uint64_t **)(a1 + 16);
    unint64_t v12 = v11[1];
    if (v12 >= v11[2])
    {
      uint64_t v13 = std::vector<TFontNameString>::__push_back_slow_path<TFontNameString const&>(v11, (const TFontNameString *)v15);
    }
    else
    {
      TFontNameString::TFontNameString((TFontNameString *)v11[1], (const TFontNameString *)v15);
      uint64_t v13 = v12 + 96;
      v11[1] = v12 + 96;
    }
    v11[1] = v13;
  }
  TFontNameString::~TFontNameString((TFontNameString *)v15);
}

void sub_1B52F217C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  uint64_t v7 = v6;
  *(void *)(v5 + 8) = v7;
  TFontNameString::~TFontNameString((TFontNameString *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TnameTable::GetAllNames(void)::$_0,std::allocator<TnameTable::GetAllNames(void)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<TnameTable::GetAllNames(void)::$_0,std::allocator<TnameTable::GetAllNames(void)::$_0>,void ()(sfntNameRecord_BE const&,int,unsigned long,BOOL *)>::target_type()
{
}

uint64_t anonymous namespace'::TFormat4UTF16cmapTable::Map<unsigned short>(_DWORD *a1, uint64_t a2, _WORD *a3, unsigned int *a4, int a5)
{
  uint64_t v6 = a3;
  uint64_t v7 = *((void *)a1 + 1);
  if (v7 && *(void *)(v7 + 16))
  {
    unsigned int v8 = *a4;
    a1[4] = *a4;
    a1[5] = v8;
    if (!*a4) {
      goto LABEL_65;
    }
    long long v9 = a1;
    unsigned int v10 = (unsigned __int16 *)(*(uint64_t (**)(void, void, uint64_t))(**(void **)a1 + 16))(*(void *)a1, 0, 4);
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v9, (unint64_t)v10, 1);
    uint64_t v11 = bswap32(*v10) >> 16;
    if (v11)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 4;
    }
    unint64_t v12 = *(void *)(*v9 + 8);
    uint64_t v13 = v10 + 4;
    uint64_t v14 = a2;
    a1 = v9;
    if (v11 < 0x10)
    {
      unsigned int v19 = 0;
      unsigned int v56 = 0;
      unsigned int v52 = 0;
    }
    else
    {
      unsigned int v15 = __clz(v11);
      uint64_t v16 = (1 << (v15 ^ 0x1F));
      if ((unint64_t)v13 + v16 + 2 > v12)
      {
LABEL_7:
        unsigned int v17 = 0;
        *((void *)a1 + 2) = 0;
LABEL_66:
        *a4 = v17;
        return a1[4];
      }
      unsigned int v19 = 30 - v15;
      unsigned int v52 = 1 << (v15 ^ 0x1F);
      unsigned int v56 = bswap32(*(unsigned __int16 *)((char *)v13 + v16)) >> 16;
      unsigned int v10 = (unsigned __int16 *)((char *)v13 + (v11 - v16));
    }
    unint64_t v20 = *a4;
    if (!v20)
    {
LABEL_65:
      unsigned int v17 = a1[5];
      goto LABEL_66;
    }
    unint64_t v21 = 0;
    uint64_t v22 = v11 >> 1;
    uint64_t v23 = (unsigned __int16)v11 & 0xFFFE;
    unsigned int v55 = v19;
    uint64_t v53 = v23;
    uint64_t v54 = v22;
    while (1)
    {
      unint64_t v24 = v21 + 1;
      unsigned int v25 = *(unsigned __int16 *)(v14 + 2 * v21);
      if (v21 + 1 != v20 && (v25 & 0xFC00) == 0xD800)
      {
        int v26 = *(unsigned __int16 *)(v14 + 2 * v24);
        if ((v26 & 0xFC00) == 0xDC00) {
          break;
        }
      }
      if (v25 >> 9 < 0x7F) {
        goto LABEL_28;
      }
      if (v25 >> 4 >= 0xFE1)
      {
        unsigned int v27 = *(unsigned __int16 *)(v14 + 2 * v21);
LABEL_24:
        BOOL v28 = v27 - 917760 < 0xF0;
        if (!v21) {
          goto LABEL_28;
        }
        goto LABEL_25;
      }
      BOOL v28 = 1;
      unsigned int v27 = *(unsigned __int16 *)(v14 + 2 * v21);
      if (!v21) {
        goto LABEL_28;
      }
LABEL_25:
      if (v28)
      {
        int v29 = v13;
        uint64_t v30 = v11;
        BOOL v31 = a1;
        *uint64_t v6 = (__int16)((unsigned __int16)TFormat14UVSTable::Map<unsigned short>(*(void *)(*((void *)a1 + 1) + 16), *(void *)(*((void *)a1 + 1) + 8), *(unsigned __int16 *)(v14 + 2 * v21 - 2), v27, v6 - 1) << 15) >> 15;
        if (v27 >= 0x10000)
        {
          v6[1] = 0;
          v6 += 2;
          unint64_t v24 = v21 + 2;
        }
        else
        {
          ++v6;
        }
        uint64_t v11 = v30;
        uint64_t v13 = v29;
        uint64_t v14 = a2;
        unsigned int v19 = v55;
        a1 = v31;
        uint64_t v23 = v53;
        uint64_t v22 = v54;
        goto LABEL_61;
      }
LABEL_28:
      uint64_t v32 = v13;
      if (v11 >= 0x10)
      {
        if (v25 >= v56) {
          uint64_t v32 = v10;
        }
        else {
          uint64_t v32 = v13;
        }
        if ((unint64_t)v32 + v52 > v12) {
          goto LABEL_7;
        }
        if (v19 >= 4)
        {
          unsigned int v33 = v19;
          LODWORD(v34) = v52;
          do
          {
            unint64_t v35 = v34;
            unint64_t v34 = (unint64_t)v34 >> 1;
            uint64_t v36 = (unsigned __int16 *)((char *)v32 + (v35 >> 1));
            if (v25 > bswap32(*v36) >> 16) {
              uint64_t v32 = v36;
            }
            --v33;
          }
          while (v33 > 3);
        }
      }
      if ((unint64_t)(v32 + 1) <= v12)
      {
        do
        {
          char v37 = v32 + 1;
          unsigned int v39 = *v32;
          int v38 = v32 + 2;
          BOOL v40 = v25 <= bswap32(v39) >> 16 || (unint64_t)v38 > v12;
          uint64_t v32 = v37;
        }
        while (!v40);
        uint64_t v32 = v37;
      }
      unsigned int v41 = &v32[v22];
      if ((unint64_t)&v41[v23 + 1] > v12 || (unsigned int v42 = bswap32(*v41), v25 < HIWORD(v42)))
      {
LABEL_57:
        *v6++ = 0;
        int v50 = a1[4];
        --a1[5];
        if (v50 > (unsigned __int16)v21) {
          a1[4] = (unsigned __int16)v21;
        }
        goto LABEL_61;
      }
      uint64_t v43 = &v41[v22];
      unsigned int v44 = bswap32(*v43) >> 16;
      unsigned int v45 = &v43[v22];
      if (*v45)
      {
        unsigned int v46 = (unsigned __int16 *)((char *)&v45[(unsigned __int16)(v25 - HIWORD(v42))] + __rev16(*v45));
        if (v46 <= v13 || (unint64_t)(v46 + 1) > v12) {
          goto LABEL_57;
        }
        unsigned int v48 = *v46;
        BOOL v49 = v48 == 0;
        unsigned int v25 = v44 + (bswap32(v48) >> 16);
        BOOL v49 = v49 || (unsigned __int16)v25 == 0;
        if (v49) {
          goto LABEL_57;
        }
      }
      else
      {
        LOWORD(v25) = v44 + v25;
        if (!(_WORD)v25) {
          goto LABEL_57;
        }
      }
      *v6++ = v25;
LABEL_61:
      unint64_t v20 = *a4;
      unint64_t v21 = v24;
      if (v24 >= v20) {
        goto LABEL_65;
      }
    }
    unsigned int v27 = v26 + (v25 << 10) - 56613888;
    goto LABEL_24;
  }
}

uint64_t anonymous namespace'::TFormat6UTF16cmapTable::Map<unsigned short>(void *a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  unsigned int v8 = (unsigned __int16 *)(*(uint64_t (**)(void, void, uint64_t))(*(void *)*a1 + 16))(*a1, 0, 4);
  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(a1, (unint64_t)v8, 1);
  unsigned int v9 = *v8;
  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(a1, (unint64_t)(v8 + 1), 1);
  unsigned int v10 = v8[1];
  unsigned int v11 = *a4;
  *((_DWORD *)a1 + 4) = *a4;
  *((_DWORD *)a1 + 5) = v11;
  if (*a4)
  {
    unint64_t v12 = 0;
    unsigned int v13 = bswap32(v9) >> 16;
    uint64_t v14 = v8 + 2;
    unsigned int v15 = bswap32(v10) >> 16;
    do
    {
      if (v15 <= (unsigned __int16)(*(_WORD *)(a2 + 2 * v12) - v13))
      {
        *(_WORD *)(a3 + 2 * v12) = 0;
        int v17 = *((_DWORD *)a1 + 4);
        --*((_DWORD *)a1 + 5);
        if (v17 > (unsigned __int16)v12) {
          *((_DWORD *)a1 + 4) = (unsigned __int16)v12;
        }
      }
      else
      {
        uint64_t v16 = &v14[(unsigned __int16)(*(_WORD *)(a2 + 2 * v12) - v13)];
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(a1, (unint64_t)v16, 1);
        *(_WORD *)(a3 + 2 * v12) = bswap32(*v16) >> 16;
      }
      ++v12;
    }
    while (v12 < *a4);
    unsigned int v11 = *((_DWORD *)a1 + 5);
  }
  *a4 = v11;
  return *((unsigned int *)a1 + 4);
}

uint64_t TFormat14UVSTable::Map<unsigned short>(uint64_t a1, unint64_t a2, int a3, int a4, _WORD *a5)
{
  uint64_t v6 = (unsigned __int8 *)(a1 + 10);
  if ((unint64_t)v6 > a2) {
    return 0;
  }
  unsigned int v10 = bswap32(*(_DWORD *)(a1 + 6));
  unsigned int v11 = &v6[11 * v10];
  if (a1 + 21 <= a2) {
    unsigned int v12 = (a2 - (unint64_t)v6) / 0xB;
  }
  else {
    unsigned int v12 = 0;
  }
  if (v11 < v6 || (unint64_t)v11 > a2) {
    unsigned int v10 = v12;
  }
  uint64_t v14 = std::__equal_range[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,TFormat14UVSTable::VarSelectorRecord const*,TFormat14UVSTable::VarSelectorRecord const*,int,std::__identity>(v6, &v6[11 * v10], a4);
  if (v14 == v15) {
    return 0;
  }
  uint64_t v16 = v14;
  unsigned int v17 = *(_DWORD *)(v14 + 3);
  if (v17)
  {
    BOOL v18 = (unsigned int *)(a1 + bswap32(v17));
    unsigned int v19 = (unsigned __int8 *)(v18 + 1);
    if ((unint64_t)(v18 + 1) <= a2)
    {
      uint64_t v20 = bswap32(*v18);
      unint64_t v21 = &v19[4 * v20];
      if ((unint64_t)(v18 + 2) <= a2) {
        uint64_t v22 = ((a2 - (unint64_t)v19) >> 2);
      }
      else {
        uint64_t v22 = 0;
      }
      if (v21 >= v19 && (unint64_t)v21 <= a2) {
        uint64_t v22 = v20;
      }
      unint64_t v24 = std::__equal_range[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,TFormat14UVSTable::UnicodeValueRange const*,TFormat14UVSTable::UnicodeValueRange const*,int,std::__identity>(v19, &v19[4 * v22], a3);
      if (v24 != v25) {
        return 1;
      }
      goto LABEL_24;
    }
    return 0;
  }
LABEL_24:
  unsigned int v27 = *(_DWORD *)(v16 + 7);
  if (!v27) {
    goto LABEL_37;
  }
  BOOL v28 = (unsigned int *)(a1 + bswap32(v27));
  int v29 = (unsigned __int8 *)(v28 + 1);
  if ((unint64_t)(v28 + 1) > a2)
  {
    int v36 = 0;
    int v37 = 0;
    return v36 | v37;
  }
  uint64_t v30 = bswap32(*v28);
  BOOL v31 = &v29[4 * v30 + v30];
  int v32 = (unint64_t)v28 + 9 <= a2 ? (a2 - (unint64_t)v29) / 5 : 0;
  if (v31 >= v29 && (unint64_t)v31 <= a2) {
    int v32 = v30;
  }
  unint64_t v34 = std::__equal_range[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,TFormat14UVSTable::UVSMapping const*,TFormat14UVSTable::UVSMapping const*,int,std::__identity>(v29, &v29[5 * v32], a3);
  if (v34 == v35)
  {
LABEL_37:
    int v36 = 1;
  }
  else
  {
    int v36 = 0;
    *a5 = bswap32(*(unsigned __int16 *)(v34 + 3)) >> 16;
  }
  int v37 = 1;
  return v36 | v37;
}

unsigned __int8 *std::__equal_range[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,TFormat14UVSTable::VarSelectorRecord const*,TFormat14UVSTable::VarSelectorRecord const*,int,std::__identity>(unsigned __int8 *result, unsigned __int8 *a2, int a3)
{
  if (a2 == result) {
    return a2;
  }
  unint64_t v3 = 0x2E8BA2E8BA2E8BA3 * (a2 - result);
  while (1)
  {
    unint64_t v4 = v3 >> 1;
    uint64_t v5 = &result[11 * (v3 >> 1)];
    int v6 = (*v5 << 16) | (v5[1] << 8) | v5[2];
    if (v6 >= a3) {
      break;
    }
    __n128 result = v5 + 11;
    unint64_t v4 = v3 + ~v4;
LABEL_7:
    unint64_t v3 = v4;
    if (!v4) {
      return result;
    }
  }
  if (v6 > a3)
  {
    a2 = &result[11 * (v3 >> 1)];
    goto LABEL_7;
  }
  uint64_t v7 = &result[11 * (v3 >> 1)];
  if (v3 >= 2)
  {
    uint64_t v7 = result;
    do
    {
      unint64_t v8 = v4 >> 1;
      unsigned int v9 = &v7[11 * (v4 >> 1)];
      int v10 = (*v9 << 16) | (v9[1] << 8) | v9[2];
      unsigned int v11 = v9 + 11;
      v4 += ~(v4 >> 1);
      if (v10 >= a3) {
        unint64_t v4 = v8;
      }
      else {
        uint64_t v7 = v11;
      }
    }
    while (v4);
  }
  unsigned int v12 = v5 + 11;
  if (a2 == v12) {
    return v7;
  }
  unint64_t v13 = 0x2E8BA2E8BA2E8BA3 * (a2 - v12);
  do
  {
    unint64_t v14 = v13 >> 1;
    unsigned int v15 = &v12[11 * (v13 >> 1)];
    int v16 = (*v15 << 16) | (v15[1] << 8) | v15[2];
    unsigned int v17 = v15 + 11;
    v13 += ~(v13 >> 1);
    if (v16 > a3) {
      unint64_t v13 = v14;
    }
    else {
      unsigned int v12 = v17;
    }
  }
  while (v13);
  return v7;
}

unsigned __int8 *std::__equal_range[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,TFormat14UVSTable::UnicodeValueRange const*,TFormat14UVSTable::UnicodeValueRange const*,int,std::__identity>(unsigned __int8 *result, unsigned __int8 *a2, int a3)
{
  if (a2 == result) {
    return a2;
  }
  unint64_t v3 = (a2 - result) >> 2;
  while (1)
  {
    unint64_t v4 = v3 >> 1;
    uint64_t v5 = &result[4 * (v3 >> 1)];
    int v6 = (*v5 << 16) | (v5[1] << 8) | v5[2];
    if (v6 + v5[3] >= a3) {
      break;
    }
    __n128 result = v5 + 4;
    unint64_t v4 = v3 + ~v4;
LABEL_7:
    unint64_t v3 = v4;
    if (!v4) {
      return result;
    }
  }
  if (v6 > a3)
  {
    a2 = &result[4 * (v3 >> 1)];
    goto LABEL_7;
  }
  uint64_t v7 = &result[4 * (v3 >> 1)];
  if (v3 >= 2)
  {
    uint64_t v7 = result;
    do
    {
      unint64_t v8 = v4 >> 1;
      unsigned int v9 = &v7[4 * (v4 >> 1)];
      int v10 = ((*v9 << 16) | (v9[1] << 8) | v9[2]) + v9[3];
      unsigned int v11 = v9 + 4;
      v4 += ~(v4 >> 1);
      if (v10 >= a3) {
        unint64_t v4 = v8;
      }
      else {
        uint64_t v7 = v11;
      }
    }
    while (v4);
  }
  unsigned int v12 = v5 + 4;
  if (a2 == v12) {
    return v7;
  }
  unint64_t v13 = (a2 - v12) >> 2;
  do
  {
    unint64_t v14 = v13 >> 1;
    unsigned int v15 = &v12[4 * (v13 >> 1)];
    int v16 = (*v15 << 16) | (v15[1] << 8) | v15[2];
    unsigned int v17 = v15 + 4;
    v13 += ~(v13 >> 1);
    if (v16 > a3) {
      unint64_t v13 = v14;
    }
    else {
      unsigned int v12 = v17;
    }
  }
  while (v13);
  return v7;
}

unsigned __int8 *std::__equal_range[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,TFormat14UVSTable::UVSMapping const*,TFormat14UVSTable::UVSMapping const*,int,std::__identity>(unsigned __int8 *result, unsigned __int8 *a2, int a3)
{
  if (a2 == result) {
    return a2;
  }
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * (a2 - result);
  while (1)
  {
    unint64_t v4 = v3 >> 1;
    uint64_t v5 = &result[5 * (v3 >> 1)];
    int v6 = (*v5 << 16) | (v5[1] << 8) | v5[2];
    if (v6 >= a3) {
      break;
    }
    __n128 result = v5 + 5;
    unint64_t v4 = v3 + ~v4;
LABEL_7:
    unint64_t v3 = v4;
    if (!v4) {
      return result;
    }
  }
  if (v6 > a3)
  {
    a2 = &result[5 * (v3 >> 1)];
    goto LABEL_7;
  }
  uint64_t v7 = &result[5 * (v3 >> 1)];
  if (v3 >= 2)
  {
    uint64_t v7 = result;
    do
    {
      unint64_t v8 = v4 >> 1;
      unsigned int v9 = &v7[5 * (v4 >> 1)];
      int v10 = (*v9 << 16) | (v9[1] << 8) | v9[2];
      unsigned int v11 = v9 + 5;
      v4 += ~(v4 >> 1);
      if (v10 >= a3) {
        unint64_t v4 = v8;
      }
      else {
        uint64_t v7 = v11;
      }
    }
    while (v4);
  }
  unsigned int v12 = v5 + 5;
  if (a2 == v12) {
    return v7;
  }
  unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * (a2 - v12);
  do
  {
    unint64_t v14 = v13 >> 1;
    unsigned int v15 = &v12[5 * (v13 >> 1)];
    int v16 = (*v15 << 16) | (v15[1] << 8) | v15[2];
    unsigned int v17 = v15 + 5;
    v13 += ~(v13 >> 1);
    if (v16 > a3) {
      unint64_t v13 = v14;
    }
    else {
      unsigned int v12 = v17;
    }
  }
  while (v13);
  return v7;
}

BOOL ComputeIndex12or13<(anonymous namespace'::SubtableFormat12or13)0,unsigned short>(unsigned int *a1, unint64_t a2, unsigned int a3, _WORD *a4)
{
  if ((unint64_t)a1 >= a2) {
    goto LABEL_12;
  }
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - (void)a1) >> 2);
  uint64_t v5 = a1;
  do
  {
    unint64_t v6 = v4 >> 1;
    uint64_t v7 = &v5[3 * (v4 >> 1)];
    unsigned int v9 = *v7;
    unint64_t v8 = v7 + 3;
    v4 += ~(v4 >> 1);
    if (bswap32(v9) > a3) {
      unint64_t v4 = v6;
    }
    else {
      uint64_t v5 = v8;
    }
  }
  while (v4);
  int v10 = v5 - 3;
  if (v5 == a1) {
    int v10 = a1;
  }
  if (v10 == a1 && bswap32(*a1) > a3 || bswap32(v10[1]) < a3)
  {
LABEL_12:
    LOWORD(v11) = 0;
    BOOL result = 0;
  }
  else
  {
    unsigned int v11 = bswap32(v10[2]) + a3 - bswap32(*v10);
    BOOL result = v11 < 0xFFFF;
    if (v11 >= 0xFFFF) {
      LOWORD(v11) = 0;
    }
  }
  *a4 = v11;
  return result;
}

uint64_t TFormat14UVSTable::Map<unsigned int>(uint64_t a1, unint64_t a2, int a3, int a4, unsigned int *a5)
{
  unint64_t v6 = (unsigned __int8 *)(a1 + 10);
  if ((unint64_t)v6 > a2) {
    return 0;
  }
  unsigned int v10 = bswap32(*(_DWORD *)(a1 + 6));
  unsigned int v11 = &v6[11 * v10];
  if (a1 + 21 <= a2) {
    unsigned int v12 = (a2 - (unint64_t)v6) / 0xB;
  }
  else {
    unsigned int v12 = 0;
  }
  if (v11 < v6 || (unint64_t)v11 > a2) {
    unsigned int v10 = v12;
  }
  unint64_t v14 = std::__equal_range[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,TFormat14UVSTable::VarSelectorRecord const*,TFormat14UVSTable::VarSelectorRecord const*,int,std::__identity>(v6, &v6[11 * v10], a4);
  if (v14 == v15) {
    return 0;
  }
  int v16 = v14;
  unsigned int v17 = *(_DWORD *)(v14 + 3);
  if (v17)
  {
    BOOL v18 = (unsigned int *)(a1 + bswap32(v17));
    unsigned int v19 = (unsigned __int8 *)(v18 + 1);
    if ((unint64_t)(v18 + 1) <= a2)
    {
      uint64_t v20 = bswap32(*v18);
      unint64_t v21 = &v19[4 * v20];
      if ((unint64_t)(v18 + 2) <= a2) {
        uint64_t v22 = ((a2 - (unint64_t)v19) >> 2);
      }
      else {
        uint64_t v22 = 0;
      }
      if (v21 >= v19 && (unint64_t)v21 <= a2) {
        uint64_t v22 = v20;
      }
      unint64_t v24 = std::__equal_range[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,TFormat14UVSTable::UnicodeValueRange const*,TFormat14UVSTable::UnicodeValueRange const*,int,std::__identity>(v19, &v19[4 * v22], a3);
      if (v24 != v25) {
        return 1;
      }
      goto LABEL_24;
    }
    return 0;
  }
LABEL_24:
  unsigned int v27 = *(_DWORD *)(v16 + 7);
  if (!v27) {
    goto LABEL_37;
  }
  BOOL v28 = (unsigned int *)(a1 + bswap32(v27));
  int v29 = (unsigned __int8 *)(v28 + 1);
  if ((unint64_t)(v28 + 1) > a2)
  {
    int v36 = 0;
    int v37 = 0;
    return v36 | v37;
  }
  uint64_t v30 = bswap32(*v28);
  BOOL v31 = &v29[4 * v30 + v30];
  int v32 = (unint64_t)v28 + 9 <= a2 ? (a2 - (unint64_t)v29) / 5 : 0;
  if (v31 >= v29 && (unint64_t)v31 <= a2) {
    int v32 = v30;
  }
  unint64_t v34 = std::__equal_range[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,TFormat14UVSTable::UVSMapping const*,TFormat14UVSTable::UVSMapping const*,int,std::__identity>(v29, &v29[5 * v32], a3);
  if (v34 == v35)
  {
LABEL_37:
    int v36 = 1;
  }
  else
  {
    int v36 = 0;
    *a5 = bswap32(*(unsigned __int16 *)(v34 + 3)) >> 16;
  }
  int v37 = 1;
  return v36 | v37;
}

BOOL ComputeIndex12or13<(anonymous namespace'::SubtableFormat12or13)0,unsigned int>(unsigned int *a1, unint64_t a2, unsigned int a3, unsigned int *a4)
{
  if ((unint64_t)a1 >= a2) {
    goto LABEL_12;
  }
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - (void)a1) >> 2);
  uint64_t v5 = a1;
  do
  {
    unint64_t v6 = v4 >> 1;
    uint64_t v7 = &v5[3 * (v4 >> 1)];
    unsigned int v9 = *v7;
    unint64_t v8 = v7 + 3;
    v4 += ~(v4 >> 1);
    if (bswap32(v9) > a3) {
      unint64_t v4 = v6;
    }
    else {
      uint64_t v5 = v8;
    }
  }
  while (v4);
  unsigned int v10 = v5 - 3;
  if (v5 == a1) {
    unsigned int v10 = a1;
  }
  if (v10 == a1 && bswap32(*a1) > a3 || bswap32(v10[1]) < a3)
  {
LABEL_12:
    unsigned int v11 = 0;
    BOOL result = 0;
  }
  else
  {
    unsigned int v11 = bswap32(v10[2]) + a3 - bswap32(*v10);
    BOOL result = v11 < 0xFFFFFF;
    if (v11 >= 0xFFFFFF) {
      unsigned int v11 = 0;
    }
  }
  *a4 = v11;
  return result;
}

uint64_t TFormat4cmapTable::Map<unsigned short>(TFormat4cmapTable *this, void *a2, unsigned int a3, _WORD *a4, unsigned int *a5)
{
  unsigned int v6 = 0;
  uint64_t v21 = *a5;
  unint64_t v23 = (unint64_t)&a4[v21];
  if (a3 && *a5)
  {
    unsigned int v6 = 0;
    unsigned int v10 = 1;
    unint64_t v11 = (unint64_t)a4;
    LODWORD(v12) = *a5;
    unint64_t v13 = a4;
    do
    {
      unint64_t v14 = (unsigned __int8 *)(*a2)++;
      int v15 = TFormat4cmapTable::ComputeIndex(this, *v14);
      unsigned int v16 = *a5;
      if (v12 == *a5) {
        unsigned int v17 = v10 - 1;
      }
      else {
        unsigned int v17 = v12;
      }
      if (v15)
      {
        ++v6;
        uint64_t v12 = v12;
      }
      else
      {
        uint64_t v12 = v17;
      }
      *v13++ = v15;
      v11 += 2;
      if (v10 >= a3) {
        break;
      }
    }
    while (v10++ < v16);
  }
  else
  {
    unint64_t v11 = (unint64_t)a4;
    unint64_t v13 = a4;
    uint64_t v12 = *a5;
  }
  if ((unint64_t)v13 < v23)
  {
    unint64_t v19 = (unint64_t)&a4[v21];
    if (v19 <= v11 + 2) {
      unint64_t v19 = v11 + 2;
    }
    bzero(v13, ((v19 + ~v11) & 0xFFFFFFFFFFFFFFFELL) + 2);
  }
  *a5 = v6;
  return v12;
}

uint64_t TFormat4cmapTable::ComputeIndex(TFormat4cmapTable *this, unsigned int a2)
{
  unint64_t v3 = (void *)((char *)this + 8);
  unint64_t v4 = (unsigned __int16 *)(*(uint64_t (**)(void, void, uint64_t))(**((void **)this + 1) + 16))(*((void *)this + 1), 0, 4);
  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v3, (unint64_t)v4, 1);
  uint64_t v5 = bswap32(*v4) >> 16;
  if (v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  if (v5 < 0x10)
  {
    uint64_t v12 = v4 + 4;
  }
  else
  {
    unsigned int v6 = __clz(v5 >> 1);
    unsigned int v7 = v6 ^ 0x1F;
    LODWORD(v8) = 2 << (v6 ^ 0x1F);
    unsigned int v9 = v4 + 4;
    unsigned int v10 = &v4[(1 << (v6 ^ 0x1F)) + 4];
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v3, (unint64_t)v10, 1);
    if (a2 >= bswap32(*v10) >> 16) {
      uint64_t v11 = (v5 - v8) >> 1;
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = &v9[v11];
    if (v7 >= 4)
    {
      do
      {
        unint64_t v13 = v8;
        unint64_t v8 = (unint64_t)v8 >> 1;
        unint64_t v14 = (unsigned __int16 *)((char *)v12 + (v13 >> 1));
        TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v3, (unint64_t)v14, 1);
        if (a2 > bswap32(*v14) >> 16) {
          uint64_t v12 = v14;
        }
        --v7;
      }
      while (v7 > 3);
    }
  }
  do
  {
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v3, (unint64_t)v12, 1);
    unsigned int v15 = *v12++;
  }
  while (a2 > bswap32(v15) >> 16);
  TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v3, (unint64_t)v12 + v5, 1);
  if (a2 >= bswap32(*(unsigned __int16 *)((char *)v12 + v5)) >> 16)
  {
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v3, (unint64_t)v12 + v5, 1);
    unsigned int v17 = *(unsigned __int16 *)((char *)v12 + v5);
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v3, (unint64_t)&v12[v5], 1);
    unsigned int v18 = bswap32(v12[v5]) >> 16;
    TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v3, (unint64_t)v12 + 3 * v5, 1);
    if (a2 == 0xFFFF || !*(unsigned __int16 *)((char *)v12 + 3 * v5))
    {
      return (unsigned __int16)(v18 + a2);
    }
    else
    {
      TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v3, (unint64_t)v12 + 3 * v5, 1);
      unint64_t v19 = (unsigned __int16 *)((char *)v12
                               + 3 * v5
                               + 2 * (unsigned __int16)(a2 - (bswap32(v17) >> 16))
                               + (bswap32(*(unsigned __int16 *)((char *)v12 + 3 * v5)) >> 16));
      TcmapTableDataRef::validateArray<FPBigEndianScalar<unsigned short>>(v3, (unint64_t)v19, 1);
      unsigned int v20 = v18 + (bswap32((unsigned __int16)*v19) >> 16);
      if (*v19) {
        return (unsigned __int16)v20;
      }
      else {
        return 0;
      }
    }
  }
  else
  {
    return 0;
  }
}

uint64_t TFormat6cmapTable::Map<unsigned short>(TFormat6cmapTable *a1, uint64_t *a2, unsigned int a3, _WORD *a4, unsigned int *a5)
{
  if (TFormat6cmapTable::VerifyCMAP(a1))
  {
    uint64_t v10 = *a5;
    uint64_t v11 = (unsigned __int16 *)(*(uint64_t (**)(void, void, uint64_t))(**(void **)a1 + 16))(*(void *)a1, 0, 4);
    unsigned int v12 = *a5;
    if (*a5 >= a3) {
      unsigned int v13 = a3;
    }
    else {
      unsigned int v13 = *a5;
    }
    if (v13)
    {
      unsigned int v14 = 0;
      unsigned int v15 = 0;
      unsigned int v16 = bswap32(*v11) >> 16;
      unsigned int v17 = bswap32(v11[1]) >> 16;
      unsigned int v18 = v11 + 2;
      uint64_t v19 = *a2 + 1;
      unint64_t v20 = (unint64_t)a4;
      uint64_t v21 = *a5;
      uint64_t v22 = a4;
      while (1)
      {
        *a2 = v19;
        if (v17 <= (unsigned __int16)(*(unsigned __int8 *)(v19 - 1) - (_WORD)v16)) {
          break;
        }
        unsigned int v23 = v18[(unsigned __int16)(*(unsigned __int8 *)(v19 - 1) - (_WORD)v16)];
        if (!v18[(unsigned __int16)(*(unsigned __int8 *)(v19 - 1) - (_WORD)v16)]) {
          goto LABEL_11;
        }
        LOWORD(v23) = __rev16(v23);
        ++v15;
LABEL_14:
        ++v19;
        *v22++ = v23;
        ++v14;
        v20 += 2;
        if (v13 == v14) {
          goto LABEL_18;
        }
      }
      LOWORD(v23) = 0;
LABEL_11:
      if (v21 == v12) {
        uint64_t v21 = v14;
      }
      else {
        uint64_t v21 = v21;
      }
      goto LABEL_14;
    }
    unsigned int v15 = 0;
    unint64_t v20 = (unint64_t)a4;
    uint64_t v22 = a4;
    uint64_t v21 = *a5;
LABEL_18:
    if (v22 < &a4[v10])
    {
      unint64_t v24 = (unint64_t)&a4[v10];
      if (v24 <= v20 + 2) {
        unint64_t v24 = v20 + 2;
      }
      bzero(v22, ((v24 + ~v20) & 0xFFFFFFFFFFFFFFFELL) + 2);
    }
  }
  else
  {
    unsigned int v15 = 0;
    uint64_t v21 = 0;
  }
  *a5 = v15;
  return v21;
}

void StreamTTFont(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v297 = *MEMORY[0x1E4F143B8];
  unsigned int v7 = *(memoryContext **)a1;
  v243 = 0;
  v244 = 0;
  unsigned int FontProtectionInfo = TFontSurrogate::GetFontProtectionInfo((TFontSurrogate *)(*(void *)v7 + 16), 0);
  uint64_t v242 = a2;
  if (!*(void *)(*(void *)(a2 + 8) + 56))
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  unsigned int v9 = FontProtectionInfo;
  v222 = v7;
  ScalerGetFontTable(v7, 1751474532, 0, &v243, 0, 54);
  unsigned int FontTable = ScalerGetFontTable(v7, 1886352244, 0, &v244, 1, 0);
  uint64_t v10 = HIWORD(v9) & 0x30E;
  uint64_t v11 = *(void *)(a2 + 8);
  size_t v18 = strlen(*(const char **)(v11 + 56));
  if (a3) {
    goto LABEL_3;
  }
  if ((*(unsigned char *)(v11 + 16) & 8) == 0)
  {
    if (*(_DWORD *)(v11 + 28) == -1)
    {
      v254[0] = -1431655766;
      CFRange v89 = (char *)ZGetString(41, v254);
      StreamBytesThroughBuffer(v242, v254[0], v89);
    }
LABEL_3:
    uint64_t v19 = v243;
    ZWriteStringF(v242, 0, v12, v13, v14, v15, v16, v17, v18);
    goto LABEL_4;
  }
  uint64_t v19 = v243;
  ZWriteStringF(v242, 1, v12, v13, v14, v15, v16, v17, bswap32(*(_DWORD *)v243));
LABEL_4:
  if (v10) {
    ZWriteStringF(v242, 203, v20, v21, v22, v23, v24, v25, v10);
  }
  ZWriteStringF(v242, 2, v20, v21, v22, v23, v24, v25, v18);
  v254[0] = -1431655766;
  int v26 = (char *)ZGetString(3, v254);
  StreamBytesThroughBuffer(v242, v254[0], v26);
  v254[0] = -1431655766;
  unsigned int v27 = (char *)ZGetString(7, v254);
  StreamBytesThroughBuffer(v242, v254[0], v27);
  v227 = v244;
  DumpFontEncoding(v222, v242, (uint64_t)v244, FontTable);
  v254[0] = -1431655766;
  BOOL v28 = (char *)ZGetString(8, v254);
  StreamBytesThroughBuffer(v242, v254[0], v28);
  if (a3)
  {
    v254[0] = -1431655766;
    int v29 = (char *)ZGetString(200, v254);
    StreamBytesThroughBuffer(v242, v254[0], v29);
  }
  if ((*(_DWORD *)(*(void *)(v242 + 8) + 16) & 8) != 0) {
    int v30 = 5;
  }
  else {
    int v30 = 4;
  }
  v254[0] = -1431655766;
  BOOL v31 = (char *)ZGetString(v30, v254);
  StreamBytesThroughBuffer(v242, v254[0], v31);
  v254[0] = -1431655766;
  int v32 = (char *)ZGetString(9, v254);
  StreamBytesThroughBuffer(v242, v254[0], v32);
  ZWriteStringF(v242, 10, v33, v34, v35, v36, v37, v38, bswap32(*((unsigned __int16 *)v19 + 9)) >> 16);
  uint64_t v45 = *(void *)(v242 + 8);
  if ((*(unsigned char *)(v45 + 16) & 8) == 0)
  {
    unsigned int v46 = bswap32(v19[2]);
    int v47 = *(_DWORD *)(v45 + 28);
    if (v47 >= 1)
    {
      unsigned int v48 = *(int **)(v45 + 32);
      unsigned int v49 = v47 + 1;
      do
      {
        int v50 = *v48;
        int v51 = v48[1];
        v48 += 2;
        v46 += v50 + v51;
        --v49;
      }
      while (v49 > 1);
    }
    ZWriteStringF(v242, 13, v39, v40, v41, v42, v43, v44, v46 & 0x7FFFFF | 0x800000);
    uint64_t v45 = *(void *)(v242 + 8);
  }
  v235 = *(memoryContext **)a1;
  v223 = v19;
  unsigned int v52 = *((__int16 *)v19 + 25);
  uint64_t v53 = *(unsigned int **)(v45 + 48);
  *(void *)&long long v54 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v54 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v272 = v54;
  long long v273 = v54;
  v270[4] = v54;
  *(_OWORD *)v271 = v54;
  v270[2] = v54;
  v270[3] = v54;
  v270[0] = v54;
  v270[1] = v54;
  long long v268 = v54;
  long long v269 = v54;
  long long v266 = v54;
  long long v267 = v54;
  long long v264 = v54;
  long long v265 = v54;
  long long v262 = v54;
  long long v263 = v54;
  long long v260 = v54;
  long long v261 = v54;
  long long v258 = v54;
  long long v259 = v54;
  long long v256 = v54;
  long long v257 = v54;
  *(_OWORD *)v254 = v54;
  long long v255 = v54;
  InitGlyphDataContext(a1, v45, (uint64_t)v254);
  uint64_t v55 = *(void *)(a1 + 8);
  int v56 = *(_DWORD *)(v55 + 100);
  int v274 = v56;
  if (!v56)
  {
    v209 = __cxa_allocate_exception(2uLL);
    _WORD *v209 = 5;
    __cxa_throw(v209, MEMORY[0x1E4FBA3C8], 0);
  }
  if (v56 == -1)
  {
    v210 = __cxa_allocate_exception(2uLL);
    _WORD *v210 = 4;
    __cxa_throw(v210, MEMORY[0x1E4FBA3C8], 0);
  }
  if (v52) {
    char v57 = 2;
  }
  else {
    char v57 = 1;
  }
  int v58 = (v56 >> v57) - 1;
  int v59 = *(unsigned __int16 *)(v55 + 40);
  if (v58 < v59) {
    int v59 = v58;
  }
  int v274 = v59;
  *(void *)&long long v60 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v60 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v295 = v60;
  long long v296 = v60;
  long long v293 = v60;
  long long v294 = v60;
  long long v291 = v60;
  long long v292 = v60;
  *(_OWORD *)v289 = v60;
  long long v290 = v60;
  *v53 |= 0x80000000;
  v276[0] = 0;
  ScalerGetFontTable(v235, 1751672161, 0, v276, 0, 36);
  unsigned int v61 = *((unsigned __int16 *)v276[0] + 17);
  ScalerReleaseFontTable(v235, v276[0]);
  v253 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
  ScalerGetFontTable(v235, 1819239265, 0, &v253, 0, 0);
  unsigned int v62 = v253;
  unsigned int v230 = AccumulateComponentGlyphBits(v235, &v274, v53, v253, v52, 0);
  uint64_t v63 = malloc_type_calloc((unsigned __int16)v230, 2uLL, 0x1000040BDFB0063uLL);
  size_t count = (unsigned __int16)v230 + 1;
  v225 = (char *)malloc_type_calloc(count, 4uLL, 0x100004052888210uLL);
  unsigned int v239 = 0;
  int v241 = 0;
  int v64 = 0;
  char v65 = 0;
  *(_DWORD *)v225 = 0;
  int v66 = v225 + 4;
  uint64_t v240 = (unsigned __int16)((bswap32(v61) >> 16) - 1);
  unsigned int v67 = v63;
  do
  {
    if (*v53)
    {
      unsigned int v68 = 0x80000000;
      int v69 = v274;
      do
      {
        if ((*v53 & v68) != 0)
        {
          v65 |= v240 == v64;
          if (v64 >= v69) {
            break;
          }
          int NewGlyphSize = GetNewGlyphSize((uint64_t)v254, *(memoryContext **)a1, (unsigned __int16)v64, (uint64_t)v62, v52);
          *v67++ = v64;
          v239 += NewGlyphSize;
          *v66++ = bswap32(v239);
          int v71 = v241;
          if (v64 <= (int)v240) {
            int v71 = v241 + 1;
          }
          int v241 = v71;
          int v69 = v274;
        }
        ++v64;
        if (v68 < 2) {
          break;
        }
        v68 >>= 1;
      }
      while (v64 < v69);
    }
    else
    {
      v64 += 32;
      int v69 = v274;
    }
    ++v53;
  }
  while (v64 < v69);
  int v72 = 2 * ((unsigned __int16)v230 - (unsigned __int16)v241) + 4 * (unsigned __int16)v241 + 2;
  if (((unsigned __int16)v241 >= (unsigned __int16)v230) | v65 & 1) {
    int v72 = 2 * ((unsigned __int16)v230 - (unsigned __int16)v241) + 4 * (unsigned __int16)v241;
  }
  char v216 = ((unsigned __int16)v241 >= (unsigned __int16)v230) | v65;
  unsigned int v217 = v72;
  ScalerReleaseFontTable(v235, v62);
  unsigned int v73 = v225;
  int v74 = (unsigned __int16)v230;
  if (bswap32(*(_DWORD *)&v225[4 * (unsigned __int16)v230]) >> 17)
  {
    __int16 v215 = 256;
    int v78 = 4;
    char v79 = 2;
  }
  else
  {
    unsigned int v75 = (unsigned __int16)v230 + 2;
    unint64_t v76 = (unsigned int *)v225;
    do
    {
      unsigned int v77 = *v76++;
      *(_WORD *)unsigned int v73 = bswap32(bswap32(v77) >> 1) >> 16;
      v73 += 2;
      --v75;
    }
    while (v75 > 1);
    __int16 v215 = 0;
    int v78 = 2;
    char v79 = 1;
  }
  if (BYTE1(v271[0]))
  {
    LODWORD(v276[0]) = 0;
    TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)v235 + 16), 1735811442, (unsigned int *)v276);
    if (LODWORD(v276[0]))
    {
      v276[0] = (void *)0xAAAAAAAAAAAAAAAALL;
      ScalerGetFontTable(v235, 1735811442, 0, v276, 0, 36);
      unsigned int v80 = malloc_type_calloc(count, 4uLL, 0x100004052888210uLL);
      v221 = (char *)v80;
      int v81 = v78;
      uint64_t v82 = v276[0];
      unsigned int v236 = *((_DWORD *)v276[0] + 4);
      unsigned int v83 = *((_DWORD *)v276[0] + 2);
      *unsigned int v80 = 0;
      if ((_WORD)v230)
      {
        unsigned int v84 = 0;
        unint64_t v85 = v80 + 1;
        int v86 = count;
        unint64_t v87 = v63;
        do
        {
          unsigned int v88 = *v87++;
          v84 += GetGlyphVariationOffsetAndSize(v88, (uint64_t)v82, 0);
          *v85++ = bswap32(v84);
          --v86;
        }
        while (v86 > 1);
      }
      else
      {
        unsigned int v84 = 0;
      }
      CFRange v91 = v221;
      if (bswap32(*(_DWORD *)&v221[4 * (unsigned __int16)v230]) >> 17)
      {
        char v95 = 2;
        unsigned int v233 = 1;
        int v78 = v81;
      }
      else
      {
        int v92 = (unsigned __int16)v230 + 2;
        int v93 = (unsigned int *)v221;
        int v78 = v81;
        do
        {
          unsigned int v94 = *v93++;
          *(_WORD *)CFRange v91 = bswap32(bswap32(v94) >> 1) >> 16;
          v91 += 2;
          --v92;
        }
        while (v92 > 1);
        unsigned int v233 = 0;
        char v95 = 1;
      }
      ScalerReleaseFontTable(v235, v82);
      unsigned int v90 = bswap32(v236) - bswap32(v83) + v84 + (count << v95) + 20;
    }
    else
    {
      unsigned int v233 = 0;
      v221 = 0;
      unsigned int v90 = 0;
    }
    int v74 = (unsigned __int16)v230;
  }
  else
  {
    unsigned int v233 = 0;
    v221 = 0;
    unsigned int v90 = 0;
  }
  uint64_t v96 = 0;
  unsigned int v97 = 0;
  unsigned int v98 = 0;
  memset(__src, 170, 28);
  int v224 = (v74 << v79) + v78;
  *(void *)&long long v99 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v99 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v287 = v99;
  long long v288 = v99;
  long long v285 = v99;
  long long v286 = v99;
  int v100 = v239;
  if (!v239) {
    int v100 = 4;
  }
  unsigned int v237 = v100;
  long long v283 = v99;
  long long v284 = v99;
  long long v281 = v99;
  long long v282 = v99;
  long long v279 = v99;
  long long v280 = v99;
  long long v277 = v99;
  long long v278 = v99;
  *(_OWORD *)v276 = v99;
  do
  {
    if (BYTE1(v271[0])) {
      BOOL v101 = 1;
    }
    else {
      BOOL v101 = (unsigned __int16)v96 > 6u;
    }
    if (v101 || ((1 << v96) & 0x53) == 0)
    {
      int v103 = DumpFontData(fsg_SplineKey *,streamBuffer *,sfntFontHeader const*,sfntPostScriptInfo const*,unsigned int,BOOL)::fontTables[v96];
      LODWORD(v245[0]) = 0;
      TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)v235 + 16), v103, (unsigned int *)v245);
      unsigned int v104 = v245[0];
      if (((uint64_t)v245[0] & 0x80000000) == 0)
      {
        long long v105 = &v276[2 * (__int16)v98];
        *(_DWORD *)long long v105 = v103;
        *((_DWORD *)v105 + 1) = 0;
        *((_DWORD *)v105 + 2) = v97;
        if (v103 > 1751672160)
        {
          if (v103 <= 1819239264)
          {
            if (v103 == 1751672161)
            {
              unsigned int v106 = 36;
            }
            else
            {
              unsigned int v106 = v104;
              if (v103 == 1752003704) {
                unsigned int v106 = v217;
              }
            }
            goto LABEL_96;
          }
          unsigned int v106 = v224;
          if (v103 == 1819239265) {
            goto LABEL_96;
          }
          if (v103 == 1835104368)
          {
            unsigned int v106 = 32;
            goto LABEL_96;
          }
          unsigned int v106 = v104;
          int v107 = 1886545264;
        }
        else
        {
          if (v103 > 1735162213)
          {
            unsigned int v106 = v237;
            if (v103 != 1735162214)
            {
              unsigned int v106 = v90;
              if (v103 != 1735811442)
              {
                unsigned int v106 = v104;
                if (v103 == 1751474532) {
                  unsigned int v106 = 54;
                }
              }
            }
            goto LABEL_96;
          }
          if (v103 == 1668707360) {
            goto LABEL_88;
          }
          unsigned int v106 = v104;
          int v107 = 1718642541;
        }
        if (v103 == v107)
        {
LABEL_88:
          if (v104) {
            unsigned int v106 = v104;
          }
          else {
            unsigned int v106 = 4;
          }
        }
LABEL_96:
        unsigned int v97 = (v97 + v106 + 3) & 0xFFFFFFFC;
        HIDWORD(v276[2 * (__int16)v98++ + 1]) = bswap32(v106);
      }
    }
    ++v96;
  }
  while (v96 != 13);
  int v108 = (16 * (__int16)v98) | 0xC;
  if ((__int16)v98 >= 1)
  {
    uint64_t v109 = (unsigned __int16)v98;
    int v110 = &v276[1];
    do
    {
      *(_DWORD *)int v110 = bswap32(*(_DWORD *)v110 + v108);
      *((_DWORD *)v110 - 2) = bswap32(*((_DWORD *)v110 - 2));
      v110 += 2;
      --v109;
    }
    while (v109);
  }
  LODWORD(__src[0]) = 1702195828;
  WORD2(__src[0]) = bswap32(v98) >> 16;
  *(_DWORD *)((char *)__src + 6) = 0;
  WORD1(__src[1]) = 0;
  *(_DWORD *)(v242 + 131112) = 0;
  int v251 = 0;
  if (a4) {
    int v111 = 14;
  }
  else {
    int v111 = 119;
  }
  LODWORD(v245[0]) = -1431655766;
  unsigned int v112 = (char *)ZGetString(v111, (int *)v245);
  StreamBytesThroughBuffer(v242, (int)v245[0], v112);
  ZWriteDataHex(v242, 12, (char *)__src, a4);
  ZWriteDataHex(v242, 16 * (__int16)v98, (char *)v276, a4);
  if ((__int16)v98 > 0)
  {
    if (a4) {
      int v113 = 15;
    }
    else {
      int v113 = 120;
    }
    int v229 = v113;
    unsigned int v219 = bswap32(v230) >> 16;
    unsigned int v214 = bswap32(v241 + ((v216 & 1) == 0)) >> 16;
    if (v233) {
      char v114 = 2;
    }
    else {
      char v114 = 1;
    }
    int v211 = count << v114;
    unsigned int v218 = (count << v114) + 20;
    unsigned int v213 = bswap32(v218);
    __int16 v212 = __rev16(v233);
    uint64_t v226 = (unsigned __int16)v98;
    uint64_t v115 = 0;
    do
    {
      uint64_t v232 = v115;
      unsigned int v116 = (unsigned int *)&v276[2 * v115];
      unsigned int v117 = *v116;
      unsigned int v118 = bswap32(*v116);
      if (bswap32(v116[3]) + v108 >= 0xFFFF && v118 != 1735162214 && v118 != 1735811442)
      {
        LODWORD(v245[0]) = -1431655766;
        int v135 = (char *)ZGetString(v229, (int *)v245);
        StreamBytesThroughBuffer(v242, (int)v245[0], v135);
        int v108 = 0;
        unsigned int v117 = *v116;
      }
      uint64_t v234 = (unint64_t)v116 | 0xC;
      uint64_t v121 = bswap32(v117);
      if ((int)v121 > 1751672160)
      {
        if ((int)v121 <= 1819239264)
        {
          if (v121 != 1751672161)
          {
            if (v121 == 1752003704)
            {
              uint64_t v128 = v272;
              if (v271[1]) {
                int v129 = (char *)v271[1];
              }
              else {
                int v129 = (char *)v268;
              }
              if (!v271[1]) {
                uint64_t v128 = (void **)v270 + 1;
              }
              unint64_t v130 = (unint64_t)*v128;
              unsigned int v131 = v63;
              if ((_WORD)v241)
              {
                int v132 = 0;
                unsigned int v131 = v63;
                do
                {
                  unint64_t v133 = &v129[4 * *v131];
                  if ((unint64_t)(v133 + 4) <= v130) {
                    ZWriteDataHex(v242, 4, v133, a4);
                  }
                  else {
                    ZWriteDataHex(v242, 4, DumpFontData(fsg_SplineKey *,streamBuffer *,sfntFontHeader const*,sfntPostScriptInfo const*,unsigned int,BOOL)::kZeroLongMetrics, a4);
                  }
                  ++v131;
                  ++v132;
                }
                while ((unsigned __int16)v132 < (unsigned __int16)v241);
              }
              if ((unsigned __int16)v241 < (unsigned __int16)v230)
              {
                if ((v216 & 1) == 0)
                {
                  int v134 = &v129[4 * v240];
                  if ((unint64_t)(v134 + 2) <= v130) {
                    ZWriteDataHex(v242, 2, v134, a4);
                  }
                  else {
                    ZWriteDataHex(v242, 2, DumpFontData(fsg_SplineKey *,streamBuffer *,sfntFontHeader const*,sfntPostScriptInfo const*,unsigned int,BOOL)::kZeroLongMetrics, a4);
                  }
                }
                uint64_t v183 = (uint64_t)&v129[4 * v240 + 2 + -2 * v240];
                int v184 = v241;
                do
                {
                  if (v183 + 2 * (unint64_t)*v131 + 2 <= v130) {
                    v185 = (char *)(v183 + 2 * *v131);
                  }
                  else {
                    v185 = DumpFontData(fsg_SplineKey *,streamBuffer *,sfntFontHeader const*,sfntPostScriptInfo const*,unsigned int,BOOL)::kZeroLongMetrics;
                  }
                  ZWriteDataHex(v242, 2, v185, a4);
                  ++v131;
                  ++v184;
                }
                while ((unsigned __int16)v184 < (unsigned __int16)v230);
              }
              v108 += v217;
              if (v271[1])
              {
                free(v271[1]);
                v271[1] = 0;
                v272[0] = 0;
              }
              goto LABEL_226;
            }
LABEL_207:
            v245[0] = 0;
            ScalerGetFontTable(v235, v121, 0, v245, 0, 0);
            uint64_t v180 = v245[0];
            ZWriteDataHex(v242, bswap32(*(_DWORD *)v234), (char *)v245[0], a4);
            unsigned int v127 = *(_DWORD *)v234;
            ScalerReleaseFontTable(v235, v180);
LABEL_208:
            unsigned int v181 = bswap32(v127);
            goto LABEL_210;
          }
          v245[0] = 0;
          ScalerGetFontTable(v235, 1751672161, 0, v245, 0, 36);
          BOOL v138 = v245[0];
          ZWriteDataHex(v242, 34, (char *)v245[0], a4);
          LOWORD(v249) = v214;
          ZWriteDataHex(v242, 2, (char *)&v249, a4);
          ScalerReleaseFontTable(v235, v138);
          v108 += 36;
        }
        else if (v121 == 1819239265)
        {
          ZWriteDataHex(v242, v224, v225, a4);
          v108 += v224;
        }
        else
        {
          if (v121 != 1835104368)
          {
            int v125 = 1886545264;
LABEL_132:
            if (v121 != v125) {
              goto LABEL_207;
            }
            v245[0] = 0;
            if (ScalerGetFontTable(v235, v121, 0, v245, 1, 0))
            {
              BOOL v126 = v245[0];
              ZWriteDataHex(v242, bswap32(*(_DWORD *)v234), (char *)v245[0], a4);
              unsigned int v127 = *(_DWORD *)v234;
              ScalerReleaseFontTable(v235, v126);
              goto LABEL_208;
            }
            v249 = 0;
            ZWriteDataHex(v242, bswap32(*(_DWORD *)v234), (char *)&v249, a4);
            unsigned int v181 = bswap32(*(_DWORD *)v234);
LABEL_210:
            v108 += v181;
            goto LABEL_226;
          }
          v245[0] = 0;
          LOWORD(v249) = v219;
          ScalerGetFontTable(v235, 1835104368, 0, v245, 0, 32);
          uint64_t v179 = (char *)v245[0];
          ZWriteDataHex(v242, 4, (char *)v245[0], a4);
          ZWriteDataHex(v242, 2, (char *)&v249, a4);
          ZWriteDataHex(v242, 26, v179 + 6, a4);
          ScalerReleaseFontTable(v235, v179);
          v108 += 32;
        }
      }
      else
      {
        if ((int)v121 <= 1735162213)
        {
          if (v121 == 1668707360)
          {
            signed int v136 = (char *)v272[1];
            v245[0] = v272[1];
            if (v272[1])
            {
              unsigned int v137 = *(_DWORD *)v234;
LABEL_212:
              ZWriteDataHex(v242, bswap32(v137), v136, a4);
              unsigned int v182 = bswap32(*(_DWORD *)v234);
              if (v272[1])
              {
                free(v136);
                v272[1] = 0;
              }
              else
              {
                ScalerReleaseFontTable(v235, v136);
              }
            }
            else
            {
              ScalerGetFontTable(v235, 1668707360, 0, v245, 1, 0);
              signed int v136 = (char *)v245[0];
              unsigned int v137 = *(_DWORD *)v234;
              if (v245[0]) {
                goto LABEL_212;
              }
              v249 = 0;
              ZWriteDataHex(v242, bswap32(v137), (char *)&v249, a4);
              unsigned int v182 = bswap32(*(_DWORD *)v234);
            }
            v108 += v182;
            goto LABEL_226;
          }
          int v125 = 1718642541;
          goto LABEL_132;
        }
        if (v121 == 1735162214)
        {
          if (v239)
          {
            long long v139 = v63;
            int v140 = (unsigned __int16)v230;
            do
            {
              v245[0] = (void *)0xAAAAAAAAAAAAAAAALL;
              unsigned int NewGlyphData = GetNewGlyphData(*v139, (uint64_t)v254, v245);
              unsigned int v142 = NewGlyphData;
              int v143 = (char *)v245[0];
              if (NewGlyphData >= 0xB && v245[0] != 0)
              {
                if (NewGlyphData + v108 >= 0xFFFF)
                {
                  LODWORD(v249) = -1431655766;
                  uint64_t v145 = (char *)ZGetString(v229, (int *)&v249);
                  StreamBytesThroughBuffer(v242, (int)v249, v145);
                  int v108 = 0;
                }
                int v231 = v108 + v142;
                if ((*(_WORD *)v143 & 0x80) == 0) {
                  goto LABEL_189;
                }
                ZWriteDataHex(v242, 10, v143, a4);
                unint64_t v146 = (unint64_t)&v143[v142];
                v143 += 10;
                do
                {
                  LOWORD(v249) = -21846;
                  if ((unint64_t)v143 > 0xFFFFFFFFFFFFFFF9
                    || (v245[0] <= v143 ? (BOOL v147 = (unint64_t)(v143 + 6) > v146) : (BOOL v147 = 1), v147))
                  {
                    v206 = __cxa_allocate_exception(2uLL);
                    _WORD *v206 = 5;
                    __cxa_throw(v206, MEMORY[0x1E4FBA3C8], 0);
                  }
                  unsigned int v148 = *(unsigned __int16 *)v143;
                  ZWriteDataHex(v242, 2, v143, a4);
                  if ((_WORD)v230)
                  {
                    int v149 = 0;
                    unsigned int v150 = bswap32(*((unsigned __int16 *)v143 + 1)) >> 16;
                    int v151 = (unsigned __int16)v230 - 1;
                    do
                    {
                      signed int v152 = (v151 + v149) >> 1;
                      unsigned int v153 = (unsigned __int16)v63[v152];
                      if (v153 >= v150)
                      {
                        if (v153 <= v150) {
                          goto LABEL_178;
                        }
                        int v151 = v152 - 1;
                      }
                      else
                      {
                        int v149 = v152 + 1;
                      }
                    }
                    while (v149 <= v151);
                  }
                  signed int v152 = -1;
LABEL_178:
                  LOWORD(v249) = bswap32(v152) >> 16;
                  ZWriteDataHex(v242, 2, (char *)&v249, a4);
                  unsigned int v154 = bswap32(v148) >> 16;
                  unsigned __int16 v155 = v143 + 4;
                  uint64_t v156 = 1;
                  if (v154) {
                    uint64_t v156 = 2;
                  }
                  uint64_t v157 = v156 + ((v154 >> 3) & 1);
                  if ((v154 & 0x40) != 0) {
                    uint64_t v157 = v156 + 2;
                  }
                  uint64_t v158 = v156 | 4;
                  if ((v154 & 0x80) != 0) {
                    uint64_t v159 = v158;
                  }
                  else {
                    uint64_t v159 = v157;
                  }
                  int v160 = &v155[2 * v159];
                  if (v160 < v155 || (unint64_t)v160 > v146)
                  {
                    v207 = __cxa_allocate_exception(2uLL);
                    _WORD *v207 = 5;
                    __cxa_throw(v207, MEMORY[0x1E4FBA3C8], 0);
                  }
                  ZWriteDataHex(v242, 2 * v159, v155, a4);
                  int v143 = &v155[2 * v159];
                }
                while ((v154 & 0x20) != 0);
                v142 -= (__int16)((_WORD)v143 - LOWORD(v245[0]));
                if (v142) {
LABEL_189:
                }
                  ZWriteDataHex(v242, v142, v143, a4);
                int v108 = v231;
              }
              ++v139;
              BOOL v161 = __OFSUB__(v140--, 1);
            }
            while (!((v140 < 0) ^ v161 | (v140 == 0)));
          }
          else
          {
            LODWORD(v245[0]) = 0;
            ZWriteDataHex(v242, 4, (char *)v245, a4);
          }
          goto LABEL_226;
        }
        if (v121 == 1735811442)
        {
          v245[0] = 0;
          unsigned int v250 = -1431655766;
          ScalerGetFontTable(v235, 1735811442, 0, v245, 0, 36);
          int v162 = v245[0];
          unsigned int v163 = bswap32(*((_DWORD *)v245[0] + 4)) + v218 - bswap32(*((_DWORD *)v245[0] + 2));
          if ((int)(v163 + v108) >= 0xFFFF)
          {
            LODWORD(v249) = -1431655766;
            BOOL v164 = (char *)ZGetString(v229, (int *)&v249);
            StreamBytesThroughBuffer(v242, (int)v249, v164);
            int v108 = 0;
          }
          ZWriteDataHex(v242, 8, (char *)v162, a4);
          unsigned int v250 = v213;
          ZWriteDataHex(v242, 4, (char *)&v250, a4);
          LOWORD(v249) = v219;
          ZWriteDataHex(v242, 2, (char *)&v249, a4);
          LOWORD(v249) = v212;
          ZWriteDataHex(v242, 2, (char *)&v249, a4);
          unsigned int v250 = bswap32(bswap32(*((_DWORD *)v162 + 4)) + v218 - bswap32(*((_DWORD *)v162 + 2)));
          ZWriteDataHex(v242, 4, (char *)&v250, a4);
          ZWriteDataHex(v242, v211, v221, a4);
          unsigned int v165 = *((_DWORD *)v162 + 4);
          unsigned int v166 = *((_DWORD *)v162 + 2);
          ScalerReleaseFontTable(v235, v162);
          unsigned int v167 = bswap32(v165);
          unsigned int v168 = bswap32(v166);
          int v169 = v167 - v168;
          v245[0] = 0;
          if ((int)(v167 - v168) >= 1)
          {
            ScalerGetFontTable(v235, 1735811442, v168, v245, 0, v167 - v168);
            int32x2_t v170 = v245[0];
            ZWriteDataHex(v242, v169, (char *)v245[0], a4);
            ScalerReleaseFontTable(v235, v170);
            v245[0] = 0;
          }
          ScalerGetFontTable(v235, 1735811442, 0, v245, 0, v168);
          v108 += v163;
          v249 = (void *)0xAAAAAAAAAAAAAAAALL;
          unsigned int v248 = -1431655766;
          int v171 = count;
          unsigned int v172 = v63;
          unsigned int v173 = v245[0];
          do
          {
            unsigned int v174 = *v172++;
            int GlyphVariationOffsetAndSize = GetGlyphVariationOffsetAndSize(v174, (uint64_t)v173, &v248);
            if (GlyphVariationOffsetAndSize)
            {
              int v176 = GlyphVariationOffsetAndSize;
              ScalerGetFontTable(v235, 1735811442, v248, &v249, 0, GlyphVariationOffsetAndSize);
              if (v176 + v108 >= 0xFFFF)
              {
                int v275 = -1431655766;
                v177 = (char *)ZGetString(v229, &v275);
                StreamBytesThroughBuffer(v242, v275, v177);
                int v108 = 0;
              }
              int v178 = v249;
              ZWriteDataHex(v242, v176, (char *)v249, a4);
              ScalerReleaseFontTable(v235, v178);
              v108 += v176;
            }
            --v171;
          }
          while (v171 > 1);
          ScalerReleaseFontTable(v235, v173);
          goto LABEL_226;
        }
        if (v121 != 1751474532) {
          goto LABEL_207;
        }
        long long v122 = *(_OWORD *)v223;
        long long v123 = *((_OWORD *)v223 + 1);
        long long v124 = *((_OWORD *)v223 + 2);
        *(void *)&v247[14] = *(void *)((char *)v223 + 46);
        long long v246 = v123;
        *(_OWORD *)v247 = v124;
        *(_OWORD *)v245 = v122;
        *(_WORD *)&v247[18] = v215;
        ZWriteDataHex(v242, 54, (char *)v245, a4);
        v108 += 54;
      }
LABEL_226:
      if ((*(unsigned char *)(v234 + 3) & 3) != 0)
      {
        ZWriteDataHex(v242, 4 - (*(unsigned char *)(v234 + 3) & 3), (char *)&v251, a4);
        int v108 = v108 - (*(unsigned char *)(v234 + 3) & 3) + 4;
      }
      uint64_t v115 = v232 + 1;
    }
    while (v232 + 1 != v226);
  }
  if (a4) {
    int v186 = 16;
  }
  else {
    int v186 = 121;
  }
  LODWORD(v245[0]) = -1431655766;
  v187 = (char *)ZGetString(v186, (int *)v245);
  StreamBytesThroughBuffer(v242, (int)v245[0], v187);
  ZWriteStringF(v242, 17, v188, v189, v190, v191, v192, v193, (unsigned __int16)v230);
  LOBYTE(v245[0]) = -86;
  if ((_WORD)v230)
  {
    uint64_t v194 = 0;
    do
    {
      ZGetGlyphName((uint64_t)v227, FontTable, (unsigned __int16)v274, (unsigned __int16)v63[v194], (char *)v245, v289, 0x80uLL);
      if (LOBYTE(v245[0])) {
        ZWriteStringF(v242, 18, v195, v196, v197, v198, v199, v200, LOBYTE(v245[0]));
      }
      ++v194;
    }
    while ((unsigned __int16)v230 != v194);
  }
  LODWORD(v245[0]) = -1431655766;
  v201 = (char *)ZGetString(19, (int *)v245);
  StreamBytesThroughBuffer(v242, (int)v245[0], v201);
  free(v221);
  free(v225);
  free(v63);
  UninitGlyphDataContext((memoryContext **)a1, (uint64_t)v254);
  uint64_t v202 = v242;
  if (*(unsigned char *)(*(void *)(v242 + 8) + 16))
  {
    v254[0] = -1431655766;
    v203 = (char *)ZGetString(20, v254);
    StreamBytesThroughBuffer(v242, v254[0], v203);
    v254[0] = -1431655766;
    v204 = (char *)ZGetString(21, v254);
    StreamBytesThroughBuffer(v242, v254[0], v204);
    uint64_t v202 = v242;
  }
  v254[0] = -1431655766;
  v205 = (char *)ZGetString(22, v254);
  StreamBytesThroughBuffer(v202, v254[0], v205);
  if (v244) {
    ScalerReleaseFontTable(v222, v244);
  }
  ScalerReleaseFontTable(v222, v243);
}

uint64_t StreamPortableTTFont(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  unsigned int v5 = *(_DWORD *)(v4 + 16) & 0xFFFFF000;
  *(_DWORD *)(v4 + 16) = v5 | 8;
  StreamTTFont(a1, a2, 1, 1);
  int v9 = -1431655766;
  unsigned int v6 = (char *)ZGetString(201, &v9);
  StreamBytesThroughBuffer(a2, v9, v6);
  *(_DWORD *)(*(void *)(a2 + 8) + 16) = v5 | 2;
  StreamT1Font(a1, a2, 1);
  int v10 = -1431655766;
  unsigned int v7 = (char *)ZGetString(202, &v10);
  uint64_t result = StreamBytesThroughBuffer(a2, v10, v7);
  *(_DWORD *)(*(void *)(a2 + 8) + 16) = v5 | 0x20;
  return result;
}

void StreamVariationPSOperator(memoryContext **a1, uint64_t a2)
{
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unint64_t v8 = v4;
  long long v9 = v4;
  long long v7 = v4;
  if (InitVariationInfo((uint64_t)a1, (uint64_t)&v7, *(_DWORD *)(*(void *)(a2 + 8) + 28), *(uint64_t **)(*(void *)(a2 + 8) + 32)))
  {
    int v11 = -1431655766;
    unsigned int v5 = (char *)ZGetString(44, &v11);
    StreamBytesThroughBuffer(a2, v11, v5);
    StreamBinaryThroughBuffer(a2, 8 * *(_DWORD *)(*(void *)(a2 + 8) + 28), *(char **)(*(void *)(a2 + 8) + 32));
    int v11 = -1431655766;
    unsigned int v6 = (char *)ZGetString(45, &v11);
    StreamBytesThroughBuffer(a2, v11, v6);
    ScalerDisposeBlock(*a1, (char *)v8[1], -1);
  }
}

void StreamFlatFont(memoryContext **a1, uint64_t a2, int a3, uint64_t a4, __CFArray *a5)
{
  __dst[52] = *MEMORY[0x1E4F143B8];
  v249 = *a1;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v272 = v7;
  long long v273 = v7;
  long long v270 = v7;
  long long v271 = v7;
  long long v268 = v7;
  long long v269 = v7;
  long long v266 = v7;
  long long v267 = v7;
  long long v264 = v7;
  long long v265 = v7;
  v263[12] = v7;
  v263[13] = v7;
  v263[10] = v7;
  v263[11] = v7;
  v263[8] = v7;
  v263[9] = v7;
  v263[6] = v7;
  v263[7] = v7;
  v263[4] = v7;
  v263[5] = v7;
  v263[2] = v7;
  v263[3] = v7;
  v263[0] = v7;
  v263[1] = v7;
  unint64_t v8 = a1 + 1;
  unsigned int v9 = *((unsigned __int16 *)a1[1] + 20);
  int v262 = v9;
  uint64_t v10 = *(void *)(a2 + 8);
  int v11 = *(unsigned int **)(v10 + 48);
  memcpy(__dst, "fpaZ", 0x1A0uLL);
  int v229 = a1;
  InitGlyphDataContext((uint64_t)a1, v10, (uint64_t)v263);
  __src = (char *)malloc_type_calloc(1uLL, 0xDCuLL, 0xA7917466uLL);
  long long v261 = 0;
  uint64_t v12 = *v8;
  int v13 = *(_DWORD *)(*v8 + 100);
  *v11 |= 0x80000000;
  unsigned int v14 = *(__int16 *)(v12 + 144);
  int v260 = 0;
  uint64_t v259 = 0;
  if (v13)
  {
    int v15 = *(_DWORD *)(v12 + 100);
    if (v14) {
      char v16 = 2;
    }
    else {
      char v16 = 1;
    }
    int v17 = v15 >> v16;
    if (v17 < 2)
    {
      exception = __cxa_allocate_exception(2uLL);
      _WORD *exception = 5;
      __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
    }
    if (v17 <= v9) {
      int v262 = v17 - 1;
    }
    *(void *)int v275 = 0;
    ScalerGetFontTable(v249, 1819239265, 0, v275, 0, 0);
    v283[0] = 0;
    TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)v249 + 16), 1735162214, v283);
    size_t v18 = *(const void **)v275;
    signed int v241 = AccumulateComponentGlyphBits(v249, &v262, v11, *(unsigned int **)v275, v14, &v259);
    unsigned int v248 = malloc_type_calloc(v241, 2uLL, 0x1000040BDFB0063uLL);
    uint64_t v19 = malloc_type_calloc(v241 + 1, 4uLL, 0x100004052888210uLL);
    long long v246 = v19;
    *uint64_t v19 = 0;
    int v20 = v262;
    if (v262 < 1)
    {
      unsigned int v250 = 0;
    }
    else
    {
      LODWORD(v21) = 0;
      unsigned int v250 = 0;
      uint64_t v22 = v19 + 1;
      uint64_t v23 = v248;
      do
      {
        uint64_t v21 = (int)v21;
        unsigned int v24 = 0x80000000;
        do
        {
          if ((*v11 & v24) != 0)
          {
            int NewGlyphSize = GetNewGlyphSize((uint64_t)v263, v249, (unsigned __int16)v21, (uint64_t)v18, v14);
            if (a5) {
              CFArrayAppendValue(a5, (const void *)v21);
            }
            *v23++ = v21;
            v250 += NewGlyphSize;
            *v22++ = bswap32(v250);
            int v20 = v262;
          }
          ++v21;
          if (v24 < 2) {
            break;
          }
          v24 >>= 1;
        }
        while (v21 < v20);
        ++v11;
      }
      while (v20 > (int)v21);
    }
    BOOL v26 = (v250 & 0xFFFE0000) != 0;
    ScalerReleaseFontTable(v249, v18);
  }
  else
  {
    unsigned int v248 = malloc_type_calloc(1uLL, 2uLL, 0x1000040BDFB0063uLL);
    long long v246 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
    BOOL v26 = 0;
    signed int v241 = 0;
    unsigned int v250 = 0;
  }
  int v285 = -1431655766;
  *(void *)&long long v27 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v284[7] = v27;
  v284[6] = v27;
  v284[5] = v27;
  v284[4] = v27;
  v284[3] = v27;
  v284[2] = v27;
  v284[1] = v27;
  v284[0] = v27;
  *(_OWORD *)long long v283 = v27;
  *(void *)int v275 = 0;
  ScalerGetFontTable(v249, 1835104368, 0, v275, 0, 32);
  long long v28 = *(_OWORD *)(*(void *)v275 + 12);
  *(_OWORD *)long long v256 = **(_OWORD **)v275;
  *(_OWORD *)&v256[12] = v28;
  ScalerReleaseFontTable(v249, *(const void **)v275);
  unsigned int v29 = bswap32(v241);
  unsigned int v233 = HIWORD(v29);
  *(_DWORD *)&v256[4] = HIWORD(v29);
  *(_WORD *)&v256[8] = 0;
  *(_WORD *)&v256[10] = bswap32((unsigned __int16)v259) >> 16;
  *(_WORD *)&v256[12] = bswap32(WORD2(v259)) >> 16;
  unsigned __int16 v257 = 0;
  __int16 v258 = bswap32((unsigned __int16)v260) >> 16;
  __dst[38] = v256;
  HIDWORD(__dst[37]) = 32;
  *(void *)int v275 = 0;
  ScalerGetFontTable(v249, 1751474532, 0, v275, 0, 54);
  long long v31 = *(_OWORD *)(*(void *)v275 + 16);
  long long v30 = *(_OWORD *)(*(void *)v275 + 32);
  long long v32 = **(_OWORD **)v275;
  *(void *)&v255[14] = *(void *)(*(void *)v275 + 46);
  v254[1] = v31;
  *(_OWORD *)long long v255 = v30;
  v254[0] = v32;
  *(_WORD *)&v255[18] = v26 << 8;
  ScalerReleaseFontTable(v249, *(const void **)v275);
  __dst[22] = v254;
  HIDWORD(__dst[21]) = 54;
  *(void *)int v275 = 0;
  ScalerGetFontTable(v249, 1751672161, 0, v275, 0, 36);
  int v33 = *(_DWORD *)(*(void *)v275 + 32);
  long long v34 = *(_OWORD *)(*(void *)v275 + 16);
  v252[0] = **(_OWORD **)v275;
  v252[1] = v34;
  int v253 = v33;
  ScalerReleaseFontTable(v249, *(const void **)v275);
  unsigned int v35 = HIWORD(v253);
  HIWORD(v253) = v233;
  __dst[26] = v252;
  HIDWORD(__dst[25]) = 36;
  __dst[42] = v283;
  uint64_t v36 = *(const char **)(*(void *)(a2 + 8) + 56);
  size_t v37 = strlen(v36);
  *(void *)long long v283 = 0x100120001000000;
  if (v37 >= 0x7F) {
    size_t v38 = 127;
  }
  else {
    size_t v38 = v37;
  }
  v283[2] = 0;
  LOWORD(v283[3]) = 1536;
  HIWORD(v283[3]) = (_WORD)v38 << 8;
  LOWORD(v284[0]) = 0;
  memcpy((char *)v284 + 2, v36, v38);
  int v39 = (v38 + 21) & 0xFC;
  if (v39 != v38 + 18) {
    bzero((char *)v283 + (v38 + 18), (v39 - (v38 + 18)));
  }
  HIDWORD(__dst[41]) = (v38 + 21) & 0xFC;
  *(void *)&v251[1] = 0;
  uint64_t v40 = 0;
  v235 = 0;
  unsigned int v236 = 0;
  uint64_t v242 = 0;
  uint64_t v41 = 0;
  unsigned int v42 = bswap32(v35) >> 16;
  v238 = 0;
  int v226 = 4 * v241 + 8;
  *(void *)v245 = ScalerGetFontTable(v249, 1886352244, 0, &v251[1], 1, 0);
  uint64_t v43 = 2 * v241;
  uint64_t v225 = v43 + 34;
  uint64_t v227 = v43 + 37;
  BOOL v44 = v26;
  int v45 = 4 * v241 + 4;
  if (!v26) {
    int v45 = 2 * v241 + 2;
  }
  int v231 = v45;
  if (v241 < 0) {
    BOOL v44 = 1;
  }
  BOOL v230 = v44;
  int v46 = v241 + 1;
  int v47 = v248;
  unsigned int v48 = v246;
  do
  {
    unsigned int v49 = (unsigned int *)&__dst[4 * v40];
    if (*((unsigned char *)v49 + 25))
    {
      *(void *)int v275 = 0;
      int FontTable = ScalerGetFontTable(v249, *v49, 0, v275, *((unsigned __int8 *)v49 + 24) == 0, 0);
      int v51 = &__dst[4 * v40];
      v51[2] = *(void *)v275;
      *((_DWORD *)v51 + 3) = FontTable;
      int v47 = v248;
      unsigned int v48 = v246;
LABEL_266:
      int v46 = v241 + 1;
      goto LABEL_267;
    }
    int v52 = *v49;
    if (v52 <= 1735162213)
    {
      unsigned int v244 = v42;
      if (v52 == 1516335206)
      {
        *(void *)int v275 = 0xAAAAAAAAAAAAAAAALL;
        unsigned int v68 = ScalerGetFontTable(v249, 1516335206, 0, v275, 1, 0);
        unsigned int v69 = v68;
        if (!v68) {
          goto LABEL_265;
        }
        uint64_t v70 = *(char **)v275;
        if (v68 >= 9 && **(_DWORD **)v275 == 256)
        {
          int v71 = (unsigned __int16 *)malloc_type_calloc(v241, 2uLL, 0x1000040BDFB0063uLL);
          int v72 = v71;
          unsigned int v73 = v70 + 8;
          int v74 = 0;
          if (v241 > 0)
          {
            unsigned int v75 = v248;
            unint64_t v76 = v71;
            uint64_t v77 = v241;
            do
            {
              unsigned int v79 = *v75++;
              uint64_t v78 = v79;
              if (4 * (unint64_t)v79 + 12 <= v69
                && (uint64_t v80 = bswap32(*(_DWORD *)&v73[4 * v78]), v80 + 10 <= (unint64_t)v69))
              {
                unsigned int v82 = bswap32(*(unsigned __int16 *)&v70[v80 + 8]) >> 16;
                if ((unint64_t)((2 * v82 + 15) & 0x3FFFC) + v80 <= v69) {
                  unsigned int v81 = v82;
                }
                else {
                  unsigned int v81 = 0;
                }
              }
              else
              {
                unsigned int v81 = 0;
              }
              *v76++ = v81;
              v74 += (2 * v81 + 15) & 0x3FFFC;
              --v77;
            }
            while (v77);
          }
          LODWORD(v83) = v74 + v226;
          uint64_t v242 = malloc_type_calloc(1uLL, (v74 + v226), 0x5CCC55FDuLL);
          *uint64_t v242 = 256;
          if (v241 > 0)
          {
            uint64_t v84 = 0;
            unsigned int v85 = 4 * v241 + 8;
            do
            {
              *((_DWORD *)v242 + v84 + 2) = bswap32(v85);
              unsigned int v86 = v72[v84];
              unint64_t v87 = (char *)v242 + v85;
              *(void *)unint64_t v87 = -1;
              unsigned int v88 = v87 + 10;
              *((_WORD *)v87 + 4) = __rev16(v86);
              if (v86)
              {
                CFRange v89 = &v70[bswap32(*(_DWORD *)&v73[4 * (unsigned __int16)v248[v84]]) + 10];
                unsigned int v90 = v86;
                do
                {
                  __int16 v91 = *(_WORD *)v89;
                  v89 += 2;
                  *v88++ = v91;
                  --v90;
                }
                while (v90);
              }
              *unsigned int v88 = 0;
              v85 += (2 * v86 + 15) & 0x3FFFC;
              ++v84;
            }
            while (v84 != v241);
          }
          free(v72);
        }
        else
        {
          LODWORD(v83) = 0;
          uint64_t v242 = 0;
        }
        ScalerReleaseFontTable(v249, v70);
        unsigned int v142 = &__dst[4 * v40];
        int v143 = (char *)v242;
LABEL_264:
        v142[2] = v143;
        *((_DWORD *)v142 + 3) = v83;
        goto LABEL_265;
      }
      if (v52 != 1668112752)
      {
        if (v52 != 1668707360)
        {
          int v47 = v248;
          goto LABEL_175;
        }
        int v57 = ScalerGetFontTable(v249, 1668707360, 0, &v261, 1, 0);
        int v58 = v261;
        if (*((void *)&v272 + 1))
        {
          ScalerReleaseFontTable(v249, v261);
          int v58 = (void *)*((void *)&v272 + 1);
          long long v261 = (void *)*((void *)&v272 + 1);
        }
        int v59 = &__dst[4 * v40];
        v59[2] = v58;
        *((_DWORD *)v59 + 3) = v57;
        goto LABEL_265;
      }
      if (a3)
      {
        *(void *)int v275 = 0xAAAAAAAAAAAAAAAALL;
        unsigned int v124 = ScalerGetFontTable(v249, 1668112752, 0, v275, 1, 4);
        if (*(void *)v275)
        {
          unint64_t v125 = *(void *)v275 + v124;
          uint64_t v126 = __rev16(*(unsigned __int16 *)(*(void *)v275 + 2));
          unint64_t v127 = *(void *)v275 + 4 + 8 * v126;
          unint64_t v128 = ((unint64_t)v124 - 4) >> 3;
          if (*(void *)v275 + 12 > v125) {
            unint64_t v128 = 0;
          }
          if ((v127 > v125 || v127 < *(void *)v275 + 4) && v128 != v126)
          {
            v223 = __cxa_allocate_exception(2uLL);
            _WORD *v223 = 5;
            __cxa_throw(v223, MEMORY[0x1E4FBA3C8], 0);
          }
          if (*(_WORD *)(*(void *)v275 + 2))
          {
            uint64_t v131 = 0;
            unsigned int v132 = 0;
            if (v126 <= 1) {
              LODWORD(v126) = 1;
            }
            uint64_t v133 = 8 * v126;
            do
            {
              if (*(_WORD *)(*(void *)v275 + v131 + 4) == 256)
              {
                unsigned int v134 = bswap32(*(unsigned __int16 *)(*(void *)v275 + v131 + 6)) >> 16;
                BOOL v135 = v134 > 0x19 || ((1 << v134) & 0x200000E) == 0;
                int v136 = v135;
                if (!v135) {
                  unsigned int v132 = v134;
                }
                BOOL v99 = v134 > 0x19;
                int v137 = (1 << v134) & 0x200000E;
                BOOL v138 = v99 || v137 == 0;
                if (!v138 && v136 == 0) {
                  break;
                }
              }
              v131 += 8;
            }
            while (v133 != v131);
            ScalerReleaseFontTable(v249, *(const void **)v275);
            if ((_WORD)v132)
            {
              unsigned int v236 = (char *)malloc_type_calloc(1uLL, 0x1AuLL, 0x677CC8C4uLL);
              *(_DWORD *)unsigned int v236 = 0x1000000;
              *((_WORD *)v236 + 2) = 256;
              *((_WORD *)v236 + 3) = bswap32(v132) >> 16;
              *((void *)v236 + 1) = 0xC0006000C000000;
              *(_DWORD *)(v236 + 18) = 0x1000000;
              *((_WORD *)v236 + 11) = 0;
              int v140 = &__dst[4 * v40];
              v140[2] = v236;
              int v141 = 26;
              goto LABEL_234;
            }
          }
          else
          {
            ScalerReleaseFontTable(v249, *(const void **)v275);
          }
        }
LABEL_265:
        int v47 = v248;
        unsigned int v48 = v246;
        unsigned int v42 = v244;
        goto LABEL_266;
      }
      bzero(v275, 0x400uLL);
      if (a4)
      {
        if (v241 < 1)
        {
          unsigned int v148 = 0;
          goto LABEL_258;
        }
        uint64_t v146 = 0;
        unsigned __int16 v147 = 0;
        unsigned int v148 = 0;
        unsigned int v149 = 0xFFFF;
        do
        {
          uint64_t v150 = 0;
          while (*(unsigned __int16 *)(a4 + 2 * v150) != (unsigned __int16)v248[v146])
          {
            if (++v150 == 256) {
              goto LABEL_198;
            }
          }
          int v151 = &v275[v147];
          *int v151 = v150;
          v151[1] = v146;
          ++v147;
          if ((unsigned __int16)v150 >= (unsigned __int16)v149) {
            unsigned int v149 = (unsigned __int16)v149;
          }
          else {
            unsigned int v149 = (unsigned __int16)v150;
          }
          if ((unsigned __int16)v150 <= (unsigned __int16)v148) {
            unsigned int v148 = (unsigned __int16)v148;
          }
          else {
            unsigned int v148 = (unsigned __int16)v150;
          }
LABEL_198:
          ++v146;
        }
        while (v146 < v241 && v147 < 0x100u);
      }
      else
      {
        unsigned int v148 = 0;
        v177 = v248;
        unsigned int v237 = *(void **)&v251[1];
        if (!*(void *)&v251[1] || !v245[0]) {
          goto LABEL_258;
        }
        *(void *)&long long v178 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v178 + 1) = 0xAAAAAAAAAAAAAAAALL;
        __n[6] = v178;
        __n[7] = v178;
        __n[4] = v178;
        __n[5] = v178;
        __n[2] = v178;
        __n[3] = v178;
        __n[0] = v178;
        __n[1] = v178;
        if (v241 < 1)
        {
          unsigned int v148 = 0;
          unsigned __int16 v240 = 0;
          unsigned int v149 = 0xFFFF;
        }
        else
        {
          uint64_t v179 = 0;
          unsigned __int16 v240 = 0;
          unsigned int v148 = 0;
          unsigned int v149 = 0xFFFF;
          do
          {
            v251[0] = -86;
            uint64_t v180 = ZGetGlyphName((uint64_t)v237, v245[0], (unsigned __int16)v262, (unsigned __int16)v177[v179], v251, (char *)__n, 0x80uLL);
            unsigned int v181 = v41;
            uint64_t v182 = 0;
            size_t v183 = v251[0];
            int v184 = "space";
            while (*(v184 - 1) != v183 || strncmp(v184, v180, v183))
            {
              ++v182;
              v184 += 16;
              if (v182 == 207) {
                goto LABEL_250;
              }
            }
            unsigned int v185 = (unsigned __int16)pdfMacRomanCharIDs[v182];
            int v186 = &v275[v240];
            *int v186 = v185;
            v186[1] = v179;
            ++v240;
            if (v185 >= (unsigned __int16)v149) {
              unsigned int v149 = (unsigned __int16)v149;
            }
            else {
              unsigned int v149 = v185;
            }
            if (v185 <= (unsigned __int16)v148) {
              unsigned int v148 = (unsigned __int16)v148;
            }
            else {
              unsigned int v148 = v185;
            }
LABEL_250:
            ++v179;
            v177 = v248;
            uint64_t v41 = v181;
          }
          while (v179 < v241 && v240 < 0xCFu);
        }
        unsigned __int16 v147 = v240;
      }
      if (v147)
      {
        char v187 = 0;
        goto LABEL_259;
      }
LABEL_258:
      unsigned __int16 v147 = 0;
      unsigned int v149 = 0;
      char v187 = 1;
LABEL_259:
      unsigned int v188 = v148 - v149 + 1;
      size_t v83 = 2 * (unsigned __int16)(v148 - v149 + 1) + 24;
      unsigned int v236 = (char *)malloc_type_calloc(1uLL, v83, 0x14022726uLL);
      *(void *)unsigned int v236 = 0x10001000000;
      *((_DWORD *)v236 + 2) = 201326592;
      *((_WORD *)v236 + 6) = 1536;
      *((_WORD *)v236 + 9) = bswap32(v149) >> 16;
      *((_WORD *)v236 + 10) = bswap32(v188) >> 16;
      *((_WORD *)v236 + 7) = bswap32(2 * v188 + 10) >> 16;
      if ((v187 & 1) == 0 && v147)
      {
        int v189 = 0;
        do
        {
          *(_WORD *)&v236[2 * (LOWORD(v275[(__int16)v189]) - (unint64_t)(unsigned __int16)v149) + 22] = bswap32(HIWORD(v275[(__int16)v189])) >> 16;
          ++v189;
        }
        while (v147 > (__int16)v189);
      }
      unsigned int v142 = &__dst[4 * v40];
      int v143 = v236;
      goto LABEL_264;
    }
    if (v52 <= 1819239264)
    {
      if (v52 != 1735162214)
      {
        if (v52 == 1752003704)
        {
          unsigned int v53 = v262;
          long long v54 = (char *)*((void *)&v271 + 1);
          if (*((void *)&v271 + 1))
          {
            unint64_t v55 = v272;
            if (*((void *)&v271 + 1) + 4 <= (unint64_t)v272) {
              unint64_t v56 = ((void)v272 - *((void *)&v271 + 1)) >> 2;
            }
            else {
              unint64_t v56 = 0;
            }
            if (v56 < v42) {
              unsigned int v42 = v56;
            }
          }
          else
          {
            long long v54 = (char *)v264;
            if (v42 >= WORD4(v264)) {
              unsigned int v42 = WORD4(v264);
            }
            if (!(void)v264) {
              goto LABEL_217;
            }
            unint64_t v55 = *((void *)&v266 + 1);
          }
          v238 = malloc_type_calloc(v241, 4uLL, 0x100004052888210uLL);
          __int16 v144 = 0;
          uint64_t v145 = 0;
          if (v42)
          {
            int v47 = v248;
            if (v42 < v53)
            {
              uint64_t v145 = &v54[4 * v42];
              __int16 v144 = *(_WORD *)&v54[4 * v42 - 4];
            }
          }
          else
          {
            int v47 = v248;
          }
          int v46 = v241 + 1;
          if (v241 >= 1)
          {
            signed int v152 = v47;
            unsigned int v153 = v238;
            uint64_t v154 = v241;
            do
            {
              unsigned int v156 = *v152++;
              uint64_t v155 = v156;
              if (v42 <= v156)
              {
                *unsigned int v153 = v144;
                if (v145)
                {
                  uint64_t v158 = &v145[2 * v155 + -2 * v42];
                  if (v54 <= v158 && (unint64_t)(v158 + 2) <= v55) {
                    v153[1] = *(_WORD *)v158;
                  }
                }
              }
              else
              {
                uint64_t v157 = &v54[4 * v155];
                if ((unint64_t)(v157 + 4) <= v55) {
                  *(_DWORD *)unsigned int v153 = *(_DWORD *)v157;
                }
              }
              v153 += 2;
              --v154;
            }
            while (v154);
          }
          if (*((void *)&v271 + 1))
          {
            free(v54);
            *((void *)&v271 + 1) = 0;
            *(void *)&long long v272 = 0;
          }
          int v160 = &__dst[4 * v40];
          v160[2] = v238;
          *((_DWORD *)v160 + 3) = 4 * v241;
        }
LABEL_217:
        unsigned int v48 = v246;
        goto LABEL_267;
      }
      if ((int)v250 < 1) {
        goto LABEL_217;
      }
      unsigned int v244 = v42;
      int v92 = (unsigned __int16 *)malloc_type_calloc(1uLL, v250, 0xFB4C0EC6uLL);
      uint64_t v41 = v92;
      *(void *)int v275 = 0xAAAAAAAAAAAAAAAALL;
      int v93 = v92;
      int v47 = v248;
      if (v241 > 0)
      {
        uint64_t v94 = 0;
        unint64_t v95 = (unint64_t)v92 + v250;
        uint64_t v96 = v92;
        do
        {
          unsigned int NewGlyphData = GetNewGlyphData(v47[v94], (uint64_t)v263, v275);
          unsigned int v98 = (char *)v96 + NewGlyphData;
          BOOL v99 = v98 < (char *)v96 || (unint64_t)v98 > v95;
          if (v99)
          {
            unsigned int v218 = __cxa_allocate_exception(2uLL);
            *unsigned int v218 = 5;
            __cxa_throw(v218, MEMORY[0x1E4FBA3C8], 0);
          }
          uint64_t v100 = NewGlyphData;
          BOOL v101 = NewGlyphData < 0xB || *(void *)v275 == 0;
          int v47 = v248;
          if (v101)
          {
            int v93 = v96;
          }
          else
          {
            memcpy(v96, *(const void **)v275, NewGlyphData);
            if ((int)bswap32(v96[1]) >> 16 > (int)bswap32(v96[3]) >> 16)
            {
              v96[1] = 0;
              v96[3] = 0;
            }
            unsigned int v102 = *v96;
            if ((int)bswap32(v96[2]) >> 16 > (int)bswap32(v96[4]) >> 16)
            {
              _OWORD v96[2] = 0;
              v96[4] = 0;
            }
            int v93 = (unsigned __int16 *)((char *)v96 + v100);
            int v103 = (int)bswap32(v102) >> 16;
            unsigned int v104 = v96 + 5;
            if (v103 < 0)
            {
              unsigned int v108 = 0;
              do
              {
                if (v96 > v104 || (uint64_t v109 = v104 + 1, (unint64_t)(v104 + 1) > v95))
                {
                  unsigned int v217 = __cxa_allocate_exception(2uLL);
                  *unsigned int v217 = 5;
                  __cxa_throw(v217, MEMORY[0x1E4FBA3C8], 0);
                }
                unsigned int v112 = *v104;
                int v110 = v104 + 2;
                unsigned int v111 = v112;
                if ((unint64_t)v110 > v95)
                {
                  char v216 = __cxa_allocate_exception(2uLL);
                  *char v216 = 5;
                  __cxa_throw(v216, MEMORY[0x1E4FBA3C8], 0);
                }
                uint64_t v113 = 0;
                unsigned int v114 = bswap32(v111) >> 16;
                ++v108;
                unsigned int v115 = bswap32((unsigned __int16)*v109) >> 16;
                while ((unsigned __int16)v248[v113] != v115)
                {
                  if (v241 == ++v113)
                  {
                    LOWORD(v116) = 0;
                    goto LABEL_121;
                  }
                }
                unsigned int v116 = bswap32(v113) >> 16;
LABEL_121:
                _WORD *v109 = v116;
                if (v114) {
                  uint64_t v117 = 2;
                }
                else {
                  uint64_t v117 = 1;
                }
                uint64_t v118 = v117 + ((v114 >> 3) & 1);
                if ((v114 & 0x40) != 0) {
                  uint64_t v118 = v117 + 2;
                }
                uint64_t v119 = v117 | 4;
                if ((v114 & 0x80) == 0) {
                  uint64_t v119 = v118;
                }
                unsigned int v104 = &v110[v119];
              }
              while ((v114 & 0x20) != 0);
              if ((unsigned __int16)v108 > bswap32(v257) >> 16) {
                unsigned __int16 v257 = bswap32(v108) >> 16;
              }
            }
            else
            {
              if (v103 > (int)(bswap32(*(unsigned __int16 *)&v256[8]) >> 16)) {
                *(_WORD *)&v256[8] = v102;
              }
              long long v105 = &v104[(unsigned __int16)v103];
              if (v105 < v104 || (unint64_t)v105 > v95)
              {
                unint64_t v106 = (unint64_t)(v96 + 6) <= v95 ? (v95 - (unint64_t)v104) >> 1 : 0;
                if (v106 != (unsigned __int16)v103)
                {
                  v220 = __cxa_allocate_exception(0x10uLL);
                  *(void *)v220 = &unk_1F0DD4440;
                  v220[2] = 4;
                }
              }
              unsigned int v107 = (bswap32(v104[v103 - 1]) >> 16) + 1;
              if ((unsigned __int16)v107 > bswap32(*(unsigned __int16 *)&v256[6]) >> 16) {
                *(_WORD *)&v256[6] = bswap32(v107) >> 16;
              }
            }
          }
          ++v94;
          uint64_t v96 = v93;
        }
        while (v94 != v241);
      }
      int v46 = v241 + 1;
      if ((char *)v93 - (unsigned char *)v41 > v250)
      {
        v221 = __cxa_allocate_exception(2uLL);
        _WORD *v221 = 5;
        __cxa_throw(v221, MEMORY[0x1E4FBA3C8], 0);
      }
      uint64_t v120 = &__dst[4 * v40];
      v120[2] = v41;
      *((_DWORD *)v120 + 3) = v250;
      unsigned int v48 = v246;
LABEL_175:
      unsigned int v42 = v244;
      goto LABEL_267;
    }
    if (v52 != 1819239265)
    {
      if (v52 != 1886352244) {
        goto LABEL_267;
      }
      long long v60 = *(_OWORD **)&v251[1];
      if (!*(void *)&v251[1]) {
        goto LABEL_217;
      }
      if (v245[0] < 0x20u) {
        goto LABEL_217;
      }
      unsigned int v61 = bswap32(**(_DWORD **)&v251[1]);
      if (v61 != 0x10000 && v61 != 163840 && v61 != 0x20000) {
        goto LABEL_217;
      }
      unsigned int v244 = v42;
      *(void *)&long long v62 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v62 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v281 = v62;
      long long v282 = v62;
      long long v279 = v62;
      long long v280 = v62;
      long long v277 = v62;
      long long v278 = v62;
      *(_OWORD *)int v275 = v62;
      long long v276 = v62;
      LOBYTE(__n[0]) = -86;
      if (v241 < 1)
      {
        uint64_t v63 = 0;
      }
      else
      {
        uint64_t v63 = 0;
        uint64_t v64 = v241;
        do
        {
          char v65 = ZGetGlyphName((uint64_t)v60, v245[0], (unsigned __int16)v262, *v47, (char *)__n, (char *)v275, 0x80uLL);
          if (*v47++)
          {
            uint64_t v67 = LOBYTE(__n[0]);
            if (!ZGetCanonIndexFromGlyphName(v65, LOBYTE(__n[0]))) {
              v63 += v67 + 1;
            }
          }
          --v64;
        }
        while (v64);
      }
      int v224 = (v227 + v63) & 0xFFFFFFFC;
      v235 = (char *)malloc_type_calloc(1uLL, (v227 + v63) & 0xFFFFFFFFFFFFFFFCLL, 0xF3D8D7A3uLL);
      long long v161 = v60[1];
      *(_OWORD *)v235 = *v60;
      *((_OWORD *)v235 + 1) = v161;
      *(_DWORD *)v235 = 512;
      *((_WORD *)v235 + 16) = v233;
      if (v241 > 0)
      {
        int v162 = 0;
        unsigned int v239 = (char *)v60 + *(void *)v245;
        unsigned int v163 = &v235[v225];
        BOOL v164 = v235 + 34;
        unsigned int v165 = v248;
        uint64_t v166 = v241;
        uint64_t v243 = v40;
        do
        {
          unsigned int v167 = ZGetGlyphName(*(uint64_t *)&v251[1], v245[0], (unsigned __int16)v262, *v165, (char *)__n, (char *)v275, 0x80uLL);
          unsigned int v168 = v41;
          uint64_t v169 = LOBYTE(__n[0]);
          unsigned int v170 = ZGetCanonIndexFromGlyphName(v167, LOBYTE(__n[0]));
          if (*v165++) {
            BOOL v172 = v170 == 0;
          }
          else {
            BOOL v172 = 0;
          }
          if (v172)
          {
            if (v167 != (const char *)v275 && &v167[v169] > v239)
            {
              unsigned int v219 = __cxa_allocate_exception(2uLL);
              *unsigned int v219 = 5;
              __cxa_throw(v219, MEMORY[0x1E4FBA3C8], 0);
            }
            int v174 = v162 + 1;
            *BOOL v164 = bswap32(v162 + 258) >> 16;
            *unsigned int v163 = v169;
            unsigned __int16 v175 = v163 + 1;
            uint64_t v176 = LOBYTE(__n[0]);
            memcpy(v175, v167, LOBYTE(__n[0]));
            unsigned int v163 = &v175[v176];
            int v162 = v174;
          }
          else
          {
            *BOOL v164 = bswap32(v170) >> 16;
          }
          ++v164;
          --v166;
          uint64_t v41 = v168;
          uint64_t v40 = v243;
        }
        while (v166);
      }
      int v140 = &__dst[4 * v40];
      v140[2] = v235;
      int v141 = v224;
LABEL_234:
      *((_DWORD *)v140 + 3) = v141;
      goto LABEL_265;
    }
    int v121 = v231;
    if (!v230)
    {
      uint64_t v122 = 0;
      do
      {
        v48[v122] = bswap32(bswap32(*(_DWORD *)&v48[2 * v122]) >> 1) >> 16;
        ++v122;
      }
      while (v46 != v122);
      int v121 = 2 * v241 + 2;
    }
    long long v123 = &__dst[4 * v40];
    v123[2] = v48;
    *((_DWORD *)v123 + 3) = v121;
LABEL_267:
    ++v40;
  }
  while (v40 != 13);
  if (*(void *)&v251[1]) {
    ScalerReleaseFontTable(v249, *(const void **)&v251[1]);
  }
  uint64_t v190 = 0;
  unsigned int v191 = 0;
  do
  {
    if (LOBYTE(__dst[v190 + 3]) || __dst[v190 + 2] && HIDWORD(__dst[v190 + 1])) {
      ++v191;
    }
    v190 += 4;
  }
  while (v190 != 52);
  *(_DWORD *)__src = 1702195828;
  *((_WORD *)__src + 2) = bswap32(v191) >> 16;
  if (v191)
  {
    __int16 v192 = __clz(v191);
    __int16 v193 = v192 ^ 0x1F;
    int v194 = -1 << (v192 ^ 0x1F);
    unsigned int v195 = bswap32(16 << (v192 ^ 0x1F)) >> 16;
    __int16 v196 = v193 << 8;
    unsigned int v197 = bswap32(16 * (v194 + v191)) >> 16;
  }
  else
  {
    LOWORD(v195) = 0;
    __int16 v196 = 0;
    LOWORD(v197) = 0;
  }
  uint64_t v198 = 0;
  *((_WORD *)__src + 3) = v195;
  *((_WORD *)__src + 4) = v196;
  unsigned int v199 = 220;
  *((_WORD *)__src + 5) = v197;
  while (2)
  {
    uint64_t v200 = dword_1B5394618[v198];
    v201 = &__dst[4 * v200];
    if (*((unsigned char *)v201 + 24))
    {
      int v202 = *((_DWORD *)v201 + 3);
LABEL_284:
      LODWORD(__dst[4 * v200 + 1]) = v199;
      if (v202) {
        int v203 = v202;
      }
      else {
        int v203 = 4;
      }
      unsigned int v199 = (v199 + v203 + 3) & 0xFFFFFFFC;
    }
    else if (v201[2])
    {
      int v202 = HIDWORD(__dst[4 * v200 + 1]);
      if (v202) {
        goto LABEL_284;
      }
    }
    if (++v198 != 13) {
      continue;
    }
    break;
  }
  uint64_t v204 = 0;
  int v205 = 0;
  while (2)
  {
    v206 = &__dst[v204];
    if (LOBYTE(__dst[v204 + 3]))
    {
      unsigned int v207 = *((_DWORD *)v206 + 3);
      goto LABEL_295;
    }
    if (v206[2])
    {
      unsigned int v207 = HIDWORD(__dst[v204 + 1]);
      if (v207)
      {
LABEL_295:
        v208 = &__src[16 * v205];
        *(void *)(v208 + 12) = bswap32(__dst[v204]);
        *((_DWORD *)v208 + 5) = bswap32(__dst[v204 + 1]);
        *((_DWORD *)v208 + 6) = bswap32(v207);
        ++v205;
      }
    }
    v204 += 4;
    if (v204 != 52) {
      continue;
    }
    break;
  }
  v209 = (_DWORD *)(a2 + 131112);
  *(_DWORD *)(a2 + 131112) = 0;
  StreamBytesThroughBuffer(a2, 220, __src);
  uint64_t v210 = 0;
  v275[0] = 0;
  do
  {
    uint64_t v211 = dword_1B5394618[v210];
    __int16 v212 = &__dst[4 * v211];
    unsigned int v213 = (char *)v212[2];
    if (v213 && (int v214 = *((_DWORD *)v212 + 3)) != 0)
    {
      _DWORD *v209 = 0;
      StreamBytesThroughBuffer(a2, v214, v213);
      int v215 = ((v214 + 3) & 0xFFFFFFFC) - v214;
      if (v215 >= 1)
      {
        _DWORD *v209 = 0;
        StreamBytesThroughBuffer(a2, v215, (char *)v275);
      }
      if (BYTE1(__dst[4 * v211 + 3])) {
        ScalerReleaseFontTable(v249, v213);
      }
    }
    else if (*((unsigned char *)v212 + 24))
    {
      _DWORD *v209 = 0;
      StreamBytesThroughBuffer(a2, 4, (char *)v275);
    }
    ++v210;
  }
  while (v210 != 13);
  free(v248);
  free(__src);
  free(v246);
  free(v238);
  free(v41);
  free(v236);
  free(v235);
  free(v242);
  if (*((void *)&v272 + 1))
  {
    free(v261);
    *((void *)&v272 + 1) = 0;
  }
  else if (v261)
  {
    ScalerReleaseFontTable(v249, v261);
  }
  UninitGlyphDataContext(v229, (uint64_t)v263);
}

uint64_t InitGlyphDataContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v5 = 0;
  *(unsigned char *)(a3 + 336) = 0;
  unsigned int v6 = *(_DWORD *)(a2 + 28);
  if (v6 == -1) {
    BOOL v5 = (*(unsigned char *)(a2 + 16) & 8) == 0;
  }
  *(unsigned char *)(a3 + 337) = v5;
  *(void *)(a3 + 344) = 0;
  *(void *)(a3 + 360) = 0;
  *(void *)(a3 + 376) = 0;
  uint64_t inited = InitVariationInfo(a1, a3 + 280, v6, *(uint64_t **)(a2 + 32));
  if (inited)
  {
    *(unsigned char *)(a3 + 336) = 1;
    if (*(unsigned char *)(*(void *)(a1 + 8) + 157))
    {
      __src = (void *)0xAAAAAAAAAAAAAAAALL;
      unsigned int FontTable = ScalerGetFontTable(*(memoryContext **)a1, 1668707360, 0, &__src, 0, 0);
      unsigned int v9 = malloc_type_calloc(1uLL, FontTable, 0x2387A6DFuLL);
      *(void *)(a3 + 360) = v9;
      uint64_t v10 = *(void *)(a1 + 8);
      int v11 = __src;
      if (*(_WORD *)(v10 + 150))
      {
        uint64_t v12 = 2 * *(unsigned __int16 *)(v10 + 150);
        int v13 = v9;
        unsigned int v14 = (unsigned __int16 *)__src;
        do
        {
          unsigned int v15 = *v14++;
          *v13++ = bswap32(v15) >> 16;
          v12 -= 2;
        }
        while (v12);
      }
      ScalerReleaseFontTable(*(memoryContext **)a1, v11);
      unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
      ScalerGetFontTable(*(memoryContext **)a1, 1668702578, 0, &v20, 0, 8);
      ApplyVariationToCVT();
    }
    __src = (void *)0xAAAAAAAAAAAAAAAALL;
    size_t v16 = ScalerGetFontTable(*(memoryContext **)a1, 1752003704, 0, &__src, 0, 0);
    int v17 = malloc_type_calloc(1uLL, v16, 0x30FAC058uLL);
    *(void *)(a3 + 344) = v17;
    size_t v18 = __src;
    memcpy(v17, __src, v16);
    *(void *)(a3 + 352) = *(void *)(a3 + 344) + v16;
    ScalerReleaseFontTable(*(memoryContext **)a1, v18);
  }
  return InitGlyphInfo(a1, a3, inited);
}

uint64_t GetNewGlyphSize(uint64_t a1, memoryContext *a2, unsigned int a3, uint64_t a4, int a5)
{
  if (a5)
  {
    long long v7 = (unsigned int *)(a4 + 4 * a3);
    unsigned int v8 = bswap32(*v7);
    unsigned int v9 = bswap32(v7[1]) - v8;
  }
  else
  {
    uint64_t v10 = (unsigned __int16 *)(a4 + 2 * a3);
    unsigned int v11 = bswap32(*v10);
    unsigned int v8 = 2 * HIWORD(v11);
    unsigned int v9 = 2 * ((bswap32(v10[1]) >> 16) - HIWORD(v11));
  }
  unsigned int v24 = v9;
  if (v9 < 0xB) {
    return 0;
  }
  uint64_t v23 = (void *)0xAAAAAAAAAAAAAAAALL;
  unsigned int FontTable = ScalerGetFontTable(a2, 1735162214, v8, &v23, 0, v9);
  int v13 = (const __int16 *)v23;
  BOOL v14 = __CFADD__(v8, v9);
  unsigned int v15 = v8 + v9;
  if (v14 || v15 > FontTable && v15 > ScalerGetBlockSize(a2, v23))
  {
    unsigned int v24 = 0;
  }
  else if (*v13 && *(unsigned char *)(a1 + 336))
  {
    unint64_t v17 = (unint64_t)v13 + v9;
    int v18 = (int)bswap32(*(unsigned __int16 *)v13) >> 16;
    uint64_t v19 = v13 + 5;
    if (v18 < 1)
    {
      CountGlyphComponents(v19, v17, &v24);
    }
    else
    {
      unint64_t v20 = &v19[(unsigned __int16)v18];
      BOOL v21 = v20 < v19 || (unint64_t)v20 > v17;
      if (v21 && ((unint64_t)(v13 + 6) > v17 || ((unint64_t)v9 - 10) >> 1 != (unsigned __int16)v18))
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *(void *)exception = &unk_1F0DD4440;
        exception[2] = 4;
      }
      unsigned int v24 = 2 * (unsigned __int16)v18
          + (bswap32((unsigned __int16)v19[v18]) >> 16)
          + 5 * (unsigned __int16)((bswap32((unsigned __int16)v19[v18 - 1]) >> 16) + 1)
          + 12;
    }
  }
  ScalerReleaseFontTable(a2, v13);
  return (v24 & 1) + v24;
}

uint64_t GetNewGlyphData(unsigned int a1, uint64_t a2, void *a3)
{
  unsigned int v49 = 0;
  FreeGlyphData(*(memoryContext ***)(a2 + 248), a2);
  *(void *)(a2 + 376) = 0;
  if (*(unsigned char *)(a2 + 336))
  {
    GetGlyphForStreaming(a1, (unsigned int *)a2, 0, 0);
    unsigned int v6 = *(unsigned __int16 *)(a2 + 8);
    if (v6 > 0xA)
    {
      int v16 = *(__int16 *)(a2 + 24);
      if (v16 < 0)
      {
        uint64_t v44 = *(void *)(a2 + 64);
        if (v44)
        {
          *(_DWORD *)(a2 + 368) = 2;
          *a3 = v44;
          *(_WORD *)(*(void *)(a2 + 64) + 10) |= 0x400u;
          CountGlyphComponents((const __int16 *)(*(void *)(a2 + 16) + 10), *(void *)(a2 + 16) + *(unsigned __int16 *)(a2 + 8), &v49);
        }
      }
      else
      {
        unsigned int v17 = *(unsigned __int16 *)(a2 + 26);
        if (*(_DWORD *)(a2 + 192) < (signed int)v17) {
          goto LABEL_50;
        }
        if (*(_DWORD *)(*(void *)(*(void *)(a2 + 248) + 8) + 28) < v16) {
          goto LABEL_50;
        }
        int v18 = 2 * v16;
        BOOL v13 = __CFADD__(v18, 10);
        unsigned int v19 = v18 + 10;
        unsigned int v49 = v19;
        if (v13) {
          goto LABEL_50;
        }
        BOOL v13 = __CFADD__(v19, 2);
        unsigned int v20 = v19 + 2;
        unsigned int v49 = v20;
        if (v13) {
          goto LABEL_50;
        }
        int v21 = *(unsigned __int16 *)(a2 + 48);
        BOOL v13 = __CFADD__(v20, v21);
        unsigned int v22 = v20 + v21;
        unsigned int v49 = v22;
        if (v13
          || (BOOL v13 = __CFADD__(v22, 5 * v17), v23 = v22 + 5 * v17, v49 = v23, v13)
          || (v23 & 1) != 0 && (BOOL v13 = __CFADD__(v23, 1), ++v23, v49 = v23, v13))
        {
LABEL_50:
          exception = __cxa_allocate_exception(2uLL);
          _WORD *exception = 5;
          __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
        }
        unsigned int v24 = malloc_type_calloc(1uLL, v23, 0xA88DF300uLL);
        *a3 = v24;
        *(void *)(a2 + 376) = v24;
        *(_DWORD *)(a2 + 368) = 0;
        uint64_t v25 = (_WORD *)*a3;
        *uint64_t v25 = bswap32(*(unsigned __int16 *)(a2 + 24)) >> 16;
        v25[1] = bswap32(*(unsigned __int16 *)(a2 + 28)) >> 16;
        _OWORD v25[2] = bswap32(*(unsigned __int16 *)(a2 + 30)) >> 16;
        _OWORD v25[3] = bswap32(*(unsigned __int16 *)(a2 + 32)) >> 16;
        v25[4] = bswap32(*(unsigned __int16 *)(a2 + 34)) >> 16;
        BOOL v26 = (char *)(v25 + 5);
        if (*(__int16 *)(a2 + 24) >= 1)
        {
          memcpy(v26, *(const void **)(a2 + 40), 2 * *(unsigned __int16 *)(a2 + 24));
          v26 += 2 * *(__int16 *)(a2 + 24);
        }
        *(_WORD *)BOOL v26 = bswap32(*(unsigned __int16 *)(a2 + 48)) >> 16;
        long long v27 = v26 + 2;
        if (*(_WORD *)(a2 + 48))
        {
          memcpy(v27, *(const void **)(a2 + 56), *(unsigned __int16 *)(a2 + 48));
          v27 += *(unsigned __int16 *)(a2 + 48);
        }
        if (*(__int16 *)(a2 + 24) >= 1)
        {
          **(unsigned char **)(a2 + 120) |= 0x40u;
          memcpy(v27, *(const void **)(a2 + 120), *(unsigned __int16 *)(a2 + 26));
          uint64_t v28 = *(unsigned __int16 *)(a2 + 26);
          uint64_t v29 = *(void *)(*(void *)(a2 + 248) + 8);
          if (*(unsigned char *)(v29 + 159) && *(_DWORD *)(v29 + 84) == a1)
          {
            for (uint64_t i = 0; i != 8; ++i)
            {
              if (v17 <= *(unsigned __int8 *)(v29 + 88 + i))
              {
                int v46 = __cxa_allocate_exception(2uLL);
                *int v46 = 5;
                __cxa_throw(v46, MEMORY[0x1E4FBA3C8], 0);
              }
            }
            uint64_t v32 = *(void *)(a2 + 152);
            uint64_t v31 = *(void *)(a2 + 160);
            *(_WORD *)(a2 + 312) = *(_WORD *)(v31 + 2 * *(unsigned __int8 *)(v29 + 88));
            *(_WORD *)(a2 + 314) = *(_WORD *)(v31 + 2 * *(unsigned __int8 *)(v29 + 89));
            *(_WORD *)(a2 + 316) = *(_WORD *)(v31 + 2 * *(unsigned __int8 *)(v29 + 90))
                                 - *(_WORD *)(v31 + 2 * *(unsigned __int8 *)(v29 + 91));
            *(_WORD *)(a2 + 318) = *(_WORD *)(v32 + 2 * *(unsigned __int8 *)(v29 + 90))
                                 - *(_WORD *)(v32 + 2 * *(unsigned __int8 *)(v29 + 91));
            *(_WORD *)(a2 + 320) = *(_WORD *)(v32 + 2 * *(unsigned __int8 *)(v29 + 91));
            *(_WORD *)(a2 + 322) = *(_WORD *)(v32 + 2 * *(unsigned __int8 *)(v29 + 92));
            *(_WORD *)(a2 + 324) = *(_WORD *)(v32 + 2 * *(unsigned __int8 *)(v29 + 93));
            *(_WORD *)(a2 + 326) = *(_WORD *)(v32 + 2 * *(unsigned __int8 *)(v29 + 94))
                                 - *(_WORD *)(v32 + 2 * *(unsigned __int8 *)(v29 + 95));
            *(_WORD *)(a2 + 328) = *(_WORD *)(v31 + 2 * *(unsigned __int8 *)(v29 + 94))
                                 - *(_WORD *)(v31 + 2 * *(unsigned __int8 *)(v29 + 95));
            *(_WORD *)(a2 + 330) = *(_WORD *)(v31 + 2 * *(unsigned __int8 *)(v29 + 95));
          }
          if (v28)
          {
            int v33 = 0;
            long long v34 = &v27[v28];
            unsigned int v35 = *(unsigned __int16 **)(a2 + 152);
            do
            {
              int v36 = *v35++;
              *(_WORD *)long long v34 = bswap32(v36 - v33) >> 16;
              v34 += 2;
              int v33 = v36;
              LODWORD(v28) = v28 - 1;
            }
            while (v28);
            if (*(_WORD *)(a2 + 26))
            {
              uint64_t v37 = 0;
              int v38 = 0;
              uint64_t v39 = *(void *)(a2 + 160);
              int v40 = 2 * *(unsigned __int16 *)(a2 + 26);
              do
              {
                int v41 = *(unsigned __int16 *)(v39 + v37);
                *(_WORD *)&v34[v37] = bswap32(v41 - v38) >> 16;
                v37 += 2;
                int v38 = v41;
              }
              while (v40 != v37);
            }
          }
        }
      }
    }
    else
    {
      *(_DWORD *)(a2 + 368) = 1;
      *a3 = *(void *)(a2 + 16);
      unsigned int v49 = v6;
    }
    uint64_t v7 = *(void *)(a2 + 344);
    if (!v7)
    {
      int v47 = __cxa_allocate_exception(2uLL);
      *int v47 = 5;
      __cxa_throw(v47, MEMORY[0x1E4FBA3C8], 0);
    }
    uint64_t v8 = *(unsigned __int16 *)(a2 + 232);
    if (v8 <= a1)
    {
      uint64_t v42 = 2 * v8 - 2;
      if (!*(_WORD *)(a2 + 232)) {
        uint64_t v42 = 0;
      }
      uint64_t v43 = (_WORD *)(v7 + 2 * v42);
      if ((unint64_t)&v43[(int)(a1 - v8) + 3] <= *(void *)(a2 + 352))
      {
        *uint64_t v43 = bswap32(*(unsigned __int16 *)(a2 + 234)) >> 16;
        v43[a1 - *(unsigned __int16 *)(a2 + 232) + 2] = bswap32(*(unsigned __int16 *)(a2 + 236)) >> 16;
      }
    }
    else
    {
      unsigned int v9 = (_WORD *)(v7 + 4 * a1);
      if ((unint64_t)(v9 + 2) <= *(void *)(a2 + 352))
      {
        *unsigned int v9 = bswap32(*(unsigned __int16 *)(a2 + 234)) >> 16;
        v9[1] = bswap32(*(unsigned __int16 *)(a2 + 236)) >> 16;
      }
    }
  }
  else
  {
    unsigned int v48 = -1431655766;
    unsigned int GlyphOffsetAndSize = GetGlyphOffsetAndSize(a1, *(char **)(a2 + 208), *(_WORD *)(a2 + 216) != 0, &v48, *(void *)(a2 + 272));
    unsigned int v49 = GlyphOffsetAndSize;
    if (GlyphOffsetAndSize >= 0xB)
    {
      unsigned int v11 = GlyphOffsetAndSize;
      unsigned int FontTable = ScalerGetFontTable(**(memoryContext ***)(a2 + 248), 1735162214, v48, a3, 1, GlyphOffsetAndSize);
      BOOL v13 = __CFADD__(v48, v11);
      unsigned int v14 = v48 + v11;
      if (v13
        || v14 > FontTable && v14 > ScalerGetBlockSize(**(memoryContext ***)(a2 + 248), (const void *)*a3))
      {
        return 0;
      }
      *(void *)(a2 + 376) = *a3;
      *(_DWORD *)(a2 + 368) = 1;
    }
  }
  return (v49 & 1) + v49;
}

void sub_1B52F7178(void *a1)
{
}

void UninitGlyphDataContext(memoryContext **a1, uint64_t a2)
{
  UninitGlyphInfo(a1, a2);
  FreeGlyphData(a1, a2);
  free(*(void **)(a2 + 344));
  long long v4 = *(void **)(a2 + 360);
  free(v4);
}

uint64_t GetGlyphVariationOffsetAndSize(unsigned int a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v3 = a2 + 20;
  if ((*(_WORD *)(a2 + 14) & 0x100) != 0)
  {
    uint64_t v8 = (unsigned int *)(v3 + 4 * a1);
    unsigned int v9 = v8[1];
    unsigned int v10 = bswap32(*v8);
    unsigned int v6 = bswap32(*(_DWORD *)(a2 + 16)) + v10;
    uint64_t result = bswap32(v9) - v10;
    if (!a3) {
      return result;
    }
    goto LABEL_5;
  }
  long long v4 = (unsigned __int16 *)(v3 + 2 * a1);
  unsigned int v5 = bswap32(*v4);
  unsigned int v6 = bswap32(*(_DWORD *)(a2 + 16)) + 2 * HIWORD(v5);
  uint64_t result = 2 * ((bswap32(v4[1]) >> 16) - HIWORD(v5));
  if (a3) {
LABEL_5:
  }
    *a3 = v6;
  return result;
}

void FreeGlyphData(memoryContext **a1, uint64_t a2)
{
  if (*(void *)(a2 + 376))
  {
    int v2 = *(_DWORD *)(a2 + 368);
    if (v2 == 1)
    {
      ScalerReleaseFontTable(*a1, *(const void **)(a2 + 376));
    }
    else if (!v2)
    {
      free(*(void **)(a2 + 376));
    }
  }
}

void TType1PDC0Font::~TType1PDC0Font(TType1PDC0Font *this)
{
  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x1BA9994D0);
}

uint64_t TType1PDC0Font::GetFontDataTableTag(TType1PDC0Font *this)
{
  return 1346650928;
}

uint64_t fnt_SDPVTL(uint64_t a1)
{
  if (!*(void *)(a1 + 16) || !*(void *)(a1 + 8))
  {
    uint64_t v12 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "CHECK_ASSERTION: interpreter assertion failed \"%s\"");
    goto LABEL_14;
  }
  CHECK_STACK_POINTER_BASE(a1, *(void *)(a1 + 56));
  unint64_t v2 = *(void *)(a1 + 56);
  unsigned int v4 = *(_DWORD *)(v2 - 4);
  v2 -= 4;
  uint64_t v3 = v4;
  *(void *)(a1 + 56) = v2;
  CHECK_STACK_POINTER_BASE(a1, v2);
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v6 = *(unsigned int *)(v5 - 4);
  *(void *)(a1 + 56) = v5 - 4;
  uint64_t v7 = *(int **)(a1 + 16);
  CHECK_ELEMENTPTR(a1, v7);
  if ((v4 & 0x80000000) != 0 || v7[28] <= (int)v3)
  {
    uint64_t v12 = (FILE **)MEMORY[0x1E4F143C8];
    BOOL v13 = (FILE *)*MEMORY[0x1E4F143C8];
LABEL_13:
    fprintf(v13, "CHECK_RANGE_INDEX: %d not in range (%d - %d), interpreter value out of range");
LABEL_14:
    uint64_t v14 = *(void *)(*(void *)(a1 + 72) + 8);
    if (v14) {
      fprintf(*v12, "(glyph = %d)\n", *(_DWORD *)(v14 + 88));
    }
    fputc(10, *v12);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t v8 = *(void *)(a1 + 8);
  if ((v6 & 0x80000000) != 0 || *(_DWORD *)(v8 + 112) <= (int)v6)
  {
    uint64_t v12 = (FILE **)MEMORY[0x1E4F143C8];
    BOOL v13 = (FILE *)*MEMORY[0x1E4F143C8];
    goto LABEL_13;
  }
  fnt_Normalize(a1, *(_DWORD *)(*(void *)(v8 + 8) + 4 * v6) - *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 8) + 4 * v3), *(_DWORD *)(*(void *)(v8 + 16) + 4 * v6) - *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 16) + 4 * v3), (_WORD *)(a1 + 24));
  fnt_Normalize(a1, *(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 56) + 4 * v6)- *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 56) + 4 * v3), *(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 64) + 4 * v6)- *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 64) + 4 * v3), (_WORD *)(a1 + 32));
  *(unsigned char *)(a1 + 364) = 0;
  if (*(unsigned char *)(a1 + 363))
  {
    __int16 v9 = *(_WORD *)(a1 + 26);
    *(_WORD *)(a1 + 26) = *(_WORD *)(a1 + 24);
    *(_WORD *)(a1 + 24) = -v9;
    __int16 v10 = *(_WORD *)(a1 + 34);
    *(_WORD *)(a1 + 34) = *(_WORD *)(a1 + 32);
    *(_WORD *)(a1 + 32) = -v10;
    *(unsigned char *)(a1 + 364) = 1;
  }
  uint64_t result = fnt_ComputeAndCheck_PF_Proj(a1);
  *(void *)(a1 + 120) = fnt_MovePoint;
  *(void *)(a1 + 128) = fnt_Project;
  *(void *)(a1 + 136) = fnt_OldProject;
  return result;
}

uint64_t CHECK_STACK_POINTER_BASE(uint64_t result, unint64_t a2)
{
  uint64_t v2 = *(void *)(result + 80);
  if (*(int *)(v2 + 4) <= 0)
  {
    uint64_t v3 = (FILE **)MEMORY[0x1E4F143C8];
    unsigned int v4 = (FILE *)*MEMORY[0x1E4F143C8];
    uint64_t v5 = "ERROR: trying to pop an empty stack";
    goto LABEL_6;
  }
  if (*(void *)(v2 + 8) >= a2)
  {
    uint64_t v3 = (FILE **)MEMORY[0x1E4F143C8];
    unsigned int v4 = (FILE *)*MEMORY[0x1E4F143C8];
    uint64_t v5 = "ERROR: trying to pop below the stack base";
LABEL_6:
    uint64_t v6 = result;
    fprintf(v4, "CHECK_ASSERTION: interpreter assertion failed \"%s\"", v5);
    uint64_t v7 = *(void *)(*(void *)(v6 + 72) + 8);
    if (v7) {
      fprintf(*v3, "(glyph = %d)\n", *(_DWORD *)(v7 + 88));
    }
    fputc(10, *v3);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  return result;
}

uint64_t fnt_ISECT(uint64_t *a1)
{
  uint64_t v2 = *a1;
  unint64_t v3 = a1[7];
  CHECK_STACK_POINTER_BASE((uint64_t)a1, v3);
  uint64_t v4 = *(unsigned int *)(v3 - 4);
  CHECK_STACK_POINTER_BASE((uint64_t)a1, v3 - 4);
  if (!v2
    || (uint64_t v5 = *(unsigned int *)(v3 - 8), (v5 & 0x80000000) != 0)
    || (int v6 = *(_DWORD *)(v2 + 112), (int)v5 >= v6)
    || (v4 & 0x80000000) != 0
    || (int)v4 >= v6)
  {
    uint64_t v42 = (FILE **)MEMORY[0x1E4F143C8];
    uint64_t v43 = (FILE *)*MEMORY[0x1E4F143C8];
    uint64_t v44 = "ERROR: arg1 or arg2 out of range(CE0)";
    goto LABEL_49;
  }
  uint64_t v7 = *(void *)(v2 + 8);
  uint64_t v8 = *(void *)(v2 + 16);
  int v9 = *(_DWORD *)(v7 + 4 * v4);
  int v47 = *(_DWORD *)(v7 + 4 * v5);
  int v10 = *(_DWORD *)(v8 + 4 * v4);
  int v11 = *(_DWORD *)(v8 + 4 * v5);
  uint64_t v12 = a1[1];
  CHECK_STACK_POINTER_BASE((uint64_t)a1, v3 - 8);
  uint64_t v13 = *(unsigned int *)(v3 - 12);
  CHECK_STACK_POINTER_BASE((uint64_t)a1, v3 - 12);
  if (!v12
    || (uint64_t v14 = *(unsigned int *)(v3 - 16), (v14 & 0x80000000) != 0)
    || (int v15 = *(_DWORD *)(v12 + 112), (int)v14 >= v15)
    || (v13 & 0x80000000) != 0
    || (int)v13 >= v15)
  {
    uint64_t v42 = (FILE **)MEMORY[0x1E4F143C8];
    uint64_t v43 = (FILE *)*MEMORY[0x1E4F143C8];
    uint64_t v44 = "ERROR: arg1 or arg2 out of range(CE1)";
    goto LABEL_49;
  }
  uint64_t v16 = *(void *)(v12 + 8);
  uint64_t v17 = *(void *)(v12 + 16);
  int v18 = *(_DWORD *)(v16 + 4 * v13);
  int v19 = *(_DWORD *)(v16 + 4 * v14);
  int v20 = *(_DWORD *)(v17 + 4 * v13);
  int v21 = *(_DWORD *)(v17 + 4 * v14);
  uint64_t v22 = a1[2];
  uint64_t result = CHECK_STACK_POINTER_BASE((uint64_t)a1, v3 - 16);
  uint64_t v24 = *(unsigned int *)(v3 - 20);
  a1[7] = v3 - 20;
  if (!v22 || (v24 & 0x80000000) != 0 || (int)v24 >= *(_DWORD *)(v22 + 112))
  {
    uint64_t v42 = (FILE **)MEMORY[0x1E4F143C8];
    uint64_t v43 = (FILE *)*MEMORY[0x1E4F143C8];
    uint64_t v44 = "ERROR: arg1 out of range(CE2)";
LABEL_49:
    fprintf(v43, "CHECK_ASSERTION: interpreter assertion failed \"%s\"", v44);
    uint64_t v45 = *(void *)(a1[9] + 8);
    if (v45) {
      fprintf(*v42, "(glyph = %d)\n", *(_DWORD *)(v45 + 88));
    }
    fputc(10, *v42);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  int v25 = v9 - v47;
  int v26 = v10 - v11;
  int v27 = v18 - v19;
  int v28 = v20 - v21;
  *(unsigned char *)(*(void *)(a1[2] + 48) + v24) |= 3u;
  uint64_t v29 = a1[2];
  uint64_t v31 = *(void *)(v29 + 8);
  uint64_t v30 = *(void *)(v29 + 16);
  if (v10 == v11)
  {
    if (v18 == v19)
    {
      *(_DWORD *)(v31 + 4 * v24) = v18;
      goto LABEL_45;
    }
    int v32 = v21 - v10;
    int v33 = v21 - v20;
    if (!v28)
    {
LABEL_43:
      *(_DWORD *)(v31 + 4 * v24) = (v47 + (v25 >> 1) + v19 + (v27 >> 1)) >> 1;
      int v10 = (v11 + (v26 >> 1) + v21 + (v28 >> 1)) >> 1;
      goto LABEL_45;
    }
  }
  else if (v9 == v47)
  {
    if (v20 == v21)
    {
      *(_DWORD *)(v31 + 4 * v24) = v9;
      int v10 = v20;
      goto LABEL_45;
    }
    int v32 = v19 - v9;
    int v33 = v19 - v18;
    if (!v27) {
      goto LABEL_43;
    }
  }
  else
  {
    if (v25 >= 0) {
      unsigned int v34 = v9 - v47;
    }
    else {
      unsigned int v34 = v47 - v9;
    }
    if (v26 >= 0) {
      unsigned int v35 = v10 - v11;
    }
    else {
      unsigned int v35 = v11 - v10;
    }
    if (v34 <= v35)
    {
      signed int v41 = vcvtd_n_s64_f64((double)v25 * 9.31322575e-10 / ((double)v26 * 9.31322575e-10), 0x1EuLL);
      uint64_t result = (v47 - v19);
      int v32 = result + ((unint64_t)((v21 - v11) * (uint64_t)v41 + 0x20000000) >> 30);
      int v33 = v27 - ((unint64_t)(v28 * (uint64_t)v41 + 0x20000000) >> 30);
      if (!v33) {
        goto LABEL_43;
      }
    }
    else
    {
      signed int v36 = vcvtd_n_s64_f64((double)v26 * 9.31322575e-10 / ((double)v25 * 9.31322575e-10), 0x1EuLL);
      uint64_t result = (v21 - v11);
      int v32 = result - ((unint64_t)((v19 - v47) * (uint64_t)v36 + 0x20000000) >> 30);
      int v33 = ((unint64_t)(v27 * (uint64_t)v36 + 0x20000000) >> 30) - v28;
      if (!v33) {
        goto LABEL_43;
      }
    }
  }
  if (v32 >= 0) {
    unsigned int v37 = v32;
  }
  else {
    unsigned int v37 = -v32;
  }
  if (v33 >= 0) {
    unsigned int v38 = v33;
  }
  else {
    unsigned int v38 = -v33;
  }
  if (v37 >= v38)
  {
    if (v32)
    {
      double v40 = (double)(int)vcvtd_n_s64_f64((double)v33 * 9.31322575e-10 / ((double)v32 * 9.31322575e-10), 0x1EuLL)
          * 9.31322575e-10;
      *(_DWORD *)(v31 + 4 * v24) = v19 + vcvtd_n_s64_f64((double)v27 * 9.31322575e-10 / v40, 0x1EuLL);
      int v10 = v21 + vcvtd_n_s64_f64((double)v28 * 9.31322575e-10 / v40, 0x1EuLL);
    }
    else
    {
      *(_DWORD *)(v31 + 4 * v24) = v19;
      int v10 = v21;
    }
  }
  else
  {
    signed int v39 = vcvtd_n_s64_f64((double)v32 * 9.31322575e-10 / ((double)v33 * 9.31322575e-10), 0x1EuLL);
    *(_DWORD *)(v31 + 4 * v24) = v19 + ((unint64_t)(v39 * (uint64_t)v27 + 0x20000000) >> 30);
    int v10 = v21 + ((unint64_t)(v39 * (uint64_t)v28 + 0x20000000) >> 30);
  }
LABEL_45:
  *(_DWORD *)(v30 + 4 * v24) = v10;
  return result;
}

uint64_t fnt_SROUND(uint64_t a1)
{
  CHECK_STACK_POINTER_BASE(a1, *(void *)(a1 + 56));
  uint64_t v2 = *(void *)(a1 + 56);
  unsigned int v3 = *(_DWORD *)(v2 - 4);
  *(void *)(a1 + 56) = v2 - 4;
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t result = fnt_SetRoundValues(v4, v3, 1);
  *(void *)(v4 + 216) = fnt_SuperRound;
  return result;
}

uint64_t fnt_SetRoundValues(uint64_t result, unsigned int a2, int a3)
{
  int v3 = a2 & 0xC0;
  if (!a3)
  {
    *(_DWORD *)(result + 228) = 759250125;
    if ((a2 & 0xC0) != 0)
    {
      if (v3 == 64)
      {
        unsigned int v6 = 45;
        goto LABEL_23;
      }
      if (v3 == 128) {
        int v7 = 1518500250;
      }
      else {
        int v7 = 999;
      }
      if (v3 == 128) {
        unsigned int v6 = 91;
      }
      else {
        unsigned int v6 = 0;
      }
    }
    else
    {
      unsigned int v6 = 23;
      int v7 = 379625062;
    }
    *(_DWORD *)(result + 228) = v7;
LABEL_23:
    *(_WORD *)(result + 232) = v6;
    goto LABEL_24;
  }
  if (v3 == 64) {
    int v4 = 64;
  }
  else {
    int v4 = 999;
  }
  if (v3 == 128) {
    int v5 = 128;
  }
  else {
    int v5 = v4;
  }
  if ((a2 & 0xC0) != 0) {
    unsigned int v6 = v5;
  }
  else {
    unsigned int v6 = 32;
  }
  *(_WORD *)(result + 232) = v6;
  *(_DWORD *)(result + 224) = -v6;
LABEL_24:
  LOWORD(v8) = 0;
  switch((a2 >> 4) & 3)
  {
    case 1u:
      unsigned int v9 = v6 + 2;
      goto LABEL_28;
    case 2u:
      unsigned int v8 = (v6 + 1) >> 1;
      break;
    case 3u:
      unsigned int v9 = 3 * v6 + 2;
LABEL_28:
      unsigned int v8 = v9 >> 2;
      break;
    default:
      break;
  }
  *(_WORD *)(result + 234) = v8;
  if ((a2 & 0xF) != 0) {
    unsigned int v6 = (((a2 & 0xF) + 524284) * v6 + 4) >> 3;
  }
  else {
    LOWORD(v6) = v6 - 1;
  }
  *(_WORD *)(result + 236) = v6;
  *(unsigned char *)(result + 245) = a2;
  return result;
}

uint64_t fnt_S45ROUND(uint64_t a1)
{
  CHECK_STACK_POINTER_BASE(a1, *(void *)(a1 + 56));
  uint64_t v2 = *(void *)(a1 + 56);
  unsigned int v3 = *(_DWORD *)(v2 - 4);
  *(void *)(a1 + 56) = v2 - 4;
  uint64_t v4 = *(void *)(a1 + 80);
  uint64_t result = fnt_SetRoundValues(v4, v3, 0);
  *(void *)(v4 + 216) = fnt_Super45Round;
  return result;
}

uint64_t fnt_RAW(void *a1)
{
  uint64_t v2 = *(void *)(a1[9] + 8);
  if (!v2)
  {
    int v7 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "CHECK_ASSERTION: interpreter assertion failed \"%s\"", "ERROR: elements[GLYPHELEMENT] == NULL");
    uint64_t v8 = *(void *)(a1[9] + 8);
    if (v8) {
      fprintf(*v7, "(glyph = %d)\n", *(_DWORD *)(v8 + 88));
    }
    fputc(10, *v7);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t v3 = *(void *)(v2 + 56);
  uint64_t v4 = *(int *)(v2 + 4);
  GrowStackForPush(a1, 1);
  uint64_t result = CHECK_STACK_POINTER_END((uint64_t)a1, a1[7]);
  unsigned int v6 = (_DWORD *)a1[7];
  *unsigned int v6 = *(_DWORD *)(v3 + 4 * v4 + 4) - *(_DWORD *)(v3 + 4 * v4);
  a1[7] = v6 + 1;
  return result;
}

uint64_t CHECK_STACK_POINTER_END(uint64_t result, unint64_t a2)
{
  if (*(int *)(*(void *)(result + 80) + 4) <= 0)
  {
    uint64_t v2 = (FILE **)MEMORY[0x1E4F143C8];
    uint64_t v3 = (FILE *)*MEMORY[0x1E4F143C8];
    uint64_t v4 = "ERROR: trying to pop an empty stack";
    goto LABEL_6;
  }
  if (*(void *)(result + 48) <= a2)
  {
    uint64_t v2 = (FILE **)MEMORY[0x1E4F143C8];
    uint64_t v3 = (FILE *)*MEMORY[0x1E4F143C8];
    uint64_t v4 = "ERROR: trying to push beyond the end of stack";
LABEL_6:
    uint64_t v5 = result;
    fprintf(v3, "CHECK_ASSERTION: interpreter assertion failed \"%s\"", v4);
    uint64_t v6 = *(void *)(*(void *)(v5 + 72) + 8);
    if (v6) {
      fprintf(*v2, "(glyph = %d)\n", *(_DWORD *)(v6 + 88));
    }
    fputc(10, *v2);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  return result;
}

uint64_t fnt_SANGW(uint64_t a1)
{
  uint64_t result = CHECK_STACK_POINTER_BASE(a1, *(void *)(a1 + 56));
  *(void *)(a1 + 56) -= 4;
  return result;
}

uint64_t fnt_AA(uint64_t a1)
{
  uint64_t result = CHECK_STACK_POINTER_BASE(a1, *(void *)(a1 + 56));
  *(void *)(a1 + 56) -= 4;
  return result;
}

uint64_t fnt_DEBUG(uint64_t a1)
{
  CHECK_STACK_POINTER_BASE(a1, *(void *)(a1 + 56));
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(int *)(v2 - 4);
  *(void *)(a1 + 56) = v2 - 4;
  return printf("fnt_DEBUG: DEBUG opcode: %08lX\n", v3);
}

uint64_t fnt_UTP(uint64_t a1)
{
  CHECK_STACK_POINTER_BASE(a1, *(void *)(a1 + 56));
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(unsigned int *)(v2 - 4);
  *(void *)(a1 + 56) = v2 - 4;
  uint64_t v4 = *(int **)a1;
  if (!*(void *)a1)
  {
    int v7 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "CHECK_ASSERTION: interpreter assertion failed \"%s\"");
    goto LABEL_11;
  }
  uint64_t result = CHECK_ELEMENTPTR(a1, *(int **)a1);
  if ((v3 & 0x80000000) != 0 || v4[28] <= (int)v3)
  {
    int v7 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "CHECK_RANGE_INDEX: %d not in range (%d - %d), interpreter value out of range");
LABEL_11:
    uint64_t v8 = *(void *)(*(void *)(a1 + 72) + 8);
    if (v8) {
      fprintf(*v7, "(glyph = %d)\n", *(_DWORD *)(v8 + 88));
    }
    fputc(10, *v7);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t v6 = *(void *)(*(void *)a1 + 48);
  if (*(_WORD *)(a1 + 28)) {
    *(unsigned char *)(v6 + v3) &= ~1u;
  }
  if (*(_WORD *)(a1 + 30)) {
    *(unsigned char *)(v6 + v3) &= ~2u;
  }
  return result;
}

uint64_t fnt_SDB(uint64_t a1)
{
  uint64_t result = CHECK_STACK_POINTER_BASE(a1, *(void *)(a1 + 56));
  uint64_t v3 = *(void *)(a1 + 56);
  int v4 = *(_DWORD *)(v3 - 4);
  *(void *)(a1 + 56) = v3 - 4;
  *(_WORD *)(*(void *)(a1 + 80) + 238) = v4;
  return result;
}

uint64_t fnt_SDS(uint64_t a1)
{
  uint64_t result = CHECK_STACK_POINTER_BASE(a1, *(void *)(a1 + 56));
  uint64_t v3 = *(void *)(a1 + 56);
  int v4 = *(_DWORD *)(v3 - 4);
  *(void *)(a1 + 56) = v3 - 4;
  *(_WORD *)(*(void *)(a1 + 80) + 240) = v4;
  return result;
}

uint64_t fnt_FLIPPT(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  if (!*(void *)a1)
  {
    int v10 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "CHECK_ASSERTION: interpreter assertion failed \"%s\"");
    goto LABEL_9;
  }
  uint64_t v3 = *(void *)(v2 + 40);
  unint64_t v4 = *(void *)(a1 + 56);
  uint64_t result = CHECK_ELEMENTPTR(a1, (int *)v2);
  int v6 = *(_DWORD *)(a1 + 112);
  if ((v6 & 0x80000000) == 0)
  {
    int v7 = v6 + 1;
    while (1)
    {
      uint64_t result = CHECK_STACK_POINTER_BASE(a1, v4);
      unsigned int v9 = *(_DWORD *)(v4 - 4);
      v4 -= 4;
      uint64_t v8 = v9;
      if ((v9 & 0x80000000) != 0 || *(_DWORD *)(*(void *)a1 + 112) <= (int)v8) {
        break;
      }
      *(unsigned char *)(v3 + v8) ^= 1u;
      if (--v7 <= 0) {
        goto LABEL_7;
      }
    }
    int v10 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "CHECK_RANGE_INDEX: %d not in range (%d - %d), interpreter value out of range");
LABEL_9:
    uint64_t v11 = *(void *)(*(void *)(a1 + 72) + 8);
    if (v11) {
      fprintf(*v10, "(glyph = %d)\n", *(_DWORD *)(v11 + 88));
    }
    fputc(10, *v10);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
LABEL_7:
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 56) = v4;
  return result;
}

uint64_t CHECK_ELEMENTPTR(uint64_t result, int *a2)
{
  if (!a2)
  {
LABEL_4:
    uint64_t v3 = (FILE **)MEMORY[0x1E4F143C8];
    uint64_t v4 = result;
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "CHECK_ASSERTION: interpreter assertion failed \"%s\"", "Bad element ptr");
    uint64_t v5 = *(void *)(*(void *)(v4 + 72) + 8);
    if (v5) {
      fprintf(*v3, "(glyph = %d)\n", *(_DWORD *)(v5 + 88));
    }
    fputc(10, *v3);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    goto LABEL_26;
  }
  uint64_t v2 = *(int ***)(result + 72);
  if (v2[1] == a2)
  {
    int v7 = *(unsigned __int16 **)(*(void *)(result + 80) + 248);
    if (v7[4] <= v7[6]) {
      int v8 = v7[6];
    }
    else {
      int v8 = v7[4];
    }
    int v9 = v7[3];
    unsigned int v10 = v7[5];
    if (v9 <= v10) {
      int v9 = v10;
    }
    if (*a2 >= 1 && *a2 <= v8)
    {
      int v12 = a2[1];
      if (v12 >= 1 && v12 <= v9) {
        return result;
      }
      uint64_t v14 = (FILE **)MEMORY[0x1E4F143C8];
      int v15 = (FILE *)*MEMORY[0x1E4F143C8];
      int v19 = v9;
      int v18 = a2[1];
    }
    else
    {
      uint64_t v14 = (FILE **)MEMORY[0x1E4F143C8];
      int v15 = (FILE *)*MEMORY[0x1E4F143C8];
      int v19 = v8;
      int v18 = *a2;
    }
    uint64_t v16 = result;
    fprintf(v15, "CHECK_RANGE: %d not in range (%d - %d), interpreter value out of range", v18, v19, 1);
    uint64_t v17 = *(void *)(*(void *)(v16 + 72) + 8);
    if (v17) {
      fprintf(*v14, "(glyph = %d)\n", *(_DWORD *)(v17 + 88));
    }
    fputc(10, *v14);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
LABEL_26:
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  if (*v2 != a2) {
    goto LABEL_4;
  }
  return result;
}

uint64_t fnt_FLIPRGON(void *a1)
{
  if (!*a1)
  {
    uint64_t v13 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "CHECK_ASSERTION: interpreter assertion failed \"%s\"");
    goto LABEL_15;
  }
  uint64_t v2 = *(void *)(*a1 + 40);
  unint64_t v3 = a1[7];
  CHECK_STACK_POINTER_BASE((uint64_t)a1, v3);
  int v4 = *(_DWORD *)(v3 - 4);
  uint64_t v5 = *a1;
  CHECK_ELEMENTPTR((uint64_t)a1, (int *)*a1);
  if (v4 < 0 || *(_DWORD *)(v5 + 112) <= v4)
  {
    uint64_t v13 = (FILE **)MEMORY[0x1E4F143C8];
    uint64_t v14 = (FILE *)*MEMORY[0x1E4F143C8];
LABEL_14:
    fprintf(v14, "CHECK_RANGE_INDEX: %d not in range (%d - %d), interpreter value out of range");
LABEL_15:
    uint64_t v15 = *(void *)(a1[9] + 8);
    if (v15) {
      fprintf(*v13, "(glyph = %d)\n", *(_DWORD *)(v15 + 88));
    }
    fputc(10, *v13);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t result = CHECK_STACK_POINTER_BASE((uint64_t)a1, v3 - 4);
  unsigned int v9 = *(_DWORD *)(v3 - 8);
  unint64_t v8 = v3 - 8;
  uint64_t v7 = v9;
  if ((v9 & 0x80000000) != 0 || *(_DWORD *)(*a1 + 112) <= (int)v7)
  {
    uint64_t v13 = (FILE **)MEMORY[0x1E4F143C8];
    uint64_t v14 = (FILE *)*MEMORY[0x1E4F143C8];
    goto LABEL_14;
  }
  if (v4 - (int)v7 >= 0)
  {
    unsigned int v10 = (unsigned char *)(v2 + v7);
    int v11 = ~v4 + v7;
    do
      *v10++ |= 1u;
    while (!__CFADD__(v11++, 1));
  }
  a1[7] = v8;
  return result;
}

uint64_t fnt_FLIPRGOFF(unint64_t *a1)
{
  if (!*a1)
  {
    uint64_t v13 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "CHECK_ASSERTION: interpreter assertion failed \"%s\"");
    goto LABEL_15;
  }
  uint64_t v2 = *(void *)(*a1 + 40);
  CHECK_STACK_POINTER_BASE((uint64_t)a1, a1[7]);
  unint64_t v3 = a1[7];
  int v4 = *(_DWORD *)(v3 - 4);
  a1[7] = v3 - 4;
  unint64_t v5 = *a1;
  CHECK_ELEMENTPTR((uint64_t)a1, (int *)*a1);
  if (v4 < 0 || *(_DWORD *)(v5 + 112) <= v4)
  {
    uint64_t v13 = (FILE **)MEMORY[0x1E4F143C8];
    uint64_t v14 = (FILE *)*MEMORY[0x1E4F143C8];
LABEL_14:
    fprintf(v14, "CHECK_RANGE_INDEX: %d not in range (%d - %d), interpreter value out of range");
LABEL_15:
    uint64_t v15 = *(void *)(a1[9] + 8);
    if (v15) {
      fprintf(*v13, "(glyph = %d)\n", *(_DWORD *)(v15 + 88));
    }
    fputc(10, *v13);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t result = CHECK_STACK_POINTER_BASE((uint64_t)a1, a1[7]);
  unint64_t v7 = a1[7];
  unsigned int v9 = *(_DWORD *)(v7 - 4);
  uint64_t v8 = v9;
  a1[7] = v7 - 4;
  if ((v9 & 0x80000000) != 0 || *(_DWORD *)(*a1 + 112) <= (int)v8)
  {
    uint64_t v13 = (FILE **)MEMORY[0x1E4F143C8];
    uint64_t v14 = (FILE *)*MEMORY[0x1E4F143C8];
    goto LABEL_14;
  }
  if (v4 - (int)v8 >= 0)
  {
    unsigned int v10 = (unsigned char *)(v2 + v8);
    int v11 = ~v4 + v8;
    do
      *v10++ &= ~1u;
    while (!__CFADD__(v11++, 1));
  }
  return result;
}

uint64_t fnt_MPS(void *a1)
{
  GrowStackForPush(a1, 1);
  uint64_t result = CHECK_STACK_POINTER_END((uint64_t)a1, a1[7]);
  unint64_t v3 = (_DWORD *)a1[7];
  *unint64_t v3 = *(_DWORD *)(a1[10] + 120);
  a1[7] = v3 + 1;
  return result;
}

__n128 fnt_IDefPatch(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  int v3 = *(_DWORD *)(v2 + 124);
  if (v3 < 1) {
LABEL_5:
  }
    fnt_IllegalInstruction();
  int v4 = v3 + 1;
  unint64_t v5 = (unsigned __int8 *)(*(void *)(v2 + 56) + 7);
  while (*v5 != *(unsigned __int8 *)(a1 + 363))
  {
    --v4;
    v5 += 8;
    if (v4 <= 1) {
      goto LABEL_5;
    }
  }
  unsigned int v6 = *(v5 - 1);
  if (v6 >= 2)
  {
    unsigned int v10 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "CHECK_PROGRAM: %d is neither a fontProgramIndex(%d) nor preProgramIndex(%d)", v6, 0, 1);
    uint64_t v11 = *(void *)(*(void *)(a1 + 72) + 8);
    if (v11) {
      fprintf(*v10, "(glyph = %d)\n", *(_DWORD *)(v11 + 88));
    }
    fputc(10, *v10);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = *(void *)(v2 + 8 * *(v5 - 1) + 64) + *(int *)(v5 - 7);
  __n128 v13 = *(__n128 *)(a1 + 368);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 144))(a1, v8, v8 + *(unsigned __int16 *)(v5 - 3));
  *(void *)(a1 + 64) = v7;
  __n128 result = v13;
  *(__n128 *)(a1 + 368) = v13;
  return result;
}

unsigned __int8 *fnt_IDEF(unint64_t *a1)
{
  CHECK_STACK_POINTER_BASE((uint64_t)a1, a1[7]);
  unint64_t v2 = a1[7];
  int v3 = *(unsigned __int8 *)(v2 - 4);
  a1[7] = v2 - 4;
  unint64_t v4 = a1[10];
  uint64_t v5 = *(int *)(v4 + 124);
  if ((int)v5 < 1)
  {
LABEL_5:
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = *(void *)(v4 + 56);
    int v7 = v5 + 1;
    while (*(unsigned __int8 *)(v6 + 7) != v3)
    {
      v6 += 8;
      if (--v7 <= 1) {
        goto LABEL_5;
      }
    }
  }
  uint64_t v8 = *(int *)(v4 + 128);
  if (v8 >= 2)
  {
    __n128 v13 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "CHECK_PROGRAM: %d is neither a fontProgramIndex(%d) nor preProgramIndex(%d)", v8, 0, 1);
    uint64_t v14 = *(void *)(a1[9] + 8);
    if (v14) {
      fprintf(*v13, "(glyph = %d)\n", *(_DWORD *)(v14 + 88));
    }
    fputc(10, *v13);
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 1;
LABEL_17:
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t v9 = *(void *)(v4 + 8 * v8 + 64);
  unsigned int v10 = (unsigned __int8 *)a1[8];
  if (v6) {
    goto LABEL_10;
  }
  if ((int)v5 >= *(unsigned __int16 *)(*(void *)(v4 + 248) + 22) + 4)
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    goto LABEL_17;
  }
  uint64_t v11 = *(void *)(v4 + 56);
  *(_DWORD *)(v4 + 124) = v5 + 1;
  uint64_t v6 = v11 + 8 * v5;
LABEL_10:
  if (v8 == 1) {
    *(unsigned char *)(v4 + 265) = 1;
  }
  *(unsigned char *)(v6 + 6) = v8;
  *(unsigned char *)(v6 + 7) = v3;
  *(_DWORD *)uint64_t v6 = v10 - v9;
  __n128 result = fnt_FindENDF((uint64_t)a1, v10);
  *(_WORD *)(v6 + 4) = ~*((_WORD *)a1 + 32) + (_WORD)result;
  a1[8] = (unint64_t)result;
  return result;
}

uint64_t TTrueTypeFont::IsTrueTypeFont(TTrueTypeFont *this, TSFNTFont *a2, const TSFNTFont *a3)
{
  int v4 = (int)this;
  uint64_t result = 0;
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (v4 < 0x10000)
  {
    if (v4 != -1519689116 && v4 != -1519619212) {
      return result;
    }
LABEL_7:
    qmemcpy(v7, "pxamdaehaehhxtmhacolfylg", sizeof(v7));
    uint64_t result = TSFNTFont::HasTableTags(a2, (uint64_t)v7, 6);
    if (result) {
      return TTrueTypeFont::ThrowIfInvalid(a2, v6);
    }
    return result;
  }
  if (v4 == 1953658213 || v4 == 0x10000) {
    goto LABEL_7;
  }
  return result;
}

uint64_t TTrueTypeFont::ThrowIfInvalid(TTrueTypeFont *this, const TSFNTFont *a2)
{
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v8 = v3;
  long long v9 = v3;
  long long v7 = v3;
  TsfntTable::TsfntTable((TsfntTable *)&v7, this, 1835104368);
  *(void *)&long long v7 = &unk_1F0DD6EE0;
  if (TsfntTable::operator BOOL((TsfntTable *)&v7)) {
    TmaxpTable::GetNumGlyphs((TmaxpTable *)&v7);
  }
  TDataReference::~TDataReference((TDataReference *)&v7);
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v8 = v4;
  long long v9 = v4;
  long long v7 = v4;
  TheadTable::TheadTable((TheadTable *)&v7, this);
  if (TsfntTable::operator BOOL((TsfntTable *)&v7)
    && (TheadTable::GetUnitsPerEm((TheadTable *)&v7), *(_WORD *)(TheadTable::GetHead((TheadTable *)&v7) + 52)))
  {
    TDataReference::~TDataReference((TDataReference *)&v7);
    return 0;
  }
  else
  {
    TDataReference::~TDataReference((TDataReference *)&v7);
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v10 = v6;
    long long v11 = v6;
    long long v8 = v6;
    long long v9 = v6;
    long long v7 = v6;
    ThmtxTable::ThmtxTable((uint64_t)&v7, this, 0);
    if (TsfntTable::operator BOOL((TsfntTable *)&v7)) {
      ThmtxTable::GetHhea((ThmtxTable *)&v7);
    }
    TDataReference::~TDataReference((TDataReference *)&v7);
    return 1;
  }
}

void sub_1B52F8AE8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B52F8B20(_Unwind_Exception *a1)
{
}

void TTrueTypeMemoryFont::TTrueTypeMemoryFont(TSFNTFont *a1, uint64_t a2, const void *a3)
{
  TSFNTFont::TSFNTFont(a1);
  *(void *)uint64_t v6 = &unk_1F0DD76A0;
  *(void *)(v6 + 16) = &unk_1F0DD78A8;
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)(v6 + 200) = &unk_1F0DD4120;
  *(void *)(v6 + 208) = v7;
  *(_DWORD *)(v6 + 216) = *(_DWORD *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  if (a3) {
    CFTypeRef v8 = CFRetain(a3);
  }
  else {
    CFTypeRef v8 = 0;
  }
  CFTypeRef v9 = v8;
  TInMemoryDataReference::TInMemoryDataReference((void *)a1 + 28);
}

void sub_1B52F8C10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  TInMemoryDataReference::~TInMemoryDataReference(v11);
  TSFNTFont::~TSFNTFont(v10);
  _Unwind_Resume(a1);
}

void TTrueTypeMemoryFont::~TTrueTypeMemoryFont(TTrueTypeMemoryFont *this)
{
  *(void *)this = &unk_1F0DD76A0;
  *((void *)this + 2) = &unk_1F0DD78A8;
  TInMemoryDataReference::~TInMemoryDataReference((TTrueTypeMemoryFont *)((char *)this + 224));
  TInMemoryDataReference::~TInMemoryDataReference((TTrueTypeMemoryFont *)((char *)this + 200));
  TSFNTFont::~TSFNTFont(this);
}

{
  uint64_t vars8;

  TTrueTypeMemoryFont::~TTrueTypeMemoryFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TTrueTypeMemoryFont::~TTrueTypeMemoryFont(TTrueTypeMemoryFont *this)
{
}

{
  uint64_t vars8;

  TTrueTypeMemoryFont::~TTrueTypeMemoryFont((TTrueTypeMemoryFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

uint64_t TTrueTypeMemoryFont::GetKind(TTrueTypeMemoryFont *this)
{
  return 9;
}

BOOL TTrueTypeMemoryFont::GotTable(TTrueTypeMemoryFont *this, int a2)
{
  if (a2 == 1516335206) {
    BOOL v2 = *(void *)(*((void *)this + 29) + 16) == 0;
  }
  else {
    BOOL v2 = TSFNTFont::GetTableOffset(this, a2, 0) == -1;
  }
  return !v2;
}

void *TTrueTypeMemoryFont::GetTable@<X0>(TTrueTypeMemoryFont *this@<X0>, unint64_t *a2@<X2>, int a3@<W1>, uint64_t a4@<X8>)
{
  if (a3 == 1516335206)
  {
    *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)a4 = v8;
    *(_OWORD *)(a4 + 16) = v8;
    uint64_t result = TInMemoryDataReference::GetDataReference((void *)this + 28, 0, 0, (void *)a4);
    uint64_t v10 = *(void *)(a4 + 24) - *(void *)(a4 + 16);
    if (v10 >= 1)
    {
      uint64_t v11 = *(void *)(a4 + 8);
      if (v11)
      {
        if (*(void *)(v11 + 8))
        {
          *a2 = v10;
          return result;
        }
      }
    }
    TDataReference::~TDataReference((TDataReference *)a4);
  }
  return (void *)TSFNTFont::GetTable(this, a2, a3, (void *)a4);
}

uint64_t TTrueTypeMemoryFont::GetFontRef(TTrueTypeMemoryFont *this)
{
  return (uint64_t)this + 200;
}

void TTrueTypeWOFFFont::TTrueTypeWOFFFont(TTrueTypeWOFFFont *this, CFDataRef theData)
{
  CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  long long v3 = &unk_1F0DD4120;
  operator new();
}

void sub_1B52F8FA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  TTrueTypeMemoryFont::~TTrueTypeMemoryFont(v10);
  _Unwind_Resume(a1);
}

void TTrueTypeWOFFFont::~TTrueTypeWOFFFont(TTrueTypeWOFFFont *this)
{
  *(void *)this = &unk_1F0DFE6E8;
  *((void *)this + 2) = &unk_1F0DFE8F0;
  TCFData::~TCFData((const void **)this + 31);
  TTrueTypeMemoryFont::~TTrueTypeMemoryFont(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DFE6E8;
  *((void *)this + 2) = &unk_1F0DFE8F0;
  TCFData::~TCFData((const void **)this + 31);
  TTrueTypeMemoryFont::~TTrueTypeMemoryFont(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DFE6E8;
  *((void *)this + 2) = &unk_1F0DFE8F0;
  TCFData::~TCFData((const void **)this + 31);
  TTrueTypeMemoryFont::~TTrueTypeMemoryFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TTrueTypeWOFFFont::~TTrueTypeWOFFFont(TTrueTypeWOFFFont *this)
{
  uint64_t v1 = (TTrueTypeWOFFFont *)((char *)this - 16);
  *((void *)this - 2) = &unk_1F0DFE6E8;
  *(void *)this = &unk_1F0DFE8F0;
  TCFData::~TCFData((const void **)this + 29);
  TTrueTypeMemoryFont::~TTrueTypeMemoryFont(v1);
}

{
  TTrueTypeWOFFFont::~TTrueTypeWOFFFont((TTrueTypeWOFFFont *)((char *)this - 16));
}

void non-virtual thunk to'TTrueTypeDataForkFont::~TTrueTypeDataForkFont(TTrueTypeDataForkFont *this)
{
  uint64_t v1 = (TTrueTypeDataForkFont *)((char *)this - 16);
  *((void *)this - 2) = &unk_1F0DD7478;
  *(void *)this = &unk_1F0DD7680;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 23);
  TSFNTFont::~TSFNTFont(v1);
}

{
  TTrueTypeDataForkFont::~TTrueTypeDataForkFont((TTrueTypeDataForkFont *)((char *)this - 16));
}

void TTrueTypeFont::GetGlyphName(TTrueTypeFont *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v10 = v6;
  long long v11 = v6;
  long long v8 = v6;
  long long v9 = v6;
  TSFNTFont::GetGlyphName(this, a2, (uint64_t)&v8);
  if (!*((void *)&v8 + 1))
  {
    if (!*((void *)&v10 + 1)) {
      goto LABEL_10;
    }
    if (!*(void *)(*((void *)&v10 + 1) + 8) || (void)v9 == 0) {
      goto LABEL_10;
    }
LABEL_13:
    TStringRef::TStringRef((TStringRef *)a3, (const TStringRef *)&v8);
    goto LABEL_16;
  }
  if ((void)v9) {
    goto LABEL_13;
  }
LABEL_10:
  if (a2)
  {
    if ((*(unsigned int (**)(TTrueTypeFont *))(*(void *)this + 168))(this) <= a2)
    {
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(void *)a3 = &unk_1F0DD43A0;
      *(unsigned char *)(a3 + 24) = 0;
      *(void *)(a3 + 32) = &unk_1F0DD4218;
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 48) = 0;
      *(void *)(a3 + 56) = 0;
    }
    else
    {
      memset(__s1, 170, sizeof(__s1));
      snprintf_l(__s1, 0x10uLL, 0, "gid%d", a2);
      TStringRef::TStringRef<16ul>(a3, __s1);
    }
  }
  else
  {
    TStringRef::TStringRef<8ul>(a3, ".notdef");
  }
LABEL_16:
  TStringRef::~TStringRef((void **)&v8);
}

void sub_1B52F94A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TStringRef::~TStringRef((void **)va);
  _Unwind_Resume(a1);
}

uint64_t TStringRef::TStringRef<8ul>(uint64_t a1, char *__s1)
{
  long long v4 = strndup(__s1, 7uLL);
  size_t v5 = strnlen(__s1, 7uLL);
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(void *)a1 = &unk_1F0DD43A0;
  *(unsigned char *)(a1 + 24) = 1;
  *(void *)(a1 + 32) = &unk_1F0DD4218;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  return a1;
}

size_t TSFNTFont::GetPostScriptNameSuffixForVariation(TSFNTFont *a1, uint64_t *a2, char *a3, void *a4)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v75 = v8;
  long long v76 = v8;
  TSFNTFont::GetTable(a1, 1719034226, 0, &v75);
  if (!*((void *)&v75 + 1)) {
    goto LABEL_73;
  }
  uint64_t v9 = *(void *)(*((void *)&v75 + 1) + 8);
  if (!v9) {
    goto LABEL_73;
  }
  long long v10 = v76;
  long long v11 = (unsigned __int16 *)(v9 + v76);
  memcpy(__dst, &unk_1B53956E8, sizeof(__dst));
  unsigned int v12 = *(unsigned __int16 *)(v9 + v76 + 8);
  unsigned int v13 = __rev16(v12);
  if (v13 > 0x3F) {
    goto LABEL_73;
  }
  uint64_t v14 = bswap32(v11[2]) >> 16;
  if (*(_WORD *)(v9 + v76 + 8))
  {
    if (v13 <= 1) {
      uint64_t v15 = 1;
    }
    else {
      uint64_t v15 = v13;
    }
    uint64_t v16 = (double *)&__dst[2];
    uint64_t v17 = (unsigned int *)(v76 + v14 + v9 + 8);
    do
    {
      *((_DWORD *)v16 - 2) = bswap32(*(v17 - 2));
      unsigned int v18 = *v17;
      v17 += 5;
      *uint64_t v16 = (double)(int)bswap32(v18) * 0.0000152587891;
      v16 += 2;
      --v15;
    }
    while (v15);
  }
  unsigned int v19 = v11[5];
  unsigned int v20 = v11[6];
  unsigned int v21 = v11[7];
  uint64_t v22 = *a2;
  if (*a2)
  {
    uint64_t v23 = 0;
    char v24 = 0;
    uint64_t v25 = a2[1];
    if (v13 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = v13;
    }
    do
    {
      if (v12)
      {
        uint64_t v27 = 0;
        int v28 = &__dst[2];
        while (*(_DWORD *)(v25 + 16 * v23) != *(v28 - 2))
        {
          ++v27;
          v28 += 4;
          if (v26 == v27)
          {
            LOWORD(v27) = v26;
            goto LABEL_21;
          }
        }
        *(void *)int v28 = *(void *)(v25 + 16 * v23 + 8);
      }
      else
      {
        LOWORD(v27) = 0;
      }
LABEL_21:
      v24 |= v13 == (unsigned __int16)v27;
      ++v23;
    }
    while (v23 != v22);
    if (v24) {
      goto LABEL_73;
    }
  }
  else if (v13 <= 1)
  {
    uint64_t v26 = 1;
  }
  else
  {
    uint64_t v26 = v13;
  }
  uint64_t v29 = (char *)v11 + v14;
  if (!v20)
  {
LABEL_43:
    long long v107 = 0u;
    long long v108 = 0u;
    long long v105 = 0u;
    long long v106 = 0u;
    long long v103 = 0u;
    long long v104 = 0u;
    long long v101 = 0u;
    long long v102 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    long long v97 = 0u;
    long long v98 = 0u;
    long long v95 = 0u;
    long long v96 = 0u;
    long long v93 = 0u;
    long long v94 = 0u;
    long long v91 = 0u;
    long long v92 = 0u;
    long long v89 = 0u;
    long long v90 = 0u;
    long long v87 = 0u;
    long long v88 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    *(_OWORD *)__source = 0u;
    long long v78 = 0u;
    if (!v12) {
      goto LABEL_73;
    }
    uint64_t v48 = 0;
    unint64_t v49 = 0;
    while (1)
    {
      unsigned int v50 = 0;
      unint64_t v51 = __dst[4 * v48];
      unint64_t v52 = v49 + 1;
      __source[v49] = 95;
      do
      {
        if ((v51 - 805306368) >> 25 >= 5 && ((v51 & 0xDF000000) - 1090519040) >> 25 > 0xC)
        {
          long long v54 = &__source[v52];
          v54[1] = TSFNTFont::GetPostScriptNameSuffixForVariation(TVariationsRef const&,char *,std::unordered_map<unsigned short,TFontNameString> const*)const::nibbleToHex[(unint64_t)v51 >> 28];
          unint64_t v55 = v52 + 3;
          v54[2] = TSFNTFont::GetPostScriptNameSuffixForVariation(TVariationsRef const&,char *,std::unordered_map<unsigned short,TFontNameString> const*)const::nibbleToHex[(v51 >> 24) & 0xF];
          LOBYTE(v54) = 37;
        }
        else
        {
          LODWORD(v54) = BYTE3(v51);
          unint64_t v55 = v52 + 1;
        }
        __source[v52] = (char)v54;
        unint64_t v51 = (v51 << 8);
        unint64_t v52 = v55;
      }
      while (v50++ < 3);
      double v57 = *(double *)&__dst[4 * v48 + 2];
      double v58 = (double)(int)bswap32(*(_DWORD *)&v29[20 * v48 + 8]) * 0.0000152587891;
      double v59 = vabdd_f64(v57, v58);
      if (v59 < 0.0001) {
        goto LABEL_63;
      }
      double v60 = fabs(v57);
      double v61 = fabs(v58);
      if (v60 >= v61) {
        double v61 = v60;
      }
      if (v59 / v61 < 0.0001) {
        goto LABEL_63;
      }
      unsigned int v62 = vcvtd_n_s64_f64(v57, 0x10uLL);
      if (v62) {
        break;
      }
      unint64_t v49 = v55 + 1;
      __source[v55] = 48;
LABEL_64:
      if (v49 <= 0xFF && ++v48 != v26) {
        continue;
      }
      if (v49 - 1 <= 0xFE)
      {
        size_t v65 = strlcpy(a3, __source, 0x100uLL);
        goto LABEL_74;
      }
LABEL_73:
      size_t v65 = 0;
      goto LABEL_74;
    }
    if (v62 >> 28)
    {
      uint64_t v63 = 8;
      do
      {
LABEL_69:
        unint64_t v49 = v55 + 1;
        __source[v55] = TSFNTFont::GetPostScriptNameSuffixForVariation(TVariationsRef const&,char *,std::unordered_map<unsigned short,TFontNameString> const*)const::nibbleToHex[(unint64_t)v62 >> 28];
        v62 *= 16;
        ++v55;
        --v63;
      }
      while (v63);
      goto LABEL_64;
    }
    uint64_t v63 = 8;
    do
    {
      unsigned int v64 = HIBYTE(v62);
      v62 *= 16;
      --v63;
    }
    while (!v64);
    if (v63) {
      goto LABEL_69;
    }
LABEL_63:
    unint64_t v49 = v55;
    goto LABEL_64;
  }
  unsigned int v30 = bswap32(v19) >> 16;
  unsigned int v31 = __rev16(v20);
  unsigned int v32 = bswap32(v21);
  int v33 = (unsigned __int16 *)&v29[v30 * (unint64_t)v13];
  unint64_t v34 = v9 + *((void *)&v10 + 1);
  uint64_t v35 = HIWORD(v32);
  signed int v36 = a3 + 1;
  uint64_t v37 = v30 * (unint64_t)v13 + v14;
  unint64_t v38 = (unint64_t)v11 + v37 + 4;
  uint64_t v39 = v37 + v10 + v9 + 8;
  while (1)
  {
    if (v12)
    {
      if (v38 < (unint64_t)v11) {
        goto LABEL_86;
      }
      uint64_t v40 = 0;
      signed int v41 = (double *)&__dst[2];
      unint64_t v42 = v39;
      while (1)
      {
        if (v42 > v34) {
          goto LABEL_86;
        }
        double v43 = (double)(int)bswap32(*(_DWORD *)(v42 - 4)) * 0.0000152587891;
        double v44 = vabdd_f64(*v41, v43);
        if (v44 >= 0.0001)
        {
          double v45 = fabs(*v41);
          double v46 = fabs(v43);
          if (v45 < v46) {
            double v45 = v46;
          }
          if (v44 / v45 >= 0.0001) {
            break;
          }
        }
        --v40;
        v42 += 4;
        v41 += 2;
        if (-v26 == v40)
        {
          LOWORD(v47) = v26;
          goto LABEL_41;
        }
      }
      int v47 = -(int)v40;
    }
    else
    {
      LOWORD(v47) = 0;
    }
LABEL_41:
    if (v13 == (unsigned __int16)v47) {
      break;
    }
    --v31;
    int v33 = (unsigned __int16 *)((char *)v33 + v35);
    v38 += v35;
    v39 += v35;
    if (!(_WORD)v31) {
      goto LABEL_43;
    }
  }
  if (v11 > v33 || (unint64_t)(v33 + 1) > v34)
  {
LABEL_86:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  *(void *)&long long v67 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v67 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v81 = v67;
  long long v82 = v67;
  long long v79 = v67;
  long long v80 = v67;
  *(_OWORD *)__source = v67;
  long long v78 = v67;
  TFont::GetNameUsingMap((uint64_t)a1, bswap32(*v33) >> 16, a4, (TFontNameString *)__source);
  *a3 = 95;
  *(void *)&long long v68 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v68 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v110[2] = v68;
  v110[3] = v68;
  v110[0] = v68;
  v110[1] = v68;
  unsigned int v111 = 0;
  unsigned int v112 = (unsigned __int8 *)v110;
  unint64_t v113 = 0;
  TPostScriptNameString::operator=((uint64_t)v110, (TFontNameString *)__source);
  if (v113 >= 0xFE) {
    uint64_t v69 = 254;
  }
  else {
    uint64_t v69 = v113;
  }
  if (v69)
  {
    uint64_t v70 = v112;
    int v71 = &v112[v69];
    do
    {
      int v73 = *v70++;
      char v72 = v73;
      if (v73 == 32) {
        char v72 = 45;
      }
      *v36++ = v72;
    }
    while (v70 < v71);
  }
  char *v36 = 0;
  free(v111);
  TFontNameString::~TFontNameString((TFontNameString *)__source);
  size_t v65 = v69 + 1;
LABEL_74:
  TDataReference::~TDataReference((TDataReference *)&v75);
  return v65;
}

void sub_1B52F9B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void TSBITDataForkFont::~TSBITDataForkFont(TSBITDataForkFont *this)
{
  *(void *)this = &unk_1F0DD7250;
  *((void *)this + 2) = &unk_1F0DD7458;
  TSFNTFont::~TSFNTFont((TSBITDataForkFont *)((char *)this + 224));
  *(void *)this = &unk_1F0DD7478;
  *((void *)this + 2) = &unk_1F0DD7680;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 25);
  TSFNTFont::~TSFNTFont(this);
}

{
  uint64_t vars8;

  TSBITDataForkFont::~TSBITDataForkFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TSBITDataForkFont::~TSBITDataForkFont(TSBITDataForkFont *this)
{
}

{
  uint64_t vars8;

  TSBITDataForkFont::~TSBITDataForkFont((TSBITDataForkFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

__n128 TSBITDataForkFont::GetHorizontalMetrics(TSBITDataForkFont *this, int *a2, int *a3, int *a4, int *a5, int *a6, int *a7, int *a8, int *a9, int *a10, BOOL *a11, BOOL *a12, double *a13, int *a14, int *a15, double *a16, double *a17, double *a18, double *a19, __int16 *a20,__int16 *a21)
{
  TSBITFont::GetHorizontalMetrics((TSBITDataForkFont *)((char *)this + 224), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
    a20,
    a21);
  return result;
}

uint64_t TSBITDataForkFont::GetAscent(TSBITDataForkFont *this)
{
  return *((__int16 *)this + 224);
}

uint64_t TSBITDataForkFont::GetDescent(TSBITDataForkFont *this)
{
  return *((__int16 *)this + 225);
}

uint64_t TSBITDataForkFont::GetLineGap(TSBITDataForkFont *this)
{
  return *((__int16 *)this + 226);
}

uint64_t TSBITDataForkFont::GetMaxAdvance(TSBITDataForkFont *this)
{
  return *((unsigned __int16 *)this + 227);
}

uint64_t TSBITDataForkFont::GetAvgAdvance(TSBITDataForkFont *this)
{
  return TSBITFont::GetAvgAdvance((TSBITDataForkFont *)((char *)this + 224));
}

uint64_t TSBITDataForkFont::GetStemH(TSBITDataForkFont *this)
{
  return (int)*((double *)this + 55);
}

uint64_t TSBITDataForkFont::GetStemV(TSBITDataForkFont *this)
{
  return (int)*((double *)this + 54);
}

_WORD *TSBITDataForkFont::GetCaretInfo(_WORD *this, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  *a2 = this[228];
  *a3 = this[229];
  *a4 = this[230];
  return this;
}

void TSBITDataForkFont::GetBounds(TSBITDataForkFont *this, double *a2, double *a3, double *a4, double *a5)
{
}

void TSBITWOFFFont::TSBITWOFFFont(TSBITWOFFFont *this, const __CFData *a2)
{
}

void sub_1B52F9DCC(_Unwind_Exception *a1)
{
  TTrueTypeWOFFFont::~TTrueTypeWOFFFont(v1);
  _Unwind_Resume(a1);
}

void TSBITWOFFFont::~TSBITWOFFFont(TSBITWOFFFont *this)
{
  *(void *)this = &unk_1F0DFE910;
  *((void *)this + 2) = &unk_1F0DFEB18;
  TSFNTFont::~TSFNTFont((TSBITWOFFFont *)((char *)this + 256));
  *(void *)this = &unk_1F0DFE6E8;
  *((void *)this + 2) = &unk_1F0DFE8F0;
  TCFData::~TCFData((const void **)this + 31);
  TTrueTypeMemoryFont::~TTrueTypeMemoryFont(this);
}

{
  uint64_t vars8;

  TSBITWOFFFont::~TSBITWOFFFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TSBITWOFFFont::~TSBITWOFFFont(TSBITWOFFFont *this)
{
}

{
  uint64_t vars8;

  TSBITWOFFFont::~TSBITWOFFFont((TSBITWOFFFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

__n128 TSBITWOFFFont::GetHorizontalMetrics(TSBITWOFFFont *this, int *a2, int *a3, int *a4, int *a5, int *a6, int *a7, int *a8, int *a9, int *a10, BOOL *a11, BOOL *a12, double *a13, int *a14, int *a15, double *a16, double *a17, double *a18, double *a19, __int16 *a20,__int16 *a21)
{
  TSBITFont::GetHorizontalMetrics((TSBITWOFFFont *)((char *)this + 256), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
    a20,
    a21);
  return result;
}

uint64_t TSBITWOFFFont::GetAscent(TSBITWOFFFont *this)
{
  return *((__int16 *)this + 240);
}

uint64_t TSBITWOFFFont::GetDescent(TSBITWOFFFont *this)
{
  return *((__int16 *)this + 241);
}

uint64_t TSBITWOFFFont::GetLineGap(TSBITWOFFFont *this)
{
  return *((__int16 *)this + 242);
}

uint64_t TSBITWOFFFont::GetMaxAdvance(TSBITWOFFFont *this)
{
  return *((unsigned __int16 *)this + 243);
}

uint64_t TSBITWOFFFont::GetAvgAdvance(TSBITWOFFFont *this)
{
  return TSBITFont::GetAvgAdvance((TSBITWOFFFont *)((char *)this + 256));
}

uint64_t TSBITWOFFFont::GetStemH(TSBITWOFFFont *this)
{
  return (int)*((double *)this + 59);
}

uint64_t TSBITWOFFFont::GetStemV(TSBITWOFFFont *this)
{
  return (int)*((double *)this + 58);
}

_WORD *TSBITWOFFFont::GetCaretInfo(_WORD *this, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  *a2 = this[244];
  *a3 = this[245];
  *a4 = this[246];
  return this;
}

void TSBITWOFFFont::GetBounds(TSBITWOFFFont *this, double *a2, double *a3, double *a4, double *a5)
{
}

void TSBITMemoryFont::TSBITMemoryFont(TSFNTFont *a1, uint64_t a2)
{
}

void sub_1B52FA030(_Unwind_Exception *a1)
{
  TTrueTypeMemoryFont::~TTrueTypeMemoryFont(v1);
  _Unwind_Resume(a1);
}

void TSBITMemoryFont::~TSBITMemoryFont(TSBITMemoryFont *this)
{
  *(void *)this = &unk_1F0DFEB38;
  *((void *)this + 2) = &unk_1F0DFED40;
  TSFNTFont::~TSFNTFont((TSBITMemoryFont *)((char *)this + 248));
  TTrueTypeMemoryFont::~TTrueTypeMemoryFont(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F0DFEB38;
  *((void *)this + 2) = &unk_1F0DFED40;
  TSFNTFont::~TSFNTFont((TSBITMemoryFont *)((char *)this + 248));
  TTrueTypeMemoryFont::~TTrueTypeMemoryFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TSBITMemoryFont::~TSBITMemoryFont(TSBITMemoryFont *this)
{
  uint64_t v1 = (TSBITMemoryFont *)((char *)this - 16);
  *((void *)this - 2) = &unk_1F0DFEB38;
  *(void *)this = &unk_1F0DFED40;
  TSFNTFont::~TSFNTFont((TSBITMemoryFont *)((char *)this + 232));
  TTrueTypeMemoryFont::~TTrueTypeMemoryFont(v1);
}

{
  TSBITMemoryFont::~TSBITMemoryFont((TSBITMemoryFont *)((char *)this - 16));
}

__n128 TSBITMemoryFont::GetHorizontalMetrics(TSBITMemoryFont *this, int *a2, int *a3, int *a4, int *a5, int *a6, int *a7, int *a8, int *a9, int *a10, BOOL *a11, BOOL *a12, double *a13, int *a14, int *a15, double *a16, double *a17, double *a18, double *a19, __int16 *a20,__int16 *a21)
{
  TSBITFont::GetHorizontalMetrics((TSBITMemoryFont *)((char *)this + 248), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
    a20,
    a21);
  return result;
}

uint64_t TSBITMemoryFont::GetAscent(TSBITMemoryFont *this)
{
  return *((__int16 *)this + 236);
}

uint64_t TSBITMemoryFont::GetDescent(TSBITMemoryFont *this)
{
  return *((__int16 *)this + 237);
}

uint64_t TSBITMemoryFont::GetLineGap(TSBITMemoryFont *this)
{
  return *((__int16 *)this + 238);
}

uint64_t TSBITMemoryFont::GetMaxAdvance(TSBITMemoryFont *this)
{
  return *((unsigned __int16 *)this + 239);
}

uint64_t TSBITMemoryFont::GetAvgAdvance(TSBITMemoryFont *this)
{
  return TSBITFont::GetAvgAdvance((TSBITMemoryFont *)((char *)this + 248));
}

uint64_t TSBITMemoryFont::GetStemH(TSBITMemoryFont *this)
{
  return (int)*((double *)this + 58);
}

uint64_t TSBITMemoryFont::GetStemV(TSBITMemoryFont *this)
{
  return (int)*((double *)this + 57);
}

_WORD *TSBITMemoryFont::GetCaretInfo(_WORD *this, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  *a2 = this[240];
  *a3 = this[241];
  *a4 = this[242];
  return this;
}

void TSBITMemoryFont::GetBounds(TSBITMemoryFont *this, double *a2, double *a3, double *a4, double *a5)
{
}

void TCFData::~TCFData(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

uint32x2_t ComputeQDMetrics(uint64_t a1, uint64_t a2, int32x2_t *a3)
{
  long long v3 = a3;
  signed int v66 = *(_DWORD *)a2;
  unint64_t v6 = (unint64_t)&a3[132];
  uint64_t v7 = a3 + 132;
  memmove(&a3[132], (const void *)(a2 + 276), 0x200uLL);
  v3[2].i32[0] = *(unsigned __int8 *)(a2 + 273);
  long long v8 = v3 + 4;
  __int16 v9 = *(_WORD *)(*(void *)(a1 + 8) + 130);
  uint64_t v10 = *(void *)(a1 + 24);
  if (!*(unsigned char *)(v10 + 490)) {
    goto LABEL_4;
  }
  __int16 v11 = *(_WORD *)(a2 + 274);
  if ((v11 & 1) == 0)
  {
LABEL_27:
    unint64_t v83 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v41 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v82[1] = v41;
    long long v82[2] = v41;
    v82[0] = v41;
    memset(v81, 170, sizeof(v81));
    unint64_t v80 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v78 = 0xAAAAAAAAAAAAAAAALL;
    long long v76 = v41;
    long long v77 = v41;
    long long v74 = v41;
    long long v75 = v41;
    long long v72 = v41;
    long long v73 = v41;
    *(_OWORD *)uint64_t v70 = v41;
    long long v71 = v41;
    uint64_t v42 = *(void *)(v10 + 80);
    *(_OWORD *)&v69[12] = v41;
    long long v68 = v41;
    *(_OWORD *)uint64_t v69 = v41;
    double v43 = (long long *)(v10 + 96);
    *(_OWORD *)long long v67 = v41;
    if (v43 != (long long *)v42)
    {
      long long v44 = *v43;
      long long v45 = v43[1];
      *(_DWORD *)(v42 + 32) = *((_DWORD *)v43 + 8);
      *(_OWORD *)uint64_t v42 = v44;
      *(_OWORD *)(v42 + 16) = v45;
    }
    if (!sbit_FontMatch(*(memoryContext **)a1, a1, (uint64_t)v67, 1, 0)) {
      *(_WORD *)(*(void *)(a1 + 24) + 489) = 0;
    }
    int v65 = M3x3Flags((_DWORD *)v42);
    BOOL v46 = *(_DWORD *)(v42 + 36) == 1 && *(_DWORD *)(v42 + 40) == 1;
    int v47 = -HIDWORD(v67[1]);
    v3->i32[0] = HIDWORD(v67[0]);
    v3->i32[1] = v47;
    __int32 v48 = *(_DWORD *)v69;
    v3[1].i32[0] = *(_DWORD *)&v69[12];
    v3[1].i32[1] = v48;
    *(void *)(a1 + 32) = v70;
    int v79 = v3[132].u16[0];
    if (!sbit_IsThereAGlyphImage(a1, &v79)) {
      *(unsigned char *)(*(void *)(a1 + 24) + 490) = 0;
    }
    char Metrics = sbit_GetMetrics(v82, v81, (int *)&v80, a1, v79, (v11 & 0x100) == 0);
    unsigned int v64 = v3;
    if (v66)
    {
      if (!Metrics)
      {
        signed int v66 = vcvtd_n_s64_f64((double)v66 * 0.0000152587891 / ((double)*(int *)&v69[16] * 0.0000152587891), 0x10uLL);
        if ((v11 & 0x100) == 0) {
          signed int v66 = (v66 + 0x8000) & 0xFFFF0000;
        }
      }
    }
    unsigned int v50 = v3 + 4;
    do
    {
      int v51 = v7->u16[0];
      uint64_t v7 = (int32x2_t *)((char *)v7 + 2);
      int v79 = v51;
      if (!sbit_IsThereAGlyphImage(a1, &v79)) {
        *(unsigned char *)(*(void *)(a1 + 24) + 490) = 0;
      }
      char v52 = sbit_GetMetrics(v82, v81, (int *)&v80, a1, v79, (v11 & 0x100) == 0);
      if (v46) {
        M3x3Mul((int *)v42, v65, v81, (const int *)1);
      }
      unsigned __int32 v53 = v81[0].i32[0];
      if ((v11 & 0x100) == 0) {
        unsigned __int32 v53 = (v81[0].i32[0] + 0x8000) & 0xFFFF0000;
      }
      v50->i32[0] = v53 + v66;
      unsigned int v50 = (int32x2_t *)((char *)v50 + 4);
    }
    while ((unint64_t)v50 < v6);
    *(void *)(a1 + 32) = 0;
    if (v52) {
      int v54 = 1;
    }
    else {
      int v54 = v46;
    }
    int v55 = *(_DWORD *)&v69[16];
    if (v54)
    {
      int v55 = 0x10000;
      int v56 = 0x10000;
    }
    else
    {
      int v56 = *(_DWORD *)&v69[20];
    }
    __int32 v57 = *(_DWORD *)&v69[24];
    long long v3 = v64;
    v64[3].i32[0] = v56;
    v64[3].i32[1] = v57;
    v64[2].i32[0] |= 0x80000000;
    v64[2].i32[1] = v55;
    goto LABEL_55;
  }
  unsigned int v12 = *(memoryContext **)a1;
  LODWORD(v70[0]) = 0;
  TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)v12 + 16), 1752003704, (unsigned int *)v70);
  if (!LODWORD(v70[0]))
  {
    __int16 v11 = *(_WORD *)(a2 + 274);
    uint64_t v10 = *(void *)(a1 + 24);
    goto LABEL_27;
  }
LABEL_4:
  v67[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  ScalerGetFontTable(*(memoryContext **)a1, 1752003704, 0, v67, 0, 4);
  int v13 = 0;
  uint64_t v14 = *(void *)(a1 + 8);
  unsigned int v15 = *(unsigned __int16 *)(v14 + 146);
  int v16 = *(_DWORD *)(*(void *)(a1 + 24) + 96);
  if (v15 < *(unsigned __int16 *)(v14 + 40)) {
    int v13 = *(_DWORD *)a2
  }
        + (int)((double)v16 * (double)((int)bswap32(*((unsigned __int16 *)v67[0] + 2 * v15 - 2)) >> 16) / (double)v9);
  if ((*(_WORD *)(a2 + 274) & 0x100) != 0)
  {
    uint64_t v26 = (unsigned __int16 *)v67[0];
    double v27 = (double)v9;
    unsigned int v32 = v3 + 4;
    do
    {
      unsigned int v34 = v7->u16[0];
      uint64_t v7 = (int32x2_t *)((char *)v7 + 2);
      uint64_t v33 = v34;
      int v35 = v13;
      if (v34 < v15) {
        int v35 = v66 + (int)((double)v16 * (double)((int)bswap32(v26[2 * v33]) >> 16) / v27);
      }
      v32->i32[0] = v35;
      unsigned int v32 = (int32x2_t *)((char *)v32 + 4);
    }
    while ((unint64_t)v32 < v6);
  }
  else
  {
    uint64_t v63 = v3;
    int v17 = v66 + 0x8000;
    if (v16 < 16678912)
    {
      unsigned int v18 = *(memoryContext **)a1;
      v70[0] = (void *)0xAAAAAAAAAAAAAAAALL;
      ScalerGetFontTable(v18, 1751412088, 0, v70, 1, 0);
      unsigned int v19 = v70[0];
      if (v70[0])
      {
        int v20 = (int)bswap32(*((unsigned __int16 *)v70[0] + 1)) >> 16;
        if (v20 >= 1)
        {
          int v21 = (v16 + 0x8000) >> 16;
          uint64_t v22 = bswap32(*((_DWORD *)v70[0] + 1));
          unsigned int v23 = (unsigned __int16)v20 + 1;
          char v24 = (char *)v70[0] + 10;
          do
          {
            int v25 = *(v24 - 2);
            if (v21 < v25) {
              break;
            }
            if (v21 == v25)
            {
              for (uint64_t i = 0; i != 256; ++i)
              {
                double v61 = (unsigned int *)(v6 + 4 * i - 1024);
                unsigned int v62 = (v17 + (v24[v7->u16[i]] << 16)) & 0xFFFF0000;
                *double v61 = v62;
              }
              ScalerReleaseFontTable(v18, v19);
              uint64_t v26 = (unsigned __int16 *)v67[0];
              double v27 = (double)v9;
              goto LABEL_20;
            }
            --v23;
            v24 += v22;
          }
          while (v23 > 1);
        }
        ScalerReleaseFontTable(v18, v70[0]);
      }
    }
    uint64_t v26 = (unsigned __int16 *)v67[0];
    double v27 = (double)v9;
    int v28 = (unsigned int *)v8;
    do
    {
      unsigned int v30 = v7->u16[0];
      uint64_t v7 = (int32x2_t *)((char *)v7 + 2);
      uint64_t v29 = v30;
      int v31 = v13 + 0x8000;
      if (v30 < v15) {
        int v31 = v17 + (int)((double)v16 * (double)((int)bswap32(v26[2 * v29]) >> 16) / v27);
      }
      *v28++ = v31 & 0xFFFF0000;
    }
    while ((unint64_t)v28 < v6);
    v66 += 0x8000;
LABEL_20:
    long long v3 = v63;
  }
  ScalerReleaseFontTable(*(memoryContext **)a1, v26);
  signed int v36 = *(memoryContext **)a1;
  uint64_t v37 = *(void *)(a1 + 24);
  v70[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  ScalerGetFontTable(v36, 1751672161, 0, v70, 0, 36);
  int v38 = *(_DWORD *)(v37 + 96);
  uint64_t v39 = (unsigned __int16 *)v70[0];
  double v40 = (double)*(int *)(v37 + 112);
  v3->i32[0] = ((int)(v40 * (double)((int)bswap32(*((unsigned __int16 *)v70[0] + 2)) >> 16) / v27) + 0x8000) & 0xFFFF0000;
  v3->i32[1] = -(((int)(v40 * (double)((int)bswap32(v39[3]) >> 16) / v27) + 0x8000) & 0xFFFF0000);
  v3[1].i32[0] = ((int)(v40 * (double)((int)bswap32(v39[4]) >> 16) / v27) + 0x8000) & 0xFFFF0000;
  v3[1].i32[1] = ((int)((double)v38 * (double)(bswap32(v39[5]) >> 16) / v27) + 0xFFFF) & 0xFFFF0000;
  ScalerReleaseFontTable(v36, v39);
LABEL_55:
  if (v66 < 0)
  {
    do
    {
      if (v8->i32[0] < 0) {
        v8->i32[0] = 0;
      }
      long long v8 = (int32x2_t *)((char *)v8 + 4);
    }
    while ((unint64_t)v8 < v6);
  }
  uint64_t v58 = *(void *)(a1 + 24);
  uint32x2_t result = vshr_n_u32((uint32x2_t)vadd_s32(*v3, (int32x2_t)0x800000008000), 0x10uLL);
  *(_WORD *)(v58 + 494) = result.i16[2];
  *(_WORD *)(v58 + 492) = result.i16[0];
  return result;
}

void TType1OTFCIDFont::~TType1OTFCIDFont(TType1OTFCIDFont *this)
{
  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x1BA9994D0);
}

uint64_t TType1OTFCIDFont::GetFontDataTableTag(TType1OTFCIDFont *this)
{
  return 1128678944;
}

void TType1OTFCIDFont::GetAltGlyphMetricsParametres(TType1OTFCIDFont *this, unsigned __int16 *a2, int *a3, int *a4, int *a5, int *a6, int *a7, int *a8, int *a9, int *a10, int *a11)
{
  int v16 = (unsigned __int16 *)*((void *)this + 4);
  unsigned int v17 = v16[180];
  unsigned int v18 = *a2;
  unsigned int v19 = (*(uint64_t (**)(unsigned __int16 *))(*(void *)v16 + 168))(v16);
  if (v19 >= 0xFFFF) {
    unsigned int v20 = 0xFFFF;
  }
  else {
    unsigned int v20 = v19;
  }
  if (v18 >= v20
    && (*(unsigned int (**)(void, void))(**((void **)this + 4) + 560))(*((void *)this + 4), *a2) >= v17)
  {
    *a2 = 0;
  }
  *a6 = 0;
  *a4 = 0;
  *a11 = 2097152001;
  *a10 = 2097152001;
  *a9 = 2097152001;
  *a8 = 2097152001;
  *a7 = 2097152001;
  *a5 = 2097152001;
  *a3 = 2097152001;
  int v21 = (const TFontObjectSurrogate *)(*(uint64_t (**)(TType1OTFCIDFont *))(*(void *)this + 216))(this);
  uint64_t v22 = *a2;
  unint64_t v51 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v50[1] = v23;
  _OWORD v50[2] = v23;
  v50[0] = v23;
  TFontObjectTable::TFontObjectTable((TFontObjectTable *)v50, v21, 1751672161);
  if (LODWORD(v50[0]) <= 0x23)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  unint64_t v49 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v47 = v24;
  long long v48 = v24;
  long long v46 = v24;
  TFontObjectTable::TFontObjectTable((TFontObjectTable *)&v46, v21, 1448038983);
  unsigned int v25 = bswap32(*(unsigned __int16 *)(*((void *)&v48 + 1) + 4)) >> 16;
  unsigned int v26 = bswap32(*(unsigned __int16 *)(*((void *)&v48 + 1) + 6)) >> 16;
  unint64_t v27 = *((void *)&v48 + 1) + 12;
  while (1)
  {
    unsigned int v26 = (unsigned __int16)v26 + 0xFFFF;
    if ((v26 & 0x10000) == 0 || v27 > *((void *)&v48 + 1) + (unint64_t)DWORD1(v46)) {
      break;
    }
    unsigned int v28 = bswap32(*(unsigned __int16 *)(v27 - 4));
    v27 += 4;
    if (v22 == HIWORD(v28))
    {
      unsigned int v25 = bswap32(*(unsigned __int16 *)(v27 - 6)) >> 16;
      break;
    }
  }
  TDataReference::~TDataReference((TDataReference *)((char *)&v46 + 8));
  unint64_t v49 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v29 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v47 = v29;
  long long v48 = v29;
  long long v46 = v29;
  TFontObjectTable::TFontObjectTable((TFontObjectTable *)&v46, v21, 1986553185);
  if (v46 <= 0x23)
  {
    int v38 = __cxa_allocate_exception(0x10uLL);
    *(void *)int v38 = &unk_1F0DFC400;
    v38[4] = 5;
  }
  unsigned int v30 = *(unsigned __int16 *)(*((void *)&v48 + 1) + 6);
  unsigned int v31 = *(unsigned __int16 *)(*((void *)&v48 + 1) + 34);
  unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v43[1] = v32;
  long long v44 = v32;
  v43[0] = v32;
  TFontObjectTable::TFontObjectTable((TFontObjectTable *)v43, v21, 1986884728);
  unsigned int v33 = __rev16(v31);
  if (v33 > (unsigned __int16)(LODWORD(v43[0]) >> 2)) {
    LOWORD(v33) = LODWORD(v43[0]) >> 2;
  }
  if (v22 >= (unsigned __int16)v33) {
    uint64_t v34 = (unsigned __int16)v33 - 1;
  }
  else {
    uint64_t v34 = v22;
  }
  if (v34 < 0
    || (int v35 = (unsigned __int16 *)(*((void *)&v44 + 1) + 4 * v34),
        (unint64_t)(v35 + 2) > *((void *)&v44 + 1) + (unint64_t)LODWORD(v43[0])))
  {
    uint64_t v39 = __cxa_allocate_exception(0x10uLL);
    *(void *)uint64_t v39 = &unk_1F0DFC400;
    v39[4] = 5;
  }
  unsigned int v36 = bswap32(*v35) >> 16;
  TDataReference::~TDataReference((TDataReference *)((char *)v43 + 8));
  TDataReference::~TDataReference((TDataReference *)((char *)&v46 + 8));
  *a8 = v25 << 16;
  *a7 = -65536 * (bswap32(v30) >> 16);
  *a11 = -65536 * v36;
  TDataReference::~TDataReference((TDataReference *)((char *)v50 + 8));
  *a5 = *a11;
}

void sub_1B52FAE2C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,long long a21)
{
  TDataReference::~TDataReference((TDataReference *)&a14);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1B52FACD8);
  }
  TDataReference::~TDataReference((TDataReference *)((char *)&a21 + 8));
  TDataReference::~TDataReference((TDataReference *)((v21 - 144) | 8));
  _Unwind_Resume(a1);
}

void sub_1B52FAF90()
{
  TDataReference::~TDataReference((TDataReference *)((v0 - 144) | 8));
  JUMPOUT(0x1B52FB014);
}

void sub_1B52FB00C()
{
}

uint64_t TType1OTFCIDFont::GetPSStreamType(TType1OTFCIDFont *this, int a2)
{
  if ((a2 & 0x100) != 0) {
    return a2 & 0xFFFFF000 | 0x100;
  }
  else {
    return TType1CIDFont::GetPSStreamType(this, a2);
  }
}

void TT2T1CIDConvertingBufferedStreamingContext::~TT2T1CIDConvertingBufferedStreamingContext(TT2T1CIDConvertingBufferedStreamingContext *this)
{
  *(void *)this = &unk_1F0DFEF60;
  uint64_t v2 = (void **)((char *)this + 696);
  std::vector<CompFDInfo>::__destroy_vector::operator()[abi:fe180100](&v2);
  TBufferedCharStringStreamingContext::~TBufferedCharStringStreamingContext(this);
}

{
  void **v2;

  *(void *)this = &unk_1F0DFEF60;
  uint64_t v2 = (void **)((char *)this + 696);
  std::vector<CompFDInfo>::__destroy_vector::operator()[abi:fe180100](&v2);
  TBufferedCharStringStreamingContext::~TBufferedCharStringStreamingContext(this);
  MEMORY[0x1BA9994D0]();
}

void TT2T1CIDConvertingBufferedStreamingContext::StreamCharString(TT2T1CIDConvertingBufferedStreamingContext *this, const TType1SFNTFont *a2, uint64_t a3, const unsigned __int8 *a4, int *a5)
{
  __b[499] = *MEMORY[0x1E4F143B8];
  memset(__b, 170, 0xF98uLL);
  TType2ToType1CharStringConvertionContext::TType2ToType1CharStringConvertionContext((TType2ToType1CharStringConvertionContext *)__b, a2);
  __b[0] = &unk_1F0DFEFB8;
  __b[38] = &unk_1F0DFEFF0;
  __b[491] = 0;
  LOBYTE(__b[497]) = a3 == 0;
  __b[498] = 0;
  unsigned int v23 = -1431655766;
  unsigned int v24 = -1431655766;
  WORD1(__b[497]) = (*(uint64_t (**)(const TType1SFNTFont *, uint64_t, unsigned int *, unsigned int *))(*(void *)a2 + 336))(a2, a3, &v24, &v23);
  uint64_t v10 = (*(uint64_t (**)(const TType1SFNTFont *))(*(void *)a2 + 312))(a2);
  LODWORD(__b[277]) = *(unsigned __int16 *)(v10 + 70);
  HIDWORD(__b[471]) = *(_DWORD *)(v10 + 440);
  LODWORD(__b[472]) = *(_DWORD *)(v10 + 120);
  __int16 v11 = WORD1(__b[497]);
  uint64_t v12 = *((void *)a2 + 4);
  unsigned int v13 = *(unsigned __int16 *)(*(void *)(v12 + 400) + 488 * SWORD1(__b[497]) + 4);
  if (v13 >= 0x8408) {
    __int16 v14 = 0x8000;
  }
  else {
    __int16 v14 = 1131;
  }
  if (v13 < 0x4D8) {
    __int16 v14 = 107;
  }
  WORD2(__b[488]) = v14;
  unsigned int v15 = *(unsigned __int16 *)(v12 + 318);
  if (v15 >= 0x846C) {
    __int16 v16 = 0x8000;
  }
  else {
    __int16 v16 = 1131;
  }
  if (v15 >= 0x4D8) {
    __int16 v17 = v16;
  }
  else {
    __int16 v17 = 107;
  }
  HIWORD(__b[488]) = v17;
  LOWORD(__b[489]) = v15;
  if (a3)
  {
    int v18 = (*(uint64_t (**)(const TType1SFNTFont *, uint64_t, uint64_t, char *))(*(void *)a2 + 184))(a2, a3, 127, (char *)&__b[472] + 5);
    BYTE4(__b[472]) = 47;
    __b[33] = (char *)&__b[472] + 4;
    __b[34] = (v18 + 1);
    LOBYTE(__b[497]) = 0;
    __int16 v11 = WORD1(__b[497]);
  }
  (*(void (**)(uint64_t *__return_ptr, const TType1SFNTFont *, void, void, void))(*(void *)a2 + 352))(&v22, a2, v11, v24, v23);
  uint64_t v19 = v22;
  uint64_t v22 = 0;
  uint64_t v20 = __b[498];
  __b[498] = v19;
  if (v20)
  {
    MEMORY[0x1BA9994A0](v20, 0x1000C8077774924);
    uint64_t v21 = v22;
    uint64_t v22 = 0;
    if (v21) {
      MEMORY[0x1BA9994A0](v21, 0x1000C8077774924);
    }
  }
  __b[41] = __b[498];
  __b[42] = __b[498];
  __b[40] = __b[498] + v23;
  LODWORD(__b[37]) = malloc_good_size(4 * v23);
  __b[35] = AllocateMemory(LODWORD(__b[37]), 0);
  __b[36] = 0;
  LOBYTE(v22) = 0;
  TType2ToType1CharStringConvertionContext::ConvertT2ToT1CharString((uint64_t)__b, 0, (BOOL *)&v22);
  (*(void (**)(TT2T1CIDConvertingBufferedStreamingContext *, void *, const unsigned __int8 *, int *))(*(void *)this + 64))(this, __b, a4, a5);
  TType2CIDToType1CharStringConvertionContext::~TType2CIDToType1CharStringConvertionContext((TType2CIDToType1CharStringConvertionContext *)__b);
}

void sub_1B52FB488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TType2CIDToType1CharStringConvertionContext::~TType2CIDToType1CharStringConvertionContext((TType2CIDToType1CharStringConvertionContext *)va);
  _Unwind_Resume(a1);
}

uint64_t TT2T1CIDConvertingBufferedStreamingContext::DoCharString(TBufferedCharStringStreamingContext *this, uint64_t a2, char *__src, uint64_t a4)
{
  long long v8 = (char *)this + 136;
  uint64_t v9 = a2 + 3780;
  char v10 = 1;
  do
  {
    char v11 = v10;
    *((void *)this + 67) = a4;
    __int16 v12 = *((_WORD *)this + 260);
    if ((*((__int16 *)this + 261) & 0x80000000) == 0) {
      std::vector<unsigned char>::__insert_with_size[abi:fe180100]<unsigned char const*,unsigned char const*>((uint64_t)v8, *((char **)this + 18), __src, &__src[*((unsigned __int16 *)this + 261)], *((unsigned __int16 *)this + 261));
    }
    TBufferedCharStringStreamingContext::ProcessCharString((uint64_t)this, *(const unsigned __int8 **)(a2 + 280), *(_DWORD *)(a2 + 288), 0);
    TBufferedCharStringStreamingContext::StreamCharHeader((uint64_t)this, a2, *((_DWORD *)this + 36) - *((_DWORD *)this + 34));
    std::vector<unsigned char>::__insert_with_size[abi:fe180100]<unsigned char const*,unsigned char const*>((uint64_t)v8, *((char **)this + 18), " ND\r", "", 4);
    *((_WORD *)this + 260) = v12;
    uint64_t result = TBufferedCharStringStreamingContext::BufferCharBuffer((uint64_t)this);
    if (!*(unsigned char *)(a2 + 3976)) {
      break;
    }
    char v10 = 0;
    *(_WORD *)(a2 + 3780) = 26415;
    *(unsigned char *)(a2 + 3782) = 48;
    *(void *)(a2 + 264) = v9;
    *(void *)(a2 + 272) = 3;
  }
  while ((v11 & 1) != 0);
  return result;
}

void TType2CIDToType1CharStringConvertionContext::~TType2CIDToType1CharStringConvertionContext(TType2CIDToType1CharStringConvertionContext *this)
{
  *(void *)this = &unk_1F0DFEFB8;
  *((void *)this + 38) = &unk_1F0DFEFF0;
  uint64_t v2 = *((void *)this + 498);
  *((void *)this + 498) = 0;
  if (v2) {
    MEMORY[0x1BA9994A0](v2, 0x1000C8077774924);
  }
  *(void *)this = off_1F0DFD8F8;
  *((void *)this + 38) = &unk_1F0DFD930;
  free(*((void **)this + 35));
}

{
  uint64_t vars8;

  TType2CIDToType1CharStringConvertionContext::~TType2CIDToType1CharStringConvertionContext(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TType2CIDToType1CharStringConvertionContext::~TType2CIDToType1CharStringConvertionContext(TType2CIDToType1CharStringConvertionContext *this)
{
}

{
  uint64_t vars8;

  TType2CIDToType1CharStringConvertionContext::~TType2CIDToType1CharStringConvertionContext((TType2CIDToType1CharStringConvertionContext *)((char *)this - 304));
  JUMPOUT(0x1BA9994D0);
}

__n128 TType2CIDToType1CharStringConvertionContext::FlattenSubr(__n128 *this, unsigned int a2, BOOL *a3)
{
  unint64_t v6 = this[245].n128_u64[1];
  if (!v6)
  {
    unint64_t v6 = (*(uint64_t (**)(unint64_t, void, __int8 *, __int8 *, __n128 *, __n128 *, __int8 *, __n128 *))(*(void *)this[19].n128_u64[1] + 368))(this[19].n128_u64[1], this[248].n128_i16[5], &this[248].n128_i8[12], &this[246].n128_i8[8], this + 247, this + 246, &this[247].n128_i8[8], this + 248);
    this[245].n128_u64[1] = v6;
    if (!v6) {
      goto LABEL_17;
    }
  }
  unsigned __int16 v7 = this[34].n128_u16[6] - 1;
  this[34].n128_u16[6] = v7;
  unsigned __int16 v8 = this[244].n128_u16[2] + this[22].n128_u16[2 * v7 + 7];
  if (this[248].n128_u16[6] <= v8) {
    goto LABEL_17;
  }
  unint64_t v9 = this[247].n128_u64[0];
  if (v9 < v6) {
    goto LABEL_17;
  }
  if (v9 > this[248].n128_u64[0]) {
    goto LABEL_17;
  }
  int v10 = this[246].n128_i16[4];
  int v11 = v10 * v8;
  unint64_t v12 = v6 + v11;
  unint64_t v13 = v12 + 2 * this[246].n128_i16[4];
  if (v13 > v9 || v11 < 0 || v13 < v12) {
    goto LABEL_17;
  }
  unsigned int v14 = BytesToCard((const unsigned __int8 *)(v6 + v11), this[246].n128_i16[4]);
  int v15 = BytesToCard((const unsigned __int8 *)(v12 + v10), v10);
  unint64_t v16 = this[246].n128_u64[0];
  unint64_t v17 = v16 + v14 - 1;
  unint64_t v18 = v17 + v15 - v14;
  BOOL v19 = v16 <= v17 && v18 >= v17;
  if (!v19 || v18 > this[247].n128_u64[1])
  {
LABEL_17:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  unint64_t v21 = this[21].n128_u64[0];
  __n128 v24 = this[20];
  this[20].n128_u64[1] = v17;
  this[21].n128_u64[0] = v17;
  this[20].n128_u64[0] = v18;
  TType2ToType1CharStringConvertionContext::ConvertT2ToT1CharString((uint64_t)this, a2, a3);
  __n128 result = v24;
  this[20] = v24;
  this[21].n128_u64[0] = v21;
  return result;
}

void TOTFCIDCFFFontSet::~TOTFCIDCFFFontSet(TOTFCIDCFFFontSet *this)
{
  TCIDCFFFontSet::~TCIDCFFFontSet(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TOTFCIDCFFFontSet::AddCharString(TOTFCIDCFFFontSet *this, const TType1PSFont *a2, uint64_t a3)
{
  unsigned int v6 = (*(uint64_t (**)(void))(**((void **)a2 + 4) + 168))(*((void *)a2 + 4));
  if (v6 >= 0xFFFF) {
    unsigned int v7 = 0xFFFF;
  }
  else {
    unsigned int v7 = v6;
  }
  if (v7 <= a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 8;
  }
  unsigned int v13 = -1431655766;
  unsigned int v14 = -1431655766;
  uint64_t v8 = (*(uint64_t (**)(const TType1PSFont *, uint64_t, unsigned int *, unsigned int *))(*(void *)a2 + 336))(a2, a3, &v14, &v13);
  unint64_t v12 = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(unsigned __int8 **__return_ptr, const TType1PSFont *, uint64_t, void, void))(*(void *)a2 + 352))(&v12, a2, v8, v14, v13);
  TCFFArray::Add((TOTFCIDCFFFontSet *)((char *)this + 240), v13, v12);
  unint64_t v9 = v12;
  unint64_t v12 = 0;
  if (v9) {
    MEMORY[0x1BA9994A0](v9, 0x1000C8077774924);
  }
  return (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 4) + 560))(*((void *)a2 + 4), a3);
}

void sub_1B52FBB14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1BA9994A0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void TOTFCIDCFFFontSet::AddGlobalSubrs(TOTFCIDCFFFontSet *this, const TType1PSFont *a2, unsigned __int8 a3, const unsigned __int8 *a4, const unsigned __int8 *a5)
{
}

void sub_1B52FBC0C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9994D0](v1, 0x1091C4015871C78);
  _Unwind_Resume(a1);
}

uint64_t TType1OTFCIDFont::EncodeCIDGlyph(TType1OTFCIDFont *this, uint64_t a2, char *a3)
{
  unsigned int v6 = (const char *)((*(uint64_t (**)(TType1OTFCIDFont *))(*(void *)this + 320))(this) + 1);
  uint64_t v7 = (*(uint64_t (**)(TType1OTFCIDFont *))(*(void *)this + 328))(this);
  uint64_t v8 = DetermineROS(v6, (const char *)(v7 + 1));
  if ((v8 & 0xFF00000000) != 0) {
    int v9 = v8;
  }
  else {
    int v9 = 0xFFFF;
  }
  if (v9 != 0xFFFF) {
    LODWORD(a2) = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 4) + 560))(*((void *)this + 4), a2);
  }
  uint64_t result = MakeGlyphNameForCIDPerROS(a2, v9, a3 + 1, 0xFFuLL);
  *a3 = result;
  return result;
}

uint64_t TType1OTFCIDFont::GetGlyphID(TType1OTFCIDFont *this, const unsigned __int8 *a2, unsigned int a3)
{
  uint64_t result = TType1CIDFont::GetGlyphID(this, a2, a3);
  unsigned __int16 v6 = result;
  if (*a2 != 97)
  {
    (*(void (**)(void, unsigned __int16 *, uint64_t, unsigned __int16 *))(**((void **)this + 4) + 368))(*((void *)this + 4), &v6, 1, &v6);
    return v6;
  }
  return result;
}

uint64_t TType1OTFCIDFont::StreamPSFont(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9, uint64_t a10)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = ((uint64_t (*)(void **, void))(*a1)[6])(a1, *a9);
  *a9 = v13;
  unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  ((void (*)(unint64_t *__return_ptr, void **, uint64_t, uint64_t))(*a1)[30])(&v21, a1, v13, a8);
  unsigned int v14 = (__int32 *)v21;
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v56 = v15;
  long long v55 = v15;
  long long v54 = v15;
  long long v53 = v15;
  long long v52 = v15;
  long long v51 = v15;
  long long v50 = v15;
  long long v49 = v15;
  long long v48 = v15;
  long long v47 = v15;
  long long v46 = v15;
  long long v45 = v15;
  long long v44 = v15;
  long long v43 = v15;
  long long v42 = v15;
  long long v41 = v15;
  long long v40 = v15;
  long long v39 = v15;
  long long v38 = v15;
  long long v37 = v15;
  long long v36 = v15;
  long long v35 = v15;
  long long v34 = v15;
  long long v33 = v15;
  long long v32 = v15;
  long long v31 = v15;
  long long v30 = v15;
  long long v28 = v15;
  long long v29 = v15;
  long long v26 = v15;
  long long v27 = v15;
  *(_OWORD *)unsigned int v25 = v15;
  unsigned int v16 = (*(uint64_t (**)(void *))(*a1[4] + 168))(a1[4]);
  if (v16 >= 0xFFFF) {
    uint64_t v18 = 0xFFFFLL;
  }
  else {
    uint64_t v18 = v16;
  }
  if (!a5) {
    TType1PSFont::SetEncoding(v18, v14, v25, v17);
  }
  if ((*a9 & 0x100) != 0)
  {
    ((void (*)(void **))(*a1)[15])(a1);
    unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
    int v23[6] = v19;
    unsigned char v23[7] = v19;
    _OWORD v23[4] = v19;
    v23[5] = v19;
    v23[2] = v19;
    v23[3] = v19;
    v23[0] = v19;
    v23[1] = v19;
    TBufferedStreamingContext::TBufferedStreamingContext(v23, (uint64_t)a1, (uint64_t)v14, a10);
  }
  if ((*a9 & 4) != 0)
  {
    memset(__b, 170, 0x2D8uLL);
    TBufferedCharStringStreamingContext::TBufferedCharStringStreamingContext(__b, (uint64_t)a1, (uint64_t)v14, a10);
  }
  uint64_t result = v21;
  unint64_t v21 = 0;
  if (result) {
    return MEMORY[0x1BA9994A0](result, 0x1000C8052888210);
  }
  return result;
}

void sub_1B52FC3A4()
{
}

void sub_1B52FC51C()
{
}

void sub_1B52FC554(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x1B52FC54CLL);
}

uint64_t TType1OTFCIDFont::GetLocalSubrArrayAndObjectData(TType1OTFCIDFont *this, unsigned __int8 a2, unsigned __int16 *a3, __int16 *a4, const unsigned __int8 **a5, const unsigned __int8 **a6, const unsigned __int8 **a7, const unsigned __int8 **a8)
{
  __int16 v20 = -21846;
  __int16 v19 = -21846;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = (*(uint64_t (**)(void, void, unsigned __int16 *, __int16 *, __int16 *, unint64_t *))(**((void **)this + 4) + 536))(*((void *)this + 4), a2, a3, &v19, &v20, &v18);
  int v15 = v19;
  *a4 = v19;
  if (a3 && result)
  {
    unsigned int v16 = (const unsigned __int8 *)(result + v15 + v15 * *a3);
    unint64_t v17 = (const unsigned __int8 *)(result + v18);
  }
  else
  {
    unsigned int v16 = 0;
    unint64_t v17 = 0;
    uint64_t result = 0;
    *a3 = 0;
  }
  *a6 = v16;
  *a5 = v16;
  *a7 = v17;
  *a8 = v17;
  return result;
}

uint64_t TType1OTFCIDFont::GetGlyphCountForStreaming(TType1OTFCIDFont *this)
{
  LODWORD(result) = (*(uint64_t (**)(void))(**((void **)this + 4) + 168))(*((void *)this + 4));
  if (result >= 0xFFFF) {
    return 0xFFFFLL;
  }
  else {
    return result;
  }
}

void TType1OTFCIDFont::StreamCharData(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  uint64_t v12 = 0x4FBCDA3AC10C9715 * ((a2 - *(void *)(*(void *)(a1 + 32) + 400) - 36) >> 3);
  if (*(_WORD *)(a2 + 80)) {
    std::vector<int>::size_type v13 = *(unsigned __int16 *)(a2 + 80);
  }
  else {
    std::vector<int>::size_type v13 = 32;
  }
  memset(&v26, 170, sizeof(v26));
  std::vector<int>::vector(&v26, v13);
  uint64_t v14 = *(void *)(a3 + 696);
  if ((__int16)v12 >= (unint64_t)((*(void *)(a3 + 704) - v14) >> 4))
  {
    __break(1u);
  }
  else
  {
    std::vector<int>::pointer begin = v26.__begin_;
    uint64_t v15 = *(void *)(a3 + 8);
    __int16 v16 = *(_WORD *)(v14 + 16 * (__int16)v12);
    TBufferedStreamingContext::BufferString(a3, (const unsigned __int8 *)"2 index /CharStrings ", 0x15uLL);
    IntToPString((unsigned __int16)(v16 + 2), (unsigned __int8 *)(a3 + 66));
    TBufferedStreamingContext::BufferString(a3, (const unsigned __int8 *)(a3 + 67), *(unsigned __int8 *)(a3 + 66));
    TBufferedStreamingContext::BufferString(a3, " dict dup begin\r", 0x10uLL);
    TBufferedStreamingContext::StreamBuffer(a3);
    uint64_t v17 = 0;
    int v29 = 0;
    __int16 v18 = 4330;
    do
    {
      int v19 = *((unsigned __int8 *)&v29 + v17) ^ ((unsigned __int16)(v18 & 0xFF00) >> 8);
      __int16 v18 = 22719 - 12691 * (v18 + (*((unsigned char *)&v29 + v17) ^ ((unsigned __int16)(v18 & 0xFF00) >> 8)));
      *((unsigned char *)&v29 + v17++) = v19;
    }
    while (v17 != 4);
    unsigned int v20 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a3 + 8) + 32) + 168))(*(void *)(*(void *)(a3 + 8) + 32));
    if (v20 >= 0xFFFF) {
      int v21 = 0xFFFF;
    }
    else {
      int v21 = v20;
    }
    if (v21)
    {
      unsigned int v22 = 0;
      uint64_t v23 = *(void *)(a3 + 16);
      do
      {
        if (!v22 || ((*(_DWORD *)(v23 + 4 * (v22 >> 5)) << v22) & 0x80000000) != 0)
        {
          int v27 = -1431655766;
          int v28 = -1431655766;
          unsigned __int16 v24 = (*(uint64_t (**)(uint64_t, void, int *, int *))(*(void *)v15 + 336))(v15, (unsigned __int16)v22, &v28, &v27);
          if (!v22 || v24 == (unsigned __int16)v12)
          {
            *(_WORD *)(a3 + 522) = 4;
            *(_WORD *)(a3 + 520) = v18;
            *(_DWORD *)(a3 + 544) = 0;
            *(_WORD *)(a3 + 529) = 257;
            *(unsigned char *)(a3 + 548) = 0;
            *(_OWORD *)(a3 + 648) = 0u;
            *(_OWORD *)(a3 + 664) = 0u;
            *(_DWORD *)(a3 + 680) = 0;
            (*(void (**)(uint64_t, uint64_t, void, int *, std::vector<int>::pointer))(*(void *)a3 + 56))(a3, v15, (unsigned __int16)v22, &v29, begin);
          }
        }
        ++v22;
      }
      while (v21 != v22);
    }
    TBufferedStreamingContext::BufferString(a3, "end\r", 4uLL);
    if (v26.__begin_)
    {
      v26.__end_ = v26.__begin_;
      operator delete(v26.__begin_);
    }
  }
}

void sub_1B52FC9A4()
{
}

uint64_t TType1OTFCIDFont::CheckSubrs(TType1OTFCIDFont *this, unsigned int *a2)
{
  *a2 = 2;
  return 1;
}

BOOL TType1OTFCIDFont::GetEmbeddedCharMetrics(TType1OTFCIDFont *this, uint64_t a2, const unsigned __int8 *a3, int a4, int *a5, int *a6)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  BOOL v11 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  *(_OWORD *)uint64_t v12 = 0u;
  long long v13 = 0u;
  unsigned __int16 v10 = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)uint64_t v7 = 0u;
  TType1OTFCIDFont::ParseType2CharString((uint64_t)this, a2, a3, v7, a4, 0, v12, &v10, &v11, a5, a6);
  return v11;
}

uint64_t TType1OTFCIDFont::ParseType2CharString(uint64_t this, uint64_t a2, const unsigned __int8 *a3, unsigned __int8 *a4, int a5, unsigned int a6, int *a7, unsigned __int16 *a8, BOOL *a9, int *a10, int *a11)
{
  if (a6 > 0xA)
  {
LABEL_78:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  BOOL v11 = a3;
  uint64_t v69 = a3;
  if (a5 && !*a9)
  {
    long long v15 = (TType1OTFCIDFont *)this;
    __int16 v16 = 0;
    unsigned __int16 v67 = a6 + 1;
    double v60 = a4 + 18;
    int v61 = a2;
    uint64_t v63 = a4 + 8;
    unsigned int v64 = a4 + 16;
    unsigned int v62 = a4 + 32;
    int v65 = a4 + 40;
    signed int v66 = a4 + 24;
    long long v17 = (const unsigned __int8 **)&a3[a5];
    while (1)
    {
      long long v18 = v11 + 1;
      unsigned int v19 = *v11;
      if (v19 >= 0x20) {
        break;
      }
      if (v19 == 12)
      {
        int v21 = v11[1];
        v11 += 2;
        unsigned int v19 = v21 | 0xC00;
      }
      else
      {
        if (v19 == 28)
        {
          BOOL v20 = 0;
          v11 += 3;
LABEL_14:
          ++v16;
          goto LABEL_63;
        }
        ++v11;
      }
      uint64_t v22 = *a8;
      LODWORD(v23) = v22 + v16;
      if ((int)v23 > 48) {
        goto LABEL_78;
      }
      if (v16 >= 1)
      {
        do
        {
          this = TType2ToType1CharStringConvertionContext::ArgPtrToFixed((TType2ToType1CharStringConvertionContext *)&v69, v17, a3);
          a7[v22++] = this;
          uint64_t v23 = *a8 + (uint64_t)v16;
        }
        while (v22 < v23);
      }
      *a8 = v23;
      switch(v19)
      {
        case 1u:
        case 3u:
        case 0x12u:
        case 0x17u:
          *a11 = 0;
          this = (*(uint64_t (**)(TType1OTFCIDFont *))(*(void *)v15 + 40))(v15);
          if (((unsigned __int16)v23 & 0xFFFEu) < (unsigned __int16)v23) {
            goto LABEL_69;
          }
          goto LABEL_71;
        case 2u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xCu:
        case 0xDu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x13u:
        case 0x14u:
          goto LABEL_61;
        case 4u:
        case 0x16u:
          *a11 = 0;
          this = (*(uint64_t (**)(TType1OTFCIDFont *))(*(void *)v15 + 40))(v15);
          if ((unsigned __int16)v23 <= 1u) {
            goto LABEL_71;
          }
          goto LABEL_69;
        case 0xAu:
          __int16 v24 = HIWORD(a7[(unsigned __int16)v23 - 1]);
          unsigned int v25 = *(unsigned __int16 *)(*(void *)(*((void *)v15 + 4) + 400) + 488 * v61 + 4);
          __int16 v26 = 0x8000;
          if (v25 < 0x8408) {
            __int16 v26 = 1131;
          }
          if (v25 >= 0x4D8) {
            __int16 v27 = v26;
          }
          else {
            __int16 v27 = 107;
          }
          *a8 = v23 - 1;
          unint64_t v28 = *(void *)a4;
          if (!*(void *)a4)
          {
            unint64_t v28 = (*(uint64_t (**)(TType1OTFCIDFont *, uint64_t, const unsigned __int8 *, const unsigned __int8 *, const unsigned __int8 *, const unsigned __int8 *, const unsigned __int8 *, const unsigned __int8 *))(*(void *)v15 + 368))(v15, a2, v60, v64, v66, v63, v62, v65);
            *(void *)a4 = v28;
          }
          unint64_t v29 = *(void *)v66;
          if (*(void *)v66 < v28
            || v29 > *(void *)v65
            || (int v30 = (unsigned __int16)(v27 + v24),
                uint64_t v31 = *(__int16 *)v64,
                unint64_t v32 = v28 + v30 * v31,
                unint64_t v33 = v32 + 2 * (int)v31,
                v33 > v29)
            || v30 * (uint64_t)(int)v31 < 0
            || v33 < v32)
          {
            uint64_t v58 = __cxa_allocate_exception(0x10uLL);
            *(void *)uint64_t v58 = &unk_1F0DFC400;
            v58[4] = 5;
          }
          unsigned int v34 = BytesToCard((const unsigned __int8 *)(v28 + v30 * (uint64_t)*(__int16 *)v64), *(__int16 *)v64);
          uint64_t v35 = BytesToCard((const unsigned __int8 *)(v32 + v31), v31) - v34;
          long long v36 = (const unsigned __int8 *)(*(void *)v63 + v34 - 1);
          long long v37 = &v36[v35];
          if (*(void *)v63 > (unint64_t)v36 || v37 < v36 || (unint64_t)v37 > *(void *)v62)
          {
            double v59 = __cxa_allocate_exception(0x10uLL);
            *(void *)double v59 = &unk_1F0DFC400;
            v59[4] = 5;
          }
          goto LABEL_40;
        case 0xBu:
          return this;
        case 0xEu:
          *a11 = 0;
          this = (*(uint64_t (**)(TType1OTFCIDFont *))(*(void *)v15 + 40))(v15);
          if (!(_WORD)v23) {
            goto LABEL_71;
          }
          goto LABEL_69;
        case 0x15u:
          *a11 = 0;
          this = (*(uint64_t (**)(TType1OTFCIDFont *))(*(void *)v15 + 40))(v15);
          if ((unsigned __int16)v23 > 2u) {
LABEL_69:
          }
            int v56 = *a7 + *(_DWORD *)(this + 440);
          else {
LABEL_71:
          }
            int v56 = *(_DWORD *)(this + 120);
          *a10 = v56;
          *a9 = 1;
          return this;
        default:
          if (v19 == 29)
          {
            unsigned int v41 = *(unsigned __int16 *)(*((void *)v15 + 4) + 318);
            if (v41 >= 0x846C) {
              __int16 v42 = 0x8000;
            }
            else {
              __int16 v42 = 1131;
            }
            if (v41 >= 0x4D8) {
              __int16 v43 = v42;
            }
            else {
              __int16 v43 = 107;
            }
            unsigned __int16 v44 = v43 + HIWORD(a7[(unsigned __int16)v23 - 1]);
            *a8 = v23 - 1;
            v72[0] = -21846;
            memset(v71, 170, sizeof(v71));
            unint64_t v70 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v45 = (*(uint64_t (**)(TType1OTFCIDFont *, __int16 *, void *, void *, void *, unint64_t *))(*(void *)v15 + 152))(v15, v72, &v71[1], &v71[2], v71, &v70);
            int v46 = v72[0];
            int v47 = v44 * v72[0];
            if (v47 < 0) {
              goto LABEL_78;
            }
            long long v48 = (const unsigned __int8 *)(v45 + v47);
            long long v49 = &v48[2 * v72[0]];
            if (v49 < v48 || (unint64_t)v49 > v71[1]) {
              goto LABEL_78;
            }
            unsigned int v51 = BytesToCard(v48, v72[0]);
            uint64_t v35 = BytesToCard(&v48[v46], v46) - v51;
            long long v36 = (const unsigned __int8 *)(v71[2] + v51 - 1);
            long long v52 = &v36[v35];
            BOOL v53 = v71[2] <= (unint64_t)v36 && v52 >= v36;
            if (!v53 || (unint64_t)v52 > v71[0]) {
              goto LABEL_78;
            }
LABEL_40:
            long long v40 = a9;
            this = TType1OTFCIDFont::ParseType2CharString(v15, a2, v36, a4, v35, v67, a7, a8, a9, a10, a11);
          }
          else
          {
LABEL_61:
            *a8 = 0;
            long long v40 = a9;
          }
          __int16 v16 = 0;
          uint64_t v69 = v11;
          BOOL v20 = *v40;
          break;
      }
LABEL_63:
      if (v11 >= (const unsigned __int8 *)v17 || v20) {
        return this;
      }
    }
    BOOL v20 = 0;
    if (v19 > 0xF6) {
      long long v18 = v11 + 2;
    }
    if (v19 == 255) {
      v11 += 5;
    }
    else {
      BOOL v11 = v18;
    }
    goto LABEL_14;
  }
  return this;
}

void sub_1B52FD0F0(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:fe180100]<std::allocator<CompFDInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:fe180100]();
  }
  return operator new(16 * a2);
}

void std::vector<CompFDInfo>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  uint64_t v2 = (uint64_t *)*a1;
  if (*v2)
  {
    std::vector<CompFDInfo>::__base_destruct_at_end[abi:fe180100]((uint64_t)v2, *v2);
    long long v3 = **a1;
    operator delete(v3);
  }
}

uint64_t std::vector<CompFDInfo>::__base_destruct_at_end[abi:fe180100](uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  for (uint64_t i = *(void *)(result + 8); i != a2; i -= 16)
  {
    uint64_t result = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (result) {
      uint64_t result = MEMORY[0x1BA9994A0](result, 0x1000C80BDFB0063);
    }
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<int>::__vallocate[abi:fe180100](this, __n);
    std::vector<int>::pointer end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_1B52FD2B8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<int>::__vallocate[abi:fe180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<int>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:fe180100]<std::allocator<int>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:fe180100]();
  }
  return operator new(4 * a2);
}

uint64_t TTResetScalerCache(void)
{
  return 0;
}

int *TTScalerOpen()
{
  {
    TTScalerInfo(void)::ourInfo = 1953658213;
    unk_1EB2CD274 = "TrueType";
    unk_1EB2CD27C = xmmword_1B5395C00;
    unk_1EB2CD28C = "eurt";
    dword_1EB2CD294 = 3;
    qword_1EB2CD298 = (uint64_t)&TTScalerInfo(void)::ourCapabilities;
    dword_1EB2CD2A0 = 2;
    unk_1EB2CD2A4 = &TTScalerInfo(void)::ourMetrics;
    dword_1EB2CD2AC = 4;
    qword_1EB2CD2B0 = (uint64_t)"pambpamchtaptpxg";
    unk_1EB2CD2B8 = TTScalerGetProto::theThing;
  }
  return &TTScalerInfo(void)::ourInfo;
}

void *OutlineToPath(memoryContext *a1, unsigned int *a2, _WORD *a3)
{
  uint64_t v4 = *a2;
  if ((int)v4 >= 1)
  {
    size_t v5 = (unsigned __int16 *)*((void *)a2 + 4);
    signed int v6 = a2[1];
    int v7 = -1;
    signed int v8 = 4;
    while (1)
    {
      signed int v10 = *v5++;
      int v9 = v10;
      if (v6 <= v10) {
        break;
      }
      v8 += 8 * (v9 - v7) + 4 * ((v9 - v7 + 31) >> 5) + 4;
      int v7 = v9;
      if (!--v4) {
        goto LABEL_7;
      }
    }
LABEL_22:
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  signed int v8 = 4;
LABEL_7:
  uint64_t v11 = *((void *)a2 + 5);
  uint64_t v12 = (int *)*((void *)a2 + 1);
  long long v13 = (int *)*((void *)a2 + 2);
  uint64_t result = ScalerNewBlock(a1, v8, 5, 0, 0, 0, a3);
  if (result)
  {
    *(_DWORD *)uint64_t result = *a2;
    if ((int)*a2 >= 1)
    {
      uint64_t v15 = 0;
      int v16 = 0;
      long long v17 = (_DWORD *)result + 1;
      uint64_t v18 = *((void *)a2 + 4);
      while (1)
      {
        int v19 = *(unsigned __int16 *)(v18 + 2 * v15);
        int v20 = v16 + v19;
        if (v16 + v19 < 0) {
          goto LABEL_22;
        }
        *long long v17 = v20 + 1;
        int v21 = v17 + 1;
        do
        {
          uint64_t v22 = 0;
          int v23 = 0;
          uint64_t v24 = v11;
          while (1)
          {
            uint64_t v25 = v22;
            int v23 = (*(unsigned char *)(v11 + v22) == 0) | (2 * v23);
            if (v22 == 31) {
              break;
            }
            ++v22;
            if ((v20 & ~(v20 >> 31)) + 1 == v25 + 1)
            {
              *v21++ = v23 << -(char)v22;
              goto LABEL_18;
            }
          }
          *v21++ = v23;
          v11 += v22 + 1;
          BOOL v26 = v20 == 31;
          v20 -= 32;
        }
        while (!v26);
LABEL_18:
        uint64_t v11 = v24 + v25 + 1;
        int v27 = v16 + v19 + 1;
        do
        {
          int v28 = *v12++;
          *int v21 = v28 << 10;
          int v29 = *v13++;
          long long v17 = v21 + 2;
          v21[1] = -1024 * v29;
          --v27;
          v21 += 2;
        }
        while (v27 > 0);
        int v16 = ~v19;
        if (++v15 >= (int)*a2) {
          return result;
        }
      }
    }
  }
  return result;
}

int32x4_t GetScalerVariationInfo(uint64_t a1, uint64_t a2, int a3, int32x4_t *a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (a3 && *(unsigned char *)(v4 + 156))
  {
    a4->i64[0] = 0;
    a4->i64[1] = 0;
  }
  else
  {
    float64x2_t v5 = (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL);
    int32x4_t v6 = vmovl_s16(*(int16x4_t *)(v4 + 132));
    v7.i64[0] = v6.i32[0];
    v7.i64[1] = v6.i32[1];
    float64x2_t v8 = vcvtq_f64_s64(v7);
    v7.i64[0] = v6.i32[2];
    v7.i64[1] = v6.i32[3];
    float64x2_t v9 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)*(__int16 *)(v4 + 130) * 0.0000152587891), 0);
    int32x4_t result = vuzp1q_s32((int32x4_t)vcvtq_n_s64_f64(vdivq_f64(vmulq_f64(v8, v5), v9), 0x10uLL), (int32x4_t)vcvtq_n_s64_f64(vdivq_f64(vmulq_f64(vcvtq_f64_s64(v7), v5), v9), 0x10uLL));
    *a4 = result;
  }
  return result;
}

void *CreateScalerVariationBlock(uint64_t a1, memoryContext *a2, unsigned int a3, uint64_t *a4)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  float64x2_t v8 = ScalerNewBlock(a2, 64, 2, 0, 0, 0, 0);
  float64x2_t v9 = v8;
  *(_DWORD *)float64x2_t v8 = 1986097769;
  *((unsigned char *)v8 + 56) = 0;
  *(void *)(a1 + 16) = v8;
  if (a3)
  {
    uint64_t v10 = *(void *)(a1 + 8);
    if (*(unsigned char *)(v10 + 155))
    {
      uint64_t v11 = *(unsigned __int16 *)(v10 + 150);
      *((_DWORD *)v8 + 2) = 64;
      unsigned int v12 = 2 * *(_DWORD *)(v10 + 72);
      *((_DWORD *)v8 + 6) = v12 + 64;
      int v13 = *(_DWORD *)(v10 + 76) * v12;
      unsigned int v14 = v13 + v12 + 64;
      BOOL v15 = __CFADD__(v13, v12 + 64);
      *((_DWORD *)v8 + 10) = v14;
      signed int v16 = v14 + 2 * v11;
      BOOL v17 = __CFADD__(v14, 2 * v11);
      if (v12 > 0xFFFFFFBF || v15 || v17)
      {
        exception = __cxa_allocate_exception(2uLL);
        _WORD *exception = 5;
        __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
      }
      float64x2_t v9 = ScalerNewBlock(a2, v16, 2, v8, 0, 0, 0);
      *(void *)(a1 + 16) = v9;
      _OWORD v9[2] = (char *)v9 + *((unsigned int *)v9 + 2);
      uint64_t v18 = *((unsigned int *)v9 + 6);
      _OWORD v9[4] = (char *)v9 + v18;
      uint64_t v19 = *((unsigned int *)v9 + 10);
      v9[6] = (char *)v9 + v19;
      uint64_t v20 = *(void *)(a1 + 8);
      if (*(_DWORD *)(v20 + 76))
      {
        __src[0] = (void *)0xAAAAAAAAAAAAAAAALL;
        int v21 = v19 - v18;
        ScalerGetFontTable(a2, 1735811442, *(_DWORD *)(v20 + 68), __src, 0, v19 - v18);
        uint64_t v22 = __src[0];
        memcpy((void *)v9[4], __src[0], v21);
        ScalerReleaseFontTable(a2, v22);
      }
      *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v38 = v23;
      long long v39 = v23;
      long long v36 = v23;
      long long v37 = v23;
      *(_OWORD *)__src = v23;
      long long v35 = v23;
      long long v33 = 0uLL;
      std::vector<CGFontVariation,TInlineBufferAllocator<CGFontVariation,4ul>>::vector(__src, a3, &v33);
      uint64_t v24 = (double *)__src[0];
      uint64_t v25 = 8 * a3;
      do
      {
        uint64_t v26 = *a4++;
        *(void *)uint64_t v24 = v26;
        v24[1] = (double)SHIDWORD(v26) * 0.0000152587891;
        v24 += 2;
        v25 -= 8;
      }
      while (v25);
      int v27 = (*(uint64_t (**)(void, void, void *, void))(**(void **)(*(void *)a2 + 24) + 408))(*(void *)(*(void *)a2 + 24), a3, __src[0], v9[2]);
      *((unsigned char *)v9 + 56) = v27;
      if (v27)
      {
        if (v11)
        {
          if (*(unsigned char *)(*(void *)(a1 + 8) + 157))
          {
            *(void *)&long long v33 = 0;
            ScalerGetFontTable(a2, 1668707360, 0, &v33, 0, 0);
            int v28 = (char *)v33;
            if ((void)v33)
            {
              uint64_t v29 = 0;
              uint64_t v30 = v9[6];
              do
              {
                *(_WORD *)(v30 + v29) = bswap32(*(unsigned __int16 *)&v28[v29]) >> 16;
                v29 += 2;
              }
              while (2 * v11 != v29);
              ScalerReleaseFontTable(a2, v28);
              ApplyStyleToCVT((memoryContext **)a1);
            }
          }
        }
      }
      *(void *)&long long v33 = __src;
      std::vector<CGFontVariation,TInlineBufferAllocator<CGFontVariation,4ul>>::__destroy_vector::operator()[abi:fe180100]((void ***)&v33);
    }
  }
  return v9;
}

void sub_1B52FD944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, char a11)
{
  a9 = (void **)&a11;
  std::vector<CGFontVariation,TInlineBufferAllocator<CGFontVariation,4ul>>::__destroy_vector::operator()[abi:fe180100](&a9);
  _Unwind_Resume(a1);
}

unsigned int GetVariationScalar(uint64_t a1, int a2)
{
  if (a2 < 0) {
    return 1;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(_DWORD *)(v2 + 76) <= a2) {
    return 1;
  }
  double v3 = ComputeVectorScalar(*(_DWORD *)(v2 + 72), *(const __int16 **)(*(void *)(a1 + 16) + 16), (const __int16 *)(*(void *)(*(void *)(a1 + 16) + 32) + 2 * *(_DWORD *)(v2 + 72) * a2));
  double v4 = *(float *)&v3;
  if (v4 <= *(double *)"") {
    return vcvtd_n_s64_f64(v4, 0x10uLL);
  }
  else {
    return 0x7FFFFFFF;
  }
}

void std::vector<CGFontVariation,TInlineBufferAllocator<CGFontVariation,4ul>>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    double v3 = v1 + 11;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[11]) {
        *double v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void *std::vector<CGFontVariation,TInlineBufferAllocator<CGFontVariation,4ul>>::vector(void *a1, unint64_t a2, _OWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[11] = a1 + 3;
  if (a2)
  {
    std::vector<CGFontVariation,TInlineBufferAllocator<CGFontVariation,4ul>>::__vallocate[abi:fe180100](a1, a2);
    int32x4_t v6 = (_OWORD *)a1[1];
    int64x2_t v7 = &v6[a2];
    uint64_t v8 = 16 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 16;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1B52FDAB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<CGFontVariation,TInlineBufferAllocator<CGFontVariation,4ul>>::__vallocate[abi:fe180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
  }
  int32x4_t result = (char *)TInlineBufferAllocator<CGFontVariation,4ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * a2];
  return result;
}

void *TInlineBufferAllocator<CGFontVariation,4ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v2 = (unint64_t *)(a1 + 64);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 16 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >> 60) {
      std::__throw_bad_array_new_length[abi:fe180100]();
    }
    return operator new(16 * a2);
  }
}

uint64_t TType1SFNTFont::GetSubrCount(TType1SFNTFont *this)
{
  return *(unsigned __int16 *)(*((void *)this + 4) + 144);
}

uint64_t TType1SFNTFont::GetSubrData(TType1SFNTFont *this, const unsigned __int8 **a2, __int16 *a3, const unsigned __int8 **a4)
{
  uint64_t v4 = *((void *)this + 4);
  int v5 = *(unsigned __int16 *)(v4 + 146);
  *a3 = v5;
  uint64_t v8 = v4 + 112;
  int64x2_t v7 = *(const unsigned __int8 **)(v4 + 112);
  uint64_t v6 = *(void *)(v8 + 8);
  *a2 = v7;
  if (v7) {
    BOOL v9 = v5 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    uint64_t result = 0;
    *a4 = 0;
  }
  else
  {
    *a4 = &v7[v6];
    uint64_t v10 = (uint64_t)*a2;
    return v10 + *a3 + *a3 * (uint64_t)(*(int (**)(TType1SFNTFont *))(*(void *)this + 144))(this);
  }
  return result;
}

uint64_t TType1SFNTFont::GetGlobalSubrCount(TType1SFNTFont *this)
{
  return 0;
}

uint64_t TType1SFNTFont::GetGlobalSubrArrayAndObjectData(TType1SFNTFont *this, __int16 *a2, const unsigned __int8 **a3, const unsigned __int8 **a4, const unsigned __int8 **a5, const unsigned __int8 **a6)
{
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  return 0;
}

uint64_t TType1SFNTFont::GetCharOutline@<X0>(TType1SFNTFont *this@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 4) + 168))(*((void *)this + 4));
  if (result >= 0xFFFF) {
    unsigned int v8 = 0xFFFF;
  }
  else {
    unsigned int v8 = result;
  }
  if (v8 <= a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 8;
  }
  uint64_t v9 = *(void *)(*((void *)this + 4) + 104);
  int v10 = *(_DWORD *)(v9 + 8 * a2 + 4);
  if (v10)
  {
    uint64_t v11 = 8 * a2;
    unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v16[1] = v12;
    *(_OWORD *)BOOL v17 = v12;
    v16[0] = v12;
    int v13 = (const TFontObjectSurrogate *)(*(uint64_t (**)(TType1SFNTFont *))(*(void *)this + 216))(this);
    uint64_t v14 = (*(uint64_t (**)(TType1SFNTFont *))(*(void *)this + 120))(this);
    TFontObjectTable::TFontObjectTable((TFontObjectTable *)v16, v13, v14, *(unsigned int *)(v9 + v11), v10);
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    operator new[]();
  }
  *a3 = 0;
  return result;
}

void sub_1B52FDDD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *uint64_t v2 = 0;
  MEMORY[0x1BA9994A0](v3, 0x1000C8077774924);
  TDataReference::~TDataReference((TDataReference *)va);
  _Unwind_Resume(a1);
}

uint64_t cacheCallContext::cacheCallContext(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(_DWORD *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  uint64_t v4 = *(void *)(a2 + 64);
  *(void *)(result + 16) = &unk_1F0DD8690;
  *(void *)(result + 24) = v4;
  *(void *)(result + 32) = 0;
  *(void *)(result + 40) = a3;
  *(_DWORD *)(result + 48) = a4;
  *(_WORD *)(result + 60) = 0;
  *(void *)(result + 52) = 0;
  if (!v4)
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  return result;
}

void cacheCallContext::cacheCallContext(cacheCallContext *this, const TFont *a2, void *a3, int a4)
{
  *(_DWORD *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &unk_1F0DD8690;
  *((void *)this + 3) = a2;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = a3;
  *((_DWORD *)this + 12) = a4;
  *(void *)((char *)this + 52) = 0;
  *((_WORD *)this + 30) = 0;
  if (!a2)
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
}

void *CreateScalerFontBlock(void *a1, memoryContext *a2)
{
  unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
  if (ScalerGetFontTable(a2, 1835104368, 0, &v54, 0, 32) <= 0x1F) {
    goto LABEL_54;
  }
  unint64_t v4 = v54;
  unsigned int v5 = ((bswap32(*(unsigned __int16 *)(v54 + 20)) >> 13) & 0x7FFF8) + 228;
  uint64_t v6 = ScalerNewBlock(a2, v5 + 8 * (bswap32(*(unsigned __int16 *)(v54 + 22)) >> 16) + 32, 1, 0, 0, 1, 0);
  int64x2_t v7 = v6;
  *(_DWORD *)uint64_t v6 = 1718578804;
  *((_DWORD *)v6 + 9) = bswap32(*(_DWORD *)v4);
  int8x16_t v8 = vrev16q_s8(*(int8x16_t *)(v4 + 4));
  *(int8x16_t *)(v6 + 5) = v8;
  v6[7] = vrev16_s8(*(int8x8_t *)(v4 + 20));
  *((_WORD *)v6 + 32) = bswap32(*(unsigned __int16 *)(v4 + 28)) >> 16;
  unsigned int v9 = bswap32(*(unsigned __int16 *)(v4 + 30)) >> 16;
  *((_WORD *)v6 + 33) = v9;
  if (v8.u16[5] >= 3u) {
    *((_WORD *)v6 + 25) = 2;
  }
  if (v9 >= 0x11) {
    *((_WORD *)v6 + 33) = 16;
  }
  *((_DWORD *)v6 + 1) = 180;
  *((_DWORD *)v6 + 2) = v5;
  LODWORD(v53) = 0;
  int TableIndex = TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1819239265, (unsigned int *)&v53);
  int v11 = (int)v53;
  *((_DWORD *)v7 + 24) = TableIndex;
  *((_DWORD *)v7 + 25) = v11;
  LODWORD(v53) = 0;
  int v12 = TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1735162214, (unsigned int *)&v53);
  int v13 = (int)v53;
  *((_DWORD *)v7 + 26) = v12;
  *((_DWORD *)v7 + 27) = v13;
  a1[1] = v7;
  a1[6] = (char *)v7 + *((unsigned int *)v7 + 1);
  a1[7] = (char *)v7 + *((unsigned int *)v7 + 2);
  *((_DWORD *)v7 + 3) = 4 * *((unsigned __int16 *)v7 + 27);
  LODWORD(v53) = 0;
  TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1668707360, (unsigned int *)&v53);
  *((_WORD *)v7 + 75) = v53 >> 1;
  int v14 = *((unsigned __int16 *)v7 + 26);
  int v15 = 12 * v14;
  v14 *= 5;
  int v16 = v15 + 2 * v14;
  int v17 = v16 + 4;
  int v18 = (v16 + 7) & 0x3FFFFC;
  int v19 = ((2 * v14) & 2) != 0 ? v18 : v17;
  *((_DWORD *)v7 + 4) = v19;
  unsigned int v20 = *((unsigned __int16 *)v7 + 22) <= *((unsigned __int16 *)v7 + 24)
      ? *((unsigned __int16 *)v7 + 24)
      : *((unsigned __int16 *)v7 + 22);
  unsigned int v21 = *((unsigned __int16 *)v7 + 21) <= *((unsigned __int16 *)v7 + 23)
      ? *((unsigned __int16 *)v7 + 23)
      : *((unsigned __int16 *)v7 + 21);
  *((_DWORD *)v7 + 7) = v20 + 8;
  *((_DWORD *)v7 + 8) = v21 + 8;
  if (v20 > 0xFFF7 || v21 >= 0xFFF8) {
    goto LABEL_54;
  }
  int v22 = (unsigned __int16)(v21 + 8);
  *((_DWORD *)v7 + 5) = 12 * v22 + 8 * *((unsigned __int16 *)v7 + 32) + 10;
  *((_DWORD *)v7 + 6) = 4 * (unsigned __int16)(v20 + 8) + 10 * v22;
  ScalerReleaseFontTable(a2, (const void *)v4);
  *((unsigned char *)v7 + 154) = 0;
  LODWORD(v53) = 0;
  int v23 = TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1651273571, (unsigned int *)&v53);
  int v24 = (int)v53;
  LODWORD(v53) = 0;
  int v25 = TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1161972803, (unsigned int *)&v53);
  int v26 = (int)v53;
  BOOL v27 = v53 != 0;
  BOOL v28 = v24 == 0;
  BOOL v29 = !v28 || !v27;
  if (v28 && v27) {
    int v30 = v25;
  }
  else {
    int v30 = v23;
  }
  if (v29) {
    int v26 = v24;
  }
  if (v24 != 0 && v27)
  {
    int v31 = 0;
  }
  else
  {
    int v23 = v30;
    int v31 = v26;
  }
  *((unsigned char *)v7 + 153) = v31 != 0;
  BOOL v53 = 0;
  unsigned int FontTable = ScalerGetFontTable(a2, 1751474532, 0, &v53, 1, 54);
  if (!FontTable) {
    unsigned int FontTable = ScalerGetFontTable(a2, 1651008868, 0, &v53, 1, 54);
  }
  long long v33 = (unsigned __int16 *)v53;
  if (v53 && FontTable >= 0x36)
  {
    unsigned int v34 = bswap32(*((unsigned __int16 *)v53 + 9));
    if ((unsigned __int16)(HIWORD(v34) - 16385) <= 0xC03Eu) {
      goto LABEL_54;
    }
    unsigned int v35 = HIWORD(v34);
    *((_WORD *)v7 + 65) = v35;
    *((_WORD *)v7 + 66) = bswap32(v33[18]) >> 16;
    *((_WORD *)v7 + 67) = bswap32(v33[19]) >> 16;
    *((_WORD *)v7 + 68) = bswap32(v33[20]) >> 16;
    *((_WORD *)v7 + 69) = bswap32(v33[21]) >> 16;
    *((_WORD *)v7 + 71) = vcvtd_n_s64_f64((double)v35 * 0.0000152587891 * 0.0500030518, 0x10uLL);
    *((_WORD *)v7 + 70) = bswap32(v33[23]) >> 16;
    *((_WORD *)v7 + 64) = bswap32(v33[8]) >> 16;
    *((_WORD *)v7 + 72) = bswap32(v33[25]) >> 16;
    *((unsigned char *)v7 + 152) = *((_DWORD *)v7 + 27) != 0;
    ScalerReleaseFontTable(a2, v33);
  }
  else
  {
    if (!*((_DWORD *)v7 + 42)) {
      goto LABEL_54;
    }
    *((_DWORD *)v7 + 32) = 302383104;
    *((_WORD *)v7 + 72) = 0;
    *((unsigned char *)v7 + 152) = 0;
    *(void *)((char *)v7 + 132) = 0;
    *((_DWORD *)v7 + 35) = 15073280;
  }
  BOOL v53 = (void *)0xAAAAAAAAAAAAAAAALL;
  *(_DWORD *)((char *)v7 + 146) = 0;
  LODWORD(v52) = 0;
  *((_DWORD *)v7 + 28) = TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1752003704, (unsigned int *)&v52);
  ScalerGetFontTable(a2, 1751672161, 0, &v53, 1, 36);
  long long v36 = v53;
  if (v53)
  {
    *((_WORD *)v7 + 73) = bswap32(*((unsigned __int16 *)v53 + 17)) >> 16;
    ScalerReleaseFontTable(a2, v36);
  }
  LODWORD(v52) = 0;
  *((_DWORD *)v7 + 29) = TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1986884728, (unsigned int *)&v52);
  if (v52)
  {
    ScalerGetFontTable(a2, 1986553185, 0, &v53, 1, 36);
    long long v37 = v53;
    if (v53)
    {
      *((_WORD *)v7 + 74) = bswap32(*((unsigned __int16 *)v53 + 17)) >> 16;
      ScalerReleaseFontTable(a2, v37);
    }
  }
  BOOL v53 = 0;
  ScalerGetFontTable(a2, 1718449272, 0, &v53, 1, 16);
  long long v38 = (unsigned int *)v53;
  *((unsigned char *)v7 + 159) = v53 != 0;
  if (v38)
  {
    int v39 = bswap32(*v38);
    if (v39 < 0x20000)
    {
      *((unsigned char *)v7 + 159) = 0;
LABEL_43:
      ScalerReleaseFontTable(a2, v38);
      goto LABEL_44;
    }
    *((_DWORD *)v7 + 20) = v39;
    unsigned int v40 = bswap32(v38[1]);
    *((_DWORD *)v7 + 21) = v40;
    v7[11] = *((void *)v38 + 1);
    if (v40 < *((unsigned __int16 *)v7 + 20)) {
      goto LABEL_43;
    }
LABEL_54:
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
LABEL_44:
  LODWORD(v53) = 0;
  TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1718642541, (unsigned int *)&v53);
  *((_DWORD *)v7 + 30) = v53;
  LODWORD(v53) = 0;
  TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1886545264, (unsigned int *)&v53);
  *((_DWORD *)v7 + 31) = v53;
  LODWORD(v53) = 0;
  TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1719034226, (unsigned int *)&v53);
  int v41 = (int)v53;
  *((unsigned char *)v7 + 155) = v53 != 0;
  if (v41)
  {
    BOOL v53 = (void *)0xAAAAAAAAAAAAAAAALL;
    ScalerGetFontTable(a2, 1719034226, 0, &v53, 0, 16);
    __int16 v42 = v53;
    *((_DWORD *)v7 + 18) = bswap32(*((unsigned __int16 *)v53 + 4)) >> 16;
    ScalerReleaseFontTable(a2, v42);
    LODWORD(v52) = 0;
    unsigned int v43 = TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1735811442, (unsigned int *)&v52);
    *((unsigned char *)v7 + 156) = v43 != 0;
    if (v43)
    {
      long long v52 = (void *)0xAAAAAAAAAAAAAAAALL;
      ScalerGetTableParts(a2, v43, 0, 0x14u, &v52, 0);
      unsigned __int16 v44 = (unsigned __int16 *)v52;
      *((_DWORD *)v7 + 17) = bswap32(*((_DWORD *)v52 + 2));
      *((_DWORD *)v7 + 19) = bswap32(v44[3]) >> 16;
      ScalerReleaseFontTable(a2, v44);
    }
    __int16 v45 = *((_WORD *)v7 + 75);
    if (v45)
    {
      LODWORD(v52) = 0;
      TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1668702578, (unsigned int *)&v52);
      LOBYTE(v45) = v52 != 0;
    }
    *((unsigned char *)v7 + 157) = v45;
    LODWORD(v52) = 0;
    TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1635148146, (unsigned int *)&v52);
    *((unsigned char *)v7 + 158) = (_BYTE)v52;
  }
  if (*((unsigned char *)v7 + 153) == 1)
  {
    *((_DWORD *)v7 + 41) = v23;
    *((_DWORD *)v7 + 42) = v31;
    LODWORD(v53) = 0;
    int v46 = TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1650745716, (unsigned int *)&v53);
    int v47 = (int)v53;
    *((_DWORD *)v7 + 43) = v46;
    *((_DWORD *)v7 + 44) = v47;
    if (!v47)
    {
      LODWORD(v53) = 0;
      int v48 = TFontSurrogate::GetTableIndex((TFontSurrogate *)(*(void *)a2 + 16), 1161970772, (unsigned int *)&v53);
      int v49 = (int)v53;
      *((_DWORD *)v7 + 43) = v48;
      *((_DWORD *)v7 + 44) = v49;
    }
  }
  return v7;
}

void GetFontMetrics(uint64_t a1, memoryContext *a2, int a3, char *a4)
{
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  uint64_t v89 = 0;
  long long v90 = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  if (!*(_WORD *)(v4 + 130))
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t v7 = *(void *)(a1 + 24);
  bzero(a4, 0x4CuLL);
  float64x2_t v8 = (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL);
  int32x4_t v9 = vmovl_s16(*(int16x4_t *)(v4 + 132));
  v10.i64[0] = v9.i32[0];
  v10.i64[1] = v9.i32[1];
  float64x2_t v11 = vcvtq_f64_s64(v10);
  v10.i64[0] = v9.i32[2];
  v10.i64[1] = v9.i32[3];
  float64x2_t v12 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)*(__int16 *)(v4 + 130) * 0.0000152587891), 0);
  int32x4_t v95 = vuzp1q_s32((int32x4_t)vcvtq_n_s64_f64(vdivq_f64(vmulq_f64(v11, v8), v12), 0x10uLL), (int32x4_t)vcvtq_n_s64_f64(vdivq_f64(vmulq_f64(vcvtq_f64_s64(v10), v8), v12), 0x10uLL));
  int v13 = (int *)(v7 + 96);
  int v14 = M3x3Flags((_DWORD *)(v7 + 96));
  M3x3Mul((int *)(v7 + 96), v14, (int32x2_t *)&v95, (const int *)2);
  *(int32x4_t *)(a4 + 56) = v95;
  if (a3) {
    uint64_t v15 = 1986553185;
  }
  else {
    uint64_t v15 = 1751672161;
  }
  ScalerGetFontTable(a2, v15, 0, &v90, 1, 36);
  int v16 = v90;
  if (v90)
  {
    double v17 = (double)((int)bswap32(v90[2]) >> 16);
    double v18 = (double)*(__int16 *)(v4 + 130) * 0.0000152587891;
    v95.i32[0] = 0;
    *(uint64_t *)((char *)v95.i64 + 4) = vcvtd_n_s64_f64(v17 * 0.0000152587891 / v18, 0x10uLL);
    v95.i32[3] = vcvtd_n_s64_f64((double)((int)bswap32(v90[3]) >> 16) * 0.0000152587891 / v18, 0x10uLL);
    M3x3Mul((int *)(v7 + 96), v14, (int32x2_t *)&v95, (const int *)2);
    int v19 = *(_DWORD *)((unint64_t)&v95 | 0xC);
    *(_DWORD *)a4 = v95.i32[1];
    *((_DWORD *)a4 + 1) = v19;
    v95.i32[0] = 0;
    double v20 = (double)*(__int16 *)(v4 + 130) * 0.0000152587891;
    v95.i32[1] = vcvtd_n_s64_f64((double)((int)bswap32(v16[4]) >> 16) * 0.0000152587891 / v20, 0x10uLL);
    v95.i32[2] = vcvtd_n_s64_f64((double)(bswap32(v16[5]) >> 16) * 0.0000152587891 / v20, 0x10uLL);
    *(_DWORD *)((unint64_t)&v95 | 0xC) = 0;
    M3x3Mul(v13, v14, (int32x2_t *)&v95, (const int *)2);
    *((_DWORD *)a4 + 2) = v95.i32[1];
    *((_DWORD *)a4 + 4) = v95.i32[2];
    double v21 = (double)*(__int16 *)(v4 + 130) * 0.0000152587891;
    v95.i64[0] = vcvtd_n_s64_f64((double)((int)bswap32(v16[6]) >> 16) * 0.0000152587891 / v21, 0x10uLL);
    v95.i32[2] = vcvtd_n_s64_f64((double)((int)bswap32(v16[7]) >> 16) * 0.0000152587891 / v21, 0x10uLL);
    *(_DWORD *)((unint64_t)&v95 | 0xC) = 0;
    M3x3Mul(v13, v14, (int32x2_t *)&v95, (const int *)2);
    __int32 v22 = v95.i32[2];
    *((_DWORD *)a4 + 5) = v95.i32[0];
    *((_DWORD *)a4 + 6) = v22;
    ScalerReleaseFontTable(a2, v16);
    if (a3)
    {
      int v23 = *((_DWORD *)a4 + 15) - *((_DWORD *)a4 + 17);
      int v24 = *((_DWORD *)a4 + 16) - *((_DWORD *)a4 + 14);
      int v25 = v24 + 65537;
      int v26 = v24 + 0x10000;
      if (v26 < 0) {
        int v26 = v25;
      }
      *((void *)a4 + 8) = (v26 >> 1);
      *((_DWORD *)a4 + 14) = -(v26 >> 1);
      *((_DWORD *)a4 + 15) = v23;
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v27 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v27 + 490))
    {
      *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v94[12] = v28;
      long long v93 = v28;
      *(_OWORD *)long long v94 = v28;
      *(_OWORD *)long long v92 = v28;
      uint64_t v29 = *(void *)(v27 + 80);
      if (v27 + 96 != v29)
      {
        long long v30 = *(_OWORD *)(v27 + 96);
        long long v31 = *(_OWORD *)(v27 + 112);
        *(_DWORD *)(v29 + 32) = *(_DWORD *)(v27 + 128);
        *(_OWORD *)uint64_t v29 = v30;
        *(_OWORD *)(v29 + 16) = v31;
        uint64_t v27 = *(void *)(a1 + 24);
      }
      if (sbit_FontMatch(a2, a1, (uint64_t)v92, *(unsigned __int8 *)(v27 + 484), 1)) {
        *(_WORD *)(*(void *)(a1 + 24) + 489) = 514;
      }
      int v32 = HIDWORD(v92[0]);
      int v33 = HIDWORD(v92[1]);
      *(_DWORD *)a4 = HIDWORD(v92[0]);
      *((_DWORD *)a4 + 1) = v33;
      int v34 = *(_DWORD *)v94;
      *((_DWORD *)a4 + 2) = *(_DWORD *)&v94[12];
      *((_DWORD *)a4 + 4) = v34;
      if (*((_DWORD *)a4 + 14) == *((_DWORD *)a4 + 16) || *((_DWORD *)a4 + 15) == *((_DWORD *)a4 + 17))
      {
        *((_DWORD *)a4 + 14) = 0;
        *((_DWORD *)a4 + 15) = v33;
        *((_DWORD *)a4 + 16) = v34;
        *((_DWORD *)a4 + 17) = v32 - v33;
      }
      if (a3) {
        goto LABEL_27;
      }
    }
    else
    {
      if (a3)
      {
        int v35 = *((_DWORD *)a4 + 17);
        int v36 = *((_DWORD *)a4 + 15);
        int v37 = *((_DWORD *)a4 + 16) - *((_DWORD *)a4 + 14);
        int v38 = v37 + 65537;
        int v39 = v37 + 0x10000;
        if (v39 < 0) {
          int v39 = v38;
        }
        unsigned int v40 = v39 >> 1;
        int v41 = -(v39 >> 1);
        *(_DWORD *)a4 = v40;
        *((_DWORD *)a4 + 1) = v41;
        *((_DWORD *)a4 + 2) = 0;
        int v42 = v36 - v35;
        *((void *)a4 + 8) = v40;
        *((_DWORD *)a4 + 14) = v41;
        *((_DWORD *)a4 + 15) = v42;
        *((_DWORD *)a4 + 5) = 0;
        *((_DWORD *)a4 + 6) = 0;
        *((_DWORD *)a4 + 4) = -v42;
        goto LABEL_27;
      }
      int v43 = *((_DWORD *)a4 + 16);
      int v45 = *((_DWORD *)a4 + 14);
      unsigned int v44 = *((_DWORD *)a4 + 15);
      *(_DWORD *)a4 = *((_DWORD *)a4 + 17);
      *(void *)(a4 + 4) = v44;
      *((_DWORD *)a4 + 5) = 0;
      *((_DWORD *)a4 + 6) = 0;
      *((_DWORD *)a4 + 4) = v43 - v45;
    }
  }
  ScalerGetFontTable(a2, 1886352244, 0, &v89, 1, 12);
  int v46 = (unsigned int *)v89;
  if (v89)
  {
    double v47 = (double)*(__int16 *)(v4 + 130) * 0.0000152587891;
    *(uint64_t *)((char *)v95.i64 + 4) = vcvtd_n_s64_f64((double)((int)bswap32(*(unsigned __int16 *)(v89 + 8)) >> 16)* 0.0000152587891/ v47, 0x10uLL);
    int v48 = bswap32(*(unsigned __int16 *)(v89 + 10));
    v95.i32[0] = 0;
    v95.i32[3] = vcvtd_n_s64_f64((double)(v48 >> 16) * 0.0000152587891 / v47, 0x10uLL);
    M3x3Mul(v13, v14, (int32x2_t *)&v95, (const int *)2);
    __int32 v49 = v95.i32[1];
    *((_DWORD *)a4 + 11) = bswap32(v46[1]);
    *((_DWORD *)a4 + 12) = v49;
    *((_DWORD *)a4 + 13) = *(_DWORD *)((unint64_t)&v95 | 0xC);
    ScalerReleaseFontTable(a2, v46);
    goto LABEL_31;
  }
LABEL_27:
  *((_DWORD *)a4 + 11) = 0;
  int v50 = *((_DWORD *)a4 + 1);
  int v51 = (*(_DWORD *)a4 - v50) / 20;
  *((_DWORD *)a4 + 13) = v51;
  if (a3) {
    int v52 = v50 - v51;
  }
  else {
    int v52 = v50 / 2;
  }
  *((_DWORD *)a4 + 12) = v52;
LABEL_31:
  *((_DWORD *)a4 + 3) = 0;
  *(void *)(a4 + 36) = 0;
  *(void *)(a4 + 28) = 0;
  v92[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  unsigned int FontTable = ScalerGetFontTable(a2, 1717859171, 0, v92, 1, 8);
  if (v92[0])
  {
    unint64_t v54 = (char *)v92[0] + FontTable;
    unsigned int v55 = bswap32(*((_DWORD *)v92[0] + 1));
    int v56 = (char *)v92[0] + 8 * v55 + 8;
    if ((char *)v92[0] + 16 <= v54) {
      unsigned int v57 = ((unint64_t)FontTable + 0x7FFFFFFF8) >> 3;
    }
    else {
      unsigned int v57 = 0;
    }
    if (v56 <= v54 && v56 >= (char *)v92[0] + 8) {
      unsigned int v59 = v55;
    }
    else {
      unsigned int v59 = v57;
    }
    if (v59)
    {
      int v60 = 0;
      int v61 = 0;
      unsigned int v62 = (unsigned int *)((char *)v92[0] + 12);
      do
      {
        unsigned int v63 = bswap32(*(v62 - 1));
        if (v63 == 1936486004)
        {
          int v61 = bswap32(*v62);
        }
        else if (v63 == 1851878502 && *v62)
        {
          v60 |= 4u;
        }
        v62 += 2;
        --v59;
      }
      while (v59);
    }
    else
    {
      int v61 = 0;
      int v60 = 0;
    }
    ScalerReleaseFontTable(a2, v92[0]);
  }
  else
  {
    int v61 = 0;
    int v60 = 0;
  }
  __int16 v97 = 0;
  uint64_t v96 = 0;
  v92[0] = 0;
  v92[1] = 0;
  LODWORD(v93) = 0;
  uint64_t v64 = *(void *)(a1 + 8);
  unsigned int v65 = *(_DWORD *)(v64 + 112);
  if (v65)
  {
    long long v91 = (void *)0xAAAAAAAAAAAAAAAALL;
    unsigned int TableParts = ScalerGetTableParts(a2, v65, 0, 0, &v91, 0);
    unsigned __int16 v67 = v91;
    long long v68 = (char *)v91 + TableParts;
    unsigned int v69 = *(unsigned __int16 *)(v64 + 146);
    if (v69 >= 0x64) {
      uint64_t v70 = 100;
    }
    else {
      uint64_t v70 = *(unsigned __int16 *)(v64 + 146);
    }
    long long v71 = (char *)v91 + 4 * v70;
    if (v71 < v91 || v71 > v68)
    {
      unint64_t v73 = (char *)v91 + 4 <= v68 ? (unint64_t)TableParts >> 2 : 0;
      if (v73 != v70)
      {
        long long v86 = __cxa_allocate_exception(2uLL);
        *long long v86 = 5;
        __cxa_throw(v86, MEMORY[0x1E4FBA3C8], 0);
      }
    }
    if (!v70)
    {
      long long v85 = __cxa_allocate_exception(2uLL);
      *long long v85 = 5;
      __cxa_throw(v85, MEMORY[0x1E4FBA3C8], 0);
    }
    int v74 = 0;
    long long v75 = v91;
    do
    {
      unsigned int v76 = __rev16((unsigned __int16)*v75);
      if (*v75)
      {
        uint64_t v77 = 0;
        while (*((unsigned __int16 *)&v96 + v77) != v76)
        {
          if (!*((_WORD *)&v96 + v77))
          {
            *((_WORD *)&v96 + v77) = v76;
            break;
          }
          if (++v77 == 5) {
            goto LABEL_76;
          }
        }
        ++*((_DWORD *)v92 + v77);
      }
LABEL_76:
      v75 += 2;
      ++v74;
    }
    while (v74 != v70);
    if (v69 <= 0x63)
    {
      uint64_t v78 = 0;
      LODWORD(v70) = *(unsigned __int16 *)(v64 + 40);
      if (v70 >= 0x64) {
        LODWORD(v70) = 100;
      }
      while (*((unsigned __int16 *)&v96 + v78) != v76)
      {
        if (++v78 == 5) {
          goto LABEL_84;
        }
      }
      *((_DWORD *)v92 + v78) += v70 - v69;
    }
LABEL_84:
    uint64_t v79 = 0;
    unsigned int v80 = 0;
    do
    {
      if (*(_DWORD *)((char *)v92 + v79) > v80) {
        unsigned int v80 = *(_DWORD *)((char *)v92 + v79);
      }
      v79 += 4;
    }
    while (v79 != 20);
    if (v70)
    {
      BOOL v81 = 100 * v80 / v70 < 0x60;
      ScalerReleaseFontTable(a2, v67);
      if (!v81) {
        v60 |= 1u;
      }
    }
    else
    {
      ScalerReleaseFontTable(a2, v67);
    }
  }
  if (!v61)
  {
    v92[0] = 0;
    if (!ScalerGetFontTable(a2, 1751474532, 0, v92, 1, 54)) {
      ScalerGetFontTable(a2, 1651008868, 0, v92, 1, 54);
    }
    if (v92[0])
    {
      int v82 = *((unsigned __int16 *)v92[0] + 22);
      ScalerReleaseFontTable(a2, v92[0]);
      int v61 = (v82 << 22 >> 31) & 0xF0000;
    }
    else
    {
      int v61 = 0;
    }
  }
  int v83 = v60 | 0x40;
  if (v61 < 786432) {
    int v83 = v60;
  }
  *((_DWORD *)a4 + 18) = v83;
  if (!*((_DWORD *)a4 + 11))
  {
    if (v61) {
      *((_DWORD *)a4 + 11) = -v61;
    }
  }
}

uint64_t TType1PSFont::SetEncoding(uint64_t this, __int32 *a2, const unsigned int *a3, unsigned __int16 *a4)
{
  v4.i32[1] = 0;
  *((_OWORD *)a3 + 30) = 0u;
  *((_OWORD *)a3 + 31) = 0u;
  *((_OWORD *)a3 + 28) = 0u;
  *((_OWORD *)a3 + 29) = 0u;
  *((_OWORD *)a3 + 26) = 0u;
  *((_OWORD *)a3 + 27) = 0u;
  *((_OWORD *)a3 + 24) = 0u;
  *((_OWORD *)a3 + 25) = 0u;
  *((_OWORD *)a3 + 22) = 0u;
  *((_OWORD *)a3 + 23) = 0u;
  *((_OWORD *)a3 + 20) = 0u;
  *((_OWORD *)a3 + 21) = 0u;
  *((_OWORD *)a3 + 18) = 0u;
  *((_OWORD *)a3 + 19) = 0u;
  *((_OWORD *)a3 + 16) = 0u;
  *((_OWORD *)a3 + 17) = 0u;
  *((_OWORD *)a3 + 14) = 0u;
  *((_OWORD *)a3 + 15) = 0u;
  *((_OWORD *)a3 + 12) = 0u;
  *((_OWORD *)a3 + 13) = 0u;
  *((_OWORD *)a3 + 10) = 0u;
  *((_OWORD *)a3 + 11) = 0u;
  *((_OWORD *)a3 + 8) = 0u;
  *((_OWORD *)a3 + 9) = 0u;
  *((_OWORD *)a3 + 6) = 0u;
  *((_OWORD *)a3 + 7) = 0u;
  *((_OWORD *)a3 + 4) = 0u;
  *((_OWORD *)a3 + 5) = 0u;
  *((_OWORD *)a3 + 2) = 0u;
  *((_OWORD *)a3 + 3) = 0u;
  *(_OWORD *)a3 = 0u;
  *((_OWORD *)a3 + 1) = 0u;
  if (a2)
  {
    if ((this + 31) >= 0x20)
    {
      unsigned int v5 = 0;
      unsigned int v11 = (this + 31) >> 5;
      float64x2_t v12 = a2;
      do
      {
        if (*v12)
        {
          v4.i32[0] = *v12;
          int8x8_t v4 = vcnt_s8(v4);
          v4.i16[0] = vaddlv_u8((uint8x8_t)v4);
          v5 += v4.i32[0];
        }
        ++v12;
        --v11;
      }
      while (v11);
      if (v5 > 0xFF) {
        unsigned int v5 = 256;
      }
    }
    else
    {
      unsigned int v5 = 0;
    }
    if (this && v5)
    {
      unsigned int v13 = 0;
      unsigned __int16 v14 = 0;
      unsigned __int16 v15 = 0;
      do
      {
        if (a2[v13 >> 5] << v13 < 0) {
          *((_WORD *)a3 + v15++) = v14;
        }
        unsigned int v13 = ++v14;
      }
      while (v14 < this && v5 > v15);
    }
  }
  else
  {
    if ((int)this >= 255) {
      int v6 = 255;
    }
    else {
      int v6 = (__int16)this;
    }
    if (v6 >= 1)
    {
      unsigned int v7 = (256 - v6) >> 1;
      int v8 = (256 - v6) >> 1;
      int v9 = v6 + v8;
      __int16 v10 = v7;
      do
      {
        *((_WORD *)a3 + v10) = v10 - v7;
        __int16 v10 = v8 + 1;
        int v8 = (__int16)(v8 + 1);
      }
      while (v8 < v9);
    }
  }
  return this;
}

uint64_t TType1PSFont::EvaluateCharCode(uint64_t this, unsigned __int8 **a2, const unsigned __int8 **a3, const unsigned __int8 *a4)
{
  if (this >= 0xF7)
  {
    int8x8_t v4 = *a2;
    if (this == 255 || v4 >= (unsigned __int8 *)a3)
    {
      if (v4 + 3 >= (unsigned __int8 *)a3)
      {
        return 0;
      }
      else
      {
        *a2 = v4 + 2;
        int v5 = v4[1];
        *a2 = v4 + 3;
        int v6 = v4[2];
        *a2 = v4 + 4;
        return (v5 << 24) | (v6 << 16) | (v4[3] << 8);
      }
    }
    else
    {
      *a2 = v4 + 1;
      return *v4 | (this << 8);
    }
  }
  return this;
}

void TType1PSFont::FastSearchForSeac(TType1PSFont *this, const unsigned __int8 *a2, int a3, unsigned __int8 *a4, __int16 *a5)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  v17[0] = 0;
  if (a3 < 1) {
    return;
  }
  int v7 = 0;
  int v8 = (const unsigned __int8 **)&a2[a3];
  while (1)
  {
    int v9 = a2 + 1;
    int v16 = (unsigned __int8 *)(a2 + 1);
    uint64_t v10 = *a2;
    if (v10 < 0x20) {
      break;
    }
    *(_DWORD *)((unint64_t)v17 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v7 & 1))) = TType1PSFont::EvaluateCharCode(v10, &v16, v8, a4);
    int v9 = v16;
    ++v7;
LABEL_10:
    a2 = v9;
    if (v9 >= (const unsigned __int8 *)v8) {
      return;
    }
  }
  if (v10 != 12 || v9 >= (const unsigned __int8 *)v8) {
    goto LABEL_10;
  }
  int v9 = a2 + 2;
  int v16 = (unsigned __int8 *)(a2 + 2);
  if (a2[1] != 6) {
    goto LABEL_10;
  }
  __int16 v12 = v17[0];
  unsigned int v13 = HIDWORD(v17[0]);
  __int16 v14 = LOWORD(v17[0]) + 2412;
  if (BYTE1(v17[0]) > 0xFAu) {
    __int16 v14 = -1388 - LOWORD(v17[0]);
  }
  if (LODWORD(v17[0]) <= 0xFF) {
    __int16 v14 = LOWORD(v17[0]) - 139;
  }
  if (LODWORD(v17[0]) < 0x10000) {
    __int16 v12 = v14;
  }
  *(_WORD *)a4 = v12;
  if (BYTE1(v13) <= 0xFAu) {
    __int16 v15 = v13 + 2412;
  }
  else {
    __int16 v15 = -1388 - v13;
  }
  if (v13 <= 0xFF) {
    __int16 v15 = v13 - 139;
  }
  if (v13 >= 0x10000) {
    __int16 v15 = v13;
  }
  *a5 = v15;
}

uint64_t TType1PSFont::PrinterIsBad(uint64_t this, const char *a2)
{
  *(void *)((char *)&v33[3] + 7) = *MEMORY[0x1E4F143B8];
  if (this)
  {
    uint64_t v2 = 0;
    do
    {
      if (v2 == 127) {
        break;
      }
      int v3 = *(unsigned __int8 *)(this + v2);
      TType1PSFont::PrinterIsBad(char const*)::gMMBugPrinter[v2++] = v3;
    }
    while (v3);
    int8x8_t v4 = &TType1PSFont::PrinterIsBad(char const*)::gMMBugPrinter[v2];
    uint64_t v5 = 0;
    *int8x8_t v4 = 0;
    memset(v33, 170, 31);
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v31[0] = v6;
    v31[1] = v6;
    _OWORD v30[2] = v6;
    v30[3] = v6;
    v30[0] = v6;
    v30[1] = v6;
    do
    {
      uint64_t v7 = v5;
      int v8 = *(unsigned __int8 *)(this + v5);
      if ((v8 & 0xFFFFFFDF) == 0)
      {
        int v9 = (char *)v33 + v7;
        goto LABEL_10;
      }
      *((unsigned char *)v33 + v7) = v8;
      uint64_t v5 = v7 + 1;
    }
    while (v7 != 30);
    int v9 = (char *)v33 + v5;
LABEL_10:
    uint64_t v10 = 0;
    unsigned int v11 = &v9[~(unint64_t)&v32];
    char v32 = (char)v11;
    do
    {
      uint64_t v12 = v10;
      int v13 = *(unsigned __int8 *)(this + v10 + v7 + 1);
      if ((v13 & 0xFFFFFFDF) == 0)
      {
        __int16 v14 = (char *)v31 + v12 + 1;
        goto LABEL_15;
      }
      *((unsigned char *)v31 + v12 + 1) = v13;
      uint64_t v10 = v12 + 1;
    }
    while (v12 != 30);
    __int16 v14 = (char *)v31 + v10 + 1;
LABEL_15:
    uint64_t v15 = 0;
    int v16 = &v14[~(unint64_t)v31];
    LOBYTE(v31[0]) = (_BYTE)v16;
    double v17 = (char *)(this + v7 + v12 + 2);
    while (1)
    {
      char v18 = *v17;
      if (!*v17) {
        break;
      }
      ++v17;
      *((unsigned char *)v30 + ++v15) = v18;
      if (v15 == 63)
      {
        int v19 = (char *)v31;
        goto LABEL_20;
      }
    }
    int v19 = (char *)v30 + v15 + 1;
LABEL_20:
    uint64_t v20 = 0;
    LOBYTE(v30[0]) = (_BYTE)v19 + ~(unint64_t)v30;
    size_t v21 = (char)v11;
    uint64_t v22 = (char)v11 + 1;
    size_t v23 = (char)v16;
    uint64_t v29 = (char)v16 + 1;
    size_t v24 = SLOBYTE(v30[0]);
    while (1)
    {
      int v25 = off_1E60E2028[v20] + 1;
      if (!memcmp(v33, v25, v21))
      {
        int v26 = &v25[v22];
        if (*v26 == 42)
        {
          uint64_t v27 = 2;
        }
        else
        {
          int v28 = memcmp((char *)v31 + 1, v26, v23);
          uint64_t v27 = v29;
          if (v28) {
            goto LABEL_26;
          }
        }
        if (!memcmp((char *)v30 + 1, &v26[v27], v24)) {
          return 1;
        }
      }
LABEL_26:
      if (++v20 == 6) {
        return 0;
      }
    }
  }
  return this;
}

uint64_t TType1PSFont::GetPSStreamType(TType1PSFont *this, int a2)
{
  if ((a2 & 0x22) != 0)
  {
    int v2 = 2;
  }
  else
  {
    if ((a2 & 0x200) == 0 || *(unsigned __int16 *)(*((void *)this + 4) + 150) >= 2u)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DFC400;
      exception[4] = 10;
    }
    int v2 = 512;
  }
  return v2 | a2 & 0xFFFFF000;
}

uint64_t TType1PSFont::SetupGlyphBits@<X0>(uint64_t this@<X0>, const unsigned int *a2@<X2>, void *a3@<X8>)
{
  if (a2)
  {
    unsigned int v3 = (*(uint64_t (**)(void))(**(void **)(this + 32) + 168))(*(void *)(this + 32));
    if (v3 >= 0xFFFF) {
      int v4 = 0xFFFF;
    }
    else {
      int v4 = v3;
    }
    if (v4) {
      operator new[]();
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  *a3 = 0;
  return this;
}

void sub_1B52FF8F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  MEMORY[0x1BA9994A0](v13, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t TStreamEncodingContext::TStreamEncodingContext(uint64_t a1, uint64_t a2, char a3, char a4)
{
  *(void *)a1 = &unk_1F0DFF190;
  std::vector<unsigned char>::vector((void *)(a1 + 8), 0x64uLL);
  *(void *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 48) = a4;
  *(unsigned char *)(a1 + 49) = a3;
  int v8 = *(unsigned char **)(a1 + 8);
  if (a4)
  {
    uint64_t v9 = 17;
    uint64_t v10 = "StandardEncoding\r";
    int v11 = 17;
    do
    {
      --v11;
      char v12 = *v10++;
      *v8++ = v12;
    }
    while ((_BYTE)v11);
  }
  else
  {
    uint64_t v9 = 50;
    uint64_t v13 = "256 array 0 1 255 {1 index exch /.notdef put} for\r";
    int v14 = 50;
    do
    {
      --v14;
      char v15 = *v13++;
      *v8++ = v15;
    }
    while ((_BYTE)v14);
  }
  *int v8 = 0;
  *(void *)(a1 + 40) = v9;
  return a1;
}

uint64_t TStreamEncodingContext::TStreamEncodingContext(uint64_t a1, uint64_t a2, char a3)
{
  *(void *)a1 = &unk_1F0DFF190;
  std::vector<unsigned char>::vector((void *)(a1 + 8), 0x1388uLL);
  *(void *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 49) = a3;
  int v6 = 50;
  uint64_t v7 = "256 array 0 1 255 {1 index exch /.notdef put} for\r";
  int v8 = *(unsigned char **)(a1 + 8);
  do
  {
    --v6;
    char v9 = *v7++;
    *v8++ = v9;
  }
  while ((_BYTE)v6);
  *int v8 = 0;
  *(void *)(a1 + 40) = 50;
  return a1;
}

uint64_t TStreamEncodingContext::AddEncodingText(uint64_t this, int a2, const char *a3)
{
  if (!*(unsigned char *)(this + 48))
  {
    uint64_t v5 = (void *)this;
    uint64_t v8 = *(void *)(this + 8);
    int v6 = (unint64_t *)(this + 8);
    uint64_t v7 = v8;
    unint64_t v9 = v6[4];
    uint64_t v10 = v6[1];
    unint64_t v11 = v10 - v8;
    if (v9 + 100 > v10 - v8)
    {
      if (v11 > 0xFFFFFFFFFFFFF63BLL)
      {
        uint64_t v10 = v11 + v7 + 2500;
        void v5[2] = v10;
      }
      else
      {
        std::vector<unsigned char>::__append(v6, 0x9C4uLL);
        unint64_t v9 = v5[5];
        uint64_t v7 = v5[1];
        uint64_t v10 = v5[2];
      }
    }
    this = snprintf_l((char *)(v7 + v9), v10 - v9 - v7, 0, "dup %d %.*s put\r", a2, *(unsigned __int8 *)a3, a3 + 1);
    v5[5] += (int)this;
  }
  return this;
}

uint64_t TStreamEncodingContext::DumpPSEncoding(TStreamEncodingContext *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (!*((unsigned char *)this + 49))
  {
    uint64_t v4 = *((void *)this + 1);
    unsigned int v3 = (unint64_t *)((char *)this + 8);
    unint64_t v5 = *((void *)this + 2) - v4;
    if (v2 + 13 > v5)
    {
      std::vector<unsigned char>::__append(v3, v2 + 13 - v5);
      uint64_t v4 = *((void *)this + 1);
      uint64_t v2 = *((void *)this + 5);
    }
    int v6 = (unsigned char *)(v4 + v2);
    int v7 = 13;
    uint64_t v8 = "readonly def\r";
    do
    {
      --v7;
      char v9 = *v8++;
      *v6++ = v9;
    }
    while ((_BYTE)v7);
    *int v6 = 0;
    uint64_t v2 = *((void *)this + 5) + 13;
    *((void *)this + 5) = v2;
  }
  uint64_t v10 = (uint64_t *)*((void *)this + 4);
  if (!v10 || (uint64_t v11 = *v10) == 0 || !*(_DWORD *)v11)
  {
    __int16 v13 = 9;
    goto LABEL_14;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, void))(v11 + 20))(*(void *)(v11 + 28), v2, *((void *)this + 1));
  if ((_WORD)result)
  {
    __int16 v13 = result;
LABEL_14:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = v13;
  }
  return result;
}

void TStreamEncodingContext::~TStreamEncodingContext(TStreamEncodingContext *this)
{
  *(void *)this = &unk_1F0DFF190;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0DFF190;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1BA9994D0);
}

void TType1PSFont::StreamEncoding(uint64_t a1, const void *a2, char a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(v7 + 88);
  if (v8)
  {
    unint64_t v9 = *(void *)(v7 + 96);
    memcpy(__dst, a2, sizeof(__dst));
    for (uint64_t i = 0; i != 29; ++i)
    {
      unint64_t v11 = kComponentCodes[i];
      if ((__int16)__dst[v11] == -1 && v9 > v11) {
        __dst[v11] = *(_WORD *)(v8 + 2 * v11);
      }
    }
    TType1PSFont::StreamEncodingData((void **)a1, (uint64_t)__dst, a3, a4);
  }
  else
  {
    TType1PSFont::StreamEncodingData((void **)a1, (uint64_t)a2, a3, a4);
  }
}

void TType1PSFont::StreamEncodingData(void **a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v13 = v6;
  long long v14 = v6;
  *(_OWORD *)__p = v6;
  TStreamEncodingContext::TStreamEncodingContext((uint64_t)__p, a4, a3);
  uint64_t v7 = 0;
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v30 = v8;
  long long v31 = v8;
  long long v28 = v8;
  long long v29 = v8;
  long long v26 = v8;
  long long v27 = v8;
  long long v24 = v8;
  long long v25 = v8;
  long long v22 = v8;
  long long v23 = v8;
  long long v20 = v8;
  long long v21 = v8;
  long long v18 = v8;
  long long v19 = v8;
  *(_OWORD *)int v16 = v8;
  long long v17 = v8;
  do
  {
    uint64_t v9 = *(unsigned __int16 *)(a2 + 2 * v7);
    if (*(_WORD *)(a2 + 2 * v7))
    {
      unsigned int v10 = (*(uint64_t (**)(void *))(*a1[4] + 168))(a1[4]);
      unsigned int v11 = v10 >= 0xFFFF ? 0xFFFF : v10;
      if (v9 < v11)
      {
        ((void (*)(void **, uint64_t, unsigned __int8 *))(*a1)[29])(a1, v9, v16);
        TStreamEncodingContext::AddEncodingText((uint64_t)__p, v7, (const char *)v16);
      }
    }
    ++v7;
  }
  while (v7 != 256);
  TStreamEncodingContext::DumpPSEncoding((TStreamEncodingContext *)__p);
  __p[0] = &unk_1F0DFF190;
  if (__p[1])
  {
    *(void **)&long long v13 = __p[1];
    operator delete(__p[1]);
  }
}

void sub_1B52FFFD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TType1PSFont::StreamPSEncoding(void **a1, unsigned int *a2, uint64_t a3, char a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    long long v8 = (uint64_t (*)(void))(*a1)[31];
    return v8();
  }
  else
  {
    uint64_t v13 = ((uint64_t (*)(void **, void))(*a1)[6])(a1, *a5);
    *a5 = v13;
    unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
    ((void (*)(unint64_t *__return_ptr, void **, uint64_t, uint64_t))(*a1)[30])(&v18, a1, v13, a3);
    long long v14 = (__int32 *)v18;
    *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v49 = v15;
    long long v50 = v15;
    long long v47 = v15;
    long long v48 = v15;
    long long v45 = v15;
    long long v46 = v15;
    long long v43 = v15;
    long long v44 = v15;
    long long v41 = v15;
    long long v42 = v15;
    long long v39 = v15;
    long long v40 = v15;
    long long v37 = v15;
    long long v38 = v15;
    long long v35 = v15;
    long long v36 = v15;
    long long v33 = v15;
    long long v34 = v15;
    long long v31 = v15;
    long long v32 = v15;
    long long v29 = v15;
    long long v30 = v15;
    long long v27 = v15;
    long long v28 = v15;
    long long v25 = v15;
    long long v26 = v15;
    long long v23 = v15;
    long long v24 = v15;
    long long v21 = v15;
    long long v22 = v15;
    *(_OWORD *)long long v19 = v15;
    long long v20 = v15;
    if (!a2)
    {
      LODWORD(v16) = (*(uint64_t (**)(void *))(*a1[4] + 168))(a1[4]);
      if (v16 >= 0xFFFF) {
        uint64_t v16 = 0xFFFFLL;
      }
      else {
        uint64_t v16 = v16;
      }
      a2 = v19;
      TType1PSFont::SetEncoding(v16, v14, v19, v17);
    }
    ((void (*)(void **, unsigned int *, uint64_t, uint64_t))(*a1)[32])(a1, a2, 1, a6);
    uint64_t result = v18;
    unint64_t v18 = 0;
    if (result) {
      return MEMORY[0x1BA9994A0](result, 0x1000C8052888210);
    }
  }
  return result;
}

void sub_1B530025C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

uint64_t TType1PSFont::StreamReEncodeFont(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned __int8 *a4, uint64_t *a5)
{
  if (!a5) {
    goto LABEL_25;
  }
  uint64_t v6 = *a5;
  if (!*a5 || !*(_DWORD *)v6) {
    goto LABEL_25;
  }
  LOWORD(result) = (*(uint64_t (**)(void, uint64_t, void *))(v6 + 20))(*(void *)(v6 + 28), 2, &kCRAndSlash);
  if ((_WORD)result)
  {
LABEL_31:
    __int16 v21 = result;
    goto LABEL_32;
  }
  uint64_t v12 = *a5;
  if (!*a5 || !*(_DWORD *)v12) {
    goto LABEL_24;
  }
  __int16 v13 = (*(uint64_t (**)(void, void, unsigned __int8 *))(v12 + 20))(*(void *)(v12 + 28), *a3, a3 + 1);
  if (v13) {
    goto LABEL_27;
  }
  uint64_t v14 = *a5;
  if (!*a5 || !*(_DWORD *)v14) {
    goto LABEL_24;
  }
  __int16 v13 = (*(uint64_t (**)(void, uint64_t, char *))(v14 + 20))(*(void *)(v14 + 28), 9, " findfont");
  if (v13)
  {
LABEL_27:
    __int16 v20 = v13;
    goto LABEL_28;
  }
  uint64_t v15 = *a5;
  if (!*a5 || !*(_DWORD *)v15)
  {
LABEL_24:
    __int16 v20 = 9;
LABEL_28:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = v20;
    goto LABEL_33;
  }
  __int16 v13 = (*(uint64_t (**)(void, uint64_t, void *))(v15 + 20))(*(void *)(v15 + 28), 2, &kCRAndSlash);
  if (v13) {
    goto LABEL_27;
  }
  uint64_t v16 = *a5;
  if (!*a5 || !*(_DWORD *)v16) {
    goto LABEL_26;
  }
  __int16 v17 = (*(uint64_t (**)(void, void, unsigned __int8 *))(v16 + 20))(*(void *)(v16 + 28), *a4, a4 + 1);
  if (v17)
  {
LABEL_29:
    __int16 v22 = v17;
    goto LABEL_30;
  }
  uint64_t v18 = *a5;
  if (!*a5 || !*(_DWORD *)v18)
  {
LABEL_26:
    __int16 v22 = 9;
LABEL_30:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = v22;
    goto LABEL_33;
  }
  __int16 v17 = (*(uint64_t (**)(void, uint64_t, void *))(v18 + 20))(*(void *)(v18 + 28), 1, &kCRAndSlash);
  if (v17) {
    goto LABEL_29;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 256))(a1, a2, 1, a5);
  uint64_t v19 = *a5;
  if (!*a5 || !*(_DWORD *)v19)
  {
LABEL_25:
    __int16 v21 = 9;
LABEL_32:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = v21;
LABEL_33:
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, const char *))(v19 + 20))(*(void *)(v19 + 28), 207, "3 -1 roll dup length dict exch {exch dup dup /FID ne exch /Encoding ne and {2 index 3 1 roll exch put} {pop pop} ifelse} forall\rdup 3 -1 roll /Encoding exch put 2 copy exch /FontName exch put definefont pop\r");
  if ((_WORD)result) {
    goto LABEL_31;
  }
  return result;
}

unsigned __int8 *TType1PSFont::GetStandardEncoding(unsigned __int8 *this, unsigned __int16 *a2)
{
  if (a2)
  {
    uint64_t v3 = (uint64_t)this;
    for (uint64_t i = 0; i != 256; ++i)
    {
      if ((_BYTE)i)
      {
        this = (unsigned __int8 *)TParsingContext::GetStandardEncodeName((TParsingContext *)i);
        if (this) {
          this = (unsigned __int8 *)(*(uint64_t (**)(uint64_t, unsigned __int8 *, void))(*(void *)v3 + 192))(v3, this + 1, *this);
        }
      }
      else
      {
        this = 0;
      }
      a2[i] = (unsigned __int16)this;
    }
  }
  return this;
}

uint64_t TType1PSFont::GetFontEncoding(TType1PSFont *this, unsigned __int16 *a2)
{
  *(_OWORD *)__p = 0u;
  long long v31 = 0u;
  int v24 = 1;
  uint64_t v26 = 0;
  uint64_t v25 = 0;
  long long v27 = LocalStreamer;
  long long v28 = __p;
  __int16 v29 = 0;
  long long v23 = &v24;
  (*(void (**)(TType1PSFont *, int **))(*(void *)this + 248))(this, &v23);
  if (a2)
  {
    bzero(a2, 0x200uLL);
    uint64_t v4 = (char *)__p[1];
    *((unsigned char *)__p[1] + (unint64_t)__p[0]) = 0;
    if (strstr(v4, "StandardEncoding"))
    {
      __int16 v21 = 23;
LABEL_33:
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DFC400;
      exception[4] = v21;
    }
    unint64_t v5 = strstr(v4, "dup");
    if (v5)
    {
      while (1)
      {
        uint64_t v6 = 0;
        *(_DWORD *)long long v32 = -1431655766;
        uint64_t v7 = v5 + 3;
        long long v8 = v32;
        while (1)
        {
          uint64_t v9 = &v5[v6];
          int v10 = v5[v6 + 3];
          if (!v5[v6 + 3] || v10 == 47) {
            break;
          }
          if ((char)v10 >= 33)
          {
            if ((v10 - 48) > 9) {
              break;
            }
            if (v8 - v32 <= 2) {
              *v8++ = v10;
            }
          }
          ++v6;
          ++v7;
        }
        *long long v8 = 0;
        if (!v32[0])
        {
          if (v6 == -3) {
            uint64_t v15 = v5 + 1;
          }
          else {
            uint64_t v15 = v5;
          }
          unsigned int v11 = &v15[v6 + 3];
          goto LABEL_28;
        }
        unsigned int v11 = v9 + 3;
        if (v9[3] == 47) {
          break;
        }
        uint64_t v12 = 0;
        if (v9[3]) {
          goto LABEL_23;
        }
LABEL_24:
        unsigned __int16 v16 = atoi(v32);
        if ((v16 & 0xFF00) != 0)
        {
          __int16 v21 = 5;
          goto LABEL_33;
        }
        uint64_t v17 = v16;
        a2[v16] = 0;
        if (v12)
        {
          size_t v18 = strlen(v12);
          int v19 = (*(uint64_t (**)(TType1PSFont *, const char *, size_t))(*(void *)this + 192))(this, v12, v18);
          if (v19 != 0xFFFF) {
            a2[v17] = v19;
          }
        }
LABEL_28:
        unint64_t v5 = strstr(v11, "dup");
        if (!v5) {
          goto LABEL_29;
        }
      }
      uint64_t v12 = &v5[v6 + 4];
      do
      {
        int v14 = *++v7;
        char v13 = v14;
      }
      while (v14 > 32);
      unsigned int v11 = v7;
      if (!v13) {
        goto LABEL_24;
      }
LABEL_23:
      *v11++ = 0;
      goto LABEL_24;
    }
  }
LABEL_29:
  if (__p[1])
  {
    *(void **)&long long v31 = __p[1];
    operator delete(__p[1]);
  }
  return 1;
}

void sub_1B5300844(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1B53007BCLL);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LocalStreamer(void *a1, size_t __len, void *__src)
{
  if (!__len) {
    return 0;
  }
  if (!__src) {
    return 8;
  }
  unsigned int v4 = __len;
  uint64_t v6 = *a1;
  unint64_t v7 = *a1 + __len + 1;
  uint64_t v10 = a1[1];
  long long v8 = (std::vector<char> *)(a1 + 1);
  uint64_t v9 = v10;
  unint64_t v11 = a1[2] - v10;
  if (v7 > v11)
  {
    std::vector<char>::__append(v8, v7 - v11);
    uint64_t v6 = *a1;
    uint64_t v9 = a1[1];
  }
  memmove((void *)(v9 + v6), __src, v4);
  uint64_t result = 0;
  *a1 += v4;
  return result;
}

void sub_1B530091C(void *a1)
{
}

size_t TType1PSFont::FindValueForKey(TType1PSFont *this, const char *a2, const char *a3, _DWORD *a4, unsigned int *a5, unsigned int *a6)
{
  long long v8 = a2;
  uint64_t v10 = &a2[a3];
  size_t result = strlen((const char *)this);
  uint64_t v12 = (TType1PSFont *)((char *)this + result);
  int v13 = ~v8;
  do
  {
    if (v8 >= v10)
    {
      *a5 = -1;
      return result;
    }
    int v14 = (int)v8;
    uint64_t v15 = this;
    while (1)
    {
      unsigned __int16 v16 = v15;
      if (v15 >= v12) {
        break;
      }
      int v17 = *(unsigned __int8 *)v8++;
      uint64_t v15 = (TType1PSFont *)((char *)v15 + 1);
      ++v14;
      if (v17 != *(unsigned __int8 *)v16) {
        goto LABEL_25;
      }
    }
    do
    {
      int v18 = *v8++;
      ++v14;
    }
    while (v18 < 33);
    *a4 = v13 + v14;
    if ((*(v8 - 1) & 0xDF) != 0x5B)
    {
      do
        int v23 = *v8++;
      while (v23 > 32);
      goto LABEL_22;
    }
    if (v8 >= v10) {
      goto LABEL_21;
    }
    int v19 = 1;
    __int16 v20 = v8;
    while (1)
    {
      int v21 = *(unsigned __int8 *)v20++;
      unsigned int v22 = v21 & 0xFFFFFFDF;
      if ((v21 & 0xFFFFFFDF) != 0x5D)
      {
        if (v22 == 91) {
          ++v19;
        }
        goto LABEL_16;
      }
      if (!--v19) {
        break;
      }
LABEL_16:
      long long v8 = v20;
      if (v20 >= v10)
      {
        long long v8 = v10;
        goto LABEL_21;
      }
    }
    ++v8;
LABEL_21:
    if (++v8 >= v10) {
      unsigned int v24 = -1;
    }
    else {
LABEL_22:
    }
      unsigned int v24 = v8 - v14;
    *a5 = v24;
LABEL_25:
    ;
  }
  while (v16 < v12);
  return result;
}

size_t TType1PSFont::FindNameRange(TType1PSFont *this, const char *a2, _DWORD *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  size_t result = TType1PSFont::FindValueForKey((TType1PSFont *)"/FontName", (const char *)this, a2, a3, a4, a6);
  if (*a4 != -1)
  {
    ++*a3;
    --*a4;
  }
  return result;
}

const unsigned __int8 *TType1PSFont::ScanForKey(TType1PSFont *this, char *a2, const unsigned __int8 *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  int v9 = (int)a2;
  int v13 = (unsigned __int8 *)a2;
  size_t result = FindKey((const char *)this, *(_DWORD *)a3, (const unsigned __int8 **)&v13);
  if (!result)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  int v11 = (int)v13;
  *a4 = v13 - v9;
  *a5 = result - v11;
  *(_DWORD *)a3 -= *a4;
  return result;
}

const unsigned __int8 *FindKey(const char *a1, int a2, const unsigned __int8 **a3)
{
  uint64_t v6 = *a3;
  size_t v7 = strlen(a1);
  if (a2)
  {
    unint64_t v8 = (unint64_t)&v6[a2];
    int v9 = v6;
    do
    {
      size_t v10 = v7;
      int v11 = a1;
      while ((unint64_t)v9 < v8)
      {
        if (*v9 != *v11)
        {
          ++v9;
          break;
        }
        ++v11;
        ++v9;
        if (!--v10) {
          return &v6[v7];
        }
      }
      *a3 = v9;
      uint64_t v6 = v9;
    }
    while ((unint64_t)v9 < v8);
  }
  return 0;
}

void TBufferedStreamingContext::TBufferedStreamingContext(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = &unk_1F0DFF1B0;
  a1[1] = a2;
  a1[2] = a3;
  a1[3] = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
  a1[4] = a4;
  operator new[]();
}

void TBufferedStreamingContext::~TBufferedStreamingContext(TBufferedStreamingContext *this)
{
  *(void *)this = &unk_1F0DFF1B0;
  if (!*((_WORD *)this + 32)) {
    TBufferedStreamingContext::StreamBuffer((uint64_t)this);
  }
  uint64_t v2 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v2) {
    MEMORY[0x1BA9994A0](v2, 0x1000C8077774924);
  }
}

{
  uint64_t vars8;

  TBufferedStreamingContext::~TBufferedStreamingContext(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TBufferedStreamingContext::StreamBuffer(uint64_t this)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!*(_WORD *)(this + 64))
  {
    uint64_t v1 = this;
    if (*(unsigned char *)(this + 63))
    {
      *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v24[14] = v2;
      v24[15] = v2;
      v24[12] = v2;
      v24[13] = v2;
      v24[10] = v2;
      v24[11] = v2;
      v24[8] = v2;
      v24[9] = v2;
      _OWORD v24[6] = v2;
      unsigned char v24[7] = v2;
      v24[4] = v2;
      v24[5] = v2;
      uint64_t v24[2] = v2;
      int32x2_t v24[3] = v2;
      v24[0] = v2;
      v24[1] = v2;
      uint64_t v3 = *(void *)(this + 48);
      if (v3 >= 1)
      {
        unsigned int v4 = 0;
        uint64_t v5 = *(void *)(this + 40);
        unint64_t v6 = v5 + v3;
        unint64_t v7 = v5 + 1;
        unint64_t v8 = v24;
        do
        {
          while (1)
          {
            unint64_t v9 = *(unsigned __int8 *)(v7 - 1);
            char v10 = kHexChar[v9 >> 4];
            LOBYTE(v9) = kHexChar[v9 & 0xF];
            *unint64_t v8 = v10;
            v8[1] = v9;
            LODWORD(v9) = *(_DWORD *)(v1 + 56) + 1;
            *(_DWORD *)(v1 + 56) = v9;
            if (v9 < 0x30)
            {
              v8 += 2;
              v4 += 2;
            }
            else
            {
              *(_DWORD *)(v1 + 56) = 0;
              v8[2] = 13;
              v8 += 3;
              v4 += 3;
            }
            if (v4 < 0xFE) {
              break;
            }
            int v11 = *(uint64_t **)(v1 + 32);
            if (!v11 || (uint64_t v12 = *v11) == 0 || !*(_DWORD *)v12)
            {
              __int16 v13 = 9;
LABEL_30:
              exception = __cxa_allocate_exception(0x10uLL);
              *(void *)exception = &unk_1F0DFC400;
              exception[4] = v13;
            }
            this = (*(uint64_t (**)(void))(v12 + 20))(*(void *)(v12 + 28));
            __int16 v13 = this;
            if ((_WORD)this) {
              goto LABEL_30;
            }
            unsigned int v4 = 0;
            unint64_t v8 = v24;
            BOOL v14 = v7++ >= v6;
            if (v14) {
              goto LABEL_27;
            }
          }
          BOOL v14 = v7++ >= v6;
        }
        while (!v14);
        uint64_t v15 = *(uint64_t **)(v1 + 32);
        if (!v15 || (uint64_t v16 = *v15) == 0 || !*(_DWORD *)v16)
        {
          __int16 v17 = 9;
          goto LABEL_34;
        }
        this = (*(uint64_t (**)(void))(v16 + 20))(*(void *)(v16 + 28));
        __int16 v17 = this;
        if ((_WORD)this)
        {
LABEL_34:
          int v23 = __cxa_allocate_exception(0x10uLL);
          *(void *)int v23 = &unk_1F0DFC400;
          _OWORD v23[4] = v17;
        }
      }
      goto LABEL_27;
    }
    int v18 = *(uint64_t **)(this + 32);
    if (v18 && (uint64_t v19 = *v18) != 0 && *(_DWORD *)v19)
    {
      this = (*(uint64_t (**)(void, void, void))(v19 + 20))(*(void *)(v19 + 28), *(unsigned int *)(this + 48), *(void *)(this + 40));
      __int16 v20 = this;
      if (!(_WORD)this)
      {
LABEL_27:
        *(void *)(v1 + 48) = 0;
        return this;
      }
    }
    else
    {
      __int16 v20 = 9;
    }
    unsigned int v22 = __cxa_allocate_exception(0x10uLL);
    *(void *)unsigned int v22 = &unk_1F0DFC400;
    _OWORD v22[4] = v20;
  }
  return this;
}

void sub_1B5301000(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    uint64_t v3 = __cxa_begin_catch(exception_object);
    *(_WORD *)(v2 + 64) = v3[4];
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = v3[4];
  }
  _Unwind_Resume(exception_object);
}

void sub_1B5301080(_Unwind_Exception *a1)
{
}

void sub_1B530108C(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1B5301094);
  }
  __clang_call_terminate(a1);
}

char *TBufferedStreamingContext::StreamSubstituteHeaderComment(TBufferedStreamingContext *this, const char *a2, char *__s1, unsigned int *a4)
{
  uint64_t v5 = __s1;
  if (!strncmp(__s1, "%!", 2uLL))
  {
    TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"%!FontType1-1.0: ", 0x11uLL);
    size_t v8 = strlen(a2);
    TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)a2, v8);
    unsigned __int8 v16 = 32;
    TBufferedStreamingContext::BufferString((uint64_t)this, &v16, 1uLL);
    TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"001.003", 7uLL);
    unsigned __int8 v17 = 13;
    TBufferedStreamingContext::BufferString((uint64_t)this, &v17, 1uLL);
    unint64_t v9 = &v5[*a4];
    while (v5 < v9)
    {
      int v11 = *v5++;
      int v10 = v11;
      if (v11 == 13 || v10 == 10)
      {
        if (v5 < v9)
        {
          int v13 = *v5;
          if (v13 == 13 || v13 == 10) {
            ++v5;
          }
        }
        break;
      }
    }
    *a4 = v9 - v5;
  }
  return v5;
}

uint64_t TBufferedStreamingContext::BufferString(uint64_t this, const unsigned __int8 *a2, unint64_t a3)
{
  if (a3)
  {
    unint64_t v3 = a3;
    uint64_t v5 = this;
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(v5 + 48);
      if (1024 - v7 >= v3) {
        size_t v8 = v3;
      }
      else {
        size_t v8 = 1024 - v7;
      }
      if (*(unsigned char *)(v5 + 62))
      {
        __int16 v9 = *(_WORD *)(v5 + 60);
        if (v8)
        {
          int v10 = (unsigned char *)(*(void *)(v5 + 40) + v7);
          int v11 = &a2[v6];
          size_t v12 = v8;
          do
          {
            char v13 = *v11++;
            char v14 = HIBYTE(v9);
            __int16 v9 = 22719 - 12691 * (v9 + (v13 ^ ((unsigned __int16)(v9 & 0xFF00) >> 8)));
            *v10++ = v13 ^ v14;
            --v12;
          }
          while (v12);
        }
        *(_WORD *)(v5 + 60) = v9;
      }
      else
      {
        this = (uint64_t)memcpy((void *)(*(void *)(v5 + 40) + v7), &a2[v6], v8);
      }
      size_t v15 = *(void *)(v5 + 48) + v8;
      *(void *)(v5 + 48) = v15;
      if (v15 == 1024) {
        this = TBufferedStreamingContext::StreamBuffer(v5);
      }
      v6 += v8;
      v3 -= v8;
    }
    while (v3);
  }
  return this;
}

BOOL TBufferedStreamingContext::StreamTillSubstitutedFontName(TBufferedStreamingContext *this, const char *a2, const unsigned __int8 **a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  unsigned int v15 = -1431655766;
  LODWORD(v16) = -1431655766;
  TType1PSFont::FindNameRange((TType1PSFont *)*a3, (const char *)*a4, &v16, &v15, a5, a6);
  unsigned int v10 = v15;
  if (v15 != -1)
  {
    int v11 = v16;
    TBufferedStreamingContext::BufferString((uint64_t)this, *a3, v16);
    size_t v12 = strlen(a2);
    TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)a2, v12);
    uint64_t v13 = v11 + v10;
    *a3 += v13;
    *a4 -= v13;
  }
  return v10 != -1;
}

uint64_t TBufferedStreamingContext::BeginEexec(TBufferedStreamingContext *this, int a2, char a3)
{
  char v4 = a2;
  if (a2)
  {
    TBufferedStreamingContext::BufferString((uint64_t)this, "currentfile eexec\r", 0x12uLL);
    TBufferedStreamingContext::StreamBuffer((uint64_t)this);
    *((unsigned char *)this + 62) = v4;
    *((unsigned char *)this + 63) = a3;
    *((_DWORD *)this + 14) = 0;
    *((_WORD *)this + 30) = -9871;
    *(_DWORD *)uint64_t v7 = 0;
    return TBufferedStreamingContext::BufferString((uint64_t)this, v7, 4uLL);
  }
  else
  {
    uint64_t result = TBufferedStreamingContext::StreamBuffer((uint64_t)this);
    *((unsigned char *)this + 62) = v4;
    *((unsigned char *)this + 63) = a3;
    *((_DWORD *)this + 14) = 0;
    *((_WORD *)this + 30) = -9871;
  }
  return result;
}

uint64_t TBufferedStreamingContext::EndEexec(uint64_t this)
{
  if (!*(_WORD *)(this + 64))
  {
    uint64_t v1 = this;
    if (*(unsigned char *)(this + 62)) {
      TBufferedStreamingContext::BufferString(this, (const unsigned __int8 *)"mark currentfile closefile\r", 0x1BuLL);
    }
    this = TBufferedStreamingContext::StreamBuffer(v1);
    *(unsigned char *)(v1 + 63) = 0;
    if (*(unsigned char *)(v1 + 62))
    {
      *(unsigned char *)(v1 + 62) = 0;
      if (*(_DWORD *)(v1 + 56))
      {
        unsigned __int8 v4 = 13;
        TBufferedStreamingContext::BufferString(v1, &v4, 1uLL);
      }
      unsigned int v2 = 0;
      do
        TBufferedStreamingContext::BufferString(v1, (const unsigned __int8 *)"0000000000000000000000000000000000000000000000000000000000000000\r", 0x41uLL);
      while (v2++ < 7);
      return TBufferedStreamingContext::BufferString(v1, "cleartomark\r", 0xCuLL);
    }
  }
  return this;
}

uint64_t TBufferedStreamingContext::BufferPSString(TBufferedStreamingContext *this, const unsigned __int8 *a2, int a3)
{
  unsigned __int8 v17 = 40;
  TBufferedStreamingContext::BufferString((uint64_t)this, &v17, 1uLL);
  for (; a3; --a3)
  {
    unsigned int v7 = *a2++;
    unsigned int v6 = v7;
    if (v7 - 32 > 0x5E)
    {
      char v16 = -86;
      __int16 v15 = -21846;
      uint64_t v12 = 3;
      unsigned __int8 v14 = 92;
      do
      {
        *(&v14 + v12) = v6 & 7 | 0x30;
        v6 >>= 3;
        --v12;
      }
      while (v12);
      __int16 v9 = &v14;
      unsigned int v10 = this;
      unint64_t v11 = 4;
    }
    else
    {
      if (v6 - 40 <= 0x34 && ((1 << (v6 - 40)) & 0x10000000000003) != 0)
      {
        unsigned __int8 v18 = 92;
        TBufferedStreamingContext::BufferString((uint64_t)this, &v18, 1uLL);
      }
      char v19 = v6;
      __int16 v9 = (unsigned __int8 *)&v19;
      unsigned int v10 = this;
      unint64_t v11 = 1;
    }
    TBufferedStreamingContext::BufferString((uint64_t)v10, v9, v11);
  }
  unsigned __int8 v20 = 41;
  return TBufferedStreamingContext::BufferString((uint64_t)this, &v20, 1uLL);
}

uint64_t TBufferedStreamingContext::BufferInt(TBufferedStreamingContext *this, unsigned int a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v10 = -1431655766;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v2 = (unint64_t *)&v8;
  do
  {
    *((unsigned char *)v2 + 1) = (a2 % 0xA) | 0x30;
    unsigned int v2 = (unint64_t *)((char *)v2 + 1);
    BOOL v3 = a2 > 9;
    a2 /= 0xAu;
  }
  while (v3);
  unsigned __int8 v4 = (const unsigned __int8 *)this + 67;
  LOBYTE(v5) = (_BYTE)this + 67;
  if (v2 >= &v9)
  {
    uint64_t v5 = (char *)this + 67;
    do
    {
      char v6 = *(unsigned char *)v2;
      unsigned int v2 = (unint64_t *)((char *)v2 - 1);
      *v5++ = v6;
    }
    while (v2 >= &v9);
  }
  *((unsigned char *)this + 66) = (_BYTE)v5 - (_BYTE)v4;
  return TBufferedStreamingContext::BufferString((uint64_t)this, v4, ((_BYTE)v5 - (_BYTE)v4));
}

uint64_t TBufferedStreamingContext::BufferUnitEmFixed(TBufferedStreamingContext *this, int a2)
{
  unsigned __int8 v6 = 32;
  TBufferedStreamingContext::BufferString((uint64_t)this, &v6, 1uLL);
  FixedToPString(a2 / 1000, 3, (unsigned __int8 *)this + 66);
  unint64_t v4 = *((unsigned __int8 *)this + 66);
  return TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)this + 67, v4);
}

void TBufferedCharStringStreamingContext::TBufferedCharStringStreamingContext(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B5301868(_Unwind_Exception *a1)
{
  unint64_t v4 = *v2;
  if (*v2)
  {
    *((void *)v1 + 18) = v4;
    operator delete(v4);
  }
  TBufferedStreamingContext::~TBufferedStreamingContext(v1);
  _Unwind_Resume(a1);
}

void TBufferedCharStringStreamingContext::~TBufferedCharStringStreamingContext(TBufferedCharStringStreamingContext *this)
{
  *(void *)this = &unk_1F0DFF1D0;
  unsigned int v2 = (void *)*((void *)this + 17);
  if (v2)
  {
    *((void *)this + 18) = v2;
    operator delete(v2);
  }
  TBufferedStreamingContext::~TBufferedStreamingContext(this);
}

uint64_t TBufferedCharStringStreamingContext::BufferBlueValues(uint64_t this, const unsigned __int8 *a2, int a3)
{
  uint64_t v3 = *(void *)(this + 24);
  int v4 = *(unsigned __int16 *)(v3 + 66);
  if (!*(_WORD *)(v3 + 66)) {
    return this;
  }
  uint64_t v7 = this;
  int v8 = 0;
  uint64_t v9 = this + 320;
  unsigned __int8 v17 = (unsigned __int8 *)(a2 + 1);
  int v10 = (unsigned __int8 *)(this + 66);
  uint64_t v11 = (const unsigned __int8 *)(this + 67);
  int v12 = 1;
  char v13 = 1;
  while (2)
  {
    v9 += 8;
    int v14 = v12;
    while (1)
    {
      int v12 = 2 * v14;
      if (!(_WORD)v8) {
        break;
      }
      if (((*(_DWORD *)(v3 + 32) & v14) == 0) != a3) {
        goto LABEL_10;
      }
LABEL_8:
      ++v8;
      v9 += 8;
      v14 *= 2;
      if (v4 <= (__int16)v8)
      {
        if (v13) {
          return this;
        }
        goto LABEL_19;
      }
    }
    if (a3) {
      goto LABEL_8;
    }
LABEL_10:
    if (v13) {
      TBufferedStreamingContext::BufferString(v7, v17, *a2);
    }
    signed int v15 = *(_DWORD *)(v9 - 8);
    if (*(_DWORD *)(v9 - 4) >= v15) {
      unsigned int v16 = *(_DWORD *)(v9 - 8);
    }
    else {
      unsigned int v16 = *(_DWORD *)(v9 - 4);
    }
    FixedToPString(v16, 3, v10);
    TBufferedStreamingContext::BufferString(v7, v11, *(unsigned __int8 *)(v7 + 66));
    unsigned __int8 v18 = 32;
    TBufferedStreamingContext::BufferString(v7, &v18, 1uLL);
    FixedToPString(v15, 3, v10);
    TBufferedStreamingContext::BufferString(v7, v11, *(unsigned __int8 *)(v7 + 66));
    unsigned __int8 v19 = 32;
    this = TBufferedStreamingContext::BufferString(v7, &v19, 1uLL);
    char v13 = 0;
    uint64_t v3 = *(void *)(v7 + 24);
    ++v8;
    int v4 = *(unsigned __int16 *)(v3 + 66);
    if (v4 > (__int16)v8) {
      continue;
    }
    break;
  }
LABEL_19:
  return TBufferedStreamingContext::BufferString(v7, "] def\r", 6uLL);
}

uint64_t TBufferedCharStringStreamingContext::BufferFamilyBlues(uint64_t this, const unsigned __int8 *a2, int a3)
{
  uint64_t v3 = *(void *)(this + 24);
  int v4 = *(unsigned __int16 *)(v3 + 68);
  if (!*(_WORD *)(v3 + 68)) {
    return this;
  }
  uint64_t v7 = this;
  int v8 = 0;
  uint64_t v9 = this + 416;
  unsigned __int8 v17 = (unsigned __int8 *)(a2 + 1);
  int v10 = (unsigned __int8 *)(this + 66);
  uint64_t v11 = (const unsigned __int8 *)(this + 67);
  int v12 = 1;
  char v13 = 1;
  while (2)
  {
    v9 += 8;
    int v14 = v12;
    while (1)
    {
      int v12 = 2 * v14;
      if (!(_WORD)v8) {
        break;
      }
      if (((*(_DWORD *)(v3 + 36) & v14) == 0) != a3) {
        goto LABEL_10;
      }
LABEL_8:
      ++v8;
      v9 += 8;
      v14 *= 2;
      if (v4 <= (__int16)v8)
      {
        if (v13) {
          return this;
        }
        goto LABEL_19;
      }
    }
    if (a3) {
      goto LABEL_8;
    }
LABEL_10:
    if (v13) {
      TBufferedStreamingContext::BufferString(v7, v17, *a2);
    }
    signed int v15 = *(_DWORD *)(v9 - 8);
    if (*(_DWORD *)(v9 - 4) >= v15) {
      unsigned int v16 = *(_DWORD *)(v9 - 8);
    }
    else {
      unsigned int v16 = *(_DWORD *)(v9 - 4);
    }
    FixedToPString(v16, 3, v10);
    TBufferedStreamingContext::BufferString(v7, v11, *(unsigned __int8 *)(v7 + 66));
    unsigned __int8 v18 = 32;
    TBufferedStreamingContext::BufferString(v7, &v18, 1uLL);
    FixedToPString(v15, 3, v10);
    TBufferedStreamingContext::BufferString(v7, v11, *(unsigned __int8 *)(v7 + 66));
    unsigned __int8 v19 = 32;
    this = TBufferedStreamingContext::BufferString(v7, &v19, 1uLL);
    char v13 = 0;
    uint64_t v3 = *(void *)(v7 + 24);
    ++v8;
    int v4 = *(unsigned __int16 *)(v3 + 68);
    if (v4 > (__int16)v8) {
      continue;
    }
    break;
  }
LABEL_19:
  return TBufferedStreamingContext::BufferString(v7, "] def\r", 6uLL);
}

uint64_t TBufferedCharStringStreamingContext::BufferStdW(uint64_t this)
{
  uint64_t v1 = this;
  unsigned int v2 = *(_DWORD *)(this + 176);
  if (v2)
  {
    TBufferedStreamingContext::BufferString(this, (const unsigned __int8 *)"/StdHW [", 8uLL);
    FixedToPString(v2, 3, (unsigned __int8 *)(v1 + 66));
    TBufferedStreamingContext::BufferString(v1, (const unsigned __int8 *)(v1 + 67), *(unsigned __int8 *)(v1 + 66));
    this = TBufferedStreamingContext::BufferString(v1, "] def\r", 6uLL);
  }
  unsigned int v3 = *(_DWORD *)(v1 + 180);
  if (v3)
  {
    TBufferedStreamingContext::BufferString(v1, (const unsigned __int8 *)"/StdVW [", 8uLL);
    FixedToPString(v3, 3, (unsigned __int8 *)(v1 + 66));
    TBufferedStreamingContext::BufferString(v1, (const unsigned __int8 *)(v1 + 67), *(unsigned __int8 *)(v1 + 66));
    return TBufferedStreamingContext::BufferString(v1, "] def\r", 6uLL);
  }
  return this;
}

uint64_t TBufferedCharStringStreamingContext::BufferBlueStuff(uint64_t this)
{
  uint64_t v1 = this;
  unsigned int v2 = *(_DWORD *)(this + 308);
  if (v2 != 2597)
  {
    TBufferedStreamingContext::BufferString(this, (const unsigned __int8 *)"/BlueScale ", 0xBuLL);
    FixedToPString(v2, 6, (unsigned __int8 *)(v1 + 66));
    TBufferedStreamingContext::BufferString(v1, (const unsigned __int8 *)(v1 + 67), *(unsigned __int8 *)(v1 + 66));
    this = TBufferedStreamingContext::BufferString(v1, " def\r", 5uLL);
  }
  unsigned int v3 = *(_DWORD *)(v1 + 312);
  if (v3 != 0x10000)
  {
    TBufferedStreamingContext::BufferString(v1, (const unsigned __int8 *)"/BlueFuzz ", 0xAuLL);
    FixedToPString(v3, 6, (unsigned __int8 *)(v1 + 66));
    TBufferedStreamingContext::BufferString(v1, (const unsigned __int8 *)(v1 + 67), *(unsigned __int8 *)(v1 + 66));
    this = TBufferedStreamingContext::BufferString(v1, " def\r", 5uLL);
  }
  unsigned int v4 = *(_DWORD *)(v1 + 316);
  if (v4 != 458752)
  {
    TBufferedStreamingContext::BufferString(v1, (const unsigned __int8 *)"/BlueShift ", 0xBuLL);
    FixedToPString(v4, 2, (unsigned __int8 *)(v1 + 66));
    TBufferedStreamingContext::BufferString(v1, (const unsigned __int8 *)(v1 + 67), *(unsigned __int8 *)(v1 + 66));
    return TBufferedStreamingContext::BufferString(v1, " def\r", 5uLL);
  }
  return this;
}

uint64_t TBufferedCharStringStreamingContext::BufferForceBold(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 516);
  if ((v1 & 2) != 0)
  {
    if (v1)
    {
      unsigned int v2 = "/ForceBold true def\r";
      unint64_t v3 = 20;
    }
    else
    {
      unsigned int v2 = "/ForceBold false def\r";
      unint64_t v3 = 21;
    }
    return TBufferedStreamingContext::BufferString(this, (const unsigned __int8 *)v2, v3);
  }
  return this;
}

uint64_t TBufferedCharStringStreamingContext::BufferStemSnap(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 24);
  uint64_t v3 = *(unsigned __int16 *)(v2 + 62);
  if (*(_WORD *)(v2 + 62))
  {
    TBufferedStreamingContext::BufferString(this, "/StemSnapH [", 0xCuLL);
    uint64_t v4 = 0;
    uint64_t v5 = 4 * v3;
    do
    {
      FixedToPString(*(_DWORD *)(v1 + v4 + 212), 3, (unsigned __int8 *)(v1 + 66));
      TBufferedStreamingContext::BufferString(v1, (const unsigned __int8 *)(v1 + 67), *(unsigned __int8 *)(v1 + 66));
      unsigned __int8 v9 = 32;
      TBufferedStreamingContext::BufferString(v1, &v9, 1uLL);
      v4 += 4;
    }
    while (v5 != v4);
    this = TBufferedStreamingContext::BufferString(v1, "] def\r", 6uLL);
    uint64_t v2 = *(void *)(v1 + 24);
  }
  uint64_t v6 = *(unsigned __int16 *)(v2 + 64);
  if (*(_WORD *)(v2 + 64))
  {
    TBufferedStreamingContext::BufferString(v1, "/StemSnapV [", 0xCuLL);
    uint64_t v7 = 0;
    uint64_t v8 = 4 * v6;
    do
    {
      FixedToPString(*(_DWORD *)(v1 + v7 + 260), 3, (unsigned __int8 *)(v1 + 66));
      TBufferedStreamingContext::BufferString(v1, (const unsigned __int8 *)(v1 + 67), *(unsigned __int8 *)(v1 + 66));
      unsigned __int8 v10 = 32;
      TBufferedStreamingContext::BufferString(v1, &v10, 1uLL);
      v7 += 4;
    }
    while (v8 != v7);
    return TBufferedStreamingContext::BufferString(v1, "] def\r", 6uLL);
  }
  return this;
}

uint64_t TBufferedCharStringStreamingContext::BufferSubrs(TBufferedCharStringStreamingContext *this)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  int v27 = -1431655766;
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v26 = v2;
  long long v25 = v2;
  *(_OWORD *)&v24[8] = v2;
  TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"/Subrs 5 array\r", 0xFuLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"dup 0 15 RD ", 0xCuLL);
  uint64_t v3 = 0;
  *(_DWORD *)int v23 = 0;
  *(void *)unsigned int v24 = 0x110C110C100C8B8ELL;
  *(_DWORD *)&unsigned char v24[7] = 186715153;
  int v4 = 4330;
  do
  {
    char v5 = BYTE1(v4);
    int v4 = 22719 - 12691 * (v4 + (v23[v3] ^ ((unsigned __int16)(v4 & 0xFF00) >> 8)));
    v23[v3++] ^= v5;
  }
  while (v3 != 15);
  TBufferedStreamingContext::BufferString((uint64_t)this, v23, 0xFuLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, " NP\r", 4uLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"dup 1 9 RD ", 0xBuLL);
  uint64_t v6 = 0;
  *(_DWORD *)int v23 = 0;
  *(_DWORD *)unsigned int v24 = 269257867;
  v24[4] = 11;
  int v7 = 4330;
  do
  {
    char v8 = BYTE1(v7);
    int v7 = 22719 - 12691 * (v7 + (v23[v6] ^ ((unsigned __int16)(v7 & 0xFF00) >> 8)));
    v23[v6++] ^= v8;
  }
  while (v6 != 9);
  TBufferedStreamingContext::BufferString((uint64_t)this, v23, 9uLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, " NP\r", 4uLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"dup 2 9 RD ", 0xBuLL);
  uint64_t v9 = 0;
  *(_DWORD *)int v23 = 0;
  *(_DWORD *)unsigned int v24 = 269258123;
  v24[4] = 11;
  int v10 = 4330;
  do
  {
    char v11 = BYTE1(v10);
    int v10 = 22719 - 12691 * (v10 + (v23[v9] ^ ((unsigned __int16)(v10 & 0xFF00) >> 8)));
    v23[v9++] ^= v11;
  }
  while (v9 != 9);
  TBufferedStreamingContext::BufferString((uint64_t)this, v23, 9uLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, " NP\r", 4uLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"dup 3 5 RD ", 0xBuLL);
  uint64_t v12 = 0;
  *(_DWORD *)int v23 = 0;
  v24[0] = 11;
  int v13 = 4330;
  do
  {
    char v14 = BYTE1(v13);
    int v13 = 22719 - 12691 * (v13 + (v23[v12] ^ ((unsigned __int16)(v13 & 0xFF00) >> 8)));
    v23[v12++] ^= v14;
  }
  while (v12 != 5);
  TBufferedStreamingContext::BufferString((uint64_t)this, v23, 5uLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, " NP\r", 4uLL);
  if (*((_DWORD *)this + 131) == 1)
  {
    unint64_t v15 = 12;
    TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"dup 4 12 RD ", 0xCuLL);
    uint64_t v16 = 0;
    *(_DWORD *)int v23 = 0;
    *(void *)unsigned int v24 = 0xB0A110C100C8E8CLL;
    int v17 = 4330;
    do
    {
      char v18 = BYTE1(v17);
      int v17 = 22719 - 12691 * (v17 + (v23[v16] ^ ((unsigned __int16)(v17 & 0xFF00) >> 8)));
      v23[v16++] ^= v18;
    }
    while (v16 != 12);
  }
  else
  {
    TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"dup 4 13 RD ", 0xCuLL);
    uint64_t v19 = 0;
    *(_DWORD *)int v23 = 0;
    *(void *)unsigned int v24 = 0xA110C100C8E8C8ELL;
    v24[8] = 11;
    int v20 = 4330;
    unint64_t v15 = 13;
    do
    {
      char v21 = BYTE1(v20);
      int v20 = 22719 - 12691 * (v20 + (v23[v19] ^ ((unsigned __int16)(v20 & 0xFF00) >> 8)));
      v23[v19++] ^= v21;
    }
    while (v19 != 13);
  }
  TBufferedStreamingContext::BufferString((uint64_t)this, v23, v15);
  TBufferedStreamingContext::BufferString((uint64_t)this, " NP\r", 4uLL);
  return TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"ND\r", 3uLL);
}

uint64_t TBufferedCharStringStreamingContext::StreamCharHeader(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  TBufferedStreamingContext::BufferString(a1, *(const unsigned __int8 **)(a2 + 264), *(void *)(a2 + 272));
  v13[0] = 32;
  TBufferedStreamingContext::BufferString(a1, v13, 1uLL);
  memset(v13, 170, 12);
  char v5 = (unsigned __int8 *)&v12;
  do
  {
    *++char v5 = (a3 % 0xA) | 0x30;
    BOOL v6 = a3 >= 9;
    BOOL v7 = a3 == 9;
    a3 /= 0xAu;
  }
  while (!v7 && v6);
  char v8 = (const unsigned __int8 *)(a1 + 67);
  LOBYTE(v9) = a1 + 67;
  if (v5 >= v13)
  {
    uint64_t v9 = (unsigned char *)(a1 + 67);
    do
    {
      char v10 = *v5--;
      *v9++ = v10;
    }
    while (v5 >= v13);
  }
  *(unsigned char *)(a1 + 66) = (_BYTE)v9 - (_BYTE)v8;
  TBufferedStreamingContext::BufferString(a1, v8, ((_BYTE)v9 - (_BYTE)v8));
  TBufferedStreamingContext::BufferString(a1, (const unsigned __int8 *)" RD ", 4uLL);
  return TBufferedStreamingContext::StreamBuffer(a1);
}

uint64_t TBufferedCharStringStreamingContext::BufferCharBuffer(uint64_t this)
{
  uint64_t v1 = *(const unsigned __int8 **)(this + 136);
  long long v2 = *(const unsigned __int8 **)(this + 144);
  if (v2 != v1)
  {
    uint64_t v3 = this;
    TBufferedStreamingContext::BufferString(this, v1, v2 - v1);
    this = TBufferedStreamingContext::StreamBuffer(v3);
    uint64_t v4 = *(void *)(v3 + 136);
    if (*(void *)(v3 + 144) != v4) {
      *(void *)(v3 + 144) = v4;
    }
  }
  return this;
}

char *TBufferedCharStringStreamingContext::CharBufferAndEncrypt(TBufferedCharStringStreamingContext *this, char *__src, unsigned int a3)
{
  uint64_t v7 = *((void *)this + 17);
  char v5 = (char *)*((void *)this + 18);
  BOOL v6 = (char *)this + 136;
  int64_t v8 = a3;
  uint64_t result = std::vector<unsigned char>::__insert_with_size[abi:fe180100]<unsigned char const*,unsigned char const*>((uint64_t)this + 136, v5, __src, &__src[v8], v8);
  __int16 v10 = *((_WORD *)v6 + 192);
  if (a3)
  {
    char v11 = (unsigned __int8 *)(*(void *)v6 + (v5 - v7));
    do
    {
      int v12 = *v11 ^ ((unsigned __int16)(v10 & 0xFF00) >> 8);
      *v11++ ^= (unsigned __int16)(v10 & 0xFF00) >> 8;
      __int16 v10 = 22719 - 12691 * (v10 + v12);
      --v8;
    }
    while (v8);
  }
  *((_WORD *)this + 260) = v10;
  return result;
}

char *TBufferedCharStringStreamingContext::BufferCharData(TBufferedCharStringStreamingContext *this, unsigned int a2, int a3, int *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a3 >= 7)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[1] = v4;
  _OWORD v19[2] = v4;
  v19[0] = v4;
  char v5 = v19;
  if (a3 >= 1)
  {
    do
    {
      int v7 = *a4++;
      int v6 = v7;
      if ((v7 + 7012352) >> 16 > 0xD6)
      {
        if ((v6 - 7077888) >> 26)
        {
          if ((v6 + 74121216) >> 26)
          {
            *char v5 = -1;
            v5[1] = v6 >> 31;
            void v5[2] = v6 >> 31;
            v5[3] = HIBYTE(v6);
            v5[4] = BYTE2(v6);
            v5 += 5;
            goto LABEL_11;
          }
          unsigned int v8 = -((v6 + 7077888) >> 16);
          int v9 = (v8 >> 8) - 5;
        }
        else
        {
          unsigned int v8 = HIWORD(v6) - 108;
          int v9 = (v8 >> 8) - 9;
        }
        *char v5 = v9;
        v5[1] = v8;
        v5 += 2;
      }
      else
      {
        *v5++ = BYTE2(v6) - 117;
      }
LABEL_11:
      unsigned int v10 = (unsigned __int16)a3--;
    }
    while (v10 > 1);
  }
  if (a2 < 0x20)
  {
    int v11 = v5 + 1;
  }
  else
  {
    int v11 = v5 + 2;
    v5[1] = a2 - 32;
    LOBYTE(a2) = 12;
  }
  *char v5 = a2;
  int64_t v12 = v11 - v19;
  if ((*((__int16 *)this + 261) & 0x80000000) == 0)
  {
    __int16 v13 = *((_WORD *)this + 260);
    if (v11 != v19)
    {
      uint64_t v14 = (unsigned __int8 *)v19;
      int64_t v15 = v12;
      do
      {
        int v16 = *v14 ^ ((unsigned __int16)(v13 & 0xFF00) >> 8);
        *v14++ ^= (unsigned __int16)(v13 & 0xFF00) >> 8;
        __int16 v13 = 22719 - 12691 * (v13 + v16);
        --v15;
      }
      while (v15);
    }
    *((_WORD *)this + 260) = v13;
  }
  return std::vector<unsigned char>::__insert_with_size[abi:fe180100]<unsigned char const*,unsigned char const*>((uint64_t)this + 136, *((char **)this + 18), (char *)v19, (char *)v19 + v12, v12);
}

uint64_t TBufferedCharStringStreamingContext::BlendVal(uint64_t this, int *a2, int a3)
{
  if (a3)
  {
    do
    {
      --a3;
      int v3 = *a2++;
      uint64_t v4 = *(int *)(this + 648);
      *(_DWORD *)(this + 648) = v4 + 1;
      *(_DWORD *)(this + 4 * v4 + 552) = v3;
    }
    while ((_WORD)a3);
  }
  return this;
}

unint64_t TBufferedCharStringStreamingContext::GetStreamableSubrData(TBufferedCharStringStreamingContext *this, int a2, unsigned int *a3)
{
  memset(v28, 170, sizeof(v28));
  unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = (*(uint64_t (**)(void, unint64_t *, _WORD *, _WORD *))(**((void **)this + 1) + 136))(*((void *)this + 1), &v27, v28, &v28[1]);
  if (v6) {
    BOOL v7 = v27 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7) {
    goto LABEL_22;
  }
  unint64_t v8 = v6;
  int v9 = (*(uint64_t (**)(void))(**((void **)this + 1) + 144))(*((void *)this + 1));
  int v10 = v28[0];
  int v11 = v10 + v10 * v9;
  unint64_t v12 = *(void *)&v28[1];
  unint64_t v13 = v27 + v11;
  BOOL v14 = v13 < v27 || v13 > *(void *)&v28[1];
  if (v14 || v28[0] * a2 < 0) {
    goto LABEL_22;
  }
  int64_t v15 = (const unsigned __int8 *)(v27 + v28[0] * a2);
  unint64_t v16 = v27 + v11;
  int v17 = &v15[2 * v28[0]];
  if (v17 < v15 || (unint64_t)v17 > v16) {
    goto LABEL_22;
  }
  unsigned int v19 = BytesToCard(v15, v28[0]);
  int v20 = BytesToCard(&v15[v10], v10);
  unint64_t result = v8 + v19 - 1;
  uint64_t v22 = v20 - v19;
  *a3 = v22;
  unint64_t v23 = result + v22;
  BOOL v24 = v8 <= result && v23 >= result;
  if (!v24 || v23 > v12)
  {
LABEL_22:
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  return result;
}

uint64_t TBufferedCharStringStreamingContext::ProcessCharString(uint64_t this, const unsigned __int8 *a2, int a3, int a4)
{
  uint64_t v221 = *MEMORY[0x1E4F143B8];
  if (a4 >= 11)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  char v5 = (int32x2_t *)this;
  uint64_t v6 = this + 552;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v219 = v7;
  long long v220 = v7;
  long long v217 = v7;
  long long v218 = v7;
  long long v215 = v7;
  long long v216 = v7;
  if (a3) {
    unint64_t v8 = (unint64_t)&a2[a3];
  }
  else {
    unint64_t v8 = 0xFFFFFFFFLL;
  }
  uint64_t v208 = this + 548;
  long long v213 = v7;
  long long v214 = v7;
  long long v211 = v7;
  long long v212 = v7;
  __int16 v9 = a4 + 1;
  *(_OWORD *)uint64_t v210 = v7;
  *(_OWORD *)&v210[16] = v7;
  int v10 = a2;
  while (2)
  {
    uint64_t v11 = v5[81].u32[0];
    if (v11 >= 0x30)
    {
      unsigned int v156 = __cxa_allocate_exception(0x10uLL);
      *(void *)unsigned int v156 = &unk_1F0DFC400;
      v156[4] = 5;
    }
    if (v10 < a2 || (unint64_t v12 = v10 + 1, (unint64_t)(v10 + 1) > v8))
    {
      uint64_t v155 = __cxa_allocate_exception(0x10uLL);
      *(void *)uint64_t v155 = &unk_1F0DFC400;
      v155[4] = 5;
    }
    unsigned int v13 = *v10;
    switch(*v10)
    {
      case 1u:
        if (v11 != 2)
        {
          unsigned int v168 = __cxa_allocate_exception(0x10uLL);
          *(void *)unsigned int v168 = &unk_1F0DFC400;
          v168[4] = 5;
        }
        __int32 v25 = v5[69].i32[1];
        v5[81].i32[0] = 0;
        int v26 = v5[69].i32[0] + v5[84].i32[0] + 0x8000;
        *(_DWORD *)uint64_t v210 = (v26 & 0xFFFF0000) - v5[85].i32[0];
        *(_DWORD *)&v210[4] = ((v26 + v25) & 0xFFFF0000) - (v26 & 0xFFFF0000);
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 1u, 2, (int *)v210);
        goto LABEL_90;
      case 2u:
        v5[66].i8[1] = 0;
        int v160 = __cxa_allocate_exception(0x10uLL);
        *(void *)int v160 = &unk_1F0DFC400;
        v160[4] = 5;
      case 3u:
        if (v11 != 2)
        {
          unsigned int v167 = __cxa_allocate_exception(0x10uLL);
          *(void *)unsigned int v167 = &unk_1F0DFC400;
          v167[4] = 5;
        }
        __int32 v23 = v5[69].i32[1];
        v5[81].i32[0] = 0;
        int v24 = v5[69].i32[0] + v5[83].i32[1] + 0x8000;
        *(_DWORD *)uint64_t v210 = (v24 & 0xFFFF0000) - v5[84].i32[1];
        *(_DWORD *)&v210[4] = ((v24 + v23) & 0xFFFF0000) - (v24 & 0xFFFF0000);
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 3u, 2, (int *)v210);
        goto LABEL_90;
      case 4u:
      case 7u:
        if (v11 != 1)
        {
          uint64_t v159 = __cxa_allocate_exception(0x10uLL);
          *(void *)uint64_t v159 = &unk_1F0DFC400;
          v159[4] = 5;
        }
        v5[81].i32[0] = 0;
        __int32 v14 = v5[83].i32[0];
        int v15 = v5[82].i32[0] + v5[69].i32[0];
        v5[82].i32[0] = v15;
        unsigned int v16 = (v15 + 0x8000) & 0xFFFF0000;
        v5[83].i32[0] = v16;
        *(_DWORD *)uint64_t v210 = v16 - v14;
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, v13, 1, (int *)v210);
        goto LABEL_90;
      case 5u:
      case 0x15u:
        if (v11 != 2)
        {
          uint64_t v158 = __cxa_allocate_exception(0x10uLL);
          *(void *)uint64_t v158 = &unk_1F0DFC400;
          v158[4] = 5;
        }
        v5[81].i32[0] = 0;
        int32x2_t v17 = vadd_s32(*(int32x2_t *)(v6 + 100), v5[69]);
        *(int32x2_t *)(v6 + 100) = v17;
        int32x2_t v18 = (int32x2_t)vand_s8((int8x8_t)vadd_s32(v17, (int32x2_t)0x800000008000), (int8x8_t)0xFFFF0000FFFF0000);
        int32x2_t v19 = *(int32x2_t *)(v6 + 108);
        *(int32x2_t *)(v6 + 108) = v18;
        *(int32x2_t *)uint64_t v210 = vsub_s32(v18, v19);
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, v13, 2, (int *)v210);
        goto LABEL_90;
      case 6u:
      case 0x16u:
        if (v11 != 1)
        {
          uint64_t v157 = __cxa_allocate_exception(0x10uLL);
          *(void *)uint64_t v157 = &unk_1F0DFC400;
          v157[4] = 5;
        }
        v5[81].i32[0] = 0;
        __int32 v20 = v5[82].i32[1];
        int v21 = v5[81].i32[1] + v5[69].i32[0];
        v5[81].i32[1] = v21;
        unsigned int v22 = (v21 + 0x8000) & 0xFFFF0000;
        v5[82].i32[1] = v22;
        *(_DWORD *)uint64_t v210 = v22 - v20;
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, v13, 1, (int *)v210);
        goto LABEL_90;
      case 8u:
        if (v11 != 6)
        {
          uint64_t v166 = __cxa_allocate_exception(0x10uLL);
          *(void *)uint64_t v166 = &unk_1F0DFC400;
          v166[4] = 5;
        }
        v5[81].i32[0] = 0;
        int32x2_t v62 = vadd_s32(*(int32x2_t *)(v6 + 100), v5[69]);
        int32x2_t v63 = (int32x2_t)vand_s8((int8x8_t)vadd_s32(v62, (int32x2_t)0x800000008000), (int8x8_t)0xFFFF0000FFFF0000);
        int32x2_t v64 = vadd_s32(v62, v5[70]);
        int32x2_t v65 = (int32x2_t)vand_s8((int8x8_t)vadd_s32(v64, (int32x2_t)0x800000008000), (int8x8_t)0xFFFF0000FFFF0000);
        *(int32x2_t *)uint64_t v210 = vsub_s32(v63, *(int32x2_t *)(v6 + 108));
        *(int32x2_t *)&v210[8] = vsub_s32(v65, v63);
        *(int32x2_t *)&long long v66 = vadd_s32(v64, v5[71]);
        *((int8x8_t *)&v66 + 1) = vand_s8((int8x8_t)vadd_s32(*(int32x2_t *)&v66, (int32x2_t)0x800000008000), (int8x8_t)0xFFFF0000FFFF0000);
        *(_OWORD *)&v5[81].u8[4] = v66;
        *(int32x2_t *)&v210[16] = vsub_s32(*(int32x2_t *)((char *)&v66 + 8), v65);
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 8u, 6, (int *)v210);
        goto LABEL_90;
      case 9u:
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 9u, 0, (int *)v210);
        goto LABEL_90;
      case 0xAu:
        if (!v11)
        {
          unsigned int v165 = __cxa_allocate_exception(0x10uLL);
          *(void *)unsigned int v165 = &unk_1F0DFC400;
          v165[4] = 5;
        }
        LODWORD(v71) = v11 - 1;
        v5[81].i32[0] = v11 - 1;
        int v72 = v5[69].i32[(v11 - 1)];
        uint64_t v73 = (v72 >> 16);
        if (!v5[66].i8[0]) {
          goto LABEL_89;
        }
        while (2)
        {
          if (v72 < 0x40000)
          {
            if (!v73)
            {
              uint64_t v79 = (int)v71 - 1;
              v5[81].i32[0] = v79;
              LODWORD(v79) = v5[69].i32[v79];
              uint64_t v80 = (int)v71 - 2;
              v5[81].i32[0] = v80;
              LODWORD(v80) = v5[69].i32[v80];
              uint64_t v81 = (int)v71 - 3;
              v5[81].i32[0] = v81;
              LODWORD(v81) = v5[69].i32[v81];
              v5[82].i32[0] = v79;
              v5[81].i32[1] = v80;
              LODWORD(v79) = (v79 + 0x8000) & 0xFFFF0000;
              v5[83].i32[0] = v79;
              v5[82].i32[1] = (v80 + 0x8000) & 0xFFFF0000;
              *(_DWORD *)uint64_t v210 = v81;
              *(_DWORD *)&v210[4] = (v80 + 0x8000) & 0xFFFF0000;
              *(_DWORD *)&v210[8] = v79;
              *(_DWORD *)&v210[12] = 0;
              this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0xAu, 4, (int *)v210);
              if (v5[66].i8[0]) {
                goto LABEL_90;
              }
              uint64_t v73 = 0;
              goto LABEL_89;
            }
            int v77 = v73 << 16;
          }
          else
          {
            if (v73 != 4) {
              goto LABEL_89;
            }
            __int32 v74 = v5[65].i32[1];
            if (v74 == 1)
            {
              *(void *)uint64_t v210 = 0x4000000030000;
              this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0xAu, 2, (int *)v210);
              uint64_t v71 = v5[81].i32[0] - 1;
              v5[81].i32[0] = v71;
              int v72 = v5[69].i32[v71];
              uint64_t v73 = (v72 >> 16);
              if (v72 >= 327680) {
                goto LABEL_89;
              }
              continue;
            }
            if (v74 != 2)
            {
              if (v5[66].i8[0])
              {
LABEL_87:
                if (v74) {
                  goto LABEL_90;
                }
              }
              uint64_t v73 = 4;
              goto LABEL_89;
            }
            int v77 = 0x40000;
            uint64_t v73 = 4;
          }
          break;
        }
        *(_DWORD *)uint64_t v210 = v77;
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0xAu, 1, (int *)v210);
        if (v5[66].i8[0] && (int)v73 <= 4)
        {
          if (v73 != 4) {
            goto LABEL_90;
          }
          __int32 v74 = v5[65].i32[1];
          goto LABEL_87;
        }
LABEL_89:
        unsigned int v209 = -1431655766;
        int v83 = (const unsigned __int8 *)(*(uint64_t (**)(int32x2_t *, uint64_t, unsigned int *))(*(void *)v5 + 48))(v5, v73, &v209);
        this = TBufferedCharStringStreamingContext::ProcessCharString((TBufferedCharStringStreamingContext *)v5, v83, v209, v9);
LABEL_90:
        __int16 v29 = v12;
        goto LABEL_91;
      case 0xBu:
        return this;
      case 0xCu:
        __int16 v29 = v10 + 2;
        if ((unint64_t)(v10 + 2) > v8)
        {
          BOOL v164 = __cxa_allocate_exception(0x10uLL);
          *(void *)BOOL v164 = &unk_1F0DFC400;
          v164[4] = 5;
        }
        int v30 = *v12;
        switch(*v12)
        {
          case 0u:
            this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0x20u, 0, (int *)v210);
            goto LABEL_91;
          case 1u:
          case 2u:
            if (v11 != 6)
            {
              BOOL v172 = __cxa_allocate_exception(0x10uLL);
              *(void *)BOOL v172 = &unk_1F0DFC400;
              v172[4] = 5;
            }
            v5[81].i32[0] = 0;
            __int32 v31 = v5[69].i32[0];
            int v32 = v5[69].i32[1];
            __int32 v33 = v5[70].i32[1];
            uint64_t v34 = 170;
            if (v30 == 1) {
              uint64_t v34 = 169;
            }
            uint64_t v35 = 168;
            if (v30 == 1) {
              uint64_t v35 = 167;
            }
            this = v5->u32[v35];
            __int32 v36 = v5->i32[v34];
            __int32 v37 = v5[71].i32[1];
            int v38 = this + v31;
            int v39 = this + v31 + v32;
            int v40 = this + v5[70].i32[0];
            int v41 = v40 + v33;
            int v42 = this + v5[71].i32[0];
            if ((v32 & 0x80000000) == 0
              && v39 <= v40
              && (v33 & 0x80000000) == 0
              && v41 <= v42
              && (v37 & 0x80000000) == 0
              || v32 <= 0
              && (v39 >= v40 ? (BOOL v43 = v33 <= 0) : (BOOL v43 = 0),
                  v43 ? (BOOL v44 = v41 < v42) : (BOOL v44 = 1),
                  !v44 ? (BOOL v45 = v37 <= 0) : (BOOL v45 = 0),
                  v45))
            {
              unsigned __int32 v46 = ((v38 + 0x8000) & 0xFFFF0000) - v36;
              unsigned __int32 v47 = ((v39 + 0x8000) & 0xFFFF0000) - v36;
              unsigned __int32 v48 = ((v40 + 0x8000) & 0xFFFF0000) - v36;
              unsigned __int32 v49 = ((v41 + 0x8000) & 0xFFFF0000) - v36;
              *(_DWORD *)uint64_t v210 = v46;
              *(_DWORD *)&v210[4] = v47 - v46;
              *(_DWORD *)&v210[8] = v48;
              *(_DWORD *)&v210[12] = v49 - v48;
              *(_DWORD *)&v210[16] = v49 + v48 - v47;
              *(_DWORD *)&v210[20] = v47 - v46;
              this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, (v30 + 32), 6, (int *)v210);
            }
            goto LABEL_91;
          case 6u:
            if (v11 != 5)
            {
              unsigned int v185 = __cxa_allocate_exception(0x10uLL);
              *(void *)unsigned int v185 = &unk_1F0DFC400;
              v185[4] = 5;
            }
            v5[81].i32[0] = 0;
            unsigned int v109 = (v5[70].i32[0] + 0x8000) & 0xFFFF0000;
            *(int8x8_t *)uint64_t v210 = vand_s8((int8x8_t)vadd_s32(v5[69], (int32x2_t)0x800000008000), (int8x8_t)0xFFFF0000FFFF0000);
            *(_DWORD *)&v210[8] = v109;
            *(int8x8_t *)&v210[12] = vand_s8(*(int8x8_t *)(v6 + 12), (int8x8_t)0xFFFF0000FFFF0000);
            this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0x26u, 5, (int *)v210);
            goto LABEL_91;
          case 7u:
            if (v11 != 4)
            {
              int v184 = __cxa_allocate_exception(0x10uLL);
              *(void *)int v184 = &unk_1F0DFC400;
              v184[4] = 5;
            }
            v5[81].i32[0] = 0;
            int32x4_t v84 = *(int32x4_t *)v6;
            v85.i64[0] = 0x800000008000;
            v85.i64[1] = 0x800000008000;
            v86.i64[0] = 0xFFFF0000FFFF0000;
            v86.i64[1] = 0xFFFF0000FFFF0000;
            int8x16_t v87 = vandq_s8((int8x16_t)vaddq_s32(*(int32x4_t *)v6, v85), v86);
            v84.i64[1] = v87.i64[0];
            *(int32x4_t *)&v5[83].u8[4] = v84;
            *(int32x4_t *)&v5[81].u8[4] = v84;
            *(int8x16_t *)uint64_t v210 = v87;
            this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0x27u, 4, (int *)v210);
            goto LABEL_91;
          case 0xAu:
            __int32 v88 = v11 - 1;
            v5[81].i32[0] = v11 - 1;
            uint64_t v89 = v5 + 69;
            __int32 v108 = v5[68].i32[(int)v11 + 1];
            __int32 v91 = v11 - 2;
            v5[81].i32[0] = v91;
            unsigned int v92 = v5[69].i32[v91] + v108;
            goto LABEL_109;
          case 0xBu:
            __int32 v88 = v11 - 1;
            v5[81].i32[0] = v11 - 1;
            uint64_t v89 = v5 + 69;
            __int32 v93 = v5[68].i32[(int)v11 + 1];
            __int32 v91 = v11 - 2;
            v5[81].i32[0] = v91;
            unsigned int v92 = v5[69].i32[v91] - v93;
            goto LABEL_109;
          case 0xCu:
            __int32 v94 = v11 - 1;
            if (v11 <= 1)
            {
              size_t v183 = __cxa_allocate_exception(0x10uLL);
              *(void *)size_t v183 = &unk_1F0DFC400;
              v183[4] = 5;
            }
            v5[81].i32[0] = v94;
            int v110 = v5 + 69;
            int v111 = v5[69].i32[v94];
            unsigned __int32 v112 = v11 - 2;
            v5[81].i32[0] = v112;
            if (!v5[68].i8[4]) {
              goto LABEL_119;
            }
            v111 >>= 16;
            goto LABEL_118;
          case 0x10u:
            unsigned int v113 = v11 - 1;
            if (v11 > 1)
            {
              v5[81].i32[0] = v113;
              int v114 = v5[69].i32[v113];
              int v115 = v114 >> 16;
              switch(v114 >> 16)
              {
                case 0:
                case 1:
                case 2:
                case 12:
                case 13:
                  uint64_t v116 = (v11 - 2);
                  v5[81].i32[0] = v116;
                  int v117 = v5[69].i32[v116];
                  if (v117 < 0 || (int v118 = v117 >> 16, (int)v116 < v117 >> 16))
                  {
                    unsigned int v188 = __cxa_allocate_exception(0x10uLL);
                    *(void *)unsigned int v188 = &unk_1F0DFC400;
                    v188[4] = 5;
                  }
                  unsigned int v119 = v114 & 0xFFFF0000;
                  int v120 = v118 + 1;
                  *(_DWORD *)&v210[4 * (v118 + 1)] = v119;
                  *(_DWORD *)&v210[4 * v118] = v117 & 0xFFFF0000;
                  if (v117 >= 0x10000)
                  {
                    int v121 = &v210[4 * (v118 - 1)];
                    uint64_t v122 = (int *)(v208 + 4 * v116);
                    __int32 v123 = v11 - 3;
                    do
                    {
                      v5[81].i32[0] = v123;
                      int v124 = *v122--;
                      *v121-- = v124;
                      --v120;
                      --v123;
                    }
                    while (v120 > 1);
                  }
                  this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0x30u, (__int16)(HIWORD(v117) + 2), (int *)v210);
                  goto LABEL_91;
                case 3:
                  v5[81].i32[0] = v11 - 2;
                  if (v5[69].u16[2 * (v11 - 2) + 1] << 16 != 0x10000)
                  {
                    int v205 = __cxa_allocate_exception(0x10uLL);
                    *(void *)int v205 = &unk_1F0DFC400;
                    v205[4] = 5;
                  }
                  if (v5[66].i8[2])
                  {
                    *(void *)uint64_t v210 = 0x1000000030000;
                    *(_DWORD *)&v210[8] = 196608;
                    TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0x30u, 3, (int *)v210);
                    TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0x31u, 0, (int *)v210);
                    this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0xAu, 0, (int *)v210);
                  }
                  goto LABEL_91;
                case 4:
                  v5[81].i32[0] = v11 - 2;
                  if (v5[69].u16[2 * (v11 - 2) + 1] << 16 != 0x10000)
                  {
                    unsigned int v207 = __cxa_allocate_exception(0x10uLL);
                    *(void *)unsigned int v207 = &unk_1F0DFC400;
                    v207[4] = 5;
                  }
                  if (v5[68].i8[4]) {
                    v5[68].i8[4] = 0;
                  }
                  int v127 = v11 - 3;
                  goto LABEL_132;
                case 6:
                  v5[81].i32[0] = v11 - 2;
                  if (v5[69].i32[(v11 - 2)])
                  {
                    v206 = __cxa_allocate_exception(0x10uLL);
                    *(void *)v206 = &unk_1F0DFC400;
                    v206[4] = 5;
                  }
                  *(void *)uint64_t v210 = 0x6000000000000;
                  this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0x30u, 2, (int *)v210);
                  goto LABEL_91;
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                  char v187 = __cxa_allocate_exception(0x10uLL);
                  *(void *)char v187 = &unk_1F0DFC400;
                  v187[4] = 5;
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                  __int32 v128 = v11 - 2;
                  v5[81].i32[0] = v128;
                  int v129 = v5[69].i32[v128];
                  if (v129 < 0
                    || (v130 = v129 >> 16, BOOL v131 = __OFSUB__(v128, v130), v132 = v128 - v130, (v132 < 0) ^ v131))
                  {
                    int v189 = __cxa_allocate_exception(0x10uLL);
                    *(void *)int v189 = &unk_1F0DFC400;
                    v189[4] = 5;
                  }
                  v5[81].i32[0] = v132;
                  int v133 = HIWORD(v114) - 13;
                  if (v115 == 18) {
                    __int16 v134 = 6;
                  }
                  else {
                    __int16 v134 = v133;
                  }
                  if (v130 < *(unsigned __int16 *)(*(void *)&v5[3] + 72) * (unsigned __int16)v134)
                  {
                    uint64_t v190 = __cxa_allocate_exception(0x10uLL);
                    *(void *)uint64_t v190 = &unk_1F0DFC400;
                    v190[4] = 5;
                  }
                  this = (*(uint64_t (**)(int32x2_t *, uint64_t, void))(*(void *)v5 + 40))(v5, (uint64_t)&v5[69] + 4 * v132, v134);
                  goto LABEL_91;
                case 19:
                  if (v113 <= 1)
                  {
                    uint64_t v198 = __cxa_allocate_exception(0x10uLL);
                    *(void *)uint64_t v198 = &unk_1F0DFC400;
                    v198[4] = 5;
                  }
                  v5[81].i32[0] = v11 - 3;
                  int v145 = v5[69].i32[(v11 - 3)];
                  if (v145 < 0
                    || (int v146 = v145 >> 16,
                        int32x2_t v147 = v5[3],
                        int v148 = *(unsigned __int16 *)(*(void *)&v147 + 80),
                        v146 >= v148)
                    || v146 + *(unsigned __int16 *)(*(void *)&v147 + 72) >= v148)
                  {
                    __int16 v193 = __cxa_allocate_exception(0x10uLL);
                    *(void *)__int16 v193 = &unk_1F0DFC400;
                    v193[4] = 5;
                  }
                  this = (*(uint64_t (**)(int32x2_t *))(*(void *)v5 + 32))(v5);
                  goto LABEL_91;
                case 20:
                  if (v113 <= 2)
                  {
                    int v203 = __cxa_allocate_exception(0x10uLL);
                    *(void *)int v203 = &unk_1F0DFC400;
                    v203[4] = 5;
                  }
                  __int32 v140 = v11 - 3;
                  v5[81].i32[0] = v11 - 3;
                  int v141 = v5 + 69;
                  __int32 v154 = v5[69].i32[(v11 - 3)];
                  unsigned __int32 v143 = v11 - 4;
                  v5[81].i32[0] = v143;
                  unsigned int v152 = v5[69].i32[v143] + v154;
                  goto LABEL_181;
                case 21:
                  if (v113 <= 2)
                  {
                    v201 = __cxa_allocate_exception(0x10uLL);
                    *(void *)v201 = &unk_1F0DFC400;
                    v201[4] = 5;
                  }
                  __int32 v140 = v11 - 3;
                  v5[81].i32[0] = v11 - 3;
                  int v141 = v5 + 69;
                  __int32 v151 = v5[69].i32[(v11 - 3)];
                  unsigned __int32 v143 = v11 - 4;
                  v5[81].i32[0] = v143;
                  unsigned int v152 = v5[69].i32[v143] - v151;
                  goto LABEL_181;
                case 22:
                  if (v113 <= 2)
                  {
                    __int16 v196 = __cxa_allocate_exception(0x10uLL);
                    *(void *)__int16 v196 = &unk_1F0DFC400;
                    v196[4] = 5;
                  }
                  __int32 v140 = v11 - 3;
                  v5[81].i32[0] = v11 - 3;
                  int v141 = v5 + 69;
                  int v142 = v5[69].i32[(v11 - 3)];
                  unsigned __int32 v143 = v11 - 4;
                  v5[81].i32[0] = v143;
                  double v144 = (double)v142 * 0.0000152587891 * ((double)v5[69].i32[v143] * 0.0000152587891);
                  goto LABEL_178;
                case 23:
                  if (v113 <= 2)
                  {
                    int v202 = __cxa_allocate_exception(0x10uLL);
                    *(void *)int v202 = &unk_1F0DFC400;
                    v202[4] = 5;
                  }
                  if (v5[68].i8[4]) {
                    v5[68].i8[4] = 0;
                  }
                  __int32 v140 = v11 - 3;
                  v5[81].i32[0] = v11 - 3;
                  int v141 = v5 + 69;
                  int v153 = v5[69].i32[(v11 - 3)];
                  unsigned __int32 v143 = v11 - 4;
                  v5[81].i32[0] = v143;
                  double v144 = (double)v5[69].i32[v143] * 0.0000152587891 / ((double)v153 * 0.0000152587891);
LABEL_178:
                  unsigned int v152 = vcvtd_n_s64_f64(v144, 0x10uLL);
LABEL_181:
                  v5[81].i32[0] = v140;
                  v141->i32[v143] = v152;
                  goto LABEL_91;
                case 24:
                case 26:
                  if (v113 <= 2)
                  {
                    unsigned int v191 = __cxa_allocate_exception(0x10uLL);
                    *(void *)unsigned int v191 = &unk_1F0DFC400;
                    v191[4] = 5;
                  }
                  v5[81].i32[0] = v11 - 3;
                  int v135 = v5[69].i32[(v11 - 3)];
                  v5[81].i32[0] = v11 - 4;
                  if (v135 < 0 || v135 >> 16 >= *(unsigned __int16 *)(*(void *)&v5[3] + 80))
                  {
                    __int16 v192 = __cxa_allocate_exception(0x10uLL);
                    *(void *)__int16 v192 = &unk_1F0DFC400;
                    v192[4] = 5;
                  }
                  *(_DWORD *)(*(void *)&v5[67] + 4 * (v135 >> TSBITWOFFFont::~TSBITWOFFFont((TSBITWOFFFont *)((char *)this - 16)) = v5[69].i32[(v11 - 4)];
                  goto LABEL_91;
                case 25:
                  v5[66].i8[1] = 0;
                  __int32 v94 = v11 - 2;
                  if (v11 <= 2)
                  {
                    int v194 = __cxa_allocate_exception(0x10uLL);
                    *(void *)int v194 = &unk_1F0DFC400;
                    v194[4] = 5;
                  }
                  unsigned __int32 v136 = v11 - 3;
                  v5[81].i32[0] = v136;
                  int v137 = (char *)v5 + 4 * v136;
                  int v138 = *((_DWORD *)v137 + 138);
                  if (v138 < 0 || (int v139 = v138 >> 16, v139 >= *(unsigned __int16 *)(*(void *)&v5[3] + 80)))
                  {
                    unsigned int v195 = __cxa_allocate_exception(0x10uLL);
                    *(void *)unsigned int v195 = &unk_1F0DFC400;
                    v195[4] = 5;
                  }
                  long long v100 = (int *)(v137 + 552);
                  unsigned int v98 = *(_DWORD *)(*(void *)&v5[67] + 4 * v139);
                  goto LABEL_120;
                case 27:
                  v5[66].i8[1] = 0;
                  __int32 v94 = v11 - 5;
                  if (v11 <= 5)
                  {
                    unsigned int v199 = __cxa_allocate_exception(0x10uLL);
                    *(void *)unsigned int v199 = &unk_1F0DFC400;
                    v199[4] = 5;
                  }
                  v5[81].i32[0] = v11 - 3;
                  int32x4_t v95 = v5 + 69;
                  __int32 v96 = v5[69].i32[(v11 - 3)];
                  v5[81].i32[0] = v11 - 4;
                  __int32 v97 = v5[69].i32[(v11 - 4)];
                  v5[81].i32[0] = v94;
                  unsigned int v98 = v5[69].u32[v94];
                  unsigned __int32 v99 = v11 - 6;
                  goto LABEL_100;
                case 28:
                  v5[66].i8[1] = 0;
                  unsigned int v149 = (char *)v5 + 4 * (v11 - 2);
                  unsigned int v150 = 1103515245 * v5[68].i32[0] + 12345;
                  v5[68].i32[0] = v150;
                  v5[81].i32[0] = v113;
                  *((_DWORD *)v149 + 138) = HIWORD(v150) + 1;
                  goto LABEL_91;
                case 29:
                  v5[81].i32[0] = v11 - 2;
                  if (v11 == 2)
                  {
                    unsigned int v197 = __cxa_allocate_exception(0x10uLL);
                    *(void *)unsigned int v197 = &unk_1F0DFC400;
                    v197[4] = 5;
                  }
                  v5[69].i32[(v11 - 2)] = v5[69].i32[(v11 - 3)];
                  goto LABEL_131;
                case 30:
                  if (v11 <= 2)
                  {
                    uint64_t v200 = __cxa_allocate_exception(0x10uLL);
                    *(void *)uint64_t v200 = &unk_1F0DFC400;
                    v200[4] = 5;
                  }
                  v5[81].i32[0] = v11 - 3;
                  unint64_t v125 = v5 + 69;
                  __int32 v126 = v5[69].i32[(v11 - 3)];
                  v5[69].i32[(v11 - 3)] = v5[67].i32[(int)v11];
                  goto LABEL_130;
                default:
                  uint64_t v204 = __cxa_allocate_exception(0x10uLL);
                  *(void *)uint64_t v204 = &unk_1F0DFC400;
                  v204[4] = 5;
              }
            }
            uint64_t v182 = __cxa_allocate_exception(0x10uLL);
            *(void *)uint64_t v182 = &unk_1F0DFC400;
            v182[4] = 5;
          case 0x11u:
            goto LABEL_91;
          case 0x13u:
            unsigned int v181 = __cxa_allocate_exception(0x10uLL);
            *(void *)unsigned int v181 = &unk_1F0DFC400;
            v181[4] = 5;
          case 0x18u:
            __int32 v88 = v11 - 1;
            v5[81].i32[0] = v11 - 1;
            uint64_t v89 = v5 + 69;
            int v90 = v5[68].i32[(int)v11 + 1];
            __int32 v91 = v11 - 2;
            v5[81].i32[0] = v91;
            unsigned int v92 = vcvtd_n_s64_f64((double)v90 * 0.0000152587891 * ((double)v5[69].i32[v91] * 0.0000152587891), 0x10uLL);
LABEL_109:
            v5[81].i32[0] = v88;
            v89->i32[v91] = v92;
            goto LABEL_91;
          case 0x19u:
            __int32 v94 = v11 - 1;
            if (v11 <= 1)
            {
              uint64_t v180 = __cxa_allocate_exception(0x10uLL);
              *(void *)uint64_t v180 = &unk_1F0DFC400;
              v180[4] = 5;
            }
            v5[81].i32[0] = v94;
            int v110 = v5 + 69;
            int v111 = v5[69].i32[v94];
            unsigned __int32 v112 = v11 - 2;
            v5[81].i32[0] = v112;
            if (v5[68].i8[4]) {
LABEL_118:
            }
              v5[68].i8[4] = 0;
LABEL_119:
            long long v100 = (int *)v110 + v112;
            unsigned int v98 = vcvtd_n_s64_f64((double)*v100 * 0.0000152587891 / ((double)v111 * 0.0000152587891), 0x10uLL);
            goto LABEL_120;
          case 0x1Au:
            v5[69].i32[v11] = v5[68].i32[(int)v11 + 1];
            goto LABEL_131;
          case 0x1Bu:
            v5[81].i32[0] = v11 - 1;
            unint64_t v125 = v5 + 69;
            __int32 v126 = v5[68].i32[(int)v11 + 1];
            v5[68].i32[(int)v11 + 1] = v5[68].i32[(int)v11];
LABEL_130:
            v125->i32[v5[81].i32[0] - 1] = v126;
LABEL_131:
            int v127 = v5[81].i32[0] + 1;
LABEL_132:
            v5[81].i32[0] = v127;
            break;
          case 0x1Cu:
            __int32 v101 = v11 - 1;
            if (v11 <= 1)
            {
              uint64_t v179 = __cxa_allocate_exception(0x10uLL);
              *(void *)uint64_t v179 = &unk_1F0DFC400;
              v179[4] = 5;
            }
            v5[81].i32[0] = v101;
            uint64_t v102 = v5[69].u32[v101];
            __int32 v103 = v11 - 2;
            v5[81].i32[0] = v103;
            if (v102 >= *(unsigned __int16 *)(*(void *)&v5[3] + 80))
            {
              long long v178 = __cxa_allocate_exception(0x10uLL);
              *(void *)long long v178 = &unk_1F0DFC400;
              v178[4] = 5;
            }
            *(_DWORD *)(*(void *)&v5[67] + 4 * v102) = v5[69].i32[v103];
            break;
          case 0x1Du:
            v5[66].i8[1] = 0;
            unsigned __int32 v104 = v11 - 1;
            if (v11 <= 1)
            {
              v177 = __cxa_allocate_exception(0x10uLL);
              *(void *)v177 = &unk_1F0DFC400;
              v177[4] = 5;
            }
            v5[81].i32[0] = v104;
            long long v105 = (char *)v5 + 4 * v104;
            uint64_t v106 = *((unsigned int *)v105 + 138);
            if (v106 >= *(unsigned __int16 *)(*(void *)&v5[3] + 80))
            {
              uint64_t v176 = __cxa_allocate_exception(0x10uLL);
              *(void *)uint64_t v176 = &unk_1F0DFC400;
              v176[4] = 5;
            }
            int v107 = *(_DWORD *)(*(void *)&v5[67] + 4 * v106);
            v5[81].i32[0] = v11;
            *((_DWORD *)v105 + 138) = v107;
            break;
          case 0x1Eu:
            v5[66].i8[1] = 0;
            __int32 v94 = v11 - 3;
            if (v11 <= 3)
            {
              unsigned __int16 v175 = __cxa_allocate_exception(0x10uLL);
              *(void *)unsigned __int16 v175 = &unk_1F0DFC400;
              v175[4] = 5;
            }
            v5[81].i32[0] = v11 - 1;
            int32x4_t v95 = v5 + 69;
            __int32 v96 = v5[69].i32[(v11 - 1)];
            v5[81].i32[0] = v11 - 2;
            __int32 v97 = v5[69].i32[(v11 - 2)];
            v5[81].i32[0] = v94;
            unsigned int v98 = v5[69].u32[v94];
            unsigned __int32 v99 = v11 - 4;
LABEL_100:
            v5[81].i32[0] = v99;
            long long v100 = (int *)v95 + v99;
            if (v97 <= v96) {
              unsigned int v98 = *v100;
            }
LABEL_120:
            v5[81].i32[0] = v94;
            *long long v100 = v98;
            break;
          case 0x21u:
            int v174 = __cxa_allocate_exception(0x10uLL);
            *(void *)int v174 = &unk_1F0DFC400;
            v174[4] = 5;
          default:
            int v186 = __cxa_allocate_exception(0x10uLL);
            *(void *)int v186 = &unk_1F0DFC400;
            v186[4] = 5;
        }
        goto LABEL_91;
      case 0xDu:
        if (v11 != 2)
        {
          unsigned int v163 = __cxa_allocate_exception(0x10uLL);
          *(void *)unsigned int v163 = &unk_1F0DFC400;
          v163[4] = 5;
        }
        v5[81].i32[0] = 0;
        v5[84].i32[0] = 0;
        v5[85].i32[0] = 0;
        v5[82].i32[0] = 0;
        v5[83].i32[0] = 0;
        int32x2_t v27 = v5[69];
        v5[83].i32[1] = v27.i32[0];
        int8x8_t v28 = vand_s8((int8x8_t)vadd_s32(v27, (int32x2_t)0x800000008000), (int8x8_t)0xFFFF0000FFFF0000);
        v5[84].i32[1] = v28.i32[0];
        v5[81].i32[1] = v27.i32[0];
        v5[82].i32[1] = v28.i32[0];
        *(int8x8_t *)uint64_t v210 = v28;
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0xDu, 2, (int *)v210);
        goto LABEL_90;
      case 0xEu:
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0xEu, 0, (int *)v210);
        goto LABEL_90;
      case 0x1Eu:
        if (v11 != 4)
        {
          int v162 = __cxa_allocate_exception(0x10uLL);
          *(void *)int v162 = &unk_1F0DFC400;
          v162[4] = 5;
        }
        int32x2_t v67 = vadd_s32(vrev64_s32(*(int32x2_t *)(v6 + 100)), v5[69]);
        int32x2_t v68 = (int32x2_t)vand_s8((int8x8_t)vadd_s32(v67, (int32x2_t)0x800000008000), (int8x8_t)0xFFFF0000FFFF0000);
        *(int32x2_t *)v69.i8 = vadd_s32(v67, v5[70]);
        v5[81].i32[0] = 0;
        __int32 v70 = v5[82].i32[1];
        *(_DWORD *)uint64_t v210 = v68.i32[0] - v5[83].i32[0];
        *(_DWORD *)&v210[4] = v68.i32[1] - v70;
        v69.u64[1] = (unint64_t)vand_s8((int8x8_t)vadd_s32(*(int32x2_t *)v69.i8, (int32x2_t)0x800000008000), (int8x8_t)0xFFFF0000FFFF0000);
        *(int32x4_t *)&v5[81].u8[4] = vrev64q_s32(v69);
        *(int32x2_t *)&v210[8] = vsub_s32((int32x2_t)v69.u64[1], v68);
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0x1Eu, 4, (int *)v210);
        goto LABEL_90;
      case 0x1Fu:
        if (v11 != 4)
        {
          long long v161 = __cxa_allocate_exception(0x10uLL);
          *(void *)long long v161 = &unk_1F0DFC400;
          v161[4] = 5;
        }
        v5[81].i32[0] = 0;
        __int32 v50 = v5[70].i32[1];
        int v51 = v5[81].i32[1] + v5[69].i32[0];
        unsigned int v52 = (v51 + 0x8000) & 0xFFFF0000;
        unsigned __int32 v53 = v52 - v5[82].i32[1];
        __int32 v54 = v51 + v5[69].i32[1];
        int v55 = v5[82].i32[0] + v5[70].i32[0];
        __int32 v56 = v5[83].i32[0];
        v5[81].i32[1] = v54;
        unsigned int v57 = (v54 + 0x8000) & 0xFFFF0000;
        v5[82].i32[1] = v57;
        unsigned int v58 = v57 - v52;
        unsigned int v59 = (v55 + 0x8000) & 0xFFFF0000;
        *(_DWORD *)uint64_t v210 = v53;
        *(_DWORD *)&v210[4] = v58;
        __int32 v60 = v55 + v50;
        v5[82].i32[0] = v60;
        unsigned int v61 = (v60 + 0x8000) & 0xFFFF0000;
        v5[83].i32[0] = v61;
        *(_DWORD *)&v210[8] = v59 - v56;
        *(_DWORD *)&v210[12] = v61 - v59;
        this = (uint64_t)TBufferedCharStringStreamingContext::BufferCharData((TBufferedCharStringStreamingContext *)v5, 0x1Fu, 4, (int *)v210);
        goto LABEL_90;
      default:
        if (v13 <= 0xF6)
        {
          v5[81].i32[0] = v11 + 1;
          v5[69].i32[v11] = (v13 << 16) - 9109504;
          goto LABEL_90;
        }
        if (v13 <= 0xFA)
        {
          __int16 v29 = v10 + 2;
          if ((unint64_t)(v10 + 2) > v8)
          {
            unsigned int v170 = __cxa_allocate_exception(0x10uLL);
            *(void *)unsigned int v170 = &unk_1F0DFC400;
            v170[4] = 5;
          }
          int v75 = (*v12 << 16) | (v13 << 24);
          int v76 = 158072832;
LABEL_72:
          unsigned int v78 = v75 + v76;
LABEL_73:
          v5[81].i32[0] = v11 + 1;
          v5[69].i32[v11] = v78;
          goto LABEL_91;
        }
        if (v13 != 255)
        {
          __int16 v29 = v10 + 2;
          if ((unint64_t)(v10 + 2) > v8)
          {
            int v171 = __cxa_allocate_exception(0x10uLL);
            *(void *)int v171 = &unk_1F0DFC400;
            v171[4] = 5;
          }
          int v75 = -9109504 - ((*v12 << 16) | (v13 << 24));
          int v76 = -81854464;
          goto LABEL_72;
        }
        if ((unint64_t)v12 > 0xFFFFFFFFFFFFFFFBLL || (unint64_t)(v10 + 5) > v8)
        {
          unsigned int v173 = __cxa_allocate_exception(0x10uLL);
          *(void *)unsigned int v173 = &unk_1F0DFC400;
          v173[4] = 5;
        }
        __int16 v29 = v10 + 5;
        unsigned int v82 = bswap32(*(_DWORD *)(v10 + 1));
        if (v82 + 32000 <= 0xFA00)
        {
          unsigned int v78 = v82 << 16;
          goto LABEL_73;
        }
        v5[81].i32[0] = v11 + 1;
        v5[69].i32[v11] = v82;
        v5[68].i8[4] = 1;
LABEL_91:
        int v10 = v29;
        if ((unint64_t)v29 < v8) {
          continue;
        }
        return this;
    }
  }
}

uint64_t TBufferedCharStringStreamingContext::DoCharString(TBufferedCharStringStreamingContext *this, uint64_t a2, char *a3, uint64_t a4)
{
  *((void *)this + 67) = a4;
  __int16 v6 = *((_WORD *)this + 260);
  if ((*((__int16 *)this + 261) & 0x80000000) == 0) {
    std::vector<unsigned char>::__insert_with_size[abi:fe180100]<unsigned char const*,unsigned char const*>((uint64_t)this + 136, *((char **)this + 18), a3, &a3[*((unsigned __int16 *)this + 261)], *((unsigned __int16 *)this + 261));
  }
  long long v7 = *(const unsigned __int8 **)(a2 + 280);
  if (v7)
  {
    TBufferedCharStringStreamingContext::ProcessCharString((uint64_t)this, v7, *(_DWORD *)(a2 + 288), 0);
  }
  else if (*((unsigned char *)this + 530))
  {
    if (*((__int16 *)this + 261) == -1)
    {
      char __src = 14;
      std::vector<unsigned char>::__insert_with_size[abi:fe180100]<unsigned char const*,unsigned char const*>((uint64_t)this + 136, *((char **)this + 18), &__src, &v19, 1);
    }
    else
    {
      TBufferedCharStringStreamingContext::CharBufferAndEncrypt(this, kEndChar, 1u);
    }
  }
  if (*((unsigned char *)this + 530))
  {
    TBufferedCharStringStreamingContext::StreamCharHeader((uint64_t)this, a2, *((_DWORD *)this + 36) - *((_DWORD *)this + 34));
  }
  else
  {
    uint64_t v8 = *(void *)(a2 + 288);
    if (*((__int16 *)this + 261) < 0)
    {
      TBufferedCharStringStreamingContext::StreamCharHeader((uint64_t)this, a2, v8);
      unint64_t v12 = *(char **)(a2 + 280);
      if (v12)
      {
        int64_t v13 = *(unsigned int *)(a2 + 288);
        __int32 v14 = (char *)this + 136;
        int v15 = (char *)*((void *)this + 18);
        unsigned int v16 = &v12[v13];
      }
      else
      {
        char v19 = 14;
        __int32 v14 = (char *)this + 136;
        int v15 = (char *)*((void *)this + 18);
        unsigned int v16 = (char *)&v20;
        unint64_t v12 = &v19;
        int64_t v13 = 1;
      }
      std::vector<unsigned char>::__insert_with_size[abi:fe180100]<unsigned char const*,unsigned char const*>((uint64_t)v14, v15, v12, v16, v13);
    }
    else
    {
      TBufferedCharStringStreamingContext::StreamCharHeader((uint64_t)this, a2, v8 + *((unsigned __int16 *)this + 261));
      __int16 v9 = *(char **)(a2 + 280);
      if (v9)
      {
        unsigned int v10 = *(_DWORD *)(a2 + 288);
        uint64_t v11 = this;
      }
      else
      {
        __int16 v9 = kEndChar;
        uint64_t v11 = this;
        unsigned int v10 = 1;
      }
      TBufferedCharStringStreamingContext::CharBufferAndEncrypt(v11, v9, v10);
    }
  }
  std::vector<unsigned char>::__insert_with_size[abi:fe180100]<unsigned char const*,unsigned char const*>((uint64_t)this + 136, *((char **)this + 18), " ND\r", "", 4);
  *((_WORD *)this + 260) = v6;
  return TBufferedCharStringStreamingContext::BufferCharBuffer((uint64_t)this);
}

BOOL TType1PSFont::CheckSubrs(TType1PSFont *this, unsigned int *a2)
{
  uint64_t v2 = *((void *)this + 4);
  uint64_t v3 = *(unsigned __int16 *)(v2 + 144);
  if (v3 < 4) {
    return 0;
  }
  if (*(_WORD *)(v2 + 146) != 4)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 8;
  }
  uint64_t v4 = *(void *)(v2 + 120);
  if (!v4) {
    return 0;
  }
  __int16 v6 = *(const unsigned __int8 **)(v2 + 112);
  long long v7 = &v6[v4];
  uint64_t v8 = &v6[4 * v3 + 4];
  BOOL v9 = CheckSubr(0, v6, v8, &v6[v4], (const char *)&SUBR0, 0xBuLL);
  BOOL result = 0;
  if (v9)
  {
    BOOL result = CheckSubr(1, v6, v8, v7, (const char *)&SUBR1, 5uLL);
    if (result)
    {
      BOOL result = CheckSubr(2, v6, v8, v7, (const char *)&SUBR2, 5uLL);
      if (result)
      {
        BOOL result = CheckSubr(3, v6, v8, v7, "\v", 1uLL);
        if (result)
        {
          *a2 = 0;
          if (v3 >= 5)
          {
            if (CheckSubr(4, v6, v8, v7, SUBR4V1, 8uLL))
            {
              unsigned int v11 = 1;
LABEL_15:
              *a2 = v11;
              return 1;
            }
            if (CheckSubr(4, v6, v8, v7, (const char *)&SUBR4V2, 9uLL))
            {
              unsigned int v11 = 2;
              goto LABEL_15;
            }
          }
          return 1;
        }
      }
    }
  }
  return result;
}

BOOL CheckSubr(int a1, const unsigned __int8 *a2, const unsigned __int8 *a3, const unsigned __int8 *a4, const char *__s1, size_t __n)
{
  __int16 v6 = (unsigned int *)&a2[4 * a1];
  unsigned int v7 = v6[1];
  uint64_t v8 = bswap32(*v6);
  if (bswap32(v7) - v8 == __n
    && ((BOOL v9 = &a3[v8 - 1], v10 = (unint64_t)&v9[__n], v10 <= (unint64_t)a4)
      ? (BOOL v11 = v9 >= a3)
      : (BOOL v11 = 0),
        v11 ? (BOOL v12 = v10 >= (unint64_t)v9) : (BOOL v12 = 0),
        v12))
  {
    return memcmp(__s1, v9, __n) == 0;
  }
  else
  {
    return 0;
  }
}

uint64_t TType1PSFont::StreamType1Font(void *a1, uint64_t a2, const char *a3, const char *a4, uint64_t a5, int a6, char a7, uint64_t a8)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = (*(uint64_t (**)(void *))(*a1 + 88))(a1);
  if (v14) {
    int v15 = (const char *)v14;
  }
  else {
    int v15 = "\a001.003";
  }
  time_t v43 = time(0);
  memset(&v42, 0, sizeof(v42));
  if (v43 != -1) {
    gmtime_r(&v43, &v42);
  }
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v67 = v16;
  long long v68 = v16;
  long long v65 = v16;
  long long v66 = v16;
  long long v63 = v16;
  long long v64 = v16;
  long long v61 = v16;
  long long v62 = v16;
  long long v59 = v16;
  long long v60 = v16;
  long long v57 = v16;
  long long v58 = v16;
  long long v55 = v16;
  long long v56 = v16;
  *(_OWORD *)__str = v16;
  long long v54 = v16;
  uint64_t v17 = a1[4];
  uint64_t v18 = *(int *)(v17 + 76);
  if (v18 == -1 || (uint64_t v19 = *(void *)(v17 + 48)) == 0)
  {
    if (a3)
    {
      unint64_t v22 = strlen(a3);
      int v21 = (char *)a3;
    }
    else
    {
      int v21 = __str;
      unint64_t v22 = snprintf(__str, 0xFFuLL, "Font_%ld", v43);
    }
LABEL_18:
    if (v22 >= 0x100)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DFC400;
      exception[4] = 8;
    }
    goto LABEL_19;
  }
  uint64_t v20 = v19 + v18;
  if (a3) {
    int v21 = (char *)a3;
  }
  else {
    int v21 = (char *)(v20 + 1);
  }
  if (!a4 || a3 && strcmp(a3, (const char *)(v20 + 1)))
  {
    unint64_t v22 = strlen(v21);
    goto LABEL_18;
  }
  size_t v36 = strlen(v21);
  unint64_t v22 = v36 + strlen(a4) + 1;
  if (v22 >= 0x100)
  {
    int v38 = __cxa_allocate_exception(0x10uLL);
    *(void *)int v38 = &unk_1F0DFC400;
    v38[4] = 8;
  }
  int v39 = v21;
  int v21 = __str;
  snprintf(__str, 0xFFuLL, "%s_%s", v39, a4);
LABEL_19:
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"%!FontType1-1.0: ", 0x11uLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)v21, v22);
  v45[0] = 32;
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)v45, 1uLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)v15 + 1, *(unsigned __int8 *)v15);
  v45[0] = 13;
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)v45, 1uLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"%%CreationDate: ", 0x10uLL);
  *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v51 = v23;
  long long v52 = v23;
  long long v49 = v23;
  long long v50 = v23;
  long long v47 = v23;
  long long v48 = v23;
  *(_OWORD *)BOOL v45 = v23;
  long long v46 = v23;
  int v24 = snprintf(v45, 0x7FuLL, "%d/%d/%02d", v42.tm_mon + 1, v42.tm_mday, v42.tm_year % 100);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)v45, v24);
  unsigned __int8 v44 = 13;
  TBufferedStreamingContext::BufferString(a8, &v44, 1uLL);
  int v25 = snprintf(v45, 0x7FuLL, "%% Copyright %d Apple Inc. and its licensors, all rights reserved.\r", v42.tm_year + 1900);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)v45, v25);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"11 dict begin\r/FontInfo 9 dict dup begin\r", 0x29uLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/version (", 0xAuLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)v15 + 1, *(unsigned __int8 *)v15);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)") readonly def\r", 0xFuLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/FullName (", 0xBuLL);
  int v26 = (unsigned __int8 *)(*(uint64_t (**)(void *))(*a1 + 72))(a1);
  if (v26 || (int v26 = (unsigned __int8 *)(*(uint64_t (**)(void *))(*a1 + 80))(a1)) != 0) {
    TBufferedStreamingContext::BufferString(a8, v26 + 1, *v26);
  }
  else {
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)v21, v22);
  }
  if (a4)
  {
    unsigned __int8 v44 = 32;
    TBufferedStreamingContext::BufferString(a8, &v44, 1uLL);
    size_t v27 = strlen(a4);
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)a4, v27);
  }
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)") readonly def\r", 0xFuLL);
  int8x8_t v28 = (unsigned __int8 *)(*(uint64_t (**)(void *))(*a1 + 80))(a1);
  if (v28)
  {
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/FamilyName (", 0xDuLL);
    TBufferedStreamingContext::BufferString(a8, v28 + 1, *v28);
    if (a4)
    {
      unsigned __int8 v44 = 32;
      TBufferedStreamingContext::BufferString(a8, &v44, 1uLL);
      size_t v29 = strlen(a4);
      TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)a4, v29);
    }
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)") readonly def\r", 0xFuLL);
  }
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/Weight (SnapShot) readonly def\r", 0x20uLL);
  int v30 = (_DWORD *)a1[4];
  unsigned int v31 = v30[38];
  if (v31)
  {
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/ItalicAngle ", 0xDuLL);
    FixedToPString(v31, 2, (unsigned __int8 *)(a8 + 66));
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
    TBufferedStreamingContext::BufferString(a8, " def\r", 5uLL);
    int v30 = (_DWORD *)a1[4];
  }
  if ((*(unsigned int (**)(_DWORD *))(*(void *)v30 + 312))(v30)) {
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/isFixedPitch true def\r", 0x17uLL);
  }
  else {
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/isFixedPitch false def\r", 0x18uLL);
  }
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/UnderlinePosition ", 0x13uLL);
  unint64_t v32 = (*(uint64_t (**)(void))(*(void *)a1[4] + 296))(a1[4]);
  IntToPString(v32, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, " def\r", 5uLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/UnderlineThickness ", 0x14uLL);
  unint64_t v33 = (*(uint64_t (**)(void))(*(void *)a1[4] + 304))(a1[4]);
  IntToPString(v33, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, " def\r", 5uLL);
  unint64_t v34 = *(_WORD *)(a1[4] + 178) & 0x30E;
  if ((*(_WORD *)(a1[4] + 178) & 0x30E) != 0)
  {
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/FSType ", 8uLL);
    IntToPString(v34, (unsigned __int8 *)(a8 + 66));
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
    TBufferedStreamingContext::BufferString(a8, " def\r", 5uLL);
  }
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"end readonly def\r", 0x11uLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/FontName /", 0xBuLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)v21, v22);
  TBufferedStreamingContext::BufferString(a8, " def\r", 5uLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/PaintType ", 0xBuLL);
  IntToPString(*(unsigned __int16 *)(a2 + 60), (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, " def\r", 5uLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/FontType 1 def\r", 0x10uLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/FontMatrix [", 0xDuLL);
  FractToPString(*(_DWORD *)(*(void *)(a8 + 24) + 4), 4, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  unsigned __int8 v44 = 32;
  TBufferedStreamingContext::BufferString(a8, &v44, 1uLL);
  FractToPString(*(_DWORD *)(*(void *)(a8 + 24) + 8), 4, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  unsigned __int8 v44 = 32;
  TBufferedStreamingContext::BufferString(a8, &v44, 1uLL);
  FractToPString(*(_DWORD *)(*(void *)(a8 + 24) + 12), 4, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  unsigned __int8 v44 = 32;
  TBufferedStreamingContext::BufferString(a8, &v44, 1uLL);
  FractToPString(*(_DWORD *)(*(void *)(a8 + 24) + 16), 4, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  unsigned __int8 v44 = 32;
  TBufferedStreamingContext::BufferString(a8, &v44, 1uLL);
  FractToPString(*(_DWORD *)(*(void *)(a8 + 24) + 20), 4, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  unsigned __int8 v44 = 32;
  TBufferedStreamingContext::BufferString(a8, &v44, 1uLL);
  FractToPString(*(_DWORD *)(*(void *)(a8 + 24) + 24), 4, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"] readonly def\r", 0xFuLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/Encoding ", 0xAuLL);
  TBufferedStreamingContext::StreamBuffer(a8);
  TBufferedStreamingContext::StreamBuffer(a8);
  (*(void (**)(void *, uint64_t, void, void))(*a1 + 256))(a1, a5, 0, *(void *)(a8 + 32));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"/FontBBox {", 0xBuLL);
  FixedToPString(*(_DWORD *)(a8 + 160), 3, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  unsigned __int8 v44 = 32;
  TBufferedStreamingContext::BufferString(a8, &v44, 1uLL);
  FixedToPString(*(_DWORD *)(a8 + 164), 3, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  unsigned __int8 v44 = 32;
  TBufferedStreamingContext::BufferString(a8, &v44, 1uLL);
  FixedToPString(*(_DWORD *)(a8 + 168), 3, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  unsigned __int8 v44 = 32;
  TBufferedStreamingContext::BufferString(a8, &v44, 1uLL);
  FixedToPString(*(_DWORD *)(a8 + 172), 3, (unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)(a8 + 67), *(unsigned __int8 *)(a8 + 66));
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"} readonly def\r", 0xFuLL);
  TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"currentdict end\r", 0x10uLL);
  if (a6)
  {
    TBufferedStreamingContext::BeginEexec((TBufferedStreamingContext *)a8, 1, a7);
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 272))(a1, a2, a8);
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"noaccess put\rdup /FontName get exch definefont pop\r", 0x33uLL);
    return TBufferedStreamingContext::EndEexec(a8);
  }
  else
  {
    TBufferedStreamingContext::BufferString(a8, "systemdict begin\r", 0x11uLL);
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 272))(a1, a2, a8);
    TBufferedStreamingContext::BufferString(a8, (const unsigned __int8 *)"noaccess put\rdup /FontName get exch definefont pop\r", 0x33uLL);
    return TBufferedStreamingContext::BufferString(a8, "end\r", 4uLL);
  }
}

void sub_1B5305AF0(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TType1PSFont::StreamPrivateFontDict(uint64_t a1, uint64_t a2, TBufferedStreamingContext *this)
{
  TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"dup /Private 20 dict dup begin\r", 0x1FuLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"/RD {string currentfile exch readstring pop} executeonly def\r", 0x3DuLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"/ND {noaccess def} executeonly def\r", 0x23uLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"/NP {noaccess put} executeonly def\r", 0x23uLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"/MinFeature {16 16} def\r", 0x18uLL);
  TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"/password 5839 def\r", 0x13uLL);
  TBufferedCharStringStreamingContext::BufferBlueValues((uint64_t)this, "\r/BlueValues [", 0);
  TBufferedCharStringStreamingContext::BufferBlueValues((uint64_t)this, "\r/OtherBlues [", 1);
  TBufferedCharStringStreamingContext::BufferFamilyBlues((uint64_t)this, kFamilyBluesString, 0);
  TBufferedCharStringStreamingContext::BufferFamilyBlues((uint64_t)this, kFamilyOtherBluesString, 1);
  TBufferedCharStringStreamingContext::BufferStdW((uint64_t)this);
  TBufferedCharStringStreamingContext::BufferStemSnap((uint64_t)this);
  if (*(_WORD *)(a2 + 70))
  {
    TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"/LanguageGroup ", 0xFuLL);
    IntToPString(*(unsigned __int16 *)(a2 + 70), (unsigned __int8 *)this + 66);
    TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)this + 67, *((unsigned __int8 *)this + 66));
    TBufferedStreamingContext::BufferString((uint64_t)this, " def\r", 5uLL);
    if (*(_WORD *)(a2 + 70) == 1) {
      TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"/RndStemUp false def\r", 0x15uLL);
    }
    if (*(_DWORD *)(a2 + 44))
    {
      TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"/ExpansionFactor ", 0x11uLL);
      FixedToPString(*(_DWORD *)(a2 + 44), 3, (unsigned __int8 *)this + 66);
      TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)this + 67, *((unsigned __int8 *)this + 66));
      TBufferedStreamingContext::BufferString((uint64_t)this, " def\r", 5uLL);
    }
  }
  TBufferedCharStringStreamingContext::BufferBlueStuff((uint64_t)this);
  TBufferedCharStringStreamingContext::BufferForceBold((uint64_t)this);
  TBufferedStreamingContext::BufferString((uint64_t)this, otherSubrs, 0x14E2uLL);
  (*(void (**)(TBufferedStreamingContext *))(*(void *)this + 16))(this);
  (*(void (**)(uint64_t, uint64_t, TBufferedStreamingContext *))(*(void *)a1 + 280))(a1, a2, this);
  return TBufferedStreamingContext::BufferString((uint64_t)this, (const unsigned __int8 *)"end\rreadonly put\r", 0x11uLL);
}

void TType1PSFont::StreamCharData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4 = *(unsigned __int16 *)(a2 + 80);
  __p.__end_ = (std::vector<int>::pointer)0xAAAAAAAAAAAAAAAALL;
  __p.__end_cap_.__value_ = (int *)0xAAAAAAAAAAAAAAAALL;
  if (v4) {
    std::vector<int>::size_type v5 = v4;
  }
  else {
    std::vector<int>::size_type v5 = 32;
  }
  __p.__begin_ = (std::vector<int>::pointer)0xAAAAAAAAAAAAAAAALL;
  std::vector<int>::vector(&__p, v5);
  std::vector<int>::pointer begin = __p.__begin_;
  unsigned int v7 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a3 + 8) + 32) + 168))(*(void *)(*(void *)(a3 + 8) + 32));
  if (v7 >= 0xFFFF) {
    int v9 = 0xFFFF;
  }
  else {
    int v9 = v7;
  }
  unint64_t v10 = *(__int32 **)(a3 + 16);
  if (v10 && v9)
  {
    unsigned int v11 = v9 + 31;
    LOWORD(v9) = 0;
    unsigned int v12 = v11 >> 5;
    do
    {
      if (*v10)
      {
        v8.i32[0] = *v10;
        int8x8_t v8 = vcnt_s8(v8);
        LOWORD(v9) = vaddlv_u8((uint8x8_t)v8) + v9;
      }
      ++v10;
      --v12;
    }
    while (v12);
  }
  TBufferedStreamingContext::BufferString(a3, (const unsigned __int8 *)"2 index /CharStrings ", 0x15uLL);
  IntToPString((unsigned __int16)v9, (unsigned __int8 *)(a3 + 66));
  TBufferedStreamingContext::BufferString(a3, (const unsigned __int8 *)(a3 + 67), *(unsigned __int8 *)(a3 + 66));
  TBufferedStreamingContext::BufferString(a3, " dict dup begin\r", 0x10uLL);
  TBufferedStreamingContext::StreamBuffer(a3);
  uint64_t v13 = 0;
  int v21 = 0;
  __int16 v14 = 4330;
  do
  {
    int v15 = *((unsigned __int8 *)&v21 + v13) ^ ((unsigned __int16)(v14 & 0xFF00) >> 8);
    __int16 v14 = 22719 - 12691 * (v14 + (*((unsigned char *)&v21 + v13) ^ ((unsigned __int16)(v14 & 0xFF00) >> 8)));
    *((unsigned char *)&v21 + v13++) = v15;
  }
  while (v13 != 4);
  unsigned int v16 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a3 + 8) + 32) + 168))(*(void *)(*(void *)(a3 + 8) + 32));
  if (v16 >= 0xFFFF) {
    int v17 = 0xFFFF;
  }
  else {
    int v17 = v16;
  }
  if (v17)
  {
    unsigned int v18 = 0;
    uint64_t v19 = *(void *)(a3 + 16);
    do
    {
      if (((*(_DWORD *)(v19 + 4 * (v18 >> 5)) << v18) & 0x80000000) != 0)
      {
        *(_WORD *)(a3 + 522) = 4;
        *(_WORD *)(a3 + 520) = v14;
        *(_DWORD *)(a3 + 544) = 0;
        *(_WORD *)(a3 + 529) = 257;
        *(unsigned char *)(a3 + 548) = 0;
        *(_OWORD *)(a3 + 648) = 0u;
        *(_OWORD *)(a3 + 664) = 0u;
        *(_DWORD *)(a3 + 680) = 0;
        (*(void (**)(uint64_t, void, void, int *, std::vector<int>::pointer))(*(void *)a3 + 24))(a3, *(void *)(a3 + 8), (unsigned __int16)v18, &v21, begin);
      }
      ++v18;
    }
    while (v17 != v18);
  }
  TBufferedStreamingContext::BufferString(a3, "end\r", 4uLL);
  if (__p.__begin_)
  {
    __p.__end_ = __p.__begin_;
    operator delete(__p.__begin_);
  }
}

void sub_1B5305FFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (a2 == 1)
  {
    unsigned int v12 = __cxa_begin_catch(exception_object);
    *(_WORD *)(v10 + 64) = v12[4];
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = v12[4];
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MStreamSnapShotContext::~MStreamSnapShotContext(MStreamSnapShotContext *this)
{
}

const char *MStreamSnapShotContext::MakeInstanceName(MStreamSnapShotContext *this, char *__s, uint64_t a3)
{
  uint64_t v3 = __s;
  if (__s)
  {
    if (*((void *)this + 2))
    {
      *__s = 0;
      if (*((__int16 *)this + 12) >= 1)
      {
        uint64_t v6 = 0;
        do
        {
          int v7 = *(_DWORD *)(*((void *)this + 2) + 4 * v6);
          if (v7 >= -32) {
            int v8 = (1000 * v7 + 0x8000) >> 16;
          }
          else {
            int v8 = -((1000 * v7 + 0x8000) >> 16);
          }
          if (v6)
          {
            size_t v9 = strlen(v3);
            snprintf((char *)&v3[v9], a3 - v9, "_");
          }
          size_t v10 = strlen(v3);
          snprintf((char *)&v3[v10], a3 - v10, "%x", v8);
          ++v6;
        }
        while (v6 < *((__int16 *)this + 12));
      }
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t MStreamSnapShotContext::BlendValue(uint64_t this, TBufferedCharStringStreamingContext *a2, int *a3, int a4)
{
  if (a4)
  {
    unsigned int v4 = &a3[a4];
    int v5 = *(unsigned __int16 *)(this + 24);
    int v6 = v5 - 1;
    uint64_t v7 = 4 * (unsigned __int16)(v5 - 2) + 4;
    uint64_t v8 = *(void *)(this + 16) + 4;
    do
    {
      int v10 = *a3++;
      int v9 = v10;
      if ((_WORD)v6)
      {
        unsigned int v11 = (int *)v8;
        int v12 = v6;
        uint64_t v13 = v4;
        do
        {
          int v14 = *v11++;
          double v15 = (double)v14 * 0.0000152587891;
          int v16 = *v13++;
          v9 += vcvtd_n_s64_f64(v15 * ((double)v16 * 0.0000152587891), 0x10uLL);
          --v12;
        }
        while ((_WORD)v12);
        unsigned int v4 = (int *)((char *)v4 + v7);
      }
      --a4;
      uint64_t v17 = *((int *)a2 + 162);
      *((_DWORD *)a2 + 162) = v17 + 1;
      *((_DWORD *)a2 + v17 + 138) = v9;
    }
    while ((_WORD)a4);
  }
  return this;
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<unsigned int>::__vallocate[abi:fe180100](this, __n);
    std::vector<unsigned int>::pointer end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_1B53062AC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned int>::__vallocate[abi:fe180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::vector<unsigned int>::__throw_length_error[abi:fe180100]();
  }
  BOOL result = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<int>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void std::vector<unsigned int>::__throw_length_error[abi:fe180100]()
{
}

void *std::vector<unsigned char>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:fe180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    int v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B530637C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned char>::__vallocate[abi:fe180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    std::vector<unsigned char>::__throw_length_error[abi:fe180100]();
  }
  BOOL result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  int v5 = (char *)a1[1];
  uint64_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    uint64_t v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      std::vector<unsigned char>::__throw_length_error[abi:fe180100]();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    int v12 = &v7[v11];
    uint64_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      int v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      int v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void std::vector<char>::__append(std::vector<char> *this, std::vector<char>::size_type __n)
{
  std::vector<unsigned int>::pointer end = this->__end_;
  FontParser::Language value = this->__end_cap_.__value_;
  if (value - end >= __n)
  {
    if (__n)
    {
      bzero(this->__end_, __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    std::vector<char>::pointer begin = this->__begin_;
    int64_t v7 = end - this->__begin_;
    unint64_t v8 = v7 + __n;
    if ((uint64_t)(v7 + __n) < 0) {
      std::vector<unsigned int>::__throw_length_error[abi:fe180100]();
    }
    unint64_t v9 = value - begin;
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (char *)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    int v12 = &v11[v7];
    uint64_t v13 = &v11[v10];
    bzero(v12, __n);
    if (end == begin)
    {
      unint64_t v11 = v12;
    }
    else
    {
      int v14 = &end[~(unint64_t)begin];
      do
      {
        char v15 = *--end;
        (v14--)[(void)v11] = v15;
      }
      while (end != begin);
      std::vector<unsigned int>::pointer end = this->__begin_;
    }
    this->__begin_ = v11;
    this->__end_ = &v12[__n];
    this->__end_cap_.__value_ = v13;
    if (end)
    {
      operator delete(end);
    }
  }
}

char *std::vector<unsigned char>::__insert_with_size[abi:fe180100]<unsigned char const*,unsigned char const*>(uint64_t a1, char *__dst, char *__src, char *a4, int64_t a5)
{
  int v5 = __dst;
  if (a5 < 1) {
    return v5;
  }
  size_t v10 = *(char **)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    unint64_t v11 = *(char **)a1;
    uint64_t v12 = (uint64_t)&v10[a5 - *(void *)a1];
    if (v12 < 0) {
      std::vector<unsigned char>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v13 = (char *)(__dst - v11);
    unint64_t v14 = v9 - (void)v11;
    if (2 * v14 > v12) {
      uint64_t v12 = 2 * v14;
    }
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v15 = v12;
    }
    if (v15)
    {
      size_t v16 = v15;
      uint64_t v17 = (char *)operator new(v15);
    }
    else
    {
      size_t v16 = 0;
      uint64_t v17 = 0;
    }
    size_t v27 = &v13[(void)v17];
    memcpy(&v13[(void)v17], __src, a5);
    int8x8_t v28 = &v13[(void)v17];
    size_t v29 = v16;
    if (v11 != v5)
    {
      do
      {
        v13[(void)v17 - 1] = v13[(void)(v11 - 1)];
        --v13;
      }
      while (v13);
      size_t v10 = *(char **)(a1 + 8);
      int8x8_t v28 = v17;
    }
    int v30 = &v27[a5];
    unsigned int v31 = &v17[v29];
    if (v10 != v5) {
      memmove(v30, v5, v10 - v5);
    }
    unint64_t v32 = *(char **)a1;
    *(void *)a1 = v28;
    *(void *)(a1 + 8) = &v30[v10 - v5];
    *(void *)(a1 + 16) = v31;
    if (v32) {
      operator delete(v32);
    }
    return v27;
  }
  uint64_t v18 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    uint64_t v19 = &__src[a5];
    int v21 = *(char **)(a1 + 8);
LABEL_17:
    unint64_t v22 = &v5[a5];
    long long v23 = &v21[-a5];
    int v24 = v21;
    if (&v21[-a5] < v10)
    {
      int64_t v25 = &v10[a5] - v21;
      int v24 = v21;
      do
      {
        char v26 = *v23++;
        *v24++ = v26;
        --v25;
      }
      while (v25);
    }
    *(void *)(a1 + 8) = v24;
    if (v21 != v22) {
      memmove(&v5[a5], v5, v21 - v22);
    }
    if (v19 != __src) {
      memmove(v5, __src, v19 - __src);
    }
    return v5;
  }
  uint64_t v19 = &__src[v18];
  int64_t v20 = a4 - &__src[v18];
  if (a4 != &__src[v18]) {
    memmove(*(void **)(a1 + 8), &__src[v18], a4 - &__src[v18]);
  }
  int v21 = &v10[v20];
  *(void *)(a1 + 8) = &v10[v20];
  if (v18 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void DisposeStreamBuffer(_DWORD *a1)
{
  if (a1)
  {
    if ((a1[5] - 131073) >= 0xFFFE0000 && *((_DWORD **)a1 + 3) == a1 + 10) {
      FlushStreamBuffer((uint64_t)a1);
    }
    uint64_t v2 = *(memoryContext **)a1;
    ScalerDisposeBlock(v2, (char *)a1, -1);
  }
}

uint64_t FlushStreamBuffer(uint64_t a1)
{
  uint64_t v1 = **(uint64_t ***)(a1 + 8);
  if (!v1
    || (uint64_t v2 = *v1) == 0
    || !*(_DWORD *)v2
    || (uint64_t result = (*(uint64_t (**)(void, void, void))(v2 + 20))(*(void *)(v2 + 28), *(unsigned int *)(a1 + 20), *(void *)(a1 + 24)), (_WORD)result))
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 0;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  *(_DWORD *)(a1 + 20) = 0;
  *(void *)(a1 + 32) = a1 + 40;
  return result;
}

uint64_t StreamBytesThroughBuffer(uint64_t result, int a2, char *__src)
{
  if (a2 >= 1)
  {
    int v4 = a2;
    uint64_t v5 = result;
    int v6 = 0x20000 - *(_DWORD *)(result + 20);
    do
    {
      if (v6 >= v4) {
        int v7 = v4;
      }
      else {
        int v7 = v6;
      }
      uint64_t result = (uint64_t)memmove(*(void **)(v5 + 32), __src, v7);
      *(void *)(v5 + 32) += v7;
      int v8 = *(_DWORD *)(v5 + 20) + v7;
      *(_DWORD *)(v5 + 20) = v8;
      if (v8 >= 0x20000)
      {
        uint64_t result = FlushStreamBuffer(v5);
        int v6 = 0x20000 - *(_DWORD *)(v5 + 20);
      }
      else
      {
        v6 -= v7;
      }
      __src += v7;
      BOOL v9 = __OFSUB__(v4, v7);
      v4 -= v7;
    }
    while (!((v4 < 0) ^ v9 | (v4 == 0)));
  }
  return result;
}

uint64_t StreamBinaryThroughBuffer(uint64_t result, int a2, char *__src)
{
  int v3 = (int)__src;
  uint64_t v5 = result;
  int v6 = __src;
  int v7 = __src;
  do
  {
    unsigned int v8 = *v6;
    if (v8 > 0x27)
    {
      switch(v8)
      {
        case '(':
          BOOL v9 = "\x02\\(";
          break;
        case '\\':
          BOOL v9 = "\x02\\\\"";
          break;
        case ')':
          BOOL v9 = "\x02\\)";
          break;
        default:
          goto LABEL_18;
      }
    }
    else
    {
      switch(v8)
      {
        case 4u:
          BOOL v9 = "\x04\\004";
          break;
        case 0xAu:
          BOOL v9 = "\x02\\n";
          break;
        case 0xDu:
          BOOL v9 = "\x02\\r";
          break;
        default:
          goto LABEL_18;
      }
    }
    if (v7 < v6) {
      StreamBytesThroughBuffer(v5, v3 - v7, v7);
    }
    int v7 = v6 + 1;
    uint64_t result = StreamBytesThroughBuffer(v5, *(unsigned __int8 *)v9, (char *)v9 + 1);
LABEL_18:
    ++v6;
    ++v3;
    --a2;
  }
  while (a2);
  if (v7 < v6)
  {
    return StreamBytesThroughBuffer(v5, v3 - (int)v7, v7);
  }
  return result;
}

uint64_t StreamHexThroughBuffer(uint64_t result, int a2, char *a3)
{
  int v4 = a2;
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 20);
  int v7 = 0x20000 - v6;
  int v8 = 131073 - v6;
  if (v7 >= 0) {
    int v8 = v7;
  }
  int v9 = v8 >> 1;
  if (v9 >= a2) {
    int v10 = a2;
  }
  else {
    int v10 = v9;
  }
  do
  {
    unint64_t v11 = *(unsigned char **)(v5 + 32);
    if (v10)
    {
      int v12 = v10;
      uint64_t v13 = a3;
      do
      {
        *unint64_t v11 = str_6_0[(unint64_t)*v13 >> 4];
        char v14 = *v13++;
        v11[1] = str_6_0[v14 & 0xF];
        v11 += 2;
        --v12;
      }
      while (v12);
      unint64_t v11 = *(unsigned char **)(v5 + 32);
    }
    *(void *)(v5 + 32) = &v11[2 * v10];
    int v15 = *(_DWORD *)(v5 + 20) + 2 * v10;
    *(_DWORD *)(v5 + 20) = v15;
    v4 -= v10;
    if (v4 >= 0x10000) {
      int v16 = 0x10000;
    }
    else {
      int v16 = v4;
    }
    if (v15 >= 0x1FFFF) {
      uint64_t result = FlushStreamBuffer(v5);
    }
    a3 += v10;
    int v10 = v16;
  }
  while (v4);
  return result;
}

void DumpFontEncoding(memoryContext *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v57 = v8;
  long long v58 = v8;
  long long v55 = v8;
  long long v56 = v8;
  long long v53 = v8;
  long long v54 = v8;
  *(_OWORD *)long long v51 = v8;
  long long v52 = v8;
  StreamBytesThroughBuffer(a2, 49, "256 array 0 1 255 {1 index exch/.notdef put} for\n");
  unsigned int v9 = (*(uint64_t (**)(void))(**(void **)(*(void *)a1 + 24) + 168))(*(void *)(*(void *)a1 + 24));
  if (v9 >= 0xFFFF) {
    unsigned int v10 = 0xFFFF;
  }
  else {
    unsigned int v10 = v9;
  }
  uint64_t v11 = *(void *)(*(void *)(a2 + 8) + 40);
  if (!v11)
  {
    long long v50 = 0;
    unsigned int FontTable = ScalerGetFontTable(a1, 1668112752, 0, &v50, 0, 12);
    unint64_t v22 = v50;
    unsigned int v23 = (bswap32(*((unsigned __int16 *)v50 + 1)) >> 16) - 1;
    if ((v23 & 0x8000) != 0) {
      goto LABEL_53;
    }
    int v24 = (unsigned __int16 *)((char *)v50 + FontTable);
    if ((char *)v50 + 12 > (char *)v24) {
      goto LABEL_53;
    }
    int64_t v25 = (char *)v50 + 20;
    while (*((_WORD *)v25 - 8) != 256 || *((_WORD *)v25 - 7))
    {
      if ((__int16)v23 >= 1)
      {
        LOWORD(v23) = v23 - 1;
        BOOL v26 = v25 > (char *)v24;
        v25 += 8;
        if (!v26) {
          continue;
        }
      }
      goto LABEL_53;
    }
    size_t v27 = (char *)v50 + bswap32(*((_DWORD *)v25 - 3));
    long long v48 = (unsigned __int8 *)(v27 + 3);
    if (v27 + 3 > v24) {
      goto LABEL_53;
    }
    if (*v27 == 1536)
    {
      int v32 = bswap32((unsigned __int16)v27[3]);
      int v30 = v27 + 5;
      int v31 = (__int16)((bswap32((unsigned __int16)v27[4]) >> 16) + HIWORD(v32));
      if (v31 >= 255) {
        int v31 = 255;
      }
      if (v31 >= v32 >> 16) {
        __int16 v33 = HIWORD(v32);
      }
      else {
        __int16 v33 = 255;
      }
      uint64_t v29 = v33;
      unint64_t v34 = &v30[(__int16)(v31 + 1) - (uint64_t)v33];
      if ((int)v29 > v31 || v34 >= v24) {
        goto LABEL_53;
      }
      long long v48 = 0;
    }
    else
    {
      if (*v27) {
        BOOL v28 = 1;
      }
      else {
        BOOL v28 = v27 + 131 >= v24;
      }
      if (v28)
      {
LABEL_53:
        ScalerReleaseFontTable(a1, v22);
        return;
      }
      uint64_t v29 = 0;
      int v30 = 0;
      LOWORD(v31) = 255;
    }
    int v36 = (__int16)v31 + 1;
    long long v47 = v27;
    do
    {
      if (*v27)
      {
        unsigned int v37 = *v30++;
        unsigned int v38 = bswap32(v37) >> 16;
      }
      else
      {
        unsigned int v38 = *v48++;
      }
      if (v38) {
        BOOL v39 = v38 >= v10;
      }
      else {
        BOOL v39 = 1;
      }
      if (!v39)
      {
        char v49 = -86;
        int v40 = ZGetGlyphName(a3, a4, (unsigned __int16)v10, v38, &v49, v51, 0x80uLL);
        if (v49 && (v49 != 7 || strncmp(v40, ".notdef", 7uLL))) {
          ZWriteStringF(a2, 25, v41, v42, v43, v44, v45, v46, v29);
        }
        size_t v27 = v47;
      }
      uint64_t v29 = (v29 + 1);
    }
    while (v36 != v29);
    goto LABEL_53;
  }
  uint64_t v12 = 0;
  do
  {
    LOBYTE(v50) = -86;
    unsigned int v13 = *(unsigned __int16 *)(v11 + 2 * v12);
    if (v13 != 0xFFFF)
    {
      char v14 = ZGetGlyphName(a3, a4, (unsigned __int16)v10, v13, (char *)&v50, v51, 0x80uLL);
      if ((_BYTE)v50)
      {
        if (v50 != 7 || strncmp(v14, ".notdef", 7uLL)) {
          ZWriteStringF(a2, 25, v15, v16, v17, v18, v19, v20, v12);
        }
      }
    }
    ++v12;
  }
  while (v12 != 256);
}

const char *ZGetGlyphName(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, char *a5, char *a6, size_t a7)
{
  int v7 = a6;
  *a5 = 0;
  if (a1 && a2 >= 0x20)
  {
    HIDWORD(v9) = bswap32(*(_DWORD *)a1);
    LODWORD(v9) = HIDWORD(v9) - 0x10000;
    unint64_t v10 = a1 + a2;
    switch((v9 >> 15))
    {
      case 0u:
        if (a4 > 0x101) {
          goto LABEL_60;
        }
        int v7 = &CanonGlyphNameTable[18 * a4];
        char v11 = strlen(v7);
        goto LABEL_63;
      case 2u:
        if (a2 < 0x22) {
          break;
        }
        unint64_t v12 = a1 + 34;
        unint64_t v13 = bswap32(*(unsigned __int16 *)(a1 + 32)) >> 16;
        unint64_t v14 = a1 + 34 + 2 * v13;
        unint64_t v15 = ((unint64_t)a2 - 34) >> 1;
        if (a2 < 0x24) {
          unint64_t v15 = 0;
        }
        BOOL v16 = v14 <= v10 && v14 >= v12;
        if (v16) {
          unint64_t v15 = v13;
        }
        if (v15 <= a4) {
          break;
        }
        if (!a4) {
          goto LABEL_62;
        }
        uint64_t v17 = __rev16(*(unsigned __int16 *)(v12 + 2 * a4));
        if (v17 <= 0x101)
        {
          if (!*(_WORD *)(v12 + 2 * a4)) {
            goto LABEL_60;
          }
          int v7 = &CanonGlyphNameTable[18 * v17];
LABEL_32:
          char v11 = strlen(v7);
          goto LABEL_63;
        }
        __int16 v33 = (unsigned __int8 *)(v12 + 2 * v15);
        if (v17 != 258 && (unint64_t)v33 < v10)
        {
          uint64_t v34 = v17 - 259;
          do
          {
            v33 += *v33 + 1;
            BOOL v16 = v34-- != 0;
          }
          while (v16 && (unint64_t)v33 < v10);
        }
        if ((unint64_t)v33 < v10 && *v33)
        {
          int v7 = (const char *)(v33 + 1);
          uint64_t v35 = v10 - (void)(v33 + 1);
          if (v35 >= *v33) {
            char v11 = *v33;
          }
          else {
            char v11 = v35;
          }
          goto LABEL_63;
        }
        break;
      case 3u:
        if (a2 < 0x22) {
          break;
        }
        unint64_t v18 = a1 + 34;
        unint64_t v19 = bswap32(*(unsigned __int16 *)(a1 + 32)) >> 16;
        unint64_t v20 = a1 + 34 + 2 * v19;
        unint64_t v21 = ((unint64_t)a2 - 34) >> 1;
        if (a2 < 0x24) {
          unint64_t v21 = 0;
        }
        BOOL v22 = v20 <= v10 && v20 >= v18;
        unint64_t v23 = v22 ? v19 : v21;
        if (v23 <= a4) {
          break;
        }
        if (!a4) {
          goto LABEL_62;
        }
        unint64_t v24 = *(char *)(v18 + a4) + (unint64_t)a4;
        if (v24 - 258 < 0xFFFFFFFFFFFFFEFFLL) {
          goto LABEL_60;
        }
        int v7 = &CanonGlyphNameTable[18 * (int)v24];
        goto LABEL_32;
      case 6u:
        unint64_t v25 = a1 + 32;
        unint64_t v26 = a1 + 32 + 2 * a3;
        unsigned int v27 = (a2 + 131040) >> 1;
        if (a2 < 0x22) {
          LOWORD(v27) = 0;
        }
        if (v26 <= v10 && v26 >= v25) {
          unsigned __int16 v29 = a3;
        }
        else {
          unsigned __int16 v29 = v27;
        }
        if (a4 >= v29) {
          break;
        }
        if (!a4) {
          goto LABEL_62;
        }
        unsigned int v30 = *(unsigned __int16 *)(v25 + 2 * a4);
        if (v30 == 0xFFFF) {
          goto LABEL_60;
        }
        uint64_t v31 = __rev16(v30);
        if (v31 >= 0x100) {
          int v32 = "a%04x";
        }
        else {
          int v32 = "a%02x";
        }
        char v11 = snprintf_l(a6, a7, 0, v32, v31);
        goto LABEL_63;
      default:
        break;
    }
  }
  if (a4)
  {
LABEL_60:
    char v11 = snprintf_l(a6, a7, 0, "gid%d");
  }
  else
  {
LABEL_62:
    int v7 = ".notdef";
    char v11 = 7;
  }
LABEL_63:
  *a5 = v11;
  return v7;
}

const char *ZWriteStringF(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  int v27 = -1431655766;
  memset(v36, 170, sizeof(v36));
  BOOL v28 = (double *)&a9;
  *(_DWORD *)(a1 + 131112) = 0;
  uint64_t result = ZGetString(a2, &v27);
  int v11 = v27;
  if (v27 >= 1)
  {
    unint64_t v12 = (char *)result;
    while (2)
    {
      while (2)
      {
        while (2)
        {
          uint64_t v13 = 0;
          int v14 = v11;
          uint64_t v15 = 1;
          while (v12[v13] != 94)
          {
            ++v13;
            if (v14 + (int)--v15 <= 1) {
              return (const char *)StreamBytesThroughBuffer(a1, v13, v12);
            }
          }
          if (v13) {
            StreamBytesThroughBuffer(a1, v13, v12);
          }
          int v11 = v14 - v13;
          BOOL v16 = &v12[v13 + 1];
          if (v14 - (int)v13 <= 0)
          {
            v12 += v13 + 1;
            continue;
          }
          break;
        }
        int v35 = -1431655766;
        *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v33 = v17;
        long long v34 = v17;
        long long v31 = v17;
        long long v32 = v17;
        *(_OWORD *)__s = v17;
        long long v30 = v17;
        v12 += v13 + 2;
        int v18 = *v16;
        if (v18 > 104)
        {
          if (v18 != 105)
          {
            if (v18 != 115) {
              continue;
            }
            unint64_t v25 = v28++;
            int v22 = *(_DWORD *)v25;
            BOOL v28 = v25 + 2;
            unint64_t v20 = (char *)*((void *)v25 + 1);
            goto LABEL_25;
          }
          ++v28;
          unint64_t v20 = v36;
          int v26 = snprintf_l(v36, 0x10uLL, 0, "%d");
        }
        else
        {
          if (v18 != 100)
          {
            if (v18 != 102) {
              continue;
            }
            unint64_t v19 = v28++;
            unint64_t v20 = __s;
            snprintf_l(__s, 0x64uLL, 0, "%.15f", *v19);
            int v21 = strlen(__s);
            int v22 = v21;
            if (v21 >= 4)
            {
              uint64_t v23 = v21 + 1;
              while (1)
              {
                uint64_t v24 = (v23 - 2);
                unint64_t v20 = __s;
                if (__s[v24] != 48) {
                  break;
                }
                __s[v24] = 0;
                --v22;
                if ((unint64_t)--v23 <= 4)
                {
                  int v22 = 3;
                  goto LABEL_25;
                }
              }
            }
            goto LABEL_25;
          }
          ++v28;
          unint64_t v20 = v36;
          int v26 = snprintf_l(v36, 0x10uLL, 0, "%.4f");
        }
        break;
      }
      int v22 = v26;
LABEL_25:
      StreamBytesThroughBuffer(a1, v22, v20);
      int v11 = v14 - v13 - 2;
      continue;
    }
  }
  return result;
}

uint64_t ZWriteDataHex(uint64_t a1, int a2, char *__src, int a4)
{
  if (a4)
  {
    int v7 = (int *)(a1 + 131112);
    int v8 = *(_DWORD *)(a1 + 131112);
    if (v8 + a2 > 1024)
    {
      int v9 = 1024 - v8;
    }
    else
    {
      *int v7 = v8 + a2;
      int v9 = a2;
    }
    uint64_t result = StreamHexThroughBuffer(a1, v9, __src);
    int v11 = a2 - v9;
    if (a2 != v9)
    {
      unint64_t v12 = &__src[v9];
      do
      {
        *int v7 = 0;
        StreamBytesThroughBuffer(a1, 2, "\n\r");
        if (v11 > 1024)
        {
          int v13 = 1024;
        }
        else
        {
          *int v7 = v11;
          int v13 = v11;
        }
        uint64_t result = StreamHexThroughBuffer(a1, v13, v12);
        v12 += v13;
        v11 -= v13;
      }
      while (v11);
    }
  }
  else
  {
    return StreamBinaryThroughBuffer(a1, a2, __src);
  }
  return result;
}

const char *ZGetString(int a1, int *a2)
{
  uint64_t result = "%!FontType1-1.0: ^s ^d.^d\n";
  int v5 = 26;
  switch(a1)
  {
    case 0:
      break;
    case 1:
      uint64_t result = "%!PS-TrueTypeFont-^d-^d-2\n";
      break;
    case 2:
      uint64_t result = "14 dict begin\n/FontName /^s def\n";
      int v5 = 32;
      break;
    case 3:
      uint64_t result = "/PaintType 0 def\n";
      goto LABEL_20;
    case 4:
      uint64_t result = "/FontType 3 def\n";
      goto LABEL_55;
    case 5:
      uint64_t result = "/FontType 42 def\n";
      goto LABEL_20;
    case 6:
      uint64_t result = "/FontType 1 def\n";
      goto LABEL_55;
    case 7:
      uint64_t result = "/Encoding ";
      goto LABEL_84;
    case 8:
    case 106:
      uint64_t result = "readonly def\n";
      int v5 = 13;
      break;
    case 9:
    case 102:
      uint64_t result = "/FontMatrix matrix def\n";
      goto LABEL_53;
    case 10:
      uint64_t result = "/FontBBox[^i ^i 1 index div ^i 2 index div ^i 3 index div ^i 5 -1 roll div]cvx def\n";
      int v5 = 83;
      break;
    case 11:
      uint64_t result = "/FontMatrix [ ^f 0 0 ^f 0 0 ] readonly def\n";
      int v5 = 43;
      break;
    case 12:
      uint64_t result = "/FontBBox {^i ^i ^i ^i} readonly def\n";
      int v5 = 37;
      break;
    case 13:
      uint64_t result = "/UniqueID ^i def\n";
LABEL_20:
      int v5 = 17;
      break;
    case 14:
      uint64_t result = "/sfnts [<\n";
      goto LABEL_84;
    case 15:
      uint64_t result = "\n00><\n";
      goto LABEL_81;
    case 16:
      uint64_t result = "\n00>] def\n";
LABEL_84:
      int v5 = 10;
      break;
    case 17:
    case 109:
      uint64_t result = "/CharStrings ^i dict dup begin\n";
      goto LABEL_63;
    case 18:
      uint64_t result = "/^s ^i def\n";
      int v5 = 11;
      break;
    case 19:
      uint64_t result = " end readonly def\n";
      goto LABEL_57;
    case 20:
      uint64_t result = "/TrueState 271 string def TrueDict begin sfnts save 72 0 matrix defaultmatrix dtransform dup mul exch dup"
               " mul add sqrt cvi 0 72 matrix defaultmatrix dtransform dup mul exch dup mul add sqrt cvi 3 -1 roll restor"
               "e TrueState initer end\n";
      int v5 = 233;
      break;
    case 21:
      uint64_t result = "/BuildChar{exch begin Encoding 1 index get CharStrings dup 2 index known{exch}{exch pop /.notdef}ifelse g"
               "et dup xcheck{currentdict systemdict begin begin exec end end}{exch pop TrueDict begin /bander load cvlit"
               " exch TrueState render end}ifelse end} bind def\n";
      int v5 = 258;
      break;
    case 22:
      uint64_t result = "currentdict dup/FontName get exch definefont pop end\n";
      int v5 = 53;
      break;
    case 23:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
LABEL_8:
      int v5 = 0;
      uint64_t result = 0;
      break;
    case 24:
      uint64_t result = "256 array 0 1 255 {1 index exch/.notdef put} for\n";
      int v5 = 49;
      break;
    case 25:
    case 105:
      uint64_t result = "dup ^i /^s put\n";
      int v5 = 15;
      break;
    case 26:
      uint64_t result = "currentfile eexec\n";
      goto LABEL_57;
    case 27:
      uint64_t result = "0000000000000000000000000000000000000000000000000000000000000000\n";
      int v5 = 65;
      break;
    case 28:
      uint64_t result = "cleartomark\n";
      goto LABEL_67;
    case 29:
      uint64_t result = "dup/Private 13 dict dup begin/RD{string currentfile exch readstring pop}executeonly def/ND{noaccess def}e"
               "xecuteonly def/NP{noaccess put}executeonly def/BlueValues[]def/MinFeature{16 16}def/password 5839 def/Oth"
               "erSubrs[{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{16384 div 4 1 roll 16384 div 4 1 roll 16384 div 4 1 roll"
               " 16384 div 4 1 roll 0 0 matrix astore matrix currentmatrix exch concat}executeonly{setmatrix}executeonly]noaccess def\n";
      int v5 = 433;
      break;
    case 30:
      uint64_t result = "/Subrs ";
      goto LABEL_36;
    case 31:
      uint64_t result = " array\n";
LABEL_36:
      int v5 = 7;
      break;
    case 32:
      uint64_t result = "dup ";
      goto LABEL_41;
    case 33:
      uint64_t result = " RD ";
      goto LABEL_41;
    case 34:
      uint64_t result = " NP\n";
      goto LABEL_41;
    case 35:
      uint64_t result = " ND\n";
LABEL_41:
      int v5 = 4;
      break;
    case 36:
      uint64_t result = "2 index/CharStrings ";
      int v5 = 20;
      break;
    case 37:
      uint64_t result = " dict dup begin\n";
      goto LABEL_55;
    case 38:
      uint64_t result = "/.notdef 8 RD ";
      int v5 = 14;
      break;
    case 39:
      uint64_t result = "end end readonly put\nnoaccess put\ndup/FontName get exch definefont pop\nmark currentfile closefile\n";
      int v5 = 98;
      break;
    case 40:
      uint64_t result = "systemdict/product 2 copy known{get dup(LaserWriter IIf)eq exch(LaserWriter IIg)eq or version(2010.113)eq"
               " and not}{pop pop true}ifelse{/UniqueID ^i def}if\n";
      int v5 = 155;
      break;
    case 41:
      uint64_t result = "userdict/TTMakeVariationFont known userdict begin/TTMakeVariationFontDefined exch def end\n"
               "TTMakeVariationFontDefined{save}if userdict begin/TTMakeVariationFont{exch dup length 1 add dict exch{exc"
               "h dup dup/FID ne exch/UniqueID ne and{2 index 4 1 roll exch put}{pop pop}ifelse} forall begin/Variations "
               "exch def currentdict end/GXVariationfont exch definefont} bind def end TTMakeVariationFontDefined{restore}if\n";
      int v5 = 409;
      break;
    case 42:
      uint64_t result = "<";
      goto LABEL_51;
    case 43:
      uint64_t result = "00> TTMakeVariationFont\n";
      goto LABEL_69;
    case 44:
      uint64_t result = "(";
LABEL_51:
      int v5 = 1;
      break;
    case 45:
      uint64_t result = (const char *)&unk_1B5398541;
LABEL_53:
      int v5 = 23;
      break;
    case 46:
      uint64_t result = "currentdict end\n";
LABEL_55:
      int v5 = 16;
      break;
    case 100:
      uint64_t result = "14 dict dup begin\n";
LABEL_57:
      int v5 = 18;
      break;
    case 101:
      uint64_t result = "/FontType 3 def\n/PaintType 0 def\n/StrokeWidth 0 def\n";
      int v5 = 52;
      break;
    case 103:
      uint64_t result = "/FontBBox[^d ^d ^d ^d]def\n";
      break;
    case 104:
      uint64_t result = "/Encoding 256 array 0 1 255 {1 index exch/.notdef put} for\n";
LABEL_86:
      int v5 = 59;
      break;
    case 107:
      uint64_t result = "/BuildChar{exch begin Encoding exch get CharStrings dup 2 index known{exch}{exch pop /.notdef}ifelse get "
               "dup xcheck{currentdict systemdict begin begin exec end end}{dup 0 get 0 2 index 1 4 getinterval aload pop"
               " setcachedevice dup 6 get exch dup 5 get 3 -1 roll true yopmatrix dup 4 6 index 7 get put dup 5 6 index 8"
               " get put 5 -1 roll 9 1 getinterval cvx imagemask}ifelse end}bind def\n";
      int v5 = 384;
      break;
    case 108:
      uint64_t result = "/yopmatrix [^i 0 0 ^i 0 0] def\n";
LABEL_63:
      int v5 = 31;
      break;
    case 110:
      uint64_t result = "/^s [^d ^d ^d ^d ^d ^i ^i ^d ^d <";
      goto LABEL_79;
    case 111:
      uint64_t result = ">]def\n";
      goto LABEL_81;
    case 112:
      uint64_t result = "end def end\n";
LABEL_67:
      int v5 = 12;
      break;
    case 113:
      uint64_t result = "/^s exch definefont pop\n";
LABEL_69:
      int v5 = 24;
      break;
    case 114:
      uint64_t result = "/yopmatrix[^i 0 ^i .25 mul ^i 0 0]def\n";
      int v5 = 38;
      break;
    case 115:
      uint64_t result = "/FontMatrix[1 0 .25 1 0 0]def\n";
      int v5 = 30;
      break;
    case 116:
      uint64_t result = "/GetShort {2 copy get 256 mul\n"
               "3 1 roll\n"
               "1 add\n"
               "get add\n"
               "} bind def\n"
               "/SignedByte {dup 127 gt {256 sub\n"
               "} if\n"
               "} bind def\n"
               "/LocalVariables 3 dict dup begin/theString null def\n"
               "/strInd 0 def\n"
               "/doingY false def\n"
               "end def/DrawGlyph {exec\n"
               "LocalVariables begin\n"
               "/theString exch def \n"
               "/strInd 0 def\n"
               "theString strInd GetShort\n"
               "/strInd strInd 2 add def\n";
      int v5 = 328;
      break;
    case 117:
      uint64_t result = "{theString strInd GetShort\n"
               "/strInd strInd 2 add def\n"
               "dup 0 gt {\n"
               "1 sub 2 mul\n"
               "theString strInd get SignedByte\n"
               "theString strInd 1 add get SignedByte moveto\n"
               "/strInd strInd 2 add def\n"
               "/doingY false def\n"
               "dup strInd add\texch\n"
               "theString strInd 3 -1 roll getinterval\n"
               "{SignedByte\n"
               "doingY {rlineto /doingY false def}\n"
               " {/doingY true def} ifelse \n"
               "} forall\n"
               "closepath \n"
               "/strInd exch def\n"
               "} if\n"
               "} repeat\n"
               "PaintType 2 eq { StrokeWidth\n"
               "setlinewidth stroke\n"
               "} {eofill\n"
               "} ifelse\n"
               "end\n";
      int v5 = 452;
      break;
    case 118:
      uint64_t result = "} bind def\n"
               "/BuildChar{exch begin Encoding exch get CharStrings dup 2 index known{exch}{exch pop /.notdef}ifelse get\n"
               "dup 0 get\n"
               " 0\n"
               "3 -1 roll\n"
               "dup 1 get exch dup 2 get exch dup 3 get exch dup 4 get exch\n"
               "7 1 roll\n"
               "setcachedevice\n"
               "yopmatrix matrix invertmatrix concat\n"
               "9 get DrawGlyph\n"
               "end}bind def\n";
      int v5 = 289;
      break;
    case 119:
      uint64_t result = "/sfnts [(";
      int v5 = 9;
      break;
    case 120:
      uint64_t result = (const char *)&unk_1B5397310;
      int v5 = 3;
      break;
    case 121:
      uint64_t result = (const char *)&unk_1B5398538;
      int v5 = 8;
      break;
    case 122:
      uint64_t result = "/^s [^d ^d ^d ^d ^d ^i ^i ^d ^d (";
LABEL_79:
      int v5 = 33;
      break;
    case 123:
      uint64_t result = ")]def\n";
LABEL_81:
      int v5 = 6;
      break;
    default:
      switch(a1)
      {
        case 200:
          uint64_t result = "42/FontType resourcestatus{pop pop false}{true}ifelse\n"
                   "%APLsfntBegin\n"
                   "{currentfile 0(%APLsfntEnd\\n)/SubFileDecode filter flushfile}if\n";
          int v5 = 132;
          break;
        case 201:
          uint64_t result = "%APLsfntEnd\n"
                   "42/FontType resourcestatus{pop pop true}{false}ifelse\n"
                   "{currentfile 0(%APLT1End\\n)/SubFileDecode filter flushfile}if\n";
          int v5 = 128;
          break;
        case 202:
          uint64_t result = "%APLT1End\n";
          goto LABEL_84;
        case 203:
          uint64_t result = "/FontInfo 1 dict dup begin\n/FSType ^i def\nend readonly def\n";
          goto LABEL_86;
        default:
          goto LABEL_8;
      }
      break;
  }
  *a2 = v5;
  return result;
}

BOOL ZGetGlyphID(uint64_t a1, unsigned int a2, char *__s, unsigned int a4, unsigned __int16 *a5)
{
  unsigned int v10 = strlen(__s);
  int v11 = v10;
  if (a1 && a2 >= 0x20 && v10)
  {
    unsigned int v12 = bswap32(*(_DWORD *)a1) - 0x10000;
    BOOL v13 = *(_DWORD *)a1 != 512 || a2 >= 0x21;
    if (v13) {
      unsigned int v14 = v12;
    }
    else {
      unsigned int v14 = 0;
    }
    HIDWORD(v15) = v14;
    LODWORD(v15) = v14;
    switch((v15 >> 15))
    {
      case 0u:
        *a5 = ZGetCanonIndexFromGlyphName(__s, v10);
        return 1;
      case 2u:
        if (!*(_WORD *)(a1 + 32)) {
          goto LABEL_42;
        }
        uint64_t v16 = 0;
        uint64_t v17 = a1 + 34;
        unint64_t v18 = a1 + a2;
        unsigned int v19 = __rev16(*(unsigned __int16 *)(a1 + 32));
        unint64_t v20 = a1 + 34 + 2 * v19;
        size_t __n = v10;
        if (v19 <= 1) {
          uint64_t v21 = 1;
        }
        else {
          uint64_t v21 = v19;
        }
        while (2)
        {
          unsigned int v22 = bswap32(*(unsigned __int16 *)(v17 + 2 * v16)) >> 16;
          if (v22 > 0x101)
          {
            BOOL v25 = v22 == 258 || v20 >= v18;
            int v26 = (unsigned __int8 *)v20;
            if (!v25)
            {
              unsigned int v27 = v22 - 259;
              int v26 = (unsigned __int8 *)v20;
              do
              {
                v26 += *v26 + 1;
                BOOL v13 = v27-- != 0;
              }
              while (v13 && (unint64_t)v26 < v18);
            }
            if ((unint64_t)v26 >= v18) {
              return 0;
            }
            uint64_t v23 = (const char *)(v26 + 1);
            uint64_t v24 = *v26;
            if ((unint64_t)&v26[v24] >= v18) {
              return 0;
            }
          }
          else
          {
            uint64_t v23 = &CanonGlyphNameTable[18 * v22];
            LODWORD(v24) = strlen(v23);
          }
          if (v11 != v24 || *__s != *v23 || strncmp(v23, __s, __n))
          {
            if (++v16 == v21) {
              goto LABEL_42;
            }
            continue;
          }
          break;
        }
        *a5 = v16;
        return 1;
      case 3u:
        if (!*(_WORD *)(a1 + 32)) {
          goto LABEL_42;
        }
        uint64_t v28 = 0;
        uint64_t v29 = a1 + 34;
        unsigned int v30 = __rev16(*(unsigned __int16 *)(a1 + 32));
        if (v30 <= 1) {
          uint64_t v31 = 1;
        }
        else {
          uint64_t v31 = v30;
        }
        while (1)
        {
          unsigned int v32 = v28 + *(char *)(v29 + v28);
          if (v32 <= 0x101)
          {
            long long v33 = &CanonGlyphNameTable[18 * v32];
            if (v11 == strlen(v33) && *__s == *v33 && !strcmp(__s, v33)) {
              break;
            }
          }
          if (v31 == ++v28) {
            goto LABEL_42;
          }
        }
        *a5 = v28;
        return 1;
      case 6u:
        if (v10 == 7 && !strncmp(__s, ".notdef", 7uLL)) {
          goto LABEL_65;
        }
        int v39 = *__s;
        if (v39 == 97)
        {
          if (v11 != 5 && v11 != 3) {
            goto LABEL_52;
          }
          int v52 = 0;
          int Hex = SimpleGetHex(__s + 1, &v52);
          if (!a4 || !Hex) {
            goto LABEL_52;
          }
          unsigned __int16 v45 = 0;
          while (v52 != bswap32(*(unsigned __int16 *)(a1 + 32 + 2 * v45)) >> 16)
          {
            if (a4 <= ++v45) {
              goto LABEL_52;
            }
          }
          *a5 = v45;
        }
        else
        {
          if (v39 != 117)
          {
            if (v39 == 103 && __s[1] == 105 && __s[2] == 100)
            {
              int v40 = __s[3];
              if (__s[3])
              {
                unsigned int v41 = 0;
                uint64_t v42 = __s + 4;
                while ((v40 - 58) >= 0xFFFFFFF6)
                {
                  unsigned int v41 = v40 + 10 * v41 - 48;
                  int v43 = *v42++;
                  int v40 = v43;
                  if (!v43) {
                    goto LABEL_97;
                  }
                }
                BOOL result = 0;
                LOWORD(v41) = 0;
              }
              else
              {
                unsigned int v41 = 0;
LABEL_97:
                BOOL result = v41 < a4;
                if (v41 >= a4) {
                  LOWORD(v41) = 0;
                }
              }
              *a5 = v41;
              return result;
            }
            goto LABEL_52;
          }
          if (__s[1] != 110 || __s[2] != 105 || v11 < 9) {
            goto LABEL_52;
          }
          for (uint64_t i = __s + 5; ; ++i)
          {
            if ((*(i - 2) - 58) <= 0xF5u)
            {
              unsigned int v47 = *(i - 2) - 46;
              if (v47 > 0x38) {
                goto LABEL_52;
              }
              if (((1 << v47) & 0x1F8000001F80000) == 0) {
                break;
              }
            }
          }
          if (*(i - 2) != 46) {
            goto LABEL_52;
          }
          int v48 = *(i - 1);
          if (*(i - 1))
          {
            unsigned __int16 v49 = 0;
            do
            {
              if ((v48 - 58) < 0xFFFFFFF6) {
                goto LABEL_52;
              }
              unsigned __int16 v49 = v48 + 10 * v49 - 48;
              int v50 = *i++;
              int v48 = v50;
            }
            while (v50);
          }
          else
          {
            unsigned __int16 v49 = 0;
          }
          *a5 = v49;
        }
        break;
      default:
        goto LABEL_42;
    }
    return 1;
  }
LABEL_42:
  if (*__s == 103 && __s[1] == 105 && __s[2] == 100)
  {
    int v34 = __s[3];
    if (__s[3])
    {
      unsigned int v35 = 0;
      int v36 = __s + 4;
      while ((v34 - 58) >= 0xFFFFFFF6)
      {
        unsigned int v35 = v34 + 10 * v35 - 48;
        int v37 = *v36++;
        int v34 = v37;
        if (!v37) {
          goto LABEL_68;
        }
      }
      goto LABEL_52;
    }
    unsigned int v35 = 0;
LABEL_68:
    if (v35 >= a4) {
      goto LABEL_52;
    }
    *a5 = v35;
  }
  else
  {
    if (v11 != 7 || strncmp(__s, ".notdef", 7uLL))
    {
LABEL_52:
      BOOL result = 0;
      *a5 = 0;
      return result;
    }
LABEL_65:
    *a5 = 0;
  }
  return 1;
}

uint64_t ZGetCanonIndexFromGlyphName(const char *a1, unsigned int a2)
{
  uint64_t v3 = 0;
  size_t v4 = a2;
  for (uint64_t i = ".notdef"; strlen(i) != v4 || strncmp(i, a1, v4); i += 18)
  {
    if (++v3 == 258) {
      return 0;
    }
  }
  return v3;
}

uint64_t SimpleGetHex(const char *a1, int *a2)
{
  int v2 = *(unsigned __int8 *)a1;
  if (*a1)
  {
    int v3 = 0;
    size_t v4 = a1 + 1;
    while (1)
    {
      if ((v2 - 58) > 0xFFFFFFF5)
      {
        int v5 = -48;
      }
      else if ((v2 - 71) > 0xFFFFFFF9)
      {
        int v5 = -55;
      }
      else
      {
        if ((v2 - 103) < 0xFFFFFFFA) {
          return 0;
        }
        int v5 = -87;
      }
      int v3 = v2 + 16 * v3 + v5;
      int v6 = *(unsigned __int8 *)v4++;
      int v2 = v6;
      if (!v6) {
        goto LABEL_12;
      }
    }
  }
  int v3 = 0;
LABEL_12:
  *a2 = v3;
  return 1;
}

uint64_t ZMergeAndCountLongBits(unsigned int *a1, unsigned int *a2, int a3)
{
  uint64_t v3 = 0;
  if (a3)
  {
    do
    {
      int v4 = *a2++;
      unsigned int v5 = *a1 | v4;
      *a1 = v5;
      if (v5)
      {
        int v6 = 32;
        do
        {
          uint64_t v3 = (v5 & 1) + v3;
          if (v5 < 2) {
            break;
          }
          v5 >>= 1;
          --v6;
        }
        while ((_WORD)v6);
      }
      ++a1;
      a3 = (__int16)(a3 - 1);
    }
    while (a3 > 0);
  }
  return v3;
}

size_t *ENewBuffer(uint64_t a1, memoryContext **a2)
{
  BOOL result = ScalerNewScratch(*a2, 0x400u, 0);
  uint64_t v5 = 0;
  *(void *)(a1 + 8) = result;
  *(_DWORD *)(a1 + 16) = 0;
  int v6 = 4;
  *(void *)(a1 + 24) = a2;
  int v9 = 1998898061;
  __int16 v7 = -9871;
  do
  {
    char v8 = HIBYTE(v7);
    __int16 v7 = 22719 - 12691 * (v7 + (*((unsigned char *)&v9 + v5) ^ ((unsigned __int16)(v7 & 0xFF00) >> 8)));
    *((unsigned char *)result + v5) = *((unsigned char *)&v9 + v5) ^ v8;
    --v6;
    ++v5;
  }
  while ((_WORD)v6);
  *(void *)a1 = (char *)result + v5;
  *(_DWORD *)(a1 + 16) += 4;
  *(_WORD *)(a1 + 20) = v7;
  return result;
}

uint64_t EDumpBuffer(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 16);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 24);
    int v4 = *(char **)(v2 + 8);
    if ((*(unsigned char *)(*(void *)(v3 + 8) + 18) & 1) == 0)
    {
      StreamHexThroughBuffer(v3, v1, v4);
      uint64_t v3 = *(void *)(v2 + 24);
      int v4 = "\n\r";
      int v1 = 2;
    }
    BOOL result = StreamBytesThroughBuffer(v3, v1, v4);
    *(void *)uint64_t v2 = *(void *)(v2 + 8);
    *(_DWORD *)(v2 + 16) = 0;
  }
  return result;
}

uint64_t EWriteByte(uint64_t result, __int16 a2)
{
  unsigned __int16 v2 = *(_WORD *)(result + 20);
  *(_WORD *)(result + 20) = -12691 * (v2 + (a2 ^ HIBYTE(v2))) + 22719;
  *(unsigned char *)(*(void *)result)++ = a2 ^ HIBYTE(v2);
  unsigned int v3 = *(_DWORD *)(result + 16) + 1;
  *(_DWORD *)(result + 16) = v3;
  if (v3 >= 0x400) {
    return EDumpBuffer(result);
  }
  return result;
}

uint64_t EWriteBytesAny(uint64_t result, int a2, char *a3)
{
  if (a2)
  {
    int v4 = a2;
    uint64_t v5 = result;
    do
    {
      unsigned int v6 = *(_DWORD *)(v5 + 16);
      if (v4 >= (int)(1024 - v6)) {
        int v7 = 1024 - v6;
      }
      else {
        int v7 = v4;
      }
      if ((_WORD)v7)
      {
        __int16 v8 = *(_WORD *)(v5 + 20);
        int v9 = *(unsigned char **)v5;
        unsigned int v10 = a3;
        LOWORD(v11) = v7;
        do
        {
          char v12 = *v10++;
          char v13 = HIBYTE(v8);
          __int16 v8 = 22719 - 12691 * (v8 + (v12 ^ ((unsigned __int16)(v8 & 0xFF00) >> 8)));
          *v9++ = v12 ^ v13;
          int v11 = (__int16)(v11 - 1);
        }
        while (v11 > 0);
        *(void *)uint64_t v5 = v9;
        unsigned int v6 = *(_DWORD *)(v5 + 16) + v7;
        *(_DWORD *)(v5 + 16) = v6;
        *(_WORD *)(v5 + 20) = v8;
      }
      if (v6 >= 0x400) {
        BOOL result = EDumpBuffer(v5);
      }
      a3 += v7;
      BOOL v14 = __OFSUB__(v4, v7);
      v4 -= v7;
    }
    while (!((v4 < 0) ^ v14 | (v4 == 0)));
  }
  return result;
}

uint64_t EWriteGlyphName(uint64_t a1, char *a2, int a3)
{
  EWriteByte(a1, 47);
  EWriteBytesAny(a1, a3, a2);
  return EWriteByte(a1, 32);
}

void *EGrowCSBuffer(uint64_t a1, int a2)
{
  signed int v3 = *(_DWORD *)(a1 + 20) + 32 * a2;
  BOOL result = ScalerNewBlock(**(memoryContext ***)(a1 + 32), v3, -1, *(void **)(a1 + 8), 0, 0, 0);
  *(_DWORD *)(a1 + 20) = v3;
  *(void *)a1 = (char *)result + *(unsigned int *)(a1 + 16);
  *(void *)(a1 + 8) = result;
  return result;
}

void *EWriteCSByte(void *result, char a2)
{
  signed int v3 = result;
  unsigned int v4 = *((_DWORD *)result + 5);
  if (v4 <= *((_DWORD *)result + 4) + 1)
  {
    unsigned int v5 = v4 + 32;
    BOOL result = ScalerNewBlock(*(memoryContext **)result[4], v4 + 32, -1, (void *)result[1], 0, 0, 0);
    *((_DWORD *)v3 + 5) = v5;
    *signed int v3 = (char *)result + *((unsigned int *)v3 + 4);
    v3[1] = result;
  }
  if (!*((_DWORD *)v3 + 6))
  {
    *(unsigned char *)(*v3)++ = a2;
    ++*((_DWORD *)v3 + 4);
  }
  return result;
}

void *EWriteCSByte2(void *result, char a2)
{
  signed int v3 = result;
  unsigned int v4 = *((_DWORD *)result + 5);
  if (v4 <= *((_DWORD *)result + 4) + 2)
  {
    unsigned int v5 = v4 + 64;
    BOOL result = ScalerNewBlock(*(memoryContext **)result[4], v4 + 64, -1, (void *)result[1], 0, 0, 0);
    *((_DWORD *)v3 + 5) = v5;
    *signed int v3 = (char *)result + *((unsigned int *)v3 + 4);
    v3[1] = result;
  }
  if (!*((_DWORD *)v3 + 6))
  {
    unsigned int v6 = (unsigned char *)*v3;
    *unsigned int v6 = 12;
    v6[1] = a2;
    *signed int v3 = v6 + 2;
    *((_DWORD *)v3 + 4) += 2;
  }
  return result;
}

void *EWriteCSNumber(void *result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unsigned int v10 = result;
  unint64_t v15 = &a9;
  if (*((_DWORD *)result + 5) <= (*((_DWORD *)result + 4) + 5 * a2)) {
    BOOL result = EGrowCSBuffer((uint64_t)result, a2);
  }
  if (!*((_DWORD *)v10 + 6))
  {
    int v11 = (unsigned char *)*v10;
    int v12 = a2 + 1;
    while (1)
    {
      char v13 = (int *)v15++;
      int v14 = *v13;
      if ((v14 + 107) > 0xD6)
      {
        if ((v14 - 108) > 0x3FF)
        {
          if ((v14 + 1131) > 0x3FF)
          {
            *int v11 = -1;
            v11[1] = HIBYTE(v14);
            void v11[2] = BYTE2(v14);
            int32x2_t v11[3] = BYTE1(v14);
            void v11[4] = v14;
            v11 += 5;
            goto LABEL_13;
          }
          *int v11 = ((unsigned __int16)(-108 - v14) >> 8) - 5;
          v11[1] = -108 - v14;
        }
        else
        {
          *int v11 = ((unsigned __int16)(v14 - 108) >> 8) - 9;
          v11[1] = v14 - 108;
        }
        v11 += 2;
      }
      else
      {
        *v11++ = v14 - 117;
      }
LABEL_13:
      if (--v12 <= 1)
      {
        *((_DWORD *)v10 + 4) += v11 - *(_DWORD *)v10;
        *unsigned int v10 = v11;
        return result;
      }
    }
  }
  return result;
}

uint64_t EWriteCSString(uint64_t a1, uint64_t a2)
{
  int v14 = 1869051240;
  int v4 = 4;
  unsigned int v5 = &v14;
  int v6 = 4330;
  do
  {
    char v7 = BYTE1(v6);
    int v6 = 22719 - 12691 * (v6 + (*(unsigned char *)v5 ^ ((unsigned __int16)(v6 & 0xFF00) >> 8)));
    *(unsigned char *)v5 ^= v7;
    unsigned int v5 = (int *)((char *)v5 + 1);
    --v4;
  }
  while ((_WORD)v4);
  int v8 = *(_DWORD *)(a2 + 16);
  if ((_WORD)v8)
  {
    int v9 = *(unsigned char **)(a2 + 8);
    do
    {
      char v10 = BYTE1(v6);
      int v6 = 22719 - 12691 * (v6 + (*v9 ^ ((unsigned __int16)(v6 & 0xFF00) >> 8)));
      *v9++ ^= v10;
      int v8 = (__int16)(v8 - 1);
    }
    while (v8 > 0);
  }
  EWriteBytesAny(a1, 4, (char *)&v14);
  int v11 = *(_DWORD *)(a2 + 16);
  int v12 = *(char **)(a2 + 8);
  return EWriteBytesAny(a1, v11, v12);
}

uint64_t GetGlyphOffsetAndSize(int a1, char *a2, int a3, unsigned int *a4, unint64_t a5)
{
  if (!a3)
  {
    char v10 = &a2[2 * a1];
    if (a5)
    {
      if (((unint64_t)v10 > 0xFFFFFFFFFFFFFFFBLL || (unint64_t)(v10 + 4) > a5)
        && ((unint64_t)(v10 + 2) > a5 || ((a5 - (void)v10) & 0xFFFFFFFFFFFFFFFELL) != 4))
      {
        return 0;
      }
    }
    unsigned int v13 = bswap32(*(unsigned __int16 *)v10);
    int v8 = 2 * HIWORD(v13);
    uint64_t result = 2 * ((bswap32(*((unsigned __int16 *)v10 + 1)) >> 16) - HIWORD(v13));
    if (!a4) {
      return result;
    }
LABEL_27:
    *a4 = v8;
    return result;
  }
  unsigned int v5 = (unsigned int *)&a2[4 * a1];
  if (a5)
  {
    if (((unint64_t)v5 > 0xFFFFFFFFFFFFFFF7 || (unint64_t)(v5 + 2) > a5)
      && ((unint64_t)(v5 + 1) > a5 || ((a5 - (void)v5) & 0xFFFFFFFFFFFFFFFCLL) != 8))
    {
      return 0;
    }
  }
  int v8 = bswap32(*v5);
  uint64_t result = bswap32(v5[1]) - v8;
  if (a4) {
    goto LABEL_27;
  }
  return result;
}

uint64_t InitVariationInfo(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if ((int)a3 < 1) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  if (!*(unsigned char *)(v5 + 155)) {
    return 0;
  }
  uint64_t v9 = *(int *)(v5 + 72);
  uint64_t v10 = *(int *)(v5 + 76) * (uint64_t)(int)v9;
  uint64_t v11 = 2 * v10;
  int v12 = ScalerNewScratch(*(memoryContext **)a1, 2 * (int)v10 + 2 * (int)v9, 0);
  *(void *)(a2 + 8) = v12;
  *(void *)(a2 + 16) = (char *)v12 + 2 * v9;
  *(void *)(a2 + 24) = v12;
  *(_DWORD *)a2 = *(_DWORD *)(*(void *)(a1 + 8) + 72);
  *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v21[4] = v13;
  v21[5] = v13;
  void v21[2] = v13;
  void v21[3] = v13;
  v21[0] = v13;
  v21[1] = v13;
  long long __src = 0uLL;
  std::vector<CGFontVariation,TInlineBufferAllocator<CGFontVariation,4ul>>::vector(v21, a3, &__src);
  uint64_t v14 = *(void *)&v21[0];
  uint64_t v15 = 8 * a3;
  do
  {
    uint64_t v16 = *a4++;
    *(void *)uint64_t v14 = v16;
    *(double *)(v14 + 8) = (double)SHIDWORD(v16) * 0.0000152587891;
    v14 += 16;
    v15 -= 8;
  }
  while (v15);
  (*(void (**)(void, void, void, void))(**(void **)(**(void **)a1 + 24) + 408))(*(void *)(**(void **)a1 + 24), a3, *(void *)&v21[0], *(void *)(a2 + 8));
  uint64_t v17 = *(void *)(a1 + 8);
  if (*(_DWORD *)(v17 + 76))
  {
    *(void *)&long long __src = 0xAAAAAAAAAAAAAAAALL;
    ScalerGetFontTable(*(memoryContext **)a1, 1735811442, *(_DWORD *)(v17 + 68), &__src, 0, v11);
    unint64_t v18 = (const void *)__src;
    memcpy(*(void **)(a2 + 16), (const void *)__src, v11);
    ScalerReleaseFontTable(*(memoryContext **)a1, v18);
  }
  *(void *)&long long __src = v21;
  std::vector<CGFontVariation,TInlineBufferAllocator<CGFontVariation,4ul>>::__destroy_vector::operator()[abi:fe180100]((void ***)&__src);
  return a2;
}

void sub_1B5308B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, char a11)
{
  a9 = (void **)&a11;
  std::vector<CGFontVariation,TInlineBufferAllocator<CGFontVariation,4ul>>::__destroy_vector::operator()[abi:fe180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t InitGlyphInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(memoryContext **)a1;
  int v6 = *(unsigned __int16 **)(a1 + 8);
  unsigned int v8 = v6[21];
  if (v8 <= v6[23]) {
    unsigned int v8 = v6[23];
  }
  unsigned int v9 = v6[22];
  unsigned int v10 = v6[24];
  if (v9 <= v10) {
    unsigned int v11 = v10;
  }
  else {
    unsigned int v11 = v9;
  }
  *(_DWORD *)a2 = -1;
  uint64_t v12 = v8 + 8;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 240) = a3;
  *(void *)(a2 + 248) = a1;
  *(unsigned char *)(a2 + 260) = 0;
  long long v13 = ScalerNewScratch(v5, 22 * v12 + 4 * v11, 1);
  *(void *)(a2 + 72) = v13;
  uint64_t v14 = (uint64_t)v13 + 4 * v12 + 4 * v12;
  uint64_t v15 = v14 + 2 * v11;
  *(void *)(a2 + 104) = v14;
  *(void *)(a2 + 112) = v15;
  uint64_t v16 = v15 + 2 * v11;
  *(void *)(a2 + 120) = v16;
  *(void *)(a2 + 128) = v16 + v12;
  *(_DWORD *)(a2 + 188) = v11;
  *(_DWORD *)(a2 + 192) = v12;
  if (v13)
  {
    uint64_t v17 = v16 + v12 + v12;
    uint64_t v18 = v17 + 4 * v12;
    uint64_t v19 = v18 + 4 * v12;
    uint64_t v20 = v19 + 2 * v12;
    uint64_t v21 = v20 + 2 * v12;
  }
  else
  {
    uint64_t v17 = 1358921729;
    uint64_t v18 = 1358921729;
    uint64_t v19 = 1358921729;
    uint64_t v20 = 1358921729;
    uint64_t v21 = 1358921729;
  }
  *(void *)(a2 + 136) = v17;
  *(void *)(a2 + 144) = v18;
  *(void *)(a2 + 152) = v19;
  *(void *)(a2 + 160) = v20;
  *(void *)(a2 + 200) = v21;
  *(void *)(a2 + 88) = 1358921729;
  *(void *)(a2 + 96) = 1358921729;
  uint64_t v22 = *(memoryContext **)a1;
  uint64_t v23 = *(void *)(a1 + 8);
  *(_WORD *)(a2 + 232) = *(_WORD *)(v23 + 146);
  *(_WORD *)(a2 + 216) = *(_WORD *)(v23 + 144);
  unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int FontTable = ScalerGetFontTable(v22, 1752003704, 0, &v30, 1, 0);
  if (FontTable && (BOOL v25 = (const void *)v30) != 0)
  {
    size_t v26 = FontTable;
    if (FontTable < 4 * (unint64_t)*(unsigned __int16 *)(a2 + 232)) {
      *(_WORD *)(a2 + 232) = FontTable >> 2;
    }
    unsigned int v27 = ScalerNewScratch(*(memoryContext **)a1, FontTable, 0);
    *(void *)(a2 + 224) = v27;
    memcpy(v27, v25, v26);
    *(void *)(a2 + 264) = *(void *)(a2 + 224) + v26;
    ScalerReleaseFontTable(*(memoryContext **)a1, v25);
  }
  else
  {
    *(void *)(a2 + 224) = 0;
    *(void *)(a2 + 264) = 0;
  }
  uint64_t result = ScalerGetFontTable(*(memoryContext **)a1, 1819239265, 0, (void *)(a2 + 208), 1, 0);
  if (result != *(_DWORD *)(*(void *)(a1 + 8) + 100))
  {
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  *(void *)(a2 + 272) = *(void *)(a2 + 208) + result;
  return result;
}

void UninitGlyphInfo(memoryContext **a1, uint64_t a2)
{
  int v4 = *(char **)(a2 + 224);
  if (v4) {
    ScalerDisposeBlock(*a1, v4, -1);
  }
  uint64_t v5 = *(const void **)(a2 + 208);
  if (v5) {
    ScalerReleaseFontTable(*a1, v5);
  }
  if (*(unsigned char *)(a2 + 260))
  {
    ScalerReleaseFontTable(*a1, *(const void **)(a2 + 16));
    *(unsigned char *)(a2 + 260) = 0;
  }
  ScalerDisposeBlock(*a1, *(char **)(a2 + 72), -1);
  uint64_t v6 = *(void *)(a2 + 240);
  if (v6)
  {
    char v7 = *a1;
    unsigned int v8 = *(char **)(v6 + 24);
    ScalerDisposeBlock(v7, v8, -1);
  }
}

void GetGlyphForStreaming(unsigned int a1, unsigned int *a2, int a3, int a4)
{
  if ((a1 & 0x80000000) != 0) {
    goto LABEL_112;
  }
  uint64_t v6 = *((void *)a2 + 31);
  if (*(unsigned __int16 *)(*(void *)(v6 + 8) + 40) < a1) {
    goto LABEL_112;
  }
  if (!(a4 | a3) && *a2 == a1) {
    return;
  }
  *a2 = a1;
  if (*((unsigned char *)a2 + 260))
  {
    ScalerReleaseFontTable(*(memoryContext **)v6, *((const void **)a2 + 2));
    *((unsigned char *)a2 + 260) = 0;
  }
  unsigned __int16 GlyphOffsetAndSize = GetGlyphOffsetAndSize((unsigned __int16)a1, *((char **)a2 + 26), *((_WORD *)a2 + 108) != 0, a2 + 1, *((void *)a2 + 34));
  *((_WORD *)a2 + 4) = GlyphOffsetAndSize;
  a2[64] = 0;
  *((void *)a2 + 8) = 0;
  uint64_t v10 = *((void *)a2 + 28);
  if (!v10)
  {
LABEL_112:
    exception = __cxa_allocate_exception(2uLL);
    _WORD *exception = 5;
    __cxa_throw(exception, MEMORY[0x1E4FBA3C8], 0);
  }
  uint64_t v11 = *((unsigned __int16 *)a2 + 116);
  if (a1 >= v11)
  {
    uint64_t v15 = v10 + 4 * v11;
    *((_WORD *)a2 + 117) = bswap32(*(unsigned __int16 *)(v15 - 4)) >> 16;
    uint64_t v16 = v15 - 4 + 2 * (int)(a1 - v11);
    if ((unint64_t)(v16 + 6) > *((void *)a2 + 33))
    {
      LOWORD(v17) = 0;
      goto LABEL_14;
    }
    long long v13 = (unsigned __int16 *)(v16 + 4);
  }
  else
  {
    uint64_t v12 = (unsigned __int16 *)(v10 + 4 * a1);
    unsigned int v14 = *v12;
    long long v13 = v12 + 1;
    *((_WORD *)a2 + 117) = bswap32(v14) >> 16;
  }
  unsigned int v17 = bswap32(*v13) >> 16;
LABEL_14:
  *((_WORD *)a2 + 118) = v17;
  if (GlyphOffsetAndSize < 0xBu)
  {
    unint64_t v20 = 0;
    goto LABEL_26;
  }
  int FontTable = ScalerGetFontTable(*(memoryContext **)v6, 1735162214, a2[1], (void *)a2 + 2, 0, GlyphOffsetAndSize);
  uint64_t v19 = (unsigned __int16 *)*((void *)a2 + 2);
  unint64_t v20 = (unint64_t)v19 + FontTable - a2[1];
  *((unsigned char *)a2 + 260) = 1;
  if (!v19)
  {
LABEL_26:
    LOWORD(v28) = 0;
    uint64_t v21 = 0;
    int v25 = 0;
    a2[6] = 0;
    uint64_t v23 = a2 + 6;
    *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v80 = v32;
    long long v81 = v32;
    long long v78 = v32;
    long long v79 = v32;
    int v77 = 0;
    goto LABEL_27;
  }
  if ((unint64_t)(v19 + 1) > v20) {
    goto LABEL_112;
  }
  uint64_t v21 = v19 + 5;
  int v22 = bswap32(*v19);
  *((_WORD *)a2 + 12) = HIWORD(v22);
  uint64_t v23 = a2 + 6;
  *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v80 = v24;
  long long v81 = v24;
  int v25 = v22 >> 16;
  long long v78 = v24;
  long long v79 = v24;
  int v77 = 0;
  if (v25 > 0)
  {
    if (v25 > *(unsigned __int16 *)(*(void *)(v6 + 8) + 44)
      || *((unsigned __int16 *)a2 + 4) <= 2 * (unint64_t)(v25 + 1))
    {
      LOWORD(v28) = 0;
      int v25 = 0;
      *((void *)a2 + 5) = 0;
      *((_WORD *)a2 + 24) = 0;
      *((void *)a2 + 7) = 0;
      unint64_t v26 = (unint64_t)(v19 + 5);
      a2[6] = 0;
    }
    else
    {
      *((void *)a2 + 5) = v21;
      unint64_t v26 = (unint64_t)&v21[(unsigned __int16)v25 + 1];
      if (v26 > v20
        || (unsigned int v27 = &v21[(unsigned __int16)v25],
            unsigned int v28 = (bswap32(*(v27 - 1)) >> 16) + 1,
            *((_WORD *)a2 + 13) = v28,
            uint64_t v29 = bswap32(*v27) >> 16,
            *((_WORD *)a2 + 24) = v29,
            *((void *)a2 + 7) = v26,
            (unint64_t)v19 > v26)
        || (unint64_t v30 = v29 + v26, v30 < v26)
        || v30 > v20)
      {
        uint64_t v31 = __cxa_allocate_exception(2uLL);
        *uint64_t v31 = 5;
        __cxa_throw(v31, MEMORY[0x1E4FBA3C8], 0);
      }
    }
    goto LABEL_28;
  }
  LOWORD(v28) = *((_WORD *)a2 + 13);
LABEL_27:
  *((_WORD *)a2 + 24) = 0;
  *((void *)a2 + 7) = v21;
  unint64_t v26 = (unint64_t)v21;
LABEL_28:
  unsigned int v33 = *a2;
  a2[20] = v25;
  int v34 = (int *)(a2 + 20);
  a2[42] = v33;
  a2[21] = (unsigned __int16)v28;
  uint64_t v35 = *((void *)a2 + 30);
  if (v35)
  {
    uint64_t v36 = *(void *)(v35 + 8);
    uint64_t v37 = *(void *)(v35 + 16);
    LOBYTE(v35) = 1;
  }
  else
  {
    uint64_t v37 = 1358921729;
    uint64_t v36 = 1358921729;
  }
  *(void *)&long long v81 = 1358921729;
  *(void *)&long long v80 = v37;
  *(void *)&long long v79 = v36;
  BYTE8(v81) = v35;
  *(void *)(v6 + 16) = &v78;
  *(void *)(v6 + 24) = 1358921729;
  *(void *)(v6 + 32) = 1358921729;
  *(void *)(v6 + 40) = 1358921729;
  StretchGlyph((uint64_t *)v6, (uint64_t)(a2 + 20), 0, (uint64_t *)&v77, 0, (unsigned char *)a2 + 258, 0);
  if (a3) {
    BOOL v38 = *((unsigned char *)a2 + 258) == 0;
  }
  else {
    BOOL v38 = 1;
  }
  char v39 = !v38;
  int v40 = *v34;
  if (*v34 >= 1)
  {
    unsigned int v41 = (unsigned __int16 *)*((void *)a2 + 13);
    uint64_t v42 = (unsigned __int16 *)*((void *)a2 + 14);
    uint64_t v43 = *((void *)a2 + 19);
    uint64_t v44 = *((void *)a2 + 20);
    uint64_t v45 = *((void *)a2 + 15);
    int v46 = a2[48];
    do
    {
      unsigned int v48 = *v41++;
      uint64_t v47 = v48;
      unsigned int v50 = *v42++;
      uint64_t v49 = v50;
      if (v50 < v47 || v46 <= (int)v49)
      {
        int v75 = __cxa_allocate_exception(2uLL);
        *int v75 = 5;
        __cxa_throw(v75, MEMORY[0x1E4FBA3C8], 0);
      }
      if (*(unsigned __int16 *)(v43 + 2 * v47) == *(unsigned __int16 *)(v43 + 2 * v49)
        && *(unsigned __int16 *)(v44 + 2 * v47) == *(unsigned __int16 *)(v44 + 2 * v49)
        && *(unsigned __int8 *)(v45 + v47) != *(unsigned __int8 *)(v45 + v49))
      {
        *(unsigned char *)(v45 + v49) = 1;
        *(unsigned char *)(v45 + v47) = 1;
      }
      --v40;
    }
    while (v40);
  }
  if (a4) {
    char v39 = 1;
  }
  if (v39)
  {
    unsigned int v52 = a2[20];
    unsigned int v53 = a2[21];
    *((_WORD *)a2 + 12) = v52;
    *((_WORD *)a2 + 13) = v53;
    *((_WORD *)a2 + 24) = 0;
  }
  else
  {
    LOWORD(v52) = *v23;
  }
  *(void *)(a2 + 7) = *(void *)(a2 + 43);
  *(unsigned int *)((char *)a2 + 234) = a2[45];
  if ((v52 & 0x8000u) == 0) {
    char v39 = 1;
  }
  long long v54 = v77;
  if ((v39 & 1) == 0)
  {
    long long v55 = (_WORD *)*((void *)a2 + 9);
    *((void *)a2 + 8) = v55;
    if (v54) {
      long long v56 = &v54[(int)(CountGlyphComponents((const __int16 *)v26, v20, 0) + 4)];
    }
    else {
      long long v56 = 0;
    }
    long long v57 = v55 + 5;
    if ((unint64_t)(v55 + 5) > *((void *)a2 + 25))
    {
LABEL_110:
      __int32 v74 = __cxa_allocate_exception(2uLL);
      *__int32 v74 = 5;
      __cxa_throw(v74, MEMORY[0x1E4FBA3C8], 0);
    }
    *long long v55 = -1;
    v55[1] = bswap32(*((unsigned __int16 *)a2 + 14)) >> 16;
    void v55[2] = bswap32(*((unsigned __int16 *)a2 + 15)) >> 16;
    v55[3] = bswap32(*((unsigned __int16 *)a2 + 16)) >> 16;
    v55[4] = bswap32(*((unsigned __int16 *)a2 + 17)) >> 16;
    while (1)
    {
      ++*((_WORD *)a2 + 128);
      long long v58 = (_WORD *)(v26 + 6);
      if (v26 + 6 > v20) {
        goto LABEL_110;
      }
      unsigned int v59 = __rev16(*(_WORD *)v26 & 0xFFFE);
      __int16 v60 = *(_WORD *)(v26 + 2);
      if ((v59 & 2) != 0)
      {
        if ((v59 & 1) == 0)
        {
          int v61 = *(char *)(v26 + 4);
          int v62 = *(char *)(v26 + 5);
          v59 |= 1u;
          goto LABEL_69;
        }
      }
      else
      {
        *((unsigned char *)a2 + 259) = 1;
        if ((v59 & 1) == 0)
        {
          int v61 = *(unsigned __int8 *)(v26 + 4);
          int v62 = *(unsigned __int8 *)(v26 + 5);
          goto LABEL_69;
        }
      }
      long long v58 = (_WORD *)(v26 + 8);
      if (v26 + 8 > v20) {
        goto LABEL_110;
      }
      int v61 = bswap32(*(unsigned __int16 *)(v26 + 4)) >> 16;
      int v62 = bswap32(*(unsigned __int16 *)(v26 + 6)) >> 16;
LABEL_69:
      if (v77)
      {
        if ((v59 & 2) != 0)
        {
          float v63 = roundf(*v54 + (float)(__int16)v61);
          if (v63 <= 32767.0) {
            float v64 = v63;
          }
          else {
            float v64 = 32767.0;
          }
          if (v63 >= -32768.0) {
            float v65 = v64;
          }
          else {
            float v65 = -32768.0;
          }
          int v61 = (int)v65;
          float v66 = roundf(*v56 + (float)(__int16)v62);
          if (v66 <= 32767.0) {
            float v67 = v66;
          }
          else {
            float v67 = 32767.0;
          }
          if (v66 >= -32768.0) {
            float v68 = v67;
          }
          else {
            float v68 = -32768.0;
          }
          int v62 = (int)v68;
        }
        ++v54;
        ++v56;
      }
      unint64_t v69 = *((void *)a2 + 25);
      if ((unint64_t)(v57 + 2) > v69) {
        goto LABEL_110;
      }
      *long long v57 = __rev16(v59);
      v57[1] = v60;
      if (v59)
      {
        __int32 v70 = v57 + 4;
        if ((unint64_t)(v57 + 4) > v69) {
          goto LABEL_110;
        }
        v57[2] = bswap32(v61) >> 16;
        v57[3] = bswap32(v62) >> 16;
      }
      else
      {
        __int32 v70 = v57 + 3;
        if ((unint64_t)(v57 + 3) > v69) {
          goto LABEL_110;
        }
        *((unsigned char *)v57 + 4) = v61;
        *((unsigned char *)v57 + 5) = v62;
      }
      long long v57 = v70;
      if ((v59 & 0xC8) == 0) {
        goto LABEL_103;
      }
      uint64_t v71 = v58 + 1;
      if ((unint64_t)(v58 + 1) > v20) {
        goto LABEL_110;
      }
      int v72 = v57 + 1;
      unint64_t v73 = *((void *)a2 + 25);
      if ((unint64_t)(v57 + 1) > v73) {
        goto LABEL_110;
      }
      *long long v57 = *v58;
      if ((v59 & 0x80) != 0)
      {
        if ((unint64_t)(v58 + 4) > v20 || (unint64_t)(v57 + 4) > v73) {
          goto LABEL_110;
        }
        v57[1] = v58[1];
        uint64_t v71 = v58 + 3;
        int v72 = v57 + 3;
        v57[2] = v58[2];
        v58 += 4;
        v57 += 4;
        goto LABEL_102;
      }
      if ((v59 & 0x40) != 0)
      {
        v58 += 2;
        if ((unint64_t)v58 > v20) {
          goto LABEL_110;
        }
        v57 += 2;
        if ((unint64_t)v57 > v73) {
          goto LABEL_110;
        }
LABEL_102:
        _WORD *v72 = *v71;
        goto LABEL_103;
      }
      ++v58;
      ++v57;
LABEL_103:
      unint64_t v26 = (unint64_t)v58;
      if ((v59 & 0x20) == 0)
      {
        long long v54 = v77;
        break;
      }
    }
  }
  int v77 = 0;
  if (v54) {
    MEMORY[0x1BA9994A0](v54, 0x1000C8052888210);
  }
}

void sub_1B53094E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x1BA9994A0](a10, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AccumulateComponentGlyphBits(memoryContext *a1, int *a2, unsigned int *a3, unsigned int *a4, unsigned int a5, _DWORD *a6)
{
  int v6 = *a2;
  if (!*a2) {
    return 0;
  }
  uint64_t v18 = a2;
  HIDWORD(v17) = v6 + 31;
  unsigned int v8 = (unsigned int *)ScalerNewScratch(a1, ((v6 + 31) >> 3) & 0xFFFFFFFC, 1);
  int v9 = 0;
  uint64_t v10 = a3;
  do
  {
    if (*v10)
    {
      int v11 = 0;
      unsigned int v12 = 0x80000000;
      do
      {
        if ((*v10 & v12) != 0)
        {
          int v13 = v9 + v11;
          if (v9 + v11 >= v6)
          {
            a3[v13 >> 5] &= ~(0x80000000 >> v11);
          }
          else if ((v8[v13 >> 5] & (0x80000000 >> v11)) == 0)
          {
            *(void *)long long v24 = 0;
            unsigned int v23 = 0;
            LODWORD(v17) = 0;
            if (SetComponentGlyphs(a1, (unsigned __int16)(v9 + v11), v6, v8, a4, (const void *)a5, 0, &v24[1], v24, &v23, v17, v18))
            {
              if (a6)
              {
                if (*a6 < v24[1]) {
                  *a6 = v24[1];
                }
                if (a6[1] < v24[0]) {
                  a6[1] = v24[0];
                }
                if (a6[2] < v23) {
                  a6[2] = v23;
                }
              }
            }
            else
            {
              a3[(uint64_t)v13 >> 5] &= ~(0x80000000 >> v11);
            }
          }
        }
        v12 >>= 1;
        ++v11;
      }
      while (v11 != 32);
    }
    v9 += 32;
    ++v10;
  }
  while (v9 < v6);
  int v14 = ZMergeAndCountLongBits(a3, v8, (__int16)(SHIDWORD(v17) >> 5));
  if (v14 >= v6) {
    uint64_t v15 = v6;
  }
  else {
    uint64_t v15 = v14;
  }
  *uint64_t v18 = v6;
  ScalerDisposeBlock(a1, (char *)v8, -1);
  return v15;
}

uint64_t SetComponentGlyphs(memoryContext *a1, unsigned int a2, int a3, unsigned int *a4, unsigned int *a5, const void *a6, int a7, _DWORD *a8, unsigned int *a9, unsigned int *a10, unsigned int *a11, unsigned int a12)
{
  if (a11 >= 0x10)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  if (a6)
  {
    uint64_t v18 = &a5[a2];
    unsigned int v19 = bswap32(*v18);
    unsigned int v20 = bswap32(v18[1]) - v19;
  }
  else
  {
    uint64_t v21 = (unsigned __int16 *)a5 + a2;
    unsigned int v22 = bswap32(*v21);
    unsigned int v19 = 2 * HIWORD(v22);
    unsigned int v20 = 2 * ((bswap32(v21[1]) >> 16) - HIWORD(v22));
  }
  if (v20 < 0xB) {
    return 1;
  }
  uint64_t v47 = 0;
  int FontTable = ScalerGetFontTable(a1, 1735162214, v19, &v47, 1, v20);
  long long v24 = (char *)v47;
  if (!v47) {
    return 0;
  }
  uint64_t v25 = FontTable - v19;
  unint64_t v26 = (unsigned __int16 *)((char *)v47 + v25);
  if ((char *)v47 + 2 > (char *)v47 + v25)
  {
    uint64_t v42 = __cxa_allocate_exception(0x10uLL);
    *(void *)uint64_t v42 = &unk_1F0DD4440;
    v42[2] = 4;
  }
  unsigned int v27 = (unsigned __int16 *)((char *)v47 + 10);
  int v28 = (int)bswap32(*(unsigned __int16 *)v47) >> 16;
  if (v28 < 0)
  {
    HIDWORD(v45) = a11 + 1;
    if (*a10 <= a11) {
      *a10 = HIDWORD(v45);
    }
    do
    {
      if ((unint64_t)v27 > 0xFFFFFFFFFFFFFFFBLL || v24 > (char *)v27 || v27 + 2 > v26)
      {
        int v40 = __cxa_allocate_exception(0x10uLL);
        *(void *)int v40 = &unk_1F0DD4440;
        v40[2] = 4;
      }
      unsigned int v34 = bswap32(*v27);
      if (a7 && (v34 & 0xC80000) != 0) {
        break;
      }
      unsigned int v35 = bswap32(v27[1]);
      if ((int)HIWORD(v35) < a3)
      {
        a4[v35 >> 21] |= 0x80000000 >> SBYTE2(v35);
        LODWORD(v44) = HIDWORD(v45);
        SetComponentGlyphs(a1, HIWORD(v35), a3, a4, a5, a6, a7, a8, a9, a10, v44, v45);
      }
      if ((v34 & 0x10000) != 0) {
        uint64_t v36 = 2;
      }
      else {
        uint64_t v36 = 1;
      }
      uint64_t v37 = v36 + ((v34 >> 19) & 1);
      if ((v34 & 0x400000) != 0) {
        uint64_t v37 = v36 + 2;
      }
      uint64_t v38 = v36 | 4;
      if ((v34 & 0x800000) == 0) {
        uint64_t v38 = v37;
      }
      v27 += v38 + 2;
    }
    while ((v34 & 0x200000) != 0);
    uint64_t v29 = 1;
  }
  else
  {
    uint64_t v29 = 1;
    if (a11 && *(_WORD *)v47)
    {
      *a9 += v28;
      unint64_t v30 = &v27[(unsigned __int16)v28];
      if (v30 < v27 || v30 > v26)
      {
        unint64_t v32 = (unint64_t)(v25 - 10) >> 1;
        if (v24 + 12 > (char *)v26 || v32 != (unsigned __int16)v28)
        {
          uint64_t v43 = __cxa_allocate_exception(0x10uLL);
          *(void *)uint64_t v43 = &unk_1F0DD4440;
          _OWORD v43[2] = 4;
        }
      }
      *a8 += (bswap32(v27[v28 - 1]) >> 16) + 1;
    }
  }
  ScalerReleaseFontTable(a1, v24);
  return v29;
}

void sub_1B5309AC0(void *a1)
{
}

memoryContext *FindComponentsFromGlyfTable(memoryContext *result, int a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, void *a6, int a7)
{
  int v13 = result;
  int v14 = 0;
  do
  {
    if (*a3)
    {
      int v15 = 0;
      unsigned int v16 = 0x80000000;
      do
      {
        BOOL v17 = v14 + v15 >= a2 || (*a3 & v16) == 0;
        if (!v17 && ((a4[(v14 + v15) >> 5] << v15) & 0x80000000) == 0) {
          uint64_t result = (memoryContext *)SetComponentGlyphs(v13, (unsigned __int16)(v14 + v15), a2, a4, a5, a6, a7, &v19[1], v19, (unsigned int *)&v18 + 1, 0, 0);
        }
        v16 >>= 1;
        ++v15;
      }
      while (v15 != 32);
    }
    v14 += 32;
    ++a3;
  }
  while (v14 < a2);
  return result;
}

void TType1PDT1Font::~TType1PDT1Font(TType1PDT1Font *this)
{
  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x1BA9994D0);
}

void TType1PDT1Font::TType1PDT1Font(TType1PDT1Font *this, const TType1Font *a2)
{
  *((void *)this + 3) = 0;
  *((void *)this + 4) = a2;
  *(void *)this = &unk_1F0DFF2B8;
  *((_WORD *)this + 4) = 0;
  FontObject = TType1PSFont::GetFontObject(this);
  uint64_t v4 = (*(uint64_t (**)(TType1PDT1Font *))(*(void *)this + 120))(this);
  if ((*(unsigned int (**)(void *, uint64_t))(*FontObject + 64))(FontObject, v4) + 1 <= 1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  *((_WORD *)this + 8) = *(_WORD *)(*(void *)(*((void *)this + 4) + 128) + 56);
}

void sub_1B5309DDC(_Unwind_Exception *exception_object)
{
  *int v1 = &unk_1F0E02218;
  uint64_t v3 = v1[3];
  v1[3] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TType1PDT1Font::GetFontDataTableTag(TType1PDT1Font *this)
{
  return 1346655281;
}

uint64_t TType1PDT1Font::GetFontDataHeaderSize(TType1PDT1Font *this)
{
  return 0;
}

uint64_t TType1PDT1Font::GetFontDataLength(TType1PDT1Font *this, unsigned int *a2, unsigned int *a3)
{
  unint64_t v39 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v37[1] = v6;
  *(_OWORD *)uint64_t v38 = v6;
  v37[0] = v6;
  char v7 = (const TFontObjectSurrogate *)(*(uint64_t (**)(TType1PDT1Font *))(*(void *)this + 216))(this);
  uint64_t v8 = (*(uint64_t (**)(TType1PDT1Font *))(*(void *)this + 120))(this);
  TFontObjectTable::TFontObjectTable((TFontObjectTable *)v37, v7, v8);
  uint64_t v10 = LODWORD(v37[0]);
  unsigned int v35 = -1431655766;
  unsigned int v36 = -1431655766;
  uint64_t v11 = *(void *)(*((void *)this + 4) + 200);
  if (v11) {
    unsigned int v12 = "currentfile eexec";
  }
  else {
    unsigned int v12 = "systemdict begin";
  }
  *(_DWORD *)unsigned int v34 = v37[0];
  int v13 = TType1PSFont::ScanForKey((TType1PSFont *)v12, v38[1], v34, &v35, &v36, v9);
  int v15 = v13;
  unsigned int v16 = v36;
  unsigned int v17 = *(_DWORD *)v34;
  unsigned int v18 = *(_DWORD *)v34 - v36;
  *(_DWORD *)v34 -= v36;
  if (*(_DWORD *)v34)
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0xFFFFFFFFLL;
    do
    {
      int v21 = v13[v19];
      if (v21 != 13 && v21 != 10)
      {
        unsigned int v23 = (char *)&v13[v19];
        unsigned int v17 = v16 + v19;
        goto LABEL_14;
      }
      unsigned int v36 = v16 + v19 + 1;
      *(_DWORD *)unsigned int v34 = v18 + v20;
      ++v19;
      --v20;
    }
    while (v18 != v19);
    unsigned int v23 = (char *)&v13[v19];
  }
  else
  {
    unsigned int v17 = v36;
    unsigned int v23 = (char *)v13;
  }
LABEL_14:
  unsigned int v24 = v35 + v17;
  *a2 = v24;
  if (v11)
  {
    uint64_t v25 = TType1PSFont::ScanForKey((TType1PSFont *)"cleartomark", v23, v34, &v35, &v36, v14);
    unint64_t v26 = &v25[-v36 - 1];
    int v27 = 511;
    unsigned int v28 = v35;
    do
    {
      int v29 = v27;
      --v28;
      unint64_t v30 = v26;
      while (1)
      {
        int v31 = *v30--;
        unsigned int v35 = v28;
        if (v31 == 48) {
          break;
        }
        --v28;
        unint64_t v26 = v30;
        if (v30 <= v15)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          *(void *)exception = &unk_1F0DFC400;
          exception[4] = 5;
        }
      }
      int v27 = v29 - 1;
      --v26;
    }
    while (v29);
  }
  else
  {
    unsigned int v28 = v10 - v24;
  }
  *a3 = v28;
  TDataReference::~TDataReference((TDataReference *)((char *)v37 + 8));
  return v10;
}

void sub_1B530A090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  TDataReference::~TDataReference((TDataReference *)va);
  _Unwind_Resume(a1);
}

void TType1PDT1Font::GetCharOutline(TType1PDT1Font *this@<X0>, unsigned __int16 *a2@<X2>, void *a3@<X8>)
{
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v9 = v5;
  long long v10 = v5;
  *(_OWORD *)long long __src = v5;
  long long v8 = v5;
  (*(void (**)(void **__return_ptr))(**((void **)this + 4) + 488))(__src);
  __int16 v6 = v8;
  *a2 = v8;
  if (v6)
  {
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    operator new[]();
  }
  *a3 = 0;
  TCharString::~TCharString(__src);
}

void sub_1B530A168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void *TType1PDT1Font::FindCharName(TType1PDT1Font *this, unsigned int a2, unsigned __int8 *a3)
{
  uint64_t v3 = *((void *)this + 4);
  uint64_t v4 = *(unsigned int *)(*(void *)(v3 + 192) + 4 * a2);
  if ((v4 & 0x80000000) != 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  __int16 v6 = (unsigned __int8 *)(*(void *)(v3 + 48) + v4);
  uint64_t result = memcpy(a3 + 2, v6 + 1, *v6);
  a3[1] = 47;
  *a3 = *v6 + 1;
  return result;
}

uint64_t TType1PDT1Font::GetGlyphID(TType1PDT1Font *this, const unsigned __int8 *a2, int a3)
{
  __int16 v6 = (void *)*((void *)this + 4);
  uint64_t v7 = v6[24];
  unsigned int v8 = (*(uint64_t (**)(void *))(*v6 + 168))(v6);
  if (v8 >= 0xFFFF) {
    uint64_t v9 = 0xFFFFLL;
  }
  else {
    uint64_t v9 = v8;
  }
  if (v9)
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *(unsigned int *)(v7 + 4 * v10);
      if ((v11 & 0x80000000) == 0)
      {
        unsigned int v12 = (unsigned __int8 *)(*(void *)(*((void *)this + 4) + 48) + v11);
        size_t v13 = *v12;
        if (v13 == a3 && !memcmp(v12 + 1, a2, v13)) {
          break;
        }
      }
      if (v9 == ++v10) {
        goto LABEL_10;
      }
    }
  }
  else
  {
LABEL_10:
    LOWORD(v10) = 0;
  }
  return (unsigned __int16)v10;
}

void TPDT1CharStringContext::~TPDT1CharStringContext(TPDT1CharStringContext *this)
{
  *(void *)this = &unk_1F0DFF400;
  uint64_t v2 = *((void *)this + 37);
  *((void *)this + 37) = 0;
  if (v2) {
    MEMORY[0x1BA9994A0](v2, 0x1000C8077774924);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0DFF400;
  uint64_t v2 = *((void *)this + 37);
  *((void *)this + 37) = 0;
  if (v2) {
    MEMORY[0x1BA9994A0](v2, 0x1000C8077774924);
  }
  JUMPOUT(0x1BA9994D0);
}

void TBufferedPDT1CharStringStreamingContext::~TBufferedPDT1CharStringStreamingContext(TBufferedPDT1CharStringStreamingContext *this)
{
  TBufferedCharStringStreamingContext::~TBufferedCharStringStreamingContext(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TBufferedPDT1CharStringStreamingContext::StreamDecryptedCharString(TBufferedPDT1CharStringStreamingContext *this, const TType1PSFont *a2, uint64_t a3, char *a4, int *a5)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[15] = v10;
  v23[14] = v10;
  v23[13] = v10;
  v23[12] = v10;
  v23[11] = v10;
  v23[10] = v10;
  void v23[9] = v10;
  _OWORD v23[8] = v10;
  unsigned char v23[7] = v10;
  v23[5] = v10;
  int v23[6] = v10;
  v23[3] = v10;
  unsigned __int8 v23[4] = v10;
  v23[1] = v10;
  v23[2] = v10;
  v23[0] = v10;
  unsigned int v24 = "/.notdef";
  uint64_t v25 = 8;
  unint64_t v26 = 0;
  unint64_t v27 = 0;
  unsigned int v22 = &unk_1F0DFF400;
  uint64_t v28 = 0;
  uint64_t v11 = *(void *)(*((void *)a2 + 4) + 104);
  (*(void (**)(const TType1PSFont *, uint64_t, _OWORD *))(*(void *)a2 + 232))(a2, a3, v23);
  unsigned int v24 = (char *)v23 + 1;
  uint64_t v25 = LOBYTE(v23[0]);
  unint64_t v27 = *(unsigned int *)(v11 + 8 * a3 + 4);
  __int16 v21 = -21846;
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(unint64_t *__return_ptr, const TType1PSFont *, uint64_t, __int16 *))(*(void *)a2 + 128))(&v20, a2, a3, &v21);
  unint64_t v12 = v20;
  unint64_t v26 = v20;
  if (*((__int16 *)a2 + 8) >= 1)
  {
    unint64_t v13 = *((unsigned __int16 *)a2 + 8);
    BOOL v14 = v27 >= v13;
    unint64_t v15 = v27 - v13;
    if (!v14)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DFC400;
      exception[4] = 5;
    }
    unint64_t v27 = v15;
  }
  unint64_t v20 = 0;
  uint64_t v16 = v28;
  uint64_t v28 = v12;
  if (v16)
  {
    MEMORY[0x1BA9994A0](v16, 0x1000C8077774924);
    unint64_t v17 = v20;
    unint64_t v20 = 0;
    if (v17) {
      MEMORY[0x1BA9994A0](v17, 0x1000C8077774924);
    }
  }
  TBufferedCharStringStreamingContext::DoCharString(this, (uint64_t)&v22, a4, (uint64_t)a5);
  uint64_t result = v28;
  unsigned int v22 = &unk_1F0DFF400;
  uint64_t v28 = 0;
  if (result) {
    return MEMORY[0x1BA9994A0](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1B530A674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49)
{
  if (a10) {
    MEMORY[0x1BA9994A0](a10, 0x1000C8077774924);
  }
  if (a49) {
    MEMORY[0x1BA9994A0](a49, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TType1PDT1Font::StreamPSFont(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9, uint64_t a10)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 48))(a1, *a9);
  *a9 = v14;
  unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(&v33, a1, v14, a8);
  unint64_t v15 = (__int32 *)v33;
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v75 = v16;
  long long v74 = v16;
  long long v73 = v16;
  long long v72 = v16;
  long long v71 = v16;
  long long v70 = v16;
  long long v69 = v16;
  long long v68 = v16;
  long long v67 = v16;
  long long v66 = v16;
  long long v65 = v16;
  long long v64 = v16;
  long long v63 = v16;
  long long v62 = v16;
  long long v61 = v16;
  long long v60 = v16;
  long long v59 = v16;
  long long v58 = v16;
  long long v57 = v16;
  long long v56 = v16;
  long long v55 = v16;
  long long v54 = v16;
  long long v53 = v16;
  long long v52 = v16;
  long long v51 = v16;
  long long v50 = v16;
  long long v48 = v16;
  long long v49 = v16;
  long long v46 = v16;
  long long v47 = v16;
  *(_OWORD *)uint64_t v44 = v16;
  long long v45 = v16;
  unsigned int v17 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 168))(*(void *)(a1 + 32));
  if (v17 >= 0xFFFF) {
    uint64_t v20 = 0xFFFFLL;
  }
  else {
    uint64_t v20 = v17;
  }
  if (!a5) {
    TType1PSFont::SetEncoding(v20, v15, v44, v18);
  }
  if ((*a9 & 0x200) != 0)
  {
    unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v41 = v24;
    long long v42 = v24;
    long long v39 = v24;
    long long v40 = v24;
    long long v37 = v24;
    long long v38 = v24;
    long long v35 = v24;
    long long v36 = v24;
    TBufferedStreamingContext::TBufferedStreamingContext(&v35, a1, (uint64_t)v15, a10);
  }
  if ((*a9 & 2) != 0)
  {
    if (v15)
    {
      int v21 = 0;
      if (v20)
      {
        unsigned int v22 = (v20 + 31) >> 5;
        unsigned int v23 = v15;
        do
        {
          if (*v23)
          {
            v19.i32[0] = *v23;
            int8x8_t v19 = vcnt_s8(v19);
            v19.i16[0] = vaddlv_u8((uint8x8_t)v19);
            v21 += v19.i32[0];
          }
          ++v23;
          --v22;
        }
        while (v22);
      }
      if (a5 || v21 != v20)
      {
LABEL_22:
        memset(__b, 170, 0x2B8uLL);
        TBufferedCharStringStreamingContext::TBufferedCharStringStreamingContext(__b, a1, (uint64_t)v15, a10);
      }
    }
    else if (a5)
    {
      goto LABEL_22;
    }
    if ((a3 & 1) != 0 || (*(_WORD *)(a1 + 8) & 0x4000) == 0)
    {
      unint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v25 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v31[1] = v25;
      _OWORD v31[2] = v25;
      v31[0] = v25;
      unint64_t v26 = (const TFontObjectSurrogate *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 216))(a1);
      uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
      TFontObjectTable::TFontObjectTable((TFontObjectTable *)v31, v26, v27);
      v30[0] = -1431655766;
      v30[1] = -1431655766;
      (*(void (**)(uint64_t, unsigned int *, unsigned int *))(*(void *)a1 + 296))(a1, &v30[1], v30);
      unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v41 = v28;
      long long v42 = v28;
      long long v39 = v28;
      long long v40 = v28;
      long long v37 = v28;
      long long v38 = v28;
      long long v35 = v28;
      long long v36 = v28;
      TBufferedStreamingContext::TBufferedStreamingContext(&v35, a1, (uint64_t)v15, a10);
    }
    goto LABEL_22;
  }
  uint64_t result = v33;
  unint64_t v33 = 0;
  if (result) {
    return MEMORY[0x1BA9994A0](result, 0x1000C8052888210);
  }
  return result;
}

void sub_1B530AD64(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void TType1PFAFont::TType1PFAFont(TType1PFAFont *this, const TType1Font *a2)
{
  *((void *)this + 3) = 0;
  *((void *)this + 4) = a2;
  *(void *)this = &unk_1F0DFF420;
  *((_WORD *)this + 4) = 0;
  uint64_t v3 = (*(uint64_t (**)(const TType1Font *))(*(void *)a2 + 56))(a2);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 24))(v3) + 1 <= 1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DFC400;
    exception[4] = 5;
  }
  *((_WORD *)this + 8) = *(_WORD *)(*(void *)(*((void *)this + 4) + 128) + 56);
}

void sub_1B530B0A8(_Unwind_Exception *exception_object)
{
  *int v1 = &unk_1F0E02218;
  uint64_t v3 = v1[3];
  v1[3] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  _Unwind_Resume(exception_object);
}

void TType1PFAFont::~TType1PFAFont(TType1PFAFont *this)
{
  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F0E02218;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x1BA9994D0);
}

const unsigned __int8 *TType1OTFFont::GetSubrData(TType1OTFFont *this, const unsigned __int8 **a2, __int16 *a3, const unsigned __int8 **a4)
{
  uint64_t v4 = *((void *)this + 4);
  int v5 = *(unsigned __int16 *)(v4 + 146);
  *a3 = v5;
  uint64_t v8 = v4 + 112;
  __int16 v6 = *(const unsigned __int8 **)(v4 + 112);
  uint64_t v7 = *(void *)(v8 + 8);
  *a2 = v6;
  *a4 = &v6[v7];
  if (*a2) {
    BOOL v9 = v5 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9) {
    return &v6[(__int16)v5 + (__int16)v5 * (unint64_t)*(unsigned __int16 *)(*((void *)this + 4) + 144)];
  }
  uint64_t result = 0;
  *a4 = 0;
  return result;
}

uint64_t TType1OTFFont::GetGlobalSubrCount(TType1OTFFont *this)
{
  return *(unsigned __int16 *)(*((void *)this + 4) + 318);
}

uint64_t TType1OTFFont::GetGlobalSubrArrayAndObjectData(TType1OTFFont *this, __int16 *a2, const unsigned __int8 **a3, const unsigned __int8 **a4, const unsigned __int8 **a5, const unsigned __int8 **a6)
{
  uint64_t v6 = *((void *)this + 4);
  uint64_t result = *(void *)(v6 + 320);
  if (result
    && (__int16 v8 = *(unsigned __int8 *)(v6 + 317),
        unint64_t v9 = *(void *)(v6 + 328),
        unint64_t v10 = *(unsigned __int8 *)(v6 + 317)
            + *(unsigned __int16 *)(v6 + 318) * (unint64_t)*(unsigned __int8 *)(v6 + 317),
        v9 > v10))
  {
    uint64_t v11 = (const unsigned __int8 *)(result + v10);
    *a2 = v8;
    *a3 = v11;
    *a4 = v11;
    unint64_t v12 = (const unsigned __int8 *)(result + v9);
  }
  else
  {
    unint64_t v12 = 0;
    uint64_t result = 0;
    *a2 = 0;
    *a3 = 0;
    *a4 = 0;
  }
  *a5 = v12;
  *a6 = v12;
  return result;
}

uint64_t DetermineROS(const char *a1, const char *a2)
{
  if (!a1 || !a2 || strcmp(a1, "Adobe")) {
    goto LABEL_4;
  }
  if (!strcmp(a2, "Japan1"))
  {
    uint64_t v3 = 0x100000000;
    uint64_t v4 = 2;
    return v4 | v3;
  }
  if (!strcmp(a2, "GB1"))
  {
    uint64_t v4 = 0;
    uint64_t v3 = 0x100000000;
    return v4 | v3;
  }
  if (!strcmp(a2, "CNS1"))
  {
    uint64_t v3 = 0x100000000;
    uint64_t v4 = 1;
    return v4 | v3;
  }
  if (!strcmp(a2, "Korea1"))
  {
    uint64_t v3 = 0x100000000;
    uint64_t v4 = 3;
  }
  else
  {
LABEL_4:
    uint64_t v3 = 0;
    uint64_t v4 = 0;
  }
  return v4 | v3;
}

uint64_t MakeGlyphNameForCIDPerROS(unsigned int a1, int a2, char *a3, size_t a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = "90CEFE00";
  uint64_t v7 = (const char *)&str_4635;
  unint64_t v8 = 30284;
  switch(a2)
  {
    case 0:
      goto LABEL_7;
    case 1:
      uint64_t v6 = "D840DCCC";
      unint64_t v8 = 19179;
      uint64_t v7 = (const char *)&str_4637;
      goto LABEL_7;
    case 2:
      uint64_t v6 = "0030FE00";
      unint64_t v8 = 23060;
      uint64_t v7 = (const char *)&str_4639;
      goto LABEL_7;
    case 3:
      uint64_t v6 = "00280028";
      unint64_t v8 = 18352;
      uint64_t v7 = str_4641;
LABEL_7:
      if (v8 <= a1) {
        return snprintf_l(a3, a4, 0, "cid%d");
      }
      uint64_t v11 = &v7[4 * a1];
      if ((*v11 & 0x80000000) == 0)
      {
        size_t v12 = 4 * (*v11 != 0);
        if (*v11) {
          goto LABEL_10;
        }
        return snprintf_l(a3, a4, 0, "cid%d");
      }
      uint64_t v11 = &v6[bswap32(*(_DWORD *)v11 & 0xFFFFFF7F)];
      size_t v12 = strlen(v11);
      if (!*v11) {
        return snprintf_l(a3, a4, 0, "cid%d");
      }
LABEL_10:
      if (v12 < 5) {
        return snprintf_l(a3, a4, 0, "uni%.*s.%d");
      }
      size_t v13 = v12 >> 2;
      *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v40[4] = v14;
      v40[5] = v14;
      v40[2] = v14;
      v40[3] = v14;
      v40[0] = v14;
      v40[1] = v14;
      LOWORD(v39) = 0;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::vector(v40, v12 >> 2, &v39);
      unint64_t v15 = *(unsigned __int16 **)&v40[0];
      if ((uint64_t)v12 >= 1)
      {
        uint64_t v16 = 0;
        unsigned int v17 = &v11[v12];
        do
        {
          LOBYTE(v18) = *v11;
          if (*v11)
          {
            __int16 v19 = 0;
            uint64_t v20 = 1;
            do
            {
              __int16 v21 = (char)v18;
              if ((v18 - 48) >= 0xAu)
              {
                if (((char)v18 - 65) >= 6)
                {
                  if (((char)v18 - 97) > 5) {
                    goto LABEL_24;
                  }
                  __int16 v22 = -87;
                }
                else
                {
                  __int16 v22 = -55;
                }
              }
              else
              {
                __int16 v22 = -48;
              }
              __int16 v19 = v21 + 16 * v19 + v22;
              if ((v20 - 1) > 2) {
                break;
              }
              int v18 = v11[v20++];
            }
            while (v18);
          }
          else
          {
LABEL_24:
            __int16 v19 = -1;
          }
          v15[v16++] = v19;
          v11 += 4;
        }
        while (v11 < v17);
      }
      int v23 = *v15;
      int v24 = v23;
      int v38 = a1;
      if ((v23 & 0xF800) != 0xD800) {
        goto LABEL_37;
      }
      int v24 = 65533;
      if (v13 == 1 || (v23 & 0x400) != 0) {
        goto LABEL_37;
      }
      int v25 = v15[1];
      if ((v25 & 0xFC00) != 0xDC00)
      {
        int v24 = 65533;
LABEL_37:
        int v26 = snprintf_l(a3, a4, 0, "uni%04X", v24);
        int v27 = 1;
        unint64_t v28 = 1;
        goto LABEL_38;
      }
      int v26 = snprintf_l(a3, a4, 0, "u%X", v25 + (v23 << 10) - 56613888);
      int v27 = 0;
      unint64_t v28 = 2;
LABEL_38:
      uint64_t v31 = v26;
      if (v28 < v13)
      {
        do
        {
          unint64_t v32 = v28 + 1;
          int v33 = v15[v28];
          if ((v33 & 0xF800) != 0xD800
            || (v33 & 0x400) != 0
            || v32 == v13
            || (int v34 = v15[v32], (v34 & 0xFC00) != 0xDC00))
          {
            long long v36 = &a3[v31];
            size_t v37 = a4 - v31;
            if (v27) {
              int v35 = snprintf_l(v36, v37, 0, "%04X");
            }
            else {
              int v35 = snprintf_l(v36, v37, 0, "_uni%04X");
            }
            int v27 = 1;
          }
          else
          {
            int v35 = snprintf_l(&a3[v31], a4 - v31, 0, "_u%X", (v33 << 10) - 56613888 + v34);
            int v27 = 0;
            unint64_t v32 = v28 + 2;
          }
          v31 += v35;
          unint64_t v28 = v32;
        }
        while (v32 < v13);
      }
      uint64_t v29 = v31 + snprintf_l(&a3[v31], a4 - v31, 0, ".%d", v38);
      long long v39 = (void **)v40;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:fe180100](&v39);
      return v29;
    default:
      if (a2 != 0xFFFF) {
        return snprintf_l(a3, a4, 0, "cid%d");
      }
      return snprintf_l(a3, a4, 0, "gid%d");
  }
}

void sub_1B530B798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

char *GenerateGlyphNameForCIDPerROS(unsigned int a1, int a2, char *a3)
{
  return a3;
}

uint64_t TGlyphNameToUnicodeTaxisLookup::GetUnicodes(const char ***this, const char *a2, unsigned int (*a3)[4])
{
  unsigned int v8 = -1431655766;
  if (!TSortedStringTable::GetValue(this, a2, &v8)) {
    return 0;
  }
  if (HIWORD(v8) > 0x10u)
  {
    unsigned int v5 = v8 - 1114112;
    if (v8 - 1114112 <= 0x56)
    {
      *(void *)&(*a3)[2] = 0;
      uint64_t v6 = (unsigned int *)((char *)&gGlyphNamesUnicodeSequences + 20 * v5);
      uint64_t v4 = *v6;
      memcpy(a3, v6 + 1, 4 * v4);
      return v4;
    }
    return 0;
  }
  (*a3)[0] = v8;
  return 1;
}

void ___Z26GetLatinEncodingDictionaryv_block_invoke()
{
}

void ___Z24GetLatinEncodingTaxonomyv_block_invoke()
{
}

void *std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::vector(void *a1, uint64_t a2, _WORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[11] = a1 + 3;
  if (a2)
  {
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:fe180100](a1, a2);
    uint64_t v6 = (_WORD *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 2 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 2;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1B530B99C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:fe180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
  }
  uint64_t result = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * a2];
  return result;
}

uint64_t TType1Font::AddName(uint64_t *a1, unsigned __int8 *a2, __int16 a3)
{
  __int16 v9 = a3;
  uint64_t v4 = *a2;
  uint64_t v7 = v4;
  uint64_t v8 = a2 + 1;
  unint64_t v5 = a1[1];
  if (v5 >= a1[2])
  {
    uint64_t result = std::vector<TFontNameString>::__emplace_back_slow_path<unsigned short &,void const*,unsigned long>(a1, &v9, &v8, &v7);
  }
  else
  {
    *(void *)(v5 + 8) = a2 + 1;
    *(void *)(v5 + 16) = v4;
    *(unsigned char *)(v5 + 24) = 0;
    *(void *)(v5 + 32) = &unk_1F0DD4218;
    *(void *)(v5 + 40) = 0;
    *(void *)(v5 + 48) = 0;
    *(void *)(v5 + 56) = 0;
    *(unsigned char *)(v5 + 64) = 1;
    *(void *)unint64_t v5 = &unk_1F0DD4360;
    *(_WORD *)(v5 + 66) = a3;
    *(_DWORD *)(v5 + 68) = 1;
    *(_WORD *)(v5 + 72) = 0;
    uint64_t result = v5 + 96;
    *(void *)(v5 + 80) = 0;
    *(void *)(v5 + 88) = 0;
  }
  a1[1] = result;
  return result;
}

uint64_t TType1Font::GetNames@<X0>(uint64_t this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = this;
  a2[2] = 0;
  uint64_t v4 = (uint64_t)(a2 + 2);
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(int *)(this + 80);
  if (v5 != -1) {
    this = TType1Font::AddName(a2, (unsigned __int8 *)(*(void *)(this + 48) + v5), 0);
  }
  uint64_t v6 = *(int *)(v2 + 60);
  if (v6 != -1)
  {
    this = TType1Font::AddName(a2, (unsigned __int8 *)(*(void *)(v2 + 48) + v6), 1);
    uint64_t v7 = *(int *)(v2 + 56);
    if (v7 != -1)
    {
      this = (uint64_t)DeriveStyleName((const unsigned __int8 *)(*(void *)(v2 + 48) + *(int *)(v2 + 60)), (const unsigned __int8 *)(*(void *)(v2 + 48) + v7));
      if (this)
      {
        uint64_t v8 = this;
        this = strlen((const char *)this);
        uint64_t v9 = this;
        unint64_t v10 = a2[1];
        unint64_t v11 = a2[2];
        if (v10 >= v11)
        {
          unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *a2) >> 5);
          unint64_t v14 = v13 + 1;
          if (v13 + 1 > 0x2AAAAAAAAAAAAAALL) {
            std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
          }
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - *a2) >> 5);
          if (2 * v15 > v14) {
            unint64_t v14 = 2 * v15;
          }
          if (v15 >= 0x155555555555555) {
            unint64_t v16 = 0x2AAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v16 = v14;
          }
          unsigned __int8 v23[4] = v4;
          if (v16) {
            unsigned int v17 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TFontNameString>>(v4, v16);
          }
          else {
            unsigned int v17 = 0;
          }
          int v18 = &v17[96 * v13];
          v23[0] = v17;
          v23[1] = v18;
          v23[3] = &v17[96 * v16];
          *((void *)v18 + 1) = v8;
          *((void *)v18 + 2) = v9;
          v18[24] = 0;
          *((void *)v18 + 4) = &unk_1F0DD4218;
          *((void *)v18 + 5) = 0;
          *((void *)v18 + 6) = 0;
          *((void *)v18 + 7) = 0;
          v18[64] = 1;
          *(void *)int v18 = &unk_1F0DD4360;
          *(void *)(v18 + 66) = 65538;
          *((void *)v18 + 10) = 0;
          *((void *)v18 + 11) = 0;
          v23[2] = v18 + 96;
          std::vector<TFontNameString>::__swap_out_circular_buffer(a2, v23);
          uint64_t v12 = a2[1];
          this = std::__split_buffer<TFontNameString>::~__split_buffer((uint64_t)v23);
        }
        else
        {
          *(void *)(v10 + 8) = v8;
          *(void *)(v10 + 16) = this;
          *(unsigned char *)(v10 + 24) = 0;
          *(void *)(v10 + 32) = &unk_1F0DD4218;
          *(void *)(v10 + 40) = 0;
          *(void *)(v10 + 48) = 0;
          *(void *)(v10 + 56) = 0;
          *(unsigned char *)(v10 + 64) = 1;
          *(void *)unint64_t v10 = &unk_1F0DD4360;
          *(void *)(v10 + 66) = 65538;
          *(void *)(v10 + 80) = 0;
          *(void *)(v10 + 88) = 0;
          uint64_t v12 = v10 + 96;
          a2[1] = v10 + 96;
        }
        a2[1] = v12;
      }
    }
  }
  uint64_t v19 = *(int *)(v2 + 56);
  if (v19 != -1)
  {
    TType1Font::AddName(a2, (unsigned __int8 *)(*(void *)(v2 + 48) + v19), 3);
    this = TType1Font::AddName(a2, (unsigned __int8 *)(*(void *)(v2 + 48) + *(int *)(v2 + 56)), 4);
  }
  uint64_t v20 = *(int *)(v2 + 64);
  if (v20 != -1) {
    this = TType1Font::AddName(a2, (unsigned __int8 *)(*(void *)(v2 + 48) + v20), 5);
  }
  uint64_t v21 = *(int *)(v2 + 76);
  if (v21 != -1) {
    this = TType1Font::AddName(a2, (unsigned __int8 *)(*(void *)(v2 + 48) + v21), 6);
  }
  uint64_t v22 = *(int *)(v2 + 72);
  if (v22 != -1) {
    return TType1Font::AddName(a2, (unsigned __int8 *)(*(void *)(v2 + 48) + v22), 7);
  }
  return this;
}

void sub_1B530BDC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14)
{
}

uint64_t TType1Font::GetSomeNames(TType1Font *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 104))();
}

uint64_t TType1Font::GetNumberOfGlyphs(TType1Font *this)
{
  return *((unsigned int *)this + 35);
}

double TType1Font::GetCaretInfo(TType1Font *this, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  *(double *)&uint64_t v15 = NAN;
  double v16 = NAN;
  TType1Font::ApplyFontMatrix((uint64_t)this, 0.0, 0.0, (double *)&v15);
  int v8 = *((_DWORD *)this + 38);
  if (v8)
  {
    double v9 = (double)((18 * (-v8 >> 8)) >> 16);
    double v10 = 1000.0;
  }
  else
  {
    double v9 = 0.0;
    double v10 = 1.0;
  }
  TType1Font::ApplyFontMatrix((uint64_t)this, v9, v10, v14);
  double v11 = v14[0];
  double v12 = *(double *)&v15;
  *a2 = llround(v14[1] - v16);
  double result = v11 - v12;
  *a3 = llround(result);
  *a4 = 0;
  return result;
}

void *TType1Font::GetGlyphName@<X0>(void *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (!this[24]
    || ((uint64_t v5 = this,
         this = (void *)(*(uint64_t (**)(void *))(*this + 168))(this),
         this >= 0xFFFF)
      ? (unsigned int v6 = 0xFFFF)
      : (unsigned int v6 = this),
        v6 <= a2 || (uint64_t v7 = *(int *)(v5[24] + 4 * a2), v7 == -1)))
  {
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  else
  {
    int v8 = (unsigned __int8 *)(v5[6] + v7);
    uint64_t v9 = *v8;
    *(void *)(a3 + 8) = v8 + 1;
    *(void *)(a3 + 16) = v9;
  }
  *(void *)a3 = &unk_1F0DD43A0;
  *(unsigned char *)(a3 + 24) = 0;
  *(void *)(a3 + 32) = &unk_1F0DD4218;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  return this;
}

uint64_t TType1Font::VerifyGlyphName(TType1Font *this, uint64_t a2, const char *a3)
{
  if (!*((void *)this + 24)) {
    return 0;
  }
  unsigned int v6 = (*(uint64_t (**)(TType1Font *))(*(void *)this + 168))(this);
  unsigned int v7 = v6 >= 0xFFFF ? 0xFFFF : v6;
  if (v7 <= a2) {
    return 0;
  }
  uint64_t v8 = *(int *)(*((void *)this + 24) + 4 * a2);
  if (v8 == -1) {
    return 0;
  }
  uint64_t v9 = (const char *)(*((void *)this + 6) + v8);
  size_t v10 = *(unsigned __int8 *)v9;
  if (strlen(a3) != v10 || strncmp(a3, v9 + 1, v10)) {
    return 0;
  }
  return a2;
}

void TType1Font::GetMMVR(void *a1@<X8>)
{
  *a1 = &unk_1F0DD4218;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
}

void TType1Font::GetBLND(void *a1@<X8>)
{
  *a1 = &unk_1F0DD4218;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
}

void TType1Font::GetCharString(TType1Font *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (*((_DWORD *)this + 35) <= a2 || (uint64_t v5 = *((void *)this + 13)) == 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  unsigned int v7 = (unsigned int *)(v5 + 8 * a2);
  size_t v8 = v7[1];
  if (v8)
  {
    uint64_t v9 = *(__int16 *)(*((void *)this + 16) + 56);
    uint64_t v10 = *((void *)this + 25);
    if (v10)
    {
      *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)(a3 + 32) = v11;
      *(_OWORD *)(a3 + 48) = v11;
      *(_OWORD *)a3 = v11;
      *(_OWORD *)(a3 + 16) = v11;
      TCharString::TCharString((TCharString *)a3, a2, v8, 0);
      *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v20 = v12;
      long long v21 = v12;
      (*(void (**)(long long *__return_ptr, TType1Font *, void, size_t))(*(void *)this + 48))(&v20, this, *v7, v8);
      if (*((void *)&v20 + 1) && (uint64_t v13 = *(void *)(*((void *)&v20 + 1) + 8)) != 0) {
        unint64_t v14 = (const unsigned __int8 *)(v13 + v21);
      }
      else {
        unint64_t v14 = 0;
      }
      EexecDecrypt(*(unsigned __int8 **)(a3 + 8), v14, (int)v8, *(unsigned int *)(v10 + 4 * a2), *((unsigned __int8 *)this + 208));
      LenIVDecrypt(*(unsigned __int8 **)(a3 + 8), *(unsigned __int8 **)(a3 + 8), v8, v9);
    }
    else if (*(_WORD *)(*((void *)this + 16) + 56))
    {
      *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)(a3 + 32) = v15;
      *(_OWORD *)(a3 + 48) = v15;
      *(_OWORD *)a3 = v15;
      *(_OWORD *)(a3 + 16) = v15;
      TCharString::TCharString((TCharString *)a3, a2, v8 - v9, 0);
      *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v20 = v16;
      long long v21 = v16;
      (*(void (**)(long long *__return_ptr, TType1Font *, void, size_t))(*(void *)this + 48))(&v20, this, *v7, v8);
      if (*((void *)&v20 + 1) && (uint64_t v17 = *(void *)(*((void *)&v20 + 1) + 8)) != 0) {
        int v18 = (unsigned __int8 *)(v17 + v21);
      }
      else {
        int v18 = 0;
      }
      LenIVDecrypt(*(unsigned __int8 **)(a3 + 8), v18, v8, v9);
    }
    else
    {
      (*(void (**)(long long *__return_ptr, TType1Font *, void, void))(*(void *)this + 48))(&v20, this, *v7, v7[1]);
      TCharString::TCharString((TCharString *)a3, a2, (const TDataReference *)&v20);
    }
    TDataReference::~TDataReference((TDataReference *)&v20);
  }
  else
  {
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = &unk_1F0DFF650;
    *(_DWORD *)(a3 + 24) = 0;
    *(unsigned char *)(a3 + 28) = 0;
    *(void *)(a3 + 32) = &unk_1F0DD4218;
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 48) = 0;
    *(void *)(a3 + 56) = 0;
  }
}

void sub_1B530C358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void TCharString::TCharString(TCharString *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1F0DFF650;
  *((_DWORD *)this + 6) = 0;
  *((unsigned char *)this + 28) = 0;
  *((void *)this + 4) = &unk_1F0DD4218;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
}

{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1F0DFF650;
  *((_DWORD *)this + 6) = 0;
  *((unsigned char *)this + 28) = 0;
  *((void *)this + 4) = &unk_1F0DD4218;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
}

BOOL TType1Font::GetType1Encoding(TType1Font *this, unsigned __int16 *a2)
{
  uint64_t v2 = *((void *)this + 28);
  if (v2)
  {
    for (uint64_t i = 0; i != 256; ++i)
    {
      uint64_t v6 = *(int *)(v2 + 4 * i);
      if (v6)
      {
        uint64_t v7 = (*(uint64_t (**)(TType1Font *, uint64_t))(*(void *)this + 352))(this, v6 + *((void *)this + 28) + 1);
        if ((v7 & 0xFF00000000) != 0) {
          a2[i] = v7;
        }
      }
    }
  }
  return v2 != 0;
}

void TType1Font::GetStandardEncoding(TType1Font *this, unsigned __int16 *a2)
{
  uint64_t v4 = 0;
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v44 = v5;
  long long v43 = v5;
  __dst[1] = 0;
  long long v42 = 0;
  __dst[0] = 0;
  long long v45 = (char *)&v43;
  do
  {
    if ((_BYTE)v4)
    {
      StandardEncodeName = (unsigned char *)TParsingContext::GetStandardEncodeName((TParsingContext *)v4);
      if (StandardEncodeName)
      {
        size_t v8 = StandardEncodeName + 1;
        size_t v7 = *StandardEncodeName;
        unint64_t v9 = (unint64_t)v42;
        uint64_t v10 = __dst[0];
        if (v42 - (char *)__dst[0] >= v7)
        {
          long long v11 = __dst[1];
          int64_t v12 = (char *)__dst[1] - (char *)__dst[0];
          if ((char *)__dst[1] - (char *)__dst[0] >= v7)
          {
            if (*StandardEncodeName) {
              memmove(__dst[0], v8, v7);
            }
            unint64_t v14 = &v10[v7];
          }
          else
          {
            if (__dst[1] == __dst[0])
            {
              uint64_t v13 = (char *)__dst[0];
            }
            else
            {
              memmove(__dst[0], v8, (char *)__dst[1] - (char *)__dst[0]);
              uint64_t v13 = (char *)__dst[1];
            }
            int v18 = &v8[v12];
            uint64_t v19 = v13;
            if (&v8[v12] != &v8[v7])
            {
              int64_t v20 = &v10[v7] - v11;
              uint64_t v19 = (char *)(&v10[v7 + (void)v13] - v11);
              long long v21 = v13;
              do
              {
                char v22 = *v18++;
                *v21++ = v22;
                --v20;
              }
              while (v20);
            }
            unint64_t v14 = v19;
          }
        }
        else
        {
          if (__dst[0])
          {
            __dst[1] = __dst[0];
            if (&v43 > __dst[0] || (char *)&v44 + 14 <= __dst[0])
            {
              operator delete(__dst[0]);
            }
            else if (v42 == v45)
            {
              long long v45 = (char *)__dst[0];
            }
            unint64_t v9 = 0;
            __dst[0] = 0;
            __dst[1] = 0;
            long long v42 = 0;
          }
          uint64_t v15 = 2 * v9;
          if (2 * v9 <= v7) {
            uint64_t v15 = v7;
          }
          if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v16 = v15;
          }
          std::vector<char,TInlineBufferAllocator<char,30ul>>::__vallocate[abi:fe180100]((char *)__dst, v16);
          unint64_t v14 = (char *)__dst[1];
          do
          {
            char v17 = *v8++;
            *v14++ = v17;
            --v7;
          }
          while (v7);
        }
        __dst[1] = v14;
        if (v14 >= v42)
        {
          int64_t v24 = v14 - (char *)__dst[0];
          int64_t v25 = v14 - (char *)__dst[0] + 1;
          if (v25 < 0) {
            std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
          }
          unint64_t v26 = v42 - (char *)__dst[0];
          if (2 * (v42 - (char *)__dst[0]) > (unint64_t)v25) {
            int64_t v25 = 2 * v26;
          }
          if (v26 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v27 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v27 = v25;
          }
          long long v40 = &v43;
          if (v27)
          {
            unint64_t v28 = v45;
            if (&v45[v27] <= (char *)&v44 + 14) {
              v45 += v27;
            }
            else {
              unint64_t v28 = operator new(v27);
            }
          }
          else
          {
            unint64_t v28 = 0;
          }
          uint64_t v29 = &v28[v24];
          unint64_t v30 = &v28[v27];
          long long v39 = &v28[v27];
          v28[v24] = 0;
          int v23 = &v28[v24 + 1];
          v38.i64[1] = (uint64_t)v23;
          unint64_t v32 = (char *)__dst[0];
          uint64_t v31 = (char *)__dst[1];
          if (__dst[1] == __dst[0])
          {
            int64x2_t v34 = vdupq_n_s64((unint64_t)__dst[1]);
          }
          else
          {
            do
            {
              char v33 = *--v31;
              *--uint64_t v29 = v33;
            }
            while (v31 != v32);
            int64x2_t v34 = *(int64x2_t *)__dst;
            int v23 = (char *)v38.i64[1];
            unint64_t v30 = v39;
          }
          __dst[0] = v29;
          __dst[1] = v23;
          int64x2_t v38 = v34;
          int v35 = v42;
          long long v42 = v30;
          long long v39 = v35;
          size_t v37 = (void **)v34.i64[0];
          std::__split_buffer<char,TInlineBufferAllocator<char,30ul> &>::~__split_buffer((uint64_t)&v37);
        }
        else
        {
          *unint64_t v14 = 0;
          int v23 = v14 + 1;
        }
        __dst[1] = v23;
        uint64_t v36 = (*(uint64_t (**)(TType1Font *, void *))(*(void *)this + 352))(this, __dst[0]);
        if ((v36 & 0xFF00000000) != 0) {
          a2[v4] = v36;
        }
      }
    }
    ++v4;
  }
  while (v4 != 256);
  size_t v37 = __dst;
  std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:fe180100](&v37);
}

void sub_1B530C7B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14, char a15)
{
  a14 = (void **)&a15;
  std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:fe180100](&a14);
  _Unwind_Resume(a1);
}

void *TType1Font::GetPostScriptNameSuffixForVariation(unsigned __int16 *a1, void *a2, char *a3, void *a4)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (*a2) {
    BOOL v4 = a2[1] == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 0;
  }
  long long v42 = 0;
  long long v43 = 0;
  uint64_t v44 = 0;
  memset(__p, 170, sizeof(__p));
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 400))(__p);
  if (__p[1] != __p[0])
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    unint64_t v11 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    int64_t v12 = a3 + 1;
    if (v11 <= 1) {
      int64_t v13 = 1;
    }
    else {
      int64_t v13 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    }
    uint64_t v14 = a1[74];
    uint64_t v15 = (double *)v42;
    while (1)
    {
      uint64_t v16 = 0;
      if (a1[74]) {
        break;
      }
LABEL_19:
      if (v16 == v14)
      {
LABEL_32:
        *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v49 = v32;
        long long v50 = v32;
        long long v47 = v32;
        long long v48 = v32;
        *(_OWORD *)__source = v32;
        long long v46 = v32;
        if (v11 > v10)
        {
          TFont::GetNameUsingMap((uint64_t)a1, *((_WORD *)__p[0] + 4 * v10 + 1), a4, (TFontNameString *)__source);
          *a3 = 95;
          char v33 = *(unsigned __int8 **)&__source[8];
          if (!*(void *)&__source[8])
          {
            char v33 = (unsigned __int8 *)*((void *)&v47 + 1);
            if (*((void *)&v47 + 1))
            {
              char v33 = *(unsigned __int8 **)(*((void *)&v47 + 1) + 8);
              if (v33) {
                v33 += v48;
              }
            }
          }
          if ((unint64_t)v46 >= 0xFE) {
            uint64_t v34 = 254;
          }
          else {
            uint64_t v34 = v46;
          }
          if (v34)
          {
            int v35 = &v33[v34];
            do
            {
              int v37 = *v33++;
              char v36 = v37;
              if (v37 == 32) {
                char v36 = 95;
              }
              *v12++ = v36;
            }
            while (v33 < v35);
          }
          *int64_t v12 = 0;
          TFontNameString::~TFontNameString((TFontNameString *)__source);
          a4 = (void *)(v34 + 1);
          int v28 = 1;
          goto LABEL_50;
        }
LABEL_57:
        __break(1u);
      }
      ++v10;
      v15 += v14;
      v9 += v14;
      if (v10 == v13) {
        goto LABEL_21;
      }
    }
    char v17 = (double *)(a2[1] + 8);
    while ((v43 - (unsigned char *)v42) >> 3 > (unint64_t)(v9 + v16))
    {
      double v18 = v15[v16];
      double v19 = vabdd_f64(*v17, v18);
      if (v19 >= 0.0001)
      {
        double v20 = fabs(*v17);
        double v21 = fabs(v18);
        if (v20 < v21) {
          double v20 = v21;
        }
        if (v19 / v20 >= 0.0001) {
          goto LABEL_19;
        }
      }
      ++v16;
      v17 += 2;
      if (v14 == v16) {
        goto LABEL_32;
      }
    }
    goto LABEL_57;
  }
LABEL_21:
  *(void *)&long long v22 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v39 = v22;
  long long v40 = v22;
  (*(void (**)(long long *__return_ptr, unsigned __int16 *))(*(void *)a1 + 472))(&v39, a1);
  if (*((void *)&v39 + 1) && (uint64_t v23 = *(void *)(*((void *)&v39 + 1) + 8)) != 0)
  {
    unint64_t v24 = a1[74];
    if (a1[74])
    {
      unint64_t v25 = 0;
      a4 = 0;
      uint64_t v26 = v23 + v40;
      *(void *)&long long v27 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
      int v28 = 1;
      while (1)
      {
        unsigned int v29 = bswap32(*(_DWORD *)(v26 + 8 * v25));
        unint64_t v30 = (double *)(a2[1] + 8);
        while (*((_DWORD *)v30 - 2) != v29)
        {
          v30 += 2;
          if (!--v24) {
            goto LABEL_48;
          }
        }
        if (!v24) {
          break;
        }
        double v31 = *v30 * (double)((int)bswap32(*(unsigned __int16 *)(v26 + 8 * v25 + 6)) >> 16);
        long long v47 = v27;
        long long v48 = v27;
        *(_OWORD *)__source = v27;
        long long v46 = v27;
        snprintf_l(__source, 0x40uLL, 0, "_%d", llround(v31));
        a4 = (void *)((char *)a4 + strlcat(a3, __source, 0x100uLL));
        ++v25;
        unint64_t v24 = a1[74];
        *(void *)&long long v27 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
        if (v25 >= v24) {
          goto LABEL_49;
        }
      }
    }
    else
    {
      a4 = 0;
    }
LABEL_48:
    int v28 = 1;
  }
  else
  {
    int v28 = 0;
  }
LABEL_49:
  TDataReference::~TDataReference((TDataReference *)&v39);
LABEL_50:
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v42)
  {
    long long v43 = v42;
    operator delete(v42);
  }
  if (!v28) {
    return 0;
  }
  return a4;
}

void sub_1B530CB84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a18)
  {
    a19 = (uint64_t)a18;
    operator delete(a18);
  }
  _Unwind_Resume(a1);
}

uint64_t TType1Font::GetCharactersPerGlyphs(TType1Font *this, const unsigned __int16 *a2, unsigned __int16 *a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  if (*((void *)this + 23))
  {
    uint64_t v5 = a4;
    unsigned int v8 = (*(uint64_t (**)(TType1Font *))(*(void *)this + 168))(this);
    if (v8 >= 0xFFFF) {
      unsigned int v9 = 0xFFFF;
    }
    else {
      unsigned int v9 = v8;
    }
    unint64_t v10 = a3;
    while (1)
    {
      uint64_t v11 = *a2;
      if (v11 >= v9) {
        break;
      }
      unsigned int v12 = *(_DWORD *)(*((void *)this + 23) + 4 * v11);
      if ((v12 - 0x10000) >> 20)
      {
        if (HIWORD(v12)) {
          break;
        }
        *unint64_t v10 = v12;
      }
      else
      {
        *unint64_t v10 = (v12 >> 10) - 10304;
        v10[1] = v12 & 0x3FF | 0xDC00;
        ++v10;
      }
LABEL_13:
      ++a2;
      ++v10;
      if (!--v5) {
        return v10 - a3;
      }
    }
    *unint64_t v10 = -1;
    goto LABEL_13;
  }
  return 0;
}

CFMutableCharacterSetRef TType1Font::CopyCharacterSet(TType1Font *this)
{
  unsigned int v2 = (*(uint64_t (**)(TType1Font *))(*(void *)this + 168))(this);
  if (v2 >= 0xFFFF) {
    unint64_t v3 = 0xFFFFLL;
  }
  else {
    unint64_t v3 = v2;
  }
  if (!v3 || !*((void *)this + 23)) {
    return 0;
  }
  CFMutableCharacterSetRef theSet = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  if (!theSet)
  {
    TCFCharacterSet::~TCFCharacterSet((const void **)&theSet);
    return 0;
  }
  uint64_t v4 = 0;
  unsigned int v5 = -1;
  while (v5 == 0xFFFF || v5 == -1)
  {
    unsigned int v5 = *(_DWORD *)(*((void *)this + 23) + 4 * v4++);
    if (v3 == v4)
    {
      unsigned int v7 = v5 + 1;
      goto LABEL_31;
    }
  }
  unsigned int v7 = v5 + 1;
  if (v3 > (unsigned __int16)v4)
  {
    do
    {
      unint64_t v9 = (unsigned __int16)v4;
      while (1)
      {
        unsigned int v10 = *(_DWORD *)(*((void *)this + 23) + 4 * v9);
        if (v10 == -1 || v10 == 0xFFFF) {
          break;
        }
        if (v7 != v10)
        {
          if (HIWORD(v5) <= 0x10u && (v7 - 1) >> 16 <= 0x10)
          {
            v14.int length = v7 - v5;
            v14.unsigned int location = v5;
            CFCharacterSetAddCharactersInRange(theSet, v14);
          }
          unsigned int v7 = v10 + 1;
          unsigned int v5 = v10;
          break;
        }
        ++v9;
        ++v7;
        if (v9 >= v3) {
          goto LABEL_31;
        }
      }
      LOWORD(v4) = v9 + 1;
    }
    while (v3 > (unsigned __int16)(v9 + 1));
  }
LABEL_31:
  if (v5 != -1 && v5 != 0xFFFF && HIWORD(v5) <= 0x10u && (v7 - 1) >> 16 <= 0x10)
  {
    v15.int length = v7 - v5;
    v15.unsigned int location = v5;
    CFCharacterSetAddCharactersInRange(theSet, v15);
  }
  CFMutableCharacterSetRef v8 = theSet;
  CFMutableCharacterSetRef theSet = 0;
  TCFCharacterSet::~TCFCharacterSet((const void **)&theSet);
  return v8;
}

void sub_1B530CE68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TCFCharacterSet::~TCFCharacterSet((const void **)va);
  _Unwind_Resume(a1);
}

void TType1Font::GetOS2UnicodeRanges(TType1Font *this, unsigned int a2, unsigned int *a3, float a4)
{
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
}

uint64_t TType1Font::GetCharactersForGlyph(TType1Font *this, unsigned int a2, unsigned __int16 *a3)
{
  if (a2 > 0xFFFE) {
    return 0;
  }
  uint64_t v8 = v3;
  uint64_t v9 = v4;
  __int16 v7 = a2;
  int v6 = -1431655766;
  if (!a3) {
    a3 = (unsigned __int16 *)&v6;
  }
  return (*(uint64_t (**)(TType1Font *, __int16 *, unsigned __int16 *, uint64_t))(*(void *)this + 160))(this, &v7, a3, 1);
}

void TCharString::TCharString(TCharString *this, int a2, size_t size, const void *a4)
{
  *((void *)this + 1) = a4;
  *((void *)this + 2) = size;
  *(void *)this = &unk_1F0DFF650;
  *((_DWORD *)this + 6) = a2;
  *((void *)this + 4) = &unk_1F0DD4218;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((unsigned char *)this + 28) = a4 == 0;
  if (!a4)
  {
    unsigned int v5 = malloc_type_malloc(size, 0x528EA017uLL);
    *((void *)this + 1) = v5;
    if (!v5)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 2;
    }
  }
}

void sub_1B530CFE0(_Unwind_Exception *a1)
{
  TDataReference::~TDataReference(v1);
  _Unwind_Resume(a1);
}

void TCharString::TCharString(TCharString *this, int a2, const TDataReference *a3)
{
  uint64_t v3 = *((void *)a3 + 1);
  if (v3)
  {
    uint64_t v3 = *(void *)(v3 + 8);
    if (v3) {
      v3 += *((void *)a3 + 2);
    }
  }
  uint64_t v4 = *((void *)a3 + 3) - *((void *)a3 + 2);
  *((void *)this + 1) = v3;
  *((void *)this + 2) = v4;
  *(void *)this = &unk_1F0DFF650;
  *((_DWORD *)this + 6) = a2;
  *((unsigned char *)this + 28) = 0;
  *((void *)this + 4) = &unk_1F0DD4218;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  TDataReference::operator=((TCharString *)((char *)this + 32), (uint64_t)a3);
}

void TCharString::TCharString(TCharString *this, int a2, const TDataReference *a3, uint64_t a4)
{
  uint64_t v4 = *((void *)a3 + 1);
  if (v4)
  {
    uint64_t v4 = *(void *)(v4 + 8);
    if (v4) {
      v4 += *((void *)a3 + 2);
    }
  }
  *((void *)this + 1) = v4;
  *((void *)this + 2) = a4;
  *(void *)this = &unk_1F0DFF650;
  *((_DWORD *)this + 6) = a2;
  *((unsigned char *)this + 28) = 0;
  *((void *)this + 4) = &unk_1F0DD4218;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  TDataReference::operator=((TCharString *)((char *)this + 32), (uint64_t)a3);
}

void TType1DataParsingContext::~TType1DataParsingContext(TType1DataParsingContext *this)
{
  TType1ParsingContext::~TType1ParsingContext(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TType1DataParsingContext::BlendNumberAxes(TType1DataParsingContext *this)
{
  return 0;
}

void **TType1DataParsingContext::CharStringIndex(void **this, int a2, int a3, unsigned int a4, const char *a5)
{
  uint64_t v8 = (uint64_t)this;
  if (a3 | a2 || a4 || a5)
  {
    unsigned int v9 = a4 + 2;
    unsigned int v10 = (char *)reallocf(this[105], *((_DWORD *)this + 212) + a4 + 2);
    *(void *)(v8 + 840) = v10;
    if (!v10)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      *(void *)exception = &unk_1F0DD4440;
      exception[2] = 2;
    }
    uint64_t v11 = *(unsigned int *)(v8 + 848);
    this = (void **)memcpy(&v10[v11], a5, a4);
    unsigned int v12 = (_DWORD *)(*(void *)(v8 + 632) + 8 * a2);
    *unsigned int v12 = v11;
    v12[1] = a4;
    *(_DWORD *)(v8 + 848) = v11 + v9;
  }
  return this;
}

void TType1DataFont::~TType1DataFont(TType1DataFont *this)
{
  *(void *)this = &unk_1F0DFF670;
  *((void *)this + 2) = &unk_1F0DFF888;
  free(*((void **)this + 29));
  TType1Font::~TType1Font(this);
}

unsigned __int8 *TType1DataFont::GetCharString@<X0>(TType1DataFont *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  double result = (unsigned __int8 *)(*(uint64_t (**)(TType1DataFont *))(*(void *)this + 168))(this);
  if (result >= 0xFFFF) {
    unsigned int v7 = 0xFFFF;
  }
  else {
    unsigned int v7 = result;
  }
  if (v7 <= a2 || (uint64_t v8 = *((void *)this + 13)) == 0)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    *(void *)exception = &unk_1F0DD4440;
    exception[2] = 4;
  }
  size_t v9 = *(unsigned int *)(v8 + 8 * a2 + 4);
  if (v9)
  {
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)(a3 + 32) = v10;
    *(_OWORD *)(a3 + 48) = v10;
    *(_OWORD *)a3 = v10;
    *(_OWORD *)(a3 + 16) = v10;
    TCharString::TCharString((TCharString *)a3, a2, v9, 0);
    return LenIVDecrypt(*(unsigned __int8 **)(a3 + 8), (unsigned __int8 *)(*((void *)this + 29) + *(unsigned int *)(v8 + 8 * a2)), v9, *(__int16 *)(*((void *)this + 16) + 56));
  }
  else
  {
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = &unk_1F0DFF650;
    *(_DWORD *)(a3 + 24) = 0;
    *(unsigned char *)(a3 + 28) = 0;
    *(void *)(a3 + 32) = &unk_1F0DD4218;
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 48) = 0;
    *(void *)(a3 + 56) = 0;
  }
  return result;
}

void sub_1B530D4B0(_Unwind_Exception *a1)
{
  TCharString::~TCharString(v1);
  _Unwind_Resume(a1);
}

void TType1MemoryFont::TType1MemoryFont(TType1MemoryFont *this, const void *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 27) = 0;
  *(void *)this = &unk_1F0DD7B98;
  *((void *)this + 2) = &unk_1F0DD7DB0;
  *((void *)this + 30) = &unk_1F0DD4120;
  operator new();
}

void sub_1B530D748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  TType1ParsingContext::~TType1ParsingContext((TType1ParsingContext *)va);
  TInMemoryDataReference::~TInMemoryDataReference(v6);
  TType1DataFont::~TType1DataFont(v5);
  _Unwind_Resume(a1);
}

void TType1MemoryFont::~TType1MemoryFont(TType1MemoryFont *this)
{
  *(void *)this = &unk_1F0DD7B98;
  *((void *)this + 2) = &unk_1F0DD7DB0;
  TInMemoryDataReference::~TInMemoryDataReference((TType1MemoryFont *)((char *)this + 240));
  *(void *)this = &unk_1F0DFF670;
  *((void *)this + 2) = &unk_1F0DFF888;
  free(*((void **)this + 29));
  TType1Font::~TType1Font(this);
}

{
  uint64_t vars8;

  TType1MemoryFont::~TType1MemoryFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TType1MemoryFont::~TType1MemoryFont(TType1MemoryFont *this)
{
}

{
  uint64_t vars8;

  TType1MemoryFont::~TType1MemoryFont((TType1MemoryFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

uint64_t TType1MemoryFont::GetKind(TType1MemoryFont *this)
{
  return 23;
}

uint64_t TType1MemoryFont::GetFontRef(TType1MemoryFont *this)
{
  return (uint64_t)this + 240;
}

void TType1PFBParsingContext::~TType1PFBParsingContext(TType1PFBParsingContext *this)
{
  TType1ParsingContext::~TType1ParsingContext(this);
  JUMPOUT(0x1BA9994D0);
}

uint64_t TType1PFBParsingContext::GetBytes(TType1PFBParsingContext *this, unint64_t *a2)
{
  uint64_t v2 = *((void *)this + 6);
  uint64_t v3 = *((void *)this + 7);
  if (v2)
  {
    uint64_t v4 = *(void *)(v2 + 8);
    if (v4) {
      uint64_t v5 = v4 + v3;
    }
    else {
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = *((int *)this + 18);
  if ((v7 & 0x80000000) == 0)
  {
    unint64_t v8 = v5 + *((void *)this + 8) - v3;
    uint64_t v9 = v5 + v7;
    uint64_t v10 = v9 + 6;
    if (v9 + 6 <= v8)
    {
      unint64_t v11 = *(unsigned int *)(v9 + 2);
      *a2 = v11;
      *((_DWORD *)this + 18) = v7 + v11 + 6;
      BOOL v12 = __CFADD__(v11, v10);
      unint64_t v13 = v11 + v10;
      if (v12)
      {
        return 0;
      }
      else if (v13 > v8)
      {
        return 0;
      }
      else
      {
        return v9 + 6;
      }
    }
  }
  return v6;
}

void TType1BinaryMemoryFont::TType1BinaryMemoryFont(TType1BinaryMemoryFont *this, const void *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 27) = 0;
  *(void *)this = &unk_1F0DFF8A8;
  *((void *)this + 2) = &unk_1F0DFFAC0;
  *((void *)this + 30) = &unk_1F0DD4120;
  operator new();
}

void sub_1B530DBD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  TType1ParsingContext::~TType1ParsingContext((TType1ParsingContext *)va);
  TInMemoryDataReference::~TInMemoryDataReference(v6);
  TType1DataFont::~TType1DataFont(v5);
  _Unwind_Resume(a1);
}

void TType1BinaryMemoryFont::~TType1BinaryMemoryFont(TType1BinaryMemoryFont *this)
{
  *(void *)this = &unk_1F0DFF8A8;
  *((void *)this + 2) = &unk_1F0DFFAC0;
  TInMemoryDataReference::~TInMemoryDataReference((TType1BinaryMemoryFont *)((char *)this + 240));
  *(void *)this = &unk_1F0DFF670;
  *((void *)this + 2) = &unk_1F0DFF888;
  free(*((void **)this + 29));
  TType1Font::~TType1Font(this);
}

{
  uint64_t vars8;

  TType1BinaryMemoryFont::~TType1BinaryMemoryFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TType1BinaryMemoryFont::~TType1BinaryMemoryFont(TType1BinaryMemoryFont *this)
{
}

{
  uint64_t vars8;

  TType1BinaryMemoryFont::~TType1BinaryMemoryFont((TType1BinaryMemoryFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

uint64_t TType1BinaryMemoryFont::GetKind(TType1BinaryMemoryFont *this)
{
  return 23;
}

uint64_t TType1BinaryMemoryFont::GetFontRef(TType1BinaryMemoryFont *this)
{
  return (uint64_t)this + 240;
}

void TType1FileDataFont::TType1FileDataFont(TType1FileDataFont *this, const TFileDataSurrogate *a2)
{
  __b[107] = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 27) = 0;
  *(void *)this = &unk_1F0DD7960;
  *((void *)this + 2) = &unk_1F0DD7B78;
  *((void *)this + 30) = &unk_1F0DD4168;
  uint64_t v3 = *((void *)a2 + 1);
  *((void *)this + 31) = v3;
  (*(void (**)(void))(*(void *)(v3 + 24) + 24))();
  memset(__b, 170, 0x358uLL);
  uint64_t v4 = (*(uint64_t (**)(TType1FileDataFont *))(*(void *)this + 56))(this);
  (*(void (**)(void *__return_ptr))(*(void *)v4 + 32))(v5);
  TParsingContext::TParsingContext((TParsingContext *)__b, (const TDataReference *)v5, 256);
}

void sub_1B530DF8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  TType1ParsingContext::~TType1ParsingContext((TType1ParsingContext *)va);
  TFileDataSurrogate::~TFileDataSurrogate(v6);
  TType1DataFont::~TType1DataFont(v5);
  _Unwind_Resume(a1);
}

void TType1FileDataFont::~TType1FileDataFont(TType1FileDataFont *this)
{
  *(void *)this = &unk_1F0DD7960;
  *((void *)this + 2) = &unk_1F0DD7B78;
  TFileDataSurrogate::~TFileDataSurrogate((const TFileFragmentReference **)this + 30);
  *(void *)this = &unk_1F0DFF670;
  *((void *)this + 2) = &unk_1F0DFF888;
  free(*((void **)this + 29));
  TType1Font::~TType1Font(this);
}

{
  uint64_t vars8;

  TType1FileDataFont::~TType1FileDataFont(this);
  JUMPOUT(0x1BA9994D0);
}

void non-virtual thunk to'TType1FileDataFont::~TType1FileDataFont(TType1FileDataFont *this)
{
}

{
  uint64_t vars8;

  TType1FileDataFont::~TType1FileDataFont((TType1FileDataFont *)((char *)this - 16));
  JUMPOUT(0x1BA9994D0);
}

uint64_t TType1FileDataFont::GetKind(TType1FileDataFont *this)
{
  return 24;
}

uint64_t TType1FileDataFont::GetFontRef(TType1FileDataFont *this)
{
  return (uint64_t)this + 240;
}

uint64_t MType1CIDFont::GetCIDGlyphName@<X0>(MType1CIDFont *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v4 = a2;
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[6] = v6;
    void v9[7] = v6;
    _OWORD v9[4] = v6;
    _DWORD v9[5] = v6;
    _OWORD v9[2] = v6;
    v9[3] = v6;
    v9[0] = v6;
    v9[1] = v6;
    int ROS = MType1CIDFont::GetROS(this);
    if (ROS != 0xFFFF) {
      LODWORD(v4) = (*(uint64_t (**)(MType1CIDFont *, uint64_t))(*(void *)this + 32))(this, v4);
    }
    MakeGlyphNameForCIDPerROS(v4, ROS, (char *)v9, 0x80uLL);
    return TStringRef::TStringRef<128ul>(a3, (char *)v9);
  }
  else
  {
    return TStringRef::TStringRef<8ul>(a3, ".notdef");
  }
}

uint64_t TStringRef::TStringRef<128ul>(uint64_t a1, char *__s1)
{
  uint64_t v4 = strndup(__s1, 0x7FuLL);
  size_t v5 = strnlen(__s1, 0x7FuLL);
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(void *)a1 = &unk_1F0DD43A0;
  *(unsigned char *)(a1 + 24) = 1;
  *(void *)(a1 + 32) = &unk_1F0DD4218;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  return a1;
}

uint64_t MType1CIDFont::GetCID(MType1CIDFont *this, unsigned int a2)
{
  if (*((unsigned __int16 *)this + 8) <= a2) {
    return 0;
  }
  else {
    return (unsigned __int16)a2;
  }
}

uint64_t std::vector<TFontNameString>::__emplace_back_slow_path<unsigned short &,void const*,unsigned long>(uint64_t *a1, __int16 *a2, void *a3, uint64_t *a4)
{
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0x2AAAAAAAAAAAAAALL) {
    std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
  }
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v5) >> 5);
  if (2 * v12 > v7) {
    unint64_t v7 = 2 * v12;
  }
  if (v12 >= 0x155555555555555) {
    unint64_t v13 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v13 = v7;
  }
  void v20[4] = a1 + 2;
  if (v13) {
    CFRange v14 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<TFontNameString>>(v11, v13);
  }
  else {
    CFRange v14 = 0;
  }
  CFRange v15 = &v14[96 * v6];
  v20[0] = v14;
  v20[1] = v15;
  v20[3] = &v14[96 * v13];
  __int16 v16 = *a2;
  uint64_t v17 = *a4;
  *((void *)v15 + 1) = *a3;
  *((void *)v15 + 2) = v17;
  v15[24] = 0;
  *((void *)v15 + 6) = 0;
  *((void *)v15 + 7) = 0;
  *((void *)v15 + 4) = &unk_1F0DD4218;
  *((void *)v15 + 5) = 0;
  v15[64] = 1;
  *(void *)CFRange v15 = &unk_1F0DD4360;
  *((_WORD *)v15 + 33) = v16;
  *((_DWORD *)v15 + 17) = 1;
  *((_WORD *)v15 + 36) = 0;
  *((void *)v15 + 10) = 0;
  *((void *)v15 + 11) = 0;
  v20[2] = v15 + 96;
  std::vector<TFontNameString>::__swap_out_circular_buffer(a1, v20);
  uint64_t v18 = a1[1];
  std::__split_buffer<TFontNameString>::~__split_buffer((uint64_t)v20);
  return v18;
}

void sub_1B530E454(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TFontNameString>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL TFractMatrix::IsIdentity(TFractMatrix *this)
{
  return (*(_DWORD *)this - 1073741) <= 1
      && !*((_DWORD *)this + 1)
      && !*((_DWORD *)this + 2)
      && (*((_DWORD *)this + 3) - 1073741) <= 1
      && !*((_DWORD *)this + 4)
      && *((_DWORD *)this + 5) == 0;
}

char *std::vector<char,TInlineBufferAllocator<char,30ul>>::__vallocate[abi:fe180100](char *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    std::vector<char,TInlineBufferAllocator<char,1024ul>>::__throw_length_error[abi:fe180100]();
  }
  double result = (char *)*((void *)a1 + 7);
  if (&result[__sz] <= a1 + 54) {
    *((void *)a1 + 7) = &result[__sz];
  }
  else {
    double result = (char *)operator new(__sz);
  }
  *(void *)a1 = result;
  *((void *)a1 + 1) = result;
  *((void *)a1 + 2) = &result[__sz];
  return result;
}

uint64_t std::__split_buffer<char,TInlineBufferAllocator<char,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(void *)(a1 + 16) != v2) {
    *(void *)(a1 + 16) = v2;
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v4 = *(void *)(a1 + 32);
    if (v4 <= (unint64_t)v3 && v4 + 30 > (unint64_t)v3)
    {
      if (*(void *)(a1 + 24) == *(void *)(v4 + 32)) {
        *(void *)(v4 + 32) = v3;
      }
    }
    else
    {
      operator delete(v3);
    }
  }
  return a1;
}

void std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = (void **)((char *)v1 + 54);
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[7]) {
        v1[7] = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

TBlendRec *std::unique_ptr<TBlendRec>::reset[abi:fe180100](TBlendRec **a1, TBlendRec *a2)
{
  double result = *a1;
  *a1 = a2;
  if (result)
  {
    TBlendRec::~TBlendRec(result);
    JUMPOUT(0x1BA9994D0);
  }
  return result;
}

void std::__tree<std::__value_type<unsigned int,unsigned short>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned short>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned short>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,unsigned short>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned short>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned short>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned int,unsigned short>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned short>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned short>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t *std::unique_ptr<std::map<unsigned int,unsigned short>>::reset[abi:fe180100](uint64_t *result)
{
  uint64_t v1 = *result;
  *double result = 0;
  if (v1)
  {
    std::__tree<std::__value_type<unsigned int,unsigned short>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned short>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned short>>>::destroy(v1, *(void **)(v1 + 8));
    JUMPOUT(0x1BA9994D0);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<unsigned int,unsigned short>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned short>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned short>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  BOOL v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  double result = std::__tree_balance_after_insert[abi:fe180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:fe180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      BOOL v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), BOOL v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            uint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            uint64_t v9 = (uint64_t **)v2[1];
            uint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              _OWORD v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            _OWORD v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *uint64_t v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *uint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), BOOL v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *BOOL v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}