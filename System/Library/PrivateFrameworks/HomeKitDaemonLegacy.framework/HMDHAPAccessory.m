@interface HMDHAPAccessory
+ (BOOL)supportsSecureCoding;
+ (Class)transactionClass;
+ (double)chipPairingModeActiveDuration;
+ (void)encodeServices:(id)a3 forXPCCoder:(id)a4 metadata:(id)a5;
- (BOOL)_containsSecureCharacteristic;
- (BOOL)_handleCharacteristicError:(id)a3 read:(BOOL)a4 characteristic:(id)a5 didRelayMessage:(id)a6;
- (BOOL)_handleUpdatedServicesForAccessCodes;
- (BOOL)_handleUpdatedServicesForCameraProfiles:(id)a3;
- (BOOL)_handleUpdatedServicesForDiagnosticsManager:(id)a3;
- (BOOL)_handleUpdatedServicesForDoorbellController;
- (BOOL)_handleUpdatedServicesForFirmwareUpdateProfile:(id)a3;
- (BOOL)_handleUpdatedServicesForLightProfiles:(id)a3;
- (BOOL)_handleUpdatedServicesForLowPowerModeProfile;
- (BOOL)_handleUpdatedServicesForMediaProfile:(id)a3;
- (BOOL)_handleUpdatedServicesForNetworkRouterController:(id)a3;
- (BOOL)_handleUpdatedServicesForSiriEndpointProfile:(id)a3;
- (BOOL)_handleUpdatedServicesForWalletKey;
- (BOOL)_handleUpdatedServicesForWiFiManagementController;
- (BOOL)_isRegisteredForNotificationsByForegroundProcess;
- (BOOL)_remotelySetNotificationsEnabled:(BOOL)a3 forCharacteristic:(id)a4 clientIdentifier:(id)a5;
- (BOOL)_resolveAudioAbility:(id)a3;
- (BOOL)_resolveSupportedSiriInputType:(id)a3;
- (BOOL)_serviceSupportsMinimumUserPrivilege:(id)a3;
- (BOOL)_shouldFilterAccessoryProfileForUnentitledClients:(id)a3;
- (BOOL)_shouldTrackAccessoryWithPriority:(BOOL *)a3;
- (BOOL)_supportsMediaAccessControl;
- (BOOL)_updateNetworkRouterControllerUsingRouterService:(id)a3;
- (BOOL)_validateConnectivityInfo:(id)a3;
- (BOOL)_validateCurrentThreadCredentials:(id)a3 metadata:(id)a4;
- (BOOL)_validateIncomingMessage:(id)a3;
- (BOOL)associateControllerKeyWithAccessory:(id)a3 error:(id *)a4;
- (BOOL)bulkSendListenersRequireCharacteristicReadsSync;
- (BOOL)canAcceptBulkSendListeners;
- (BOOL)canAcceptBulkSendListenersSync;
- (BOOL)canProceedWithRequests:(id)a3 suspended:(BOOL *)a4 error:(id *)a5;
- (BOOL)canReturnCachedValueForCharacteristic:(id)a3;
- (BOOL)canWakeBasedOnCharacteristicRequests:(id)a3;
- (BOOL)canWakeUpViaWoL;
- (BOOL)canWakeViaCustomWoBLE;
- (BOOL)custom1WoBLE;
- (BOOL)hardwareSupport;
- (BOOL)hasAnyServiceWithTypes:(id)a3;
- (BOOL)hasBLEServer;
- (BOOL)hasBTLELink;
- (BOOL)hasBattery;
- (BOOL)hasCameraStreamService;
- (BOOL)hasIPLink;
- (BOOL)hasIPServer;
- (BOOL)hasPostedBulletinForAccessCodeOnboarding;
- (BOOL)hasPostedBulletinForWalletKeyOnboarding;
- (BOOL)hasResidentWithFirmwareUpdatesSupport;
- (BOOL)hasSiriEndpointService;
- (BOOL)hasSiriSettingsService;
- (BOOL)hasSmartSpeakerService;
- (BOOL)hasTelevisionService;
- (BOOL)hasThreadServer;
- (BOOL)hasValidCachedValueForCharacteristic:(id)a3 shouldLog:(BOOL)a4;
- (BOOL)hmmtrHasBLEServer:(id)a3;
- (BOOL)hmmtrHasIPServer:(id)a3;
- (BOOL)hmmtrHasThreadServer:(id)a3;
- (BOOL)isAppleAccessory;
- (BOOL)isAssignedHubForSiriEndpoint;
- (BOOL)isAutomaticThirdPartyAccessorySoftwareUpdateEnabled;
- (BOOL)isBLELinkConnected;
- (BOOL)isBLESecureSessionEstablished;
- (BOOL)isCameraRecordingFeatureSupported;
- (BOOL)isCertifiedForSiriEndpoint;
- (BOOL)isClientRegisteredForNotifications;
- (BOOL)isEqual:(id)a3;
- (BOOL)isHMMTRAccessoryServer:(id)a3;
- (BOOL)isIPSecureSessionEstablished;
- (BOOL)isMatterLocalLinkConnectedAndPreferred;
- (BOOL)isNonClientNotificationEnabled;
- (BOOL)isNotificationEnabled;
- (BOOL)isNotificationEnabledForClientIdentifier:(id)a3;
- (BOOL)isPaired;
- (BOOL)isPoweringOn;
- (BOOL)isPrimary;
- (BOOL)isReachableViaBSP;
- (BOOL)isReadingRequiredForBTLEAccessoryCharacteristic:(id)a3 forceReadFWVersion:(BOOL)a4;
- (BOOL)isSecureSessionEstablished;
- (BOOL)isSecuritySessionOpen;
- (BOOL)isSuspended;
- (BOOL)isThreadSecureSessionEstablished;
- (BOOL)isThreadTheCurrentlyActiveTransport;
- (BOOL)keyGenerationInProgress;
- (BOOL)matchesHAPAccessory:(id)a3;
- (BOOL)matchesHAPAccessoryWithServerIdentifier:(id)a3 instanceID:(id)a4;
- (BOOL)matchesHAPAccessoryWithServerIdentifier:(id)a3 linkType:(int64_t *)a4;
- (BOOL)needsAirplayAccess;
- (BOOL)providesHashRouteID;
- (BOOL)requiresThreadRouter;
- (BOOL)residentCanWakeForWOL;
- (BOOL)shouldConfigureTargetController;
- (BOOL)shouldDisconnectOnIdle;
- (BOOL)shouldDiscoverSuspendCapableAccessoryServer:(id)a3;
- (BOOL)shouldEnableDaemonRelaunch;
- (BOOL)shouldSubmitRoutineConfigurationEventForSiriEndpointProfileMetricsDispatcher:(id)a3;
- (BOOL)supportsAccessCode;
- (BOOL)supportsAnnounce;
- (BOOL)supportsAnyInPersonAccess;
- (BOOL)supportsCHIP;
- (BOOL)supportsDiagnosticsTransfer;
- (BOOL)supportsDoorbellChime;
- (BOOL)supportsFirmwareUpdate;
- (BOOL)supportsHAP;
- (BOOL)supportsIdentify;
- (BOOL)supportsMinimumUserPrivilege;
- (BOOL)supportsMultiUser;
- (BOOL)supportsMusicAlarm;
- (BOOL)supportsNetworkProtection;
- (BOOL)supportsPersonalRequests;
- (BOOL)supportsPreferredMediaUser;
- (BOOL)supportsPrimaryUserInfoSubscription;
- (BOOL)supportsSiri;
- (BOOL)supportsSiriEndpoint;
- (BOOL)supportsSiriEndpointOnBoarding;
- (BOOL)supportsSoftwareUpdate;
- (BOOL)supportsTargetController;
- (BOOL)supportsThread;
- (BOOL)supportsThreadCommissioning;
- (BOOL)supportsUnreachablePing;
- (BOOL)supportsUserManagement;
- (BOOL)supportsUserMediaSettings;
- (BOOL)supportsWalletKey;
- (BOOL)supportsWiFiReconfiguration;
- (BOOL)supportsWoL;
- (BOOL)updateAccessoryInformationWithCharacteristicType:(id)a3 serviceType:(id)a4 value:(id)a5 accessoryTransaction:(id)a6;
- (BOOL)updateTransportInformation:(id)a3 localSource:(BOOL)a4;
- (BOOL)wasUpdatedWithServiceType:(id)a3;
- (HAPSocketInfo)socketInfo;
- (HMCameraUserNotificationSettings)cameraProfileNotificationSettings;
- (HMDAccessoryAdvertisement)accessoryAdvertisement;
- (HMDAccessoryDiagnosticsManager)diagnosticsManager;
- (HMDAccessoryFirmwareUpdateProfile)firmwareUpdateProfile;
- (HMDAccessoryMetric)accessoryMetric;
- (HMDAccessorySymptomHandler)symptomsHandler;
- (HMDAnalyticsHAPServiceData)primaryHAPServiceForAnalytics;
- (HMDBulletinBoard)bulletinBoard;
- (HMDCHIPAccessoryStorage)chipStorage;
- (HMDCameraProfileSettingsManager)cameraProfileSettingsManager;
- (HMDDataStreamController)dataStreamController;
- (HMDDoorbellChimeController)doorbellChimeController;
- (HMDHAPAccessory)init;
- (HMDHAPAccessory)initWithCoder:(id)a3;
- (HMDHAPAccessory)initWithHAPMetadata:(id)a3;
- (HMDHAPAccessory)initWithTransaction:(id)a3 home:(id)a4;
- (HMDHAPAccessory)initWithTransaction:(id)a3 home:(id)a4 hapMetadata:(id)a5;
- (HMDHAPMetadata)hapMetadata;
- (HMDLightProfile)lightProfileWithNaturalLighting;
- (HMDLowPowerModeProfile)lpmProfile;
- (HMDMatterAccessoryDiagnosticsManager)matterDiagnosticManager;
- (HMDMediaProfile)mediaProfile;
- (HMDMessageRouter)primaryResidentMessageRouter;
- (HMDNetworkRouterController)networkRouterController;
- (HMDPendingCharacteristic)pendingPowerOn;
- (HMDService)primaryService;
- (HMDSiriEndpointProfile)siriEndpointProfile;
- (HMDSiriEndpointProfileMetricsDispatcher)siriEndpointProfileMetricsDispatcher;
- (HMDTargetControllerManager)targetControllerManager;
- (HMDUser)cachedRemovedUser;
- (HMDWiFiManagementController)wiFiManagementController;
- (HMFConnectivityInfo)connectivityInfo;
- (HMFPairingIdentity)pairingIdentity;
- (HMFTimer)accessoryDiscoveryBackoffTimer;
- (HMFTimer)accessoryKeyRefreshTimer;
- (HMFTimer)sessionRestoreTimer;
- (HMMTRAccessoryServer)accessoryServer;
- (HMMTRAccessoryServer)chipAccessoryServer;
- (HMSupportedAccessoryDiagnostics)supportedDiagnostics;
- (NAFuture)didConfigureCHIPAccessoryServerFuture;
- (NSArray)accessoryDiagnosticEvents;
- (NSArray)attributeDescriptions;
- (NSArray)hapServicesListForAnalytics;
- (NSArray)services;
- (NSArray)targetUUIDs;
- (NSArray)transportInformationInstances;
- (NSData)broadcastKey;
- (NSData)nfcReaderIdentifier;
- (NSData)publicKey;
- (NSData)setupHash;
- (NSDate)keyUpdatedTime;
- (NSDictionary)accessoryDiagnosticCounters;
- (NSDictionary)assistantObject;
- (NSDictionary)bonjourDeviceInfo;
- (NSMutableArray)discoveredServices;
- (NSMutableArray)pendingReads;
- (NSMutableArray)powerOnCompletionRoutines;
- (NSMutableDictionary)accessCodeCache;
- (NSMutableSet)activeSessionRestoreClients;
- (NSNumber)accessoryFlags;
- (NSNumber)backedOffStateNumber;
- (NSNumber)chipNodeId;
- (NSNumber)hapInstanceId;
- (NSNumber)hasOnboardedForNaturalLighting;
- (NSNumber)internalEnhancedAuthConfigNumber;
- (NSNumber)internalEnhancedAuthMethod;
- (NSNumber)internalThreadActive;
- (NSNumber)internalThreadCapabilities;
- (NSNumber)internalThreadStatus;
- (NSNumber)keyUpdatedStateNumber;
- (NSNumber)matterNodeID;
- (NSNumber)matterProductID;
- (NSNumber)matterSoftwareVersionNumber;
- (NSNumber)matterVendorID;
- (NSNumber)matterWEDSupport;
- (NSNumber)needsOnboarding;
- (NSNumber)sleepInterval;
- (NSNumber)supportedLinkLayerTypes;
- (NSNumber)wakingViaCharacteristicWithIID;
- (NSNumber)wiFiTransportCapabilities;
- (NSSet)cameraProfiles;
- (NSSet)identifiersForBridgedAccessories;
- (NSSet)initialServiceTypeUUIDs;
- (NSSet)lightProfiles;
- (NSSet)serviceTypeUUIDs;
- (NSString)matterExtendedMACAddress;
- (NSString)pairingUsername;
- (NSString)serializedIdentifier;
- (NSString)shortDescription;
- (NSString)uniqueIdentifier;
- (NSString)urlString;
- (double)_getDurationAndUpdateCurrentTime:(id)a3 currentTime:(id *)a4;
- (double)eventTimestamp;
- (double)lastLinkChangeSessionCheckTime;
- (double)sessionCheckPeriod;
- (id)_accessoryForHH2MigrationFileName;
- (id)_characteristicsToEnableEvents;
- (id)_createDiagnosticsManager:(id)a3;
- (id)_findThreadControlPointCharacteristicWithError:(id *)a3;
- (id)_initWithCoder:(id)a3;
- (id)_messagesForUpdatedRoom:(id)a3;
- (id)_notificationRegistrationsByClientIDForCharacteristics:(id)a3;
- (id)_prepareMessagePayloadForCharacteristicRemoteWrite:(id)a3;
- (id)_updatedResponseForRemoteResponse:(id)a3;
- (id)_updatedResponseTuplesForRequests:(id)a3 error:(id)a4 source:(unint64_t)a5 suspended:(BOOL)a6;
- (id)accessoryCategoryTypeForSiriEndpointProfileMetricsDispatcher:(id)a3;
- (id)anyIPServer;
- (id)backingStoreObjects:(int64_t)a3;
- (id)backingStoreTransactionWithName:(id)a3;
- (id)bridge;
- (id)cameraProfileNotificationSettingsFromCoder:(id)a3;
- (id)characteristicWithAuthorizationDataMessage:(id)a3;
- (id)characteristicsPassingTest:(id)a3;
- (id)chipHomeDataSourceWithFabricID:(id)a3 home:(id)a4;
- (id)compositeSettingsControllerManagerForSiriEndpointProfileMetricsDispatcher:(id)a3;
- (id)configureService:(id)a3;
- (id)createSiriEndpointProfileMetricsDispatcherWithAccessoryUUID:(id)a3 homeUUID:(id)a4 logEventSubmitter:(id)a5;
- (id)createUpdateServiceTransactionWithServiceUUID:(id)a3;
- (id)currentActiveSessionRestoreClients;
- (id)dataFromAttributeReport:(id)a3;
- (id)dumpSimpleState;
- (id)dumpState;
- (id)eventForwarder;
- (id)eventSourceIdentifier;
- (id)eventStoreReadHandle;
- (id)expectedTransport;
- (id)fabricDataFetcherWithCHIPStorageDelegate:(id)a3 keychainDelegate:(id)a4;
- (id)findCharacteristic:(id)a3;
- (id)findCharacteristic:(id)a3 forService:(id)a4;
- (id)findCharacteristicType:(id)a3 forServiceType:(id)a4;
- (id)findCharacteristicsByType:(id)a3 forServiceType:(id)a4;
- (id)findCharacteristicsByTypes:(id)a3 forServiceType:(id)a4;
- (id)findService:(id)a3;
- (id)findServiceWithServiceType:(id)a3;
- (id)firmwareUpdateManager;
- (id)getBluetoothAddress;
- (id)getConfiguredName;
- (id)getFullError:(id)a3 source:(unint64_t)a4 suspended:(BOOL)a5;
- (id)getHAPAccessoryMatchingInstanceId;
- (id)getOrCreateServiceUpdateTransactionForKey:(id)a3 fromDictionary:(id)a4;
- (id)getPrimaryHAPAccessories;
- (id)getTransportInformationArray;
- (id)hapCharacteristicWriteRequests:(id)a3 hapAccessory:(id)a4 hmdResponses:(id *)a5 mapping:(id *)a6;
- (id)hmdCharacteristicForInstanceId:(id)a3;
- (id)hmdCharacteristicFromHapCharacteristic:(id)a3;
- (id)matchingHAPAccessoryServerIdentifierWithLinkType:(int64_t)a3;
- (id)matchingHAPAccessoryWithLinkType:(int64_t)a3;
- (id)matchingHAPAccessoryWithServerIdentifier:(id)a3;
- (id)matchingHAPAccessoryWithServerIdentifier:(id)a3 instanceID:(id)a4;
- (id)matchingHAPAccessoryWithServerIdentifier:(id)a3 linkType:(int64_t)a4;
- (id)matchingSystemCommissionerPairingForCHIPPairings:(id)a3 amongSystemCommissionerPairings:(id)a4;
- (id)matchingTransportInformation:(id)a3;
- (id)matchingTransportInformationWithServerIdentifier:(id)a3;
- (id)matchingTransportInformationWithServerIdentifier:(id)a3 instanceID:(id)a4 linkType:(int64_t)a5;
- (id)matchingTransportInformationWithServerIdentifier:(id)a3 linkType:(int64_t)a4;
- (id)messageSendPolicy;
- (id)modelObjectWithChangeType:(unint64_t)a3;
- (id)modelObjectWithChangeType:(unint64_t)a3 version:(int64_t)a4;
- (id)name;
- (id)namesOfServicesShowingTilesInHomeApp;
- (id)numberFromAttributeReport:(id)a3;
- (id)preferredHAPAccessoryForOperation:(int64_t)a3 linkType:(int64_t *)a4;
- (id)primaryIPServer;
- (id)profileFieldsForSiriEndpointProfileMetricsDispatcher:(id)a3;
- (id)rootPublicKeysOfHomes:(id)a3 keychainDelegate:(id)a4;
- (id)runtimeState;
- (id)serviceWithSPIClientIdentifier:(id)a3;
- (id)serviceWithUUID:(id)a3;
- (id)settingTopicForKeyPath:(id)a3;
- (id)targetControllerButtonConfiguration;
- (id)transactionWithObjectChangeType:(unint64_t)a3;
- (id)transportReports;
- (id)updateAccessoryFlagsAndNotifyClients:(id)a3;
- (id)valueFromAttribute:(id)a3;
- (id)waitForChipAccessoryServerWithFlow:(id)a3;
- (id)waitForDoorLockClusterObjectWithFlow:(id)a3;
- (int64_t)certificationStatus;
- (int64_t)communicationProtocol;
- (int64_t)computeSiriEndpointCertification;
- (int64_t)linkLayerType;
- (int64_t)linkSpeed;
- (int64_t)reachableTransports;
- (unint64_t)_threadRSSIToLinkQuality:(id)a3;
- (unint64_t)_wifiRSSIToLinkQuality:(id)a3;
- (unint64_t)activationAttempts;
- (unint64_t)enhancedAuthMethod;
- (unint64_t)hash;
- (unint64_t)identityType;
- (unint64_t)lastSessionStatus;
- (unint64_t)numActiveSessionClients;
- (unint64_t)pairingAttempts;
- (unint64_t)siriEndpointCapabilities;
- (unint64_t)supportedTransports;
- (unint64_t)suspendedState;
- (unint64_t)targetControllerTicksPerSecond;
- (unsigned)keyGenerationType;
- (unsigned)metric_threadCapabilities;
- (unsigned)threadCapabilities;
- (unsigned)threadStatus;
- (void)__checkLowBatteryUpdatedNotification:(id)a3;
- (void)__handleCharacteristicsChangedPayload:(id)a3;
- (void)__updateNotifyingCharacteristicStateNumber:(id)a3;
- (void)_addHAPAccessory:(id)a3;
- (void)_addService:(id)a3;
- (void)_autoConfigureTargetController;
- (void)_cancelPowerOn;
- (void)_challengeAccessoryAuthMethod;
- (void)_checkBridgedAccessoryOnConfigured;
- (void)_checkForSiriEndpointServiceChange;
- (void)_checkHAPSessionRestore;
- (void)_checkRegisterForServerNotification;
- (void)_checkResidentDeviceForReachabilityPing;
- (void)_checkSession;
- (void)_checkSessionRestoreOnLinkStateChange;
- (void)_commissionToThreadNetworkWithActivity:(id)a3 pairingEvent:(id)a4 completion:(id)a5;
- (void)_configNumberUpdated;
- (void)_configureTargetControllerWithCompletion:(id)a3;
- (void)_configureWithAccessoryServices:(id)a3 changedCharacteristics:(id *)a4;
- (void)_createDiagnosticManagerForMatterDevice:(id)a3;
- (void)_deregisterAllClientsFromSessionRestore;
- (void)_deregisterFromSessionRestore:(id)a3;
- (void)_destroyDiagnosticsManager;
- (void)_disableNotificationsForBundleID:(id)a3 completionHandler:(id)a4;
- (void)_doPrimaryResidentUpdated;
- (void)_doReachabilityUpdateForServer:(id)a3;
- (void)_enableBroadcastNotifications:(BOOL)a3 hapAccessory:(id)a4 forCharacteristics:(id)a5;
- (void)_enableNotification:(BOOL)a3 forCharacteristics:(id)a4 message:(id)a5 clientIdentifier:(id)a6;
- (void)_encodeWithCoder:(id)a3;
- (void)_evaluateAvailableSoftwareUpdate;
- (void)_evaluateLocalOperation:(int64_t)a3 state:(id)a4 completion:(id)a5;
- (void)_evaluateResidentEnabledFeatures;
- (void)_fetchPairingsAndUpdateTransaction;
- (void)_forceEnableReachabilityPingForPrimaryResident:(id)a3;
- (void)_forceUpdateBTLEKeyGenerationForServer:(id)a3;
- (void)_groupCharacteristicsNotificationWithCharacteristics:(id)a3 enable:(BOOL)a4 activity:(id)a5 clientIdentifier:(id)a6 groupCharacteristicsError:(id *)a7 characteristicsToModifyLocally:(id *)a8 characteristicsToModifyOnResident:(id *)a9 characteristicsToDisableOnResident:(id *)a10 characteristicsErrorsMapFailingToModify:(id *)a11;
- (void)_handleActivateCHIPPairingModeAndCreateSetupPayloadStringMessage:(id)a3;
- (void)_handleActivateCHIPPairingModeMessage:(id)a3;
- (void)_handleAddServiceTransaction:(id)a3 message:(id)a4;
- (void)_handleChangeUpdateSource:(id)a3;
- (void)_handleCharacteristicRead:(id)a3;
- (void)_handleCharacteristicWrite:(id)a3;
- (void)_handleConfigureTargets:(id)a3;
- (void)_handleDiscoveryBackoffTimerFired;
- (void)_handleFetchCHIPPairingsMessage:(id)a3;
- (void)_handleHomeNameChangedNotification:(id)a3;
- (void)_handleHomeUserRemovedNotification:(id)a3;
- (void)_handleKeyRefreshTimerFired;
- (void)_handleMultipleCharacteristicsUpdated:(id)a3 message:(id)a4 completionQueue:(id)a5 completionHandler:(id)a6;
- (void)_handleRemoveCHIPPairingsMessage:(id)a3;
- (void)_handleRemoveStagedSoftwareUpdate:(id)a3;
- (void)_handleRenameService:(id)a3;
- (void)_handleRoomChangedFromOldRoomName:(id)a3;
- (void)_handleServiceRemovedTransaction:(id)a3 message:(id)a4;
- (void)_handleSessionRestoreTimerFired;
- (void)_handleStartUpdate:(id)a3;
- (void)_handleUnreachableAccessoryToPerformOperation:(int64_t)a3 operationBlock:(id)a4 errorBlock:(id)a5;
- (void)_handleUpdateAccessoryConnectionState:(id)a3;
- (void)_handleUpdateAssociatedServiceType:(id)a3;
- (void)_handleUpdateCharacteristicAuthorizationDataMessage:(id)a3;
- (void)_handleUpdateMediaSourceDisplayOrder:(id)a3;
- (void)_handleUpdatedAuthMethod;
- (void)_handleUpdatedName:(id)a3;
- (void)_handleUpdatedServicesForDataStreamController:(id)a3;
- (void)_handleUpdatedServicesForProfilesAndControllers:(BOOL)a3;
- (void)_handleUpdatedServicesForThreadManagementWithActivity:(id)a3;
- (void)_handleValidatePairingAuthMethodMessage:(id)a3;
- (void)_handleWakeSuspendedAccessoryMessage:(id)a3;
- (void)_logServerReachabilityNotification:(BOOL)a3 withDuration:(id)a4 withLinkType:(id)a5;
- (void)_logServerReachabilityNotification:(id)a3;
- (void)_maybeCommissionToThreadNetworkWithActivity:(id)a3 completion:(id)a4;
- (void)_notifyBridgedAccessoryReachabilityChange:(id)a3;
- (void)_notifyCharacteristicNotificationChanges:(id)a3 enableNotification:(BOOL)a4 message:(id)a5 clientIdentifier:(id)a6;
- (void)_notifyClientsOfTargetControlSupportUpdate;
- (void)_notifyClientsWithNotificationChangesForCharacteristics:(id)a3 characteristicErrors:(id)a4 enableNotification:(BOOL)a5 message:(id)a6;
- (void)_parseResponseFromRemotePeer:(id)a3 message:(id)a4 error:(id)a5 characteristic:(id)a6;
- (void)_performOperation:(int64_t)a3 linkType:(int64_t)a4 operationBlock:(id)a5 errorBlock:(id)a6;
- (void)_postUpdateEventsIfDifferent:(id)a3;
- (void)_readCharacteristicValues:(id)a3 hapAccessory:(id)a4 source:(unint64_t)a5 message:(id)a6 logEvent:(id)a7 completionHandler:(id)a8;
- (void)_readCharacteristicValues:(id)a3 localOperationRequired:(BOOL)a4 source:(unint64_t)a5 message:(id)a6 logEvent:(id)a7 completionHandler:(id)a8 errorBlock:(id)a9;
- (void)_readValueForCharacteristic:(id)a3 hapAccessory:(id)a4 requestMessage:(id)a5;
- (void)_reconcileAccessControlSetting;
- (void)_reenableNotificationsOnWatch;
- (void)_registerForMessages;
- (void)_registerForMessages_lowPowerMode;
- (void)_registerForSessionRestore:(id)a3;
- (void)_relayReadFromCharacteristic:(id)a3 toResidentForMessage:(id)a4 viaDevice:(id)a5;
- (void)_relayWriteToCharacteristic:(id)a3 toResidentForMessage:(id)a4 viaDevice:(id)a5;
- (void)_removeBackedoffAccessoryForStateNumber:(id)a3;
- (void)_removeService:(id)a3;
- (void)_removeSystemCommissionerPairingFromAccessoryPairings:(id)a3 completion:(id)a4;
- (void)_renameAccessory:(id)a3 resetName:(BOOL)a4 message:(id)a5;
- (void)_renameService:(id)a3 name:(id)a4 message:(id)a5 completionBlock:(id)a6;
- (void)_retrieveHAPAccessoryToPerformOperation:(int64_t)a3 linkType:(int64_t)a4 operationBlock:(id)a5 errorBlock:(id)a6 activity:(id)a7;
- (void)_retrieveHAPAccessoryToPerformOperation:(int64_t)a3 linkType:(int64_t)a4 retries:(unint64_t)a5 operationBlock:(id)a6 errorBlock:(id)a7 activity:(id)a8;
- (void)_saveHardwareSupport:(BOOL)a3;
- (void)_saveTargetUUIDs:(id)a3;
- (void)_setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 clientIdentifier:(id)a5 matchingHAPAccessory:(id)a6;
- (void)_setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 hapAccessory:(id)a5 activity:(id)a6 completion:(id)a7;
- (void)_setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 notificationChangeThresholds:(id)a5 clientIdentifier:(id)a6 matchingHAPAccessory:(id)a7;
- (void)_setTargetControllerSession;
- (void)_startManualUpdateFromBestSuitableDevice:(id)a3;
- (void)_startSessionMonitor;
- (void)_startUpdateFromCurrentDeviceWithRequest:(id)a3;
- (void)_startUpdateSessionWithRequest:(id)a3;
- (void)_stopScan;
- (void)_stopSessionMonitor;
- (void)_submitReachabilityDelayedMetric:(id)a3;
- (void)_submitStateNumberChangeMetric;
- (void)_updateAccessoryTracking;
- (void)_updateAuthMethodWithServer:(id)a3 completion:(id)a4;
- (void)_updateBroadcastKey:(id)a3 keyUpdatedStateNumber:(id)a4 keyUpdatedTime:(double)a5;
- (void)_updateCHIPAccessoryWithFabricLabel:(id)a3 completionHandler:(id)a4;
- (void)_updatePrimaryServiceIfNeededWithService:(id)a3;
- (void)_updateReachability;
- (void)_updateReachabilityMetric:(BOOL)a3 withDuration:(id)a4;
- (void)_updateSessionRestoreOnServer:(BOOL)a3;
- (void)_updateSiriAudioFormat:(id)a3;
- (void)_updateStateForTrackedAccessory:(id)a3 stateNumber:(id)a4;
- (void)_wakeAccessoryIfNeededForCharacteristicRequests:(id)a3 source:(unint64_t)a4 activity:(id)a5 completion:(id)a6;
- (void)_wakeSuspendedHAPAccessoryToPerformOperation:(int64_t)a3 linkType:(int64_t)a4 operationBlock:(id)a5 errorBlock:(id)a6 activity:(id)a7;
- (void)_wirelessPowerOn:(id)a3;
- (void)_wol_ignoreWakingViaCharacteristicUpdateFromChangedService:(id)a3;
- (void)_wol_processDidRemoveHPAccessoryServer:(id)a3;
- (void)_wol_processReadWriteResponseForCharacteristic:(id)a3 isRead:(BOOL)a4 error:(id)a5;
- (void)_wol_runAccessoryTransaction:(id)a3 localOnly:(BOOL)a4;
- (void)_wol_updateSuspendCapableHAPAccessoryServer:(id)a3;
- (void)_wol_updateWakingViaCharacteristicForWriteRequests:(id)a3;
- (void)_wol_updateWakingViaCharacteristicForWriteResponses:(id)a3;
- (void)_writeCharacteristicValues:(id)a3 hapAccessory:(id)a4 source:(unint64_t)a5 message:(id)a6 logEvent:(id)a7 completionHandler:(id)a8;
- (void)_writeCharacteristicValues:(id)a3 localOperationRequired:(BOOL)a4 source:(unint64_t)a5 completionHandler:(id)a6 errorBlock:(id)a7;
- (void)_writeCharacteristicValues:(id)a3 localOperationRequired:(BOOL)a4 source:(unint64_t)a5 message:(id)a6 completionHandler:(id)a7 logEvent:(id)a8 errorBlock:(id)a9;
- (void)_writeCredentialsForThreadNetworkWithActivity:(id)a3 pairingEvent:(id)a4 metadata:(id)a5 threadControlPointCharacteristic:(id)a6 completion:(id)a7;
- (void)_writeThreadControlPointCharacteristic:(id)a3 value:(id)a4 activity:(id)a5 completion:(id)a6;
- (void)_writeValue:(id)a3 forCharacteristic:(id)a4 hapAccessory:(id)a5 authorizationData:(id)a6 message:(id)a7;
- (void)accessory:(id)a3 didUpdateReachabilityState:(BOOL)a4;
- (void)acknowledgeTargetControlService:(id)a3 active:(BOOL)a4;
- (void)addAdvertisement:(id)a3;
- (void)addDataStreamBulkSendListener:(id)a3 fileType:(id)a4;
- (void)addHostedAccessory:(id)a3;
- (void)addSession:(int64_t)a3;
- (void)addTarget:(id)a3 buttonConfiguration:(id)a4;
- (void)addTransportInformationInstance:(id)a3;
- (void)addUser:(id)a3 completionHandler:(id)a4;
- (void)assignBonjourDeviceInfo:(id)a3 socketInfo:(id)a4;
- (void)associateWithAccessoryAdvertisement:(id)a3;
- (void)autoConfigureTargetController;
- (void)autoUpdateCachedCountDownCharacteristics:(id)a3;
- (void)backOffAccessoryForStateNumber:(id)a3 backoffPeriod:(double)a4;
- (void)cancelPowerOn;
- (void)checkHAPSessionRestore;
- (void)cleanupNotificationCenterObservers;
- (void)commissionToThreadNetworkWithPairingEvent:(id)a3 completion:(id)a4;
- (void)configureBulletinNotification;
- (void)configureCHIPAccessory;
- (void)configureSiriEndpointProfileMetricsDispatcherWithFactory:(id)a3 logEventSubmitter:(id)a4 dailyScheduler:(id)a5;
- (void)configureTargetControllerWithCompletion:(id)a3;
- (void)configureWithAccessory:(id)a3 homeNotificationsEnabled:(BOOL)a4 queue:(id)a5 completion:(id)a6;
- (void)configureWithHome:(id)a3 msgDispatcher:(id)a4 configurationTracker:(id)a5 initialConfiguration:(BOOL)a6;
- (void)deregisterFromSessionRestore:(id)a3;
- (void)didUpdateConnectionState:(BOOL)a3 linkLayerType:(int64_t)a4 withError:(id)a5;
- (void)didUpdateConnectionState:(BOOL)a3 sessionInfo:(id)a4 linkLayerType:(int64_t)a5 bookkeeping:(id)a6 withError:(id)a7;
- (void)didUpdatePairingsForAccessoryServer:(id)a3;
- (void)didUpdateRequiresThreadRouterForAccessoryServer:(id)a3;
- (void)disableNotificationsForBundleID:(id)a3 completionHandler:(id)a4;
- (void)enableNotification:(BOOL)a3 forCharacteristicIDs:(id)a4 message:(id)a5 clientIdentifier:(id)a6;
- (void)enableNotification:(BOOL)a3 forCharacteristics:(id)a4 message:(id)a5 clientIdentifier:(id)a6;
- (void)enableNotificationsWithHAPAccessory:(id)a3 homeNotificationsEnabled:(BOOL)a4;
- (void)encodeCameraProfileNotificationSettingsWithCoder:(id)a3;
- (void)encodeWithCoder:(id)a3;
- (void)establishLocalHAPConnectionWithQueue:(id)a3 completion:(id)a4;
- (void)getLinkQualityForAccessory:(id)a3 forMessage:(id)a4;
- (void)getSupportedSiriAudioConfiguration:(id)a3;
- (void)handleAccessoryConfigured:(id)a3;
- (void)handleActivateCHIPPairingModeAndCreateSetupPayloadStringMessage:(id)a3;
- (void)handleActivateCHIPPairingModeMessage:(id)a3;
- (void)handleCHIPSendRemoteRequestMessage:(id)a3;
- (void)handleCHIPSendRemoteRequestMessage:(id)a3 chipAccessoryServer:(id)a4;
- (void)handleCharacteristicsChangedNotification:(id)a3;
- (void)handleClearCredentialMessage:(id)a3;
- (void)handleClearUserMessage:(id)a3;
- (void)handleFetchCHIPPairingsMessage:(id)a3;
- (void)handleGetAccessoryDiagnosticCountersMessage:(id)a3;
- (void)handleGetAccessoryDiagnosticEventsMessage:(id)a3;
- (void)handleGetAllUsersMessage:(id)a3;
- (void)handleGetStartUpColorTemperature:(id)a3;
- (void)handleHomeUserRemovedNotification:(id)a3;
- (void)handleIdentifyAccessoryMessage:(id)a3;
- (void)handleLinkQualityRequestMessage:(id)a3;
- (void)handleMultipleCharacteristicsUpdated:(id)a3 message:(id)a4 completionQueue:(id)a5 completionHandler:(id)a6;
- (void)handlePairedStateChange:(BOOL)a3;
- (void)handlePrimaryResidentUpdateNotification:(id)a3;
- (void)handleRemoteGatewayNotificationRegistration:(id)a3 enable:(BOOL)a4 enableTime:(id)a5;
- (void)handleRemoveCHIPPairingsMessage:(id)a3;
- (void)handleRemoveCorrespondingSystemCommissionerMessage:(id)a3;
- (void)handleResidentDeviceUpdated:(id)a3;
- (void)handleRoomChanged:(id)a3;
- (void)handleRoomNameChanged:(id)a3;
- (void)handleSetHasOnboardedForNaturalLighting:(id)a3;
- (void)handleSetStartUpColorTemperature:(id)a3;
- (void)handleUpdatePreferredMediaUser:(id)a3;
- (void)handleUpdatedAuthMethod;
- (void)handleUpdatedCHIPPropertiesOnAccessoryModel:(id)a3 actions:(id)a4;
- (void)handleUpdatedMinimumUserPrivilege:(int64_t)a3;
- (void)handleUpdatedPairings:(id)a3 previousPairings:(id)a4;
- (void)handleUpdatedPassword:(id)a3;
- (void)handleUpdatedServicesForThreadManagementWithCompletion:(id)a3;
- (void)indicateNotificationFromServer:(id)a3 notifyType:(unint64_t)a4 withDictionary:(id)a5;
- (void)initializeBTLEScan;
- (void)initiateScan:(id)a3;
- (void)makeServiceNameConsistent:(id)a3 withName:(id)a4 completionHandler:(id)a5;
- (void)maybeCommissionToThreadNetworkWithCompletion:(id)a3;
- (void)notifyClientsOfTargetControlSupportUpdate;
- (void)notifyClientsOfUpdatedAccessoryControllableValue;
- (void)notifyValue:(id)a3 previousValue:(id)a4 error:(id)a5 forCharacteristic:(id)a6 requestMessage:(id)a7;
- (void)notifyingCharacteristicStateNumberUpdated:(id)a3;
- (void)openBulkSendSessionForFileType:(id)a3 reason:(id)a4 metadata:(id)a5 queue:(id)a6 callback:(id)a7;
- (void)pairingsWithCompletionHandler:(id)a3;
- (void)performOperation:(int64_t)a3 linkType:(int64_t)a4 operationBlock:(id)a5 errorBlock:(id)a6;
- (void)populateHMDCharacteristicResponses:(id)a3 hapResponses:(id)a4 mapping:(id)a5 overallError:(id)a6 requests:(id)a7;
- (void)populateModelObject:(id)a3 version:(int64_t)a4;
- (void)postUpdateEventsIfDifferentWithPreferredMediaUUID:(id)a3 selectionType:(unint64_t)a4;
- (void)powerOnComplete:(id)a3;
- (void)profile:(id)a3 didUpdateAccessoryState:(unint64_t)a4;
- (void)profile:(id)a3 didUpdateWoWLANInfos:(id)a4;
- (void)reachabilityDidChangeToReachable:(id)a3;
- (void)reachabilityDidChangeToUnreachable:(id)a3;
- (void)readCharacteristicValues:(id)a3 source:(unint64_t)a4 message:(id)a5 queue:(id)a6 logEvent:(id)a7 completionHandler:(id)a8;
- (void)readCharacteristicValues:(id)a3 source:(unint64_t)a4 queue:(id)a5 completionHandler:(id)a6;
- (void)readInitialRequiredCharacteristicsForAccessory:(id)a3;
- (void)registerForActiveIdentifierNotifications;
- (void)registerForSessionRestore:(id)a3;
- (void)removeAdvertisement:(id)a3;
- (void)removeAllCHIPPairingsWithCompletion:(id)a3;
- (void)removeDataStreamBulkSendListener:(id)a3;
- (void)removeHostedAccessory:(id)a3;
- (void)removeSession:(int64_t)a3;
- (void)removeTarget:(id)a3;
- (void)removeTransportInformationInstance:(id)a3;
- (void)removeUser:(id)a3 completionHandler:(id)a4;
- (void)requestResource:(id)a3 queue:(id)a4 completionHandler:(id)a5;
- (void)resetAccessoryDiagnosticCounters;
- (void)resetNotificationEnabledTime;
- (void)respondToFetchCHIPPairingsMessage:(id)a3 pairings:(id)a4 systemCommissionerPairings:(id)a5 fetchError:(id)a6;
- (void)routeUpdatePreferredMediaUser:(id)a3;
- (void)runTransactionWithPreferredMediaUserUUID:(id)a3 selectionType:(unint64_t)a4 completion:(id)a5;
- (void)saveBluetoothAddress:(id)a3;
- (void)saveCharacteristicsToLocalDiskForHH2Migration;
- (void)saveHardwareSupport:(BOOL)a3;
- (void)savePublicKeyToKeychain;
- (void)saveTargetUUIDs:(id)a3;
- (void)scanningCompleteWithAccessoryFound:(BOOL)a3 suspended:(BOOL)a4;
- (void)sendTargetControlWhoAmIWithIdentifier:(unsigned int)a3;
- (void)setAccessCodeCache:(id)a3;
- (void)setAccessoryAdvertisement:(id)a3;
- (void)setAccessoryDiscoveryBackoffTimer:(id)a3;
- (void)setAccessoryFlags:(id)a3;
- (void)setAccessoryKeyRefreshTimer:(id)a3;
- (void)setAccessoryMetric:(id)a3;
- (void)setAccessoryServer:(id)a3;
- (void)setActivationAttempts:(unint64_t)a3;
- (void)setBackedOffStateNumber:(id)a3;
- (void)setBroadcastKey:(id)a3;
- (void)setBroadcastKey:(id)a3 keyUpdatedStateNumber:(id)a4 keyUpdatedTime:(id)a5;
- (void)setBulletinBoard:(id)a3;
- (void)setCHIPReportHandler:(id)a3;
- (void)setCachedRemovedUser:(id)a3;
- (void)setCameraProfileNotificationSettings:(id)a3;
- (void)setCertificationStatus:(int64_t)a3;
- (void)setChipStorage:(id)a3;
- (void)setCommunicationProtocol:(int64_t)a3;
- (void)setCommunicationProtocolIfNeeded;
- (void)setConnectivityInfo:(id)a3;
- (void)setDataStreamController:(id)a3;
- (void)setDefaultPreferredMediaUser;
- (void)setDefaultPreferredMediaUserIfNeeded;
- (void)setDiagnosticsManager:(id)a3;
- (void)setDidConfigureCHIPAccessoryServer;
- (void)setDiscoveredServices:(id)a3;
- (void)setDoorbellChimeController:(id)a3;
- (void)setFirmwareUpdateProfile:(id)a3;
- (void)setHardwareSupport:(BOOL)a3;
- (void)setHasOnboardedForNaturalLighting:(id)a3;
- (void)setHasPostedBulletinForAccessCodeOnboarding:(BOOL)a3;
- (void)setHasPostedBulletinForWalletKeyOnboarding:(BOOL)a3;
- (void)setHasSiriEndpointService:(BOOL)a3;
- (void)setIdentifiersForBridgedAccessories:(id)a3;
- (void)setInitialServiceTypeUUIDs:(id)a3;
- (void)setInternalEnhancedAuthMethod:(id)a3 configNumber:(unint64_t)a4;
- (void)setInternalThreadActive:(id)a3;
- (void)setInternalThreadCapabilities:(id)a3;
- (void)setInternalThreadStatus:(id)a3;
- (void)setKeyGenerationInProgress:(BOOL)a3;
- (void)setKeyGenerationType:(unsigned __int8)a3;
- (void)setKeyUpdatedStateNumber:(id)a3;
- (void)setKeyUpdatedTime:(id)a3;
- (void)setLastLinkChangeSessionCheckTime:(double)a3;
- (void)setLastSessionStatus:(unint64_t)a3;
- (void)setMatterDiagnosticManager:(id)a3;
- (void)setMatterExtendedMACAddress:(id)a3;
- (void)setMatterNodeID:(id)a3;
- (void)setMatterProductID:(id)a3;
- (void)setMatterSoftwareVersionNumber:(id)a3;
- (void)setMatterVendorID:(id)a3;
- (void)setMatterWEDSupport:(id)a3;
- (void)setNeedsOnboarding:(id)a3;
- (void)setNetworkRouterController:(id)a3;
- (void)setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 clientIdentifier:(id)a5;
- (void)setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 notificationChangeThresholds:(id)a5 clientIdentifier:(id)a6;
- (void)setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 notificationChangeThresholds:(id)a5 clientIdentifier:(id)a6 matchingHAPAccessory:(id)a7;
- (void)setPairingAttempts:(unint64_t)a3;
- (void)setPairingUsername:(id)a3;
- (void)setPairingUsername:(id)a3 publicKey:(id)a4;
- (void)setPendingPowerOn:(id)a3;
- (void)setPendingReads:(id)a3;
- (void)setPowerOnCompletionRoutines:(id)a3;
- (void)setPublicKey:(id)a3;
- (void)setReachability:(BOOL)a3 serverIdentifier:(id)a4 linkType:(int64_t)a5;
- (void)setReachableViaBSP:(BOOL)a3;
- (void)setRequiresThreadRouter:(BOOL)a3;
- (void)setSelectedSiriAudioConfiguration:(id)a3;
- (void)setSessionRestoreTimer:(id)a3;
- (void)setSetupHash:(id)a3;
- (void)setShouldDisconnectOnIdle:(BOOL)a3;
- (void)setSiriEndpointCapabilities:(unint64_t)a3;
- (void)setSiriEndpointProfileMetricsDispatcher:(id)a3;
- (void)setSleepInterval:(id)a3;
- (void)setSupportedLinkLayerTypes:(id)a3;
- (void)setSupportsAccessCode:(BOOL)a3;
- (void)setSupportsWalletKey:(BOOL)a3;
- (void)setSuspendedState:(unint64_t)a3;
- (void)setSuspendedState:(unint64_t)a3 shouldNotify:(BOOL)a4;
- (void)setSymptomsHandler:(id)a3;
- (void)setTargetControllerManager:(id)a3;
- (void)setTargetUUIDs:(id)a3;
- (void)setUniqueIdentifier:(id)a3;
- (void)setWakingViaCharacteristicWithIID:(id)a3;
- (void)setWiFiManagementController:(id)a3;
- (void)setWiFiTransportCapabilities:(id)a3;
- (void)startPing;
- (void)startReachabilityCheck;
- (void)stopPing;
- (void)stopScan;
- (void)submitCharacteristicReadErrorLogEvent:(id)a3 message:(id)a4 error:(id)a5;
- (void)submitCharacteristicWriteErrorLogEvent:(id)a3 startTime:(double)a4 message:(id)a5 error:(id)a6;
- (void)testSetInternalEnhancedAuthConfigNumber:(id)a3;
- (void)testSetInternalEnhancedAuthMethod:(id)a3;
- (void)timerDidFire:(id)a3;
- (void)transactionObjectRemoved:(id)a3 message:(id)a4;
- (void)transactionObjectUpdated:(id)a3 newValues:(id)a4 message:(id)a5;
- (void)unconfigure;
- (void)unconfigureAccessoryWithServerIdentifier:(id)a3 linkType:(int64_t)a4 updateReachability:(BOOL)a5;
- (void)unconfigureWithCompletion:(id)a3;
- (void)unregisterFromAccessoryServer;
- (void)updateAccessoryFlags:(id)a3;
- (void)updateActiveDisconnectOnIdleTimeout:(double)a3;
- (void)updateBridgedAccessoryLightProfilesSettings;
- (void)updateButtonConfigurationForTarget:(id)a3;
- (void)updateCHIPAccessoryName:(id)a3;
- (void)updateCameraProfileNotificationSettings:(id)a3;
- (void)updateHasPostedBulletinForWalletKeyOnboarding:(BOOL)a3;
- (void)updateLightProfilesSettings;
- (void)updateNotificationEnabled:(BOOL)a3 forCharacteristics:(id)a4 onBehalfOf:(id)a5;
- (void)updatePrimaryServiceIfNeeded;
- (void)updateSuspendedStateWithConnectionState:(BOOL)a3 hapAccessory:(id)a4;
- (void)updateSuspendedStateWithWakeNumber:(id)a3 hapAccessory:(id)a4;
- (void)updateSymptoms;
- (void)updateTarget:(id)a3 name:(id)a4 buttonConfiguration:(id)a5;
- (void)updateTargetUUIDs:(id)a3;
- (void)updateTrackedAccessoryStateNumber:(id)a3;
- (void)verifyPairingWithCompletionHandler:(id)a3;
- (void)wakeOrScanForSuspendedAccessoryForRequests:(id)a3 source:(unint64_t)a4 completion:(id)a5;
- (void)wirelessPowerOn:(id)a3;
- (void)wirelessResumeInit;
- (void)writeCharacteristicValues:(id)a3 source:(unint64_t)a4 message:(id)a5 queue:(id)a6 completionHandler:(id)a7;
- (void)writeCharacteristicValues:(id)a3 source:(unint64_t)a4 message:(id)a5 queue:(id)a6 logEvent:(id)a7 completionHandler:(id)a8;
- (void)writeCharacteristicValues:(id)a3 source:(unint64_t)a4 queue:(id)a5 completionHandler:(id)a6;
- (void)writeValue:(id)a3 toCharacteristic:(id)a4 queue:(id)a5 completion:(id)a6;
@end

@implementation HMDHAPAccessory

+ (BOOL)supportsSecureCoding
{
  return 1;
}

- (id)findServiceWithServiceType:(id)a3
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  v5 = [(HMDHAPAccessory *)self services];
  id v6 = (id)[v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v14;
    while (2)
    {
      for (i = 0; i != v6; i = (char *)i + 1)
      {
        if (*(void *)v14 != v7) {
          objc_enumerationMutation(v5);
        }
        v9 = *(void **)(*((void *)&v13 + 1) + 8 * i);
        v10 = [v9 serviceType];
        char v11 = [v10 isEqualToString:v4];

        if (v11)
        {
          id v6 = v9;
          goto LABEL_11;
        }
      }
      id v6 = (id)[v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
LABEL_11:

  return v6;
}

- (NSArray)services
{
  os_unfair_recursive_lock_lock_with_options();
  v3 = (void *)[(NSMutableArray *)self->_services copy];
  os_unfair_recursive_lock_unlock();
  return (NSArray *)v3;
}

- (BOOL)updateAccessoryInformationWithCharacteristicType:(id)a3 serviceType:(id)a4 value:(id)a5 accessoryTransaction:(id)a6
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = a6;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    long long v14 = v12;
  }
  else {
    long long v14 = 0;
  }
  id v15 = v14;
  id v16 = v12;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    v17 = v16;
  }
  else {
    v17 = 0;
  }
  id v18 = v17;

  if (([v11 isEqualToString:*MEMORY[0x1E4F2DDB8]] & 1) == 0
    && ![v11 isEqualToString:*MEMORY[0x1E4F5BA50]])
  {
    if ([v11 isEqualToString:@"00000239-0000-1000-8000-0026BB765291"])
    {
      BOOL v31 = 0;
      if (![v10 isEqualToString:@"0000023A-0000-1000-8000-0026BB765291"] || !v15) {
        goto LABEL_60;
      }
      v32 = [(HMDHAPAccessory *)self sleepInterval];
      char v33 = HMFEqualObjects();

      if ((v33 & 1) == 0)
      {
        [v13 setSleepInterval:v15];
LABEL_36:
        BOOL v31 = 1;
        goto LABEL_60;
      }
    }
LABEL_59:
    BOOL v31 = 0;
    goto LABEL_60;
  }
  if ([v10 isEqualToString:*MEMORY[0x1E4F2CF48]])
  {
    if (!v18) {
      goto LABEL_59;
    }
    v19 = [(HMDAccessory *)self providedName];
    char v20 = HMFEqualObjects();

    if (v20) {
      goto LABEL_59;
    }
    if ([(HMDHAPAccessory *)self supportsCHIP])
    {
      v21 = [(HMDAccessory *)self home];
      int v22 = [v21 isCurrentDevicePrimaryResident];

      if (v22)
      {
        v23 = (void *)MEMORY[0x1D9452090]();
        v24 = self;
        v25 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
        {
          v48 = HMFGetLogIdentifier();
          [(HMDAccessory *)v24 providedName];
          v26 = v49 = v23;
          [(HMDAccessory *)v24 providedName];
          *(_DWORD *)buf = 138544130;
          v51 = v48;
          __int16 v52 = 2112;
          v53 = v26;
          __int16 v54 = 2112;
          id v55 = v18;
          v57 = __int16 v56 = 2112;
          v27 = (void *)v57;
          _os_log_impl(&dword_1D49D5000, v25, OS_LOG_TYPE_INFO, "%{public}@Primary resident should not change matter accessory name from %@ to %@. Updating matter accessory name back to %@", buf, 0x2Au);

          v23 = v49;
        }

        v28 = [(HMDAccessory *)v24 providedName];
        [(HMDHAPAccessory *)v24 updateCHIPAccessoryName:v28];
        goto LABEL_58;
      }
    }
    [v13 setProvidedName:v18];
    goto LABEL_36;
  }
  if ([v10 isEqualToString:*MEMORY[0x1E4F2CF30]])
  {
    if (!v18) {
      goto LABEL_59;
    }
    v29 = [(HMDAccessory *)self model];
    char v30 = HMFEqualObjects();

    if (v30) {
      goto LABEL_59;
    }
    [v13 setModel:v18];
    goto LABEL_36;
  }
  if ([v10 isEqualToString:*MEMORY[0x1E4F2CF28]])
  {
    if (!v18) {
      goto LABEL_59;
    }
    v34 = [(HMDAccessory *)self manufacturer];
    char v35 = HMFEqualObjects();

    if (v35) {
      goto LABEL_59;
    }
    [v13 setManufacturer:v18];
    goto LABEL_36;
  }
  if ([v10 isEqualToString:*MEMORY[0x1E4F2CEF0]])
  {
    if ([(HMDHAPAccessory *)self supportsCHIP])
    {
      if (!v18) {
        goto LABEL_59;
      }
      v36 = [(HMDAccessory *)self displayableFirmwareVersion];
      char v37 = HMFEqualObjects();

      if (v37) {
        goto LABEL_59;
      }
      [v13 setDisplayableFirmwareVersion:v18];
      goto LABEL_36;
    }
    if (v18)
    {
      v28 = [[HMDAccessoryVersion alloc] initWithVersionString:v18];
      if (v28)
      {
        v40 = [(HMDAccessory *)self firmwareVersion];
        char v41 = [(HMDAccessoryVersion *)v28 isEqualToVersion:v40];

        if ((v41 & 1) == 0)
        {
          [v13 setFirmwareVersion:v18];
LABEL_45:

          goto LABEL_36;
        }
      }
    }
    else
    {
      v28 = 0;
    }
    goto LABEL_58;
  }
  if ([v10 isEqualToString:*MEMORY[0x1E4F2CFA0]])
  {
    if (!v18) {
      goto LABEL_59;
    }
    v38 = [(HMDAccessory *)self serialNumber];
    char v39 = HMFEqualObjects();

    if (v39) {
      goto LABEL_59;
    }
    [v13 setSerialNumber:v18];
    goto LABEL_36;
  }
  if ([v10 isEqualToString:@"000000A6-0000-1000-8000-0026BB765291"])
  {
    if (!v15) {
      goto LABEL_59;
    }
    v42 = [(HMDHAPAccessory *)self accessoryFlags];
    char v43 = HMFEqualObjects();

    if (v43) {
      goto LABEL_59;
    }
    [v13 setAccessoryFlags:v15];
    goto LABEL_36;
  }
  if (([v10 isEqualToString:@"00000220-0000-1000-8000-0026BB765291"] & 1) != 0
    || ![v10 isEqualToString:@"0000026D-0000-1000-8000-0026BB765291"])
  {
    goto LABEL_59;
  }
  BOOL v31 = 0;
  if ([(HMDHAPAccessory *)self supportsCHIP] && v15)
  {
    v28 = -[HMDAccessoryVersion initWithMajorVersion:minorVersion:updateVersion:]([HMDAccessoryVersion alloc], "initWithMajorVersion:minorVersion:updateVersion:", [v15 unsignedLongValue], 0, 0);
    if (v28)
    {
      v44 = [(HMDAccessory *)self firmwareVersion];
      char v45 = HMFEqualObjects();

      if ((v45 & 1) == 0)
      {
        v46 = [(HMDAccessoryVersion *)v28 versionString];
        [v13 setFirmwareVersion:v46];

        goto LABEL_45;
      }
    }
LABEL_58:

    goto LABEL_59;
  }
LABEL_60:

  return v31;
}

uint64_t __80__HMDHAPAccessory_enableNotificationsWithHAPAccessory_homeNotificationsEnabled___block_invoke(uint64_t a1, void *a2)
{
  return [a2 characteristic];
}

- (id)characteristicsPassingTest:(id)a3
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v4 = (unsigned int (**)(id, void))a3;
  v5 = [MEMORY[0x1E4F1CA48] array];
  id v6 = [(HMDHAPAccessory *)self hapMetadata];
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  uint64_t v7 = [(HMDHAPAccessory *)self services];
  v8 = (void *)[v7 copy];

  id obj = v8;
  uint64_t v9 = [v8 countByEnumeratingWithState:&v32 objects:v37 count:16];
  if (v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = *(void *)v33;
    uint64_t v25 = *(void *)v33;
    do
    {
      uint64_t v12 = 0;
      uint64_t v26 = v10;
      do
      {
        if (*(void *)v33 != v11) {
          objc_enumerationMutation(obj);
        }
        id v13 = *(void **)(*((void *)&v32 + 1) + 8 * v12);
        long long v14 = [v13 type];
        char v15 = [v6 shouldFilterServiceOfType:v14];

        if ((v15 & 1) == 0)
        {
          id v16 = v6;
          long long v30 = 0u;
          long long v31 = 0u;
          long long v28 = 0u;
          long long v29 = 0u;
          v17 = [v13 characteristics];
          id v18 = (void *)[v17 copy];

          uint64_t v19 = [v18 countByEnumeratingWithState:&v28 objects:v36 count:16];
          if (v19)
          {
            uint64_t v20 = v19;
            uint64_t v21 = *(void *)v29;
            do
            {
              for (uint64_t i = 0; i != v20; ++i)
              {
                if (*(void *)v29 != v21) {
                  objc_enumerationMutation(v18);
                }
                uint64_t v23 = *(void *)(*((void *)&v28 + 1) + 8 * i);
                if (v4[2](v4, v23)) {
                  [v5 addObject:v23];
                }
              }
              uint64_t v20 = [v18 countByEnumeratingWithState:&v28 objects:v36 count:16];
            }
            while (v20);
          }

          id v6 = v16;
          uint64_t v11 = v25;
          uint64_t v10 = v26;
        }
        ++v12;
      }
      while (v12 != v10);
      uint64_t v10 = [obj countByEnumeratingWithState:&v32 objects:v37 count:16];
    }
    while (v10);
  }

  return v5;
}

uint64_t __49__HMDHAPAccessory__characteristicsToEnableEvents__block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 type];
  v5 = [v3 service];
  id v6 = [v5 type];

  if ([*(id *)(a1 + 32) shouldFilterChangeNotificationsForCharacteristicType:v4 serviceType:v6]) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = [v3 isNotificationEnabled];
  }

  return v7;
}

- (BOOL)isPrimary
{
  v2 = [(HMDHAPAccessory *)self bridge];

  return v2 == 0;
}

- (id)bridge
{
  v2 = [(HMDAccessory *)self hostAccessory];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v3 = v2;
  }
  else {
    id v3 = 0;
  }
  id v4 = v3;

  return v4;
}

- (HMDHAPMetadata)hapMetadata
{
  return (HMDHAPMetadata *)objc_getProperty(self, a2, 1024, 1);
}

- (HMDService)primaryService
{
  os_unfair_recursive_lock_lock_with_options();
  id v3 = self->_primaryService;
  os_unfair_recursive_lock_unlock();
  return v3;
}

void __61__HMDHAPAccessory_setReachability_serverIdentifier_linkType___block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  [*(id *)(a1 + 32) transportInformationInstances];
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v3 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v12;
    while (2)
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        if (*(void *)v12 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void **)(*((void *)&v11 + 1) + 8 * i);
        if (!*(void *)(a1 + 48)
          || objc_msgSend(*(id *)(*((void *)&v11 + 1) + 8 * i), "linkType", (void)v11) == *(void *)(a1 + 48))
        {
          v8 = *(void **)(a1 + 40);
          if (!v8
            || ([v7 serverIdentifier],
                uint64_t v9 = objc_claimAutoreleasedReturnValue(),
                int v10 = [v8 isEqualToString:v9],
                v9,
                v10))
          {
            objc_msgSend(v7, "setReachable:", *(unsigned __int8 *)(a1 + 56), (void)v11);
            [*(id *)(a1 + 32) _updateReachability];
            goto LABEL_14;
          }
        }
      }
      uint64_t v4 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }
LABEL_14:
}

uint64_t __48__HMDHAPAccessory_isBLESecureSessionEstablished__block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  if ([v2 linkType] == 2)
  {
    uint64_t v3 = [v2 hapAccessory];
    uint64_t v4 = [v3 server];

    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 0;
    }
    id v6 = v5;

    uint64_t v7 = [v6 isSecuritySessionOpen];
  }
  else
  {
    uint64_t v7 = 0;
  }

  return v7;
}

id __47__HMDHAPAccessory_getTransportInformationArray__block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  if ([v2 linkType])
  {
    uint64_t v3 = [v2 transportInfoDictionary];
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

BOOL __28__HMDHAPAccessory_hasIPLink__block_invoke(uint64_t a1, void *a2)
{
  return [a2 linkType] == 1;
}

BOOL __30__HMDHAPAccessory_hasBTLELink__block_invoke(uint64_t a1, void *a2)
{
  return [a2 linkType] == 2;
}

- (void)handleUpdatedServicesForThreadManagementWithCompletion:(id)a3
{
  id v5 = a3;
  id v6 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __92__HMDHAPAccessory_ThreadManagement__handleUpdatedServicesForThreadManagementWithCompletion___block_invoke;
  block[3] = &unk_1E6A181A0;
  id v9 = v5;
  SEL v10 = a2;
  block[4] = self;
  id v7 = v5;
  dispatch_async(v6, block);
}

- (BOOL)matchesHAPAccessoryWithServerIdentifier:(id)a3 linkType:(int64_t *)a4
{
  id v6 = (void *)MEMORY[0x1E4F5BC00];
  id v7 = a3;
  v8 = [(HMDHAPAccessory *)self uniqueIdentifier];
  id v9 = [v6 serverIdentifierWithUniqueIdentifier:v8];
  char v10 = [v7 isEqualToString:v9];

  long long v11 = [(HMDHAPAccessory *)self matchingTransportInformationWithServerIdentifier:v7];

  if (!v11)
  {
    int64_t v12 = 0;
    if (!a4) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  int64_t v12 = [v11 linkType];
  char v10 = 1;
  if (a4) {
LABEL_3:
  }
    *a4 = v12;
LABEL_4:

  return v10;
}

- (id)matchingTransportInformationWithServerIdentifier:(id)a3
{
  return [(HMDHAPAccessory *)self matchingTransportInformationWithServerIdentifier:a3 instanceID:0 linkType:0];
}

- (void)maybeCommissionToThreadNetworkWithCompletion:(id)a3
{
  id v5 = a3;
  id v6 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __82__HMDHAPAccessory_ThreadManagement__maybeCommissionToThreadNetworkWithCompletion___block_invoke;
  block[3] = &unk_1E6A181A0;
  id v9 = v5;
  SEL v10 = a2;
  block[4] = self;
  id v7 = v5;
  dispatch_async(v6, block);
}

- (BOOL)matchesHAPAccessory:(id)a3
{
  uint64_t v3 = [(HMDHAPAccessory *)self matchingTransportInformation:a3];
  BOOL v4 = v3 != 0;

  return v4;
}

BOOL __88__HMDHAPAccessory_matchingTransportInformationWithServerIdentifier_instanceID_linkType___block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  BOOL v4 = [v3 serverIdentifier];
  int v5 = HMFEqualObjects();

  if (v5
    && (!*(void *)(a1 + 40)
     || ([v3 instanceID],
         id v6 = objc_claimAutoreleasedReturnValue(),
         int v7 = HMFEqualObjects(),
         v6,
         v7)))
  {
    if (*(void *)(a1 + 48)) {
      BOOL v8 = [v3 linkType] == *(void *)(a1 + 48);
    }
    else {
      BOOL v8 = 1;
    }
  }
  else
  {
    BOOL v8 = 0;
  }

  return v8;
}

- (id)matchingTransportInformation:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [v4 instanceID];
  if (v5
    && (id v6 = (void *)v5,
        [v4 serverIdentifier],
        int v7 = objc_claimAutoreleasedReturnValue(),
        v7,
        v6,
        v7))
  {
    BOOL v8 = [v4 serverIdentifier];
    id v9 = [v4 instanceID];
    SEL v10 = -[HMDHAPAccessory matchingTransportInformationWithServerIdentifier:instanceID:linkType:](self, "matchingTransportInformationWithServerIdentifier:instanceID:linkType:", v8, v9, [v4 linkType]);
  }
  else
  {
    SEL v10 = 0;
  }

  return v10;
}

- (id)matchingTransportInformationWithServerIdentifier:(id)a3 instanceID:(id)a4 linkType:(int64_t)a5
{
  id v8 = a3;
  id v9 = a4;
  if (v8)
  {
    SEL v10 = [(HMDHAPAccessory *)self transportInformationInstances];
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __88__HMDHAPAccessory_matchingTransportInformationWithServerIdentifier_instanceID_linkType___block_invoke;
    v13[3] = &unk_1E6A0AF70;
    id v14 = v8;
    id v15 = v9;
    int64_t v16 = a5;
    long long v11 = objc_msgSend(v10, "na_firstObjectPassingTest:", v13);
  }
  else
  {
    long long v11 = 0;
  }

  return v11;
}

- (NSArray)transportInformationInstances
{
  os_unfair_recursive_lock_lock_with_options();
  id v3 = (void *)[(NSMutableArray *)self->_transportInformationInstances copy];
  os_unfair_recursive_lock_unlock();
  return (NSArray *)v3;
}

- (id)preferredHAPAccessoryForOperation:(int64_t)a3 linkType:(int64_t *)a4
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    uint64_t v6 = [&unk_1F2DC6B50 countByEnumeratingWithState:&v41 objects:v46 count:16];
    if (!v6)
    {
LABEL_28:
      uint64_t v26 = 0;
      *a4 = 0;
      goto LABEL_31;
    }
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v42;
    uint64_t v32 = *MEMORY[0x1E4F5BED0];
    char v33 = 1;
    unint64_t v9 = 0x1E4F28000uLL;
    uint64_t v28 = *(void *)v42;
    long long v29 = self;
LABEL_4:
    uint64_t v10 = 0;
    uint64_t v30 = v7;
    while (1)
    {
      if (*(void *)v42 != v8) {
        objc_enumerationMutation(&unk_1F2DC6B50);
      }
      long long v11 = *(void **)(*((void *)&v41 + 1) + 8 * v10);
      int64_t v12 = [(HMDHAPAccessory *)self transportInformationInstances];
      long long v37 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      id obj = v12;
      uint64_t v13 = [obj countByEnumeratingWithState:&v37 objects:v45 count:16];
      if (v13) {
        break;
      }
LABEL_26:

      if (++v10 == v7)
      {
        uint64_t v7 = [&unk_1F2DC6B50 countByEnumeratingWithState:&v41 objects:v46 count:16];
        if (!v7) {
          goto LABEL_28;
        }
        goto LABEL_4;
      }
    }
    uint64_t v14 = v13;
    uint64_t v31 = v10;
    uint64_t v15 = *(void *)v38;
    uint64_t v34 = *(void *)v38;
LABEL_9:
    uint64_t v16 = 0;
    while (1)
    {
      if (*(void *)v38 != v15) {
        objc_enumerationMutation(obj);
      }
      v17 = *(void **)(*((void *)&v37 + 1) + 8 * v16);
      id v18 = objc_msgSend(*(id *)(v9 + 3792), "numberWithInteger:", objc_msgSend(v17, "linkType"));
      if ([v11 isEqualToNumber:v18])
      {
        if (a3 == 1 || a3 == 10)
        {
          [v17 instanceID];
          uint64_t v19 = v11;
          v21 = int64_t v20 = a3;
          [*(id *)(v9 + 3792) numberWithUnsignedInteger:v32];
          v23 = unint64_t v22 = v9;
          int v24 = [v21 isEqualToNumber:v23];

          unint64_t v9 = v22;
          a3 = v20;
          long long v11 = v19;
          uint64_t v15 = v34;

          if (!v24) {
            goto LABEL_21;
          }
        }
        else
        {
        }
        if (((*a4 != 0) & v33) != 1)
        {
          uint64_t v26 = [v17 hapAccessory];
          *a4 = [v17 linkType];

          goto LABEL_31;
        }
        int64_t v25 = *a4;
        if (v25 == [v17 linkType])
        {
          char v33 = 0;
LABEL_25:
          uint64_t v8 = v28;
          self = v29;
          uint64_t v7 = v30;
          uint64_t v10 = v31;
          goto LABEL_26;
        }
      }
      else
      {
      }
LABEL_21:
      if (v14 == ++v16)
      {
        uint64_t v14 = [obj countByEnumeratingWithState:&v37 objects:v45 count:16];
        if (v14) {
          goto LABEL_9;
        }
        goto LABEL_25;
      }
    }
  }
  uint64_t v26 = 0;
LABEL_31:
  return v26;
}

- (void)_notifyCharacteristicNotificationChanges:(id)a3 enableNotification:(BOOL)a4 message:(id)a5 clientIdentifier:(id)a6
{
  BOOL v8 = a4;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a5;
  id v26 = a6;
  if ([v10 count])
  {
    id v22 = v11;
    int64_t v12 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v10, "count"));
    int64_t v25 = [MEMORY[0x1E4F28E10] strongToStrongObjectsMapTable];
    [MEMORY[0x1E4F1C9C8] date];
    v24 = id v23 = v10;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    id v13 = v10;
    uint64_t v14 = [v13 countByEnumeratingWithState:&v27 objects:v31 count:16];
    if (v14)
    {
      uint64_t v15 = v14;
      uint64_t v16 = *(void *)v28;
      do
      {
        for (uint64_t i = 0; i != v15; ++i)
        {
          if (*(void *)v28 != v16) {
            objc_enumerationMutation(v13);
          }
          id v18 = *(void **)(*((void *)&v27 + 1) + 8 * i);
          uint64_t v19 = [v18 characteristic];
          int64_t v20 = [(HMDHAPAccessory *)self hmdCharacteristicFromHapCharacteristic:v19];
          if (v20)
          {
            [v12 addObject:v20];
            uint64_t v21 = [v18 error];
            if (v21)
            {
              [v25 setObject:v21 forKey:v20];
              if (!v8) {
                [v20 setNotificationEnabled:0 forClientIdentifier:v26];
              }
            }
            else
            {
              [v20 setNotificationEnabled:v8 forClientIdentifier:v26];
              if (v8) {
                [v20 setNotificationEnabledTime:v24];
              }
            }
          }
        }
        uint64_t v15 = [v13 countByEnumeratingWithState:&v27 objects:v31 count:16];
      }
      while (v15);
    }

    id v11 = v22;
    [(HMDHAPAccessory *)self _notifyClientsWithNotificationChangesForCharacteristics:v12 characteristicErrors:v25 enableNotification:v8 message:v22];

    id v10 = v23;
  }
}

- (id)hmdCharacteristicFromHapCharacteristic:(id)a3
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = [v4 service];
    uint64_t v7 = [v6 accessory];
    if ([(HMDHAPAccessory *)self matchesHAPAccessory:v7])
    {
      BOOL v8 = [v5 instanceID];
      unint64_t v9 = [v6 instanceID];
      id v10 = [(HMDHAPAccessory *)self findCharacteristic:v8 forService:v9];

      if (v10)
      {
LABEL_8:

        goto LABEL_10;
      }
      id v11 = (void *)MEMORY[0x1D9452090]();
      int64_t v12 = self;
      id v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = HMFGetLogIdentifier();
        uint64_t v15 = [v7 uniqueIdentifier];
        uint64_t v16 = [v6 instanceID];
        v17 = [v5 instanceID];
        int v19 = 138544130;
        int64_t v20 = v14;
        __int16 v21 = 2112;
        id v22 = v15;
        __int16 v23 = 2112;
        int v24 = v16;
        __int16 v25 = 2112;
        id v26 = v17;
        _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_ERROR, "%{public}@hapCharacteristic %@/%@/%@ to hmdCharacteristic mapping failed", (uint8_t *)&v19, 0x2Au);
      }
    }
    id v10 = 0;
    goto LABEL_8;
  }
  id v10 = 0;
LABEL_10:

  return v10;
}

- (id)findCharacteristic:(id)a3 forService:(id)a4
{
  id v6 = a3;
  uint64_t v7 = [(HMDHAPAccessory *)self findService:a4];
  BOOL v8 = [v7 findCharacteristic:v6];

  return v8;
}

- (id)findService:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HMDHAPAccessory *)self services];
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = __31__HMDHAPAccessory_findService___block_invoke;
  v9[3] = &unk_1E6A0AE70;
  id v10 = v4;
  id v6 = v4;
  uint64_t v7 = objc_msgSend(v5, "na_firstObjectPassingTest:", v9);

  return v7;
}

- (void)configureWithAccessory:(id)a3 homeNotificationsEnabled:(BOOL)a4 queue:(id)a5 completion:(id)a6
{
  id v11 = a3;
  id v12 = a5;
  id v13 = a6;
  uint64_t v14 = [(HMDAccessory *)self workQueue];
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 3221225472;
  v18[2] = __84__HMDHAPAccessory_configureWithAccessory_homeNotificationsEnabled_queue_completion___block_invoke;
  v18[3] = &unk_1E6A0AF48;
  v18[4] = self;
  id v19 = v11;
  BOOL v23 = a4;
  id v20 = v12;
  id v21 = v13;
  SEL v22 = a2;
  id v15 = v13;
  id v16 = v12;
  id v17 = v11;
  dispatch_async(v14, v18);
}

- (void)_evaluateAvailableSoftwareUpdate
{
  id v3 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v3);

  id v4 = [(HMDHAPAccessory *)self firmwareUpdateManager];
  id v11 = [v4 sessionForAccessory:self];

  if (!v11)
  {
    uint64_t v5 = [(HMDAccessory *)self softwareUpdate];
    if (v5)
    {
      id v6 = (void *)v5;
      uint64_t v7 = [(HMDAccessory *)self softwareUpdate];
      BOOL v8 = [v7 version];
      unint64_t v9 = [(HMDAccessory *)self firmwareVersion];
      char v10 = [v8 isEqualToVersion:v9];

      if ((v10 & 1) == 0) {
        [(HMDAccessory *)self updateSoftwareUpdate:0 completionHandler:&__block_literal_global_19782];
      }
    }
  }
}

- (id)firmwareUpdateManager
{
  id v2 = [(HMDAccessory *)self home];
  id v3 = [v2 homeManager];
  id v4 = [v3 accessoryFirmwareUpdateManager];

  return v4;
}

- (BOOL)isEqual:(id)a3
{
  id v4 = (HMDHAPAccessory *)a3;
  if (self == v4)
  {
    char v9 = 1;
  }
  else
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 0;
    }
    id v6 = v5;
    if (v6)
    {
      uint64_t v7 = [(HMDHAPAccessory *)self uniqueIdentifier];
      BOOL v8 = [(HMDHAPAccessory *)v6 uniqueIdentifier];
      char v9 = [v7 isEqualToString:v8];
    }
    else
    {
      char v9 = 0;
    }
  }
  return v9;
}

- (NSString)shortDescription
{
  int v3 = isInternalBuild();
  id v4 = NSString;
  if (v3)
  {
    uint64_t v5 = [(HMDHAPAccessory *)self name];
    id v6 = [(HMDAccessory *)self uuid];
    uint64_t v7 = [(HMDHAPAccessory *)self uniqueIdentifier];
    [(HMDAccessory *)self isReachable];
    BOOL v8 = HMFBooleanToString();
    char v9 = [v4 stringWithFormat:@"%@/%@/%@/%@", v5, v6, v7, v8];
  }
  else
  {
    uint64_t v5 = [(HMDAccessory *)self uuid];
    id v6 = [(HMDHAPAccessory *)self uniqueIdentifier];
    [(HMDAccessory *)self isReachable];
    uint64_t v7 = HMFBooleanToString();
    char v9 = [v4 stringWithFormat:@"%@/%@/%@", v5, v6, v7];
  }

  return (NSString *)v9;
}

- (id)name
{
  v8.receiver = self;
  v8.super_class = (Class)HMDHAPAccessory;
  int v3 = [(HMDAccessory *)&v8 name];
  if ([(HMDHAPAccessory *)self hasSmartSpeakerService])
  {
    uint64_t v4 = [(HMDHAPAccessory *)self getConfiguredName];

    int v3 = (void *)v4;
    if (!v4)
    {
      uint64_t v5 = [(HMDAccessory *)self room];
      int v3 = [v5 name];
    }
  }
  if (![v3 length])
  {
    uint64_t v6 = [(HMDAccessory *)self initialManufacturer];

    int v3 = (void *)v6;
  }
  return v3;
}

- (BOOL)hasSmartSpeakerService
{
  id v2 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000228-0000-1000-8000-0026BB765291"];
  BOOL v3 = v2 != 0;

  return v3;
}

void __74__HMDHAPAccessory__notificationRegistrationsByClientIDForCharacteristics___block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(a1 + 32);
  id v17 = v3;
  uint64_t v5 = [v3 clientID];
  uint64_t v6 = [v4 objectForKey:v5];

  if (!v6)
  {
    uint64_t v7 = [MEMORY[0x1E4F1CA48] array];
    objc_super v8 = *(void **)(a1 + 32);
    char v9 = [v17 clientID];
    [v8 setObject:v7 forKeyedSubscript:v9];
  }
  char v10 = [HMDCharacteristicNotificationChangeThreshold alloc];
  uint64_t v11 = *(void *)(a1 + 40);
  id v12 = [v17 updateThreshold];
  id v13 = [(HMDCharacteristicNotificationChangeThreshold *)v10 initWithCharacteristic:v11 threshold:v12];

  uint64_t v14 = *(void **)(a1 + 32);
  id v15 = [v17 clientID];
  id v16 = [v14 objectForKeyedSubscript:v15];
  [v16 addObject:v13];
}

- (unint64_t)hash
{
  id v3 = [(HMDHAPAccessory *)self uniqueIdentifier];
  if (v3)
  {
    uint64_t v4 = [(HMDHAPAccessory *)self uniqueIdentifier];
    id v5 = (id)[v4 hash];
  }
  else
  {
    v7.receiver = self;
    v7.super_class = (Class)HMDHAPAccessory;
    id v5 = [(HMDHAPAccessory *)&v7 hash];
  }

  return (unint64_t)v5;
}

- (NSString)uniqueIdentifier
{
  return self->_uniqueIdentifier;
}

uint64_t __123__HMDHAPAccessory__notifyClientsWithNotificationChangesForCharacteristics_characteristicErrors_enableNotification_message___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) respondWithPayload:0];
}

uint64_t __41__HMDHAPAccessory_checkHAPSessionRestore__block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _checkHAPSessionRestore];
}

uint64_t __48__HMDHAPAccessory_WirelessResume__cancelPowerOn__block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _cancelPowerOn];
}

uint64_t __45__HMDHAPAccessory_handleAccessoryConfigured___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _evaluateAvailableSoftwareUpdate];
}

uint64_t __129__HMDHAPAccessory_setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _setNotificationsEnabled:*(unsigned __int8 *)(a1 + 72) forCharacteristics:*(void *)(a1 + 40) notificationChangeThresholds:*(void *)(a1 + 48) clientIdentifier:*(void *)(a1 + 56) matchingHAPAccessory:*(void *)(a1 + 64)];
}

- (void)_encodeWithCoder:(id)a3
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  v72.receiver = self;
  v72.super_class = (Class)HMDHAPAccessory;
  [(HMDAccessory *)&v72 encodeWithCoder:v4];
  unsigned int v5 = objc_msgSend(v4, "hmd_isForXPCTransport");
  unsigned int v6 = objc_msgSend(v4, "hmd_isForXPCTransportEntitledForSPIAccess");
  unsigned int v7 = objc_msgSend(v4, "hmd_homeManagerOptions");
  if ((v7 & 0x20) == 0)
  {
LABEL_8:
    if (!v5) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v8 = objc_msgSend(v4, "hmd_isForLocalStore");
  if (objc_msgSend(v4, "hmd_isForXPCTransport")) {
    goto LABEL_7;
  }
  if (!v5)
  {
    if (!v8) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  if ((objc_msgSend(v4, "hmd_isForXPCTransportEntitledForSPIAccess") | v8))
  {
LABEL_7:
    [(HMDAccessory *)self encodePreferredMediaUser:v4];
    goto LABEL_8;
  }
LABEL_9:
  BOOL v9 = [(HMDHAPAccessory *)self supportsPrimaryUserInfoSubscription];
  [v4 encodeBool:v9 forKey:*MEMORY[0x1E4F2C7F8]];
LABEL_10:
  if ([(HMDHAPAccessory *)self hasTelevisionService])
  {
    if ((v7 & 0x400) == 0) {
      goto LABEL_67;
    }
  }
  else
  {
    char v10 = [(HMDHAPAccessory *)self networkRouterController];

    if (v10)
    {
      if ((v7 & 0x1000) == 0) {
        goto LABEL_67;
      }
    }
    else
    {
      uint64_t v11 = [(HMDHAPAccessory *)self siriEndpointProfile];
      BOOL v12 = v11 != 0;

      if ((v7 & 0x201) == 0 && (v12 & (v7 >> 15)) == 0) {
        goto LABEL_67;
      }
    }
  }
  objc_msgSend(v4, "encodeBool:forKey:", -[HMDHAPAccessory isPaired](self, "isPaired", __PAIR64__(v6, v5)), @"paired");
  id v13 = [(HMDHAPAccessory *)self identifiersForBridgedAccessories];
  uint64_t v14 = [v13 allObjects];
  [v4 encodeObject:v14 forKey:@"identifiersForBridgedAccessories"];

  v67 = [(HMDHAPAccessory *)self bridge];
  [v4 encodeBool:v67 != 0 forKey:@"isBridged"];
  id v15 = [(HMDHAPAccessory *)self accessoryFlags];
  [v4 encodeObject:v15 forKey:@"accessoryFlagsCodingKey"];

  id v16 = [(HMDHAPAccessory *)self broadcastKey];
  [v4 encodeObject:v16 forKey:@"accessoryBroadcastKey"];

  id v17 = [(HMDHAPAccessory *)self uniqueIdentifier];
  [v4 encodeObject:v17 forKey:@"accessoryIdentifier"];

  id v18 = [(HMDHAPAccessory *)self transportInformationInstances];
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  uint64_t v19 = [v18 countByEnumeratingWithState:&v68 objects:v73 count:16];
  if (v19)
  {
    uint64_t v20 = v19;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = *(void *)v69;
    do
    {
      for (uint64_t i = 0; i != v20; ++i)
      {
        if (*(void *)v69 != v23) {
          objc_enumerationMutation(v18);
        }
        __int16 v25 = *(void **)(*((void *)&v68 + 1) + 8 * i);
        if ([v25 linkType] == 1)
        {
          v22 |= 1uLL;
          uint64_t v21 = 1;
        }
        else if ([v25 linkType] == 2)
        {
          v22 |= 2uLL;
          if (!v21) {
            uint64_t v21 = 2;
          }
        }
      }
      uint64_t v20 = [v18 countByEnumeratingWithState:&v68 objects:v73 count:16];
    }
    while (v20);
  }
  else
  {
    uint64_t v21 = 0;
    uint64_t v22 = 0;
  }
  [v4 encodeInteger:v21 forKey:@"linkType"];
  if ((v65 ^ 1 | v66) == 1)
  {
    int64_t v26 = [(HMDHAPAccessory *)self certificationStatus];
    [v4 encodeInteger:v26 forKey:*MEMORY[0x1E4F2C278]];
    uint64_t v27 = [(HMDHAPAccessory *)self targetUUIDs];
    [v4 encodeObject:v27 forKey:*MEMORY[0x1E4F2C2D8]];

    BOOL v28 = [(HMDHAPAccessory *)self hardwareSupport];
    [v4 encodeBool:v28 forKey:*MEMORY[0x1E4F2C848]];
    long long v29 = [(HMDHAPAccessory *)self getBluetoothAddress];
    [v4 encodeObject:v29 forKey:@"HM.bluetoothAddr"];

    long long v30 = [(HMDHAPAccessory *)self hasOnboardedForNaturalLighting];
    [v4 encodeObject:v30 forKey:*MEMORY[0x1E4F2C3E0]];
  }
  if (v65)
  {
    BOOL v31 = [(HMDHAPAccessory *)self supportsTargetController];
    [v4 encodeBool:v31 forKey:*MEMORY[0x1E4F2C858]];
    if (v66)
    {
      [v4 encodeInteger:v22 forKey:@"HM.accessoryTransportTypes"];
      BOOL v32 = [(HMDHAPAccessory *)self _supportsMediaAccessControl];
      [v4 encodeBool:v32 forKey:*MEMORY[0x1E4F2C7C8]];
      char v33 = [(HMDHAPAccessory *)self symptomsHandler];
      [v4 encodeBool:v33 != 0 forKey:*MEMORY[0x1E4F2C3E8]];

      BOOL v34 = [(HMDAccessory *)self isReachable]
         || [(HMDAccessory *)self isRemotelyReachable];
      [v4 encodeBool:v34 forKey:*MEMORY[0x1E4F2C2E0]];
      unint64_t v48 = [(HMDHAPAccessory *)self suspendedState];
      [v4 encodeInteger:v48 forKey:*MEMORY[0x1E4F2C828]];
      BOOL v49 = [(HMDHAPAccessory *)self supportsCHIP];
      [v4 encodeBool:v49 forKey:*MEMORY[0x1E4F2C788]];
      BOOL v50 = [(HMDHAPAccessory(CHIP) *)self requiresThreadRouter];
      [v4 encodeBool:v50 forKey:*MEMORY[0x1E4F2C548]];
      BOOL v51 = [(HMDHAPAccessory *)self supportsAccessCode];
      [v4 encodeBool:v51 forKey:*MEMORY[0x1E4F2C770]];
      BOOL v52 = [(HMDHAPAccessory *)self supportsWalletKey];
      [v4 encodeBool:v52 forKey:*MEMORY[0x1E4F2C820]];
    }
    v53 = [(HMDHAPAccessory *)self services];
    __int16 v54 = [(HMDHAPAccessory *)self hapMetadata];
    +[HMDHAPAccessory encodeServices:v53 forXPCCoder:v4 metadata:v54];

    BOOL v55 = [(HMDHAPAccessory *)self supportsDiagnosticsTransfer];
    [v4 encodeBool:v55 forKey:*MEMORY[0x1E4F2C330]];
    long long v38 = [(HMDHAPAccessory *)self supportedDiagnostics];
    if (v38) {
      [v4 encodeObject:v38 forKey:*MEMORY[0x1E4F2C768]];
    }
    __int16 v56 = [(HMDHAPAccessory *)self matterNodeID];
    [v4 encodeObject:v56 forKey:*MEMORY[0x1E4F2C430]];
  }
  else
  {
    long long v35 = [(HMDHAPAccessory *)self setupHash];
    [v4 encodeObject:v35 forKey:@"HM.accessorySetupHash"];

    [v4 encodeConditionalObject:v67 forKey:@"accessoryBridge"];
    v36 = [(HMDHAPAccessory *)self services];
    [v4 encodeObject:v36 forKey:@"services"];

    long long v37 = [(HMDHAPAccessory *)self primaryService];
    [v4 encodeObject:v37 forKey:@"kAccessoryPrimaryServiceKey"];

    long long v38 = [(HMDHAPAccessory *)self transportInformationInstances];
    [v4 encodeObject:v38 forKey:@"HM.accessoryTransportInformation"];
    objc_msgSend(v4, "encodeInteger:forKey:", -[HMDHAPAccessory communicationProtocol](self, "communicationProtocol"), @"HAP.communicationProtocol");
    uint64_t v39 = [(HMDHAPAccessory *)self publicKey];
    if (v39)
    {
      long long v40 = (void *)v39;
      long long v41 = [(HMDHAPAccessory *)self pairingUsername];

      if (v41)
      {
        long long v42 = [(HMDHAPAccessory *)self publicKey];
        [v4 encodeObject:v42 forKey:@"accessoryPublicKey"];

        long long v43 = [(HMDHAPAccessory *)self pairingUsername];
        [v4 encodeObject:v43 forKey:@"accessoryPairingUsername"];
      }
    }
    long long v44 = [(HMDHAPAccessory *)self connectivityInfo];
    [v4 encodeObject:v44 forKey:*MEMORY[0x1E4F2C2D0]];

    char v45 = [(HMDHAPAccessory *)self wiFiTransportCapabilities];
    [v4 encodeObject:v45 forKey:@"HAP.wtcap"];

    v46 = [(HMDHAPAccessory *)self sleepInterval];
    [v4 encodeObject:v46 forKey:@"HAP.sleepInterval"];

    unint64_t v47 = [(HMDHAPAccessory *)self suspendedState];
    [v4 encodeInteger:v47 forKey:*MEMORY[0x1E4F2C828]];
  }

  if ((objc_msgSend(v4, "hmd_isForLocalStore") & 1) != 0
    || objc_msgSend(v4, "hmd_isForRemoteTransport")
    && (objc_msgSend(v4, "hmd_isForRemoteTransportOnSameAccount") & 1) == 0
    && (objc_msgSend(v4, "hmd_isForRemoteUserAdministrator") & 1) != 0
    || objc_msgSend(v4, "hmd_isForRemoteTransportOnSameAccount")
    && (objc_msgSend(v4, "hmd_isForRemoteGatewayCoder") & 1) == 0)
  {
    uint64_t v57 = [(HMDHAPAccessory *)self initialServiceTypeUUIDs];
    [v4 encodeObject:v57 forKey:@"HAP.initialServiceTypeUUIDs"];
  }
  BOOL v58 = [(HMDHAPAccessory *)self supportsPreferredMediaUser];
  [v4 encodeBool:v58 forKey:*MEMORY[0x1E4F2C7F0]];
  if (objc_msgSend(v4, "hmd_isForLocalStore"))
  {
    v59 = [(HMDHAPAccessory *)self internalEnhancedAuthMethod];
    [v4 encodeObject:v59 forKey:@"HAP.authMethod"];

    v60 = [(HMDHAPAccessory *)self internalEnhancedAuthConfigNumber];
    if (v60) {
      [v4 encodeObject:v60 forKey:@"HAP.authMethodConfigNumber"];
    }
  }
  v61 = [(HMDHAPAccessory *)self needsOnboarding];
  [v4 encodeObject:v61 forKey:@"HM.needsOnboarding"];

  if (objc_msgSend(v4, "hmd_isForLocalStore"))
  {
    v62 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", -[HMDHAPAccessory siriEndpointCapabilities](self, "siriEndpointCapabilities"));
    [v4 encodeObject:v62 forKey:@"HMDSiriEndpointAccessoryCapabiltiesKey"];
  }
  [(HMDHAPAccessory *)self encodeCameraProfileNotificationSettingsWithCoder:v4];
  if (objc_msgSend(v4, "hmd_isForLocalStore"))
  {
    v63 = [(HMDHAPAccessory *)self accessCodeCache];
    [v4 encodeObject:v63 forKey:@"HMDHAPAccessoryAccessCodeCacheCodingKey"];

    if ([(HMDHAPAccessory *)self hasPostedBulletinForAccessCodeOnboarding]) {
      objc_msgSend(v4, "encodeBool:forKey:", -[HMDHAPAccessory hasPostedBulletinForAccessCodeOnboarding](self, "hasPostedBulletinForAccessCodeOnboarding"), @"HMDHAPAccessoryHasPostedBulletinForAccessCodeOnboardingCodingKey");
    }
  }
  if (objc_msgSend(v4, "hmd_isForLocalStore")
    && [(HMDHAPAccessory *)self hasPostedBulletinForWalletKeyOnboarding])
  {
    objc_msgSend(v4, "encodeBool:forKey:", -[HMDHAPAccessory hasPostedBulletinForWalletKeyOnboarding](self, "hasPostedBulletinForWalletKeyOnboarding"), @"HMDHAPAccessoryHasPostedBulletinForWalletKeyOnboardingCodingKey");
  }
  v64 = [(HMDHAPAccessory *)self chipStorage];
  [v4 encodeObject:v64 forKey:@"HMDHAP.chipStorage"];

LABEL_67:
}

- (NSArray)attributeDescriptions
{
  v29[6] = *MEMORY[0x1E4F143B8];
  id v3 = objc_alloc(MEMORY[0x1E4F653F8]);
  uint64_t v27 = [(HMDHAPAccessory *)self uniqueIdentifier];
  int64_t v26 = (void *)[v3 initWithName:@"ID" value:v27];
  v29[0] = v26;
  id v4 = objc_alloc(MEMORY[0x1E4F653F8]);
  [(HMDHAPAccessory *)self certificationStatus];
  __int16 v25 = HMAccessoryCertificationStatusToString();
  int v24 = (void *)[v4 initWithName:@"CS" value:v25];
  v29[1] = v24;
  id v5 = objc_alloc(MEMORY[0x1E4F653F8]);
  uint64_t v23 = [(HMDHAPAccessory *)self bridge];
  uint64_t v22 = [v23 uuid];
  uint64_t v21 = (void *)[v5 initWithName:@"BUUID" value:v22];
  v29[2] = v21;
  id v6 = objc_alloc(MEMORY[0x1E4F653F8]);
  unsigned int v7 = [(HMDHAPAccessory *)self matterNodeID];
  int v8 = (void *)[v6 initWithName:@"NodeID" value:v7];
  v29[3] = v8;
  id v9 = objc_alloc(MEMORY[0x1E4F653F8]);
  char v10 = [(HMDHAPAccessory *)self chipStorage];
  uint64_t v11 = [v10 vendorID];
  BOOL v12 = (void *)[v9 initWithName:@"VID" value:v11];
  v29[4] = v12;
  id v13 = objc_alloc(MEMORY[0x1E4F653F8]);
  uint64_t v14 = [(HMDHAPAccessory *)self chipStorage];
  id v15 = [v14 productID];
  id v16 = (void *)[v13 initWithName:@"PID" value:v15];
  v29[5] = v16;
  id v17 = [MEMORY[0x1E4F1C978] arrayWithObjects:v29 count:6];

  v28.receiver = self;
  v28.super_class = (Class)HMDHAPAccessory;
  id v18 = [(HMDAccessory *)&v28 attributeDescriptions];
  uint64_t v19 = [v18 arrayByAddingObjectsFromArray:v17];

  return (NSArray *)v19;
}

- (HMDCHIPAccessoryStorage)chipStorage
{
  return self->_chipStorage;
}

- (int64_t)certificationStatus
{
  return self->_certificationStatus;
}

- (NSNumber)matterNodeID
{
  return self->_matterNodeID;
}

- (id)getConfiguredName
{
  if ([(HMDHAPAccessory *)self hasSmartSpeakerService])
  {
    id v3 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000228-0000-1000-8000-0026BB765291"];
    id v4 = [v3 getConfiguredName];
    id v5 = [(HMDAccessory *)self room];
    id v6 = [v5 name];
    int v7 = HMFEqualObjects();

    if (v7)
    {

      id v4 = 0;
    }
  }
  else
  {
    v9.receiver = self;
    v9.super_class = (Class)HMDHAPAccessory;
    id v4 = [(HMDAccessory *)&v9 getConfiguredName];
  }
  return v4;
}

- (void)_groupCharacteristicsNotificationWithCharacteristics:(id)a3 enable:(BOOL)a4 activity:(id)a5 clientIdentifier:(id)a6 groupCharacteristicsError:(id *)a7 characteristicsToModifyLocally:(id *)a8 characteristicsToModifyOnResident:(id *)a9 characteristicsToDisableOnResident:(id *)a10 characteristicsErrorsMapFailingToModify:(id *)a11
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  id v16 = a3;
  id v78 = a5;
  id v17 = a6;
  id v18 = [(HMDAccessory *)self home];
  v93 = self;
  v96 = [(HMDHAPAccessory *)self hapMetadata];
  uint64_t v19 = [v18 primaryResident];
  v88 = v18;
  int v20 = [v18 isCurrentDeviceAvailableResident];
  char v77 = [v19 isCurrentDevice];
  v79 = v17;
  int v21 = [v17 hasPrefix:@"com.apple.HomeKitDaemon.Local"];
  BOOL v22 = isWatch();
  int v23 = v21 ^ 1;
  if (((v21 ^ 1) & 1) == 0 && (v20 & 1) == 0)
  {
    int v24 = (void *)MEMORY[0x1D9452090]();
    __int16 v25 = v93;
    int64_t v26 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    uint64_t v27 = HMFGetLogIdentifier();
    objc_super v28 = [v78 identifier];
    long long v29 = [v28 shortDescription];
    *(_DWORD *)buf = 138543874;
    v103 = v27;
    __int16 v104 = 2114;
    v105 = v29;
    __int16 v106 = 2112;
    v107 = v79;
    _os_log_impl(&dword_1D49D5000, v26, OS_LOG_TYPE_ERROR, "%{public}@[%{public}@] Not modifying characteristic notifications because client identifier %@ is disallowed on non-resident enabled devices", buf, 0x20u);
    goto LABEL_9;
  }
  if ([(HMDHAPAccessory *)v93 canWakeUpViaWoL] && [(HMDHAPAccessory *)v93 isSuspended])
  {
    int v24 = (void *)MEMORY[0x1D9452090]();
    __int16 v25 = v93;
    int64_t v26 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_INFO)) {
      goto LABEL_10;
    }
    uint64_t v27 = HMFGetLogIdentifier();
    objc_super v28 = [v78 identifier];
    long long v29 = [v28 shortDescription];
    [(HMDHAPAccessory *)v25 uniqueIdentifier];
    v31 = long long v30 = v19;
    *(_DWORD *)buf = 138543874;
    v103 = v27;
    __int16 v104 = 2114;
    v105 = v29;
    __int16 v106 = 2112;
    v107 = v31;
    _os_log_impl(&dword_1D49D5000, v26, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Not modifying notification for characteristics because accessory: %@ is suspended.", buf, 0x20u);

    uint64_t v19 = v30;
LABEL_9:

LABEL_10:
    if (a7)
    {
      *a7 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
    }
    goto LABEL_65;
  }
  v75 = v19;
  v73 = a8;
  if (!v22)
  {
    if (!shouldSkipLocalAccessoryNotificationRegistration(v88, v93, v16))
    {
      int v94 = 0;
      goto LABEL_19;
    }
    BOOL v32 = (void *)MEMORY[0x1D9452090]();
    char v33 = v93;
    BOOL v34 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
    {
      long long v35 = HMFGetLogIdentifier();
      v36 = [v78 identifier];
      long long v37 = [v36 shortDescription];
      *(_DWORD *)buf = 138543874;
      v103 = v35;
      __int16 v104 = 2114;
      v105 = v37;
      __int16 v106 = 2112;
      v107 = v79;
      _os_log_impl(&dword_1D49D5000, v34, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Not modifying local notifications for characteristics for %@ as current device is a non-resident and home has a resident", buf, 0x20u);
    }
  }
  int v94 = 1;
LABEL_19:
  v90 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v16, "count", a9));
  v89 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v16, "count"));
  v76 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v16, "count"));
  long long v98 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  id v74 = v16;
  id obj = v16;
  uint64_t v38 = [obj countByEnumeratingWithState:&v98 objects:v110 count:16];
  uint64_t v39 = v79;
  if (!v38) {
    goto LABEL_58;
  }
  uint64_t v40 = v38;
  uint64_t v41 = *(void *)v99;
  int v91 = v94 | v23;
  if (v75) {
    int v42 = v20;
  }
  else {
    int v42 = 0;
  }
  int v92 = v42;
  do
  {
    uint64_t v43 = 0;
    do
    {
      if (*(void *)v99 != v41) {
        objc_enumerationMutation(obj);
      }
      long long v44 = *(void **)(*((void *)&v98 + 1) + 8 * v43);
      if ([v44 properties])
      {
        char v45 = [v44 type];
        v46 = [v44 service];
        unint64_t v47 = [v46 type];
        int v48 = [v96 shouldFilterEnableNotificationsForCharacteristicType:v45 serviceType:v47];

        if (!v48)
        {
          if (a4)
          {
            BOOL v51 = v93;
            if (v94)
            {
              BOOL v52 = (void *)MEMORY[0x1D9452090]();
              v53 = v93;
              __int16 v54 = HMFGetOSLogHandle();
              if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
              {
                v80 = HMFGetLogIdentifier();
                v82 = [v78 identifier];
                v85 = v52;
                BOOL v55 = [v82 shortDescription];
                __int16 v56 = [v44 shortDescription];
                *(_DWORD *)buf = 138543874;
                v103 = v80;
                __int16 v104 = 2114;
                v105 = v55;
                __int16 v106 = 2112;
                v107 = v56;
                _os_log_impl(&dword_1D49D5000, v54, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Dropping characteristic %@ from local notification as current device is a non-resident and home has a resident", buf, 0x20u);

                uint64_t v39 = v79;
                BOOL v51 = v93;

                BOOL v52 = v85;
              }
            }
            else
            {
              [v90 addObject:v44];
            }
            if (v92)
            {
              if (shouldSkipRemoteAccessoryNotificationRegistration(v88, v51))
              {
                uint64_t v57 = MEMORY[0x1D9452090]();
                BOOL v58 = v51;
                v59 = HMFGetOSLogHandle();
                if (os_log_type_enabled(v59, OS_LOG_TYPE_INFO))
                {
                  v60 = HMFGetLogIdentifier();
                  v83 = [v78 identifier];
                  [v83 shortDescription];
                  v61 = uint64_t v86 = v57;
                  v62 = [v44 shortDescription];
                  *(_DWORD *)buf = 138543874;
                  v103 = v60;
                  __int16 v104 = 2114;
                  v105 = v61;
                  __int16 v106 = 2112;
                  v107 = v62;
                  _os_log_impl(&dword_1D49D5000, v59, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Dropping characteristic %@ from remote notification as partitioned network is no longer supported by residents", buf, 0x20u);

                  uint64_t v57 = v86;
                  uint64_t v39 = v79;
                }

                v63 = (void *)v57;
                goto LABEL_47;
              }
              if ((v77 & 1) == 0
                && [v44 isNotificationEnabledForClientIdentifierPrefix:@"com.apple.HomeKitDaemon.Local"])
              {
                uint64_t v65 = MEMORY[0x1D9452090]();
                int v66 = v51;
                v67 = HMFGetOSLogHandle();
                if (os_log_type_enabled(v67, OS_LOG_TYPE_INFO))
                {
                  v87 = HMFGetLogIdentifier();
                  v81 = [v78 identifier];
                  long long v68 = [v81 shortDescription];
                  [(HMDHAPAccessory *)v66 uniqueIdentifier];
                  long long v69 = v84 = v65;
                  long long v70 = [v44 shortDescription];
                  *(_DWORD *)buf = 138544130;
                  v103 = v87;
                  __int16 v104 = 2114;
                  v105 = v68;
                  __int16 v106 = 2112;
                  v107 = v69;
                  __int16 v108 = 2112;
                  v109 = v70;
                  _os_log_impl(&dword_1D49D5000, v67, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Dropping characteristic %@ for remote notifications from primary resident because it should be local only: %@", buf, 0x2Au);

                  uint64_t v65 = v84;
                  uint64_t v39 = v79;
                }
                v63 = (void *)v65;
LABEL_47:
                if (v39) {
                  goto LABEL_31;
                }
                v64 = v76;
LABEL_56:
                [v64 addObject:v44];
                goto LABEL_31;
              }
            }
LABEL_54:
            if (!v91) {
              goto LABEL_31;
            }
          }
          else
          {
            if (![v44 deregisterNotificationForClientIdentifier:v39]) {
              goto LABEL_31;
            }
            if ((v94 & 1) == 0)
            {
              [v90 addObject:v44];
              goto LABEL_54;
            }
          }
          v64 = v89;
          goto LABEL_56;
        }
      }
      if (a11)
      {
        id v49 = *a11;
        BOOL v50 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
        [v49 setObject:v50 forKey:v44];
      }
LABEL_31:
      ++v43;
    }
    while (v40 != v43);
    uint64_t v71 = [obj countByEnumeratingWithState:&v98 objects:v110 count:16];
    uint64_t v40 = v71;
  }
  while (v71);
LABEL_58:

  if (v73) {
    id *v73 = (id)[v90 copy];
  }
  id v16 = v74;
  uint64_t v19 = v75;
  if (v72) {
    *objc_super v72 = (id)[v89 copy];
  }
  if (a10) {
    *a10 = (id)[v76 copy];
  }

LABEL_65:
}

- (NSSet)identifiersForBridgedAccessories
{
  os_unfair_recursive_lock_lock_with_options();
  id v3 = self->_identifiersForBridgedAccessories;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (HMDSiriEndpointProfile)siriEndpointProfile
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v2 = [(HMDAccessory *)self accessoryProfiles];
  uint64_t v3 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v12;
LABEL_3:
    uint64_t v6 = 0;
    while (1)
    {
      if (*(void *)v12 != v5) {
        objc_enumerationMutation(v2);
      }
      id v7 = *(id *)(*((void *)&v11 + 1) + 8 * v6);
      objc_opt_class();
      id v8 = (objc_opt_isKindOfClass() & 1) != 0 ? v7 : 0;
      id v9 = v8;

      if (v9) {
        break;
      }
      if (v4 == ++v6)
      {
        uint64_t v4 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
        if (v4) {
          goto LABEL_3;
        }
        goto LABEL_12;
      }
    }
  }
  else
  {
LABEL_12:
    id v7 = 0;
  }

  return (HMDSiriEndpointProfile *)v7;
}

- (void)encodeCameraProfileNotificationSettingsWithCoder:(id)a3
{
  id v5 = a3;
  if (objc_msgSend(v5, "hmd_isForLocalStore"))
  {
    uint64_t v4 = [(HMDHAPAccessory *)self cameraProfileNotificationSettings];
    [v5 encodeObject:v4 forKey:@"HAP.cpns"];
  }
}

- (HMMTRAccessoryServer)chipAccessoryServer
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  [(HMDHAPAccessory *)self transportInformationInstances];
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v3 = [v2 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v13;
LABEL_3:
    uint64_t v6 = 0;
    while (1)
    {
      if (*(void *)v13 != v5) {
        objc_enumerationMutation(v2);
      }
      id v7 = objc_msgSend(*(id *)(*((void *)&v12 + 1) + 8 * v6), "hapAccessory", (void)v12);
      id v8 = [v7 server];

      objc_opt_class();
      id v9 = (objc_opt_isKindOfClass() & 1) != 0 ? v8 : 0;
      id v10 = v9;

      if (v10) {
        break;
      }
      if (v4 == ++v6)
      {
        uint64_t v4 = [v2 countByEnumeratingWithState:&v12 objects:v16 count:16];
        if (v4) {
          goto LABEL_3;
        }
        goto LABEL_12;
      }
    }
  }
  else
  {
LABEL_12:
    id v8 = 0;
  }

  return (HMMTRAccessoryServer *)v8;
}

- (NSArray)targetUUIDs
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v3 = self->_targetUUIDs;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (HMDAccessorySymptomHandler)symptomsHandler
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v3 = self->_symptomsHandler;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (BOOL)supportsTargetController
{
  uint64_t v3 = [(HMDHAPAccessory *)self findServiceWithServiceType:*MEMORY[0x1E4F2DEE0]];
  uint64_t v4 = [v3 characteristics];
  if ([v4 count])
  {
    uint64_t v5 = [(HMDHAPAccessory *)self findServiceWithServiceType:*MEMORY[0x1E4F2DEE8]];
    uint64_t v6 = [v5 characteristics];
    BOOL v7 = [v6 count] != 0;
  }
  else
  {
    BOOL v7 = 0;
  }

  return v7;
}

- (BOOL)supportsPrimaryUserInfoSubscription
{
  return 0;
}

- (BOOL)supportsPreferredMediaUser
{
  uint64_t v3 = [(HMDAccessory *)self home];
  uint64_t v4 = [v3 primaryResident];
  if (v4)
  {
    uint64_t v5 = [(HMDHAPAccessory *)self siriEndpointProfile];
    BOOL v6 = v5 != 0;
  }
  else
  {
    BOOL v6 = 0;
  }

  return v6;
}

- (BOOL)supportsDiagnosticsTransfer
{
  if ([(HMDHAPAccessory *)self supportsCHIP])
  {
    uint64_t v3 = [(HMDHAPAccessory *)self matterDiagnosticManager];
    uint64_t v4 = [v3 supportedDiagnostics];

    if (v4) {
      return 1;
    }
  }
  BOOL v6 = [(HMDHAPAccessory *)self findServiceWithServiceType:*MEMORY[0x1E4F2DE10]];
  BOOL v5 = v6 != 0;

  return v5;
}

- (BOOL)supportsAccessCode
{
  LOBYTE(self) = self->_supportsAccessCode;
  os_unfair_recursive_lock_unlock();
  return (char)self;
}

- (id)getBluetoothAddress
{
  id v2 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithLinkType:1];
  uint64_t v3 = v2;
  if (v2)
  {
    uint64_t v4 = [v2 bluetoothClassicMacAddress];
  }
  else
  {
    uint64_t v4 = 0;
  }

  return v4;
}

- (id)matchingHAPAccessoryWithLinkType:(int64_t)a3
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  [(HMDHAPAccessory *)self transportInformationInstances];
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v13;
    while (2)
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v13 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v12 + 1) + 8 * i);
        if (objc_msgSend(v9, "linkType", (void)v12) == a3)
        {
          id v10 = [v9 hapAccessory];
          goto LABEL_11;
        }
      }
      uint64_t v6 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
  id v10 = 0;
LABEL_11:

  return v10;
}

- (BOOL)_supportsMediaAccessControl
{
  id v2 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"000000DA-0000-1000-8000-0026BB765291"];
  BOOL v3 = v2 != 0;

  return v3;
}

+ (void)encodeServices:(id)a3 forXPCCoder:(id)a4 metadata:(id)a5
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v7 = a3;
  id v8 = a4;
  id v9 = a5;
  if ((objc_msgSend(v8, "hmd_isForXPCTransport") & 1) == 0) {
    _HMFPreconditionFailure();
  }
  id v10 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v7, "count"));
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  id v11 = v7;
  uint64_t v12 = [v11 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v12)
  {
    uint64_t v13 = v12;
    uint64_t v14 = *(void *)v20;
    do
    {
      for (uint64_t i = 0; i != v13; ++i)
      {
        if (*(void *)v20 != v14) {
          objc_enumerationMutation(v11);
        }
        uint64_t v16 = *(void **)(*((void *)&v19 + 1) + 8 * i);
        uint64_t v17 = objc_msgSend(v16, "type", (void)v19);
        char v18 = [v9 shouldFilterServiceOfTypeFromApp:v17];

        if ((v18 & 1) == 0) {
          [v10 addObject:v16];
        }
      }
      uint64_t v13 = [v11 countByEnumeratingWithState:&v19 objects:v23 count:16];
    }
    while (v13);
  }

  [v8 encodeObject:v10 forKey:@"services"];
}

- (BOOL)canWakeUpViaWoL
{
  if (![(HMDAccessory *)self isSuspendCapable]) {
    return 0;
  }
  BOOL v3 = [(HMDHAPAccessory *)self lpmProfile];
  if (v3)
  {
    id v4 = [(HMDHAPAccessory *)self connectivityInfo];
    uint64_t v5 = [v4 woWLANInfo];
    char v6 = [v5 supportsSleepConfig];
  }
  else
  {
    char v6 = 0;
  }

  return v6;
}

uint64_t __82__HMDHAPAccessory_enableNotification_forCharacteristics_message_clientIdentifier___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _enableNotification:*(unsigned __int8 *)(a1 + 64) forCharacteristics:*(void *)(a1 + 40) message:*(void *)(a1 + 48) clientIdentifier:*(void *)(a1 + 56)];
}

- (void)_readCharacteristicValues:(id)a3 hapAccessory:(id)a4 source:(unint64_t)a5 message:(id)a6 logEvent:(id)a7 completionHandler:(id)a8
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  id v13 = a3;
  id v14 = a4;
  id v76 = a6;
  id v77 = a7;
  id v75 = a8;
  long long v15 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v16 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v13, "count"));
  uint64_t v86 = self;
  int v92 = [(HMDHAPAccessory *)self hapMetadata];
  v87 = [MEMORY[0x1E4F28E10] weakToStrongObjectsMapTable];
  long long v109 = 0u;
  long long v110 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  id v17 = v13;
  v79 = v15;
  v80 = v16;
  uint64_t v93 = [v17 countByEnumeratingWithState:&v109 objects:v122 count:16];
  if (v93)
  {
    uint64_t v90 = *(void *)v110;
    uint64_t v88 = *MEMORY[0x1E4F2D140];
    id v78 = v14;
    id v85 = v17;
    do
    {
      for (uint64_t i = 0; i != v93; ++i)
      {
        if (*(void *)v110 != v90) {
          objc_enumerationMutation(v17);
        }
        long long v19 = *(void **)(*((void *)&v109 + 1) + 8 * i);
        long long v20 = [v19 characteristic];
        char v21 = [v20 properties];
        long long v22 = [v20 characteristicType];
        char v23 = [v92 shouldNotCacheCharacteristicOfType:v22];

        if ((v23 & 1) != 0 || (v21 & 2) == 0)
        {
          __int16 v25 = [MEMORY[0x1E4F28C58] errorWithDomain:v88 code:48 userInfo:0];
          int64_t v26 = +[HMDCharacteristicResponse responseWithRequest:v19 error:v25];
          [v16 addObject:v26];
        }
        else
        {
          uint64_t v24 = [v20 characteristicForHAPAccessory:v14];
          if (v24)
          {
            __int16 v25 = (void *)v24;
            [v15 addObject:v24];
            [v87 setObject:v19 forKey:v25];
          }
          else
          {
            uint64_t v27 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
            objc_super v28 = +[HMDCharacteristicResponse responseWithRequest:v19 error:v27];
            long long v29 = (void *)MEMORY[0x1D9452090]();
            long long v30 = v86;
            BOOL v31 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              v81 = HMFGetLogIdentifier();
              [v20 instanceID];
              BOOL v32 = v82 = v28;
              char v33 = [v20 characteristicType];
              BOOL v34 = [v14 server];
              [v34 identifier];
              v83 = v27;
              v36 = long long v35 = v29;
              *(_DWORD *)buf = 138544130;
              v115 = v81;
              __int16 v116 = 2112;
              uint64_t v117 = (uint64_t)v32;
              __int16 v118 = 2112;
              v119 = v33;
              __int16 v120 = 2112;
              v121 = v36;
              _os_log_impl(&dword_1D49D5000, v31, OS_LOG_TYPE_DEFAULT, "%{public}@Cannot map HMDCharacteristic %@/%@ to a HAPCharacteristic for server %@ to map read requests", buf, 0x2Au);

              long long v29 = v35;
              uint64_t v27 = v83;

              id v14 = v78;
              uint64_t v16 = v80;

              objc_super v28 = v82;
              long long v15 = v79;
            }
            [v16 addObject:v28];

            __int16 v25 = 0;
            id v17 = v85;
          }
        }
      }
      uint64_t v93 = [v17 countByEnumeratingWithState:&v109 objects:v122 count:16];
    }
    while (v93);
  }

  uint64_t v37 = [v16 count];
  if (v37 == [v17 count])
  {
    uint64_t v38 = (void *)MEMORY[0x1D9452090]();
    uint64_t v39 = v86;
    uint64_t v40 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v41 = HMFGetLogIdentifier();
      uint64_t v42 = [v80 count];
      *(_DWORD *)buf = 138543618;
      v115 = v41;
      __int16 v116 = 2048;
      uint64_t v117 = v42;
      _os_log_impl(&dword_1D49D5000, v40, OS_LOG_TYPE_DEFAULT, "%{public}@No HAP characteristics (out of %tu) left to be read", buf, 0x16u);
    }
    uint64_t v43 = v75;
    long long v44 = v80;
    if (v75) {
      (*((void (**)(id, void *))v75 + 2))(v75, v80);
    }
  }
  else
  {
    char v45 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v17, "count"));
    v46 = [MEMORY[0x1E4F1CA48] array];
    long long v105 = 0u;
    long long v106 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    id v47 = v17;
    uint64_t v48 = [v47 countByEnumeratingWithState:&v105 objects:v113 count:16];
    if (v48)
    {
      uint64_t v49 = v48;
      uint64_t v50 = *(void *)v106;
      do
      {
        for (uint64_t j = 0; j != v49; ++j)
        {
          if (*(void *)v106 != v50) {
            objc_enumerationMutation(v47);
          }
          BOOL v52 = *(void **)(*((void *)&v105 + 1) + 8 * j);
          v53 = [v52 characteristic];

          if (v53)
          {
            __int16 v54 = [v52 characteristic];
            [v45 addObject:v54];
          }
          else
          {
            [v46 addObject:v52];
          }
        }
        uint64_t v49 = [v47 countByEnumeratingWithState:&v105 objects:v113 count:16];
      }
      while (v49);
    }

    if ([v46 count])
    {
      BOOL v55 = (void *)MEMORY[0x1D9452090]();
      __int16 v56 = v86;
      uint64_t v57 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
        BOOL v58 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        v115 = v58;
        __int16 v116 = 2112;
        uint64_t v117 = (uint64_t)v46;
        _os_log_impl(&dword_1D49D5000, v57, OS_LOG_TYPE_ERROR, "%{public}@Invalid read requests with missing characteristic: %@", buf, 0x16u);
      }
    }
    [MEMORY[0x1E4F6A278] currentTime];
    uint64_t v60 = v59;
    long long v15 = v79;
    if (v77)
    {
      id v61 = v77;
      [v61 setIsLocal:1];
      objc_msgSend(v61, "setLinkType:", objc_msgSend(v14, "linkType"));
      v62 = v86;
    }
    else
    {
      v63 = [v76 clientIdentifier];
      v62 = v86;
      int v94 = [(HMDAccessory *)v86 home];
      v64 = [v76 userForHome:v94];
      uint64_t v65 = [v64 uuid];
      LOBYTE(v73) = 0;
      id v61 = +[HMDCharacteristicReadWriteLogEvent eventWithCharacteristicsToRead:v45 hmdAccessory:v86 hapAccessory:v14 source:a5 isLocal:1 transactionId:0 isCached:v73 bundleId:v63 userUUID:v65];

      long long v15 = v79;
    }
    int v66 = [(HMDAccessory *)v62 metricLoggingVendorDetails];
    int v91 = [v66 manufacturer];
    v95 = v66;
    v89 = [v66 model];
    [(HMDAccessory *)v62 firmwareVersion];
    long long v68 = v67 = v62;
    uint64_t v84 = [v68 versionString];

    long long v69 = [MEMORY[0x1E4F653F0] currentActivity];
    [(HMDAccessory *)v67 uuid];

    [v45 count];
    [v14 linkType];
    long long v70 = [(HMDAccessory *)v86 workQueue];
    v96[0] = MEMORY[0x1E4F143A8];
    v96[1] = 3221225472;
    v96[2] = __100__HMDHAPAccessory__readCharacteristicValues_hapAccessory_source_message_logEvent_completionHandler___block_invoke;
    v96[3] = &unk_1E6A0B178;
    uint64_t v104 = v60;
    id v97 = v61;
    long long v98 = v86;
    id v99 = v69;
    id v100 = v80;
    id v101 = v87;
    id v102 = v47;
    id v103 = v75;
    id v71 = v69;
    id v72 = v61;
    [v14 readCharacteristicValues:v15 timeout:v70 completionQueue:v96 completionHandler:0.0];

    uint64_t v43 = v75;
    long long v44 = v80;
  }
}

void __100__HMDHAPAccessory__readCharacteristicValues_hapAccessory_source_message_logEvent_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!v6)
  {
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    id v8 = v5;
    id v7 = (void *)[v8 countByEnumeratingWithState:&v25 objects:v33 count:16];
    if (v7)
    {
      uint64_t v9 = *(void *)v26;
      while (2)
      {
        for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v26 != v9) {
            objc_enumerationMutation(v8);
          }
          id v11 = *(void **)(*((void *)&v25 + 1) + 8 * i);
          uint64_t v12 = objc_msgSend(v11, "error", (void)v25);

          if (v12)
          {
            id v7 = [v11 error];
            goto LABEL_12;
          }
        }
        id v7 = (void *)[v8 countByEnumeratingWithState:&v25 objects:v33 count:16];
        if (v7) {
          continue;
        }
        break;
      }
    }
LABEL_12:
  }
  objc_msgSend(MEMORY[0x1E4F6A278], "currentTime", (void)v25);
  [*(id *)(a1 + 32) setLocalDurationInMilliseconds:(uint64_t)((v13 - *(double *)(a1 + 88)) * 1000.0)];
  [*(id *)(a1 + 40) submitLogEvent:*(void *)(a1 + 32) error:v7];
  id v14 = *(void **)(a1 + 40);
  id v15 = *(id *)(a1 + 48);
  [v14 uuid];

  [v7 domain];
  [v7 code];

  id v16 = v6;
  id v17 = v16;
  if (v6)
  {
    id v6 = v16;
    if (([v16 isHMError] & 1) == 0)
    {
      if ([v17 isHAPError])
      {
        unint64_t v18 = [v17 code];
        if (v18 > 0x20) {
          uint64_t v19 = 52;
        }
        else {
          uint64_t v19 = qword_1D54D4320[v18];
        }
      }
      else
      {
        uint64_t v19 = 74;
      }
      id v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:v19 description:@"Read Failed." reason:0 suggestion:0 underlyingError:v17];
    }
  }
  [*(id *)(a1 + 40) populateHMDCharacteristicResponses:*(void *)(a1 + 56) hapResponses:v5 mapping:*(void *)(a1 + 64) overallError:v6 requests:*(void *)(a1 + 72)];
  uint64_t v20 = *(void *)(a1 + 80);
  if (v20)
  {
    (*(void (**)(uint64_t, void))(v20 + 16))(v20, *(void *)(a1 + 56));
  }
  else if (v6)
  {
    char v21 = (void *)MEMORY[0x1D9452090]();
    id v22 = *(id *)(a1 + 40);
    char v23 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      uint64_t v24 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      long long v30 = v24;
      __int16 v31 = 2112;
      id v32 = v6;
      _os_log_impl(&dword_1D49D5000, v23, OS_LOG_TYPE_ERROR, "%{public}@Failed to read values for characteristics: %@", buf, 0x16u);
    }
  }
}

void __92__HMDHAPAccessory_readCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  [*(id *)(a1 + 32) begin];
  id v4 = *(void (***)(void, void))(a1 + 48);
  if (v4)
  {
    id v5 = *(NSObject **)(a1 + 40);
    if (v5)
    {
      uint64_t v6 = MEMORY[0x1E4F143A8];
      uint64_t v7 = 3221225472;
      id v8 = __92__HMDHAPAccessory_readCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_2;
      uint64_t v9 = &unk_1E6A19530;
      id v11 = v4;
      id v10 = v3;
      dispatch_async(v5, &v6);
    }
    else
    {
      ((void (**)(void, id))v4)[2](v4, v3);
    }
  }
  objc_msgSend(*(id *)(a1 + 32), "end", v6, v7, v8, v9);
  [*(id *)(a1 + 32) invalidate];
}

void __92__HMDHAPAccessory_ThreadManagement__handleUpdatedServicesForThreadManagementWithCompletion___block_invoke(uint64_t a1)
{
  id v2 = objc_alloc(MEMORY[0x1E4F653F0]);
  id v3 = NSString;
  id v4 = MEMORY[0x1D94505D0](*(void *)(a1 + 32), *(void *)(a1 + 48));
  id v5 = [v3 stringWithFormat:@"%@, %s:%ld", v4, "/Library/Caches/com.apple.xbs/Sources/HomeKit_executables_legacy/Sources/homed/HMDHAPAccessory+ThreadManagement.m", 96];
  uint64_t v6 = (void *)[v2 initWithName:v5];

  [v6 begin];
  id v7 = v6;
  [*(id *)(a1 + 32) _handleUpdatedServicesForThreadManagementWithActivity:v7];
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8) {
    (*(void (**)(void))(v8 + 16))();
  }
  __HMFActivityScopeLeave();
}

- (void)_handleUpdatedServicesForThreadManagementWithActivity:(id)a3
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  uint64_t v6 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000701-0000-1000-8000-0026BB765291"];
  id v7 = v6;
  if (v6)
  {
    uint64_t v8 = [v6 characteristics];
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __91__HMDHAPAccessory_ThreadManagement___handleUpdatedServicesForThreadManagementWithActivity___block_invoke;
    v13[3] = &unk_1E6A17618;
    void v13[4] = self;
    objc_msgSend(v8, "hmf_enumerateWithAutoreleasePoolUsingBlock:", v13);

    [(HMDAccessory *)self uuid];
    [(HMDHAPAccessory *)self internalThreadCapabilities];

    [(HMDHAPAccessory *)self internalThreadStatus];
    [(HMDHAPAccessory *)self internalThreadActive];
  }
  else
  {
    uint64_t v9 = (void *)MEMORY[0x1D9452090]();
    id v10 = self;
    id v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v12 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v15 = v12;
      _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_DEBUG, "%{public}@No thread management service found", buf, 0xCu);
    }
  }
}

- (void)populateHMDCharacteristicResponses:(id)a3 hapResponses:(id)a4 mapping:(id)a5 overallError:(id)a6 requests:(id)a7
{
  uint64_t v133 = *MEMORY[0x1E4F143B8];
  id v11 = a3;
  id v89 = a4;
  id v88 = a5;
  id v84 = a6;
  id v83 = a7;
  int v94 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithArray:");
  long long v117 = 0u;
  long long v118 = 0u;
  long long v119 = 0u;
  long long v120 = 0u;
  id v12 = v11;
  int v91 = v12;
  uint64_t v95 = [v12 countByEnumeratingWithState:&v117 objects:v132 count:16];
  if (v95)
  {
    uint64_t v92 = *(void *)v118;
    do
    {
      for (uint64_t i = 0; i != v95; ++i)
      {
        if (*(void *)v118 != v92) {
          objc_enumerationMutation(v12);
        }
        id v14 = [*(id *)(*((void *)&v117 + 1) + 8 * i) request];
        long long v113 = 0u;
        long long v114 = 0u;
        long long v115 = 0u;
        long long v116 = 0u;
        id v15 = v94;
        uint64_t v16 = [v15 countByEnumeratingWithState:&v113 objects:v131 count:16];
        if (v16)
        {
          uint64_t v17 = v16;
          uint64_t v18 = *(void *)v114;
LABEL_8:
          uint64_t v19 = 0;
          while (1)
          {
            if (*(void *)v114 != v18) {
              objc_enumerationMutation(v15);
            }
            uint64_t v20 = *(void **)(*((void *)&v113 + 1) + 8 * v19);
            char v21 = [v20 characteristic];
            id v22 = [v14 characteristic];
            char v23 = [v21 isEqual:v22];

            if (v23) {
              break;
            }
            if (v17 == ++v19)
            {
              uint64_t v17 = [v15 countByEnumeratingWithState:&v113 objects:v131 count:16];
              if (v17) {
                goto LABEL_8;
              }
              id v12 = v91;
              goto LABEL_17;
            }
          }
          id v24 = v20;

          id v12 = v91;
          if (!v24) {
            goto LABEL_18;
          }
          [v15 removeObject:v24];
          id v15 = v24;
        }
LABEL_17:

LABEL_18:
      }
      uint64_t v95 = [v12 countByEnumeratingWithState:&v117 objects:v132 count:16];
    }
    while (v95);
  }

  long long v111 = 0u;
  long long v112 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  id obj = v89;
  uint64_t v90 = [obj countByEnumeratingWithState:&v109 objects:v130 count:16];
  if (v90)
  {
    uint64_t v87 = *(void *)v110;
    do
    {
      for (uint64_t j = 0; j != v90; uint64_t j = v45 + 1)
      {
        if (*(void *)v110 != v87) {
          objc_enumerationMutation(obj);
        }
        uint64_t v93 = j;
        long long v26 = *(void **)(*((void *)&v109 + 1) + 8 * j);
        v96 = [v26 characteristic];
        long long v27 = objc_msgSend(v88, "objectForKey:");
        long long v105 = 0u;
        long long v106 = 0u;
        long long v107 = 0u;
        long long v108 = 0u;
        id v28 = v94;
        uint64_t v29 = [v28 countByEnumeratingWithState:&v105 objects:v129 count:16];
        if (v29)
        {
          uint64_t v30 = v29;
          uint64_t v31 = *(void *)v106;
          while (2)
          {
            for (uint64_t k = 0; k != v30; ++k)
            {
              if (*(void *)v106 != v31) {
                objc_enumerationMutation(v28);
              }
              char v33 = *(void **)(*((void *)&v105 + 1) + 8 * k);
              uint64_t v34 = [v33 characteristic];
              long long v35 = [v27 characteristic];
              char v36 = [v34 isEqual:v35];

              if (v36)
              {
                id v38 = v33;

                if (v38) {
                  uint64_t v37 = [v28 removeObject:v38];
                }
                goto LABEL_36;
              }
            }
            uint64_t v30 = [v28 countByEnumeratingWithState:&v105 objects:v129 count:16];
            if (v30) {
              continue;
            }
            break;
          }
        }

        id v38 = 0;
LABEL_36:
        if (v27)
        {
          uint64_t v39 = [v26 error];
          uint64_t v40 = v96;
          if (v39)
          {
            id v41 = [v26 error];
          }
          else
          {
            id v41 = v84;
          }
          uint64_t v50 = v41;
          uint64_t v45 = v93;

          BOOL v51 = +[HMDCharacteristicResponse responseWithRequest:v27 error:v50];
          BOOL v52 = [v51 request];
          v53 = [v52 characteristic];
          __int16 v54 = [v96 stateNumber];
          [v53 setStateNumber:v54];

          BOOL v55 = [v26 value];
          __int16 v56 = [v26 valueUpdatedTime];
          uint64_t v57 = [v26 stateNumber];
          BOOL v58 = [v26 notificationContext];
          [v51 setValue:v55 updatedTime:v56 stateNumber:v57 notificationContext:v58];

          [v91 addObject:v51];
        }
        else
        {
          uint64_t v42 = (void *)MEMORY[0x1D9452090](v37);
          uint64_t v43 = self;
          long long v44 = HMFGetOSLogHandle();
          uint64_t v45 = v93;
          uint64_t v40 = v96;
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            v46 = HMFGetLogIdentifier();
            id v47 = [v96 service];
            uint64_t v48 = [v47 instanceID];
            uint64_t v49 = [v96 instanceID];
            *(_DWORD *)buf = 138543874;
            v124 = v46;
            __int16 v125 = 2112;
            v126 = v48;
            __int16 v127 = 2112;
            v128 = v49;
            _os_log_impl(&dword_1D49D5000, v44, OS_LOG_TYPE_DEFAULT, "%{public}@Unable to look up HMD request for HAP characteristic %@/%@", buf, 0x20u);

            uint64_t v40 = v96;
          }
        }
      }
      uint64_t v90 = [obj countByEnumeratingWithState:&v109 objects:v130 count:16];
    }
    while (v90);
  }

  uint64_t v59 = [v94 count];
  uint64_t v60 = v84;
  if (v84)
  {
    id v61 = v91;
    v62 = HMDAudioStreamConfig;
  }
  else
  {
    id v61 = v91;
    v62 = HMDAudioStreamConfig;
    if (v59)
    {
      v63 = (void *)MEMORY[0x1D9452090]();
      v64 = self;
      uint64_t v65 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        int v66 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        v124 = v66;
        _os_log_impl(&dword_1D49D5000, v65, OS_LOG_TYPE_DEFAULT, "%{public}@Did not get all requests from device back, and not in an error state (using HMErrorCodeNotFound for missing items.).", buf, 0xCu);
      }
      uint64_t v60 = [MEMORY[0x1E4F28C58] errorWithDomain:*MEMORY[0x1E4F2D140] code:2 userInfo:0];
    }
  }
  long long v103 = 0u;
  long long v104 = 0u;
  long long v101 = 0u;
  long long v102 = 0u;
  id v67 = v94;
  uint64_t v68 = [v67 countByEnumeratingWithState:&v101 objects:v122 count:16];
  if (v68)
  {
    uint64_t v69 = v68;
    uint64_t v70 = *(void *)v102;
    do
    {
      for (uint64_t m = 0; m != v69; ++m)
      {
        if (*(void *)v102 != v70) {
          objc_enumerationMutation(v67);
        }
        id v72 = [&v62[45] responseWithRequest:*(void *)(*((void *)&v101 + 1) + 8 * m) error:v60];
        [v61 addObject:v72];
      }
      uint64_t v69 = [v67 countByEnumeratingWithState:&v101 objects:v122 count:16];
    }
    while (v69);
  }

  if ([v67 count] && !v60)
  {
    uint64_t v73 = (void *)MEMORY[0x1D9452090]();
    id v74 = self;
    id v75 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
    {
      id v76 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      v124 = v76;
      _os_log_impl(&dword_1D49D5000, v75, OS_LOG_TYPE_DEFAULT, "%{public}@Did not get all requests from device back, and not in an error state (using HMErrorCodeNotFound for missing items.).", buf, 0xCu);
    }
    uint64_t v60 = [MEMORY[0x1E4F28C58] errorWithDomain:*MEMORY[0x1E4F2D140] code:2 userInfo:0];
  }
  long long v99 = 0u;
  long long v100 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  id v77 = v67;
  uint64_t v78 = [v77 countByEnumeratingWithState:&v97 objects:v121 count:16];
  if (v78)
  {
    uint64_t v79 = v78;
    uint64_t v80 = *(void *)v98;
    do
    {
      for (uint64_t n = 0; n != v79; ++n)
      {
        if (*(void *)v98 != v80) {
          objc_enumerationMutation(v77);
        }
        v82 = [&v62[45] responseWithRequest:*(void *)(*((void *)&v97 + 1) + 8 * n) error:v60];
        [v61 addObject:v82];
      }
      uint64_t v79 = [v77 countByEnumeratingWithState:&v97 objects:v121 count:16];
    }
    while (v79);
  }
}

- (void)handleAccessoryConfigured:(id)a3
{
  id v4 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __45__HMDHAPAccessory_handleAccessoryConfigured___block_invoke;
  block[3] = &unk_1E6A19B30;
  block[4] = self;
  dispatch_async(v4, block);
}

BOOL __80__HMDHAPAccessory_enableNotificationsWithHAPAccessory_homeNotificationsEnabled___block_invoke_2(uint64_t a1, void *a2)
{
  id v2 = [a2 threshold];
  BOOL v3 = v2 != 0;

  return v3;
}

- (void)_setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 notificationChangeThresholds:(id)a5 clientIdentifier:(id)a6 matchingHAPAccessory:(id)a7
{
  BOOL v101 = a3;
  uint64_t v166 = *MEMORY[0x1E4F143B8];
  id v89 = a4;
  id v102 = a5;
  long long v100 = (__CFString *)a6;
  id v90 = a7;
  id v155 = (id)[objc_alloc(MEMORY[0x1E4F653F0]) initWithName:@"Modify characteristic notifications"];
  id v11 = (void *)MEMORY[0x1D9452090]();
  val = self;
  HMFGetOSLogHandle();
  id v12 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    HMFGetLogIdentifier();
    id v13 = (id)objc_claimAutoreleasedReturnValue();
    id v14 = [v155 identifier];
    id v15 = [v14 shortDescription];
    HMFBooleanToString();
    id v16 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v17 = [v89 shortDescription];
    uint64_t v18 = [v90 identifier];
    *(_DWORD *)buf = 138544642;
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v15;
    *(_WORD *)&buf[22] = 2112;
    uint64_t v159 = (uint64_t)v16;
    __int16 v160 = 2112;
    v161 = v17;
    __int16 v162 = 2112;
    v163 = v100;
    __int16 v164 = 2112;
    v165 = v18;
    _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Setting notifications enabled to %@ for characteristics: %@ client identifier: %@  matching HAP accessory: %@", buf, 0x3Eu);
  }
  if (![v89 count])
  {
    long long v26 = (void *)MEMORY[0x1D9452090]();
    long long v27 = val;
    HMFGetOSLogHandle();
    id v28 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
    {
      HMFGetLogIdentifier();
      id v29 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v30 = [v155 identifier];
      uint64_t v31 = [v30 shortDescription];
      *(_DWORD *)buf = 138543874;
      *(void *)&uint8_t buf[4] = v29;
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v31;
      *(_WORD *)&buf[22] = 2112;
      uint64_t v159 = (uint64_t)v100;
      _os_log_impl(&dword_1D49D5000, v28, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] No characteristics to update notification for client: %@", buf, 0x20u);
    }
    goto LABEL_61;
  }
  id v88 = [(HMDAccessory *)val home];
  v82 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v89, "count"));
  uint64_t v19 = [MEMORY[0x1E4F28E10] strongToStrongObjectsMapTable];
  id v154 = 0;
  id v153 = 0;
  id v152 = 0;
  id v151 = 0;
  id v150 = v19;
  [(HMDHAPAccessory *)val _groupCharacteristicsNotificationWithCharacteristics:v89 enable:v101 activity:v155 clientIdentifier:v100 groupCharacteristicsError:&v154 characteristicsToModifyLocally:&v153 characteristicsToModifyOnResident:&v152 characteristicsToDisableOnResident:&v151 characteristicsErrorsMapFailingToModify:&v150];
  uint64_t v87 = (__CFString *)v154;
  id v85 = v153;
  id v86 = v152;
  id v84 = v151;
  id v83 = v150;

  if (!v87)
  {
    if ([v86 count])
    {
      id v32 = (void *)MEMORY[0x1D9452090]();
      char v33 = val;
      HMFGetOSLogHandle();
      uint64_t v34 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
      {
        HMFGetLogIdentifier();
        id v35 = (id)objc_claimAutoreleasedReturnValue();
        char v36 = [v155 identifier];
        uint64_t v37 = [v36 shortDescription];
        uint64_t v38 = [v86 count];
        *(_DWORD *)buf = 138544130;
        *(void *)&uint8_t buf[4] = v35;
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v37;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v159 = v38;
        __int16 v160 = 2112;
        v161 = v100;
        _os_log_impl(&dword_1D49D5000, v34, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Modifying %tu notifications on remote gateway for client: %@", buf, 0x2Au);
      }
      [v88 remotelySetNotificationsEnabled:v101 forCharacteristics:v86 characteristicChangeThresholds:v102];
    }
    if ([v84 count])
    {
      uint64_t v39 = (void *)MEMORY[0x1D9452090]();
      uint64_t v40 = val;
      HMFGetOSLogHandle();
      id v41 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
      {
        HMFGetLogIdentifier();
        id v42 = (id)objc_claimAutoreleasedReturnValue();
        uint64_t v43 = [v155 identifier];
        long long v44 = [v43 shortDescription];
        uint64_t v45 = [v84 count];
        *(_DWORD *)buf = 138544130;
        *(void *)&uint8_t buf[4] = v42;
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v44;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v159 = v45;
        __int16 v160 = 2112;
        v161 = v100;
        _os_log_impl(&dword_1D49D5000, v41, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Disabling %tu notifications on remote gateway for client: %@", buf, 0x2Au);
      }
      [v88 remotelySetNotificationsEnabled:0 forCharacteristics:v84 characteristicChangeThresholds:0];
    }
    if (shouldSkipLocalAccessoryNotificationRegistration(v88, val, v89))
    {
      v46 = (void *)MEMORY[0x1D9452090]();
      id v47 = val;
      HMFGetOSLogHandle();
      uint64_t v48 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
      {
        HMFGetLogIdentifier();
        id v49 = (id)objc_claimAutoreleasedReturnValue();
        uint64_t v50 = [v155 identifier];
        BOOL v51 = [v50 shortDescription];
        BOOL v52 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v89, "count"));
        if (v101) {
          v53 = @"Enabling";
        }
        else {
          v53 = @"Disabling";
        }
        objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v84, "count"));
        __int16 v54 = (__CFString *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138544642;
        *(void *)&uint8_t buf[4] = v49;
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v51;
        *(_WORD *)&buf[22] = 2112;
        uint64_t v159 = (uint64_t)v52;
        __int16 v160 = 2112;
        v161 = v53;
        __int16 v162 = 2112;
        v163 = v54;
        __int16 v164 = 2112;
        v165 = v100;
        _os_log_impl(&dword_1D49D5000, v48, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Not modifying local notifications for %@ characteristics. %@ %@ characteristics notifications for client: %@ via primary", buf, 0x3Eu);
      }
      v146[0] = MEMORY[0x1E4F143A8];
      v146[1] = 3221225472;
      v146[2] = __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke;
      v146[3] = &unk_1E6A0B308;
      BOOL v149 = v101;
      v147 = v100;
      id v148 = v102;
      objc_msgSend(v86, "na_each:", v146);
      [(HMDHAPAccessory *)v47 _notifyClientsWithNotificationChangesForCharacteristics:v86 characteristicErrors:v83 enableNotification:v101 message:0];
    }
    if (v101 && [(__CFString *)v100 hasPrefix:@"com.apple.HomeKitDaemon"])
    {
      long long v144 = 0u;
      long long v145 = 0u;
      long long v142 = 0u;
      long long v143 = 0u;
      id obj = v85;
      uint64_t v55 = [obj countByEnumeratingWithState:&v142 objects:v157 count:16];
      if (v55)
      {
        uint64_t v95 = *(void *)v143;
        do
        {
          uint64_t v97 = v55;
          for (uint64_t i = 0; i != v97; ++i)
          {
            if (*(void *)v143 != v95) {
              objc_enumerationMutation(obj);
            }
            uint64_t v57 = *(void **)(*((void *)&v142 + 1) + 8 * i);
            BOOL v58 = (void *)MEMORY[0x1D9452090]();
            uint64_t v59 = val;
            HMFGetOSLogHandle();
            uint64_t v60 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
            {
              HMFGetLogIdentifier();
              id v61 = (id)objc_claimAutoreleasedReturnValue();
              v62 = [v155 identifier];
              v63 = [v62 shortDescription];
              HMFBooleanToString();
              id v64 = (id)objc_claimAutoreleasedReturnValue();
              uint64_t v65 = [v57 shortDescription];
              *(_DWORD *)buf = 138544386;
              *(void *)&uint8_t buf[4] = v61;
              *(_WORD *)&buf[12] = 2114;
              *(void *)&buf[14] = v63;
              *(_WORD *)&buf[22] = 2112;
              uint64_t v159 = (uint64_t)v64;
              __int16 v160 = 2112;
              v161 = v65;
              __int16 v162 = 2112;
              v163 = v100;
              _os_log_impl(&dword_1D49D5000, v60, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Marking the notification change (%@) before actually doing it in the accessory for characteristic %@ for client %@", buf, 0x34u);
            }
            v141[0] = MEMORY[0x1E4F143A8];
            v141[1] = 3221225472;
            v141[2] = __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_632;
            v141[3] = &unk_1E6A0B2E0;
            v141[4] = v57;
            int v66 = objc_msgSend(v102, "na_firstObjectPassingTest:", v141);
            id v67 = [v66 threshold];
            [v57 setNotificationEnabled:1 forClientIdentifier:v100 changeThreshold:v67];
          }
          uint64_t v55 = [obj countByEnumeratingWithState:&v142 objects:v157 count:16];
        }
        while (v55);
      }
    }
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    LOBYTE(v159) = 0;
    LOBYTE(v159) = [v85 count] == 0;
    uint64_t v137 = 0;
    v138 = &v137;
    uint64_t v139 = 0x2020000000;
    char v140 = 0;
    dispatch_group_t v68 = dispatch_group_create();
    objc_initWeak(&location, val);
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_2_633;
    aBlock[3] = &unk_1E6A0B358;
    id obja = v85;
    id v127 = obja;
    BOOL v135 = v101;
    uint64_t v69 = v100;
    v128 = v69;
    v129 = val;
    id v130 = v155;
    dispatch_group_t group = v68;
    dispatch_group_t v131 = group;
    objc_copyWeak(&v134, &location);
    uint64_t v133 = buf;
    id v81 = v82;
    id v132 = v81;
    int v91 = _Block_copy(aBlock);
    __int16 v125 = 0;
    for (uint64_t j = [(HMDHAPAccessory *)val preferredHAPAccessoryForOperation:4 linkType:&v125];
    {
      if (![obja count] || !v125)
      {
LABEL_59:
        uint64_t v80 = [(HMDAccessory *)val workQueue];
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_638;
        block[3] = &unk_1E6A0B380;
        objc_copyWeak(&v112, &location);
        long long v110 = buf;
        id v104 = v83;
        id v105 = v81;
        BOOL v113 = v101;
        long long v106 = v69;
        long long v111 = &v137;
        id v107 = obja;
        id v108 = v155;
        id v109 = v102;
        dispatch_group_notify(group, v80, block);

        [(HMDHAPAccessory *)val _checkHAPSessionRestore];
        objc_destroyWeak(&v112);

        objc_destroyWeak(&v134);
        objc_destroyWeak(&location);

        _Block_object_dispose(&v137, 8);
        _Block_object_dispose(buf, 8);
        goto LABEL_60;
      }
      dispatch_group_enter(group);
      v96 = [j server];
      if (v96)
      {
        if (![j isReachable]) {
          goto LABEL_45;
        }
        if (v90)
        {
          if (objc_msgSend(j, "isEqual:"))
          {
            (*((void (**)(void *, void *, void *))v91 + 2))(v91, j, v96);

            goto LABEL_59;
          }
LABEL_45:
          dispatch_group_leave(group);
          goto LABEL_57;
        }
        (*((void (**)(void *, void *, void *))v91 + 2))(v91, j, v96);
      }
      else
      {
        uint64_t v70 = v125;
        if (v125 == (void *)2)
        {
          long long v123 = 0u;
          long long v124 = 0u;
          long long v121 = 0u;
          long long v122 = 0u;
          id v71 = obja;
          uint64_t v72 = [v71 countByEnumeratingWithState:&v121 objects:v156 count:16];
          if (v72)
          {
            uint64_t v73 = *(void *)v122;
            do
            {
              for (uint64_t k = 0; k != v72; ++k)
              {
                if (*(void *)v122 != v73) {
                  objc_enumerationMutation(v71);
                }
                id v75 = *(void **)(*((void *)&v121 + 1) + 8 * k);
                v120[0] = MEMORY[0x1E4F143A8];
                v120[1] = 3221225472;
                v120[2] = __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_636;
                v120[3] = &unk_1E6A0B2E0;
                v120[4] = v75;
                id v76 = objc_msgSend(v102, "na_firstObjectPassingTest:", v120);
                id v77 = [v76 threshold];
                [v75 setNotificationEnabled:v101 forClientIdentifier:v69 changeThreshold:v77];
              }
              uint64_t v72 = [v71 countByEnumeratingWithState:&v121 objects:v156 count:16];
            }
            while (v72);
          }

          *((unsigned char *)v138 + 24) = 1;
          dispatch_group_leave(group);
          [(HMDHAPAccessory *)val _updateAccessoryTracking];
        }
        else
        {
          uint64_t v78 = [(HMDAccessory *)val workQueue];
          v114[0] = MEMORY[0x1E4F143A8];
          v114[1] = 3221225472;
          v114[2] = __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_2_637;
          v114[3] = &unk_1E6A16B30;
          objc_copyWeak(v119, &location);
          id v115 = v155;
          long long v116 = group;
          v119[1] = v125;
          id v117 = v90;
          id v118 = v91;
          [v88 retrieveHAPAccessoryForHMDAccessory:val linkType:v70 forceRetrieve:0 queue:v78 completion:v114];

          objc_destroyWeak(v119);
        }
      }
LABEL_57:
      uint64_t v79 = [(HMDHAPAccessory *)val preferredHAPAccessoryForOperation:4 linkType:&v125];
    }
  }
  uint64_t v20 = (void *)MEMORY[0x1D9452090]();
  char v21 = val;
  HMFGetOSLogHandle();
  id v22 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
  {
    HMFGetLogIdentifier();
    id v23 = (id)objc_claimAutoreleasedReturnValue();
    id v24 = [v155 identifier];
    long long v25 = [v24 shortDescription];
    *(_DWORD *)buf = 138544130;
    *(void *)&uint8_t buf[4] = v23;
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v25;
    *(_WORD *)&buf[22] = 2112;
    uint64_t v159 = (uint64_t)v100;
    __int16 v160 = 2112;
    v161 = v87;
    _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] No characteristics to update notification for client: %@ due to %@", buf, 0x2Au);
  }
LABEL_60:

LABEL_61:
  __HMFActivityScopeLeave();
}

- (void)_setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 hapAccessory:(id)a5 activity:(id)a6 completion:(id)a7
{
  BOOL v10 = a3;
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  id v51 = a4;
  id v12 = a5;
  id v53 = a6;
  id v52 = a7;
  id v13 = (void *)MEMORY[0x1D9452090]();
  id v14 = self;
  id v15 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
  {
    id v16 = HMFGetLogIdentifier();
    uint64_t v17 = [v53 identifier];
    uint64_t v18 = [v17 shortDescription];
    *(_DWORD *)buf = 138543618;
    v63 = v16;
    __int16 v64 = 2114;
    uint64_t v65 = v18;
    _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Modifying characteristic notifications on HAPAccessory", buf, 0x16u);
  }
  if ([(HMDHAPAccessory *)v14 canWakeUpViaWoL] && [(HMDHAPAccessory *)v14 isSuspended])
  {
    uint64_t v19 = (void *)MEMORY[0x1D9452090]();
    uint64_t v20 = v14;
    char v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      id v22 = HMFGetLogIdentifier();
      id v23 = [v53 identifier];
      id v24 = [v23 shortDescription];
      long long v25 = [(HMDAccessory *)v20 identifier];
      *(_DWORD *)buf = 138543874;
      v63 = v22;
      __int16 v64 = 2114;
      uint64_t v65 = v24;
      __int16 v66 = 2112;
      id v67 = v25;
      _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Not modifying characteristic notifications because accessory is suspended: %@", buf, 0x20u);
    }
    (*((void (**)(id, void, void))v52 + 2))(v52, MEMORY[0x1E4F1CBF0], 0);
  }
  else
  {
    long long v26 = [MEMORY[0x1E4F1CA48] array];
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    id v27 = v51;
    uint64_t v28 = [v27 countByEnumeratingWithState:&v58 objects:v70 count:16];
    if (v28)
    {
      uint64_t v29 = *(void *)v59;
      while (2)
      {
        for (uint64_t i = 0; i != v28; ++i)
        {
          if (*(void *)v59 != v29) {
            objc_enumerationMutation(v27);
          }
          uint64_t v31 = *(void **)(*((void *)&v58 + 1) + 8 * i);
          id v32 = [v31 characteristicForHAPAccessory:v12];
          if (!v32)
          {
            context = (void *)MEMORY[0x1D9452090]();
            id v35 = v14;
            char v36 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            {
              id v49 = HMFGetLogIdentifier();
              uint64_t v37 = [v53 identifier];
              uint64_t v38 = [v37 shortDescription];
              uint64_t v39 = [v12 server];
              uint64_t v40 = [v39 identifier];
              *(_DWORD *)buf = 138544130;
              v63 = v49;
              __int16 v64 = 2114;
              uint64_t v65 = v38;
              __int16 v66 = 2112;
              id v67 = v31;
              __int16 v68 = 2112;
              uint64_t v69 = v40;
              _os_log_impl(&dword_1D49D5000, v36, OS_LOG_TYPE_ERROR, "%{public}@[%{public}@] Failed to modify characteristic notifications: cannot map %@ to a HAPCharacteristic for server %@", buf, 0x2Au);
            }
            id v41 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
            (*((void (**)(id, void, void *))v52 + 2))(v52, 0, v41);

            char v33 = v27;
            goto LABEL_23;
          }
          [v26 addObject:v32];
        }
        uint64_t v28 = [v27 countByEnumeratingWithState:&v58 objects:v70 count:16];
        if (v28) {
          continue;
        }
        break;
      }
    }

    char v33 = [v12 server];
    if (v33)
    {
      objc_initWeak((id *)buf, v14);
      v54[0] = MEMORY[0x1E4F143A8];
      v54[1] = 3221225472;
      v54[2] = __96__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_hapAccessory_activity_completion___block_invoke;
      v54[3] = &unk_1E6A0F760;
      objc_copyWeak(&v57, (id *)buf);
      id v55 = v53;
      id v56 = v52;
      uint64_t v34 = [(HMDAccessory *)v14 workQueue];
      [v33 enableEvents:v10 forCharacteristics:v26 withCompletionHandler:v54 queue:v34];

      if ([v33 linkType] == 2) {
        [(HMDHAPAccessory *)v14 _enableBroadcastNotifications:v10 hapAccessory:v12 forCharacteristics:v27];
      }

      objc_destroyWeak(&v57);
      objc_destroyWeak((id *)buf);
    }
    else
    {
      id v42 = (void *)MEMORY[0x1D9452090]();
      uint64_t v43 = v14;
      long long v44 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        uint64_t v45 = HMFGetLogIdentifier();
        v46 = [v53 identifier];
        id v47 = [v46 shortDescription];
        *(_DWORD *)buf = 138543874;
        v63 = v45;
        __int16 v64 = 2114;
        uint64_t v65 = v47;
        __int16 v66 = 2112;
        id v67 = v12;
        _os_log_impl(&dword_1D49D5000, v44, OS_LOG_TYPE_ERROR, "%{public}@[%{public}@] Failed to modify characteristic notifications: no server found for HAPAccessory: %@", buf, 0x20u);
      }
      uint64_t v48 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
      (*((void (**)(id, void, void *))v52 + 2))(v52, 0, v48);

      char v33 = 0;
    }
LABEL_23:
  }
}

- (void)_updateAccessoryTracking
{
  if ([(HMDHAPAccessory *)self hasBTLELink])
  {
    unsigned __int8 v7 = 0;
    BOOL v3 = [(HMDHAPAccessory *)self _shouldTrackAccessoryWithPriority:&v7];
    id v4 = [(HMDAccessory *)self home];
    id v5 = [v4 accessoryBrowser];
    uint64_t v6 = [v5 accessoryBrowserHapProtocol];
    [v6 configureAccessory:self trackState:v3 connectionPriority:v7];
  }
}

- (void)configureCHIPAccessory
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if ([(HMDHAPAccessory *)self supportsCHIP])
  {
    BOOL v3 = [(HMDHAPAccessory *)self chipAccessoryServer];
    id v4 = (void *)MEMORY[0x1D9452090]();
    id v5 = self;
    uint64_t v6 = HMFGetOSLogHandle();
    unsigned __int8 v7 = v6;
    if (v3)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        uint64_t v8 = HMFGetLogIdentifier();
        [(HMDHAPAccessory *)v5 isPrimary];
        uint64_t v9 = HMFBooleanToString();
        *(_DWORD *)buf = 138543618;
        uint64_t v19 = v8;
        __int16 v20 = 2112;
        char v21 = v9;
        _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Configuring CHIP accessory (isPrimary: %@)", buf, 0x16u);
      }
      if ([(HMDHAPAccessory *)v5 isPrimary]) {
        [v3 setChipDelegate:v5];
      }
      BOOL v10 = [(HMDAccessory *)v5 home];
      if ([v10 isCurrentDevicePrimaryResident])
      {
        id v11 = [MEMORY[0x1E4F28EB8] defaultCenter];
        [v11 removeObserver:v5 name:@"HMDHomeNameChangedNotification" object:v10];

        id v12 = [MEMORY[0x1E4F28EB8] defaultCenter];
        [v12 addObserver:v5 selector:sel__handleHomeNameChangedNotification_ name:@"HMDHomeNameChangedNotification" object:v10];
      }
      if ([(HMDHAPAccessory *)v5 isPrimary])
      {
        id v13 = [(HMDHAPAccessory *)v5 chipStorage];
        id v14 = [v13 pairings];

        if (!v14)
        {
          id v15 = [v10 name];
          v17[0] = MEMORY[0x1E4F143A8];
          v17[1] = 3221225472;
          v17[2] = __47__HMDHAPAccessory_CHIP__configureCHIPAccessory__block_invoke;
          v17[3] = &unk_1E6A197F0;
          v17[4] = v5;
          [(HMDHAPAccessory *)v5 _updateCHIPAccessoryWithFabricLabel:v15 completionHandler:v17];
        }
      }
    }
    else
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        id v16 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v19 = v16;
        _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_ERROR, "%{public}@Could not find CHIP accessory server to set up CHIP accessory", buf, 0xCu);
      }
    }
  }
}

- (BOOL)supportsCHIP
{
  return [(HMDHAPAccessory *)self communicationProtocol] == 2;
}

- (void)_checkHAPSessionRestore
{
  BOOL v3 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v3);

  [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000701-0000-1000-8000-0026BB765291"];
  if (objc_claimAutoreleasedReturnValue() || [(HMDHAPAccessory *)self hasBTLELink])
  {
    MEMORY[0x1F41817F8]();
  }
  else if ([(HMDHAPAccessory *)self communicationProtocol] != 2)
  {
    id v4 = [(HMDHAPAccessory *)self bridge];

    if (v4)
    {
      [(HMDHAPAccessory *)self _deregisterFromSessionRestore:@"accessorySession-Primary"];
    }
    else
    {
      id v5 = [(HMDAccessory *)self home];
      if ([v5 isCurrentDeviceConfirmedPrimaryResident]) {
        [(HMDHAPAccessory *)self _registerForSessionRestore:@"accessorySession-Primary"];
      }
      else {
        [(HMDHAPAccessory *)self _deregisterFromSessionRestore:@"accessorySession-Primary"];
      }
    }
  }
}

- (BOOL)hasIPLink
{
  if ([(HMDHAPAccessory *)self communicationProtocol] == 2)
  {
    return [(HMDHAPAccessory *)self hasIPServer];
  }
  else
  {
    id v4 = [(HMDHAPAccessory *)self transportInformationInstances];
    char v5 = objc_msgSend(v4, "na_any:", &__block_literal_global_424);

    return v5;
  }
}

- (BOOL)hasBTLELink
{
  if ([(HMDHAPAccessory *)self communicationProtocol] == 2)
  {
    return [(HMDHAPAccessory *)self hasBLEServer];
  }
  else
  {
    id v4 = [(HMDHAPAccessory *)self transportInformationInstances];
    char v5 = objc_msgSend(v4, "na_any:", &__block_literal_global_429);

    return v5;
  }
}

- (int64_t)communicationProtocol
{
  os_unfair_recursive_lock_lock_with_options();
  int64_t communicationProtocol = self->_communicationProtocol;
  os_unfair_recursive_lock_unlock();
  return communicationProtocol;
}

- (void)_deregisterFromSessionRestore:(id)a3
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  char v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  uint64_t v6 = (void *)MEMORY[0x1D9452090]();
  unsigned __int8 v7 = self;
  uint64_t v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v9 = HMFGetLogIdentifier();
    BOOL v10 = [(HMDHAPAccessory *)v7 currentActiveSessionRestoreClients];
    int v22 = 138543874;
    id v23 = v9;
    __int16 v24 = 2112;
    id v25 = v4;
    __int16 v26 = 2048;
    uint64_t v27 = [v10 count];
    _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Session Restore deregistration for accessory for client %@ count %lu", (uint8_t *)&v22, 0x20u);
  }
  os_unfair_recursive_lock_lock_with_options();
  id v11 = [(HMDHAPAccessory *)v7 activeSessionRestoreClients];
  BOOL v12 = [v11 count] == 0;

  if (v12)
  {
    os_unfair_recursive_lock_unlock();
  }
  else
  {
    id v13 = [(HMDHAPAccessory *)v7 activeSessionRestoreClients];
    [v13 removeObject:v4];

    os_unfair_recursive_lock_unlock();
    uint64_t v14 = HAPAccessoryServerSessionTypesFromString();
    if (v14) {
      [(HMDHAPAccessory *)v7 removeSession:v14];
    }
    id v15 = [(HMDHAPAccessory *)v7 currentActiveSessionRestoreClients];
    BOOL v16 = [v15 count] == 0;

    if (v16)
    {
      [(HMDHAPAccessory *)v7 _stopSessionMonitor];
    }
    else
    {
      uint64_t v17 = (void *)MEMORY[0x1D9452090]();
      uint64_t v18 = v7;
      uint64_t v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        __int16 v20 = HMFGetLogIdentifier();
        char v21 = [(HMDHAPAccessory *)v18 currentActiveSessionRestoreClients];
        int v22 = 138543618;
        id v23 = v20;
        __int16 v24 = 2112;
        id v25 = v21;
        _os_log_impl(&dword_1D49D5000, v19, OS_LOG_TYPE_DEBUG, "%{public}@Session Restore continuing to monitor accessory as with registered clients %@", (uint8_t *)&v22, 0x16u);
      }
    }
  }
}

- (NSMutableSet)activeSessionRestoreClients
{
  os_unfair_lock_assert_owner((const os_unfair_lock *)&self->super._lock);
  activeSessionRestoreClients = self->_activeSessionRestoreClients;
  return activeSessionRestoreClients;
}

void __121__HMDHAPAccessory__readCharacteristicValues_localOperationRequired_source_message_logEvent_completionHandler_errorBlock___block_invoke(uint64_t a1)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  char v89 = 0;
  uint64_t v88 = 5;
  v1 = (id *)(a1 + 32);
  uint64_t v65 = [*(id *)(a1 + 32) home];
  id v2 = [*v1 identifier];
  id v86 = 0;
  id v87 = 0;
  [v65 retrieveStateForTrackedAccessory:v2 stateNumber:&v87 isReachable:&v89 linkQuality:&v88 lastSeen:&v86];
  id v63 = v87;
  id v64 = v86;

  BOOL v3 = (void *)MEMORY[0x1D9452090]();
  id v4 = *v1;
  char v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = HMFGetLogIdentifier();
    unsigned __int8 v7 = HMFBooleanToString();
    [*(id *)(a1 + 32) isSuspended];
    uint64_t v8 = HMFBooleanToString();
    uint64_t v9 = v88;
    [v64 doubleValue];
    uint64_t v11 = v10;
    BOOL v12 = HMFBooleanToString();
    id v13 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 40), "count"));
    uint64_t v14 = [*(id *)(a1 + 48) shortDescription];
    *(_DWORD *)buf = 138545410;
    uint64_t v93 = v6;
    __int16 v94 = 2112;
    uint64_t v95 = (uint64_t)v7;
    __int16 v96 = 2112;
    uint64_t v97 = v8;
    __int16 v98 = 2112;
    id v99 = v63;
    __int16 v100 = 2048;
    uint64_t v101 = v9;
    __int16 v102 = 2048;
    uint64_t v103 = v11;
    __int16 v104 = 2112;
    id v105 = v12;
    __int16 v106 = 2112;
    id v107 = v13;
    __int16 v108 = 2112;
    id v109 = v14;
    _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Retrieved accessory: Reachable(%@) / Suspended(%@) / S#(%@) / LQ(%ld) / Seen(%.3fs) / Local(%@) for read requests (%@). %@", buf, 0x5Cu);
  }
  __int16 v66 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(*(id *)(a1 + 40), "count"));
  uint64_t v85 = 0;
  id v15 = (id)[*(id *)(a1 + 32) preferredHAPAccessoryForOperation:2 linkType:&v85];
  long long v83 = 0u;
  long long v84 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  id v16 = *(id *)(a1 + 40);
  uint64_t v17 = 0;
  uint64_t v18 = [v16 countByEnumeratingWithState:&v81 objects:v91 count:16];
  if (v18)
  {
    uint64_t v19 = *(void *)v82;
    do
    {
      for (uint64_t i = 0; i != v18; ++i)
      {
        if (*(void *)v82 != v19) {
          objc_enumerationMutation(v16);
        }
        char v21 = *(void **)(*((void *)&v81 + 1) + 8 * i);
        int v22 = [v21 characteristic];
        id v23 = [v22 stateNumber];
        BOOL v24 = HAPCompareStateNumberWithRollover() == 1;

        if (v24)
        {
          uint64_t v25 = [v22 stateNumber];

          uint64_t v17 = (void *)v25;
        }
        if ([*(id *)(a1 + 32) hasValidCachedValueForCharacteristic:v22 shouldLog:1])
        {
          [*(id *)(a1 + 32) autoUpdateCachedCountDownCharacteristics:v22];
          __int16 v26 = +[HMDCharacteristicResponse responseWithRequest:v21 error:0];
          uint64_t v27 = [v22 value];
          [v26 setValue:v27];

          [v66 addObject:v26];
        }
      }
      uint64_t v18 = [v16 countByEnumeratingWithState:&v81 objects:v91 count:16];
    }
    while (v18);
  }

  uint64_t v28 = [v66 count];
  if (v28 == [*(id *)(a1 + 40) count])
  {
    uint64_t v29 = (void *)MEMORY[0x1D9452090]();
    id v30 = *(id *)(a1 + 32);
    uint64_t v31 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      id v32 = HMFGetLogIdentifier();
      uint64_t v33 = [v66 count];
      uint64_t v34 = [*(id *)(a1 + 48) shortDescription];
      *(_DWORD *)buf = 138543874;
      uint64_t v93 = v32;
      __int16 v94 = 2048;
      uint64_t v95 = v33;
      __int16 v96 = 2112;
      uint64_t v97 = v34;
      _os_log_impl(&dword_1D49D5000, v31, OS_LOG_TYPE_DEFAULT, "%{public}@Returning Cached values, No more HAP characteristics (out of %tu) left to be read. %@", buf, 0x20u);
    }
    id v35 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(*(id *)(a1 + 40), "count"));
    char v36 = [MEMORY[0x1E4F1CA48] array];
    long long v79 = 0u;
    long long v80 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    id v37 = *(id *)(a1 + 40);
    uint64_t v38 = [v37 countByEnumeratingWithState:&v77 objects:v90 count:16];
    if (v38)
    {
      uint64_t v39 = *(void *)v78;
      do
      {
        for (uint64_t j = 0; j != v38; ++j)
        {
          if (*(void *)v78 != v39) {
            objc_enumerationMutation(v37);
          }
          id v41 = *(void **)(*((void *)&v77 + 1) + 8 * j);
          id v42 = [v41 characteristic];
          BOOL v43 = v42 == 0;

          if (v43)
          {
            [v36 addObject:v41];
          }
          else
          {
            long long v44 = [v41 characteristic];
            [v35 addObject:v44];
          }
        }
        uint64_t v38 = [v37 countByEnumeratingWithState:&v77 objects:v90 count:16];
      }
      while (v38);
    }

    if ([v36 count])
    {
      uint64_t v45 = (void *)MEMORY[0x1D9452090]();
      id v46 = *(id *)(a1 + 32);
      id v47 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        uint64_t v48 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        uint64_t v93 = v48;
        __int16 v94 = 2112;
        uint64_t v95 = (uint64_t)v36;
        _os_log_impl(&dword_1D49D5000, v47, OS_LOG_TYPE_ERROR, "%{public}@Invalid read requests with missing characteristic: %@", buf, 0x16u);
      }
    }
    id v49 = *(void **)(a1 + 56);
    if (v49)
    {
      id v50 = v49;
      [v50 setIsCached:1];
      [v50 setIsLocal:1];
    }
    else
    {
      uint64_t v51 = *(void *)(a1 + 32);
      uint64_t v52 = *(void *)(a1 + 88);
      id v53 = [*(id *)(a1 + 48) clientIdentifier];
      __int16 v54 = [*(id *)(a1 + 48) userForHome:v65];
      id v55 = [v54 uuid];
      LOBYTE(v62) = 1;
      id v50 = +[HMDCharacteristicReadWriteLogEvent eventWithCharacteristicsToRead:v35 hmdAccessory:v51 hapAccessory:0 source:v52 isLocal:1 transactionId:0 isCached:v62 bundleId:v53 userUUID:v55];
    }
    [*(id *)(a1 + 32) submitLogEvent:v50 error:0];
    uint64_t v56 = *(void *)(a1 + 72);
    if (v56)
    {
      (*(void (**)(uint64_t, void *))(v56 + 16))(v56, v66);

      goto LABEL_41;
    }
  }
  int v57 = *(unsigned __int8 *)(a1 + 96);
  objc_initWeak((id *)buf, *(id *)(a1 + 32));
  [*(id *)(a1 + 64) markWithReason:@"Evaluating"];
  if (v57) {
    uint64_t v58 = 10;
  }
  else {
    uint64_t v58 = 2;
  }
  long long v59 = *(void **)(a1 + 32);
  v68[0] = MEMORY[0x1E4F143A8];
  v68[1] = 3221225472;
  v68[2] = __121__HMDHAPAccessory__readCharacteristicValues_localOperationRequired_source_message_logEvent_completionHandler_errorBlock___block_invoke_525;
  v68[3] = &unk_1E6A0B0D8;
  objc_copyWeak(v75, (id *)buf);
  id v69 = *(id *)(a1 + 64);
  char v76 = *(unsigned char *)(a1 + 96);
  id v70 = *(id *)(a1 + 40);
  id v71 = *(id *)(a1 + 48);
  v75[1] = (id)v58;
  id v60 = *(id *)(a1 + 80);
  long long v61 = *(void **)(a1 + 88);
  id v73 = v60;
  v75[2] = v61;
  id v72 = *(id *)(a1 + 56);
  id v74 = *(id *)(a1 + 72);
  [v59 _evaluateLocalOperation:2 state:v17 completion:v68];

  objc_destroyWeak(v75);
  objc_destroyWeak((id *)buf);
LABEL_41:
}

- (BOOL)hasValidCachedValueForCharacteristic:(id)a3 shouldLog:(BOOL)a4
{
  BOOL v4 = a4;
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  BOOL v35 = [(HMDAccessory *)self isReachable];
  uint64_t v34 = 0;
  id v7 = [(HMDHAPAccessory *)self preferredHAPAccessoryForOperation:2 linkType:&v34];
  if (v34 != 2 && ([(HMDHAPAccessory *)self reachableTransports] & 2) == 0)
  {
    LOBYTE(v8) = 0;
    id v9 = 0;
    id v10 = 0;
    goto LABEL_10;
  }
  uint64_t v11 = [(HMDAccessory *)self home];
  BOOL v12 = [(HMDAccessory *)self identifier];
  id v32 = 0;
  id v33 = 0;
  [v11 retrieveStateForTrackedAccessory:v12 stateNumber:&v33 isReachable:&v35 linkQuality:0 lastSeen:&v32];
  id v9 = v33;
  id v10 = v32;

  if (!v35 || ([v6 value], (uint64_t v13 = objc_claimAutoreleasedReturnValue()) == 0))
  {
LABEL_9:
    LOBYTE(v8) = 0;
    goto LABEL_10;
  }
  uint64_t v14 = (void *)v13;
  id v15 = [v6 stateNumber];
  if (!v15 || [v6 shouldIgnoreCacheValueForRead])
  {

    goto LABEL_9;
  }
  uint64_t v17 = [v6 stateNumber];
  LODWORD(v8) = HMFEqualObjects();

  if (v4 && v8)
  {
    uint64_t v18 = (void *)MEMORY[0x1D9452090]();
    uint64_t v19 = self;
    uint64_t v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v31 = HMFGetLogIdentifier();
      id v30 = [v6 value];
      uint64_t v28 = [v6 characteristicType];
      __int16 v20 = HAPShortUUIDType();
      char v21 = [v6 instanceID];
      [v6 stateNumber];
      int v22 = v29 = v18;
      id v23 = [v6 lastKnownValue];
      [v6 lastKnownValueUpdateTime];
      BOOL v24 = v27 = v19;
      uint64_t v25 = HMFBooleanToString();
      [v10 doubleValue];
      *(_DWORD *)buf = 138545666;
      id v37 = v31;
      __int16 v38 = 2112;
      uint64_t v39 = v30;
      __int16 v40 = 2112;
      id v41 = v20;
      __int16 v42 = 2112;
      BOOL v43 = v21;
      __int16 v44 = 2112;
      uint64_t v45 = v22;
      __int16 v46 = 2112;
      id v47 = v23;
      __int16 v48 = 2112;
      id v49 = v24;
      __int16 v50 = 2112;
      id v51 = v9;
      __int16 v52 = 2112;
      id v53 = v25;
      __int16 v54 = 2048;
      uint64_t v55 = v26;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Valid cached value %@ for characteristic: %@/%@/%@/%@/%@ for Accessory: S#(%@)/R(%@)/T(%.3fs)", buf, 0x66u);

      uint64_t v19 = v27;
      uint64_t v18 = v29;
    }
    LOBYTE(v8) = 1;
  }
LABEL_10:

  return (char)v8;
}

- (BOOL)isSuspended
{
  return [(HMDHAPAccessory *)self suspendedState] == 3;
}

- (void)updateLightProfilesSettings
{
  BOOL v3 = [(HMDHAPAccessory *)self lightProfiles];
  objc_msgSend(v3, "na_filter:", &__block_literal_global_4_128852);
  id v5 = (id)objc_claimAutoreleasedReturnValue();

  BOOL v4 = [(HMDAccessory *)self home];
  [v4 updateLightProfilesSettings:v5];
}

- (id)runtimeState
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  v17.receiver = self;
  v17.super_class = (Class)HMDHAPAccessory;
  BOOL v3 = [(HMDAccessory *)&v17 runtimeState];
  BOOL v4 = (void *)[v3 mutableCopy];

  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v5 = [(HMDAccessory *)self accessoryProfiles];
  uint64_t v6 = [v5 countByEnumeratingWithState:&v13 objects:v18 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v14;
    do
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v14 != v8) {
          objc_enumerationMutation(v5);
        }
        id v10 = [*(id *)(*((void *)&v13 + 1) + 8 * i) runtimeState];
        if ([v10 count]) {
          [v4 addEntriesFromDictionary:v10];
        }
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v13 objects:v18 count:16];
    }
    while (v7);
  }

  uint64_t v11 = (void *)[v4 copy];
  return v11;
}

- (NSSet)lightProfiles
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  BOOL v3 = [MEMORY[0x1E4F1CA80] set];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  BOOL v4 = [(HMDAccessory *)self accessoryProfiles];
  uint64_t v5 = [v4 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v15;
    do
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v15 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(id *)(*((void *)&v14 + 1) + 8 * i);
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          id v10 = v9;
        }
        else {
          id v10 = 0;
        }
        id v11 = v10;

        if (v11) {
          [v3 addObject:v11];
        }
      }
      uint64_t v6 = [v4 countByEnumeratingWithState:&v14 objects:v18 count:16];
    }
    while (v6);
  }

  BOOL v12 = (void *)[v3 copy];
  return (NSSet *)v12;
}

- (void)enableNotificationsWithHAPAccessory:(id)a3 homeNotificationsEnabled:(BOOL)a4
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  if (v6)
  {
    BOOL v30 = a4;
    uint64_t v29 = [(HMDHAPAccessory *)self hapMetadata];
    uint64_t v7 = [(HMDHAPAccessory *)self _characteristicsToEnableEvents];
    uint64_t v28 = (void *)MEMORY[0x1D9452090]();
    uint64_t v31 = (void *)v7;
    uint64_t v8 = [(HMDHAPAccessory *)self _notificationRegistrationsByClientIDForCharacteristics:v7];
    long long v42 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    id obj = [v8 allKeys];
    uint64_t v36 = [obj countByEnumeratingWithState:&v42 objects:v52 count:16];
    if (v36)
    {
      uint64_t v35 = *(void *)v43;
      id v32 = v8;
      id v33 = self;
      do
      {
        for (uint64_t i = 0; i != v36; ++i)
        {
          if (*(void *)v43 != v35) {
            objc_enumerationMutation(obj);
          }
          uint64_t v10 = *(void *)(*((void *)&v42 + 1) + 8 * i);
          id v11 = [v8 objectForKeyedSubscript:v10];
          BOOL v12 = objc_msgSend(v11, "na_map:", &__block_literal_global_448);
          long long v13 = objc_msgSend(v11, "na_filter:", &__block_literal_global_451);
          context = (void *)MEMORY[0x1D9452090]();
          long long v14 = self;
          long long v15 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
          {
            long long v16 = HMFGetLogIdentifier();
            [v12 shortDescription];
            uint64_t v18 = v17 = v6;
            *(_DWORD *)buf = 138543874;
            id v47 = v16;
            __int16 v48 = 2112;
            id v49 = v18;
            __int16 v50 = 2112;
            uint64_t v51 = v10;
            _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@Enabling notifications for %@ with client id %@", buf, 0x20u);

            id v6 = v17;
            uint64_t v8 = v32;

            self = v33;
          }

          [(HMDHAPAccessory *)v14 setNotificationsEnabled:1 forCharacteristics:v12 notificationChangeThresholds:v13 clientIdentifier:v10 matchingHAPAccessory:v6];
        }
        uint64_t v36 = [obj countByEnumeratingWithState:&v42 objects:v52 count:16];
      }
      while (v36);
    }

    uint64_t v19 = [MEMORY[0x1E4F1CAD0] setWithArray:v31];
    v38[0] = MEMORY[0x1E4F143A8];
    v38[1] = 3221225472;
    v38[2] = __80__HMDHAPAccessory_enableNotificationsWithHAPAccessory_homeNotificationsEnabled___block_invoke_452;
    v38[3] = &unk_1E6A0AF20;
    BOOL v41 = v30;
    id v20 = v19;
    id v39 = v20;
    id v21 = v29;
    id v40 = v21;
    int v22 = [(HMDHAPAccessory *)self characteristicsPassingTest:v38];
    if ([v22 count])
    {
      id v23 = (void *)MEMORY[0x1D9452090]();
      BOOL v24 = self;
      uint64_t v25 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        HMFGetLogIdentifier();
        v27 = id v26 = v6;
        *(_DWORD *)buf = 138543618;
        id v47 = v27;
        __int16 v48 = 2112;
        id v49 = v22;
        _os_log_impl(&dword_1D49D5000, v25, OS_LOG_TYPE_INFO, "%{public}@Enabling notifications on behalf of homed for %@", buf, 0x16u);

        id v6 = v26;
      }

      [(HMDHAPAccessory *)v24 setNotificationsEnabled:1 forCharacteristics:v22 notificationChangeThresholds:0 clientIdentifier:@"com.apple.HomeKitDaemon.homeNotifications" matchingHAPAccessory:v6];
    }
  }
}

- (void)setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 notificationChangeThresholds:(id)a5 clientIdentifier:(id)a6 matchingHAPAccessory:(id)a7
{
  id v12 = a4;
  id v13 = a5;
  id v14 = a6;
  id v15 = a7;
  long long v16 = [(HMDAccessory *)self workQueue];
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 3221225472;
  v21[2] = __129__HMDHAPAccessory_setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke;
  v21[3] = &unk_1E6A11E78;
  BOOL v26 = a3;
  v21[4] = self;
  id v22 = v12;
  id v23 = v13;
  id v24 = v14;
  id v25 = v15;
  id v17 = v15;
  id v18 = v14;
  id v19 = v13;
  id v20 = v12;
  dispatch_async(v16, v21);
}

- (id)_notificationRegistrationsByClientIDForCharacteristics:(id)a3
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v3 = a3;
  BOOL v4 = [MEMORY[0x1E4F1CA60] dictionary];
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v5 = v3;
  uint64_t v6 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v18;
    do
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v18 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v10 = *(void **)(*((void *)&v17 + 1) + 8 * i);
        id v11 = [v10 notificationRegistrations];
        v14[0] = MEMORY[0x1E4F143A8];
        v14[1] = 3221225472;
        v14[2] = __74__HMDHAPAccessory__notificationRegistrationsByClientIDForCharacteristics___block_invoke;
        v14[3] = &unk_1E6A0AEB8;
        id v15 = v4;
        long long v16 = v10;
        objc_msgSend(v11, "na_each:", v14);
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }
    while (v7);
  }

  id v12 = (void *)[v4 copy];
  return v12;
}

- (int64_t)reachableTransports
{
  uint64_t v8 = 0;
  id v9 = &v8;
  uint64_t v10 = 0x2020000000;
  id v11 = 0;
  v7.receiver = self;
  v7.super_class = (Class)HMDHAPAccessory;
  id v11 = [(HMDAccessory *)&v7 reachableTransports];
  id v3 = [(HMDHAPAccessory *)self transportInformationInstances];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __38__HMDHAPAccessory_reachableTransports__block_invoke;
  v6[3] = &unk_1E6A0B510;
  v6[4] = &v8;
  objc_msgSend(v3, "na_each:", v6);

  int64_t v4 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v4;
}

- (id)_characteristicsToEnableEvents
{
  id v3 = [(HMDHAPAccessory *)self hapMetadata];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = __49__HMDHAPAccessory__characteristicsToEnableEvents__block_invoke;
  v7[3] = &unk_1E6A17BB8;
  id v8 = v3;
  id v4 = v3;
  id v5 = [(HMDHAPAccessory *)self characteristicsPassingTest:v7];

  return v5;
}

- (BOOL)supportsWiFiReconfiguration
{
  id v2 = [(HMDHAPAccessory *)self wiFiManagementController];
  char v3 = [v2 supportsStationConfiguration];

  return v3;
}

- (HMDWiFiManagementController)wiFiManagementController
{
  os_unfair_recursive_lock_lock_with_options();
  char v3 = self->_wiFiManagementController;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (BOOL)supportsUserMediaSettings
{
  return ([(HMDHAPAccessory *)self siriEndpointCapabilities] >> 4) & 1;
}

- (BOOL)supportsSoftwareUpdate
{
  id v2 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000236-0000-1000-8000-0026BB765291"];
  BOOL v3 = v2 != 0;

  return v3;
}

- (BOOL)supportsNetworkProtection
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if ([(HMDHAPAccessory *)self supportsCHIP])
  {
    BOOL v3 = (void *)MEMORY[0x1D9452090]();
    id v4 = self;
    id v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v47 = v6;
      objc_super v7 = "%{public}@Accessory does not support network protection because it supports CHIP";
LABEL_8:
      _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_DEBUG, v7, buf, 0xCu);
LABEL_11:

      goto LABEL_12;
    }
    goto LABEL_12;
  }
  if (![(HMDHAPAccessory *)self hasIPLink])
  {
    BOOL v3 = (void *)MEMORY[0x1D9452090]();
    id v4 = self;
    id v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = HMFGetLogIdentifier();
      id v9 = [(HMDHAPAccessory *)v4 transportInformationInstances];
      *(_DWORD *)buf = 138543618;
      id v47 = v6;
      __int16 v48 = 2112;
      id v49 = v9;
      _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_DEBUG, "%{public}@Accessory does not support network protection because it has no IP Link. transportInformationInstances: %@", buf, 0x16u);

      goto LABEL_11;
    }
    goto LABEL_12;
  }
  id v8 = [(HMDHAPAccessory *)self bridge];

  if (v8)
  {
    BOOL v3 = (void *)MEMORY[0x1D9452090]();
    id v4 = self;
    id v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v47 = v6;
      objc_super v7 = "%{public}@Accessory does not support network protection because it is a bridged accessory";
      goto LABEL_8;
    }
LABEL_12:

    return 0;
  }
  id v12 = [(HMDAccessory *)self initialCategoryIdentifier];
  if (v12)
  {
    id v13 = [(HMDHAPAccessory *)self hapMetadata];
    id v14 = [v13 categoryForIdentifier:v12];
    id v15 = [v14 uuidStr];
  }
  else
  {
    long long v16 = (void *)MEMORY[0x1D9452090]();
    long long v17 = self;
    long long v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      long long v19 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v47 = v19;
      _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_DEFAULT, "%{public}@supportsNetworkProtection: falling back to current category because initialCategoryIdentifier is unavailable", buf, 0xCu);
    }
    id v13 = [(HMDAccessory *)v17 category];
    id v15 = [v13 categoryType];
  }

  if (([v15 isEqualToString:*MEMORY[0x1E4F2C260]] & 1) != 0
    || ([v15 isEqualToString:*MEMORY[0x1E4F2C230]] & 1) != 0
    || ([v15 isEqualToString:*MEMORY[0x1E4F2C240]] & 1) != 0
    || [v15 isEqualToString:*MEMORY[0x1E4F2C248]])
  {
    long long v20 = (void *)MEMORY[0x1D9452090]();
    id v21 = self;
    uint64_t v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      id v23 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v47 = v23;
      __int16 v48 = 2112;
      id v49 = v15;
      _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_DEBUG, "%{public}@Accessory does not support network protection because of its category type: %@", buf, 0x16u);
    }
    BOOL v10 = 0;
  }
  else
  {
    id v24 = [(HMDHAPAccessory *)self initialServiceTypeUUIDs];
    if (!v24)
    {
      id v25 = (void *)MEMORY[0x1D9452090]();
      BOOL v26 = self;
      uint64_t v27 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v47 = v28;
        _os_log_impl(&dword_1D49D5000, v27, OS_LOG_TYPE_DEFAULT, "%{public}@supportsNetworkProtection: falling back to current service types because initialServiceTypeUUIDs is unavailable", buf, 0xCu);
      }
      id v24 = [(HMDHAPAccessory *)v26 initialServiceTypeUUIDs];
    }
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    id obj = v24;
    uint64_t v29 = [obj countByEnumeratingWithState:&v41 objects:v45 count:16];
    if (v29)
    {
      uint64_t v30 = v29;
      uint64_t v31 = *(void *)v42;
      uint64_t v32 = *MEMORY[0x1E4F2DF18];
      uint64_t v33 = *MEMORY[0x1E4F2DEF0];
      while (2)
      {
        for (uint64_t i = 0; i != v30; ++i)
        {
          if (*(void *)v42 != v31) {
            objc_enumerationMutation(obj);
          }
          uint64_t v35 = *(void **)(*((void *)&v41 + 1) + 8 * i);
          if (([v35 isEqualToString:v32] & 1) != 0
            || ([v35 isEqualToString:@"00000701-0000-1000-8000-0026BB765291"] & 1) != 0
            || [v35 isEqualToString:v33])
          {
            uint64_t v36 = (void *)MEMORY[0x1D9452090]();
            id v37 = self;
            __int16 v38 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              id v39 = HMFGetLogIdentifier();
              *(_DWORD *)buf = 138543618;
              id v47 = v39;
              __int16 v48 = 2112;
              id v49 = v35;
              _os_log_impl(&dword_1D49D5000, v38, OS_LOG_TYPE_DEBUG, "%{public}@Accessory does not support network protection because of its serviceType: %@", buf, 0x16u);
            }
            BOOL v10 = 0;
            goto LABEL_46;
          }
        }
        uint64_t v30 = [obj countByEnumeratingWithState:&v41 objects:v45 count:16];
        BOOL v10 = 1;
        if (v30) {
          continue;
        }
        break;
      }
    }
    else
    {
      BOOL v10 = 1;
    }
LABEL_46:
  }
  return v10;
}

- (BOOL)supportsMusicAlarm
{
  return ([(HMDHAPAccessory *)self siriEndpointCapabilities] >> 1) & 1;
}

- (unint64_t)siriEndpointCapabilities
{
  os_unfair_recursive_lock_lock_with_options();
  unint64_t siriEndpointCapabilities = self->_siriEndpointCapabilities;
  os_unfair_recursive_lock_unlock();
  return siriEndpointCapabilities;
}

- (BOOL)supportsMultiUser
{
  return ([(HMDHAPAccessory *)self siriEndpointCapabilities] >> 2) & 1;
}

- (BOOL)supportsIdentify
{
  return 1;
}

- (BOOL)supportsDoorbellChime
{
  return ([(HMDHAPAccessory *)self siriEndpointCapabilities] >> 3) & 1;
}

- (BOOL)supportsAnnounce
{
  return [(HMDHAPAccessory *)self siriEndpointCapabilities] & 1;
}

void __84__HMDHAPAccessory_configureWithAccessory_homeNotificationsEnabled_queue_completion___block_invoke(uint64_t a1)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  id v2 = (void *)MEMORY[0x1D9452090]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void **)(a1 + 40);
    objc_super v7 = HMFBooleanToString();
    *(_DWORD *)buf = 138543874;
    int v91 = v5;
    __int16 v92 = 2112;
    uint64_t v93 = v6;
    __int16 v94 = 2112;
    uint64_t v95 = v7;
    _os_log_impl(&dword_1D49D5000, v4, OS_LOG_TYPE_DEFAULT, "%{public}@Configuring with HAPAccessory: %@ homeNotificationsEnabled: %@", buf, 0x20u);
  }
  [*(id *)(a1 + 32) _addHAPAccessory:*(void *)(a1 + 40)];
  id v8 = *(void **)(a1 + 32);
  id v9 = [*(id *)(a1 + 40) services];
  id v84 = 0;
  [v8 _configureWithAccessoryServices:v9 changedCharacteristics:&v84];
  id v10 = v84;

  if ((_os_feature_enabled_impl() & 1) == 0 && [v10 count])
  {
    uint64_t v88 = @"kCharacteristicAndValueKey";
    id v11 = (void *)[v10 copy];
    char v89 = v11;
    id v12 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v89 forKeys:&v88 count:1];

    id v13 = objc_alloc(MEMORY[0x1E4F65488]);
    id v14 = [*(id *)(a1 + 32) uuid];
    id v15 = (void *)[v13 initWithTarget:v14];

    long long v16 = (void *)[objc_alloc(MEMORY[0x1E4F654B0]) initWithName:@"kCharacteristicsUpdatedNotificationKey" destination:v15 payload:v12];
    long long v17 = [*(id *)(a1 + 32) messageSendPolicy];
    [v16 setSendPolicy:v17];

    long long v18 = [*(id *)(a1 + 32) msgDispatcher];
    [v18 sendMessage:v16];
  }
  id v73 = v10;
  uint64_t v19 = [NSNumber numberWithInt:1];
  id v86 = @"HMDNotificationCharacteristicValueUpdatedReasonKey";
  uint64_t v87 = v19;
  id v72 = (void *)v19;
  id v71 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v87 forKeys:&v86 count:1];
  logAndPostNotification(@"HMDNotificationCharacteristicValueUpdated", *(void **)(a1 + 32), v71);
  [*(id *)(a1 + 32) enableNotificationsWithHAPAccessory:*(void *)(a1 + 40) homeNotificationsEnabled:*(unsigned __int8 *)(a1 + 72)];
  long long v20 = [*(id *)(a1 + 32) getPrimaryHAPAccessories];
  id v21 = [v20 firstObject];

  uint64_t v22 = [v21 server];
  if ((([*(id *)(a1 + 32) custom1WoBLE] & 1) != 0
     || [*(id *)(a1 + 32) supportsWoL])
    && v22)
  {
    id v23 = [*(id *)(a1 + 32) hapMetadata];
    id v24 = *(void **)(a1 + 32);
    v82[0] = MEMORY[0x1E4F143A8];
    v82[1] = 3221225472;
    v82[2] = __84__HMDHAPAccessory_configureWithAccessory_homeNotificationsEnabled_queue_completion___block_invoke_454;
    v82[3] = &unk_1E6A17BB8;
    id v25 = v23;
    id v83 = v25;
    BOOL v26 = [v24 characteristicsPassingTest:v82];
    uint64_t v27 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v26, "count"));
    long long v78 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    id v28 = v26;
    uint64_t v29 = [v28 countByEnumeratingWithState:&v78 objects:v85 count:16];
    if (v29)
    {
      uint64_t v30 = v29;
      uint64_t v31 = *(void *)v79;
      do
      {
        uint64_t v32 = 0;
        do
        {
          if (*(void *)v79 != v31) {
            objc_enumerationMutation(v28);
          }
          uint64_t v33 = [*(id *)(*((void *)&v78 + 1) + 8 * v32) characteristicForHAPAccessory:v21];
          if (v33) {
            [v27 addObject:v33];
          }

          ++v32;
        }
        while (v30 != v32);
        uint64_t v30 = [v28 countByEnumeratingWithState:&v78 objects:v85 count:16];
      }
      while (v30);
    }

    if ([v27 count])
    {
      uint64_t v34 = (void *)MEMORY[0x1D9452090]();
      id v35 = *(id *)(a1 + 32);
      uint64_t v36 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
      {
        id v37 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        int v91 = v37;
        __int16 v92 = 2112;
        uint64_t v93 = v27;
        _os_log_impl(&dword_1D49D5000, v36, OS_LOG_TYPE_INFO, "%{public}@Configuring accessory - sending out changed notifications: %@", buf, 0x16u);
      }
      __int16 v38 = [*(id *)(a1 + 32) home];
      [v38 handleUpdatedCharacteristics:v27 accessoryServer:v22];
    }
  }
  id v39 = dispatch_group_create();
  dispatch_group_enter(v39);
  id v40 = [*(id *)(a1 + 32) internalEnhancedAuthMethod];

  if (v40)
  {
    long long v41 = (void *)MEMORY[0x1D9452090]();
    id v42 = *(id *)(a1 + 32);
    long long v43 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
    {
      long long v44 = HMFGetLogIdentifier();
      [*(id *)(a1 + 32) enhancedAuthMethod];
      long long v45 = HAPAuthMethodToString();
      __int16 v46 = [*(id *)(a1 + 32) internalEnhancedAuthConfigNumber];
      *(_DWORD *)buf = 138543874;
      int v91 = v44;
      __int16 v92 = 2112;
      uint64_t v93 = v45;
      __int16 v94 = 2112;
      uint64_t v95 = v46;
      _os_log_impl(&dword_1D49D5000, v43, OS_LOG_TYPE_INFO, "%{public}@Auth method already calculated as %@ (c#: %@)", buf, 0x20u);
    }
  }
  else
  {
    id v47 = [*(id *)(a1 + 40) server];
    int v48 = [*(id *)(a1 + 40) isPrimary];
    id v49 = (void *)MEMORY[0x1D9452090]();
    id v50 = *(id *)(a1 + 32);
    uint64_t v51 = HMFGetOSLogHandle();
    __int16 v52 = v51;
    if (v48 && v47)
    {
      if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
      {
        uint64_t v53 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        int v91 = v53;
        _os_log_impl(&dword_1D49D5000, v52, OS_LOG_TYPE_INFO, "%{public}@We don't have an auth method, computing it from the server", buf, 0xCu);
      }
      dispatch_group_enter(v39);
      __int16 v54 = *(void **)(a1 + 32);
      v76[0] = MEMORY[0x1E4F143A8];
      v76[1] = 3221225472;
      v76[2] = __84__HMDHAPAccessory_configureWithAccessory_homeNotificationsEnabled_queue_completion___block_invoke_455;
      v76[3] = &unk_1E6A197F0;
      long long v77 = v39;
      [v54 _updateAuthMethodWithServer:v47 completion:v76];
    }
    else
    {
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v55 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        int v91 = v55;
        _os_log_impl(&dword_1D49D5000, v52, OS_LOG_TYPE_DEBUG, "%{public}@No auth method and unable to calculate it", buf, 0xCu);
      }
    }
  }
  uint64_t v56 = *(NSObject **)(a1 + 48);
  if (v56)
  {
    int v57 = *(void **)(a1 + 56);
    if (v57)
    {
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __84__HMDHAPAccessory_configureWithAccessory_homeNotificationsEnabled_queue_completion___block_invoke_456;
      block[3] = &unk_1E6A186E0;
      id v75 = v57;
      dispatch_group_notify(v39, v56, block);
    }
  }
  dispatch_group_leave(v39);
  uint64_t v58 = (void *)MEMORY[0x1D9452090]();
  id v59 = *(id *)(a1 + 32);
  id v60 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
  {
    long long v61 = HMFGetLogIdentifier();
    [*(id *)(a1 + 32) isSecureSessionEstablished];
    uint64_t v62 = HMFBooleanToString();
    *(_DWORD *)buf = 138543618;
    int v91 = v61;
    __int16 v92 = 2112;
    uint64_t v93 = v62;
    _os_log_impl(&dword_1D49D5000, v60, OS_LOG_TYPE_INFO, "%{public}@Sending accessory configured notification, Secure Session: %@", buf, 0x16u);
  }
  logAndPostNotification(@"HMDAccessoryConfiguredNotification", *(void **)(a1 + 32), 0);
  if (([*(id *)(a1 + 40) isPrimary] & 1) == 0) {
    [*(id *)(a1 + 32) _checkBridgedAccessoryOnConfigured];
  }
  [*(id *)(a1 + 32) _updateAccessoryTracking];
  [*(id *)(a1 + 32) _reconcileAccessControlSetting];
  id v63 = [*(id *)(a1 + 40) server];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if ((isKindOfClass & 1) != 0 && v63)
  {
    uint64_t v65 = (void *)MEMORY[0x1D9452090]();
    id v66 = *(id *)(a1 + 32);
    id v67 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v67, OS_LOG_TYPE_INFO))
    {
      __int16 v68 = HMFGetLogIdentifier();
      id v69 = NSStringFromSelector(*(SEL *)(a1 + 64));
      id v70 = [*(id *)(a1 + 40) shortDescription];
      *(_DWORD *)buf = 138543874;
      int v91 = v68;
      __int16 v92 = 2112;
      uint64_t v93 = v69;
      __int16 v94 = 2112;
      uint64_t v95 = v70;
      _os_log_impl(&dword_1D49D5000, v67, OS_LOG_TYPE_INFO, "%{public}@%@ setting reachabilityPingNotificationEnabled for accessory %@", buf, 0x20u);
    }
    [*(id *)(a1 + 32) setReachabilityPingNotificationEnabled:1];
  }
  [*(id *)(a1 + 32) _checkResidentDeviceForReachabilityPing];
}

- (void)_notifyClientsWithNotificationChangesForCharacteristics:(id)a3 characteristicErrors:(id)a4 enableNotification:(BOOL)a5 message:(id)a6
{
  BOOL v7 = a5;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a4;
  id v12 = a6;
  id v13 = [(HMDAccessory *)self home];
  if (v13)
  {
    id v14 = +[HMDCharacteristicResponseNotificationContext notificationUpdateMessagePayloadForHome:v13 notificationEnabled:v7 characteristics:v10 characteristicsErrorsMap:v11];
    id v15 = [v12 identifier];
    if (v15)
    {
    }
    else if (![v14 count])
    {
      goto LABEL_12;
    }
    id v20 = objc_alloc(MEMORY[0x1E4F65488]);
    id v21 = [(HMDAccessory *)self messageTargetUUID];
    uint64_t v22 = (void *)[v20 initWithTarget:v21];

    id v23 = [MEMORY[0x1E4F654B0] messageWithName:@"kAccessoryNotificationsUpdatedNotificationKey" destination:v22 payload:v14];
    id v24 = [(HMDHAPAccessory *)self messageSendPolicy];
    if (v12)
    {
      [v23 setSendPolicy:v24];
      id v25 = [v12 identifier];
      [v23 setIdentifier:v25];

      objc_msgSend(v23, "setRemote:", objc_msgSend(v12, "isRemote"));
    }
    else
    {
      uint64_t v34 = v22;
      id v26 = v10;
      id v27 = v11;
      id v28 = [HMDHomeManagerXPCMessageSendPolicy alloc];
      uint64_t v29 = [v24 entitlements];
      uint64_t v30 = [v24 options];
      uint64_t v31 = v28;
      id v11 = v27;
      id v10 = v26;
      uint64_t v22 = v34;
      uint64_t v32 = [(HMDHomeManagerXPCMessageSendPolicy *)v31 initWithEntitlements:v29 options:v30 active:1];
      [v23 setSendPolicy:v32];
    }
    uint64_t v33 = [(HMDAccessory *)self msgDispatcher];
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 3221225472;
    v35[2] = __123__HMDHAPAccessory__notifyClientsWithNotificationChangesForCharacteristics_characteristicErrors_enableNotification_message___block_invoke;
    v35[3] = &unk_1E6A197F0;
    id v36 = v12;
    [v33 sendMessage:v23 completionHandler:v35];
  }
  else
  {
    long long v16 = (void *)MEMORY[0x1D9452090]();
    long long v17 = self;
    long long v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      uint64_t v19 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      __int16 v38 = v19;
      __int16 v39 = 2112;
      id v40 = v10;
      _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_INFO, "%{public}@Not notifying characteristic changes %@ since home is nil", buf, 0x16u);
    }
    id v14 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v12 respondWithError:v14];
  }
LABEL_12:
}

- (id)messageSendPolicy
{
  if ([(HMDHAPAccessory *)self hasTelevisionService]) {
    uint64_t v3 = 1537;
  }
  else {
    uint64_t v3 = 513;
  }
  id v4 = [(HMDHAPAccessory *)self networkRouterController];

  BOOL v5 = v4 == 0;
  if (v4) {
    uint64_t v6 = 65;
  }
  else {
    uint64_t v6 = 1;
  }
  if (!v5) {
    v3 |= 0x1000uLL;
  }
  BOOL v7 = [[HMDHomeManagerXPCMessageSendPolicy alloc] initWithEntitlements:v6 options:v3];
  return v7;
}

- (BOOL)hasTelevisionService
{
  id v2 = [(HMDHAPAccessory *)self findServiceWithServiceType:*MEMORY[0x1E4F2DEF0]];
  BOOL v3 = v2 != 0;

  return v3;
}

- (HMDNetworkRouterController)networkRouterController
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_networkRouterController;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (id)getPrimaryHAPAccessories
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v17 = (id)objc_opt_new();
  BOOL v3 = [(HMDHAPAccessory *)self transportInformationInstances];
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v4 = [v3 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v19;
    uint64_t v7 = *MEMORY[0x1E4F5BED0];
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v19 != v6) {
          objc_enumerationMutation(v3);
        }
        id v9 = *(void **)(*((void *)&v18 + 1) + 8 * i);
        uint64_t v10 = [v9 hapAccessory];
        if (v10)
        {
          id v11 = (void *)v10;
          id v12 = [v9 instanceID];
          id v13 = [NSNumber numberWithUnsignedInteger:v7];
          int v14 = [v12 isEqualToNumber:v13];

          if (v14)
          {
            id v15 = [v9 hapAccessory];
            [v17 addObject:v15];
          }
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }
    while (v5);
  }

  return v17;
}

- (NSNumber)internalEnhancedAuthMethod
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_internalEnhancedAuthMethod;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (void)_cancelPowerOn
{
  if ([(HMDHAPAccessory *)self custom1WoBLE])
  {
    id v3 = +[HMDBTLEAdvertiser sharedAdvertiser];
    [v3 cancelOn:self];
  }
}

- (BOOL)custom1WoBLE
{
  os_unfair_recursive_lock_lock_with_options();
  id v3 = [(HMFConnectivityInfo *)self->_connectivityInfo woBLEInfo];
  uint64_t v4 = [v3 bleIdentifier];
  BOOL v5 = v4 != 0;

  os_unfair_recursive_lock_unlock();
  return v5;
}

- (BOOL)isSecureSessionEstablished
{
  if ([(HMDHAPAccessory *)self isIPSecureSessionEstablished]) {
    return 1;
  }
  return [(HMDHAPAccessory *)self isBLESecureSessionEstablished];
}

- (BOOL)isIPSecureSessionEstablished
{
  id v2 = [(HMDHAPAccessory *)self transportInformationInstances];
  char v3 = objc_msgSend(v2, "na_any:", &__block_literal_global_427);

  return v3;
}

- (void)_reconcileAccessControlSetting
{
  if ([(HMDHAPAccessory *)self supportsMinimumUserPrivilege])
  {
    id v4 = [(HMDAccessory *)self home];
    __handleUpdatedMinimumUserPrivilege(self, [v4 minimumMediaUserPrivilege]);
    char v3 = [v4 mediaPassword];
    __handleUpdatedPassword(self, v3);
  }
}

- (BOOL)supportsMinimumUserPrivilege
{
  if ([(HMDHAPAccessory *)self hasTelevisionService]) {
    return 1;
  }
  return [(HMDHAPAccessory *)self hasSmartSpeakerService];
}

- (void)_configureWithAccessoryServices:(id)a3 changedCharacteristics:(id *)a4
{
  long long v21 = a4;
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  uint64_t v6 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v6);

  objc_msgSend(MEMORY[0x1E4F1CA60], "dictionaryWithCapacity:", objc_msgSend(v5, "count"));
  id v26 = (id)objc_claimAutoreleasedReturnValue();
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id obj = v5;
  uint64_t v24 = [obj countByEnumeratingWithState:&v31 objects:v36 count:16];
  if (v24)
  {
    uint64_t v23 = *(void *)v32;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v32 != v23) {
          objc_enumerationMutation(obj);
        }
        uint64_t v25 = v7;
        id v8 = *(void **)(*((void *)&v31 + 1) + 8 * v7);
        long long v27 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        id v9 = [(HMDHAPAccessory *)self services];
        uint64_t v10 = [v9 countByEnumeratingWithState:&v27 objects:v35 count:16];
        if (v10)
        {
          uint64_t v11 = v10;
          uint64_t v12 = *(void *)v28;
          do
          {
            for (uint64_t i = 0; i != v11; ++i)
            {
              if (*(void *)v28 != v12) {
                objc_enumerationMutation(v9);
              }
              int v14 = *(void **)(*((void *)&v27 + 1) + 8 * i);
              id v15 = [v8 instanceID];
              long long v16 = [v14 instanceID];
              int v17 = [v15 isEqual:v16];

              if (v17)
              {
                long long v18 = [v14 configureWithService:v8 accessory:self];
                long long v19 = (void *)[v18 mutableCopy];

                [(HMDHAPAccessory *)self _wol_ignoreWakingViaCharacteristicUpdateFromChangedService:v19];
                if ([v19 count])
                {
                  long long v20 = [v14 instanceID];
                  [v26 setObject:v19 forKeyedSubscript:v20];
                }
              }
            }
            uint64_t v11 = [v9 countByEnumeratingWithState:&v27 objects:v35 count:16];
          }
          while (v11);
        }

        uint64_t v7 = v25 + 1;
      }
      while (v25 + 1 != v24);
      uint64_t v24 = [obj countByEnumeratingWithState:&v31 objects:v36 count:16];
    }
    while (v24);
  }

  if (v21) {
    id *v21 = v26;
  }
}

- (void)_wol_ignoreWakingViaCharacteristicUpdateFromChangedService:(id)a3
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if (v4)
  {
    id v5 = [(HMDHAPAccessory *)self wakingViaCharacteristicWithIID];

    if (v5)
    {
      uint64_t v6 = [v4 objectForKey:@"kModifiedCharacteristicsForAccessoryKey"];
      uint64_t v7 = [(HMDHAPAccessory *)self wakingViaCharacteristicWithIID];
      id v8 = [v6 objectForKey:v7];

      if (v8)
      {
        id v9 = [v8 objectForKeyedSubscript:@"kCharacteristicValue"];
        char v10 = [v9 BOOLValue];

        if ((v10 & 1) == 0)
        {
          uint64_t v11 = (void *)MEMORY[0x1D9452090]();
          uint64_t v12 = self;
          id v13 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
          {
            int v14 = HMFGetLogIdentifier();
            id v15 = [(HMDAccessory *)v12 identifier];
            int v17 = 138543874;
            long long v18 = v14;
            __int16 v19 = 2112;
            long long v20 = v8;
            __int16 v21 = 2112;
            uint64_t v22 = v15;
            _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_INFO, "%{public}@Ignoring changed characteristic update: '%@' since accessory: %@ has a pending wake via this characteristic.", (uint8_t *)&v17, 0x20u);
          }
          long long v16 = [(HMDHAPAccessory *)v12 wakingViaCharacteristicWithIID];
          [v6 removeObjectForKey:v16];

          [v4 setObject:v6 forKey:@"kModifiedCharacteristicsForAccessoryKey"];
        }
      }
    }
  }
}

- (NSNumber)wakingViaCharacteristicWithIID
{
  os_unfair_recursive_lock_lock_with_options();
  char v3 = self->_wakingViaCharacteristicWithIID;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (void)_checkResidentDeviceForReachabilityPing
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  char v3 = [(HMDAccessory *)self home];
  if ([v3 isCurrentDeviceAvailableResident])
  {
    if ([(HMDAccessory *)self reachabilityPingNotificationEnabled])
    {
      int v4 = [v3 isCurrentDeviceConfirmedPrimaryResident];
      id v5 = (void *)MEMORY[0x1D9452090]();
      uint64_t v6 = self;
      uint64_t v7 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        uint64_t v8 = HMFGetLogIdentifier();
        id v9 = (void *)v8;
        char v10 = @"not ";
        if (v4) {
          char v10 = &stru_1F2C9F1A8;
        }
        int v21 = 138543618;
        uint64_t v22 = v8;
        __int16 v23 = 2112;
        uint64_t v24 = v10;
        _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Current device is %@primary resident", (uint8_t *)&v21, 0x16u);
      }
      uint64_t v11 = (void *)MEMORY[0x1D9452090]();
      uint64_t v12 = v6;
      id v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        uint64_t v14 = HMFGetLogIdentifier();
        id v15 = (void *)v14;
        long long v16 = "Disabling";
        if (v4) {
          long long v16 = "Enabling";
        }
        int v21 = 138543618;
        uint64_t v22 = v14;
        __int16 v23 = 2080;
        uint64_t v24 = (void *)v16;
        _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_INFO, "%{public}@%s reachability ping for thread transport", (uint8_t *)&v21, 0x16u);
      }
      if (v4)
      {
        [(HMDAccessory *)v12 setReachabilityPingEnabled:1];
        [(HMDHAPAccessory *)v12 startReachabilityCheck];
      }
      else
      {
        [(HMDHAPAccessory *)v12 stopReachabilityCheck];
        [(HMDAccessory *)v12 setReachabilityPingEnabled:0];
      }
    }
  }
  else
  {
    int v17 = (void *)MEMORY[0x1D9452090]();
    long long v18 = self;
    __int16 v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      long long v20 = HMFGetLogIdentifier();
      int v21 = 138543362;
      uint64_t v22 = (uint64_t)v20;
      _os_log_impl(&dword_1D49D5000, v19, OS_LOG_TYPE_DEBUG, "%{public}@Current device is not a resident", (uint8_t *)&v21, 0xCu);
    }
  }
}

- (BOOL)isBLESecureSessionEstablished
{
  id v2 = [(HMDHAPAccessory *)self transportInformationInstances];
  char v3 = objc_msgSend(v2, "na_any:", &__block_literal_global_434);

  return v3;
}

- (void)_checkBridgedAccessoryOnConfigured
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  [(HMDHAPAccessory *)self setLastSessionStatus:0];
  char v3 = [(HMDHAPAccessory *)self currentActiveSessionRestoreClients];
  uint64_t v4 = [v3 count];

  if (v4)
  {
    id v5 = (void *)MEMORY[0x1D9452090]();
    uint64_t v6 = self;
    uint64_t v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = HMFGetLogIdentifier();
      int v9 = 138543362;
      char v10 = v8;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Session Restore - Checking bridged accessory", (uint8_t *)&v9, 0xCu);
    }
    [(HMDHAPAccessory *)v6 _checkSession];
  }
}

- (void)_checkSessionRestoreOnLinkStateChange
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  char v3 = [(HMDHAPAccessory *)self currentActiveSessionRestoreClients];
  if ([v3 count])
  {
    double Current = CFAbsoluteTimeGetCurrent();
    [(HMDHAPAccessory *)self lastLinkChangeSessionCheckTime];
    double v6 = Current - v5;
    [(HMDHAPAccessory *)self sessionCheckPeriod];
    if (v6 > v7)
    {
      uint64_t v8 = [(HMDHAPAccessory *)self setLastLinkChangeSessionCheckTime:CFAbsoluteTimeGetCurrent()];
      int v9 = (void *)MEMORY[0x1D9452090](v8);
      char v10 = self;
      uint64_t v11 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        uint64_t v12 = HMFGetLogIdentifier();
        int v13 = 138543618;
        uint64_t v14 = v12;
        __int16 v15 = 2112;
        long long v16 = v3;
        _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_INFO, "%{public}@Session Restore checking session on link state change, registrations %@", (uint8_t *)&v13, 0x16u);
      }
      if ([(HMDAccessory *)v10 isReachable]) {
        [(HMDHAPAccessory *)v10 _checkSession];
      }
    }
    if ([(HMDAccessory *)self isReachable]) {
      [(HMDHAPAccessory *)self _startSessionMonitor];
    }
  }
}

- (id)currentActiveSessionRestoreClients
{
  os_unfair_recursive_lock_lock_with_options();
  char v3 = [(HMDHAPAccessory *)self activeSessionRestoreClients];
  uint64_t v4 = (void *)[v3 copy];

  os_unfair_recursive_lock_unlock();
  return v4;
}

- (void)setLastSessionStatus:(unint64_t)a3
{
  self->_lastSessionStatus = a3;
}

- (HMSupportedAccessoryDiagnostics)supportedDiagnostics
{
  char v3 = [(HMDHAPAccessory *)self matterDiagnosticManager];

  if (v3)
  {
    uint64_t v4 = [(HMDHAPAccessory *)self matterDiagnosticManager];
    double v5 = [v4 supportedDiagnostics];
  }
  else
  {
    uint64_t v4 = [(HMDHAPAccessory *)self findCharacteristicType:*MEMORY[0x1E4F2CFC8] forServiceType:*MEMORY[0x1E4F2DE10]];
    double v6 = [v4 value];

    if (v6)
    {
      double v7 = (void *)MEMORY[0x1E4F5BE38];
      uint64_t v8 = [v4 value];
      uint64_t v22 = 0;
      int v9 = [v7 parsedFromData:v8 error:&v22];
      uint64_t v10 = v22;

      uint64_t v11 = [v9 options];
      uint64_t v12 = [v11 value];

      int v13 = [v9 type];
      uint64_t v14 = [v13 value];

      __int16 v15 = [v9 format];

      if (v15
        && (([v9 format],
             long long v16 = objc_claimAutoreleasedReturnValue(),
             unint64_t v17 = [v16 value],
             v16,
             v17 <= 1)
          ? (BOOL v18 = v10 == 0)
          : (BOOL v18 = 0),
            v18))
      {
        __int16 v19 = [v9 audioDiagnostics];
        uint64_t v20 = [v19 value];

        double v5 = (void *)[objc_alloc(MEMORY[0x1E4F2EB60]) initWithSupportedTypes:v14 format:v17 + 1 audio:v20 options:v12];
      }
      else
      {
        double v5 = 0;
      }
    }
    else
    {
      double v5 = 0;
    }
  }

  return (HMSupportedAccessoryDiagnostics *)v5;
}

- (BOOL)supportsWoL
{
  char v3 = [(HMDHAPAccessory *)self findCharacteristicType:@"00000251-0000-1000-8000-0026BB765291" forServiceType:@"00000221-0000-1000-8000-0026BB765291"];
  if (v3)
  {
    uint64_t v4 = [(HMDHAPAccessory *)self findCharacteristicType:@"00000252-0000-1000-8000-0026BB765291" forServiceType:@"00000221-0000-1000-8000-0026BB765291"];
    BOOL v5 = v4 != 0;
  }
  else
  {
    BOOL v5 = 0;
  }

  return v5;
}

- (id)findCharacteristicType:(id)a3 forServiceType:(id)a4
{
  id v6 = a3;
  double v7 = [(HMDHAPAccessory *)self findServiceWithServiceType:a4];
  uint64_t v8 = [v7 findCharacteristicWithType:v6];

  return v8;
}

- (HMDMatterAccessoryDiagnosticsManager)matterDiagnosticManager
{
  return self->_matterDiagnosticManager;
}

- (unint64_t)enhancedAuthMethod
{
  id v2 = [(HMDHAPAccessory *)self internalEnhancedAuthMethod];
  char v3 = v2;
  if (v2) {
    unint64_t v4 = [v2 unsignedIntValue];
  }
  else {
    unint64_t v4 = 5;
  }

  return v4;
}

- (NSNumber)internalEnhancedAuthConfigNumber
{
  os_unfair_recursive_lock_lock_with_options();
  char v3 = self->_internalEnhancedAuthConfigNumber;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (BOOL)shouldEnableDaemonRelaunch
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  v13.receiver = self;
  v13.super_class = (Class)HMDHAPAccessory;
  if ([(HMDAccessory *)&v13 shouldEnableDaemonRelaunch])
  {
    LOBYTE(v3) = 1;
  }
  else
  {
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = 0u;
    long long v10 = 0u;
    unint64_t v4 = [(HMDHAPAccessory *)self services];
    BOOL v5 = (void *)[v4 copy];

    uint64_t v3 = [v5 countByEnumeratingWithState:&v9 objects:v14 count:16];
    if (v3)
    {
      uint64_t v6 = *(void *)v10;
      while (2)
      {
        for (uint64_t i = 0; i != v3; ++i)
        {
          if (*(void *)v10 != v6) {
            objc_enumerationMutation(v5);
          }
          if ([*(id *)(*((void *)&v9 + 1) + 8 * i) shouldEnableDaemonRelaunch])
          {
            LOBYTE(v3) = 1;
            goto LABEL_13;
          }
        }
        uint64_t v3 = [v5 countByEnumeratingWithState:&v9 objects:v14 count:16];
        if (v3) {
          continue;
        }
        break;
      }
    }
LABEL_13:
  }
  return v3;
}

- (BOOL)supportsWalletKey
{
  LOBYTE(self) = self->_supportsWalletKey;
  os_unfair_recursive_lock_unlock();
  return (char)self;
}

- (BOOL)supportsHAP
{
  return [(HMDHAPAccessory *)self communicationProtocol] == 1;
}

BOOL __53__HMDHAPAccessory_Light__updateLightProfilesSettings__block_invoke(uint64_t a1, void *a2)
{
  id v2 = [a2 notificationEnabledCharacteristics];
  BOOL v3 = [v2 count] != 0;

  return v3;
}

- (BOOL)isPaired
{
  return 1;
}

- (void)populateModelObject:(id)a3 version:(int64_t)a4
{
  id v6 = a3;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    double v7 = v6;
  }
  else {
    double v7 = 0;
  }
  id v8 = v7;
  v36.receiver = self;
  v36.super_class = (Class)HMDHAPAccessory;
  [(HMDAccessory *)&v36 populateModelObject:v6 version:a4];
  long long v9 = [(HMDHAPAccessory *)self uniqueIdentifier];
  [v8 setUniqueIdentifier:v9];

  long long v10 = [(HMDHAPAccessory *)self bridge];
  long long v11 = [v10 uuid];
  long long v12 = [v11 UUIDString];
  [v8 setBridgeUUID:v12];

  objc_super v13 = [(HMDHAPAccessory *)self pairingUsername];
  [v8 setPairingUsername:v13];

  uint64_t v14 = [(HMDHAPAccessory *)self publicKey];
  [v8 setPublicKey:v14];

  if (a4 >= 2)
  {
    uint64_t v15 = [(HMDHAPAccessory *)self accessoryFlags];
    [v8 setPropertyIfNotNil:v15 named:@"accessoryFlags"];

    long long v16 = [(HMDHAPAccessory *)self broadcastKey];
    [v8 setBroadcastKey:v16];

    if ((unint64_t)a4 >= 4)
    {
      unint64_t v17 = objc_msgSend(NSNumber, "numberWithInteger:", -[HMDHAPAccessory certificationStatus](self, "certificationStatus"));
      [v8 setCertificationStatus:v17];

      BOOL v18 = [(HMDHAPAccessory *)self setupHash];
      [v8 setPropertyIfNotNil:v18 named:@"accessorySetupHash"];

      __int16 v19 = [(HMDHAPAccessory *)self wiFiTransportCapabilities];
      [v8 setWiFiTransportCapabilities:v19];

      uint64_t v20 = [(HMDHAPAccessory *)self initialServiceTypeUUIDs];
      [v8 setPropertyIfNotNil:v20 named:@"initialServiceTypeUUIDs"];

      int v21 = [(HMDHAPAccessory *)self needsOnboarding];

      if (v21)
      {
        uint64_t v22 = [(HMDHAPAccessory *)self needsOnboarding];
        [v8 setNeedsOnboarding:v22];
      }
    }
  }
  __int16 v23 = [(HMDHAPAccessory *)self getTransportInformationArray];
  if ([v23 count]) {
    [v8 setTransportInformation:v23];
  }
  if ([(HMDHAPAccessory *)self communicationProtocol])
  {
    uint64_t v24 = objc_msgSend(NSNumber, "numberWithInteger:", -[HMDHAPAccessory communicationProtocol](self, "communicationProtocol"));
    [v8 setCommunicationProtocol:v24];
  }
  uint64_t v25 = [(HMDHAPAccessory *)self connectivityInfo];
  [v8 setPropertyIfNotNil:v25 named:@"connectivityInfo"];

  id v26 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", -[HMDHAPAccessory suspendedState](self, "suspendedState"));
  [v8 setSuspendedState:v26];

  long long v27 = [(HMDHAPAccessory *)self targetControllerManager];
  long long v28 = [v27 targetUUIDs];
  [v8 setTargetUUIDs:v28];

  long long v29 = objc_msgSend(NSNumber, "numberWithBool:", -[HMDHAPAccessory hardwareSupport](self, "hardwareSupport"));
  [v8 setHardwareSupport:v29];

  long long v30 = [(HMDHAPAccessory *)self hasOnboardedForNaturalLighting];

  if (v30)
  {
    long long v31 = [(HMDHAPAccessory *)self hasOnboardedForNaturalLighting];
    [v8 setHasOnboardedForNaturalLighting:v31];
  }
  long long v32 = [(HMDAccessory *)self preferredMediaUserUUID];
  [v8 setPreferredMediaUserUUID:v32];

  long long v33 = [(HMDAccessory *)self preferredMediaUserSelectionTypeNumber];

  if (v33)
  {
    long long v34 = [(HMDAccessory *)self preferredMediaUserSelectionTypeNumber];
    [v8 setPreferredUserSelectionType:v34];
  }
  id v35 = [(HMDHAPAccessory *)self chipStorage];
  [v35 updateAccessoryModel:v8];
}

- (unint64_t)suspendedState
{
  os_unfair_recursive_lock_lock_with_options();
  unint64_t suspendedState = self->_suspendedState;
  os_unfair_recursive_lock_unlock();
  return suspendedState;
}

- (NSNumber)needsOnboarding
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_needsOnboarding;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (NSSet)initialServiceTypeUUIDs
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_initialServiceTypeUUIDs;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (NSNumber)hasOnboardedForNaturalLighting
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_hasOnboardedForNaturalLighting;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (BOOL)hardwareSupport
{
  LOBYTE(self) = self->_hardwareSupport;
  os_unfair_recursive_lock_unlock();
  return (char)self;
}

- (NSData)broadcastKey
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_broadcastKey;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (NSNumber)accessoryFlags
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_accessoryFlags;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (NSNumber)wiFiTransportCapabilities
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_wiFiTransportCapabilities;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (NSData)setupHash
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_setupHash;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (NSData)publicKey
{
  return self->_publicKey;
}

- (NSString)pairingUsername
{
  return self->_pairingUsername;
}

- (id)modelObjectWithChangeType:(unint64_t)a3 version:(int64_t)a4
{
  id v6 = [(HMDHAPAccessory *)self transactionWithObjectChangeType:a3];
  [(HMDHAPAccessory *)self populateModelObject:v6 version:a4];
  return v6;
}

- (id)transactionWithObjectChangeType:(unint64_t)a3
{
  BOOL v5 = [HMDHAPAccessoryTransaction alloc];
  id v6 = [(HMDAccessory *)self uuid];
  double v7 = [(HMDAccessory *)self home];
  id v8 = [v7 uuid];
  long long v9 = [(HMDBackingStoreModelObject *)v5 initWithObjectChangeType:a3 uuid:v6 parentUUID:v8];

  return v9;
}

- (id)modelObjectWithChangeType:(unint64_t)a3
{
  return [(HMDHAPAccessory *)self modelObjectWithChangeType:a3 version:4];
}

- (id)getTransportInformationArray
{
  id v2 = [(HMDHAPAccessory *)self transportInformationInstances];
  BOOL v3 = objc_msgSend(v2, "na_map:", &__block_literal_global_756);

  return v3;
}

- (HMFConnectivityInfo)connectivityInfo
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_connectivityInfo;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (void)_addHAPAccessory:(id)a3
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  BOOL v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = self;
  double v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = HMFGetLogIdentifier();
    long long v9 = [v4 serverIdentifier];
    unint64_t v10 = [v4 linkType];
    if (v10 > 2) {
      long long v11 = @"Undefined";
    }
    else {
      long long v11 = off_1E6A0B860[v10];
    }
    long long v12 = v11;
    int v22 = 138543874;
    __int16 v23 = v8;
    __int16 v24 = 2112;
    uint64_t v25 = v9;
    __int16 v26 = 2112;
    long long v27 = v12;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_DEFAULT, "%{public}@Adding HAPAccessory %@/%@ for accessory", (uint8_t *)&v22, 0x20u);
  }
  objc_super v13 = [(HMDHAPAccessory *)v6 matchingTransportInformation:v4];
  if (v13)
  {
    objc_msgSend(v13, "setReachable:", objc_msgSend(v4, "isReachable"));
    [v13 setHapAccessory:v4];
    uint64_t v14 = [v4 server];
    uint64_t v15 = [v14 version];
    long long v16 = [v15 versionString];
    [v13 setProtocolVersion:v16];

    [(HMDHAPAccessory *)v6 updateSuspendedStateWithConnectionState:1 hapAccessory:v4];
  }
  else
  {
    unint64_t v17 = (void *)MEMORY[0x1D9452090]();
    BOOL v18 = v6;
    __int16 v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = HMFGetLogIdentifier();
      int v21 = [v4 shortDescription];
      int v22 = 138543618;
      __int16 v23 = v20;
      __int16 v24 = 2112;
      uint64_t v25 = v21;
      _os_log_impl(&dword_1D49D5000, v19, OS_LOG_TYPE_ERROR, "%{public}@Failed to find transport info for HAPAccessory %@", (uint8_t *)&v22, 0x16u);
    }
  }
  objc_msgSend(v4, "setShouldDisconnectOnIdle:", -[HMDHAPAccessory shouldDisconnectOnIdle](v6, "shouldDisconnectOnIdle"));
  [(HMDHAPAccessory *)v6 _updateReachability];
  [v4 setDelegate:v6];
  [(HMDHAPAccessory *)v6 configureCHIPAccessory];
}

- (BOOL)shouldDisconnectOnIdle
{
  LOBYTE(self) = self->_shouldDisconnectOnIdle;
  os_unfair_recursive_lock_unlock();
  return (char)self;
}

- (void)_updateReachability
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  [(HMDHAPAccessory *)self transportInformationInstances];
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v11;
    while (2)
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v11 != v6) {
          objc_enumerationMutation(v3);
        }
        if (objc_msgSend(*(id *)(*((void *)&v10 + 1) + 8 * v7), "isReachable", (void)v10))
        {

          [(HMDAccessory *)self setReachable:1];
          [(HMDHAPAccessory *)self cancelPowerOn];
          id v8 = [(HMDHAPAccessory *)self targetControllerManager];

          if (v8)
          {
            long long v9 = HAPStringFromAccessoryServerSession();
            [(HMDHAPAccessory *)self registerForSessionRestore:v9];
          }
          goto LABEL_12;
        }
        ++v7;
      }
      while (v5 != v7);
      uint64_t v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }

  [(HMDAccessory *)self setReachable:0];
LABEL_12:
  [(HMDHAPAccessory *)self _checkSessionRestoreOnLinkStateChange];
}

uint64_t __38__HMDHAPAccessory_reachableTransports__block_invoke(uint64_t a1, void *a2)
{
  id v5 = a2;
  if ([v5 isReachable])
  {
    if ([v5 linkType] == 1)
    {
      uint64_t v3 = 1;
    }
    else
    {
      if ([v5 linkType] != 2) {
        goto LABEL_7;
      }
      uint64_t v3 = 2;
    }
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) |= v3;
  }
LABEL_7:
  return MEMORY[0x1F41817F8]();
}

- (HMDTargetControllerManager)targetControllerManager
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v3 = self->_targetControllerManager;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (void)cancelPowerOn
{
  uint64_t v3 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __48__HMDHAPAccessory_WirelessResume__cancelPowerOn__block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v3, block);
}

- (void)updateSuspendedStateWithConnectionState:(BOOL)a3 hapAccessory:(id)a4
{
  id v6 = a4;
  uint64_t v7 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __77__HMDHAPAccessory_WoL__updateSuspendedStateWithConnectionState_hapAccessory___block_invoke;
  block[3] = &unk_1E6A18708;
  BOOL v11 = a3;
  void block[4] = self;
  id v10 = v6;
  id v8 = v6;
  dispatch_async(v7, block);
}

- (void)encodeWithCoder:(id)a3
{
  id v5 = a3;
  uint64_t v4 = (void *)MEMORY[0x1D9452090]();
  [(HMDHAPAccessory *)self _encodeWithCoder:v5];
}

uint64_t __92__HMDHAPAccessory_readCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void __96__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_hapAccessory_activity_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    id v8 = v6;
    long long v9 = v8;
    if (v8 && ([v8 isHMError] & 1) == 0)
    {
      if ([v9 isHAPError])
      {
        unint64_t v10 = [v9 code];
        if (v10 > 0x20) {
          uint64_t v11 = 52;
        }
        else {
          uint64_t v11 = qword_1D54D4320[v10];
        }
      }
      else
      {
        uint64_t v11 = 54;
      }
      uint64_t v18 = [MEMORY[0x1E4F28C58] hmErrorWithCode:v11 description:@"Enabling events failed" reason:0 suggestion:0 underlyingError:v9];

      long long v9 = (void *)v18;
    }
    __int16 v19 = (void *)MEMORY[0x1D9452090]();
    id v20 = WeakRetained;
    int v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      int v22 = HMFGetLogIdentifier();
      __int16 v23 = [*(id *)(a1 + 32) identifier];
      [v23 shortDescription];
      uint64_t v29 = a1;
      __int16 v24 = v19;
      id v25 = WeakRetained;
      id v26 = v6;
      uint64_t v28 = v27 = v5;
      *(_DWORD *)buf = 138543618;
      long long v31 = v22;
      __int16 v32 = 2114;
      long long v33 = v28;
      _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Successfully modified characteristic notifications", buf, 0x16u);

      id v5 = v27;
      id v6 = v26;
      id WeakRetained = v25;
      __int16 v19 = v24;
      a1 = v29;
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    [v20 _updateAccessoryTracking];
  }
  else
  {
    long long v12 = (void *)MEMORY[0x1D9452090]();
    long long v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = HMFGetLogIdentifier();
      uint64_t v15 = [*(id *)(a1 + 32) identifier];
      long long v16 = [v15 shortDescription];
      *(_DWORD *)buf = 138543618;
      long long v31 = v14;
      __int16 v32 = 2114;
      long long v33 = v16;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_ERROR, "%{public}@[%{public}@] Failed to modify characteristic notifications: lost self", buf, 0x16u);
    }
    uint64_t v17 = *(void *)(a1 + 40);
    long long v9 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    (*(void (**)(uint64_t, void, void *))(v17 + 16))(v17, 0, v9);
  }
}

void __83__HMDHAPAccessory__enableNotification_forCharacteristics_message_clientIdentifier___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v11 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  if (WeakRetained)
  {
    if (v6)
    {
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24))
      {
        objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
        objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), a3);
      }
    }
    else
    {
      uint64_t v8 = [v11 copy];
      uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
      unint64_t v10 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = v8;

      *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

- (HMCameraUserNotificationSettings)cameraProfileNotificationSettings
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v3 = self->_cameraProfileNotificationSettings;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (NSSet)cameraProfiles
{
  os_unfair_recursive_lock_lock_with_options();
  accessoryProfiles = self->super._accessoryProfiles;
  if (accessoryProfiles) {
    [(NSMutableSet *)accessoryProfiles objectsPassingTest:&__block_literal_global_1788];
  }
  else {
  uint64_t v4 = [MEMORY[0x1E4F1CAD0] set];
  }
  os_unfair_recursive_lock_unlock();
  return (NSSet *)v4;
}

uint64_t __77__HMDHAPAccessory_WoL__updateSuspendedStateWithConnectionState_hapAccessory___block_invoke(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t result = [*(id *)(a1 + 32) suspendedState];
  if (*(unsigned char *)(a1 + 48)) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = result == 2;
  }
  if (v3)
  {
    id v5 = (void *)MEMORY[0x1D9452090](result);
    id v6 = *(id *)(a1 + 32);
    uint64_t v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      long long v12 = HMFGetLogIdentifier();
      long long v13 = HAPAccessorySuspendedStateDescription();
      uint64_t v14 = [*(id *)(a1 + 40) identifier];
      int v15 = 138543874;
      long long v16 = v12;
      __int16 v17 = 2112;
      uint64_t v18 = v13;
      __int16 v19 = 2112;
      id v20 = v14;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Received disconnection from a '%@' accessory: %@", (uint8_t *)&v15, 0x20u);
    }
    uint64_t v8 = 3;
    goto LABEL_15;
  }
  if (*(unsigned char *)(a1 + 48)) {
    BOOL v4 = result == 3;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    id v5 = (void *)MEMORY[0x1D9452090](result);
    id v6 = *(id *)(a1 + 32);
    uint64_t v7 = HMFGetOSLogHandle();
    uint64_t v8 = 1;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = HMFGetLogIdentifier();
      unint64_t v10 = HAPAccessorySuspendedStateDescription();
      id v11 = [*(id *)(a1 + 40) identifier];
      int v15 = 138543874;
      long long v16 = v9;
      __int16 v17 = 2112;
      uint64_t v18 = v10;
      __int16 v19 = 2112;
      id v20 = v11;
      uint64_t v8 = 1;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Received connection from a '%@' accessory: %@", (uint8_t *)&v15, 0x20u);
    }
LABEL_15:

    return [*(id *)(a1 + 32) setSuspendedState:v8];
  }
  return result;
}

- (id)expectedTransport
{
  BOOL v3 = [(HMDAccessory *)self home];
  int v4 = [v3 isThreadCapable];

  if (v4
    && ([(HMDHAPAccessory *)self supportsThread]
     || [(HMDHAPAccessory *)self hasThreadServer]))
  {
    return @"Thread";
  }
  if ([(HMDHAPAccessory *)self hasIPLink]) {
    return @"WiFi-Ethernet";
  }
  if ([(HMDHAPAccessory *)self hasBTLELink]) {
    return @"BLE";
  }
  return @"Unknown";
}

- (HMDAccessoryMetric)accessoryMetric
{
  return self->_accessoryMetric;
}

- (id)matchingHAPAccessoryServerIdentifierWithLinkType:(int64_t)a3
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  [(HMDHAPAccessory *)self transportInformationInstances];
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v6 = [v5 countByEnumeratingWithState:&v19 objects:v29 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v20;
    while (2)
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v20 != v8) {
          objc_enumerationMutation(v5);
        }
        unint64_t v10 = *(void **)(*((void *)&v19 + 1) + 8 * i);
        if (objc_msgSend(v10, "linkType", (void)v19) == a3)
        {
          long long v16 = [v10 serverIdentifier];

          goto LABEL_18;
        }
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v19 objects:v29 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }

  if (a3)
  {
    id v11 = (void *)MEMORY[0x1D9452090]();
    long long v12 = self;
    long long v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = HMFGetLogIdentifier();
      if ((unint64_t)a3 > 2) {
        int v15 = @"Undefined";
      }
      else {
        int v15 = off_1E6A0B860[a3];
      }
      __int16 v17 = v15;
      *(_DWORD *)buf = 138543874;
      __int16 v24 = v14;
      __int16 v25 = 2112;
      id v26 = v17;
      __int16 v27 = 2112;
      id v28 = v5;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_ERROR, "%{public}@*** no server identifier found in transport information array for link type %@, %@", buf, 0x20u);
    }
    long long v16 = 0;
  }
  else
  {
    long long v16 = [(HMDAccessory *)self identifier];
  }
LABEL_18:

  return v16;
}

- (void)checkHAPSessionRestore
{
  BOOL v3 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __41__HMDHAPAccessory_checkHAPSessionRestore__block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v3, block);
}

- (void)enableNotification:(BOOL)a3 forCharacteristics:(id)a4 message:(id)a5 clientIdentifier:(id)a6
{
  id v10 = a4;
  id v11 = a5;
  id v12 = a6;
  long long v13 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __82__HMDHAPAccessory_enableNotification_forCharacteristics_message_clientIdentifier___block_invoke;
  block[3] = &unk_1E6A154B0;
  BOOL v21 = a3;
  void block[4] = self;
  id v18 = v10;
  id v19 = v11;
  id v20 = v12;
  id v14 = v12;
  id v15 = v11;
  id v16 = v10;
  dispatch_async(v13, block);
}

- (BOOL)isSecuritySessionOpen
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  BOOL v3 = [(HMDHAPAccessory *)self transportInformationInstances];
  uint64_t v4 = [v3 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v17;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v17 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v16 + 1) + 8 * i);
        uint64_t v9 = [v8 hapAccessory];
        id v10 = [v9 server];
        if ([v10 isSecuritySessionOpen] && objc_msgSend(v8, "linkType") == 1)
        {
          id v11 = [v8 serverIdentifier];
          id v12 = [(HMDAccessory *)self identifier];
          char v13 = [v11 isEqual:v12];

          if (v13)
          {
            BOOL v14 = 1;
            goto LABEL_14;
          }
        }
        else
        {
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v5);
  }
  BOOL v14 = 0;
LABEL_14:

  return v14;
}

- (void)requestResource:(id)a3 queue:(id)a4 completionHandler:(id)a5
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  uint64_t v19 = MEMORY[0x1E4F143A8];
  uint64_t v20 = 3221225472;
  uint64_t v21 = __59__HMDHAPAccessory_requestResource_queue_completionHandler___block_invoke;
  long long v22 = &unk_1E6A19A28;
  __int16 v23 = self;
  id v11 = v10;
  id v26 = v11;
  id v12 = v8;
  id v24 = v12;
  id v13 = v9;
  id v25 = v13;
  BOOL v14 = (void (**)(void *, void))_Block_copy(&v19);
  if ([(HMDHAPAccessory *)self isSecuritySessionOpen])
  {
    id v15 = (void *)MEMORY[0x1D9452090]();
    long long v16 = self;
    long long v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      long long v18 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v28 = v18;
      _os_log_impl(&dword_1D49D5000, v17, OS_LOG_TYPE_INFO, "%{public}@Not establishing local HAP connection for resource request because security session is already open", buf, 0xCu);
    }
    v14[2](v14, 0);
  }
  else
  {
    [(HMDHAPAccessory *)self establishLocalHAPConnectionWithQueue:v13 completion:v14];
  }
}

uint64_t __47__HMDHAPAccessory_isIPSecureSessionEstablished__block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  if ([v2 linkType] == 1)
  {
    BOOL v3 = [v2 hapAccessory];
    uint64_t v4 = [v3 server];

    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 0;
    }
    id v6 = v5;

    uint64_t v7 = [v6 isSecuritySessionOpen];
  }
  else
  {
    uint64_t v7 = 0;
  }

  return v7;
}

- (NSNumber)hapInstanceId
{
  id v2 = (void *)MEMORY[0x1E4F5BC00];
  BOOL v3 = [(HMDHAPAccessory *)self uniqueIdentifier];
  uint64_t v4 = [v2 instanceIDForUniqueIdentifier:v3];

  return (NSNumber *)v4;
}

- (void)establishLocalHAPConnectionWithQueue:(id)a3 completion:(id)a4
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  uint64_t v7 = (void (**)(id, id))a4;
  id v8 = (void *)MEMORY[0x1D9452090]();
  id v9 = self;
  id v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    id v11 = HMFGetLogIdentifier();
    *(_DWORD *)long long v22 = 138543362;
    *(void *)&v22[4] = v11;
    _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, "%{public}@Establishing local HAP connection", v22, 0xCu);
  }
  id v12 = [(HMDAccessory *)v9 home];
  if (v12)
  {
    *(void *)long long v22 = 0;
    uint64_t v13 = [(HMDHAPAccessory *)v9 bridge];
    BOOL v14 = (void *)v13;
    if (v13) {
      id v15 = (void *)v13;
    }
    else {
      id v15 = v9;
    }
    id v16 = v15;

    id v17 = (id)[v16 preferredHAPAccessoryForOperation:10 linkType:v22];
    [v12 retrieveHAPAccessoryForHMDAccessory:v16 linkType:*(void *)v22 forceRetrieve:0 queue:v6 completion:v7];
  }
  else
  {
    long long v18 = (void *)MEMORY[0x1D9452090]();
    uint64_t v19 = v9;
    uint64_t v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      uint64_t v21 = HMFGetLogIdentifier();
      *(_DWORD *)long long v22 = 138543362;
      *(void *)&v22[4] = v21;
      _os_log_impl(&dword_1D49D5000, v20, OS_LOG_TYPE_ERROR, "%{public}@Cannot establish local HAP connection because home reference is nil", v22, 0xCu);
    }
    id v16 = [MEMORY[0x1E4F28C58] hmErrorWithCode:20];
    v7[2](v7, v16);
  }
}

- (void)readCharacteristicValues:(id)a3 source:(unint64_t)a4 message:(id)a5 queue:(id)a6 logEvent:(id)a7 completionHandler:(id)a8
{
  id v15 = a3;
  id v16 = a5;
  id v17 = a6;
  id v18 = a7;
  id v19 = a8;
  id v20 = objc_alloc(MEMORY[0x1E4F653F0]);
  uint64_t v21 = NSString;
  long long v22 = MEMORY[0x1D94505D0](self, a2);
  uint64_t v23 = [v21 stringWithFormat:@"%@, %s:%ld", v22, "/Library/Caches/com.apple.xbs/Sources/HomeKit_executables_legacy/Sources/homed/HMDHAPAccessory.m", 6398];
  id v44 = (id)[v20 initWithName:v23];

  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = __92__HMDHAPAccessory_readCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke;
  aBlock[3] = &unk_1E6A17640;
  id v24 = v44;
  id v41 = v24;
  id v25 = v19;
  id v43 = v25;
  id v32 = v17;
  id v42 = v32;
  id v26 = _Block_copy(aBlock);
  objc_initWeak(&location, self);
  v33[0] = MEMORY[0x1E4F143A8];
  v33[1] = 3221225472;
  v33[2] = __92__HMDHAPAccessory_readCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_3;
  v33[3] = &unk_1E6A0B060;
  objc_copyWeak(v38, &location);
  id v27 = v18;
  id v34 = v27;
  id v28 = v15;
  id v35 = v28;
  v38[1] = (id)a4;
  id v29 = v16;
  id v36 = v29;
  id v30 = v26;
  id v37 = v30;
  long long v31 = _Block_copy(v33);
  [(HMDHAPAccessory *)self _wakeAccessoryIfNeededForCharacteristicRequests:v28 source:a4 activity:v24 completion:v31];

  objc_destroyWeak(v38);
  objc_destroyWeak(&location);

  __HMFActivityScopeLeave();
}

- (void)_wakeAccessoryIfNeededForCharacteristicRequests:(id)a3 source:(unint64_t)a4 activity:(id)a5 completion:(id)a6
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a5;
  id v12 = a6;
  if ([(HMDHAPAccessory *)self canWakeViaCustomWoBLE])
  {
    v22[0] = MEMORY[0x1E4F143A8];
    v22[1] = 3221225472;
    v22[2] = __94__HMDHAPAccessory__wakeAccessoryIfNeededForCharacteristicRequests_source_activity_completion___block_invoke;
    v22[3] = &unk_1E6A13370;
    v22[4] = self;
    id v23 = v11;
    id v24 = v12;
    [(HMDHAPAccessory *)self wakeOrScanForSuspendedAccessoryForRequests:v10 source:a4 completion:v22];
  }
  else
  {
    unsigned __int8 v21 = 0;
    id v20 = 0;
    BOOL v13 = [(HMDHAPAccessory *)self canProceedWithRequests:v10 suspended:&v21 error:&v20];
    id v14 = v20;
    if (!v13)
    {
      id v15 = (void *)MEMORY[0x1D9452090]();
      id v16 = self;
      id v17 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        id v18 = HMFGetLogIdentifier();
        id v19 = [(HMDAccessory *)v16 identifier];
        *(_DWORD *)buf = 138543874;
        id v26 = v18;
        __int16 v27 = 2112;
        id v28 = v19;
        __int16 v29 = 2112;
        id v30 = v10;
        _os_log_impl(&dword_1D49D5000, v17, OS_LOG_TYPE_ERROR, "%{public}@Accessory %@ is suspended and should not wake up for requests: %@", buf, 0x20u);
      }
    }
    (*((void (**)(id, void, id))v12 + 2))(v12, v21, v14);
  }
}

void __92__HMDHAPAccessory_readCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_3(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  aBlocuint64_t k = MEMORY[0x1E4F143A8];
  uint64_t v12 = 3221225472;
  BOOL v13 = __92__HMDHAPAccessory_readCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_4;
  id v14 = &unk_1E6A0B038;
  objc_copyWeak(v19, (id *)(a1 + 64));
  id v15 = *(id *)(a1 + 32);
  id v7 = *(id *)(a1 + 40);
  id v8 = *(void **)(a1 + 72);
  id v16 = v7;
  v19[1] = v8;
  id v17 = *(id *)(a1 + 48);
  char v20 = a2;
  id v18 = *(id *)(a1 + 56);
  id v9 = _Block_copy(&aBlock);
  id v10 = v9;
  if (v5) {
    (*((void (**)(void *, id))v9 + 2))(v9, v5);
  }
  else {
    objc_msgSend(WeakRetained, "_readCharacteristicValues:localOperationRequired:source:message:logEvent:completionHandler:errorBlock:", *(void *)(a1 + 40), 0, *(void *)(a1 + 72), *(void *)(a1 + 48), *(void *)(a1 + 32), *(void *)(a1 + 56), v9, aBlock, v12, v13, v14, v15, v16, v17);
  }

  objc_destroyWeak(v19);
}

- (BOOL)canProceedWithRequests:(id)a3 suspended:(BOOL *)a4 error:(id *)a5
{
  id v8 = a3;
  if ([(HMDHAPAccessory *)self canWakeUpViaWoL]
    && [(HMDHAPAccessory *)self isSuspended])
  {
    id v9 = [(HMDAccessory *)self home];
    BOOL v10 = [(HMDHAPAccessory *)self residentCanWakeForWOL];
    if ([(HMDAccessory *)self isReachable])
    {
      BOOL v11 = 1;
      if (!v10)
      {
LABEL_9:
        if (![(HMDHAPAccessory *)self canWakeBasedOnCharacteristicRequests:v8])
        {
          if (a5)
          {
            *a5 = [MEMORY[0x1E4F28C58] hmErrorWithCode:103];
          }
          BOOL v12 = 0;
          if (a4) {
            *a4 = 1;
          }
          goto LABEL_15;
        }
LABEL_10:
        BOOL v12 = 1;
LABEL_15:

        goto LABEL_16;
      }
    }
    else
    {
      BOOL v11 = [(HMDHAPAccessory *)self isReachableViaBSP];
      if (!v10) {
        goto LABEL_9;
      }
    }
    if (([v9 isCurrentDeviceAvailableResident] | v11) != 1) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  BOOL v12 = 1;
LABEL_16:

  return v12;
}

- (BOOL)canWakeViaCustomWoBLE
{
  if ([(HMDAccessory *)self isReachable]
    || isWatch()
    || ![(HMDHAPAccessory *)self custom1WoBLE])
  {
    return 0;
  }
  BOOL v3 = [(HMDAccessory *)self home];
  BOOL v4 = [v3 homeLocation] == 1;

  return v4;
}

- (void)_readCharacteristicValues:(id)a3 localOperationRequired:(BOOL)a4 source:(unint64_t)a5 message:(id)a6 logEvent:(id)a7 completionHandler:(id)a8 errorBlock:(id)a9
{
  id v15 = a3;
  id v16 = a6;
  id v17 = a7;
  id v18 = a8;
  id v19 = a9;
  id v20 = objc_alloc(MEMORY[0x1E4F653F0]);
  unsigned __int8 v21 = NSString;
  long long v22 = MEMORY[0x1D94505D0](self, a2);
  id v23 = [v21 stringWithFormat:@"%@, %s:%ld", v22, "/Library/Caches/com.apple.xbs/Sources/HomeKit_executables_legacy/Sources/homed/HMDHAPAccessory.m", 6567];
  id v40 = (id)[v20 initWithName:v23];

  id v24 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __121__HMDHAPAccessory__readCharacteristicValues_localOperationRequired_source_message_logEvent_completionHandler_errorBlock___block_invoke;
  block[3] = &unk_1E6A0B100;
  BOOL v39 = a4;
  void block[4] = self;
  id v32 = v15;
  id v33 = v16;
  id v34 = v17;
  unint64_t v38 = a5;
  id v36 = v18;
  id v35 = v40;
  id v37 = v19;
  id v25 = v19;
  id v26 = v18;
  id v27 = v17;
  id v28 = v16;
  id v29 = v15;
  dispatch_async(v24, block);

  __HMFActivityScopeLeave();
}

- (void)_evaluateLocalOperation:(int64_t)a3 state:(id)a4 completion:(id)a5
{
  id v8 = a4;
  id v9 = (void (**)(id, void))a5;
  uint64_t v26 = 0;
  id v27 = &v26;
  uint64_t v28 = 0x2020000000;
  char v29 = 1;
  if (![(HMDHAPAccessory *)self hasBTLELink]
    || [(HMDHAPAccessory *)self isBLELinkConnected]
    || [(HMDHAPAccessory *)self hasIPLink] && [(HMDAccessory *)self isReachable])
  {
    if (v9) {
      v9[2](v9, *((unsigned __int8 *)v27 + 24));
    }
  }
  else
  {
    BOOL v10 = [(HMDAccessory *)self home];
    BOOL v11 = [v10 primaryResident];
    char v12 = [v11 isReachable];

    BOOL v13 = [v10 residentDeviceManager];
    char v14 = [v13 isCurrentDeviceAvailableResident];

    id v15 = [(HMDAccessory *)self workQueue];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __60__HMDHAPAccessory__evaluateLocalOperation_state_completion___block_invoke;
    block[3] = &unk_1E6A0B4E8;
    id v18 = v10;
    id v19 = self;
    char v24 = v14;
    char v25 = v12;
    id v20 = v8;
    long long v22 = &v26;
    int64_t v23 = a3;
    unsigned __int8 v21 = v9;
    id v16 = v10;
    dispatch_async(v15, block);
  }
  _Block_object_dispose(&v26, 8);
}

- (void)_performOperation:(int64_t)a3 linkType:(int64_t)a4 operationBlock:(id)a5 errorBlock:(id)a6
{
  uint64_t v105 = *MEMORY[0x1E4F143B8];
  id v10 = a5;
  BOOL v11 = (void (**)(id, void *))a6;
  unint64_t v94 = a4;
  char v12 = [(HMDHAPAccessory *)self preferredHAPAccessoryForOperation:a3 linkType:&v94];
  BOOL v13 = [v12 server];
  if (!v10 && v11)
  {
    char v14 = [MEMORY[0x1E4F28C58] errorWithDomain:*MEMORY[0x1E4F2D140] code:20 userInfo:0];
    v11[2](v11, v14);
    goto LABEL_68;
  }
  uint64_t v15 = [MEMORY[0x1E4F653F0] currentActivity];
  uint64_t v87 = (void *)v15;
  if (v94)
  {
    char v14 = (void *)v15;
    if (!isiOSDevice()) {
      goto LABEL_12;
    }
    if (v94 != 2) {
      goto LABEL_12;
    }
    BOOL v16 = [(HMDAccessory *)self isRemoteAccessEnabled];
    if ((a3 & 0xFFFFFFFFFFFFFFFELL) != 2 || !v16) {
      goto LABEL_12;
    }
    id v17 = [(HMDAccessory *)self identifier];
    id v18 = [(HMDHAPAccessory *)self matchingTransportInformationWithServerIdentifier:v17 linkType:v94];

    if (!v18 || ([v18 isReachable] & 1) != 0)
    {

LABEL_12:
      id v19 = v13;
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        id v20 = v19;
      }
      else {
        id v20 = 0;
      }
      id v21 = v20;

      long long v81 = v21;
      if ([v21 isReachable] && (objc_msgSend(v21, "isReadyForOperation:", a3) & 1) == 0)
      {
        uint64_t v85 = v13;
        id v43 = (void *)MEMORY[0x1D9452090]();
        id v44 = self;
        long long v45 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
        {
          __int16 v46 = HMFGetLogIdentifier();
          id v47 = [v21 shortDescription];
          *(_DWORD *)buf = 138543618;
          uint64_t v96 = v46;
          __int16 v97 = 2112;
          __int16 v98 = v47;
          _os_log_impl(&dword_1D49D5000, v45, OS_LOG_TYPE_INFO, "%{public}@BTLE server is reachable but not ready for operation: %@. Retrieving the server", buf, 0x16u);
        }
        int v48 = [(HMDAccessory *)v44 workQueue];
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = __72__HMDHAPAccessory__performOperation_linkType_operationBlock_errorBlock___block_invoke;
        block[3] = &unk_1E6A0AFC0;
        void block[4] = v44;
        int64_t v92 = a3;
        unint64_t v93 = v94;
        id v90 = v10;
        int v91 = v11;
        char v14 = v87;
        id v89 = v87;
        dispatch_async(v48, block);

        goto LABEL_50;
      }
      if (v19)
      {
        int v22 = [v12 isReachable];
        int64_t v23 = (void *)MEMORY[0x1D9452090]();
        char v24 = self;
        char v25 = HMFGetOSLogHandle();
        BOOL v26 = os_log_type_enabled(v25, OS_LOG_TYPE_INFO);
        if (v22)
        {
          if (v26)
          {
            id v75 = HMFGetLogIdentifier();
            id v83 = v13;
            if ((unint64_t)a3 > 0xA) {
              id v27 = @"Undefined";
            }
            else {
              id v27 = off_1E6A0B878[a3];
            }
            id v73 = v27;
            id v72 = [v12 serverIdentifier];
            long long v80 = v23;
            if (v94 > 2) {
              id v67 = @"Undefined";
            }
            else {
              id v67 = off_1E6A0B860[v94];
            }
            id v69 = v67;
            [(HMDHAPAccessory *)v24 suspendedState];
            id v70 = HAPAccessorySuspendedStateDescription();
            *(_DWORD *)buf = 138544386;
            uint64_t v96 = v75;
            __int16 v97 = 2112;
            __int16 v98 = v73;
            __int16 v99 = 2112;
            __int16 v100 = v72;
            __int16 v101 = 2112;
            __int16 v102 = v69;
            __int16 v103 = 2112;
            __int16 v104 = v70;
            _os_log_impl(&dword_1D49D5000, v25, OS_LOG_TYPE_INFO, "%{public}@Accessory '%@' operation: HAPAccessory %@/%@ is reachable. Suspended State: %@", buf, 0x34u);

            BOOL v13 = v83;
            int64_t v23 = v80;
          }

          [(HMDAccessory *)v24 uuid];

          char v14 = v87;
          if ([(HMDHAPAccessory *)v24 canWakeUpViaWoL]
            && [(HMDHAPAccessory *)v24 isSuspended])
          {
            [(HMDHAPAccessory *)v24 _handleUnreachableAccessoryToPerformOperation:a3 operationBlock:v10 errorBlock:v11];
          }
          else if (v10)
          {
            (*((void (**)(id, void *))v10 + 2))(v10, v12);
          }
        }
        else
        {
          if (v26)
          {
            long long v78 = v23;
            id v49 = HMFGetLogIdentifier();
            char v76 = [(HMDAccessory *)v24 identifier];
            if ((unint64_t)a3 > 0xA) {
              id v50 = @"Undefined";
            }
            else {
              id v50 = off_1E6A0B878[a3];
            }
            id v74 = v50;
            if (v94 > 2) {
              __int16 v68 = @"Undefined";
            }
            else {
              __int16 v68 = off_1E6A0B860[v94];
            }
            id v71 = v68;
            *(_DWORD *)buf = 138544130;
            uint64_t v96 = v49;
            __int16 v97 = 2112;
            __int16 v98 = v76;
            __int16 v99 = 2112;
            __int16 v100 = v74;
            __int16 v101 = 2112;
            __int16 v102 = v71;
            _os_log_impl(&dword_1D49D5000, v25, OS_LOG_TYPE_INFO, "%{public}@Accessory %@ '%@' operation: Unable to retrieve HAPAccessory for linkType %@ - trying the next link", buf, 0x2Au);

            int64_t v23 = v78;
          }

          [(HMDAccessory *)v24 uuid];

          -[HMDHAPAccessory _performOperation:linkType:operationBlock:errorBlock:](v24, "_performOperation:linkType:operationBlock:errorBlock:", a3);
          char v14 = v87;
        }
        goto LABEL_67;
      }
      uint64_t v85 = v13;
      id v33 = [(HMDAccessory *)self home];
      if ([v33 isResidentFirstAccessoryCommunicationEnabled])
      {
        id v34 = (void *)MEMORY[0x1D9452090]();
        id v35 = self;
        id v36 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
        {
          id v37 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543362;
          uint64_t v96 = v37;
          _os_log_impl(&dword_1D49D5000, v36, OS_LOG_TYPE_INFO, "%{public}@No configured HAP accessory, attempting retrieval for accessory", buf, 0xCu);
        }
        unint64_t v38 = v94;
        BOOL v39 = v35;
        int64_t v40 = a3;
        id v41 = v10;
        id v42 = v11;
        char v14 = v87;
      }
      else
      {
        if (![(HMDAccessory *)self isReachable])
        {
          uint64_t v58 = [v33 homeManager];
          id v59 = [v58 residentMesh];
          long long v79 = [v59 bestResidentDeviceForAccessory:self];

          id v60 = (void *)MEMORY[0x1D9452090]();
          long long v61 = self;
          uint64_t v62 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
          {
            HMFGetLogIdentifier();
            v63 = long long v77 = v60;
            id v64 = [v33 primaryResident];
            int v65 = [v64 isCurrentDevice];
            id v66 = @"NO";
            *(_DWORD *)buf = 138543874;
            uint64_t v96 = v63;
            __int16 v97 = 2112;
            if (v65) {
              id v66 = @"YES";
            }
            __int16 v98 = v66;
            __int16 v99 = 2112;
            __int16 v100 = v79;
            _os_log_impl(&dword_1D49D5000, v62, OS_LOG_TYPE_DEFAULT, "%{public}@Accessory unreachable, isPrimary: %@, reachable via: %@", buf, 0x20u);

            id v60 = v77;
          }

          [(HMDHAPAccessory *)v61 _performOperation:a3 linkType:v94 operationBlock:v10 errorBlock:v11];

          char v14 = v87;
          goto LABEL_49;
        }
        unint64_t v38 = v94;
        BOOL v39 = self;
        int64_t v40 = a3;
        id v41 = v10;
        id v42 = v11;
      }
      [(HMDHAPAccessory *)v39 _retrieveHAPAccessoryToPerformOperation:v40 linkType:v38 operationBlock:v41 errorBlock:v42 activity:v14];
LABEL_49:

LABEL_50:
      BOOL v13 = v85;
LABEL_67:

      goto LABEL_68;
    }
    __int16 v52 = (void *)MEMORY[0x1D9452090]();
    uint64_t v53 = self;
    __int16 v54 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
    {
      HMFGetLogIdentifier();
      uint64_t v55 = v82 = v52;
      uint64_t v56 = [(HMDAccessory *)v53 identifier];
      id v86 = v13;
      int v57 = off_1E6A0B878[a3];
      *(_DWORD *)buf = 138543874;
      uint64_t v96 = v55;
      __int16 v97 = 2112;
      __int16 v98 = v56;
      __int16 v99 = 2112;
      __int16 v100 = v57;
      _os_log_impl(&dword_1D49D5000, v54, OS_LOG_TYPE_INFO, "%{public}@Accessory %@ '%@' operation: BTLE link unreachable and there are other transports - trying the next link", buf, 0x20u);

      BOOL v13 = v86;
      __int16 v52 = v82;
    }

    [(HMDHAPAccessory *)v53 _performOperation:a3 linkType:v94 operationBlock:v10 errorBlock:v11];

    char v14 = v87;
  }
  else
  {
    id v84 = v13;
    uint64_t v28 = (void *)MEMORY[0x1D9452090]();
    char v29 = self;
    id v30 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      uint64_t v31 = HMFGetLogIdentifier();
      if ((unint64_t)a4 > 2) {
        id v32 = @"Undefined";
      }
      else {
        id v32 = off_1E6A0B860[a4];
      }
      uint64_t v51 = v32;
      *(_DWORD *)buf = 138543618;
      uint64_t v96 = v31;
      __int16 v97 = 2112;
      __int16 v98 = v51;
      _os_log_impl(&dword_1D49D5000, v30, OS_LOG_TYPE_INFO, "%{public}@No accessory of linkType %@ or higher", buf, 0x16u);
    }
    [(HMDAccessory *)v29 uuid];

    [(HMDHAPAccessory *)v29 _handleUnreachableAccessoryToPerformOperation:a3 operationBlock:v10 errorBlock:v11];
    BOOL v13 = v84;
    char v14 = v87;
  }
LABEL_68:
}

- (unint64_t)supportedTransports
{
  unint64_t v3 = [(HMDHAPAccessory *)self hasIPLink];
  if ([(HMDHAPAccessory *)self hasBTLELink]) {
    return v3 | 2;
  }
  else {
    return v3;
  }
}

- (void)setReachability:(BOOL)a3 serverIdentifier:(id)a4 linkType:(int64_t)a5
{
  id v8 = a4;
  id v9 = [(HMDAccessory *)self workQueue];
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = __61__HMDHAPAccessory_setReachability_serverIdentifier_linkType___block_invoke;
  v11[3] = &unk_1E6A12FF8;
  id v12 = v8;
  int64_t v13 = a5;
  v11[4] = self;
  BOOL v14 = a3;
  id v10 = v8;
  dispatch_async(v9, v11);
}

void __59__HMDHAPAccessory_requestResource_queue_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    BOOL v4 = (void *)MEMORY[0x1D9452090]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = HMFGetLogIdentifier();
      int v16 = 138543362;
      id v17 = v7;
      _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to establish local HAP connection for resource read", (uint8_t *)&v16, 0xCu);
    }
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  else
  {
    id v8 = [*(id *)(a1 + 32) anyIPServer];
    id v9 = v8;
    if (v8)
    {
      [v8 requestResource:*(void *)(a1 + 40) queue:*(void *)(a1 + 48) completionHandler:*(void *)(a1 + 56)];
    }
    else
    {
      id v10 = (void *)MEMORY[0x1D9452090]();
      id v11 = *(id *)(a1 + 32);
      id v12 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        int64_t v13 = HMFGetLogIdentifier();
        int v16 = 138543362;
        id v17 = v13;
        _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_ERROR, "%{public}@Failed to find a HAP accessory server for resource read", (uint8_t *)&v16, 0xCu);
      }
      uint64_t v14 = *(void *)(a1 + 56);
      uint64_t v15 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
      (*(void (**)(uint64_t, void, void *))(v14 + 16))(v14, 0, v15);
    }
  }
}

- (void)updateActiveDisconnectOnIdleTimeout:(double)a3
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v5 = [(HMDHAPAccessory *)self bridge];
  id v6 = v5;
  if (v5) {
    [v5 getPrimaryHAPAccessories];
  }
  else {
  id v7 = [(HMDHAPAccessory *)self getPrimaryHAPAccessories];
  }
  os_unfair_recursive_lock_lock_with_options();
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v8 = v7;
  uint64_t v9 = [v8 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v9)
  {
    uint64_t v10 = *(void *)v14;
    do
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (*(void *)v14 != v10) {
          objc_enumerationMutation(v8);
        }
        id v12 = objc_msgSend(*(id *)(*((void *)&v13 + 1) + 8 * i), "server", (void)v13);
        [v12 updateActiveDisconnectOnIdleTimeout:a3];
      }
      uint64_t v9 = [v8 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v9);
  }

  os_unfair_recursive_lock_unlock();
}

- (id)anyIPServer
{
  id v3 = [(HMDHAPAccessory *)self primaryIPServer];
  if (!v3)
  {
    BOOL v4 = [(HMDHAPAccessory *)self bridge];
    id v5 = v4;
    if (v4)
    {
      id v3 = [v4 primaryIPServer];
    }
    else
    {
      id v3 = 0;
    }
  }
  return v3;
}

- (id)primaryIPServer
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  [(HMDHAPAccessory *)self getPrimaryHAPAccessories];
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v3 = [v2 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v13;
    do
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        if (*(void *)v13 != v5) {
          objc_enumerationMutation(v2);
        }
        id v7 = *(void **)(*((void *)&v12 + 1) + 8 * i);
        if (objc_msgSend(v7, "linkType", (void)v12) == 1)
        {
          id v8 = [v7 server];
          objc_opt_class();
          if (objc_opt_isKindOfClass()) {
            uint64_t v9 = v8;
          }
          else {
            uint64_t v9 = 0;
          }
          id v10 = v9;

          if (v10 && ([v7 isReachable] & 1) != 0) {
            goto LABEL_16;
          }
        }
      }
      uint64_t v4 = [v2 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v4);
  }
  id v8 = 0;
LABEL_16:

  return v8;
}

- (void)_enableNotification:(BOOL)a3 forCharacteristics:(id)a4 message:(id)a5 clientIdentifier:(id)a6
{
  BOOL v8 = a3;
  uint64_t v167 = *MEMORY[0x1E4F143B8];
  id v85 = a4;
  id v84 = a5;
  id v10 = a6;
  id v11 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v11);

  objc_initWeak(&location, self);
  v151[0] = 0;
  v151[1] = v151;
  v151[2] = 0x2020000000;
  char v152 = 0;
  uint64_t v147 = 0;
  id v148 = &v147;
  uint64_t v149 = 0x2020000000;
  char v150 = 0;
  v145[0] = 0;
  v145[1] = v145;
  v145[2] = 0x3032000000;
  v145[3] = __Block_byref_object_copy__49311;
  v145[4] = __Block_byref_object_dispose__49312;
  id v146 = 0;
  uint64_t v139 = 0;
  char v140 = &v139;
  uint64_t v141 = 0x3032000000;
  long long v142 = __Block_byref_object_copy__49311;
  long long v143 = __Block_byref_object_dispose__49312;
  id v144 = 0;
  dispatch_group_t v83 = dispatch_group_create();
  id v86 = [(HMDAccessory *)self home];
  id v138 = (id)[objc_alloc(MEMORY[0x1E4F653F0]) initWithName:@"Modify characteristic notifications"];
  long long v12 = (void *)MEMORY[0x1D9452090]();
  int v91 = self;
  HMFGetOSLogHandle();
  long long v13 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    HMFGetLogIdentifier();
    id v14 = (id)objc_claimAutoreleasedReturnValue();
    long long v15 = [v138 identifier];
    long long v16 = [v15 shortDescription];
    HMFBooleanToString();
    uint64_t v17 = (__CFString *)(id)objc_claimAutoreleasedReturnValue();
    uint64_t v18 = [v85 shortDescription];
    *(_DWORD *)buf = 138544386;
    id v158 = v14;
    __int16 v159 = 2114;
    __int16 v160 = v16;
    __int16 v161 = 2112;
    __int16 v162 = v17;
    __int16 v163 = 2112;
    id v164 = v10;
    __int16 v165 = 2112;
    uint64_t v166 = v18;
    _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Setting notifications enabled to %@ for client identifier %@ for characteristics: %@", buf, 0x34u);
  }
  if ([v85 count])
  {
    id v87 = v85;
    id v89 = v87;
    if (v10)
    {
      id v89 = v87;
      if (!v8)
      {
        v134[0] = MEMORY[0x1E4F143A8];
        v134[1] = 3221225472;
        v134[2] = __83__HMDHAPAccessory__enableNotification_forCharacteristics_message_clientIdentifier___block_invoke;
        v134[3] = &unk_1E6A0B3A8;
        id v135 = v10;
        v136 = v91;
        id v137 = v138;
        id v89 = objc_msgSend(v87, "na_filter:", v134);
      }
    }
    if (v8 && [v10 hasPrefix:@"com.apple.HomeKitDaemon"])
    {
      id v19 = (void *)MEMORY[0x1D9452090]();
      id v20 = v91;
      HMFGetOSLogHandle();
      id v21 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        HMFGetLogIdentifier();
        id v22 = (id)objc_claimAutoreleasedReturnValue();
        int64_t v23 = [v138 identifier];
        char v24 = [v23 shortDescription];
        *(_DWORD *)buf = 138543618;
        id v158 = v22;
        __int16 v159 = 2114;
        __int16 v160 = v24;
        _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Updating cached characteristic notification registrations up front because client is homed", buf, 0x16u);
      }
      long long v132 = 0u;
      long long v133 = 0u;
      long long v130 = 0u;
      long long v131 = 0u;
      id v25 = v87;
      uint64_t v26 = [v25 countByEnumeratingWithState:&v130 objects:v156 count:16];
      if (v26)
      {
        uint64_t v27 = *(void *)v131;
        do
        {
          for (uint64_t i = 0; i != v26; ++i)
          {
            if (*(void *)v131 != v27) {
              objc_enumerationMutation(v25);
            }
            [*(id *)(*((void *)&v130 + 1) + 8 * i) setNotificationEnabled:1 forClientIdentifier:v10];
          }
          uint64_t v26 = [v25 countByEnumeratingWithState:&v130 objects:v156 count:16];
        }
        while (v26);
      }
    }
    if (isWatch() || shouldSkipLocalAccessoryNotificationRegistration(v86, v91, v89))
    {
      char v29 = (void *)MEMORY[0x1D9452090]();
      id v30 = v91;
      HMFGetOSLogHandle();
      uint64_t v31 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        HMFGetLogIdentifier();
        id v32 = (id)objc_claimAutoreleasedReturnValue();
        id v33 = [v138 identifier];
        id v34 = [v33 shortDescription];
        uint64_t v35 = [v87 count];
        *(_DWORD *)buf = 138544130;
        id v158 = v32;
        __int16 v159 = 2114;
        __int16 v160 = v34;
        __int16 v161 = 2048;
        __int16 v162 = (__CFString *)v35;
        __int16 v163 = 2112;
        id v164 = v10;
        _os_log_impl(&dword_1D49D5000, v31, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Modifying %tu characteristic notifications on primary for client: %@", buf, 0x2Au);
      }
      [(HMDHAPAccessory *)v30 _remotelySetNotificationsEnabled:v8 forCharacteristic:v89 clientIdentifier:v10];
      v127[0] = MEMORY[0x1E4F143A8];
      v127[1] = 3221225472;
      v127[2] = __83__HMDHAPAccessory__enableNotification_forCharacteristics_message_clientIdentifier___block_invoke_644;
      v127[3] = &unk_1E6A0B3D0;
      BOOL v129 = v8;
      id v128 = v10;
      objc_msgSend(v87, "na_each:", v127);
      *((unsigned char *)v148 + 24) = 1;

      id v89 = 0;
    }
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __83__HMDHAPAccessory__enableNotification_forCharacteristics_message_clientIdentifier___block_invoke_2;
    aBlock[3] = &unk_1E6A0B3F8;
    objc_copyWeak(&v126, &location);
    long long v123 = v145;
    long long v124 = v151;
    __int16 v125 = &v139;
    dispatch_group_t group = v83;
    dispatch_group_t v122 = group;
    uint64_t v88 = _Block_copy(aBlock);
    unint64_t v120 = 0;
    int64_t v92 = [(HMDHAPAccessory *)v91 preferredHAPAccessoryForOperation:4 linkType:&v120];
    *(void *)&long long v36 = 138543618;
    long long v82 = v36;
    while (1)
    {
      if (!objc_msgSend(v89, "count", v82) || !v120)
      {
        id v74 = [(HMDAccessory *)v91 workQueue];
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = __83__HMDHAPAccessory__enableNotification_forCharacteristics_message_clientIdentifier___block_invoke_646;
        block[3] = &unk_1E6A0B448;
        objc_copyWeak(&v102, &location);
        id v94 = v84;
        __int16 v98 = &v147;
        id v75 = v87;
        BOOL v103 = v8;
        id v95 = v75;
        __int16 v99 = v151;
        __int16 v100 = v145;
        id v96 = v10;
        id v97 = v138;
        __int16 v101 = &v139;
        dispatch_group_notify(group, v74, block);

        objc_destroyWeak(&v102);
        objc_destroyWeak(&v126);

        goto LABEL_68;
      }
      dispatch_group_enter(group);
      id v37 = [v92 server];
      if (v37) {
        break;
      }
      if (v120 == 2)
      {
        long long v118 = 0u;
        long long v119 = 0u;
        long long v116 = 0u;
        long long v117 = 0u;
        id v38 = v87;
        uint64_t v39 = [v38 countByEnumeratingWithState:&v116 objects:v155 count:16];
        if (v39)
        {
          uint64_t v40 = *(void *)v117;
          do
          {
            for (uint64_t j = 0; j != v39; ++j)
            {
              if (*(void *)v117 != v40) {
                objc_enumerationMutation(v38);
              }
              [*(id *)(*((void *)&v116 + 1) + 8 * j) setNotificationEnabled:v8 forClientIdentifier:v10];
            }
            uint64_t v39 = [v38 countByEnumeratingWithState:&v116 objects:v155 count:16];
          }
          while (v39);
        }

        *((unsigned char *)v148 + 24) = 1;
        dispatch_group_leave(group);
        [(HMDHAPAccessory *)v91 _updateAccessoryTracking];
      }
      else
      {
        if (isFeatureMatteriPhoneOnlyPairingControlEnabled()
          && !v8
          && [(HMDHAPAccessory *)v91 supportsCHIP])
        {
          __int16 v52 = (void *)MEMORY[0x1D9452090]();
          uint64_t v53 = v91;
          HMFGetOSLogHandle();
          __int16 v54 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
          {
            HMFGetLogIdentifier();
            id v55 = (id)objc_claimAutoreleasedReturnValue();
            uint64_t v56 = [v138 identifier];
            int v57 = [v56 shortDescription];
            *(_DWORD *)buf = v82;
            id v158 = v55;
            __int16 v159 = 2114;
            __int16 v160 = v57;
            _os_log_impl(&dword_1D49D5000, v54, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Not connecting to Matter accessory when disabling notifications", buf, 0x16u);
          }
          long long v114 = 0u;
          long long v115 = 0u;
          long long v112 = 0u;
          long long v113 = 0u;
          id v58 = v87;
          uint64_t v59 = [v58 countByEnumeratingWithState:&v112 objects:v154 count:16];
          if (v59)
          {
            uint64_t v60 = *(void *)v113;
            do
            {
              for (uint64_t k = 0; k != v59; ++k)
              {
                if (*(void *)v113 != v60) {
                  objc_enumerationMutation(v58);
                }
                [*(id *)(*((void *)&v112 + 1) + 8 * k) setNotificationEnabled:0 forClientIdentifier:v10];
              }
              uint64_t v59 = [v58 countByEnumeratingWithState:&v112 objects:v154 count:16];
            }
            while (v59);
          }

          *((unsigned char *)v148 + 24) = 1;
LABEL_44:
          dispatch_group_leave(group);
          goto LABEL_63;
        }
        uint64_t v62 = (void *)MEMORY[0x1D9452090]();
        id v63 = v91;
        HMFGetOSLogHandle();
        id v64 = (id)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
        {
          HMFGetLogIdentifier();
          id v65 = (id)objc_claimAutoreleasedReturnValue();
          id v66 = [v138 identifier];
          id v67 = [v66 shortDescription];
          __int16 v68 = @"Undefined";
          if (v120 <= 2) {
            __int16 v68 = off_1E6A0B860[v120];
          }
          id v69 = v68;
          *(_DWORD *)buf = 138543874;
          id v158 = v65;
          __int16 v159 = 2114;
          __int16 v160 = v67;
          __int16 v161 = 2112;
          __int16 v162 = v69;
          _os_log_impl(&dword_1D49D5000, v64, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Retrieving HAP accessory for linkType: %@", buf, 0x20u);
        }
        unint64_t v70 = v120;
        id v71 = [(HMDAccessory *)v63 workQueue];
        v104[0] = MEMORY[0x1E4F143A8];
        v104[1] = 3221225472;
        v104[2] = __83__HMDHAPAccessory__enableNotification_forCharacteristics_message_clientIdentifier___block_invoke_645;
        v104[3] = &unk_1E6A0B420;
        objc_copyWeak(v110, &location);
        id v72 = v138;
        v110[1] = (id)v120;
        id v105 = v72;
        id v109 = &v139;
        __int16 v106 = group;
        BOOL v111 = v8;
        id v107 = v89;
        id v108 = v88;
        [v86 retrieveHAPAccessoryForHMDAccessory:v63 linkType:v70 forceRetrieve:0 queue:v71 completion:v104];

        objc_destroyWeak(v110);
      }
LABEL_63:
      uint64_t v73 = [(HMDHAPAccessory *)v91 preferredHAPAccessoryForOperation:4 linkType:&v120];

      int64_t v92 = (void *)v73;
    }
    if ([v92 isReachable])
    {
      [(HMDHAPAccessory *)v91 _setNotificationsEnabled:v8 forCharacteristics:v89 hapAccessory:v92 activity:v138 completion:v88];
      goto LABEL_63;
    }
    id v42 = (void *)MEMORY[0x1D9452090]();
    id v43 = v91;
    HMFGetOSLogHandle();
    id v44 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
    {
      HMFGetLogIdentifier();
      id v45 = (id)objc_claimAutoreleasedReturnValue();
      __int16 v46 = [v138 identifier];
      id v47 = [v46 shortDescription];
      int v48 = @"Undefined";
      if (v120 <= 2) {
        int v48 = off_1E6A0B860[v120];
      }
      id v49 = v48;
      *(_DWORD *)buf = 138543874;
      id v158 = v45;
      __int16 v159 = 2114;
      __int16 v160 = v47;
      __int16 v161 = 2112;
      __int16 v162 = v49;
      _os_log_impl(&dword_1D49D5000, v44, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Not modifying characteristic notifications using linkType %@: no accessory server found", buf, 0x20u);
    }
    uint64_t v50 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
    uint64_t v51 = (void *)v140[5];
    v140[5] = v50;

    goto LABEL_44;
  }
  char v76 = (void *)MEMORY[0x1D9452090]();
  long long v77 = v91;
  HMFGetOSLogHandle();
  long long v78 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v78, OS_LOG_TYPE_INFO))
  {
    HMFGetLogIdentifier();
    id v79 = (id)objc_claimAutoreleasedReturnValue();
    long long v80 = [v138 identifier];
    long long v81 = [v80 shortDescription];
    *(_DWORD *)buf = 138543618;
    id v158 = v79;
    __int16 v159 = 2114;
    __int16 v160 = v81;
    _os_log_impl(&dword_1D49D5000, v78, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] No characteristics to modify notifications for", buf, 0x16u);
  }
  [v84 respondWithSuccess];
LABEL_68:
  __HMFActivityScopeLeave();

  _Block_object_dispose(&v139, 8);
  _Block_object_dispose(v145, 8);

  _Block_object_dispose(&v147, 8);
  _Block_object_dispose(v151, 8);
  objc_destroyWeak(&location);
}

void __82__HMDHAPAccessory_ThreadManagement__maybeCommissionToThreadNetworkWithCompletion___block_invoke(uint64_t a1)
{
  id v2 = objc_alloc(MEMORY[0x1E4F653F0]);
  uint64_t v3 = NSString;
  uint64_t v4 = MEMORY[0x1D94505D0](*(void *)(a1 + 32), *(void *)(a1 + 48));
  uint64_t v5 = [v3 stringWithFormat:@"%@, %s:%ld", v4, "/Library/Caches/com.apple.xbs/Sources/HomeKit_executables_legacy/Sources/homed/HMDHAPAccessory+ThreadManagement.m", 216];
  id v11 = (id)[v2 initWithName:v5];

  [v11 begin];
  id v10 = v11;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = __82__HMDHAPAccessory_ThreadManagement__maybeCommissionToThreadNetworkWithCompletion___block_invoke_2;
  v7[3] = &unk_1E6A17D78;
  id v6 = *(void **)(a1 + 32);
  id v9 = *(id *)(a1 + 40);
  id v8 = v10;
  [v6 _maybeCommissionToThreadNetworkWithActivity:v8 completion:v7];

  __HMFActivityScopeLeave();
  __HMFActivityScopeLeave();
}

- (void)_maybeCommissionToThreadNetworkWithActivity:(id)a3 completion:(id)a4
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = (void (**)(id, void))a4;
  id v8 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v8);

  char v9 = [(HMDHAPAccessory *)self reachableTransports];
  if (![(HMDHAPAccessory *)self hasBTLELink] || (v9 & 1) != 0)
  {
    long long v16 = (void *)MEMORY[0x1D9452090]();
    uint64_t v17 = self;
    uint64_t v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      id v19 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v32 = v19;
      _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_INFO, "%{public}@Either not a thread-capable accessory or already commissioned", buf, 0xCu);
    }
    v7[2](v7, 0);
  }
  else
  {
    id v30 = 0;
    id v10 = [(HMDHAPAccessory *)self _findThreadControlPointCharacteristicWithError:&v30];
    id v11 = v30;
    if (v10)
    {
      long long v12 = (void *)[objc_alloc(MEMORY[0x1E4F5BBB8]) initWithValue:3];
      long long v13 = (void *)[objc_alloc(MEMORY[0x1E4F5BBA8]) initWithOperationType:v12 threadNetworkCredentials:0 formingAllowed:0];
      id v29 = v11;
      id v14 = [v13 serializeWithError:&v29];
      id v15 = v29;

      if (v14)
      {
        v25[0] = MEMORY[0x1E4F143A8];
        v25[1] = 3221225472;
        v25[2] = __92__HMDHAPAccessory_ThreadManagement___maybeCommissionToThreadNetworkWithActivity_completion___block_invoke;
        v25[3] = &unk_1E6A176B8;
        uint64_t v28 = v7;
        v25[4] = self;
        id v26 = v6;
        id v27 = v10;
        [(HMDHAPAccessory *)self _writeThreadControlPointCharacteristic:v27 value:v14 activity:v26 completion:v25];
      }
      else
      {
        id v20 = (void *)MEMORY[0x1D9452090]();
        id v21 = self;
        id v22 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          HMFGetLogIdentifier();
          int64_t v23 = v24 = v20;
          *(_DWORD *)buf = 138543618;
          id v32 = v23;
          __int16 v33 = 2112;
          id v34 = v15;
          _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_ERROR, "%{public}@Unable to serialize request TLV: %@", buf, 0x16u);

          id v20 = v24;
        }

        ((void (**)(id, id))v7)[2](v7, v15);
      }
    }
    else
    {
      ((void (**)(id, id))v7)[2](v7, v11);
      id v15 = v11;
    }
  }
}

uint64_t __82__HMDHAPAccessory_ThreadManagement__maybeCommissionToThreadNetworkWithCompletion___block_invoke_2(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v2 = *(void **)(a1 + 32);
  return [v2 invalidate];
}

- (BOOL)_handleUpdatedServicesForWiFiManagementController
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = [(HMDHAPAccessory *)self wiFiManagementController];
  if (![(HMDHAPAccessory *)self isPrimary]
    || ([(HMDHAPAccessory *)self findServiceWithServiceType:@"0000022A-0000-1000-8000-0026BB765291"], (uint64_t v4 = objc_claimAutoreleasedReturnValue()) == 0))
  {
    if (v3)
    {
      id v19 = (void *)MEMORY[0x1D9452090]();
      id v20 = self;
      id v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        id v22 = HMFGetLogIdentifier();
        int v25 = 138543362;
        uint64_t v26 = (uint64_t)v22;
        _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_DEBUG, "%{public}@Removing Wi-Fi Management Controller", (uint8_t *)&v25, 0xCu);
      }
      [(HMDHAPAccessory *)v20 setWiFiManagementController:0];
      uint64_t v5 = 0;
      goto LABEL_14;
    }
    uint64_t v5 = 0;
LABEL_16:
    BOOL v23 = 0;
    goto LABEL_17;
  }
  uint64_t v5 = (void *)v4;
  if (v3)
  {
    id v6 = [v3 service];
    id v7 = [v6 uuid];
    id v8 = [v5 uuid];
    char v9 = [v7 isEqual:v8];

    if (v9) {
      goto LABEL_16;
    }
  }
  id v10 = (void *)MEMORY[0x1D9452090]();
  id v11 = self;
  long long v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v13 = HMFGetLogIdentifier();
    id v14 = (void *)v13;
    id v15 = @"Replacing";
    if (!v3) {
      id v15 = @"Creating";
    }
    int v25 = 138543618;
    uint64_t v26 = v13;
    __int16 v27 = 2112;
    uint64_t v28 = v15;
    _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_DEBUG, "%{public}@%@ Wi-Fi Management Controller", (uint8_t *)&v25, 0x16u);
  }
  long long v16 = [HMDWiFiManagementController alloc];
  uint64_t v17 = [(HMDAccessory *)v11 workQueue];
  uint64_t v18 = [(HMDWiFiManagementController *)v16 initWithAccessory:v11 wiFiTransportService:v5 workQueue:v17];
  [(HMDHAPAccessory *)v11 setWiFiManagementController:v18];

LABEL_14:
  BOOL v23 = 1;
LABEL_17:

  return v23;
}

- (void)_handleRemoveStagedSoftwareUpdate:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HMDHAPAccessory *)self firmwareUpdateManager];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = __69__HMDHAPAccessory_FirmwareUpdate___handleRemoveStagedSoftwareUpdate___block_invoke;
  v7[3] = &unk_1E6A197F0;
  id v8 = v4;
  id v6 = v4;
  [v5 rescindStagedAsset:self completion:v7];
}

void __69__HMDHAPAccessory_FirmwareUpdate___handleRemoveStagedSoftwareUpdate___block_invoke(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a1 + 32);
  if (a2)
  {
    id v4 = [MEMORY[0x1E4F28C58] hmErrorWithCode:58];
    [v2 respondWithError:v4];
  }
  else
  {
    uint64_t v3 = *(void **)(a1 + 32);
    [v3 respondWithSuccess];
  }
}

- (void)_handleChangeUpdateSource:(id)a3
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [v4 numberForKey:*MEMORY[0x1E4F2E068]];
  id v6 = [v4 stringForKey:*MEMORY[0x1E4F2E060]];
  id v7 = [v4 stringForKey:*MEMORY[0x1E4F2E050]];
  uint64_t v8 = [v4 BOOLForKey:*MEMORY[0x1E4F2E070]];
  if (!v5)
  {
    uint64_t v13 = (void *)MEMORY[0x1D9452090](v8);
    id v14 = self;
    id v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      long long v16 = HMFGetLogIdentifier();
      uint64_t v17 = [v4 messagePayload];
      *(_DWORD *)id v19 = 138543618;
      *(void *)&v19[4] = v16;
      *(_WORD *)&v19[12] = 2112;
      *(void *)&v19[14] = v17;
      uint64_t v18 = "%{public}@Missing source from message payload: %@";
LABEL_10:
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_ERROR, v18, v19, 0x16u);
    }
LABEL_11:

    id v11 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
    long long v12 = v4;
    goto LABEL_12;
  }
  uint64_t v9 = v8;
  if ([v5 integerValue] == 2 && !objc_msgSend(v6, "length"))
  {
    uint64_t v13 = (void *)MEMORY[0x1D9452090]();
    id v14 = self;
    id v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      long long v16 = HMFGetLogIdentifier();
      uint64_t v17 = [v4 messagePayload];
      *(_DWORD *)id v19 = 138543618;
      *(void *)&v19[4] = v16;
      *(_WORD *)&v19[12] = 2112;
      *(void *)&v19[14] = v17;
      uint64_t v18 = "%{public}@Missing path from message payload: %@";
      goto LABEL_10;
    }
    goto LABEL_11;
  }
  id v10 = [(HMDHAPAccessory *)self firmwareUpdateManager];
  id v11 = objc_msgSend(v10, "changeAccessory:source:path:documentationPath:userInitiatedStaging:", self, objc_msgSend(v5, "integerValue"), v6, v7, v9);

  long long v12 = v4;
  if (v11)
  {
LABEL_12:
    objc_msgSend(v12, "respondWithError:", v11, *(_OWORD *)v19, *(void *)&v19[16], v20);
    goto LABEL_13;
  }
  [v4 respondWithSuccess];
LABEL_13:
}

- (void)_startUpdateSessionWithRequest:(id)a3
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [v4 dataForKey:*MEMORY[0x1E4F2E058]];
  if (v5)
  {
    id v6 = [MEMORY[0x1E4F28DC0] deserializeObjectWithData:v5 allowedClass:objc_opt_class() frameworkClasses:&unk_1F2DC6A78];
    if (!v6)
    {
      id v21 = (void *)MEMORY[0x1D9452090]();
      id v22 = self;
      BOOL v23 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
      {
        char v24 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v37 = v24;
        _os_log_impl(&dword_1D49D5000, v23, OS_LOG_TYPE_INFO, "%{public}@Invalid software update in message payload", buf, 0xCu);
      }
      uint64_t v8 = [MEMORY[0x1E4F28C58] hmErrorWithCode:22];
      [v4 respondWithError:v8];
      goto LABEL_27;
    }
    id v7 = [(HMDHAPAccessory *)self firmwareUpdateManager];
    uint64_t v8 = [v7 sessionForAccessory:self];

    if (v8) {
      goto LABEL_4;
    }
    uint64_t v26 = [(HMDHAPAccessory *)self firmwareUpdateManager];
    uint64_t v8 = [v26 UARPAccessoryForHMDAccessory:self];

    if (v8)
    {
      __int16 v27 = [(HMDHAPAccessory *)self firmwareUpdateManager];
      uint64_t v28 = [v27 addSessionForUARPAccessory:v8];

      if (v28)
      {

        uint64_t v8 = (void *)v28;
LABEL_4:
        if (((_os_feature_enabled_impl() & 1) != 0
           || CFPreferencesGetAppBooleanValue(@"MatterOTA", @"/Library/Managed Preferences/mobile/com.apple.homed.plist", 0))&& [(HMDHAPAccessory *)self supportsCHIP])
        {
          uint64_t v9 = (void *)MEMORY[0x1D9452090]();
          id v10 = self;
          id v11 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
          {
            long long v12 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543618;
            id v37 = v12;
            __int16 v38 = 2112;
            uint64_t v39 = v10;
            _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_INFO, "%{public}@Marking software update as Requested for %@", buf, 0x16u);
          }
          [v8 updateAvailableSoftwareUpdateState:5];
          uint64_t v13 = [(HMDAccessory *)v10 home];
          id v14 = [v13 homeManager];
          id v15 = [v14 matterSoftwareUpdateProviderDelegate];
          [v15 notifyUpdateRequestedForHMDHAPAccessory:v10 isUserTriggered:1];

          [v4 respondWithPayload:0 error:0];
          goto LABEL_27;
        }
        id v35 = 0;
        [v8 startManualUpdate:v6 error:&v35];
        id v25 = v35;
        [v4 respondWithPayload:0 error:v25];
LABEL_26:

LABEL_27:
        goto LABEL_28;
      }
      uint64_t v29 = (void *)MEMORY[0x1D9452090]();
      __int16 v33 = self;
      uint64_t v31 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        id v32 = HMFGetLogIdentifier();
        id v34 = [(HMDHAPAccessory *)v33 name];
        *(_DWORD *)buf = 138543618;
        id v37 = v32;
        __int16 v38 = 2112;
        uint64_t v39 = v34;
        _os_log_impl(&dword_1D49D5000, v31, OS_LOG_TYPE_ERROR, "%{public}@Failed to start update for accessory %@ because a session could not be established", buf, 0x16u);

        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v29 = (void *)MEMORY[0x1D9452090]();
      id v30 = self;
      uint64_t v31 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        id v32 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        id v37 = v32;
        __int16 v38 = 2112;
        uint64_t v39 = v30;
        _os_log_impl(&dword_1D49D5000, v31, OS_LOG_TYPE_ERROR, "%{public}@UARP accessory is not found for accessory %@", buf, 0x16u);
LABEL_24:
      }
    }

    id v25 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v4 respondWithError:v25];
    goto LABEL_26;
  }
  long long v16 = (void *)MEMORY[0x1D9452090]();
  uint64_t v17 = self;
  uint64_t v18 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    id v19 = HMFGetLogIdentifier();
    uint64_t v20 = [v4 messagePayload];
    *(_DWORD *)buf = 138543618;
    id v37 = v19;
    __int16 v38 = 2112;
    uint64_t v39 = v20;
    _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_ERROR, "%{public}@Missing serialized software update from message payload: %@", buf, 0x16u);
  }
  id v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
  [v4 respondWithError:v6];
LABEL_28:
}

- (void)_startUpdateFromCurrentDeviceWithRequest:(id)a3
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  BOOL v6 = [(HMDAccessory *)self isReachable];
  if (((_os_feature_enabled_impl() & 1) != 0
     || CFPreferencesGetAppBooleanValue(@"MatterOTA", @"/Library/Managed Preferences/mobile/com.apple.homed.plist", 0))&& [(HMDHAPAccessory *)self supportsCHIP]&& ![(HMDAccessory *)self isReachable])
  {
    id v11 = [(HMDAccessory *)self home];
    long long v12 = [v11 homeManager];
    uint64_t v13 = [v12 matterSoftwareUpdateProviderDelegate];
    char v14 = [v13 canEstablishConnectionForHMDHAPAccessory:self];

    if (v14) {
      goto LABEL_6;
    }
  }
  else if (v6)
  {
LABEL_6:
    id v7 = (void *)MEMORY[0x1D9452090]();
    uint64_t v8 = self;
    uint64_t v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      id v10 = HMFGetLogIdentifier();
      int v21 = 138543362;
      id v22 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Attempting to start firmware update session for reachable accessory", (uint8_t *)&v21, 0xCu);
    }
    [(HMDHAPAccessory *)v8 _startUpdateSessionWithRequest:v4];
    goto LABEL_13;
  }
  id v15 = (void *)MEMORY[0x1D9452090]();
  long long v16 = self;
  uint64_t v17 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    uint64_t v18 = HMFGetLogIdentifier();
    id v19 = [(HMDHAPAccessory *)v16 logIdentifier];
    int v21 = 138543618;
    id v22 = v18;
    __int16 v23 = 2112;
    char v24 = v19;
    _os_log_impl(&dword_1D49D5000, v17, OS_LOG_TYPE_ERROR, "%{public}@Failed to start update for accessory %@ because it is not reachable and we don't have a resident to delegate to", (uint8_t *)&v21, 0x16u);
  }
  uint64_t v20 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
  [v4 respondWithError:v20];

LABEL_13:
}

- (void)_startManualUpdateFromBestSuitableDevice:(id)a3
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [(HMDAccessory *)self home];
  if (([v5 isCurrentDeviceConfirmedPrimaryResident] & 1) != 0
    || ([v5 isResidentSupported] & 1) == 0)
  {
    [(HMDHAPAccessory *)self _startUpdateFromCurrentDeviceWithRequest:v4];
  }
  else
  {
    BOOL v6 = (void *)MEMORY[0x1D9452090]();
    id v7 = self;
    uint64_t v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      long long v16 = v9;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Query for available primary resident to perform the update", buf, 0xCu);
    }
    char v14 = v7;
    id v10 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v14 count:1];
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = __76__HMDHAPAccessory_FirmwareUpdate___startManualUpdateFromBestSuitableDevice___block_invoke;
    v11[3] = &unk_1E6A19248;
    v11[4] = v7;
    id v12 = v5;
    id v13 = v4;
    [v12 queryPrimaryResidentReachabilityForAccessories:v10 completion:v11];
  }
}

void __76__HMDHAPAccessory_FirmwareUpdate___startManualUpdateFromBestSuitableDevice___block_invoke(id *a1, void *a2)
{
  id v3 = a2;
  objc_initWeak(&location, a1[4]);
  id v4 = [a1[4] workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __76__HMDHAPAccessory_FirmwareUpdate___startManualUpdateFromBestSuitableDevice___block_invoke_2;
  block[3] = &unk_1E6A17780;
  objc_copyWeak(&v10, &location);
  id v7 = v3;
  id v8 = a1[5];
  id v9 = a1[6];
  id v5 = v3;
  dispatch_async(v4, block);

  objc_destroyWeak(&v10);
  objc_destroyWeak(&location);
}

void __76__HMDHAPAccessory_FirmwareUpdate___startManualUpdateFromBestSuitableDevice___block_invoke_2(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  id v3 = [*(id *)(a1 + 32) firstObject];
  int v4 = objc_msgSend(v3, "hmf_BOOLForKey:", @"kAccessoryIsReachableKey");

  if (v4)
  {
    id v5 = [*(id *)(a1 + 40) residentDeviceManager];
    BOOL v6 = [v5 primaryResidentDevice];

    id v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = WeakRetained;
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      id v10 = HMFGetLogIdentifier();
      int v19 = 138543618;
      uint64_t v20 = v10;
      __int16 v21 = 2112;
      id v22 = v6;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Redispatching start update to primary resident %@ ", (uint8_t *)&v19, 0x16u);
    }
    id v12 = *(void **)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 48);
    id v13 = [v8 uuid];
    char v14 = [v8 workQueue];
    [v12 redispatchToResidentMessage:v11 target:v13 responseQueue:v14];
  }
  else
  {
    id v15 = (void *)MEMORY[0x1D9452090]();
    id v16 = WeakRetained;
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      uint64_t v18 = HMFGetLogIdentifier();
      int v19 = 138543362;
      uint64_t v20 = v18;
      _os_log_impl(&dword_1D49D5000, v17, OS_LOG_TYPE_INFO, "%{public}@Primary resident has no reachability with accessory, starting update in current device", (uint8_t *)&v19, 0xCu);
    }
    [v16 _startUpdateFromCurrentDeviceWithRequest:*(void *)(a1 + 48)];
  }
}

- (void)_handleStartUpdate:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = __54__HMDHAPAccessory_FirmwareUpdate___handleStartUpdate___block_invoke;
  v7[3] = &unk_1E6A197C8;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

uint64_t __54__HMDHAPAccessory_FirmwareUpdate___handleStartUpdate___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _startManualUpdateFromBestSuitableDevice:*(void *)(a1 + 40)];
}

- (BOOL)_handleUpdatedServicesForFirmwareUpdateProfile:(id)a3
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = +[HMDDeviceCapabilities deviceCapabilities];
  char v6 = [v5 supportsFirmwareUpdate];

  if (v6)
  {
    id v7 = [(HMDAccessory *)self home];
    id v45 = [v7 homeManager];

    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    id v46 = v4;
    id obj = v4;
    uint64_t v8 = [obj countByEnumeratingWithState:&v50 objects:v60 count:16];
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)v51;
      uint64_t v11 = @"00000236-0000-1000-8000-0026BB765291";
      while (2)
      {
        uint64_t v12 = 0;
        uint64_t v47 = v9;
        do
        {
          if (*(void *)v51 != v10) {
            objc_enumerationMutation(obj);
          }
          id v13 = *(HMDAccessoryFirmwareUpdateProfile **)(*((void *)&v50 + 1) + 8 * v12);
          char v14 = (void *)MEMORY[0x1D9452090]();
          id v15 = self;
          id v16 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            HMFGetLogIdentifier();
            uint64_t v17 = v10;
            uint64_t v18 = self;
            uint64_t v20 = v19 = v11;
            __int16 v21 = [(HMDAccessoryFirmwareUpdateProfile *)v13 serviceType];
            *(_DWORD *)buf = 138543874;
            id v55 = v20;
            __int16 v56 = 2112;
            int v57 = v13;
            __int16 v58 = 2112;
            uint64_t v59 = v21;
            _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_DEBUG, "%{public}@Found service: %@, %@", buf, 0x20u);

            uint64_t v11 = v19;
            self = v18;
            uint64_t v10 = v17;
            uint64_t v9 = v47;
          }

          id v22 = [(HMDAccessoryFirmwareUpdateProfile *)v13 serviceType];
          int v23 = [v22 isEqualToString:v11];

          if (v23)
          {
            id v32 = [HMDAccessoryFirmwareUpdateProfile alloc];
            __int16 v33 = [(HMDAccessoryFirmwareUpdateProfile *)v13 accessory];
            id v34 = [(HMDAccessory *)v15 workQueue];
            id v35 = [(HMDAccessoryFirmwareUpdateProfile *)v32 initWithAccessory:v33 service:v13 workQueue:v34];

            long long v36 = [(HMDHAPAccessory *)v15 firmwareUpdateProfile];
            char v37 = HMFEqualObjects();

            uint64_t v28 = v45;
            if ((v37 & 1) == 0)
            {
              __int16 v38 = (void *)MEMORY[0x1D9452090]();
              uint64_t v39 = v15;
              uint64_t v40 = HMFGetOSLogHandle();
              if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
              {
                id v41 = HMFGetLogIdentifier();
                *(_DWORD *)buf = 138543618;
                id v55 = v41;
                __int16 v56 = 2112;
                int v57 = v35;
                _os_log_impl(&dword_1D49D5000, v40, OS_LOG_TYPE_INFO, "%{public}@Adding new accessory firmware update profile: %@", buf, 0x16u);
              }
              [(HMDHAPAccessory *)v39 setFirmwareUpdateProfile:v35];
              id v42 = [(HMDHAPAccessory *)v39 firmwareUpdateProfile];
              [v42 configure];

              id v43 = [v45 accessoryFirmwareUpdateManager];
              [v43 registerAccessory:v39];
            }
            LOBYTE(v24) = v37 ^ 1;

            id v4 = v46;
            goto LABEL_25;
          }
          ++v12;
        }
        while (v9 != v12);
        uint64_t v9 = [obj countByEnumeratingWithState:&v50 objects:v60 count:16];
        if (v9) {
          continue;
        }
        break;
      }
    }

    char v24 = [(HMDHAPAccessory *)self firmwareUpdateProfile];

    if (v24)
    {
      uint64_t v25 = (void *)MEMORY[0x1D9452090]();
      uint64_t v26 = self;
      char v24 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
      {
        __int16 v27 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v55 = v27;
        _os_log_impl(&dword_1D49D5000, v24, OS_LOG_TYPE_INFO, "%{public}@Update service not available; removing third-party firmware update profile",
          buf,
          0xCu);
      }
      [(HMDHAPAccessory *)v26 setFirmwareUpdateProfile:0];
      id obja = [(HMDHAPAccessory *)v26 firmwareUpdateManager];
      [obja unregisterAccessory:v26];
      LOBYTE(v24) = 0;
      uint64_t v28 = v45;
      id v4 = v46;
    }
    else
    {
      uint64_t v28 = v45;
      id v4 = v46;
    }
LABEL_25:
  }
  else
  {
    uint64_t v29 = (void *)MEMORY[0x1D9452090]();
    id v30 = self;
    char v24 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      uint64_t v31 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v55 = v31;
      _os_log_impl(&dword_1D49D5000, v24, OS_LOG_TYPE_INFO, "%{public}@Accessory firmware update feature is not supported on this device", buf, 0xCu);
    }
    LOBYTE(v24) = 0;
  }

  return (char)v24;
}

- (BOOL)isAppleAccessory
{
  return [(HMDHAPAccessory *)self identityType] == 2;
}

- (unint64_t)identityType
{
  id v3 = [(HMDAccessory *)self manufacturer];
  if ([v3 isEqualToString:@"Apple Inc."])
  {
    id v4 = [(HMDAccessory *)self model];

    if (v4) {
      return 2;
    }
  }
  else
  {
  }
  char v6 = [(HMDAccessory *)self productData];

  if (v6) {
    return 1;
  }
  if ((_os_feature_enabled_impl() & 1) == 0
    && !CFPreferencesGetAppBooleanValue(@"MatterOTA", @"/Library/Managed Preferences/mobile/com.apple.homed.plist", 0)|| ![(HMDHAPAccessory *)self supportsCHIP])
  {
    return 0;
  }
  id v7 = [(HMDHAPAccessory *)self chipStorage];
  uint64_t v8 = [v7 vendorID];

  uint64_t v9 = [(HMDHAPAccessory *)self chipStorage];
  uint64_t v10 = [v9 productID];

  if (v10) {
    BOOL v11 = v8 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = 3;
  }

  return v5;
}

- (BOOL)supportsFirmwareUpdate
{
  id v2 = [(HMDHAPAccessory *)self firmwareUpdateProfile];
  BOOL v3 = v2 != 0;

  return v3;
}

- (BOOL)hasResidentWithFirmwareUpdatesSupport
{
  id v2 = [(HMDAccessory *)self home];
  BOOL v3 = [v2 primaryResident];
  char v4 = [v3 supportsResidentFirmwareUpdate];

  return v4;
}

- (BOOL)isAutomaticThirdPartyAccessorySoftwareUpdateEnabled
{
  id v2 = [(HMDAccessory *)self home];
  char v3 = [v2 isAutomaticThirdPartyAccessorySoftwareUpdateEnabled];

  return v3;
}

- (void)_destroyDiagnosticsManager
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  char v3 = (void *)MEMORY[0x1D9452090](self, a2);
  char v4 = self;
  unint64_t v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    char v6 = HMFGetLogIdentifier();
    id v7 = [(HMDHAPAccessory *)v4 diagnosticsManager];
    int v9 = 138543618;
    uint64_t v10 = v6;
    __int16 v11 = 2112;
    uint64_t v12 = v7;
    _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@Destroying diagnostics manager %@", (uint8_t *)&v9, 0x16u);
  }
  uint64_t v8 = [(HMDHAPAccessory *)v4 diagnosticsManager];
  [v8 shutDown];

  [(HMDHAPAccessory *)v4 setDiagnosticsManager:0];
}

- (id)_createDiagnosticsManager:(id)a3
{
  id v4 = a3;
  unint64_t v5 = [[HMDAccessoryDiagnosticsManager alloc] initWithAccessory:self service:v4];

  return v5;
}

- (void)_createDiagnosticManagerForMatterDevice:(id)a3
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  unint64_t v5 = [(HMDHAPAccessory *)self matterDiagnosticManager];
  if (!v5)
  {
    unint64_t v5 = [[HMDMatterAccessoryDiagnosticsManager alloc] initWithAccessory:self];
    char v6 = (void *)MEMORY[0x1D9452090]();
    id v7 = self;
    uint64_t v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      int v9 = HMFGetLogIdentifier();
      int v10 = 138543618;
      __int16 v11 = v9;
      __int16 v12 = 2112;
      uint64_t v13 = v5;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Starting matter diagnostic manager: %@", (uint8_t *)&v10, 0x16u);
    }
    [(HMDMatterAccessoryDiagnosticsManager *)v5 start];
    [(HMDHAPAccessory *)v7 setMatterDiagnosticManager:v5];
  }
  [(HMDMatterAccessoryDiagnosticsManager *)v5 setMatterDevice:v4];
}

- (BOOL)_handleUpdatedServicesForDiagnosticsManager:(id)a3
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  unint64_t v5 = [(HMDHAPAccessory *)self dataStreamController];

  if (v5)
  {
    char v6 = [(HMDAccessory *)self msgDispatcher];

    if (v6)
    {
      id v7 = [(HMDHAPAccessory *)self findServiceWithServiceType:*MEMORY[0x1E4F2DE10]];
      uint64_t v8 = [(HMDHAPAccessory *)self diagnosticsManager];
      int v9 = v8;
      if (v7)
      {

        if (v9)
        {
          int v10 = (void *)MEMORY[0x1D9452090]();
          __int16 v11 = self;
          __int16 v12 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
          {
            uint64_t v13 = HMFGetLogIdentifier();
            int v31 = 138543362;
            id v32 = v13;
            _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_INFO, "%{public}@Diagnostics manager is already present for diagnostics service", (uint8_t *)&v31, 0xCu);
          }
          goto LABEL_14;
        }
        int v23 = [(HMDHAPAccessory *)self _createDiagnosticsManager:v7];
        [(HMDHAPAccessory *)self setDiagnosticsManager:v23];

        char v24 = (void *)MEMORY[0x1D9452090]();
        uint64_t v25 = self;
        uint64_t v26 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v27 = HMFGetLogIdentifier();
          uint64_t v28 = [(HMDHAPAccessory *)v25 diagnosticsManager];
          int v31 = 138543874;
          id v32 = v27;
          __int16 v33 = 2112;
          id v34 = v28;
          __int16 v35 = 2112;
          long long v36 = v7;
          _os_log_impl(&dword_1D49D5000, v26, OS_LOG_TYPE_DEFAULT, "%{public}@Created diagnostics manager %@ with service: %@", (uint8_t *)&v31, 0x20u);
        }
        uint64_t v29 = [(HMDHAPAccessory *)v25 diagnosticsManager];
        [v29 start];
      }
      else
      {

        if (!v9)
        {
LABEL_14:
          BOOL v15 = 0;
LABEL_23:

          goto LABEL_24;
        }
        [(HMDHAPAccessory *)self _destroyDiagnosticsManager];
      }
      BOOL v15 = 1;
      goto LABEL_23;
    }
    id v16 = (void *)MEMORY[0x1D9452090]();
    uint64_t v17 = self;
    uint64_t v18 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    int v19 = HMFGetLogIdentifier();
    int v31 = 138543362;
    id v32 = v19;
    uint64_t v20 = "%{public}@Message dispatcher isn't set, cannot create diagnostics manager";
    __int16 v21 = v18;
    os_log_type_t v22 = OS_LOG_TYPE_ERROR;
    goto LABEL_17;
  }
  uint64_t v14 = [(HMDHAPAccessory *)self diagnosticsManager];

  if (!v14)
  {
    id v16 = (void *)MEMORY[0x1D9452090]();
    uint64_t v17 = self;
    uint64_t v18 = HMFGetOSLogHandle();
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
LABEL_18:

      BOOL v15 = 0;
      goto LABEL_24;
    }
    int v19 = HMFGetLogIdentifier();
    int v31 = 138543362;
    id v32 = v19;
    uint64_t v20 = "%{public}@Not creating diagnostics manager for accessory without a data stream controller";
    __int16 v21 = v18;
    os_log_type_t v22 = OS_LOG_TYPE_DEBUG;
LABEL_17:
    _os_log_impl(&dword_1D49D5000, v21, v22, v20, (uint8_t *)&v31, 0xCu);

    goto LABEL_18;
  }
  [(HMDHAPAccessory *)self _destroyDiagnosticsManager];
  BOOL v15 = 1;
LABEL_24:

  return v15;
}

- (void)stopScan
{
  char v3 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __37__HMDHAPAccessory_BTLEScan__stopScan__block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v3, block);
}

uint64_t __37__HMDHAPAccessory_BTLEScan__stopScan__block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _stopScan];
}

- (void)_stopScan
{
  char v3 = +[BTLEScanner sharedBTLEScanner]();
  if (v3) {
    id v4 = v3[1];
  }
  else {
    id v4 = 0;
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __38__HMDHAPAccessory_BTLEScan___stopScan__block_invoke;
  v6[3] = &unk_1E6A197C8;
  id v7 = v3;
  uint64_t v8 = self;
  unint64_t v5 = v3;
  dispatch_async(v4, v6);
}

void __38__HMDHAPAccessory_BTLEScan___stopScan__block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    char v3 = *(void **)(v2 + 40);
  }
  else {
    char v3 = 0;
  }
  id v4 = [v3 getContextForAccessory:*(void *)(a1 + 40)];

  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      char v6 = *(void **)(v5 + 40);
    }
    else {
      char v6 = 0;
    }
    [v6 removeAccessory:*(void *)(a1 + 40)];
    id v7 = *(void **)(a1 + 40);
    [v7 scanningCompleteWithAccessoryFound:0 suspended:0];
  }
}

- (void)scanningCompleteWithAccessoryFound:(BOOL)a3 suspended:(BOOL)a4
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v7 = (void *)MEMORY[0x1D9452090](self, a2);
  uint64_t v8 = self;
  int v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    int v10 = HMFGetLogIdentifier();
    __int16 v11 = [(HMDAccessory *)v8 identifier];
    __int16 v12 = HMFBooleanToString();
    uint64_t v13 = HMFBooleanToString();
    *(_DWORD *)buf = 138544130;
    id v32 = v10;
    __int16 v33 = 2112;
    id v34 = v11;
    __int16 v35 = 2112;
    long long v36 = v12;
    __int16 v37 = 2112;
    __int16 v38 = v13;
    _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Scanning of custom device(%@) found(%@) suspended(%@)", buf, 0x2Au);
  }
  if (a3)
  {
    if (a4 || [(HMDAccessory *)v8 isReachable])
    {
      uint64_t v14 = 0;
    }
    else
    {
      BOOL v15 = +[HMDBTLEAdvertiser sharedAdvertiser];
      if ([v15 isAdvertisingForAccessory:v8])
      {
        uint64_t v14 = 0;
      }
      else
      {
        id v16 = (void *)MEMORY[0x1D9452090]();
        uint64_t v17 = v8;
        uint64_t v18 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          int v19 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543362;
          id v32 = v19;
          _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_ERROR, "%{public}@Accessory discoverable via Bluetooth but no HAP connection!!!", buf, 0xCu);
        }
        uint64_t v14 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
      }
    }
  }
  else
  {
    uint64_t v14 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
  }
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  uint64_t v20 = [(HMDHAPAccessory *)v8 pendingReads];
  uint64_t v21 = [v20 countByEnumeratingWithState:&v26 objects:v30 count:16];
  if (v21)
  {
    uint64_t v22 = v21;
    uint64_t v23 = *(void *)v27;
    do
    {
      uint64_t v24 = 0;
      do
      {
        if (*(void *)v27 != v23) {
          objc_enumerationMutation(v20);
        }
        (*(void (**)(void))(*(void *)(*((void *)&v26 + 1) + 8 * v24++) + 16))();
      }
      while (v22 != v24);
      uint64_t v22 = [v20 countByEnumeratingWithState:&v26 objects:v30 count:16];
    }
    while (v22);
  }

  uint64_t v25 = [(HMDHAPAccessory *)v8 pendingReads];
  [v25 removeAllObjects];

  [(HMDHAPAccessory *)v8 setPendingReads:0];
}

- (void)initiateScan:(id)a3
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = (void *)MEMORY[0x1D9452090]();
  char v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    uint64_t v8 = HMFGetLogIdentifier();
    int v9 = [(HMDAccessory *)v6 identifier];
    *(_DWORD *)buf = 138543618;
    uint64_t v20 = v8;
    __int16 v21 = 2112;
    uint64_t v22 = v9;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Initiating BLE Scan for custom device: %@", buf, 0x16u);
  }
  int v10 = +[BTLEScanner sharedBTLEScanner]();
  __int16 v11 = v10;
  if (v10) {
    __int16 v12 = v10[1];
  }
  else {
    __int16 v12 = 0;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __42__HMDHAPAccessory_BTLEScan__initiateScan___block_invoke;
  block[3] = &unk_1E6A193D0;
  id v16 = v10;
  uint64_t v17 = v6;
  id v18 = v4;
  id v13 = v4;
  id v14 = v11;
  dispatch_async(v12, block);
}

void __42__HMDHAPAccessory_BTLEScan__initiateScan___block_invoke(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    char v3 = *(void **)(v2 + 32);
  }
  else {
    char v3 = 0;
  }
  uint64_t v4 = [v3 state];
  if (v4 && v4 != 5)
  {
    id v30 = (void *)MEMORY[0x1D9452090]();
    id v31 = *(id *)(a1 + 40);
    id v32 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      __int16 v33 = HMFGetLogIdentifier();
      id v34 = [*(id *)(a1 + 40) identifier];
      int v35 = 138543618;
      long long v36 = v33;
      __int16 v37 = 2112;
      __int16 v38 = v34;
      _os_log_impl(&dword_1D49D5000, v32, OS_LOG_TYPE_ERROR, "%{public}@Failed to start scan of custom device: %@ - bluetooth not turned on", (uint8_t *)&v35, 0x16u);
    }
    int v9 = [MEMORY[0x1E4F28C58] hmErrorWithCode:54];
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    uint64_t v5 = [*(id *)(a1 + 40) pendingReads];

    if (!v5)
    {
      id v6 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      [*(id *)(a1 + 40) setPendingReads:v6];
    }
    id v7 = [MEMORY[0x1E4F65530] sharedPreferences];
    uint64_t v8 = [v7 preferenceForKey:@"BTLEScanTimeout_Seconds"];
    int v9 = [v8 numberValue];

    uint64_t v10 = [v9 doubleValue];
    double v12 = v11;
    id v13 = (void *)MEMORY[0x1D9452090](v10);
    id v14 = *(id *)(a1 + 40);
    BOOL v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      id v16 = HMFGetLogIdentifier();
      uint64_t v17 = [*(id *)(a1 + 40) identifier];
      int v35 = 138543874;
      long long v36 = v16;
      __int16 v37 = 2112;
      __int16 v38 = v17;
      __int16 v39 = 2112;
      uint64_t v40 = v9;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@Scan timeout for custom device: %@ set to %@ seconds", (uint8_t *)&v35, 0x20u);
    }
    id v18 = [*(id *)(a1 + 40) pendingReads];
    int v19 = _Block_copy(*(const void **)(a1 + 48));
    [v18 addObject:v19];

    uint64_t v20 = *(id **)(a1 + 32);
    id v21 = *(id *)(a1 + 40);
    uint64_t v22 = v21;
    if (v20 && v21)
    {
      uint64_t v23 = objc_alloc_init(ScanContext);
      uint64_t v24 = v23;
      if (v23) {
        v23->_timeout = v12;
      }
      [v20[5] addAccessory:v22 toQueue:@"ScanQueue" context:v23];
      [v20 _checkCanScan];
    }
    else
    {

      uint64_t v25 = (void *)MEMORY[0x1D9452090]();
      id v26 = *(id *)(a1 + 40);
      long long v27 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        long long v28 = HMFGetLogIdentifier();
        long long v29 = [*(id *)(a1 + 40) identifier];
        int v35 = 138543618;
        long long v36 = v28;
        __int16 v37 = 2112;
        __int16 v38 = v29;
        _os_log_impl(&dword_1D49D5000, v27, OS_LOG_TYPE_ERROR, "%{public}@Failed to start scan of custom device: %@ - ignoring request", (uint8_t *)&v35, 0x16u);
      }
      [*(id *)(a1 + 40) scanningCompleteWithAccessoryFound:0 suspended:0];
    }
  }
}

- (void)initializeBTLEScan
{
  uint64_t v2 = +[BTLEScanner sharedBTLEScanner]();
}

- (void).cxx_destruct
{
  objc_storeStrong((id *)&self->_didConfigureCHIPAccessoryServerFuture, 0);
  objc_storeStrong((id *)&self->_matterDiagnosticManager, 0);
  objc_storeStrong((id *)&self->_hapMetadata, 0);
  objc_storeStrong((id *)&self->_pendingReads, 0);
  objc_storeStrong((id *)&self->_dataStreamController, 0);
  objc_storeStrong((id *)&self->_pairingUsername, 0);
  objc_storeStrong((id *)&self->_publicKey, 0);
  objc_storeStrong((id *)&self->_discoveredServices, 0);
  objc_storeStrong((id *)&self->_cachedRemovedUser, 0);
  objc_storeStrong((id *)&self->_siriEndpointProfileMetricsDispatcher, 0);
  objc_storeStrong((id *)&self->_accessoryMetric, 0);
  objc_storeStrong((id *)&self->_sessionRestoreTimer, 0);
  objc_storeStrong((id *)&self->_accessoryKeyRefreshTimer, 0);
  objc_storeStrong((id *)&self->_accessoryDiscoveryBackoffTimer, 0);
  objc_storeStrong((id *)&self->_backedOffStateNumber, 0);
  objc_storeStrong((id *)&self->_hapServicesListForAnalytics, 0);
  objc_storeStrong((id *)&self->_primaryHAPServiceForAnalytics, 0);
  objc_storeStrong((id *)&self->_supportedLinkLayerTypes, 0);
  objc_storeStrong((id *)&self->_matterProductID, 0);
  objc_storeStrong((id *)&self->_matterVendorID, 0);
  objc_storeStrong((id *)&self->_matterNodeID, 0);
  objc_storeStrong((id *)&self->_uniqueIdentifier, 0);
  objc_storeStrong((id *)&self->_chipExtendedMACAddress, 0);
  objc_storeStrong((id *)&self->_chipWEDSupport, 0);
  objc_storeStrong((id *)&self->_matterSoftwareVersionNumber, 0);
  objc_storeStrong((id *)&self->_chipAccessoryServer, 0);
  objc_storeStrong((id *)&self->_chipStorage, 0);
  objc_storeStrong((id *)&self->_bulletinBoard, 0);
  objc_storeStrong((id *)&self->_accessCodeCache, 0);
  objc_storeStrong((id *)&self->_needsOnboarding, 0);
  objc_storeStrong((id *)&self->_wakingViaCharacteristicWithIID, 0);
  objc_storeStrong((id *)&self->_internalThreadActive, 0);
  objc_storeStrong((id *)&self->_internalThreadStatus, 0);
  objc_storeStrong((id *)&self->_internalThreadCapabilities, 0);
  objc_storeStrong((id *)&self->_doorbellChimeController, 0);
  objc_storeStrong((id *)&self->_accessoryAdvertisement, 0);
  objc_storeStrong((id *)&self->_firmwareUpdateProfile, 0);
  objc_storeStrong((id *)&self->_activeSessionRestoreClients, 0);
  objc_storeStrong((id *)&self->_initialServiceTypeUUIDs, 0);
  objc_storeStrong((id *)&self->_cameraProfileNotificationSettings, 0);
  objc_storeStrong((id *)&self->_hasOnboardedForNaturalLighting, 0);
  objc_storeStrong((id *)&self->_sleepInterval, 0);
  objc_storeStrong((id *)&self->_diagnosticsManager, 0);
  objc_storeStrong((id *)&self->_wiFiTransportCapabilities, 0);
  objc_storeStrong((id *)&self->_wiFiManagementController, 0);
  objc_storeStrong((id *)&self->_cameraProfileSettingsManager, 0);
  objc_storeStrong((id *)&self->_powerOnCompletionRoutines, 0);
  objc_storeStrong((id *)&self->_connectivityInfo, 0);
  objc_storeStrong((id *)&self->_networkRouterController, 0);
  objc_storeStrong((id *)&self->_pendingPowerOn, 0);
  objc_storeStrong((id *)&self->_primaryService, 0);
  objc_storeStrong((id *)&self->_identifiersForBridgedAccessories, 0);
  objc_storeStrong((id *)&self->_symptomsHandler, 0);
  objc_storeStrong((id *)&self->_targetControllerManager, 0);
  objc_storeStrong((id *)&self->_targetUUIDs, 0);
  objc_storeStrong((id *)&self->_keyUpdatedTime, 0);
  objc_storeStrong((id *)&self->_keyUpdatedStateNumber, 0);
  objc_storeStrong((id *)&self->_broadcastKey, 0);
  objc_storeStrong((id *)&self->_setupHash, 0);
  objc_storeStrong((id *)&self->_internalEnhancedAuthMethod, 0);
  objc_storeStrong((id *)&self->_internalEnhancedAuthConfigNumber, 0);
  objc_storeStrong((id *)&self->_accessoryFlags, 0);
  objc_storeStrong((id *)&self->_services, 0);
  objc_storeStrong((id *)&self->_transportInformationInstances, 0);
}

- (NAFuture)didConfigureCHIPAccessoryServerFuture
{
  return (NAFuture *)objc_getProperty(self, a2, 1040, 1);
}

- (void)setMatterDiagnosticManager:(id)a3
{
}

- (void)setHasSiriEndpointService:(BOOL)a3
{
  self->_hasSiriEndpointService = a3;
}

- (BOOL)hasSiriEndpointService
{
  return self->_hasSiriEndpointService;
}

- (void)setPendingReads:(id)a3
{
}

- (NSMutableArray)pendingReads
{
  return (NSMutableArray *)objc_getProperty(self, a2, 1016, 1);
}

- (void)setDataStreamController:(id)a3
{
}

- (void)setPairingUsername:(id)a3
{
}

- (void)setPublicKey:(id)a3
{
}

- (void)setDiscoveredServices:(id)a3
{
}

- (NSMutableArray)discoveredServices
{
  return self->_discoveredServices;
}

- (void)setCachedRemovedUser:(id)a3
{
}

- (HMDUser)cachedRemovedUser
{
  return self->_cachedRemovedUser;
}

- (void)setSiriEndpointProfileMetricsDispatcher:(id)a3
{
}

- (HMDSiriEndpointProfileMetricsDispatcher)siriEndpointProfileMetricsDispatcher
{
  return (HMDSiriEndpointProfileMetricsDispatcher *)objc_getProperty(self, a2, 968, 1);
}

- (void)setAccessoryMetric:(id)a3
{
}

- (unint64_t)lastSessionStatus
{
  return self->_lastSessionStatus;
}

- (void)setLastLinkChangeSessionCheckTime:(double)a3
{
  self->_lastLinkChangeSessionCheckTime = a3;
}

- (double)lastLinkChangeSessionCheckTime
{
  return self->_lastLinkChangeSessionCheckTime;
}

- (void)setSessionRestoreTimer:(id)a3
{
}

- (HMFTimer)sessionRestoreTimer
{
  return self->_sessionRestoreTimer;
}

- (void)setKeyGenerationType:(unsigned __int8)a3
{
  self->_keyGenerationType = a3;
}

- (unsigned)keyGenerationType
{
  return self->_keyGenerationType;
}

- (void)setAccessoryKeyRefreshTimer:(id)a3
{
}

- (HMFTimer)accessoryKeyRefreshTimer
{
  return self->_accessoryKeyRefreshTimer;
}

- (void)setAccessoryDiscoveryBackoffTimer:(id)a3
{
}

- (HMFTimer)accessoryDiscoveryBackoffTimer
{
  return self->_accessoryDiscoveryBackoffTimer;
}

- (void)setBackedOffStateNumber:(id)a3
{
}

- (NSNumber)backedOffStateNumber
{
  return self->_backedOffStateNumber;
}

- (void)setPairingAttempts:(unint64_t)a3
{
  self->_pairingAttempts = a3;
}

- (unint64_t)pairingAttempts
{
  return self->_pairingAttempts;
}

- (void)setActivationAttempts:(unint64_t)a3
{
  self->_activationAttempts = a3;
}

- (unint64_t)activationAttempts
{
  return self->_activationAttempts;
}

- (NSArray)hapServicesListForAnalytics
{
  return self->_hapServicesListForAnalytics;
}

- (HMDAnalyticsHAPServiceData)primaryHAPServiceForAnalytics
{
  return self->_primaryHAPServiceForAnalytics;
}

- (void)setSupportedLinkLayerTypes:(id)a3
{
}

- (NSNumber)supportedLinkLayerTypes
{
  return self->_supportedLinkLayerTypes;
}

- (void)setMatterProductID:(id)a3
{
}

- (NSNumber)matterProductID
{
  return self->_matterProductID;
}

- (void)setMatterVendorID:(id)a3
{
}

- (NSNumber)matterVendorID
{
  return self->_matterVendorID;
}

- (void)setMatterNodeID:(id)a3
{
}

- (void)setCertificationStatus:(int64_t)a3
{
  self->_certificationStatus = a3;
}

- (void)setUniqueIdentifier:(id)a3
{
}

- (void)setMatterExtendedMACAddress:(id)a3
{
}

- (NSString)matterExtendedMACAddress
{
  return self->_chipExtendedMACAddress;
}

- (void)setMatterWEDSupport:(id)a3
{
}

- (NSNumber)matterWEDSupport
{
  return self->_chipWEDSupport;
}

- (void)setMatterSoftwareVersionNumber:(id)a3
{
}

- (NSNumber)matterSoftwareVersionNumber
{
  return self->_matterSoftwareVersionNumber;
}

- (void)setAccessoryServer:(id)a3
{
}

- (HMMTRAccessoryServer)accessoryServer
{
  return self->_chipAccessoryServer;
}

- (void)setRequiresThreadRouter:(BOOL)a3
{
  self->_requiresThreadRouter = a3;
}

- (BOOL)requiresThreadRouter
{
  return self->_requiresThreadRouter;
}

- (void)setChipStorage:(id)a3
{
}

- (void)setHasPostedBulletinForWalletKeyOnboarding:(BOOL)a3
{
  self->_hasPostedBulletinForWalletKeyOnboarding = a3;
}

- (BOOL)hasPostedBulletinForWalletKeyOnboarding
{
  return self->_hasPostedBulletinForWalletKeyOnboarding;
}

- (void)setHasPostedBulletinForAccessCodeOnboarding:(BOOL)a3
{
  self->_hasPostedBulletinForAccessCodeOnboarding = a3;
}

- (BOOL)hasPostedBulletinForAccessCodeOnboarding
{
  return self->_hasPostedBulletinForAccessCodeOnboarding;
}

- (void)setAccessCodeCache:(id)a3
{
}

- (NSMutableDictionary)accessCodeCache
{
  return (NSMutableDictionary *)objc_getProperty(self, a2, 776, 1);
}

- (void)setAccessoryAdvertisement:(id)a3
{
}

- (void)setSleepInterval:(id)a3
{
}

- (NSNumber)sleepInterval
{
  return self->_sleepInterval;
}

- (void)setPowerOnCompletionRoutines:(id)a3
{
}

- (NSMutableArray)powerOnCompletionRoutines
{
  return self->_powerOnCompletionRoutines;
}

- (void)setPendingPowerOn:(id)a3
{
}

- (HMDPendingCharacteristic)pendingPowerOn
{
  return self->_pendingPowerOn;
}

- (void)setKeyGenerationInProgress:(BOOL)a3
{
  self->_keyGenerationInProgress = a3;
}

- (BOOL)keyGenerationInProgress
{
  return self->_keyGenerationInProgress;
}

- (void)setKeyUpdatedTime:(id)a3
{
}

- (NSDate)keyUpdatedTime
{
  return self->_keyUpdatedTime;
}

- (void)setKeyUpdatedStateNumber:(id)a3
{
}

- (NSNumber)keyUpdatedStateNumber
{
  return self->_keyUpdatedStateNumber;
}

- (void)setBroadcastKey:(id)a3
{
}

- (void)_handleUpdateAccessoryConnectionState:(id)a3
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if ([v4 isRemote])
  {
    uint64_t v5 = (void *)MEMORY[0x1D9452090]();
    id v6 = self;
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = HMFGetLogIdentifier();
      int v24 = 138543618;
      uint64_t v25 = v8;
      __int16 v26 = 2112;
      id v27 = v4;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_DEFAULT, "%{public}@Message not supported: %@", (uint8_t *)&v24, 0x16u);
    }
    int v9 = [MEMORY[0x1E4F28C58] hmErrorWithCode:17];
    [v4 respondWithError:v9];
  }
  else
  {
    uint64_t v10 = [v4 stringForKey:@"kAccessoryName"];
    if (v10)
    {
      int v9 = (void *)v10;
      if ([(HMDAccessory *)self isReachable])
      {
        double v11 = [(HMDAccessory *)self identifier];
        double v12 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v11];
        id v13 = [v12 server];

        if (v13)
        {
          [v13 disconnect];
          [v4 respondWithSuccess];
        }
        else
        {
          int v19 = (void *)MEMORY[0x1D9452090]();
          uint64_t v20 = self;
          id v21 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            uint64_t v22 = HMFGetLogIdentifier();
            int v24 = 138543362;
            uint64_t v25 = v22;
            _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_ERROR, "%{public}@No matching accessory server", (uint8_t *)&v24, 0xCu);
          }
          uint64_t v23 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
          [v4 respondWithError:v23];
        }
      }
      else
      {
        BOOL v15 = (void *)MEMORY[0x1D9452090]();
        id v16 = self;
        uint64_t v17 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          id v18 = HMFGetLogIdentifier();
          int v24 = 138543362;
          uint64_t v25 = v18;
          _os_log_impl(&dword_1D49D5000, v17, OS_LOG_TYPE_ERROR, "%{public}@Accessory is not reachable", (uint8_t *)&v24, 0xCu);
        }
        id v13 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
        [v4 respondWithError:v13];
      }
    }
    else
    {
      id v14 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
      [v4 respondWithError:v14];

      int v9 = 0;
    }
  }
}

- (void)handleLinkQualityRequestMessage:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HMDHAPAccessory *)self chipAccessoryServer];
  id v8 = v5;
  if (v5)
  {
    id v6 = [v5 identifier];
    id v7 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v6];

    [(HMDHAPAccessory *)self getLinkQualityForAccessory:v7 forMessage:v4];
  }
  else
  {
    id v7 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4 description:@"Accessory server is currently unavailable" reason:0 suggestion:0];
    [v4 respondWithError:v7];
  }
}

- (void)_handleValidatePairingAuthMethodMessage:(id)a3
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if ([(HMDHAPAccessory *)self isPrimary])
  {
    uint64_t v19 = 0;
    uint64_t v5 = [(HMDHAPAccessory *)self preferredHAPAccessoryForOperation:10 linkType:&v19];
    id v6 = [v5 server];

    if (v6)
    {
      v16[0] = MEMORY[0x1E4F143A8];
      v16[1] = 3221225472;
      v16[2] = __59__HMDHAPAccessory__handleValidatePairingAuthMethodMessage___block_invoke;
      v16[3] = &unk_1E6A196E0;
      id v17 = v4;
      id v18 = self;
      [(HMDHAPAccessory *)self _updateAuthMethodWithServer:v6 completion:v16];
      id v7 = v17;
    }
    else
    {
      double v12 = (void *)MEMORY[0x1D9452090]();
      id v13 = self;
      id v14 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        BOOL v15 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v21 = v15;
        _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_ERROR, "%{public}@Unable to find accessory server to challenge for auth method", buf, 0xCu);
      }
      id v7 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
      [v4 respondWithError:v7];
    }
  }
  else
  {
    id v8 = (void *)MEMORY[0x1D9452090]();
    int v9 = self;
    uint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      double v11 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v21 = v11;
      _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_ERROR, "%{public}@Unable to challenge for auth method on bridged accessory", buf, 0xCu);
    }
    id v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
    [v4 respondWithError:v6];
  }
}

void __59__HMDHAPAccessory__handleValidatePairingAuthMethodMessage___block_invoke(uint64_t a1, uint64_t a2)
{
  v7[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)(a1 + 32);
  if (a2)
  {
    char v3 = *(void **)(a1 + 32);
    [v3 respondWithError:a2];
  }
  else
  {
    uint64_t v6 = *MEMORY[0x1E4F2C150];
    id v4 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(*(id *)(a1 + 40), "enhancedAuthMethod"));
    v7[0] = v4;
    uint64_t v5 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v7 forKeys:&v6 count:1];
    [v2 respondWithPayload:v5];
  }
}

- (void)removeSession:(int64_t)a3
{
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __33__HMDHAPAccessory_removeSession___block_invoke;
  v6[3] = &unk_1E6A189D0;
  void v6[4] = self;
  void v6[5] = a3;
  dispatch_async(v5, v6);
}

void __33__HMDHAPAccessory_removeSession___block_invoke(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)(a1 + 32);
  char v3 = [v2 identifier];
  id v4 = [v2 matchingHAPAccessoryWithServerIdentifier:v3 linkType:1];

  if (v4)
  {
    uint64_t v5 = [v4 server];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    id v7 = v6;

    if (v7)
    {
      [v7 removeActiveSession:*(void *)(a1 + 40)];
    }
    else
    {
      id v13 = (void *)MEMORY[0x1D9452090]();
      id v14 = *(id *)(a1 + 32);
      BOOL v15 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        id v16 = HMFGetLogIdentifier();
        id v17 = HAPStringFromAccessoryServerSession();
        id v18 = [*(id *)(a1 + 32) shortDescription];
        int v19 = 138543874;
        uint64_t v20 = v16;
        __int16 v21 = 2112;
        uint64_t v22 = v17;
        __int16 v23 = 2112;
        int v24 = v18;
        _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_ERROR, "%{public}@*** remove %@ from an object with no server %@", (uint8_t *)&v19, 0x20u);
      }
    }
  }
  else
  {
    id v8 = (void *)MEMORY[0x1D9452090]();
    id v9 = *(id *)(a1 + 32);
    uint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      double v11 = HMFGetLogIdentifier();
      double v12 = *(void **)(a1 + 32);
      int v19 = 138543618;
      uint64_t v20 = v11;
      __int16 v21 = 2112;
      uint64_t v22 = v12;
      _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_ERROR, "%{public}@HAPAccessory not available to set session %@", (uint8_t *)&v19, 0x16u);
    }
  }
}

- (void)addSession:(int64_t)a3
{
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __30__HMDHAPAccessory_addSession___block_invoke;
  v6[3] = &unk_1E6A189D0;
  void v6[4] = self;
  void v6[5] = a3;
  dispatch_async(v5, v6);
}

void __30__HMDHAPAccessory_addSession___block_invoke(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)(a1 + 32);
  char v3 = [v2 identifier];
  id v4 = [v2 matchingHAPAccessoryWithServerIdentifier:v3 linkType:1];

  if (v4)
  {
    uint64_t v5 = [v4 server];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    id v7 = v6;

    if (v7)
    {
      [v7 addActiveSession:*(void *)(a1 + 40)];
    }
    else
    {
      id v14 = (void *)MEMORY[0x1D9452090]();
      id v15 = *(id *)(a1 + 32);
      id v16 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        id v17 = HMFGetLogIdentifier();
        id v18 = HAPStringFromAccessoryServerSession();
        int v19 = [*(id *)(a1 + 32) shortDescription];
        int v20 = 138543874;
        __int16 v21 = v17;
        __int16 v22 = 2112;
        __int16 v23 = v18;
        __int16 v24 = 2112;
        uint64_t v25 = v19;
        _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_ERROR, "%{public}@*** adding %@ to an object with no server %@", (uint8_t *)&v20, 0x20u);
      }
    }
  }
  else
  {
    id v8 = (void *)MEMORY[0x1D9452090]();
    id v9 = *(id *)(a1 + 32);
    uint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      double v11 = HMFGetLogIdentifier();
      double v12 = HAPStringFromAccessoryServerSession();
      id v13 = [*(id *)(a1 + 32) shortDescription];
      int v20 = 138543874;
      __int16 v21 = v11;
      __int16 v22 = 2112;
      __int16 v23 = v12;
      __int16 v24 = 2112;
      uint64_t v25 = v13;
      _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_ERROR, "%{public}@HAPAccessory not available to set session %@ for %@", (uint8_t *)&v20, 0x20u);
    }
  }
}

- (void)_handleSessionRestoreTimerFired
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  char v3 = (void *)MEMORY[0x1D9452090](self, a2);
  id v4 = self;
  uint64_t v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = HMFGetLogIdentifier();
    int v7 = 138543362;
    id v8 = v6;
    _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Session Restore timer fired for accessory", (uint8_t *)&v7, 0xCu);
  }
  [(HMDHAPAccessory *)v4 _checkSession];
  if (![(HMDAccessory *)v4 isReachable]) {
    [(HMDHAPAccessory *)v4 _stopSessionMonitor];
  }
}

- (void)_updateSessionRestoreOnServer:(BOOL)a3
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __49__HMDHAPAccessory__updateSessionRestoreOnServer___block_invoke;
  v5[3] = &unk_1E6A0B5A8;
  v5[4] = self;
  BOOL v6 = a3;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = __49__HMDHAPAccessory__updateSessionRestoreOnServer___block_invoke_784;
  v3[3] = &unk_1E6A0B5D0;
  v3[4] = self;
  BOOL v4 = a3;
  [(HMDHAPAccessory *)self _performOperation:2 linkType:0 operationBlock:v5 errorBlock:v3];
}

void __49__HMDHAPAccessory__updateSessionRestoreOnServer___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  BOOL v4 = [v3 server];
  uint64_t v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = *(id *)(a1 + 32);
  int v7 = HMFGetOSLogHandle();
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_INFO);
  if (v4)
  {
    if (v8)
    {
      uint64_t v9 = HMFGetLogIdentifier();
      uint64_t v10 = HMFBooleanToString();
      int v16 = 138543618;
      id v17 = v9;
      __int16 v18 = 2112;
      int v19 = v10;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Updating session restore to %@ on server", (uint8_t *)&v16, 0x16u);
    }
    [v4 setSessionRestoreActive:*(unsigned __int8 *)(a1 + 40)];
    if (!*(unsigned char *)(a1 + 40))
    {
      id v11 = v4;
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();
      if (isKindOfClass) {
        id v13 = v11;
      }
      else {
        id v13 = 0;
      }
      id v14 = v13;

      if (isKindOfClass) {
        [v11 processPendingBonjourRemoveEvents];
      }
    }
  }
  else
  {
    if (v8)
    {
      id v15 = HMFGetLogIdentifier();
      int v16 = 138543362;
      id v17 = v15;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Session Restore - No server for accessory", (uint8_t *)&v16, 0xCu);
    }
  }
}

void __49__HMDHAPAccessory__updateSessionRestoreOnServer___block_invoke_784(uint64_t a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  BOOL v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    int v7 = HMFGetLogIdentifier();
    BOOL v8 = HMFBooleanToString();
    int v9 = 138543874;
    uint64_t v10 = v7;
    __int16 v11 = 2112;
    double v12 = v8;
    __int16 v13 = 2112;
    id v14 = v3;
    _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_INFO, "%{public}@Session Restore, unable to update sessionRestore to %@ on server, error: %@", (uint8_t *)&v9, 0x20u);
  }
}

- (void)_startSessionMonitor
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = [(HMDHAPAccessory *)self currentActiveSessionRestoreClients];
  uint64_t v4 = [v3 count];

  if (v4)
  {
    id v5 = [(HMDHAPAccessory *)self sessionRestoreTimer];

    id v6 = (void *)MEMORY[0x1D9452090]();
    int v7 = self;
    BOOL v8 = HMFGetOSLogHandle();
    int v9 = v8;
    if (v5)
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v10 = HMFGetLogIdentifier();
        int v16 = 138543362;
        id v17 = v10;
        _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_DEBUG, "%{public}@Session Restore - already monitoring accessory", (uint8_t *)&v16, 0xCu);
      }
    }
    else
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        __int16 v11 = HMFGetLogIdentifier();
        int v16 = 138543362;
        id v17 = v11;
        _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Session Restore - Starting timer to monitor session with accessory", (uint8_t *)&v16, 0xCu);
      }
      id v12 = objc_alloc(MEMORY[0x1E4F65580]);
      [(HMDHAPAccessory *)v7 sessionCheckPeriod];
      __int16 v13 = objc_msgSend(v12, "initWithTimeInterval:options:", 4);
      [(HMDHAPAccessory *)v7 setSessionRestoreTimer:v13];

      id v14 = [(HMDHAPAccessory *)v7 sessionRestoreTimer];
      [v14 setDelegate:v7];

      uint64_t v15 = [(HMDHAPAccessory *)v7 sessionRestoreTimer];
      [v15 resume];
    }
    [(HMDHAPAccessory *)v7 _updateSessionRestoreOnServer:1];
  }
}

- (void)_stopSessionMonitor
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v3 = [(HMDHAPAccessory *)self sessionRestoreTimer];

  if (v3)
  {
    uint64_t v4 = (void *)MEMORY[0x1D9452090]();
    id v5 = self;
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v7 = HMFGetLogIdentifier();
      BOOL v8 = [(HMDHAPAccessory *)v5 currentActiveSessionRestoreClients];
      int v10 = 138543618;
      __int16 v11 = v7;
      __int16 v12 = 2112;
      __int16 v13 = v8;
      _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_INFO, "%{public}@Session Restore stopping monitoring accessory, active registrations %@", (uint8_t *)&v10, 0x16u);
    }
    int v9 = [(HMDHAPAccessory *)v5 sessionRestoreTimer];
    [v9 suspend];

    [(HMDHAPAccessory *)v5 setSessionRestoreTimer:0];
  }
  [(HMDHAPAccessory *)self _updateSessionRestoreOnServer:0];
}

- (void)_notifyBridgedAccessoryReachabilityChange:(id)a3
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if (![(HMDHAPAccessory *)self isPrimary])
  {
    if (!v4)
    {
      int v16 = (void *)MEMORY[0x1D9452090]();
      id v17 = self;
      uint64_t v18 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        int v19 = HMFGetLogIdentifier();
        int v20 = 138543362;
        __int16 v21 = v19;
        _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_INFO, "%{public}@Session Restore Bridged accessory became reachable", (uint8_t *)&v20, 0xCu);
      }
      logAndPostNotification(@"HMDBridgedAccessoryReachableNotification", v17, 0);
      id v5 = [(HMDHAPAccessory *)v17 accessoryMetric];
      __int16 v11 = [v5 sessionMetric];
      uint64_t v12 = [(HMDHAPAccessory *)v17 linkLayerType];
      __int16 v13 = v11;
      uint64_t v14 = 1;
      id v15 = 0;
      goto LABEL_11;
    }
    id v5 = [v4 domain];
    if (![v5 isEqual:*MEMORY[0x1E4F2D140]])
    {
LABEL_12:

      goto LABEL_13;
    }
    uint64_t v6 = [v4 code];

    if (v6 == 88)
    {
      int v7 = (void *)MEMORY[0x1D9452090]();
      BOOL v8 = self;
      int v9 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        int v10 = HMFGetLogIdentifier();
        int v20 = 138543362;
        __int16 v21 = v10;
        _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Session Restore Bridged accessory became unreachable", (uint8_t *)&v20, 0xCu);
      }
      logAndPostNotification(@"HMDBridgedAccessoryUnreachableNotification", v8, 0);
      id v5 = [(HMDHAPAccessory *)v8 accessoryMetric];
      __int16 v11 = [v5 sessionMetric];
      uint64_t v12 = [(HMDHAPAccessory *)v8 linkLayerType];
      __int16 v13 = v11;
      uint64_t v14 = 0;
      id v15 = v4;
LABEL_11:
      [v13 updateSessionState:v14 linkLayerType:v12 sessionInfo:0 bookkeeping:0 withError:v15];

      goto LABEL_12;
    }
  }
LABEL_13:
}

- (void)_checkSession
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  id v3 = (void *)MEMORY[0x1D9452090](self, a2);
  id v4 = self;
  id v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    __int16 v11 = v6;
    _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Session Restore checking session", buf, 0xCu);
  }
  objc_initWeak((id *)buf, v4);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  v8[2] = __32__HMDHAPAccessory__checkSession__block_invoke;
  v8[3] = &unk_1E6A0B580;
  objc_copyWeak(&v9, (id *)buf);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __32__HMDHAPAccessory__checkSession__block_invoke_783;
  v7[3] = &unk_1E6A197F0;
  void v7[4] = v4;
  [(HMDHAPAccessory *)v4 _performOperation:2 linkType:0 operationBlock:v8 errorBlock:v7];
  objc_destroyWeak(&v9);
  objc_destroyWeak((id *)buf);
}

void __32__HMDHAPAccessory__checkSession__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v5 = [v3 characteristicOfType:*MEMORY[0x1E4F5B8D8] serviceType:*MEMORY[0x1E4F5BA58]];
    if (!v5)
    {
      id v5 = [v3 characteristicOfType:*MEMORY[0x1E4F5B868] serviceType:*MEMORY[0x1E4F5BA48]];
      if (!v5)
      {
        uint64_t v6 = (void *)MEMORY[0x1D9452090]();
        id v7 = WeakRetained;
        BOOL v8 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          id v9 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543362;
          int v20 = v9;
          _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_ERROR, "%{public}@Session Restore poll failed - no suitable characteristic for accessory", buf, 0xCu);
        }
        id v5 = 0;
      }
    }
    int v10 = [WeakRetained workQueue];
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    v16[2] = __32__HMDHAPAccessory__checkSession__block_invoke_782;
    v16[3] = &unk_1E6A0B558;
    void v16[4] = WeakRetained;
    id v17 = v3;
    id v18 = v5;
    id v11 = v5;
    [v17 readValueForCharacteristic:v11 timeout:v10 completionQueue:v16 completionHandler:0.0];
  }
  else
  {
    uint64_t v12 = (void *)MEMORY[0x1D9452090]();
    __int16 v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = HMFGetLogIdentifier();
      id v15 = [v3 identifier];
      *(_DWORD *)buf = 138543618;
      int v20 = v14;
      __int16 v21 = 2112;
      uint64_t v22 = v15;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_ERROR, "%{public}@Accessory disappeared. Session Restore check for accessory %@", buf, 0x16u);
    }
  }
}

void __32__HMDHAPAccessory__checkSession__block_invoke_783(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    id v7 = HMFGetLogIdentifier();
    int v8 = 138543618;
    id v9 = v7;
    __int16 v10 = 2112;
    id v11 = v3;
    _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_DEBUG, "%{public}@Session Restore failed to retrieve accessory with error %@", (uint8_t *)&v8, 0x16u);
  }
}

void __32__HMDHAPAccessory__checkSession__block_invoke_782(uint64_t a1, void *a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  id v7 = (void *)MEMORY[0x1D9452090]();
  id v8 = *(id *)(a1 + 32);
  id v9 = HMFGetOSLogHandle();
  __int16 v10 = v9;
  if (v6)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v11 = HMFGetLogIdentifier();
      int v17 = 138543618;
      id v18 = v11;
      __int16 v19 = 2112;
      id v20 = v6;
      _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_ERROR, "%{public}@Session Restore read failed with error %@", (uint8_t *)&v17, 0x16u);
    }
    if (([*(id *)(a1 + 40) isPrimary] & 1) == 0
      && [*(id *)(a1 + 32) lastSessionStatus] != 1)
    {
      [*(id *)(a1 + 32) _notifyBridgedAccessoryReachabilityChange:v6];
    }
    [*(id *)(a1 + 32) setLastSessionStatus:1];
    uint64_t v12 = [*(id *)(a1 + 40) server];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      __int16 v13 = v12;
    }
    else {
      __int16 v13 = 0;
    }
    id v14 = v13;

    if (v14) {
      [v14 processPendingBonjourRemoveEvents];
    }
  }
  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      id v15 = HMFGetLogIdentifier();
      int v16 = *(void **)(a1 + 48);
      int v17 = 138543618;
      id v18 = v15;
      __int16 v19 = 2112;
      id v20 = v16;
      _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_DEBUG, "%{public}@Session Restore valid session read %@", (uint8_t *)&v17, 0x16u);
    }
    if (([*(id *)(a1 + 40) isPrimary] & 1) == 0
      && [*(id *)(a1 + 32) lastSessionStatus] != 2)
    {
      [*(id *)(a1 + 32) _notifyBridgedAccessoryReachabilityChange:0];
    }
    [*(id *)(a1 + 32) setLastSessionStatus:2];
  }
}

- (unint64_t)numActiveSessionClients
{
  uint64_t v8 = 0;
  id v3 = [(HMDHAPAccessory *)self preferredHAPAccessoryForOperation:10 linkType:&v8];
  id v4 = [v3 server];

  if ([v4 doesPeriodicSessionChecks])
  {
    unint64_t v5 = [v4 numActiveSessionClients];
  }
  else
  {
    id v6 = [(HMDHAPAccessory *)self currentActiveSessionRestoreClients];
    unint64_t v5 = [v6 count];
  }
  return v5;
}

- (void)_deregisterAllClientsFromSessionRestore
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v3 = (void *)MEMORY[0x1D9452090](self, a2);
  id v4 = self;
  unint64_t v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    int v8 = 138543362;
    id v9 = v6;
    _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Session Restore deregistering all clients", (uint8_t *)&v8, 0xCu);
  }
  os_unfair_recursive_lock_lock_with_options();
  id v7 = [(HMDHAPAccessory *)v4 activeSessionRestoreClients];
  [v7 removeAllObjects];

  os_unfair_recursive_lock_unlock();
  [(HMDHAPAccessory *)v4 _stopSessionMonitor];
}

- (double)sessionCheckPeriod
{
  id v3 = [MEMORY[0x1E4F65530] sharedPreferences];
  id v4 = [v3 preferenceForKey:@"HMDPreferenceSessionCheckPeriod"];
  unint64_t v5 = [v4 numberValue];

  uint64_t v10 = 0;
  id v6 = [(HMDHAPAccessory *)self preferredHAPAccessoryForOperation:10 linkType:&v10];
  id v7 = [v6 server];

  if ([v7 doesPeriodicSessionChecks]) {
    double v8 = (double)(unint64_t)[v7 sessionCheckInterval];
  }
  else {
    double v8 = (double)[v5 integerValue];
  }

  return v8;
}

- (void)deregisterFromSessionRestore:(id)a3
{
  id v4 = a3;
  unint64_t v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __48__HMDHAPAccessory_deregisterFromSessionRestore___block_invoke;
  v7[3] = &unk_1E6A197C8;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

uint64_t __48__HMDHAPAccessory_deregisterFromSessionRestore___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _deregisterFromSessionRestore:*(void *)(a1 + 40)];
}

- (void)_registerForSessionRestore:(id)a3
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  unint64_t v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  id v6 = (void *)MEMORY[0x1D9452090]();
  id v7 = self;
  id v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    id v9 = HMFGetLogIdentifier();
    int v16 = 138543618;
    int v17 = v9;
    __int16 v18 = 2112;
    id v19 = v4;
    _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Session Restore registration for accessory for client %@", (uint8_t *)&v16, 0x16u);
  }
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v10 = [(HMDHAPAccessory *)v7 activeSessionRestoreClients];
  [v10 addObject:v4];

  os_unfair_recursive_lock_unlock();
  if ([(HMDAccessory *)v7 isReachable])
  {
    [(HMDHAPAccessory *)v7 _checkSession];
  }
  else
  {
    id v11 = (void *)MEMORY[0x1D9452090]();
    uint64_t v12 = v7;
    __int16 v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      id v14 = HMFGetLogIdentifier();
      int v16 = 138543362;
      int v17 = v14;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_DEBUG, "%{public}@Session Restore requested for currently unreachable accessory", (uint8_t *)&v16, 0xCu);
    }
  }
  uint64_t v15 = HAPAccessoryServerSessionTypesFromString();
  if (v15) {
    [(HMDHAPAccessory *)v7 addSession:v15];
  }
  [(HMDHAPAccessory *)v7 _startSessionMonitor];
}

- (void)registerForSessionRestore:(id)a3
{
  id v4 = a3;
  unint64_t v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __45__HMDHAPAccessory_registerForSessionRestore___block_invoke;
  v7[3] = &unk_1E6A197C8;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

uint64_t __45__HMDHAPAccessory_registerForSessionRestore___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _registerForSessionRestore:*(void *)(a1 + 40)];
}

- (void)stopPing
{
  id v3 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __27__HMDHAPAccessory_stopPing__block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v3, block);
}

void __27__HMDHAPAccessory_stopPing__block_invoke(uint64_t a1)
{
  v1 = *(void **)(a1 + 32);
  uint64_t v2 = [v1 identifier];
  id v5 = [v1 matchingHAPAccessoryWithServerIdentifier:v2 linkType:1];

  id v3 = v5;
  if (v5)
  {
    id v4 = [v5 server];
    [v4 setReachabilityPingEnabled:0];
    [v4 stopPing];

    id v3 = v5;
  }
}

- (void)startPing
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if ([(HMDHAPAccessory *)self supportsCHIP])
  {
    id v3 = (void *)MEMORY[0x1D9452090]();
    id v4 = self;
    id v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      id v6 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v12 = v6;
      _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_DEBUG, "%{public}@Matter accessories are not eligible to enable reachability ping", buf, 0xCu);
    }
  }
  else
  {
    os_unfair_recursive_lock_lock_with_options();
    BOOL reachable = self->super._reachable;
    os_unfair_recursive_lock_unlock();
    id v8 = [(HMDAccessory *)self workQueue];
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = __28__HMDHAPAccessory_startPing__block_invoke;
    v9[3] = &unk_1E6A19B58;
    void v9[4] = self;
    BOOL v10 = reachable;
    dispatch_async(v8, v9);
  }
}

void __28__HMDHAPAccessory_startPing__block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [v2 identifier];
  id v4 = [v2 matchingHAPAccessoryWithServerIdentifier:v3 linkType:1];

  if (v4)
  {
    id v5 = [v4 server];
    id v6 = v5;
    if (*(unsigned char *)(a1 + 40) || [v5 supportsUnreachablePing])
    {
      id v7 = (void *)MEMORY[0x1D9452090]();
      id v8 = *(id *)(a1 + 32);
      id v9 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        BOOL v10 = HMFGetLogIdentifier();
        int v15 = 138543362;
        int v16 = v10;
        _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@startPing", (uint8_t *)&v15, 0xCu);
      }
      [v6 setReachabilityPingEnabled:1];
      [v6 startPing];
    }
  }
  else
  {
    id v11 = (void *)MEMORY[0x1D9452090]();
    id v12 = *(id *)(a1 + 32);
    uint64_t v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      id v14 = HMFGetLogIdentifier();
      int v15 = 138543362;
      int v16 = v14;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_ERROR, "%{public}@HAPAccessory not available to enable reachability ping", (uint8_t *)&v15, 0xCu);
    }
  }
}

- (void)handleSetHasOnboardedForNaturalLighting:(id)a3
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  id v6 = [(HMDHAPAccessory *)self lightProfiles];
  id v7 = objc_msgSend(v6, "na_firstObjectPassingTest:", &__block_literal_global_779);

  if (!v7)
  {
    id v14 = (void *)MEMORY[0x1D9452090]();
    int v15 = self;
    int v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v33 = v17;
      _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_ERROR, "%{public}@Accessory does not have any light profile that supports natural lighting", buf, 0xCu);
    }
    __int16 v18 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
    [v4 respondWithError:v18];
    goto LABEL_17;
  }
  id v8 = [(HMDHAPAccessory *)self hasOnboardedForNaturalLighting];
  int v9 = [v8 BOOLValue];

  if (!v9)
  {
    id v19 = [(HMDAccessory *)self home];
    __int16 v18 = [v19 backingStore];

    uint64_t v20 = (void *)MEMORY[0x1D9452090]();
    uint64_t v21 = self;
    uint64_t v22 = HMFGetOSLogHandle();
    uint64_t v23 = v22;
    if (v18)
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        __int16 v24 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        __int16 v33 = v24;
        _os_log_impl(&dword_1D49D5000, v23, OS_LOG_TYPE_INFO, "%{public}@Setting accessory has onboarded for natural lighting", buf, 0xCu);
      }
      uint64_t v25 = [(HMDHAPAccessory *)v21 transactionWithObjectChangeType:2];
      [v25 setHasOnboardedForNaturalLighting:MEMORY[0x1E4F1CC38]];
      uint64_t v26 = [v4 name];
      id v27 = +[HMDBackingStoreTransactionOptions defaultXPCOptions];
      uint64_t v28 = [v18 transaction:v26 options:v27];

      [v28 add:v25];
      v30[0] = MEMORY[0x1E4F143A8];
      v30[1] = 3221225472;
      v30[2] = __59__HMDHAPAccessory_handleSetHasOnboardedForNaturalLighting___block_invoke_780;
      v30[3] = &unk_1E6A196E0;
      v30[4] = v21;
      id v31 = v4;
      [v28 run:v30];
    }
    else
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        long long v29 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        __int16 v33 = v29;
        __int16 v34 = 2112;
        id v35 = v4;
        _os_log_impl(&dword_1D49D5000, v23, OS_LOG_TYPE_ERROR, "%{public}@No backing store while processing message: %@", buf, 0x16u);
      }
      uint64_t v25 = [MEMORY[0x1E4F28C58] hmErrorWithCode:-1];
      [v4 respondWithError:v25];
    }

LABEL_17:
    goto LABEL_18;
  }
  BOOL v10 = (void *)MEMORY[0x1D9452090]();
  id v11 = self;
  id v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    uint64_t v13 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    __int16 v33 = v13;
    _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_INFO, "%{public}@Accessory has already been onboarded for natural lighting", buf, 0xCu);
  }
  [v4 respondWithSuccess];
LABEL_18:
}

void __59__HMDHAPAccessory_handleSetHasOnboardedForNaturalLighting___block_invoke_780(uint64_t a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x1D9452090]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = HMFGetLogIdentifier();
      uint64_t v8 = *(void *)(a1 + 40);
      int v9 = 138543874;
      BOOL v10 = v7;
      __int16 v11 = 2112;
      uint64_t v12 = v8;
      __int16 v13 = 2112;
      id v14 = v3;
      _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to run transaction block for message: %@ with error: %@", (uint8_t *)&v9, 0x20u);
    }
    [*(id *)(a1 + 40) respondWithError:v3];
  }
  else
  {
    [*(id *)(a1 + 40) respondWithSuccess];
  }
}

uint64_t __59__HMDHAPAccessory_handleSetHasOnboardedForNaturalLighting___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v2 = [a2 settings];
  uint64_t v3 = [v2 supportedFeatures] & 1;

  return v3;
}

- (void)setCommunicationProtocolIfNeeded
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (![(HMDHAPAccessory *)self communicationProtocol])
  {
    uint64_t v3 = [(HMDHAPAccessory *)self matterNodeID];
    if (v3)
    {
      id v4 = (void *)v3;
      id v5 = [(HMDHAPAccessory *)self matterNodeID];
      int v6 = [v5 isEqualToNumber:&unk_1F2DC7C30];

      if (v6) {
        uint64_t v7 = 1;
      }
      else {
        uint64_t v7 = 2;
      }
    }
    else
    {
      uint64_t v7 = 1;
    }
    uint64_t v8 = (void *)MEMORY[0x1D9452090]();
    int v9 = self;
    BOOL v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      __int16 v11 = HMFGetLogIdentifier();
      [(HMDHAPAccessory *)v9 communicationProtocol];
      uint64_t v12 = HAPCommunicationProtocolDescription();
      __int16 v13 = HAPCommunicationProtocolDescription();
      int v20 = 138543874;
      uint64_t v21 = v11;
      __int16 v22 = 2112;
      uint64_t v23 = v12;
      __int16 v24 = 2112;
      uint64_t v25 = v13;
      _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, "%{public}@Running transaction to set communication protocol from %@ to %@", (uint8_t *)&v20, 0x20u);
    }
    id v14 = [(HMDHAPAccessory *)v9 transactionWithObjectChangeType:2];
    uint64_t v15 = [NSNumber numberWithInteger:v7];
    [v14 setCommunicationProtocol:v15];

    int v16 = [(HMDAccessory *)v9 home];
    uint64_t v17 = [v16 backingStore];

    __int16 v18 = +[HMDBackingStoreTransactionOptions defaultLocalOptions];
    id v19 = [v17 transaction:@"Set communication protocol" options:v18];

    [v19 add:v14];
    [v19 run];
  }
}

- (void)setCommunicationProtocol:(int64_t)a3
{
  os_unfair_recursive_lock_lock_with_options();
  self->_int64_t communicationProtocol = a3;
  os_unfair_recursive_lock_unlock();
}

- (void)setBulletinBoard:(id)a3
{
  id v4 = (HMDBulletinBoard *)a3;
  os_unfair_recursive_lock_lock_with_options();
  bulletinBoard = self->_bulletinBoard;
  self->_bulletinBoard = v4;

  os_unfair_recursive_lock_unlock();
}

- (HMDBulletinBoard)bulletinBoard
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v3 = self->_bulletinBoard;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (void)setWakingViaCharacteristicWithIID:(id)a3
{
  id v4 = (NSNumber *)a3;
  os_unfair_recursive_lock_lock_with_options();
  wakingViaCharacteristicWithIID = self->_wakingViaCharacteristicWithIID;
  self->_wakingViaCharacteristicWithIID = v4;

  os_unfair_recursive_lock_unlock();
}

- (BOOL)isReachableViaBSP
{
  LOBYTE(self) = self->_reachableViaBSP;
  os_unfair_recursive_lock_unlock();
  return (char)self;
}

- (void)setReachableViaBSP:(BOOL)a3
{
  os_unfair_recursive_lock_lock_with_options();
  self->_reachableViaBSP = a3;
  os_unfair_recursive_lock_unlock();
}

- (void)setSuspendedState:(unint64_t)a3
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if ([(HMDHAPAccessory *)self suspendedState] != a3)
  {
    id v5 = (void *)MEMORY[0x1D9452090]();
    int v6 = self;
    uint64_t v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = HMFGetLogIdentifier();
      int v9 = HAPAccessorySuspendedStateDescription();
      BOOL v10 = HAPAccessorySuspendedStateDescription();
      __int16 v11 = [(HMDAccessory *)v6 identifier];
      int v12 = 138544130;
      __int16 v13 = v8;
      __int16 v14 = 2112;
      uint64_t v15 = v9;
      __int16 v16 = 2112;
      uint64_t v17 = v10;
      __int16 v18 = 2112;
      id v19 = v11;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Updating accessory's suspended state '%@' -> '%@' for %@", (uint8_t *)&v12, 0x2Au);
    }
    [(HMDHAPAccessory *)v6 setSuspendedState:a3 shouldNotify:1];
  }
}

- (void)setSuspendedState:(unint64_t)a3 shouldNotify:(BOOL)a4
{
  BOOL v4 = a4;
  v17[1] = *MEMORY[0x1E4F143B8];
  os_unfair_recursive_lock_lock_with_options();
  if (self->_suspendedState != a3)
  {
    self->_unint64_t suspendedState = a3;
    os_unfair_recursive_lock_unlock();
    uint64_t v7 = [(HMDAccessory *)self identifier];
    uint64_t v8 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v7];
    int v9 = [v8 server];

    BOOL v10 = [v9 primaryAccessory];
    [v10 setSuspendedState:a3];

    __int16 v11 = [(HMDHAPAccessory *)self transactionWithObjectChangeType:2];
    int v12 = [NSNumber numberWithUnsignedInteger:a3];
    [v11 setSuspendedState:v12];

    [(HMDHAPAccessory *)self _wol_runAccessoryTransaction:v11 localOnly:1];
    __int16 v13 = [(HMDAccessory *)self home];
    [v13 suspendedStateChangedForAccessory:self suspendedState:a3];

    if (!v4) {
      return;
    }
    goto LABEL_5;
  }
  os_unfair_recursive_lock_unlock();
  if (v4)
  {
LABEL_5:
    __int16 v16 = @"HMDHAPAccessorySuspendedStateKey";
    __int16 v14 = [NSNumber numberWithUnsignedInteger:a3];
    v17[0] = v14;
    uint64_t v15 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v17 forKeys:&v16 count:1];
    logAndPostNotification(@"HMDHAPAccessoryUpdatedSuspendedState", self, v15);
  }
}

- (void)setHasOnboardedForNaturalLighting:(id)a3
{
  id v6 = a3;
  os_unfair_recursive_lock_lock_with_options();
  BOOL v4 = (NSNumber *)[v6 copy];
  hasOnboardedForNaturalLighting = self->_hasOnboardedForNaturalLighting;
  self->_hasOnboardedForNaturalLighting = v4;

  os_unfair_recursive_lock_unlock();
}

- (void)setInternalThreadActive:(id)a3
{
  BOOL v4 = (NSNumber *)a3;
  os_unfair_recursive_lock_lock_with_options();
  internalThreadActive = self->_internalThreadActive;
  self->_internalThreadActive = v4;

  os_unfair_recursive_lock_unlock();
}

- (NSNumber)internalThreadActive
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v3 = self->_internalThreadActive;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (void)setInternalThreadStatus:(id)a3
{
  BOOL v4 = (NSNumber *)a3;
  os_unfair_recursive_lock_lock_with_options();
  internalThreadStatus = self->_internalThreadStatus;
  self->_internalThreadStatus = v4;

  os_unfair_recursive_lock_unlock();
}

- (NSNumber)internalThreadStatus
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v3 = self->_internalThreadStatus;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (void)setInternalThreadCapabilities:(id)a3
{
  BOOL v4 = (NSNumber *)a3;
  os_unfair_recursive_lock_lock_with_options();
  internalThreadCapabilities = self->_internalThreadCapabilities;
  self->_internalThreadCapabilities = v4;

  os_unfair_recursive_lock_unlock();
}

- (NSNumber)internalThreadCapabilities
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v3 = self->_internalThreadCapabilities;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (BOOL)supportsUnreachablePing
{
  uint64_t v3 = [(HMDAccessory *)self identifier];
  BOOL v4 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v3 linkType:1];

  if (v4)
  {
    id v5 = [v4 server];
    char v6 = [v5 supportsUnreachablePing];
  }
  else
  {
    char v6 = 0;
  }

  return v6;
}

- (void)startReachabilityCheck
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if ([(HMDAccessory *)self reachabilityPingEnabled])
  {
    [(HMDHAPAccessory *)self startPing];
  }
  else
  {
    uint64_t v3 = (void *)MEMORY[0x1D9452090]();
    BOOL v4 = self;
    id v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      char v6 = HMFGetLogIdentifier();
      int v7 = 138543362;
      uint64_t v8 = v6;
      _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_ERROR, "%{public}@Attempting to start reachability check on accessory with pings disabled", (uint8_t *)&v7, 0xCu);
    }
  }
}

- (void)setFirmwareUpdateProfile:(id)a3
{
  BOOL v4 = (HMDAccessoryFirmwareUpdateProfile *)a3;
  os_unfair_recursive_lock_lock_with_options();
  firmwareUpdateProfile = self->_firmwareUpdateProfile;
  self->_firmwareUpdateProfile = v4;

  os_unfair_recursive_lock_unlock();
}

- (HMDAccessoryFirmwareUpdateProfile)firmwareUpdateProfile
{
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v3 = self->_firmwareUpdateProfile;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (HMDCameraProfileSettingsManager)cameraProfileSettingsManager
{
  os_unfair_recursive_lock_lock_with_options();
  cameraProfileSettingsManager = self->_cameraProfileSettingsManager;
  if (!cameraProfileSettingsManager)
  {
    BOOL v4 = [HMDCameraProfileSettingsManager alloc];
    id v5 = [(HMDAccessory *)self workQueue];
    char v6 = [(HMDCameraProfileSettingsManager *)v4 initWithHAPAccessory:self workQueue:v5];
    int v7 = self->_cameraProfileSettingsManager;
    self->_cameraProfileSettingsManager = v6;

    cameraProfileSettingsManager = self->_cameraProfileSettingsManager;
  }
  uint64_t v8 = cameraProfileSettingsManager;
  os_unfair_recursive_lock_unlock();
  return v8;
}

- (id)backingStoreTransactionWithName:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDAccessory *)self home];
  char v6 = [v5 backingStore];
  int v7 = +[HMDBackingStoreTransactionOptions defaultXPCOptions];
  uint64_t v8 = [v6 transaction:v4 options:v7];

  return v8;
}

- (id)createUpdateServiceTransactionWithServiceUUID:(id)a3
{
  id v4 = a3;
  id v5 = [HMDServiceTransaction alloc];
  char v6 = [(HMDAccessory *)self uuid];
  int v7 = [(HMDBackingStoreModelObject *)v5 initWithObjectChangeType:2 uuid:v4 parentUUID:v6];

  return v7;
}

- (void)makeServiceNameConsistent:(id)a3 withName:(id)a4 completionHandler:(id)a5
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  uint64_t v9 = (__CFString *)a4;
  id v10 = a5;
  __int16 v11 = &stru_1F2C9F1A8;
  if (v9) {
    __int16 v11 = v9;
  }
  int v12 = v11;
  __int16 v13 = [v8 findCharacteristicWithType:*MEMORY[0x1E4F2CE80]];
  __int16 v14 = (void *)MEMORY[0x1D9452090]();
  uint64_t v15 = self;
  __int16 v16 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = HMFGetLogIdentifier();
    __int16 v18 = [v8 serviceType];
    [v8 instanceID];
    id v19 = v23 = v10;
    [v13 instanceID];
    uint64_t v20 = v22 = v14;
    *(_DWORD *)buf = 138544386;
    uint64_t v25 = v17;
    __int16 v26 = 2112;
    id v27 = v9;
    __int16 v28 = 2112;
    long long v29 = v18;
    __int16 v30 = 2112;
    id v31 = v19;
    __int16 v32 = 2112;
    __int16 v33 = v20;
    _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_DEFAULT, "%{public}@Writing configured name %@ to service %@/%@ via (%@)", buf, 0x34u);

    __int16 v14 = v22;
    id v10 = v23;
  }
  uint64_t v21 = [(HMDAccessory *)v15 workQueue];
  [(HMDHAPAccessory *)v15 writeValue:v12 toCharacteristic:v13 queue:v21 completion:v10];
}

- (id)backingStoreObjects:(int64_t)a3
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v5 = (void *)MEMORY[0x1E4F1CA48];
  char v6 = [(HMDHAPAccessory *)self modelObjectWithChangeType:1 version:a3];
  int v7 = [v5 arrayWithObject:v6];

  if (a3 >= 3)
  {
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    id v8 = [(HMDHAPAccessory *)self services];
    uint64_t v9 = [v8 countByEnumeratingWithState:&v17 objects:v21 count:16];
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)v18;
      do
      {
        for (uint64_t i = 0; i != v10; ++i)
        {
          if (*(void *)v18 != v11) {
            objc_enumerationMutation(v8);
          }
          __int16 v13 = [*(id *)(*((void *)&v17 + 1) + 8 * i) backingStoreObjects:a3];
          [v7 addObjectsFromArray:v13];
        }
        uint64_t v10 = [v8 countByEnumeratingWithState:&v17 objects:v21 count:16];
      }
      while (v10);
    }
  }
  v16.receiver = self;
  v16.super_class = (Class)HMDHAPAccessory;
  __int16 v14 = [(HMDAccessory *)&v16 backingStoreObjects:a3];
  [v7 addObjectsFromArray:v14];

  return v7;
}

- (void)transactionObjectRemoved:(id)a3 message:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v8 = v6;
  }
  else {
    id v8 = 0;
  }
  id v9 = v8;
  if (v9)
  {
    [(HMDHAPAccessory *)self _handleServiceRemovedTransaction:v9 message:v7];
  }
  else
  {
    id v10 = v6;
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();

    if (v10 && (isKindOfClass & 1) != 0)
    {
      int v12 = [v7 transactionResult];
      __int16 v13 = +[HMDUserManagementOperationManager sharedManager];
      __int16 v14 = [v10 uuid];
      [v13 removeOperationWithIdentifier:v14];

      [v12 markChanged];
    }
    else
    {
      v15.receiver = self;
      v15.super_class = (Class)HMDHAPAccessory;
      [(HMDAccessory *)&v15 transactionObjectRemoved:v10 message:v7];
    }
  }
}

- (BOOL)updateTransportInformation:(id)a3 localSource:(BOOL)a4
{
  BOOL v4 = a4;
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  if (!v4)
  {
    char v23 = 0;
    goto LABEL_38;
  }
  __int16 v32 = self;
  id v7 = [(HMDHAPAccessory *)self transportInformationInstances];
  id v35 = (void *)[v7 mutableCopy];

  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  id v30 = v6;
  id obj = v6;
  uint64_t v36 = [obj countByEnumeratingWithState:&v47 objects:v53 count:16];
  if (!v36)
  {
    char v33 = 0;
    goto LABEL_29;
  }
  char v33 = 0;
  uint64_t v34 = *(void *)v48;
  do
  {
    uint64_t v8 = 0;
    do
    {
      if (*(void *)v48 != v34) {
        objc_enumerationMutation(obj);
      }
      uint64_t v37 = v8;
      id v9 = *(void **)(*((void *)&v47 + 1) + 8 * v8);
      id v10 = objc_msgSend(v9, "hmf_stringForKey:", @"HM.serverIdentifier");
      uint64_t v11 = objc_msgSend(v9, "hmf_numberForKey:", @"HM.instanceID");
      int v12 = objc_msgSend(v9, "hmf_numberForKey:", @"linkType");
      uint64_t v38 = [v12 integerValue];

      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      id v13 = v35;
      uint64_t v14 = [v13 countByEnumeratingWithState:&v43 objects:v52 count:16];
      if (!v14)
      {
LABEL_20:

        goto LABEL_23;
      }
      uint64_t v15 = v14;
      uint64_t v16 = *(void *)v44;
LABEL_9:
      uint64_t v17 = 0;
      while (1)
      {
        if (*(void *)v44 != v16) {
          objc_enumerationMutation(v13);
        }
        long long v18 = *(void **)(*((void *)&v43 + 1) + 8 * v17);
        long long v19 = [v18 serverIdentifier];
        if (![v19 isEqualToString:v10]) {
          goto LABEL_17;
        }
        long long v20 = [v18 instanceID];
        if (([v20 isEqual:v11] & 1) == 0)
        {

LABEL_17:
          goto LABEL_18;
        }
        uint64_t v21 = [v18 linkType];

        if (v21 == v38) {
          break;
        }
LABEL_18:
        if (v15 == ++v17)
        {
          uint64_t v15 = [v13 countByEnumeratingWithState:&v43 objects:v52 count:16];
          if (v15) {
            goto LABEL_9;
          }
          goto LABEL_20;
        }
      }
      uint64_t v22 = v18;

      if (v22)
      {
        [v13 removeObject:v22];
        goto LABEL_24;
      }
LABEL_23:
      uint64_t v22 = [[HMDAccessoryTransportInformation alloc] initWithServerIdentifier:v10 instanceID:v11 linkType:v38];
      [(HMDHAPAccessory *)v32 addTransportInformationInstance:v22];
      char v33 = 1;
LABEL_24:

      uint64_t v8 = v37 + 1;
    }
    while (v37 + 1 != v36);
    uint64_t v36 = [obj countByEnumeratingWithState:&v47 objects:v53 count:16];
  }
  while (v36);
LABEL_29:

  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  id v24 = v35;
  uint64_t v25 = [v24 countByEnumeratingWithState:&v39 objects:v51 count:16];
  id v6 = v30;
  char v23 = v33;
  if (v25)
  {
    uint64_t v26 = v25;
    uint64_t v27 = *(void *)v40;
    do
    {
      for (uint64_t i = 0; i != v26; ++i)
      {
        if (*(void *)v40 != v27) {
          objc_enumerationMutation(v24);
        }
        [(HMDHAPAccessory *)v32 removeTransportInformationInstance:*(void *)(*((void *)&v39 + 1) + 8 * i)];
      }
      uint64_t v26 = [v24 countByEnumeratingWithState:&v39 objects:v51 count:16];
    }
    while (v26);
    char v23 = 1;
  }

LABEL_38:
  return v23 & 1;
}

- (void)transactionObjectUpdated:(id)a3 newValues:(id)a4 message:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  id v11 = v9;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    int v12 = v11;
  }
  else {
    int v12 = 0;
  }
  id v13 = v12;

  if (v13)
  {
    uint64_t v34 = 0;
    id v35 = &v34;
    uint64_t v36 = 0x3032000000;
    uint64_t v37 = __Block_byref_object_copy__49311;
    uint64_t v38 = __Block_byref_object_dispose__49312;
    id v39 = 0;
    uint64_t v14 = [v10 responseHandler];
    if (v14)
    {
      aBlock[0] = MEMORY[0x1E4F143A8];
      aBlock[1] = 3221225472;
      aBlock[2] = __62__HMDHAPAccessory_transactionObjectUpdated_newValues_message___block_invoke;
      aBlock[3] = &unk_1E6A0E428;
      void aBlock[4] = &v34;
      uint64_t v15 = _Block_copy(aBlock);
      [v10 setResponseHandler:v15];
    }
    v32.receiver = self;
    v32.super_class = (Class)HMDHAPAccessory;
    [(HMDAccessory *)&v32 transactionObjectUpdated:0 newValues:v11 message:v10];
    __transactionAccessoryUpdated_49313(self, v13, v10);
    if (v14) {
      v14[2](v14, v35[5], 0);
    }

    _Block_object_dispose(&v34, 8);
  }
  else
  {
    id v16 = v11;
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = 0;
    }
    id v18 = v17;

    if (v18)
    {
      long long v19 = [v18 uuid];
      long long v20 = [(HMDHAPAccessory *)self serviceWithUUID:v19];

      if (v20) {
        [v20 transactionObjectUpdated:v8 newValues:v16 message:v10];
      }
      else {
        [(HMDHAPAccessory *)self _handleAddServiceTransaction:v18 message:v10];
      }
    }
    else
    {
      id v21 = v16;
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = 0;
      }
      id v23 = v22;

      if (v23)
      {
        id v24 = +[HMDUserManagementOperation auditUserManagementOperationAccessory:self model:v23];

        if (v24)
        {
          uint64_t v25 = [(HMDAccessory *)self home];
          [v24 setDelegate:v25];
          uint64_t v26 = [v25 homeManager];
          uint64_t v27 = [(HMDAccessory *)self identifier];
          v30[0] = MEMORY[0x1E4F143A8];
          v30[1] = 3221225472;
          v30[2] = __62__HMDHAPAccessory_transactionObjectUpdated_newValues_message___block_invoke_2;
          v30[3] = &unk_1E6A197F0;
          id v31 = v24;
          [v26 cleanupOperationsForAccessory:v27 user:0 completion:v30];
        }
        __int16 v28 = [v10 transactionResult];
        [v28 markChanged];
      }
      else
      {
        v29.receiver = self;
        v29.super_class = (Class)HMDHAPAccessory;
        [(HMDAccessory *)&v29 transactionObjectUpdated:v8 newValues:v21 message:v10];
        id v24 = 0;
      }
    }
  }
}

void __62__HMDHAPAccessory_transactionObjectUpdated_newValues_message___block_invoke(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v5 = v4;
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a2);
    id v4 = v5;
  }
}

void __62__HMDHAPAccessory_transactionObjectUpdated_newValues_message___block_invoke_2(uint64_t a1)
{
  id v2 = +[HMDUserManagementOperationManager sharedManager];
  [v2 addOperation:*(void *)(a1 + 32)];
}

- (void)readInitialRequiredCharacteristicsForAccessory:(id)a3
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x1E4F1CA48];
  id v6 = [(HMDHAPAccessory *)self services];
  id v7 = objc_msgSend(v5, "arrayWithCapacity:", objc_msgSend(v6, "count"));

  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  id v8 = [(HMDHAPAccessory *)self services];
  uint64_t v9 = [v8 countByEnumeratingWithState:&v25 objects:v33 count:16];
  if (v9)
  {
    uint64_t v10 = *(void *)v26;
    do
    {
      uint64_t v11 = 0;
      do
      {
        if (*(void *)v26 != v10) {
          objc_enumerationMutation(v8);
        }
        int v12 = [*(id *)(*((void *)&v25 + 1) + 8 * v11) gatherRequiredReadRequestsForceReadFWVersion:0];
        if ([v12 count]) {
          [v7 addObjectsFromArray:v12];
        }

        ++v11;
      }
      while (v9 != v11);
      uint64_t v9 = [v8 countByEnumeratingWithState:&v25 objects:v33 count:16];
    }
    while (v9);
  }

  uint64_t v24 = 0;
  id v13 = [(HMDHAPAccessory *)self preferredHAPAccessoryForOperation:10 linkType:&v24];
  uint64_t v14 = [v13 server];

  if (v14) {
    uint64_t v15 = -[HMDAccessory setConfigNumber:](self, "setConfigNumber:", [v14 configNumber]);
  }
  id v16 = (void *)MEMORY[0x1D9452090](v15);
  uint64_t v17 = self;
  id v18 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    long long v19 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    id v30 = v19;
    __int16 v31 = 2112;
    objc_super v32 = v7;
    _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_DEBUG, "%{public}@Reading initial required characteristics: %@", buf, 0x16u);
  }
  if ([v7 count])
  {
    objc_initWeak((id *)buf, v17);
    long long v20 = [(HMDAccessory *)v17 workQueue];
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = __66__HMDHAPAccessory_readInitialRequiredCharacteristicsForAccessory___block_invoke;
    v21[3] = &unk_1E6A18FF8;
    objc_copyWeak(&v23, (id *)buf);
    id v22 = v4;
    [(HMDHAPAccessory *)v17 readCharacteristicValues:v7 source:7 message:0 queue:v20 logEvent:0 completionHandler:v21];

    objc_destroyWeak(&v23);
    objc_destroyWeak((id *)buf);
  }
  else
  {
    (*((void (**)(id, void))v4 + 2))(v4, 0);
  }
}

void __66__HMDHAPAccessory_readInitialRequiredCharacteristicsForAccessory___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    uint64_t v39 = a1;
    char v57 = 0;
    uint64_t v5 = +[HMDBackingStoreTransactionOptions optionsWithSource:0 destination:2 mustReplay:1 mustPush:0];
    id v6 = [WeakRetained home];
    id v7 = [v6 backingStore];
    uint64_t v38 = (void *)v5;
    uint64_t v37 = [v7 transaction:@"readInitialRequiredCharacteristics" options:v5];

    long long v43 = [MEMORY[0x1E4F1CA60] dictionary];
    long long v44 = [WeakRetained transactionWithObjectChangeType:2];
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    id v40 = v3;
    id obj = v3;
    uint64_t v45 = [obj countByEnumeratingWithState:&v53 objects:v63 count:16];
    if (v45)
    {
      uint64_t v42 = *(void *)v54;
      do
      {
        for (uint64_t i = 0; i != v45; ++i)
        {
          if (*(void *)v54 != v42) {
            objc_enumerationMutation(obj);
          }
          uint64_t v9 = *(void **)(*((void *)&v53 + 1) + 8 * i);
          uint64_t v10 = (void *)MEMORY[0x1D9452090]();
          id v11 = WeakRetained;
          id v12 = WeakRetained;
          id v13 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v14 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543618;
            uint64_t v60 = v14;
            __int16 v61 = 2112;
            uint64_t v62 = v9;
            _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_DEBUG, "%{public}@Got response %@", buf, 0x16u);
          }
          uint64_t v15 = [v9 request];
          id v16 = [v15 characteristic];

          uint64_t v17 = [v16 service];
          id v18 = [v9 value];
          long long v19 = [v9 valueUpdatedTime];
          long long v20 = [v9 stateNumber];
          id v21 = [v9 notificationContext];
          [v16 updateValue:v18 updatedTime:v19 stateNumber:v20 notificationContext:v21];

          aBlock[0] = MEMORY[0x1E4F143A8];
          aBlock[1] = 3221225472;
          aBlock[2] = __66__HMDHAPAccessory_readInitialRequiredCharacteristicsForAccessory___block_invoke_748;
          aBlock[3] = &unk_1E6A0AE48;
          void aBlock[4] = v12;
          id v51 = v17;
          id v52 = v43;
          id v22 = v17;
          id v23 = _Block_copy(aBlock);
          uint64_t v24 = [v16 type];
          long long v25 = [v9 value];
          long long v26 = [v22 type];
          long long v27 = [v22 accessory];
          +[HMDService processUpdateForCharacteristicType:v24 value:v25 serviceType:v26 service:v22 serviceTransactionGetter:v23 accessory:v27 accessoryTransaction:v44 accessoryTransactionChanged:&v57];

          id WeakRetained = v11;
        }
        uint64_t v45 = [obj countByEnumeratingWithState:&v53 objects:v63 count:16];
      }
      while (v45);
    }

    if (v57) {
      [v37 add:v44 withMessage:0];
    }
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    id v28 = v43;
    uint64_t v29 = [v28 countByEnumeratingWithState:&v46 objects:v58 count:16];
    id v3 = v40;
    if (v29)
    {
      uint64_t v30 = v29;
      uint64_t v31 = *(void *)v47;
      do
      {
        for (uint64_t j = 0; j != v30; ++j)
        {
          if (*(void *)v47 != v31) {
            objc_enumerationMutation(v28);
          }
          char v33 = [v28 objectForKey:*(void *)(*((void *)&v46 + 1) + 8 * j)];
          [v37 add:v33 withMessage:0];
        }
        uint64_t v30 = [v28 countByEnumeratingWithState:&v46 objects:v58 count:16];
      }
      while (v30);
    }

    [v37 run:*(void *)(v39 + 32)];
  }
  else
  {
    uint64_t v34 = (void *)MEMORY[0x1D9452090]();
    id v35 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
    {
      uint64_t v36 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v60 = v36;
      _os_log_impl(&dword_1D49D5000, v35, OS_LOG_TYPE_INFO, "%{public}@Accessory is no longer valid", buf, 0xCu);
    }
  }
}

id __66__HMDHAPAccessory_readInitialRequiredCharacteristicsForAccessory___block_invoke_748(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) uuid];
  id v4 = [v2 getOrCreateServiceUpdateTransactionForKey:v3 fromDictionary:*(void *)(a1 + 48)];

  return v4;
}

- (id)getOrCreateServiceUpdateTransactionForKey:(id)a3 fromDictionary:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  id v8 = [v7 objectForKey:v6];
  if (!v8)
  {
    uint64_t v9 = [HMDServiceTransaction alloc];
    uint64_t v10 = [(HMDAccessory *)self uuid];
    id v8 = [(HMDBackingStoreModelObject *)v9 initWithObjectChangeType:2 uuid:v6 parentUUID:v10];

    [v7 setObject:v8 forKey:v6];
  }

  return v8;
}

- (id)dumpSimpleState
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  v42.receiver = self;
  v42.super_class = (Class)HMDHAPAccessory;
  id v3 = [(HMDAccessory *)&v42 dumpSimpleState];
  id v4 = (void *)[v3 mutableCopy];

  uint64_t v5 = [(HMDHAPAccessory *)self identifiersForBridgedAccessories];
  uint64_t v6 = [v5 count];

  uint64_t v7 = [(HMDHAPAccessory *)self bridge];
  id v8 = (void *)v7;
  if (!v7 || v6)
  {
    if (v7 || !v6)
    {
      if (v7) {
        BOOL v10 = 1;
      }
      else {
        BOOL v10 = v6 != 0;
      }
      if (v10) {
        uint64_t v9 = @"<unknown>";
      }
      else {
        uint64_t v9 = @"standalone";
      }
    }
    else
    {
      uint64_t v9 = @"bridge";
    }
  }
  else
  {
    uint64_t v9 = @"bridged";
  }
  uint64_t v11 = *MEMORY[0x1E4F64EA0];
  id v12 = [v4 objectForKeyedSubscript:*MEMORY[0x1E4F64EA0]];
  id v13 = (void *)[v12 mutableCopy];

  uint64_t v14 = [(HMDHAPAccessory *)self connectivityInfo];
  uint64_t v15 = [(HMDHAPAccessory *)self sleepInterval];
  [v13 appendFormat:@"type: %@ connectivityInfo: %@, sleepInterval: %@", v9, v14, v15];

  [v4 setObject:v13 forKeyedSubscript:v11];
  id v16 = [(HMDHAPAccessory *)self transportInformationInstances];
  if ([v16 count])
  {
    uint64_t v34 = v13;
    id v35 = v8;
    uint64_t v36 = v4;
    uint64_t v17 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v16, "count"));
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    char v33 = v16;
    id obj = v16;
    uint64_t v18 = [obj countByEnumeratingWithState:&v38 objects:v43 count:16];
    if (v18)
    {
      uint64_t v19 = v18;
      uint64_t v20 = *(void *)v39;
      do
      {
        for (uint64_t i = 0; i != v19; ++i)
        {
          if (*(void *)v39 != v20) {
            objc_enumerationMutation(obj);
          }
          id v22 = *(void **)(*((void *)&v38 + 1) + 8 * i);
          id v23 = NSString;
          uint64_t v24 = [v22 serverIdentifier];
          long long v25 = [v22 instanceID];
          unint64_t v26 = [v22 linkType];
          long long v27 = @"Undefined";
          if (v26 <= 2) {
            long long v27 = off_1E6A0B860[v26];
          }
          id v28 = v27;
          if ([v22 isReachable]) {
            uint64_t v29 = "Yes";
          }
          else {
            uint64_t v29 = "No";
          }
          uint64_t v30 = [v22 protocolVersion];
          uint64_t v31 = [v23 stringWithFormat:@"HAPAccessory server: %@, instanceID: %@, linkType: %@, Transport Reachable: %s, version: %@", v24, v25, v28, v29, v30];

          [v17 addObject:v31];
        }
        uint64_t v19 = [obj countByEnumeratingWithState:&v38 objects:v43 count:16];
      }
      while (v19);
    }

    id v4 = v36;
    [v36 setObject:v17 forKeyedSubscript:*MEMORY[0x1E4F64D70]];

    id v13 = v34;
    id v8 = v35;
    id v16 = v33;
  }

  return v4;
}

- (id)dumpState
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  v97.receiver = self;
  v97.super_class = (Class)HMDHAPAccessory;
  id v3 = [(HMDAccessory *)&v97 dumpState];
  id v4 = (void *)[v3 mutableCopy];

  uint64_t v5 = [(HMDHAPAccessory *)self identifiersForBridgedAccessories];
  uint64_t v6 = [v5 count];

  uint64_t v7 = [(HMDHAPAccessory *)self bridge];
  id v8 = (void *)v7;
  if (!v7 || v6)
  {
    if (v7 || !v6)
    {
      if (v7) {
        BOOL v10 = 1;
      }
      else {
        BOOL v10 = v6 != 0;
      }
      if (v10) {
        uint64_t v9 = @"<unknown>";
      }
      else {
        uint64_t v9 = @"standalone";
      }
    }
    else
    {
      uint64_t v9 = @"bridge";
    }
  }
  else
  {
    uint64_t v9 = @"bridged";
  }
  uint64_t v11 = *MEMORY[0x1E4F64EA0];
  id v12 = [v4 objectForKeyedSubscript:*MEMORY[0x1E4F64EA0]];
  id v13 = (void *)[v12 mutableCopy];

  uint64_t v14 = [(HMDHAPAccessory *)self accessoryFlags];
  long long v82 = self;
  int64_t v15 = [(HMDHAPAccessory *)self certificationStatus];
  id v16 = [(HMDHAPAccessory *)v82 sleepInterval];
  int64_t v75 = v15;
  uint64_t v17 = v82;
  [v13 appendFormat:@", type: %@, accessoryFlags: %@, certificationStatus: %tu, sleepInterval: %@", v9, v14, v75, v16];

  long long v77 = v13;
  [v4 setObject:v13 forKeyedSubscript:v11];
  long long v81 = [(HMDHAPAccessory *)v82 identifiersForBridgedAccessories];
  long long v78 = v8;
  if ([v81 count])
  {
    uint64_t v18 = v4;
    uint64_t v19 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v81, "count"));
    long long v93 = 0u;
    long long v94 = 0u;
    long long v95 = 0u;
    long long v96 = 0u;
    id v20 = v81;
    uint64_t v21 = [v20 countByEnumeratingWithState:&v93 objects:v100 count:16];
    if (v21)
    {
      uint64_t v22 = v21;
      uint64_t v23 = *(void *)v94;
      do
      {
        for (uint64_t i = 0; i != v22; ++i)
        {
          if (*(void *)v94 != v23) {
            objc_enumerationMutation(v20);
          }
          long long v25 = NSString;
          unint64_t v26 = [*(id *)(*((void *)&v93 + 1) + 8 * i) UUIDString];
          long long v27 = [v25 stringWithFormat:@"Bridged accessory identifier: %@", v26];
          [v19 addObject:v27];
        }
        uint64_t v22 = [v20 countByEnumeratingWithState:&v93 objects:v100 count:16];
      }
      while (v22);
    }

    id v4 = v18;
    [v18 setObject:v19 forKeyedSubscript:*MEMORY[0x1E4F64D90]];

    id v8 = v78;
    uint64_t v17 = v82;
  }
  if (v8)
  {
    id v28 = NSString;
    uint64_t v29 = [v8 uuid];
    uint64_t v30 = [v29 UUIDString];
    uint64_t v31 = [v28 stringWithFormat:@"Bridge accessory identifier: %@", v30];
    [v4 setObject:v31 forKeyedSubscript:*MEMORY[0x1E4F64D88]];

    uint64_t v17 = v82;
  }
  objc_super v32 = [(HMDHAPAccessory *)v17 services];
  char v33 = (void *)[v32 copy];

  long long v80 = v33;
  if ([v33 count])
  {
    uint64_t v34 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v33, "count"));
    long long v89 = 0u;
    long long v90 = 0u;
    long long v91 = 0u;
    long long v92 = 0u;
    id v35 = v33;
    uint64_t v36 = [v35 countByEnumeratingWithState:&v89 objects:v99 count:16];
    if (v36)
    {
      uint64_t v37 = v36;
      uint64_t v38 = *(void *)v90;
      do
      {
        for (uint64_t j = 0; j != v37; ++j)
        {
          if (*(void *)v90 != v38) {
            objc_enumerationMutation(v35);
          }
          long long v40 = [*(id *)(*((void *)&v89 + 1) + 8 * j) dumpState];
          [v34 addObject:v40];
        }
        uint64_t v37 = [v35 countByEnumeratingWithState:&v89 objects:v99 count:16];
      }
      while (v37);
    }

    [v4 setObject:v34 forKeyedSubscript:*MEMORY[0x1E4F64E80]];
    uint64_t v17 = v82;
  }
  id v79 = [(HMDHAPAccessory *)v17 transportInformationInstances];
  if ([v79 count])
  {
    char v76 = v4;
    id v84 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v79, "count"));
    long long v85 = 0u;
    long long v86 = 0u;
    long long v87 = 0u;
    long long v88 = 0u;
    id obj = v79;
    uint64_t v41 = [obj countByEnumeratingWithState:&v85 objects:v98 count:16];
    if (v41)
    {
      uint64_t v42 = v41;
      uint64_t v43 = *(void *)v86;
      do
      {
        for (uint64_t k = 0; k != v42; ++k)
        {
          if (*(void *)v86 != v43) {
            objc_enumerationMutation(obj);
          }
          uint64_t v45 = *(void **)(*((void *)&v85 + 1) + 8 * k);
          long long v46 = (void *)MEMORY[0x1E4F28E78];
          long long v47 = [v45 serverIdentifier];
          long long v48 = [v45 instanceID];
          unint64_t v49 = [v45 linkType];
          long long v50 = @"Undefined";
          if (v49 <= 2) {
            long long v50 = off_1E6A0B860[v49];
          }
          id v51 = v50;
          if ([v45 isReachable]) {
            id v52 = "Yes";
          }
          else {
            id v52 = "No";
          }
          long long v53 = [v45 protocolVersion];
          long long v54 = [v46 stringWithFormat:@"HAPAccessory server: %@, instanceID: %@, linkType: %@, Transport Reachable: %s, version: %@", v47, v48, v51, v52, v53];

          long long v55 = [v45 hapAccessory];
          long long v56 = [v55 server];

          objc_opt_class();
          if (objc_opt_isKindOfClass()) {
            char v57 = v56;
          }
          else {
            char v57 = 0;
          }
          id v58 = v57;

          if (v58)
          {
            uint64_t v59 = [v58 peerEndpointDescription];
            [v54 appendFormat:@", endpoint: %@", v59];
          }
          uint64_t v60 = (void *)[v54 copy];
          [v84 addObject:v60];
        }
        uint64_t v42 = [obj countByEnumeratingWithState:&v85 objects:v98 count:16];
      }
      while (v42);
    }

    id v4 = v76;
    [v76 setObject:v84 forKeyedSubscript:*MEMORY[0x1E4F64D70]];

    id v8 = v78;
    uint64_t v17 = v82;
  }
  __int16 v61 = [(HMDHAPAccessory *)v17 setupHash];

  if (v61)
  {
    uint64_t v62 = [(HMDHAPAccessory *)v17 setupHash];
    [v4 setObject:v62 forKeyedSubscript:*MEMORY[0x1E4F64D68]];
  }
  id v63 = [(HMDHAPAccessory *)v17 chipStorage];
  uint64_t v64 = [v63 debugDictionaryRepresentation];
  [v4 setObject:v64 forKeyedSubscript:@"CHIP Accessory Storage"];

  [MEMORY[0x1E4F1CA60] dictionary];
  v66 = id v65 = v17;
  id v67 = [(HMDHAPAccessory *)v65 matterNodeID];
  [v66 setObject:v67 forKeyedSubscript:@"Matter Accessory Node ID"];

  __int16 v68 = [(HMDHAPAccessory *)v65 matterVendorID];
  [v66 setObject:v68 forKeyedSubscript:@"Matter Accessory Vendor ID"];

  id v69 = [(HMDHAPAccessory *)v65 matterProductID];
  [v66 setObject:v69 forKeyedSubscript:@"Matter Accessory Product ID"];

  unint64_t v70 = (void *)[v66 copy];
  [v4 setObject:v70 forKeyedSubscript:@"Matter Accessory Information"];

  id v71 = [(HMDHAPAccessory *)v65 accessoryMetric];
  id v72 = [v71 sessionMetric];
  uint64_t v73 = [v72 state];
  [v4 setObject:v73 forKeyedSubscript:@"Accessory Session State"];

  return v4;
}

- (BOOL)supportsPersonalRequests
{
  id v2 = [(HMDHAPAccessory *)self siriEndpointProfile];
  BOOL v3 = v2 != 0;

  return v3;
}

- (BOOL)isNotificationEnabled
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v2 = [(HMDHAPAccessory *)self services];
  BOOL v3 = (void *)[v2 copy];

  uint64_t v4 = [v3 countByEnumeratingWithState:&v21 objects:v26 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v22;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v22 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v21 + 1) + 8 * i);
        long long v17 = 0u;
        long long v18 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v9 = objc_msgSend(v8, "characteristics", 0);
        BOOL v10 = (void *)[v9 copy];

        uint64_t v11 = [v10 countByEnumeratingWithState:&v17 objects:v25 count:16];
        if (v11)
        {
          uint64_t v12 = v11;
          uint64_t v13 = *(void *)v18;
          while (2)
          {
            for (uint64_t j = 0; j != v12; ++j)
            {
              if (*(void *)v18 != v13) {
                objc_enumerationMutation(v10);
              }
              if ([*(id *)(*((void *)&v17 + 1) + 8 * j) isNotificationEnabled])
              {

                BOOL v15 = 1;
                goto LABEL_19;
              }
            }
            uint64_t v12 = [v10 countByEnumeratingWithState:&v17 objects:v25 count:16];
            if (v12) {
              continue;
            }
            break;
          }
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v21 objects:v26 count:16];
      BOOL v15 = 0;
    }
    while (v5);
  }
  else
  {
    BOOL v15 = 0;
  }
LABEL_19:

  return v15;
}

- (BOOL)isNonClientNotificationEnabled
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v2 = [(HMDHAPAccessory *)self services];
  BOOL v3 = (void *)[v2 copy];

  uint64_t v4 = [v3 countByEnumeratingWithState:&v21 objects:v26 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v22;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v22 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v21 + 1) + 8 * i);
        long long v17 = 0u;
        long long v18 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v9 = objc_msgSend(v8, "characteristics", 0);
        BOOL v10 = (void *)[v9 copy];

        uint64_t v11 = [v10 countByEnumeratingWithState:&v17 objects:v25 count:16];
        if (v11)
        {
          uint64_t v12 = v11;
          uint64_t v13 = *(void *)v18;
          while (2)
          {
            for (uint64_t j = 0; j != v12; ++j)
            {
              if (*(void *)v18 != v13) {
                objc_enumerationMutation(v10);
              }
              if ([*(id *)(*((void *)&v17 + 1) + 8 * j) isNonClientNotificationEnabled])
              {

                BOOL v15 = 1;
                goto LABEL_19;
              }
            }
            uint64_t v12 = [v10 countByEnumeratingWithState:&v17 objects:v25 count:16];
            if (v12) {
              continue;
            }
            break;
          }
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v21 objects:v26 count:16];
      BOOL v15 = 0;
    }
    while (v5);
  }
  else
  {
    BOOL v15 = 0;
  }
LABEL_19:

  return v15;
}

- (BOOL)isNotificationEnabledForClientIdentifier:(id)a3
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  uint64_t v5 = [(HMDHAPAccessory *)self services];
  uint64_t v6 = (void *)[v5 copy];

  uint64_t v7 = [v6 countByEnumeratingWithState:&v24 objects:v29 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v25;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v25 != v9) {
          objc_enumerationMutation(v6);
        }
        uint64_t v11 = *(void **)(*((void *)&v24 + 1) + 8 * i);
        long long v20 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        uint64_t v12 = objc_msgSend(v11, "characteristics", 0);
        uint64_t v13 = (void *)[v12 copy];

        uint64_t v14 = [v13 countByEnumeratingWithState:&v20 objects:v28 count:16];
        if (v14)
        {
          uint64_t v15 = v14;
          uint64_t v16 = *(void *)v21;
          while (2)
          {
            for (uint64_t j = 0; j != v15; ++j)
            {
              if (*(void *)v21 != v16) {
                objc_enumerationMutation(v13);
              }
              if ([*(id *)(*((void *)&v20 + 1) + 8 * j) isNotificationEnabledForClientIdentifier:v4])
              {

                BOOL v18 = 1;
                goto LABEL_19;
              }
            }
            uint64_t v15 = [v13 countByEnumeratingWithState:&v20 objects:v28 count:16];
            if (v15) {
              continue;
            }
            break;
          }
        }
      }
      uint64_t v8 = [v6 countByEnumeratingWithState:&v24 objects:v29 count:16];
      BOOL v18 = 0;
    }
    while (v8);
  }
  else
  {
    BOOL v18 = 0;
  }
LABEL_19:

  return v18;
}

- (void)accessory:(id)a3 didUpdateReachabilityState:(BOOL)a4
{
  id v6 = a3;
  uint64_t v7 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __56__HMDHAPAccessory_accessory_didUpdateReachabilityState___block_invoke;
  block[3] = &unk_1E6A18708;
  void block[4] = self;
  id v10 = v6;
  BOOL v11 = a4;
  id v8 = v6;
  dispatch_async(v7, block);
}

void __56__HMDHAPAccessory_accessory_didUpdateReachabilityState___block_invoke(uint64_t a1)
{
  id v6 = [*(id *)(a1 + 32) matchingTransportInformation:*(void *)(a1 + 40)];
  id v2 = [*(id *)(a1 + 32) home];
  BOOL v3 = [v2 reachabilityChangedLogEventManager];
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = [v6 report];
  [v3 submitForAccessory:v4 withTransportReport:v5 reachable:*(unsigned __int8 *)(a1 + 48)];

  [v6 setReachable:*(unsigned __int8 *)(a1 + 48)];
  [*(id *)(a1 + 32) _updateReachability];
}

- (void)didUpdateConnectionState:(BOOL)a3 sessionInfo:(id)a4 linkLayerType:(int64_t)a5 bookkeeping:(id)a6 withError:(id)a7
{
  id v12 = a4;
  id v13 = a6;
  id v14 = a7;
  uint64_t v15 = [(HMDAccessory *)self workQueue];
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 3221225472;
  id v19[2] = __92__HMDHAPAccessory_didUpdateConnectionState_sessionInfo_linkLayerType_bookkeeping_withError___block_invoke;
  v19[3] = &unk_1E6A19B08;
  BOOL v24 = a3;
  id v22 = v14;
  int64_t v23 = a5;
  v19[4] = self;
  id v20 = v12;
  id v21 = v13;
  id v16 = v14;
  id v17 = v13;
  id v18 = v12;
  dispatch_async(v15, v19);
}

void __92__HMDHAPAccessory_didUpdateConnectionState_sessionInfo_linkLayerType_bookkeeping_withError___block_invoke(uint64_t a1)
{
  [*(id *)(a1 + 32) _checkSessionRestoreOnLinkStateChange];
  [*(id *)(a1 + 32) setConnected:*(unsigned __int8 *)(a1 + 72)];
  if (*(unsigned char *)(a1 + 72))
  {
    id v9 = [*(id *)(a1 + 32) accessoryMetric];
    id v2 = [v9 sessionMetric];
    BOOL v3 = v2;
    uint64_t v4 = *(void *)(a1 + 64);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = 1;
    uint64_t v8 = 0;
  }
  else
  {
    logAndPostNotification(@"HMDAccessoryDisconnectedNotification", *(void **)(a1 + 32), 0);
    id v9 = [*(id *)(a1 + 32) accessoryMetric];
    id v2 = [v9 sessionMetric];
    BOOL v3 = v2;
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v4 = *(void *)(a1 + 64);
    uint64_t v7 = 0;
  }
  [v2 updateSessionState:v7 linkLayerType:v4 sessionInfo:v5 bookkeeping:v6 withError:v8];
}

- (void)didUpdateConnectionState:(BOOL)a3 linkLayerType:(int64_t)a4 withError:(id)a5
{
}

- (void)__updateNotifyingCharacteristicStateNumber:(id)a3
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id obj = [(HMDHAPAccessory *)self services];
  uint64_t v24 = [obj countByEnumeratingWithState:&v31 objects:v42 count:16];
  if (v24)
  {
    uint64_t v23 = *(void *)v32;
    long long v26 = self;
    do
    {
      uint64_t v5 = 0;
      do
      {
        if (*(void *)v32 != v23) {
          objc_enumerationMutation(obj);
        }
        uint64_t v25 = v5;
        uint64_t v6 = *(void **)(*((void *)&v31 + 1) + 8 * v5);
        long long v27 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        uint64_t v7 = [v6 characteristics];
        uint64_t v8 = [v7 countByEnumeratingWithState:&v27 objects:v41 count:16];
        if (v8)
        {
          uint64_t v9 = v8;
          uint64_t v10 = *(void *)v28;
          do
          {
            for (uint64_t i = 0; i != v9; ++i)
            {
              if (*(void *)v28 != v10) {
                objc_enumerationMutation(v7);
              }
              id v12 = *(void **)(*((void *)&v27 + 1) + 8 * i);
              if ([v12 supportsNotification])
              {
                id v13 = [v12 stateNumber];
                uint64_t v14 = HAPCompareStateNumberWithRollover();

                if (v14 == -1)
                {
                  uint64_t v15 = [v4 unsignedIntegerValue];
                  id v16 = [v12 stateNumber];
                  uint64_t v17 = v15 - [v16 unsignedIntegerValue];

                  if (v17 == 1)
                  {
                    id v18 = (void *)MEMORY[0x1D9452090]();
                    long long v19 = self;
                    id v20 = HMFGetOSLogHandle();
                    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
                    {
                      id v21 = HMFGetLogIdentifier();
                      *(_DWORD *)buf = 138543874;
                      uint64_t v36 = v21;
                      __int16 v37 = 2112;
                      id v38 = v4;
                      __int16 v39 = 2112;
                      long long v40 = v12;
                      _os_log_impl(&dword_1D49D5000, v20, OS_LOG_TYPE_INFO, "%{public}@Updating state number to %@ for characteristic: %@", buf, 0x20u);

                      self = v26;
                    }

                    [v12 setStateNumber:v4];
                  }
                }
              }
            }
            uint64_t v9 = [v7 countByEnumeratingWithState:&v27 objects:v41 count:16];
          }
          while (v9);
        }

        uint64_t v5 = v25 + 1;
      }
      while (v25 + 1 != v24);
      uint64_t v24 = [obj countByEnumeratingWithState:&v31 objects:v42 count:16];
    }
    while (v24);
  }
}

- (void)notifyingCharacteristicStateNumberUpdated:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __61__HMDHAPAccessory_notifyingCharacteristicStateNumberUpdated___block_invoke;
  v7[3] = &unk_1E6A197C8;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

uint64_t __61__HMDHAPAccessory_notifyingCharacteristicStateNumberUpdated___block_invoke(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "__updateNotifyingCharacteristicStateNumber:", *(void *)(a1 + 40));
}

- (void)_handleMultipleCharacteristicsUpdated:(id)a3 message:(id)a4 completionQueue:(id)a5 completionHandler:(id)a6
{
  uint64_t v233 = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v181 = a4;
  BOOL v11 = a5;
  id v158 = a6;
  __int16 v159 = v11;
  if (v158)
  {
    v179 = [MEMORY[0x1E4F28E10] strongToStrongObjectsMapTable];
  }
  else
  {
    id v12 = (void *)MEMORY[0x1D9452090]();
    id v13 = self;
    uint64_t v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      v216 = v15;
      _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_ERROR, "%{public}@*** modified characteristics will be skipped due to missing completion queue or handler", buf, 0xCu);
    }
    v179 = 0;
  }
  v175 = [v181 stringForKey:@"kNotificationUpdateIdentifierKey"];
  id v16 = (void *)MEMORY[0x1D9452090]();
  uint64_t v17 = self;
  id v18 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    long long v19 = HMFGetLogIdentifier();
    [v181 isRemote];
    id v20 = HMFBooleanToString();
    *(_DWORD *)buf = 138543874;
    v216 = v19;
    __int16 v217 = 2112;
    uint64_t v218 = (uint64_t)v175;
    __int16 v219 = 2112;
    uint64_t v220 = (uint64_t)v20;
    _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_INFO, "%{public}@Received characteristics updated notification with identifier %@ from message with isRemote=%@", buf, 0x20u);
  }
  BOOL v21 = [(HMDHAPAccessory *)v17 isSecuritySessionOpen];
  id v22 = [v181 destination];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v23 = v22;
  }
  else {
    uint64_t v23 = 0;
  }
  id v24 = v23;

  v170 = [(HMDHAPAccessory *)v17 hapMetadata];
  __int16 v165 = [[HMDHomeKitVersion alloc] initWithVersionString:@"3.2"];
  v157 = v24;
  uint64_t v25 = [v24 device];
  v169 = [(HMDAccessory *)v17 home];
  v177 = v25;
  long long v26 = [v25 version];
  long long v27 = [[HMDHomeKitVersion alloc] initWithVersionString:@"3.1"];
  int v168 = [v26 isAtLeastVersion:v27];

  v173 = [MEMORY[0x1E4F1CA60] dictionary];
  long long v210 = 0u;
  long long v211 = 0u;
  long long v212 = 0u;
  long long v213 = 0u;
  id v28 = v10;
  uint64_t v29 = [v28 countByEnumeratingWithState:&v210 objects:v232 count:16];
  id obj = v28;
  if (!v29)
  {

    v156 = 0;
    id v155 = (void (**)(void, void))v158;
    id v154 = v159;
    long long v31 = v179;
    if (!v158) {
      goto LABEL_138;
    }
    goto LABEL_135;
  }
  uint64_t v30 = v29;
  uint64_t v167 = 0;
  char v171 = 0;
  char v172 = !v21;
  uint64_t v162 = *(void *)v211;
  uint64_t v166 = *MEMORY[0x1E4F5BAC8];
  long long v31 = v179;
  v180 = v17;
  do
  {
    uint64_t v32 = 0;
    uint64_t v160 = v30;
    do
    {
      if (*(void *)v211 != v162) {
        objc_enumerationMutation(obj);
      }
      uint64_t v164 = v32;
      long long v33 = objc_msgSend(obj, "hmf_dictionaryForKey:", *(void *)(*((void *)&v210 + 1) + 8 * v32));
      v183 = HAPInstanceIDFromValue();
      uint64_t v34 = -[HMDHAPAccessory findService:](v17, "findService:");
      v176 = (void *)v34;
      if (v33) {
        BOOL v35 = v34 == 0;
      }
      else {
        BOOL v35 = 1;
      }
      if (!v35)
      {
        char v209 = 0;
        v174 = [(HMDHAPAccessory *)v17 transactionWithObjectChangeType:2];
        long long v205 = 0u;
        long long v206 = 0u;
        long long v207 = 0u;
        long long v208 = 0u;
        id v187 = v33;
        __int16 v161 = v33;
        uint64_t v186 = [v187 countByEnumeratingWithState:&v205 objects:v231 count:16];
        if (!v186) {
          goto LABEL_115;
        }
        uint64_t v182 = *(void *)v206;
        while (1)
        {
          for (uint64_t i = 0; i != v186; ++i)
          {
            if (*(void *)v206 != v182) {
              objc_enumerationMutation(v187);
            }
            uint64_t v37 = *(void *)(*((void *)&v205 + 1) + 8 * i);
            id v38 = HAPInstanceIDFromValue();
            uint64_t v39 = [(HMDHAPAccessory *)v17 findCharacteristic:v38 forService:v183];
            long long v40 = (void *)v39;
            if (v39)
            {
              v193 = (void *)v39;
              v188 = v38;
              uint64_t v41 = objc_msgSend(v187, "hmf_dictionaryForKey:", v37);
              uint64_t v194 = [v41 objectForKey:@"kCharacteristicValue"];
              v192 = objc_msgSend(v41, "hmf_numberForKey:", @"kCharacteristicValueUpdateStateNumberKey");
              uint64_t v42 = objc_msgSend(v41, "hmf_dateForKey:", @"kCharacteristicValueUpdateTime");
              uint64_t v43 = [v41 errorFromDataForKey:@"kCharacteristicErrorDataKey"];
              v191 = objc_msgSend(v41, "hmf_dataForKey:", @"kCharacteristicNotificationContextKey");
              uint64_t v44 = [v41 objectForKey:@"kCharacteristicBroadcastValueUpdateKey"];

              int v184 = objc_msgSend(v41, "hmf_BOOLForKey:", @"kCharacteristicBroadcastValueUpdateKey");
              id v45 = objc_alloc(MEMORY[0x1E4F29128]);
              long long v46 = objc_msgSend(v41, "hmf_stringForKey:", @"kCharacteristicAttributedUserUUIDKey");
              v190 = (void *)[v45 initWithUUIDString:v46];

              long long v47 = (void *)MEMORY[0x1D9452090]();
              long long v48 = v17;
              unint64_t v49 = HMFGetOSLogHandle();
              uint64_t v189 = i;
              if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
              {
                long long v50 = HMFGetLogIdentifier();
                id v51 = HMFBooleanToString();
                HMFBooleanToString();
                id v52 = v41;
                long long v53 = v44;
                long long v54 = v48;
                uint64_t v55 = v43;
                v57 = long long v56 = v42;
                *(_DWORD *)buf = 138545154;
                v216 = v50;
                __int16 v217 = 2112;
                uint64_t v218 = (uint64_t)v193;
                __int16 v219 = 2112;
                uint64_t v220 = (uint64_t)v51;
                __int16 v221 = 2112;
                v222 = v191;
                __int16 v223 = 2112;
                uint64_t v224 = v194;
                __int16 v225 = 2112;
                v226 = v56;
                __int16 v227 = 2112;
                v228 = v57;
                __int16 v229 = 2112;
                v230 = v190;
                _os_log_impl(&dword_1D49D5000, v49, OS_LOG_TYPE_INFO, "%{public}@Handling update notification for characteristic: %@ isSecuritySessionOpen: %@ notificationContext: %@ updatedValue: %@ valueUpdatedTime: %@ isBroadcast: %@ attributedUserUUID: %@", buf, 0x52u);

                uint64_t v42 = v56;
                uint64_t v43 = v55;
                long long v48 = v54;
                uint64_t v44 = v53;
                uint64_t v41 = v52;
                uint64_t i = v189;

                uint64_t v17 = v180;
              }

              if ([v181 isRemote])
              {
                id v58 = [v193 accessory];
                [v58 setRemotelyReachable:v43 == 0];
              }
              uint64_t v59 = (void *)v194;
              if (!(v194 | v43))
              {
                uint64_t v43 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
                uint64_t v60 = (void *)MEMORY[0x1D9452090]();
                __int16 v61 = v48;
                uint64_t v62 = HMFGetOSLogHandle();
                if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
                {
                  id v63 = HMFGetLogIdentifier();
                  *(_DWORD *)buf = 138543618;
                  v216 = v63;
                  __int16 v217 = 2112;
                  uint64_t v218 = v43;
                  _os_log_impl(&dword_1D49D5000, v62, OS_LOG_TYPE_INFO, "%{public}@Nil updated value for characteristic, adding error: %@", buf, 0x16u);
                }
                uint64_t v17 = v180;
                uint64_t v59 = (void *)v194;
              }
              if (v43)
              {
                uint64_t v64 = v41;
                id v65 = v59;
                id v66 = v42;
                id v67 = v17;
                __int16 v68 = (void *)v43;
                id v69 = (void *)MEMORY[0x1D9452090]();
                unint64_t v70 = v48;
                id v71 = HMFGetOSLogHandle();
                long long v40 = v193;
                if (os_log_type_enabled(v71, OS_LOG_TYPE_INFO))
                {
                  id v72 = HMFGetLogIdentifier();
                  *(_DWORD *)buf = 138543874;
                  v216 = v72;
                  __int16 v217 = 2112;
                  uint64_t v218 = (uint64_t)v193;
                  __int16 v219 = 2112;
                  uint64_t v220 = (uint64_t)v68;
                  _os_log_impl(&dword_1D49D5000, v71, OS_LOG_TYPE_INFO, "%{public}@Received %@ update with error %@", buf, 0x20u);
                }
                if (v179)
                {
                  uint64_t v73 = v68;
                  id v74 = [[HMDCharacteristicValueUpdate alloc] initWithError:v68];
                  [v179 setObject:v74 forKey:v193];

                  id v38 = v188;
                  int64_t v75 = v192;
                }
                else
                {
                  id v38 = v188;
                  int64_t v75 = v192;
                  uint64_t v73 = v68;
                }
                uint64_t v17 = v67;
                uint64_t v42 = v66;
                uint64_t v59 = v65;
                uint64_t v41 = v64;
                uint64_t i = v189;
                goto LABEL_112;
              }
              if (![v181 isRemote])
              {
                long long v40 = v193;
                goto LABEL_48;
              }
              if (v192)
              {
                char v76 = [v193 stateNumber];
                uint64_t v77 = HAPCompareStateNumberWithRollover();

                if (v77 == 1)
                {
                  uint64_t v78 = MEMORY[0x1D9452090]();
                  id v79 = v48;
                  long long v80 = HMFGetOSLogHandle();
                  long long v40 = v193;
                  if (os_log_type_enabled(v80, OS_LOG_TYPE_INFO))
                  {
                    long long v81 = HMFGetLogIdentifier();
                    long long v82 = [v193 stateNumber];
                    *(_DWORD *)buf = 138544130;
                    v216 = v81;
                    __int16 v217 = 2112;
                    uint64_t v218 = (uint64_t)v193;
                    __int16 v219 = 2112;
                    uint64_t v220 = (uint64_t)v192;
                    __int16 v221 = 2112;
                    v222 = v82;
                    _os_log_impl(&dword_1D49D5000, v80, OS_LOG_TYPE_INFO, "%{public}@Not adding %@ as state number:%@ is stale, current: %@", buf, 0x2Au);

                    uint64_t v59 = (void *)v194;
                  }

                  dispatch_group_t v83 = (void *)v78;
LABEL_109:
LABEL_110:
                  id v38 = v188;
                  int64_t v75 = v192;
LABEL_111:
                  uint64_t v73 = 0;
LABEL_112:

                  goto LABEL_113;
                }
              }
              v178 = v42;
              int v86 = v184;
              if (!v44) {
                int v86 = 1;
              }
              long long v40 = v193;
              if (v86 == 1)
              {
                long long v87 = [v193 value];
                if (+[HMDCharacteristic value:v59 differentThan:v87])
                {
                }
                else
                {
                  long long v113 = [v193 stateNumber];
                  int v114 = HMFEqualObjects();

                  if (v192 && v114)
                  {
                    long long v115 = (void *)MEMORY[0x1D9452090]();
                    long long v116 = v48;
                    long long v117 = HMFGetOSLogHandle();
                    if (os_log_type_enabled(v117, OS_LOG_TYPE_INFO))
                    {
                      long long v118 = HMFGetLogIdentifier();
                      long long v119 = [v193 stateNumber];
                      *(_DWORD *)buf = 138544130;
                      v216 = v118;
                      __int16 v217 = 2112;
                      uint64_t v218 = (uint64_t)v193;
                      __int16 v219 = 2112;
                      uint64_t v220 = (uint64_t)v192;
                      __int16 v221 = 2112;
                      v222 = v119;
                      _os_log_impl(&dword_1D49D5000, v117, OS_LOG_TYPE_INFO, "%{public}@Not adding %@ as the value hasn't changed and state number:%@ is same, current: %@", buf, 0x2Au);

                      uint64_t v59 = (void *)v194;
                    }

                    id v38 = v188;
                    int64_t v75 = v192;
                    goto LABEL_111;
                  }
                }
              }
              if (v192) {
                char v88 = 1;
              }
              else {
                char v88 = v172;
              }
              if (v88)
              {
                if (!v192) {
                  goto LABEL_65;
                }
LABEL_67:
                uint64_t v101 = [v193 characteristicType];
                if ([v170 shouldNotCacheCharacteristicOfType:v101])
                {
                  id v102 = [v176 serviceType];
                  if ([v102 isEqualToString:v166])
                  {
                    BOOL v103 = [v177 version];
                    uint64_t v104 = [v103 compare:v165];

                    BOOL v35 = v104 == -1;
                    uint64_t v59 = (void *)v194;
                    if (!v35)
                    {
LABEL_82:
                      unint64_t v120 = [v193 value];
                      if (+[HMDCharacteristic value:v59 differentThan:v120])
                      {
                      }
                      else
                      {
                        long long v121 = [(HMDHAPAccessory *)v48 hapMetadata];
                        dispatch_group_t v122 = [v193 type];
                        char v123 = [v121 shouldNotCacheCharacteristicOfType:v122];

                        if ((v123 & 1) == 0)
                        {
                          id v135 = [MEMORY[0x1E4F1CA98] null];
                          uint64_t v59 = (void *)v194;
                          int v136 = [(id)v194 isEqual:v135];

                          if (v136) {
                            uint64_t v137 = 0;
                          }
                          else {
                            uint64_t v137 = v194;
                          }
                          id v138 = (void *)MEMORY[0x1D9452090]([v193 updateValue:v137 updatedTime:v42 stateNumber:v192 notificationContext:v191]);
                          uint64_t v139 = v48;
                          char v140 = HMFGetOSLogHandle();
                          if (os_log_type_enabled(v140, OS_LOG_TYPE_INFO))
                          {
                            uint64_t v141 = HMFGetLogIdentifier();
                            *(_DWORD *)buf = 138543618;
                            v216 = v141;
                            __int16 v217 = 2112;
                            uint64_t v218 = (uint64_t)v193;
                            _os_log_impl(&dword_1D49D5000, v140, OS_LOG_TYPE_INFO, "%{public}@Ignoring same value updates for characteristics: %@ from remote", buf, 0x16u);
                          }
                          long long v142 = [(HMDAccessory *)v139 identifier];
                          long long v143 = v139;
                          int64_t v75 = v192;
                          [(HMDHAPAccessory *)v143 _updateStateForTrackedAccessory:v142 stateNumber:v192];

                          id v38 = v188;
                          goto LABEL_111;
                        }
                      }
                      long long v124 = (void *)MEMORY[0x1D9452090]();
                      __int16 v125 = v48;
                      id v126 = HMFGetOSLogHandle();
                      if (os_log_type_enabled(v126, OS_LOG_TYPE_INFO))
                      {
                        id v127 = HMFGetLogIdentifier();
                        *(_DWORD *)buf = 138543874;
                        v216 = v127;
                        __int16 v217 = 2112;
                        uint64_t v218 = (uint64_t)v193;
                        __int16 v219 = 2112;
                        uint64_t v220 = (uint64_t)v192;
                        _os_log_impl(&dword_1D49D5000, v126, OS_LOG_TYPE_INFO, "%{public}@Adding %@ as the value or state number: %@ changed", buf, 0x20u);
                      }
                      if (v192)
                      {
                        id v128 = (void *)MEMORY[0x1D9452090]();
                        BOOL v129 = v125;
                        long long v130 = HMFGetOSLogHandle();
                        uint64_t v59 = (void *)v194;
                        if (os_log_type_enabled(v130, OS_LOG_TYPE_INFO))
                        {
                          HMFGetLogIdentifier();
                          long long v131 = v185 = v128;
                          long long v132 = [v193 value];
                          long long v133 = [v193 stateNumber];
                          *(_DWORD *)buf = 138544642;
                          v216 = v131;
                          __int16 v217 = 2112;
                          uint64_t v218 = (uint64_t)v193;
                          uint64_t v59 = (void *)v194;
                          __int16 v219 = 2112;
                          uint64_t v220 = (uint64_t)v132;
                          __int16 v221 = 2112;
                          v222 = v133;
                          __int16 v223 = 2112;
                          uint64_t v224 = v194;
                          __int16 v225 = 2112;
                          v226 = v192;
                          _os_log_impl(&dword_1D49D5000, v130, OS_LOG_TYPE_INFO, "%{public}@Value for characteristic %@ changed with updated state number from %@/%@ to %@/%@", buf, 0x3Eu);

                          uint64_t v17 = v180;
                          uint64_t v42 = v178;

                          id v128 = v185;
                        }

                        if (HAPCompareStateNumberWithRollover() == 1)
                        {
                          id v134 = v192;

                          char v171 = 1;
                          uint64_t v167 = v134;
                        }
                        else
                        {
                          char v171 = 1;
                        }
                        long long v40 = v193;
                      }
                      else
                      {
                        uint64_t v59 = (void *)v194;
                      }
                      id v144 = [(HMDAccessory *)v125 identifier];
                      [(HMDHAPAccessory *)v125 _updateStateForTrackedAccessory:v144 stateNumber:v192];

                      if (![(HMDHAPAccessory *)v125 isClientRegisteredForNotifications]&& v192&& (v171 & 1) != 0)
                      {
                        [(HMDHAPAccessory *)v125 _removeBackedoffAccessoryForStateNumber:v192];
                        char v171 = 1;
                      }
LABEL_48:
                      id v84 = [MEMORY[0x1E4F1CA98] null];
                      int v85 = [v59 isEqual:v84];

                      if (v85)
                      {
                        [v40 updateValue:0 updatedTime:v42 stateNumber:v192 notificationContext:v191];
                      }
                      else
                      {
                        [v40 updateValue:v59 updatedTime:v42 stateNumber:v192 notificationContext:v191];
                        aBlock[0] = MEMORY[0x1E4F143A8];
                        aBlock[1] = 3221225472;
                        aBlock[2] = __99__HMDHAPAccessory__handleMultipleCharacteristicsUpdated_message_completionQueue_completionHandler___block_invoke;
                        aBlock[3] = &unk_1E6A0AE48;
                        void aBlock[4] = v48;
                        id v89 = v40;
                        id v203 = v89;
                        id v204 = v173;
                        long long v90 = _Block_copy(aBlock);
                        long long v91 = [v89 type];
                        long long v92 = [v176 type];
                        long long v93 = [v176 accessory];
                        long long v40 = v193;
                        +[HMDService processUpdateForCharacteristicType:v91 value:v194 serviceType:v92 service:v176 serviceTransactionGetter:v90 accessory:v93 accessoryTransaction:v174 accessoryTransactionChanged:&v209];

                        uint64_t v59 = (void *)v194;
                      }
                      if (v179)
                      {
                        long long v94 = [HMDCharacteristicValueUpdate alloc];
                        long long v95 = [v40 value];
                        long long v96 = [(HMDCharacteristicValueUpdate *)v94 initWithValue:v95 updateIdentifier:v175 remoteDevice:v177];

                        objc_super v97 = [v40 lastKnownValueUpdateTime];
                        __int16 v98 = [v40 stateNumber];
                        [(HMDCharacteristicValueUpdate *)v96 setValueUpdatedTime:v97 stateNumber:v98];

                        [v179 setObject:v96 forKey:v40];
                      }
                      goto LABEL_110;
                    }
                    uint64_t v105 = MEMORY[0x1D9452090]();
                    __int16 v106 = v48;
                    id v107 = HMFGetOSLogHandle();
                    if (os_log_type_enabled(v107, OS_LOG_TYPE_INFO))
                    {
                      id v108 = HMFGetLogIdentifier();
                      *(_DWORD *)buf = 138544130;
                      v216 = v108;
                      __int16 v217 = 2112;
                      uint64_t v218 = (uint64_t)v193;
                      __int16 v219 = 2112;
                      uint64_t v220 = v194;
                      __int16 v221 = 2112;
                      v222 = v177;
                      id v109 = v107;
                      os_log_type_t v110 = OS_LOG_TYPE_INFO;
                      BOOL v111 = "%{public}@Dropping %@ value update %@ from pre-Erie device %@";
                      uint32_t v112 = 42;
                      goto LABEL_107;
                    }
LABEL_108:

                    dispatch_group_t v83 = (void *)v105;
                    goto LABEL_109;
                  }
                }
                goto LABEL_82;
              }
              if ([v169 isResidentFirstAccessoryCommunicationEnabled])
              {
LABEL_65:
                if ((![(HMDHAPAccessory *)v48 hasBTLELink] | v168)) {
                  goto LABEL_67;
                }
                __int16 v99 = [v193 value];
                BOOL v100 = +[HMDCharacteristic value:v59 differentThan:v99];

                if (v100) {
                  goto LABEL_67;
                }
                uint64_t v105 = MEMORY[0x1D9452090]();
                __int16 v106 = v48;
                id v107 = HMFGetOSLogHandle();
                if (!os_log_type_enabled(v107, OS_LOG_TYPE_INFO)) {
                  goto LABEL_108;
                }
                id v108 = HMFGetLogIdentifier();
                *(_DWORD *)buf = 138543362;
                v216 = v108;
                id v109 = v107;
                os_log_type_t v110 = OS_LOG_TYPE_INFO;
                BOOL v111 = "%{public}@Ignoring stale update from legacy BLE devices";
                uint32_t v112 = 12;
              }
              else
              {
                uint64_t v105 = MEMORY[0x1D9452090]();
                __int16 v106 = v48;
                id v107 = HMFGetOSLogHandle();
                if (!os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_108;
                }
                id v108 = HMFGetLogIdentifier();
                *(_DWORD *)buf = 138543618;
                v216 = v108;
                __int16 v217 = 2112;
                uint64_t v218 = (uint64_t)v193;
                id v109 = v107;
                os_log_type_t v110 = OS_LOG_TYPE_DEFAULT;
                BOOL v111 = "%{public}@Not adding %@ as we are currently connected to the accessory";
                uint32_t v112 = 22;
              }
LABEL_107:
              _os_log_impl(&dword_1D49D5000, v109, v110, v111, buf, v112);

              goto LABEL_108;
            }
LABEL_113:
          }
          uint64_t v186 = [v187 countByEnumeratingWithState:&v205 objects:v231 count:16];
          if (!v186)
          {
LABEL_115:

            long long v145 = +[HMDBackingStoreTransactionOptions optionsWithSource:0 destination:2 mustReplay:1 mustPush:0];
            id v146 = [v169 backingStore];
            uint64_t v147 = [v146 transaction:@"AccessoryUpdated" options:v145];

            long long v200 = 0u;
            long long v201 = 0u;
            long long v198 = 0u;
            long long v199 = 0u;
            id v148 = v173;
            uint64_t v149 = [v148 countByEnumeratingWithState:&v198 objects:v214 count:16];
            if (v149)
            {
              uint64_t v150 = v149;
              uint64_t v151 = *(void *)v199;
              do
              {
                for (uint64_t j = 0; j != v150; ++j)
                {
                  if (*(void *)v199 != v151) {
                    objc_enumerationMutation(v148);
                  }
                  id v153 = [v148 objectForKey:*(void *)(*((void *)&v198 + 1) + 8 * j)];
                  [v147 add:v153 withMessage:0];
                }
                uint64_t v150 = [v148 countByEnumeratingWithState:&v198 objects:v214 count:16];
              }
              while (v150);
            }

            if (v209 && ([v147 add:v174 withMessage:0], v209) || objc_msgSend(v148, "count")) {
              [v147 run];
            }

            long long v31 = v179;
            uint64_t v30 = v160;
            long long v33 = v161;
            break;
          }
        }
      }

      uint64_t v32 = v164 + 1;
    }
    while (v164 + 1 != v30);
    uint64_t v30 = [obj countByEnumeratingWithState:&v210 objects:v232 count:16];
  }
  while (v30);

  id v155 = (void (**)(void, void))v158;
  id v154 = v159;
  if (v171)
  {
    v156 = v167;
    [(HMDHAPAccessory *)v17 __updateNotifyingCharacteristicStateNumber:v167];
    [v169 saveToCurrentAccountWithReason:@"kCharacteristicValueUpdateStateNumberKey"];
    if (!v158) {
      goto LABEL_138;
    }
LABEL_135:
    if (v154)
    {
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __99__HMDHAPAccessory__handleMultipleCharacteristicsUpdated_message_completionQueue_completionHandler___block_invoke_2;
      block[3] = &unk_1E6A19530;
      v197 = v155;
      id v196 = v31;
      dispatch_async(v154, block);
    }
    else
    {
      ((void (**)(void, void *))v155)[2](v155, v31);
    }
  }
  else
  {
    v156 = v167;
    if (v158) {
      goto LABEL_135;
    }
  }
LABEL_138:
}

id __99__HMDHAPAccessory__handleMultipleCharacteristicsUpdated_message_completionQueue_completionHandler___block_invoke(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  BOOL v3 = [*(id *)(a1 + 40) service];
  id v4 = [v3 uuid];
  uint64_t v5 = [v2 getOrCreateServiceUpdateTransactionForKey:v4 fromDictionary:*(void *)(a1 + 48)];

  return v5;
}

uint64_t __99__HMDHAPAccessory__handleMultipleCharacteristicsUpdated_message_completionQueue_completionHandler___block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

- (void)handleMultipleCharacteristicsUpdated:(id)a3 message:(id)a4 completionQueue:(id)a5 completionHandler:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = a6;
  uint64_t v14 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __98__HMDHAPAccessory_handleMultipleCharacteristicsUpdated_message_completionQueue_completionHandler___block_invoke;
  block[3] = &unk_1E6A18488;
  void block[4] = self;
  id v20 = v10;
  id v21 = v11;
  id v22 = v12;
  id v23 = v13;
  id v15 = v13;
  id v16 = v12;
  id v17 = v11;
  id v18 = v10;
  dispatch_async(v14, block);
}

uint64_t __98__HMDHAPAccessory_handleMultipleCharacteristicsUpdated_message_completionQueue_completionHandler___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _handleMultipleCharacteristicsUpdated:*(void *)(a1 + 40) message:*(void *)(a1 + 48) completionQueue:*(void *)(a1 + 56) completionHandler:*(void *)(a1 + 64)];
}

- (void)_updateReachabilityMetric:(BOOL)a3 withDuration:(id)a4
{
  BOOL v4 = a3;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v6 = a4;
  [(HMDHAPAccessory *)self transportInformationInstances];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v7 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v8 = [v7 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t v10 = *(void *)v14;
    while (2)
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (*(void *)v14 != v10) {
          objc_enumerationMutation(v7);
        }
        if (objc_msgSend(*(id *)(*((void *)&v13 + 1) + 8 * i), "linkType", (void)v13) == 1)
        {
          id v12 = [NSNumber numberWithInt:1];
          [(HMDHAPAccessory *)self _logServerReachabilityNotification:v4 withDuration:v6 withLinkType:v12];

          goto LABEL_11;
        }
      }
      uint64_t v9 = [v7 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v9) {
        continue;
      }
      break;
    }
  }
LABEL_11:
}

- (void)setWiFiTransportCapabilities:(id)a3
{
  id v6 = a3;
  os_unfair_recursive_lock_lock_with_options();
  BOOL v4 = (NSNumber *)[v6 copy];
  wiFiTransportCapabilities = self->_wiFiTransportCapabilities;
  self->_wiFiTransportCapabilities = v4;

  os_unfair_recursive_lock_unlock();
}

- (void)setWiFiManagementController:(id)a3
{
  BOOL v4 = (HMDWiFiManagementController *)a3;
  os_unfair_recursive_lock_lock_with_options();
  wiFiManagementController = self->_wiFiManagementController;
  self->_wiFiManagementController = v4;

  os_unfair_recursive_lock_unlock();
}

- (void)setDoorbellChimeController:(id)a3
{
  BOOL v4 = (HMDDoorbellChimeController *)a3;
  os_unfair_recursive_lock_lock_with_options();
  doorbellChimeController = self->_doorbellChimeController;
  self->_doorbellChimeController = v4;

  os_unfair_recursive_lock_unlock();
}

- (HMDDoorbellChimeController)doorbellChimeController
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_doorbellChimeController;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (void)removeAdvertisement:(id)a3
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543874;
    id v11 = v8;
    __int16 v12 = 2112;
    id v13 = v4;
    __int16 v14 = 2112;
    long long v15 = v6;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Removing advertisement: %@ from accessory: %@", buf, 0x20u);
  }
  v9.receiver = v6;
  v9.super_class = (Class)HMDHAPAccessory;
  [(HMDAccessory *)&v9 removeAdvertisement:v4];
  if (v4) {
    [(HMDHAPAccessory *)v6 associateWithAccessoryAdvertisement:0];
  }
}

- (void)addAdvertisement:(id)a3
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543874;
    id v11 = v8;
    __int16 v12 = 2112;
    id v13 = v4;
    __int16 v14 = 2112;
    long long v15 = v6;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Adding advertisement: %@ to accessory: %@", buf, 0x20u);
  }
  v9.receiver = v6;
  v9.super_class = (Class)HMDHAPAccessory;
  [(HMDAccessory *)&v9 addAdvertisement:v4];
  if (v4) {
    [(HMDHAPAccessory *)v6 associateWithAccessoryAdvertisement:v4];
  }
}

- (HMDAccessoryAdvertisement)accessoryAdvertisement
{
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = self->_accessoryAdvertisement;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (void)associateWithAccessoryAdvertisement:(id)a3
{
  id v4 = (HMDAccessoryAdvertisement *)a3;
  os_unfair_recursive_lock_lock_with_options();
  accessoryAdvertisement = self->_accessoryAdvertisement;
  self->_accessoryAdvertisement = v4;

  os_unfair_recursive_lock_unlock();
}

- (void)_handleConfigureTargets:(id)a3
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [(HMDHAPAccessory *)self targetControllerManager];

  if (v5)
  {
    id v6 = [(HMDHAPAccessory *)self targetControllerManager];
    id v7 = [v4 messagePayload];
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __43__HMDHAPAccessory__handleConfigureTargets___block_invoke;
    v12[3] = &unk_1E6A18C18;
    v12[4] = self;
    [v6 handleConfigureTargets:v7 responseHandler:v12];
  }
  else
  {
    uint64_t v8 = (void *)MEMORY[0x1D9452090]();
    objc_super v9 = self;
    uint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      id v11 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v14 = v11;
      _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, "%{public}@No target controller manager to handle configuring targets", buf, 0xCu);
    }
    id v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v4 respondWithError:v6];
  }
}

void __43__HMDHAPAccessory__handleConfigureTargets___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  id v7 = (void *)MEMORY[0x1D9452090]();
  id v8 = *(id *)(a1 + 32);
  objc_super v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    uint64_t v10 = HMFGetLogIdentifier();
    int v11 = 138543618;
    __int16 v12 = v10;
    __int16 v13 = 2112;
    id v14 = v6;
    _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Response from handleConfigureTargets %@", (uint8_t *)&v11, 0x16u);
  }
}

- (void)_handleKeyRefreshTimerFired
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  BOOL v3 = (void *)MEMORY[0x1D9452090](self, a2);
  id v4 = self;
  id v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    id v6 = HMFGetLogIdentifier();
    id v7 = [(HMDHAPAccessory *)v4 keyUpdatedStateNumber];
    id v8 = [(HMDHAPAccessory *)v4 keyUpdatedTime];
    int v19 = 138544130;
    id v20 = v6;
    __int16 v21 = 2112;
    id v22 = v7;
    __int16 v23 = 2112;
    id v24 = v8;
    __int16 v25 = 2048;
    double v26 = (double)(unint64_t)broadcastKeyRefreshTimeInSeconds;
    _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_DEBUG, "%{public}@Key Refresh timer fired, last updated state number: %@ last updated time: %@, update Interval: %f", (uint8_t *)&v19, 0x2Au);
  }
  objc_super v9 = [(HMDHAPAccessory *)v4 keyUpdatedTime];
  [v9 timeIntervalSinceNow];
  double v11 = fabs(v10);
  double v12 = (double)(unint64_t)broadcastKeyRefreshTimeInSeconds * 0.5;

  if (v11 >= v12)
  {
    id v14 = (void *)MEMORY[0x1D9452090]();
    uint64_t v15 = v4;
    uint64_t v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      id v17 = HMFGetLogIdentifier();
      int v19 = 138543362;
      id v20 = v17;
      _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_DEBUG, "%{public}@Retrieving for key refresh", (uint8_t *)&v19, 0xCu);
    }
    [(HMDHAPAccessory *)v15 setKeyGenerationType:1];
    __int16 v13 = [(HMDAccessory *)v15 home];
    uint64_t v18 = [(HMDAccessory *)v15 workQueue];
    [v13 retrieveHAPAccessoryForHMDAccessory:v15 linkType:2 forceRetrieve:0 queue:v18 completion:&__block_literal_global_685];
  }
  else
  {
    __int16 v13 = [(HMDHAPAccessory *)v4 accessoryKeyRefreshTimer];
    [v13 resume];
  }
}

- (void)_removeBackedoffAccessoryForStateNumber:(id)a3
{
  id v4 = [(HMDHAPAccessory *)self accessoryDiscoveryBackoffTimer];

  if (v4)
  {
    id v5 = [(HMDHAPAccessory *)self accessoryDiscoveryBackoffTimer];
    [v5 suspend];
  }
  [(HMDHAPAccessory *)self setAccessoryDiscoveryBackoffTimer:0];
  [(HMDHAPAccessory *)self setBackedOffStateNumber:0];
}

- (void)backOffAccessoryForStateNumber:(id)a3 backoffPeriod:(double)a4
{
  id v6 = a3;
  id v7 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __64__HMDHAPAccessory_backOffAccessoryForStateNumber_backoffPeriod___block_invoke;
  block[3] = &unk_1E6A16D78;
  void block[4] = self;
  id v10 = v6;
  double v11 = a4;
  id v8 = v6;
  dispatch_async(v7, block);
}

uint64_t __64__HMDHAPAccessory_backOffAccessoryForStateNumber_backoffPeriod___block_invoke(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v2 = (void *)MEMORY[0x1D9452090]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    id v5 = HMFGetLogIdentifier();
    id v6 = *(void **)(a1 + 40);
    int v18 = 138543618;
    int v19 = v5;
    __int16 v20 = 2112;
    __int16 v21 = v6;
    _os_log_impl(&dword_1D49D5000, v4, OS_LOG_TYPE_DEBUG, "%{public}@Adding accessory's state: %@ to discovery back off", (uint8_t *)&v18, 0x16u);
  }
  id v7 = [*(id *)(a1 + 32) accessoryDiscoveryBackoffTimer];

  if (!v7)
  {
    id v8 = (void *)[objc_alloc(MEMORY[0x1E4F65580]) initWithTimeInterval:8 options:*(double *)(a1 + 48)];
    [*(id *)(a1 + 32) setAccessoryDiscoveryBackoffTimer:v8];

    objc_super v9 = [*(id *)(a1 + 32) accessoryDiscoveryBackoffTimer];
    [v9 setDelegate:*(void *)(a1 + 32)];

    id v10 = [*(id *)(a1 + 32) accessoryDiscoveryBackoffTimer];
    [v10 resume];
  }
  double v11 = (void *)MEMORY[0x1D9452090]();
  id v12 = *(id *)(a1 + 32);
  __int16 v13 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    id v14 = HMFGetLogIdentifier();
    uint64_t v15 = [*(id *)(a1 + 32) backedOffStateNumber];
    uint64_t v16 = *(void *)(a1 + 40);
    int v18 = 138543874;
    int v19 = v14;
    __int16 v20 = 2112;
    __int16 v21 = v15;
    __int16 v22 = 2112;
    uint64_t v23 = v16;
    _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_DEBUG, "%{public}@Updating backed off state number from %@ to %@", (uint8_t *)&v18, 0x20u);
  }
  return [*(id *)(a1 + 32) setBackedOffStateNumber:*(void *)(a1 + 40)];
}

- (void)_handleDiscoveryBackoffTimerFired
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v3 = (void *)MEMORY[0x1D9452090](self, a2);
  id v4 = self;
  id v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    id v7 = [(HMDHAPAccessory *)v4 backedOffStateNumber];
    *(_DWORD *)id v12 = 138543618;
    *(void *)&v12[4] = v6;
    __int16 v13 = 2112;
    id v14 = v7;
    _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Discovery back off timer fired for state number %@ retrieving", v12, 0x16u);
  }
  if ([(HMDAccessory *)v4 resetOnBackoffExpiry])
  {
    [(HMDAccessory *)v4 setLastPairingFailureTime:0.0];
    [(HMDAccessory *)v4 setConsecutivePairingFailures:0];
    [(HMDAccessory *)v4 setResetOnBackoffExpiry:0];
  }
  *(void *)id v12 = 0;
  id v8 = [(HMDHAPAccessory *)v4 preferredHAPAccessoryForOperation:10 linkType:v12];
  objc_super v9 = [(HMDAccessory *)v4 home];
  uint64_t v10 = *(void *)v12;
  double v11 = [(HMDAccessory *)v4 workQueue];
  [v9 retrieveHAPAccessoryForHMDAccessory:v4 linkType:v10 forceRetrieve:1 queue:v11 completion:0];

  [(HMDHAPAccessory *)v4 setAccessoryDiscoveryBackoffTimer:0];
  [(HMDHAPAccessory *)v4 setBackedOffStateNumber:0];
}

- (void)handleIdentifyAccessoryMessage:(id)a3
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if ([(HMDHAPAccessory *)self isPaired])
  {
    id v5 = (void *)MEMORY[0x1D9452090]();
    id v6 = self;
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      id v8 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v32 = v8;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_DEFAULT, "%{public}@Identify by writing to characteristic", buf, 0xCu);
    }
    id v9 = [(HMDHAPAccessory *)v6 findCharacteristicType:*MEMORY[0x1E4F5B878] forServiceType:*MEMORY[0x1E4F5BA48]];
    objc_initWeak((id *)buf, v6);
    uint64_t v10 = [(HMDAccessory *)v6 workQueue];
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 3221225472;
    v27[2] = __50__HMDHAPAccessory_handleIdentifyAccessoryMessage___block_invoke;
    v27[3] = &unk_1E6A17758;
    objc_copyWeak(&v29, (id *)buf);
    id v28 = v4;
    [(HMDHAPAccessory *)v6 writeValue:MEMORY[0x1E4F1CC38] toCharacteristic:v9 queue:v10 completion:v27];

    objc_destroyWeak(&v29);
    objc_destroyWeak((id *)buf);
  }
  else
  {
    [(HMDHAPAccessory *)self getPrimaryHAPAccessories];
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    id v9 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v11 = [v9 countByEnumeratingWithState:&v23 objects:v30 count:16];
    if (v11)
    {
      uint64_t v12 = *(void *)v24;
      while (2)
      {
        for (uint64_t i = 0; i != v11; ++i)
        {
          if (*(void *)v24 != v12) {
            objc_enumerationMutation(v9);
          }
          id v14 = *(void **)(*((void *)&v23 + 1) + 8 * i);
          uint64_t v15 = [v14 server];
          if (v15 && [v14 isReachable])
          {
            id v17 = (void *)MEMORY[0x1D9452090]();
            int v18 = self;
            int v19 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v20 = HMFGetLogIdentifier();
              *(_DWORD *)buf = 138543362;
              uint64_t v32 = v20;
              _os_log_impl(&dword_1D49D5000, v19, OS_LOG_TYPE_DEFAULT, "%{public}@Identify by /identify URL or unpaired BTLE characteristic write", buf, 0xCu);
            }
            v21[0] = MEMORY[0x1E4F143A8];
            v21[1] = 3221225472;
            v21[2] = __50__HMDHAPAccessory_handleIdentifyAccessoryMessage___block_invoke_680;
            v21[3] = &unk_1E6A196E0;
            void v21[4] = v18;
            id v22 = v4;
            [v15 identifyWithCompletion:v21];

            uint64_t v16 = v9;
            goto LABEL_18;
          }
        }
        uint64_t v11 = [v9 countByEnumeratingWithState:&v23 objects:v30 count:16];
        if (v11) {
          continue;
        }
        break;
      }
    }

    uint64_t v16 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
    [v4 respondWithError:v16];
LABEL_18:
  }
}

void __50__HMDHAPAccessory_handleIdentifyAccessoryMessage___block_invoke(uint64_t a1, void *a2)
{
  id v6 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v4 = *(void **)(a1 + 32);
  if (WeakRetained)
  {
    [v4 respondWithPayload:0 error:v6];
  }
  else
  {
    id v5 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
    [v4 respondWithError:v5];
  }
}

void __50__HMDHAPAccessory_handleIdentifyAccessoryMessage___block_invoke_680(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = HMFGetLogIdentifier();
    int v14 = 138543618;
    uint64_t v15 = v7;
    __int16 v16 = 2112;
    id v17 = v3;
    _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_DEFAULT, "%{public}@Identify by /identify URL completed with error: %@", (uint8_t *)&v14, 0x16u);
  }
  id v8 = v3;
  id v9 = v8;
  if (v8)
  {
    uint64_t v10 = v8;
    if (([v8 isHMError] & 1) == 0)
    {
      if ([v9 isHAPError])
      {
        unint64_t v11 = [v9 code];
        if (v11 > 0x20) {
          uint64_t v12 = 52;
        }
        else {
          uint64_t v12 = qword_1D54D4320[v11];
        }
      }
      else
      {
        uint64_t v12 = 54;
      }
      uint64_t v10 = [MEMORY[0x1E4F28C58] hmErrorWithCode:v12 description:@"Identify failed." reason:0 suggestion:0 underlyingError:v9];
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  __int16 v13 = [*(id *)(a1 + 40) responseHandler];
  ((void (**)(void, void *, void))v13)[2](v13, v10, 0);
}

- (void)_handleUpdateCharacteristicAuthorizationDataMessage:(id)a3
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if ([v4 isRemote] && (objc_msgSend(v4, "isSecureRemote") & 1) == 0)
  {
    uint64_t v12 = (void *)MEMORY[0x1D9452090]();
    __int16 v13 = self;
    int v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      uint64_t v32 = v15;
      __int16 v33 = 2112;
      id v34 = v4;
      _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_DEFAULT, "%{public}@Message not supported: %@", buf, 0x16u);
    }
    id v5 = [MEMORY[0x1E4F28C58] hmErrorWithCode:17];
    [v4 respondWithError:v5];
  }
  else
  {
    id v5 = [v4 dataForKey:@"kAuthorizationDataKey"];
    if (v5)
    {
      id v6 = [(HMDHAPAccessory *)self characteristicWithAuthorizationDataMessage:v4];
      if (v6)
      {
        id v29 = @"kCharacteristicAuthDataPresentKey";
        id v7 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend(v5, "length") != 0);
        uint64_t v30 = v7;
        id v8 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v30 forKeys:&v29 count:1];

        id v9 = [v6 authorizationData];
        int v10 = [v9 isEqual:v5];

        if (v10)
        {
          [v4 respondWithPayload:v8];
        }
        else
        {
          [v6 setAuthorizationData:v5];
          long long v24 = [v6 service];
          id v17 = [(HMDAccessory *)self home];
          if ([v17 isOwnerUser])
          {
            long long v23 = [v24 modelObjectWithChangeType:2];
            uint64_t v18 = [v17 backingStore];
            int v19 = [v4 name];
            __int16 v20 = +[HMDBackingStoreTransactionOptions defaultXPCOptions];
            __int16 v21 = [v18 transaction:v19 options:v20];

            [v21 add:v23];
            objc_initWeak((id *)buf, self);
            v25[0] = MEMORY[0x1E4F143A8];
            v25[1] = 3221225472;
            v25[2] = __71__HMDHAPAccessory__handleUpdateCharacteristicAuthorizationDataMessage___block_invoke;
            v25[3] = &unk_1E6A15888;
            objc_copyWeak(&v28, (id *)buf);
            id v26 = v4;
            id v22 = v23;
            id v27 = v22;
            [v21 save:v25];

            objc_destroyWeak(&v28);
            objc_destroyWeak((id *)buf);
          }
          else
          {
            [v17 setWatchSkipVersionCheck:1];
            id v22 = [v4 name];
            __int16 v21 = +[HMDBackingStoreTransactionOptions defaultXPCOptions];
            [v17 saveSharedHomeToAccountWithReason:v22 postSyncNotification:0 options:v21];
          }

          [v4 respondWithPayload:v8];
        }
      }
      else
      {
        __int16 v16 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
        [v4 respondWithError:v16];
      }
    }
    else
    {
      unint64_t v11 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
      [v4 respondWithError:v11];

      id v5 = 0;
    }
  }
}

void __71__HMDHAPAccessory__handleUpdateCharacteristicAuthorizationDataMessage___block_invoke(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v2 = [WeakRetained home];
  id v3 = [*(id *)(a1 + 32) name];
  [v2 saveWithReason:v3 postSyncNotification:0 objectChange:*(void *)(a1 + 40) != 0];
}

- (id)characteristicWithAuthorizationDataMessage:(id)a3
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [v4 numberForKey:@"kServiceInstanceID"];
  id v6 = HAPInstanceIDFromValue();

  if (v6)
  {
    id v7 = [(HMDHAPAccessory *)self findService:v6];
    if (v7)
    {
      id v8 = [v4 numberForKey:@"kCharacteristicInstanceID"];
      id v9 = HAPInstanceIDFromValue();

      if (v9)
      {
        int v10 = [v7 findCharacteristic:v9];
        if (v10)
        {
          unint64_t v11 = [(HMDHAPAccessory *)self hapMetadata];
          if (([v10 properties] & 0x10) != 0
            || ([v10 type],
                uint64_t v12 = objc_claimAutoreleasedReturnValue(),
                [v7 type],
                __int16 v13 = objc_claimAutoreleasedReturnValue(),
                char v14 = [v11 supportsAuthorizationData:v12 forService:v13],
                v13,
                v12,
                (v14 & 1) != 0))
          {
            id v15 = v10;
          }
          else
          {
            id v38 = (void *)MEMORY[0x1D9452090]();
            uint64_t v39 = self;
            long long v40 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            {
              uint64_t v41 = HMFGetLogIdentifier();
              [v4 shortDescription];
              uint64_t v42 = v44 = v38;
              *(_DWORD *)buf = 138543874;
              long long v46 = v41;
              __int16 v47 = 2112;
              long long v48 = v42;
              __int16 v49 = 2112;
              long long v50 = v10;
              _os_log_impl(&dword_1D49D5000, v40, OS_LOG_TYPE_ERROR, "%{public}@Not handling update authorization data message: %@ because characteristic: %@ doesn't support authorization data", buf, 0x20u);

              id v38 = v44;
            }

            id v15 = 0;
          }
        }
        else
        {
          __int16 v33 = (void *)MEMORY[0x1D9452090]();
          id v34 = self;
          uint64_t v35 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            uint64_t v36 = HMFGetLogIdentifier();
            uint64_t v37 = [v4 shortDescription];
            *(_DWORD *)buf = 138544130;
            long long v46 = v36;
            __int16 v47 = 2112;
            long long v48 = v37;
            __int16 v49 = 2112;
            long long v50 = v9;
            __int16 v51 = 2112;
            id v52 = v7;
            _os_log_impl(&dword_1D49D5000, v35, OS_LOG_TYPE_ERROR, "%{public}@Not handling update authorization data message: %@, characteristic with instance ID: %@ does not exist for service: %@", buf, 0x2Au);
          }
          id v15 = 0;
        }
      }
      else
      {
        id v27 = (void *)MEMORY[0x1D9452090]();
        id v28 = self;
        id v29 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          uint64_t v30 = HMFGetLogIdentifier();
          long long v31 = [v4 shortDescription];
          uint64_t v32 = [v4 messagePayload];
          *(_DWORD *)buf = 138544130;
          long long v46 = v30;
          __int16 v47 = 2112;
          long long v48 = v31;
          __int16 v49 = 2112;
          long long v50 = 0;
          __int16 v51 = 2112;
          id v52 = v32;
          _os_log_impl(&dword_1D49D5000, v29, OS_LOG_TYPE_ERROR, "%{public}@Not handling update authorization data message: %@, missing characteristic ID key: %@ message payload: %@", buf, 0x2Au);
        }
        id v15 = 0;
      }
    }
    else
    {
      id v22 = (void *)MEMORY[0x1D9452090]();
      long long v23 = self;
      long long v24 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        long long v25 = HMFGetLogIdentifier();
        id v26 = [v4 shortDescription];
        *(_DWORD *)buf = 138543874;
        long long v46 = v25;
        __int16 v47 = 2112;
        long long v48 = v26;
        __int16 v49 = 2112;
        long long v50 = v6;
        _os_log_impl(&dword_1D49D5000, v24, OS_LOG_TYPE_ERROR, "%{public}@Not handling update authorization data message: %@, service with instance ID does not exist: %@", buf, 0x20u);
      }
      id v15 = 0;
    }
  }
  else
  {
    __int16 v16 = (void *)MEMORY[0x1D9452090]();
    id v17 = self;
    uint64_t v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      int v19 = HMFGetLogIdentifier();
      __int16 v20 = [v4 shortDescription];
      __int16 v21 = [v4 messagePayload];
      *(_DWORD *)buf = 138544130;
      long long v46 = v19;
      __int16 v47 = 2112;
      long long v48 = v20;
      __int16 v49 = 2112;
      long long v50 = 0;
      __int16 v51 = 2112;
      id v52 = v21;
      _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_ERROR, "%{public}@Not handling update authorization data message: %@, missing service ID key: %@ message payload: %@", buf, 0x2Au);
    }
    id v15 = 0;
  }

  return v15;
}

- (void)_handleUpdateAssociatedServiceType:(id)a3
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v39 = [v4 stringForKey:@"kServiceType"];
  id v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    uint64_t v44 = v8;
    __int16 v45 = 2112;
    long long v46 = v39;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Handling update associated service type: %@", buf, 0x16u);
  }
  id v9 = [v4 numberForKey:@"kServiceInstanceID"];
  int v10 = [(HMDHAPAccessory *)v6 services];
  unint64_t v11 = objc_msgSend(v10, "hmf_firstObjectWithInstanceID:", v9);

  if (v11)
  {
    uint64_t v12 = [HMDServiceTransaction alloc];
    __int16 v13 = [v11 uuid];
    char v14 = [(HMDAccessory *)v6 uuid];
    id v15 = [(HMDBackingStoreModelObject *)v12 initWithObjectChangeType:2 uuid:v13 parentUUID:v14];

    __int16 v16 = [(HMDHAPAccessory *)v6 hapMetadata];
    id v17 = [v11 serviceType];
    uint64_t v18 = [v16 validateAssociatedServiceType:v39 forService:v17];

    if (v18)
    {
      int v19 = (void *)MEMORY[0x1D9452090]();
      __int16 v20 = v6;
      __int16 v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        HMFGetLogIdentifier();
        id v22 = v38 = v18;
        [v11 serviceType];
        v24 = long long v23 = v19;
        *(_DWORD *)buf = 138543874;
        uint64_t v44 = v22;
        __int16 v45 = 2112;
        long long v46 = v39;
        __int16 v47 = 2112;
        long long v48 = v24;
        _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_INFO, "%{public}@Failed to validate associated service type: %@, for service: %@", buf, 0x20u);

        int v19 = v23;
        uint64_t v18 = v38;
      }

      [v4 respondWithError:v18];
    }
    else
    {
      [(HMDServiceTransaction *)v15 setAssociatedServiceType:v39];
      uint64_t v37 = [(HMDAccessory *)v6 home];
      id v29 = [v37 backingStore];
      uint64_t v30 = [v4 name];
      +[HMDBackingStoreTransactionOptions defaultXPCOptions];
      long long v31 = v15;
      id v32 = v4;
      __int16 v33 = v16;
      uint64_t v35 = v34 = v9;
      uint64_t v36 = [v29 transaction:v30 options:v35];

      id v9 = v34;
      __int16 v16 = v33;
      id v4 = v32;
      id v15 = v31;

      uint64_t v18 = 0;
      [v36 add:v31];
      v40[0] = MEMORY[0x1E4F143A8];
      v40[1] = 3221225472;
      v40[2] = __54__HMDHAPAccessory__handleUpdateAssociatedServiceType___block_invoke;
      v40[3] = &unk_1E6A18BA0;
      v40[4] = v6;
      id v41 = v4;
      id v42 = v11;
      [v36 run:v40];
    }
  }
  else
  {
    long long v25 = (void *)MEMORY[0x1D9452090]();
    id v26 = v6;
    id v27 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      id v28 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      uint64_t v44 = v28;
      __int16 v45 = 2112;
      long long v46 = v9;
      _os_log_impl(&dword_1D49D5000, v27, OS_LOG_TYPE_ERROR, "%{public}@No service matching instanceID %@", buf, 0x16u);
    }
    id v15 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v4 respondWithError:v15];
  }
}

void __54__HMDHAPAccessory__handleUpdateAssociatedServiceType___block_invoke(id *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = a1[4];
  id v6 = HMFGetOSLogHandle();
  id v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v8 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      __int16 v21 = v8;
      __int16 v22 = 2112;
      id v23 = v3;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to commit update associated service type transaction with error: %@", buf, 0x16u);
    }
    [a1[5] respondWithError:v3];
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      int v10 = [a1[6] associatedServiceType];
      unint64_t v11 = [a1[6] instanceID];
      *(_DWORD *)buf = 138543874;
      __int16 v21 = v9;
      __int16 v22 = 2112;
      id v23 = v10;
      __int16 v24 = 2112;
      long long v25 = v11;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Responding to message that we successfully updated service type: %@ on service: %@", buf, 0x20u);
    }
    v18[0] = @"kServiceInstanceID";
    id v12 = a1[5];
    __int16 v13 = objc_msgSend(a1[6], "instanceID", @"kServiceInstanceID");
    v18[1] = @"kServiceType";
    v19[0] = v13;
    uint64_t v14 = [a1[6] associatedServiceType];
    id v15 = (void *)v14;
    __int16 v16 = &stru_1F2C9F1A8;
    if (v14) {
      __int16 v16 = (__CFString *)v14;
    }
    v19[1] = v16;
    id v17 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v19 forKeys:v18 count:2];
    [v12 respondWithPayload:v17];
  }
}

- (void)_handleRenameService:(id)a3
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDAccessory *)self home];
  id v6 = [v4 numberForKey:@"kServiceInstanceID"];
  id v7 = [(HMDHAPAccessory *)self services];
  id v8 = objc_msgSend(v7, "hmf_firstObjectWithInstanceID:", v6);

  if (v8 && v5)
  {
    id v9 = [v4 stringForKey:@"kServiceName"];
    unint64_t v10 = HMMaxLengthForNaming();
    if ([v9 length] <= v10)
    {
      [(HMDHAPAccessory *)self _renameService:v8 name:v9 message:v4 completionBlock:0];
    }
    else
    {
      unint64_t v11 = (void *)MEMORY[0x1D9452090]();
      id v12 = self;
      __int16 v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = HMFGetLogIdentifier();
        int v20 = 138543362;
        __int16 v21 = v14;
        _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_ERROR, "%{public}@New name is longer than the pre-defined max length", (uint8_t *)&v20, 0xCu);
      }
      id v15 = [MEMORY[0x1E4F28C58] hmErrorWithCode:46];
      [v4 respondWithError:v15];
    }
  }
  else
  {
    __int16 v16 = (void *)MEMORY[0x1D9452090]();
    id v17 = self;
    uint64_t v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      int v19 = HMFGetLogIdentifier();
      int v20 = 138543618;
      __int16 v21 = v19;
      __int16 v22 = 2112;
      id v23 = v6;
      _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_ERROR, "%{public}@No service matching instanceID %@ or home does not exist", (uint8_t *)&v20, 0x16u);
    }
    id v9 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v4 respondWithError:v9];
  }
}

- (void)_renameService:(id)a3 name:(id)a4 message:(id)a5 completionBlock:(id)a6
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  __int16 v13 = (void (**)(id, void *))a6;
  uint64_t v14 = [(HMDAccessory *)self home];
  id v15 = (void *)v14;
  if (!v10 || !v14)
  {
    id v27 = (void *)MEMORY[0x1D9452090]();
    id v28 = self;
    id v29 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      long long v46 = v30;
      _os_log_impl(&dword_1D49D5000, v29, OS_LOG_TYPE_ERROR, "%{public}@No service or home does not exist", buf, 0xCu);
    }
    long long v31 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v32 = 2;
    goto LABEL_15;
  }
  if (!v11)
  {
    long long v31 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v32 = 3;
LABEL_15:
    uint64_t v16 = [v31 hmErrorWithCode:v32];
    goto LABEL_16;
  }
  if (![v11 length]
    || ([v15 validateName:v11], (uint64_t v16 = objc_claimAutoreleasedReturnValue()) == 0))
  {
    id v17 = [HMDServiceTransaction alloc];
    uint64_t v18 = [v10 uuid];
    int v19 = [(HMDAccessory *)self uuid];
    int v20 = [(HMDBackingStoreModelObject *)v17 initWithObjectChangeType:2 uuid:v18 parentUUID:v19];

    __int16 v21 = [v10 findCharacteristicWithType:*MEMORY[0x1E4F2CE80]];
    uint64_t v44 = v21;
    if ([v21 supportsWrite])
    {
      uint64_t v43 = v20;
      unint64_t v22 = [v11 length];
      id v23 = [v21 metadata];
      uint64_t v24 = [v23 maxLength];
      unint64_t v25 = [v24 unsignedIntegerValue];

      if (v22 > v25)
      {
        uint64_t v26 = [MEMORY[0x1E4F28C58] hmErrorWithCode:46];
        [v12 respondWithError:v26];
        if (v13) {
          v13[2](v13, v26);
        }

        int v20 = v43;
        goto LABEL_27;
      }
      uint64_t v35 = (void *)MEMORY[0x1D9452090]();
      uint64_t v36 = self;
      uint64_t v37 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
      {
        id v38 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        long long v46 = v38;
        __int16 v47 = 2112;
        id v48 = v11;
        _os_log_impl(&dword_1D49D5000, v37, OS_LOG_TYPE_INFO, "%{public}@Setting expected configured name to %@", buf, 0x16u);
      }
      int v20 = v43;
      [(HMDServiceTransaction *)v43 setExpectedConfiguredName:v11];
      if (!v12) {
        goto LABEL_25;
      }
    }
    else
    {
      [(HMDServiceTransaction *)v20 setName:v11];
      if (!v12)
      {
LABEL_25:
        id v34 = (id)*MEMORY[0x1E4F2EDB8];
        goto LABEL_26;
      }
    }
    id v34 = [v12 name];
LABEL_26:
    uint64_t v39 = v34;
    long long v40 = [v15 backingStore];
    id v41 = +[HMDBackingStoreTransactionOptions defaultXPCOptions];
    id v42 = [v40 transaction:v39 options:v41];

    [v42 add:v20 withMessage:v12];
    [v42 run:v13];

LABEL_27:
    goto LABEL_19;
  }
LABEL_16:
  __int16 v33 = (void *)v16;
  [v12 respondWithError:v16];
  if (v13) {
    v13[2](v13, v33);
  }

LABEL_19:
}

- (void)indicateNotificationFromServer:(id)a3 notifyType:(unint64_t)a4 withDictionary:(id)a5
{
  id v8 = a3;
  id v9 = a5;
  id v10 = [(HMDAccessory *)self workQueue];
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  v13[2] = __76__HMDHAPAccessory_indicateNotificationFromServer_notifyType_withDictionary___block_invoke;
  v13[3] = &unk_1E6A17018;
  void v13[4] = self;
  id v14 = v8;
  id v15 = v9;
  unint64_t v16 = a4;
  id v11 = v9;
  id v12 = v8;
  dispatch_async(v10, v13);
}

void __76__HMDHAPAccessory_indicateNotificationFromServer_notifyType_withDictionary___block_invoke(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v2 = [*(id *)(a1 + 32) identifier];
  id v3 = [*(id *)(a1 + 40) identifier];
  int v4 = [v2 isEqualToString:v3];

  if (v4)
  {
    id v5 = *(void **)(a1 + 48);
    if (v5)
    {
      id v6 = objc_msgSend(v5, "hmf_numberForKey:", *MEMORY[0x1E4F5B790]);
    }
    else
    {
      id v6 = 0;
    }
    id v12 = (void *)MEMORY[0x1D9452090]();
    id v13 = *(id *)(a1 + 32);
    id v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      id v15 = HMFGetLogIdentifier();
      unint64_t v16 = [MEMORY[0x1E4F5BDE0] typeToString:*(void *)(a1 + 56)];
      int v23 = 138543874;
      uint64_t v24 = v15;
      __int16 v25 = 2112;
      uint64_t v26 = v16;
      __int16 v27 = 2112;
      id v28 = v6;
      _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_INFO, "%{public}@Accessory - Notification %@ with instance %@", (uint8_t *)&v23, 0x20u);
    }
    uint64_t v17 = *(void *)(a1 + 56);
    switch(v17)
    {
      case 4:
        [*(id *)(a1 + 32) _submitReachabilityDelayedMetric:*(void *)(a1 + 48)];
        break;
      case 3:
        [*(id *)(a1 + 32) _submitStateNumberChangeMetric];
        break;
      case 2:
        [*(id *)(a1 + 32) _doReachabilityUpdateForServer:*(void *)(a1 + 48)];
        break;
      default:
        uint64_t v18 = (void *)MEMORY[0x1D9452090]();
        id v19 = *(id *)(a1 + 32);
        int v20 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
        {
          __int16 v21 = HMFGetLogIdentifier();
          unint64_t v22 = [MEMORY[0x1E4F5BDE0] typeToString:*(void *)(a1 + 56)];
          int v23 = 138543874;
          uint64_t v24 = v21;
          __int16 v25 = 2112;
          uint64_t v26 = v22;
          __int16 v27 = 2112;
          id v28 = v6;
          _os_log_impl(&dword_1D49D5000, v20, OS_LOG_TYPE_INFO, "%{public}@Accessory - Unhandled notification %@ with instance %@", (uint8_t *)&v23, 0x20u);
        }
        break;
    }
  }
  else
  {
    id v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = HMFGetLogIdentifier();
      id v11 = [*(id *)(a1 + 40) deviceID];
      int v23 = 138543618;
      uint64_t v24 = v10;
      __int16 v25 = 2112;
      uint64_t v26 = v11;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_ERROR, "%{public}@Accessory - Incorrect server for reachability indication, expected server: %@", (uint8_t *)&v23, 0x16u);
    }
  }
}

- (void)_submitReachabilityDelayedMetric:(id)a3
{
  uint64_t v4 = *MEMORY[0x1E4F5B780];
  id v5 = a3;
  objc_msgSend(v5, "hmf_numberForKey:", v4);
  id v8 = (id)objc_claimAutoreleasedReturnValue();
  id v6 = objc_msgSend(v5, "hmf_numberForKey:", *MEMORY[0x1E4F5B788]);

  id v7 = [[HMDHAPMetricsReachabilityTimerLateEvent alloc] initWithAccessory:self actualDuration:v8 expectedDuration:v6];
  [(HMDAccessory *)self submitLogEvent:v7];
}

- (void)_submitStateNumberChangeMetric
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  id v3 = [(HMDAccessory *)self home];
  int v4 = [v3 isCurrentDevicePrimaryResident];

  if (v4)
  {
    id v5 = (void *)MEMORY[0x1D9452090]();
    id v6 = self;
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = HMFGetLogIdentifier();
      int v10 = 138543362;
      id v11 = v8;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@submitting state change metric for accessory", (uint8_t *)&v10, 0xCu);
    }
    id v9 = [[HMDHAPMetricsStateNumberChangeEvent alloc] initWithAccessory:v6];
    [(HMDAccessory *)v6 submitLogEvent:v9];
  }
}

- (void)_doReachabilityUpdateForServer:(id)a3
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if ([(HMDAccessory *)self reachabilityPingEnabled])
  {
    int v5 = objc_msgSend(v4, "hmf_BOOLForKey:", *MEMORY[0x1E4F5B7A0]);
    id v6 = (void *)MEMORY[0x1D9452090]();
    id v7 = self;
    id v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      int v15 = 138543618;
      unint64_t v16 = v9;
      __int16 v17 = 1024;
      int v18 = v5;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@accessory server reachability via ping %d from accessory", (uint8_t *)&v15, 0x12u);
    }
    if (v5) {
      int v10 = (void *)MEMORY[0x1E4F5BA28];
    }
    else {
      int v10 = (void *)MEMORY[0x1E4F5BA20];
    }
    [MEMORY[0x1E4F5BDE0] postNotification:*v10 object:v7 userInfo:0];
  }
  else
  {
    id v11 = (void *)MEMORY[0x1D9452090]();
    uint64_t v12 = self;
    id v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      id v14 = HMFGetLogIdentifier();
      int v15 = 138543362;
      unint64_t v16 = v14;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_ERROR, "%{public}@ignoring reachability update - pings not enabled for accessory", (uint8_t *)&v15, 0xCu);
    }
  }
}

- (void)_checkRegisterForServerNotification
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v3 = [(HMDHAPAccessory *)self getHAPAccessoryMatchingInstanceId];
  id v4 = [v3 server];
  int v5 = v4;
  if (v3 && v4)
  {
    [v4 registerForNotifications:self];
  }
  else
  {
    id v6 = (void *)MEMORY[0x1D9452090]();
    id v7 = self;
    id v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      int v10 = 138543618;
      id v11 = v9;
      __int16 v12 = 2112;
      id v13 = v3;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@hapAccessory not ready to register for server notifications: %@", (uint8_t *)&v10, 0x16u);
    }
  }
}

- (id)findCharacteristicsByTypes:(id)a3 forServiceType:(id)a4
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  id v8 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v6, "count"));
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  id obj = [(HMDHAPAccessory *)self services];
  uint64_t v9 = [obj countByEnumeratingWithState:&v34 objects:v39 count:16];
  if (v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = *(void *)v35;
    uint64_t v26 = *(void *)v35;
    id v27 = v7;
    do
    {
      uint64_t v12 = 0;
      uint64_t v28 = v10;
      do
      {
        if (*(void *)v35 != v11) {
          objc_enumerationMutation(obj);
        }
        id v13 = *(void **)(*((void *)&v34 + 1) + 8 * v12);
        uint64_t v14 = objc_msgSend(v13, "serviceType", v26, v27);
        int v15 = [v14 isEqualToString:v7];

        if (v15)
        {
          long long v32 = 0u;
          long long v33 = 0u;
          long long v30 = 0u;
          long long v31 = 0u;
          unint64_t v16 = [v13 characteristics];
          uint64_t v17 = [v16 countByEnumeratingWithState:&v30 objects:v38 count:16];
          if (v17)
          {
            uint64_t v18 = v17;
            uint64_t v19 = *(void *)v31;
            do
            {
              for (uint64_t i = 0; i != v18; ++i)
              {
                if (*(void *)v31 != v19) {
                  objc_enumerationMutation(v16);
                }
                __int16 v21 = *(void **)(*((void *)&v30 + 1) + 8 * i);
                unint64_t v22 = [v21 type];
                int v23 = [v6 containsObject:v22];

                if (v23) {
                  [v8 addObject:v21];
                }
              }
              uint64_t v18 = [v16 countByEnumeratingWithState:&v30 objects:v38 count:16];
            }
            while (v18);
          }

          uint64_t v11 = v26;
          id v7 = v27;
          uint64_t v10 = v28;
        }
        ++v12;
      }
      while (v12 != v10);
      uint64_t v10 = [obj countByEnumeratingWithState:&v34 objects:v39 count:16];
    }
    while (v10);
  }

  uint64_t v24 = (void *)[v8 copy];
  return v24;
}

- (id)findCharacteristicsByType:(id)a3 forServiceType:(id)a4
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  id v8 = [MEMORY[0x1E4F1CA48] array];
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v9 = [(HMDHAPAccessory *)self services];
  uint64_t v10 = [v9 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)v20;
    do
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        if (*(void *)v20 != v12) {
          objc_enumerationMutation(v9);
        }
        uint64_t v14 = *(void **)(*((void *)&v19 + 1) + 8 * i);
        int v15 = [v14 serviceType];
        int v16 = [v15 isEqualToString:v7];

        if (v16)
        {
          uint64_t v17 = [v14 findCharacteristicWithType:v6];
          if (v17) {
            [v8 addObject:v17];
          }
        }
      }
      uint64_t v11 = [v9 countByEnumeratingWithState:&v19 objects:v23 count:16];
    }
    while (v11);
  }

  return v8;
}

- (id)findCharacteristic:(id)a3
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  int v5 = [(HMDHAPAccessory *)self services];
  uint64_t v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v14;
    while (2)
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v14 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v10 = [*(id *)(*((void *)&v13 + 1) + 8 * i) findCharacteristic:v4];
        if (v10)
        {
          uint64_t v11 = (void *)v10;
          goto LABEL_11;
        }
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }
  uint64_t v11 = 0;
LABEL_11:

  return v11;
}

uint64_t __31__HMDHAPAccessory_findService___block_invoke(uint64_t a1, void *a2)
{
  id v2 = [a2 instanceID];
  uint64_t v3 = HAPEqualInstanceIDs();

  return v3;
}

void __60__HMDHAPAccessory__evaluateLocalOperation_state_completion___block_invoke(uint64_t a1)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  char v31 = 0;
  uint64_t v30 = 5;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = [*(id *)(a1 + 40) identifier];
  id v28 = 0;
  id v29 = 0;
  [v2 retrieveStateForTrackedAccessory:v3 stateNumber:&v29 isReachable:&v31 linkQuality:&v30 lastSeen:&v28];
  id v4 = v29;
  id v5 = v28;

  if (*(void *)(a1 + 48) && v4 && *(void *)(a1 + 72) == 2 && (objc_msgSend(v4, "isEqual:") & 1) == 0)
  {
    uint64_t v6 = (void *)MEMORY[0x1D9452090]();
    id v7 = *(id *)(a1 + 40);
    uint64_t v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = HMFGetLogIdentifier();
      uint64_t v10 = *(void **)(a1 + 48);
      *(_DWORD *)buf = 138543874;
      long long v33 = v9;
      __int16 v34 = 2112;
      id v35 = v4;
      __int16 v36 = 2112;
      long long v37 = v10;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_DEBUG, "%{public}@State out of sync current/cached %@/%@ Preferring resident for reads", buf, 0x20u);
    }
  }
  if (*(unsigned char *)(a1 + 80))
  {
    char v11 = 1;
  }
  else if (*(unsigned char *)(a1 + 81))
  {
    char v11 = v31;
  }
  else
  {
    char v11 = 1;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = v11;
  uint64_t v12 = (void *)MEMORY[0x1D9452090]();
  id v13 = *(id *)(a1 + 40);
  long long v14 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    id v27 = v4;
    long long v15 = HMFGetLogIdentifier();
    long long v16 = HMFBooleanToString();
    [*(id *)(a1 + 40) isSuspended];
    uint64_t v17 = HMFBooleanToString();
    uint64_t v18 = v30;
    [v5 doubleValue];
    uint64_t v20 = v19;
    long long v21 = HMFBooleanToString();
    unint64_t v22 = *(void *)(a1 + 72);
    id v26 = v5;
    if (v22 > 0xA) {
      int v23 = @"Undefined";
    }
    else {
      int v23 = off_1E6A0B878[v22];
    }
    uint64_t v24 = v23;
    *(_DWORD *)buf = 138545154;
    long long v33 = v15;
    __int16 v34 = 2112;
    id v35 = v16;
    __int16 v36 = 2112;
    long long v37 = v17;
    __int16 v38 = 2112;
    id v39 = v27;
    __int16 v40 = 2048;
    uint64_t v41 = v18;
    id v4 = v27;
    __int16 v42 = 2048;
    uint64_t v43 = v20;
    __int16 v44 = 2112;
    __int16 v45 = v21;
    __int16 v46 = 2112;
    __int16 v47 = v24;
    _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_INFO, "%{public}@Retrieved accessory: Reachable(%@) / Suspended(%@) / S#(%@) / LQ(%ld) / Seen(%.3fs) / Local(%@) to evaluate operation: %@", buf, 0x52u);

    id v5 = v26;
  }

  uint64_t v25 = *(void *)(a1 + 56);
  if (v25) {
    (*(void (**)(uint64_t, void))(v25 + 16))(v25, *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8) + 24));
  }
}

- (void)_updateStateForTrackedAccessory:(id)a3 stateNumber:(id)a4
{
  id v10 = a3;
  id v6 = a4;
  if ([(HMDHAPAccessory *)self hasBTLELink])
  {
    id v7 = [(HMDAccessory *)self home];
    uint64_t v8 = [v7 accessoryBrowser];
    uint64_t v9 = [v8 accessoryBrowserHapProtocol];
    [v9 updateStateForIdentifier:v10 stateNumber:v6];
  }
}

- (void)updateTrackedAccessoryStateNumber:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __53__HMDHAPAccessory_updateTrackedAccessoryStateNumber___block_invoke;
  v7[3] = &unk_1E6A197C8;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __53__HMDHAPAccessory_updateTrackedAccessoryStateNumber___block_invoke(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [v2 identifier];
  [v2 _updateStateForTrackedAccessory:v3 stateNumber:*(void *)(a1 + 40)];
}

- (BOOL)_containsSecureCharacteristic
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v3 = [(HMDHAPAccessory *)self hapMetadata];
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  id v4 = [(HMDHAPAccessory *)self services];
  id v5 = (void *)[v4 copy];

  uint64_t v23 = [v5 countByEnumeratingWithState:&v29 objects:v34 count:16];
  if (v23)
  {
    uint64_t v6 = *(void *)v30;
    uint64_t v24 = v5;
    uint64_t v22 = *(void *)v30;
    do
    {
      for (uint64_t i = 0; i != v23; ++i)
      {
        if (*(void *)v30 != v6) {
          objc_enumerationMutation(v5);
        }
        id v8 = *(void **)(*((void *)&v29 + 1) + 8 * i);
        long long v25 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        uint64_t v9 = [v8 characteristics];
        id v10 = (void *)[v9 copy];

        uint64_t v11 = [v10 countByEnumeratingWithState:&v25 objects:v33 count:16];
        if (v11)
        {
          uint64_t v12 = v11;
          uint64_t v13 = *(void *)v26;
          while (2)
          {
            for (uint64_t j = 0; j != v12; ++j)
            {
              if (*(void *)v26 != v13) {
                objc_enumerationMutation(v10);
              }
              long long v15 = *(void **)(*((void *)&v25 + 1) + 8 * j);
              long long v16 = [v15 type];
              uint64_t v17 = [v15 service];
              uint64_t v18 = [v17 type];
              char v19 = [v3 requiresDeviceUnlock:v16 forService:v18];

              if (v19)
              {

                BOOL v20 = 1;
                id v5 = v24;
                goto LABEL_19;
              }
            }
            uint64_t v12 = [v10 countByEnumeratingWithState:&v25 objects:v33 count:16];
            if (v12) {
              continue;
            }
            break;
          }
        }

        id v5 = v24;
        uint64_t v6 = v22;
      }
      BOOL v20 = 0;
      uint64_t v23 = [v24 countByEnumeratingWithState:&v29 objects:v34 count:16];
    }
    while (v23);
  }
  else
  {
    BOOL v20 = 0;
  }
LABEL_19:

  return v20;
}

- (BOOL)_shouldTrackAccessoryWithPriority:(BOOL *)a3
{
  if (a3)
  {
    *a3 = 0;
    if ([(HMDHAPAccessory *)self _containsSecureCharacteristic])
    {
      *a3 = 1;
      return 1;
    }
  }
  else if ([(HMDHAPAccessory *)self _containsSecureCharacteristic])
  {
    return 1;
  }
  if ([(HMDHAPAccessory *)self isNotificationEnabled]) {
    return 1;
  }
  uint64_t v6 = [(HMDAccessory *)self home];
  id v7 = [v6 residentDeviceManager];
  char v8 = [v7 isCurrentDeviceAvailableResident];

  return v8;
}

- (void)setCameraProfileNotificationSettings:(id)a3
{
  id v6 = a3;
  os_unfair_recursive_lock_lock_with_options();
  id v4 = (HMCameraUserNotificationSettings *)[v6 copy];
  cameraProfileNotificationSettings = self->_cameraProfileNotificationSettings;
  self->_cameraProfileNotificationSettings = v4;

  os_unfair_recursive_lock_unlock();
}

- (void)_reenableNotificationsOnWatch
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (isWatch() && [(HMDHAPAccessory *)self isPaired])
  {
    id v3 = (void *)MEMORY[0x1D9452090]();
    id v4 = self;
    id v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      id v6 = HMFGetLogIdentifier();
      id v7 = [(HMDHAPAccessory *)v4 uniqueIdentifier];
      *(_DWORD *)buf = 138543618;
      long long v33 = v6;
      __int16 v34 = 2112;
      uint64_t v35 = v7;
      _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Accessory is reachable; re-enabling notifications on HAP accessories: %@",
        buf,
        0x16u);
    }
    char v8 = [MEMORY[0x1E4F1CA48] array];
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v21 = v4;
    uint64_t v9 = [(HMDHAPAccessory *)v4 services];
    uint64_t v10 = [v9 countByEnumeratingWithState:&v26 objects:v31 count:16];
    if (v10)
    {
      uint64_t v11 = v10;
      uint64_t v12 = *(void *)v27;
      do
      {
        for (uint64_t i = 0; i != v11; ++i)
        {
          if (*(void *)v27 != v12) {
            objc_enumerationMutation(v9);
          }
          long long v14 = *(void **)(*((void *)&v26 + 1) + 8 * i);
          long long v22 = 0u;
          long long v23 = 0u;
          long long v24 = 0u;
          long long v25 = 0u;
          long long v15 = [v14 characteristics];
          uint64_t v16 = [v15 countByEnumeratingWithState:&v22 objects:v30 count:16];
          if (v16)
          {
            uint64_t v17 = v16;
            uint64_t v18 = *(void *)v23;
            do
            {
              for (uint64_t j = 0; j != v17; ++j)
              {
                if (*(void *)v23 != v18) {
                  objc_enumerationMutation(v15);
                }
                BOOL v20 = *(void **)(*((void *)&v22 + 1) + 8 * j);
                if ([v20 isNotificationEnabled]) {
                  [v8 addObject:v20];
                }
              }
              uint64_t v17 = [v15 countByEnumeratingWithState:&v22 objects:v30 count:16];
            }
            while (v17);
          }
        }
        uint64_t v11 = [v9 countByEnumeratingWithState:&v26 objects:v31 count:16];
      }
      while (v11);
    }

    [(HMDHAPAccessory *)v21 _setNotificationsEnabled:1 forCharacteristics:v8 clientIdentifier:0 matchingHAPAccessory:0];
  }
}

- (void)notifyClientsOfUpdatedAccessoryControllableValue
{
  v2.receiver = self;
  v2.super_class = (Class)HMDHAPAccessory;
  [(HMDAccessory *)&v2 notifyClientsOfUpdatedAccessoryControllableValue:[(HMDAccessory *)self isReachable]];
}

- (void)reachabilityDidChangeToUnreachable:(id)a3
{
  id v4 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __54__HMDHAPAccessory_reachabilityDidChangeToUnreachable___block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v4, block);
}

void __54__HMDHAPAccessory_reachabilityDidChangeToUnreachable___block_invoke(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  objc_super v2 = [MEMORY[0x1E4F1C9C8] date];
  id v3 = [*(id *)(a1 + 32) timeBecameReachable];
  [v2 timeIntervalSinceDate:v3];
  double v5 = v4;

  id v6 = [NSNumber numberWithDouble:v5];
  id v7 = (void *)MEMORY[0x1D9452090]();
  id v8 = *(id *)(a1 + 32);
  uint64_t v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = HMFGetLogIdentifier();
    int v13 = 138543362;
    long long v14 = v10;
    _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_DEBUG, "%{public}@Accessory became unreachable", (uint8_t *)&v13, 0xCu);
  }
  uint64_t v11 = [*(id *)(a1 + 32) accessoryMetric];
  uint64_t v12 = [v11 sessionMetric];
  [v12 updateReachableState:0];

  [*(id *)(a1 + 32) _updateReachabilityMetric:0 withDuration:v6];
  [*(id *)(a1 + 32) notifyClientsOfUpdatedAccessoryControllableValue];
}

- (void)reachabilityDidChangeToReachable:(id)a3
{
  double v4 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __52__HMDHAPAccessory_reachabilityDidChangeToReachable___block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v4, block);
}

uint64_t __52__HMDHAPAccessory_reachabilityDidChangeToReachable___block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  objc_super v2 = (void *)MEMORY[0x1D9452090]();
  id v3 = *(id *)(a1 + 32);
  double v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    double v5 = HMFGetLogIdentifier();
    int v14 = 138543362;
    uint64_t v15 = v5;
    _os_log_impl(&dword_1D49D5000, v4, OS_LOG_TYPE_DEBUG, "%{public}@Accessory became reachable", (uint8_t *)&v14, 0xCu);
  }
  id v6 = [*(id *)(a1 + 32) accessoryMetric];
  id v7 = [v6 sessionMetric];
  [v7 updateReachableState:1];

  [*(id *)(a1 + 32) _checkRegisterForServerNotification];
  [*(id *)(a1 + 32) _reenableNotificationsOnWatch];
  [*(id *)(a1 + 32) _setTargetControllerSession];
  id v8 = [*(id *)(a1 + 32) timeBecameUnreachable];

  if (v8)
  {
    uint64_t v9 = [MEMORY[0x1E4F1C9C8] date];
    uint64_t v10 = NSNumber;
    uint64_t v11 = [*(id *)(a1 + 32) timeBecameUnreachable];
    [v9 timeIntervalSinceDate:v11];
    uint64_t v12 = objc_msgSend(v10, "numberWithDouble:");

    [*(id *)(a1 + 32) _updateReachabilityMetric:1 withDuration:v12];
  }
  return [*(id *)(a1 + 32) notifyClientsOfUpdatedAccessoryControllableValue];
}

- (void)handlePrimaryResidentUpdateNotification:(id)a3
{
  double v4 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __59__HMDHAPAccessory_handlePrimaryResidentUpdateNotification___block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v4, block);
}

void __59__HMDHAPAccessory_handlePrimaryResidentUpdateNotification___block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  [*(id *)(a1 + 32) _doPrimaryResidentUpdated];
  [*(id *)(a1 + 32) setDefaultPreferredMediaUserIfNeeded];
  objc_super v2 = [*(id *)(a1 + 32) home];
  int v3 = [v2 isCurrentDeviceConfirmedPrimaryResident];

  double v4 = [*(id *)(a1 + 32) accessoryMetric];
  double v5 = v4;
  if (v3)
  {

    if (!v5)
    {
      id v6 = (void *)MEMORY[0x1D9452090]();
      id v7 = *(id *)(a1 + 32);
      id v8 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v9 = HMFGetLogIdentifier();
        int v16 = 138543362;
        uint64_t v17 = v9;
        _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_DEBUG, "%{public}@Current device became primary - starting AccessoryMetric", (uint8_t *)&v16, 0xCu);
      }
      uint64_t v10 = [[HMDAccessoryMetric alloc] initWithAccessory:*(void *)(a1 + 32)];
      [*(id *)(a1 + 32) setAccessoryMetric:v10];
    }
  }
  else
  {

    if (v5)
    {
      uint64_t v11 = (void *)MEMORY[0x1D9452090]();
      id v12 = *(id *)(a1 + 32);
      int v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        int v14 = HMFGetLogIdentifier();
        int v16 = 138543362;
        uint64_t v17 = v14;
        _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_DEBUG, "%{public}@Current device stopped being primary - submitting AccessoryMetric and stopping", (uint8_t *)&v16, 0xCu);
      }
      uint64_t v15 = [*(id *)(a1 + 32) accessoryMetric];
      [v15 submitMetricAndStop];

      [*(id *)(a1 + 32) setAccessoryMetric:0];
    }
  }
}

- (void)_logServerReachabilityNotification:(id)a3
{
  char v9 = 0;
  uint64_t v4 = *MEMORY[0x1E4F5B7A0];
  id v5 = a3;
  uint64_t v6 = objc_msgSend(v5, "hmf_BOOLForKey:isPresent:", v4, &v9);
  id v7 = objc_msgSend(v5, "hmf_numberForKey:", *MEMORY[0x1E4F5B798]);
  id v8 = [v5 objectForKey:*MEMORY[0x1E4F5B7B0]];

  [(HMDHAPAccessory *)self _logServerReachabilityNotification:v6 withDuration:v8 withLinkType:v7];
}

- (void)_logServerReachabilityNotification:(BOOL)a3 withDuration:(id)a4 withLinkType:(id)a5
{
  BOOL v6 = a3;
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v8 = a4;
  id v9 = a5;
  uint64_t v10 = (void *)MEMORY[0x1D9452090]();
  uint64_t v11 = self;
  id v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    HMFGetLogIdentifier();
    int v13 = v26 = v8;
    id v14 = v9;
    if (v6) {
      uint64_t v15 = "unreachable";
    }
    else {
      uint64_t v15 = "reachable";
    }
    int v16 = [(HMDAccessory *)v11 identifier];
    HMFBooleanToString();
    v17 = BOOL v25 = v6;
    uint64_t v18 = [(HMDAccessory *)v11 home];
    [v18 isCurrentDeviceConfirmedPrimaryResident];
    char v19 = HMFBooleanToString();
    *(_DWORD *)buf = 138544642;
    long long v28 = v13;
    __int16 v29 = 2080;
    long long v30 = v15;
    id v9 = v14;
    __int16 v31 = 2112;
    long long v32 = v16;
    __int16 v33 = 2112;
    id v34 = v26;
    __int16 v35 = 2112;
    uint64_t v36 = v17;
    __int16 v37 = 2112;
    __int16 v38 = v19;
    _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_INFO, "%{public}@%s duration for %@ is %@ seconds - reachable %@, primary resident: %@", buf, 0x3Eu);

    BOOL v6 = v25;
    id v8 = v26;
  }

  BOOL v20 = [(HMDAccessory *)v11 home];
  int v21 = [v20 isCurrentDeviceConfirmedPrimaryResident];

  if (v21)
  {
    long long v22 = [HMDHAPMetricsReachabilityAddRemoveEvent alloc];
    if (v6) {
      uint64_t v23 = 2;
    }
    else {
      uint64_t v23 = 1;
    }
    long long v24 = [(HMDHAPMetricsReachabilityAddRemoveEvent *)v22 initWithAccessory:v11 hmdAddRemoveEvent:v23 forLinkType:v9];
    [(HMDAccessory *)v11 submitLogEvent:v24];
  }
}

- (double)_getDurationAndUpdateCurrentTime:(id)a3 currentTime:(id *)a4
{
  id v5 = a3;
  BOOL v6 = [MEMORY[0x1E4F1C9C8] date];
  id v7 = v6;
  if (v5)
  {
    [v6 timeIntervalSinceDate:v5];
    double v9 = v8;
  }
  else
  {
    double v9 = 0.0;
  }
  id v10 = v7;
  *a4 = v10;

  return v9;
}

- (void)_doPrimaryResidentUpdated
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  int v3 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v3);

  [(HMDHAPAccessory *)self _checkHAPSessionRestore];
  if (![(HMDAccessory *)self reachabilityPingNotificationEnabled])
  {
    uint64_t v18 = MEMORY[0x1D9452090]();
    char v19 = self;
    BOOL v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      int v21 = HMFGetLogIdentifier();
      int v24 = 138543362;
      BOOL v25 = v21;
      _os_log_impl(&dword_1D49D5000, v20, OS_LOG_TYPE_INFO, "%{public}@Reachability is not enabled for accessory", (uint8_t *)&v24, 0xCu);
    }
    long long v22 = (void *)v18;
    goto LABEL_15;
  }
  uint64_t v4 = [(HMDAccessory *)self home];
  char v5 = [v4 isCurrentDeviceConfirmedPrimaryResident];

  BOOL v6 = (void *)MEMORY[0x1D9452090]();
  id v7 = self;
  double v8 = HMFGetOSLogHandle();
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_INFO);
  if ((v5 & 1) == 0)
  {
    if (v9)
    {
      uint64_t v23 = HMFGetLogIdentifier();
      int v24 = 138543362;
      BOOL v25 = v23;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Primary resident notification -- but home says we're not primary!", (uint8_t *)&v24, 0xCu);
    }
    long long v22 = v6;
LABEL_15:
    return;
  }
  if (v9)
  {
    id v10 = HMFGetLogIdentifier();
    int v24 = 138543362;
    BOOL v25 = v10;
    _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Enabling reachability ping for thread transport, accessory", (uint8_t *)&v24, 0xCu);
  }
  [(HMDAccessory *)v7 setReachabilityPingEnabled:1];
  [(HMDHAPAccessory *)v7 startReachabilityCheck];
  uint64_t v11 = [(HMDHAPAccessory *)v7 cachedRemovedUser];

  if (v11)
  {
    id v12 = (void *)MEMORY[0x1D9452090]();
    int v13 = v7;
    id v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      uint64_t v15 = HMFGetLogIdentifier();
      int v16 = [(HMDHAPAccessory *)v13 cachedRemovedUser];
      int v24 = 138543618;
      BOOL v25 = v15;
      __int16 v26 = 2112;
      long long v27 = v16;
      _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_INFO, "%{public}@Current device is primary resident and there's a cached removed user: %@", (uint8_t *)&v24, 0x16u);
    }
    uint64_t v17 = [(HMDHAPAccessory *)v13 cachedRemovedUser];
    [(HMDHAPAccessory *)v13 _handleHomeUserRemovedNotification:v17];
  }
}

- (BOOL)_isRegisteredForNotificationsByForegroundProcess
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  int v3 = [MEMORY[0x1E4F1CA80] set];
  uint64_t v4 = [(HMDAccessory *)self home];
  char v5 = [v4 homeManager];
  BOOL v6 = [v5 messageDispatcher];
  id v7 = [v6 XPCTransport];
  double v8 = [v7 processMonitor];
  BOOL v9 = [v8 foregroundProcesses];
  v53[0] = MEMORY[0x1E4F143A8];
  v53[1] = 3221225472;
  v53[2] = __67__HMDHAPAccessory__isRegisteredForNotificationsByForegroundProcess__block_invoke;
  v53[3] = &unk_1E6A0B4C0;
  id v10 = v3;
  id v54 = v10;
  objc_msgSend(v9, "na_each:", v53);

  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  id v11 = v10;
  uint64_t v12 = [v11 countByEnumeratingWithState:&v49 objects:v63 count:16];
  if (v12)
  {
    uint64_t v13 = *(void *)v50;
    id v39 = v11;
    uint64_t v36 = *(void *)v50;
    do
    {
      uint64_t v14 = 0;
      uint64_t v37 = v12;
      do
      {
        if (*(void *)v50 != v13) {
          objc_enumerationMutation(v11);
        }
        uint64_t v15 = *(void *)(*((void *)&v49 + 1) + 8 * v14);
        long long v45 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        int v16 = [(HMDHAPAccessory *)self services];
        uint64_t v17 = [v16 countByEnumeratingWithState:&v45 objects:v62 count:16];
        if (v17)
        {
          uint64_t v18 = v17;
          uint64_t v19 = *(void *)v46;
          __int16 v40 = v16;
          uint64_t v38 = *(void *)v46;
          do
          {
            uint64_t v20 = 0;
            do
            {
              int v21 = self;
              if (*(void *)v46 != v19) {
                objc_enumerationMutation(v16);
              }
              long long v22 = *(void **)(*((void *)&v45 + 1) + 8 * v20);
              long long v41 = 0u;
              long long v42 = 0u;
              long long v43 = 0u;
              long long v44 = 0u;
              uint64_t v23 = [v22 characteristics];
              uint64_t v24 = [v23 countByEnumeratingWithState:&v41 objects:v61 count:16];
              if (v24)
              {
                uint64_t v25 = v24;
                uint64_t v26 = *(void *)v42;
                while (2)
                {
                  for (uint64_t i = 0; i != v25; ++i)
                  {
                    if (*(void *)v42 != v26) {
                      objc_enumerationMutation(v23);
                    }
                    uint64_t v28 = *(void **)(*((void *)&v41 + 1) + 8 * i);
                    if ([v28 isNotificationEnabledForClientIdentifier:v15])
                    {
                      long long v30 = (void *)MEMORY[0x1D9452090]();
                      __int16 v31 = v21;
                      long long v32 = HMFGetOSLogHandle();
                      if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
                      {
                        __int16 v33 = HMFGetLogIdentifier();
                        id v34 = [v28 shortDescription];
                        *(_DWORD *)buf = 138543874;
                        long long v56 = v33;
                        __int16 v57 = 2112;
                        id v58 = v34;
                        __int16 v59 = 2112;
                        uint64_t v60 = v15;
                        _os_log_impl(&dword_1D49D5000, v32, OS_LOG_TYPE_INFO, "%{public}@Characteristic %@ is registered for notifications from foreground client %@", buf, 0x20u);
                      }

                      BOOL v29 = 1;
                      id v11 = v39;
                      goto LABEL_28;
                    }
                  }
                  uint64_t v25 = [v23 countByEnumeratingWithState:&v41 objects:v61 count:16];
                  if (v25) {
                    continue;
                  }
                  break;
                }
              }

              ++v20;
              self = v21;
              int v16 = v40;
              uint64_t v19 = v38;
            }
            while (v20 != v18);
            uint64_t v18 = [v40 countByEnumeratingWithState:&v45 objects:v62 count:16];
            id v11 = v39;
            uint64_t v13 = v36;
          }
          while (v18);
        }

        ++v14;
      }
      while (v14 != v37);
      uint64_t v12 = [v11 countByEnumeratingWithState:&v49 objects:v63 count:16];
      BOOL v29 = 0;
    }
    while (v12);
  }
  else
  {
    BOOL v29 = 0;
  }
LABEL_28:

  return v29;
}

void __67__HMDHAPAccessory__isRegisteredForNotificationsByForegroundProcess__block_invoke(uint64_t a1, void *a2)
{
  id v7 = a2;
  int v3 = [v7 bundleIdentifier];

  if (v3)
  {
    uint64_t v4 = *(void **)(a1 + 32);
    char v5 = [v7 bundleIdentifier];
    BOOL v6 = [@"com.apple.HomeKit.client." stringByAppendingString:v5];
    [v4 addObject:v6];

    if ([v7 isEntitledForSPIAccess]) {
      [*(id *)(a1 + 32) addObject:@"com.apple.HomeKitDaemon.homeNotifications"];
    }
  }
}

- (void)handleResidentDeviceUpdated:(id)a3
{
  [(HMDHAPAccessory *)self _checkResidentDeviceForReachabilityPing];
  -[HMDHAPAccessory _evaluateResidentEnabledFeatures](self);
}

- (void)_evaluateResidentEnabledFeatures
{
  if (a1)
  {
    id v31 = [a1 home];
    objc_super v2 = [v31 enabledResidents];
    unsigned int v3 = objc_msgSend(v2, "na_any:", &__block_literal_global_49424);

    uint64_t v4 = [v31 appleMediaAccessories];
    char v5 = objc_msgSend(v4, "na_map:", &__block_literal_global_320_49425);

    id v6 = v5;
    id v7 = [a1 siriEndpointProfile];
    int v8 = objc_msgSend(v6, "na_any:", &__block_literal_global_326_49430);

    if (v7) {
      uint64_t v9 = v8 & v3;
    }
    else {
      uint64_t v9 = 0;
    }
    id v10 = v6;
    id v11 = [a1 siriEndpointProfile];
    int v12 = objc_msgSend(v10, "na_any:", &__block_literal_global_328_49428);

    LODWORD(v30) = v12 & v3;
    HIDWORD(v30) = v11 != 0;
    id v13 = v10;
    uint64_t v14 = [a1 siriEndpointProfile];
    int v15 = objc_msgSend(v13, "na_any:", &__block_literal_global_330);

    BOOL v16 = v14 != 0;
    int v17 = v15 & v3;
    id v18 = v13;
    uint64_t v19 = [a1 siriEndpointProfile];
    int v20 = objc_msgSend(v18, "na_any:", &__block_literal_global_332_49426);

    BOOL v21 = v19 != 0;
    int v22 = v20 & v3;
    id v23 = v18;
    uint64_t v24 = [a1 siriEndpointProfile];
    int v25 = objc_msgSend(v23, "na_any:", &__block_literal_global_334);

    BOOL v26 = v24 != 0;
    int v27 = v25 & v3;

    uint64_t v28 = v9 | 2;
    if ((HIDWORD(v30) & v30) == 0) {
      uint64_t v28 = v9;
    }
    if ((v16 & v17) != 0) {
      v28 |= 4uLL;
    }
    if ((v21 & v22) != 0) {
      v28 |= 8uLL;
    }
    if ((v26 & v27) != 0) {
      uint64_t v29 = v28 | 0x10;
    }
    else {
      uint64_t v29 = v28;
    }
    objc_msgSend(a1, "setSiriEndpointCapabilities:", v29, v30);
  }
}

uint64_t __86__HMDHAPAccessory_supportsUserMediaSettingsWithAccessoryCapabilities_supportsHomeHub___block_invoke(uint64_t a1, void *a2)
{
  return [a2 supportsUserMediaSettings];
}

uint64_t __82__HMDHAPAccessory_supportsDoorbellChimeWithAccessoryCapabilities_supportsHomeHub___block_invoke(uint64_t a1, void *a2)
{
  return [a2 supportsDoorbellChime];
}

uint64_t __78__HMDHAPAccessory_supportsMultiUserWithAccessoryCapabilities_supportsHomeHub___block_invoke(uint64_t a1, void *a2)
{
  return [a2 supportsMultiUser];
}

uint64_t __79__HMDHAPAccessory_supportsMusicAlarmWithAccessoryCapabilities_supportsHomeHub___block_invoke(uint64_t a1, void *a2)
{
  return [a2 supportsMusicAlarm];
}

uint64_t __77__HMDHAPAccessory_supportsAnnounceWithAccessoryCapabilities_supportsHomeHub___block_invoke(uint64_t a1, void *a2)
{
  return [a2 supportsAnnounce];
}

uint64_t __51__HMDHAPAccessory__evaluateResidentEnabledFeatures__block_invoke_2(uint64_t a1, void *a2)
{
  return [a2 capabilities];
}

uint64_t __51__HMDHAPAccessory__evaluateResidentEnabledFeatures__block_invoke(uint64_t a1, void *a2)
{
  objc_super v2 = [a2 capabilities];
  uint64_t v3 = [v2 supportsHomeHub];

  return v3;
}

- (void)_forceEnableReachabilityPingForPrimaryResident:(id)a3
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if (v4 && (isKindOfClass & 1) != 0)
  {
    id v6 = [(HMDAccessory *)self home];
    if ([v6 isCurrentDeviceAvailableResident])
    {
      int v7 = [v6 isCurrentDeviceConfirmedPrimaryResident];
      int v8 = (void *)MEMORY[0x1D9452090]();
      uint64_t v9 = self;
      id v10 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        uint64_t v11 = HMFGetLogIdentifier();
        int v12 = (void *)v11;
        id v13 = @"not ";
        if (v7) {
          id v13 = &stru_1F2C9F1A8;
        }
        *(_DWORD *)buf = 138543618;
        uint64_t v27 = v11;
        __int16 v28 = 2112;
        uint64_t v29 = v13;
        _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, "%{public}@Current device is %@primary resident", buf, 0x16u);
      }
      if (v7 && ![(HMDAccessory *)v9 reachabilityPingEnabled])
      {
        uint64_t v14 = [(HMDAccessory *)v9 workQueue];
        v24[0] = MEMORY[0x1E4F143A8];
        v24[1] = 3221225472;
        v24[2] = __66__HMDHAPAccessory__forceEnableReachabilityPingForPrimaryResident___block_invoke;
        v24[3] = &unk_1E6A197C8;
        v24[4] = v9;
        id v25 = v4;
        dispatch_async(v14, v24);
      }
    }
    else
    {
      int v20 = (void *)MEMORY[0x1D9452090]();
      BOOL v21 = self;
      int v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        id v23 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v27 = (uint64_t)v23;
        _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_DEBUG, "%{public}@Current device not a resident", buf, 0xCu);
      }
    }
  }
  else
  {
    int v15 = (void *)MEMORY[0x1D9452090]();
    BOOL v16 = self;
    int v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      id v18 = HMFGetLogIdentifier();
      uint64_t v19 = [v4 shortDescription];
      *(_DWORD *)buf = 138543618;
      uint64_t v27 = (uint64_t)v18;
      __int16 v28 = 2112;
      uint64_t v29 = v19;
      _os_log_impl(&dword_1D49D5000, v17, OS_LOG_TYPE_INFO, "%{public}@Accessory Server does not support forced ping enable %@", buf, 0x16u);
    }
  }
}

uint64_t __66__HMDHAPAccessory__forceEnableReachabilityPingForPrimaryResident___block_invoke(uint64_t a1)
{
  [*(id *)(a1 + 32) setReachabilityPingNotificationEnabled:1];
  [*(id *)(a1 + 32) setReachabilityPingEnabled:1];
  [*(id *)(a1 + 40) setReachabilityPingEnabled:1];
  objc_super v2 = *(void **)(a1 + 40);
  return [v2 startPing];
}

- (void)_forceUpdateBTLEKeyGenerationForServer:(id)a3
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if ([(HMDHAPAccessory *)self keyGenerationType] != 2)
  {
    char v5 = [v4 browser];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      id v6 = v5;
    }
    else {
      id v6 = 0;
    }
    id v7 = v6;

    if ([v7 remoteBrowsingEnabled]
      && ([v7 remoteBrowsingAndScanEnabled] & 1) == 0)
    {
      int v8 = (void *)MEMORY[0x1D9452090]();
      uint64_t v9 = self;
      id v10 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        uint64_t v11 = HMFGetLogIdentifier();
        int v12 = 138543618;
        id v13 = v11;
        __int16 v14 = 2112;
        int v15 = &unk_1F2DC7C90;
        _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, "%{public}@WHB Mode - Forcing the keyGenerationType to %@", (uint8_t *)&v12, 0x16u);
      }
      [(HMDHAPAccessory *)v9 setKeyGenerationType:2];
    }
  }
}

- (void)_enableBroadcastNotifications:(BOOL)a3 hapAccessory:(id)a4 forCharacteristics:(id)a5
{
  BOOL v71 = a3;
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  id v70 = a4;
  id v6 = a5;
  __int16 v68 = [MEMORY[0x1E4F1CA48] array];
  long long v85 = 0u;
  long long v86 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  id obj = v6;
  uint64_t v73 = [obj countByEnumeratingWithState:&v83 objects:v97 count:16];
  if (v73)
  {
    uint64_t v72 = *(void *)v84;
    *(void *)&long long v7 = 138544130;
    long long v67 = v7;
    do
    {
      for (uint64_t i = 0; i != v73; ++i)
      {
        if (*(void *)v84 != v72) {
          objc_enumerationMutation(obj);
        }
        uint64_t v9 = *(void **)(*((void *)&v83 + 1) + 8 * i);
        if ((objc_msgSend(v9, "properties", v67) & 8) != 0)
        {
          if ([v9 isNotificationEnabled]) {
            uint64_t v16 = 1;
          }
          else {
            uint64_t v16 = 3;
          }
          int v17 = [v9 characteristicForHAPAccessory:v70];
          uint64_t v18 = [MEMORY[0x1E4F5BC68] configurationTupleForCharacteristic:v17 broadcastEnable:v71 broadcastInterval:v16];
          uint64_t v19 = (void *)v18;
          if (v17) {
            BOOL v20 = v18 == 0;
          }
          else {
            BOOL v20 = 1;
          }
          if (v20)
          {
            uint64_t v27 = (void *)MEMORY[0x1D9452090]();
            BOOL v21 = self;
            uint64_t v29 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
            {
              int v22 = HMFGetLogIdentifier();
              id v23 = [v9 instanceID];
              uint64_t v24 = [v9 characteristicType];
              id v25 = [v70 server];
              BOOL v26 = [v25 identifier];
              *(_DWORD *)buf = v67;
              id v88 = v22;
              __int16 v89 = 2112;
              id v90 = v23;
              __int16 v91 = 2112;
              id v92 = v24;
              __int16 v93 = 2112;
              id v94 = v26;
              _os_log_impl(&dword_1D49D5000, v29, OS_LOG_TYPE_DEFAULT, "%{public}@Cannot map HMDCharacteristic %@/%@ to a HAPCharacteristic for server %@ to enable broadcast notifications", buf, 0x2Au);
            }
          }
          else
          {
            uint64_t v27 = (void *)MEMORY[0x1D9452090]([v68 addObject:v18]);
            __int16 v28 = self;
            uint64_t v29 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
            {
              id v31 = HMFGetLogIdentifier();
              long long v32 = [v19 characteristic];
              *(_DWORD *)buf = 138543618;
              id v88 = v31;
              __int16 v89 = 2112;
              id v90 = v32;
              _os_log_impl(&dword_1D49D5000, v29, OS_LOG_TYPE_DEBUG, "%{public}@Configuring broadcast notification for %@", buf, 0x16u);
            }
          }
        }
        else
        {
          id v10 = (void *)MEMORY[0x1D9452090]();
          uint64_t v11 = self;
          int v12 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            id v13 = HMFGetLogIdentifier();
            __int16 v14 = [v9 shortDescription];
            int v15 = HMFEnabledStatusToString();
            *(_DWORD *)buf = 138543874;
            id v88 = v13;
            __int16 v89 = 2112;
            id v90 = v14;
            __int16 v91 = 2112;
            id v92 = v15;
            _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_DEBUG, "%{public}@Not including %@ for broadcast notifications, enable: %@", buf, 0x20u);
          }
        }
      }
      uint64_t v73 = [obj countByEnumeratingWithState:&v83 objects:v97 count:16];
    }
    while (v73);
  }

  __int16 v33 = [v70 server];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v34 = v33;
  }
  else {
    id v34 = 0;
  }
  id v35 = v34;

  uint64_t v36 = [(HMDAccessory *)self home];
  uint64_t v37 = [v36 primaryResident];
  BOOL v38 = v37 == 0;

  if (v38)
  {
    long long v46 = (void *)MEMORY[0x1D9452090]();
    long long v47 = self;
    long long v48 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
    {
      long long v49 = HMFGetLogIdentifier();
      int v50 = [(HMDHAPAccessory *)v47 keyGenerationType];
      *(_DWORD *)buf = 138543618;
      id v88 = v49;
      __int16 v89 = 1024;
      LODWORD(v90) = v50;
      _os_log_impl(&dword_1D49D5000, v48, OS_LOG_TYPE_DEBUG, "%{public}@No resident configured - generating Broadcast Notify Key with type: %d", buf, 0x12u);
    }
  }
  else
  {
    int v39 = [v36 isCurrentDeviceAvailableResident];
    __int16 v40 = (void *)MEMORY[0x1D9452090]();
    long long v41 = self;
    long long v42 = HMFGetOSLogHandle();
    BOOL v43 = os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG);
    if (v39)
    {
      if (v43)
      {
        long long v44 = HMFGetLogIdentifier();
        int v45 = [(HMDHAPAccessory *)v41 keyGenerationType];
        *(_DWORD *)buf = 138543618;
        id v88 = v44;
        __int16 v89 = 1024;
        LODWORD(v90) = v45;
        _os_log_impl(&dword_1D49D5000, v42, OS_LOG_TYPE_DEBUG, "%{public}@Available resident - generating Broadcast Notify Key with type: %d", buf, 0x12u);
      }
    }
    else
    {
      if (v43)
      {
        long long v51 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v88 = v51;
        _os_log_impl(&dword_1D49D5000, v42, OS_LOG_TYPE_DEBUG, "%{public}@Reading Broadcast Notify Key from non-resident device", buf, 0xCu);
      }
      [(HMDHAPAccessory *)v41 setKeyGenerationType:2];
    }
  }
  if (![(HMDHAPAccessory *)self keyGenerationInProgress]
    && [v36 isAdminUser])
  {
    objc_initWeak(&location, self);
    if (v71) {
      goto LABEL_44;
    }
    long long v52 = [v36 primaryResident];
    if (!v52) {
      goto LABEL_44;
    }
    uint64_t v53 = [v36 primaryResident];
    id v54 = [v53 device];
    int v55 = [v54 isCurrentDevice];

    if (v55)
    {
LABEL_44:
      [(HMDHAPAccessory *)self setKeyGenerationInProgress:1];
      uint64_t v56 = [(HMDHAPAccessory *)self keyGenerationType];
      __int16 v57 = [(HMDAccessory *)self workQueue];
      v77[0] = MEMORY[0x1E4F143A8];
      v77[1] = 3221225472;
      v77[2] = __81__HMDHAPAccessory__enableBroadcastNotifications_hapAccessory_forCharacteristics___block_invoke;
      v77[3] = &unk_1E6A0B498;
      objc_copyWeak(&v80, &location);
      id v78 = v35;
      id v79 = v68;
      BOOL v81 = v71;
      [v78 generateBroadcastKey:v56 queue:v57 withCompletionHandler:v77];

      objc_destroyWeak(&v80);
    }
    else
    {
      id v58 = (void *)MEMORY[0x1D9452090]();
      __int16 v59 = self;
      HMFGetOSLogHandle();
      uint64_t v60 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
      {
        id v74 = v58;
        HMFGetLogIdentifier();
        id vala = (id)objc_claimAutoreleasedReturnValue();
        HMFEnabledStatusToString();
        id v61 = (id)objc_claimAutoreleasedReturnValue();
        [v36 isAdminUser];
        HMFBooleanToString();
        id v62 = (id)objc_claimAutoreleasedReturnValue();
        id v63 = [v36 primaryResident];
        uint64_t v64 = [v36 primaryResident];
        id v65 = [v64 device];
        [v65 isCurrentDevice];
        id v66 = HMFBooleanToString();
        *(_DWORD *)buf = 138544386;
        id v88 = vala;
        __int16 v89 = 2112;
        id v90 = v61;
        __int16 v91 = 2112;
        id v92 = v62;
        __int16 v93 = 2112;
        id v94 = v63;
        __int16 v95 = 2112;
        long long v96 = v66;
        _os_log_impl(&dword_1D49D5000, v60, OS_LOG_TYPE_DEBUG, "%{public}@Deferring BC configuration enable: %@, isAdminUser: %@, Resident: %@, isResident: %@", buf, 0x34u);

        id v58 = v74;
      }
    }
    objc_destroyWeak(&location);
  }
}

void __81__HMDHAPAccessory__enableBroadcastNotifications_hapAccessory_forCharacteristics___block_invoke(uint64_t a1, void *a2, void *a3, int a4, void *a5, double a6)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  id v11 = a2;
  id v12 = a3;
  id v13 = a5;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v15 = [WeakRetained setKeyGenerationInProgress:0];
  if (v13)
  {
    uint64_t v16 = (void *)MEMORY[0x1D9452090](v15);
    id v17 = WeakRetained;
    uint64_t v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = HMFGetLogIdentifier();
      BOOL v20 = objc_msgSend(NSNumber, "numberWithUnsignedChar:", objc_msgSend(v17, "keyGenerationType"));
      *(_DWORD *)buf = 138543874;
      __int16 v28 = v19;
      __int16 v29 = 2112;
      uint64_t v30 = v20;
      __int16 v31 = 2114;
      id v32 = v13;
      _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_ERROR, "%{public}@Failed generating broadcast key for type %@ with error: %{public}@", buf, 0x20u);
    }
  }
  else
  {
    if (v11 && [WeakRetained keyGenerationType] != 2 && a4)
    {
      [WeakRetained _updateBroadcastKey:v11 keyUpdatedStateNumber:v12 keyUpdatedTime:a6];
      [WeakRetained setKeyGenerationType:0];
    }
    BOOL v21 = *(void **)(a1 + 32);
    uint64_t v22 = *(void *)(a1 + 40);
    id v23 = [WeakRetained workQueue];
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    v24[2] = __81__HMDHAPAccessory__enableBroadcastNotifications_hapAccessory_forCharacteristics___block_invoke_651;
    v24[3] = &unk_1E6A0B470;
    objc_copyWeak(&v25, (id *)(a1 + 48));
    char v26 = *(unsigned char *)(a1 + 56);
    [v21 configureCharacteristics:v22 queue:v23 withCompletionHandler:v24];

    objc_destroyWeak(&v25);
  }
}

void __81__HMDHAPAccessory__enableBroadcastNotifications_hapAccessory_forCharacteristics___block_invoke_651(uint64_t a1, void *a2, void *a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v28 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  id v7 = v5;
  uint64_t v8 = a1;
  id v9 = v7;
  uint64_t v10 = [v7 countByEnumeratingWithState:&v32 objects:v42 count:16];
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)v33;
    uint64_t v29 = *(void *)v33;
    id v30 = WeakRetained;
    do
    {
      uint64_t v13 = 0;
      uint64_t v31 = v11;
      do
      {
        if (*(void *)v33 != v12) {
          objc_enumerationMutation(v9);
        }
        __int16 v14 = *(void **)(*((void *)&v32 + 1) + 8 * v13);
        uint64_t v15 = [v14 characteristic];
        uint64_t v16 = [v15 instanceID];
        id v17 = [WeakRetained hmdCharacteristicForInstanceId:v16];

        uint64_t v18 = [v14 error];

        if (v18)
        {
          BOOL v19 = *(unsigned char *)(v8 + 40) == 0;
        }
        else
        {
          BOOL v20 = (void *)MEMORY[0x1D9452090]();
          id v21 = WeakRetained;
          uint64_t v22 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
          {
            id v23 = HMFGetLogIdentifier();
            HMFEnabledStatusToString();
            id v24 = v9;
            v26 = uint64_t v25 = v8;
            uint64_t v27 = [v14 characteristic];
            *(_DWORD *)buf = 138543874;
            uint64_t v37 = v23;
            __int16 v38 = 2112;
            int v39 = v26;
            __int16 v40 = 2112;
            long long v41 = v27;
            _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_INFO, "%{public}@%@ Broadcast Events for characteristic %@", buf, 0x20u);

            uint64_t v8 = v25;
            id v9 = v24;
            id WeakRetained = v30;

            uint64_t v12 = v29;
          }

          BOOL v19 = *(unsigned char *)(v8 + 40) != 0;
          uint64_t v11 = v31;
        }
        [v17 setBroadcastNotificationEnabled:v19];

        ++v13;
      }
      while (v11 != v13);
      uint64_t v11 = [v9 countByEnumeratingWithState:&v32 objects:v42 count:16];
    }
    while (v11);
  }
}

- (BOOL)_remotelySetNotificationsEnabled:(BOOL)a3 forCharacteristic:(id)a4 clientIdentifier:(id)a5
{
  BOOL v6 = a3;
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v7 = a4;
  id v8 = a5;
  id v9 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v7, "count"));
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id obj = v7;
  uint64_t v10 = [obj countByEnumeratingWithState:&v31 objects:v39 count:16];
  id v27 = v8;
  if (!v10)
  {
    char v28 = 0;
    goto LABEL_22;
  }
  uint64_t v12 = v10;
  char v28 = 0;
  uint64_t v13 = *(void *)v32;
  *(void *)&long long v11 = 138543618;
  long long v26 = v11;
  do
  {
    for (uint64_t i = 0; i != v12; ++i)
    {
      if (*(void *)v32 != v13) {
        objc_enumerationMutation(obj);
      }
      uint64_t v15 = *(void **)(*((void *)&v31 + 1) + 8 * i);
      if (!v6)
      {
        if (![*(id *)(*((void *)&v31 + 1) + 8 * i) deregisterNotificationForClientIdentifier:v8])
        {
          char v28 = 1;
          continue;
        }
        goto LABEL_17;
      }
      if (isWatch() || ([v15 isNotificationEnabled] & 1) == 0)
      {
        BOOL v20 = (void *)MEMORY[0x1D9452090]();
        id v21 = self;
        uint64_t v22 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
        {
          id v23 = HMFGetLogIdentifier();
          *(_DWORD *)buf = v26;
          uint64_t v36 = v23;
          __int16 v37 = 2112;
          __int16 v38 = v15;
          _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_INFO, "%{public}@Enabling notification for characteristic %@ on remote gateway", buf, 0x16u);

          id v8 = v27;
        }

LABEL_17:
        objc_msgSend(v9, "addObject:", v15, v26);
        continue;
      }
      uint64_t v16 = (void *)MEMORY[0x1D9452090]();
      id v17 = self;
      uint64_t v18 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        BOOL v19 = HMFGetLogIdentifier();
        *(_DWORD *)buf = v26;
        uint64_t v36 = v19;
        __int16 v37 = 2112;
        __int16 v38 = v15;
        _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_INFO, "%{public}@Notification is already set to YES for characteristic: %@, not modifying it in remote gateway", buf, 0x16u);

        id v8 = v27;
      }
    }
    uint64_t v12 = [obj countByEnumeratingWithState:&v31 objects:v39 count:16];
  }
  while (v12);
LABEL_22:

  if ([v9 count])
  {
    id v24 = [(HMDAccessory *)self home];
    [v24 remotelySetNotificationsEnabled:v6 forCharacteristics:v9 characteristicChangeThresholds:0];

    id v8 = v27;
  }

  return v28 & 1;
}

uint64_t __83__HMDHAPAccessory__enableNotification_forCharacteristics_message_clientIdentifier___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (![v3 isNotificationEnabled])
  {
    id v5 = (void *)MEMORY[0x1D9452090]();
    id v6 = *(id *)(a1 + 40);
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = HMFGetLogIdentifier();
      id v9 = [*(id *)(a1 + 48) identifier];
      uint64_t v10 = [v9 shortDescription];
      long long v11 = [v3 shortDescription];
      int v14 = 138543874;
      uint64_t v15 = v8;
      __int16 v16 = 2114;
      id v17 = v10;
      __int16 v18 = 2112;
      BOOL v19 = v11;
      uint64_t v12 = "%{public}@[%{public}@] Filtering out request to disable characteristic because notification is already disabled: %@";
LABEL_8:
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, v12, (uint8_t *)&v14, 0x20u);
    }
LABEL_9:

    uint64_t v4 = 0;
    goto LABEL_10;
  }
  if (([v3 deregisterNotificationForClientIdentifier:*(void *)(a1 + 32)] & 1) == 0)
  {
    id v5 = (void *)MEMORY[0x1D9452090]();
    id v6 = *(id *)(a1 + 40);
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = HMFGetLogIdentifier();
      id v9 = [*(id *)(a1 + 48) identifier];
      uint64_t v10 = [v9 shortDescription];
      long long v11 = [v3 shortDescription];
      int v14 = 138543874;
      uint64_t v15 = v8;
      __int16 v16 = 2114;
      id v17 = v10;
      __int16 v18 = 2112;
      BOOL v19 = v11;
      uint64_t v12 = "%{public}@[%{public}@] Filtering out request to disable characteristic because another client identifier is "
            "still registered: %@";
      goto LABEL_8;
    }
    goto LABEL_9;
  }
  uint64_t v4 = 1;
LABEL_10:

  return v4;
}

uint64_t __83__HMDHAPAccessory__enableNotification_forCharacteristics_message_clientIdentifier___block_invoke_644(uint64_t a1, void *a2)
{
  return [a2 setNotificationEnabled:*(unsigned __int8 *)(a1 + 40) forClientIdentifier:*(void *)(a1 + 32)];
}

void __83__HMDHAPAccessory__enableNotification_forCharacteristics_message_clientIdentifier___block_invoke_645(uint64_t a1, void *a2)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  id v4 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 72));
  id v6 = WeakRetained;
  if (!WeakRetained)
  {
    uint64_t v15 = (void *)MEMORY[0x1D9452090]();
    __int16 v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      id v17 = HMFGetLogIdentifier();
      __int16 v18 = [*(id *)(a1 + 32) identifier];
      BOOL v19 = [v18 shortDescription];
      unint64_t v20 = *(void *)(a1 + 80);
      if (v20 > 2) {
        id v21 = @"Undefined";
      }
      else {
        id v21 = off_1E6A0B860[v20];
      }
      uint64_t v25 = v21;
      *(_DWORD *)buf = 138543874;
      long long v46 = v17;
      __int16 v47 = 2114;
      long long v48 = v19;
      __int16 v49 = 2112;
      int v50 = v25;
      _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_ERROR, "%{public}@[%{public}@] Failed to modify characteristic notifications using link type %@: lost self", buf, 0x20u);
    }
    uint64_t v26 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    uint64_t v27 = *(void *)(*(void *)(a1 + 64) + 8);
    char v28 = *(void **)(v27 + 40);
    *(void *)(v27 + 40) = v26;

    goto LABEL_18;
  }
  if (!v4)
  {
    uint64_t v22 = [WeakRetained matchingHAPAccessoryWithLinkType:*(void *)(a1 + 80)];
    id v23 = [v22 server];

    if (v23)
    {
      if ([v22 isReachable])
      {
        [v6 _setNotificationsEnabled:*(unsigned __int8 *)(a1 + 88) forCharacteristics:*(void *)(a1 + 48) hapAccessory:v22 activity:*(void *)(a1 + 32) completion:*(void *)(a1 + 56)];
LABEL_31:

        goto LABEL_32;
      }
      uint64_t v29 = (void *)MEMORY[0x1D9452090]();
      id v30 = v6;
      long long v31 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        long long v32 = HMFGetLogIdentifier();
        long long v33 = [*(id *)(a1 + 32) identifier];
        long long v34 = [v33 shortDescription];
        unint64_t v37 = *(void *)(a1 + 80);
        if (v37 > 2) {
          __int16 v38 = @"Undefined";
        }
        else {
          __int16 v38 = off_1E6A0B860[v37];
        }
        int v39 = v38;
        *(_DWORD *)buf = 138543874;
        long long v46 = v32;
        __int16 v47 = 2114;
        long long v48 = v34;
        __int16 v49 = 2112;
        int v50 = v39;
        uint64_t v40 = "%{public}@[%{public}@] Not modifying characteristic notifications using linkType %@: retrieved accessory is not reachable";
LABEL_29:
        _os_log_impl(&dword_1D49D5000, v31, OS_LOG_TYPE_INFO, v40, buf, 0x20u);

        id v4 = 0;
      }
    }
    else
    {
      uint64_t v29 = (void *)MEMORY[0x1D9452090]();
      id v30 = v6;
      long long v31 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        long long v32 = HMFGetLogIdentifier();
        long long v33 = [*(id *)(a1 + 32) identifier];
        long long v34 = [v33 shortDescription];
        unint64_t v35 = *(void *)(a1 + 80);
        if (v35 > 2) {
          uint64_t v36 = @"Undefined";
        }
        else {
          uint64_t v36 = off_1E6A0B860[v35];
        }
        int v39 = v36;
        *(_DWORD *)buf = 138543874;
        long long v46 = v32;
        __int16 v47 = 2114;
        long long v48 = v34;
        __int16 v49 = 2112;
        int v50 = v39;
        uint64_t v40 = "%{public}@[%{public}@] Not modifying characteristic notifications using linkType %@: no accessory server found";
        goto LABEL_29;
      }
    }

    uint64_t v41 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
    uint64_t v42 = *(void *)(*(void *)(a1 + 64) + 8);
    uint64_t v43 = *(void **)(v42 + 40);
    *(void *)(v42 + 40) = v41;

    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    goto LABEL_31;
  }
  id v7 = (void *)MEMORY[0x1D9452090]();
  id v8 = v6;
  id v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = HMFGetLogIdentifier();
    long long v11 = [*(id *)(a1 + 32) identifier];
    uint64_t v12 = [v11 shortDescription];
    unint64_t v13 = *(void *)(a1 + 80);
    long long v44 = v7;
    if (v13 > 2) {
      int v14 = @"Undefined";
    }
    else {
      int v14 = off_1E6A0B860[v13];
    }
    id v24 = v14;
    *(_DWORD *)buf = 138544130;
    long long v46 = v10;
    __int16 v47 = 2114;
    long long v48 = v12;
    __int16 v49 = 2112;
    int v50 = v24;
    __int16 v51 = 2112;
    id v52 = v4;
    _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_ERROR, "%{public}@[%{public}@] Failed to modify characteristic notifications using link type %@: accessory retrieval error: %@", buf, 0x2Au);

    id v7 = v44;
  }

  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), a2);
LABEL_18:
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
LABEL_32:
}

void __83__HMDHAPAccessory__enableNotification_forCharacteristics_message_clientIdentifier___block_invoke_646(uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 96));
  id v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24))
    {
      uint64_t v4 = *(unsigned __int8 *)(a1 + 104);
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v5 = *(void *)(a1 + 40);
    }
    else
    {
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24))
      {
        [WeakRetained _notifyCharacteristicNotificationChanges:*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) enableNotification:*(unsigned __int8 *)(a1 + 104) message:*(void *)(a1 + 32) clientIdentifier:*(void *)(a1 + 48)];
        goto LABEL_14;
      }
      if (*(unsigned char *)(a1 + 104))
      {
        id v9 = *(void **)(a1 + 48);
        if (!v9 || ([v9 hasPrefix:@"com.apple.HomeKit.client."] & 1) != 0)
        {
          uint64_t v10 = (void *)MEMORY[0x1D9452090]();
          id v11 = v3;
          uint64_t v12 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            unint64_t v13 = HMFGetLogIdentifier();
            int v14 = [*(id *)(a1 + 56) identifier];
            uint64_t v15 = [v14 shortDescription];
            uint64_t v16 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40);
            *(_DWORD *)buf = 138543874;
            unint64_t v35 = v13;
            __int16 v36 = 2114;
            unint64_t v37 = v15;
            __int16 v38 = 2112;
            uint64_t v39 = v16;
            _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_ERROR, "%{public}@[%{public}@] Characteristic notification enablement failed: %@", buf, 0x20u);
          }
          [*(id *)(a1 + 32) respondWithError:*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40)];
          goto LABEL_14;
        }
      }
      id v17 = (void *)MEMORY[0x1D9452090]();
      id v18 = v3;
      BOOL v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        unint64_t v20 = HMFGetLogIdentifier();
        id v21 = [*(id *)(a1 + 56) identifier];
        uint64_t v22 = [v21 shortDescription];
        uint64_t v23 = *(void *)(a1 + 48);
        *(_DWORD *)buf = 138543874;
        unint64_t v35 = v20;
        __int16 v36 = 2114;
        unint64_t v37 = v22;
        __int16 v38 = 2112;
        uint64_t v39 = v23;
        _os_log_impl(&dword_1D49D5000, v19, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Characteristic local notification enablement failed/skipped, updating registrations anyway for client: %@", buf, 0x20u);
      }
      long long v31 = 0u;
      long long v32 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      id v24 = *(id *)(a1 + 40);
      uint64_t v25 = [v24 countByEnumeratingWithState:&v29 objects:v33 count:16];
      if (v25)
      {
        uint64_t v26 = v25;
        uint64_t v27 = *(void *)v30;
        do
        {
          for (uint64_t i = 0; i != v26; ++i)
          {
            if (*(void *)v30 != v27) {
              objc_enumerationMutation(v24);
            }
            objc_msgSend(*(id *)(*((void *)&v29 + 1) + 8 * i), "setNotificationEnabled:forClientIdentifier:", *(unsigned __int8 *)(a1 + 104), *(void *)(a1 + 48), (void)v29);
          }
          uint64_t v26 = [v24 countByEnumeratingWithState:&v29 objects:v33 count:16];
        }
        while (v26);
      }

      uint64_t v4 = *(unsigned __int8 *)(a1 + 104);
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v5 = *(void *)(a1 + 40);
      id WeakRetained = v18;
    }
    objc_msgSend(WeakRetained, "_notifyClientsWithNotificationChangesForCharacteristics:characteristicErrors:enableNotification:message:", v5, 0, v4, v6, (void)v29);
LABEL_14:
    [v3 _checkHAPSessionRestore];
    goto LABEL_15;
  }
  id v7 = *(void **)(a1 + 32);
  id v8 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
  [v7 respondWithError:v8];

LABEL_15:
}

- (void)enableNotification:(BOOL)a3 forCharacteristicIDs:(id)a4 message:(id)a5 clientIdentifier:(id)a6
{
  id v10 = a4;
  id v11 = a5;
  id v12 = a6;
  unint64_t v13 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __84__HMDHAPAccessory_enableNotification_forCharacteristicIDs_message_clientIdentifier___block_invoke;
  block[3] = &unk_1E6A154B0;
  id v18 = v10;
  BOOL v19 = self;
  BOOL v22 = a3;
  id v20 = v12;
  id v21 = v11;
  id v14 = v11;
  id v15 = v12;
  id v16 = v10;
  dispatch_async(v13, block);
}

void __84__HMDHAPAccessory_enableNotification_forCharacteristicIDs_message_clientIdentifier___block_invoke(uint64_t a1)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  uint64_t v60 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(*(id *)(a1 + 32), "count"));
  id v61 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(*(id *)(a1 + 32), "count"));
  id v62 = [*(id *)(a1 + 40) hapMetadata];
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  id obj = *(id *)(a1 + 32);
  uint64_t v2 = [obj countByEnumeratingWithState:&v64 objects:v76 count:16];
  if (v2)
  {
    uint64_t v4 = v2;
    uint64_t v5 = *(void *)v65;
    *(void *)&long long v3 = 138543874;
    long long v58 = v3;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v65 != v5) {
          objc_enumerationMutation(obj);
        }
        id v7 = *(const char **)(*((void *)&v64 + 1) + 8 * v6);
        id v8 = objc_msgSend(*(id *)(a1 + 40), "findCharacteristic:", v7, v58);
        id v9 = v8;
        if (!v8)
        {
          uint64_t v10 = MEMORY[0x1D9452090]();
          id v11 = *(id *)(a1 + 40);
          id v12 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v13 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543618;
            id v69 = v13;
            __int16 v70 = 2112;
            BOOL v71 = v7;
            id v14 = v12;
            id v15 = "%{public}@Unable to look up characteristic with instanceID %@";
            goto LABEL_15;
          }
LABEL_16:

          id v20 = (void *)v10;
LABEL_17:
          goto LABEL_18;
        }
        if (([v8 properties] & 1) == 0)
        {
          uint64_t v10 = MEMORY[0x1D9452090]();
          id v11 = *(id *)(a1 + 40);
          id v12 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v13 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543618;
            id v69 = v13;
            __int16 v70 = 2112;
            BOOL v71 = v7;
            id v14 = v12;
            id v15 = "%{public}@Characteristic with instanceID %@ does not support notification";
            goto LABEL_15;
          }
          goto LABEL_16;
        }
        id v16 = [v9 type];
        id v17 = [v9 service];
        id v18 = [v17 type];
        int v19 = [v62 shouldFilterEnableNotificationsForCharacteristicType:v16 serviceType:v18];

        if (v19)
        {
          uint64_t v10 = MEMORY[0x1D9452090]();
          id v11 = *(id *)(a1 + 40);
          id v12 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v13 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543618;
            id v69 = v13;
            __int16 v70 = 2112;
            BOOL v71 = v7;
            id v14 = v12;
            id v15 = "%{public}@Dropping notification enable request for filtered characteristic with instanceID %@";
LABEL_15:
            _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 0x16u);
          }
          goto LABEL_16;
        }
        int v21 = [v9 isNotificationEnabled];
        int v22 = *(unsigned __int8 *)(a1 + 64);
        uint64_t v23 = [v9 isNotificationEnabledForClientIdentifier:*(void *)(a1 + 48)];
        int v24 = *(unsigned __int8 *)(a1 + 64);
        if (v22 == v21)
        {
          if (v24 != v23) {
            uint64_t v23 = [v9 setNotificationEnabled:v24 != 0 forClientIdentifier:*(void *)(a1 + 48)];
          }
          uint64_t v25 = (void *)MEMORY[0x1D9452090](v23);
          id v26 = *(id *)(a1 + 40);
          uint64_t v27 = HMFGetOSLogHandle();
          if (!os_log_type_enabled(v27, OS_LOG_TYPE_INFO)) {
            goto LABEL_29;
          }
          char v28 = HMFGetLogIdentifier();
          long long v29 = [v9 shortDescription];
          *(_DWORD *)buf = 138543618;
          id v69 = v28;
          __int16 v70 = 2112;
          BOOL v71 = v29;
          long long v30 = v27;
          long long v31 = "%{public}@No change in notification for characteristic %@";
          goto LABEL_28;
        }
        if (v24 != v23)
        {
          if (*(unsigned char *)(a1 + 64)
            || ([v9 notificationRegistrations],
                long long v32 = objc_claimAutoreleasedReturnValue(),
                uint64_t v33 = [v32 count],
                v32,
                v33 == 1))
          {
            uint64_t v34 = MEMORY[0x1D9452090]([v60 addObject:v9]);
            id v35 = *(id *)(a1 + 40);
            __int16 v36 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
            {
              HMFGetLogIdentifier();
              unint64_t v37 = v59 = v34;
              if (*(unsigned char *)(a1 + 64)) {
                __int16 v38 = "Subscribe";
              }
              else {
                __int16 v38 = "Unsubscribe";
              }
              uint64_t v39 = [v9 shortDescription];
              uint64_t v40 = *(void *)(a1 + 48);
              *(_DWORD *)buf = 138544130;
              id v69 = v37;
              __int16 v70 = 2080;
              BOOL v71 = v38;
              __int16 v72 = 2112;
              uint64_t v73 = v39;
              __int16 v74 = 2112;
              uint64_t v75 = v40;
              _os_log_impl(&dword_1D49D5000, v36, OS_LOG_TYPE_INFO, "%{public}@%s notification of characteristic %@ due to client %@", buf, 0x2Au);

              uint64_t v34 = v59;
            }

            id v20 = (void *)v34;
          }
          else
          {
            [v9 setNotificationEnabled:*(unsigned __int8 *)(a1 + 64) forClientIdentifier:*(void *)(a1 + 48)];
            uint64_t v41 = MEMORY[0x1D9452090]([v61 addObject:v9]);
            id v42 = *(id *)(a1 + 40);
            uint64_t v43 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
            {
              long long v44 = HMFGetLogIdentifier();
              int v45 = [v9 shortDescription];
              long long v46 = *(void **)(a1 + 48);
              *(_DWORD *)buf = v58;
              id v69 = v44;
              __int16 v70 = 2112;
              BOOL v71 = v45;
              __int16 v72 = 2112;
              uint64_t v73 = v46;
              _os_log_impl(&dword_1D49D5000, v43, OS_LOG_TYPE_INFO, "%{public}@Deregister notification of characteristic %@ for client %@", buf, 0x20u);
            }
            id v20 = (void *)v41;
          }
          goto LABEL_17;
        }
        uint64_t v25 = (void *)MEMORY[0x1D9452090]();
        id v26 = *(id *)(a1 + 40);
        uint64_t v27 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
        {
          char v28 = HMFGetLogIdentifier();
          long long v29 = [v9 shortDescription];
          *(_DWORD *)buf = 138543618;
          id v69 = v28;
          __int16 v70 = 2112;
          BOOL v71 = v29;
          long long v30 = v27;
          long long v31 = "%{public}@No change in notification enabled for characteristic %@";
LABEL_28:
          _os_log_impl(&dword_1D49D5000, v30, OS_LOG_TYPE_INFO, v31, buf, 0x16u);
        }
LABEL_29:

        [v61 addObject:v9];
LABEL_18:

        ++v6;
      }
      while (v4 != v6);
      uint64_t v47 = [obj countByEnumeratingWithState:&v64 objects:v76 count:16];
      uint64_t v4 = v47;
    }
    while (v47);
  }

  uint64_t v48 = [v60 count];
  if ([v61 count])
  {
    if (v48) {
      uint64_t v49 = 0;
    }
    else {
      uint64_t v49 = *(void *)(a1 + 56);
    }
    [*(id *)(a1 + 40) _notifyClientsWithNotificationChangesForCharacteristics:v61 characteristicErrors:0 enableNotification:*(unsigned __int8 *)(a1 + 64) != 0 message:v49];
    if ([v60 count]) {
      goto LABEL_52;
    }
  }
  else
  {
    if ([v60 count])
    {
LABEL_52:
      [*(id *)(a1 + 40) _enableNotification:*(unsigned __int8 *)(a1 + 64) forCharacteristics:v60 message:*(void *)(a1 + 56) clientIdentifier:*(void *)(a1 + 48)];
      goto LABEL_53;
    }
    int v50 = [*(id *)(a1 + 56) responseHandler];

    if (v50)
    {
      __int16 v51 = (void *)MEMORY[0x1D9452090]();
      id v52 = *(id *)(a1 + 40);
      uint64_t v53 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
      {
        id v54 = HMFGetLogIdentifier();
        int v55 = *(const char **)(a1 + 32);
        *(_DWORD *)buf = 138543618;
        id v69 = v54;
        __int16 v70 = 2112;
        BOOL v71 = v55;
        _os_log_impl(&dword_1D49D5000, v53, OS_LOG_TYPE_INFO, "%{public}@No matching characteristics for instanceIDs %@", buf, 0x16u);
      }
      uint64_t v56 = [*(id *)(a1 + 56) responseHandler];
      __int16 v57 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
      ((void (**)(void, void *, void))v56)[2](v56, v57, 0);
    }
  }
LABEL_53:
}

void __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v5 = *(void **)(a1 + 40);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_2;
  v10[3] = &unk_1E6A0B2E0;
  id v11 = v3;
  id v7 = v3;
  id v8 = objc_msgSend(v5, "na_firstObjectPassingTest:", v10);
  id v9 = [v8 threshold];
  [v7 setNotificationEnabled:v4 forClientIdentifier:v6 changeThreshold:v9];
}

BOOL __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_632(uint64_t a1, void *a2)
{
  id v3 = [a2 characteristic];
  BOOL v4 = v3 == *(void **)(a1 + 32);

  return v4;
}

void __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_2_633(uint64_t a1, void *a2, void *a3)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  id v41 = a2;
  id v33 = a3;
  uint64_t v38 = a1;
  uint64_t v34 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(*(id *)(a1 + 32), "count"));
  long long v53 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v50 = 0u;
  id obj = *(id *)(a1 + 32);
  uint64_t v40 = [obj countByEnumeratingWithState:&v50 objects:v63 count:16];
  if (v40)
  {
    uint64_t v39 = *(void *)v51;
    do
    {
      uint64_t v5 = 0;
      do
      {
        if (*(void *)v51 != v39) {
          objc_enumerationMutation(obj);
        }
        uint64_t v6 = *(void **)(*((void *)&v50 + 1) + 8 * v5);
        id v7 = [v6 characteristicForHAPAccessory:v41];
        id v8 = v7;
        if (v7)
        {
          if (([v7 properties] & 1) != 0
            && (*(unsigned char *)(v38 + 96)
             || [v6 deregisterNotificationForClientIdentifier:*(void *)(v38 + 40)]))
          {
            [v34 addObject:v8];
          }
        }
        else
        {
          id v9 = (void *)MEMORY[0x1D9452090]();
          id v10 = *(id *)(v38 + 48);
          id v11 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            __int16 v36 = HMFGetLogIdentifier();
            unint64_t v37 = [*(id *)(v38 + 56) identifier];
            id v12 = [v37 shortDescription];
            unint64_t v13 = [v6 instanceID];
            id v14 = [v6 characteristicType];
            id v15 = [v41 server];
            id v16 = [v15 identifier];
            *(_DWORD *)buf = 138544386;
            *(void *)&uint8_t buf[4] = v36;
            __int16 v55 = 2114;
            uint64_t v56 = v12;
            __int16 v57 = 2112;
            uint64_t v58 = (uint64_t)v13;
            __int16 v59 = 2112;
            id v60 = v14;
            __int16 v61 = 2112;
            id v62 = v16;
            _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_ERROR, "%{public}@[%{public}@] Cannot map HMDCharacteristic %@/%@ to a HAPCharacteristic for server %@ to enable notifications", buf, 0x34u);
          }
        }

        ++v5;
      }
      while (v40 != v5);
      uint64_t v17 = [obj countByEnumeratingWithState:&v50 objects:v63 count:16];
      uint64_t v40 = v17;
    }
    while (v17);
  }

  uint64_t v18 = [v34 count];
  if (v33 && v18 && (uint64_t v18 = [v41 isReachable], (v18 & 1) != 0))
  {
    int v19 = *(unsigned __int8 *)(v38 + 96);
    v42[0] = MEMORY[0x1E4F143A8];
    v42[1] = 3221225472;
    v42[2] = __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_634;
    v42[3] = &unk_1E6A0B330;
    objc_copyWeak(&v48, (id *)(v38 + 88));
    id v20 = *(id *)(v38 + 56);
    int v22 = *(void **)(v38 + 72);
    uint64_t v21 = *(void *)(v38 + 80);
    id v43 = v20;
    uint64_t v47 = v21;
    id v44 = v22;
    id v45 = *(id *)(v38 + 32);
    char v49 = *(unsigned char *)(v38 + 96);
    id v46 = *(id *)(v38 + 64);
    uint64_t v23 = [*(id *)(v38 + 48) workQueue];
    [v33 enableEvents:v19 != 0 forCharacteristics:v34 withCompletionHandler:v42 queue:v23];

    [*(id *)(v38 + 48) _updateAccessoryTracking];
    *(void *)buf = 0;
    id v24 = (id)[*(id *)(v38 + 48) preferredHAPAccessoryForOperation:4 linkType:buf];
    if (*(void *)buf == 2) {
      [*(id *)(v38 + 48) _enableBroadcastNotifications:*(unsigned __int8 *)(v38 + 96) hapAccessory:v41 forCharacteristics:*(void *)(v38 + 32)];
    }

    objc_destroyWeak(&v48);
  }
  else
  {
    uint64_t v25 = (void *)MEMORY[0x1D9452090](v18);
    id v26 = *(id *)(v38 + 48);
    uint64_t v27 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
    {
      char v28 = HMFGetLogIdentifier();
      long long v29 = [*(id *)(v38 + 56) identifier];
      long long v30 = [v29 shortDescription];
      uint64_t v31 = [v34 count];
      [v41 isReachable];
      long long v32 = HMFBooleanToString();
      *(_DWORD *)buf = 138544386;
      *(void *)&uint8_t buf[4] = v28;
      __int16 v55 = 2114;
      uint64_t v56 = v30;
      __int16 v57 = 2048;
      uint64_t v58 = v31;
      __int16 v59 = 2112;
      id v60 = v33;
      __int16 v61 = 2112;
      id v62 = v32;
      _os_log_impl(&dword_1D49D5000, v27, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Not enabling events on HAP accessory server because hapCharacteristics.count=%lu accessoryServer=%@ hapAccessory.isReachable=%@", buf, 0x34u);
    }
    dispatch_group_leave(*(dispatch_group_t *)(v38 + 64));
  }
}

BOOL __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_636(uint64_t a1, void *a2)
{
  id v3 = [a2 characteristic];
  BOOL v4 = v3 == *(void **)(a1 + 32);

  return v4;
}

void __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_2_637(uint64_t a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  uint64_t v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = [WeakRetained matchingHAPAccessoryWithLinkType:*(void *)(a1 + 72)];
    uint64_t v7 = [v6 server];
    id v8 = (void *)v7;
    if (!v3 && v7 && ([v6 isReachable] & 1) != 0)
    {
      if (!*(void *)(a1 + 48) || objc_msgSend(v6, "isEqual:"))
      {
        (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
LABEL_12:

        goto LABEL_16;
      }
    }
    else
    {
      id v9 = (void *)MEMORY[0x1D9452090]();
      id v10 = v5;
      id v11 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        id v12 = HMFGetLogIdentifier();
        unint64_t v13 = [*(id *)(a1 + 32) identifier];
        [v13 shortDescription];
        id v14 = v20 = v9;
        *(_DWORD *)buf = 138543874;
        int v22 = v12;
        __int16 v23 = 2114;
        id v24 = v14;
        __int16 v25 = 2112;
        id v26 = v3;
        _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_ERROR, "%{public}@[%{public}@] Failed to retrieve the HAP accessory: %@", buf, 0x20u);

        id v9 = v20;
      }
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    goto LABEL_12;
  }
  id v15 = (void *)MEMORY[0x1D9452090]();
  id v16 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    uint64_t v17 = HMFGetLogIdentifier();
    uint64_t v18 = [*(id *)(a1 + 32) identifier];
    int v19 = [v18 shortDescription];
    *(_DWORD *)buf = 138543618;
    int v22 = v17;
    __int16 v23 = 2114;
    id v24 = v19;
    _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Self became nil", buf, 0x16u);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
LABEL_16:
}

void __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_638(uint64_t a1)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 96));
  id v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24))
    {
      BOOL v4 = [*(id *)(a1 + 32) keyEnumerator];
      uint64_t v5 = [v4 allObjects];
      v36[0] = MEMORY[0x1E4F143A8];
      v36[1] = 3221225472;
      v36[2] = __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_2_639;
      v36[3] = &unk_1E6A135B0;
      id v37 = *(id *)(a1 + 32);
      id v38 = *(id *)(a1 + 40);
      objc_msgSend(v5, "na_each:", v36);

      [v3 _notifyCharacteristicNotificationChanges:*(void *)(a1 + 40) enableNotification:*(unsigned __int8 *)(a1 + 104) message:0 clientIdentifier:*(void *)(a1 + 48)];
    }
    else if (*(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24))
    {
      [WeakRetained _notifyClientsWithNotificationChangesForCharacteristics:*(void *)(a1 + 56) characteristicErrors:*(void *)(a1 + 32) enableNotification:*(unsigned __int8 *)(a1 + 104) message:0];
    }
    else if ([*(id *)(a1 + 48) hasPrefix:@"com.apple.HomeKitDaemon"] {
           && ([*(id *)(a1 + 48) isEqualToString:@"com.apple.HomeKitDaemon.homeNotifications"] & 1) == 0)
    }
    {
      id v12 = (void *)MEMORY[0x1D9452090]();
      long long v29 = v3;
      id v13 = v3;
      id v14 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        id v15 = HMFGetLogIdentifier();
        id v16 = [*(id *)(a1 + 64) identifier];
        uint64_t v17 = [v16 shortDescription];
        *(_DWORD *)buf = 138543618;
        id v41 = v15;
        __int16 v42 = 2114;
        id v43 = v17;
        _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Characteristic notification enablement failed, but updating registrations anyway", buf, 0x16u);
      }
      char v28 = v13;

      long long v34 = 0u;
      long long v35 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      id obj = *(id *)(a1 + 56);
      uint64_t v18 = [obj countByEnumeratingWithState:&v32 objects:v39 count:16];
      if (v18)
      {
        uint64_t v19 = v18;
        uint64_t v20 = *(void *)v33;
        do
        {
          for (uint64_t i = 0; i != v19; ++i)
          {
            if (*(void *)v33 != v20) {
              objc_enumerationMutation(obj);
            }
            int v22 = *(void **)(*((void *)&v32 + 1) + 8 * i);
            uint64_t v23 = *(unsigned __int8 *)(a1 + 104);
            uint64_t v24 = *(void *)(a1 + 48);
            __int16 v25 = *(void **)(a1 + 72);
            v31[0] = MEMORY[0x1E4F143A8];
            v31[1] = 3221225472;
            v31[2] = __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_641;
            v31[3] = &unk_1E6A0B2E0;
            v31[4] = v22;
            id v26 = objc_msgSend(v25, "na_firstObjectPassingTest:", v31, v28);
            uint64_t v27 = [v26 threshold];
            [v22 setNotificationEnabled:v23 forClientIdentifier:v24 changeThreshold:v27];
          }
          uint64_t v19 = [obj countByEnumeratingWithState:&v32 objects:v39 count:16];
        }
        while (v19);
      }

      [v28 _notifyClientsWithNotificationChangesForCharacteristics:*(void *)(a1 + 56) characteristicErrors:*(void *)(a1 + 32) enableNotification:*(unsigned __int8 *)(a1 + 104) message:0];
      id v3 = v29;
    }
    else
    {
      uint64_t v6 = (void *)MEMORY[0x1D9452090]();
      id v7 = v3;
      id v8 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        id v9 = HMFGetLogIdentifier();
        id v10 = [*(id *)(a1 + 64) identifier];
        id v11 = [v10 shortDescription];
        *(_DWORD *)buf = 138543618;
        id v41 = v9;
        __int16 v42 = 2114;
        id v43 = v11;
        _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_ERROR, "%{public}@[%{public}@] Characteristic notification enablement failed", buf, 0x16u);
      }
    }
  }
}

void __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_2_639(uint64_t a1, uint64_t a2)
{
  id v5 = [*(id *)(a1 + 32) objectForKey:a2];
  id v3 = *(void **)(a1 + 40);
  BOOL v4 = [MEMORY[0x1E4F5BC80] responseTupleForCharacteristic:0 error:v5];
  [v3 addObject:v4];
}

BOOL __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_641(uint64_t a1, void *a2)
{
  id v3 = [a2 characteristic];
  BOOL v4 = v3 == *(void **)(a1 + 32);

  return v4;
}

void __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_634(uint64_t a1, void *a2, void *a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 72));
  if (WeakRetained)
  {
    id v8 = (void *)MEMORY[0x1D9452090]();
    id v9 = WeakRetained;
    id v10 = HMFGetOSLogHandle();
    id v11 = v10;
    if (v6)
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        id v12 = HMFGetLogIdentifier();
        id v13 = [*(id *)(a1 + 32) identifier];
        id v14 = [v13 shortDescription];
        *(_DWORD *)buf = 138543874;
        uint64_t v31 = v12;
        __int16 v32 = 2114;
        long long v33 = v14;
        __int16 v34 = 2112;
        id v35 = v6;
        _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_ERROR, "%{public}@[%{public}@] One or more notification enable commands failed: %@", buf, 0x20u);
      }
    }
    else
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        id v15 = HMFGetLogIdentifier();
        id v16 = [*(id *)(a1 + 32) identifier];
        uint64_t v17 = [v16 shortDescription];
        *(_DWORD *)buf = 138543618;
        uint64_t v31 = v15;
        __int16 v32 = 2114;
        long long v33 = v17;
        _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_INFO, "%{public}@[%{public}@] Successfully modified characteristic notifications", buf, 0x16u);
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 1;
      id v25 = v5;
      [*(id *)(a1 + 40) addObjectsFromArray:v5];
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      id v18 = *(id *)(a1 + 48);
      uint64_t v19 = [v18 countByEnumeratingWithState:&v26 objects:v36 count:16];
      if (v19)
      {
        uint64_t v20 = v19;
        uint64_t v21 = *(void *)v27;
        do
        {
          for (uint64_t i = 0; i != v20; ++i)
          {
            if (*(void *)v27 != v21) {
              objc_enumerationMutation(v18);
            }
            uint64_t v23 = *(void **)(*((void *)&v26 + 1) + 8 * i);
            if (*(unsigned char *)(a1 + 80)) {
              [MEMORY[0x1E4F1C9C8] date];
            }
            else {
            uint64_t v24 = [MEMORY[0x1E4F1C9C8] distantFuture];
            }
            [v23 setNotificationEnabledTime:v24];
          }
          uint64_t v20 = [v18 countByEnumeratingWithState:&v26 objects:v36 count:16];
        }
        while (v20);
      }

      id v5 = v25;
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 56));
}

BOOL __130__HMDHAPAccessory__setNotificationsEnabled_forCharacteristics_notificationChangeThresholds_clientIdentifier_matchingHAPAccessory___block_invoke_2(uint64_t a1, void *a2)
{
  id v3 = [a2 characteristic];
  BOOL v4 = v3 == *(void **)(a1 + 32);

  return v4;
}

- (void)_setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 clientIdentifier:(id)a5 matchingHAPAccessory:(id)a6
{
}

- (void)setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 notificationChangeThresholds:(id)a5 clientIdentifier:(id)a6
{
}

- (void)setNotificationsEnabled:(BOOL)a3 forCharacteristics:(id)a4 clientIdentifier:(id)a5
{
}

- (void)_disableNotificationsForBundleID:(id)a3 completionHandler:(id)a4
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = (void (**)(id, BOOL))a4;
  id v8 = [(HMDHAPAccessory *)self hapMetadata];
  id v9 = [(HMDAccessory *)self home];
  id v10 = [v9 notificationRegistrations];
  BOOL v11 = [v10 count] != 0;

  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = __70__HMDHAPAccessory__disableNotificationsForBundleID_completionHandler___block_invoke;
  v30[3] = &unk_1E6A0B2B8;
  id v12 = v6;
  id v31 = v12;
  BOOL v34 = v11;
  id v13 = v8;
  id v32 = v13;
  long long v33 = self;
  id v14 = [(HMDHAPAccessory *)self characteristicsPassingTest:v30];
  uint64_t v15 = [v14 count];
  if (v15)
  {
    id v16 = (void *)MEMORY[0x1D9452090]();
    uint64_t v17 = self;
    id v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      uint64_t v19 = HMFGetLogIdentifier();
      uint64_t v20 = [v14 count];
      *(_DWORD *)buf = 138543618;
      uint64_t v37 = v19;
      __int16 v38 = 2048;
      uint64_t v39 = v20;
      _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_INFO, "%{public}@Disabling notification for accessory for %tu characteristics", buf, 0x16u);
    }
    [(HMDHAPAccessory *)v17 _setNotificationsEnabled:0 forCharacteristics:v14 clientIdentifier:v12 matchingHAPAccessory:0];
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id v21 = v14;
    uint64_t v22 = [v21 countByEnumeratingWithState:&v26 objects:v35 count:16];
    if (v22)
    {
      uint64_t v23 = v22;
      uint64_t v24 = *(void *)v27;
      do
      {
        uint64_t v25 = 0;
        do
        {
          if (*(void *)v27 != v24) {
            objc_enumerationMutation(v21);
          }
          objc_msgSend(*(id *)(*((void *)&v26 + 1) + 8 * v25++), "setNotificationEnabled:forClientIdentifier:", 0, v12, (void)v26);
        }
        while (v23 != v25);
        uint64_t v23 = [v21 countByEnumeratingWithState:&v26 objects:v35 count:16];
      }
      while (v23);
    }
  }
  v7[2](v7, v15 != 0);
}

uint64_t __70__HMDHAPAccessory__disableNotificationsForBundleID_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (![v3 isNotificationEnabled]) {
    goto LABEL_6;
  }
  int v4 = [v3 deregisterNotificationForClientIdentifier:*(void *)(a1 + 32)];
  id v5 = [v3 type];
  id v6 = [v3 service];
  id v7 = [v6 type];

  if (!v4
    || *(unsigned char *)(a1 + 56)
    && ([*(id *)(a1 + 40) shouldEnableHomeNotificationForCharacteristicType:v5 serviceType:v7] & 1) != 0)
  {

LABEL_6:
    uint64_t v8 = 0;
    goto LABEL_7;
  }
  id v10 = (void *)MEMORY[0x1D9452090]();
  id v11 = *(id *)(a1 + 48);
  id v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    id v13 = HMFGetLogIdentifier();
    int v14 = 138543618;
    uint64_t v15 = v13;
    __int16 v16 = 2112;
    id v17 = v3;
    _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_INFO, "%{public}@Deregistering notification for characteristic %@", (uint8_t *)&v14, 0x16u);
  }

  uint64_t v8 = 1;
LABEL_7:

  return v8;
}

- (void)disableNotificationsForBundleID:(id)a3 completionHandler:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __69__HMDHAPAccessory_disableNotificationsForBundleID_completionHandler___block_invoke;
  block[3] = &unk_1E6A193D0;
  void block[4] = self;
  id v12 = v6;
  id v13 = v7;
  id v9 = v7;
  id v10 = v6;
  dispatch_async(v8, block);
}

uint64_t __69__HMDHAPAccessory_disableNotificationsForBundleID_completionHandler___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _disableNotificationsForBundleID:*(void *)(a1 + 40) completionHandler:*(void *)(a1 + 48)];
}

- (void)handleRemoteGatewayNotificationRegistration:(id)a3 enable:(BOOL)a4 enableTime:(id)a5
{
  id v8 = a3;
  id v9 = a5;
  id v10 = [(HMDAccessory *)self workQueue];
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  v13[2] = __81__HMDHAPAccessory_handleRemoteGatewayNotificationRegistration_enable_enableTime___block_invoke;
  v13[3] = &unk_1E6A15B38;
  id v14 = v8;
  uint64_t v15 = self;
  BOOL v17 = a4;
  id v16 = v9;
  id v11 = v9;
  id v12 = v8;
  dispatch_async(v10, v13);
}

void __81__HMDHAPAccessory_handleRemoteGatewayNotificationRegistration_enable_enableTime___block_invoke(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = [MEMORY[0x1E4F1C9C8] distantFuture];
  id v3 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(*(id *)(a1 + 32), "count"));
  id v21 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(*(id *)(a1 + 32), "count"));
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  id obj = [*(id *)(a1 + 40) services];
  uint64_t v19 = [obj countByEnumeratingWithState:&v26 objects:v31 count:16];
  if (v19)
  {
    uint64_t v18 = *(void *)v27;
    do
    {
      uint64_t v4 = 0;
      do
      {
        if (*(void *)v27 != v18) {
          objc_enumerationMutation(obj);
        }
        uint64_t v20 = v4;
        id v5 = *(void **)(*((void *)&v26 + 1) + 8 * v4);
        long long v22 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        id v6 = [v5 characteristics];
        uint64_t v7 = [v6 countByEnumeratingWithState:&v22 objects:v30 count:16];
        if (v7)
        {
          uint64_t v8 = v7;
          uint64_t v9 = *(void *)v23;
          do
          {
            for (uint64_t i = 0; i != v8; ++i)
            {
              if (*(void *)v23 != v9) {
                objc_enumerationMutation(v6);
              }
              id v11 = *(void **)(*((void *)&v22 + 1) + 8 * i);
              id v12 = *(void **)(a1 + 32);
              id v13 = [v11 instanceID];
              LODWORD(v12) = [v12 containsObject:v13];

              if (v12)
              {
                if (*(unsigned char *)(a1 + 56))
                {
                  [v11 setNotificationRegisteredWithRemoteGateway:1];
                  id v14 = [v11 notificationEnabledTime];
                  int v15 = [v14 isEqualToDate:v2];

                  if (v15)
                  {
                    [v3 addObject:v11];
                    [v11 setNotificationEnabledTime:*(void *)(a1 + 48)];
                  }
                }
                else
                {
                  [v11 setNotificationRegisteredWithRemoteGateway:0];
                  id v16 = [*(id *)(a1 + 40) transportInformationInstances];
                  if ([v16 count])
                  {
                    [v21 addObject:v11];
                    [v11 setNotificationEnabledTime:v2];
                  }
                }
              }
            }
            uint64_t v8 = [v6 countByEnumeratingWithState:&v22 objects:v30 count:16];
          }
          while (v8);
        }

        uint64_t v4 = v20 + 1;
      }
      while (v20 + 1 != v19);
      uint64_t v19 = [obj countByEnumeratingWithState:&v26 objects:v31 count:16];
    }
    while (v19);
  }

  if ([v3 count]) {
    [*(id *)(a1 + 40) _notifyClientsWithNotificationChangesForCharacteristics:v3 characteristicErrors:0 enableNotification:1 message:0];
  }
  if ([v21 count]) {
    [*(id *)(a1 + 40) _notifyClientsWithNotificationChangesForCharacteristics:v21 characteristicErrors:0 enableNotification:0 message:0];
  }
}

- (void)resetNotificationEnabledTime
{
  id v3 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __47__HMDHAPAccessory_resetNotificationEnabledTime__block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v3, block);
}

void __47__HMDHAPAccessory_resetNotificationEnabledTime__block_invoke(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = [MEMORY[0x1E4F1C9C8] distantFuture];
  id v3 = [MEMORY[0x1E4F1CA48] array];
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v15 = a1;
  uint64_t v4 = [*(id *)(a1 + 32) services];
  uint64_t v5 = [v4 countByEnumeratingWithState:&v20 objects:v25 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v21;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v21 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void **)(*((void *)&v20 + 1) + 8 * v8);
        long long v16 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v19 = 0u;
        id v10 = [v9 characteristics];
        uint64_t v11 = [v10 countByEnumeratingWithState:&v16 objects:v24 count:16];
        if (v11)
        {
          uint64_t v12 = v11;
          uint64_t v13 = *(void *)v17;
          do
          {
            uint64_t v14 = 0;
            do
            {
              if (*(void *)v17 != v13) {
                objc_enumerationMutation(v10);
              }
              [*(id *)(*((void *)&v16 + 1) + 8 * v14++) setNotificationEnabledTime:v2];
            }
            while (v12 != v14);
            uint64_t v12 = [v10 countByEnumeratingWithState:&v16 objects:v24 count:16];
          }
          while (v12);
        }

        ++v8;
      }
      while (v8 != v6);
      uint64_t v6 = [v4 countByEnumeratingWithState:&v20 objects:v25 count:16];
    }
    while (v6);
  }

  [*(id *)(v15 + 32) _notifyClientsWithNotificationChangesForCharacteristics:v3 characteristicErrors:0 enableNotification:0 message:0];
}

- (BOOL)isClientRegisteredForNotifications
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v2 = [(HMDHAPAccessory *)self services];
  id v3 = (void *)[v2 copy];

  uint64_t v4 = [v3 countByEnumeratingWithState:&v21 objects:v26 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v22;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v22 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v21 + 1) + 8 * i);
        long long v17 = 0u;
        long long v18 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v9 = objc_msgSend(v8, "characteristics", 0);
        id v10 = (void *)[v9 copy];

        uint64_t v11 = [v10 countByEnumeratingWithState:&v17 objects:v25 count:16];
        if (v11)
        {
          uint64_t v12 = v11;
          uint64_t v13 = *(void *)v18;
          while (2)
          {
            for (uint64_t j = 0; j != v12; ++j)
            {
              if (*(void *)v18 != v13) {
                objc_enumerationMutation(v10);
              }
              if ([*(id *)(*((void *)&v17 + 1) + 8 * j) isClientNotificationEnabled])
              {

                BOOL v15 = 1;
                goto LABEL_19;
              }
            }
            uint64_t v12 = [v10 countByEnumeratingWithState:&v17 objects:v25 count:16];
            if (v12) {
              continue;
            }
            break;
          }
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v21 objects:v26 count:16];
      BOOL v15 = 0;
    }
    while (v5);
  }
  else
  {
    BOOL v15 = 0;
  }
LABEL_19:

  return v15;
}

- (void)updateNotificationEnabled:(BOOL)a3 forCharacteristics:(id)a4 onBehalfOf:(id)a5
{
  id v8 = a5;
  uint64_t v9 = (void *)[a4 copy];
  id v10 = [(HMDAccessory *)self workQueue];
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  v13[2] = __75__HMDHAPAccessory_updateNotificationEnabled_forCharacteristics_onBehalfOf___block_invoke;
  v13[3] = &unk_1E6A15B38;
  BOOL v17 = a3;
  id v14 = v9;
  id v15 = v8;
  long long v16 = self;
  id v11 = v8;
  id v12 = v9;
  dispatch_async(v10, v13);
}

uint64_t __75__HMDHAPAccessory_updateNotificationEnabled_forCharacteristics_onBehalfOf___block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  id v2 = *(id *)(a1 + 32);
  uint64_t v3 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v9;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v9 != v5) {
          objc_enumerationMutation(v2);
        }
        objc_msgSend(*(id *)(*((void *)&v8 + 1) + 8 * v6++), "setNotificationEnabled:forClientIdentifier:", *(unsigned __int8 *)(a1 + 56), *(void *)(a1 + 40), (void)v8);
      }
      while (v4 != v6);
      uint64_t v4 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
    }
    while (v4);
  }

  return [*(id *)(a1 + 48) _checkHAPSessionRestore];
}

- (void)_readValueForCharacteristic:(id)a3 hapAccessory:(id)a4 requestMessage:(id)a5
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  long long v11 = [v8 characteristicForHAPAccessory:v9];
  if (!v11)
  {
    id v14 = (void *)MEMORY[0x1D9452090]();
    id v15 = self;
    long long v16 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v17 = HMFGetLogIdentifier();
      long long v18 = [v8 instanceID];
      [v8 characteristicType];
      v19 = id v45 = v10;
      [v9 server];
      long long v20 = v48 = v14;
      long long v21 = [v20 identifier];
      *(_DWORD *)buf = 138544130;
      id v60 = v17;
      __int16 v61 = 2112;
      id v62 = v18;
      __int16 v63 = 2112;
      uint64_t v64 = v19;
      __int16 v65 = 2112;
      long long v66 = v21;
      _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_DEFAULT, "%{public}@Cannot map HMDCharacteristic %@/%@ to a HAPCharacteristic for server %@ for readValue", buf, 0x2Au);

      id v14 = v48;
      id v10 = v45;
    }
    id v12 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v13 = 4;
    goto LABEL_7;
  }
  if (([v8 properties] & 2) == 0)
  {
    id v12 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v13 = 6;
LABEL_7:
    long long v22 = [v12 hmErrorWithCode:v13];
    [v10 respondWithError:v22];

    goto LABEL_13;
  }
  uint64_t v44 = v11;
  char v49 = v9;
  uint64_t v42 = [v10 source];
  id v58 = v8;
  id v46 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v58 count:1];
  BOOL v23 = [(HMDHAPAccessory *)self isPrimary];
  long long v24 = self;
  if (!v23)
  {
    long long v24 = [(HMDHAPAccessory *)self bridge];
  }
  long long v25 = [v10 identifier];
  uint64_t v26 = [v10 clientIdentifier];
  uint64_t v27 = [(HMDAccessory *)self home];
  long long v28 = [v10 userForHome:v27];
  long long v29 = [v28 uuid];
  LOBYTE(v40) = 0;
  id v41 = +[HMDCharacteristicReadWriteLogEvent eventWithCharacteristicsToRead:v46 hmdAccessory:v24 hapAccessory:v49 source:v42 isLocal:1 transactionId:v25 isCached:v40 bundleId:v26 userUUID:v29];

  if (!v23) {
  long long v30 = [(HMDAccessory *)self metricLoggingVendorDetails];
  }
  uint64_t v47 = [v30 manufacturer];
  id v43 = [v30 model];
  id v31 = [(HMDAccessory *)self firmwareVersion];
  uint64_t v32 = [v31 versionString];

  long long v33 = [MEMORY[0x1E4F653F0] currentActivity];
  [(HMDAccessory *)self uuid];

  [v8 instanceID];
  id v9 = v49;
  [v49 linkType];
  BOOL v34 = [v8 value];
  id v35 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __75__HMDHAPAccessory__readValueForCharacteristic_hapAccessory_requestMessage___block_invoke;
  block[3] = &unk_1E6A0B290;
  void block[4] = self;
  id v51 = v8;
  id v52 = v33;
  id v53 = v41;
  id v54 = v34;
  id v55 = v10;
  id v56 = v49;
  id v57 = v44;
  id v36 = v34;
  long long v11 = v44;
  id v37 = v36;
  id v38 = v41;
  id v39 = v33;
  dispatch_async(v35, block);

LABEL_13:
}

void __75__HMDHAPAccessory__readValueForCharacteristic_hapAccessory_requestMessage___block_invoke(id *a1)
{
  int v2 = [a1[4] hasValidCachedValueForCharacteristic:a1[5] shouldLog:1];
  id v3 = a1[4];
  if (v2)
  {
    [a1[4] autoUpdateCachedCountDownCharacteristics:a1[5]];
    id v4 = a1[4];
    id v5 = a1[6];
    [v4 uuid];

    uint64_t v6 = [a1[5] instanceID];

    [a1[4] submitLogEvent:a1[7] error:0];
    id v7 = a1[4];
    id v11 = [a1[5] value];
    [v7 notifyValue:v11 previousValue:a1[8] error:0 forCharacteristic:a1[5] requestMessage:a1[9]];
  }
  else
  {
    id v8 = [a1[5] stateNumber];
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __75__HMDHAPAccessory__readValueForCharacteristic_hapAccessory_requestMessage___block_invoke_2;
    v12[3] = &unk_1E6A0B268;
    id v13 = a1[10];
    id v9 = a1[11];
    id v10 = a1[4];
    id v14 = v9;
    id v15 = v10;
    id v16 = a1[7];
    id v17 = a1[6];
    id v18 = a1[8];
    id v19 = a1[5];
    id v20 = a1[9];
    [v3 _evaluateLocalOperation:2 state:v8 completion:v12];
  }
}

void __75__HMDHAPAccessory__readValueForCharacteristic_hapAccessory_requestMessage___block_invoke_2(uint64_t a1, int a2)
{
  if (a2)
  {
    id v3 = *(void **)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    id v5 = [*(id *)(a1 + 48) workQueue];
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = __75__HMDHAPAccessory__readValueForCharacteristic_hapAccessory_requestMessage___block_invoke_3;
    v9[3] = &unk_1E6A0B240;
    uint64_t v6 = *(void **)(a1 + 56);
    void v9[4] = *(void *)(a1 + 48);
    id v10 = v6;
    id v11 = *(id *)(a1 + 64);
    id v12 = *(id *)(a1 + 72);
    id v13 = *(id *)(a1 + 80);
    id v14 = *(id *)(a1 + 88);
    [v3 readValueForCharacteristic:v4 timeout:v5 completionQueue:v9 completionHandler:0.0];
  }
  else
  {
    id v7 = *(void **)(a1 + 88);
    id v8 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
    [v7 respondWithError:v8];
  }
}

void __75__HMDHAPAccessory__readValueForCharacteristic_hapAccessory_requestMessage___block_invoke_3(uint64_t a1, void *a2, void *a3)
{
  id v14 = a2;
  id v5 = a3;
  [*(id *)(a1 + 32) submitLogEvent:*(void *)(a1 + 40) error:v5];
  [*(id *)(a1 + 32) uuid];

  [v14 instanceID];
  [v5 domain];

  [v5 code];
  id v6 = v5;
  id v7 = v6;
  if (!v6)
  {
    id v11 = *(void **)(a1 + 32);
    id v12 = [v14 value];
    [v11 notifyValue:v12 previousValue:*(void *)(a1 + 56) error:0 forCharacteristic:*(void *)(a1 + 64) requestMessage:*(void *)(a1 + 72)];
    id v8 = 0;
LABEL_12:

    goto LABEL_13;
  }
  id v8 = v6;
  if (([v6 isHMError] & 1) == 0)
  {
    if ([v7 isHAPError])
    {
      unint64_t v9 = [v7 code];
      if (v9 > 0x20) {
        uint64_t v10 = 52;
      }
      else {
        uint64_t v10 = qword_1D54D4320[v9];
      }
    }
    else
    {
      uint64_t v10 = 74;
    }
    id v8 = [MEMORY[0x1E4F28C58] hmErrorWithCode:v10 description:@"Read Failed." reason:0 suggestion:0 underlyingError:v7];
  }
  id v13 = [*(id *)(a1 + 72) responseHandler];

  if (v13)
  {
    id v12 = [*(id *)(a1 + 72) responseHandler];
    ((void (**)(void, void *, void))v12)[2](v12, v8, 0);
    goto LABEL_12;
  }
LABEL_13:
}

- (void)_handleCharacteristicRead:(id)a3
{
  v71[1] = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  id v6 = objc_alloc(MEMORY[0x1E4F653F0]);
  id v7 = NSString;
  id v8 = MEMORY[0x1D94505D0](self, a2);
  unint64_t v9 = [v7 stringWithFormat:@"%@, %s:%ld", v8, "/Library/Caches/com.apple.xbs/Sources/HomeKit_executables_legacy/Sources/homed/HMDHAPAccessory.m", 8559];
  id v63 = (id)[v6 initWithName:v9];

  id v10 = v5;
  id v11 = [v10 messagePayload];
  id v12 = [v11 objectForKeyedSubscript:@"kServiceInstanceID"];
  id v13 = HAPInstanceIDFromValue();

  id v14 = [v10 messagePayload];
  id v15 = [v14 objectForKeyedSubscript:@"kCharacteristicInstanceID"];
  id v16 = HAPInstanceIDFromValue();

  id v17 = [(HMDHAPAccessory *)self findService:v13];
  id v18 = [v17 findCharacteristic:v16];
  id v19 = [(HMDHAPAccessory *)self hapMetadata];
  if (!v18)
  {
    long long v22 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
    [v10 respondWithError:v22];
    goto LABEL_5;
  }
  id v20 = [v18 characteristicType];
  int v21 = [v19 shouldNotCacheCharacteristicOfType:v20];

  if (!v21)
  {
    id v51 = [(HMDAccessory *)self home];
    v71[0] = v18;
    long long v24 = [MEMORY[0x1E4F1C978] arrayWithObjects:v71 count:1];
    if ([v51 requiresUnlockToAccessCharacteristics:v24 withMessage:v10])
    {
      char v25 = [v51 isAccessAllowedForCharacteristicsWithMessage:v10];

      if ((v25 & 1) == 0)
      {
        if ([v10 isEntitledForSPIAccess]) {
          int v26 = 1;
        }
        else {
          int v26 = [v10 isInternal];
        }
        id v36 = (void *)MEMORY[0x1E4F28C58];
        BOOL v37 = +[HMDDeviceCapabilities supportsDeviceLock];
        uint64_t v38 = 10;
        if (v26) {
          uint64_t v38 = 2003;
        }
        if (v37) {
          uint64_t v39 = 82;
        }
        else {
          uint64_t v39 = v38;
        }
        uint64_t v40 = [v36 hmErrorWithCode:v39];
        [v10 respondWithError:v40];

        id v23 = v10;
        goto LABEL_34;
      }
    }
    else
    {
    }
    if (isWatch() && [(HMDAccessory *)self isRemoteAccessEnabled])
    {
      [(HMDHAPAccessory *)self _relayReadFromCharacteristic:v18 toResidentForMessage:v10 viaDevice:0];
      id v23 = v10;
LABEL_34:

      goto LABEL_35;
    }
    objc_initWeak(&location, self);
    id v23 = v10;
    if ([(HMDHAPAccessory *)self canWakeUpViaWoL])
    {
      char v49 = (void *)[v10 mutableCopy];
      v58[0] = MEMORY[0x1E4F143A8];
      v58[1] = 3221225472;
      v58[2] = __45__HMDHAPAccessory__handleCharacteristicRead___block_invoke;
      v58[3] = &unk_1E6A19048;
      id v27 = v10;
      id v59 = v27;
      objc_copyWeak(&v61, &location);
      id v50 = v18;
      id v60 = v50;
      [v49 setResponseHandler:v58];
      id v23 = (id)[v49 copy];

      id v48 = +[HMDCharacteristicRequest requestWithCharacteristic:v50];
      __int16 v70 = v48;
      long long v28 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v70 count:1];
      id v57 = 0;
      BOOL v29 = [(HMDHAPAccessory *)self canProceedWithRequests:v28 suspended:0 error:&v57];
      id v47 = v57;

      if (!v29)
      {
        BOOL v31 = [(HMDHAPAccessory *)self canReturnCachedValueForCharacteristic:v50];
        context = (void *)MEMORY[0x1D9452090]();
        uint64_t v32 = self;
        if (v31)
        {
          HMFGetOSLogHandle();
          long long v33 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
          {
            HMFGetLogIdentifier();
            id v44 = (id)objc_claimAutoreleasedReturnValue();
            BOOL v34 = [(HMDAccessory *)v32 identifier];
            *(_DWORD *)buf = 138543874;
            id v65 = v44;
            __int16 v66 = 2112;
            uint64_t v67 = v34;
            __int16 v68 = 2112;
            id v69 = v50;
            _os_log_impl(&dword_1D49D5000, v33, OS_LOG_TYPE_INFO, "%{public}@Accessory: %@ is suspended and will return the cached value for characteristic: %@", buf, 0x20u);
          }
          id v35 = [v50 value];
          [(HMDHAPAccessory *)v32 notifyValue:&unk_1F2DC7C30 previousValue:v35 error:0 forCharacteristic:v50 requestMessage:v23];
        }
        else
        {
          HMFGetOSLogHandle();
          id v41 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            id v45 = v32;
            HMFGetLogIdentifier();
            id v42 = (id)objc_claimAutoreleasedReturnValue();
            id v43 = [v50 shortDescription];
            *(_DWORD *)buf = 138543618;
            id v65 = v42;
            __int16 v66 = 2112;
            uint64_t v67 = v43;
            _os_log_impl(&dword_1D49D5000, v41, OS_LOG_TYPE_ERROR, "%{public}@Accessory is suspended and should not wake up for read request: %@", buf, 0x16u);

            uint64_t v32 = v45;
          }

          id v35 = [v23 responseHandler];
          ((void (**)(void, id, void))v35)[2](v35, v47, 0);
        }

        objc_destroyWeak(&v61);
        goto LABEL_33;
      }

      objc_destroyWeak(&v61);
    }
    long long v30 = [v18 stateNumber];
    v52[0] = MEMORY[0x1E4F143A8];
    v52[1] = 3221225472;
    v52[2] = __45__HMDHAPAccessory__handleCharacteristicRead___block_invoke_614;
    v52[3] = &unk_1E6A16730;
    objc_copyWeak(&v56, &location);
    id v53 = v18;
    id v23 = v23;
    id v54 = v23;
    id v55 = v63;
    [(HMDHAPAccessory *)self _evaluateLocalOperation:2 state:v30 completion:v52];

    objc_destroyWeak(&v56);
LABEL_33:
    objc_destroyWeak(&location);
    goto LABEL_34;
  }
  long long v22 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
  [v10 respondWithError:v22];
LABEL_5:

  id v23 = v10;
LABEL_35:

  __HMFActivityScopeLeave();
}

void __45__HMDHAPAccessory__handleCharacteristicRead___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v7 = WeakRetained;
  if (WeakRetained) {
    objc_msgSend(WeakRetained, "_wol_processReadWriteResponseForCharacteristic:isRead:error:", *(void *)(a1 + 40), 1, v8);
  }
  [*(id *)(a1 + 32) respondWithPayload:v5 error:v8];
}

void __45__HMDHAPAccessory__handleCharacteristicRead___block_invoke_614(id *a1, int a2)
{
  uint64_t v4 = a1 + 7;
  id WeakRetained = objc_loadWeakRetained(a1 + 7);
  id v6 = WeakRetained;
  if (a2)
  {
    id v7 = [WeakRetained workQueue];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __45__HMDHAPAccessory__handleCharacteristicRead___block_invoke_2;
    block[3] = &unk_1E6A0B940;
    id v18 = a1[4];
    id v19 = v6;
    id v20 = a1[5];
    objc_copyWeak(&v22, v4);
    id v21 = a1[6];
    dispatch_async(v7, block);

    objc_destroyWeak(&v22);
    id v8 = v18;
  }
  else
  {
    if (!WeakRetained)
    {
      id v14 = a1[5];
      id v15 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
      [v14 respondWithError:v15];

      goto LABEL_8;
    }
    [a1[6] begin];
    id v16 = a1[6];
    unint64_t v9 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
    char v10 = [v6 _handleCharacteristicError:v9 read:1 characteristic:a1[4] didRelayMessage:a1[5]];

    if ((v10 & 1) == 0)
    {
      id v12 = a1[4];
      id v11 = a1[5];
      id v13 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
      [v6 submitCharacteristicReadErrorLogEvent:v12 message:v11 error:v13];
    }
    __HMFActivityScopeLeave();
    id v8 = v16;
  }

LABEL_8:
}

void __45__HMDHAPAccessory__handleCharacteristicRead___block_invoke_2(id *a1)
{
  v34[1] = *MEMORY[0x1E4F143B8];
  int v2 = a1 + 4;
  id v23 = [a1[4] value];
  int v3 = [a1[5] hasValidCachedValueForCharacteristic:*v2 shouldLog:1];
  id v4 = a1[5];
  if (v3)
  {
    [a1[5] autoUpdateCachedCountDownCharacteristics:a1[4]];
    uint64_t v21 = [a1[6] source];
    id v5 = [a1[4] accessory];
    if (([v5 isPrimary] & 1) == 0)
    {
      uint64_t v6 = [v5 bridge];

      id v5 = (void *)v6;
    }
    id v7 = a1 + 4;
    v34[0] = a1[4];
    id v22 = [MEMORY[0x1E4F1C978] arrayWithObjects:v34 count:1];
    id v8 = a1 + 6;
    unint64_t v9 = [a1[6] identifier];
    char v10 = [a1[6] clientIdentifier];
    id v11 = a1[6];
    id v13 = a1[5];
    id v12 = a1 + 5;
    id v14 = [v13 home];
    id v15 = [v11 userForHome:v14];
    id v16 = [v15 uuid];
    LOBYTE(v20) = 1;
    id v17 = +[HMDCharacteristicReadWriteLogEvent eventWithCharacteristicsToRead:v22 hmdAccessory:v5 hapAccessory:0 source:v21 isLocal:1 transactionId:v9 isCached:v20 bundleId:v10 userUUID:v16];

    [*v12 submitLogEvent:v17 error:0];
    id v18 = *v12;
    id v19 = [*v7 value];
    [v18 notifyValue:v19 previousValue:v23 error:0 forCharacteristic:*v7 requestMessage:*v8];
  }
  else
  {
    v29[0] = MEMORY[0x1E4F143A8];
    v29[1] = 3221225472;
    v29[2] = __45__HMDHAPAccessory__handleCharacteristicRead___block_invoke_3;
    v29[3] = &unk_1E6A0B218;
    objc_copyWeak(&v33, a1 + 8);
    id v30 = a1[6];
    id v31 = a1[7];
    id v32 = a1[4];
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    v24[2] = __45__HMDHAPAccessory__handleCharacteristicRead___block_invoke_4;
    v24[3] = &unk_1E6A137D0;
    objc_copyWeak(&v28, a1 + 8);
    id v25 = a1[6];
    id v26 = a1[7];
    id v27 = a1[4];
    [v4 _performOperation:2 linkType:0 operationBlock:v29 errorBlock:v24];

    objc_destroyWeak(&v28);
    objc_destroyWeak(&v33);
  }
}

void __45__HMDHAPAccessory__handleCharacteristicRead___block_invoke_3(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    [*(id *)(a1 + 40) begin];
    id v7 = *(id *)(a1 + 40);
    [WeakRetained _readValueForCharacteristic:*(void *)(a1 + 48) hapAccessory:v3 requestMessage:*(void *)(a1 + 32)];
    __HMFActivityScopeLeave();
  }
  else
  {
    id v5 = *(void **)(a1 + 32);
    uint64_t v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v5 respondWithError:v6];
  }
}

void __45__HMDHAPAccessory__handleCharacteristicRead___block_invoke_4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    [*(id *)(a1 + 40) begin];
    id v7 = *(id *)(a1 + 40);
    if (([WeakRetained _handleCharacteristicError:v3 read:1 characteristic:*(void *)(a1 + 48) didRelayMessage:*(void *)(a1 + 32)] & 1) == 0)objc_msgSend(WeakRetained, "submitCharacteristicReadErrorLogEvent:message:error:", *(void *)(a1 + 48), *(void *)(a1 + 32), v3); {
    __HMFActivityScopeLeave();
    }
  }
  else
  {
    id v5 = *(void **)(a1 + 32);
    uint64_t v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v5 respondWithError:v6];
  }
}

- (void)submitCharacteristicReadErrorLogEvent:(id)a3 message:(id)a4 error:(id)a5
{
  v23[1] = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  id v22 = a5;
  id v9 = a4;
  uint64_t v21 = [v9 source];
  char v10 = [v8 accessory];
  if (([v10 isPrimary] & 1) == 0)
  {
    uint64_t v11 = [v10 bridge];

    char v10 = (void *)v11;
  }
  v23[0] = v8;
  id v12 = [MEMORY[0x1E4F1C978] arrayWithObjects:v23 count:1];
  id v13 = [v9 identifier];
  id v14 = [v9 clientIdentifier];
  [(HMDAccessory *)self home];
  v16 = id v15 = self;
  id v17 = [v9 userForHome:v16];

  id v18 = [v17 uuid];
  LOBYTE(v20) = 0;
  id v19 = +[HMDCharacteristicReadWriteLogEvent eventWithCharacteristicsToRead:v12 hmdAccessory:v10 hapAccessory:0 source:v21 isLocal:1 transactionId:v13 isCached:v20 bundleId:v14 userUUID:v18];

  [(HMDAccessory *)v15 submitLogEvent:v19 error:v22];
}

- (void)_parseResponseFromRemotePeer:(id)a3 message:(id)a4 error:(id)a5 characteristic:(id)a6
{
  id v28 = a3;
  id v10 = a4;
  id v11 = a6;
  if (a5)
  {
    [v10 respondWithError:a5];
  }
  else
  {
    id v12 = [v28 objectForKeyedSubscript:@"kCharacteristicValue"];
    id v13 = objc_msgSend(v28, "hmf_numberForKey:", @"kCharacteristicInstanceID");
    id v14 = HAPInstanceIDFromValue();

    id v15 = objc_msgSend(v28, "hmf_numberForKey:", @"kCharacteristicValueUpdateStateNumberKey");
    id v16 = objc_msgSend(v28, "hmf_dateForKey:", @"kCharacteristicValueUpdateTime");
    id v17 = objc_msgSend(v28, "hmf_dataForKey:", @"kCharacteristicNotificationContextKey");
    uint64_t v18 = [v11 instanceID];
    if (!v18) {
      goto LABEL_6;
    }
    id v19 = (void *)v18;
    [v11 instanceID];
    id v27 = self;
    uint64_t v20 = v17;
    uint64_t v21 = v15;
    id v22 = v16;
    v24 = id v23 = v12;
    char v25 = [v14 isEqualToNumber:v24];

    id v12 = v23;
    id v16 = v22;
    id v15 = v21;
    id v17 = v20;

    if (v25)
    {
      id v26 = [v11 value];
      [v11 updateValue:v12 updatedTime:v16 stateNumber:v15 notificationContext:v20];
      [(HMDHAPAccessory *)v27 __updateNotifyingCharacteristicStateNumber:v15];
      [(HMDHAPAccessory *)v27 notifyValue:v12 previousValue:v26 error:0 forCharacteristic:v11 requestMessage:v10];
    }
    else
    {
LABEL_6:
      id v26 = [MEMORY[0x1E4F28C58] hmErrorWithCode:54];
      [v10 respondWithError:v26];
    }
  }
}

- (void)_relayReadFromCharacteristic:(id)a3 toResidentForMessage:(id)a4 viaDevice:(id)a5
{
  v33[1] = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  id v9 = a4;
  id v24 = a5;
  char v25 = [(HMDAccessory *)self home];
  uint64_t v10 = [v9 source];
  v33[0] = v8;
  id v11 = [MEMORY[0x1E4F1C978] arrayWithObjects:v33 count:1];
  id v12 = [v9 identifier];
  id v13 = [v9 clientIdentifier];
  id v14 = [v9 userForHome:v25];
  id v15 = [v14 uuid];
  LOBYTE(v23) = 0;
  id v16 = +[HMDCharacteristicReadWriteLogEvent eventWithCharacteristicsToRead:v11 hmdAccessory:self hapAccessory:0 source:v10 isLocal:0 transactionId:v12 isCached:v23 bundleId:v13 userUUID:v15];

  id v17 = (void *)[v9 mutableCopy];
  [v17 setQualityOfService:33];
  objc_initWeak(&location, self);
  v26[0] = MEMORY[0x1E4F143A8];
  v26[1] = 3221225472;
  v26[2] = __79__HMDHAPAccessory__relayReadFromCharacteristic_toResidentForMessage_viaDevice___block_invoke;
  v26[3] = &unk_1E6A15958;
  id v18 = v16;
  id v27 = v18;
  id v28 = self;
  objc_copyWeak(&v31, &location);
  id v19 = v9;
  id v29 = v19;
  id v20 = v8;
  id v30 = v20;
  [v17 setResponseHandler:v26];
  uint64_t v21 = [(HMDAccessory *)self uuid];
  id v22 = [(HMDAccessory *)self workQueue];
  [v25 redispatchToResidentMessage:v17 target:v21 responseQueue:v22 viaDevice:v24];

  objc_destroyWeak(&v31);
  objc_destroyWeak(&location);
}

void __79__HMDHAPAccessory__relayReadFromCharacteristic_toResidentForMessage_viaDevice___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v11 = a2;
  id v5 = a3;
  uint64_t v6 = [v5 objectForKeyedSubscript:@"kRemoteMessageTransportAttributionKey"];
  objc_msgSend(*(id *)(a1 + 32), "setTransportType:", objc_msgSend(v6, "intValue"));

  [*(id *)(a1 + 40) submitLogEvent:*(void *)(a1 + 32) error:v11];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  id v8 = WeakRetained;
  id v9 = *(void **)(a1 + 48);
  if (WeakRetained)
  {
    [WeakRetained _parseResponseFromRemotePeer:v5 message:*(void *)(a1 + 48) error:v11 characteristic:*(void *)(a1 + 56)];
  }
  else
  {
    uint64_t v10 = [MEMORY[0x1E4F28C58] hmErrorWithCode:54];
    [v9 respondWithError:v10];
  }
}

- (void)_relayWriteToCharacteristic:(id)a3 toResidentForMessage:(id)a4 viaDevice:(id)a5
{
  v39[1] = *MEMORY[0x1E4F143B8];
  id v29 = a3;
  id v8 = a4;
  id v26 = a5;
  uint64_t v9 = [v8 source];
  uint64_t v10 = [v8 messagePayload];
  id v28 = [v10 objectForKeyedSubscript:@"kCharacteristicValue"];

  if (v28)
  {
    v39[0] = v28;
    id v27 = [MEMORY[0x1E4F1C978] arrayWithObjects:v39 count:1];
  }
  else
  {
    id v11 = [MEMORY[0x1E4F1CA98] null];
    uint64_t v38 = v11;
    id v27 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v38 count:1];
  }
  id v12 = [(HMDAccessory *)self home];
  id v37 = v29;
  id v13 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v37 count:1];
  id v14 = [v8 identifier];
  id v15 = [v8 clientIdentifier];
  id v16 = [v8 userForHome:v12];
  id v17 = [v16 uuid];
  id v18 = +[HMDCharacteristicReadWriteLogEvent eventWithCharacteristicsToWrite:v13 hmdAccessory:self hapAccessory:0 source:v9 isTimedWrite:0 isLocal:0 transactionId:v14 bundleId:v15 userUUID:v17 writtenValues:v27];

  id v19 = (void *)[v8 mutableCopy];
  [v19 setQualityOfService:33];
  id v20 = [(HMDHAPAccessory *)self _prepareMessagePayloadForCharacteristicRemoteWrite:v8];
  [v19 setMessagePayload:v20];

  objc_initWeak(&location, self);
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = __78__HMDHAPAccessory__relayWriteToCharacteristic_toResidentForMessage_viaDevice___block_invoke;
  v30[3] = &unk_1E6A15958;
  id v21 = v18;
  id v31 = v21;
  id v32 = self;
  objc_copyWeak(&v35, &location);
  id v22 = v8;
  id v33 = v22;
  id v23 = v29;
  id v34 = v23;
  [v19 setResponseHandler:v30];
  id v24 = [(HMDAccessory *)self uuid];
  char v25 = [(HMDAccessory *)self workQueue];
  [v12 redispatchToResidentMessage:v19 target:v24 responseQueue:v25 viaDevice:v26];

  objc_destroyWeak(&v35);
  objc_destroyWeak(&location);
}

void __78__HMDHAPAccessory__relayWriteToCharacteristic_toResidentForMessage_viaDevice___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v11 = a2;
  id v5 = a3;
  uint64_t v6 = [v5 objectForKeyedSubscript:@"kRemoteMessageTransportAttributionKey"];
  objc_msgSend(*(id *)(a1 + 32), "setTransportType:", objc_msgSend(v6, "intValue"));

  [*(id *)(a1 + 40) submitLogEvent:*(void *)(a1 + 32) error:v11];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  id v8 = WeakRetained;
  uint64_t v9 = *(void **)(a1 + 48);
  if (WeakRetained)
  {
    [WeakRetained _parseResponseFromRemotePeer:v5 message:*(void *)(a1 + 48) error:v11 characteristic:*(void *)(a1 + 56)];
  }
  else
  {
    uint64_t v10 = [MEMORY[0x1E4F28C58] hmErrorWithCode:54];
    [v9 respondWithError:v10];
  }
}

- (void)_handleCharacteristicWrite:(id)a3
{
  v103[1] = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  id v6 = objc_alloc(MEMORY[0x1E4F653F0]);
  id v7 = NSString;
  id v8 = MEMORY[0x1D94505D0](self, a2);
  uint64_t v9 = [v7 stringWithFormat:@"%@, %s:%ld", v8, "/Library/Caches/com.apple.xbs/Sources/HomeKit_executables_legacy/Sources/homed/HMDHAPAccessory.m", 8227];
  id v95 = (id)[v6 initWithName:v9];

  id v10 = v5;
  id v11 = [v10 messagePayload];
  uint64_t v67 = [v11 objectForKeyedSubscript:@"kCharacteristicValue"];

  id v12 = [v10 messagePayload];
  id v13 = [v12 objectForKeyedSubscript:@"kServiceInstanceID"];
  id v14 = HAPInstanceIDFromValue();

  id v15 = [v10 messagePayload];
  id v16 = [v15 objectForKeyedSubscript:@"kCharacteristicInstanceID"];
  id v17 = HAPInstanceIDFromValue();

  [MEMORY[0x1E4F6A278] currentTime];
  id v19 = v18;
  id v20 = [(HMDHAPAccessory *)self findService:v14];
  id v21 = [v20 findCharacteristic:v17];
  __int16 v68 = [(HMDHAPAccessory *)self hapMetadata];
  id v22 = [(HMDAccessory *)self home];
  if (v21)
  {
    char v23 = [v21 properties];
    id v24 = [v21 characteristicType];
    int v25 = [v68 shouldNotCacheCharacteristicOfType:v24];

    if (v25) {
      char v26 = 0;
    }
    else {
      char v26 = v23;
    }
    if ((v26 & 4) == 0)
    {
      if ((v26 & 2) != 0) {
        uint64_t v27 = 5;
      }
      else {
        uint64_t v27 = 48;
      }
      id v28 = [MEMORY[0x1E4F28C58] errorWithDomain:*MEMORY[0x1E4F2D140] code:v27 userInfo:0];
      id v29 = [v10 responseHandler];
      ((void (**)(void, void *, void))v29)[2](v29, v28, 0);

      goto LABEL_11;
    }
    v103[0] = v21;
    id v31 = [MEMORY[0x1E4F1C978] arrayWithObjects:v103 count:1];
    int v32 = [v22 requiresUnlockToAccessCharacteristics:v31 withMessage:v10];

    if (v32)
    {
      uint64_t v33 = [v10 source];
      int v34 = [v22 synchronouslyFetchIsCarPlayConnectedStatus]
          ? [v22 isCarPlayAccessAllowedForCharacteristic:v21 withMessage:v10 fromSource:v33]
          : 0;
      if ((([v22 isAccessAllowedForCharacteristicsWithMessage:v10] | v34) & 1) == 0)
      {
        if ([v10 isEntitledForSPIAccess]) {
          int v36 = 1;
        }
        else {
          int v36 = [v10 isInternal];
        }
        id v37 = (void *)MEMORY[0x1E4F28C58];
        BOOL v38 = +[HMDDeviceCapabilities supportsDeviceLock];
        uint64_t v39 = 10;
        if (v36) {
          uint64_t v39 = 2003;
        }
        if (v38) {
          uint64_t v40 = 82;
        }
        else {
          uint64_t v40 = v39;
        }
        id v41 = [v37 hmErrorWithCode:v40];
        [v10 respondWithError:v41];

        goto LABEL_12;
      }
    }
    id v94 = 0;
    id v35 = [v21 validateValueForWrite:v67 outValue:&v94];
    id v66 = v94;
    if (v35)
    {
      [v10 respondWithError:v35];
      id v30 = v10;
LABEL_43:

      goto LABEL_44;
    }
    if (isWatch() && [(HMDAccessory *)self isRemoteAccessEnabled])
    {
      [(HMDHAPAccessory *)self _relayWriteToCharacteristic:v21 toResidentForMessage:v10 viaDevice:0];
      id v30 = v10;
      id v35 = 0;
      goto LABEL_43;
    }
    if ([v10 isRemote]) {
      [v10 dataForKey:@"kAuthorizationDataKey"];
    }
    else {
    id v65 = [v21 authorizationData];
    }
    objc_initWeak(&location, self);
    id v30 = v10;
    if ([(HMDHAPAccessory *)self canWakeUpViaWoL])
    {
      id v62 = (void *)[v10 mutableCopy];
      v89[0] = MEMORY[0x1E4F143A8];
      v89[1] = 3221225472;
      v89[2] = __46__HMDHAPAccessory__handleCharacteristicWrite___block_invoke;
      v89[3] = &unk_1E6A19048;
      id v42 = v10;
      id v90 = v42;
      objc_copyWeak(&v92, &location);
      id v58 = v21;
      id v91 = v58;
      [v62 setResponseHandler:v89];
      id v30 = (id)[v62 copy];

      id v60 = +[HMDCharacteristicWriteRequest writeRequestWithCharacteristic:v58 value:v67 authorizationData:v65 type:0];
      id v102 = v60;
      id v43 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v102 count:1];
      id v88 = 0;
      BOOL v56 = [(HMDHAPAccessory *)self canProceedWithRequests:v43 suspended:0 error:&v88];
      id v44 = v88;

      if (!v56)
      {
        char v49 = (void *)MEMORY[0x1D9452090]();
        id v57 = self;
        HMFGetOSLogHandle();
        id v50 = (id)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
        {
          id v54 = v49;
          HMFGetLogIdentifier();
          id v55 = (id *)(id)objc_claimAutoreleasedReturnValue();
          id v51 = [(HMDAccessory *)v57 identifier];
          *(_DWORD *)buf = 138543874;
          objc_super v97 = v55;
          __int16 v98 = 2112;
          __int16 v99 = v51;
          __int16 v100 = 2112;
          id v101 = v58;
          _os_log_impl(&dword_1D49D5000, v50, OS_LOG_TYPE_ERROR, "%{public}@Accessory %@ is suspended and should not wake up for write request: %@", buf, 0x20u);

          char v49 = v54;
        }

        id v52 = [v30 responseHandler];
        ((void (**)(void, id, void))v52)[2](v52, v44, 0);

        objc_destroyWeak(&v92);
        goto LABEL_42;
      }

      objc_destroyWeak(&v92);
    }
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __46__HMDHAPAccessory__handleCharacteristicWrite___block_invoke_612;
    aBlock[3] = &unk_1E6A0B1C8;
    objc_copyWeak(&v87, &location);
    id v45 = v30;
    id v82 = v45;
    id v83 = v95;
    id v84 = v67;
    id v46 = v21;
    id v85 = v46;
    id v86 = v65;
    id v63 = _Block_copy(aBlock);
    v76[0] = MEMORY[0x1E4F143A8];
    v76[1] = 3221225472;
    v76[2] = __46__HMDHAPAccessory__handleCharacteristicWrite___block_invoke_2;
    v76[3] = &unk_1E6A0DD20;
    objc_copyWeak(v80, &location);
    id v47 = v45;
    id v77 = v47;
    id v78 = v95;
    id v48 = v46;
    id v79 = v48;
    v80[1] = v19;
    id v61 = _Block_copy(v76);
    id v59 = [v48 stateNumber];
    v69[0] = MEMORY[0x1E4F143A8];
    v69[1] = 3221225472;
    v69[2] = __46__HMDHAPAccessory__handleCharacteristicWrite___block_invoke_3;
    v69[3] = &unk_1E6A0B1F0;
    objc_copyWeak(v75, &location);
    id v30 = v47;
    id v70 = v30;
    id v53 = v63;
    id v73 = v53;
    id v64 = v61;
    id v74 = v64;
    id v71 = v95;
    id v72 = v48;
    v75[1] = v19;
    [(HMDHAPAccessory *)self _evaluateLocalOperation:3 state:v59 completion:v69];

    objc_destroyWeak(v75);
    objc_destroyWeak(v80);

    objc_destroyWeak(&v87);
LABEL_42:
    objc_destroyWeak(&location);

    id v35 = 0;
    goto LABEL_43;
  }
  id v28 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
  [v10 respondWithError:v28];
LABEL_11:

LABEL_12:
  id v30 = v10;
LABEL_44:

  __HMFActivityScopeLeave();
}

void __46__HMDHAPAccessory__handleCharacteristicWrite___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v7 = WeakRetained;
  if (WeakRetained) {
    objc_msgSend(WeakRetained, "_wol_processReadWriteResponseForCharacteristic:isRead:error:", *(void *)(a1 + 40), 0, v8);
  }
  [*(id *)(a1 + 32) respondWithPayload:v5 error:v8];
}

void __46__HMDHAPAccessory__handleCharacteristicWrite___block_invoke_612(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 72));
  if (WeakRetained)
  {
    [*(id *)(a1 + 40) begin];
    id v7 = *(id *)(a1 + 40);
    [WeakRetained _writeValue:*(void *)(a1 + 48) forCharacteristic:*(void *)(a1 + 56) hapAccessory:v3 authorizationData:*(void *)(a1 + 64) message:*(void *)(a1 + 32)];
    __HMFActivityScopeLeave();
  }
  else
  {
    id v5 = *(void **)(a1 + 32);
    id v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v5 respondWithError:v6];
  }
}

void __46__HMDHAPAccessory__handleCharacteristicWrite___block_invoke_2(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    [*(id *)(a1 + 40) begin];
    id v7 = *(id *)(a1 + 40);
    if (([WeakRetained _handleCharacteristicError:v3 read:0 characteristic:*(void *)(a1 + 48) didRelayMessage:*(void *)(a1 + 32)] & 1) == 0)objc_msgSend(WeakRetained, "submitCharacteristicWriteErrorLogEvent:startTime:message:error:", *(void *)(a1 + 48), *(void *)(a1 + 32), v3, *(double *)(a1 + 64)); {
    __HMFActivityScopeLeave();
    }
  }
  else
  {
    id v5 = *(void **)(a1 + 32);
    id v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v5 respondWithError:v6];
  }
}

void __46__HMDHAPAccessory__handleCharacteristicWrite___block_invoke_3(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 72));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    if (a2)
    {
      [WeakRetained _performOperation:3 linkType:0 operationBlock:*(void *)(a1 + 56) errorBlock:*(void *)(a1 + 64)];
    }
    else
    {
      [*(id *)(a1 + 40) begin];
      id v9 = *(id *)(a1 + 40);
      id v8 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
      if (([v5 _handleCharacteristicError:v8 read:0 characteristic:*(void *)(a1 + 48) didRelayMessage:*(void *)(a1 + 32)] & 1) == 0)objc_msgSend(v5, "submitCharacteristicWriteErrorLogEvent:startTime:message:error:", *(void *)(a1 + 48), *(void *)(a1 + 32), v8, *(double *)(a1 + 80)); {

      }
      __HMFActivityScopeLeave();
    }
  }
  else
  {
    id v6 = *(void **)(a1 + 32);
    id v7 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v6 respondWithError:v7];
  }
}

- (void)submitCharacteristicWriteErrorLogEvent:(id)a3 startTime:(double)a4 message:(id)a5 error:(id)a6
{
  v32[1] = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a5;
  id v29 = a6;
  uint64_t v28 = [v11 source];
  id v12 = [v10 accessory];
  if (([v12 isPrimary] & 1) == 0)
  {
    uint64_t v13 = [v12 bridge];

    id v12 = (void *)v13;
  }
  id v14 = [v11 messagePayload];
  uint64_t v15 = [v14 objectForKeyedSubscript:@"kCharacteristicValue"];

  uint64_t v27 = (void *)v15;
  if (v15)
  {
    v32[0] = v15;
    id v16 = [MEMORY[0x1E4F1C978] arrayWithObjects:v32 count:1];
  }
  else
  {
    id v17 = [MEMORY[0x1E4F1CA98] null];
    id v31 = v17;
    id v16 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v31 count:1];
  }
  id v30 = v10;
  id v18 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v30 count:1];
  id v19 = [v11 identifier];
  [v11 clientIdentifier];
  id v20 = v26 = v10;
  [(HMDAccessory *)self home];
  id v21 = v25 = self;
  id v22 = [v11 userForHome:v21];
  char v23 = [v22 uuid];
  id v24 = +[HMDCharacteristicReadWriteLogEvent eventWithStartTime:v18 characteristicsToWrite:v12 hmdAccessory:0 hapAccessory:v28 source:0 isTimedWrite:1 isLocal:a4 transactionId:v19 bundleId:v20 userUUID:v23 writtenValues:v16];

  [(HMDAccessory *)v25 submitLogEvent:v24 error:v29];
}

- (BOOL)_handleCharacteristicError:(id)a3 read:(BOOL)a4 characteristic:(id)a5 didRelayMessage:(id)a6
{
  BOOL v8 = a4;
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a5;
  id v12 = a6;
  if (v10)
  {
    uint64_t v13 = [v10 domain];
    if ([v13 isEqualToString:*MEMORY[0x1E4F2D140]])
    {
      uint64_t v14 = [v10 code];

      if (v14 == 4)
      {
        uint64_t v15 = (void *)MEMORY[0x1E4F1CA60];
        id v16 = [v12 messagePayload];
        id v17 = [v15 dictionaryWithDictionary:v16];

        id v18 = [(HMDAccessory *)self home];
        id v19 = [v18 primaryResident];
        id v20 = [v19 device];
        int v21 = [v20 isCurrentDevice];

        __int16 v68 = v18;
        if (v21)
        {
          id v22 = [NSNumber numberWithBool:1];
          [v17 setObject:v22 forKey:@"kDoNotForwardMessageKey"];

          char v23 = [v12 messagePayload];
          int v24 = objc_msgSend(v23, "hmf_BOOLForKey:", @"kDoNotForwardMessageKey");

          if (v24)
          {
            int v25 = (void (**)(void, void, void))MEMORY[0x1D9452090]();
            char v26 = self;
            uint64_t v27 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
            {
              HMFGetLogIdentifier();
              uint64_t v28 = v64 = v25;
              id v29 = [v11 accessory];
              [v29 uuid];
              id v30 = v69 = v17;
              uint64_t v31 = [v30 UUIDString];
              int v32 = (void *)v31;
              uint64_t v33 = @"write";
              *(_DWORD *)buf = 138543874;
              id v72 = v28;
              __int16 v73 = 2112;
              if (v8) {
                uint64_t v33 = @"read";
              }
              uint64_t v74 = v31;
              __int16 v75 = 2112;
              char v76 = v33;
              _os_log_impl(&dword_1D49D5000, v27, OS_LOG_TYPE_INFO, "%{public}@Accessory %@ is unreachable for %@ operation (DoNotForward set)", buf, 0x20u);

              id v17 = v69;
              int v25 = v64;
            }

            [v12 respondWithError:v10];
            LOBYTE(v25) = 0;
LABEL_41:
            id v18 = v68;
LABEL_42:

            goto LABEL_43;
          }
          id v41 = [v18 homeManager];
          id v42 = [v41 residentMesh];
          int v34 = [v42 bestResidentDeviceForAccessory:self];

          id v70 = v17;
          if (!v34 || [v34 isCurrentDevice])
          {
            int v25 = (void (**)(void, void, void))MEMORY[0x1D9452090]();
            id v43 = self;
            id v44 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
            {
              HMFGetLogIdentifier();
              id v45 = v63 = v25;
              id v46 = [v11 accessory];
              [v46 uuid];
              id v47 = v66 = v34;
              uint64_t v48 = [v47 UUIDString];
              char v49 = (void *)v48;
              id v50 = @"write";
              *(_DWORD *)buf = 138543874;
              id v72 = v45;
              __int16 v73 = 2112;
              if (v8) {
                id v50 = @"read";
              }
              uint64_t v74 = v48;
              __int16 v75 = 2112;
              char v76 = v50;
              _os_log_impl(&dword_1D49D5000, v44, OS_LOG_TYPE_INFO, "%{public}@Accessory %@ is unreachable for %@ operation (no path)", buf, 0x20u);

              id v18 = v68;
              int v34 = v66;

              int v25 = v63;
            }

            [v12 respondWithError:v10];

            LOBYTE(v25) = 0;
            id v17 = v70;
            goto LABEL_42;
          }
        }
        else
        {
          id v70 = v17;
          int v34 = 0;
        }
        id v35 = (void *)MEMORY[0x1D9452090]();
        int v36 = self;
        id v37 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
        {
          id v65 = v35;
          HMFGetLogIdentifier();
          id v38 = (id)objc_claimAutoreleasedReturnValue();
          if (v8) {
            uint64_t v39 = @"read";
          }
          else {
            uint64_t v39 = @"write";
          }
          if (v34)
          {
            id v62 = [v34 identifier];
            uint64_t v40 = [v62 UUIDString];
          }
          else
          {
            uint64_t v40 = @"resident";
          }
          *(_DWORD *)buf = 138543874;
          id v72 = v38;
          __int16 v73 = 2112;
          uint64_t v74 = (uint64_t)v39;
          __int16 v75 = 2112;
          char v76 = v40;
          _os_log_impl(&dword_1D49D5000, v37, OS_LOG_TYPE_INFO, "%{public}@Accessory is unreachable for %@ operation, forwarding to %@.", buf, 0x20u);
          if (v34)
          {
          }
          id v35 = v65;
        }

        id v51 = (void *)MEMORY[0x1E4F65480];
        id v52 = [v12 responseHandler];
        id v53 = [v51 messageWithMessage:v12 messagePayload:v70 responseHandler:v52];

        id v54 = [v11 accessory];
        [v54 uuid];

        [v11 instanceID];
        id v55 = [v34 device];
        if (v8) {
          [(HMDHAPAccessory *)v36 _relayReadFromCharacteristic:v11 toResidentForMessage:v53 viaDevice:v55];
        }
        else {
          [(HMDHAPAccessory *)v36 _relayWriteToCharacteristic:v11 toResidentForMessage:v53 viaDevice:v55];
        }

        if ([(HMDHAPAccessory *)v36 hasBTLELink]
          && [(HMDAccessory *)v36 isRemoteAccessEnabled])
        {
          BOOL v56 = (void *)MEMORY[0x1D9452090]();
          id v57 = v36;
          id v58 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v58, OS_LOG_TYPE_INFO))
          {
            id v59 = HMFGetLogIdentifier();
            [(HMDHAPAccessory *)v57 name];
            id v60 = v67 = v34;
            *(_DWORD *)buf = 138543618;
            id v72 = v59;
            __int16 v73 = 2112;
            uint64_t v74 = (uint64_t)v60;
            _os_log_impl(&dword_1D49D5000, v58, OS_LOG_TYPE_INFO, "%{public}@Accessory %@ is unreachable for write operation, kicking off BTLE scan to update reachability", buf, 0x16u);

            int v34 = v67;
          }

          [v68 btleAccessoryReachabilityProbeTimer:1];
        }

        LOBYTE(v25) = 1;
        id v17 = v70;
        goto LABEL_41;
      }
    }
    else
    {
    }
  }
  int v25 = [v12 responseHandler];

  if (v25)
  {
    int v25 = [v12 responseHandler];
    ((void (**)(void, id, void))v25)[2](v25, v10, 0);

    LOBYTE(v25) = 0;
  }
LABEL_43:

  return (char)v25;
}

- (id)_prepareMessagePayloadForCharacteristicRemoteWrite:(id)a3
{
  id v4 = a3;
  id v5 = [v4 messagePayload];
  id v6 = [v5 objectForKeyedSubscript:@"kServiceInstanceID"];
  id v7 = HAPInstanceIDFromValue();

  BOOL v8 = [v4 messagePayload];
  id v9 = [v8 objectForKeyedSubscript:@"kCharacteristicInstanceID"];
  id v10 = HAPInstanceIDFromValue();

  id v11 = [(HMDHAPAccessory *)self findService:v7];
  id v12 = [v11 findCharacteristic:v10];
  if (v12)
  {
    uint64_t v13 = [v4 messagePayload];
    uint64_t v14 = (void *)[v13 mutableCopy];

    uint64_t v15 = [v12 authorizationData];

    if (v15)
    {
      id v16 = [v12 authorizationData];
      [v14 setObject:v16 forKeyedSubscript:@"kAuthorizationDataKey"];
    }
    if ([v4 BOOLForKey:@"kShortActionKey"]) {
      [v14 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:@"kShortActionKey"];
    }
    id v17 = [(HMDAccessory *)self home];
    id v18 = [v17 currentUser];
    id v19 = [v18 notificationContextHAPIdentifier];
    id v20 = [v12 contextDataForWriteRequestWithIdentifier:v19];

    if (v20) {
      [v14 setObject:v20 forKeyedSubscript:@"kCharacteristicContextDataForWriteKey"];
    }
  }
  else
  {
    uint64_t v14 = 0;
  }

  return v14;
}

- (void)_writeValue:(id)a3 forCharacteristic:(id)a4 hapAccessory:(id)a5 authorizationData:(id)a6 message:(id)a7
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  id v60 = a3;
  id v12 = a4;
  id v13 = a5;
  id v58 = a6;
  id v64 = a7;
  id v65 = v12;
  id v63 = v13;
  id v62 = [v12 characteristicForHAPAccessory:v13];
  if (v62)
  {
    id v61 = [v12 service];
    BOOL v56 = [(HMDHAPAccessory *)self hapMetadata];
    uint64_t v14 = [v12 type];
    uint64_t v15 = [v61 type];
    uint64_t v16 = [v56 requiresTimedWrite:v14 forService:v15];

    unint64_t v17 = [v62 properties];
    id v57 = [(HMDAccessory *)self home];
    id v51 = [v12 value];
    if ([v64 isRemote])
    {
      id v55 = [v64 dataForKey:@"kCharacteristicContextDataForWriteKey"];
    }
    else
    {
      char v26 = [v57 currentUser];
      uint64_t v27 = [v26 notificationContextHAPIdentifier];
      id v55 = [v65 contextDataForWriteRequestWithIdentifier:v27];
    }
    id v59 = [MEMORY[0x1E4F5BCE0] writeRequestTupleForCharacteristic:v62 value:v60 authorizationData:v58 timedWrite:v16 responseValue:(v17 >> 7) & 1 type:0 contextData:v55];
    uint64_t v28 = [v61 accessory];
    id v29 = [v28 uuid];
    [v59 setHmdAccessoryUUID:v29];

    id v30 = [v63 server];
    char v76 = v59;
    uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v76 count:1];
    unsigned int v52 = [v30 requiresTimedWrite:v31];

    uint64_t v32 = [v64 source];
    if (v60)
    {
      id v75 = v60;
      id v54 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v75 count:1];
    }
    else
    {
      uint64_t v33 = [MEMORY[0x1E4F1CA98] null];
      uint64_t v74 = v33;
      id v54 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v74 count:1];
    }
    __int16 v73 = v65;
    int v34 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v73 count:1];
    BOOL v35 = [(HMDHAPAccessory *)self isPrimary];
    int v36 = self;
    if (!v35)
    {
      int v36 = [(HMDHAPAccessory *)self bridge];
    }
    id v37 = [v64 identifier];
    id v38 = [v64 clientIdentifier];
    uint64_t v39 = [v64 userForHome:v57];
    uint64_t v40 = [v39 uuid];
    id v41 = +[HMDCharacteristicReadWriteLogEvent eventWithCharacteristicsToWrite:v34 hmdAccessory:v36 hapAccessory:v63 source:v32 isTimedWrite:v52 isLocal:1 transactionId:v37 bundleId:v38 userUUID:v40 writtenValues:v54];

    if (!v35) {
    id v42 = [(HMDAccessory *)self metricLoggingVendorDetails];
    }
    id v43 = [v42 manufacturer];
    id v53 = [v42 model];
    id v44 = [(HMDAccessory *)self firmwareVersion];
    id v45 = [v44 versionString];

    id v46 = [MEMORY[0x1E4F653F0] currentActivity];
    [(HMDAccessory *)self uuid];

    [v65 instanceID];
    [v63 linkType];
    objc_initWeak((id *)buf, self);
    id v47 = [(HMDAccessory *)self workQueue];
    v66[0] = MEMORY[0x1E4F143A8];
    v66[1] = 3221225472;
    v66[2] = __88__HMDHAPAccessory__writeValue_forCharacteristic_hapAccessory_authorizationData_message___block_invoke;
    v66[3] = &unk_1E6A0B1A0;
    v66[4] = self;
    id v48 = v41;
    id v67 = v48;
    id v49 = v46;
    id v68 = v49;
    id v50 = v51;
    id v69 = v50;
    id v70 = v65;
    id v71 = v64;
    objc_copyWeak(&v72, (id *)buf);
    [v63 writeCharacteristicValue:v59 timeout:v47 completionQueue:v66 completionHandler:0.0];

    objc_destroyWeak(&v72);
    objc_destroyWeak((id *)buf);
  }
  else
  {
    id v18 = (void *)MEMORY[0x1D9452090]();
    id v19 = self;
    id v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = HMFGetLogIdentifier();
      id v22 = [v65 instanceID];
      char v23 = [v65 characteristicType];
      int v24 = [v63 server];
      int v25 = [v24 identifier];
      *(_DWORD *)buf = 138544130;
      id v78 = v21;
      __int16 v79 = 2112;
      id v80 = v22;
      __int16 v81 = 2112;
      id v82 = v23;
      __int16 v83 = 2112;
      id v84 = v25;
      _os_log_impl(&dword_1D49D5000, v20, OS_LOG_TYPE_DEFAULT, "%{public}@Cannot map HMDCharacteristic %@/%@ to a HAPCharacteristic for server %@ for write value", buf, 0x2Au);
    }
    id v61 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
    [v64 respondWithError:v61];
  }
}

void __88__HMDHAPAccessory__writeValue_forCharacteristic_hapAccessory_authorizationData_message___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  [*(id *)(a1 + 32) submitLogEvent:*(void *)(a1 + 40) error:v6];
  id v7 = *(void **)(a1 + 32);
  id v8 = *(id *)(a1 + 48);
  [v7 uuid];

  [v6 domain];
  [v6 code];

  id v9 = v6;
  id v10 = v9;
  if (v9
    && ((id v11 = v9, ([v9 isHMError] & 1) != 0)
     || (![v10 isHAPError]
       ? (uint64_t v13 = 74)
       : (unint64_t v12 = [v10 code], v12 > 0x20)
       ? (uint64_t v13 = 52)
       : (uint64_t v13 = qword_1D54D4320[v12]),
         [MEMORY[0x1E4F28C58] hmErrorWithCode:v13 description:@"Write Failed." reason:0 suggestion:0 underlyingError:v10], id v11 = objc_claimAutoreleasedReturnValue(), v10, v11)))
  {
    uint64_t v14 = [*(id *)(a1 + 72) responseHandler];

    if (v14)
    {
      id WeakRetained = objc_loadWeakRetained((id *)(a1 + 80));
      uint64_t v16 = WeakRetained;
      if (WeakRetained)
      {
        unint64_t v17 = [WeakRetained workQueue];
        v21[0] = MEMORY[0x1E4F143A8];
        v21[1] = 3221225472;
        v21[2] = __88__HMDHAPAccessory__writeValue_forCharacteristic_hapAccessory_authorizationData_message___block_invoke_2;
        v21[3] = &unk_1E6A197C8;
        id v22 = *(id *)(a1 + 72);
        id v23 = v11;
        dispatch_async(v17, v21);
      }
      else
      {
        id v20 = [*(id *)(a1 + 72) responseHandler];
        ((void (**)(void, void *, void))v20)[2](v20, v11, 0);
      }
    }
  }
  else
  {
    id v18 = *(void **)(a1 + 32);
    id v19 = [v5 value];
    [v18 notifyValue:v19 previousValue:*(void *)(a1 + 56) error:0 forCharacteristic:*(void *)(a1 + 64) requestMessage:*(void *)(a1 + 72)];

    id v11 = 0;
  }
}

void __88__HMDHAPAccessory__writeValue_forCharacteristic_hapAccessory_authorizationData_message___block_invoke_2(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) responseHandler];
  (*((void (**)(id, void, void))v2 + 2))(v2, *(void *)(a1 + 40), 0);
}

- (void)_writeCharacteristicValues:(id)a3 hapAccessory:(id)a4 source:(unint64_t)a5 message:(id)a6 logEvent:(id)a7 completionHandler:(id)a8
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  id v68 = a3;
  id v67 = a4;
  id v61 = a6;
  id v63 = a7;
  id v66 = (void (**)(id, void *))a8;
  id v14 = objc_alloc(MEMORY[0x1E4F653F0]);
  uint64_t v15 = NSString;
  id v69 = self;
  uint64_t v16 = MEMORY[0x1D94505D0](self, a2);
  unint64_t v17 = [v15 stringWithFormat:@"%@, %s:%ld", v16, "/Library/Caches/com.apple.xbs/Sources/HomeKit_executables_legacy/Sources/homed/HMDHAPAccessory.m", 7710];
  id v86 = (id)[v14 initWithName:v17];

  id v84 = 0;
  id v85 = 0;
  id v64 = [(HMDHAPAccessory *)self hapCharacteristicWriteRequests:v68 hapAccessory:v67 hmdResponses:&v85 mapping:&v84];
  id v18 = v85;
  id v62 = v84;
  id v65 = v18;
  uint64_t v19 = [v18 count];
  if (v19 == [v68 count])
  {
    id v20 = (void *)MEMORY[0x1D9452090]();
    int v21 = self;
    HMFGetOSLogHandle();
    id v22 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      HMFGetLogIdentifier();
      id v23 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v24 = [v65 count];
      *(_DWORD *)buf = 138543618;
      id v89 = v23;
      __int16 v90 = 2048;
      uint64_t v91 = v24;
      _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_DEFAULT, "%{public}@No HAP characteristics (out of %tu) left to be written to", buf, 0x16u);
    }
    if (v66) {
      v66[2](v66, v65);
    }
  }
  else
  {
    int v25 = [v67 server];
    unsigned int v58 = [v25 requiresTimedWrite:v64];

    char v26 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v68, "count"));
    uint64_t v27 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v68, "count"));
    id v70 = [MEMORY[0x1E4F1CA48] array];
    long long v82 = 0u;
    long long v83 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    id v28 = v68;
    uint64_t v29 = [v28 countByEnumeratingWithState:&v80 objects:v87 count:16];
    if (v29)
    {
      uint64_t v30 = *(void *)v81;
      do
      {
        for (uint64_t i = 0; i != v29; ++i)
        {
          if (*(void *)v81 != v30) {
            objc_enumerationMutation(v28);
          }
          uint64_t v32 = *(void **)(*((void *)&v80 + 1) + 8 * i);
          uint64_t v33 = [v32 characteristic];
          BOOL v34 = v33 == 0;

          if (v34)
          {
            [v70 addObject:v32];
          }
          else
          {
            BOOL v35 = [v32 characteristic];
            [v26 addObject:v35];

            int v36 = [v32 value];
            SEL v37 = v36;
            if (!v36)
            {
              a2 = [MEMORY[0x1E4F1CA98] null];
              SEL v37 = a2;
            }
            [v27 addObject:v37];
            if (!v36) {
          }
            }
        }
        uint64_t v29 = [v28 countByEnumeratingWithState:&v80 objects:v87 count:16];
      }
      while (v29);
    }

    if ([v70 count])
    {
      id v38 = (void *)MEMORY[0x1D9452090]();
      uint64_t v39 = v69;
      HMFGetOSLogHandle();
      uint64_t v40 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        id v41 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        id v89 = v41;
        __int16 v90 = 2112;
        uint64_t v91 = (uint64_t)v70;
        _os_log_impl(&dword_1D49D5000, v40, OS_LOG_TYPE_ERROR, "%{public}@Invalid write requests with missing characteristic: %@", buf, 0x16u);
      }
    }
    if ([v28 count])
    {
      id v42 = [v28 firstObject];
      id v43 = [v42 identifier];
    }
    else
    {
      id v43 = 0;
    }
    [MEMORY[0x1E4F6A278] currentTime];
    uint64_t v45 = v44;
    if (v63)
    {
      id v46 = v63;
      [v46 setIsLocal:1];
      [v46 setIsTimedWrite:v58];
      objc_msgSend(v46, "setLinkType:", objc_msgSend(v67, "linkType"));
    }
    else
    {
      id v47 = [v61 clientIdentifier];
      id v48 = [(HMDAccessory *)v69 home];
      id v49 = [v61 userForHome:v48];
      id v50 = [v49 uuid];
      id v46 = +[HMDCharacteristicReadWriteLogEvent eventWithCharacteristicsToWrite:v26 hmdAccessory:v69 hapAccessory:v67 source:a5 isTimedWrite:v58 isLocal:1 transactionId:v43 bundleId:v47 userUUID:v50 writtenValues:v27];
    }
    id v51 = [(HMDAccessory *)v69 metricLoggingVendorDetails];
    unsigned int v52 = [v51 manufacturer];
    id v60 = [v51 model];
    id v53 = [(HMDAccessory *)v69 firmwareVersion];
    id v54 = [v53 versionString];

    id v55 = v86;
    [(HMDAccessory *)v69 uuid];

    [v26 count];
    [v67 linkType];

    BOOL v56 = [(HMDAccessory *)v69 workQueue];
    v71[0] = MEMORY[0x1E4F143A8];
    v71[1] = 3221225472;
    v71[2] = __101__HMDHAPAccessory__writeCharacteristicValues_hapAccessory_source_message_logEvent_completionHandler___block_invoke;
    v71[3] = &unk_1E6A0B178;
    id v57 = v46;
    uint64_t v79 = v45;
    id v72 = v57;
    __int16 v73 = v69;
    id v74 = v86;
    id v75 = v65;
    id v76 = v62;
    id v77 = v28;
    id v78 = v66;
    [v67 writeCharacteristicValues:v64 timeout:v56 completionQueue:v71 completionHandler:0.0];
  }
  __HMFActivityScopeLeave();
}

void __101__HMDHAPAccessory__writeCharacteristicValues_hapAccessory_source_message_logEvent_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!v6)
  {
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id v8 = v5;
    id v7 = (void *)[v8 countByEnumeratingWithState:&v26 objects:v34 count:16];
    if (v7)
    {
      uint64_t v9 = *(void *)v27;
      while (2)
      {
        for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v27 != v9) {
            objc_enumerationMutation(v8);
          }
          id v11 = *(void **)(*((void *)&v26 + 1) + 8 * i);
          unint64_t v12 = objc_msgSend(v11, "error", (void)v26);

          if (v12)
          {
            id v7 = [v11 error];
            goto LABEL_12;
          }
        }
        id v7 = (void *)[v8 countByEnumeratingWithState:&v26 objects:v34 count:16];
        if (v7) {
          continue;
        }
        break;
      }
    }
LABEL_12:
  }
  objc_msgSend(MEMORY[0x1E4F6A278], "currentTime", (void)v26);
  [*(id *)(a1 + 32) setLocalDurationInMilliseconds:(uint64_t)((v13 - *(double *)(a1 + 88)) * 1000.0)];
  [*(id *)(a1 + 40) submitLogEvent:*(void *)(a1 + 32) error:v7];
  id v14 = *(void **)(a1 + 40);
  id v15 = *(id *)(a1 + 48);
  [v14 uuid];

  [v7 domain];
  [v7 code];

  id v16 = v6;
  unint64_t v17 = v16;
  if (v6)
  {
    id v18 = v16;
    if (([v16 isHMError] & 1) == 0)
    {
      if ([v17 isHAPError])
      {
        unint64_t v19 = [v17 code];
        if (v19 > 0x20) {
          uint64_t v20 = 52;
        }
        else {
          uint64_t v20 = qword_1D54D4320[v19];
        }
      }
      else
      {
        uint64_t v20 = 74;
      }
      id v18 = [MEMORY[0x1E4F28C58] hmErrorWithCode:v20 description:@"Write Failed." reason:0 suggestion:0 underlyingError:v17];
    }
  }
  else
  {
    id v18 = 0;
  }
  [*(id *)(a1 + 40) populateHMDCharacteristicResponses:*(void *)(a1 + 56) hapResponses:v5 mapping:*(void *)(a1 + 64) overallError:v18 requests:*(void *)(a1 + 72)];
  uint64_t v21 = *(void *)(a1 + 80);
  if (v21)
  {
    (*(void (**)(uint64_t, void))(v21 + 16))(v21, *(void *)(a1 + 56));
  }
  else if (v6)
  {
    id v22 = (void *)MEMORY[0x1D9452090]();
    id v23 = *(id *)(a1 + 40);
    uint64_t v24 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      int v25 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      uint64_t v31 = v25;
      __int16 v32 = 2112;
      uint64_t v33 = v17;
      _os_log_impl(&dword_1D49D5000, v24, OS_LOG_TYPE_ERROR, "%{public}@Failed to write values for characteristics: %@", buf, 0x16u);
    }
  }
}

- (id)hapCharacteristicWriteRequests:(id)a3 hapAccessory:(id)a4 hmdResponses:(id *)a5 mapping:(id *)a6
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  id v73 = a4;
  id v64 = [MEMORY[0x1E4F1CA48] array];
  id v65 = [MEMORY[0x1E4F28E10] weakToStrongObjectsMapTable];
  uint64_t v9 = [MEMORY[0x1E4F1CA48] array];
  id v74 = self;
  long long v81 = [(HMDHAPAccessory *)self hapMetadata];
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  id obj = v8;
  uint64_t v10 = [obj countByEnumeratingWithState:&v83 objects:v95 count:16];
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)v84;
    uint64_t v79 = *MEMORY[0x1E4F2D140];
    id v66 = v9;
    uint64_t v69 = *(void *)v84;
    do
    {
      uint64_t v13 = 0;
      uint64_t v70 = v11;
      do
      {
        id v14 = v9;
        if (*(void *)v84 != v12) {
          objc_enumerationMutation(obj);
        }
        id v15 = *(void **)(*((void *)&v83 + 1) + 8 * v13);
        id v16 = [v15 characteristic];
        char v17 = [v16 properties];
        id v18 = [v16 characteristicType];
        int v19 = [v81 shouldNotCacheCharacteristicOfType:v18];

        if (v19) {
          char v20 = 0;
        }
        else {
          char v20 = v17;
        }
        if ((v20 & 4) != 0)
        {
          id v22 = [v15 value];
          id v82 = 0;
          id v23 = [v16 validateValueForWrite:v22 outValue:&v82];
          id v24 = v82;
        }
        else
        {
          if ((v20 & 2) != 0) {
            uint64_t v21 = 5;
          }
          else {
            uint64_t v21 = 48;
          }
          id v23 = [MEMORY[0x1E4F28C58] errorWithDomain:v79 code:v21 userInfo:0];
          id v24 = 0;
        }
        int v25 = v16;
        uint64_t v9 = v14;
        if (!v23)
        {
          long long v26 = [v25 characteristicForHAPAccessory:v73];
          if (v26)
          {
            uint64_t v77 = [v15 authorizationData];
            long long v27 = [(HMDHAPAccessory *)v74 hapMetadata];
            long long v28 = [v25 type];
            long long v29 = [v25 service];
            uint64_t v30 = [v29 type];
            id v75 = v27;
            uint64_t v31 = [v27 requiresTimedWrite:v28 forService:v30];

            id v32 = v15;
            if (([v26 properties] & 0x80) != 0)
            {
            }
            else
            {
              int v33 = [v32 includeResponseValue];

              if (!v33)
              {
                id v71 = v25;
                uint64_t v34 = 0;
                goto LABEL_26;
              }
            }
            if ([v26 supportsWriteWithResponse])
            {
              id v71 = v25;
              uint64_t v34 = 1;
LABEL_26:
              id v42 = (void *)MEMORY[0x1E4F5BCE0];
              BOOL v43 = [v32 requestType] == 1;
              uint64_t v44 = [v32 contextData];
              uint64_t v45 = v26;
              id v46 = v24;
              id v68 = v24;
              id v47 = v26;
              id v48 = (void *)v77;
              id v49 = [v42 writeRequestTupleForCharacteristic:v45 value:v46 authorizationData:v77 timedWrite:v31 responseValue:v34 type:v43 contextData:v44];

              id v50 = [v32 characteristic];
              id v51 = [v50 service];
              unsigned int v52 = [v51 accessory];
              id v53 = [v52 uuid];
              [v49 setHmdAccessoryUUID:v53];

              id v54 = v47;
              id v55 = v47;
              id v24 = v68;
              [v65 setObject:v32 forKey:v55];
              [v64 addObject:v49];

              id v23 = 0;
              uint64_t v9 = v66;
              int v25 = v71;
            }
            else
            {
              BOOL v56 = (void *)MEMORY[0x1D9452090]();
              id v57 = v74;
              unsigned int v58 = HMFGetOSLogHandle();
              if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
              {
                id v59 = HMFGetLogIdentifier();
                *(_DWORD *)buf = 138543618;
                id v88 = v59;
                __int16 v89 = 2112;
                __int16 v90 = v26;
                _os_log_impl(&dword_1D49D5000, v58, OS_LOG_TYPE_ERROR, "%{public}@Cannot use write-response with characteristic %@", buf, 0x16u);
              }
              id v54 = v26;

              id v23 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
              id v48 = (void *)v77;
            }

            uint64_t v12 = v69;
            uint64_t v11 = v70;
            long long v26 = v54;
          }
          else
          {
            uint64_t v35 = (void *)MEMORY[0x1D9452090]();
            int v36 = v74;
            SEL v37 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              id v67 = HMFGetLogIdentifier();
              [v25 instanceID];
              id v38 = v76 = v36;
              [v25 characteristicType];
              uint64_t v39 = v78 = v35;
              [v73 server];
              uint64_t v40 = v72 = v25;
              id v41 = [v40 identifier];
              *(_DWORD *)buf = 138544130;
              id v88 = v67;
              __int16 v89 = 2112;
              __int16 v90 = v38;
              __int16 v91 = 2112;
              uint64_t v92 = v39;
              __int16 v93 = 2112;
              id v94 = v41;
              _os_log_impl(&dword_1D49D5000, v37, OS_LOG_TYPE_DEFAULT, "%{public}@Cannot map HMDCharacteristic %@/%@ to a HAPCharacteristic for server %@ to map write requests", buf, 0x2Au);

              uint64_t v11 = v70;
              int v25 = v72;

              uint64_t v35 = v78;
              int v36 = v76;
              uint64_t v12 = v69;
            }
            id v23 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
            uint64_t v9 = v66;
          }

          if (!v23) {
            goto LABEL_33;
          }
        }
        id v60 = +[HMDCharacteristicResponse responseWithRequest:v15 error:v23];
        [v9 addObject:v60];

LABEL_33:
        ++v13;
      }
      while (v11 != v13);
      uint64_t v11 = [obj countByEnumeratingWithState:&v83 objects:v95 count:16];
    }
    while (v11);
  }

  if (a6) {
    *a6 = v65;
  }
  if (a5) {
    *a5 = v9;
  }

  return v64;
}

- (void)notifyValue:(id)a3 previousValue:(id)a4 error:(id)a5 forCharacteristic:(id)a6 requestMessage:(id)a7
{
  v95[4] = *MEMORY[0x1E4F143B8];
  id v78 = a3;
  id v73 = a4;
  id v77 = a5;
  id v12 = a6;
  id v13 = a7;
  id v76 = [v12 service];
  id v14 = (void *)MEMORY[0x1E4F1CA60];
  v94[0] = @"kServiceInstanceID";
  id v15 = [v76 instanceID];
  v95[0] = v15;
  v94[1] = @"kCharacteristicInstanceID";
  id v16 = [v12 instanceID];
  v95[1] = v16;
  v94[2] = @"kCharacteristicValue";
  id v17 = v78;
  id v18 = v78;
  if (!v78)
  {
    id v18 = [MEMORY[0x1E4F1CA98] null];
    id v17 = 0;
  }
  BOOL v19 = v17 != 0;
  v95[2] = v18;
  v94[3] = @"kCharacteristicValueUpdateTime";
  char v20 = [v12 lastKnownValueUpdateTime];
  v95[3] = v20;
  uint64_t v21 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v95 forKeys:v94 count:4];
  uint64_t v79 = [v14 dictionaryWithDictionary:v21];

  if (!v19) {
  id v72 = [(HMDAccessory *)self home];
  }
  id v22 = [v12 stateNumber];

  if (v22)
  {
    id v23 = [v12 stateNumber];
    [v79 setObject:v23 forKeyedSubscript:@"kCharacteristicValueUpdateStateNumberKey"];
  }
  id v24 = [v12 notificationContext];

  if (v24)
  {
    int v25 = (void *)MEMORY[0x1D9452090]();
    long long v26 = self;
    long long v27 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
    {
      long long v28 = HMFGetLogIdentifier();
      long long v29 = [v12 notificationContext];
      *(_DWORD *)buf = 138543618;
      __int16 v91 = v28;
      __int16 v92 = 2112;
      id v93 = v29;
      _os_log_impl(&dword_1D49D5000, v27, OS_LOG_TYPE_INFO, "%{public}@Setting notification context %@ in message payload", buf, 0x16u);
    }
    uint64_t v30 = [v12 notificationContext];
    [v79 setObject:v30 forKeyedSubscript:@"kCharacteristicNotificationContextKey"];
  }
  if (v77)
  {
    uint64_t v31 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v77 requiringSecureCoding:1 error:0];
    [v79 setObject:v31 forKeyedSubscript:@"kCharacteristicErrorDataKey"];
  }
  objc_initWeak(&location, self);
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = __84__HMDHAPAccessory_notifyValue_previousValue_error_forCharacteristic_requestMessage___block_invoke;
  aBlock[3] = &unk_1E6A17958;
  objc_copyWeak(&v88, &location);
  id v32 = v13;
  id v87 = v32;
  int v33 = (void (**)(void *, id, void *))_Block_copy(aBlock);
  id v34 = v32;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v35 = v34;
  }
  else {
    uint64_t v35 = 0;
  }
  id v74 = v35;

  int v36 = [v34 destination];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    SEL v37 = v36;
  }
  else {
    SEL v37 = 0;
  }
  id v75 = v37;

  int v38 = [v34 isRemote];
  if (v75) {
    int v39 = v38;
  }
  else {
    int v39 = 0;
  }
  if (v39 == 1 && [v74 type] != 2)
  {
    unsigned int v52 = [v75 device];
    id v53 = [v52 version];
    id v54 = [[HMDHomeKitVersion alloc] initWithVersionString:@"3.0"];
    int v55 = [v53 isAtLeastVersion:v54];

    BOOL v56 = (void *)MEMORY[0x1D9452090]();
    id v57 = self;
    if (v55)
    {
      HMFGetOSLogHandle();
      unsigned int v58 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_INFO))
      {
        id v59 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        __int16 v91 = v59;
        __int16 v92 = 2112;
        id v93 = v74;
        _os_log_impl(&dword_1D49D5000, v58, OS_LOG_TYPE_INFO, "%{public}@Preferring to send the response as a response for: %@", buf, 0x16u);
      }
      v33[2](v33, v77, v79);
      int v40 = 1;
    }
    else
    {
      HMFGetOSLogHandle();
      id v60 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
      {
        id v61 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        __int16 v91 = v61;
        __int16 v92 = 2112;
        id v93 = v74;
        _os_log_impl(&dword_1D49D5000, v60, OS_LOG_TYPE_INFO, "%{public}@Preferring to send the response as a notification for: %@", buf, 0x16u);
      }
      id v62 = (void *)[v79 mutableCopy];
      [v62 setObject:MEMORY[0x1E4F1CC38] forKey:@"kIDSMessageIsNotificationKey"];
      id v71 = v62;

      id v63 = [HMDRemoteDeviceMessageDestination alloc];
      id v64 = [(HMDAccessory *)v57 uuid];
      id v65 = [v75 device];
      id v66 = [(HMDRemoteDeviceMessageDestination *)v63 initWithTarget:v64 device:v65];

      id v67 = [[HMDRemoteMessage alloc] initWithName:@"kCharacteristicValueUpdatedNotificationKey" destination:v66 payload:v71 type:2 timeout:1 secure:0.0];
      id v68 = [v34 identifier];
      [(HMDRemoteMessage *)v67 setIdentifier:v68];

      uint64_t v69 = [v72 homeManager];
      uint64_t v70 = [v69 messageDispatcher];
      v83[0] = MEMORY[0x1E4F143A8];
      v83[1] = 3221225472;
      v83[2] = __84__HMDHAPAccessory_notifyValue_previousValue_error_forCharacteristic_requestMessage___block_invoke_566;
      v83[3] = &unk_1E6A17D78;
      long long v85 = v33;
      id v84 = v77;
      [v70 sendMessage:v67 completionHandler:v83];

      int v40 = 1;
      uint64_t v79 = v71;
    }
  }
  else
  {
    int v40 = 0;
  }
  id v41 = [(HMDHAPAccessory *)self hapMetadata];
  id v42 = [v12 type];
  BOOL v43 = [v76 type];
  int v44 = [v41 requiresDeviceUnlock:v42 forService:v43];

  if ((isAppleTV() & v44) != 1 || [v74 isEntitledForSPIAccess])
  {
    id v45 = objc_alloc(MEMORY[0x1E4F65488]);
    id v46 = [(HMDAccessory *)self uuid];
    id v47 = (void *)[v45 initWithTarget:v46];

    id v48 = (void *)[objc_alloc(MEMORY[0x1E4F654B0]) initWithName:@"kCharacteristicValueUpdatedNotificationKey" destination:v47 payload:v79];
    id v49 = [v34 identifier];
    [v48 setIdentifier:v49];

    id v50 = [(HMDHAPAccessory *)self messageSendPolicy];
    [v48 setSendPolicy:v50];

    id v51 = [(HMDAccessory *)self msgDispatcher];
    v80[0] = MEMORY[0x1E4F143A8];
    v80[1] = 3221225472;
    id v80[2] = __84__HMDHAPAccessory_notifyValue_previousValue_error_forCharacteristic_requestMessage___block_invoke_2_567;
    v80[3] = &unk_1E6A0B150;
    char v82 = v40;
    long long v81 = v33;
    [v51 sendMessage:v48 completionHandler:v80];
  }
  if (v78
    && !v77
    && +[HMDCharacteristic value:v78 differentThan:v73])
  {
    [v72 notifyOfChangedCharacteristic:v12 changedByThisDevice:v40 ^ 1u residentShouldNotifyPeers:1 message:v34];
  }

  objc_destroyWeak(&v88);
  objc_destroyWeak(&location);
}

void __84__HMDHAPAccessory_notifyValue_previousValue_error_forCharacteristic_requestMessage___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v8 = [*(id *)(a1 + 32) responseHandler];

    if (v8)
    {
      uint64_t v9 = [WeakRetained workQueue];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __84__HMDHAPAccessory_notifyValue_previousValue_error_forCharacteristic_requestMessage___block_invoke_2;
      block[3] = &unk_1E6A19668;
      id v11 = *(id *)(a1 + 32);
      id v12 = v5;
      id v13 = v6;
      dispatch_async(v9, block);
    }
  }
}

uint64_t __84__HMDHAPAccessory_notifyValue_previousValue_error_forCharacteristic_requestMessage___block_invoke_566(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t __84__HMDHAPAccessory_notifyValue_previousValue_error_forCharacteristic_requestMessage___block_invoke_2_567(uint64_t result)
{
  if (!*(unsigned char *)(result + 40)) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

void __84__HMDHAPAccessory_notifyValue_previousValue_error_forCharacteristic_requestMessage___block_invoke_2(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) responseHandler];
  (*((void (**)(id, void, void))v2 + 2))(v2, *(void *)(a1 + 40), *(void *)(a1 + 48));
}

- (void)runTransactionWithPreferredMediaUserUUID:(id)a3 selectionType:(unint64_t)a4 completion:(id)a5
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  id v9 = a5;
  uint64_t v10 = (void *)MEMORY[0x1D9452090]();
  id v11 = self;
  id v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    id v13 = HMFGetLogIdentifier();
    id v14 = [NSNumber numberWithUnsignedInteger:a4];
    *(_DWORD *)buf = 138543874;
    id v22 = v13;
    __int16 v23 = 2112;
    id v24 = v8;
    __int16 v25 = 2112;
    long long v26 = v14;
    _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_INFO, "%{public}@Run transaction and set preferred media user: %@, type: %@.", buf, 0x20u);
  }
  id v15 = [(HMDHAPAccessory *)v11 transactionWithObjectChangeType:2];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v16 = v15;
  }
  else {
    id v16 = 0;
  }
  id v17 = v16;

  [v17 setPreferredMediaUserUUID:v8];
  id v18 = [NSNumber numberWithUnsignedInteger:a4];
  [v17 setPreferredUserSelectionType:v18];

  id v20 = v17;
  BOOL v19 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v20 count:1];

  [(HMDAccessory *)v11 runTransactionWithModels:v19 label:@"Update preferred media user" completion:v9];
}

- (void)handleUpdatePreferredMediaUser:(id)a3
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    int v44 = v8;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Handling update preferred media user notification", buf, 0xCu);
  }
  id v9 = [(HMDHAPAccessory *)v6 siriEndpointProfile];
  BOOL v10 = v9 == 0;

  if (v10)
  {
    __int16 v25 = (void *)MEMORY[0x1D9452090]();
    long long v26 = v6;
    uint64_t v27 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      long long v28 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      int v44 = v28;
      _os_log_impl(&dword_1D49D5000, v27, OS_LOG_TYPE_ERROR, "%{public}@Cannot set preferred user on accessory that is not siri capable.", buf, 0xCu);
    }
    id v11 = [MEMORY[0x1E4F28C58] hmfErrorWithCode:5];
    [v4 respondWithError:v11];
  }
  else
  {
    id v11 = [v4 numberForKey:*MEMORY[0x1E4F2C4E8]];
    if ([v11 unsignedIntegerValue] == 1)
    {
      id v12 = [v4 uuidForKey:@"kUserUUIDKey"];
      id v13 = [(HMDAccessory *)v6 home];
      id v14 = [v13 userWithUUID:v12];
      BOOL v15 = v14 == 0;

      if (v15)
      {
        int v33 = (void *)MEMORY[0x1D9452090]();
        id v34 = v6;
        uint64_t v35 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          int v36 = HMFGetLogIdentifier();
          SEL v37 = [(HMDAccessory *)v34 home];
          *(_DWORD *)buf = 138543874;
          int v44 = v36;
          __int16 v45 = 2112;
          id v46 = v12;
          __int16 v47 = 2112;
          id v48 = v37;
          _os_log_impl(&dword_1D49D5000, v35, OS_LOG_TYPE_ERROR, "%{public}@Did not find user with uuid %@ in home %@.", buf, 0x20u);
        }
        int v38 = [MEMORY[0x1E4F28C58] hmfErrorWithCode:5];
        [v4 respondWithError:v38];
      }
      else
      {
        id v16 = [(HMDAccessory *)v6 preferredMediaUserUUID];
        int v17 = HMFEqualObjects();

        if (v17
          && ([(HMDAccessory *)v6 preferredMediaUserSelectionTypeNumber],
              (id v18 = objc_claimAutoreleasedReturnValue()) != 0)
          && ([(HMDAccessory *)v6 preferredMediaUserSelectionTypeNumber],
              BOOL v19 = objc_claimAutoreleasedReturnValue(),
              BOOL v20 = [v19 unsignedIntegerValue] == 1,
              v19,
              v18,
              v20))
        {
          uint64_t v21 = (void *)MEMORY[0x1D9452090]();
          id v22 = v6;
          __int16 v23 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
          {
            id v24 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543362;
            int v44 = v24;
            _os_log_impl(&dword_1D49D5000, v23, OS_LOG_TYPE_INFO, "%{public}@User already matches.", buf, 0xCu);
          }
          [v4 respondWithSuccess];
        }
        else
        {
          objc_initWeak((id *)buf, v6);
          v39[0] = MEMORY[0x1E4F143A8];
          v39[1] = 3221225472;
          v39[2] = __50__HMDHAPAccessory_handleUpdatePreferredMediaUser___block_invoke;
          void v39[3] = &unk_1E6A0B128;
          objc_copyWeak(v42, (id *)buf);
          id v40 = v4;
          id v12 = v12;
          id v41 = v12;
          v42[1] = (id)1;
          [(HMDAccessory *)v6 setPreferredMediaUser:v12 selectionType:1 completion:v39];

          objc_destroyWeak(v42);
          objc_destroyWeak((id *)buf);
        }
      }
    }
    else
    {
      long long v29 = (void *)MEMORY[0x1D9452090]();
      uint64_t v30 = v6;
      uint64_t v31 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        id v32 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        int v44 = v32;
        __int16 v45 = 2112;
        id v46 = v11;
        _os_log_impl(&dword_1D49D5000, v31, OS_LOG_TYPE_ERROR, "%{public}@Unexpected selection type %@", buf, 0x16u);
      }
      id v12 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
      [v4 respondWithError:v12];
    }
  }
}

void __50__HMDHAPAccessory_handleUpdatePreferredMediaUser___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = WeakRetained;
  id v7 = HMFGetOSLogHandle();
  id v8 = v7;
  if (v3)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v9 = HMFGetLogIdentifier();
      int v12 = 138543618;
      id v13 = v9;
      __int16 v14 = 2112;
      id v15 = v3;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_ERROR, "%{public}@Failed to update preferred media user, error: %@", (uint8_t *)&v12, 0x16u);
    }
    [*(id *)(a1 + 32) respondWithError:v3];
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      BOOL v10 = HMFGetLogIdentifier();
      id v11 = *(void **)(a1 + 40);
      int v12 = 138543618;
      id v13 = v10;
      __int16 v14 = 2112;
      id v15 = v11;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Updated preferred media user to %@", (uint8_t *)&v12, 0x16u);
    }
    [*(id *)(a1 + 32) respondWithSuccess];
    [v6 postUpdateEventsIfDifferentWithPreferredMediaUUID:*(void *)(a1 + 40) selectionType:*(void *)(a1 + 56)];
  }
}

- (void)routeUpdatePreferredMediaUser:(id)a3
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self primaryResidentMessageRouter];
  id v6 = v5;
  if (v5)
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __49__HMDHAPAccessory_routeUpdatePreferredMediaUser___block_invoke;
    v12[3] = &unk_1E6A17E18;
    void v12[4] = self;
    [v5 routeMessage:v4 localHandler:v12];
  }
  else
  {
    id v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = self;
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      BOOL v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      __int16 v14 = v10;
      __int16 v15 = 2112;
      id v16 = v4;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_ERROR, "%{public}@Primary resident message router is nil. %@", buf, 0x16u);
    }
    id v11 = [MEMORY[0x1E4F28C58] hmfErrorWithCode:5];
    [v4 respondWithError:v11];
  }
}

uint64_t __49__HMDHAPAccessory_routeUpdatePreferredMediaUser___block_invoke(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) handleUpdatePreferredMediaUser:a2];
}

- (void)_handleHomeUserRemovedNotification:(id)a3
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  id v6 = (void *)MEMORY[0x1D9452090]();
  id v7 = self;
  id v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    id v9 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    __int16 v45 = v9;
    __int16 v46 = 2112;
    id v47 = v4;
    _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Handling removed user: %@", buf, 0x16u);
  }
  if (!v4)
  {
    long long v28 = (void *)MEMORY[0x1D9452090]();
    long long v29 = v7;
    uint64_t v30 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      uint64_t v31 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v45 = v31;
      _os_log_impl(&dword_1D49D5000, v30, OS_LOG_TYPE_INFO, "%{public}@Removed user is nil", buf, 0xCu);
    }
    goto LABEL_14;
  }
  BOOL v10 = [(HMDHAPAccessory *)v7 siriEndpointProfile];
  BOOL v11 = v10 == 0;

  if (v11)
  {
    long long v28 = (void *)MEMORY[0x1D9452090]();
    long long v29 = v7;
    uint64_t v30 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      id v32 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v45 = v32;
      _os_log_impl(&dword_1D49D5000, v30, OS_LOG_TYPE_INFO, "%{public}@SiriEndpointProfile is not installed", buf, 0xCu);
    }
LABEL_14:

    goto LABEL_23;
  }
  int v12 = [(HMDAccessory *)v7 home];
  if ([v12 isCurrentDeviceConfirmedPrimaryResident])
  {
    id v13 = [v12 owner];
    id v14 = v4;
    __int16 v15 = [(HMDHAPAccessory *)v7 cachedRemovedUser];
    if (v15)
    {
      id v16 = [(HMDHAPAccessory *)v7 cachedRemovedUser];
      uint64_t v17 = [v16 uuid];
      id v18 = [(HMDAccessory *)v7 preferredMediaUserUUID];
      int v19 = objc_msgSend(v17, "hmf_isEqualToUUID:", v18);

      if (v19)
      {
        BOOL v20 = (void *)MEMORY[0x1D9452090]();
        uint64_t v21 = v7;
        id v22 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
        {
          __int16 v23 = HMFGetLogIdentifier();
          id v24 = [(HMDHAPAccessory *)v21 cachedRemovedUser];
          *(_DWORD *)buf = 138543618;
          __int16 v45 = v23;
          __int16 v46 = 2112;
          id v47 = v24;
          _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_INFO, "%{public}@Current preferred media user is the cached removed user: %@", buf, 0x16u);
        }
        uint64_t v25 = [(HMDHAPAccessory *)v21 cachedRemovedUser];

        id v14 = (id)v25;
      }
    }
    objc_initWeak((id *)buf, v7);
    v40[0] = MEMORY[0x1E4F143A8];
    v40[1] = 3221225472;
    v40[2] = __54__HMDHAPAccessory__handleHomeUserRemovedNotification___block_invoke;
    v40[3] = &unk_1E6A15888;
    objc_copyWeak(&v43, (id *)buf);
    id v26 = v14;
    id v41 = v26;
    id v27 = v13;
    id v42 = v27;
    [(HMDAccessory *)v7 setDefaultPreferredMediaUserIfRemoved:v26 defaultUser:v27 completion:v40];

    objc_destroyWeak(&v43);
    objc_destroyWeak((id *)buf);
  }
  else
  {
    int v33 = [v4 uuid];
    id v34 = [(HMDAccessory *)v7 preferredMediaUserUUID];
    int v35 = objc_msgSend(v33, "hmf_isEqualToUUID:", v34);

    if (v35)
    {
      int v36 = (void *)MEMORY[0x1D9452090]();
      SEL v37 = v7;
      int v38 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
      {
        int v39 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        __int16 v45 = v39;
        __int16 v46 = 2112;
        id v47 = v4;
        _os_log_impl(&dword_1D49D5000, v38, OS_LOG_TYPE_INFO, "%{public}@Current preferred user was removed while there's no confirmed primary resident. Caching removed user: %@.", buf, 0x16u);
      }
      [(HMDHAPAccessory *)v37 setCachedRemovedUser:v4];
    }
  }

LABEL_23:
}

void __54__HMDHAPAccessory__handleHomeUserRemovedNotification___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = WeakRetained;
  id v7 = HMFGetOSLogHandle();
  id v8 = v7;
  if (v3)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v9 = HMFGetLogIdentifier();
      uint64_t v10 = *(void *)(a1 + 32);
      uint64_t v11 = *(void *)(a1 + 40);
      int v16 = 138544130;
      uint64_t v17 = v9;
      __int16 v18 = 2112;
      uint64_t v19 = v10;
      __int16 v20 = 2112;
      uint64_t v21 = v11;
      __int16 v22 = 2112;
      id v23 = v3;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_ERROR, "%{public}@Updated preferred media user %@ to owner: %@ with error: %@", (uint8_t *)&v16, 0x2Au);
    }
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      int v12 = HMFGetLogIdentifier();
      uint64_t v13 = *(void *)(a1 + 32);
      uint64_t v14 = *(void *)(a1 + 40);
      int v16 = 138543874;
      uint64_t v17 = v12;
      __int16 v18 = 2112;
      uint64_t v19 = v13;
      __int16 v20 = 2112;
      uint64_t v21 = v14;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Updated preferred media user %@ to owner: %@", (uint8_t *)&v16, 0x20u);
    }
    [v6 setCachedRemovedUser:0];
    __int16 v15 = [*(id *)(a1 + 40) uuid];
    [v6 postUpdateEventsIfDifferentWithPreferredMediaUUID:v15 selectionType:1];
  }
}

- (void)handleHomeUserRemovedNotification:(id)a3
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    __int16 v15 = v8;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Handling home user removed notification", buf, 0xCu);
  }
  id v9 = [(HMDAccessory *)v6 workQueue];
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = __53__HMDHAPAccessory_handleHomeUserRemovedNotification___block_invoke;
  v11[3] = &unk_1E6A197C8;
  id v12 = v4;
  uint64_t v13 = v6;
  id v10 = v4;
  dispatch_async(v9, v11);
}

void __53__HMDHAPAccessory_handleHomeUserRemovedNotification___block_invoke(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) userInfo];
  id v3 = [v2 objectForKey:@"HMDUserNotificationKey"];

  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v4 = v3;
  }
  else {
    id v4 = 0;
  }
  id v5 = v4;

  [*(id *)(a1 + 40) _handleHomeUserRemovedNotification:v5];
}

- (HMDMessageRouter)primaryResidentMessageRouter
{
  id v2 = [(HMDAccessory *)self home];
  id v3 = [v2 primaryResidentMessageRouter];

  return (HMDMessageRouter *)v3;
}

- (BOOL)_shouldFilterAccessoryProfileForUnentitledClients:(id)a3
{
  id v4 = a3;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    || (v7.receiver = self,
        v7.super_class = (Class)HMDHAPAccessory,
        [(HMDAccessory *)&v7 _shouldFilterAccessoryProfileForUnentitledClients:v4])|| (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)|| (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    char isKindOfClass = 1;
  }
  else
  {
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();
  }

  return isKindOfClass & 1;
}

- (id)_initWithCoder:(id)a3
{
  v134[2] = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  v121.receiver = self;
  v121.super_class = (Class)HMDHAPAccessory;
  id v5 = [(HMDAccessory *)&v121 initWithCoder:v4];
  if (v5)
  {
    if ([v4 containsValueForKey:@"accessoryBridge"])
    {
      id v6 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"accessoryBridge"];
      if (v6) {
        [(HMDAccessory *)v5 setHostAccessory:v6];
      }
    }
    uint64_t v7 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"accessoryIdentifier"];
    uniqueIdentifier = v5->_uniqueIdentifier;
    v5->_uniqueIdentifier = (NSString *)v7;

    uint64_t v9 = +[HMDHAPMetadata getSharedInstance];
    hapMetadata = v5->_hapMetadata;
    v5->_hapMetadata = (HMDHAPMetadata *)v9;

    uint64_t v11 = (NAFuture *)objc_alloc_init(MEMORY[0x1E4F7A0D8]);
    didConfigureCHIPAccessoryServerFuture = v5->_didConfigureCHIPAccessoryServerFuture;
    v5->_didConfigureCHIPAccessoryServerFuture = v11;

    if ([v4 containsValueForKey:@"accessoryPublicKey"]
      && [v4 containsValueForKey:@"accessoryPairingUsername"])
    {
      uint64_t v13 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"accessoryPublicKey"];
      publicKey = v5->_publicKey;
      v5->_publicKey = (NSData *)v13;

      uint64_t v15 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"accessoryPairingUsername"];
      pairingUsername = v5->_pairingUsername;
      v5->_pairingUsername = (NSString *)v15;
    }
    uint64_t v17 = (void *)MEMORY[0x1E4F1CAD0];
    unint64_t v18 = 0x1E4F1C000uLL;
    v134[0] = objc_opt_class();
    v134[1] = objc_opt_class();
    uint64_t v19 = [MEMORY[0x1E4F1C978] arrayWithObjects:v134 count:2];
    __int16 v20 = [v17 setWithArray:v19];

    uint64_t v21 = [v4 decodeObjectOfClasses:v20 forKey:@"identifiersForBridgedAccessories"];
    if (v21) {
      [MEMORY[0x1E4F1CAD0] setWithArray:v21];
    }
    else {
    __int16 v22 = [MEMORY[0x1E4F1CAD0] set];
    }
    objc_storeStrong((id *)&v5->_identifiersForBridgedAccessories, v22);

    id v23 = (void *)MEMORY[0x1E4F1CAD0];
    v133[0] = objc_opt_class();
    v133[1] = objc_opt_class();
    uint64_t v24 = [MEMORY[0x1E4F1C978] arrayWithObjects:v133 count:2];
    uint64_t v25 = [v23 setWithArray:v24];
    uint64_t v26 = [v4 decodeObjectOfClasses:v25 forKey:@"services"];

    unint64_t v120 = (void *)v26;
    [(NSMutableArray *)v5->_services setArray:v26];
    uint64_t v27 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"kAccessoryPrimaryServiceKey"];
    primaryService = v5->_primaryService;
    v5->_primaryService = (HMDService *)v27;

    if ([v4 containsValueForKey:@"HM.bluetoothAddr"])
    {
      long long v29 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"HM.bluetoothAddr"];
      if (v29)
      {
        uint64_t v30 = v20;
        uint64_t v31 = (void *)MEMORY[0x1D9452090]();
        id v32 = v5;
        int v33 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
        {
          id v34 = HMFGetLogIdentifier();
          [v29 formattedString];
          v36 = int v35 = v21;
          *(_DWORD *)buf = 138543618;
          __int16 v125 = v34;
          __int16 v126 = 2112;
          uint64_t v127 = (uint64_t)v36;
          _os_log_impl(&dword_1D49D5000, v33, OS_LOG_TYPE_INFO, "%{public}@Bluetooth address %@", buf, 0x16u);

          uint64_t v21 = v35;
        }

        [(HMDHAPAccessory *)v32 saveBluetoothAddress:v29];
        unint64_t v18 = 0x1E4F1C000uLL;
        __int16 v20 = v30;
      }
    }
    if (objc_msgSend(v4, "containsValueForKey:", @"HM.accessoryTransportInformation", 832))
    {
      SEL v37 = (void *)MEMORY[0x1E4F1CAD0];
      v132[0] = objc_opt_class();
      v132[1] = objc_opt_class();
      int v38 = [MEMORY[0x1E4F1C978] arrayWithObjects:v132 count:2];
      uint64_t v39 = [v37 setWithArray:v38];

      id v40 = [v4 decodeObjectOfClasses:v39 forKey:@"HM.accessoryTransportInformation"];
      id v41 = (void *)MEMORY[0x1D9452090]();
      id v42 = v5;
      id v43 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
      {
        int v44 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        __int16 v125 = v44;
        __int16 v126 = 2112;
        uint64_t v127 = (uint64_t)v40;
        _os_log_impl(&dword_1D49D5000, v43, OS_LOG_TYPE_INFO, "%{public}@adding transportInformationInstances for accessory transportInformationInstances: %@", buf, 0x16u);

        unint64_t v18 = 0x1E4F1C000;
      }

      [v42[57] setArray:v40];
      long long v119 = (void *)v39;
    }
    else
    {
      long long v119 = v20;
      __int16 v45 = v21;
      uint64_t v46 = [v4 decodeIntegerForKey:@"linkType"];
      id v40 = [MEMORY[0x1E4F5BC00] serverIdentifierWithUniqueIdentifier:*(Class *)((char *)&v5->super.super.super.isa + v118)];
      id v47 = [MEMORY[0x1E4F5BC00] instanceIDForUniqueIdentifier:*(Class *)((char *)&v5->super.super.super.isa + v118)];
      uint64_t v48 = [[HMDAccessoryTransportInformation alloc] initWithServerIdentifier:v40 instanceID:v47 linkType:v46];
      uint64_t v49 = (void *)MEMORY[0x1D9452090]();
      id v50 = v5;
      id v51 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
      {
        unsigned int v52 = HMFGetLogIdentifier();
        uint64_t v53 = [(HMDAccessoryTransportInformation *)v48 linkType];
        *(_DWORD *)buf = 138543618;
        __int16 v125 = v52;
        __int16 v126 = 2048;
        uint64_t v127 = v53;
        _os_log_impl(&dword_1D49D5000, v51, OS_LOG_TYPE_INFO, "%{public}@adding transportInformationInstance to accessory for linktype %ld", buf, 0x16u);
      }
      [v50[57] addObject:v48];

      uint64_t v21 = v45;
      unint64_t v18 = 0x1E4F1C000uLL;
    }

    v5->_int64_t communicationProtocol = 0;
    if ([v4 containsValueForKey:@"HAP.communicationProtocol"])
    {
      uint64_t v54 = [v4 decodeIntegerForKey:@"HAP.communicationProtocol"];
      if ((unint64_t)(v54 - 1) <= 1) {
        v5->_int64_t communicationProtocol = v54;
      }
    }
    uint64_t v55 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"accessoryFlagsCodingKey"];
    accessoryFlags = v5->_accessoryFlags;
    v5->_accessoryFlags = (NSNumber *)v55;

    v5->_certificationStatus = 0;
    uint64_t v57 = *MEMORY[0x1E4F2C278];
    if ([v4 containsValueForKey:*MEMORY[0x1E4F2C278]])
    {
      uint64_t v58 = [v4 decodeIntegerForKey:v57];
      if ((unint64_t)(v58 - 1) <= 1) {
        v5->_certificationStatus = v58;
      }
    }
    if ([v4 containsValueForKey:@"HAP.authMethod"])
    {
      uint64_t v59 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"HAP.authMethod"];
      internalEnhancedAuthMethod = v5->_internalEnhancedAuthMethod;
      v5->_internalEnhancedAuthMethod = (NSNumber *)v59;
    }
    if ([v4 containsValueForKey:@"HAP.authMethodConfigNumber"])
    {
      uint64_t v61 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"HAP.authMethodConfigNumber"];
      internalEnhancedAuthConfigNumber = v5->_internalEnhancedAuthConfigNumber;
      v5->_internalEnhancedAuthConfigNumber = (NSNumber *)v61;
    }
    id v63 = (void *)MEMORY[0x1E4F1CAD0];
    v131[0] = objc_opt_class();
    v131[1] = objc_opt_class();
    id v64 = [*(id *)(v18 + 2424) arrayWithObjects:v131 count:2];
    id v65 = [v63 setWithArray:v64];

    uint64_t v66 = [v4 decodeObjectOfClasses:v65 forKey:*MEMORY[0x1E4F2C2D8]];
    targetUUIDs = v5->_targetUUIDs;
    v5->_targetUUIDs = (NSArray *)v66;

    v5->_hardwareSupport = [v4 decodeBoolForKey:*MEMORY[0x1E4F2C848]];
    [(HMDHAPAccessory *)v5 wirelessResumeInit];
    uint64_t v68 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"HM.accessorySetupHash"];
    setupHash = v5->_setupHash;
    v5->_setupHash = (NSData *)v68;

    if ([v4 containsValueForKey:@"accessoryBroadcastKey"])
    {
      uint64_t v70 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"accessoryBroadcastKey"];
      broadcastKey = v5->_broadcastKey;
      v5->_broadcastKey = (NSData *)v70;
    }
    uint64_t v72 = *MEMORY[0x1E4F2C2D0];
    if ([v4 containsValueForKey:*MEMORY[0x1E4F2C2D0]])
    {
      id v73 = (void *)MEMORY[0x1E4F1CAD0];
      v130[0] = objc_opt_class();
      v130[1] = objc_opt_class();
      v130[2] = objc_opt_class();
      id v74 = [*(id *)(v18 + 2424) arrayWithObjects:v130 count:3];
      id v75 = [v73 setWithArray:v74];
      uint64_t v76 = [v4 decodeObjectOfClasses:v75 forKey:v72];
      connectivityInfo = v5->_connectivityInfo;
      v5->_connectivityInfo = (HMFConnectivityInfo *)v76;

      id v78 = (void *)MEMORY[0x1D9452090]();
      uint64_t v79 = v5;
      long long v80 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
      {
        long long v81 = HMFGetLogIdentifier();
        char v82 = v5->_connectivityInfo;
        uint64_t v83 = *(uint64_t *)((char *)&v5->super.super.super.isa + v118);
        *(_DWORD *)buf = 138543874;
        __int16 v125 = v81;
        __int16 v126 = 2112;
        uint64_t v127 = (uint64_t)v82;
        __int16 v128 = 2112;
        uint64_t v129 = v83;
        _os_log_impl(&dword_1D49D5000, v80, OS_LOG_TYPE_DEBUG, "%{public}@Setting connectivityInfo to: %@ for accessory: %@", buf, 0x20u);
      }
      unint64_t v18 = 0x1E4F1C000uLL;
    }
    uint64_t v84 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"HAP.wtcap"];
    wiFiTransportCapabilities = v5->_wiFiTransportCapabilities;
    v5->_wiFiTransportCapabilities = (NSNumber *)v84;

    uint64_t v86 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"HAP.sleepInterval"];
    sleepInterval = v5->_sleepInterval;
    v5->_sleepInterval = (NSNumber *)v86;

    uint64_t v88 = [v4 decodeObjectOfClass:objc_opt_class() forKey:*MEMORY[0x1E4F2C3E0]];
    hasOnboardedForNaturalLighting = v5->_hasOnboardedForNaturalLighting;
    v5->_hasOnboardedForNaturalLighting = (NSNumber *)v88;

    __int16 v90 = (void *)MEMORY[0x1E4F1CAD0];
    v123[0] = objc_opt_class();
    v123[1] = objc_opt_class();
    __int16 v91 = [*(id *)(v18 + 2424) arrayWithObjects:v123 count:2];
    __int16 v92 = [v90 setWithArray:v91];
    id v93 = [v4 decodeObjectOfClasses:v92 forKey:@"HAP.initialServiceTypeUUIDs"];

    uint64_t v94 = objc_msgSend(MEMORY[0x1E4F654E8], "hmf_setOfCachedInstancesForStrings:", v93);
    initialServiceTypeUUIDs = v5->_initialServiceTypeUUIDs;
    v5->_initialServiceTypeUUIDs = (NSSet *)v94;

    uint64_t v96 = [(HMDHAPAccessory *)v5 cameraProfileNotificationSettingsFromCoder:v4];
    cameraProfileNotificationSettings = v5->_cameraProfileNotificationSettings;
    v5->_cameraProfileNotificationSettings = (HMCameraUserNotificationSettings *)v96;

    if ([v4 containsValueForKey:@"HM.needsOnboarding"])
    {
      uint64_t v98 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"HM.needsOnboarding"];
      needsOnboarding = v5->_needsOnboarding;
      v5->_needsOnboarding = (NSNumber *)v98;
    }
    v5->_unint64_t suspendedState = 0;
    uint64_t v100 = *MEMORY[0x1E4F2C828];
    if ([v4 containsValueForKey:*MEMORY[0x1E4F2C828]])
    {
      uint64_t v101 = [v4 decodeIntegerForKey:v100];
      if ((unint64_t)(v101 - 1) <= 2) {
        v5->_unint64_t suspendedState = v101;
      }
    }
    [(HMDAccessory *)v5 decodePreferredMediaUser:v4];
    if ([v4 containsValueForKey:@"HMDSiriEndpointAccessoryCapabiltiesKey"])
    {
      id v102 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"HMDSiriEndpointAccessoryCapabiltiesKey"];
      BOOL v103 = v102;
      if (v102) {
        -[HMDHAPAccessory setSiriEndpointCapabilities:](v5, "setSiriEndpointCapabilities:", [v102 unsignedIntegerValue]);
      }
    }
    if ([v4 containsValueForKey:@"HMDHAPAccessoryAccessCodeCacheCodingKey"])
    {
      uint64_t v104 = (void *)MEMORY[0x1E4F1CAD0];
      v122[0] = objc_opt_class();
      v122[1] = objc_opt_class();
      v122[2] = objc_opt_class();
      uint64_t v105 = [*(id *)(v18 + 2424) arrayWithObjects:v122 count:3];
      __int16 v106 = [v104 setWithArray:v105];
      uint64_t v107 = [v4 decodeObjectOfClasses:v106 forKey:@"HMDHAPAccessoryAccessCodeCacheCodingKey"];
      accessCodeCache = v5->_accessCodeCache;
      v5->_accessCodeCache = (NSMutableDictionary *)v107;
    }
    if ([v4 containsValueForKey:@"HMDHAPAccessoryHasPostedBulletinForAccessCodeOnboardingCodingKey"])v5->_hasPostedBulletinForAccessCodeOnboarding = objc_msgSend(v4, "decodeBoolForKey:", @"HMDHAPAccessoryHasPostedBulletinForAccessCodeOnboardingCodingKey"); {
    if ([v4 containsValueForKey:@"HMDHAPAccessoryHasPostedBulletinForWalletKeyOnboardingCodingKey"])v5->_hasPostedBulletinForWalletKeyOnboarding = objc_msgSend(v4, "decodeBoolForKey:", @"HMDHAPAccessoryHasPostedBulletinForWalletKeyOnboardingCodingKey");
    }
    id v109 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"HMDHAP.chipStorage"];
    if (v109)
    {
      objc_storeStrong((id *)&v5->_chipStorage, v109);
      uint64_t v110 = [v109 nodeID];
      BOOL v111 = (void *)v110;
      if (v110) {
        uint32_t v112 = (void *)v110;
      }
      else {
        uint32_t v112 = &unk_1F2DC7C30;
      }
      objc_storeStrong((id *)&v5->_matterNodeID, v112);

      uint64_t v113 = [v109 vendorID];
      matterVendorID = v5->_matterVendorID;
      v5->_matterVendorID = (NSNumber *)v113;

      uint64_t v115 = [v109 productID];
      matterProductID = v5->_matterProductID;
      v5->_matterProductID = (NSNumber *)v115;

      if (v5->_matterVendorID && v5->_matterProductID) {
        logAndPostNotification(@"HMDAccessoryVendorIDProductIDUpdatedNotification", v5, 0);
      }
    }
  }
  return v5;
}

- (HMDHAPAccessory)initWithCoder:(id)a3
{
  id v4 = a3;
  id v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = (HMDHAPAccessory *)[(HMDHAPAccessory *)self _initWithCoder:v4];

  return v6;
}

- (void)saveBluetoothAddress:(id)a3
{
  id v9 = a3;
  id v4 = [(HMDHAPAccessory *)self transportInformationInstances];
  id v5 = v4;
  if (v4)
  {
    id v6 = [v4 objectAtIndexedSubscript:0];
    uint64_t v7 = [v6 hapAccessory];
    id v8 = v7;
    if (v7) {
      [v7 setBluetoothClassicMacAddress:v9];
    }
  }
}

- (BOOL)shouldConfigureTargetController
{
  id v3 = [(HMDAccessory *)self home];
  int v4 = [v3 isOwnerUser];

  if (!v4) {
    return 0;
  }
  return [(HMDHAPAccessory *)self supportsTargetController];
}

- (id)hmdCharacteristicForInstanceId:(id)a3
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id v5 = [(HMDHAPAccessory *)self services];
  id v6 = (void *)[v5 copy];

  uint64_t v22 = [v6 countByEnumeratingWithState:&v27 objects:v32 count:16];
  if (v22)
  {
    uint64_t v7 = *(void *)v28;
    uint64_t v21 = *(void *)v28;
    do
    {
      for (uint64_t i = 0; i != v22; ++i)
      {
        if (*(void *)v28 != v7) {
          objc_enumerationMutation(v6);
        }
        id v9 = *(void **)(*((void *)&v27 + 1) + 8 * i);
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        id v10 = objc_msgSend(v9, "characteristics", v21);
        uint64_t v11 = (void *)[v10 copy];

        uint64_t v12 = [v11 countByEnumeratingWithState:&v23 objects:v31 count:16];
        if (v12)
        {
          uint64_t v13 = v12;
          uint64_t v14 = *(void *)v24;
          while (2)
          {
            for (uint64_t j = 0; j != v13; ++j)
            {
              if (*(void *)v24 != v14) {
                objc_enumerationMutation(v11);
              }
              uint64_t v16 = *(void **)(*((void *)&v23 + 1) + 8 * j);
              uint64_t v17 = [v16 instanceID];
              char v18 = [v17 isEqual:v4];

              if (v18)
              {
                id v19 = v16;

                goto LABEL_19;
              }
            }
            uint64_t v13 = [v11 countByEnumeratingWithState:&v23 objects:v31 count:16];
            if (v13) {
              continue;
            }
            break;
          }
        }

        uint64_t v7 = v21;
      }
      id v19 = 0;
      uint64_t v22 = [v6 countByEnumeratingWithState:&v27 objects:v32 count:16];
    }
    while (v22);
  }
  else
  {
    id v19 = 0;
  }
LABEL_19:

  return v19;
}

void __121__HMDHAPAccessory__readCharacteristicValues_localOperationRequired_source_message_logEvent_completionHandler_errorBlock___block_invoke_525(uint64_t a1, char a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v4 = (id *)(a1 + 80);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 80));
  [*(id *)(a1 + 32) markWithReason:@"Evaluated"];
  if ((a2 & 1) != 0 || *(unsigned char *)(a1 + 104))
  {
    id v6 = (void *)MEMORY[0x1D9452090]([*(id *)(a1 + 32) markWithReason:@"Resolving link type"]);
    id v7 = WeakRetained;
    id v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      uint64_t v10 = *(void *)(a1 + 40);
      uint64_t v11 = [*(id *)(a1 + 48) shortDescription];
      *(_DWORD *)buf = 138543874;
      long long v26 = v9;
      __int16 v27 = 2112;
      uint64_t v28 = v10;
      __int16 v29 = 2112;
      long long v30 = v11;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Performing a local read on the accessory: %@. %@", buf, 0x20u);
    }
    uint64_t v12 = *(void *)(a1 + 88);
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 3221225472;
    void v17[2] = __121__HMDHAPAccessory__readCharacteristicValues_localOperationRequired_source_message_logEvent_completionHandler_errorBlock___block_invoke_529;
    v17[3] = &unk_1E6A0B0B0;
    objc_copyWeak(v24, v4);
    id v22 = *(id *)(a1 + 64);
    id v18 = *(id *)(a1 + 32);
    id v13 = *(id *)(a1 + 40);
    uint64_t v14 = *(void **)(a1 + 96);
    id v19 = v13;
    v24[1] = v14;
    id v20 = *(id *)(a1 + 48);
    id v21 = *(id *)(a1 + 56);
    id v23 = *(id *)(a1 + 72);
    [v7 _performOperation:v12 linkType:0 operationBlock:v17 errorBlock:*(void *)(a1 + 64)];

    objc_destroyWeak(v24);
  }
  else
  {
    uint64_t v15 = *(void *)(a1 + 64);
    uint64_t v16 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
    (*(void (**)(uint64_t, void *))(v15 + 16))(v15, v16);
  }
}

void __121__HMDHAPAccessory__readCharacteristicValues_localOperationRequired_source_message_logEvent_completionHandler_errorBlock___block_invoke_529(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 80));
  if (WeakRetained)
  {
    objc_msgSend(*(id *)(a1 + 32), "markWithFormat:", @"Reading via accessory: %tu", objc_msgSend(v3, "linkType"));
    [*(id *)(a1 + 32) begin];
    id v7 = *(id *)(a1 + 32);
    [WeakRetained _readCharacteristicValues:*(void *)(a1 + 40) hapAccessory:v3 source:*(void *)(a1 + 88) message:*(void *)(a1 + 48) logEvent:*(void *)(a1 + 56) completionHandler:*(void *)(a1 + 72)];
    __HMFActivityScopeLeave();
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 64);
    if (v5)
    {
      id v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
      (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);
    }
  }
}

- (void)autoUpdateCachedCountDownCharacteristics:(id)a3
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [(HMDHAPAccessory *)self hapMetadata];
  id v6 = [v4 type];
  int v7 = [v5 isSecondsDownCounterCharacteristicType:v6];

  if (v7)
  {
    id v8 = [MEMORY[0x1E4F1C9C8] date];
    id v9 = [v4 lastKnownValueUpdateTime];
    [v8 timeIntervalSinceDate:v9];
    unint64_t v11 = (unint64_t)v10;

    uint64_t v12 = [v4 lastKnownValue];
    unint64_t v13 = [v12 unsignedIntegerValue];

    if (v13 <= v11)
    {
      uint64_t v16 = &unk_1F2DC7C30;
    }
    else
    {
      uint64_t v14 = NSNumber;
      uint64_t v15 = [v4 lastKnownValue];
      uint64_t v16 = objc_msgSend(v14, "numberWithInteger:", objc_msgSend(v15, "unsignedIntegerValue") - v11);

      uint64_t v17 = (void *)MEMORY[0x1D9452090]();
      id v18 = self;
      id v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        id v20 = HMFGetLogIdentifier();
        int v22 = 138543618;
        id v23 = v20;
        __int16 v24 = 2112;
        long long v25 = v16;
        _os_log_impl(&dword_1D49D5000, v19, OS_LOG_TYPE_DEBUG, "%{public}@Auto updating countdown counter value to: %@", (uint8_t *)&v22, 0x16u);
      }
    }
    id v21 = [v4 stateNumber];
    [v4 updateValue:v16 updatedTime:0 stateNumber:v21 notificationContext:0];
  }
}

void __94__HMDHAPAccessory__wakeAccessoryIfNeededForCharacteristicRequests_source_activity_completion___block_invoke(id *a1, void *a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  int v7 = (void *)MEMORY[0x1D9452090]();
  id v8 = a1[4];
  id v9 = HMFGetOSLogHandle();
  double v10 = v9;
  if (v6)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      unint64_t v11 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v21 = v11;
      __int16 v22 = 2112;
      id v23 = v6;
      _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_ERROR, "%{public}@Failed to wake/scan for accessory with error: %@", buf, 0x16u);
    }
    id v12 = a1[4];
    id v13 = a1[5];
    [v12 uuid];

    [v6 domain];
    [v6 code];
  }
  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v14 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v21 = v14;
      _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, "%{public}@Found suspended accessory", buf, 0xCu);
    }
    id v13 = [a1[4] uuid];
  }

  uint64_t v15 = [a1[4] workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __94__HMDHAPAccessory__wakeAccessoryIfNeededForCharacteristicRequests_source_activity_completion___block_invoke_524;
  block[3] = &unk_1E6A113D0;
  id v17 = a1[5];
  id v18 = a1[6];
  BOOL v19 = v6 == 0;
  dispatch_async(v15, block);
}

uint64_t __94__HMDHAPAccessory__wakeAccessoryIfNeededForCharacteristicRequests_source_activity_completion___block_invoke_524(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), 0);
}

void __92__HMDHAPAccessory_readCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_4(uint64_t a1, void *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  id v5 = *(void **)(a1 + 32);
  if (!WeakRetained)
  {
    if (!v5) {
      goto LABEL_20;
    }
LABEL_19:
    [v5 setIsLocal:1];
    [WeakRetained submitLogEvent:*(void *)(a1 + 32) error:v3];
    goto LABEL_20;
  }
  if (v5) {
    goto LABEL_19;
  }
  id v29 = v3;
  id v6 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(*(id *)(a1 + 40), "count"));
  int v7 = [MEMORY[0x1E4F1CA48] array];
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  id v8 = *(id *)(a1 + 40);
  uint64_t v9 = [v8 countByEnumeratingWithState:&v30 objects:v38 count:16];
  if (v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = *(void *)v31;
    do
    {
      for (uint64_t i = 0; i != v10; ++i)
      {
        if (*(void *)v31 != v11) {
          objc_enumerationMutation(v8);
        }
        id v13 = *(void **)(*((void *)&v30 + 1) + 8 * i);
        uint64_t v14 = [v13 characteristic];

        if (v14)
        {
          uint64_t v15 = [v13 characteristic];
          [v6 addObject:v15];
        }
        else
        {
          [v7 addObject:v13];
        }
      }
      uint64_t v10 = [v8 countByEnumeratingWithState:&v30 objects:v38 count:16];
    }
    while (v10);
  }

  id v3 = v29;
  if ([v7 count])
  {
    uint64_t v16 = (void *)MEMORY[0x1D9452090]();
    id v17 = WeakRetained;
    id v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      BOOL v19 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      int v35 = v19;
      __int16 v36 = 2112;
      SEL v37 = v7;
      _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_ERROR, "%{public}@Invalid read requests with missing characteristic: %@", buf, 0x16u);
    }
  }
  uint64_t v28 = *(void *)(a1 + 72);
  id v20 = [*(id *)(a1 + 48) clientIdentifier];
  id v21 = *(void **)(a1 + 48);
  __int16 v22 = [WeakRetained home];
  id v23 = [v21 userForHome:v22];
  uint64_t v24 = [v23 uuid];
  LOBYTE(v27) = 0;
  long long v25 = +[HMDCharacteristicReadWriteLogEvent eventWithCharacteristicsToRead:v6 hmdAccessory:WeakRetained hapAccessory:0 source:v28 isLocal:1 transactionId:0 isCached:v27 bundleId:v20 userUUID:v24];

  [WeakRetained submitLogEvent:v25 error:v29];
LABEL_20:
  uint64_t v26 = [WeakRetained _updatedResponseTuplesForRequests:*(void *)(a1 + 40) error:v3 source:*(void *)(a1 + 72) suspended:*(unsigned __int8 *)(a1 + 80)];
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

- (void)readCharacteristicValues:(id)a3 source:(unint64_t)a4 queue:(id)a5 completionHandler:(id)a6
{
}

- (id)_updatedResponseForRemoteResponse:(id)a3
{
  v23[1] = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [v4 error];
  if (v5
    && (id v6 = (void *)v5,
        BOOL v7 = [(HMDHAPAccessory *)self canWakeViaCustomWoBLE],
        v6,
        v7))
  {
    id v8 = [v4 error];
    uint64_t v9 = [v8 underlyingErrors];
    uint64_t v10 = [v9 firstObject];

    if ([v10 isHMError] && objc_msgSend(v10, "code") == 2400)
    {
      uint64_t v11 = [MEMORY[0x1E4F28C58] hmPrivateErrorWithCode:2401];
      id v12 = (void *)MEMORY[0x1E4F28C58];
      id v13 = [v4 error];
      uint64_t v14 = [v13 code];
      uint64_t v22 = *MEMORY[0x1E4F28A50];
      v23[0] = v11;
      uint64_t v15 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v23 forKeys:&v22 count:1];
      uint64_t v16 = [v12 hmErrorWithCode:v14 userInfo:v15];

      id v17 = [v4 request];
      id v18 = +[HMDCharacteristicResponse responseWithRequest:v17 error:v16];
    }
    else
    {
      id v18 = 0;
    }
  }
  else
  {
    id v18 = 0;
  }
  if (v18) {
    BOOL v19 = v18;
  }
  else {
    BOOL v19 = v4;
  }
  id v20 = v19;

  return v20;
}

- (id)_updatedResponseTuplesForRequests:(id)a3 error:(id)a4 source:(unint64_t)a5 suspended:(BOOL)a6
{
  BOOL v6 = a6;
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  id v9 = a3;
  id v44 = a4;
  uint64_t v10 = [(HMDAccessory *)self home];
  uint64_t v11 = [v10 homeLocation];

  __int16 v45 = self;
  BOOL v43 = 0;
  if ([(HMDAccessory *)self isSuspendCapable] && v6)
  {
    if ([v44 isHMError])
    {
      if (-[HMDHAPAccessory custom1WoBLE](self, "custom1WoBLE") && [v44 code] == 4)
      {
        id v12 = (void *)MEMORY[0x1D9452090]();
        id v13 = self;
        uint64_t v14 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v15 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543362;
          unsigned int v52 = v15;
          _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_DEBUG, "%{public}@Ignoring unreachability error for accessory supporting custom wake on BTLE", buf, 0xCu);
        }
        BOOL v16 = 1;
        goto LABEL_11;
      }
      if ([(HMDHAPAccessory *)self canWakeUpViaWoL])
      {
        BOOL v16 = [v44 code] == 103;
LABEL_11:
        BOOL v43 = v16;
        goto LABEL_13;
      }
    }
    BOOL v43 = 0;
  }
LABEL_13:
  objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v9, "count"));
  id v46 = (id)objc_claimAutoreleasedReturnValue();
  long long v47 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  id obj = v9;
  uint64_t v17 = [obj countByEnumeratingWithState:&v47 objects:v59 count:16];
  unint64_t v19 = a5;
  if (v17)
  {
    uint64_t v20 = v17;
    uint64_t v21 = *(void *)v48;
    BOOL v22 = v11 == 1 && v43;
    uint64_t v42 = *MEMORY[0x1E4F2CE48];
    *(void *)&long long v18 = 138544130;
    long long v39 = v18;
    do
    {
      for (uint64_t i = 0; i != v20; ++i)
      {
        if (*(void *)v48 != v21) {
          objc_enumerationMutation(obj);
        }
        uint64_t v24 = *(void **)(*((void *)&v47 + 1) + 8 * i);
        if (v22
          && ([*(id *)(*((void *)&v47 + 1) + 8 * i) characteristic],
              long long v25 = objc_claimAutoreleasedReturnValue(),
              [v25 type],
              uint64_t v26 = objc_claimAutoreleasedReturnValue(),
              int v27 = [v26 isEqualToString:v42],
              v26,
              v25,
              v27))
        {
          uint64_t v28 = (void *)MEMORY[0x1D9452090]();
          id v29 = v45;
          long long v30 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
          {
            long long v31 = HMFGetLogIdentifier();
            long long v32 = [(HMDAccessory *)v29 identifier];
            *(_DWORD *)buf = v39;
            unsigned int v52 = v31;
            __int16 v53 = 2112;
            uint64_t v54 = &unk_1F2DC7C30;
            __int16 v55 = 2112;
            uint64_t v56 = v42;
            __int16 v57 = 2112;
            uint64_t v58 = v32;
            _os_log_impl(&dword_1D49D5000, v30, OS_LOG_TYPE_INFO, "%{public}@Force setting value: '%@' for characteristic type: %@ of %@ while suspended", buf, 0x2Au);

            unint64_t v19 = a5;
          }

          long long v33 = 0;
          int v34 = 1;
          int v35 = &unk_1F2DC7C30;
        }
        else
        {
          long long v33 = -[HMDHAPAccessory getFullError:source:suspended:](v45, "getFullError:source:suspended:", v44, v19, v43, v39);
          int v34 = 0;
          int v35 = 0;
        }
        __int16 v36 = +[HMDCharacteristicResponse responseWithRequest:error:](HMDCharacteristicResponse, "responseWithRequest:error:", v24, v33, v39);
        if (v34)
        {
          SEL v37 = [v24 characteristic];
          [v37 updateValue:v35 updatedTime:0 stateNumber:0 notificationContext:0];

          [v36 setValue:v35];
        }
        [v46 addObject:v36];
      }
      uint64_t v20 = [obj countByEnumeratingWithState:&v47 objects:v59 count:16];
    }
    while (v20);
  }

  return v46;
}

- (id)getFullError:(id)a3 source:(unint64_t)a4 suspended:(BOOL)a5
{
  v17[1] = *MEMORY[0x1E4F143B8];
  id v7 = a3;
  id v8 = v7;
  if (v7)
  {
    if (a5)
    {
      id v9 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2401];
      if (a4 == 8)
      {
        uint64_t v10 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2400];

        id v9 = (void *)v10;
      }
      uint64_t v16 = *MEMORY[0x1E4F28A50];
      v17[0] = v9;
      uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v17 forKeys:&v16 count:1];
      id v12 = (void *)MEMORY[0x1E4F28C58];
      id v13 = [v8 domain];
      objc_msgSend(v12, "errorWithDomain:code:userInfo:", v13, objc_msgSend(v8, "code"), v11);
      id v14 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      id v14 = v7;
    }
  }
  else
  {
    id v14 = 0;
  }

  return v14;
}

- (void)_writeCharacteristicValues:(id)a3 localOperationRequired:(BOOL)a4 source:(unint64_t)a5 message:(id)a6 completionHandler:(id)a7 logEvent:(id)a8 errorBlock:(id)a9
{
  BOOL v12 = a4;
  id v15 = a3;
  id v16 = a6;
  id v17 = a7;
  id v18 = a8;
  id v19 = a9;
  id v20 = objc_alloc(MEMORY[0x1E4F653F0]);
  uint64_t v21 = NSString;
  BOOL v22 = MEMORY[0x1D94505D0](self, a2);
  id v23 = [v21 stringWithFormat:@"%@, %s:%ld", v22, "/Library/Caches/com.apple.xbs/Sources/HomeKit_executables_legacy/Sources/homed/HMDHAPAccessory.m", 6227];
  uint64_t v24 = (void *)[v20 initWithName:v23];
  id v43 = v24;

  objc_initWeak(&location, self);
  [v24 markWithReason:@"Evaluating"];
  if (v12) {
    uint64_t v25 = 10;
  }
  else {
    uint64_t v25 = 3;
  }
  v33[0] = MEMORY[0x1E4F143A8];
  v33[1] = 3221225472;
  void v33[2] = __122__HMDHAPAccessory__writeCharacteristicValues_localOperationRequired_source_message_completionHandler_logEvent_errorBlock___block_invoke;
  v33[3] = &unk_1E6A0B0D8;
  objc_copyWeak(v40, &location);
  id v26 = v43;
  BOOL v41 = v12;
  id v34 = v26;
  v40[1] = (id)v25;
  id v27 = v19;
  id v38 = v27;
  id v28 = v15;
  id v35 = v28;
  v40[2] = (id)a5;
  id v29 = v16;
  id v36 = v29;
  id v30 = v18;
  id v37 = v30;
  id v31 = v17;
  id v39 = v31;
  [(HMDHAPAccessory *)self _evaluateLocalOperation:3 state:0 completion:v33];

  objc_destroyWeak(v40);
  objc_destroyWeak(&location);
  __HMFActivityScopeLeave();
}

void __122__HMDHAPAccessory__writeCharacteristicValues_localOperationRequired_source_message_completionHandler_logEvent_errorBlock___block_invoke(uint64_t a1, char a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v4 = (id *)(a1 + 80);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 80));
  uint64_t v6 = [*(id *)(a1 + 32) markWithReason:@"Evaluated"];
  if ((a2 & 1) != 0 || *(unsigned char *)(a1 + 104))
  {
    uint64_t v7 = *(void *)(a1 + 88);
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 3221225472;
    void v17[2] = __122__HMDHAPAccessory__writeCharacteristicValues_localOperationRequired_source_message_completionHandler_logEvent_errorBlock___block_invoke_2;
    v17[3] = &unk_1E6A0B0B0;
    objc_copyWeak(v24, v4);
    id v22 = *(id *)(a1 + 64);
    id v18 = *(id *)(a1 + 32);
    id v8 = *(id *)(a1 + 40);
    id v9 = *(void **)(a1 + 96);
    id v19 = v8;
    v24[1] = v9;
    id v20 = *(id *)(a1 + 48);
    id v21 = *(id *)(a1 + 56);
    id v23 = *(id *)(a1 + 72);
    [WeakRetained _performOperation:v7 linkType:0 operationBlock:v17 errorBlock:*(void *)(a1 + 64)];

    objc_destroyWeak(v24);
  }
  else
  {
    uint64_t v10 = (void *)MEMORY[0x1D9452090](v6);
    id v11 = WeakRetained;
    BOOL v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      id v13 = HMFGetLogIdentifier();
      id v14 = [*(id *)(a1 + 48) shortDescription];
      *(_DWORD *)buf = 138543618;
      id v26 = v13;
      __int16 v27 = 2112;
      id v28 = v14;
      _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_DEBUG, "%{public}@Should dispatch accessory to resident. %@", buf, 0x16u);
    }
    uint64_t v15 = *(void *)(a1 + 64);
    id v16 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
    (*(void (**)(uint64_t, void *))(v15 + 16))(v15, v16);
  }
}

void __122__HMDHAPAccessory__writeCharacteristicValues_localOperationRequired_source_message_completionHandler_logEvent_errorBlock___block_invoke_2(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 80));
  if (WeakRetained)
  {
    objc_msgSend(*(id *)(a1 + 32), "markWithFormat:", @"Writing via accessory: %tu", objc_msgSend(v3, "linkType"));
    [*(id *)(a1 + 32) begin];
    id v7 = *(id *)(a1 + 32);
    [WeakRetained _writeCharacteristicValues:*(void *)(a1 + 40) hapAccessory:v3 source:*(void *)(a1 + 88) message:*(void *)(a1 + 48) logEvent:*(void *)(a1 + 56) completionHandler:*(void *)(a1 + 72)];
    __HMFActivityScopeLeave();
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 64);
    if (v5)
    {
      uint64_t v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
      (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);
    }
  }
}

- (void)_writeCharacteristicValues:(id)a3 localOperationRequired:(BOOL)a4 source:(unint64_t)a5 completionHandler:(id)a6 errorBlock:(id)a7
{
}

- (void)wakeOrScanForSuspendedAccessoryForRequests:(id)a3 source:(unint64_t)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a5;
  if ([(HMDHAPAccessory *)self isPoweringOn]
    || [(HMDHAPAccessory *)self canWakeBasedOnCharacteristicRequests:v8])
  {
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    void v18[2] = __80__HMDHAPAccessory_wakeOrScanForSuspendedAccessoryForRequests_source_completion___block_invoke;
    v18[3] = &unk_1E6A17D78;
    uint64_t v10 = &v19;
    v18[4] = self;
    id v19 = v9;
    id v11 = v9;
    [(HMDHAPAccessory *)self wirelessPowerOn:v18];
  }
  else
  {
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __80__HMDHAPAccessory_wakeOrScanForSuspendedAccessoryForRequests_source_completion___block_invoke_500;
    v14[3] = &unk_1E6A0B088;
    void v14[4] = self;
    uint64_t v10 = &v15;
    id v12 = v8;
    id v16 = v9;
    unint64_t v17 = a4;
    id v15 = v12;
    id v13 = v9;
    [(HMDHAPAccessory *)self initiateScan:v14];
  }
}

void __80__HMDHAPAccessory_wakeOrScanForSuspendedAccessoryForRequests_source_completion___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    int v8 = 138543618;
    id v9 = v7;
    __int16 v10 = 2112;
    id v11 = v3;
    _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_INFO, "%{public}@Wireless power on completed with error: %@", (uint8_t *)&v8, 0x16u);
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void __80__HMDHAPAccessory_wakeOrScanForSuspendedAccessoryForRequests_source_completion___block_invoke_500(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = HMFGetLogIdentifier();
    int v12 = 138543618;
    id v13 = v7;
    __int16 v14 = 2112;
    id v15 = v3;
    _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_INFO, "%{public}@Scanning for suspended accessory completed with error: %@", (uint8_t *)&v12, 0x16u);
  }
  if (v3
    || (objc_msgSend(*(id *)(a1 + 40), "na_any:", &__block_literal_global_504) & 1) != 0
    || ([*(id *)(a1 + 32) isReachable] & 1) != 0)
  {
    int v8 = 0;
  }
  else
  {
    id v9 = *(void **)(a1 + 32);
    uint64_t v10 = *(void *)(a1 + 40);
    id v11 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
    int v8 = [v9 _updatedResponseTuplesForRequests:v10 error:v11 source:*(void *)(a1 + 56) suspended:1];
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

uint64_t __80__HMDHAPAccessory_wakeOrScanForSuspendedAccessoryForRequests_source_completion___block_invoke_501(uint64_t a1, void *a2)
{
  id v2 = a2;
  objc_opt_class();
  uint64_t v3 = objc_opt_isKindOfClass() & (v2 != 0);

  return v3;
}

- (void)writeCharacteristicValues:(id)a3 source:(unint64_t)a4 message:(id)a5 queue:(id)a6 logEvent:(id)a7 completionHandler:(id)a8
{
  id v15 = a3;
  id v16 = a5;
  id v17 = a6;
  id v18 = a7;
  id v19 = a8;
  id v20 = objc_alloc(MEMORY[0x1E4F653F0]);
  id v21 = NSString;
  id v22 = MEMORY[0x1D94505D0](self, a2);
  id v23 = [v21 stringWithFormat:@"%@, %s:%ld", v22, "/Library/Caches/com.apple.xbs/Sources/HomeKit_executables_legacy/Sources/homed/HMDHAPAccessory.m", 6059];
  id v43 = (id)[v20 initWithName:v23];

  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke;
  aBlock[3] = &unk_1E6A17640;
  id v40 = v43;
  id v24 = v19;
  id v42 = v24;
  id v25 = v17;
  id v41 = v25;
  id v26 = _Block_copy(aBlock);
  __int16 v27 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_3;
  block[3] = &unk_1E6A15BD8;
  void block[4] = self;
  id v33 = v18;
  id v34 = v15;
  id v35 = v16;
  id v37 = v26;
  unint64_t v38 = a4;
  id v36 = v43;
  id v28 = v26;
  id v29 = v16;
  id v30 = v15;
  id v31 = v18;
  dispatch_async(v27, block);

  __HMFActivityScopeLeave();
}

void __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  [*(id *)(a1 + 32) begin];
  id v4 = *(void (***)(void, void))(a1 + 48);
  if (v4)
  {
    id v5 = *(NSObject **)(a1 + 40);
    if (v5)
    {
      uint64_t v6 = MEMORY[0x1E4F143A8];
      uint64_t v7 = 3221225472;
      int v8 = __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_2;
      id v9 = &unk_1E6A19530;
      id v11 = v4;
      id v10 = v3;
      dispatch_async(v5, &v6);
    }
    else
    {
      ((void (**)(void, id))v4)[2](v4, v3);
    }
  }
  objc_msgSend(*(id *)(a1 + 32), "end", v6, v7, v8, v9);
  [*(id *)(a1 + 32) invalidate];
}

void __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_3(uint64_t a1)
{
  objc_initWeak(&location, *(id *)(a1 + 32));
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_4;
  aBlock[3] = &unk_1E6A0B060;
  objc_copyWeak(v10, &location);
  id v6 = *(id *)(a1 + 40);
  id v2 = *(id *)(a1 + 48);
  id v3 = *(void **)(a1 + 80);
  id v7 = v2;
  v10[1] = v3;
  id v8 = *(id *)(a1 + 56);
  id v9 = *(id *)(a1 + 72);
  id v4 = _Block_copy(aBlock);
  [*(id *)(a1 + 32) _wakeAccessoryIfNeededForCharacteristicRequests:*(void *)(a1 + 48) source:*(void *)(a1 + 80) activity:*(void *)(a1 + 64) completion:v4];

  objc_destroyWeak(v10);
  objc_destroyWeak(&location);
}

void __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_4(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_5;
  aBlock[3] = &unk_1E6A0B038;
  objc_copyWeak(v23, (id *)(a1 + 64));
  id v19 = *(id *)(a1 + 32);
  id v7 = *(id *)(a1 + 40);
  id v8 = *(void **)(a1 + 72);
  id v20 = v7;
  v23[1] = v8;
  id v21 = *(id *)(a1 + 48);
  char v24 = a2;
  id v22 = *(id *)(a1 + 56);
  id v9 = _Block_copy(aBlock);
  id v10 = v9;
  if (v5)
  {
    (*((void (**)(void *, id))v9 + 2))(v9, v5);
  }
  else
  {
    objc_msgSend(WeakRetained, "_wol_updateWakingViaCharacteristicForWriteRequests:", *(void *)(a1 + 40));
    uint64_t v12 = MEMORY[0x1E4F143A8];
    uint64_t v13 = 3221225472;
    __int16 v14 = __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_498;
    id v15 = &unk_1E6A18FF8;
    objc_copyWeak(&v17, (id *)(a1 + 64));
    id v16 = *(id *)(a1 + 56);
    id v11 = _Block_copy(&v12);
    objc_msgSend(WeakRetained, "_writeCharacteristicValues:localOperationRequired:source:message:completionHandler:logEvent:errorBlock:", *(void *)(a1 + 40), 0, *(void *)(a1 + 72), *(void *)(a1 + 48), v11, *(void *)(a1 + 32), v10, v12, v13, v14, v15);

    objc_destroyWeak(&v17);
  }

  objc_destroyWeak(v23);
}

void __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_5(uint64_t a1, void *a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  id v5 = *(void **)(a1 + 32);
  if (!WeakRetained)
  {
    if (!v5) {
      goto LABEL_23;
    }
LABEL_22:
    [v5 setIsLocal:1];
    [WeakRetained submitLogEvent:*(void *)(a1 + 32) error:v3];
    goto LABEL_23;
  }
  if (v5) {
    goto LABEL_22;
  }
  id v31 = v3;
  long long v32 = WeakRetained;
  id v6 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(*(id *)(a1 + 40), "count"));
  id v7 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v6, "count"));
  id v8 = [MEMORY[0x1E4F1CA48] array];
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  id v9 = *(id *)(a1 + 40);
  uint64_t v10 = [v9 countByEnumeratingWithState:&v33 objects:v41 count:16];
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)v34;
    do
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        if (*(void *)v34 != v12) {
          objc_enumerationMutation(v9);
        }
        __int16 v14 = *(void **)(*((void *)&v33 + 1) + 8 * i);
        id v15 = [v14 characteristic];

        if (v15)
        {
          id v16 = [v14 characteristic];
          [v6 addObject:v16];

          id v17 = [v14 value];
          if (v17)
          {
            [v7 addObject:v17];
          }
          else
          {
            id v18 = [MEMORY[0x1E4F1CA98] null];
            [v7 addObject:v18];
          }
        }
        else
        {
          [v8 addObject:v14];
        }
      }
      uint64_t v11 = [v9 countByEnumeratingWithState:&v33 objects:v41 count:16];
    }
    while (v11);
  }

  id v3 = v31;
  if ([v8 count])
  {
    id v19 = (void *)MEMORY[0x1D9452090]();
    id v20 = v32;
    id v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      id v22 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      unint64_t v38 = v22;
      __int16 v39 = 2112;
      id v40 = v8;
      _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_ERROR, "%{public}@Invalid write requests with missing characteristic: %@", buf, 0x16u);
    }
  }
  uint64_t v30 = *(void *)(a1 + 72);
  id v29 = [*(id *)(a1 + 48) clientIdentifier];
  id v23 = *(void **)(a1 + 48);
  id WeakRetained = v32;
  char v24 = [v32 home];
  id v25 = [v23 userForHome:v24];
  id v26 = [v25 uuid];
  __int16 v27 = +[HMDCharacteristicReadWriteLogEvent eventWithCharacteristicsToWrite:v6 hmdAccessory:v32 hapAccessory:0 source:v30 isTimedWrite:0 isLocal:1 transactionId:0 bundleId:v29 userUUID:v26 writtenValues:v7];

  [v32 submitLogEvent:v27 error:v31];
LABEL_23:
  id v28 = [WeakRetained _updatedResponseTuplesForRequests:*(void *)(a1 + 40) error:v3 source:*(void *)(a1 + 72) suspended:*(unsigned __int8 *)(a1 + 80)];
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

void __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_498(uint64_t a1, void *a2)
{
  id v3 = (id *)(a1 + 40);
  id v4 = a2;
  id WeakRetained = objc_loadWeakRetained(v3);
  objc_msgSend(WeakRetained, "_wol_updateWakingViaCharacteristicForWriteResponses:", v4);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __93__HMDHAPAccessory_writeCharacteristicValues_source_message_queue_logEvent_completionHandler___block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

- (void)writeCharacteristicValues:(id)a3 source:(unint64_t)a4 message:(id)a5 queue:(id)a6 completionHandler:(id)a7
{
}

- (void)writeCharacteristicValues:(id)a3 source:(unint64_t)a4 queue:(id)a5 completionHandler:(id)a6
{
}

- (BOOL)canWakeBasedOnCharacteristicRequests:(id)a3
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v20 = [(HMDHAPAccessory *)self hapMetadata];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id obj = v4;
  uint64_t v5 = [obj countByEnumeratingWithState:&v21 objects:v25 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v22;
    while (2)
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v22 != v6) {
          objc_enumerationMutation(obj);
        }
        id v8 = *(id *)(*((void *)&v21 + 1) + 8 * i);
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          id v9 = v8;
        }
        else {
          id v9 = 0;
        }
        id v10 = v9;

        if (v10)
        {
          uint64_t v11 = [v10 value];
          uint64_t v12 = 3;
        }
        else
        {
          uint64_t v11 = 0;
          uint64_t v12 = 2;
        }
        uint64_t v13 = [v8 service];
        __int16 v14 = [v13 type];
        id v15 = [v8 characteristic];
        id v16 = [v15 characteristicType];
        char v17 = [v20 shouldAllowToWakeSuspendedAccessoryForOperation:v12 service:v14 characteristicType:v16 value:v11];

        if (v17)
        {
          LOBYTE(v5) = 1;
          goto LABEL_17;
        }
      }
      uint64_t v5 = [obj countByEnumeratingWithState:&v21 objects:v25 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
LABEL_17:

  return v5;
}

- (BOOL)supportsUserManagement
{
  if (![(HMDHAPAccessory *)self isPrimary]) {
    return 0;
  }
  id v3 = [(HMDHAPAccessory *)self publicKey];
  BOOL v4 = v3 != 0;

  return v4;
}

- (void)_handleUnreachableAccessoryToPerformOperation:(int64_t)a3 operationBlock:(id)a4 errorBlock:(id)a5
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v9 = a4;
  id v10 = (void (**)(id, void *))a5;
  if ([(HMDHAPAccessory *)self canWakeUpViaWoL])
  {
    if (a3 == 3)
    {
      uint64_t v11 = [(HMDAccessory *)self home];
      BOOL v12 = [(HMDHAPAccessory *)self residentCanWakeForWOL];
      int v13 = 1;
      if (![(HMDHAPAccessory *)self isReachableViaBSP] && v12) {
        int v13 = [v11 isCurrentDeviceAvailableResident];
      }
      id v14 = objc_alloc(MEMORY[0x1E4F653F0]);
      id v15 = NSString;
      id v16 = MEMORY[0x1D94505D0](self, a2);
      char v17 = [v15 stringWithFormat:@"%@, %s:%ld", v16, "/Library/Caches/com.apple.xbs/Sources/HomeKit_executables_legacy/Sources/homed/HMDHAPAccessory.m", 5978];
      id v18 = (void *)[v14 initWithName:v17];
      unint64_t v38 = v18;

      if (v13) {
        id v19 = v9;
      }
      else {
        id v19 = 0;
      }
      if (v13) {
        id v20 = v10;
      }
      else {
        id v20 = 0;
      }
      uint64_t v21 = [(HMDHAPAccessory *)self _wakeSuspendedHAPAccessoryToPerformOperation:3 linkType:1 operationBlock:v19 errorBlock:v20 activity:v18];
      if (v13)
      {
        context = (void *)MEMORY[0x1D9452090](v21);
        long long v22 = self;
        HMFGetOSLogHandle();
        long long v23 = (id)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          HMFGetLogIdentifier();
          id v24 = (id)objc_claimAutoreleasedReturnValue();
          id v25 = [(HMDAccessory *)v22 identifier];
          [(HMDHAPAccessory *)v22 isReachableViaBSP];
          HMFBooleanToString();
          id v26 = (id)objc_claimAutoreleasedReturnValue();
          HMFBooleanToString();
          id v27 = (id)objc_claimAutoreleasedReturnValue();
          [v11 isCurrentDeviceAvailableResident];
          id v28 = HMFBooleanToString();
          *(_DWORD *)buf = 138544386;
          id v40 = v24;
          __int16 v41 = 2112;
          uint64_t v42 = v25;
          __int16 v43 = 2112;
          id v44 = v26;
          __int16 v45 = 2112;
          id v46 = v27;
          __int16 v47 = 2112;
          long long v48 = v28;
          _os_log_impl(&dword_1D49D5000, v23, OS_LOG_TYPE_INFO, "%{public}@Waiting for wake operation to complete for accessory: %@. Reachability (%@) / ResidentCanWake (%@) / isResident (%@)", buf, 0x34u);
        }
        __HMFActivityScopeLeave();

        goto LABEL_25;
      }
      __HMFActivityScopeLeave();
    }
    else
    {
      id v29 = (void *)MEMORY[0x1D9452090]();
      uint64_t v30 = self;
      id v31 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
      {
        long long v32 = HMFGetLogIdentifier();
        if ((unint64_t)a3 > 0xA) {
          long long v33 = @"Undefined";
        }
        else {
          long long v33 = off_1E6A0B878[a3];
        }
        long long v34 = v33;
        long long v35 = [(HMDAccessory *)v30 identifier];
        [(HMDHAPAccessory *)v30 suspendedState];
        long long v36 = HAPAccessorySuspendedStateDescription();
        *(_DWORD *)buf = 138544130;
        id v40 = v32;
        __int16 v41 = 2112;
        uint64_t v42 = v34;
        __int16 v43 = 2112;
        id v44 = v35;
        __int16 v45 = 2112;
        id v46 = v36;
        _os_log_impl(&dword_1D49D5000, v31, OS_LOG_TYPE_DEBUG, "%{public}@Not processing wake for operation: '%@' on unreachable accessory: %@ in state: '%@'", buf, 0x2Au);
      }
    }
  }
  if (v10)
  {
    uint64_t v11 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
    v10[2](v10, v11);
LABEL_25:
  }
}

- (BOOL)residentCanWakeForWOL
{
  id v3 = [(HMDAccessory *)self home];
  BOOL v4 = [v3 primaryResident];

  if ([(HMDAccessory *)self isRemoteAccessEnabled]
    && [v4 isEnabled]
    && [v4 isReachable])
  {
    uint64_t v5 = [v4 capabilities];
    char v6 = [v5 supportsWakeOnLAN];
  }
  else
  {
    char v6 = 0;
  }

  return v6;
}

- (void)_retrieveHAPAccessoryToPerformOperation:(int64_t)a3 linkType:(int64_t)a4 operationBlock:(id)a5 errorBlock:(id)a6 activity:(id)a7
{
  id v12 = a5;
  id v13 = a6;
  id v14 = a7;
  objc_initWeak(&location, self);
  id v15 = [(HMDAccessory *)self home];
  id v16 = [(HMDAccessory *)self workQueue];
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 3221225472;
  v20[2] = __103__HMDHAPAccessory__retrieveHAPAccessoryToPerformOperation_linkType_operationBlock_errorBlock_activity___block_invoke;
  v20[3] = &unk_1E6A0B010;
  objc_copyWeak(v24, &location);
  id v17 = v14;
  id v21 = v17;
  v24[1] = (id)a3;
  id v24[2] = (id)a4;
  id v18 = v12;
  id v22 = v18;
  id v19 = v13;
  id v23 = v19;
  [v15 retrieveHAPAccessoryForHMDAccessory:self linkType:a4 forceRetrieve:0 queue:v16 completion:v20];

  objc_destroyWeak(v24);
  objc_destroyWeak(&location);
}

void __103__HMDHAPAccessory__retrieveHAPAccessoryToPerformOperation_linkType_operationBlock_errorBlock_activity___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  uint64_t v5 = WeakRetained;
  if (WeakRetained)
  {
    if (v3)
    {
      [WeakRetained uuid];

      [v3 domain];
      [v3 code];
      if ([v3 isHMError] && objc_msgSend(v3, "code") == 53)
      {
        id v6 = v3;
        goto LABEL_10;
      }
      id v12 = (void *)MEMORY[0x1D9452090]();
      id v13 = v5;
      id v14 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        id v15 = HMFGetLogIdentifier();
        id v16 = [v13 identifier];
        unint64_t v17 = *(void *)(a1 + 64);
        if (v17 > 0xA) {
          id v18 = @"Undefined";
        }
        else {
          id v18 = off_1E6A0B878[v17];
        }
        id v27 = v18;
        unint64_t v28 = *(void *)(a1 + 72);
        if (v28 > 2) {
          id v29 = @"Undefined";
        }
        else {
          id v29 = off_1E6A0B860[v28];
        }
        uint64_t v30 = v29;
        int v35 = 138544130;
        long long v36 = v15;
        __int16 v37 = 2112;
        unint64_t v38 = v16;
        __int16 v39 = 2112;
        id v40 = v27;
        __int16 v41 = 2112;
        uint64_t v42 = v30;
        _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_INFO, "%{public}@Accessory %@ '%@' operation: Unable to retrieve HAPAccessory for linkType %@ - trying the next link", (uint8_t *)&v35, 0x2Au);
      }
      [v13 _performOperation:*(void *)(a1 + 64) linkType:*(void *)(a1 + 72) operationBlock:*(void *)(a1 + 40) errorBlock:*(void *)(a1 + 48)];
      uint64_t v11 = 0;
LABEL_28:
      id v6 = 0;
      goto LABEL_29;
    }
    uint64_t v19 = [WeakRetained matchingHAPAccessoryWithLinkType:*(void *)(a1 + 72)];
    if (v19)
    {
      uint64_t v11 = (void *)v19;
      if (*(void *)(a1 + 40))
      {
        [v5 uuid];

        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      }
      goto LABEL_28;
    }
    id v20 = (void *)MEMORY[0x1D9452090]();
    id v21 = v5;
    id v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      id v23 = HMFGetLogIdentifier();
      id v24 = [v21 identifier];
      unint64_t v25 = *(void *)(a1 + 64);
      if (v25 > 0xA) {
        id v26 = @"Undefined";
      }
      else {
        id v26 = off_1E6A0B878[v25];
      }
      id v31 = v26;
      unint64_t v32 = *(void *)(a1 + 72);
      if (v32 > 2) {
        long long v33 = @"Undefined";
      }
      else {
        long long v33 = off_1E6A0B860[v32];
      }
      long long v34 = v33;
      int v35 = 138544130;
      long long v36 = v23;
      __int16 v37 = 2112;
      unint64_t v38 = v24;
      __int16 v39 = 2112;
      id v40 = v31;
      __int16 v41 = 2112;
      uint64_t v42 = v34;
      _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_INFO, "%{public}@Accessory %@ '%@' operation: Retrieval succeeded but no HAPAccessory of linkType %@", (uint8_t *)&v35, 0x2Au);
    }
    [v21 uuid];
  }
  else
  {
    id v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      int v35 = 138543362;
      long long v36 = v9;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Accessory went away", (uint8_t *)&v35, 0xCu);
    }
  }
  id v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4];
  if (v6)
  {
LABEL_10:
    uint64_t v10 = *(void *)(a1 + 48);
    if (v10) {
      (*(void (**)(uint64_t, id))(v10 + 16))(v10, v6);
    }
  }
  uint64_t v11 = 0;
LABEL_29:
}

- (void)_retrieveHAPAccessoryToPerformOperation:(int64_t)a3 linkType:(int64_t)a4 retries:(unint64_t)a5 operationBlock:(id)a6 errorBlock:(id)a7 activity:(id)a8
{
  id v14 = a6;
  id v15 = a7;
  id v16 = a8;
  objc_initWeak(&location, self);
  uint64_t v21 = MEMORY[0x1E4F143A8];
  uint64_t v22 = 3221225472;
  id v23 = __111__HMDHAPAccessory__retrieveHAPAccessoryToPerformOperation_linkType_retries_operationBlock_errorBlock_activity___block_invoke;
  id v24 = &unk_1E6A0AFE8;
  objc_copyWeak(v28, &location);
  v28[1] = (id)a5;
  v28[2] = (id)a3;
  v28[3] = (id)a4;
  id v17 = v14;
  id v26 = v17;
  id v18 = v15;
  id v27 = v18;
  id v19 = v16;
  id v25 = v19;
  id v20 = _Block_copy(&v21);
  -[HMDHAPAccessory _retrieveHAPAccessoryToPerformOperation:linkType:operationBlock:errorBlock:activity:](self, "_retrieveHAPAccessoryToPerformOperation:linkType:operationBlock:errorBlock:activity:", a3, a4, v17, v20, v19, v21, v22, v23, v24);

  objc_destroyWeak(v28);
  objc_destroyWeak(&location);
}

void __111__HMDHAPAccessory__retrieveHAPAccessoryToPerformOperation_linkType_retries_operationBlock_errorBlock_activity___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  uint64_t v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = WeakRetained;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    id v8 = HMFGetLogIdentifier();
    id v9 = [NSNumber numberWithUnsignedInteger:*(void *)(a1 + 64)];
    int v12 = 138543874;
    id v13 = v8;
    __int16 v14 = 2112;
    id v15 = v3;
    __int16 v16 = 2112;
    id v17 = v9;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_ERROR, "%{public}@Retrieving the accessory server failed with error: %@. Retries: (%@)", (uint8_t *)&v12, 0x20u);
  }
  if (*(void *)(a1 + 64) && [v3 isHMError] && objc_msgSend(v3, "code") == 4)
  {
    [v6 _retrieveHAPAccessoryToPerformOperation:*(void *)(a1 + 72) linkType:*(void *)(a1 + 80) retries:*(void *)(a1 + 64) - 1 operationBlock:*(void *)(a1 + 40) errorBlock:*(void *)(a1 + 48) activity:*(void *)(a1 + 32)];
  }
  else
  {
    uint64_t v10 = _Block_copy(*(const void **)(a1 + 48));
    uint64_t v11 = v10;
    if (v10) {
      (*((void (**)(void *, id))v10 + 2))(v10, v3);
    }
  }
}

uint64_t __72__HMDHAPAccessory__performOperation_linkType_operationBlock_errorBlock___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _retrieveHAPAccessoryToPerformOperation:*(void *)(a1 + 64) linkType:*(void *)(a1 + 72) retries:1 operationBlock:*(void *)(a1 + 48) errorBlock:*(void *)(a1 + 56) activity:*(void *)(a1 + 40)];
}

- (void)performOperation:(int64_t)a3 linkType:(int64_t)a4 operationBlock:(id)a5 errorBlock:(id)a6
{
  id v10 = a5;
  id v11 = a6;
  int v12 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __71__HMDHAPAccessory_performOperation_linkType_operationBlock_errorBlock___block_invoke;
  block[3] = &unk_1E6A0AF98;
  int64_t v18 = a3;
  int64_t v19 = a4;
  void block[4] = self;
  id v16 = v10;
  id v17 = v11;
  id v13 = v11;
  id v14 = v10;
  dispatch_async(v12, block);
}

uint64_t __71__HMDHAPAccessory_performOperation_linkType_operationBlock_errorBlock___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _performOperation:*(void *)(a1 + 56) linkType:*(void *)(a1 + 64) operationBlock:*(void *)(a1 + 40) errorBlock:*(void *)(a1 + 48)];
}

- (id)matchingHAPAccessoryWithServerIdentifier:(id)a3 instanceID:(id)a4
{
  BOOL v4 = [(HMDHAPAccessory *)self matchingTransportInformationWithServerIdentifier:a3 instanceID:a4 linkType:0];
  uint64_t v5 = [v4 hapAccessory];

  return v5;
}

- (id)matchingHAPAccessoryWithServerIdentifier:(id)a3
{
  id v3 = [(HMDHAPAccessory *)self matchingTransportInformationWithServerIdentifier:a3 instanceID:0 linkType:0];
  BOOL v4 = [v3 hapAccessory];

  return v4;
}

- (id)matchingHAPAccessoryWithServerIdentifier:(id)a3 linkType:(int64_t)a4
{
  BOOL v4 = [(HMDHAPAccessory *)self matchingTransportInformationWithServerIdentifier:a3 instanceID:0 linkType:a4];
  uint64_t v5 = [v4 hapAccessory];

  return v5;
}

- (id)matchingTransportInformationWithServerIdentifier:(id)a3 linkType:(int64_t)a4
{
  return [(HMDHAPAccessory *)self matchingTransportInformationWithServerIdentifier:a3 instanceID:0 linkType:a4];
}

- (BOOL)matchesHAPAccessoryWithServerIdentifier:(id)a3 instanceID:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  id v8 = v7;
  BOOL v9 = 0;
  if (v6 && v7)
  {
    id v10 = [(HMDHAPAccessory *)self uniqueIdentifier];
    id v11 = [MEMORY[0x1E4F5BC00] serverIdentifierWithUniqueIdentifier:v10];
    int v12 = HMFEqualObjects();

    if (v12
      && ([MEMORY[0x1E4F5BC00] instanceIDForUniqueIdentifier:v10],
          id v13 = objc_claimAutoreleasedReturnValue(),
          char v14 = HMFEqualObjects(),
          v13,
          (v14 & 1) != 0))
    {
      BOOL v9 = 1;
    }
    else
    {
      id v15 = [(HMDHAPAccessory *)self matchingTransportInformationWithServerIdentifier:v6 instanceID:v8 linkType:0];
      BOOL v9 = v15 != 0;
    }
  }

  return v9;
}

- (void)unconfigureAccessoryWithServerIdentifier:(id)a3 linkType:(int64_t)a4 updateReachability:(BOOL)a5
{
  id v8 = a3;
  objc_initWeak(&location, self);
  BOOL v9 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __88__HMDHAPAccessory_unconfigureAccessoryWithServerIdentifier_linkType_updateReachability___block_invoke;
  block[3] = &unk_1E6A15F98;
  objc_copyWeak(v13, &location);
  id v12 = v8;
  v13[1] = (id)a4;
  BOOL v14 = a5;
  id v10 = v8;
  dispatch_async(v9, block);

  objc_destroyWeak(v13);
  objc_destroyWeak(&location);
}

void __88__HMDHAPAccessory_unconfigureAccessoryWithServerIdentifier_linkType_updateReachability___block_invoke(uint64_t a1)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = (void *)MEMORY[0x1D9452090]();
  id v4 = WeakRetained;
  uint64_t v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = HMFGetLogIdentifier();
    id v7 = *(void **)(a1 + 32);
    unint64_t v8 = *(void *)(a1 + 48);
    if (v8 > 2) {
      BOOL v9 = @"Undefined";
    }
    else {
      BOOL v9 = off_1E6A0B860[v8];
    }
    id v10 = v9;
    *(_DWORD *)buf = 138543874;
    id v46 = v6;
    __int16 v47 = 2112;
    long long v48 = v7;
    __int16 v49 = 2112;
    long long v50 = v10;
    _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@Unconfiguring HAPAccessory with serverIdentifier %@/%@...", buf, 0x20u);
  }
  id v11 = [v4 matchingTransportInformationWithServerIdentifier:*(void *)(a1 + 32) linkType:*(void *)(a1 + 48)];
  id v12 = v11;
  if (v11)
  {
    [v11 setHapAccessory:0];
    if ([v12 linkType] != 2) {
      [v12 setReachable:0];
    }
  }
  long long v34 = v12;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  id v13 = [v4 services];
  uint64_t v14 = [v13 countByEnumeratingWithState:&v39 objects:v44 count:16];
  if (v14)
  {
    uint64_t v15 = v14;
    uint64_t v16 = *(void *)v40;
    do
    {
      for (uint64_t i = 0; i != v15; ++i)
      {
        if (*(void *)v40 != v16) {
          objc_enumerationMutation(v13);
        }
        int64_t v18 = *(void **)(*((void *)&v39 + 1) + 8 * i);
        long long v35 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        int64_t v19 = [v18 characteristics];
        uint64_t v20 = [v19 countByEnumeratingWithState:&v35 objects:v43 count:16];
        if (v20)
        {
          uint64_t v21 = v20;
          uint64_t v22 = *(void *)v36;
          do
          {
            for (uint64_t j = 0; j != v21; ++j)
            {
              if (*(void *)v36 != v22) {
                objc_enumerationMutation(v19);
              }
              [*(id *)(*((void *)&v35 + 1) + 8 * j) unconfigureForServerIdentifier:*(void *)(a1 + 32) linkType:*(void *)(a1 + 48)];
            }
            uint64_t v21 = [v19 countByEnumeratingWithState:&v35 objects:v43 count:16];
          }
          while (v21);
        }
      }
      uint64_t v15 = [v13 countByEnumeratingWithState:&v39 objects:v44 count:16];
    }
    while (v15);
  }

  id v24 = (void *)MEMORY[0x1D9452090]();
  id v25 = v4;
  id v26 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    id v27 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    id v46 = v27;
    _os_log_impl(&dword_1D49D5000, v26, OS_LOG_TYPE_DEFAULT, "%{public}@Sending disconnected notification", buf, 0xCu);
  }
  logAndPostNotification(@"HMDAccessoryDisconnectedNotification", v25, 0);
  if (*(unsigned char *)(a1 + 56)) {
    uint64_t v28 = [v25 _updateReachability];
  }
  id v29 = (void *)MEMORY[0x1D9452090](v28);
  id v30 = v25;
  id v31 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
  {
    unint64_t v32 = HMFGetLogIdentifier();
    [v30 isSecureSessionEstablished];
    long long v33 = HMFBooleanToString();
    *(_DWORD *)buf = 138543618;
    id v46 = v32;
    __int16 v47 = 2112;
    long long v48 = v33;
    _os_log_impl(&dword_1D49D5000, v31, OS_LOG_TYPE_INFO, "%{public}@Sending accessory unconfigured notification, Secure Session: %@", buf, 0x16u);
  }
  logAndPostNotification(@"HMDAccessoryUnconfiguredNotification", v30, 0);
}

- (void)unconfigureWithCompletion:(id)a3
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  [(HMDHAPAccessory *)self cleanupNotificationCenterObservers];
  v15.receiver = self;
  v15.super_class = (Class)HMDHAPAccessory;
  id v5 = [(HMDAccessory *)&v15 unconfigure];
  id v6 = (void *)MEMORY[0x1D9452090](v5);
  id v7 = self;
  unint64_t v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v9 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    id v17 = v9;
    _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@Removing all services and characteristics...", buf, 0xCu);
  }
  objc_initWeak((id *)buf, v7);
  id v10 = [(HMDAccessory *)v7 workQueue];
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  v12[2] = __45__HMDHAPAccessory_unconfigureWithCompletion___block_invoke;
  v12[3] = &unk_1E6A15DB8;
  objc_copyWeak(&v14, (id *)buf);
  id v13 = v4;
  id v11 = v4;
  dispatch_async(v10, v12);

  objc_destroyWeak(&v14);
  objc_destroyWeak((id *)buf);
}

void __45__HMDHAPAccessory_unconfigureWithCompletion___block_invoke(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  [WeakRetained _deregisterAllClientsFromSessionRestore];
  [WeakRetained stopPing];
  [WeakRetained unregisterFromAccessoryServer];
  [WeakRetained cancelPowerOn];
  [WeakRetained stopScan];
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v3 = [WeakRetained services];
  uint64_t v4 = [v3 countByEnumeratingWithState:&v20 objects:v25 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v21;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v21 != v6) {
          objc_enumerationMutation(v3);
        }
        unint64_t v8 = *(void **)(*((void *)&v20 + 1) + 8 * v7);
        long long v16 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v19 = 0u;
        BOOL v9 = objc_msgSend(v8, "characteristics", 0);
        uint64_t v10 = [v9 countByEnumeratingWithState:&v16 objects:v24 count:16];
        if (v10)
        {
          uint64_t v11 = v10;
          uint64_t v12 = *(void *)v17;
          do
          {
            uint64_t v13 = 0;
            do
            {
              if (*(void *)v17 != v12) {
                objc_enumerationMutation(v9);
              }
              [*(id *)(*((void *)&v16 + 1) + 8 * v13++) unconfigure];
            }
            while (v11 != v13);
            uint64_t v11 = [v9 countByEnumeratingWithState:&v16 objects:v24 count:16];
          }
          while (v11);
        }

        ++v7;
      }
      while (v7 != v5);
      uint64_t v5 = [v3 countByEnumeratingWithState:&v20 objects:v25 count:16];
    }
    while (v5);
  }

  id v14 = _Block_copy(*(const void **)(a1 + 32));
  objc_super v15 = v14;
  if (v14) {
    (*((void (**)(void *))v14 + 2))(v14);
  }
}

- (void)unconfigure
{
}

- (void)cleanupNotificationCenterObservers
{
  id v3 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v3 removeObserver:self name:@"HMDAccessoryIsReachableNotification" object:self];

  uint64_t v4 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v4 removeObserver:self name:@"HMDAccessoryIsNotReachableNotification" object:self];

  uint64_t v5 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v5 removeObserver:self name:@"HMDAccessoryCharacteristicsChangedNotification" object:self];

  uint64_t v6 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v6 removeObserver:self name:@"HMDNotificationAccessoryChangedRoom" object:self];

  uint64_t v7 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v7 removeObserver:self name:@"HMDRoomNameUpdatedNotification" object:self];

  unint64_t v8 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v8 removeObserver:self name:@"HMDAccessoryConnectedNotification" object:self];

  id v18 = [(HMDAccessory *)self home];
  BOOL v9 = [MEMORY[0x1E4F28EB8] defaultCenter];
  uint64_t v10 = [v18 residentDeviceManager];
  [v9 removeObserver:self name:@"HMDResidentDeviceManagerAddResidentNotification" object:v10];

  uint64_t v11 = [MEMORY[0x1E4F28EB8] defaultCenter];
  uint64_t v12 = [v18 residentDeviceManager];
  [v11 removeObserver:self name:@"HMDResidentDeviceManagerRemoveResidentNotification" object:v12];

  uint64_t v13 = [MEMORY[0x1E4F28EB8] defaultCenter];
  id v14 = [v18 residentDeviceManager];
  [v13 removeObserver:self name:@"HMDResidentDeviceManagerUpdatePrimaryResidentNotification" object:v14];

  objc_super v15 = [MEMORY[0x1E4F28EB8] defaultCenter];
  long long v16 = [v18 residentDeviceManager];
  [v15 removeObserver:self name:@"HMDResidentDeviceManagerUpdateResidentNotification" object:v16];

  long long v17 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v17 removeObserver:self name:@"HMDResidentDeviceConfirmedStateChangedNotification" object:self];
}

- (void)unregisterFromAccessoryServer
{
  id v3 = [(HMDHAPAccessory *)self getPrimaryHAPAccessories];
  id v6 = [v3 firstObject];

  uint64_t v4 = v6;
  if (v6)
  {
    uint64_t v5 = [v6 server];
    [v5 unregisterForNotifications:self];

    uint64_t v4 = v6;
  }
}

uint64_t __84__HMDHAPAccessory_configureWithAccessory_homeNotificationsEnabled_queue_completion___block_invoke_454(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  uint64_t v4 = [v3 type];
  uint64_t v5 = [v3 service];

  id v6 = [v5 type];
  uint64_t v7 = [v2 generateNotificationOnConfigurationForCharacteristicType:v4 serviceType:v6];

  return v7;
}

void __84__HMDHAPAccessory_configureWithAccessory_homeNotificationsEnabled_queue_completion___block_invoke_455(uint64_t a1)
{
}

uint64_t __84__HMDHAPAccessory_configureWithAccessory_homeNotificationsEnabled_queue_completion___block_invoke_456(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __80__HMDHAPAccessory_enableNotificationsWithHAPAccessory_homeNotificationsEnabled___block_invoke_452(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 type];
  uint64_t v5 = [v3 service];
  id v6 = [v5 type];

  if (*(unsigned char *)(a1 + 48) && ([*(id *)(a1 + 32) containsObject:v3] & 1) == 0) {
    uint64_t v7 = [*(id *)(a1 + 40) shouldEnableHomeNotificationForCharacteristicType:v4 serviceType:v6];
  }
  else {
    uint64_t v7 = 0;
  }

  return v7;
}

- (id)configureService:(id)a3
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v31 = [MEMORY[0x1E4F1CA60] dictionary];
  unint64_t v32 = self;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  id obj = [(HMDHAPAccessory *)self transportInformationInstances];
  uint64_t v35 = [obj countByEnumeratingWithState:&v41 objects:v52 count:16];
  if (v35)
  {
    uint64_t v34 = *(void *)v42;
    do
    {
      for (uint64_t i = 0; i != v35; ++i)
      {
        if (*(void *)v42 != v34) {
          objc_enumerationMutation(obj);
        }
        id v6 = [*(id *)(*((void *)&v41 + 1) + 8 * i) hapAccessory];
        long long v37 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        uint64_t v7 = [v6 services];
        unint64_t v8 = (void *)[v7 copy];

        uint64_t v9 = [v8 countByEnumeratingWithState:&v37 objects:v51 count:16];
        if (v9)
        {
          uint64_t v10 = v9;
          long long v36 = v6;
          uint64_t v11 = *(void *)v38;
LABEL_8:
          uint64_t v12 = 0;
          while (1)
          {
            if (*(void *)v38 != v11) {
              objc_enumerationMutation(v8);
            }
            uint64_t v13 = *(void **)(*((void *)&v37 + 1) + 8 * v12);
            id v14 = [v4 instanceID];
            objc_super v15 = [v13 instanceID];
            int v16 = [v14 isEqual:v15];

            if (v16) {
              break;
            }
            if (v10 == ++v12)
            {
              uint64_t v10 = [v8 countByEnumeratingWithState:&v37 objects:v51 count:16];
              if (v10) {
                goto LABEL_8;
              }
              id v17 = v8;
              id v6 = v36;
              goto LABEL_21;
            }
          }
          id v17 = v13;
          id v18 = [v4 type];
          long long v19 = [v17 type];
          char v20 = [v18 isEqualToString:v19];

          if ((v20 & 1) == 0)
          {
            id v24 = (void *)MEMORY[0x1D9452090]();
            id v25 = v32;
            uint64_t v26 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              id v27 = HMFGetLogIdentifier();
              uint64_t v28 = [v17 type];
              *(_DWORD *)buf = 138543874;
              id v46 = v27;
              __int16 v47 = 2112;
              long long v48 = v28;
              __int16 v49 = 2112;
              id v50 = v4;
              _os_log_impl(&dword_1D49D5000, v26, OS_LOG_TYPE_ERROR, "%{public}@Service type, %@, changed for service: %@", buf, 0x20u);
            }
            id v29 = [MEMORY[0x1E4F28C58] hmErrorWithCode:66];
            [(HMDAccessory *)v25 didEncounterError:v29];

            id v23 = 0;
            long long v22 = v31;
            goto LABEL_28;
          }

          id v6 = v36;
          if (!v17) {
            goto LABEL_22;
          }
          long long v21 = [v4 configureWithService:v17 accessory:v32];
          if ([v21 count]) {
            [v31 addEntriesFromDictionary:v21];
          }
        }
        else
        {
          id v17 = v8;
        }
LABEL_21:

LABEL_22:
      }
      uint64_t v35 = [obj countByEnumeratingWithState:&v41 objects:v52 count:16];
    }
    while (v35);
  }

  long long v22 = v31;
  id v23 = v31;
LABEL_28:

  return v23;
}

- (id)getHAPAccessoryMatchingInstanceId
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  [(HMDHAPAccessory *)self transportInformationInstances];
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v4 = [v3 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v17;
    while (2)
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v17 != v6) {
          objc_enumerationMutation(v3);
        }
        unint64_t v8 = *(void **)(*((void *)&v16 + 1) + 8 * i);
        uint64_t v9 = objc_msgSend(v8, "hapAccessory", (void)v16);
        if (v9)
        {
          uint64_t v10 = (void *)v9;
          uint64_t v11 = [v8 instanceID];
          uint64_t v12 = [(HMDHAPAccessory *)self hapInstanceId];
          char v13 = [v11 isEqualToNumber:v12];

          if (v13)
          {
            id v14 = [v8 hapAccessory];
            goto LABEL_12;
          }
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v16 objects:v20 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
  id v14 = 0;
LABEL_12:

  return v14;
}

- (int64_t)linkSpeed
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v3 = [(HMDHAPAccessory *)self transportInformationInstances];
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v4 = [v3 countByEnumeratingWithState:&v22 objects:v27 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    int64_t v6 = 0;
    uint64_t v7 = *(void *)v23;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v23 != v7) {
          objc_enumerationMutation(v3);
        }
        if ([*(id *)(*((void *)&v22 + 1) + 8 * i) linkType] == 2) {
          --v6;
        }
        else {
          ++v6;
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v22 objects:v27 count:16];
    }
    while (v5);
  }
  else
  {
    int64_t v6 = 0;
  }
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  uint64_t v9 = [(HMDHAPAccessory *)self services];
  uint64_t v10 = [v9 countByEnumeratingWithState:&v18 objects:v26 count:16];
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)v19;
    uint64_t v13 = *MEMORY[0x1E4F5BAB8];
    while (2)
    {
      for (uint64_t j = 0; j != v11; ++j)
      {
        if (*(void *)v19 != v12) {
          objc_enumerationMutation(v9);
        }
        objc_super v15 = [*(id *)(*((void *)&v18 + 1) + 8 * j) serviceType];
        char v16 = [v15 isEqual:v13];

        if (v16)
        {
          int64_t v6 = 1;
          goto LABEL_23;
        }
      }
      uint64_t v11 = [v9 countByEnumeratingWithState:&v18 objects:v26 count:16];
      if (v11) {
        continue;
      }
      break;
    }
  }
LABEL_23:

  return v6;
}

- (BOOL)isThreadSecureSessionEstablished
{
  id v2 = [(HMDHAPAccessory *)self transportInformationInstances];
  char v3 = objc_msgSend(v2, "na_any:", &__block_literal_global_440);

  return v3;
}

uint64_t __51__HMDHAPAccessory_isThreadSecureSessionEstablished__block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  if ([v2 linkType] == 1)
  {
    char v3 = [v2 hapAccessory];
    uint64_t v4 = [v3 server];

    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 0;
    }
    id v6 = v5;

    uint64_t v7 = [v6 isSecuritySessionOpen];
  }
  else
  {
    uint64_t v7 = 0;
  }

  return v7;
}

- (BOOL)hasThreadServer
{
  char v3 = [(HMDAccessory *)self identifier];
  uint64_t v4 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v3];

  uint64_t v5 = [v4 server];
  if ([(HMDHAPAccessory *)self isHMMTRAccessoryServer:v5])
  {
    BOOL v6 = [(HMDHAPAccessory *)self hmmtrHasThreadServer:v5];
  }
  else
  {
    id v7 = v5;
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();

    BOOL v6 = isKindOfClass & (v7 != 0);
  }

  return v6;
}

- (BOOL)supportsThread
{
  id v2 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000701-0000-1000-8000-0026BB765291"];

  return v2 != 0;
}

- (BOOL)isMatterLocalLinkConnectedAndPreferred
{
  id v2 = [(HMDHAPAccessory *)self transportInformationInstances];
  char v3 = objc_msgSend(v2, "na_any:", &__block_literal_global_436);

  return v3;
}

uint64_t __57__HMDHAPAccessory_isMatterLocalLinkConnectedAndPreferred__block_invoke(uint64_t a1, void *a2)
{
  id v2 = [a2 hapAccessory];
  char v3 = [v2 server];

  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  id v5 = v4;

  uint64_t v6 = [v5 hasPreferredLocalLink];
  return v6;
}

- (BOOL)isBLELinkConnected
{
  id v2 = [(HMDHAPAccessory *)self transportInformationInstances];
  char v3 = objc_msgSend(v2, "na_any:", &__block_literal_global_432);

  return v3;
}

uint64_t __37__HMDHAPAccessory_isBLELinkConnected__block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  if ([v2 linkType] == 2)
  {
    char v3 = [v2 hapAccessory];
    uint64_t v4 = [v3 server];
    uint64_t v5 = [v4 isBLELinkConnected];
  }
  else
  {
    uint64_t v5 = 0;
  }

  return v5;
}

- (BOOL)hasBLEServer
{
  char v3 = [(HMDAccessory *)self identifier];
  uint64_t v4 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v3];

  uint64_t v5 = [v4 server];
  if ([(HMDHAPAccessory *)self isHMMTRAccessoryServer:v5])
  {
    BOOL v6 = [(HMDHAPAccessory *)self hmmtrHasBLEServer:v5];
  }
  else
  {
    id v7 = v5;
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();

    BOOL v6 = isKindOfClass & (v7 != 0);
  }

  return v6;
}

- (BOOL)hasIPServer
{
  char v3 = [(HMDAccessory *)self identifier];
  uint64_t v4 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v3];

  uint64_t v5 = [v4 server];
  if ([(HMDHAPAccessory *)self isHMMTRAccessoryServer:v5])
  {
    BOOL v6 = [(HMDHAPAccessory *)self hmmtrHasIPServer:v5];
  }
  else
  {
    id v7 = v5;
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();

    BOOL v6 = isKindOfClass & (v7 != 0);
  }

  return v6;
}

- (int64_t)linkLayerType
{
  char v3 = [(HMDAccessory *)self identifier];
  uint64_t v4 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v3];

  uint64_t v5 = [v4 server];
  BOOL v6 = v5;
  if (v5) {
    int64_t v7 = [v5 linkLayerType];
  }
  else {
    int64_t v7 = 0;
  }

  return v7;
}

- (void)setDiagnosticsManager:(id)a3
{
  uint64_t v4 = (HMDAccessoryDiagnosticsManager *)a3;
  os_unfair_recursive_lock_lock_with_options();
  diagnosticsManager = self->_diagnosticsManager;
  self->_diagnosticsManager = v4;

  os_unfair_recursive_lock_unlock();
}

- (HMDAccessoryDiagnosticsManager)diagnosticsManager
{
  os_unfair_recursive_lock_lock_with_options();
  char v3 = self->_diagnosticsManager;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (void)setNetworkRouterController:(id)a3
{
  uint64_t v4 = (HMDNetworkRouterController *)a3;
  os_unfair_recursive_lock_lock_with_options();
  networkRouterController = self->_networkRouterController;
  self->_networkRouterController = v4;

  os_unfair_recursive_lock_unlock();
}

- (HMDDataStreamController)dataStreamController
{
  os_unfair_recursive_lock_lock_with_options();
  char v3 = self->_dataStreamController;
  os_unfair_recursive_lock_unlock();
  return v3;
}

- (BOOL)hasCameraStreamService
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v2 = [(HMDHAPAccessory *)self services];
  char v3 = (void *)[v2 copy];

  uint64_t v4 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v14;
    uint64_t v7 = *MEMORY[0x1E4F5BA68];
    while (2)
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v14 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v9 = [*(id *)(*((void *)&v13 + 1) + 8 * i) type];
        char v10 = [v9 isEqualToString:v7];

        if (v10)
        {
          BOOL v11 = 1;
          goto LABEL_11;
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
  BOOL v11 = 0;
LABEL_11:

  return v11;
}

- (void)removeTransportInformationInstance:(id)a3
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  os_unfair_recursive_lock_lock_with_options();
  [(NSMutableArray *)self->_transportInformationInstances removeObject:v4];
  uint64_t v5 = [(NSMutableArray *)self->_transportInformationInstances count];
  uint64_t v6 = os_unfair_recursive_lock_unlock();
  if (!v5) {
    uint64_t v6 = [(HMDHAPAccessory *)self resetNotificationEnabledTime];
  }
  uint64_t v7 = (void *)MEMORY[0x1D9452090](v6);
  unint64_t v8 = self;
  uint64_t v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    char v10 = HMFGetLogIdentifier();
    int v11 = 138543618;
    uint64_t v12 = v10;
    __int16 v13 = 2048;
    uint64_t v14 = [v4 linkType];
    _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@removed transportInformationInstance linkType %ld", (uint8_t *)&v11, 0x16u);
  }
}

- (void)addTransportInformationInstance:(id)a3
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if (v4)
  {
    os_unfair_recursive_lock_lock_with_options();
    [(NSMutableArray *)self->_transportInformationInstances addObject:v4];
    uint64_t v5 = os_unfair_recursive_lock_unlock();
    uint64_t v6 = (void *)MEMORY[0x1D9452090](v5);
    uint64_t v7 = self;
    unint64_t v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = HMFGetLogIdentifier();
      int v10 = 138543618;
      int v11 = v9;
      __int16 v12 = 2112;
      id v13 = v4;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Added transport information instance: %@", (uint8_t *)&v10, 0x16u);
    }
    logAndPostNotification(@"HMDAccessoryTransportAddedNotification", v7, 0);
  }
}

- (void)removeHostedAccessory:(id)a3
{
  v16[1] = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v5 = (void *)[(NSSet *)self->_identifiersForBridgedAccessories mutableCopy];
  uint64_t v6 = [v4 uuid];
  int v7 = [v5 containsObject:v6];

  if (v7)
  {
    unint64_t v8 = [v4 uuid];
    [v5 removeObject:v8];

    uint64_t v9 = [MEMORY[0x1E4F28EB8] defaultCenter];
    uint64_t v15 = @"HMDAccessoryBridgedAccessoryUUIDKey";
    int v10 = [v4 uuid];
    int v11 = [v10 UUIDString];
    v16[0] = v11;
    __int16 v12 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v16 forKeys:&v15 count:1];
    [v9 postNotificationName:@"HMDAccessoryBridgedAccessoryRemovedNotification" object:self userInfo:v12];

    id v13 = (NSSet *)[v5 copy];
    identifiersForBridgedAccessories = self->_identifiersForBridgedAccessories;
    self->_identifiersForBridgedAccessories = v13;
  }
  os_unfair_recursive_lock_unlock();
}

- (void)addHostedAccessory:(id)a3
{
  v16[1] = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  os_unfair_recursive_lock_lock_with_options();
  uint64_t v5 = (void *)[(NSSet *)self->_identifiersForBridgedAccessories mutableCopy];
  uint64_t v6 = [v4 uuid];
  char v7 = [v5 containsObject:v6];

  if ((v7 & 1) == 0)
  {
    unint64_t v8 = [v4 uuid];
    [v5 addObject:v8];

    uint64_t v9 = [MEMORY[0x1E4F28EB8] defaultCenter];
    uint64_t v15 = @"HMDAccessoryBridgedAccessoryUUIDKey";
    int v10 = [v4 uuid];
    int v11 = [v10 UUIDString];
    v16[0] = v11;
    __int16 v12 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v16 forKeys:&v15 count:1];
    [v9 postNotificationName:@"HMDAccessoryBridgedAccessoryAddedNotification" object:self userInfo:v12];

    id v13 = (NSSet *)[v5 copy];
    identifiersForBridgedAccessories = self->_identifiersForBridgedAccessories;
    self->_identifiersForBridgedAccessories = v13;
  }
  os_unfair_recursive_lock_unlock();
}

- (void)setIdentifiersForBridgedAccessories:(id)a3
{
  id v6 = a3;
  os_unfair_recursive_lock_lock_with_options();
  if (v6)
  {
    id v4 = (void *)[v6 copy];
  }
  else
  {
    id v4 = [MEMORY[0x1E4F1CAD0] set];
  }
  uint64_t v5 = v4;
  objc_storeStrong((id *)&self->_identifiersForBridgedAccessories, v4);

  os_unfair_recursive_lock_unlock();
}

- (void)updateButtonConfigurationForTarget:(id)a3
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [(HMDHAPAccessory *)self targetControllerManager];

  if (v5)
  {
    id v6 = [(HMDHAPAccessory *)self targetControllerManager];
    [v6 updateButtonConfigurationForTarget:v4];
  }
  else
  {
    char v7 = (void *)MEMORY[0x1D9452090]();
    unint64_t v8 = self;
    uint64_t v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      int v10 = HMFGetLogIdentifier();
      int v11 = 138543618;
      __int16 v12 = v10;
      __int16 v13 = 2112;
      id v14 = v4;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Attempt to update the button configuration for target %@ active with no target controller manager", (uint8_t *)&v11, 0x16u);
    }
  }
}

- (void)acknowledgeTargetControlService:(id)a3 active:(BOOL)a4
{
  BOOL v4 = a4;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  char v7 = [(HMDHAPAccessory *)self targetControllerManager];

  if (v7)
  {
    unint64_t v8 = [(HMDHAPAccessory *)self targetControllerManager];
    [v8 acknowledgeTargetControlService:v6 active:v4];
  }
  else
  {
    uint64_t v9 = (void *)MEMORY[0x1D9452090]();
    int v10 = self;
    int v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      __int16 v12 = HMFGetLogIdentifier();
      __int16 v13 = [(HMDHAPAccessory *)v10 name];
      id v14 = [v6 instanceID];
      int v15 = 138543874;
      long long v16 = v12;
      __int16 v17 = 2112;
      uint64_t v18 = v13;
      __int16 v19 = 2112;
      long long v20 = v14;
      _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_INFO, "%{public}@Attempt to mark controller %@ target control service %@ active with no target controller manager", (uint8_t *)&v15, 0x20u);
    }
  }
}

- (void)autoConfigureTargetController
{
  if ([(HMDHAPAccessory *)self shouldConfigureTargetController])
  {
    if (+[HMDDeviceCapabilities supportsTargetControllerAutoConfigure])
    {
      char v3 = [(HMDAccessory *)self workQueue];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __48__HMDHAPAccessory_autoConfigureTargetController__block_invoke;
      block[3] = &unk_1E6A19B30;
      void block[4] = self;
      dispatch_async(v3, block);
    }
  }
}

uint64_t __48__HMDHAPAccessory_autoConfigureTargetController__block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _autoConfigureTargetController];
}

- (void)_autoConfigureTargetController
{
  objc_initWeak(&location, self);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = __49__HMDHAPAccessory__autoConfigureTargetController__block_invoke;
  v3[3] = &unk_1E6A18528;
  objc_copyWeak(&v4, &location);
  [(HMDHAPAccessory *)self _configureTargetControllerWithCompletion:v3];
  objc_destroyWeak(&v4);
  objc_destroyWeak(&location);
}

void __49__HMDHAPAccessory__autoConfigureTargetController__block_invoke(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (!a2 && WeakRetained)
  {
    id v5 = WeakRetained;
    id v4 = [WeakRetained targetControllerManager];
    [v4 autoConfigureTargets];

    id WeakRetained = v5;
  }
}

- (void)_configureTargetControllerWithCompletion:(id)a3
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if ([(HMDHAPAccessory *)self shouldConfigureTargetController])
  {
    [(HMDHAPAccessory *)self updateSymptoms];
    id v5 = [(HMDHAPAccessory *)self targetControllerManager];

    if (!v5)
    {
      id v6 = (void *)MEMORY[0x1D9452090]();
      char v7 = self;
      unint64_t v8 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        uint64_t v9 = HMFGetLogIdentifier();
        int v10 = [(HMDHAPAccessory *)v7 targetUUIDs];
        *(_DWORD *)buf = 138543618;
        long long v25 = v9;
        __int16 v26 = 2112;
        id v27 = v10;
        _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Accessory supports being a target controller but no target controller manager - creating one with target UUIDs: %@", buf, 0x16u);
      }
      int v11 = [HMDTargetControllerManager alloc];
      __int16 v12 = [(HMDHAPAccessory *)v7 targetUUIDs];
      __int16 v13 = [(HMDTargetControllerManager *)v11 initWithTargetControllerAccessory:v7 targets:v12];
      [(HMDHAPAccessory *)v7 setTargetControllerManager:v13];
    }
    if ([(HMDAccessory *)self isReachable])
    {
      [(HMDHAPAccessory *)self _setTargetControllerSession];
      id v14 = [(HMDHAPAccessory *)self targetControllerManager];
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = __60__HMDHAPAccessory__configureTargetControllerWithCompletion___block_invoke;
      v22[3] = &unk_1E6A17D78;
      v22[4] = self;
      id v23 = v4;
      [v14 refreshConfigurationWithCompletion:v22];
    }
    else if (v4)
    {
      (*((void (**)(id, void))v4 + 2))(v4, 0);
    }
  }
  else
  {
    int v15 = [(HMDHAPAccessory *)self targetControllerManager];

    if (v15)
    {
      long long v16 = (void *)MEMORY[0x1D9452090]();
      __int16 v17 = self;
      uint64_t v18 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        __int16 v19 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        long long v25 = v19;
        _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_INFO, "%{public}@Target controller manager present but accessory no longer supports being a target controller", buf, 0xCu);
      }
      long long v20 = [(HMDHAPAccessory *)v17 targetControllerManager];
      [v20 invalidate];

      [(HMDHAPAccessory *)v17 _notifyClientsOfTargetControlSupportUpdate];
    }
    if (v4)
    {
      uint64_t v21 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
      (*((void (**)(id, void *))v4 + 2))(v4, v21);
    }
  }
}

uint64_t __60__HMDHAPAccessory__configureTargetControllerWithCompletion___block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  char v3 = *(void **)(a1 + 32);
  return [v3 _notifyClientsOfTargetControlSupportUpdate];
}

- (void)configureTargetControllerWithCompletion:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __59__HMDHAPAccessory_configureTargetControllerWithCompletion___block_invoke;
  v7[3] = &unk_1E6A19530;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

uint64_t __59__HMDHAPAccessory_configureTargetControllerWithCompletion___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _configureTargetControllerWithCompletion:*(void *)(a1 + 40)];
}

- (void)_setTargetControllerSession
{
  char v3 = [(HMDAccessory *)self home];
  int v4 = [v3 isCurrentDeviceAvailableResident];

  if (v4)
  {
    uint64_t v5 = [(HMDHAPAccessory *)self targetControllerManager];
    if (v5)
    {
      id v6 = (void *)v5;
      BOOL v7 = isAppleTV();

      if (v7)
      {
        id v8 = HAPStringFromAccessoryServerSession();
        [(HMDHAPAccessory *)self registerForSessionRestore:v8];

        id v10 = [(HMDHAPAccessory *)self bridge];
        if (v10)
        {
          uint64_t v9 = HAPStringFromAccessoryServerSession();
          [v10 registerForSessionRestore:v9];
        }
      }
    }
  }
}

- (void)_notifyClientsOfTargetControlSupportUpdate
{
  v11[3] = *MEMORY[0x1E4F143B8];
  v10[0] = *MEMORY[0x1E4F2C838];
  char v3 = objc_msgSend(NSNumber, "numberWithBool:", -[HMDAccessory supportsTargetControl](self, "supportsTargetControl"));
  v11[0] = v3;
  v10[1] = *MEMORY[0x1E4F2C860];
  int v4 = objc_msgSend(NSNumber, "numberWithBool:", -[HMDHAPAccessory supportsTargetController](self, "supportsTargetController"));
  v11[1] = v4;
  id v10[2] = *MEMORY[0x1E4F2C850];
  uint64_t v5 = objc_msgSend(NSNumber, "numberWithBool:", -[HMDHAPAccessory hardwareSupport](self, "hardwareSupport"));
  v11[2] = v5;
  id v6 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v11 forKeys:v10 count:3];

  BOOL v7 = [MEMORY[0x1E4F65480] entitledMessageWithName:*MEMORY[0x1E4F2C840] messagePayload:v6];
  id v8 = [(HMDAccessory *)self msgDispatcher];
  uint64_t v9 = [(HMDAccessory *)self uuid];
  [v8 sendMessage:v7 target:v9];
}

- (void)notifyClientsOfTargetControlSupportUpdate
{
  char v3 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __60__HMDHAPAccessory_notifyClientsOfTargetControlSupportUpdate__block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v3, block);
}

uint64_t __60__HMDHAPAccessory_notifyClientsOfTargetControlSupportUpdate__block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _notifyClientsOfTargetControlSupportUpdate];
}

- (unint64_t)targetControllerTicksPerSecond
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  char v3 = [(HMDHAPAccessory *)self targetControllerManager];

  if (v3)
  {
    int v4 = [(HMDHAPAccessory *)self targetControllerManager];
    unint64_t v5 = [v4 ticksPerSecond];

    return v5;
  }
  else
  {
    BOOL v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = self;
    uint64_t v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      id v10 = HMFGetLogIdentifier();
      int v11 = 138543362;
      __int16 v12 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Attempt to get the supported button configuration for a controller with no target controller manager", (uint8_t *)&v11, 0xCu);
    }
    return 1000;
  }
}

- (id)targetControllerButtonConfiguration
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  char v3 = [(HMDHAPAccessory *)self targetControllerManager];

  if (v3)
  {
    int v4 = [(HMDHAPAccessory *)self targetControllerManager];
    unint64_t v5 = [v4 buttonConfiguration];
  }
  else
  {
    id v6 = (void *)MEMORY[0x1D9452090]();
    BOOL v7 = self;
    id v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      uint64_t v9 = HMFGetLogIdentifier();
      int v11 = 138543362;
      __int16 v12 = v9;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Attempt to get the supported button configuration for a controller with no target controller manager", (uint8_t *)&v11, 0xCu);
    }
    unint64_t v5 = 0;
  }
  return v5;
}

- (void)registerForActiveIdentifierNotifications
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  char v3 = [(HMDHAPAccessory *)self targetControllerManager];

  if (v3)
  {
    id v8 = [(HMDHAPAccessory *)self targetControllerManager];
    [v8 registerForActiveIdentifierNotifications];
  }
  else
  {
    int v4 = (void *)MEMORY[0x1D9452090]();
    unint64_t v5 = self;
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      BOOL v7 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v10 = v7;
      _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_INFO, "%{public}@Attempt to register for active identifier changes but no target controller manager", buf, 0xCu);
    }
  }
}

- (void)updateTarget:(id)a3 name:(id)a4 buttonConfiguration:(id)a5
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (!v8)
  {
    uint64_t v13 = (void *)MEMORY[0x1D9452090]();
    id v14 = self;
    int v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      long long v16 = HMFGetLogIdentifier();
      __int16 v17 = buttonConfigurationAsString(v10);
      int v21 = 138543874;
      long long v22 = v16;
      __int16 v23 = 2112;
      id v24 = v9;
      __int16 v25 = 2112;
      __int16 v26 = v17;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@Attempt to update a nil target accessory with name %@ and buttonConfiguration %@", (uint8_t *)&v21, 0x20u);

LABEL_8:
    }
LABEL_9:

    goto LABEL_10;
  }
  uint64_t v11 = [(HMDHAPAccessory *)self targetControllerManager];

  if (!v11)
  {
    uint64_t v13 = (void *)MEMORY[0x1D9452090]();
    id v14 = self;
    int v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      long long v16 = HMFGetLogIdentifier();
      uint64_t v18 = [v8 name];
      __int16 v19 = [v8 uuid];
      long long v20 = [v19 UUIDString];
      int v21 = 138543874;
      long long v22 = v16;
      __int16 v23 = 2112;
      id v24 = v18;
      __int16 v25 = 2112;
      __int16 v26 = v20;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@Attempt to update the name and button configuration of target %@/%@ but no target controller manager", (uint8_t *)&v21, 0x20u);

      goto LABEL_8;
    }
    goto LABEL_9;
  }
  __int16 v12 = [(HMDHAPAccessory *)self targetControllerManager];
  [v12 updateTargetAccessory:v8 name:v9 buttonConfiguration:v10];

LABEL_10:
}

- (void)removeTarget:(id)a3
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if (!v4)
  {
    BOOL v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = self;
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      id v10 = HMFGetLogIdentifier();
      int v14 = 138543362;
      int v15 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Attempt to remove a nil target accessory", (uint8_t *)&v14, 0xCu);
LABEL_8:
    }
LABEL_9:

    goto LABEL_10;
  }
  unint64_t v5 = [(HMDHAPAccessory *)self targetControllerManager];

  if (!v5)
  {
    BOOL v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = self;
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      id v10 = HMFGetLogIdentifier();
      uint64_t v11 = [v4 name];
      __int16 v12 = [v4 uuid];
      uint64_t v13 = [v12 UUIDString];
      int v14 = 138543874;
      int v15 = v10;
      __int16 v16 = 2112;
      __int16 v17 = v11;
      __int16 v18 = 2112;
      __int16 v19 = v13;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Attempt to remove a target %@/%@ to an accessory with no target controller manager", (uint8_t *)&v14, 0x20u);

      goto LABEL_8;
    }
    goto LABEL_9;
  }
  id v6 = [(HMDHAPAccessory *)self targetControllerManager];
  [v6 removeTargetAccessory:v4];

LABEL_10:
}

- (void)addTarget:(id)a3 buttonConfiguration:(id)a4
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  if (!v6)
  {
    id v10 = (void *)MEMORY[0x1D9452090]();
    uint64_t v11 = self;
    __int16 v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      uint64_t v13 = HMFGetLogIdentifier();
      int v17 = 138543362;
      __int16 v18 = v13;
      _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_INFO, "%{public}@Attempt to add a nil target accessory", (uint8_t *)&v17, 0xCu);
LABEL_8:
    }
LABEL_9:

    goto LABEL_10;
  }
  id v8 = [(HMDHAPAccessory *)self targetControllerManager];

  if (!v8)
  {
    id v10 = (void *)MEMORY[0x1D9452090]();
    uint64_t v11 = self;
    __int16 v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      uint64_t v13 = HMFGetLogIdentifier();
      int v14 = [v6 name];
      int v15 = [v6 uuid];
      __int16 v16 = [v15 UUIDString];
      int v17 = 138543874;
      __int16 v18 = v13;
      __int16 v19 = 2112;
      uint64_t v20 = v14;
      __int16 v21 = 2112;
      long long v22 = v16;
      _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_INFO, "%{public}@Attempt to add a target %@/%@ to an accessory with no target controller manager", (uint8_t *)&v17, 0x20u);

      goto LABEL_8;
    }
    goto LABEL_9;
  }
  id v9 = [(HMDHAPAccessory *)self targetControllerManager];
  [v9 addTargetAccessory:v6 buttonConfiguration:v7];

LABEL_10:
}

- (void)_handleServiceRemovedTransaction:(id)a3 message:(id)a4
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  v29.receiver = self;
  v29.super_class = (Class)HMDHAPAccessory;
  [(HMDAccessory *)&v29 transactionObjectRemoved:v6 message:v7];
  id v8 = [v6 uuid];
  id v9 = [(HMDHAPAccessory *)self serviceWithUUID:v8];

  id v10 = (void *)MEMORY[0x1D9452090]();
  uint64_t v11 = self;
  __int16 v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    uint64_t v13 = HMFGetLogIdentifier();
    int v14 = [v9 name];
    int v15 = [v9 instanceID];
    __int16 v16 = [v7 shortDescription];
    *(_DWORD *)buf = 138544130;
    id v31 = v13;
    __int16 v32 = 2112;
    long long v33 = v14;
    __int16 v34 = 2112;
    uint64_t v35 = v15;
    __int16 v36 = 2112;
    long long v37 = v16;
    _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_INFO, "%{public}@Removing service:%@ instanceID:%@. Message: %@", buf, 0x2Au);
  }
  int v17 = [(HMDAccessory *)v11 home];
  [v17 removeService:v9];

  __int16 v18 = +[HMDBulletinBoard sharedBulletinBoard];
  [v18 removeBulletinsForService:v9];

  [(HMDHAPAccessory *)v11 _removeService:v9];
  __int16 v19 = [v7 transactionResult];
  [v19 markChanged];
  [v19 markSaveToAssistant];
  uint64_t v20 = (void *)MEMORY[0x1D9452090]([v7 respondWithPayload:0]);
  __int16 v21 = v11;
  long long v22 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
  {
    uint64_t v23 = HMFGetLogIdentifier();
    id v24 = [v9 instanceID];
    *(_DWORD *)buf = 138543618;
    id v31 = v23;
    __int16 v32 = 2112;
    long long v33 = v24;
    _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_INFO, "%{public}@Service %@ removed", buf, 0x16u);
  }
  __int16 v25 = [(HMDAccessory *)v21 workQueue];
  v27[0] = MEMORY[0x1E4F143A8];
  v27[1] = 3221225472;
  v27[2] = __60__HMDHAPAccessory__handleServiceRemovedTransaction_message___block_invoke;
  v27[3] = &unk_1E6A197C8;
  void v27[4] = v21;
  id v28 = v9;
  id v26 = v9;
  dispatch_async(v25, v27);
}

void __60__HMDHAPAccessory__handleServiceRemovedTransaction_message___block_invoke(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  [*(id *)(a1 + 32) _handleUpdatedServicesForProfilesAndControllers:0];
  [*(id *)(a1 + 32) updatePrimaryServiceIfNeeded];
  uint64_t v2 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v2 postNotificationName:@"kHMDNotificationServicesUpdated" object:*(void *)(a1 + 32) userInfo:0];

  char v3 = (void *)MEMORY[0x1D9452090]();
  id v4 = *(id *)(a1 + 32);
  unint64_t v5 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    id v7 = [*(id *)(a1 + 32) primaryService];
    id v8 = [v7 name];
    id v9 = [*(id *)(a1 + 32) primaryService];
    id v10 = [v9 uuid];
    uint64_t v11 = [*(id *)(a1 + 40) name];
    __int16 v12 = [*(id *)(a1 + 40) uuid];
    int v13 = 138544386;
    int v14 = v6;
    __int16 v15 = 2112;
    __int16 v16 = v8;
    __int16 v17 = 2112;
    __int16 v18 = v10;
    __int16 v19 = 2112;
    uint64_t v20 = v11;
    __int16 v21 = 2112;
    long long v22 = v12;
    _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Current primary service of accessory is %@(%@) after removing service %@(%@)", (uint8_t *)&v13, 0x34u);
  }
}

- (void)_handleAddServiceTransaction:(id)a3 message:(id)a4
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  id v8 = [[HMDService alloc] initWithTransaction:v6 accessory:self owner:self];
  if (v8)
  {
    long long v43 = v7;
    long long v44 = v6;
    BOOL v42 = [(HMDHAPAccessory *)self supportsTargetController];
    BOOL v41 = [(HMDHAPAccessory *)self supportsSiri];
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    id v9 = [(HMDHAPAccessory *)self services];
    uint64_t v10 = [v9 countByEnumeratingWithState:&v54 objects:v69 count:16];
    if (v10)
    {
      uint64_t v11 = v10;
      uint64_t v12 = *(void *)v55;
      while (2)
      {
        for (uint64_t i = 0; i != v11; ++i)
        {
          if (*(void *)v55 != v12) {
            objc_enumerationMutation(v9);
          }
          int v14 = *(void **)(*((void *)&v54 + 1) + 8 * i);
          __int16 v15 = [v14 instanceID];
          __int16 v16 = [(HMDService *)v8 instanceID];
          int v17 = [v15 isEqual:v16];

          if (v17)
          {
            id v7 = v43;
            id v6 = v44;
            [v14 transactionObjectUpdated:0 newValues:v44 message:v43];
            goto LABEL_23;
          }
        }
        uint64_t v11 = [v9 countByEnumeratingWithState:&v54 objects:v69 count:16];
        if (v11) {
          continue;
        }
        break;
      }
    }

    dispatch_group_t group = [v44 configurationTracker];
    if (group) {
      dispatch_group_enter(group);
    }
    [(HMDHAPAccessory *)self _addService:v8];
    __int16 v18 = [(HMDAccessory *)self workQueue];
    __int16 v19 = [(HMDAccessory *)self msgDispatcher];
    [(HMDService *)v8 configureWithWorkQueue:v18 messageDispatcher:v19];

    id v7 = v43;
    id v9 = [v43 transactionResult];
    [v9 markChanged];
    [v9 markSaveToAssistant];
    uint64_t v20 = (void *)MEMORY[0x1D9452090]([v43 respondWithPayload:0]);
    __int16 v21 = self;
    long long v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      long long v39 = v20;
      uint64_t v38 = HMFGetLogIdentifier();
      uint64_t v23 = [(HMDService *)v8 type];
      uint64_t v24 = [(HMDService *)v8 instanceID];
      __int16 v25 = NSNumber;
      id v26 = [(HMDService *)v8 characteristics];
      uint64_t v27 = objc_msgSend(v25, "numberWithUnsignedInteger:", objc_msgSend(v26, "count"));
      id v28 = [v43 shortDescription];
      *(_DWORD *)buf = 138544386;
      uint64_t v60 = v38;
      __int16 v61 = 2112;
      id v62 = v23;
      __int16 v63 = 2112;
      uint64_t v64 = v24;
      objc_super v29 = (void *)v24;
      __int16 v65 = 2112;
      uint64_t v66 = v27;
      __int16 v67 = 2112;
      uint64_t v68 = v28;
      uint64_t v20 = v39;
      _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_DEBUG, "%{public}@Service %@/%@ with %@ characteristics added. Message: %@", buf, 0x34u);

      id v7 = v43;
    }

    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    id v30 = [(HMDAccessory *)v21 home];
    id v31 = [v30 serviceGroups];

    uint64_t v32 = [v31 countByEnumeratingWithState:&v50 objects:v58 count:16];
    if (v32)
    {
      uint64_t v33 = v32;
      uint64_t v34 = *(void *)v51;
      do
      {
        for (uint64_t j = 0; j != v33; ++j)
        {
          if (*(void *)v51 != v34) {
            objc_enumerationMutation(v31);
          }
          [*(id *)(*((void *)&v50 + 1) + 8 * j) setServiceIfPresent:v8];
        }
        uint64_t v33 = [v31 countByEnumeratingWithState:&v50 objects:v58 count:16];
      }
      while (v33);
    }

    __int16 v36 = [(HMDAccessory *)v21 workQueue];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __56__HMDHAPAccessory__handleAddServiceTransaction_message___block_invoke;
    block[3] = &unk_1E6A12D20;
    void block[4] = v21;
    BOOL v48 = v42;
    BOOL v49 = v41;
    id v46 = v8;
    __int16 v47 = group;
    long long v37 = group;
    dispatch_async(v36, block);

    id v6 = v44;
LABEL_23:
  }
}

void __56__HMDHAPAccessory__handleAddServiceTransaction_message___block_invoke(uint64_t a1)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  [*(id *)(a1 + 32) transportInformationInstances];
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  id obj = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v42 = [obj countByEnumeratingWithState:&v50 objects:v67 count:16];
  if (v42)
  {
    uint64_t v40 = *(void *)v51;
    do
    {
      for (uint64_t i = 0; i != v42; ++i)
      {
        if (*(void *)v51 != v40) {
          objc_enumerationMutation(obj);
        }
        char v3 = [*(id *)(*((void *)&v50 + 1) + 8 * i) hapAccessory];
        long long v46 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v44 = v3;
        id v4 = [v3 services];
        uint64_t v5 = [v4 countByEnumeratingWithState:&v46 objects:v66 count:16];
        if (v5)
        {
          uint64_t v6 = v5;
          uint64_t v7 = *(void *)v47;
          do
          {
            for (uint64_t j = 0; j != v6; ++j)
            {
              if (*(void *)v47 != v7) {
                objc_enumerationMutation(v4);
              }
              id v9 = *(void **)(*((void *)&v46 + 1) + 8 * j);
              uint64_t v10 = [v9 instanceID];
              uint64_t v11 = [*(id *)(a1 + 40) instanceID];
              int v12 = [v10 isEqual:v11];

              if (v12) {
                id v13 = (id)[*(id *)(a1 + 40) configureWithService:v9 accessory:*(void *)(a1 + 32) shouldRead:0 added:1];
              }
            }
            uint64_t v6 = [v4 countByEnumeratingWithState:&v46 objects:v66 count:16];
          }
          while (v6);
        }
      }
      uint64_t v42 = [obj countByEnumeratingWithState:&v50 objects:v67 count:16];
    }
    while (v42);
  }

  [*(id *)(a1 + 32) _handleUpdatedServicesForProfilesAndControllers:0];
  int v14 = [*(id *)(a1 + 32) primaryService];
  [*(id *)(a1 + 32) updatePrimaryServiceIfNeeded];
  if ([*(id *)(a1 + 32) _serviceSupportsMinimumUserPrivilege:*(void *)(a1 + 40)]) {
    [*(id *)(a1 + 32) _reconcileAccessControlSetting];
  }
  __int16 v15 = [*(id *)(a1 + 32) hapMetadata];
  __int16 v16 = [*(id *)(a1 + 40) type];
  char v17 = [v15 shouldFilterServiceOfTypeFromApp:v16];

  if (v14)
  {
    __int16 v18 = [*(id *)(a1 + 32) primaryService];

    if (v18 == v14) {
      char v19 = v17;
    }
    else {
      char v19 = 0;
    }
    if ((v19 & 1) == 0) {
      goto LABEL_24;
    }
  }
  else if ((v17 & 1) == 0)
  {
LABEL_24:
    uint64_t v20 = [MEMORY[0x1E4F28EB8] defaultCenter];
    [v20 postNotificationName:@"kHMDNotificationServicesUpdated" object:*(void *)(a1 + 32) userInfo:0];
  }
  __int16 v21 = (void *)MEMORY[0x1D9452090]();
  id v22 = *(id *)(a1 + 32);
  uint64_t v23 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
  {
    __int16 v45 = v14;
    uint64_t v38 = HMFGetLogIdentifier();
    BOOL v41 = [*(id *)(a1 + 32) primaryService];
    uint64_t v24 = [v41 name];
    [*(id *)(a1 + 32) primaryService];
    v25 = long long v43 = v21;
    id v26 = [v25 uuid];
    uint64_t v27 = [*(id *)(a1 + 40) name];
    id v28 = [*(id *)(a1 + 40) uuid];
    *(_DWORD *)buf = 138544386;
    long long v57 = v38;
    __int16 v58 = 2112;
    uint64_t v59 = v24;
    objc_super v29 = (void *)v24;
    __int16 v60 = 2112;
    __int16 v61 = v26;
    __int16 v62 = 2112;
    __int16 v63 = v27;
    __int16 v64 = 2112;
    __int16 v65 = v28;
    int v14 = v45;
    _os_log_impl(&dword_1D49D5000, v23, OS_LOG_TYPE_DEBUG, "%{public}@Current primary service of accessory is %@(%@) after adding service %@(%@)", buf, 0x34u);

    __int16 v21 = v43;
  }

  char v30 = [*(id *)(a1 + 32) supportsTargetController];
  int v31 = [*(id *)(a1 + 32) supportsSiri];
  if (!*(unsigned char *)(a1 + 56) && (v30 & 1) != 0 || (!*(unsigned char *)(a1 + 57) ? (int v32 = v31) : (int v32 = 0), v32 == 1)) {
    [*(id *)(a1 + 32) _configureTargetControllerWithCompletion:&__block_literal_global_418];
  }
  uint64_t v33 = [MEMORY[0x1E4F28EB8] defaultCenter];
  uint64_t v35 = *(void *)(a1 + 32);
  uint64_t v34 = *(void *)(a1 + 40);
  long long v54 = @"HMDServiceNotificationKey";
  uint64_t v55 = v34;
  __int16 v36 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v55 forKeys:&v54 count:1];
  [v33 postNotificationName:@"HMDAccessoryServiceAddedNotification" object:v35 userInfo:v36];

  long long v37 = *(NSObject **)(a1 + 48);
  if (v37) {
    dispatch_group_leave(v37);
  }
}

- (void)_handleUpdatedServicesForProfilesAndControllers:(BOOL)a3
{
  BOOL v3 = a3;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  uint64_t v6 = [(HMDHAPAccessory *)self services];
  uint64_t v7 = [(HMDAccessory *)self home];
  [(HMDHAPAccessory *)self _handleUpdatedServicesForDataStreamController:v6];
  id v8 = [MEMORY[0x1E4F28E78] string];
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForCameraProfiles:v6])
  {
    [v8 appendString:@"CreateCameraProfiles"];
    int v9 = !v3;
  }
  else
  {
    int v9 = 0;
  }
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForNetworkRouterController:v6])
  {
    [v8 appendString:@"NetworkRouterProfiles"];
  }
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForFirmwareUpdateProfile:v6])
  {
    [v8 appendString:@"FirmwareUpdateProfile"];
  }
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForMediaProfile:v6]) {
    [v8 appendString:@"MediaProfiles"];
  }
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForLightProfiles:v6]) {
    [v8 appendString:@"LightProfiles"];
  }
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForWiFiManagementController])
  {
    [v8 appendString:@"WiFiManagementController"];
  }
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForDoorbellController])
  {
    uint64_t v10 = (void *)MEMORY[0x1D9452090]();
    uint64_t v11 = self;
    int v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      id v13 = HMFGetLogIdentifier();
      int v17 = 138543362;
      __int16 v18 = v13;
      _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_DEBUG, "%{public}@calling update services on doorbell chime controller", (uint8_t *)&v17, 0xCu);
    }
    [v8 appendString:@"DoorbellChimeController"];
  }
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForSiriEndpointProfile:v6])
  {
    -[HMDHAPAccessory _evaluateResidentEnabledFeatures](self);
    [v8 appendString:@"SiriEndpointProfile"];
  }
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForDiagnosticsManager:v6])
  {
    [v8 appendString:@"DiagnosticsManager"];
  }
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForLowPowerModeProfile])
  {
    [v8 appendString:@"LowPowerModeProfile"];
  }
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForAccessCodes]) {
    [v8 appendString:@"AddedAccessCodeSupport"];
  }
  if ([(HMDHAPAccessory *)self _handleUpdatedServicesForWalletKey]) {
    [v8 appendString:@"supportsWalletKey"];
  }
  int v14 = [v7 homeManager];
  if ([v8 length])
  {
    __int16 v15 = [(HMDAccessory *)self uuid];
    [v14 updateGenerationCounterWithReason:v8 sourceUUID:v15 shouldNotifyClients:1];
  }
  if (v9)
  {
    __int16 v16 = (void *)[v8 copy];
    [v14 assistantSyncDataChanged:v16];
  }
}

- (id)serviceWithSPIClientIdentifier:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HMDHAPAccessory *)self services];
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = __50__HMDHAPAccessory_serviceWithSPIClientIdentifier___block_invoke;
  v9[3] = &unk_1E6A0AE70;
  id v10 = v4;
  id v6 = v4;
  uint64_t v7 = objc_msgSend(v5, "na_firstObjectPassingTest:", v9);

  return v7;
}

uint64_t __50__HMDHAPAccessory_serviceWithSPIClientIdentifier___block_invoke(uint64_t a1, void *a2)
{
  BOOL v3 = [a2 spiClientIdentifier];
  uint64_t v4 = objc_msgSend(v3, "hmf_isEqualToUUID:", *(void *)(a1 + 32));

  return v4;
}

- (id)serviceWithUUID:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HMDHAPAccessory *)self services];
  id v6 = objc_msgSend(v5, "hmf_firstObjectWithUUID:", v4);

  return v6;
}

- (void)_removeService:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    id v5 = v4;
    os_unfair_recursive_lock_lock_with_options();
    [(NSMutableArray *)self->_services removeObject:v5];
    os_unfair_recursive_lock_unlock();
    id v4 = v5;
  }
}

- (void)_addService:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    id v5 = v4;
    os_unfair_recursive_lock_lock_with_options();
    [(NSMutableArray *)self->_services addObject:v5];
    os_unfair_recursive_lock_unlock();
    id v4 = v5;
  }
}

- (void)_updatePrimaryServiceIfNeededWithService:(id)a3
{
  id v25 = a3;
  if ([v25 isPrimary])
  {
    id v5 = (HMDService *)v25;
    id primaryService = self->_primaryService;
    self->_id primaryService = v5;
LABEL_3:

    id v8 = v25;
    goto LABEL_8;
  }
  int v9 = [v25 instanceID];
  int v10 = [v9 intValue];

  id v8 = v25;
  if (v10 != 1)
  {
    uint64_t v7 = [v25 isCustom];
    id v8 = v25;
    if ((v7 & 1) == 0)
    {
      p_id primaryService = (id *)&self->_primaryService;
      int v12 = self->_primaryService;
      if (!v12)
      {
        id v13 = v25;
        id primaryService = *p_primaryService;
        *p_id primaryService = v13;
        goto LABEL_3;
      }
      uint64_t v7 = [(HMDService *)v12 isPrimary];
      id v8 = v25;
      if ((v7 & 1) == 0)
      {
        id primaryService = [(HMDAccessory *)self category];
        int v14 = [primaryService categoryType];
        __int16 v15 = [*p_primaryService serviceType];
        BOOL v16 = +[HMDHAPMetadata isServiceType:v15 compatibleWithAccessoryCategoryType:v14];

        int v17 = [v25 serviceType];
        BOOL v18 = +[HMDHAPMetadata isServiceType:v17 compatibleWithAccessoryCategoryType:v14];

        uint64_t v19 = [v25 instanceID];
        int v20 = [v19 intValue];
        __int16 v21 = [*p_primaryService instanceID];
        int v22 = [v21 intValue];

        if (v18)
        {
          if (v20 >= v22 && v16) {
            goto LABEL_23;
          }
        }
        else
        {
          char v24 = v20 >= v22 || v16;
          if (v24) {
            goto LABEL_23;
          }
        }
        objc_storeStrong(p_primaryService, a3);
LABEL_23:

        goto LABEL_3;
      }
    }
  }
LABEL_8:
  MEMORY[0x1F41817F8](v7, v8);
}

- (void)updatePrimaryServiceIfNeeded
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (!self)
  {
    uint64_t v2 = 0;
LABEL_6:
    BOOL v9 = 0;
    goto LABEL_12;
  }
  uint64_t v2 = self;
  BOOL v3 = [(HMDHAPAccessory *)self cameraProfiles];
  uint64_t v4 = [v3 count];

  if (v4)
  {
    id v5 = (void *)MEMORY[0x1D9452090]();
    id v6 = v2;
    uint64_t v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      id v8 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v54 = v8;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Accessory with camera profiles do not have primary service", buf, 0xCu);
    }
    goto LABEL_6;
  }
  accessoryToEncodeForXPCTransportForAccessory(v2);
  int v10 = (HMDHAPAccessory *)objc_claimAutoreleasedReturnValue();
  BOOL v9 = v10 == v2;
  if (v10 != v2)
  {
    uint64_t v11 = (void *)MEMORY[0x1D9452090]();
    int v12 = v2;
    id v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      int v14 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v54 = v14;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_DEBUG, "%{public}@HomePod sensor accessory does not have primary service", buf, 0xCu);
    }
  }

LABEL_12:
  os_unfair_recursive_lock_lock_with_options();
  id primaryService = v2->_primaryService;
  v2->_id primaryService = 0;

  if (v9)
  {
    locatiouint64_t n = (id *)&v2->_primaryService;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = v2;
    id obj = v2->_services;
    uint64_t v16 = [(NSMutableArray *)obj countByEnumeratingWithState:&v49 objects:v59 count:16];
    if (!v16) {
      goto LABEL_43;
    }
    uint64_t v17 = *(void *)v50;
    while (1)
    {
      uint64_t v18 = 0;
      do
      {
        if (*(void *)v50 != v17) {
          objc_enumerationMutation(obj);
        }
        uint64_t v19 = *(void **)(*((void *)&v49 + 1) + 8 * v18);
        int v20 = v48;
        id v21 = v19;
        int v22 = v21;
        if (!v21) {
          goto LABEL_20;
        }
        uint64_t v23 = [v21 instanceID];
        BOOL v24 = [v23 intValue] == 1;

        if (v24) {
          goto LABEL_20;
        }
        if ([v22 isPrimary])
        {
          id v25 = location;
          id v26 = *location;
LABEL_25:
          id *v25 = v22;
          int v22 = v26;
          goto LABEL_26;
        }
        if ([v22 isCustom]) {
          goto LABEL_20;
        }
        if (!*location)
        {
          id v26 = 0;
          id v25 = location;
          goto LABEL_25;
        }
        if ([*location isPrimary]) {
          goto LABEL_20;
        }
        long long v44 = [(HMDAccessory *)v20 category];
        __int16 v45 = [v44 categoryType];
        uint64_t v33 = [*location serviceType];
        BOOL v43 = +[HMDHAPMetadata isServiceType:v33 compatibleWithAccessoryCategoryType:v45];

        uint64_t v34 = [v22 serviceType];
        BOOL v42 = +[HMDHAPMetadata isServiceType:v34 compatibleWithAccessoryCategoryType:v45];

        uint64_t v35 = [v22 instanceID];
        int v36 = [v35 intValue];
        long long v37 = [*location instanceID];
        int v38 = [v37 intValue];

        if (v42)
        {
          BOOL v39 = v43;
          if (v36 < v38) {
            BOOL v39 = 0;
          }
          if (v39) {
            goto LABEL_41;
          }
        }
        else
        {
          char v40 = v43;
          if (v36 >= v38) {
            char v40 = 1;
          }
          if (v40)
          {
LABEL_41:

LABEL_20:
            goto LABEL_21;
          }
        }
        objc_storeStrong(location, v19);

LABEL_26:
        uint64_t v27 = (void *)MEMORY[0x1D9452090]();
        id v28 = v20;
        HMFGetOSLogHandle();
        objc_super v29 = (id)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          HMFGetLogIdentifier();
          id v30 = (id)objc_claimAutoreleasedReturnValue();
          int v31 = [*location name];
          int v32 = [*location uuid];
          *(_DWORD *)buf = 138543874;
          id v54 = v30;
          __int16 v55 = 2112;
          long long v56 = v31;
          __int16 v57 = 2112;
          __int16 v58 = v32;
          _os_log_impl(&dword_1D49D5000, v29, OS_LOG_TYPE_DEBUG, "%{public}@Current primary service of accessory is %@(%@)", buf, 0x20u);
        }
LABEL_21:
        ++v18;
      }
      while (v16 != v18);
      uint64_t v41 = [(NSMutableArray *)obj countByEnumeratingWithState:&v49 objects:v59 count:16];
      uint64_t v16 = v41;
      if (!v41)
      {
LABEL_43:

        break;
      }
    }
  }
  os_unfair_recursive_lock_unlock();
}

- (BOOL)wasUpdatedWithServiceType:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self findServiceWithServiceType:v4];

  if (v5)
  {
    id v6 = [(HMDHAPAccessory *)self initialServiceTypeUUIDs];
    int v7 = [v6 containsObject:v4] ^ 1;
  }
  else
  {
    LOBYTE(v7) = 0;
  }

  return v7;
}

- (void)setInitialServiceTypeUUIDs:(id)a3
{
  id v6 = a3;
  os_unfair_recursive_lock_lock_with_options();
  id v4 = (NSSet *)[v6 copy];
  initialServiceTypeUUIDs = self->_initialServiceTypeUUIDs;
  self->_initialServiceTypeUUIDs = v4;

  os_unfair_recursive_lock_unlock();
}

- (NSSet)serviceTypeUUIDs
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  os_unfair_recursive_lock_lock_with_options();
  BOOL v3 = objc_msgSend(MEMORY[0x1E4F1CA80], "setWithCapacity:", -[NSMutableArray count](self->_services, "count"));
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v4 = self->_services;
  uint64_t v5 = [(NSMutableArray *)v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v4);
        }
        id v8 = objc_msgSend(*(id *)(*((void *)&v11 + 1) + 8 * i), "serviceType", (void)v11);
        [v3 addObject:v8];
      }
      uint64_t v5 = [(NSMutableArray *)v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v5);
  }

  BOOL v9 = (void *)[v3 copy];
  os_unfair_recursive_lock_unlock();
  return (NSSet *)v9;
}

- (HMFPairingIdentity)pairingIdentity
{
  id v3 = objc_alloc(MEMORY[0x1E4F65510]);
  id v4 = [(HMDHAPAccessory *)self publicKey];
  uint64_t v5 = (void *)[v3 initWithPairingKeyData:v4];

  id v6 = objc_alloc(MEMORY[0x1E4F5BE00]);
  int v7 = [(HMDAccessory *)self identifier];
  id v8 = (void *)[v6 initWithIdentifier:v7 publicKey:v5 privateKey:0 permissions:0];

  return (HMFPairingIdentity *)v8;
}

- (void)pairingsWithCompletionHandler:(id)a3
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = self;
  int v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    uint64_t v27 = v8;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_DEFAULT, "%{public}@Requesting pairings", buf, 0xCu);
  }
  BOOL v9 = [(HMDAccessory *)v6 home];
  char v10 = [v9 isOwnerUser];

  if (v10)
  {
    uint64_t v25 = 0;
    long long v11 = [(HMDHAPAccessory *)v6 preferredHAPAccessoryForOperation:7 linkType:&v25];
    long long v12 = [v11 server];

    if (v12)
    {
      long long v13 = [(HMDAccessory *)v6 workQueue];
      v23[0] = MEMORY[0x1E4F143A8];
      v23[1] = 3221225472;
      id v23[2] = __49__HMDHAPAccessory_pairingsWithCompletionHandler___block_invoke;
      v23[3] = &unk_1E6A187D0;
      v23[4] = v6;
      id v24 = v4;
      [v12 listPairingsWithCompletionQueue:v13 completionHandler:v23];
    }
    else
    {
      uint64_t v18 = (void *)MEMORY[0x1D9452090]();
      uint64_t v19 = v6;
      int v20 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        id v21 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v27 = v21;
        _os_log_impl(&dword_1D49D5000, v20, OS_LOG_TYPE_DEFAULT, "%{public}@Unable to list pairings without a reachable accessory server", buf, 0xCu);
      }
      if (v4)
      {
        int v22 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
        (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v22);
      }
    }
    goto LABEL_14;
  }
  long long v14 = (void *)MEMORY[0x1D9452090]();
  __int16 v15 = v6;
  uint64_t v16 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v17 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    uint64_t v27 = v17;
    _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_DEBUG, "%{public}@Only owners may list pairings", buf, 0xCu);
  }
  if (v4)
  {
    long long v12 = [MEMORY[0x1E4F28C58] hmErrorWithCode:17];
    (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v12);
LABEL_14:
  }
}

void __49__HMDHAPAccessory_pairingsWithCompletionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  int v7 = (void *)MEMORY[0x1D9452090]();
  id v8 = *(id *)(a1 + 32);
  BOOL v9 = HMFGetOSLogHandle();
  char v10 = v9;
  if (v6)
  {
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
    long long v11 = HMFGetLogIdentifier();
    int v16 = 138543618;
    uint64_t v17 = v11;
    __int16 v18 = 2112;
    id v19 = v6;
    long long v12 = "%{public}@Failed to list pairings with error: %@";
    long long v13 = v10;
    os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
  }
  else
  {
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_INFO)) {
      goto LABEL_7;
    }
    long long v11 = HMFGetLogIdentifier();
    int v16 = 138543618;
    uint64_t v17 = v11;
    __int16 v18 = 2112;
    id v19 = v5;
    long long v12 = "%{public}@Successfully requested pairing identities: %@";
    long long v13 = v10;
    os_log_type_t v14 = OS_LOG_TYPE_INFO;
  }
  _os_log_impl(&dword_1D49D5000, v13, v14, v12, (uint8_t *)&v16, 0x16u);

LABEL_7:
  uint64_t v15 = *(void *)(a1 + 40);
  if (v15) {
    (*(void (**)(uint64_t, id, id))(v15 + 16))(v15, v5, v6);
  }
}

- (void)removeUser:(id)a3 completionHandler:(id)a4
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  int v7 = (void (**)(id, void *))a4;
  id v8 = (void *)MEMORY[0x1D9452090]();
  BOOL v9 = self;
  char v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    long long v11 = HMFGetLogIdentifier();
    int v13 = 138543362;
    os_log_type_t v14 = v11;
    _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, "%{public}@Does not support remove user interface", (uint8_t *)&v13, 0xCu);
  }
  if (v7)
  {
    long long v12 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
    v7[2](v7, v12);
  }
}

- (void)addUser:(id)a3 completionHandler:(id)a4
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  int v7 = (void (**)(id, void *))a4;
  id v8 = (void *)MEMORY[0x1D9452090]();
  BOOL v9 = self;
  char v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    long long v11 = HMFGetLogIdentifier();
    int v13 = 138543362;
    os_log_type_t v14 = v11;
    _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, "%{public}@Does not support add user interface", (uint8_t *)&v13, 0xCu);
  }
  if (v7)
  {
    long long v12 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
    v7[2](v7, v12);
  }
}

- (void)verifyPairingWithCompletionHandler:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __54__HMDHAPAccessory_verifyPairingWithCompletionHandler___block_invoke;
  v7[3] = &unk_1E6A19530;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __54__HMDHAPAccessory_verifyPairingWithCompletionHandler___block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __54__HMDHAPAccessory_verifyPairingWithCompletionHandler___block_invoke_2;
  v5[3] = &unk_1E6A0F6C0;
  v5[4] = v2;
  id v6 = *(id *)(a1 + 40);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = __54__HMDHAPAccessory_verifyPairingWithCompletionHandler___block_invoke_375;
  v3[3] = &unk_1E6A19358;
  id v4 = *(id *)(a1 + 40);
  [v2 _performOperation:10 linkType:0 operationBlock:v5 errorBlock:v3];
}

void __54__HMDHAPAccessory_verifyPairingWithCompletionHandler___block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) findCharacteristicType:*MEMORY[0x1E4F5B8A8] forServiceType:*MEMORY[0x1E4F5BA48]];
  id v5 = [v4 characteristicForHAPAccessory:v3];
  if (v5)
  {
    id v6 = [*(id *)(a1 + 32) workQueue];
    [v3 readValueForCharacteristic:v5 timeout:v6 completionQueue:*(void *)(a1 + 40) completionHandler:0.0];
  }
  else
  {
    int v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = *(id *)(a1 + 32);
    BOOL v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      char v10 = HMFGetLogIdentifier();
      long long v11 = [v4 instanceID];
      long long v12 = [v4 characteristicType];
      uint64_t v15 = [v3 server];
      int v16 = v7;
      int v13 = [v15 identifier];
      *(_DWORD *)buf = 138544130;
      __int16 v18 = v10;
      __int16 v19 = 2112;
      uint64_t v20 = v11;
      __int16 v21 = 2112;
      int v22 = v12;
      __int16 v23 = 2112;
      id v24 = v13;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_DEFAULT, "%{public}@Cannot map HMDCharacteristic %@/%@ to a HAPCharacteristic for server %@ to verify pairing", buf, 0x2Au);

      int v7 = v16;
    }

    uint64_t v14 = *(void *)(a1 + 40);
    id v6 = [MEMORY[0x1E4F28C58] errorWithDomain:*MEMORY[0x1E4F2D140] code:2 userInfo:0];
    (*(void (**)(uint64_t, void, void *))(v14 + 16))(v14, 0, v6);
  }
}

uint64_t __54__HMDHAPAccessory_verifyPairingWithCompletionHandler___block_invoke_375(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

- (void)savePublicKeyToKeychain
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if ([(HMDHAPAccessory *)self isPrimary])
  {
    id v3 = [MEMORY[0x1E4F5BE48] systemStore];
    id v4 = [(HMDHAPAccessory *)self publicKey];
    id v5 = [(HMDHAPAccessory *)self pairingUsername];
    id v15 = 0;
    int v6 = [v3 savePublicKey:v4 forAccessoryName:v5 error:&v15];
    id v7 = v15;

    if (v6) {
      BOOL v8 = v7 == 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (!v8)
    {
      BOOL v9 = (void *)MEMORY[0x1D9452090]();
      char v10 = self;
      long long v11 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        long long v12 = HMFGetLogIdentifier();
        int v13 = [(HMDHAPAccessory *)v10 publicKey];
        uint64_t v14 = [(HMDHAPAccessory *)v10 pairingUsername];
        *(_DWORD *)buf = 138544130;
        uint64_t v17 = v12;
        __int16 v18 = 2112;
        __int16 v19 = v13;
        __int16 v20 = 2112;
        __int16 v21 = v14;
        __int16 v22 = 2112;
        id v23 = v7;
        _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_INFO, "%{public}@Failed to save public key(%@) pairing username(%@): %@", buf, 0x2Au);
      }
    }
  }
}

- (BOOL)associateControllerKeyWithAccessory:(id)a3 error:(id *)a4
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  if (!v6) {
    _HMFPreconditionFailure();
  }
  id v7 = v6;
  BOOL v8 = (void *)MEMORY[0x1D9452090]();
  BOOL v9 = self;
  char v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    long long v11 = HMFGetLogIdentifier();
    long long v12 = [v7 controllerKeyIdentifier];
    int v27 = 138543618;
    uint64_t v28 = v11;
    __int16 v29 = 2112;
    id v30 = v12;
    _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, "%{public}@Going to save new pairing identity %@ to keychain", (uint8_t *)&v27, 0x16u);
  }
  int v13 = [MEMORY[0x1E4F5BE48] systemStore];
  int v14 = [v13 establishRelationshipBetweenAccessoryAndControllerKey:v7 error:a4];
  if (v14 && !*a4)
  {
    id v15 = (void *)MEMORY[0x1D9452090]();
    id v23 = v9;
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      uint64_t v24 = HMFGetLogIdentifier();
      uint64_t v25 = [v7 controllerKeyIdentifier];
      id v26 = [(HMDHAPAccessory *)v23 pairingUsername];
      int v27 = 138543874;
      uint64_t v28 = v24;
      __int16 v29 = 2112;
      id v30 = v25;
      __int16 v31 = 2112;
      int v32 = v26;
      _os_log_impl(&dword_1D49D5000, v17, OS_LOG_TYPE_INFO, "%{public}@Successfully updated key chain entry to associate controller key [%@] with the accessory [%@]", (uint8_t *)&v27, 0x20u);
    }
  }
  else
  {
    id v15 = (void *)MEMORY[0x1D9452090]();
    int v16 = v9;
    uint64_t v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      __int16 v18 = HMFGetLogIdentifier();
      __int16 v19 = [v7 controllerKeyIdentifier];
      __int16 v20 = [(HMDHAPAccessory *)v16 pairingUsername];
      id v21 = *a4;
      int v27 = 138544130;
      uint64_t v28 = v18;
      __int16 v29 = 2112;
      id v30 = v19;
      __int16 v31 = 2112;
      int v32 = v20;
      __int16 v33 = 2112;
      id v34 = v21;
      _os_log_impl(&dword_1D49D5000, v17, OS_LOG_TYPE_ERROR, "%{public}@Unable to associate accessory controller key identifier to the accessory public key. PV with this accessory will fail in future : controller Key to be used : %@ forAccessory : %@, %@", (uint8_t *)&v27, 0x2Au);
    }
  }

  return v14;
}

- (void)setPairingUsername:(id)a3 publicKey:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  BOOL v8 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __48__HMDHAPAccessory_setPairingUsername_publicKey___block_invoke;
  block[3] = &unk_1E6A19668;
  void block[4] = self;
  id v12 = v6;
  id v13 = v7;
  id v9 = v7;
  id v10 = v6;
  dispatch_async(v8, block);
}

uint64_t __48__HMDHAPAccessory_setPairingUsername_publicKey___block_invoke(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)MEMORY[0x1D9452090]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 48);
    int v9 = 138543874;
    id v10 = v5;
    __int16 v11 = 2112;
    uint64_t v12 = v6;
    __int16 v13 = 2112;
    uint64_t v14 = v7;
    _os_log_impl(&dword_1D49D5000, v4, OS_LOG_TYPE_INFO, "%{public}@Going to update username & public key : [%@ / %@]", (uint8_t *)&v9, 0x20u);
  }
  [*(id *)(a1 + 32) setPublicKey:*(void *)(a1 + 48)];
  return [*(id *)(a1 + 32) setPairingUsername:*(void *)(a1 + 40)];
}

- (void)handlePairedStateChange:(BOOL)a3
{
  id v5 = [(HMDAccessory *)self workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __43__HMDHAPAccessory_handlePairedStateChange___block_invoke;
  v6[3] = &unk_1E6A19B58;
  void v6[4] = self;
  BOOL v7 = a3;
  dispatch_async(v5, v6);
}

void __43__HMDHAPAccessory_handlePairedStateChange___block_invoke(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)MEMORY[0x1D9452090]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    __int16 v19 = v5;
    _os_log_impl(&dword_1D49D5000, v4, OS_LOG_TYPE_INFO, "%{public}@Notifying clients of a change in pairing state", buf, 0xCu);
  }
  uint64_t v6 = (void *)MEMORY[0x1E4F654B0];
  uint64_t v7 = *MEMORY[0x1E4F2EC30];
  id v8 = objc_alloc(MEMORY[0x1E4F65488]);
  int v9 = [*(id *)(a1 + 32) uuid];
  id v10 = (void *)[v8 initWithTarget:v9];
  __int16 v11 = objc_msgSend(NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 40), @"kAccessoryIsPairedKey");
  uint64_t v17 = v11;
  uint64_t v12 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v17 forKeys:&v16 count:1];
  __int16 v13 = [v6 messageWithName:v7 destination:v10 payload:v12];

  uint64_t v14 = [*(id *)(a1 + 32) messageSendPolicy];
  [v13 setSendPolicy:v14];

  uint64_t v15 = [*(id *)(a1 + 32) msgDispatcher];
  [v15 sendMessage:v13];
}

- (void)timerDidFire:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __32__HMDHAPAccessory_timerDidFire___block_invoke;
  v7[3] = &unk_1E6A197C8;
  id v8 = v4;
  int v9 = self;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __32__HMDHAPAccessory_timerDidFire___block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) accessoryDiscoveryBackoffTimer];

  if (v2 == v3)
  {
    id v8 = *(void **)(a1 + 40);
    [v8 _handleDiscoveryBackoffTimerFired];
  }
  else
  {
    id v4 = *(void **)(a1 + 32);
    id v5 = [*(id *)(a1 + 40) accessoryKeyRefreshTimer];

    if (v4 == v5)
    {
      int v9 = *(void **)(a1 + 40);
      [v9 _handleKeyRefreshTimerFired];
    }
    else
    {
      id v6 = *(void **)(a1 + 32);
      uint64_t v7 = [*(id *)(a1 + 40) sessionRestoreTimer];

      if (v6 == v7)
      {
        id v10 = *(void **)(a1 + 40);
        [v10 _handleSessionRestoreTimerFired];
      }
    }
  }
}

- (id)updateAccessoryFlagsAndNotifyClients:(id)a3
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = self;
  uint64_t v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    uint64_t v20 = v8;
    __int16 v21 = 2112;
    id v22 = v4;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Updating accessory flags: %@", buf, 0x16u);
  }
  int v9 = [(HMDHAPAccessory *)v6 accessoryFlags];
  char v10 = HMFEqualObjects();

  if (v10)
  {
    __int16 v11 = 0;
  }
  else
  {
    [(HMDHAPAccessory *)v6 setAccessoryFlags:v4];
    uint64_t v12 = [(HMDHAPAccessory *)v6 accessoryFlags];
    __int16 v18 = v12;
    __int16 v13 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v18 forKeys:&v17 count:1];

    uint64_t v14 = (void *)MEMORY[0x1E4F65480];
    uint64_t v15 = [MEMORY[0x1E4F29128] UUID];
    __int16 v11 = [v14 entitledMessageWithName:@"kAccessoryFlagsChangedNotificationKey" identifier:v15 messagePayload:v13];
  }
  return v11;
}

- (id)namesOfServicesShowingTilesInHomeApp
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v3 = [MEMORY[0x1E4F1CA48] array];
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  id v4 = [(HMDHAPAccessory *)self services];
  id v5 = (void *)[v4 copy];

  id obj = v5;
  uint64_t v6 = [v5 countByEnumeratingWithState:&v29 objects:v39 count:16];
  if (v6)
  {
    uint64_t v8 = v6;
    uint64_t v9 = *(void *)v30;
    *(void *)&long long v7 = 138543874;
    long long v26 = v7;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v30 != v9) {
          objc_enumerationMutation(obj);
        }
        __int16 v11 = *(void **)(*((void *)&v29 + 1) + 8 * i);
        uint64_t v12 = [(HMDHAPAccessory *)self hapMetadata];
        __int16 v13 = [v11 type];
        int v14 = [v12 shouldHomeAppShowTileForServiceType:v13];

        if (v14)
        {
          uint64_t v15 = [v11 name];

          if (v15)
          {
            uint64_t v16 = [v11 name];
            [v3 addObject:v16];
          }
          else
          {
            uint64_t v17 = (void *)MEMORY[0x1D9452090]();
            __int16 v18 = self;
            __int16 v19 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            {
              HMFGetLogIdentifier();
              uint64_t v20 = v27 = v17;
              [v11 type];
              id v22 = v21 = v3;
              *(_DWORD *)buf = v26;
              id v34 = v20;
              __int16 v35 = 2112;
              int v36 = v11;
              __int16 v37 = 2112;
              int v38 = v22;
              _os_log_impl(&dword_1D49D5000, v19, OS_LOG_TYPE_ERROR, "%{public}@The name of the service (%@) with type (%@) is nil.", buf, 0x20u);

              id v3 = v21;
              uint64_t v17 = v27;
            }
          }
        }
      }
      uint64_t v8 = [obj countByEnumeratingWithState:&v29 objects:v39 count:16];
    }
    while (v8);
  }

  if (![v3 count])
  {
    uint64_t v23 = [(HMDHAPAccessory *)self name];

    if (v23)
    {
      uint64_t v24 = [(HMDHAPAccessory *)self name];
      [v3 addObject:v24];
    }
  }
  return v3;
}

- (BOOL)isReadingRequiredForBTLEAccessoryCharacteristic:(id)a3 forceReadFWVersion:(BOOL)a4
{
  id v6 = a3;
  long long v7 = [v6 service];
  uint64_t v8 = [v7 type];

  if (([v8 isEqualToString:*MEMORY[0x1E4F2DDB8]] & 1) == 0
    && ![v8 isEqualToString:*MEMORY[0x1E4F5BA50]])
  {
LABEL_23:
    if (![v8 isEqualToString:@"00000239-0000-1000-8000-0026BB765291"]
      || ([v6 type],
          int v27 = objc_claimAutoreleasedReturnValue(),
          int v28 = [v27 isEqualToString:@"0000023A-0000-1000-8000-0026BB765291"],
          v27,
          !v28))
    {
      if ([v8 isEqualToString:@"00000701-0000-1000-8000-0026BB765291"])
      {
        long long v29 = [(HMDAccessory *)self home];
        int v30 = [v29 isOwnerUser];

        if (v30)
        {
          long long v31 = [v6 type];
          int v32 = [v31 isEqualToString:@"00000702-0000-1000-8000-0026BB765291"];

          if (v32)
          {
            __int16 v11 = [(HMDHAPAccessory *)self internalThreadCapabilities];
            goto LABEL_34;
          }
          __int16 v33 = [v6 type];
          int v34 = [v33 isEqualToString:@"00000703-0000-1000-8000-0026BB765291"];

          if (v34)
          {
            __int16 v11 = [(HMDHAPAccessory *)self internalThreadStatus];
            goto LABEL_34;
          }
          __int16 v35 = [v6 type];
          int v36 = [v35 isEqualToString:@"0000022B-0000-1000-8000-0026BB765291"];

          if (v36)
          {
            __int16 v11 = [(HMDHAPAccessory *)self internalThreadActive];
            goto LABEL_34;
          }
        }
      }
      BOOL v18 = 0;
      goto LABEL_35;
    }
    __int16 v11 = [(HMDHAPAccessory *)self sleepInterval];
LABEL_34:
    BOOL v18 = v11 == 0;

    goto LABEL_35;
  }
  uint64_t v9 = [v6 type];
  int v10 = [v9 isEqualToString:*MEMORY[0x1E4F2CF48]];

  if (v10)
  {
    __int16 v11 = [(HMDAccessory *)self providedName];
    goto LABEL_34;
  }
  uint64_t v12 = [v6 type];
  int v13 = [v12 isEqualToString:*MEMORY[0x1E4F2CF30]];

  if (v13)
  {
    __int16 v11 = [(HMDAccessory *)self model];
    goto LABEL_34;
  }
  int v14 = [v6 type];
  int v15 = [v14 isEqualToString:*MEMORY[0x1E4F2CF28]];

  if (v15)
  {
    __int16 v11 = [(HMDAccessory *)self manufacturer];
    goto LABEL_34;
  }
  uint64_t v16 = [v6 type];
  int v17 = [v16 isEqualToString:*MEMORY[0x1E4F2CEF0]];

  if (v17)
  {
    if ([(HMDHAPAccessory *)self supportsHAP] && a4) {
      goto LABEL_12;
    }
LABEL_16:
    __int16 v11 = [(HMDAccessory *)self firmwareVersion];
    goto LABEL_34;
  }
  __int16 v19 = [v6 type];
  int v20 = [v19 isEqualToString:*MEMORY[0x1E4F5B898]];

  if (!v20 || ![(HMDHAPAccessory *)self supportsCHIP])
  {
    __int16 v21 = [v6 type];
    int v22 = [v21 isEqualToString:*MEMORY[0x1E4F2CFA0]];

    if (v22)
    {
      __int16 v11 = [(HMDAccessory *)self serialNumber];
      goto LABEL_34;
    }
    uint64_t v23 = [v6 type];
    int v24 = [v23 isEqualToString:@"000000A6-0000-1000-8000-0026BB765291"];

    if (v24)
    {
      __int16 v11 = [(HMDHAPAccessory *)self accessoryFlags];
      goto LABEL_34;
    }
    uint64_t v25 = [v6 type];
    int v26 = [v25 isEqualToString:@"00000220-0000-1000-8000-0026BB765291"];

    if (v26)
    {
      __int16 v11 = [(HMDAccessory *)self productData];
      goto LABEL_34;
    }
    goto LABEL_23;
  }
  if (!a4) {
    goto LABEL_16;
  }
LABEL_12:
  BOOL v18 = 1;
LABEL_35:

  return v18;
}

- (void)handleCharacteristicsChangedNotification:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __60__HMDHAPAccessory_handleCharacteristicsChangedNotification___block_invoke;
  v7[3] = &unk_1E6A197C8;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __60__HMDHAPAccessory_handleCharacteristicsChangedNotification___block_invoke(uint64_t a1)
{
  objc_msgSend(*(id *)(a1 + 32), "__checkLowBatteryUpdatedNotification:", *(void *)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) userInfo];
  objc_msgSend(v2, "__handleCharacteristicsChangedPayload:", v3);
}

- (void)__handleCharacteristicsChangedPayload:(id)a3
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  id v4 = objc_msgSend(a3, "hmf_arrayForKey:", @"kModifiedCharacteristicsKey");
  long long v31 = [MEMORY[0x1E4F1CA60] dictionary];
  char v43 = 0;
  int v28 = [(HMDAccessory *)self home];
  int v30 = [(HMDHAPAccessory *)self transactionWithObjectChangeType:2];
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  id obj = v4;
  uint64_t v5 = [obj countByEnumeratingWithState:&v39 objects:v45 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v40;
    long long v29 = self;
    do
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v40 != v7) {
          objc_enumerationMutation(obj);
        }
        uint64_t v9 = *(void **)(*((void *)&v39 + 1) + 8 * i);
        int v10 = [v9 accessory];
        int v11 = [v10 isEqual:self];

        if (v11)
        {
          aBlock[0] = MEMORY[0x1E4F143A8];
          aBlock[1] = 3221225472;
          aBlock[2] = __57__HMDHAPAccessory___handleCharacteristicsChangedPayload___block_invoke;
          aBlock[3] = &unk_1E6A0AE48;
          void aBlock[4] = self;
          void aBlock[5] = v9;
          id v38 = v31;
          uint64_t v12 = _Block_copy(aBlock);
          int v13 = [v9 service];
          int v14 = [v9 type];
          int v15 = [v9 value];
          uint64_t v16 = [v13 serviceType];
          int v17 = [v13 accessory];
          +[HMDService processUpdateForCharacteristicType:v14 value:v15 serviceType:v16 service:v13 serviceTransactionGetter:v12 accessory:v17 accessoryTransaction:v30 accessoryTransactionChanged:&v43];

          self = v29;
        }
      }
      uint64_t v6 = [obj countByEnumeratingWithState:&v39 objects:v45 count:16];
    }
    while (v6);
  }

  if (v43 || [v31 count])
  {
    BOOL v18 = +[HMDBackingStoreTransactionOptions optionsWithSource:0 destination:0 mustReplay:0 mustPush:0];
    if ([v28 isCurrentDeviceConfirmedPrimaryResident])
    {
      uint64_t v19 = +[HMDBackingStoreTransactionOptions optionsWithSource:0 destination:2 mustReplay:1 mustPush:0];

      BOOL v18 = (void *)v19;
    }
    int v20 = [v28 backingStore];
    __int16 v21 = [v20 transaction:@"HMDCharacteristicsChanged" options:v18];

    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    id v22 = v31;
    uint64_t v23 = [v22 countByEnumeratingWithState:&v33 objects:v44 count:16];
    if (v23)
    {
      uint64_t v24 = v23;
      uint64_t v25 = *(void *)v34;
      do
      {
        for (uint64_t j = 0; j != v24; ++j)
        {
          if (*(void *)v34 != v25) {
            objc_enumerationMutation(v22);
          }
          int v27 = [v22 objectForKey:*(void *)(*((void *)&v33 + 1) + 8 * j)];
          [v21 add:v27 withMessage:0];
        }
        uint64_t v24 = [v22 countByEnumeratingWithState:&v33 objects:v44 count:16];
      }
      while (v24);
    }

    if (v43) {
      [v21 add:v30];
    }
    [v21 run];
  }
}

id __57__HMDHAPAccessory___handleCharacteristicsChangedPayload___block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) service];
  id v4 = [v3 uuid];
  uint64_t v5 = [v2 getOrCreateServiceUpdateTransactionForKey:v4 fromDictionary:*(void *)(a1 + 48)];

  return v5;
}

- (void)__checkLowBatteryUpdatedNotification:(id)a3
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [v4 userInfo];
  uint64_t v6 = [v5 objectForKeyedSubscript:@"kModifiedCharacteristicsKey"];

  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  id v8 = v7;

  uint64_t v9 = objc_msgSend(v8, "hmf_firstObjectWithCharacteristicType:", *MEMORY[0x1E4F2CFB8]);
  int v10 = v9;
  if (v9)
  {
    int v11 = [v9 value];
    BOOL v12 = +[HMDCharacteristic value:v11 differentThan:&unk_1F2DC7C60];
    if (v12 == [(HMDAccessory *)self isLowBattery])
    {
      BOOL v13 = !v12;
      int v14 = (void *)MEMORY[0x1D9452090]();
      int v15 = self;
      uint64_t v16 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        int v17 = HMFGetLogIdentifier();
        BOOL v18 = [v10 previousValue];
        int v24 = 138543874;
        uint64_t v25 = v17;
        __int16 v26 = 2112;
        int v27 = v18;
        __int16 v28 = 2112;
        long long v29 = v11;
        _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_DEBUG, "%{public}@Low Battery value updated: %@ -> %@", (uint8_t *)&v24, 0x20u);
      }
      uint64_t v19 = (void *)MEMORY[0x1D9452090]();
      int v20 = v15;
      __int16 v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        id v22 = HMFGetLogIdentifier();
        uint64_t v23 = HMFBooleanToString();
        int v24 = 138543618;
        uint64_t v25 = v22;
        __int16 v26 = 2114;
        int v27 = v23;
        _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_INFO, "%{public}@Updating low battery to %{public}@", (uint8_t *)&v24, 0x16u);
      }
      [(HMDAccessory *)v20 setLowBattery:v13];
    }
  }
}

- (void)handleRoomChanged:(id)a3
{
  id v19 = a3;
  id v4 = [v19 object];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  id v6 = v5;

  if (v6)
  {
    uint64_t v7 = [v6 uuid];
    id v8 = [(HMDAccessory *)self uuid];
    int v9 = [v7 isEqual:v8];

    if (v9)
    {
      int v10 = [v19 userInfo];
      int v11 = objc_msgSend(v10, "hmf_stringForKey:", @"kRoomOldNameKey");

      [(HMDHAPAccessory *)self _handleRoomChangedFromOldRoomName:v11];
      BOOL v12 = [v19 userInfo];
      char v13 = objc_msgSend(v12, "hmf_BOOLForKey:", @"HMIsCloudSourceKey");

      if ([(HMDHAPAccessory *)self hasSmartSpeakerService])
      {
        int v14 = [(HMDHAPAccessory *)self getConfiguredName];
        if (v14) {
          char v13 = 1;
        }

        if ((v13 & 1) == 0)
        {
          int v15 = [v19 userInfo];
          uint64_t v16 = objc_msgSend(v15, "hmf_stringForKey:", @"kRoomOldNameKey");

          int v17 = [(HMDHAPAccessory *)self name];
          char v18 = HMFEqualObjects();

          if ((v18 & 1) == 0) {
            [(HMDAccessory *)self notifyAccessoryNameChanged:1];
          }
        }
      }
    }
  }
}

- (void)handleRoomNameChanged:(id)a3
{
  id v18 = a3;
  id v4 = [v18 object];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  id v6 = v5;

  if (v6)
  {
    uint64_t v7 = [(HMDAccessory *)self room];
    int v8 = HMFEqualObjects();

    if (v8)
    {
      int v9 = [v18 userInfo];
      int v10 = objc_msgSend(v9, "hmf_stringForKey:", @"kRoomOldNameKey");

      [(HMDHAPAccessory *)self _handleRoomChangedFromOldRoomName:v10];
      int v11 = [v18 userInfo];
      char v12 = objc_msgSend(v11, "hmf_BOOLForKey:", @"HMIsCloudSourceKey");

      if ([(HMDHAPAccessory *)self hasSmartSpeakerService])
      {
        char v13 = [(HMDHAPAccessory *)self getConfiguredName];
        if (v13) {
          char v12 = 1;
        }

        if ((v12 & 1) == 0)
        {
          int v14 = [v18 userInfo];
          int v15 = objc_msgSend(v14, "hmf_stringForKey:", @"kRoomOldNameKey");

          uint64_t v16 = [(HMDHAPAccessory *)self name];
          char v17 = HMFEqualObjects();

          if ((v17 & 1) == 0) {
            [(HMDAccessory *)self notifyAccessoryNameChanged:1];
          }
        }
      }
    }
  }
}

- (void)_handleRoomChangedFromOldRoomName:(id)a3
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [(HMDAccessory *)self room];
  id v6 = [v5 name];
  char v7 = HMFEqualObjects();

  if ((v7 & 1) == 0)
  {
    int v8 = [(HMDAccessory *)self room];
    int v9 = [(HMDHAPAccessory *)self _messagesForUpdatedRoom:v8];

    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    id v10 = v9;
    uint64_t v11 = [v10 countByEnumeratingWithState:&v17 objects:v21 count:16];
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)v18;
      do
      {
        uint64_t v14 = 0;
        do
        {
          if (*(void *)v18 != v13) {
            objc_enumerationMutation(v10);
          }
          uint64_t v15 = *(void *)(*((void *)&v17 + 1) + 8 * v14);
          uint64_t v16 = [(HMDAccessory *)self msgDispatcher];
          [v16 sendMessage:v15 completionHandler:0];

          ++v14;
        }
        while (v12 != v14);
        uint64_t v12 = [v10 countByEnumeratingWithState:&v17 objects:v21 count:16];
      }
      while (v12);
    }
  }
}

- (id)_messagesForUpdatedRoom:(id)a3
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v4 = objc_msgSend(MEMORY[0x1E4F1CA48], "array", a3);
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v5 = [(HMDHAPAccessory *)self services];
  uint64_t v6 = [v5 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v19;
    uint64_t v9 = *MEMORY[0x1E4F2DEF0];
    while (2)
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v19 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v11 = *(void **)(*((void *)&v18 + 1) + 8 * i);
        uint64_t v12 = [v11 serviceType];
        int v13 = [v12 isEqualToString:v9];

        if (v13)
        {
          uint64_t v14 = [(HMDAccessory *)self room];
          uint64_t v15 = [v11 messagesForUpdatedRoom:v14];
          [v4 addObjectsFromArray:v15];

          goto LABEL_11;
        }
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v18 objects:v22 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }
LABEL_11:

  uint64_t v16 = (void *)[v4 copy];
  return v16;
}

- (void)_challengeAccessoryAuthMethod
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v3);

  BOOL v4 = [(HMDHAPAccessory *)self isPrimary];
  uint64_t v5 = (void *)MEMORY[0x1D9452090]();
  uint64_t v6 = self;
  uint64_t v7 = HMFGetOSLogHandle();
  uint64_t v8 = v7;
  if (v4)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      long long v19 = v9;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@Updating our auth method because c# changed", buf, 0xCu);
    }
    uint64_t v17 = 0;
    id v10 = [(HMDHAPAccessory *)v6 preferredHAPAccessoryForOperation:10 linkType:&v17];
    uint64_t v11 = [v10 server];

    if (v11)
    {
      [(HMDHAPAccessory *)v6 _updateAuthMethodWithServer:v11 completion:0];
    }
    else
    {
      int v13 = (void *)MEMORY[0x1D9452090]();
      uint64_t v14 = v6;
      uint64_t v15 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        uint64_t v16 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        long long v19 = v16;
        _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_ERROR, "%{public}@Unable to find accessory server to challenge for auth method", buf, 0xCu);
      }
    }
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v12 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      long long v19 = v12;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Not challenging for auth method on a bridged accessory", buf, 0xCu);
    }
  }
}

- (void)_configNumberUpdated
{
  id v3 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v3);

  [(HMDHAPAccessory *)self _challengeAccessoryAuthMethod];
}

- (void)_updateAuthMethodWithServer:(id)a3 completion:(id)a4
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v8);

  uint64_t v9 = (void *)MEMORY[0x1D9452090]();
  id v10 = self;
  uint64_t v11 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    uint64_t v12 = HMFGetLogIdentifier();
    int v13 = [v6 identifier];
    *(_DWORD *)buf = 138543618;
    uint64_t v20 = v12;
    __int16 v21 = 2112;
    uint64_t v22 = v13;
    _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_INFO, "%{public}@Attempting to validate the pairing auth method for %@", buf, 0x16u);
  }
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  void v16[2] = __58__HMDHAPAccessory__updateAuthMethodWithServer_completion___block_invoke;
  v16[3] = &unk_1E6A0AE20;
  void v16[4] = v10;
  id v17 = v6;
  id v18 = v7;
  id v14 = v7;
  id v15 = v6;
  [v15 validatePairingAuthMethod:v16];
}

void __58__HMDHAPAccessory__updateAuthMethodWithServer_completion___block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = [*(id *)(a1 + 32) workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __58__HMDHAPAccessory__updateAuthMethodWithServer_completion___block_invoke_2;
  block[3] = &unk_1E6A14940;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void **)(a1 + 40);
  id v11 = v5;
  uint64_t v12 = v7;
  id v13 = v8;
  id v14 = *(id *)(a1 + 48);
  uint64_t v15 = a3;
  id v9 = v5;
  dispatch_async(v6, block);
}

uint64_t __58__HMDHAPAccessory__updateAuthMethodWithServer_completion___block_invoke_2(uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    id v3 = [v2 domain];
    if ([v3 isEqualToString:*MEMORY[0x1E4F5B998]])
    {
      uint64_t v4 = [*(id *)(a1 + 32) code];

      if (v4 == 3)
      {
        id v5 = (void *)MEMORY[0x1D9452090]();
        id v6 = *(id *)(a1 + 40);
        uint64_t v7 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
          uint64_t v8 = HMFGetLogIdentifier();
          int v9 = [*(id *)(a1 + 48) configNumber];
          int v31 = 138543618;
          int v32 = v8;
          __int16 v33 = 1024;
          LODWORD(v34) = v9;
          _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Accessory doesn't support the new protocol (c#: %d)", (uint8_t *)&v31, 0x12u);
        }
        id v10 = *(void **)(a1 + 40);
        uint64_t v11 = [*(id *)(a1 + 48) configNumber];
        uint64_t v12 = &unk_1F2DC7C48;
        id v13 = v10;
LABEL_15:
        [v13 setInternalEnhancedAuthMethod:v12 configNumber:v11];
        uint64_t result = *(void *)(a1 + 56);
        if (!result) {
          return result;
        }
        uint64_t v23 = *(uint64_t (**)(void))(result + 16);
        return v23();
      }
    }
    else
    {
    }
    int v24 = (void *)MEMORY[0x1D9452090]();
    id v25 = *(id *)(a1 + 40);
    __int16 v26 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      int v27 = HMFGetLogIdentifier();
      __int16 v28 = *(void **)(a1 + 32);
      int v29 = [*(id *)(a1 + 48) configNumber];
      int v31 = 138543874;
      int v32 = v27;
      __int16 v33 = 2112;
      long long v34 = v28;
      __int16 v35 = 1024;
      int v36 = v29;
      _os_log_impl(&dword_1D49D5000, v26, OS_LOG_TYPE_ERROR, "%{public}@Unexpected error validating auth method: %@ (c#: %d)", (uint8_t *)&v31, 0x1Cu);
    }
    uint64_t v30 = *(void **)(a1 + 40);
    uint64_t v11 = [*(id *)(a1 + 48) configNumber];
    id v13 = v30;
    uint64_t v12 = 0;
    goto LABEL_15;
  }
  id v14 = (void *)MEMORY[0x1D9452090]();
  id v15 = *(id *)(a1 + 40);
  uint64_t v16 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    id v17 = HMFGetLogIdentifier();
    id v18 = HAPAuthMethodToString();
    int v19 = [*(id *)(a1 + 48) configNumber];
    int v31 = 138543874;
    int v32 = v17;
    __int16 v33 = 2112;
    long long v34 = v18;
    __int16 v35 = 1024;
    int v36 = v19;
    _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_DEFAULT, "%{public}@Saving validated auth method: %@ (c#: %d)", (uint8_t *)&v31, 0x1Cu);
  }
  uint64_t v20 = *(void **)(a1 + 40);
  __int16 v21 = [NSNumber numberWithUnsignedInteger:*(void *)(a1 + 64)];
  objc_msgSend(v20, "setInternalEnhancedAuthMethod:configNumber:", v21, objc_msgSend(*(id *)(a1 + 48), "configNumber"));

  uint64_t result = *(void *)(a1 + 56);
  if (result)
  {
    uint64_t v23 = *(uint64_t (**)(void))(result + 16);
    return v23();
  }
  return result;
}

- (void)_handleUpdatedName:(id)a3
{
  id v4 = a3;
  v6.receiver = self;
  v6.super_class = (Class)HMDHAPAccessory;
  [(HMDAccessory *)&v6 _handleUpdatedName:v4];
  if ([(HMDHAPAccessory *)self hasSmartSpeakerService])
  {
    id v5 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000228-0000-1000-8000-0026BB765291"];
    [(HMDHAPAccessory *)self _renameService:v5 name:v4 message:0 completionBlock:0];
  }
}

- (void)_renameAccessory:(id)a3 resetName:(BOOL)a4 message:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = a5;
  if ([(HMDHAPAccessory *)self hasSmartSpeakerService])
  {
    id v10 = v8;
    if (v6)
    {
      uint64_t v11 = [(HMDAccessory *)self room];
      uint64_t v12 = [v11 name];

      id v10 = (id)v12;
    }
    id v13 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000228-0000-1000-8000-0026BB765291"];
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    v15[2] = __54__HMDHAPAccessory__renameAccessory_resetName_message___block_invoke;
    v15[3] = &unk_1E6A0ADF8;
    v15[4] = self;
    BOOL v17 = v6;
    id v16 = v9;
    [(HMDHAPAccessory *)self _renameService:v13 name:v10 message:0 completionBlock:v15];
  }
  else
  {
    v14.receiver = self;
    v14.super_class = (Class)HMDHAPAccessory;
    [(HMDAccessory *)&v14 _renameAccessory:v8 resetName:v6 message:v9];
  }
}

void __54__HMDHAPAccessory__renameAccessory_resetName_message___block_invoke(uint64_t a1, void *a2)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    id v4 = 0;
  }
  else
  {
    uint64_t v5 = [*(id *)(a1 + 32) name];
    BOOL v6 = (void *)v5;
    if (v5 && !*(unsigned char *)(a1 + 48))
    {
      uint64_t v7 = @"kAccessoryName";
      v8[0] = v5;
      id v4 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v8 forKeys:&v7 count:1];
    }
    else
    {
      id v4 = 0;
    }
  }
  [*(id *)(a1 + 40) respondWithPayload:v4 error:v3];
}

- (void)handleUpdatedPassword:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __41__HMDHAPAccessory_handleUpdatedPassword___block_invoke;
  v7[3] = &unk_1E6A197C8;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __41__HMDHAPAccessory_handleUpdatedPassword___block_invoke(uint64_t a1)
{
}

- (void)handleUpdatedMinimumUserPrivilege:(int64_t)a3
{
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __53__HMDHAPAccessory_handleUpdatedMinimumUserPrivilege___block_invoke;
  v6[3] = &unk_1E6A189D0;
  void v6[4] = self;
  void v6[5] = a3;
  dispatch_async(v5, v6);
}

void __53__HMDHAPAccessory_handleUpdatedMinimumUserPrivilege___block_invoke(uint64_t a1)
{
}

- (BOOL)_serviceSupportsMinimumUserPrivilege:(id)a3
{
  id v3 = a3;
  id v4 = [v3 serviceType];
  if ([v4 isEqualToString:*MEMORY[0x1E4F2DEF0]])
  {
    char v5 = 1;
  }
  else
  {
    id v6 = [v3 serviceType];
    if ([v6 isEqualToString:@"00000228-0000-1000-8000-0026BB765291"])
    {
      char v5 = 1;
    }
    else
    {
      uint64_t v7 = [v3 serviceType];
      char v5 = [v7 isEqualToString:@"000000DA-0000-1000-8000-0026BB765291"];
    }
  }

  return v5;
}

- (BOOL)needsAirplayAccess
{
  id v3 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000228-0000-1000-8000-0026BB765291"];
  if (v3)
  {
    BOOL v4 = 1;
  }
  else
  {
    char v5 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000253-0000-1000-8000-0026BB765291"];
    BOOL v4 = v5 != 0;
  }
  return v4;
}

- (BOOL)_handleUpdatedServicesForWalletKey
{
  id v3 = [(HMDHAPAccessory *)self services];
  if (objc_msgSend(v3, "na_any:", &__block_literal_global_337)) {
    int v4 = objc_msgSend(v3, "na_any:", &__block_literal_global_339);
  }
  else {
    int v4 = 0;
  }
  os_unfair_recursive_lock_lock_with_options();
  int supportsWalletKey = self->_supportsWalletKey;
  if (supportsWalletKey == v4)
  {
    os_unfair_recursive_lock_unlock();
  }
  else
  {
    self->_int supportsWalletKey = v4;
    os_unfair_recursive_lock_unlock();
    logAndPostNotification(@"HMDAccessorySupportsWalletKeyDidChangeNotification", self, 0);
  }

  return supportsWalletKey != v4;
}

uint64_t __53__HMDHAPAccessory__handleUpdatedServicesForWalletKey__block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v2 = [a2 type];
  uint64_t v3 = [v2 isEqualToString:@"00000266-0000-1000-8000-0026BB765291"];

  return v3;
}

uint64_t __53__HMDHAPAccessory__handleUpdatedServicesForWalletKey__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v2 = [a2 type];
  uint64_t v3 = [v2 isEqualToString:*MEMORY[0x1E4F2DE88]];

  return v3;
}

- (BOOL)supportsAnyInPersonAccess
{
  if ([(HMDHAPAccessory *)self supportsAccessCode]) {
    return 1;
  }
  return [(HMDHAPAccessory *)self supportsWalletKey];
}

- (void)setSupportsWalletKey:(BOOL)a3
{
  os_unfair_recursive_lock_lock_with_options();
  self->_int supportsWalletKey = a3;
  os_unfair_recursive_lock_unlock();
}

- (BOOL)_handleUpdatedServicesForAccessCodes
{
  uint64_t v3 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000260-0000-1000-8000-0026BB765291"];
  int v4 = v3 != 0;

  os_unfair_recursive_lock_lock_with_options();
  int supportsAccessCode = self->_supportsAccessCode;
  if (supportsAccessCode == v4)
  {
    os_unfair_recursive_lock_unlock();
  }
  else
  {
    self->_int supportsAccessCode = v4;
    os_unfair_recursive_lock_unlock();
    logAndPostNotification(@"HMDAccessorySupportsAccessCodeDidChangeNotification", self, 0);
  }
  return supportsAccessCode != v4;
}

- (void)setSupportsAccessCode:(BOOL)a3
{
  os_unfair_recursive_lock_lock_with_options();
  self->_int supportsAccessCode = a3;
  os_unfair_recursive_lock_unlock();
}

- (void)setSiriEndpointCapabilities:(unint64_t)a3
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  os_unfair_recursive_lock_lock_with_options();
  if (self->_siriEndpointCapabilities == a3)
  {
    os_unfair_recursive_lock_unlock();
  }
  else
  {
    self->_unint64_t siriEndpointCapabilities = a3;
    uint64_t v5 = os_unfair_recursive_lock_unlock();
    id v6 = (void *)MEMORY[0x1D9452090](v5);
    uint64_t v7 = self;
    id v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      id v10 = [NSNumber numberWithUnsignedInteger:a3];
      int v14 = 138543618;
      id v15 = v9;
      __int16 v16 = 2112;
      BOOL v17 = v10;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@SiriEndPointFeatureSupportChanged to %@", (uint8_t *)&v14, 0x16u);
    }
    uint64_t v11 = [(HMDAccessory *)v7 home];
    uint64_t v12 = [v11 homeManager];
    id v13 = [(HMDAccessory *)v7 uuid];
    [v12 updateGenerationCounterWithReason:@"SiriEndPointFeatureSupportChanged" sourceUUID:v13 shouldNotifyClients:1];
  }
}

- (BOOL)hasBattery
{
  uint64_t v2 = [(HMDHAPAccessory *)self findServiceWithServiceType:*MEMORY[0x1E4F2DDD0]];
  BOOL v3 = v2 != 0;

  return v3;
}

- (void)setShouldDisconnectOnIdle:(BOOL)a3
{
  BOOL v3 = a3;
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = [(HMDHAPAccessory *)self bridge];
  id v6 = v5;
  if (v5) {
    [v5 getPrimaryHAPAccessories];
  }
  else {
  uint64_t v18 = [(HMDHAPAccessory *)self getPrimaryHAPAccessories];
  }
  uint64_t v7 = os_unfair_recursive_lock_lock_with_options();
  if (self->_shouldDisconnectOnIdle != v3)
  {
    context = (void *)MEMORY[0x1D9452090](v7);
    id v8 = self;
    HMFGetOSLogHandle();
    id v9 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      HMFGetLogIdentifier();
      id v10 = (id)objc_claimAutoreleasedReturnValue();
      HMFBooleanToString();
      id v11 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v12 = HMFBooleanToString();
      *(_DWORD *)buf = 138543874;
      id v25 = v10;
      __int16 v26 = 2112;
      id v27 = v11;
      __int16 v28 = 2112;
      int v29 = v12;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Updating shouldDisconnectOnIdle from: %@ to: %@", buf, 0x20u);
    }
    self->_shouldDisconnectOnIdle = v3;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    id v13 = v18;
    uint64_t v14 = [v13 countByEnumeratingWithState:&v19 objects:v23 count:16];
    if (v14)
    {
      uint64_t v15 = *(void *)v20;
      do
      {
        for (uint64_t i = 0; i != v14; ++i)
        {
          if (*(void *)v20 != v15) {
            objc_enumerationMutation(v13);
          }
          objc_msgSend(*(id *)(*((void *)&v19 + 1) + 8 * i), "setShouldDisconnectOnIdle:", v3, context);
        }
        uint64_t v14 = [v13 countByEnumeratingWithState:&v19 objects:v23 count:16];
      }
      while (v14);
    }
  }
  os_unfair_recursive_lock_unlock();
}

- (void)setSymptomsHandler:(id)a3
{
  int v4 = (HMDAccessorySymptomHandler *)a3;
  os_unfair_recursive_lock_lock_with_options();
  symptomsHandler = self->_symptomsHandler;
  self->_symptomsHandler = v4;

  os_unfair_recursive_lock_unlock();
}

- (BOOL)providesHashRouteID
{
  if ([(HMDHAPAccessory *)self hasTelevisionService]) {
    return 1;
  }
  return [(HMDHAPAccessory *)self hasSmartSpeakerService];
}

- (void)updateTargetUUIDs:(id)a3
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [(HMDHAPAccessory *)self targetControllerManager];

  id v6 = (void *)MEMORY[0x1D9452090]();
  uint64_t v7 = self;
  id v8 = HMFGetOSLogHandle();
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_INFO);
  if (v5)
  {
    if (v9)
    {
      id v10 = HMFGetLogIdentifier();
      id v11 = [(HMDHAPAccessory *)v7 targetUUIDs];
      int v14 = 138543874;
      uint64_t v15 = v10;
      __int16 v16 = 2112;
      id v17 = v11;
      __int16 v18 = 2112;
      id v19 = v4;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Updating targetUUIDs %@ -> %@", (uint8_t *)&v14, 0x20u);
    }
    [(HMDHAPAccessory *)v7 setTargetUUIDs:v4];
    [(HMDHAPAccessory *)v7 updateSymptoms];
    uint64_t v12 = [(HMDHAPAccessory *)v7 targetControllerManager];
    [v12 updateTargets:v4];
  }
  else
  {
    if (v9)
    {
      id v13 = HMFGetLogIdentifier();
      int v14 = 138543618;
      uint64_t v15 = v13;
      __int16 v16 = 2112;
      id v17 = v4;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Attempt to update targets to %@ with no target controller manager", (uint8_t *)&v14, 0x16u);
    }
  }
}

- (void)_saveTargetUUIDs:(id)a3
{
  id v4 = a3;
  id v9 = [(HMDHAPAccessory *)self transactionWithObjectChangeType:2];
  [v9 setTargetUUIDs:v4];

  uint64_t v5 = [(HMDAccessory *)self home];
  id v6 = [v5 backingStore];
  uint64_t v7 = +[HMDBackingStoreTransactionOptions defaultXPCOptions];
  id v8 = [v6 transaction:@"SaveTargetUUIDs" options:v7];

  [v8 add:v9];
  [v8 run];
}

- (void)saveTargetUUIDs:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __35__HMDHAPAccessory_saveTargetUUIDs___block_invoke;
  v7[3] = &unk_1E6A197C8;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

uint64_t __35__HMDHAPAccessory_saveTargetUUIDs___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _saveTargetUUIDs:*(void *)(a1 + 40)];
}

- (void)setTargetControllerManager:(id)a3
{
  id v4 = (HMDTargetControllerManager *)a3;
  os_unfair_recursive_lock_lock_with_options();
  targetControllerManager = self->_targetControllerManager;
  self->_targetControllerManager = v4;

  os_unfair_recursive_lock_unlock();
}

- (void)_saveHardwareSupport:(BOOL)a3
{
  BOOL v3 = a3;
  id v10 = [(HMDHAPAccessory *)self transactionWithObjectChangeType:2];
  uint64_t v5 = [NSNumber numberWithBool:v3];
  [v10 setHardwareSupport:v5];

  id v6 = [(HMDAccessory *)self home];
  uint64_t v7 = [v6 backingStore];
  id v8 = +[HMDBackingStoreTransactionOptions defaultXPCOptions];
  id v9 = [v7 transaction:@"SaveHardwareSupport" options:v8];

  [v9 add:v10];
  [v9 run];
}

- (void)saveHardwareSupport:(BOOL)a3
{
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __39__HMDHAPAccessory_saveHardwareSupport___block_invoke;
  v6[3] = &unk_1E6A19B58;
  void v6[4] = self;
  BOOL v7 = a3;
  dispatch_async(v5, v6);
}

uint64_t __39__HMDHAPAccessory_saveHardwareSupport___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _saveHardwareSupport:*(unsigned __int8 *)(a1 + 40)];
}

- (void)setHardwareSupport:(BOOL)a3
{
  os_unfair_recursive_lock_lock_with_options();
  self->_hardwareSupport = a3;
  os_unfair_recursive_lock_unlock();
}

- (void)setTargetUUIDs:(id)a3
{
  id v6 = a3;
  os_unfair_recursive_lock_lock_with_options();
  if ((HMFEqualObjects() & 1) == 0)
  {
    id v4 = (NSArray *)[v6 copy];
    targetUUIDs = self->_targetUUIDs;
    self->_targetUUIDs = v4;
  }
  os_unfair_recursive_lock_unlock();
}

- (void)updateSymptoms
{
  BOOL v3 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __33__HMDHAPAccessory_updateSymptoms__block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v3, block);
}

void __33__HMDHAPAccessory_updateSymptoms__block_invoke(uint64_t a1)
{
  if ([*(id *)(a1 + 32) shouldConfigureTargetController]
    && +[HMDDeviceCapabilities supportsSymptomsHandler])
  {
    id v16 = [MEMORY[0x1E4F1CA80] set];
    uint64_t v2 = [*(id *)(a1 + 32) targetUUIDs];
    uint64_t v3 = [v2 count];

    if (!v3)
    {
      id v4 = (void *)[objc_alloc(MEMORY[0x1E4F2EB68]) initWithType:12];
      [v16 addObject:v4];
    }
    uint64_t v5 = [*(id *)(a1 + 32) symptomsHandler];
    id v6 = [v5 symptoms];
    BOOL v7 = v6;
    if (v6)
    {
      id v8 = v6;
    }
    else
    {
      id v8 = [MEMORY[0x1E4F1CAD0] set];
    }
    id v9 = v8;

    if (([v9 isEqualToSet:v16] & 1) == 0)
    {
      if ([v16 count])
      {
        id v10 = [[HMDAccessorySymptomHandler alloc] initWithAccessory:*(void *)(a1 + 32)];
        [*(id *)(a1 + 32) setSymptomsHandler:v10];

        id v11 = [*(id *)(a1 + 32) symptomsHandler];
        [v11 configure];

        uint64_t v12 = [*(id *)(a1 + 32) symptomsHandler];
        [v12 updateSymptoms:v16];
      }
      else
      {
        [*(id *)(a1 + 32) setSymptomsHandler:0];
      }
      id v13 = [*(id *)(a1 + 32) home];
      int v14 = [v13 homeManager];
      uint64_t v15 = [*(id *)(a1 + 32) uuid];
      [v14 updateGenerationCounterWithReason:@"AccessoryHasSymptomsHandlerUpdated" sourceUUID:v15 shouldNotifyClients:1];
    }
  }
}

- (void)setNeedsOnboarding:(id)a3
{
  id v6 = a3;
  os_unfair_recursive_lock_lock_with_options();
  if ((HMFEqualObjects() & 1) == 0)
  {
    id v4 = (NSNumber *)[v6 copy];
    needsOnboarding = self->_needsOnboarding;
    self->_needsOnboarding = v4;
  }
  os_unfair_recursive_lock_unlock();
}

- (void)setSetupHash:(id)a3
{
  id v6 = a3;
  os_unfair_recursive_lock_lock_with_options();
  if ((HMFEqualObjects() & 1) == 0)
  {
    id v4 = (NSData *)[v6 copy];
    setupHash = self->_setupHash;
    self->_setupHash = v4;
  }
  os_unfair_recursive_lock_unlock();
}

- (void)setConnectivityInfo:(id)a3
{
  id v4 = (HMFConnectivityInfo *)a3;
  os_unfair_recursive_lock_lock_with_options();
  connectivityInfo = self->_connectivityInfo;
  self->_connectivityInfo = v4;

  os_unfair_recursive_lock_unlock();
}

- (void)setBroadcastKey:(id)a3 keyUpdatedStateNumber:(id)a4 keyUpdatedTime:(id)a5
{
  id v25 = a3;
  id v8 = a4;
  id v9 = a5;
  id v10 = [(HMDAccessory *)self identifier];
  os_unfair_recursive_lock_lock_with_options();
  id v11 = (NSData *)[v25 copy];
  broadcastKey = self->_broadcastKey;
  self->_broadcastKey = v11;

  id v13 = (NSNumber *)[v8 copy];
  keyUpdatedStateNumber = self->_keyUpdatedStateNumber;
  self->_keyUpdatedStateNumber = v13;

  uint64_t v15 = (NSDate *)[v9 copy];
  keyUpdatedTime = self->_keyUpdatedTime;
  self->_keyUpdatedTime = v15;

  id v17 = objc_alloc(MEMORY[0x1E4F65580]);
  __int16 v18 = (HMFTimer *)[v17 initWithTimeInterval:1 options:(double)(unint64_t)broadcastKeyRefreshTimeInSeconds * 0.5+ (double)(arc4random() % 0x2E + 15)];
  accessoryKeyRefreshTimer = self->_accessoryKeyRefreshTimer;
  self->_accessoryKeyRefreshTimer = v18;

  uint64_t v20 = [(HMDHAPAccessory *)self accessoryKeyRefreshTimer];
  [v20 setDelegate:self];

  self->_keyGenerationType = 0;
  long long v21 = [(HMDHAPAccessory *)self accessoryKeyRefreshTimer];
  [v21 resume];

  os_unfair_recursive_lock_unlock();
  long long v22 = [(HMDAccessory *)self home];
  uint64_t v23 = [v22 accessoryBrowser];
  int v24 = [v23 accessoryBrowserHapProtocol];
  [v9 timeIntervalSinceReferenceDate];
  objc_msgSend(v24, "updateBroadcastKeyForIdentifier:key:keyUpdatedStateNumber:keyUpdatedTime:", v10, v25, v8);
}

- (void)_updateBroadcastKey:(id)a3 keyUpdatedStateNumber:(id)a4 keyUpdatedTime:(double)a5
{
  id v17 = a3;
  id v8 = a4;
  id v9 = [(HMDHAPAccessory *)self broadcastKey];
  char v10 = HMFEqualObjects();

  if ((v10 & 1) == 0)
  {
    id v11 = [(HMDHAPAccessory *)self transactionWithObjectChangeType:2];
    [v11 setBroadcastKey:v17];
    [v11 setKeyUpdatedStateNumber:v8];
    uint64_t v12 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:a5];
    [v11 setKeyUpdatedTime:v12];

    id v13 = [(HMDAccessory *)self home];
    int v14 = [v13 backingStore];
    uint64_t v15 = +[HMDBackingStoreTransactionOptions defaultXPCOptions];
    id v16 = [v14 transaction:@"AccessoryUpdated" options:v15];

    [v16 add:v11];
    [v16 run];
  }
}

- (void)_handleUpdatedAuthMethod
{
  uint64_t v3 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v3);

  [(HMDHAPAccessory *)self _handleUpdatedServicesForProfilesAndControllers:0];
}

- (void)handleUpdatedAuthMethod
{
  uint64_t v3 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __42__HMDHAPAccessory_handleUpdatedAuthMethod__block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v3, block);
}

uint64_t __42__HMDHAPAccessory_handleUpdatedAuthMethod__block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _handleUpdatedAuthMethod];
}

- (void)testSetInternalEnhancedAuthConfigNumber:(id)a3
{
  id v4 = (NSNumber *)a3;
  os_unfair_recursive_lock_lock_with_options();
  internalEnhancedAuthConfigNumber = self->_internalEnhancedAuthConfigNumber;
  self->_internalEnhancedAuthConfigNumber = v4;

  os_unfair_recursive_lock_unlock();
}

- (void)testSetInternalEnhancedAuthMethod:(id)a3
{
  id v4 = (NSNumber *)a3;
  os_unfair_recursive_lock_lock_with_options();
  internalEnhancedAuthMethod = self->_internalEnhancedAuthMethod;
  self->_internalEnhancedAuthMethod = v4;

  os_unfair_recursive_lock_unlock();
}

- (void)setInternalEnhancedAuthMethod:(id)a3 configNumber:(unint64_t)a4
{
  id v12 = a3;
  BOOL v7 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v7);

  os_unfair_recursive_lock_lock_with_options();
  id v8 = self->_internalEnhancedAuthMethod;
  objc_storeStrong((id *)&self->_internalEnhancedAuthMethod, a3);
  id v9 = [NSNumber numberWithUnsignedInteger:a4];
  internalEnhancedAuthConfigNumber = self->_internalEnhancedAuthConfigNumber;
  self->_internalEnhancedAuthConfigNumber = v9;

  os_unfair_recursive_lock_unlock();
  if ((HMFEqualObjects() & 1) == 0)
  {
    [(HMDHAPAccessory *)self _handleUpdatedAuthMethod];
    id v11 = [(HMDAccessory *)self home];
    [v11 saveWithReason:@"HMDHAPAccessorySaveAuthMethodReason" postSyncNotification:0];
  }
}

- (void)setAccessoryFlags:(id)a3
{
  if (a3)
  {
    -[HMDHAPAccessory updateAccessoryFlags:](self, "updateAccessoryFlags:");
    id v4 = [(HMDAccessory *)self home];
    [v4 saveWithReason:@"kAccessoryInformationUpdate" postSyncNotification:0];
  }
}

- (void)updateAccessoryFlags:(id)a3
{
  id v6 = a3;
  os_unfair_recursive_lock_lock_with_options();
  if ((HMFEqualObjects() & 1) == 0)
  {
    id v4 = (NSNumber *)[v6 copy];
    accessoryFlags = self->_accessoryFlags;
    self->_accessoryFlags = v4;
  }
  os_unfair_recursive_lock_unlock();
}

- (void)_postUpdateEventsIfDifferent:(id)a3
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  id v6 = (void *)MEMORY[0x1D9452090]();
  BOOL v7 = self;
  id v8 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    id v9 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    long long v44 = v9;
    __int16 v45 = 2112;
    id v46 = v4;
    _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Posting event to update primaryUserInfo: %@", buf, 0x16u);
  }
  char v10 = [(HMDAccessory *)v7 uuid];
  id v11 = [(HMDAccessory *)v7 home];
  id v12 = [v11 uuid];

  if (v10 && v12)
  {
    id v13 = [MEMORY[0x1E4F2E580] topicFromSuffixID:*MEMORY[0x1E4F2C388] homeUUID:v12 accessoryUUID:v10];
    int v14 = [(HMDHAPAccessory *)v7 eventStoreReadHandle];
    uint64_t v15 = [v14 lastEventForTopic:v13];

    if (v15)
    {
      id v16 = objc_alloc(MEMORY[0x1E4F2E598]);
      id v17 = [v15 encodedData];
      __int16 v18 = (void *)[v16 initWithProtoData:v17];

      if (v18)
      {
        if ([v18 isEqual:v4])
        {
          id v19 = (void *)MEMORY[0x1D9452090]();
          uint64_t v20 = v7;
          long long v21 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
          {
            long long v22 = HMFGetLogIdentifier();
            *(_DWORD *)buf = 138543362;
            long long v44 = v22;
            _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_INFO, "%{public}@Skip sending event update for primaryUserInfo as it matches stored", buf, 0xCu);
          }
LABEL_21:

          goto LABEL_22;
        }
LABEL_18:
        int v31 = (void *)MEMORY[0x1D9452090]();
        int v32 = v7;
        __int16 v33 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
        {
          long long v34 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543874;
          long long v44 = v34;
          __int16 v45 = 2112;
          id v46 = v13;
          __int16 v47 = 2112;
          id v48 = v4;
          _os_log_impl(&dword_1D49D5000, v33, OS_LOG_TYPE_INFO, "%{public}@Forwarding event with topic: %@ for primaryUserInfo: %@", buf, 0x20u);
        }
        id v35 = objc_alloc(MEMORY[0x1E4F69F48]);
        int v36 = [(HMDHAPAccessory *)v32 eventSourceIdentifier];
        [(HMDHAPAccessory *)v32 eventTimestamp];
        uint64_t v37 = objc_msgSend(v35, "initWithSource:cachePolicy:combineType:timestamp:", v36, 2, 2);

        id v38 = objc_alloc(MEMORY[0x1E4F69F38]);
        long long v39 = [v4 protoData];
        long long v40 = (void *)[v38 initWithEventData:v39 metadata:v37];

        long long v41 = [(HMDHAPAccessory *)v32 eventForwarder];
        v42[0] = MEMORY[0x1E4F143A8];
        v42[1] = 3221225472;
        id v42[2] = __48__HMDHAPAccessory__postUpdateEventsIfDifferent___block_invoke;
        v42[3] = &unk_1E6A197F0;
        void v42[4] = v32;
        [v41 forwardEvent:v40 topic:v13 completion:v42];

        goto LABEL_21;
      }
      id v27 = (void *)MEMORY[0x1D9452090]();
      __int16 v28 = v7;
      int v29 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        uint64_t v30 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        long long v44 = v30;
        __int16 v45 = 2112;
        id v46 = v13;
        _os_log_impl(&dword_1D49D5000, v29, OS_LOG_TYPE_ERROR, "%{public}@Error reading stored primary user for topic %@", buf, 0x16u);
      }
    }
    __int16 v18 = 0;
    goto LABEL_18;
  }
  uint64_t v23 = (void *)MEMORY[0x1D9452090]();
  int v24 = v7;
  id v25 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    __int16 v26 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543874;
    long long v44 = v26;
    __int16 v45 = 2112;
    id v46 = v12;
    __int16 v47 = 2112;
    id v48 = v10;
    _os_log_impl(&dword_1D49D5000, v25, OS_LOG_TYPE_ERROR, "%{public}@Unexpected nil value in homeUUID: %@, accessoryUUID: %@", buf, 0x20u);
  }
LABEL_22:
}

void __48__HMDHAPAccessory__postUpdateEventsIfDifferent___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x1D9452090]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      BOOL v7 = HMFGetLogIdentifier();
      int v8 = 138543618;
      id v9 = v7;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_ERROR, "%{public}@Error in forwarding the primary user event: %@", (uint8_t *)&v8, 0x16u);
    }
  }
}

- (void)postUpdateEventsIfDifferentWithPreferredMediaUUID:(id)a3 selectionType:(unint64_t)a4
{
  id v6 = a3;
  if (_os_feature_enabled_impl())
  {
    BOOL v7 = [(HMDAccessory *)self workQueue];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __83__HMDHAPAccessory_postUpdateEventsIfDifferentWithPreferredMediaUUID_selectionType___block_invoke;
    block[3] = &unk_1E6A16D78;
    __int16 v10 = self;
    unint64_t v11 = a4;
    id v9 = v6;
    dispatch_async(v7, block);
  }
}

void __83__HMDHAPAccessory_postUpdateEventsIfDifferentWithPreferredMediaUUID_selectionType___block_invoke(uint64_t a1)
{
  id v2 = objc_alloc(MEMORY[0x1E4F2E598]);
  id v3 = [*(id *)(a1 + 32) UUIDString];
  id v4 = (id)[v2 initWithUUIDString:v3 selectionType:*(void *)(a1 + 48)];

  [*(id *)(a1 + 40) _postUpdateEventsIfDifferent:v4];
}

- (id)eventStoreReadHandle
{
  id v2 = [(HMDAccessory *)self home];
  id v3 = [v2 homeManager];
  id v4 = [v3 eventStoreReadHandle];

  return v4;
}

- (id)eventForwarder
{
  id v2 = [(HMDAccessory *)self home];
  id v3 = [v2 homeManager];
  id v4 = [v3 eventForwarder];

  return v4;
}

- (double)eventTimestamp
{
  [MEMORY[0x1E4F1C9C8] timeIntervalSinceReferenceDate];
  return result;
}

- (id)eventSourceIdentifier
{
  id v2 = [(HMDAccessory *)self uuid];
  id v3 = [v2 UUIDString];

  return v3;
}

- (id)settingTopicForKeyPath:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDAccessory *)self home];
  id v6 = [v5 uuid];
  BOOL v7 = [(HMDAccessory *)self uuid];
  int v8 = MEMORY[0x1D94507C0](v6, v7, v4);

  return v8;
}

- (void)configureBulletinNotification
{
  id v3 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __48__HMDHAPAccessory_configureBulletinNotification__block_invoke;
  block[3] = &unk_1E6A19B30;
  void block[4] = self;
  dispatch_async(v3, block);
}

void __48__HMDHAPAccessory_configureBulletinNotification__block_invoke(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  v1 = objc_msgSend(*(id *)(a1 + 32), "services", 0);
  id v2 = (void *)[v1 copy];

  uint64_t v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v8;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        [*(id *)(*((void *)&v7 + 1) + 8 * v6++) configureBulletinNotification];
      }
      while (v4 != v6);
      uint64_t v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
    }
    while (v4);
  }
}

- (void)setDefaultPreferredMediaUser
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = [(HMDAccessory *)self home];
  int v4 = [v3 isCurrentDeviceConfirmedPrimaryResident];
  uint64_t v5 = [(HMDHAPAccessory *)self siriEndpointProfile];

  if (v5) {
    int v6 = v4;
  }
  else {
    int v6 = 0;
  }
  if (v6 == 1)
  {
    long long v7 = (void *)MEMORY[0x1D9452090]();
    long long v8 = self;
    long long v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      long long v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v18 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Setting default preferred media user to owner", buf, 0xCu);
    }
    unint64_t v11 = [v3 owner];
    uint64_t v12 = [v11 uuid];

    objc_initWeak((id *)buf, v8);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __47__HMDHAPAccessory_setDefaultPreferredMediaUser__block_invoke;
    v14[3] = &unk_1E6A17758;
    objc_copyWeak(&v16, (id *)buf);
    id v13 = v12;
    id v15 = v13;
    [(HMDAccessory *)v8 setPreferredMediaUser:v13 selectionType:1 completion:v14];

    objc_destroyWeak(&v16);
    objc_destroyWeak((id *)buf);
  }
}

void __47__HMDHAPAccessory_setDefaultPreferredMediaUser__block_invoke(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (!a2)
  {
    id v5 = WeakRetained;
    [WeakRetained postUpdateEventsIfDifferentWithPreferredMediaUUID:*(void *)(a1 + 32) selectionType:1];
    id WeakRetained = v5;
  }
}

- (void)setDefaultPreferredMediaUserIfNeeded
{
  uint64_t v3 = [(HMDAccessory *)self preferredMediaUserUUID];

  if (!v3)
  {
    [(HMDHAPAccessory *)self setDefaultPreferredMediaUser];
  }
}

- (void)configureWithHome:(id)a3 msgDispatcher:(id)a4 configurationTracker:(id)a5 initialConfiguration:(BOOL)a6
{
  uint64_t v6 = a6;
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a4;
  uint64_t v12 = a5;
  uint64_t v13 = HMFUptime();
  uint64_t v15 = v14;
  if (v6)
  {
    id v37 = v11;
    unsigned int v38 = v6;
    id v16 = (void *)MEMORY[0x1D9452090](v13);
    id v17 = self;
    __int16 v18 = HMFGetOSLogHandle();
    unint64_t v19 = 0x1E4F28000;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      id v35 = HMFGetLogIdentifier();
      uint64_t v20 = [v10 uuid];
      [(HMDAccessory *)v17 uuid];
      long long v21 = v36 = v16;
      long long v22 = [NSNumber numberWithBool:1];
      *(_DWORD *)buf = 138545922;
      __int16 v47 = v35;
      __int16 v48 = 2114;
      uint64_t v49 = @"accessoryConfigureStart";
      __int16 v50 = 2112;
      long long v51 = @"Configuring accessory";
      __int16 v52 = 2114;
      long long v53 = @"state";
      __int16 v54 = 2112;
      __int16 v55 = @"start";
      __int16 v56 = 2114;
      __int16 v57 = @"homeUUID";
      __int16 v58 = 2112;
      uint64_t v59 = v20;
      __int16 v60 = 2114;
      __int16 v61 = @"accessoryUUID";
      __int16 v62 = 2112;
      __int16 v63 = v21;
      __int16 v64 = 2114;
      __int16 v65 = @"initialConfig";
      __int16 v66 = 2112;
      __int16 v67 = v22;
      _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_DEBUG, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\"", buf, 0x70u);

      id v16 = v36;
      unint64_t v19 = 0x1E4F28000uLL;
    }
    uint64_t v23 = [MEMORY[0x1E4F6A2A0] sharedInstance];
    id v24 = objc_alloc(MEMORY[0x1E4F6A2B0]);
    id v25 = [v10 uuid];
    __int16 v26 = [(HMDAccessory *)v17 uuid];
    id v27 = [*(id *)(v19 + 3792) numberWithBool:1];
    __int16 v28 = HMDTaggedLoggingCreateDictionary();
    int v29 = objc_msgSend(v24, "initWithTag:data:", @"accessoryConfigureStart", v28, @"state", @"start", @"homeUUID", v25, @"accessoryUUID", v26, @"initialConfig", v27);
    uint64_t v30 = [MEMORY[0x1E4F653F0] currentTagProcessorList];
    [v23 submitTaggedEvent:v29 processorList:v30];

    uint64_t v6 = v38;
    id v11 = v37;
  }
  if (v12) {
    dispatch_group_enter(v12);
  }
  v45.receiver = self;
  v45.super_class = (Class)HMDHAPAccessory;
  [(HMDAccessory *)&v45 configureWithHome:v10 msgDispatcher:v11 configurationTracker:v12 initialConfiguration:v6];
  int v31 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __93__HMDHAPAccessory_configureWithHome_msgDispatcher_configurationTracker_initialConfiguration___block_invoke;
  block[3] = &unk_1E6A19B08;
  void block[4] = self;
  id v40 = v11;
  char v44 = v6;
  id v41 = v10;
  long long v42 = v12;
  uint64_t v43 = v15;
  int v32 = v12;
  id v33 = v10;
  id v34 = v11;
  dispatch_async(v31, block);
}

void __93__HMDHAPAccessory_configureWithHome_msgDispatcher_configurationTracker_initialConfiguration___block_invoke(uint64_t a1)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  id v2 = [*(id *)(a1 + 32) services];
  uint64_t v3 = [v2 countByEnumeratingWithState:&v75 objects:v105 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v76;
    do
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        if (*(void *)v76 != v5) {
          objc_enumerationMutation(v2);
        }
        long long v7 = *(void **)(*((void *)&v75 + 1) + 8 * i);
        long long v8 = [*(id *)(a1 + 32) workQueue];
        [v7 configureWithWorkQueue:v8 messageDispatcher:*(void *)(a1 + 40)];
      }
      uint64_t v4 = [v2 countByEnumeratingWithState:&v75 objects:v105 count:16];
    }
    while (v4);
  }

  [*(id *)(a1 + 32) _handleUpdatedServicesForProfilesAndControllers:*(unsigned __int8 *)(a1 + 72)];
  [*(id *)(a1 + 32) updatePrimaryServiceIfNeeded];
  [*(id *)(a1 + 32) _configureTargetControllerWithCompletion:0];
  [*(id *)(a1 + 32) initializeBTLEScan];
  [*(id *)(a1 + 32) _checkResidentDeviceForReachabilityPing];
  [*(id *)(a1 + 32) _checkRegisterForServerNotification];
  long long v9 = [MEMORY[0x1E4F28EB8] defaultCenter];
  uint64_t v10 = *(void *)(a1 + 32);
  id v11 = [*(id *)(a1 + 48) residentDeviceManager];
  [v9 addObserver:v10 selector:sel_handleResidentDeviceUpdated_ name:@"HMDResidentDeviceManagerAddResidentNotification" object:v11];

  uint64_t v12 = [MEMORY[0x1E4F28EB8] defaultCenter];
  uint64_t v13 = *(void *)(a1 + 32);
  uint64_t v14 = [*(id *)(a1 + 48) residentDeviceManager];
  [v12 addObserver:v13 selector:sel_handleResidentDeviceUpdated_ name:@"HMDResidentDeviceManagerRemoveResidentNotification" object:v14];

  uint64_t v15 = [MEMORY[0x1E4F28EB8] defaultCenter];
  uint64_t v16 = *(void *)(a1 + 32);
  id v17 = [*(id *)(a1 + 48) residentDeviceManager];
  [v15 addObserver:v16 selector:sel_handleResidentDeviceUpdated_ name:@"HMDResidentDeviceManagerUpdateResidentNotification" object:v17];

  __int16 v18 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v18 addObserver:*(void *)(a1 + 32) selector:sel_handleResidentDeviceUpdated_ name:@"HMDDeviceCapabilitiiesUpdatedNotification" object:0];

  unint64_t v19 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v19 addObserver:*(void *)(a1 + 32) selector:sel_handleResidentDeviceUpdated_ name:@"HMDResidentDeviceCapabilitiesUpdatedNotification" object:0];

  uint64_t v20 = [MEMORY[0x1E4F28EB8] defaultCenter];
  uint64_t v21 = *(void *)(a1 + 32);
  long long v22 = [*(id *)(a1 + 48) residentDeviceManager];
  [v20 addObserver:v21 selector:sel_handlePrimaryResidentUpdateNotification_ name:@"HMDResidentDeviceManagerUpdatePrimaryResidentNotification" object:v22];

  uint64_t v23 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v23 addObserver:*(void *)(a1 + 32) selector:sel_handlePrimaryResidentUpdateNotification_ name:@"HMDResidentDeviceConfirmedStateChangedNotification" object:0];

  -[HMDHAPAccessory _evaluateResidentEnabledFeatures](*(void **)(a1 + 32));
  id v24 = *(NSObject **)(a1 + 56);
  if (v24) {
    dispatch_group_leave(v24);
  }
  id v25 = (void *)MEMORY[0x1D9452090]();
  id v26 = *(id *)(a1 + 32);
  id v27 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
  {
    __int16 v28 = HMFGetLogIdentifier();
    [*(id *)(a1 + 48) isCurrentDevicePrimaryResident];
    HMFBooleanToString();
    int v29 = (__CFString *)objc_claimAutoreleasedReturnValue();
    [*(id *)(a1 + 48) isCurrentDeviceAvailableResident];
    HMFBooleanToString();
    uint64_t v30 = (__CFString *)objc_claimAutoreleasedReturnValue();
    [*(id *)(a1 + 48) areAllResidentsUnreachable];
    HMFBooleanToString();
    int v31 = (__CFString *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138544130;
    long long v80 = v28;
    __int16 v81 = 2114;
    char v82 = v29;
    __int16 v83 = 2114;
    uint64_t v84 = v30;
    __int16 v85 = 2114;
    uint64_t v86 = v31;
    _os_log_impl(&dword_1D49D5000, v27, OS_LOG_TYPE_INFO, "%{public}@Evaluating disconnect on idle status using - isCurrentDevicePrimaryResident = %{public}@, isCurrentDeviceAvailableResident = %{public}@, areAllResidentsUnBOOL reachable = %{public}@", buf, 0x2Au);
  }
  uint64_t v32 = shouldDisconnectOnIdleForAccessory(*(void **)(a1 + 32));
  id v33 = (void *)MEMORY[0x1D9452090]();
  id v34 = *(id *)(a1 + 32);
  id v35 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
  {
    int v36 = HMFGetLogIdentifier();
    HMFBooleanToString();
    id v37 = (__CFString *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138543618;
    long long v80 = v36;
    __int16 v81 = 2112;
    char v82 = v37;
    _os_log_impl(&dword_1D49D5000, v35, OS_LOG_TYPE_INFO, "%{public}@Configuring initial accessory shouldDisconnectOnIdle to %@", buf, 0x16u);
  }
  [*(id *)(a1 + 32) setShouldDisconnectOnIdle:v32];
  unsigned int v38 = [*(id *)(a1 + 32) siriEndpointProfile];

  if (v38)
  {
    long long v39 = *(void **)(a1 + 32);
    id v40 = [*(id *)(a1 + 48) logEventSubmitter];
    id v41 = [*(id *)(a1 + 48) dailyScheduler];
    [v39 configureSiriEndpointProfileMetricsDispatcherWithFactory:v39 logEventSubmitter:v40 dailyScheduler:v41];
  }
  long long v42 = (void *)MEMORY[0x1D9452090]();
  id v43 = *(id *)(a1 + 32);
  char v44 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
  {
    objc_super v45 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    long long v80 = v45;
    _os_log_impl(&dword_1D49D5000, v44, OS_LOG_TYPE_INFO, "%{public}@Setting default preferred media user if needed.", buf, 0xCu);
  }
  [*(id *)(a1 + 32) setDefaultPreferredMediaUserIfNeeded];
  [*(id *)(a1 + 32) setCommunicationProtocolIfNeeded];
  [*(id *)(a1 + 32) checkHAPSessionRestore];
  [*(id *)(a1 + 32) wirelessResumeInit];
  if ([*(id *)(a1 + 48) isCurrentDeviceConfirmedPrimaryResident])
  {
    id v46 = (void *)MEMORY[0x1D9452090]();
    id v47 = *(id *)(a1 + 32);
    __int16 v48 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v49 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      long long v80 = v49;
      _os_log_impl(&dword_1D49D5000, v48, OS_LOG_TYPE_DEBUG, "%{public}@Current device is primary - starting AccessoryMetric", buf, 0xCu);
    }
    __int16 v50 = [[HMDAccessoryMetric alloc] initWithAccessory:*(void *)(a1 + 32)];
    [*(id *)(a1 + 32) setAccessoryMetric:v50];
  }
  if (*(unsigned char *)(a1 + 72))
  {
    long long v51 = (void *)MEMORY[0x1D9452090]();
    id v52 = *(id *)(a1 + 32);
    long long v53 = HMFGetOSLogHandle();
    unint64_t v54 = 0x1E4F29000;
    if (os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
    {
      __int16 v55 = HMFGetLogIdentifier();
      __int16 v56 = [*(id *)(a1 + 48) uuid];
      __int16 v57 = [*(id *)(a1 + 32) uuid];
      __int16 v58 = NSString;
      HMFUptime();
      __int16 v60 = objc_msgSend(v58, "stringWithFormat:", @"%.3f", v59 - *(double *)(a1 + 64));
      __int16 v61 = (objc_class *)objc_opt_class();
      __int16 v62 = NSStringFromClass(v61);
      *(_DWORD *)buf = 138546434;
      long long v80 = v55;
      __int16 v81 = 2114;
      char v82 = @"accessoryConfigureDone";
      __int16 v83 = 2112;
      uint64_t v84 = @"Configured accessory";
      __int16 v85 = 2114;
      uint64_t v86 = @"state";
      __int16 v87 = 2112;
      uint64_t v88 = @"end";
      __int16 v89 = 2114;
      __int16 v90 = @"homeUUID";
      __int16 v91 = 2112;
      __int16 v92 = v56;
      __int16 v93 = 2114;
      uint64_t v94 = @"accessoryUUID";
      __int16 v95 = 2112;
      uint64_t v96 = v57;
      __int16 v97 = 2114;
      uint64_t v98 = @"duration";
      __int16 v99 = 2112;
      uint64_t v100 = v60;
      __int16 v101 = 2114;
      id v102 = @"accessoryType";
      __int16 v103 = 2112;
      uint64_t v104 = v62;
      _os_log_impl(&dword_1D49D5000, v53, OS_LOG_TYPE_INFO, "%{public}@tag=\"%{public}@\" desc=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\" %{public}@=\"%@\"", buf, 0x84u);

      unint64_t v54 = 0x1E4F29000uLL;
    }

    __int16 v63 = [MEMORY[0x1E4F6A2A0] sharedInstance];
    id v64 = objc_alloc(MEMORY[0x1E4F6A2B0]);
    __int16 v65 = [*(id *)(a1 + 48) uuid];
    __int16 v66 = [*(id *)(a1 + 32) uuid];
    __int16 v67 = *(void **)(v54 + 24);
    HMFUptime();
    uint64_t v69 = objc_msgSend(v67, "stringWithFormat:", @"%.3f", v68 - *(double *)(a1 + 64));
    uint64_t v70 = (objc_class *)objc_opt_class();
    id v71 = NSStringFromClass(v70);
    uint64_t v72 = HMDTaggedLoggingCreateDictionary();
    id v73 = objc_msgSend(v64, "initWithTag:data:", @"accessoryConfigureDone", v72, @"state", @"end", @"homeUUID", v65, @"accessoryUUID", v66, @"duration", v69, @"accessoryType", v71);
    id v74 = [MEMORY[0x1E4F653F0] currentTagProcessorList];
    [v63 submitTaggedEvent:v73 processorList:v74];
  }
}

- (id)transportReports
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = [MEMORY[0x1E4F1CA48] array];
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v4 = [(HMDHAPAccessory *)self transportInformationInstances];
  uint64_t v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        long long v9 = [*(id *)(*((void *)&v11 + 1) + 8 * i) report];
        [v9 setReason:@"unchanged"];
        [v3 addObject:v9];
      }
      uint64_t v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v6);
  }

  return v3;
}

- (void)_registerForMessages
{
  uint64_t v160 = *MEMORY[0x1E4F143B8];
  v133.receiver = self;
  v133.super_class = (Class)HMDHAPAccessory;
  [(HMDAccessory *)&v133 _registerForMessages];
  long long v132 = [(HMDAccessory *)self home];
  long long v131 = +[HMDUserMessagePolicy userMessagePolicyWithHome:userPrivilege:remoteAccessRequired:](HMDUserMessagePolicy, "userMessagePolicyWithHome:userPrivilege:remoteAccessRequired:");
  uint64_t v3 = +[HMDDeviceCapabilities deviceCapabilities];
  if ([v3 isResidentCapable])
  {
  }
  else
  {
    BOOL v4 = +[HMDDeviceCapabilities isCompanionCapable];

    if (!v4) {
      goto LABEL_7;
    }
  }
  uint64_t v5 = (void *)MEMORY[0x1D9452090]();
  uint64_t v6 = self;
  uint64_t v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    long long v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    __int16 v159 = v8;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Registering for legacy accessory read / write handlers", buf, 0xCu);
  }
  long long v9 = +[HMDUserMessagePolicy userMessagePolicyWithHome:v132 userPrivilege:0 remoteAccessRequired:1];
  uint64_t v10 = +[HMDRemoteMessagePolicy defaultSecurePolicy];
  objc_msgSend(v10, "setRoles:", objc_msgSend(v10, "roles") | 6);
  long long v11 = (void *)[v10 copy];
  long long v12 = [(HMDAccessory *)v6 msgDispatcher];
  v157[0] = v11;
  v157[1] = v9;
  long long v13 = +[HMDXPCMessagePolicy policyWithEntitlements:1];
  v157[2] = v13;
  long long v14 = +[HMDXPCBackgroundMessagePolicy policyWithEntitlementRequirement:1];
  v157[3] = v14;
  uint64_t v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v157 count:4];
  [v12 registerForMessage:@"kCharacteristicWriteRequestKey" receiver:v6 policies:v15 selector:sel__handleCharacteristicWrite_];

  uint64_t v16 = [(HMDAccessory *)v6 msgDispatcher];
  v156[0] = v11;
  v156[1] = v9;
  id v17 = +[HMDXPCMessagePolicy policyWithEntitlements:1];
  v156[2] = v17;
  __int16 v18 = +[HMDXPCBackgroundMessagePolicy policyWithEntitlementRequirement:1];
  v156[3] = v18;
  unint64_t v19 = [MEMORY[0x1E4F1C978] arrayWithObjects:v156 count:4];
  [v16 registerForMessage:@"kCharacteristicReadRequestKey" receiver:v6 policies:v19 selector:sel__handleCharacteristicRead_];

LABEL_7:
  uint64_t v20 = +[HMDDeviceCapabilities deviceCapabilities];
  uint64_t v21 = +[HMDUserMessagePolicy userMessagePolicyWithHome:v132 userPrivilege:3 remoteAccessRequired:0];
  uint64_t v22 = +[HMDUserMessagePolicy userMessagePolicyWithHome:v132 userPrivilege:4 remoteAccessRequired:0];
  uint64_t v23 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
  v155[0] = v23;
  id v24 = +[HMDRemoteMessagePolicy defaultSecurePolicy];
  v155[1] = v24;
  v155[2] = v22;
  long long v130 = (void *)v22;
  id v25 = [MEMORY[0x1E4F1C978] arrayWithObjects:v155 count:3];

  if ([v20 supportsFirmwareUpdate])
  {
    id v26 = [(HMDAccessory *)self msgDispatcher];
    [v26 registerForMessage:*MEMORY[0x1E4F2E048] receiver:self policies:v25 selector:sel__handleStartUpdate_];
  }
  id v27 = [(HMDAccessory *)self msgDispatcher];
  [v27 registerForMessage:*MEMORY[0x1E4F2C890] receiver:self policies:v25 selector:sel_routeUpdatePreferredMediaUser_];

  __int16 v28 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
  v154[0] = v28;
  int v29 = +[HMDConfigurationMessagePolicy policyWithOperationTypes:2];
  v154[1] = v29;
  v154[2] = v21;
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithObjects:v154 count:3];

  if (isInternalBuild() && [v20 supportsFirmwareUpdate])
  {
    int v31 = [(HMDAccessory *)self msgDispatcher];
    [v31 registerForMessage:*MEMORY[0x1E4F2E030] receiver:self policies:v30 selector:sel__handleChangeUpdateSource_];

    uint64_t v32 = [(HMDAccessory *)self msgDispatcher];
    [v32 registerForMessage:*MEMORY[0x1E4F2E040] receiver:self policies:v30 selector:sel__handleRemoveStagedSoftwareUpdate_];
  }
  id v33 = [v132 administratorHandler];
  uint64_t v34 = *MEMORY[0x1E4F2EDB8];
  id v35 = +[HMDConfigurationMessagePolicy policyWithOperationTypes:2];
  v153[0] = v35;
  int v36 = +[HMDXPCMessagePolicy policyWithEntitlements:1];
  v153[1] = v36;
  id v37 = [MEMORY[0x1E4F1C978] arrayWithObjects:v153 count:2];
  [v33 registerForMessage:v34 receiver:self policies:v37 selector:sel__handleRenameService_];

  unsigned int v38 = [v132 administratorHandler];
  long long v39 = +[HMDConfigurationMessagePolicy policyWithOperationTypes:2];
  v152[0] = v39;
  id v40 = +[HMDXPCMessagePolicy policyWithEntitlements:1];
  v152[1] = v40;
  id v41 = [MEMORY[0x1E4F1C978] arrayWithObjects:v152 count:2];
  [v38 registerForMessage:@"kSetAssociatedServiceTypeRequestKey" receiver:self policies:v41 selector:sel__handleUpdateAssociatedServiceType_];

  long long v42 = [(HMDAccessory *)self msgDispatcher];
  uint64_t v43 = *MEMORY[0x1E4F2C880];
  char v44 = +[HMDConfigurationMessagePolicy policyWithOperationTypes:2];
  v151[0] = v44;
  v151[1] = v131;
  objc_super v45 = +[HMDXPCMessagePolicy policyWithEntitlements:1];
  v151[2] = v45;
  id v46 = [MEMORY[0x1E4F1C978] arrayWithObjects:v151 count:3];
  [v42 registerForMessage:v43 receiver:self policies:v46 selector:sel__handleUpdateCharacteristicAuthorizationDataMessage_];

  id v47 = [(HMDAccessory *)self msgDispatcher];
  uint64_t v48 = *MEMORY[0x1E4F2C2B8];
  uint64_t v49 = +[HMDConfigurationMessagePolicy policyWithOperationTypes:2];
  v150[0] = v49;
  v150[1] = v131;
  __int16 v50 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
  v150[2] = v50;
  long long v51 = [MEMORY[0x1E4F1C978] arrayWithObjects:v150 count:3];
  [v47 registerForMessage:v48 receiver:self policies:v51 selector:sel__handleConfigureTargets_];

  id v52 = [(HMDAccessory *)self msgDispatcher];
  uint64_t v53 = *MEMORY[0x1E4F2E1C8];
  unint64_t v54 = +[HMDConfigurationMessagePolicy policyWithOperationTypes:2];
  v149[0] = v54;
  v149[1] = v131;
  __int16 v55 = +[HMDXPCMessagePolicy policyWithEntitlements:1];
  v149[2] = v55;
  __int16 v56 = [MEMORY[0x1E4F1C978] arrayWithObjects:v149 count:3];
  [v52 registerForMessage:v53 receiver:self policies:v56 selector:sel__handleUpdateMediaSourceDisplayOrder_];

  __int16 v57 = [(HMDAccessory *)self msgDispatcher];
  uint64_t v58 = *MEMORY[0x1E4F2C578];
  double v59 = +[HMDConfigurationMessagePolicy policyWithOperationTypes:2];
  v148[0] = v59;
  v148[1] = v131;
  __int16 v60 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
  v148[2] = v60;
  __int16 v61 = [MEMORY[0x1E4F1C978] arrayWithObjects:v148 count:3];
  [v57 registerForMessage:v58 receiver:self policies:v61 selector:sel_handleSetHasOnboardedForNaturalLighting_];

  __int16 v62 = [(HMDAccessory *)self msgDispatcher];
  uint64_t v63 = *MEMORY[0x1E4F2C3C0];
  id v64 = +[HMDRemoteMessagePolicy defaultSecurePolicy];
  v147[0] = v64;
  v147[1] = v131;
  __int16 v65 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
  v147[2] = v65;
  __int16 v66 = [MEMORY[0x1E4F1C978] arrayWithObjects:v147 count:3];
  [v62 registerForMessage:v63 receiver:self policies:v66 selector:sel_handleFetchCHIPPairingsMessage_];

  __int16 v67 = [(HMDAccessory *)self msgDispatcher];
  uint64_t v68 = *MEMORY[0x1E4F2C528];
  uint64_t v69 = +[HMDRemoteMessagePolicy defaultSecurePolicy];
  v146[0] = v69;
  uint64_t v70 = +[HMDUserMessagePolicy userMessagePolicyWithHome:v132 userPrivilege:4 remoteAccessRequired:1];
  v146[1] = v70;
  id v71 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
  v146[2] = v71;
  uint64_t v72 = [MEMORY[0x1E4F1C978] arrayWithObjects:v146 count:3];
  [v67 registerForMessage:v68 receiver:self policies:v72 selector:sel_handleRemoveCHIPPairingsMessage_];

  id v73 = [(HMDAccessory *)self msgDispatcher];
  uint64_t v74 = *MEMORY[0x1E4F2C538];
  long long v75 = +[HMDRemoteMessagePolicy defaultSecurePolicy];
  v145[0] = v75;
  long long v76 = +[HMDUserMessagePolicy userMessagePolicyWithHome:v132 userPrivilege:4 remoteAccessRequired:1];
  v145[1] = v76;
  long long v77 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
  v145[2] = v77;
  long long v78 = [MEMORY[0x1E4F1C978] arrayWithObjects:v145 count:3];
  [v73 registerForMessage:v74 receiver:self policies:v78 selector:sel_handleRemoveCorrespondingSystemCommissionerMessage_];

  uint64_t v79 = [(HMDAccessory *)self msgDispatcher];
  uint64_t v80 = *MEMORY[0x1E4F2C0F0];
  __int16 v81 = +[HMDRemoteMessagePolicy defaultSecurePolicy];
  v144[0] = v81;
  char v82 = +[HMDUserMessagePolicy userMessagePolicyWithHome:v132 userPrivilege:4 remoteAccessRequired:1];
  v144[1] = v82;
  __int16 v83 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
  v144[2] = v83;
  uint64_t v84 = [MEMORY[0x1E4F1C978] arrayWithObjects:v144 count:3];
  [v79 registerForMessage:v80 receiver:self policies:v84 selector:sel_handleActivateCHIPPairingModeMessage_];

  __int16 v85 = [(HMDAccessory *)self msgDispatcher];
  uint64_t v86 = *MEMORY[0x1E4F2C0E8];
  __int16 v87 = +[HMDRemoteMessagePolicy defaultSecurePolicy];
  v143[0] = v87;
  uint64_t v88 = +[HMDUserMessagePolicy userMessagePolicyWithHome:v132 userPrivilege:4 remoteAccessRequired:1];
  v143[1] = v88;
  __int16 v89 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
  v143[2] = v89;
  __int16 v90 = [MEMORY[0x1E4F1C978] arrayWithObjects:v143 count:3];
  [v85 registerForMessage:v86 receiver:self policies:v90 selector:sel_handleActivateCHIPPairingModeAndCreateSetupPayloadStringMessage_];

  __int16 v91 = [(HMDAccessory *)self msgDispatcher];
  uint64_t v92 = *MEMORY[0x1E4F2C8A8];
  v142[0] = v131;
  __int16 v93 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
  v142[1] = v93;
  uint64_t v94 = [MEMORY[0x1E4F1C978] arrayWithObjects:v142 count:2];
  [v91 registerForMessage:v92 receiver:self policies:v94 selector:sel__handleValidatePairingAuthMethodMessage_];

  if (isInternalBuild())
  {
    __int16 v95 = [(HMDAccessory *)self msgDispatcher];
    v141[0] = v131;
    uint64_t v96 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
    v141[1] = v96;
    __int16 v97 = [MEMORY[0x1E4F1C978] arrayWithObjects:v141 count:2];
    [v95 registerForMessage:@"kUpdateAccessoryConnectionStateKey" receiver:self policies:v97 selector:sel__handleUpdateAccessoryConnectionState_];
  }
  if (isInternalBuild())
  {
    uint64_t v98 = [(HMDAccessory *)self msgDispatcher];
    uint64_t v99 = *MEMORY[0x1E4F2C358];
    v140[0] = v131;
    uint64_t v100 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
    v140[1] = v100;
    __int16 v101 = [MEMORY[0x1E4F1C978] arrayWithObjects:v140 count:2];
    [v98 registerForMessage:v99 receiver:self policies:v101 selector:sel_handleGetAllUsersMessage_];

    id v102 = [(HMDAccessory *)self msgDispatcher];
    uint64_t v103 = *MEMORY[0x1E4F2C2A0];
    v139[0] = v131;
    uint64_t v104 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
    v139[1] = v104;
    uint64_t v105 = [MEMORY[0x1E4F1C978] arrayWithObjects:v139 count:2];
    [v102 registerForMessage:v103 receiver:self policies:v105 selector:sel_handleClearUserMessage_];

    uint64_t v106 = [(HMDAccessory *)self msgDispatcher];
    uint64_t v107 = *MEMORY[0x1E4F2C288];
    v138[0] = v131;
    id v108 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
    v138[1] = v108;
    id v109 = [MEMORY[0x1E4F1C978] arrayWithObjects:v138 count:2];
    [v106 registerForMessage:v107 receiver:self policies:v109 selector:sel_handleClearCredentialMessage_];

    uint64_t v110 = [(HMDAccessory *)self msgDispatcher];
    v137[0] = v131;
    BOOL v111 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
    v137[1] = v111;
    uint32_t v112 = [MEMORY[0x1E4F1C978] arrayWithObjects:v137 count:2];
    [v110 registerForMessage:@"kSetStartUpColorTemperatureRequestKey" receiver:self policies:v112 selector:sel_handleSetStartUpColorTemperature_];

    uint64_t v113 = [(HMDAccessory *)self msgDispatcher];
    v136[0] = v131;
    int v114 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
    v136[1] = v114;
    uint64_t v115 = [MEMORY[0x1E4F1C978] arrayWithObjects:v136 count:2];
    [v113 registerForMessage:@"kGetStartUpColorTemperatureRequestKey" receiver:self policies:v115 selector:sel_handleGetStartUpColorTemperature_];

    long long v116 = [(HMDAccessory *)self msgDispatcher];
    uint64_t v117 = *MEMORY[0x1E4F2C3D0];
    v135[0] = v131;
    uint64_t v118 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
    v135[1] = v118;
    long long v119 = [MEMORY[0x1E4F1C978] arrayWithObjects:v135 count:2];
    [v116 registerForMessage:v117 receiver:self policies:v119 selector:sel_handleGetAccessoryDiagnosticCountersMessage_];

    unint64_t v120 = [(HMDAccessory *)self msgDispatcher];
    uint64_t v121 = *MEMORY[0x1E4F2C3D8];
    v134[0] = v131;
    dispatch_group_t v122 = +[HMDXPCMessagePolicy policyWithEntitlements:5];
    v134[1] = v122;
    char v123 = [MEMORY[0x1E4F1C978] arrayWithObjects:v134 count:2];
    [v120 registerForMessage:v121 receiver:self policies:v123 selector:sel_handleGetAccessoryDiagnosticEventsMessage_];
  }
  [(HMDHAPAccessory *)self _registerForMessages_lowPowerMode];
  long long v124 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v124 addObserver:self selector:sel_handleCharacteristicsChangedNotification_ name:@"HMDAccessoryCharacteristicsChangedNotification" object:self];

  __int16 v125 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v125 addObserver:self selector:sel_handleRoomChanged_ name:@"HMDNotificationAccessoryChangedRoom" object:self];

  __int16 v126 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v126 addObserver:self selector:sel_handleRoomNameChanged_ name:@"HMDRoomNameUpdatedNotification" object:0];

  uint64_t v127 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v127 addObserver:self selector:sel_handleAccessoryConfigured_ name:@"HMDAccessoryConnectedNotification" object:self];

  __int16 v128 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v128 removeObserver:self name:@"HMDHomeUserRemovedNotification" object:0];

  uint64_t v129 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v129 addObserver:self selector:sel_handleHomeUserRemovedNotification_ name:@"HMDHomeUserRemovedNotification" object:v132];
}

- (NSString)serializedIdentifier
{
  uint64_t v3 = [(HMDAccessory *)self home];
  BOOL v4 = NSString;
  uint64_t v5 = [v3 uuid];
  uint64_t v6 = [v5 UUIDString];
  uint64_t v7 = [(HMDAccessory *)self uuid];
  long long v8 = [v7 UUIDString];
  long long v9 = [v4 stringWithFormat:@"%@/%@", v6, v8];

  return (NSString *)v9;
}

- (BOOL)_validateConnectivityInfo:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [v4 woBLEInfo];
  uint64_t v6 = [v5 bleIdentifier];
  if (v6)
  {
  }
  else
  {
    uint64_t v7 = [v4 woWLANInfo];
    long long v8 = [v7 primaryMACAddress];

    if (v8) {
      goto LABEL_5;
    }
    long long v11 = [v4 woWLANInfo];
    int v12 = [v11 supportsSleepConfig];

    if (!v12)
    {
      char v9 = 0;
      goto LABEL_6;
    }
    uint64_t v5 = [v4 woWLANInfos];
    if ([v5 count] == 1)
    {
      long long v13 = [(HMDHAPAccessory *)self connectivityInfo];
      long long v14 = [v13 woWLANInfos];
      unint64_t v15 = [v14 count];
      uint64_t v16 = [v4 woWLANInfos];
      LOBYTE(v15) = v15 > [v16 count];

      char v9 = v15 ^ 1;
      goto LABEL_6;
    }
  }

LABEL_5:
  char v9 = 1;
LABEL_6:

  return v9 & 1;
}

- (HMDHAPAccessory)initWithTransaction:(id)a3 home:(id)a4 hapMetadata:(id)a5
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  v92.receiver = self;
  v92.super_class = (Class)HMDHAPAccessory;
  long long v11 = [(HMDAccessory *)&v92 initWithTransaction:v8 home:v9];
  if (!v11)
  {
LABEL_34:
    id v40 = v11;
    goto LABEL_35;
  }
  uint64_t v12 = [v8 uniqueIdentifier];
  uniqueIdentifier = v11->_uniqueIdentifier;
  v11->_uniqueIdentifier = (NSString *)v12;

  if (v11->_uniqueIdentifier)
  {
    objc_storeStrong((id *)&v11->_hapMetadata, a5);
    long long v14 = [v8 communicationProtocol];

    if (v14)
    {
      unint64_t v15 = [v8 communicationProtocol];
      v11->_int64_t communicationProtocol = [v15 integerValue];
    }
    uint64_t v16 = [v8 accessoryFlags];
    accessoryFlags = v11->_accessoryFlags;
    v11->_accessoryFlags = (NSNumber *)v16;

    __int16 v18 = [v8 certificationStatus];
    v11->_certificationStatus = [v18 unsignedIntegerValue];

    uint64_t v19 = [v8 pairingUsername];
    pairingUsername = v11->_pairingUsername;
    v11->_pairingUsername = (NSString *)v19;

    uint64_t v21 = [v8 publicKey];
    publicKey = v11->_publicKey;
    v11->_publicKey = (NSData *)v21;

    uint64_t v23 = [v8 broadcastKey];
    broadcastKey = v11->_broadcastKey;
    v11->_broadcastKey = (NSData *)v23;

    uint64_t v25 = [v8 keyUpdatedTime];
    keyUpdatedTime = v11->_keyUpdatedTime;
    v11->_keyUpdatedTime = (NSDate *)v25;

    v11->_keyGenerationInProgress = 0;
    uint64_t v27 = [v8 keyUpdatedStateNumber];
    keyUpdatedStateNumber = v11->_keyUpdatedStateNumber;
    v11->_keyUpdatedStateNumber = (NSNumber *)v27;

    uint64_t v29 = [v8 hasOnboardedForNaturalLighting];
    hasOnboardedForNaturalLighting = v11->_hasOnboardedForNaturalLighting;
    v11->_hasOnboardedForNaturalLighting = (NSNumber *)v29;

    id v31 = objc_alloc(MEMORY[0x1E4F29128]);
    uint64_t v32 = [v8 bridgeUUID];
    id v33 = (void *)[v31 initWithUUIDString:v32];

    uint64_t v34 = [v8 bridgeUUID];

    if (v34)
    {
      id v35 = v33;
    }
    else
    {
      id v35 = [v8 hostAccessoryUUID];

      if (v35)
      {
        id v41 = objc_alloc(MEMORY[0x1E4F29128]);
        long long v42 = [v8 hostAccessoryUUID];
        id v35 = (id)[v41 initWithUUIDString:v42];
      }
    }
    __int16 v91 = v35;
    [(HMDAccessory *)v11 _updateHost:v35];
    uint64_t v43 = [v8 transportInformation];
    [(HMDHAPAccessory *)v11 updateTransportInformation:v43 localSource:1];

    char v44 = +[HMDBulletinBoard sharedBulletinBoard];
    [(HMDHAPAccessory *)v11 setBulletinBoard:v44];

    objc_super v45 = [v8 firmwareVersion];

    if (v45 && [(HMDHAPAccessory *)v11 supportsCHIP])
    {
      id v46 = [HMDAccessoryVersion alloc];
      id v47 = [v8 firmwareVersion];
      uint64_t v48 = [(HMDAccessoryVersion *)v46 initWithMatterVersionString:v47];
      [(HMDAccessory *)v11 setFirmwareVersion:v48];
    }
    uint64_t v49 = [(HMDHAPAccessory *)v11 bridge];
    uint64_t v50 = [v49 room];
    if (v50)
    {
      long long v51 = (void *)v50;
      id v52 = [v8 roomUUID];

      if (!v52)
      {
        uint64_t v53 = [v49 room];
        [(HMDAccessory *)v11 setRoom:v53];
      }
    }
    uint64_t v54 = [v8 accessorySetupHash];
    setupHash = v11->_setupHash;
    v11->_setupHash = (NSData *)v54;

    uint64_t v56 = [v8 wiFiTransportCapabilities];
    wiFiTransportCapabilities = v11->_wiFiTransportCapabilities;
    v11->_wiFiTransportCapabilities = (NSNumber *)v56;

    uint64_t v58 = [v8 targetUUIDs];
    targetUUIDs = v11->_targetUUIDs;
    v11->_targetUUIDs = (NSArray *)v58;

    __int16 v60 = [v8 hardwareSupport];
    v11->_hardwareSupport = [v60 BOOLValue];

    __int16 v61 = [v8 connectivityInfo];
    if (v61 && [(HMDHAPAccessory *)v11 _validateConnectivityInfo:v61])
    {
      __int16 v89 = v33;
      id v90 = v10;
      objc_storeStrong((id *)&v11->_connectivityInfo, v61);
      __int16 v62 = (void *)MEMORY[0x1D9452090]();
      uint64_t v63 = v11;
      id v64 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        __int16 v65 = HMFGetLogIdentifier();
        __int16 v66 = v11->_uniqueIdentifier;
        *(_DWORD *)buf = 138543874;
        uint64_t v94 = v65;
        __int16 v95 = 2112;
        id v96 = v61;
        __int16 v97 = 2112;
        uint64_t v98 = v66;
        _os_log_impl(&dword_1D49D5000, v64, OS_LOG_TYPE_DEBUG, "%{public}@Setting connectivityInfo to: %@ from accessory transaction of %@", buf, 0x20u);
      }
      id v33 = v89;
      id v10 = v90;
    }
    uint64_t v67 = [v8 sleepInterval];
    sleepInterval = v11->_sleepInterval;
    v11->_sleepInterval = (NSNumber *)v67;

    uint64_t v69 = (void *)MEMORY[0x1E4F654E8];
    uint64_t v70 = [v8 initialServiceTypeUUIDs];
    uint64_t v71 = objc_msgSend(v69, "hmf_setOfCachedInstancesForStrings:", v70);
    initialServiceTypeUUIDs = v11->_initialServiceTypeUUIDs;
    v11->_initialServiceTypeUUIDs = (NSSet *)v71;

    id v73 = [v8 suspendedState];

    if (v73)
    {
      uint64_t v74 = [v8 suspendedState];
      -[HMDHAPAccessory setSuspendedState:](v11, "setSuspendedState:", [v74 unsignedIntegerValue]);
    }
    [(HMDHAPAccessory *)v11 wirelessResumeInit];
    v11->_unint64_t siriEndpointCapabilities = 0;
    long long v75 = [v8 needsOnboarding];

    if (v75)
    {
      long long v76 = [v8 needsOnboarding];
      uint64_t v77 = [v76 copy];
      needsOnboarding = v11->_needsOnboarding;
      v11->_needsOnboarding = (NSNumber *)v77;
    }
    [(HMDCHIPAccessoryStorage *)v11->_chipStorage updateUsingAccessoryModel:v8];
    uint64_t v79 = [(HMDCHIPAccessoryStorage *)v11->_chipStorage nodeID];
    uint64_t v80 = (void *)v79;
    if (v79) {
      __int16 v81 = (void *)v79;
    }
    else {
      __int16 v81 = &unk_1F2DC7C30;
    }
    objc_storeStrong((id *)&v11->_matterNodeID, v81);

    uint64_t v82 = [(HMDCHIPAccessoryStorage *)v11->_chipStorage vendorID];
    matterVendorID = v11->_matterVendorID;
    v11->_matterVendorID = (NSNumber *)v82;

    uint64_t v84 = [(HMDCHIPAccessoryStorage *)v11->_chipStorage productID];
    matterProductID = v11->_matterProductID;
    v11->_matterProductID = (NSNumber *)v84;

    if (v11->_matterVendorID && v11->_matterProductID) {
      logAndPostNotification(@"HMDAccessoryVendorIDProductIDUpdatedNotification", v11, 0);
    }
    uint64_t v86 = (NAFuture *)objc_alloc_init(MEMORY[0x1E4F7A0D8]);
    didConfigureCHIPAccessoryServerFuture = v11->_didConfigureCHIPAccessoryServerFuture;
    v11->_didConfigureCHIPAccessoryServerFuture = v86;

    goto LABEL_34;
  }
  int v36 = (void *)MEMORY[0x1D9452090]();
  id v37 = v11;
  unsigned int v38 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
  {
    long long v39 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    uint64_t v94 = v39;
    __int16 v95 = 2112;
    id v96 = v8;
    _os_log_impl(&dword_1D49D5000, v38, OS_LOG_TYPE_ERROR, "%{public}@Failed to create accessory from transaction with nil uniqueIdentifier: %@", buf, 0x16u);
  }
  id v40 = 0;
LABEL_35:

  return v40;
}

- (HMDHAPAccessory)initWithTransaction:(id)a3 home:(id)a4
{
  id v6 = a4;
  id v7 = a3;
  id v8 = +[HMDHAPMetadata getSharedInstance];
  id v9 = [(HMDHAPAccessory *)self initWithTransaction:v7 home:v6 hapMetadata:v8];

  return v9;
}

- (HMDHAPAccessory)initWithHAPMetadata:(id)a3
{
  id v5 = a3;
  v36.receiver = self;
  v36.super_class = (Class)HMDHAPAccessory;
  id v6 = [(HMDAccessory *)&v36 init];
  id v7 = v6;
  if (v6)
  {
    v6->_certificationStatus = 0;
    objc_storeStrong((id *)&v6->_hapMetadata, a3);
    internalEnhancedAuthConfigNumber = v7->_internalEnhancedAuthConfigNumber;
    v7->_internalEnhancedAuthConfigNumber = 0;

    internalEnhancedAuthMethod = v7->_internalEnhancedAuthMethod;
    v7->_internalEnhancedAuthMethod = 0;

    uint64_t v10 = [MEMORY[0x1E4F1CA48] array];
    services = v7->_services;
    v7->_services = (NSMutableArray *)v10;

    uint64_t v12 = [MEMORY[0x1E4F1CAD0] set];
    identifiersForBridgedAccessories = v7->_identifiersForBridgedAccessories;
    v7->_identifiersForBridgedAccessories = (NSSet *)v12;

    uint64_t v14 = objc_opt_new();
    transportInformationInstances = v7->_transportInformationInstances;
    v7->_transportInformationInstances = (NSMutableArray *)v14;

    v7->_int64_t communicationProtocol = 0;
    backedOffStateNumber = v7->_backedOffStateNumber;
    v7->_backedOffStateNumber = 0;

    accessoryDiscoveryBackoffTimer = v7->_accessoryDiscoveryBackoffTimer;
    v7->_accessoryDiscoveryBackoffTimer = 0;

    accessoryKeyRefreshTimer = v7->_accessoryKeyRefreshTimer;
    v7->_accessoryKeyRefreshTimer = 0;

    v7->_keyGenerationType = 0;
    uint64_t v19 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E4F1CA48]);
    powerOnCompletionRoutines = v7->_powerOnCompletionRoutines;
    v7->_powerOnCompletionRoutines = v19;

    v7->_unint64_t siriEndpointCapabilities = 0;
    uint64_t v21 = [MEMORY[0x1E4F1CA60] dictionary];
    accessCodeCache = v7->_accessCodeCache;
    v7->_accessCodeCache = (NSMutableDictionary *)v21;

    uint64_t v23 = [MEMORY[0x1E4F1CA80] set];
    activeSessionRestoreClients = v7->_activeSessionRestoreClients;
    v7->_activeSessionRestoreClients = (NSMutableSet *)v23;

    sessionRestoreTimer = v7->_sessionRestoreTimer;
    v7->_sessionRestoreTimer = 0;

    v7->_lastLinkChangeSessionCheckTime = 0.0;
    v7->_lastSessionStatus = 0;
    id v26 = objc_alloc_init(HMDCHIPAccessoryStorage);
    chipStorage = v7->_chipStorage;
    v7->_chipStorage = v26;

    matterNodeID = v7->_matterNodeID;
    v7->_matterNodeID = (NSNumber *)&unk_1F2DC7C30;

    uint64_t v29 = (NAFuture *)objc_alloc_init(MEMORY[0x1E4F7A0D8]);
    didConfigureCHIPAccessoryServerFuture = v7->_didConfigureCHIPAccessoryServerFuture;
    v7->_didConfigureCHIPAccessoryServerFuture = v29;

    id v31 = [MEMORY[0x1E4F28EB8] defaultCenter];
    [v31 addObserver:v7 selector:sel_reachabilityDidChangeToReachable_ name:@"HMDAccessoryIsReachableNotification" object:v7];

    uint64_t v32 = [MEMORY[0x1E4F28EB8] defaultCenter];
    [v32 addObserver:v7 selector:sel_reachabilityDidChangeToUnreachable_ name:@"HMDAccessoryIsNotReachableNotification" object:v7];
  }
  uint64_t v33 = +[HMDBulletinBoard sharedBulletinBoard];
  bulletinBoard = v7->_bulletinBoard;
  v7->_bulletinBoard = (HMDBulletinBoard *)v33;

  return v7;
}

- (HMDHAPAccessory)init
{
  uint64_t v3 = +[HMDHAPMetadata getSharedInstance];
  id v4 = [(HMDHAPAccessory *)self initWithHAPMetadata:v3];

  return v4;
}

+ (Class)transactionClass
{
  return (Class)objc_opt_class();
}

- (id)_accessoryForHH2MigrationFileName
{
  uint64_t v3 = NSString;
  id v4 = (id)hh1ToHH2PerDeviceMigrationDirectoryPath;
  id v5 = [(HMDAccessory *)self uuid];
  id v6 = [v3 stringWithFormat:@"%@/HMDHAPAccessory-%@.plist", v4, v5];

  return v6;
}

- (void)saveCharacteristicsToLocalDiskForHH2Migration
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = [(HMDHAPAccessory *)self services];
  uint64_t v4 = [v3 count];

  if (v4)
  {
    id v5 = (void *)MEMORY[0x1D9452090]();
    id v6 = (void *)MEMORY[0x1D9452090]();
    id v7 = self;
    id v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      int v21 = 138543362;
      uint64_t v22 = v9;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Storing accessory for migration", (uint8_t *)&v21, 0xCu);
    }
    uint64_t v10 = encodeRootObject();
    if (v10)
    {
      long long v11 = [(HMDHAPAccessory *)v7 _accessoryForHH2MigrationFileName];
      uint64_t v12 = +[HMDPersistentStore writeData:v10 toStorePath:v11 dataLabel:@"PerHAPAccessoryHH2Migration"];
      long long v13 = (void *)MEMORY[0x1D9452090]();
      uint64_t v14 = v7;
      unint64_t v15 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        uint64_t v16 = HMFGetLogIdentifier();
        int v21 = 138543874;
        uint64_t v22 = v16;
        __int16 v23 = 2112;
        id v24 = v12;
        __int16 v25 = 2112;
        id v26 = v11;
        _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@Stored [%@] bytes to [%@]", (uint8_t *)&v21, 0x20u);
      }
    }
    else
    {
      id v17 = (void *)MEMORY[0x1D9452090]();
      __int16 v18 = v7;
      uint64_t v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        uint64_t v20 = HMFGetLogIdentifier();
        int v21 = 138543362;
        uint64_t v22 = v20;
        _os_log_impl(&dword_1D49D5000, v19, OS_LOG_TYPE_ERROR, "%{public}@Nothing to store as there is no data after archiving the accessory", (uint8_t *)&v21, 0xCu);
      }
    }
  }
}

- (BOOL)_handleUpdatedServicesForNetworkRouterController:(id)a3
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  id v6 = v4;
  uint64_t v7 = [v6 countByEnumeratingWithState:&v22 objects:v30 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    int v9 = 0;
    uint64_t v10 = *(void *)v23;
    uint64_t v11 = *MEMORY[0x1E4F2DF18];
    while (2)
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v23 != v10) {
          objc_enumerationMutation(v6);
        }
        long long v13 = *(void **)(*((void *)&v22 + 1) + 8 * i);
        uint64_t v14 = objc_msgSend(v13, "serviceType", (void)v22);
        int v15 = [v14 isEqualToString:v11];

        if (v15)
        {
          if (![(HMDHAPAccessory *)self isPrimary])
          {
            uint64_t v16 = (void *)MEMORY[0x1D9452090]();
            id v17 = self;
            __int16 v18 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              uint64_t v19 = HMFGetLogIdentifier();
              uint64_t v20 = [(HMDHAPAccessory *)v17 name];
              *(_DWORD *)buf = 138543618;
              uint64_t v27 = v19;
              __int16 v28 = 2112;
              uint64_t v29 = v20;
              _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_ERROR, "%{public}@Network router service is not allowed on bridged HAP accessory: %@", buf, 0x16u);
            }
            goto LABEL_16;
          }
          v9 |= [(HMDHAPAccessory *)self _updateNetworkRouterControllerUsingRouterService:v13];
        }
      }
      uint64_t v8 = [v6 countByEnumeratingWithState:&v22 objects:v30 count:16];
      if (v8) {
        continue;
      }
      break;
    }
  }
  else
  {
    LOBYTE(v9) = 0;
  }
LABEL_16:

  return v9 & 1;
}

- (BOOL)_updateNetworkRouterControllerUsingRouterService:(id)a3
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  id v6 = [(HMDHAPAccessory *)self networkRouterController];
  uint64_t v7 = [HMDNetworkRouterController alloc];
  uint64_t v8 = [(HMDAccessory *)self workQueue];
  int v9 = [(HMDNetworkRouterController *)v7 initWithAccessory:self service:v4 workQueue:v8];

  char v10 = HMFEqualObjects();
  if ((v10 & 1) == 0)
  {
    [(HMDNetworkRouterController *)v9 configure];
    [(HMDHAPAccessory *)self setNetworkRouterController:v9];
    uint64_t v11 = [(HMDAccessory *)self home];
    unint64_t v12 = 0x1E4F1C000;
    if (v6)
    {
      long long v13 = (void *)MEMORY[0x1D9452090]();
      uint64_t v14 = self;
      int v15 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        uint64_t v16 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        uint64_t v31 = v16;
        __int16 v32 = 2112;
        uint64_t v33 = v6;
        _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@Removing existing network router controller: %@", buf, 0x16u);

        unint64_t v12 = 0x1E4F1C000uLL;
      }

      id v17 = [MEMORY[0x1E4F28EB8] defaultCenter];
      __int16 v28 = @"HMDNetworkRouterAccessoryNotificationKey";
      uint64_t v29 = v14;
      __int16 v18 = [*(id *)(v12 + 2536) dictionaryWithObjects:&v29 forKeys:&v28 count:1];
      [v17 postNotificationName:@"HMDAccessoryDidRemoveNetworkRouterControllerNotification" object:v11 userInfo:v18];
    }
    if (v9)
    {
      uint64_t v19 = (void *)MEMORY[0x1D9452090]();
      uint64_t v20 = self;
      int v21 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        long long v22 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        uint64_t v31 = v22;
        __int16 v32 = 2112;
        uint64_t v33 = v9;
        _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_INFO, "%{public}@Creating new network router controller: %@", buf, 0x16u);
      }
      long long v23 = [MEMORY[0x1E4F28EB8] defaultCenter];
      id v26 = @"HMDNetworkRouterAccessoryNotificationKey";
      uint64_t v27 = v20;
      long long v24 = [*(id *)(v12 + 2536) dictionaryWithObjects:&v27 forKeys:&v26 count:1];
      [v23 postNotificationName:@"HMDAccessoryDidAddNetworkRouterControllerNotification" object:v11 userInfo:v24];
    }
  }

  return v10 ^ 1;
}

- (BOOL)hasAnyServiceWithTypes:(id)a3
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v5 = [(HMDHAPAccessory *)self services];
  uint64_t v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v13;
    while (2)
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v13 != v7) {
          objc_enumerationMutation(v5);
        }
        int v9 = [*(id *)(*((void *)&v12 + 1) + 8 * i) type];
        char v10 = [v4 containsObject:v9];

        if (v10)
        {
          LOBYTE(v6) = 1;
          goto LABEL_11;
        }
      }
      uint64_t v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
LABEL_11:

  return v6;
}

- (void)updateHasPostedBulletinForWalletKeyOnboarding:(BOOL)a3
{
  BOOL v3 = a3;
  if ([(HMDHAPAccessory *)self hasPostedBulletinForWalletKeyOnboarding] != a3)
  {
    [(HMDHAPAccessory *)self setHasPostedBulletinForWalletKeyOnboarding:v3];
    id v5 = [(HMDAccessory *)self home];
    [v5 saveToCurrentAccountWithReason:@"HMDHAPAccessoryUpdateHasPostedBulletinForWalletKeyOnboardingReason"];
  }
}

- (NSData)nfcReaderIdentifier
{
  v9[2] = *MEMORY[0x1E4F143B8];
  v9[0] = 0;
  v9[1] = 0;
  id v2 = (void *)MEMORY[0x1E4F29128];
  BOOL v3 = [(HMDAccessory *)self uuid];
  uint64_t v8 = @"69D04989-C152-43AD-85CD-CE5336B758FA";
  id v4 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v8 count:1];
  id v5 = objc_msgSend(v2, "hm_deriveUUIDFromBaseUUID:withSalts:", v3, v4);
  [v5 getUUIDBytes:v9];

  uint64_t v6 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v9 length:8];
  return (NSData *)v6;
}

- (id)compositeSettingsControllerManagerForSiriEndpointProfileMetricsDispatcher:(id)a3
{
  BOOL v3 = [(HMDAccessory *)self home];
  id v4 = [v3 homeManager];
  id v5 = [v4 compositeSettingsControllerManager];

  return v5;
}

- (id)profileFieldsForSiriEndpointProfileMetricsDispatcher:(id)a3
{
  id v4 = [(HMDHAPAccessory *)self needsOnboarding];
  [v4 BOOLValue];

  id v5 = [(HMDHAPAccessory *)self siriEndpointProfile];
  uint64_t v6 = [HMDSiriEndpointProfileFields alloc];
  uint64_t v7 = HMFBooleanToString();
  [(HMDHAPAccessory *)self supportsSiriEndpointOnBoarding];
  uint64_t v8 = HMFBooleanToString();
  if (v5)
  {
    [v5 siriEnable];
    int v9 = HMFBooleanToString();
    [v5 siriListening];
    char v10 = HMFBooleanToString();
    [v5 siriTouchToUse];
    uint64_t v11 = HMFBooleanToString();
    [v5 siriLightOnUse];
    long long v12 = HMFBooleanToString();
    [v5 siriSoundOnUse];
    long long v13 = HMFBooleanToString();
    long long v14 = [(HMDSiriEndpointProfileFields *)v6 initWithNeedsOnboardingField:v7 supportsOnboardingField:v8 siriEnableField:v9 siriListeningField:v10 siriTouchToUseField:v11 siriLightOnUseField:v12 siriSoundOnUseField:v13];
  }
  else
  {
    long long v14 = [(HMDSiriEndpointProfileFields *)v6 initWithNeedsOnboardingField:v7 supportsOnboardingField:v8 siriEnableField:@"NoProfile" siriListeningField:@"NoProfile" siriTouchToUseField:@"NoProfile" siriLightOnUseField:@"NoProfile" siriSoundOnUseField:@"NoProfile"];
  }

  return v14;
}

- (id)accessoryCategoryTypeForSiriEndpointProfileMetricsDispatcher:(id)a3
{
  BOOL v3 = [(HMDAccessory *)self category];
  id v4 = [v3 categoryType];

  return v4;
}

- (BOOL)shouldSubmitRoutineConfigurationEventForSiriEndpointProfileMetricsDispatcher:(id)a3
{
  id v4 = [(HMDAccessory *)self home];
  if ([v4 isCurrentDeviceConfirmedPrimaryResident])
  {
    id v5 = [(HMDHAPAccessory *)self siriEndpointProfile];
    BOOL v6 = v5 != 0;
  }
  else
  {
    BOOL v6 = 0;
  }

  return v6;
}

- (BOOL)_handleUpdatedServicesForDoorbellController
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  BOOL v3 = [(HMDHAPAccessory *)self services];
  char v4 = objc_msgSend(v3, "na_any:", &__block_literal_global_108346);

  if (v4)
  {
    id v5 = [(HMDHAPAccessory *)self doorbellChimeController];

    if (!v5)
    {
      BOOL v6 = [HMDDoorbellChimeController alloc];
      uint64_t v7 = [(HMDAccessory *)self workQueue];
      uint64_t v8 = [(HMDDoorbellChimeController *)v6 initWithWorkQueue:v7 accessory:self];
      [(HMDHAPAccessory *)self setDoorbellChimeController:v8];

      int v9 = [(HMDHAPAccessory *)self doorbellChimeController];
      [v9 configure];

      return 1;
    }
  }
  else
  {
    uint64_t v11 = (void *)MEMORY[0x1D9452090]();
    long long v12 = self;
    long long v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      long long v14 = HMFGetLogIdentifier();
      int v15 = 138543362;
      uint64_t v16 = v14;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_DEBUG, "%{public}@No service type doorbell, chime controller not created", (uint8_t *)&v15, 0xCu);
    }
  }
  return 0;
}

uint64_t __87__HMDHAPAccessory_DoorbellChimeController___handleUpdatedServicesForDoorbellController__block_invoke(uint64_t a1, void *a2)
{
  id v2 = [a2 serviceType];
  uint64_t v3 = [v2 isEqualToString:*MEMORY[0x1E4F2DE20]];

  return v3;
}

- (void)writeValue:(id)a3 toCharacteristic:(id)a4 queue:(id)a5 completion:(id)a6
{
  location[3] = *(id *)MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = a6;
  if (v11)
  {
    long long v14 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:1];
    int v15 = [v11 authorizationData];
    uint64_t v16 = +[HMDCharacteristicWriteRequest writeRequestWithCharacteristic:v11 value:v10 authorizationData:v15 type:0];

    [v14 addObject:v16];
    objc_initWeak(location, self);
    uint64_t v22 = MEMORY[0x1E4F143A8];
    uint64_t v23 = 3221225472;
    long long v24 = __71__HMDHAPAccessory_Write__writeValue_toCharacteristic_queue_completion___block_invoke;
    long long v25 = &unk_1E6A18FF8;
    objc_copyWeak(&v27, location);
    id v26 = v13;
    uint64_t v17 = _Block_copy(&v22);
    -[HMDHAPAccessory writeCharacteristicValues:source:queue:completionHandler:](self, "writeCharacteristicValues:source:queue:completionHandler:", v14, 7, v12, v17, v22, v23, v24, v25);

    objc_destroyWeak(&v27);
    objc_destroyWeak(location);
LABEL_7:

    goto LABEL_8;
  }
  __int16 v18 = (void *)MEMORY[0x1D9452090]();
  uint64_t v19 = self;
  uint64_t v20 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    int v21 = HMFGetLogIdentifier();
    LODWORD(location[0]) = 138543362;
    *(id *)((char *)location + 4) = v21;
    _os_log_impl(&dword_1D49D5000, v20, OS_LOG_TYPE_ERROR, "%{public}@Invalid characteristic to write", (uint8_t *)location, 0xCu);
  }
  long long v14 = _Block_copy(v13);
  if (v14)
  {
    uint64_t v16 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
    (*((void (**)(void *, void *))v14 + 2))(v14, v16);
    goto LABEL_7;
  }
LABEL_8:
}

void __71__HMDHAPAccessory_Write__writeValue_toCharacteristic_queue_completion___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v5 = [v3 firstObject];
    BOOL v6 = v5;
    uint64_t v7 = *(void *)(a1 + 32);
    if (v5)
    {
      if (v7)
      {
        uint64_t v8 = [v5 error];
LABEL_11:
        id v13 = (void *)v8;
        (*(void (**)(uint64_t, uint64_t))(v7 + 16))(v7, v8);
      }
    }
    else if (v7)
    {
      uint64_t v8 = [MEMORY[0x1E4F28C58] hmErrorWithCode:74];
      goto LABEL_11;
    }
LABEL_12:

    goto LABEL_13;
  }
  int v9 = (void *)MEMORY[0x1D9452090]();
  id v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = HMFGetLogIdentifier();
    int v14 = 138543362;
    int v15 = v11;
    _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_ERROR, "%{public}@Accessory not found for writing target list characteristic", (uint8_t *)&v14, 0xCu);
  }
  uint64_t v12 = *(void *)(a1 + 32);
  if (v12)
  {
    BOOL v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    (*(void (**)(uint64_t, void *))(v12 + 16))(v12, v6);
    goto LABEL_12;
  }
LABEL_13:
}

- (NSDictionary)assistantObject
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  v28.receiver = self;
  v28.super_class = (Class)HMDHAPAccessory;
  id v3 = [(HMDAccessory *)&v28 assistantObject];
  char v4 = (void *)[v3 mutableCopy];

  id v5 = [(HMDHAPAccessory *)self identifiersForBridgedAccessories];
  BOOL v6 = objc_msgSend(MEMORY[0x1E4F1CA80], "setWithCapacity:", objc_msgSend(v5, "count"));
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  id v7 = v5;
  uint64_t v8 = [v7 countByEnumeratingWithState:&v24 objects:v33 count:16];
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t v10 = *(void *)v25;
    do
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (*(void *)v25 != v10) {
          objc_enumerationMutation(v7);
        }
        uint64_t v12 = *(void *)(*((void *)&v24 + 1) + 8 * i);
        id v13 = [(HMDAccessory *)self home];
        int v14 = [v13 accessoryWithUUID:v12];

        if (v14)
        {
          int v15 = [v14 urlString];
          [v6 addObject:v15];
        }
      }
      uint64_t v9 = [v7 countByEnumeratingWithState:&v24 objects:v33 count:16];
    }
    while (v9);
  }

  if ((objc_msgSend(v6, "hmf_isEmpty") & 1) == 0)
  {
    uint64_t v31 = @"objectRelatedIdentifiers";
    uint64_t v16 = [v6 allObjects];
    __int16 v32 = v16;
    uint64_t v17 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v32 forKeys:&v31 count:1];
    [v4 addEntriesFromDictionary:v17];
  }
  __int16 v18 = [(HMDHAPAccessory *)self primaryService];

  if (v18)
  {
    uint64_t v29 = @"objectAccessoryPrimaryServiceIdentifier";
    uint64_t v19 = [(HMDHAPAccessory *)self primaryService];
    uint64_t v20 = [v19 urlString];
    uint64_t v30 = v20;
    int v21 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v30 forKeys:&v29 count:1];
    [v4 addEntriesFromDictionary:v21];
  }
  uint64_t v22 = (void *)[v4 copy];

  return (NSDictionary *)v22;
}

- (NSString)urlString
{
  v4.receiver = self;
  v4.super_class = (Class)HMDHAPAccessory;
  id v2 = [(HMDAccessory *)&v4 urlString];
  return (NSString *)v2;
}

- (BOOL)isAssignedHubForSiriEndpoint
{
  id v3 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v3);

  objc_super v4 = [(HMDHAPAccessory *)self currentActiveSessionRestoreClients];
  id v5 = HAPStringFromAccessoryServerSession();
  char v6 = [v4 containsObject:v5];

  return v6;
}

- (BOOL)supportsSiriEndpointOnBoarding
{
  id v2 = [(HMDAccessory *)self home];
  char v3 = [v2 supportsSiriEndpointOnBoarding];

  return v3;
}

- (void)_checkForSiriEndpointServiceChange
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  char v3 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000253-0000-1000-8000-0026BB765291"];

  if (v3)
  {
    BOOL v4 = [(HMDHAPAccessory *)self hasSiriEndpointService];
    uint64_t v5 = [(HMDHAPAccessory *)self setHasSiriEndpointService:1];
    if (!v4)
    {
      char v6 = (void *)MEMORY[0x1D9452090](v5);
      id v7 = self;
      uint64_t v8 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        uint64_t v9 = HMFGetLogIdentifier();
        int v11 = 138543362;
        uint64_t v12 = v9;
        _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Siri endpoint service observed before the profile is added. Sending out a notification.", (uint8_t *)&v11, 0xCu);
      }
      uint64_t v10 = [MEMORY[0x1E4F28EB8] defaultCenter];
      [v10 postNotificationName:@"HMDAccessorySiriEndpointServiceAddedNotification" object:v7 userInfo:0];
    }
  }
  else
  {
    [(HMDHAPAccessory *)self setHasSiriEndpointService:0];
  }
}

- (BOOL)_handleUpdatedServicesForSiriEndpointProfile:(id)a3
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  [(HMDHAPAccessory *)self _checkForSiriEndpointServiceChange];
  if (![(HMDHAPAccessory *)self supportsSiriEndpoint])
  {
    BOOL v10 = 0;
    goto LABEL_81;
  }
  uint64_t v84 = self;
  uint64_t v6 = [(HMDHAPAccessory *)self siriEndpointProfile];
  if (v6)
  {
    id v7 = (HMDSiriEndpointProfile *)v6;
    long long v99 = 0u;
    long long v100 = 0u;
    long long v97 = 0u;
    long long v98 = 0u;
    id obj = v4;
    uint64_t v8 = [obj countByEnumeratingWithState:&v97 objects:v108 count:16];
    if (!v8)
    {
      BOOL v10 = 0;
      goto LABEL_80;
    }
    uint64_t v9 = v8;
    id v75 = v4;
    BOOL v10 = 0;
    uint64_t v11 = *(void *)v98;
LABEL_5:
    uint64_t v12 = 0;
    while (1)
    {
      if (*(void *)v98 != v11) {
        objc_enumerationMutation(obj);
      }
      uint64_t v13 = *(void **)(*((void *)&v97 + 1) + 8 * v12);
      int v14 = [v13 serviceType];
      int v15 = [v14 isEqualToString:@"00000133-0000-1000-8000-0026BB765291"];

      if (v15) {
        break;
      }
      uint64_t v22 = [v13 serviceType];
      int v23 = [v22 isEqualToString:@"0000026A-0000-1000-8000-0026BB765291"];

      if (v23)
      {
        uint64_t v16 = (void *)MEMORY[0x1D9452090]([(HMDSiriEndpointProfile *)v7 addService:v13]);
        long long v24 = v84;
        __int16 v18 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          uint64_t v19 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          uint64_t v105 = v19;
          __int16 v106 = 2112;
          uint64_t v107 = v7;
          uint64_t v20 = v18;
          int v21 = "%{public}@Added Assistant service to current Siri Endpoint profile: %@";
LABEL_14:
          _os_log_impl(&dword_1D49D5000, v20, OS_LOG_TYPE_INFO, v21, buf, 0x16u);
        }
LABEL_15:

        BOOL v10 = 1;
      }
      if (v9 == ++v12)
      {
        uint64_t v9 = [obj countByEnumeratingWithState:&v97 objects:v108 count:16];
        if (!v9)
        {
          id v4 = v75;
          goto LABEL_80;
        }
        goto LABEL_5;
      }
    }
    uint64_t v16 = (void *)MEMORY[0x1D9452090]([(HMDSiriEndpointProfile *)v7 addService:v13]);
    uint64_t v17 = v84;
    __int16 v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      uint64_t v19 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      uint64_t v105 = v19;
      __int16 v106 = 2112;
      uint64_t v107 = v7;
      uint64_t v20 = v18;
      int v21 = "%{public}@Added Siri service to current Siri Endpoint profile: %@";
      goto LABEL_14;
    }
    goto LABEL_15;
  }
  id obj = [MEMORY[0x1E4F1CA48] array];
  long long v78 = [MEMORY[0x1E4F1CA48] array];
  long long v93 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  id v25 = v4;
  id v7 = (HMDSiriEndpointProfile *)[v25 countByEnumeratingWithState:&v93 objects:v103 count:16];
  BOOL v10 = v7 != 0;
  if (!v7) {
    goto LABEL_78;
  }
  id v76 = v4;
  char v81 = 0;
  char v26 = 0;
  uint64_t v27 = *(void *)v94;
  objc_super v28 = v78;
  do
  {
    uint64_t v29 = 0;
    do
    {
      if (*(void *)v94 != v27) {
        objc_enumerationMutation(v25);
      }
      uint64_t v30 = *(void **)(*((void *)&v93 + 1) + 8 * (void)v29);
      uint64_t v31 = [v30 serviceType];
      char v32 = [v31 isEqualToString:@"00000253-0000-1000-8000-0026BB765291"];

      if (v32)
      {
        char v26 = 1;
LABEL_29:
        id v35 = obj;
LABEL_30:
        [v35 addObject:v30];
        goto LABEL_31;
      }
      uint64_t v33 = [v30 serviceType];
      char v34 = [v33 isEqualToString:@"00000133-0000-1000-8000-0026BB765291"];

      if (v34)
      {
        char v81 = 1;
        goto LABEL_29;
      }
      objc_super v36 = [v30 serviceType];
      int v37 = [v36 isEqualToString:@"0000026A-0000-1000-8000-0026BB765291"];

      id v35 = v78;
      if (v37) {
        goto LABEL_30;
      }
LABEL_31:
      uint64_t v29 = (HMDSiriEndpointProfile *)((char *)v29 + 1);
    }
    while (v7 != v29);
    uint64_t v38 = [v25 countByEnumeratingWithState:&v93 objects:v103 count:16];
    id v7 = (HMDSiriEndpointProfile *)v38;
  }
  while (v38);

  if ((v26 & 1) == 0)
  {
    BOOL v10 = 0;
    id v7 = 0;
    id v4 = v76;
    goto LABEL_79;
  }
  if ((v81 & 1) == 0)
  {
    long long v39 = [(HMDHAPAccessory *)v84 findServiceWithServiceType:@"00000133-0000-1000-8000-0026BB765291"];
    if (v39) {
      [obj addObject:v39];
    }
  }
  long long v91 = 0u;
  long long v92 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  id v80 = [(HMDHAPAccessory *)v84 services];
  uint64_t v40 = [v80 countByEnumeratingWithState:&v89 objects:v102 count:16];
  if (v40)
  {
    uint64_t v41 = v40;
    uint64_t v42 = *(void *)v90;
    uint64_t v77 = *(void *)v90;
    do
    {
      uint64_t v43 = 0;
      uint64_t v79 = v41;
      do
      {
        if (*(void *)v90 != v42) {
          objc_enumerationMutation(v80);
        }
        char v44 = *(void **)(*((void *)&v89 + 1) + 8 * v43);
        objc_super v45 = [v44 serviceType];
        int v46 = [v45 isEqualToString:@"0000026A-0000-1000-8000-0026BB765291"];

        if (v46)
        {
          uint64_t v82 = v43;
          long long v87 = 0u;
          long long v88 = 0u;
          long long v85 = 0u;
          long long v86 = 0u;
          id v47 = v28;
          uint64_t v48 = [v47 countByEnumeratingWithState:&v85 objects:v101 count:16];
          if (v48)
          {
            uint64_t v49 = v48;
            uint64_t v50 = *(void *)v86;
            do
            {
              for (uint64_t i = 0; i != v49; ++i)
              {
                if (*(void *)v86 != v50) {
                  objc_enumerationMutation(v47);
                }
                id v52 = *(void **)(*((void *)&v85 + 1) + 8 * i);
                uint64_t v53 = [v52 serviceType];
                if ([v53 isEqualToString:@"0000026A-0000-1000-8000-0026BB765291"])
                {
                  uint64_t v54 = [v52 instanceID];
                  __int16 v55 = [v44 instanceID];
                  char v56 = [v54 isEqual:v55];

                  if (v56)
                  {

                    goto LABEL_59;
                  }
                }
                else
                {
                }
              }
              uint64_t v49 = [v47 countByEnumeratingWithState:&v85 objects:v101 count:16];
            }
            while (v49);
          }

          [v47 addObject:v44];
LABEL_59:
          uint64_t v42 = v77;
          objc_super v28 = v78;
          uint64_t v41 = v79;
          uint64_t v43 = v82;
        }
        ++v43;
      }
      while (v43 != v41);
      uint64_t v41 = [v80 countByEnumeratingWithState:&v89 objects:v102 count:16];
    }
    while (v41);
  }

  [obj addObjectsFromArray:v28];
  id v7 = [[HMDSiriEndpointProfile alloc] initWithSiriEndpointServices:obj];
  __int16 v57 = v84;
  uint64_t v58 = [(HMDHAPAccessory *)v84 computeSiriEndpointCertification];
  switch(v58)
  {
    case 3:
      double v59 = (void *)MEMORY[0x1D9452090]();
      id v64 = v84;
      __int16 v61 = HMFGetOSLogHandle();
      if (!os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_74;
      }
      __int16 v62 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v105 = v62;
      uint64_t v63 = "%{public}@Allowing Siri Endpoint Profile creation because the force allow pref is on";
LABEL_73:
      _os_log_impl(&dword_1D49D5000, v61, OS_LOG_TYPE_DEFAULT, v63, buf, 0xCu);

      goto LABEL_74;
    case 2:
      double v59 = (void *)MEMORY[0x1D9452090]();
      __int16 v65 = v84;
      __int16 v61 = HMFGetOSLogHandle();
      if (!os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_74;
      }
      __int16 v62 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v105 = v62;
      uint64_t v63 = "%{public}@Allowing Siri Endpoint Profile creation because the extended auth feature flag is off";
      goto LABEL_73;
    case 1:
      double v59 = (void *)MEMORY[0x1D9452090]();
      __int16 v60 = v84;
      __int16 v61 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v62 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        uint64_t v105 = v62;
        uint64_t v63 = "%{public}@Allowing Siri Endpoint Profile creation because the accessory supports HW auth with Enhanced Auth";
        goto LABEL_73;
      }
LABEL_74:

      __int16 v57 = v84;
      break;
  }
  __int16 v66 = (void *)MEMORY[0x1D9452090]();
  uint64_t v67 = v57;
  uint64_t v68 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v68, OS_LOG_TYPE_INFO))
  {
    uint64_t v69 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    uint64_t v105 = v69;
    __int16 v106 = 2112;
    uint64_t v107 = v7;
    _os_log_impl(&dword_1D49D5000, v68, OS_LOG_TYPE_INFO, "%{public}@Adding new Siri Endpoint profile: %@", buf, 0x16u);
  }
  [(HMDAccessory *)v67 addAccessoryProfile:v7];
  uint64_t v70 = [(HMDAccessory *)v67 msgDispatcher];
  [(HMDAccessoryProfile *)v7 configureWithMessageDispatcher:v70 configurationTracker:0];

  uint64_t v71 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v71 postNotificationName:@"HMDSiriEndpointProfileAddedNotification" object:v67 userInfo:0];

  [(HMDHAPAccessory *)v67 setDefaultPreferredMediaUserIfNeeded];
  id v25 = [(HMDAccessory *)v67 home];
  uint64_t v72 = [v25 logEventSubmitter];
  id v73 = [v25 dailyScheduler];
  [(HMDHAPAccessory *)v67 configureSiriEndpointProfileMetricsDispatcherWithFactory:v67 logEventSubmitter:v72 dailyScheduler:v73];

  id v4 = v76;
  BOOL v10 = 1;
LABEL_78:

LABEL_79:
LABEL_80:

LABEL_81:
  return v10;
}

- (BOOL)hasSiriSettingsService
{
  id v2 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000133-0000-1000-8000-0026BB765291"];
  BOOL v3 = v2 != 0;

  return v3;
}

- (BOOL)supportsSiriEndpoint
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  BOOL v3 = [(HMDHAPAccessory *)self hasSiriEndpointService];
  int64_t v4 = [(HMDHAPAccessory *)self computeSiriEndpointCertification];
  BOOL v5 = (unint64_t)(v4 - 7) < 0xFFFFFFFFFFFFFFFDLL && v3;
  if ((unint64_t)(v4 - 7) >= 0xFFFFFFFFFFFFFFFDLL && v3)
  {
    switch(v4)
    {
      case 6:
        id v7 = (void *)MEMORY[0x1D9452090](v5);
        uint64_t v12 = self;
        uint64_t v9 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v10 = HMFGetLogIdentifier();
          int v15 = 138543362;
          uint64_t v16 = v10;
          uint64_t v11 = "%{public}@We don't support Siri Endpoints because the accessory doesn't support HW Auth IC with Enhanced Auth";
          goto LABEL_17;
        }
        break;
      case 5:
        id v7 = (void *)MEMORY[0x1D9452090](v5);
        uint64_t v13 = self;
        uint64_t v9 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v10 = HMFGetLogIdentifier();
          int v15 = 138543362;
          uint64_t v16 = v10;
          uint64_t v11 = "%{public}@We don't support Siri Endpoints because we aren't using hardware auth";
          goto LABEL_17;
        }
        break;
      case 4:
        id v7 = (void *)MEMORY[0x1D9452090](v5);
        uint64_t v8 = self;
        uint64_t v9 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v10 = HMFGetLogIdentifier();
          int v15 = 138543362;
          uint64_t v16 = v10;
          uint64_t v11 = "%{public}@We don't support Siri Endpoints because the accessory isn't certified";
LABEL_17:
          _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v15, 0xCu);
        }
        break;
      default:
LABEL_19:
        LOBYTE(v5) = 0;
        return v5;
    }

    goto LABEL_19;
  }
  return v5;
}

- (BOOL)isCertifiedForSiriEndpoint
{
  return (unint64_t)([(HMDHAPAccessory *)self computeSiriEndpointCertification]- 7) < 0xFFFFFFFFFFFFFFFDLL;
}

- (int64_t)computeSiriEndpointCertification
{
  BOOL v3 = [MEMORY[0x1E4F65530] sharedPreferences];
  int64_t v4 = [v3 preferenceForKey:@"forceAllowSiriEndpoints"];
  char v5 = [v4 BOOLValue];

  if (v5) {
    return 3;
  }
  if ([(HMDHAPAccessory *)self certificationStatus] != 2) {
    return 4;
  }
  unint64_t v7 = [(HMDHAPAccessory *)self enhancedAuthMethod];
  if (v7 > 6) {
    return 2;
  }
  else {
    return qword_1D54D4038[v7];
  }
}

- (HMDLightProfile)lightProfileWithNaturalLighting
{
  id v2 = [(HMDHAPAccessory *)self lightProfiles];
  BOOL v3 = objc_msgSend(v2, "na_firstObjectPassingTest:", &__block_literal_global_6_128850);

  return (HMDLightProfile *)v3;
}

uint64_t __57__HMDHAPAccessory_Light__lightProfileWithNaturalLighting__block_invoke(uint64_t a1, void *a2)
{
  id v2 = [a2 settings];
  uint64_t v3 = [v2 supportedFeatures] & 1;

  return v3;
}

- (void)updateBridgedAccessoryLightProfilesSettings
{
  id v2 = self;
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if ([(HMDHAPAccessory *)self isPrimary])
  {
    uint64_t v3 = [(HMDHAPAccessory *)v2 identifiersForBridgedAccessories];
    uint64_t v4 = [v3 count];

    if (v4)
    {
      char v5 = [(HMDAccessory *)v2 home];
      uint64_t v6 = [MEMORY[0x1E4F1CA80] set];
      long long v29 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      unint64_t v7 = [(HMDHAPAccessory *)v2 identifiersForBridgedAccessories];
      uint64_t v28 = [v7 countByEnumeratingWithState:&v29 objects:v37 count:16];
      if (v28)
      {
        uint64_t v9 = *(void *)v30;
        *(void *)&long long v8 = 138543618;
        long long v25 = v8;
        char v26 = v7;
        uint64_t v27 = *(void *)v30;
        do
        {
          for (uint64_t i = 0; i != v28; ++i)
          {
            if (*(void *)v30 != v9) {
              objc_enumerationMutation(v7);
            }
            uint64_t v11 = *(void *)(*((void *)&v29 + 1) + 8 * i);
            uint64_t v12 = objc_msgSend(v5, "accessoryWithUUID:", v11, v25);
            objc_opt_class();
            if (objc_opt_isKindOfClass()) {
              uint64_t v13 = v12;
            }
            else {
              uint64_t v13 = 0;
            }
            id v14 = v13;

            if (v14)
            {
              int v15 = [v14 lightProfiles];
              uint64_t v16 = objc_msgSend(v15, "na_filter:", &__block_literal_global_128855);

              uint64_t v17 = [v16 allObjects];
              [v6 addObjectsFromArray:v17];
            }
            else
            {
              __int16 v18 = (void *)MEMORY[0x1D9452090]();
              uint64_t v19 = v2;
              uint64_t v20 = HMFGetOSLogHandle();
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              {
                HMFGetLogIdentifier();
                int v21 = v6;
                uint64_t v22 = v5;
                v24 = int v23 = v2;
                *(_DWORD *)buf = v25;
                char v34 = v24;
                __int16 v35 = 2112;
                uint64_t v36 = v11;
                _os_log_impl(&dword_1D49D5000, v20, OS_LOG_TYPE_ERROR, "%{public}@Cannot find hap accessory with uuid: %@", buf, 0x16u);

                id v2 = v23;
                char v5 = v22;
                uint64_t v6 = v21;
                unint64_t v7 = v26;
              }

              uint64_t v9 = v27;
            }
          }
          uint64_t v28 = [v7 countByEnumeratingWithState:&v29 objects:v37 count:16];
        }
        while (v28);
      }

      [v5 updateLightProfilesSettings:v6];
    }
  }
}

BOOL __69__HMDHAPAccessory_Light__updateBridgedAccessoryLightProfilesSettings__block_invoke(uint64_t a1, void *a2)
{
  id v2 = [a2 notificationEnabledCharacteristics];
  BOOL v3 = [v2 count] != 0;

  return v3;
}

- (BOOL)_handleUpdatedServicesForLightProfiles:(id)a3
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  char v5 = (void *)MEMORY[0x1D9452090]();
  uint64_t v6 = self;
  unint64_t v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    long long v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    __int16 v62 = v8;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_DEBUG, "%{public}@Handling services update for light profiles", buf, 0xCu);
  }
  uint64_t v9 = [(HMDHAPAccessory *)v6 lightProfiles];
  BOOL v10 = (void *)[v9 mutableCopy];

  uint64_t v11 = [(HMDHAPAccessory *)v6 lightProfiles];
  objc_super v45 = (void *)[v11 mutableCopy];

  char v44 = [MEMORY[0x1E4F1CA80] set];
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  id obj = v4;
  uint64_t v12 = [obj countByEnumeratingWithState:&v56 objects:v66 count:16];
  if (v12)
  {
    uint64_t v13 = v12;
    uint64_t v14 = *(void *)v57;
    uint64_t v15 = *MEMORY[0x1E4F2DE78];
    do
    {
      for (uint64_t i = 0; i != v13; ++i)
      {
        if (*(void *)v57 != v14) {
          objc_enumerationMutation(obj);
        }
        uint64_t v17 = *(void **)(*((void *)&v56 + 1) + 8 * i);
        __int16 v18 = [v17 type];
        int v19 = [v18 isEqual:v15];

        if (v19)
        {
          uint64_t v20 = [HMDLightProfile alloc];
          int v21 = [(HMDAccessory *)v6 workQueue];
          uint64_t v22 = [(HMDLightProfile *)v20 initWithWorkQueue:v21 lightService:v17 accessory:v6];

          if ([v45 containsObject:v22]) {
            [v10 removeObject:v22];
          }
          else {
            [v44 addObject:v22];
          }
        }
      }
      uint64_t v13 = [obj countByEnumeratingWithState:&v56 objects:v66 count:16];
    }
    while (v13);
  }

  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  id v47 = v10;
  uint64_t v23 = [v47 countByEnumeratingWithState:&v52 objects:v65 count:16];
  if (v23)
  {
    uint64_t v24 = v23;
    uint64_t v25 = *(void *)v53;
    do
    {
      for (uint64_t j = 0; j != v24; ++j)
      {
        if (*(void *)v53 != v25) {
          objc_enumerationMutation(v47);
        }
        uint64_t v27 = *(void *)(*((void *)&v52 + 1) + 8 * j);
        uint64_t v28 = (void *)MEMORY[0x1D9452090]();
        long long v29 = v6;
        long long v30 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
        {
          long long v31 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          __int16 v62 = v31;
          __int16 v63 = 2112;
          uint64_t v64 = v27;
          _os_log_impl(&dword_1D49D5000, v30, OS_LOG_TYPE_INFO, "%{public}@Removing light profile: %@", buf, 0x16u);
        }
        [(HMDAccessory *)v29 removeAccessoryProfile:v27];
      }
      uint64_t v24 = [v47 countByEnumeratingWithState:&v52 objects:v65 count:16];
    }
    while (v24);
  }

  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  id v32 = v44;
  uint64_t v33 = [v32 countByEnumeratingWithState:&v48 objects:v60 count:16];
  if (v33)
  {
    uint64_t v34 = v33;
    uint64_t v35 = *(void *)v49;
    do
    {
      for (uint64_t k = 0; k != v34; ++k)
      {
        if (*(void *)v49 != v35) {
          objc_enumerationMutation(v32);
        }
        uint64_t v37 = *(void *)(*((void *)&v48 + 1) + 8 * k);
        uint64_t v38 = (void *)MEMORY[0x1D9452090]();
        long long v39 = v6;
        uint64_t v40 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
        {
          uint64_t v41 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543618;
          __int16 v62 = v41;
          __int16 v63 = 2112;
          uint64_t v64 = v37;
          _os_log_impl(&dword_1D49D5000, v40, OS_LOG_TYPE_INFO, "%{public}@Adding light profile: %@", buf, 0x16u);
        }
        [(HMDAccessory *)v39 addAccessoryProfile:v37];
      }
      uint64_t v34 = [v32 countByEnumeratingWithState:&v48 objects:v60 count:16];
    }
    while (v34);
  }

  if ([v47 count]) {
    BOOL v42 = 1;
  }
  else {
    BOOL v42 = [v32 count] != 0;
  }

  return v42;
}

- (void)updateCameraProfileNotificationSettings:(id)a3
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  char v5 = [(HMDHAPAccessory *)self cameraProfileNotificationSettings];
  char v6 = HMFEqualObjects();

  if ((v6 & 1) == 0)
  {
    unint64_t v7 = (void *)MEMORY[0x1D9452090]();
    long long v8 = self;
    uint64_t v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      BOOL v10 = HMFGetLogIdentifier();
      uint64_t v11 = [(HMDHAPAccessory *)v8 cameraProfileNotificationSettings];
      int v13 = 138543874;
      uint64_t v14 = v10;
      __int16 v15 = 2112;
      uint64_t v16 = v11;
      __int16 v17 = 2112;
      id v18 = v4;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Updating camera profile notification settings from %@ -> %@", (uint8_t *)&v13, 0x20u);
    }
    [(HMDHAPAccessory *)v8 setCameraProfileNotificationSettings:v4];
    uint64_t v12 = [(HMDAccessory *)v8 home];
    [v12 saveToCurrentAccountWithReason:@"HMDHAPAccessoryUpdateCameraProfileNotificationSettingsReason"];
  }
}

- (id)cameraProfileNotificationSettingsFromCoder:(id)a3
{
  id v3 = a3;
  id v4 = [v3 decodeObjectOfClass:objc_opt_class() forKey:@"HAP.cpns"];

  return v4;
}

- (BOOL)_handleUpdatedServicesForCameraProfiles:(id)a3
{
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  char v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  char v6 = [(HMDAccessory *)self home];
  if (!v6)
  {
    uint64_t v35 = (void *)MEMORY[0x1D9452090]();
    uint64_t v36 = self;
    uint64_t v37 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
    {
      uint64_t v38 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      long long v94 = v38;
      _os_log_impl(&dword_1D49D5000, v37, OS_LOG_TYPE_INFO, "%{public}@Cannot create camera profile due to updated services: home is nil", buf, 0xCu);
    }
    LOBYTE(v35) = 0;
    goto LABEL_70;
  }
  unint64_t v7 = [(HMDAccessory *)self msgDispatcher];
  if (!v7)
  {
    uint64_t v35 = (void *)MEMORY[0x1D9452090]();
    long long v39 = self;
    uint64_t v40 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
    {
      uint64_t v41 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      long long v94 = v41;
      _os_log_impl(&dword_1D49D5000, v40, OS_LOG_TYPE_INFO, "%{public}@Cannot create camera profile due to updated services: message dispatcher is nil", buf, 0xCu);
    }
    LOBYTE(v35) = 0;
    goto LABEL_69;
  }
  id v69 = v4;
  uint64_t v71 = v6;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  id v8 = v4;
  char v81 = self;
  uint64_t v83 = [v8 countByEnumeratingWithState:&v88 objects:v99 count:16];
  uint64_t v72 = v7;
  if (!v83)
  {
    BOOL v10 = 0;
    uint64_t v34 = 0;
    goto LABEL_37;
  }
  id obj = v8;
  char v9 = 0;
  BOOL v10 = 0;
  uint64_t v82 = *(void *)v89;
  uint64_t v11 = *MEMORY[0x1E4F2DDE8];
  uint64_t v79 = *MEMORY[0x1E4F2DDD8];
  uint64_t v75 = *MEMORY[0x1E4F2DEC0];
  uint64_t v76 = *MEMORY[0x1E4F2DE90];
  uint64_t v73 = *MEMORY[0x1E4F2DDF0];
  do
  {
    uint64_t v12 = 0;
    do
    {
      if (*(void *)v89 != v82) {
        objc_enumerationMutation(obj);
      }
      int v13 = *(HMDCameraProfile **)(*((void *)&v88 + 1) + 8 * v12);
      uint64_t v14 = (void *)MEMORY[0x1D9452090]();
      __int16 v15 = self;
      uint64_t v16 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        HMFGetLogIdentifier();
        id v18 = v17 = v10;
        uint64_t v19 = [(HMDCameraProfile *)v13 serviceType];
        *(_DWORD *)buf = 138543874;
        long long v94 = v18;
        __int16 v95 = 2112;
        long long v96 = v13;
        __int16 v97 = 2112;
        long long v98 = v19;
        _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_DEBUG, "%{public}@Found service: %@, %@", buf, 0x20u);

        BOOL v10 = v17;
        self = v81;
      }

      uint64_t v20 = [(HMDCameraProfile *)v13 serviceType];
      if (([v20 isEqualToString:v11] & 1) == 0)
      {
        int v21 = [(HMDCameraProfile *)v13 serviceType];
        if (([v21 isEqualToString:v79] & 1) == 0)
        {
          uint64_t v22 = [(HMDCameraProfile *)v13 serviceType];
          if (([v22 isEqualToString:v76] & 1) == 0)
          {
            uint64_t v77 = v10;
            uint64_t v23 = [(HMDCameraProfile *)v13 serviceType];
            if (([v23 isEqualToString:v75] & 1) == 0)
            {
              char v26 = [(HMDCameraProfile *)v13 serviceType];
              char v74 = [v26 isEqualToString:v73];

              self = v81;
              BOOL v10 = v77;
              if ((v74 & 1) == 0) {
                goto LABEL_21;
              }
              goto LABEL_18;
            }

            BOOL v10 = v77;
          }
        }
      }

LABEL_18:
      if (!v10)
      {
        BOOL v10 = [MEMORY[0x1E4F1CA48] arrayWithCapacity:4];
      }
      -[HMDCameraProfile addObject:](v10, "addObject:", v13, v69);
LABEL_21:
      uint64_t v24 = [(HMDCameraProfile *)v13 serviceType];
      char v25 = [v24 isEqualToString:v11];

      v9 |= v25;
      ++v12;
    }
    while (v83 != v12);
    uint64_t v27 = [obj countByEnumeratingWithState:&v88 objects:v99 count:16];
    uint64_t v83 = v27;
  }
  while (v27);

  if (v9)
  {
    uint64_t v28 = (void *)MEMORY[0x1D9452090]();
    long long v29 = v15;
    long long v30 = HMFGetOSLogHandle();
    unint64_t v7 = v72;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      long long v31 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      long long v94 = v31;
      __int16 v95 = 2112;
      long long v96 = v10;
      _os_log_impl(&dword_1D49D5000, v30, OS_LOG_TYPE_DEBUG, "%{public}@Creating camera profile with services: %@", buf, 0x16u);
    }
    id v32 = [HMDCameraProfile alloc];
    id v8 = [(HMDAccessory *)v29 workQueue];
    uint64_t v33 = [(HMDHAPAccessory *)v29 cameraProfileSettingsManager];
    uint64_t v34 = [(HMDCameraProfile *)v32 initWithAccessory:v29 services:v10 msgDispatcher:v72 workQueue:v8 home:v71 settingsManager:v33];

LABEL_37:
    long long v78 = v10;
  }
  else
  {
    long long v78 = v10;
    uint64_t v34 = 0;
    unint64_t v7 = v72;
  }
  long long v86 = 0u;
  long long v87 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  BOOL v42 = [(HMDAccessory *)self accessoryProfiles];
  uint64_t v43 = [v42 countByEnumeratingWithState:&v84 objects:v92 count:16];
  if (v43)
  {
    uint64_t v44 = v43;
    uint64_t v45 = *(void *)v85;
    while (2)
    {
      for (uint64_t i = 0; i != v44; ++i)
      {
        if (*(void *)v85 != v45) {
          objc_enumerationMutation(v42);
        }
        id v47 = (HMDCameraProfile *)*(id *)(*((void *)&v84 + 1) + 8 * i);
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          long long v48 = v47;
        }
        else {
          long long v48 = 0;
        }
        long long v49 = v48;

        if (v49)
        {

          BOOL v51 = v34 != 0;
          int v50 = 1;
          goto LABEL_53;
        }
      }
      uint64_t v44 = [v42 countByEnumeratingWithState:&v84 objects:v92 count:16];
      if (v44) {
        continue;
      }
      break;
    }
  }

  if (v34)
  {
    int v50 = 0;
    id v47 = 0;
    BOOL v51 = 1;
LABEL_53:
    long long v52 = v78;
    long long v53 = (void *)MEMORY[0x1D9452090]();
    long long v54 = v81;
    long long v55 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
    {
      long long v56 = HMFGetLogIdentifier();
      long long v57 = [(HMDAccessoryProfile *)v47 uniqueIdentifier];
      long long v58 = [(HMDAccessoryProfile *)v34 uniqueIdentifier];
      *(_DWORD *)buf = 138543874;
      long long v94 = v56;
      __int16 v95 = 2112;
      long long v96 = v57;
      __int16 v97 = 2112;
      long long v98 = v58;
      _os_log_impl(&dword_1D49D5000, v55, OS_LOG_TYPE_DEBUG, "%{public}@Current CameraProfile %@, New CameraProfile %@", buf, 0x20u);

      long long v52 = v78;
    }

    uint64_t v59 = HMFEqualObjects();
    if (v59)
    {
      LOBYTE(v35) = 0;
      unint64_t v7 = v72;
      goto LABEL_68;
    }
    if (v51)
    {
      __int16 v60 = (void *)MEMORY[0x1D9452090]();
      __int16 v61 = v54;
      __int16 v62 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
      {
        __int16 v63 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        long long v94 = v63;
        __int16 v95 = 2112;
        long long v96 = v34;
        _os_log_impl(&dword_1D49D5000, v62, OS_LOG_TYPE_INFO, "%{public}@Adding camera profile: %@", buf, 0x16u);
      }
      [(HMDCameraProfile *)v34 setUp];
      uint64_t v59 = [(HMDAccessory *)v61 addAccessoryProfile:v34];
      unint64_t v7 = v72;
      long long v52 = v78;
      if ((v50 & 1) == 0)
      {
LABEL_66:
        LOBYTE(v35) = 1;
        goto LABEL_68;
      }
    }
    else
    {
      unint64_t v7 = v72;
      if (!v50) {
        goto LABEL_66;
      }
    }
    uint64_t v64 = (void *)MEMORY[0x1D9452090](v59);
    __int16 v65 = v54;
    __int16 v66 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_INFO))
    {
      uint64_t v67 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      long long v94 = v67;
      __int16 v95 = 2112;
      long long v96 = v47;
      _os_log_impl(&dword_1D49D5000, v66, OS_LOG_TYPE_INFO, "%{public}@Removing camera profile: %@", buf, 0x16u);
    }
    [(HMDCameraProfile *)v47 tearDownWithReplacementCameraProfile:v34];
    [(HMDAccessory *)v65 removeAccessoryProfile:v47];
    goto LABEL_66;
  }
  id v47 = 0;
  LODWORD(v35) = HMFEqualObjects() ^ 1;
  long long v52 = v78;
LABEL_68:

  id v4 = v70;
  char v6 = v71;
LABEL_69:

LABEL_70:
  return (char)v35;
}

- (BOOL)isCameraRecordingFeatureSupported
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id v2 = [(HMDHAPAccessory *)self cameraProfiles];
  uint64_t v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v8;
    while (2)
    {
      for (uint64_t i = 0; i != v3; ++i)
      {
        if (*(void *)v8 != v4) {
          objc_enumerationMutation(v2);
        }
        if ([*(id *)(*((void *)&v7 + 1) + 8 * i) isCameraRecordingFeatureSupported])
        {
          LOBYTE(v3) = 1;
          goto LABEL_11;
        }
      }
      uint64_t v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
      if (v3) {
        continue;
      }
      break;
    }
  }
LABEL_11:

  return v3;
}

- (void)_updateSiriAudioFormat:(id)a3
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  char v5 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000127-0000-1000-8000-0026BB765291"];
  char v6 = v5;
  if (v5)
  {
    long long v7 = [v5 findCharacteristicWithType:*MEMORY[0x1E4F2CF98]];
    if (v7)
    {
      id v37 = 0;
      uint64_t v34 = (void *)[objc_alloc(MEMORY[0x1E4F5BE10]) initWithConfiguration:v4];
      long long v8 = [v34 serializeWithError:&v37];
      id v9 = v37;
      if (v9 || !v8)
      {
        context = (void *)MEMORY[0x1D9452090]();
        uint64_t v27 = self;
        uint64_t v28 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          id v32 = HMFGetLogIdentifier();
          long long v29 = [(HMDHAPAccessory *)v27 name];
          long long v30 = [(HMDAccessory *)v27 uuid];
          long long v31 = [v30 UUIDString];
          *(_DWORD *)locatiouint64_t n = 138544130;
          *(void *)&id location[4] = v32;
          __int16 v40 = 2112;
          id v41 = v9;
          __int16 v42 = 2112;
          uint64_t v43 = v29;
          __int16 v44 = 2112;
          uint64_t v45 = v31;
          _os_log_impl(&dword_1D49D5000, v28, OS_LOG_TYPE_INFO, "%{public}@[Updating Selected Audio] Failed to serialize charactersitic value; error=%@ (%@/%@)",
            location,
            0x2Au);
        }
      }
      else
      {
        long long v10 = +[HMDCharacteristicWriteRequest writeRequestWithCharacteristic:v7 value:v8 authorizationData:0 type:0];
        uint64_t v38 = v10;
        uint64_t v11 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v38 count:1];
        objc_initWeak((id *)location, self);
        uint64_t v12 = [(HMDAccessory *)self workQueue];
        v35[0] = MEMORY[0x1E4F143A8];
        v35[1] = 3221225472;
        v35[2] = __48__HMDHAPAccessory_Siri___updateSiriAudioFormat___block_invoke;
        v35[3] = &unk_1E6A19160;
        objc_copyWeak(&v36, (id *)location);
        [(HMDHAPAccessory *)self writeCharacteristicValues:v11 source:7 queue:v12 completionHandler:v35];

        objc_destroyWeak(&v36);
        objc_destroyWeak((id *)location);
      }
    }
    else
    {
      uint64_t v20 = (void *)MEMORY[0x1D9452090]();
      int v21 = self;
      uint64_t v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        uint64_t v23 = HMFGetLogIdentifier();
        uint64_t v24 = [(HMDHAPAccessory *)v21 name];
        char v25 = [(HMDAccessory *)v21 uuid];
        char v26 = [v25 UUIDString];
        *(_DWORD *)locatiouint64_t n = 138543874;
        *(void *)&id location[4] = v23;
        __int16 v40 = 2112;
        id v41 = v24;
        __int16 v42 = 2112;
        uint64_t v43 = v26;
        _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_INFO, "%{public}@[Updating Selected Audio] No selected audio configuration (%@/%@)", location, 0x20u);
      }
    }
  }
  else
  {
    int v13 = (void *)MEMORY[0x1D9452090]();
    uint64_t v14 = self;
    __int16 v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      uint64_t v16 = HMFGetLogIdentifier();
      __int16 v17 = [(HMDHAPAccessory *)v14 name];
      id v18 = [(HMDAccessory *)v14 uuid];
      uint64_t v19 = [v18 UUIDString];
      *(_DWORD *)locatiouint64_t n = 138543874;
      *(void *)&id location[4] = v16;
      __int16 v40 = 2112;
      id v41 = v17;
      __int16 v42 = 2112;
      uint64_t v43 = v19;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@[Updating Selected Audio] No Audio services available (%@/%@)", location, 0x20u);
    }
  }
}

void __48__HMDHAPAccessory_Siri___updateSiriAudioFormat___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    if (v3 && [v3 count])
    {
      char v5 = [v3 objectAtIndex:0];
      char v6 = [v5 error];

      long long v7 = (void *)MEMORY[0x1D9452090]();
      id v8 = WeakRetained;
      id v9 = HMFGetOSLogHandle();
      long long v10 = v9;
      if (v6)
      {
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          uint64_t v11 = HMFGetLogIdentifier();
          uint64_t v12 = [v5 error];
          int v13 = [v8 name];
          [v8 uuid];
          uint64_t v14 = v26 = v7;
          __int16 v15 = [v14 UUIDString];
          *(_DWORD *)buf = 138544130;
          uint64_t v28 = v11;
          __int16 v29 = 2112;
          long long v30 = v12;
          __int16 v31 = 2112;
          id v32 = v13;
          __int16 v33 = 2112;
          uint64_t v34 = v15;
          _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_ERROR, "%{public}@[Updating Selected Audio] Failed to update characteristic value; error=%@ (%@/%@)",
            buf,
            0x2Au);

          long long v7 = v26;
LABEL_12:
        }
      }
      else if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        uint64_t v11 = HMFGetLogIdentifier();
        uint64_t v23 = [v8 name];
        uint64_t v24 = [v8 uuid];
        char v25 = [v24 UUIDString];
        *(_DWORD *)buf = 138543874;
        uint64_t v28 = v11;
        __int16 v29 = 2112;
        long long v30 = v23;
        __int16 v31 = 2112;
        id v32 = v25;
        _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, "%{public}@[Updating Selected Audio] Selected audio configuration set successfully (%@/%@)", buf, 0x20u);

        goto LABEL_12;
      }

      goto LABEL_14;
    }
    uint64_t v16 = (void *)MEMORY[0x1D9452090]();
    id v17 = WeakRetained;
    id v18 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = HMFGetLogIdentifier();
      uint64_t v20 = [v17 name];
      int v21 = [v17 uuid];
      uint64_t v22 = [v21 UUIDString];
      *(_DWORD *)buf = 138543874;
      uint64_t v28 = v19;
      __int16 v29 = 2112;
      long long v30 = v20;
      __int16 v31 = 2112;
      id v32 = v22;
      _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_ERROR, "%{public}@[Updating Selected Audio] Failed to update characteristic value; no response (%@/%@)",
        buf,
        0x20u);
    }
  }
LABEL_14:
}

- (void)setSelectedSiriAudioConfiguration:(id)a3
{
  id v4 = a3;
  char v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __59__HMDHAPAccessory_Siri__setSelectedSiriAudioConfiguration___block_invoke;
  v7[3] = &unk_1E6A197C8;
  id v8 = v4;
  id v9 = self;
  id v6 = v4;
  dispatch_async(v5, v7);
}

uint64_t __59__HMDHAPAccessory_Siri__setSelectedSiriAudioConfiguration___block_invoke(uint64_t result)
{
  if (*(void *)(result + 32)) {
    return objc_msgSend(*(id *)(result + 40), "_updateSiriAudioFormat:");
  }
  return result;
}

- (BOOL)_resolveSupportedSiriInputType:(id)a3
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  char v5 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000133-0000-1000-8000-0026BB765291"];
  id v6 = v5;
  if (v5)
  {
    long long v7 = [v5 findCharacteristicWithType:@"00000132-0000-1000-8000-0026BB765291"];
    id v8 = v7;
    if (v7)
    {
      id v9 = [v7 value];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        long long v10 = v9;
      }
      else {
        long long v10 = 0;
      }
      id v11 = v10;

      BOOL v12 = v11 != 0;
      if (v11)
      {
        objc_msgSend(v4, "setSiriInputType:", objc_msgSend(v11, "integerValue"));
      }
      else
      {
        uint64_t v27 = (void *)MEMORY[0x1D9452090]();
        uint64_t v28 = self;
        __int16 v29 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
        {
          uint64_t v34 = HMFGetLogIdentifier();
          long long v30 = [(HMDHAPAccessory *)v28 name];
          [(HMDAccessory *)v28 uuid];
          __int16 v31 = v35 = v27;
          [v31 UUIDString];
          *(_DWORD *)buf = 138543874;
          id v37 = v34;
          __int16 v38 = 2112;
          long long v39 = v30;
          uint64_t v41 = v40 = 2112;
          id v32 = (void *)v41;
          _os_log_impl(&dword_1D49D5000, v29, OS_LOG_TYPE_INFO, "%{public}@Unable to parse Siri Input Type (%@/%@)", buf, 0x20u);

          uint64_t v27 = v35;
        }
      }
    }
    else
    {
      uint64_t v20 = (void *)MEMORY[0x1D9452090]();
      int v21 = self;
      uint64_t v22 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        uint64_t v23 = HMFGetLogIdentifier();
        uint64_t v24 = [(HMDHAPAccessory *)v21 name];
        char v25 = [(HMDAccessory *)v21 uuid];
        char v26 = [v25 UUIDString];
        *(_DWORD *)buf = 138543874;
        id v37 = v23;
        __int16 v38 = 2112;
        long long v39 = v24;
        __int16 v40 = 2112;
        uint64_t v41 = (uint64_t)v26;
        _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_INFO, "%{public}@No Siri Input Type (%@/%@)", buf, 0x20u);
      }
      BOOL v12 = 0;
    }
  }
  else
  {
    int v13 = (void *)MEMORY[0x1D9452090]();
    uint64_t v14 = self;
    __int16 v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      uint64_t v16 = HMFGetLogIdentifier();
      id v17 = [(HMDHAPAccessory *)v14 name];
      id v18 = [(HMDAccessory *)v14 uuid];
      uint64_t v19 = [v18 UUIDString];
      *(_DWORD *)buf = 138543874;
      id v37 = v16;
      __int16 v38 = 2112;
      long long v39 = v17;
      __int16 v40 = 2112;
      uint64_t v41 = (uint64_t)v19;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@No Siri services available (%@/%@)", buf, 0x20u);
    }
    BOOL v12 = 0;
  }

  return v12;
}

- (BOOL)_resolveAudioAbility:(id)a3
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  char v5 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000127-0000-1000-8000-0026BB765291"];
  id v6 = v5;
  if (v5)
  {
    long long v7 = [v5 findCharacteristicWithType:*MEMORY[0x1E4F2CFC0]];
    if (v7)
    {
      id v8 = [v6 findCharacteristicWithType:*MEMORY[0x1E4F2CF98]];
      if (v8)
      {
        id v9 = (void *)MEMORY[0x1E4F5BE28];
        long long v10 = [v7 value];
        id v63 = 0;
        id v11 = [v9 parsedFromData:v10 error:&v63];
        id v12 = v63;

        if (v12 || !v11)
        {
          uint64_t v41 = (void *)MEMORY[0x1D9452090]();
          uint64_t v42 = self;
          uint64_t v43 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
          {
            __int16 v44 = HMFGetLogIdentifier();
            [(HMDHAPAccessory *)v42 name];
            uint64_t v45 = v55 = v8;
            [(HMDAccessory *)v42 uuid];
            v46 = long long v57 = v41;
            [v46 UUIDString];
            id v47 = v60 = v11;
            *(_DWORD *)buf = 138543874;
            __int16 v65 = v44;
            __int16 v66 = 2112;
            uint64_t v67 = v45;
            __int16 v68 = 2112;
            id v69 = v47;
            _os_log_impl(&dword_1D49D5000, v43, OS_LOG_TYPE_INFO, "%{public}@Failed to parse supported audio configurations (%@/%@)", buf, 0x20u);

            uint64_t v41 = v57;
            id v8 = v55;

            id v11 = v60;
          }

          BOOL v17 = 0;
        }
        else
        {
          int v13 = (void *)MEMORY[0x1E4F5BE10];
          uint64_t v14 = [v8 value];
          id v62 = 0;
          __int16 v15 = [v13 parsedFromData:v14 error:&v62];
          id v12 = v62;

          if (v12) {
            BOOL v16 = 1;
          }
          else {
            BOOL v16 = v15 == 0;
          }
          BOOL v17 = !v16;
          if (v16)
          {
            __int16 v61 = v11;
            long long v48 = (void *)MEMORY[0x1D9452090]();
            long long v49 = self;
            int v50 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v50, OS_LOG_TYPE_INFO))
            {
              long long v58 = HMFGetLogIdentifier();
              long long v56 = [(HMDHAPAccessory *)v49 name];
              [(HMDAccessory *)v49 uuid];
              v51 = long long v54 = v48;
              long long v53 = [v51 UUIDString];
              *(_DWORD *)buf = 138543874;
              __int16 v65 = v58;
              __int16 v66 = 2112;
              uint64_t v67 = v56;
              __int16 v68 = 2112;
              id v69 = v53;
              _os_log_impl(&dword_1D49D5000, v50, OS_LOG_TYPE_INFO, "%{public}@Failed to parse selected audio configuration (%@/%@)", buf, 0x20u);

              long long v48 = v54;
            }

            id v11 = v61;
          }
          else
          {
            id v18 = [v11 configurations];
            [v4 setSupportedConfigurations:v18];

            uint64_t v19 = [v15 configuration];
            [v4 setSelectedConfiguration:v19];
          }
        }
      }
      else
      {
        uint64_t v34 = (void *)MEMORY[0x1D9452090]();
        uint64_t v35 = self;
        id v36 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
        {
          id v37 = HMFGetLogIdentifier();
          __int16 v38 = [(HMDHAPAccessory *)v35 name];
          long long v39 = [(HMDAccessory *)v35 uuid];
          [v39 UUIDString];
          __int16 v40 = v59 = v34;
          *(_DWORD *)buf = 138543874;
          __int16 v65 = v37;
          __int16 v66 = 2112;
          uint64_t v67 = v38;
          __int16 v68 = 2112;
          id v69 = v40;
          _os_log_impl(&dword_1D49D5000, v36, OS_LOG_TYPE_INFO, "%{public}@No selected audio configuration (%@/%@)", buf, 0x20u);

          uint64_t v34 = v59;
        }

        BOOL v17 = 0;
      }
    }
    else
    {
      uint64_t v27 = (void *)MEMORY[0x1D9452090]();
      uint64_t v28 = self;
      __int16 v29 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
      {
        long long v30 = HMFGetLogIdentifier();
        __int16 v31 = [(HMDHAPAccessory *)v28 name];
        id v32 = [(HMDAccessory *)v28 uuid];
        __int16 v33 = [v32 UUIDString];
        *(_DWORD *)buf = 138543874;
        __int16 v65 = v30;
        __int16 v66 = 2112;
        uint64_t v67 = v31;
        __int16 v68 = 2112;
        id v69 = v33;
        _os_log_impl(&dword_1D49D5000, v29, OS_LOG_TYPE_INFO, "%{public}@No supported audio configuration (%@/%@)", buf, 0x20u);
      }
      BOOL v17 = 0;
    }
  }
  else
  {
    uint64_t v20 = (void *)MEMORY[0x1D9452090]();
    int v21 = self;
    uint64_t v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      uint64_t v23 = HMFGetLogIdentifier();
      uint64_t v24 = [(HMDHAPAccessory *)v21 name];
      char v25 = [(HMDAccessory *)v21 uuid];
      char v26 = [v25 UUIDString];
      *(_DWORD *)buf = 138543874;
      __int16 v65 = v23;
      __int16 v66 = 2112;
      uint64_t v67 = v24;
      __int16 v68 = 2112;
      id v69 = v26;
      _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_INFO, "%{public}@No Audio services available (%@/%@)", buf, 0x20u);
    }
    BOOL v17 = 0;
  }

  return v17;
}

- (void)getSupportedSiriAudioConfiguration:(id)a3
{
  id v4 = a3;
  char v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __60__HMDHAPAccessory_Siri__getSupportedSiriAudioConfiguration___block_invoke;
  v7[3] = &unk_1E6A19530;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __60__HMDHAPAccessory_Siri__getSupportedSiriAudioConfiguration___block_invoke(uint64_t a1)
{
  id v2 = objc_alloc_init(HMDSupportedSiriAudioConfigurations);
  if (objc_msgSend(*(id *)(a1 + 32), "_resolveSupportedSiriInputType:")) {
    [*(id *)(a1 + 32) _resolveAudioAbility:v2];
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

- (BOOL)supportsSiri
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (![(HMDHAPAccessory *)self supportsTargetController]) {
    return 0;
  }
  if ([(HMDHAPAccessory *)self certificationStatus] != 2)
  {
    id v3 = [MEMORY[0x1E4F65530] sharedPreferences];
    id v4 = [v3 preferenceForKey:@"allowSiriForUncertifiedAccessories"];
    int v5 = [v4 BOOLValue];

    if (!v5) {
      return 0;
    }
  }
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v6 = [(HMDHAPAccessory *)self services];
  uint64_t v7 = [v6 countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    char v9 = 0;
    char v10 = 0;
    char v11 = 0;
    uint64_t v12 = *(void *)v24;
LABEL_6:
    uint64_t v13 = 0;
    while (1)
    {
      if (*(void *)v24 != v12) {
        objc_enumerationMutation(v6);
      }
      uint64_t v14 = *(void **)(*((void *)&v23 + 1) + 8 * v13);
      __int16 v15 = [v14 type];
      char v16 = [v15 isEqualToString:@"00000129-0000-1000-8000-0026BB765291"];

      if (v16)
      {
        char v9 = 1;
        if (v11) {
          goto LABEL_16;
        }
      }
      else
      {
        BOOL v17 = [v14 type];
        char v18 = [v17 isEqualToString:@"00000127-0000-1000-8000-0026BB765291"];

        if (v18)
        {
          char v10 = 1;
          if (v11) {
            goto LABEL_16;
          }
        }
        else
        {
          uint64_t v19 = [v14 type];
          char v20 = [v19 isEqualToString:@"00000133-0000-1000-8000-0026BB765291"];

          v11 |= v20;
          if (v11)
          {
LABEL_16:
            if (v10 & 1) != 0 && (v9)
            {
              BOOL v21 = 1;
              goto LABEL_23;
            }
          }
        }
      }
      if (v8 == ++v13)
      {
        uint64_t v8 = [v6 countByEnumeratingWithState:&v23 objects:v27 count:16];
        if (v8) {
          goto LABEL_6;
        }
        break;
      }
    }
  }
  BOOL v21 = 0;
LABEL_23:

  return v21;
}

- (void)_handleUpdateMediaSourceDisplayOrder:(id)a3
{
  uint64_t v115 = *MEMORY[0x1E4F143B8];
  id v63 = a3;
  id v62 = [v63 numberForKey:@"kServiceInstanceID"];
  __int16 v61 = [v63 arrayForKey:*MEMORY[0x1E4F2E1C0]];
  if (v62 && [v61 count])
  {
    __int16 v60 = [(HMDHAPAccessory *)self findService:v62];
    if (!v60
      || ([v60 serviceType],
          id v4 = objc_claimAutoreleasedReturnValue(),
          char v5 = [v4 isEqualToString:*MEMORY[0x1E4F2DEF0]],
          v4,
          (v5 & 1) == 0))
    {
      __int16 v38 = [v63 responseHandler];

      if (v38)
      {
        long long v39 = [v63 responseHandler];
        __int16 v40 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
        ((void (**)(void, void *, void))v39)[2](v39, v40, 0);
      }
      goto LABEL_64;
    }
    long long v56 = [v60 findCharacteristicWithType:@"00000136-0000-1000-8000-0026BB765291"];
    if (!v56)
    {
      uint64_t v43 = objc_msgSend(v63, "responseHandler", 0);

      if (v43)
      {
        __int16 v44 = [v63 responseHandler];
        uint64_t v45 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
        ((void (**)(void, void *, void))v44)[2](v44, v45, 0);
      }
      goto LABEL_63;
    }
    id v6 = (void *)MEMORY[0x1E4F1CA48];
    uint64_t v7 = [v60 linkedServices];
    uint64_t v8 = objc_msgSend(v6, "arrayWithCapacity:", objc_msgSend(v7, "count"));

    long long v79 = 0u;
    long long v80 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    char v9 = [v60 linkedServices];
    uint64_t v10 = [v9 countByEnumeratingWithState:&v77 objects:v87 count:16];
    if (v10)
    {
      uint64_t v11 = *(void *)v78;
      uint64_t v12 = *MEMORY[0x1E4F2DE58];
      do
      {
        for (uint64_t i = 0; i != v10; ++i)
        {
          if (*(void *)v78 != v11) {
            objc_enumerationMutation(v9);
          }
          uint64_t v14 = -[HMDHAPAccessory findService:](self, "findService:", *(void *)(*((void *)&v77 + 1) + 8 * i), v56);
          __int16 v15 = [v14 serviceType];
          int v16 = [v15 isEqualToString:v12];

          if (v16) {
            [v8 addObject:v14];
          }
        }
        uint64_t v10 = [v9 countByEnumeratingWithState:&v77 objects:v87 count:16];
      }
      while (v10);
    }

    long long v75 = 0u;
    long long v76 = 0u;
    long long v73 = 0u;
    long long v74 = 0u;
    id obj = v61;
    uint64_t v59 = [obj countByEnumeratingWithState:&v73 objects:v86 count:16];
    if (v59)
    {
      uint64_t v58 = *(void *)v74;
      while (1)
      {
        uint64_t v17 = 0;
LABEL_18:
        if (*(void *)v74 != v58) {
          objc_enumerationMutation(obj);
        }
        uint64_t v18 = *(void *)(*((void *)&v73 + 1) + 8 * v17);
        long long v69 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        long long v72 = 0u;
        id v19 = v8;
        uint64_t v20 = [v19 countByEnumeratingWithState:&v69 objects:v85 count:16];
        if (!v20) {
          break;
        }
        uint64_t v21 = *(void *)v70;
LABEL_22:
        uint64_t v22 = 0;
        while (1)
        {
          if (*(void *)v70 != v21) {
            objc_enumerationMutation(v19);
          }
          long long v23 = objc_msgSend(*(id *)(*((void *)&v69 + 1) + 8 * v22), "mediaSourceIdentifier", v56);
          char v24 = [v23 isEqualToNumber:v18];

          if (v24) {
            break;
          }
          if (v20 == ++v22)
          {
            uint64_t v20 = [v19 countByEnumeratingWithState:&v69 objects:v85 count:16];
            if (v20) {
              goto LABEL_22;
            }
            goto LABEL_47;
          }
        }

        if (++v17 != v59) {
          goto LABEL_18;
        }
        uint64_t v59 = [obj countByEnumeratingWithState:&v73 objects:v86 count:16];
        if (!v59) {
          goto LABEL_31;
        }
      }
LABEL_47:

      uint64_t v41 = [v63 responseHandler];

      if (!v41) {
        goto LABEL_62;
      }
      id v32 = [v63 responseHandler];
      uint64_t v42 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
      ((void (**)(void, void *, void))v32)[2](v32, v42, 0);
    }
    else
    {
LABEL_31:

      id v25 = obj;
      [v25 count];
      long long v114 = 0u;
      long long v113 = 0u;
      long long v112 = 0u;
      long long v111 = 0u;
      long long v110 = 0u;
      long long v109 = 0u;
      long long v108 = 0u;
      long long v107 = 0u;
      long long v106 = 0u;
      long long v105 = 0u;
      long long v104 = 0u;
      long long v103 = 0u;
      long long v102 = 0u;
      long long v101 = 0u;
      long long v99 = 0u;
      long long v100 = 0u;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v96 = 0u;
      memset(v95, 0, sizeof(v95));
      TLV8BufferInit();
      long long v83 = 0u;
      long long v84 = 0u;
      long long v81 = 0u;
      long long v82 = 0u;
      id v26 = v25;
      uint64_t v27 = [v26 countByEnumeratingWithState:&v81 objects:v94 count:16];
      if (v27)
      {
        char v28 = 0;
        uint64_t v29 = *(void *)v82;
        while (2)
        {
          for (uint64_t j = 0; j != v27; ++j)
          {
            if (*(void *)v82 != v29) {
              objc_enumerationMutation(v26);
            }
            __int16 v31 = *(void **)(*((void *)&v81 + 1) + 8 * j);
            if ((v28 & 1) != 0 && (LODWORD(v32) = TLV8BufferAppend(), v32)
              || (objc_msgSend(v31, "unsignedIntegerValue", v56), LODWORD(v32) = TLV8BufferAppendUInt64(), v32))
            {

              uint64_t v33 = TLV8BufferFree();
              goto LABEL_52;
            }
            char v28 = 1;
          }
          uint64_t v27 = [v26 countByEnumeratingWithState:&v81 objects:v94 count:16];
          if (v27) {
            continue;
          }
          break;
        }
      }

      id v32 = [MEMORY[0x1E4F1C9B8] dataWithBytes:*(void *)v95 length:*(void *)&v95[8]];
      uint64_t v33 = TLV8BufferFree();
      if (v32)
      {
        id v34 = 0;
      }
      else
      {
LABEL_52:
        uint64_t v46 = (void *)MEMORY[0x1D9452090](v33);
        id v47 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
        {
          long long v48 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543874;
          long long v89 = v48;
          __int16 v90 = 2112;
          id v91 = v26;
          __int16 v92 = 2048;
          uint64_t v93 = (int)v32;
          _os_log_impl(&dword_1D49D5000, v47, OS_LOG_TYPE_INFO, "%{public}@Failed to serialize display order %@ as TLV - status %ld", buf, 0x20u);
        }
        id v34 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
        id v32 = 0;
      }

      id obj = v34;
      if (obj)
      {
        long long v49 = (void *)MEMORY[0x1D9452090]();
        int v50 = self;
        BOOL v51 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
        {
          long long v52 = HMFGetLogIdentifier();
          *(_DWORD *)__int16 v95 = 138543874;
          *(void *)&v95[4] = v52;
          *(_WORD *)&v95[12] = 2112;
          *(void *)&v95[14] = v26;
          *(_WORD *)&v95[22] = 2112;
          *(void *)&v95[24] = obj;
          _os_log_impl(&dword_1D49D5000, v51, OS_LOG_TYPE_INFO, "%{public}@Failed to serialize request for updating display order to %@ - error %@", v95, 0x20u);
        }
        long long v53 = [v63 responseHandler];

        if (v53)
        {
          long long v54 = [v63 responseHandler];
          ((void (**)(void, id, void))v54)[2](v54, obj, 0);
        }
      }
      else
      {
        objc_initWeak((id *)v95, self);
        long long v55 = [(HMDAccessory *)self workQueue];
        v64[0] = MEMORY[0x1E4F143A8];
        v64[1] = 3221225472;
        v64[2] = __68__HMDHAPAccessory_Television___handleUpdateMediaSourceDisplayOrder___block_invoke;
        v64[3] = &unk_1E6A137D0;
        objc_copyWeak(&v68, (id *)v95);
        id v65 = v26;
        id v66 = v63;
        id v67 = v56;
        [(HMDHAPAccessory *)self writeValue:v32 toCharacteristic:v67 queue:v55 completion:v64];

        objc_destroyWeak(&v68);
        objc_destroyWeak((id *)v95);
        id obj = 0;
      }
    }

LABEL_62:
LABEL_63:

LABEL_64:
    goto LABEL_65;
  }
  uint64_t v35 = [v63 responseHandler];

  if (v35)
  {
    id v36 = [v63 responseHandler];
    id v37 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
    ((void (**)(void, void *, void))v36)[2](v36, v37, 0);
  }
LABEL_65:
}

void __68__HMDHAPAccessory_Television___handleUpdateMediaSourceDisplayOrder___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    if (v3)
    {
      char v5 = (void *)MEMORY[0x1D9452090]();
      id v6 = WeakRetained;
      uint64_t v7 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        uint64_t v8 = HMFGetLogIdentifier();
        uint64_t v9 = *(void *)(a1 + 32);
        int v11 = 138543874;
        uint64_t v12 = v8;
        __int16 v13 = 2112;
        uint64_t v14 = v9;
        __int16 v15 = 2112;
        id v16 = v3;
        _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Failed to write request for updating display order to %@ - error  %@", (uint8_t *)&v11, 0x20u);
      }
      [*(id *)(a1 + 40) respondWithError:v3];
    }
    else
    {
      uint64_t v10 = [*(id *)(a1 + 48) service];
      [v10 updateMediaSourceDisplayOrder:*(void *)(a1 + 32) requestMessage:*(void *)(a1 + 40)];

      [*(id *)(a1 + 40) respondWithPayload:0];
    }
  }
}

- (id)createSiriEndpointProfileMetricsDispatcherWithAccessoryUUID:(id)a3 homeUUID:(id)a4 logEventSubmitter:(id)a5
{
  id v7 = a5;
  id v8 = a4;
  id v9 = a3;
  uint64_t v10 = [[HMDSiriEndpointProfileMetricsDispatcher alloc] initWithAccessoryUUID:v9 homeUUID:v8 logEventSubmitter:v7];

  return v10;
}

- (void)configureSiriEndpointProfileMetricsDispatcherWithFactory:(id)a3 logEventSubmitter:(id)a4 dailyScheduler:(id)a5
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  unint64_t v9 = (unint64_t)a4;
  unint64_t v10 = (unint64_t)a5;
  int v11 = (void *)MEMORY[0x1D9452090]();
  uint64_t v12 = self;
  __int16 v13 = HMFGetOSLogHandle();
  BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_INFO);
  if (v9 | v10)
  {
    if (v14)
    {
      __int16 v15 = HMFGetLogIdentifier();
      int v21 = 138543362;
      uint64_t v22 = v15;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_INFO, "%{public}@Configuring siri endpoint profile metrics dispatcher", (uint8_t *)&v21, 0xCu);
    }
    id v16 = [(HMDAccessory *)v12 uuid];
    uint64_t v17 = [(HMDAccessory *)v12 home];
    uint64_t v18 = [v17 uuid];
    id v19 = [v8 createSiriEndpointProfileMetricsDispatcherWithAccessoryUUID:v16 homeUUID:v18 logEventSubmitter:v9];

    [v19 setDataSource:v12];
    [(id)v10 registerDailyTaskRunner:v19];
    [(HMDHAPAccessory *)v12 setSiriEndpointProfileMetricsDispatcher:v19];
  }
  else
  {
    if (v14)
    {
      uint64_t v20 = HMFGetLogIdentifier();
      int v21 = 138543362;
      uint64_t v22 = v20;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_INFO, "%{public}@Metrics disabled for siri endpoint profile metrics dispatcher", (uint8_t *)&v21, 0xCu);
    }
  }
}

- (void)assignBonjourDeviceInfo:(id)a3 socketInfo:(id)a4
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  id v8 = (void *)MEMORY[0x1D9452090]();
  unint64_t v9 = self;
  unint64_t v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    int v11 = HMFGetLogIdentifier();
    int v21 = 138543874;
    uint64_t v22 = v11;
    __int16 v23 = 2112;
    id v24 = v6;
    __int16 v25 = 2112;
    id v26 = v7;
    _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_DEBUG, "%{public}@Assigning bonjour device info: %@, socket info: %@", (uint8_t *)&v21, 0x20u);
  }
  uint64_t v12 = [(HMDHAPAccessory *)v9 primaryIPServer];
  __int16 v13 = (void *)MEMORY[0x1D9452090]();
  BOOL v14 = v9;
  __int16 v15 = HMFGetOSLogHandle();
  BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_INFO);
  if (v12)
  {
    if (v16)
    {
      uint64_t v17 = HMFGetLogIdentifier();
      int v21 = 138543362;
      uint64_t v22 = v17;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@Accessory is reachable.  Assigning socket info to existing accessory server", (uint8_t *)&v21, 0xCu);
    }
    [v12 setCachedSocketInfo:v7];
  }
  else
  {
    if (v16)
    {
      uint64_t v18 = HMFGetLogIdentifier();
      int v21 = 138543362;
      uint64_t v22 = v18;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@HAPAccessoryServerIP not available via IP browser.  Attempting to interject accessory is reachable via simulating bonjour update", (uint8_t *)&v21, 0xCu);
    }
    id v19 = [(HMDAccessory *)v14 home];
    uint64_t v20 = [v19 accessoryBrowser];
    [v20 handleConnectionUpdateWithBonjourDeviceInfo:v6 socketInfo:v7];
  }
}

- (NSDictionary)bonjourDeviceInfo
{
  uint64_t v7 = 0;
  id v8 = &v7;
  uint64_t v9 = 0x3032000000;
  unint64_t v10 = __Block_byref_object_copy__171976;
  int v11 = __Block_byref_object_dispose__171977;
  id v12 = 0;
  id v3 = [(HMDAccessory *)self workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __45__HMDHAPAccessory_Network__bonjourDeviceInfo__block_invoke;
  v6[3] = &unk_1E6A18690;
  void v6[4] = self;
  void v6[5] = &v7;
  dispatch_sync(v3, v6);

  id v4 = (id)v8[5];
  _Block_object_dispose(&v7, 8);

  return (NSDictionary *)v4;
}

void __45__HMDHAPAccessory_Network__bonjourDeviceInfo__block_invoke(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v2 = [*(id *)(a1 + 32) primaryIPServer];
  id v3 = v2;
  if (!v2)
  {
    id v8 = (void *)MEMORY[0x1D9452090]();
    id v9 = *(id *)(a1 + 32);
    unint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      int v11 = HMFGetLogIdentifier();
      int v13 = 138543362;
      BOOL v14 = v11;
      id v12 = "%{public}@Could not get bonjour device info: IP server does not exist";
      goto LABEL_7;
    }
LABEL_8:

    goto LABEL_9;
  }
  id v4 = [v2 bonjourDeviceInfo];
  uint64_t v5 = [v4 copy];
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;

  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40))
  {
    id v8 = (void *)MEMORY[0x1D9452090]();
    id v9 = *(id *)(a1 + 32);
    unint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      int v11 = HMFGetLogIdentifier();
      int v13 = 138543362;
      BOOL v14 = v11;
      id v12 = "%{public}@Could not get bonjour device info: IP server not reachable via bonjour";
LABEL_7:
      _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, v12, (uint8_t *)&v13, 0xCu);

      goto LABEL_8;
    }
    goto LABEL_8;
  }
LABEL_9:
}

- (HAPSocketInfo)socketInfo
{
  uint64_t v7 = 0;
  id v8 = &v7;
  uint64_t v9 = 0x3032000000;
  unint64_t v10 = __Block_byref_object_copy__171976;
  int v11 = __Block_byref_object_dispose__171977;
  id v12 = 0;
  id v3 = [(HMDAccessory *)self workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __38__HMDHAPAccessory_Network__socketInfo__block_invoke;
  v6[3] = &unk_1E6A18690;
  void v6[4] = self;
  void v6[5] = &v7;
  dispatch_sync(v3, v6);

  id v4 = (id)v8[5];
  _Block_object_dispose(&v7, 8);

  return (HAPSocketInfo *)v4;
}

void __38__HMDHAPAccessory_Network__socketInfo__block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v2 = [*(id *)(a1 + 32) primaryIPServer];
  id v3 = v2;
  if (v2)
  {
    uint64_t v4 = [v2 currentSocketInfo];
    uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }
  else
  {
    uint64_t v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = *(id *)(a1 + 32);
    uint64_t v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      unint64_t v10 = HMFGetLogIdentifier();
      int v11 = 138543362;
      id v12 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Could not get peer socket address: IP server does not exist", (uint8_t *)&v11, 0xCu);
    }
  }
}

- (unsigned)metric_threadCapabilities
{
  int v3 = [(HMDHAPAccessory *)self threadCapabilities];
  if (!v3)
  {
    uint64_t v4 = [(HMDHAPAccessory *)self findCharacteristicType:@"00000702-0000-1000-8000-0026BB765291" forServiceType:@"00000701-0000-1000-8000-0026BB765291"];
    uint64_t v5 = [v4 value];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v6 = [v4 value];
    }
    else
    {
      uint64_t v6 = 0;
    }

    __int16 v7 = [v6 unsignedShortValue];
    LOWORD(v3) = v7;
  }
  return v3;
}

- (void)_writeCredentialsForThreadNetworkWithActivity:(id)a3 pairingEvent:(id)a4 metadata:(id)a5 threadControlPointCharacteristic:(id)a6 completion:(id)a7
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  id v56 = a3;
  id v12 = a4;
  id v13 = a5;
  id v55 = a6;
  id v58 = a7;
  BOOL v14 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v14);

  id v15 = v13;
  id v16 = objc_alloc(MEMORY[0x1E4F5BE68]);
  uint64_t v17 = objc_msgSend(NSNumber, "numberWithUnsignedChar:", objc_msgSend(v15, "channel"));
  uint64_t v18 = (void *)[v16 initWithValue:v17];

  unsigned __int16 v62 = 0;
  id v19 = [v15 PANID];
  uint64_t v20 = [v19 length];

  long long v57 = v12;
  if (v20 == 2)
  {
    int v21 = [v15 PANID];
    [v21 getBytes:&v62 length:2];

    unsigned __int16 v62 = bswap32(v62) >> 16;
    id v22 = objc_alloc(MEMORY[0x1E4F5BE68]);
    __int16 v23 = [NSNumber numberWithUnsignedShort:v62];
    id v24 = (void *)[v22 initWithValue:v23];

    __int16 v25 = (void *)[objc_alloc(MEMORY[0x1E4F5BE68]) initWithValue:&unk_1F2DC9DD8];
    id v26 = objc_alloc(MEMORY[0x1E4F5BBB0]);
    uint64_t v27 = [v15 name];
    char v28 = [v15 extendedPANID];
    uint64_t v29 = [v15 masterKey];
    long long v30 = (void *)[v26 initWithNetworkName:v27 channel:v18 panID:v24 extendedPanID:v28 masterKey:v29 reattachPeriod:v25];
  }
  else
  {
    __int16 v31 = (void *)MEMORY[0x1D9452090]();
    id v32 = objc_opt_class();
    uint64_t v33 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      id v34 = HMFGetLogIdentifier();
      uint64_t v35 = [v15 PANID];
      *(_DWORD *)buf = 138543618;
      uint64_t v64 = v34;
      __int16 v65 = 2112;
      id v66 = v35;
      _os_log_impl(&dword_1D49D5000, v33, OS_LOG_TYPE_ERROR, "%{public}@Invalid length for PANID: %@", buf, 0x16u);
    }
    long long v30 = 0;
  }

  if (v30)
  {
    id v36 = (void *)[objc_alloc(MEMORY[0x1E4F5BBB8]) initWithValue:1];
    id v37 = objc_alloc(MEMORY[0x1E4F5BE68]);
    __int16 v38 = (void *)[v37 initWithValue:MEMORY[0x1E4F1CC38]];
    long long v39 = (void *)[objc_alloc(MEMORY[0x1E4F5BBA8]) initWithOperationType:v36 threadNetworkCredentials:v30 formingAllowed:v38];
    id v61 = 0;
    __int16 v40 = [v39 serializeWithError:&v61];
    id v41 = v61;
    uint64_t v42 = v57;
    if (v40)
    {
      if (v57) {
        [v57 setBtCommissioned:1];
      }
      [(HMDAccessory *)self uuid];

      v59[0] = MEMORY[0x1E4F143A8];
      v59[1] = 3221225472;
      v59[2] = __149__HMDHAPAccessory_ThreadManagement___writeCredentialsForThreadNetworkWithActivity_pairingEvent_metadata_threadControlPointCharacteristic_completion___block_invoke;
      v59[3] = &unk_1E6A176E0;
      v59[4] = self;
      id v60 = v58;
      uint64_t v43 = self;
      uint64_t v45 = v55;
      __int16 v44 = v56;
      [(HMDHAPAccessory *)v43 _writeThreadControlPointCharacteristic:v55 value:v40 activity:v56 completion:v59];
    }
    else
    {
      context = (void *)MEMORY[0x1D9452090]();
      BOOL v51 = self;
      long long v52 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        long long v53 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        uint64_t v64 = v53;
        __int16 v65 = 2112;
        id v66 = v41;
        _os_log_impl(&dword_1D49D5000, v52, OS_LOG_TYPE_ERROR, "%{public}@Unable to serialize thread control point TLV: %@", buf, 0x16u);

        uint64_t v42 = v57;
      }

      (*((void (**)(id, id))v58 + 2))(v58, v41);
      uint64_t v45 = v55;
      __int16 v44 = v56;
    }

    int v50 = v58;
  }
  else
  {
    uint64_t v46 = (void *)MEMORY[0x1D9452090]();
    id v47 = self;
    long long v48 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      long long v49 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v64 = v49;
      _os_log_impl(&dword_1D49D5000, v48, OS_LOG_TYPE_ERROR, "%{public}@Unable to create TLV for network credentials", buf, 0xCu);
    }
    id v36 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
    int v50 = v58;
    (*((void (**)(id, void *))v58 + 2))(v58, v36);
    __int16 v44 = v56;
    uint64_t v42 = v57;
    uint64_t v45 = v55;
  }
}

void __149__HMDHAPAccessory_ThreadManagement___writeCredentialsForThreadNetworkWithActivity_pairingEvent_metadata_threadControlPointCharacteristic_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    __int16 v7 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
  }
  else
  {
    id v8 = (void *)MEMORY[0x1D9452090]();
    id v9 = *(id *)(a1 + 32);
    unint64_t v10 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = HMFGetLogIdentifier();
      int v12 = 138543618;
      id v13 = v11;
      __int16 v14 = 2112;
      uint64_t v15 = MEMORY[0x1E4F1CC38];
      _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_DEFAULT, "%{public}@Writing thread credentials succeeded - formingAllowed=%@", (uint8_t *)&v12, 0x16u);
    }
    __int16 v7 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
  }
  v7();
}

- (void)_commissionToThreadNetworkWithActivity:(id)a3 pairingEvent:(id)a4 completion:(id)a5
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  int v11 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v11);

  if ([(HMDHAPAccessory *)self hasBTLELink])
  {
    int v12 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000701-0000-1000-8000-0026BB765291"];
    id v13 = v12;
    if (v12)
    {
      uint64_t v14 = [v12 findCharacteristicWithType:@"00000704-0000-1000-8000-0026BB765291"];
      if (v14)
      {
        uint64_t v15 = (void *)v14;
        if (v9) {
          [v9 setThreadAccessory:1];
        }
        aBlock[0] = MEMORY[0x1E4F143A8];
        aBlock[1] = 3221225472;
        aBlock[2] = __100__HMDHAPAccessory_ThreadManagement___commissionToThreadNetworkWithActivity_pairingEvent_completion___block_invoke;
        aBlock[3] = &unk_1E6A17690;
        void aBlock[4] = self;
        id v33 = v8;
        id v36 = v10;
        id v34 = v9;
        id v16 = v15;
        id v35 = v16;
        uint64_t v17 = _Block_copy(aBlock);
        uint64_t v18 = [(HMDAccessory *)self home];
        [v18 retrieveThreadNetworkMetadataWithCompletion:v17];
      }
      else
      {
        uint64_t v27 = (void *)MEMORY[0x1D9452090]();
        char v28 = self;
        uint64_t v29 = HMFGetOSLogHandle();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          long long v30 = HMFGetLogIdentifier();
          *(_DWORD *)buf = 138543362;
          __int16 v38 = v30;
          _os_log_impl(&dword_1D49D5000, v29, OS_LOG_TYPE_ERROR, "%{public}@Unable to find thread control point characteristic", buf, 0xCu);
        }
        __int16 v31 = [MEMORY[0x1E4F28C58] hmErrorWithCode:66];
        (*((void (**)(id, void *))v10 + 2))(v10, v31);

        id v16 = 0;
      }
    }
    else
    {
      __int16 v23 = (void *)MEMORY[0x1D9452090]();
      id v24 = self;
      __int16 v25 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        id v26 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        __int16 v38 = v26;
        _os_log_impl(&dword_1D49D5000, v25, OS_LOG_TYPE_INFO, "%{public}@This accessory doesn't support thread", buf, 0xCu);
      }
      id v16 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
      (*((void (**)(id, id))v10 + 2))(v10, v16);
    }
  }
  else
  {
    id v19 = (void *)MEMORY[0x1D9452090]();
    uint64_t v20 = self;
    int v21 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      id v22 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v38 = v22;
      _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_ERROR, "%{public}@Commissioning to a thread network is only supported for bluetooth accessories", buf, 0xCu);
    }
    id v13 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
    (*((void (**)(id, void *))v10 + 2))(v10, v13);
  }
}

void __100__HMDHAPAccessory_ThreadManagement___commissionToThreadNetworkWithActivity_pairingEvent_completion___block_invoke(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  __int16 v7 = [a1[4] workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __100__HMDHAPAccessory_ThreadManagement___commissionToThreadNetworkWithActivity_pairingEvent_completion___block_invoke_2;
  block[3] = &unk_1E6A17668;
  id v8 = a1[5];
  id v9 = a1[4];
  id v13 = v8;
  id v14 = v9;
  id v15 = v6;
  id v16 = v5;
  id v19 = a1[8];
  id v17 = a1[6];
  id v18 = a1[7];
  id v10 = v5;
  id v11 = v6;
  dispatch_async(v7, block);
}

void __100__HMDHAPAccessory_ThreadManagement___commissionToThreadNetworkWithActivity_pairingEvent_completion___block_invoke_2(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  [*(id *)(a1 + 32) begin];
  id v20 = *(id *)(a1 + 32);
  id v2 = *(id *)(a1 + 32);
  [*(id *)(a1 + 40) uuid];

  [*(id *)(a1 + 48) code];
  if (*(void *)(a1 + 56)) {
    goto LABEL_2;
  }
  if ([*(id *)(a1 + 40) supportsCHIP])
  {
    id v13 = (void *)MEMORY[0x1D9452090]();
    id v14 = *(id *)(a1 + 40);
    HMFGetOSLogHandle();
    id v15 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      id v16 = HMFGetLogIdentifier();
      id v17 = *(void **)(a1 + 48);
      *(_DWORD *)buf = 138543618;
      id v22 = v16;
      __int16 v23 = 2112;
      id v24 = v17;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_ERROR, "%{public}@Unable to retrieve metadata for thread network with error %@", buf, 0x16u);
    }
LABEL_15:

    (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
    goto LABEL_16;
  }
  if ([*(id *)(a1 + 48) code] == 92 || objc_msgSend(*(id *)(a1 + 48), "code") == 91)
  {
    id v13 = (void *)MEMORY[0x1D9452090]();
    id v14 = *(id *)(a1 + 40);
    HMFGetOSLogHandle();
    id v15 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      id v18 = HMFGetLogIdentifier();
      id v19 = *(void **)(a1 + 48);
      *(_DWORD *)buf = 138543618;
      id v22 = v18;
      __int16 v23 = 2112;
      id v24 = v19;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_INFO, "%{public}@Ignoring error for HAP accessories %@", buf, 0x16u);
    }
    goto LABEL_15;
  }
LABEL_2:
  int v3 = (void *)MEMORY[0x1D9452090]();
  id v4 = *(id *)(a1 + 40);
  HMFGetOSLogHandle();
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    __int16 v7 = *(void **)(a1 + 56);
    *(_DWORD *)buf = 138543618;
    id v22 = v6;
    __int16 v23 = 2112;
    id v24 = v7;
    _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Retrieved metadata for thread network %@", buf, 0x16u);
  }
  id v8 = (void *)MEMORY[0x1D9452090]();
  id v9 = *(id *)(a1 + 40);
  HMFGetOSLogHandle();
  id v10 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    HMFGetLogIdentifier();
    id v11 = (id)objc_claimAutoreleasedReturnValue();
    int v12 = [*(id *)(a1 + 56) name];
    *(_DWORD *)buf = 138543618;
    id v22 = v11;
    __int16 v23 = 2112;
    id v24 = v12;
    _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_DEFAULT, "%{public}@Attempting to commission thread accessory to network '%@'", buf, 0x16u);
  }
  [*(id *)(a1 + 40) _writeCredentialsForThreadNetworkWithActivity:*(void *)(a1 + 32) pairingEvent:*(void *)(a1 + 64) metadata:*(void *)(a1 + 56) threadControlPointCharacteristic:*(void *)(a1 + 72) completion:*(void *)(a1 + 80)];
LABEL_16:
  __HMFActivityScopeLeave();
}

- (void)commissionToThreadNetworkWithPairingEvent:(id)a3 completion:(id)a4
{
  id v7 = a3;
  id v8 = a4;
  id v9 = objc_alloc(MEMORY[0x1E4F653F0]);
  id v10 = NSString;
  id v11 = MEMORY[0x1D94505D0](self, a2);
  int v12 = [v10 stringWithFormat:@"%@, %s:%ld", v11, "/Library/Caches/com.apple.xbs/Sources/HomeKit_executables_legacy/Sources/homed/HMDHAPAccessory+ThreadManagement.m", 353];
  id v21 = (id)[v9 initWithName:v12];

  id v13 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __90__HMDHAPAccessory_ThreadManagement__commissionToThreadNetworkWithPairingEvent_completion___block_invoke;
  block[3] = &unk_1E6A18398;
  id v17 = v21;
  id v18 = self;
  id v19 = v7;
  id v20 = v8;
  id v14 = v8;
  id v15 = v7;
  dispatch_async(v13, block);

  __HMFActivityScopeLeave();
}

void __90__HMDHAPAccessory_ThreadManagement__commissionToThreadNetworkWithPairingEvent_completion___block_invoke(uint64_t a1)
{
  [*(id *)(a1 + 32) begin];
  id v2 = *(id *)(a1 + 32);
  [*(id *)(a1 + 40) _commissionToThreadNetworkWithActivity:*(void *)(a1 + 32) pairingEvent:*(void *)(a1 + 48) completion:*(void *)(a1 + 56)];
  __HMFActivityScopeLeave();
}

- (BOOL)_validateCurrentThreadCredentials:(id)a3 metadata:(id)a4
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = [v6 networkName];
  if (v8)
  {
    id v9 = (void *)v8;
    uint64_t v10 = [v6 extendedPanID];
    if (v10)
    {
      id v11 = (void *)v10;
      int v12 = [v6 channel];

      if (v12)
      {
        id v13 = [v7 name];
        id v14 = [v6 networkName];
        if ([v13 isEqualToString:v14])
        {
          id v15 = [v7 extendedPANID];
          id v16 = [v6 extendedPanID];
          if ([v15 isEqualToData:v16])
          {
            int v17 = [v7 channel];
            id v18 = [v6 channel];
            id v19 = [v18 value];
            BOOL v20 = [v19 unsignedIntValue] == v17;
          }
          else
          {
            BOOL v20 = 0;
          }
        }
        else
        {
          BOOL v20 = 0;
        }

        goto LABEL_15;
      }
    }
    else
    {
    }
  }
  id v21 = (void *)MEMORY[0x1D9452090]();
  id v22 = self;
  __int16 v23 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    id v24 = HMFGetLogIdentifier();
    uint64_t v25 = [v6 networkName];
    id v26 = [v6 extendedPanID];
    int v28 = 138543874;
    uint64_t v29 = v24;
    __int16 v30 = 2112;
    __int16 v31 = v25;
    __int16 v32 = 2112;
    id v33 = v26;
    _os_log_impl(&dword_1D49D5000, v23, OS_LOG_TYPE_ERROR, "%{public}@Cannot validate %@/%@", (uint8_t *)&v28, 0x20u);
  }
  BOOL v20 = 0;
LABEL_15:

  return v20;
}

void __92__HMDHAPAccessory_ThreadManagement___maybeCommissionToThreadNetworkWithActivity_completion___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  if (!v5)
  {
    id v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = *(id *)(a1 + 32);
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v31 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_DEFAULT, "%{public}@Writing to the thread control point succeeded", buf, 0xCu);
    }
    if (v6)
    {
      id v29 = 0;
      id v11 = [MEMORY[0x1E4F5BBA8] parsedFromData:v6 error:&v29];
      id v5 = v29;
      if (v11)
      {
LABEL_12:
        uint64_t v20 = MEMORY[0x1E4F143A8];
        uint64_t v21 = 3221225472;
        id v22 = __92__HMDHAPAccessory_ThreadManagement___maybeCommissionToThreadNetworkWithActivity_completion___block_invoke_17;
        __int16 v23 = &unk_1E6A17690;
        id v16 = *(void **)(a1 + 40);
        uint64_t v24 = *(void *)(a1 + 32);
        id v25 = v16;
        id v28 = *(id *)(a1 + 56);
        id v26 = v11;
        id v27 = *(id *)(a1 + 48);
        id v17 = v11;
        id v18 = _Block_copy(&v20);
        id v19 = objc_msgSend(*(id *)(a1 + 32), "home", v20, v21, v22, v23, v24);
        [v19 retrieveThreadNetworkMetadataWithCompletion:v18];

        goto LABEL_13;
      }
    }
    else
    {
      id v5 = 0;
    }
    int v12 = (void *)MEMORY[0x1D9452090]();
    id v13 = *(id *)(a1 + 32);
    id v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      id v15 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      __int16 v31 = v15;
      __int16 v32 = 2112;
      id v33 = v5;
      _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_ERROR, "%{public}@Unable to parse returned credentials: %@. Recommissioning", buf, 0x16u);
    }
    id v11 = 0;
    goto LABEL_12;
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
LABEL_13:
}

void __92__HMDHAPAccessory_ThreadManagement___maybeCommissionToThreadNetworkWithActivity_completion___block_invoke_17(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [a1[4] workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __92__HMDHAPAccessory_ThreadManagement___maybeCommissionToThreadNetworkWithActivity_completion___block_invoke_2;
  block[3] = &unk_1E6A17668;
  id v8 = a1[5];
  id v9 = a1[4];
  id v13 = v8;
  id v14 = v9;
  id v15 = v6;
  id v16 = v5;
  id v19 = a1[8];
  id v17 = a1[6];
  id v18 = a1[7];
  id v10 = v5;
  id v11 = v6;
  dispatch_async(v7, block);
}

void __92__HMDHAPAccessory_ThreadManagement___maybeCommissionToThreadNetworkWithActivity_completion___block_invoke_2(uint64_t a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  [*(id *)(a1 + 32) begin];
  id v29 = *(id *)(a1 + 32);
  id v2 = *(id *)(a1 + 32);
  [*(id *)(a1 + 40) uuid];

  [*(id *)(a1 + 48) code];
  if (!*(void *)(a1 + 56))
  {
    if ([*(id *)(a1 + 40) supportsCHIP])
    {
      id v19 = (void *)MEMORY[0x1D9452090]();
      id v20 = *(id *)(a1 + 40);
      HMFGetOSLogHandle();
      uint64_t v21 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        id v22 = HMFGetLogIdentifier();
        __int16 v23 = *(void **)(a1 + 48);
        *(_DWORD *)buf = 138543618;
        id v31 = v22;
        __int16 v32 = 2112;
        id v33 = v23;
        _os_log_impl(&dword_1D49D5000, v21, OS_LOG_TYPE_ERROR, "%{public}@Unable to retrieve metadata for thread network with error %@", buf, 0x16u);
      }
      uint64_t v24 = *(void *)(a1 + 80);
      uint64_t v25 = *(void *)(a1 + 48);
      goto LABEL_13;
    }
LABEL_12:
    uint64_t v25 = 0;
    uint64_t v24 = *(void *)(a1 + 80);
LABEL_13:
    (*(void (**)(uint64_t, uint64_t))(v24 + 16))(v24, v25);
    goto LABEL_17;
  }
  int v3 = (void *)MEMORY[0x1D9452090]();
  id v4 = *(id *)(a1 + 40);
  HMFGetOSLogHandle();
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    id v6 = HMFGetLogIdentifier();
    id v7 = *(void **)(a1 + 56);
    *(_DWORD *)buf = 138543618;
    id v31 = v6;
    __int16 v32 = 2112;
    id v33 = v7;
    _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Retrieved metadata for thread network %@", buf, 0x16u);
  }
  id v8 = *(void **)(a1 + 40);
  id v9 = [*(id *)(a1 + 64) threadNetworkCredentials];
  int v10 = [v8 _validateCurrentThreadCredentials:v9 metadata:*(void *)(a1 + 56)];

  id v11 = (void *)MEMORY[0x1D9452090]();
  id v12 = *(id *)(a1 + 40);
  if (v10)
  {
    HMFGetOSLogHandle();
    id v13 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      HMFGetLogIdentifier();
      id v14 = (id)objc_claimAutoreleasedReturnValue();
      id v15 = [*(id *)(a1 + 64) threadNetworkCredentials];
      id v16 = [v15 networkName];
      id v17 = [*(id *)(a1 + 64) threadNetworkCredentials];
      id v18 = [v17 extendedPanID];
      *(_DWORD *)buf = 138543874;
      id v31 = v14;
      __int16 v32 = 2112;
      id v33 = v16;
      __int16 v34 = 2112;
      id v35 = v18;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_INFO, "%{public}@Accessory already has been commissioned to %@/%@", buf, 0x20u);
    }
    goto LABEL_12;
  }
  HMFGetOSLogHandle();
  id v26 = (id)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    HMFGetLogIdentifier();
    id v27 = (id)objc_claimAutoreleasedReturnValue();
    id v28 = [*(id *)(a1 + 56) name];
    *(_DWORD *)buf = 138543618;
    id v31 = v27;
    __int16 v32 = 2112;
    id v33 = v28;
    _os_log_impl(&dword_1D49D5000, v26, OS_LOG_TYPE_DEFAULT, "%{public}@Attempting to commission thread accessory to network '%@'", buf, 0x16u);
  }
  [*(id *)(a1 + 40) _writeCredentialsForThreadNetworkWithActivity:*(void *)(a1 + 32) pairingEvent:0 metadata:*(void *)(a1 + 56) threadControlPointCharacteristic:*(void *)(a1 + 72) completion:*(void *)(a1 + 80)];
LABEL_17:
  __HMFActivityScopeLeave();
}

- (void)_writeThreadControlPointCharacteristic:(id)a3 value:(id)a4 activity:(id)a5 completion:(id)a6
{
  v21[1] = *MEMORY[0x1E4F143B8];
  id v10 = a5;
  id v11 = a6;
  id v12 = +[HMDCharacteristicWriteRequest writeRequestWithCharacteristic:a3 value:a4 authorizationData:0 identifier:0 type:0 includeResponseValue:1];
  v21[0] = v12;
  id v13 = [MEMORY[0x1E4F1C978] arrayWithObjects:v21 count:1];
  id v14 = [(HMDAccessory *)self workQueue];
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 3221225472;
  void v17[2] = __102__HMDHAPAccessory_ThreadManagement___writeThreadControlPointCharacteristic_value_activity_completion___block_invoke;
  v17[3] = &unk_1E6A17640;
  id v18 = v10;
  id v19 = self;
  id v20 = v11;
  id v15 = v11;
  id v16 = v10;
  [(HMDHAPAccessory *)self writeCharacteristicValues:v13 source:7 queue:v14 completionHandler:v17];
}

void __102__HMDHAPAccessory_ThreadManagement___writeThreadControlPointCharacteristic_value_activity_completion___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  [*(id *)(a1 + 32) begin];
  id v18 = *(id *)(a1 + 32);
  if ([v3 count])
  {
    id v4 = [v3 firstObject];
    id v5 = [v4 error];

    id v6 = [v3 firstObject];
    id v7 = [v6 value];

    if (v5)
    {
      id v8 = (void *)MEMORY[0x1D9452090]();
      id v9 = *(id *)(a1 + 40);
      HMFGetOSLogHandle();
      id v10 = (id)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        id v11 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        id v20 = v11;
        __int16 v21 = 2112;
        id v22 = v5;
        _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_ERROR, "%{public}@Writing to the thread control point failed: %@", buf, 0x16u);
      }
    }
    else
    {
      id v16 = [v3 firstObject];
      uint64_t v17 = [v16 value];

      id v5 = 0;
      id v7 = (void *)v17;
    }
  }
  else
  {
    id v5 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
    id v12 = (void *)MEMORY[0x1D9452090]();
    id v13 = *(id *)(a1 + 40);
    HMFGetOSLogHandle();
    id v14 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      id v15 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v20 = v15;
      _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_ERROR, "%{public}@No response found", buf, 0xCu);
    }
    id v7 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();

  __HMFActivityScopeLeave();
}

- (id)_findThreadControlPointCharacteristicWithError:(id *)a3
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v5 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000701-0000-1000-8000-0026BB765291"];
  id v6 = v5;
  if (v5)
  {
    id v7 = [v5 findCharacteristicWithType:@"00000704-0000-1000-8000-0026BB765291"];
    id v8 = v7;
    if (v7)
    {
      id v9 = v7;
    }
    else
    {
      id v14 = (void *)MEMORY[0x1D9452090]();
      id v15 = self;
      id v16 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        uint64_t v17 = HMFGetLogIdentifier();
        int v19 = 138543362;
        id v20 = v17;
        _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_ERROR, "%{public}@Unable to find thread control point characteristic", (uint8_t *)&v19, 0xCu);
      }
      if (a3)
      {
        *a3 = [MEMORY[0x1E4F28C58] hmErrorWithCode:66];
      }
    }
  }
  else
  {
    id v10 = (void *)MEMORY[0x1D9452090]();
    id v11 = self;
    id v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      id v13 = HMFGetLogIdentifier();
      int v19 = 138543362;
      id v20 = v13;
      _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_INFO, "%{public}@Commissioning to a thread network is not possible with this accessory", (uint8_t *)&v19, 0xCu);
    }
    if (a3)
    {
      [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
      id v8 = 0;
      *a3 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      id v8 = 0;
    }
  }

  return v8;
}

void __91__HMDHAPAccessory_ThreadManagement___handleUpdatedServicesForThreadManagementWithActivity___block_invoke(uint64_t a1, void *a2)
{
  id v11 = a2;
  id v3 = [v11 type];
  int v4 = [v3 isEqualToString:@"00000702-0000-1000-8000-0026BB765291"];

  if (v4)
  {
    id v5 = [v11 value];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v6 = [v11 value];

      if (!v6) {
        goto LABEL_15;
      }
      [*(id *)(a1 + 32) setInternalThreadCapabilities:v6];
LABEL_13:
      id v5 = (void *)v6;
    }
  }
  else
  {
    id v7 = [v11 type];
    int v8 = [v7 isEqualToString:@"00000703-0000-1000-8000-0026BB765291"];

    if (!v8)
    {
      id v9 = [v11 type];
      int v10 = [v9 isEqualToString:@"0000022B-0000-1000-8000-0026BB765291"];

      if (!v10) {
        goto LABEL_15;
      }
      id v5 = [v11 value];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_14;
      }
      uint64_t v6 = [v11 value];

      if (!v6) {
        goto LABEL_15;
      }
      [*(id *)(a1 + 32) setInternalThreadActive:v6];
      goto LABEL_13;
    }
    id v5 = [v11 value];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v6 = [v11 value];

      if (!v6) {
        goto LABEL_15;
      }
      [*(id *)(a1 + 32) setInternalThreadStatus:v6];
      goto LABEL_13;
    }
  }
LABEL_14:

LABEL_15:
}

- (BOOL)supportsThreadCommissioning
{
  id v3 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v3);

  if (![(HMDHAPAccessory *)self hasBTLELink]) {
    return 0;
  }
  int v4 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000701-0000-1000-8000-0026BB765291"];
  BOOL v5 = v4 != 0;

  return v5;
}

- (BOOL)isThreadTheCurrentlyActiveTransport
{
  id v2 = [(HMDHAPAccessory *)self internalThreadActive];
  char v3 = [v2 BOOLValue];

  return v3;
}

- (unsigned)threadStatus
{
  id v2 = [(HMDHAPAccessory *)self internalThreadStatus];
  unsigned __int16 v3 = [v2 unsignedShortValue];

  return v3;
}

- (unsigned)threadCapabilities
{
  id v2 = [(HMDHAPAccessory *)self internalThreadCapabilities];
  unsigned __int16 v3 = [v2 unsignedShortValue];

  return v3;
}

- (BOOL)_handleUpdatedServicesForMediaProfile:(id)a3
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  BOOL v5 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v5);

  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  id v6 = v4;
  uint64_t v7 = [v6 countByEnumeratingWithState:&v26 objects:v35 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v27;
    while (2)
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v27 != v9) {
          objc_enumerationMutation(v6);
        }
        id v11 = *(void **)(*((void *)&v26 + 1) + 8 * i);
        id v12 = objc_msgSend(v11, "serviceType", (void)v26);
        if ([v12 isEqualToString:@"00000228-0000-1000-8000-0026BB765291"])
        {
          id v13 = [(HMDHAPAccessory *)self mediaProfile];

          if (!v13)
          {
            id v15 = [HMDHAPMediaProfile alloc];
            __int16 v34 = v11;
            id v16 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v34 count:1];
            uint64_t v17 = [(HMDHAPMediaProfile *)v15 initWithMediaServices:v16];

            id v18 = (void *)MEMORY[0x1D9452090]();
            int v19 = self;
            id v20 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
            {
              id v22 = HMFGetLogIdentifier();
              *(_DWORD *)buf = 138543618;
              id v31 = v22;
              __int16 v32 = 2112;
              id v33 = v17;
              _os_log_impl(&dword_1D49D5000, v20, OS_LOG_TYPE_INFO, "%{public}@Adding new media profile: %@", buf, 0x16u);
            }
            [(HMDAccessory *)v19 addAccessoryProfile:v17];
            uint64_t v23 = [(HMDAccessory *)v19 msgDispatcher];
            [(HMDMediaProfile *)v17 configureWithMessageDispatcher:v23 configurationTracker:0];

            uint64_t v24 = [MEMORY[0x1E4F28EB8] defaultCenter];
            [v24 postNotificationName:@"HMDHAPMediaProfileAddedNotification" object:v19 userInfo:0];

            BOOL v14 = 1;
            goto LABEL_16;
          }
        }
        else
        {
        }
      }
      uint64_t v8 = [v6 countByEnumeratingWithState:&v26 objects:v35 count:16];
      if (v8) {
        continue;
      }
      break;
    }
  }
  BOOL v14 = 0;
LABEL_16:

  return v14;
}

- (HMDMediaProfile)mediaProfile
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v2 = [(HMDAccessory *)self accessoryProfiles];
  uint64_t v3 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v12;
LABEL_3:
    uint64_t v6 = 0;
    while (1)
    {
      if (*(void *)v12 != v5) {
        objc_enumerationMutation(v2);
      }
      id v7 = *(id *)(*((void *)&v11 + 1) + 8 * v6);
      objc_opt_class();
      id v8 = (objc_opt_isKindOfClass() & 1) != 0 ? v7 : 0;
      id v9 = v8;

      if (v9) {
        break;
      }
      if (v4 == ++v6)
      {
        uint64_t v4 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
        if (v4) {
          goto LABEL_3;
        }
        goto LABEL_12;
      }
    }
  }
  else
  {
LABEL_12:
    id v7 = 0;
  }

  return (HMDMediaProfile *)v7;
}

- (void)_handleUpdatedServicesForDataStreamController:(id)a3
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if (!+[HMDDeviceCapabilities supportsHomeKitDataStream])
  {
    id v18 = (void *)MEMORY[0x1D9452090]();
    int v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      id v20 = HMFGetLogIdentifier();
      int v29 = 138543362;
      __int16 v30 = v20;
      uint64_t v21 = "%{public}@Handling updated services for data stream controller, accessory does not support HDS.";
LABEL_12:
      _os_log_impl(&dword_1D49D5000, v19, OS_LOG_TYPE_INFO, v21, (uint8_t *)&v29, 0xCu);
    }
LABEL_13:

    goto LABEL_19;
  }
  uint64_t v5 = [(HMDAccessory *)self msgDispatcher];

  if (!v5)
  {
    id v18 = (void *)MEMORY[0x1D9452090]();
    int v19 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      id v20 = HMFGetLogIdentifier();
      int v29 = 138543362;
      __int16 v30 = v20;
      uint64_t v21 = "%{public}@Message dispatcher isn't set, cannot create DataStream controller";
      goto LABEL_12;
    }
    goto LABEL_13;
  }
  uint64_t v6 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000129-0000-1000-8000-0026BB765291"];
  id v7 = [(HMDHAPAccessory *)self dataStreamController];
  id v8 = v7;
  if (v6)
  {

    if (!v8)
    {
      id v9 = [HMDDataStreamController alloc];
      int v10 = [(HMDAccessory *)self workQueue];
      long long v11 = [(HMDDataStreamController *)v9 initWithAccessory:self service:v6 workQueue:v10];
      [(HMDHAPAccessory *)self setDataStreamController:v11];

      long long v12 = [(HMDHAPAccessory *)self dataStreamController];
      [v12 registerForNotifications];

      long long v13 = (void *)MEMORY[0x1D9452090]();
      long long v14 = self;
      id v15 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = HMFGetLogIdentifier();
        uint64_t v17 = [(HMDHAPAccessory *)v14 dataStreamController];
        int v29 = 138543874;
        __int16 v30 = v16;
        __int16 v31 = 2112;
        __int16 v32 = v17;
        __int16 v33 = 2112;
        __int16 v34 = v6;
        _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_DEFAULT, "%{public}@Created DataStream controller %@ with service: %@", (uint8_t *)&v29, 0x20u);
      }
    }
  }
  else
  {

    if (v8)
    {
      id v22 = (void *)MEMORY[0x1D9452090]();
      uint64_t v23 = self;
      uint64_t v24 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = HMFGetLogIdentifier();
        long long v26 = [(HMDHAPAccessory *)v23 dataStreamController];
        int v29 = 138543618;
        __int16 v30 = v25;
        __int16 v31 = 2112;
        __int16 v32 = v26;
        _os_log_impl(&dword_1D49D5000, v24, OS_LOG_TYPE_DEFAULT, "%{public}@Invalidating DataStream controller %@", (uint8_t *)&v29, 0x16u);
      }
      long long v27 = [(HMDHAPAccessory *)v23 dataStreamController];
      [v27 deRegisterFromNotifications];

      long long v28 = [(HMDHAPAccessory *)v23 dataStreamController];
      [v28 invalidate];

      [(HMDHAPAccessory *)v23 setDataStreamController:0];
    }
  }

LABEL_19:
}

- (void)openBulkSendSessionForFileType:(id)a3 reason:(id)a4 metadata:(id)a5 queue:(id)a6 callback:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = a7;
  uint64_t v17 = [(HMDAccessory *)self workQueue];
  v23[0] = MEMORY[0x1E4F143A8];
  v23[1] = 3221225472;
  id v23[2] = __101__HMDHAPAccessory_DataStreamBulkSend__openBulkSendSessionForFileType_reason_metadata_queue_callback___block_invoke;
  v23[3] = &unk_1E6A18640;
  v23[4] = self;
  id v24 = v12;
  id v25 = v13;
  id v26 = v14;
  id v27 = v15;
  id v28 = v16;
  id v18 = v15;
  id v19 = v14;
  id v20 = v13;
  id v21 = v12;
  id v22 = v16;
  dispatch_async(v17, v23);
}

void __101__HMDHAPAccessory_DataStreamBulkSend__openBulkSendSessionForFileType_reason_metadata_queue_callback___block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v2 = [*(id *)(a1 + 32) dataStreamController];

  if (v2)
  {
    id v7 = [*(id *)(a1 + 32) dataStreamController];
    [v7 openBulkSendSessionForFileType:*(void *)(a1 + 40) reason:*(void *)(a1 + 48) metadata:*(void *)(a1 + 56) queue:*(void *)(a1 + 64) callback:*(void *)(a1 + 72)];
  }
  else
  {
    uint64_t v3 = (void *)MEMORY[0x1D9452090]();
    id v4 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      uint64_t v5 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v9 = v5;
      _os_log_impl(&dword_1D49D5000, v4, OS_LOG_TYPE_INFO, "%{public}@DataStream controller isn't set; cannot start bulk send session",
        buf,
        0xCu);
    }
    uint64_t v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
  }
}

- (void)sendTargetControlWhoAmIWithIdentifier:(unsigned int)a3
{
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __77__HMDHAPAccessory_DataStreamBulkSend__sendTargetControlWhoAmIWithIdentifier___block_invoke;
  v6[3] = &unk_1E6A18370;
  void v6[4] = self;
  unsigned int v7 = a3;
  dispatch_async(v5, v6);
}

void __77__HMDHAPAccessory_DataStreamBulkSend__sendTargetControlWhoAmIWithIdentifier___block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v2 = [*(id *)(a1 + 32) dataStreamController];

  if (v2)
  {
    id v10 = [*(id *)(a1 + 32) dataStreamController];
    [v10 sendTargetControlWhoAmIWithIdentifier:*(unsigned int *)(a1 + 40)];
  }
  else
  {
    uint64_t v3 = (void *)MEMORY[0x1D9452090]();
    id v4 = *(id *)(a1 + 32);
    uint64_t v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = HMFGetLogIdentifier();
      unsigned int v7 = [*(id *)(a1 + 32) name];
      id v8 = [*(id *)(a1 + 32) uuid];
      id v9 = [v8 UUIDString];
      *(_DWORD *)buf = 138543874;
      id v12 = v6;
      __int16 v13 = 2112;
      id v14 = v7;
      __int16 v15 = 2112;
      id v16 = v9;
      _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Ignoring attempt to send target-control whomai due to no active data stream (%@/%@)", buf, 0x20u);
    }
  }
}

- (BOOL)bulkSendListenersRequireCharacteristicReadsSync
{
  uint64_t v3 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v3);

  id v4 = [(HMDHAPAccessory *)self dataStreamController];
  if (v4)
  {
    uint64_t v5 = [(HMDHAPAccessory *)self dataStreamController];
    char v6 = [v5 setupRequiresCharacteristicReads];
  }
  else
  {
    char v6 = 0;
  }

  return v6;
}

- (BOOL)canAcceptBulkSendListenersSync
{
  uint64_t v3 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v3);

  id v4 = [(HMDHAPAccessory *)self dataStreamController];
  if (v4)
  {
    uint64_t v5 = [(HMDHAPAccessory *)self dataStreamController];
    char v6 = [v5 canAcceptBulkSendListeners];
  }
  else
  {
    char v6 = 0;
  }

  return v6;
}

- (BOOL)canAcceptBulkSendListeners
{
  id v2 = self;
  uint64_t v6 = 0;
  unsigned int v7 = &v6;
  uint64_t v8 = 0x2020000000;
  char v9 = 0;
  uint64_t v3 = [(HMDAccessory *)self workQueue];
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __65__HMDHAPAccessory_DataStreamBulkSend__canAcceptBulkSendListeners__block_invoke;
  v5[3] = &unk_1E6A18690;
  v5[4] = v2;
  void v5[5] = &v6;
  dispatch_sync(v3, v5);

  LOBYTE(v2) = *((unsigned char *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return (char)v2;
}

void __65__HMDHAPAccessory_DataStreamBulkSend__canAcceptBulkSendListeners__block_invoke(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) dataStreamController];
  if (v2)
  {
    id v4 = v2;
    uint64_t v3 = [*(id *)(a1 + 32) dataStreamController];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [v3 canAcceptBulkSendListeners];

    id v2 = v4;
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  }
}

- (void)removeDataStreamBulkSendListener:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __72__HMDHAPAccessory_DataStreamBulkSend__removeDataStreamBulkSendListener___block_invoke;
  v7[3] = &unk_1E6A197C8;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __72__HMDHAPAccessory_DataStreamBulkSend__removeDataStreamBulkSendListener___block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v2 = [*(id *)(a1 + 32) dataStreamController];

  if (v2)
  {
    id v11 = [*(id *)(a1 + 32) dataStreamController];
    [v11 removeBulkSendListener:*(void *)(a1 + 40)];
  }
  else
  {
    uint64_t v3 = (void *)MEMORY[0x1D9452090]();
    id v4 = *(id *)(a1 + 32);
    uint64_t v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      id v6 = HMFGetLogIdentifier();
      unsigned int v7 = [*(id *)(a1 + 32) name];
      id v8 = [*(id *)(a1 + 32) uuid];
      char v9 = [v8 UUIDString];
      *(_DWORD *)buf = 138543874;
      __int16 v13 = v6;
      __int16 v14 = 2112;
      __int16 v15 = v7;
      __int16 v16 = 2112;
      uint64_t v17 = v9;
      _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Cancelling listener registration due to no active data stream (%@/%@)", buf, 0x20u);
    }
    id v10 = [MEMORY[0x1E4F28C58] hmInternalErrorWithCode:1063];
    [*(id *)(a1 + 40) accessory:*(void *)(a1 + 32) didCloseDataStreamWithError:v10];
  }
}

- (void)addDataStreamBulkSendListener:(id)a3 fileType:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  id v8 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __78__HMDHAPAccessory_DataStreamBulkSend__addDataStreamBulkSendListener_fileType___block_invoke;
  block[3] = &unk_1E6A19668;
  void block[4] = self;
  id v12 = v6;
  id v13 = v7;
  id v9 = v7;
  id v10 = v6;
  dispatch_async(v8, block);
}

void __78__HMDHAPAccessory_DataStreamBulkSend__addDataStreamBulkSendListener_fileType___block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v2 = [*(id *)(a1 + 32) dataStreamController];

  if (v2)
  {
    id v11 = [*(id *)(a1 + 32) dataStreamController];
    [v11 addBulkSendListener:*(void *)(a1 + 40) fileType:*(void *)(a1 + 48)];
  }
  else
  {
    uint64_t v3 = (void *)MEMORY[0x1D9452090]();
    id v4 = *(id *)(a1 + 32);
    uint64_t v5 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      id v6 = HMFGetLogIdentifier();
      id v7 = [*(id *)(a1 + 32) name];
      id v8 = [*(id *)(a1 + 32) uuid];
      id v9 = [v8 UUIDString];
      *(_DWORD *)buf = 138543874;
      id v13 = v6;
      __int16 v14 = 2112;
      __int16 v15 = v7;
      __int16 v16 = 2112;
      uint64_t v17 = v9;
      _os_log_impl(&dword_1D49D5000, v5, OS_LOG_TYPE_INFO, "%{public}@Cancelling listener registration due to no active data stream (%@/%@)", buf, 0x20u);
    }
    id v10 = [MEMORY[0x1E4F28C58] hmInternalErrorWithCode:1063];
    [*(id *)(a1 + 40) accessory:*(void *)(a1 + 32) didCloseDataStreamWithError:v10];
  }
}

- (id)valueFromAttribute:(id)a3
{
  id v3 = a3;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v4 = v3;
  }
  else {
    id v4 = 0;
  }
  id v5 = v4;
  id v6 = [v5 objectForKeyedSubscript:*MEMORY[0x1E4F31170]];

  return v6;
}

- (id)dataFromAttributeReport:(id)a3
{
  id v3 = [a3 objectForKeyedSubscript:*MEMORY[0x1E4F31160]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v4 = v3;
  }
  else {
    id v4 = 0;
  }
  id v5 = v4;

  if (v5)
  {
    id v6 = [v5 objectForKeyedSubscript:*MEMORY[0x1E4F31170]];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      id v7 = v6;
    }
    else {
      id v7 = 0;
    }
    id v8 = v7;
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

- (id)numberFromAttributeReport:(id)a3
{
  id v3 = [a3 objectForKeyedSubscript:*MEMORY[0x1E4F31160]];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v4 = v3;
  }
  else {
    id v4 = 0;
  }
  id v5 = v4;

  if (v5)
  {
    id v6 = [v5 objectForKeyedSubscript:*MEMORY[0x1E4F31170]];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      id v7 = v6;
    }
    else {
      id v7 = 0;
    }
    id v8 = v7;
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

- (void)didUpdateRequiresThreadRouterForAccessoryServer:(id)a3
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = self;
  id v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    [v4 requiresThreadRouter];
    id v9 = HMFBooleanToString();
    *(_DWORD *)buf = 138543618;
    __int16 v16 = v8;
    __int16 v17 = 2112;
    uint64_t v18 = v9;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Updating accessory requires thread router to %@", buf, 0x16u);
  }
  id v10 = [(HMDAccessory *)v6 workQueue];
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  v12[2] = __73__HMDHAPAccessory_CHIP__didUpdateRequiresThreadRouterForAccessoryServer___block_invoke;
  v12[3] = &unk_1E6A197C8;
  id v13 = v4;
  __int16 v14 = v6;
  id v11 = v4;
  dispatch_async(v10, v12);
}

void __73__HMDHAPAccessory_CHIP__didUpdateRequiresThreadRouterForAccessoryServer___block_invoke(uint64_t a1)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *MEMORY[0x1E4F2C558];
  id v2 = objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(*(id *)(a1 + 32), "requiresThreadRouter"));
  v9[0] = v2;
  id v3 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v9 forKeys:&v8 count:1];
  id v4 = (void *)[v3 mutableCopy];

  id v5 = [MEMORY[0x1E4F65480] messageWithName:*MEMORY[0x1E4F2C550] messagePayload:v4];
  id v6 = [*(id *)(a1 + 40) msgDispatcher];
  id v7 = [*(id *)(a1 + 40) uuid];
  [v6 sendMessage:v5 target:v7];
}

- (void)didUpdatePairingsForAccessoryServer:(id)a3
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  BOOL v5 = [(HMDHAPAccessory *)self isPrimary];
  id v6 = (void *)MEMORY[0x1D9452090]();
  id v7 = self;
  uint64_t v8 = HMFGetOSLogHandle();
  id v9 = v8;
  if (v5)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      id v10 = HMFGetLogIdentifier();
      id v11 = [v4 primaryAccessory];
      int v14 = 138543618;
      __int16 v15 = v10;
      __int16 v16 = 2112;
      __int16 v17 = v11;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Received pairing change update for CHIP accessory %@", (uint8_t *)&v14, 0x16u);
    }
    [(HMDHAPAccessory *)v7 _fetchPairingsAndUpdateTransaction];
  }
  else
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      id v12 = HMFGetLogIdentifier();
      id v13 = [v4 primaryAccessory];
      int v14 = 138543618;
      __int16 v15 = v12;
      __int16 v16 = 2112;
      __int16 v17 = v13;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_DEBUG, "%{public}@Ignoring pairing change update for CHIP accessory %@ because current accessory is not primary", (uint8_t *)&v14, 0x16u);
    }
  }
}

- (void)_handleHomeNameChangedNotification:(id)a3
{
  id v4 = a3;
  BOOL v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __60__HMDHAPAccessory_CHIP___handleHomeNameChangedNotification___block_invoke;
  v7[3] = &unk_1E6A197C8;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __60__HMDHAPAccessory_CHIP___handleHomeNameChangedNotification___block_invoke(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  id v2 = (void *)MEMORY[0x1D9452090]();
  id v3 = *(id *)(a1 + 32);
  id v4 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    BOOL v5 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    id v11 = v5;
    _os_log_impl(&dword_1D49D5000, v4, OS_LOG_TYPE_INFO, "%{public}@Handling home name changed notification", buf, 0xCu);
  }
  id v6 = [*(id *)(a1 + 40) userInfo];
  id v7 = objc_msgSend(v6, "hmf_stringForKey:", @"HMDHomeNameNotificationKey");

  id v8 = *(void **)(a1 + 32);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  void v9[2] = __60__HMDHAPAccessory_CHIP___handleHomeNameChangedNotification___block_invoke_107;
  void v9[3] = &unk_1E6A197F0;
  void v9[4] = v8;
  [v8 _updateCHIPAccessoryWithFabricLabel:v7 completionHandler:v9];
}

void __60__HMDHAPAccessory_CHIP___handleHomeNameChangedNotification___block_invoke_107(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x1D9452090]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = HMFGetLogIdentifier();
      int v8 = 138543618;
      id v9 = v7;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to update fabric label for accessory: %@", (uint8_t *)&v8, 0x16u);
    }
  }
}

- (void)handleCHIPSendRemoteRequestMessage:(id)a3 chipAccessoryServer:(id)a4
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    int v8 = [v6 dictionaryForKey:@"HMDHomeCHIPRequestMessageKey"];
    if (v8)
    {
      v19[0] = MEMORY[0x1E4F143A8];
      v19[1] = 3221225472;
      void v19[2] = __80__HMDHAPAccessory_CHIP__handleCHIPSendRemoteRequestMessage_chipAccessoryServer___block_invoke;
      v19[3] = &unk_1E6A18CB8;
      id v20 = v6;
      [v7 handleCHIPRemoteRequest:v8 completion:v19];
      id v9 = v20;
    }
    else
    {
      int v14 = (void *)MEMORY[0x1D9452090]();
      __int16 v15 = self;
      __int16 v16 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        __int16 v17 = HMFGetLogIdentifier();
        uint64_t v18 = [v6 messagePayload];
        *(_DWORD *)buf = 138543618;
        id v22 = v17;
        __int16 v23 = 2112;
        id v24 = v18;
        _os_log_impl(&dword_1D49D5000, v16, OS_LOG_TYPE_ERROR, "%{public}@Cannot find command in CHIP remote request message payload: %@", buf, 0x16u);
      }
      id v9 = [MEMORY[0x1E4F28C58] errorWithDomain:*MEMORY[0x1E4F64ED0] code:2 userInfo:0];
      [v6 respondWithError:v9];
    }
  }
  else
  {
    __int16 v10 = (void *)MEMORY[0x1D9452090]();
    id v11 = self;
    uint64_t v12 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      id v13 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v22 = v13;
      _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_ERROR, "%{public}@Could not find CHIP accessory server to handle remote request", buf, 0xCu);
    }
    int v8 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v6 respondWithError:v8];
  }
}

void __80__HMDHAPAccessory_CHIP__handleCHIPSendRemoteRequestMessage_chipAccessoryServer___block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  id v3 = *(void **)(a1 + 32);
  if (a3)
  {
    id v5 = a2;
    [v3 respondWithError:a3];
  }
  else
  {
    int v8 = @"HMDHomeCHIPResponseMessageKey";
    v9[0] = a2;
    id v6 = (void *)MEMORY[0x1E4F1C9E8];
    id v7 = a2;
    id v5 = [v6 dictionaryWithObjects:v9 forKeys:&v8 count:1];
    [v3 respondWithPayload:v5];
  }
}

- (void)respondToFetchCHIPPairingsMessage:(id)a3 pairings:(id)a4 systemCommissionerPairings:(id)a5 fetchError:(id)a6
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = a6;
  int v14 = [v11 allObjects];
  __int16 v15 = [(HMDHAPAccessory *)self matchingSystemCommissionerPairingForCHIPPairings:v14 amongSystemCommissionerPairings:v12];

  id v16 = v11;
  __int16 v17 = v16;
  if (v15)
  {
    uint64_t v18 = (void *)MEMORY[0x1D9452090]();
    uint64_t v19 = self;
    id v20 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      id v21 = HMFGetLogIdentifier();
      id v22 = [v15 uuid];
      *(_DWORD *)buf = 138543618;
      __int16 v31 = v21;
      __int16 v32 = 2112;
      __int16 v33 = v22;
      _os_log_impl(&dword_1D49D5000, v20, OS_LOG_TYPE_DEBUG, "%{public}@Updating raw CHIP pairings with system commissioner pairing UUID %@", buf, 0x16u);
    }
    v26[0] = MEMORY[0x1E4F143A8];
    v26[1] = 3221225472;
    v26[2] = __106__HMDHAPAccessory_CHIP__respondToFetchCHIPPairingsMessage_pairings_systemCommissionerPairings_fetchError___block_invoke;
    v26[3] = &unk_1E6A180F0;
    id v27 = v15;
    __int16 v17 = objc_msgSend(v16, "na_map:", v26);
  }
  uint64_t v28 = *MEMORY[0x1E4F2C158];
  __int16 v23 = v17;
  if (!v17)
  {
    __int16 v23 = [MEMORY[0x1E4F1CAD0] set];
  }
  id v24 = encodeRootObjectForIncomingXPCMessage(v23, 0);
  int v29 = v24;
  uint64_t v25 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v29 forKeys:&v28 count:1];
  [v10 respondWithPayload:v25];

  if (!v17) {
}
  }

id __106__HMDHAPAccessory_CHIP__respondToFetchCHIPPairingsMessage_pairings_systemCommissionerPairings_fetchError___block_invoke(uint64_t a1, void *a2)
{
  id v3 = (objc_class *)MEMORY[0x1E4F2E958];
  id v4 = a2;
  id v5 = [v3 alloc];
  id v6 = [v4 identifier];
  id v7 = [v4 home];

  int v8 = (void *)[v5 initWithIdentifier:v6 home:v7];
  id v9 = [*(id *)(a1 + 32) uuid];
  [v8 setSystemCommissionerPairingUUID:v9];

  return v8;
}

- (id)matchingSystemCommissionerPairingForCHIPPairings:(id)a3 amongSystemCommissionerPairings:(id)a4
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v38 = a4;
  id v7 = [(HMDAccessory *)self home];
  int v8 = [v7 homeManager];
  id v9 = [v8 accessoryBrowser];
  id v10 = [v9 chipAccessoryServerBrowser];
  id v11 = [v10 systemCommissionerFabricRootPublicKey];

  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  id v12 = v6;
  uint64_t v13 = [v12 countByEnumeratingWithState:&v43 objects:v48 count:16];
  if (v13)
  {
    uint64_t v14 = v13;
    uint64_t v15 = *(void *)v44;
    id v36 = v12;
    id v37 = v11;
    uint64_t v33 = *(void *)v44;
    do
    {
      uint64_t v16 = 0;
      uint64_t v34 = v14;
      do
      {
        if (*(void *)v44 != v15) {
          objc_enumerationMutation(v12);
        }
        __int16 v17 = *(void **)(*((void *)&v43 + 1) + 8 * v16);
        uint64_t v18 = objc_msgSend(v17, "operationalIdentity", v33);
        uint64_t v19 = [v18 rootPublicKey];
        int v20 = [v19 isEqual:v11];

        if (v20)
        {
          uint64_t v35 = v16;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          id v21 = v38;
          uint64_t v22 = [v21 countByEnumeratingWithState:&v39 objects:v47 count:16];
          if (v22)
          {
            uint64_t v23 = v22;
            uint64_t v24 = *(void *)v40;
            while (2)
            {
              for (uint64_t i = 0; i != v23; ++i)
              {
                if (*(void *)v40 != v24) {
                  objc_enumerationMutation(v21);
                }
                id v26 = *(void **)(*((void *)&v39 + 1) + 8 * i);
                id v27 = [v26 nodeID];
                uint64_t v28 = [v17 operationalIdentity];
                int v29 = [v28 nodeID];
                char v30 = [v27 isEqual:v29];

                if (v30)
                {
                  id v31 = v26;

                  id v12 = v36;
                  id v11 = v37;
                  goto LABEL_21;
                }
              }
              uint64_t v23 = [v21 countByEnumeratingWithState:&v39 objects:v47 count:16];
              if (v23) {
                continue;
              }
              break;
            }
          }

          id v12 = v36;
          id v11 = v37;
          uint64_t v15 = v33;
          uint64_t v14 = v34;
          uint64_t v16 = v35;
        }
        ++v16;
      }
      while (v16 != v14);
      uint64_t v14 = [v12 countByEnumeratingWithState:&v43 objects:v48 count:16];
      id v31 = 0;
    }
    while (v14);
  }
  else
  {
    id v31 = 0;
  }
LABEL_21:

  return v31;
}

- (void)updateCHIPAccessoryName:(id)a3
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self chipAccessoryServer];
  if (v5)
  {
    id v6 = (void *)MEMORY[0x1D9452090]();
    id v7 = self;
    int v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      int v10 = 138543874;
      id v11 = v9;
      __int16 v12 = 2112;
      id v13 = v4;
      __int16 v14 = 2112;
      uint64_t v15 = v5;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Updating CHIP accessory name to %@ for accessory server %@", (uint8_t *)&v10, 0x20u);
    }
    [v5 updateAccessoryName:v4];
  }
}

- (void)_updateCHIPAccessoryWithFabricLabel:(id)a3 completionHandler:(id)a4
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  int v8 = [(HMDHAPAccessory *)self chipAccessoryServer];
  id v9 = (void *)MEMORY[0x1D9452090]();
  int v10 = self;
  id v11 = HMFGetOSLogHandle();
  __int16 v12 = v11;
  if (v8)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      id v13 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543874;
      uint64_t v19 = v13;
      __int16 v20 = 2112;
      id v21 = v6;
      __int16 v22 = 2112;
      uint64_t v23 = v8;
      _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_INFO, "%{public}@Updating fabric label to %@ for accessory server %@", buf, 0x20u);
    }
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    void v16[2] = __79__HMDHAPAccessory_CHIP___updateCHIPAccessoryWithFabricLabel_completionHandler___block_invoke;
    v16[3] = &unk_1E6A19358;
    id v17 = v7;
    [v8 updateFabricLabel:v6 completionHandler:v16];
    __int16 v14 = v17;
  }
  else
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      uint64_t v19 = v15;
      __int16 v20 = 2112;
      id v21 = v6;
      _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_ERROR, "%{public}@Could not find CHIP accessory server to update fabric label to %@", buf, 0x16u);
    }
    __int16 v14 = [MEMORY[0x1E4F28C58] hmfErrorWithCode:11];
    (*((void (**)(id, void *))v7 + 2))(v7, v14);
  }
}

uint64_t __79__HMDHAPAccessory_CHIP___updateCHIPAccessoryWithFabricLabel_completionHandler___block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

- (void)_fetchPairingsAndUpdateTransaction
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v3 = [(HMDHAPAccessory *)self chipAccessoryServer];
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = self;
  id v6 = HMFGetOSLogHandle();
  id v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v8 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v12 = v8;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Fetching CHIP pairings", buf, 0xCu);
    }
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    id v10[2] = __59__HMDHAPAccessory_CHIP___fetchPairingsAndUpdateTransaction__block_invoke;
    void v10[3] = &unk_1E6A180C8;
    void v10[4] = v5;
    [v3 fetchPairingsWithCompletionHandler:v10];
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v9 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v12 = v9;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_ERROR, "%{public}@Could not find CHIP accessory server", buf, 0xCu);
    }
  }
}

void __59__HMDHAPAccessory_CHIP___fetchPairingsAndUpdateTransaction__block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  int v10 = v9;
  if (v7)
  {
    id v41 = v9;
    id v42 = v8;
    id v11 = [*(id *)(a1 + 32) home];
    __int16 v12 = [v11 homeManager];
    uint64_t v13 = *(void **)(a1 + 32);
    __int16 v14 = [v12 homes];
    uint64_t v15 = [v12 accessoryBrowser];
    uint64_t v16 = [v15 chipAccessoryServerBrowser];
    id v17 = [v13 rootPublicKeysOfHomes:v14 keychainDelegate:v16];

    uint64_t v18 = [v12 accessoryBrowser];
    uint64_t v19 = [v18 chipAccessoryServerBrowser];
    __int16 v20 = [v19 systemCommissionerFabricRootPublicKey];

    if (!v20)
    {
      id v21 = (void *)MEMORY[0x1D9452090]();
      id v22 = *(id *)(a1 + 32);
      uint64_t v23 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        id v47 = v24;
        _os_log_impl(&dword_1D49D5000, v23, OS_LOG_TYPE_ERROR, "%{public}@System commissioner fabric root public key unavailable to authenticate CHIP pairings", buf, 0xCu);
      }
    }
    uint64_t v25 = (void *)MEMORY[0x1E4F1CAD0];
    v43[0] = MEMORY[0x1E4F143A8];
    v43[1] = 3221225472;
    v43[2] = __59__HMDHAPAccessory_CHIP___fetchPairingsAndUpdateTransaction__block_invoke_97;
    v43[3] = &unk_1E6A180A0;
    id v26 = v17;
    id v44 = v26;
    id v27 = v20;
    id v45 = v27;
    uint64_t v28 = objc_msgSend(v7, "na_map:", v43);
    int v29 = [v25 setWithArray:v28];

    char v30 = [*(id *)(a1 + 32) chipStorage];
    id v31 = [v30 pairings];
    char v32 = [v31 isEqual:v29];

    if ((v32 & 1) == 0)
    {
      uint64_t v33 = [*(id *)(a1 + 32) transactionWithObjectChangeType:2];
      [v33 setChipPairings:v29];
      uint64_t v34 = [v11 backingStore];
      uint64_t v35 = +[HMDBackingStoreTransactionOptions defaultXPCOptions];
      id v36 = [v34 transaction:@"CHIP pairings changed" options:v35];

      [v36 add:v33];
      [v36 run];
    }
    int v10 = v41;
    id v8 = v42;
  }
  else
  {
    id v37 = (void *)MEMORY[0x1D9452090]();
    id v38 = *(id *)(a1 + 32);
    long long v39 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      long long v40 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v47 = v40;
      __int16 v48 = 2112;
      id v49 = v8;
      _os_log_impl(&dword_1D49D5000, v39, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch pairings from CHIP accessory server: %@", buf, 0x16u);
    }
  }
}

id __59__HMDHAPAccessory_CHIP___fetchPairingsAndUpdateTransaction__block_invoke_97(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  id v5 = [v3 rootPublicKey];
  if ([v4 containsObject:v5])
  {
    uint64_t v6 = 1;
  }
  else
  {
    id v7 = *(void **)(a1 + 40);
    id v8 = [v3 rootPublicKey];
    uint64_t v6 = [v7 isEqual:v8];
  }
  id v9 = (void *)[objc_alloc(MEMORY[0x1E4F2E698]) initWithHMMTRPairing:v3 ownedEcosystem:v6];

  return v9;
}

- (id)rootPublicKeysOfHomes:(id)a3 keychainDelegate:(id)a4
{
  id v6 = a4;
  uint64_t v12 = MEMORY[0x1E4F143A8];
  uint64_t v13 = 3221225472;
  __int16 v14 = __64__HMDHAPAccessory_CHIP__rootPublicKeysOfHomes_keychainDelegate___block_invoke;
  uint64_t v15 = &unk_1E6A18058;
  uint64_t v16 = self;
  id v17 = v6;
  id v7 = v6;
  id v8 = objc_msgSend(a3, "na_map:", &v12);
  id v9 = objc_msgSend(v8, "na_filter:", &__block_literal_global_96_181728, v12, v13, v14, v15, v16);

  int v10 = [MEMORY[0x1E4F1CAD0] setWithArray:v9];

  return v10;
}

id __64__HMDHAPAccessory_CHIP__rootPublicKeysOfHomes_keychainDelegate___block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 matterFabricID];
  id v5 = v4;
  if (v4 && ([v4 isEqual:&unk_1F2DC9E20] & 1) == 0)
  {
    id v7 = [*(id *)(a1 + 32) chipHomeDataSourceWithFabricID:v5 home:v3];
    id v8 = [*(id *)(a1 + 32) fabricDataFetcherWithCHIPStorageDelegate:v7 keychainDelegate:*(void *)(a1 + 40)];
    uint64_t v11 = 0;
    id v9 = [v8 locallyStoredFabricDataWithError:&v11];
    id v6 = [v9 rootPublicKey];
  }
  else
  {
    id v6 = 0;
  }

  return v6;
}

BOOL __64__HMDHAPAccessory_CHIP__rootPublicKeysOfHomes_keychainDelegate___block_invoke_2(uint64_t a1, uint64_t a2)
{
  return a2 != 0;
}

- (id)fabricDataFetcherWithCHIPStorageDelegate:(id)a3 keychainDelegate:(id)a4
{
  id v5 = (objc_class *)MEMORY[0x1E4F6A0D8];
  id v6 = a4;
  id v7 = a3;
  id v8 = (void *)[[v5 alloc] initWithCHIPStorageDelegate:v7 keychainDelegate:v6];

  return v8;
}

- (id)chipHomeDataSourceWithFabricID:(id)a3 home:(id)a4
{
  id v5 = a4;
  id v6 = a3;
  id v7 = [[HMDCHIPHomeDataSource alloc] initWithFabricID:v6 home:v5];

  return v7;
}

- (void)handleUpdatedPairings:(id)a3 previousPairings:(id)a4
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  id v8 = [MEMORY[0x1E4F1CA60] dictionary];
  long long v78 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  id v9 = v7;
  uint64_t v10 = [v9 countByEnumeratingWithState:&v78 objects:v90 count:16];
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)v79;
    do
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        if (*(void *)v79 != v12) {
          objc_enumerationMutation(v9);
        }
        __int16 v14 = *(void **)(*((void *)&v78 + 1) + 8 * i);
        uint64_t v15 = [v14 UUID];
        [v8 setObject:v14 forKeyedSubscript:v15];
      }
      uint64_t v11 = [v9 countByEnumeratingWithState:&v78 objects:v90 count:16];
    }
    while (v11);
  }

  uint64_t v16 = [MEMORY[0x1E4F1CA60] dictionary];
  long long v74 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  id v17 = v6;
  uint64_t v18 = [v17 countByEnumeratingWithState:&v74 objects:v89 count:16];
  if (v18)
  {
    uint64_t v19 = v18;
    uint64_t v20 = *(void *)v75;
    do
    {
      for (uint64_t j = 0; j != v19; ++j)
      {
        if (*(void *)v75 != v20) {
          objc_enumerationMutation(v17);
        }
        id v22 = *(void **)(*((void *)&v74 + 1) + 8 * j);
        uint64_t v23 = [v22 UUID];
        [v16 setObject:v22 forKeyedSubscript:v23];
      }
      uint64_t v19 = [v17 countByEnumeratingWithState:&v74 objects:v89 count:16];
    }
    while (v19);
  }

  if (([v8 isEqualToDictionary:v16] & 1) == 0)
  {
    uint64_t v24 = (void *)MEMORY[0x1D9452090]();
    uint64_t v25 = self;
    id v26 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
    {
      id v27 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543874;
      long long v84 = v27;
      __int16 v85 = 2112;
      long long v86 = v8;
      __int16 v87 = 2112;
      long long v88 = v16;
      _os_log_impl(&dword_1D49D5000, v26, OS_LOG_TYPE_INFO, "%{public}@Pairings changed from %@ to %@", buf, 0x20u);
    }
    uint64_t v28 = (void *)[v16 mutableCopy];
    int v29 = [v8 allKeys];
    [v28 removeObjectsForKeys:v29];

    char v30 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v67 = v28;
    id v31 = [v28 allValues];
    char v32 = [v30 setWithArray:v31];

    id v66 = v32;
    uint64_t v33 = objc_msgSend(v32, "na_filter:", &__block_literal_global_87);
    uint64_t v34 = (void *)[v8 mutableCopy];
    uint64_t v35 = [v16 allKeys];
    [v34 removeObjectsForKeys:v35];

    id v36 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v64 = v34;
    id v37 = [v34 allValues];
    id v38 = [v36 setWithArray:v37];

    long long v39 = objc_msgSend(v38, "na_filter:", &__block_literal_global_89_181736);
    __int16 v65 = v33;
    id v63 = v39;
    if ([v33 count] || objc_msgSend(v39, "count"))
    {
      uint64_t v59 = v38;
      id v60 = v17;
      id v61 = v9;
      unsigned __int16 v62 = v8;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      id obj = v33;
      uint64_t v40 = [obj countByEnumeratingWithState:&v70 objects:v82 count:16];
      if (v40)
      {
        uint64_t v41 = v40;
        uint64_t v42 = *(void *)v71;
        p_vtable = &OBJC_METACLASS___HMDDurationEventModel.vtable;
        do
        {
          uint64_t v44 = 0;
          uint64_t v68 = v41;
          do
          {
            if (*(void *)v71 != v42) {
              objc_enumerationMutation(obj);
            }
            id v45 = (void *)[objc_alloc((Class)(p_vtable + 182)) initWithAddedPairing:*(void *)(*((void *)&v70 + 1) + 8 * v44) accessory:v25];
            long long v46 = (void *)MEMORY[0x1D9452090]();
            id v47 = v25;
            __int16 v48 = HMFGetOSLogHandle();
            if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
            {
              HMFGetLogIdentifier();
              uint64_t v49 = v42;
              uint64_t v50 = v25;
              BOOL v51 = v16;
              v53 = long long v52 = p_vtable;
              *(_DWORD *)buf = 138543618;
              long long v84 = v53;
              __int16 v85 = 2112;
              long long v86 = v45;
              _os_log_impl(&dword_1D49D5000, v48, OS_LOG_TYPE_INFO, "%{public}@Inserting connected ecosystems changed bulletin: %@", buf, 0x16u);

              p_vtable = v52;
              uint64_t v16 = v51;
              uint64_t v25 = v50;
              uint64_t v42 = v49;
              uint64_t v41 = v68;
            }

            long long v54 = [(HMDHAPAccessory *)v47 bulletinBoard];
            [v54 insertConnectedCHIPEcosystemsChangedBulletin:v45];

            ++v44;
          }
          while (v41 != v44);
          uint64_t v41 = [obj countByEnumeratingWithState:&v70 objects:v82 count:16];
        }
        while (v41);
      }

      id v9 = v61;
      id v8 = v62;
      id v38 = v59;
      id v17 = v60;
      long long v39 = v63;
    }
    else
    {
      id v55 = (void *)MEMORY[0x1D9452090]();
      id v56 = v25;
      long long v57 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
      {
        id v58 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543362;
        long long v84 = v58;
        _os_log_impl(&dword_1D49D5000, v57, OS_LOG_TYPE_INFO, "%{public}@Not inserting connected ecosystems changed bulletin because all added/removed pairings are for Apple Home/System Commissioner", buf, 0xCu);

        long long v39 = v63;
      }
    }
  }
}

uint64_t __64__HMDHAPAccessory_CHIP__handleUpdatedPairings_previousPairings___block_invoke_2(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v5 = [v4 home];
  id v6 = [v5 ecosystem];
  id v7 = [v6 vendor];
  char v8 = [v7 isAppleVendor];
  if (v8)
  {
LABEL_4:
    uint64_t v10 = [v4 home];
    uint64_t v11 = [v10 ecosystem];
    uint64_t v12 = [v11 owned] ^ 1;

    id v9 = v14;
    if (v8) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  id v9 = [v4 home];
  id v2 = [v9 ecosystem];
  id v3 = [v2 vendor];
  if ([v3 isSystemCommissionerVendor])
  {
    __int16 v14 = v9;
    goto LABEL_4;
  }
  uint64_t v12 = 1;
LABEL_7:

LABEL_8:
  return v12;
}

uint64_t __64__HMDHAPAccessory_CHIP__handleUpdatedPairings_previousPairings___block_invoke(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v5 = [v4 home];
  id v6 = [v5 ecosystem];
  id v7 = [v6 vendor];
  char v8 = [v7 isAppleVendor];
  if (v8)
  {
LABEL_4:
    uint64_t v10 = [v4 home];
    uint64_t v11 = [v10 ecosystem];
    uint64_t v12 = [v11 owned] ^ 1;

    id v9 = v14;
    if (v8) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  id v9 = [v4 home];
  id v2 = [v9 ecosystem];
  id v3 = [v2 vendor];
  if ([v3 isSystemCommissionerVendor])
  {
    __int16 v14 = v9;
    goto LABEL_4;
  }
  uint64_t v12 = 1;
LABEL_7:

LABEL_8:
  return v12;
}

- (void)_handleActivateCHIPPairingModeAndCreateSetupPayloadStringMessage:(id)a3
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self chipAccessoryServer];
  if (v5)
  {
    uint64_t v6 = [(id)objc_opt_class() chipPairingModeActiveDuration];
    double v8 = v7;
    id v9 = (void *)MEMORY[0x1D9452090](v6);
    uint64_t v10 = self;
    uint64_t v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      uint64_t v12 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v21 = v12;
      __int16 v22 = 2048;
      double v23 = v8;
      _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_INFO, "%{public}@Opening CHIP pairing window with PIN for duration: %fs", buf, 0x16u);
    }
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    void v18[2] = __90__HMDHAPAccessory_CHIP___handleActivateCHIPPairingModeAndCreateSetupPayloadStringMessage___block_invoke;
    v18[3] = &unk_1E6A18010;
    v18[4] = v10;
    id v19 = v4;
    [v5 openPairingWindowWithPINForDuration:v18 completionHandler:v8];
  }
  else
  {
    uint64_t v13 = (void *)MEMORY[0x1D9452090]();
    __int16 v14 = self;
    uint64_t v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v21 = v16;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_ERROR, "%{public}@Could not find CHIP accessory server to handle activate CHIP pairing mode and create setup payload string message", buf, 0xCu);
    }
    id v17 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v4 respondWithError:v17];
  }
}

void __90__HMDHAPAccessory_CHIP___handleActivateCHIPPairingModeAndCreateSetupPayloadStringMessage___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    double v7 = *(void **)(a1 + 40);
    uint64_t v14 = *MEMORY[0x1E4F2C160];
    id v15 = v5;
    double v8 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v15 forKeys:&v14 count:1];
    [v7 respondWithPayload:v8];
  }
  else
  {
    id v9 = (void *)MEMORY[0x1D9452090]();
    id v10 = *(id *)(a1 + 32);
    uint64_t v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v17 = v12;
      __int16 v18 = 2112;
      id v19 = v6;
      _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_ERROR, "%{public}@Failed to open CHIP pairing window with PIN: %@", buf, 0x16u);
    }
    uint64_t v13 = *(void **)(a1 + 40);
    double v8 = [MEMORY[0x1E4F28C58] hmErrorWithCode:-1];
    [v13 respondWithError:v8];
  }
}

- (void)_handleActivateCHIPPairingModeMessage:(id)a3
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self chipAccessoryServer];
  if (v5)
  {
    uint64_t v6 = [(id)objc_opt_class() chipPairingModeActiveDuration];
    double v8 = v7;
    id v9 = (void *)MEMORY[0x1D9452090](v6);
    id v10 = self;
    uint64_t v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      uint64_t v12 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v21 = v12;
      __int16 v22 = 2048;
      double v23 = v8;
      _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_INFO, "%{public}@Opening CHIP pairing window for duration: %fs", buf, 0x16u);
    }
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    void v18[2] = __63__HMDHAPAccessory_CHIP___handleActivateCHIPPairingModeMessage___block_invoke;
    v18[3] = &unk_1E6A196E0;
    v18[4] = v10;
    id v19 = v4;
    [v5 openPairingWindowForDuration:v18 completionHandler:v8];
  }
  else
  {
    uint64_t v13 = (void *)MEMORY[0x1D9452090]();
    uint64_t v14 = self;
    id v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v21 = v16;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_ERROR, "%{public}@Could not find CHIP accessory server to handle activate CHIP pairing mode message", buf, 0xCu);
    }
    id v17 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v4 respondWithError:v17];
  }
}

void __63__HMDHAPAccessory_CHIP___handleActivateCHIPPairingModeMessage___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x1D9452090]();
    id v5 = *(id *)(a1 + 32);
    uint64_t v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      double v7 = HMFGetLogIdentifier();
      int v10 = 138543618;
      uint64_t v11 = v7;
      __int16 v12 = 2112;
      id v13 = v3;
      _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to open CHIP pairing window: %@", (uint8_t *)&v10, 0x16u);
    }
    double v8 = *(void **)(a1 + 40);
    id v9 = [MEMORY[0x1E4F28C58] hmErrorWithCode:-1];
    [v8 respondWithError:v9];
  }
  else
  {
    [*(id *)(a1 + 40) respondWithSuccess];
  }
}

- (void)_handleRemoveCHIPPairingsMessage:(id)a3
{
  v64[2] = *MEMORY[0x1E4F143B8];
  id v35 = a3;
  id v37 = [(HMDHAPAccessory *)self chipAccessoryServer];
  if (v37)
  {
    v64[0] = objc_opt_class();
    v64[1] = objc_opt_class();
    id v4 = [MEMORY[0x1E4F1C978] arrayWithObjects:v64 count:2];
    id v5 = [v35 unarchivedObjectForKey:*MEMORY[0x1E4F2C158] ofClasses:v4];

    uint64_t v6 = (void *)MEMORY[0x1D9452090]();
    uint64_t v41 = self;
    double v7 = HMFGetOSLogHandle();
    double v8 = v7;
    if (v5)
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        id v9 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v5;
        _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@Removing CHIP pairings: %@", buf, 0x16u);
      }
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000;
      char v63 = 0;
      dispatch_group_t group = dispatch_group_create();
      long long v53 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      id obj = v5;
      int v10 = v41;
      uint64_t v39 = [obj countByEnumeratingWithState:&v53 objects:v61 count:16];
      if (v39)
      {
        uint64_t v38 = *(void *)v54;
        do
        {
          for (uint64_t i = 0; i != v39; ++i)
          {
            if (*(void *)v54 != v38) {
              objc_enumerationMutation(obj);
            }
            id v45 = *(void **)(*((void *)&v53 + 1) + 8 * i);
            dispatch_group_enter(group);
            uint64_t v42 = [(HMDAccessory *)v10 home];
            long long v43 = [v42 homeManager];
            uint64_t v11 = [v45 home];
            __int16 v12 = [v11 ecosystem];
            id v13 = [v12 vendor];
            if (([v13 isAppleVendor] & 1) == 0)
            {

LABEL_16:
              id v26 = [v45 chipPluginPairing];
              v49[0] = MEMORY[0x1E4F143A8];
              v49[1] = 3221225472;
              v49[2] = __58__HMDHAPAccessory_CHIP___handleRemoveCHIPPairingsMessage___block_invoke_81;
              v49[3] = &unk_1E6A17FE8;
              v49[4] = v41;
              v49[5] = v45;
              v50[1] = buf;
              v50[0] = group;
              [v37 removePairing:v26 completionHandler:v49];

              uint64_t v25 = (id *)v50;
              goto LABEL_17;
            }
            uint64_t v14 = [v45 home];
            id v15 = [v14 ecosystem];
            uint64_t v16 = [v15 rootPublicKey];
            id v17 = [v43 accessoryBrowser];
            __int16 v18 = [v17 chipAccessoryServerBrowser];
            id v19 = [v18 appleHomeFabricRootPublicKey];
            int v20 = [v16 isEqual:v19];

            if (!v20) {
              goto LABEL_16;
            }
            id v21 = (void *)MEMORY[0x1D9452090]();
            __int16 v22 = v41;
            HMFGetOSLogHandle();
            double v23 = (id)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
            {
              uint64_t v24 = HMFGetLogIdentifier();
              *(_DWORD *)long long v57 = 138543618;
              id v58 = v24;
              __int16 v59 = 2112;
              id v60 = v45;
              _os_log_impl(&dword_1D49D5000, v23, OS_LOG_TYPE_INFO, "%{public}@Pairing is from apple ecosystem, removing accessory from HomeKit: %@", v57, 0x16u);
            }
            v51[0] = MEMORY[0x1E4F143A8];
            v51[1] = 3221225472;
            v51[2] = __58__HMDHAPAccessory_CHIP___handleRemoveCHIPPairingsMessage___block_invoke;
            v51[3] = &unk_1E6A17FE8;
            v51[4] = v22;
            v51[5] = v45;
            v52[1] = buf;
            v52[0] = group;
            [v42 handleRemoveAccessory:v22 completion:v51];
            uint64_t v25 = (id *)v52;
LABEL_17:

            int v10 = v41;
          }
          uint64_t v39 = [obj countByEnumeratingWithState:&v53 objects:v61 count:16];
        }
        while (v39);
      }

      id v27 = [(HMDAccessory *)v41 workQueue];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __58__HMDHAPAccessory_CHIP___handleRemoveCHIPPairingsMessage___block_invoke_82;
      block[3] = &unk_1E6A19A00;
      __int16 v48 = buf;
      void block[4] = v41;
      id v47 = v35;
      dispatch_group_notify(group, v27, block);

      _Block_object_dispose(buf, 8);
    }
    else
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        char v32 = HMFGetLogIdentifier();
        uint64_t v33 = [v35 messagePayload];
        *(_DWORD *)buf = 138543618;
        *(void *)&uint8_t buf[4] = v32;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v33;
        _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_ERROR, "%{public}@Could not find CHIP pairings in remote CHIP pairings message payload: %@", buf, 0x16u);
      }
      uint64_t v34 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
      [v35 respondWithError:v34];

      id obj = 0;
    }
  }
  else
  {
    uint64_t v28 = (void *)MEMORY[0x1D9452090]();
    int v29 = self;
    char v30 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      id v31 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      *(void *)&uint8_t buf[4] = v31;
      _os_log_impl(&dword_1D49D5000, v30, OS_LOG_TYPE_ERROR, "%{public}@Could not find CHIP accessory server to handle remove CHIP pairings message", buf, 0xCu);
    }
    id obj = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v35 respondWithError:obj];
  }
}

void __58__HMDHAPAccessory_CHIP___handleRemoveCHIPPairingsMessage___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = HMFGetOSLogHandle();
  double v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      double v8 = HMFGetLogIdentifier();
      uint64_t v9 = *(void *)(a1 + 40);
      int v12 = 138543618;
      id v13 = v8;
      __int16 v14 = 2112;
      uint64_t v15 = v9;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to remove chip accessory from HomeKit: %@", (uint8_t *)&v12, 0x16u);
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v10 = HMFGetLogIdentifier();
      uint64_t v11 = *(void *)(a1 + 40);
      int v12 = 138543618;
      id v13 = v10;
      __int16 v14 = 2112;
      uint64_t v15 = v11;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Successfully removed chip accessory from HomeKit: %@", (uint8_t *)&v12, 0x16u);
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

void __58__HMDHAPAccessory_CHIP___handleRemoveCHIPPairingsMessage___block_invoke_81(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = HMFGetOSLogHandle();
  double v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      double v8 = HMFGetLogIdentifier();
      uint64_t v9 = *(void *)(a1 + 40);
      int v12 = 138543874;
      id v13 = v8;
      __int16 v14 = 2112;
      uint64_t v15 = v9;
      __int16 v16 = 2112;
      id v17 = v3;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to remove CHIP pairing %@: %@", (uint8_t *)&v12, 0x20u);
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v10 = HMFGetLogIdentifier();
      uint64_t v11 = *(void *)(a1 + 40);
      int v12 = 138543618;
      id v13 = v10;
      __int16 v14 = 2112;
      uint64_t v15 = v11;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Successfully removed CHIP pairing: %@", (uint8_t *)&v12, 0x16u);
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

void __58__HMDHAPAccessory_CHIP___handleRemoveCHIPPairingsMessage___block_invoke_82(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v2 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  id v3 = (void *)MEMORY[0x1D9452090]();
  id v4 = *(id *)(a1 + 32);
  id v5 = HMFGetOSLogHandle();
  uint64_t v6 = v5;
  if (v2)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      double v7 = HMFGetLogIdentifier();
      int v11 = 138543362;
      int v12 = v7;
      _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to remove some CHIP pairings", (uint8_t *)&v11, 0xCu);
    }
    double v8 = *(void **)(a1 + 40);
    uint64_t v9 = [MEMORY[0x1E4F28C58] hmErrorWithCode:-1];
    [v8 respondWithError:v9];
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      int v10 = HMFGetLogIdentifier();
      int v11 = 138543362;
      int v12 = v10;
      _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_INFO, "%{public}@Successfully removed CHIP pairings", (uint8_t *)&v11, 0xCu);
    }
    [*(id *)(a1 + 40) respondWithSuccess];
  }
}

- (void)_handleFetchCHIPPairingsMessage:(id)a3
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self chipAccessoryServer];
  uint64_t v6 = (void *)MEMORY[0x1D9452090]();
  double v7 = self;
  double v8 = HMFGetOSLogHandle();
  uint64_t v9 = v8;
  if (v5)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      int v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v21 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Fetching locally cached CHIP pairings", buf, 0xCu);
    }
    int v11 = [(HMDHAPAccessory *)v7 bridge];
    if (!v11) {
      int v11 = v7;
    }
    int v12 = [(HMDHAPAccessory *)v11 chipStorage];
    uint64_t v13 = [v12 pairings];
    __int16 v14 = v13;
    if (!v13)
    {
      __int16 v14 = [MEMORY[0x1E4F1CAD0] set];
    }
    uint64_t v15 = encodeRootObjectForIncomingXPCMessage(v14, 0);
    id v19 = v15;
    __int16 v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v19 forKeys:&v18 count:1];
    [v4 respondWithPayload:v16];

    if (!v13) {
  }
    }
  else
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      id v17 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v21 = v17;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_ERROR, "%{public}@Could not find CHIP accessory server to handle fetch CHIP pairings message", buf, 0xCu);
    }
    int v11 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v4 respondWithError:v11];
  }
}

- (void)_removeSystemCommissionerPairingFromAccessoryPairings:(id)a3 completion:(id)a4
{
  id v6 = a4;
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 3221225472;
  void v19[2] = __90__HMDHAPAccessory_CHIP___removeSystemCommissionerPairingFromAccessoryPairings_completion___block_invoke;
  v19[3] = &unk_1E6A17F70;
  void v19[4] = self;
  double v7 = objc_msgSend(a3, "na_firstObjectPassingTest:", v19);
  if (v7)
  {
    double v8 = [(HMDAccessory *)self home];
    uint64_t v9 = [v8 homeManager];
    int v10 = [v9 accessoryBrowserInternal];
    int v11 = [v10 chipAccessoryServerBrowser];
    int v12 = [v11 systemCommissionerPairingManager];

    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    v15[2] = __90__HMDHAPAccessory_CHIP___removeSystemCommissionerPairingFromAccessoryPairings_completion___block_invoke_2;
    v15[3] = &unk_1E6A17FC0;
    v15[4] = self;
    id v18 = v6;
    id v16 = v7;
    id v17 = v12;
    id v13 = v12;
    [v13 fetchSystemCommissionerPairingsWithCompletionHandler:v15];
  }
  else
  {
    __int16 v14 = _Block_copy(v6);
    id v13 = v14;
    if (v14) {
      (*((void (**)(void *, void))v14 + 2))(v14, 0);
    }
  }
}

uint64_t __90__HMDHAPAccessory_CHIP___removeSystemCommissionerPairingFromAccessoryPairings_completion___block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 home];
  id v5 = [v4 ecosystem];
  id v6 = [v5 vendor];
  if ([v6 isSystemCommissionerVendor])
  {
    id v17 = [v3 home];
    id v16 = [v17 ecosystem];
    [v16 rootPublicKey];
    double v7 = v15 = v4;
    double v8 = [*(id *)(a1 + 32) home];
    uint64_t v9 = [v8 homeManager];
    int v10 = [v9 accessoryBrowser];
    int v11 = [v10 chipAccessoryServerBrowser];
    int v12 = [v11 systemCommissionerFabricRootPublicKey];
    uint64_t v13 = [v7 isEqual:v12];

    id v4 = v15;
  }
  else
  {
    uint64_t v13 = 0;
  }

  return v13;
}

void __90__HMDHAPAccessory_CHIP___removeSystemCommissionerPairingFromAccessoryPairings_completion___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    v26[0] = MEMORY[0x1E4F143A8];
    v26[1] = 3221225472;
    v26[2] = __90__HMDHAPAccessory_CHIP___removeSystemCommissionerPairingFromAccessoryPairings_completion___block_invoke_78;
    v26[3] = &unk_1E6A17F98;
    id v27 = *(id *)(a1 + 40);
    double v7 = objc_msgSend(v5, "na_firstObjectPassingTest:", v26);
    double v8 = v7;
    if (v7)
    {
      uint64_t v9 = *(void **)(a1 + 48);
      int v10 = [v7 uuid];
      v24[0] = MEMORY[0x1E4F143A8];
      v24[1] = 3221225472;
      id v24[2] = __90__HMDHAPAccessory_CHIP___removeSystemCommissionerPairingFromAccessoryPairings_completion___block_invoke_80;
      id v24[3] = &unk_1E6A17D78;
      void v24[4] = *(void *)(a1 + 32);
      id v25 = *(id *)(a1 + 56);
      [v9 removeSystemCommissionerPairingWithUUID:v10 completionHandler:v24];
    }
    else
    {
      id v17 = (void *)MEMORY[0x1D9452090]();
      id v18 = *(id *)(a1 + 32);
      id v19 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        int v20 = HMFGetLogIdentifier();
        id v21 = *(void **)(a1 + 40);
        *(_DWORD *)buf = 138543618;
        int v29 = v20;
        __int16 v30 = 2112;
        id v31 = v21;
        _os_log_impl(&dword_1D49D5000, v19, OS_LOG_TYPE_ERROR, "%{public}@Could not find matching system commissioner pairing for accessory pairing: %@", buf, 0x16u);
      }
      uint64_t v22 = (void (**)(void *, void *))_Block_copy(*(const void **)(a1 + 56));
      if (v22)
      {
        double v23 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
        v22[2](v22, v23);
      }
    }

    id v16 = v27;
  }
  else
  {
    int v11 = (void *)MEMORY[0x1D9452090]();
    id v12 = *(id *)(a1 + 32);
    uint64_t v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      __int16 v14 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      int v29 = v14;
      __int16 v30 = 2112;
      id v31 = v6;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch system commissioner pairings: %@", buf, 0x16u);
    }
    uint64_t v15 = _Block_copy(*(const void **)(a1 + 56));
    id v16 = v15;
    if (v15) {
      (*((void (**)(void *, id))v15 + 2))(v15, v6);
    }
  }
}

uint64_t __90__HMDHAPAccessory_CHIP___removeSystemCommissionerPairingFromAccessoryPairings_completion___block_invoke_78(uint64_t a1, void *a2)
{
  id v3 = [a2 nodeID];
  id v4 = [*(id *)(a1 + 32) identifier];
  uint64_t v5 = [v3 isEqualToNumber:v4];

  return v5;
}

void __90__HMDHAPAccessory_CHIP___removeSystemCommissionerPairingFromAccessoryPairings_completion___block_invoke_80(uint64_t a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  double v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      double v8 = HMFGetLogIdentifier();
      int v13 = 138543618;
      __int16 v14 = v8;
      __int16 v15 = 2112;
      id v16 = v3;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to remove system commissioner pairing from matter locker: %@", (uint8_t *)&v13, 0x16u);
    }
    uint64_t v9 = (void (**)(void *, void *))_Block_copy(*(const void **)(a1 + 40));
    if (v9)
    {
      int v10 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
      v9[2](v9, v10);
    }
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v11 = HMFGetLogIdentifier();
      int v13 = 138543362;
      __int16 v14 = v11;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Successfully removed system commissioner pairing from matter locker", (uint8_t *)&v13, 0xCu);
    }
    id v12 = (void (**)(void *, void *))_Block_copy(*(const void **)(a1 + 40));
    uint64_t v9 = v12;
    if (v12) {
      v12[2](v12, 0);
    }
  }
}

- (void)handleGetAccessoryDiagnosticEventsMessage:(id)a3
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = self;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v6 = v5;
  }
  else {
    id v6 = 0;
  }
  double v7 = v6;

  double v8 = (void *)MEMORY[0x1D9452090]();
  uint64_t v9 = v5;
  int v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    int v11 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    id v21 = v11;
    _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_DEBUG, "%{public}@Handling GetAccessoryDiagnosticEvenetsMessage", buf, 0xCu);
  }
  if (v7 && [(HMDHAPAccessory *)v7 communicationProtocol] == 2)
  {
    id v12 = [(HMDHAPAccessory *)v7 accessoryDiagnosticEvents];
    int v13 = (void *)MEMORY[0x1D9452090]();
    __int16 v14 = v9;
    __int16 v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      id v16 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543618;
      id v21 = v16;
      __int16 v22 = 2112;
      double v23 = v12;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_DEBUG, "%{public}@Read accessory diagnostic events: %@", buf, 0x16u);
    }
    id v18 = @"Events";
    id v19 = v12;
    uint64_t v17 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v19 forKeys:&v18 count:1];
    [v4 respondWithPayload:v17];
  }
  else
  {
    id v12 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48 description:@"This Accessory type does not support diagnostic events" reason:0 suggestion:0];
    [v4 respondWithError:v12];
  }
}

- (void)handleGetAccessoryDiagnosticCountersMessage:(id)a3
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = self;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v6 = v5;
  }
  else {
    id v6 = 0;
  }
  double v7 = v6;

  double v8 = (void *)MEMORY[0x1D9452090]();
  uint64_t v9 = v5;
  int v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    int v11 = HMFGetLogIdentifier();
    int v17 = 138543362;
    id v18 = v11;
    _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_DEBUG, "%{public}@Handling GetAccessoryDiagnosticCountersMessage", (uint8_t *)&v17, 0xCu);
  }
  if (v7 && [(HMDHAPAccessory *)v7 communicationProtocol] == 2)
  {
    id v12 = [(HMDHAPAccessory *)v7 accessoryDiagnosticCounters];
    int v13 = (void *)MEMORY[0x1D9452090]();
    __int16 v14 = v9;
    __int16 v15 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      id v16 = HMFGetLogIdentifier();
      int v17 = 138543618;
      id v18 = v16;
      __int16 v19 = 2112;
      int v20 = v12;
      _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_DEBUG, "%{public}@Read accessory diagnostic: %@", (uint8_t *)&v17, 0x16u);
    }
    [v4 respondWithPayload:v12];
  }
  else
  {
    id v12 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48 description:@"This Accessory type does not support diagnostic counters" reason:0 suggestion:0];
    [v4 respondWithError:v12];
  }
}

- (void)handleGetStartUpColorTemperature:(id)a3
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = self;
  double v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    double v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    uint64_t v21 = v8;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@handleGetStartUpColorTemperature", buf, 0xCu);
  }
  uint64_t v9 = v6;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    int v10 = v9;
  }
  else {
    int v10 = 0;
  }
  int v11 = v10;

  if (v11
    && ([(HMDHAPAccessory *)v9 chipAccessoryServer],
        id v12 = objc_claimAutoreleasedReturnValue(),
        v12,
        v12))
  {
    int v13 = [(HMDHAPAccessory *)v9 chipAccessoryServer];
    __int16 v14 = [v13 identifier];
    __int16 v15 = [(HMDHAPAccessory *)v9 hapInstanceId];
    id v16 = [(HMDHAPAccessory *)v9 matchingHAPAccessoryWithServerIdentifier:v14 instanceID:v15];

    int v17 = [(HMDHAPAccessory *)v9 chipAccessoryServer];
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    void v18[2] = __58__HMDHAPAccessory_CHIP__handleGetStartUpColorTemperature___block_invoke;
    v18[3] = &unk_1E6A17F48;
    v18[4] = v9;
    id v19 = v4;
    [v17 fetchColorControlClusterForHapAccessory:v16 completionHandler:v18];
  }
  else
  {
    id v16 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
    [v4 respondWithError:v16];
  }
}

void __58__HMDHAPAccessory_CHIP__handleGetStartUpColorTemperature___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  double v7 = v6;
  if (!v5 || v6)
  {
    uint64_t v9 = (void *)MEMORY[0x1D9452090]();
    id v10 = *(id *)(a1 + 32);
    int v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      id v12 = HMFGetLogIdentifier();
      int v13 = [*(id *)(a1 + 32) name];
      *(_DWORD *)buf = 138543618;
      id v19 = v12;
      __int16 v20 = 2112;
      uint64_t v21 = v13;
      _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch color control cluster from accessory: %@", buf, 0x16u);
    }
    __int16 v14 = *(void **)(a1 + 40);
    __int16 v15 = [MEMORY[0x1E4F28C58] hmErrorWithCode:-1];
    [v14 respondWithError:v15];
  }
  else
  {
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    void v16[2] = __58__HMDHAPAccessory_CHIP__handleGetStartUpColorTemperature___block_invoke_65;
    v16[3] = &unk_1E6A17F20;
    double v8 = *(void **)(a1 + 40);
    void v16[4] = *(void *)(a1 + 32);
    id v17 = v8;
    [v5 readStartUpColorTemperatureWithCompletion:v16];
  }
}

void __58__HMDHAPAccessory_CHIP__handleGetStartUpColorTemperature___block_invoke_65(uint64_t a1, void *a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  double v7 = (void *)MEMORY[0x1D9452090]();
  id v8 = *(id *)(a1 + 32);
  uint64_t v9 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    id v10 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    id v17 = v10;
    __int16 v18 = 2112;
    id v19 = v5;
    _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@handleGetStartUpColorTemperature responding with startUpColorTemperature: %@", buf, 0x16u);
  }
  int v11 = *(void **)(a1 + 40);
  __int16 v14 = @"kStartUpColorTemperatureKey";
  id v12 = v5;
  if (!v5)
  {
    id v12 = objc_msgSend(MEMORY[0x1E4F1CA98], "null", v14);
  }
  __int16 v15 = v12;
  int v13 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v15 forKeys:&v14 count:1];
  [v11 respondWithPayload:v13];

  if (!v5) {
}
  }

- (void)handleSetStartUpColorTemperature:(id)a3
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = self;
  double v7 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543362;
    uint64_t v24 = v8;
    _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@handleSetStartUpColorTemperature", buf, 0xCu);
  }
  uint64_t v9 = v6;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v10 = v9;
  }
  else {
    id v10 = 0;
  }
  int v11 = v10;

  if (v11
    && ([(HMDHAPAccessory *)v9 chipAccessoryServer],
        id v12 = objc_claimAutoreleasedReturnValue(),
        v12,
        v12))
  {
    int v13 = [v4 messagePayload];
    __int16 v14 = [v13 objectForKeyedSubscript:@"kStartUpColorTemperatureKey"];

    if (v14)
    {
      __int16 v15 = [(HMDHAPAccessory *)v9 chipAccessoryServer];
      id v16 = [v15 identifier];
      id v17 = [(HMDHAPAccessory *)v9 hapInstanceId];
      __int16 v18 = [(HMDHAPAccessory *)v9 matchingHAPAccessoryWithServerIdentifier:v16 instanceID:v17];

      id v19 = [(HMDHAPAccessory *)v9 chipAccessoryServer];
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 3221225472;
      v20[2] = __58__HMDHAPAccessory_CHIP__handleSetStartUpColorTemperature___block_invoke;
      v20[3] = &unk_1E6A17EF8;
      void v20[4] = v9;
      id v21 = v4;
      id v22 = v14;
      [v19 fetchColorControlClusterForHapAccessory:v18 completionHandler:v20];
    }
    else
    {
      __int16 v18 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
      [v4 respondWithError:v18];
    }
  }
  else
  {
    __int16 v14 = [MEMORY[0x1E4F28C58] hmErrorWithCode:48];
    [v4 respondWithError:v14];
  }
}

void __58__HMDHAPAccessory_CHIP__handleSetStartUpColorTemperature___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  double v7 = v6;
  if (!v5 || v6)
  {
    uint64_t v9 = (void *)MEMORY[0x1D9452090]();
    id v10 = *(id *)(a1 + 32);
    int v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      id v12 = HMFGetLogIdentifier();
      int v13 = [*(id *)(a1 + 32) name];
      *(_DWORD *)buf = 138543618;
      uint64_t v20 = v12;
      __int16 v21 = 2112;
      id v22 = v13;
      _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_ERROR, "%{public}@Failed to fetch color control cluster from accessory: %@", buf, 0x16u);
    }
    __int16 v14 = *(void **)(a1 + 40);
    __int16 v15 = [MEMORY[0x1E4F28C58] hmErrorWithCode:-1];
    [v14 respondWithError:v15];
  }
  else
  {
    id v8 = *(void **)(a1 + 48);
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    void v16[2] = __58__HMDHAPAccessory_CHIP__handleSetStartUpColorTemperature___block_invoke_63;
    v16[3] = &unk_1E6A18BA0;
    void v16[4] = *(void *)(a1 + 32);
    id v17 = v8;
    id v18 = *(id *)(a1 + 40);
    [v5 writeStartUpColorTemperature:v17 completion:v16];
  }
}

void __58__HMDHAPAccessory_CHIP__handleSetStartUpColorTemperature___block_invoke_63(uint64_t a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    double v7 = HMFGetLogIdentifier();
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = [*(id *)(a1 + 32) name];
    int v11 = 138544130;
    id v12 = v7;
    __int16 v13 = 2112;
    uint64_t v14 = v8;
    __int16 v15 = 2112;
    id v16 = v9;
    __int16 v17 = 2112;
    id v18 = v3;
    _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_INFO, "%{public}@Startup color temperature: %@ set on accessory: %@ with error: %@", (uint8_t *)&v11, 0x2Au);
  }
  id v10 = *(void **)(a1 + 48);
  if (v3) {
    [v10 respondWithError:v3];
  }
  else {
    [v10 respondWithSuccess];
  }
}

- (void)handleClearCredentialMessage:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self chipAccessoryServer];
  id v6 = [MEMORY[0x1E4F65430] untrackedPlaceholderFlow];
  double v7 = [v5 createDoorLockClusterObjectWithFlow:v6];
  uint64_t v8 = [v7 naFuture];
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 3221225472;
  void v19[2] = __54__HMDHAPAccessory_CHIP__handleClearCredentialMessage___block_invoke;
  v19[3] = &unk_1E6A17EA8;
  id v9 = v4;
  id v20 = v9;
  id v10 = [v8 flatMap:v19];
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 3221225472;
  void v17[2] = __54__HMDHAPAccessory_CHIP__handleClearCredentialMessage___block_invoke_2;
  v17[3] = &unk_1E6A17ED0;
  id v11 = v9;
  id v18 = v11;
  id v12 = [v10 addSuccessBlock:v17];
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  v15[2] = __54__HMDHAPAccessory_CHIP__handleClearCredentialMessage___block_invoke_3;
  v15[3] = &unk_1E6A197F0;
  id v16 = v11;
  id v13 = v11;
  id v14 = (id)[v12 addFailureBlock:v15];
}

id __54__HMDHAPAccessory_CHIP__handleClearCredentialMessage___block_invoke(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = *MEMORY[0x1E4F2C280];
  id v5 = a2;
  id v6 = [v3 numberForKey:v4];
  double v7 = [*(id *)(a1 + 32) numberForKey:*MEMORY[0x1E4F2C290]];
  uint64_t v8 = [v6 integerValue];
  id v9 = [MEMORY[0x1E4F65430] untrackedPlaceholderFlow];
  id v10 = [v5 clearCredentialAtIndex:v8 withCredentialType:v7 flow:v9];

  id v11 = [v10 naFuture];

  return v11;
}

uint64_t __54__HMDHAPAccessory_CHIP__handleClearCredentialMessage___block_invoke_2(uint64_t a1)
{
  return [*(id *)(a1 + 32) respondWithSuccess];
}

uint64_t __54__HMDHAPAccessory_CHIP__handleClearCredentialMessage___block_invoke_3(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) respondWithError:a2];
}

- (void)handleClearUserMessage:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self chipAccessoryServer];
  id v6 = [MEMORY[0x1E4F65430] untrackedPlaceholderFlow];
  double v7 = [v5 createDoorLockClusterObjectWithFlow:v6];
  uint64_t v8 = [v7 naFuture];
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 3221225472;
  void v19[2] = __48__HMDHAPAccessory_CHIP__handleClearUserMessage___block_invoke;
  v19[3] = &unk_1E6A17EA8;
  id v9 = v4;
  id v20 = v9;
  id v10 = [v8 flatMap:v19];
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 3221225472;
  void v17[2] = __48__HMDHAPAccessory_CHIP__handleClearUserMessage___block_invoke_2;
  v17[3] = &unk_1E6A17ED0;
  id v11 = v9;
  id v18 = v11;
  id v12 = [v10 addSuccessBlock:v17];
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  v15[2] = __48__HMDHAPAccessory_CHIP__handleClearUserMessage___block_invoke_3;
  v15[3] = &unk_1E6A197F0;
  id v16 = v11;
  id v13 = v11;
  id v14 = (id)[v12 addFailureBlock:v15];
}

id __48__HMDHAPAccessory_CHIP__handleClearUserMessage___block_invoke(uint64_t a1, void *a2)
{
  int v2 = *(void **)(a1 + 32);
  uint64_t v3 = *MEMORY[0x1E4F2C298];
  id v4 = a2;
  id v5 = [v2 numberForKey:v3];
  uint64_t v6 = [v5 integerValue];
  double v7 = [MEMORY[0x1E4F65430] untrackedPlaceholderFlow];
  uint64_t v8 = [v4 clearUserAtIndex:v6 flow:v7];

  id v9 = [v8 naFuture];

  return v9;
}

uint64_t __48__HMDHAPAccessory_CHIP__handleClearUserMessage___block_invoke_2(uint64_t a1)
{
  return [*(id *)(a1 + 32) respondWithSuccess];
}

uint64_t __48__HMDHAPAccessory_CHIP__handleClearUserMessage___block_invoke_3(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) respondWithError:a2];
}

- (void)handleGetAllUsersMessage:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self chipAccessoryServer];
  uint64_t v6 = [MEMORY[0x1E4F65430] untrackedPlaceholderFlow];
  double v7 = [v5 createDoorLockClusterObjectWithFlow:v6];
  uint64_t v8 = [v7 naFuture];
  id v9 = [v8 flatMap:&__block_literal_global_181785];
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  void v16[2] = __50__HMDHAPAccessory_CHIP__handleGetAllUsersMessage___block_invoke_3;
  v16[3] = &unk_1E6A17E80;
  id v10 = v4;
  id v17 = v10;
  id v11 = [v9 addSuccessBlock:v16];
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  v14[2] = __50__HMDHAPAccessory_CHIP__handleGetAllUsersMessage___block_invoke_4;
  v14[3] = &unk_1E6A197F0;
  id v15 = v10;
  id v12 = v10;
  id v13 = (id)[v11 addFailureBlock:v14];
}

void __50__HMDHAPAccessory_CHIP__handleGetAllUsersMessage___block_invoke_3(uint64_t a1, void *a2)
{
  v7[1] = *MEMORY[0x1E4F143B8];
  int v2 = *(void **)(a1 + 32);
  uint64_t v6 = *MEMORY[0x1E4F2C350];
  v7[0] = a2;
  uint64_t v3 = (void *)MEMORY[0x1E4F1C9E8];
  id v4 = a2;
  id v5 = [v3 dictionaryWithObjects:v7 forKeys:&v6 count:1];
  [v2 respondWithPayload:v5];
}

uint64_t __50__HMDHAPAccessory_CHIP__handleGetAllUsersMessage___block_invoke_4(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) respondWithError:a2];
}

id __50__HMDHAPAccessory_CHIP__handleGetAllUsersMessage___block_invoke(uint64_t a1, void *a2)
{
  int v2 = [a2 getAllUsers];
  uint64_t v3 = [v2 naFuture];
  id v4 = [v3 flatMap:&__block_literal_global_55_181788];

  return v4;
}

id __50__HMDHAPAccessory_CHIP__handleGetAllUsersMessage___block_invoke_2(uint64_t a1, void *a2)
{
  int v2 = (void *)MEMORY[0x1E4F7A0D8];
  uint64_t v3 = [a2 componentsJoinedByString:@"\n"];
  id v4 = [v2 futureWithResult:v3];

  return v4;
}

- (void)handleRemoveCorrespondingSystemCommissionerMessage:(id)a3
{
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self chipStorage];
  uint64_t v6 = [v5 pairings];
  double v7 = v6;
  if (v6)
  {
    id v8 = v6;
  }
  else
  {
    id v8 = [MEMORY[0x1E4F1CAD0] set];
  }
  id v9 = v8;

  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = __76__HMDHAPAccessory_CHIP__handleRemoveCorrespondingSystemCommissionerMessage___block_invoke;
  v11[3] = &unk_1E6A197F0;
  id v12 = v4;
  id v10 = v4;
  [(HMDHAPAccessory *)self _removeSystemCommissionerPairingFromAccessoryPairings:v9 completion:v11];
}

uint64_t __76__HMDHAPAccessory_CHIP__handleRemoveCorrespondingSystemCommissionerMessage___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) respondWithSuccess];
}

- (void)handleActivateCHIPPairingModeAndCreateSetupPayloadStringMessage:(id)a3
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self primaryResidentMessageRouter];
  uint64_t v6 = v5;
  if (v5)
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __89__HMDHAPAccessory_CHIP__handleActivateCHIPPairingModeAndCreateSetupPayloadStringMessage___block_invoke;
    v12[3] = &unk_1E6A17E18;
    void v12[4] = self;
    [v5 routeMessage:v4 localHandler:v12];
  }
  else
  {
    double v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = self;
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v14 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_ERROR, "%{public}@Could not find primary resident message router to handle activate CHIP pairing mode and create setup payload string message", buf, 0xCu);
    }
    id v11 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v4 respondWithError:v11];
  }
}

uint64_t __89__HMDHAPAccessory_CHIP__handleActivateCHIPPairingModeAndCreateSetupPayloadStringMessage___block_invoke(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _handleActivateCHIPPairingModeAndCreateSetupPayloadStringMessage:a2];
}

- (void)handleActivateCHIPPairingModeMessage:(id)a3
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self primaryResidentMessageRouter];
  uint64_t v6 = v5;
  if (v5)
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __62__HMDHAPAccessory_CHIP__handleActivateCHIPPairingModeMessage___block_invoke;
    v12[3] = &unk_1E6A17E18;
    void v12[4] = self;
    [v5 routeMessage:v4 localHandler:v12];
  }
  else
  {
    double v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = self;
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      id v14 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_ERROR, "%{public}@Could not find primary resident message router to handle activate CHIP pairing mode message", buf, 0xCu);
    }
    id v11 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v4 respondWithError:v11];
  }
}

uint64_t __62__HMDHAPAccessory_CHIP__handleActivateCHIPPairingModeMessage___block_invoke(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _handleActivateCHIPPairingModeMessage:a2];
}

- (void)handleRemoveCHIPPairingsMessage:(id)a3
{
  id v24[2] = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self primaryResidentMessageRouter];
  if (v5)
  {
    uint64_t v6 = *MEMORY[0x1E4F2C158];
    v24[0] = objc_opt_class();
    v24[1] = objc_opt_class();
    double v7 = [MEMORY[0x1E4F1C978] arrayWithObjects:v24 count:2];
    id v8 = [v4 unarchivedObjectForKey:v6 ofClasses:v7];

    if (v8)
    {
      [(HMDHAPAccessory *)self _removeSystemCommissionerPairingFromAccessoryPairings:v8 completion:0];
      v19[0] = MEMORY[0x1E4F143A8];
      v19[1] = 3221225472;
      void v19[2] = __57__HMDHAPAccessory_CHIP__handleRemoveCHIPPairingsMessage___block_invoke;
      v19[3] = &unk_1E6A17E18;
      void v19[4] = self;
      [v5 routeMessage:v4 localHandler:v19];
    }
    else
    {
      id v13 = (void *)MEMORY[0x1D9452090]();
      id v14 = self;
      uint64_t v15 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        id v16 = HMFGetLogIdentifier();
        id v17 = [v4 messagePayload];
        *(_DWORD *)buf = 138543618;
        __int16 v21 = v16;
        __int16 v22 = 2112;
        uint64_t v23 = v17;
        _os_log_impl(&dword_1D49D5000, v15, OS_LOG_TYPE_ERROR, "%{public}@Could not find pairings in CHIP pairings message payload: %@", buf, 0x16u);
      }
      id v18 = [MEMORY[0x1E4F28C58] hmErrorWithCode:20];
      [v4 respondWithError:v18];

      id v8 = 0;
    }
  }
  else
  {
    id v9 = (void *)MEMORY[0x1D9452090]();
    id v10 = self;
    id v11 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      id v12 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      __int16 v21 = v12;
      _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_ERROR, "%{public}@Could not find primary resident message router to handle remove CHIP pairings message", buf, 0xCu);
    }
    id v8 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v4 respondWithError:v8];
  }
}

uint64_t __57__HMDHAPAccessory_CHIP__handleRemoveCHIPPairingsMessage___block_invoke(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _handleRemoveCHIPPairingsMessage:a2];
}

- (void)handleFetchCHIPPairingsMessage:(id)a3
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self primaryResidentMessageRouter];
  if (v5)
  {
    uint64_t v6 = (void *)[v4 copy];
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __56__HMDHAPAccessory_CHIP__handleFetchCHIPPairingsMessage___block_invoke;
    v12[3] = &unk_1E6A17DF0;
    void v12[4] = self;
    id v13 = v4;
    [v6 setResponseHandler:v12];
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = __56__HMDHAPAccessory_CHIP__handleFetchCHIPPairingsMessage___block_invoke_2;
    v11[3] = &unk_1E6A17E18;
    void v11[4] = self;
    [v5 routeMessage:v6 localHandler:v11];
  }
  else
  {
    double v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = self;
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v15 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_ERROR, "%{public}@Could not find primary resident message router to handle fetch CHIP pairings message", buf, 0xCu);
    }
    uint64_t v6 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    [v4 respondWithError:v6];
  }
}

void __56__HMDHAPAccessory_CHIP__handleFetchCHIPPairingsMessage___block_invoke(uint64_t a1, void *a2, void *a3)
{
  v31[2] = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *MEMORY[0x1E4F2C158];
  v31[0] = objc_opt_class();
  v31[1] = objc_opt_class();
  id v8 = [MEMORY[0x1E4F1C978] arrayWithObjects:v31 count:2];
  id v9 = objc_msgSend(v6, "hmf_unarchivedObjectForKey:ofClasses:", v7, v8);

  id v10 = (void *)MEMORY[0x1D9452090]();
  id v11 = *(id *)(a1 + 32);
  id v12 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    id v13 = HMFGetLogIdentifier();
    *(_DWORD *)buf = 138543618;
    uint64_t v28 = v13;
    __int16 v29 = 2112;
    __int16 v30 = v9;
    _os_log_impl(&dword_1D49D5000, v12, OS_LOG_TYPE_DEBUG, "%{public}@Fetched raw CHIP pairings: %@", buf, 0x16u);
  }
  id v14 = [*(id *)(a1 + 32) home];
  uint64_t v15 = [v14 homeManager];

  if (v15)
  {
    uint64_t v16 = [v15 accessoryBrowser];
    id v17 = [v16 chipAccessoryServerBrowser];
    id v18 = [v17 systemCommissionerPairingManager];

    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    id v24[2] = __56__HMDHAPAccessory_CHIP__handleFetchCHIPPairingsMessage___block_invoke_47;
    void v24[3] = &unk_1E6A17DC8;
    uint64_t v19 = *(void **)(a1 + 40);
    void v24[4] = *(void *)(a1 + 32);
    id v25 = v19;
    id v26 = v9;
    [v18 fetchSystemCommissionerPairingsWithCompletionHandler:v24];
  }
  else
  {
    id v20 = (void *)MEMORY[0x1D9452090]();
    id v21 = *(id *)(a1 + 32);
    __int16 v22 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v28 = v23;
      _os_log_impl(&dword_1D49D5000, v22, OS_LOG_TYPE_DEFAULT, "%{public}@Home manager was nil while determining system commissioner pairing UUID", buf, 0xCu);
    }
    [*(id *)(a1 + 32) respondToFetchCHIPPairingsMessage:*(void *)(a1 + 40) pairings:v9 systemCommissionerPairings:MEMORY[0x1E4F1CBF0] fetchError:0];
  }
}

uint64_t __56__HMDHAPAccessory_CHIP__handleFetchCHIPPairingsMessage___block_invoke_2(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _handleFetchCHIPPairingsMessage:a2];
}

uint64_t __56__HMDHAPAccessory_CHIP__handleFetchCHIPPairingsMessage___block_invoke_47(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) respondToFetchCHIPPairingsMessage:*(void *)(a1 + 40) pairings:*(void *)(a1 + 48) systemCommissionerPairings:a2 fetchError:a3];
}

- (void)resetAccessoryDiagnosticCounters
{
  id v7 = [(HMDHAPAccessory *)self chipAccessoryServer];
  if (v7)
  {
    uint64_t v3 = [(HMDAccessory *)self identifier];
    id v4 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v3];
    [v7 resetThreadNetworkDiagnosticsCountForAccessory:v4];

    id v5 = [(HMDAccessory *)self identifier];
    id v6 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v5];
    [v7 resetWiFiNetworkDiagnosticsCountForAccessory:v6];
  }
}

- (NSArray)accessoryDiagnosticEvents
{
  uint64_t v3 = [(HMDHAPAccessory *)self chipAccessoryServer];
  id v4 = [(HMDAccessory *)self identifier];
  id v5 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v4];
  id v6 = [v3 readPastDiagnosticEventsFromAccessory:v5 fromEventNumber:0];

  return (NSArray *)v6;
}

- (NSDictionary)accessoryDiagnosticCounters
{
  uint64_t v3 = [(HMDHAPAccessory *)self chipAccessoryServer];
  id v4 = [(HMDAccessory *)self identifier];
  id v5 = [(HMDHAPAccessory *)self matchingHAPAccessoryWithServerIdentifier:v4];
  id v6 = [v3 collectDiagnosticsForAccessory:v5];

  return (NSDictionary *)v6;
}

- (unint64_t)_threadRSSIToLinkQuality:(id)a3
{
  id v3 = a3;
  id v4 = v3;
  if (v3)
  {
    int v5 = [v3 intValue];
    uint64_t v6 = 3;
    uint64_t v7 = 1;
    if (v5 > 0xFFFFFFAB) {
      uint64_t v7 = 2;
    }
    if (v5 <= 0xFFFFFFBA) {
      uint64_t v6 = v7;
    }
    if (v5 <= -55) {
      unint64_t v8 = v6;
    }
    else {
      unint64_t v8 = 4;
    }
  }
  else
  {
    unint64_t v8 = 0;
  }

  return v8;
}

- (unint64_t)_wifiRSSIToLinkQuality:(id)a3
{
  id v3 = a3;
  id v4 = v3;
  if (v3)
  {
    int v5 = [v3 intValue];
    uint64_t v6 = 3;
    uint64_t v7 = 1;
    if (v5 > 0xFFFFFFBA) {
      uint64_t v7 = 2;
    }
    if (v5 <= 0xFFFFFFBF) {
      uint64_t v6 = v7;
    }
    if (v5 <= -55) {
      unint64_t v8 = v6;
    }
    else {
      unint64_t v8 = 4;
    }
  }
  else
  {
    unint64_t v8 = 0;
  }

  return v8;
}

- (void)getLinkQualityForAccessory:(id)a3 forMessage:(id)a4
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  unint64_t v8 = [(HMDHAPAccessory *)self chipAccessoryServer];
  if ([v8 isReachable])
  {
    uint64_t v42 = v7;
    id v9 = [v8 getConnectNetworkIDForAccessory:v6];
    id v10 = [v9 objectForKeyedSubscript:*MEMORY[0x1E4F6A128]];
    id v11 = [v8 getOperationalNetworkAddressForAccessory:v6];
    uint64_t v12 = [v11 objectForKeyedSubscript:*MEMORY[0x1E4F6A120]];
    uint64_t v13 = [v8 linkLayerType];
    uint64_t v14 = v13;
    uint64_t v40 = v11;
    uint64_t v41 = v9;
    if (v13 == 4)
    {
      id v18 = [v8 getThreadNetworkLinkQualityForAccessory:v6];
      long long v43 = [v18 objectForKeyedSubscript:*MEMORY[0x1E4F6A168]];
      uint64_t v39 = v18;
      uint64_t v19 = [v18 objectForKeyedSubscript:*MEMORY[0x1E4F6A1B8]];
      id v20 = v19;
      if (v19)
      {
        id v21 = v19;

        id v10 = v21;
      }
      unint64_t v37 = [(HMDHAPAccessory *)self _threadRSSIToLinkQuality:v43];

      uint64_t v38 = 0;
      uint64_t v16 = 0;
      uint64_t v14 = 4;
    }
    else if (v13 == 1)
    {
      uint64_t v15 = [v8 getWiFiNetworkLinkQualityForAccessory:v6];
      uint64_t v38 = [v15 objectForKeyedSubscript:*MEMORY[0x1E4F6A180]];
      uint64_t v16 = [v38 BOOLValue];
      uint64_t v39 = v15;
      long long v43 = [v15 objectForKeyedSubscript:*MEMORY[0x1E4F6A1B0]];
      unint64_t v37 = -[HMDHAPAccessory _wifiRSSIToLinkQuality:](self, "_wifiRSSIToLinkQuality:");
    }
    else
    {
      unint64_t v37 = 0;
      uint64_t v38 = 0;
      long long v43 = 0;
      uint64_t v16 = 0;
      uint64_t v39 = 0;
    }
    if (v10) {
      __int16 v22 = v10;
    }
    else {
      __int16 v22 = &stru_1F2C9F1A8;
    }
    if (v12) {
      uint64_t v23 = (__CFString *)v12;
    }
    else {
      uint64_t v23 = &stru_1F2C9F1A8;
    }
    uint64_t v24 = (void *)MEMORY[0x1D9452090]();
    id v25 = self;
    id v26 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
    {
      id v27 = HMFGetLogIdentifier();
      HAPLinkLayerTypeDescription();
      id v35 = v6;
      uint64_t v28 = v36 = v14;
      HMFBooleanToString();
      __int16 v30 = v29 = v16;
      *(_DWORD *)buf = 138544642;
      id v47 = v27;
      __int16 v48 = 2112;
      uint64_t v49 = v28;
      __int16 v50 = 2112;
      BOOL v51 = v30;
      __int16 v52 = 2112;
      long long v53 = v43;
      __int16 v54 = 2112;
      long long v55 = v22;
      __int16 v56 = 2112;
      long long v57 = v23;
      _os_log_impl(&dword_1D49D5000, v26, OS_LOG_TYPE_INFO, "%{public}@[LinkQuality] Read linkLayerType: %@, supported: %@ RSSI: %@, networkID: %@, hardwareAddress: %@", buf, 0x3Eu);

      uint64_t v16 = v29;
      id v6 = v35;
      uint64_t v14 = v36;
    }
    v44[0] = @"kAccessoryLinkQualitySupportedKey";
    id v31 = [NSNumber numberWithBool:v16];
    v45[0] = v31;
    v44[1] = @"kAccessoryLinkLayerTypeKey";
    uint64_t v32 = [NSNumber numberWithInteger:v14];
    v45[1] = v32;
    v44[2] = @"kAccessoryLinkQualityKey";
    uint64_t v33 = [NSNumber numberWithUnsignedInteger:v37];
    v45[2] = v33;
    v45[3] = v22;
    v44[3] = @"kAccessoryNetworkNameKey";
    v44[4] = @"kAccessoryMacAddressKey";
    v45[4] = v23;
    uint64_t v34 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v45 forKeys:v44 count:5];
    id v7 = v42;
    [v42 respondWithPayload:v34];
  }
  else
  {
    id v17 = [MEMORY[0x1E4F28C58] hmErrorWithCode:4 description:@"Accessory is not reachable" reason:0 suggestion:0];
    [v7 respondWithError:v17];
  }
}

- (BOOL)hmmtrHasThreadServer:(id)a3
{
  id v3 = a3;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  BOOL v5 = 0;
  if (v3 && (isKindOfClass & 1) != 0) {
    BOOL v5 = [v3 linkLayerType] == 4;
  }

  return v5;
}

- (BOOL)hmmtrHasBLEServer:(id)a3
{
  id v3 = a3;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  BOOL v5 = 0;
  if (v3 && (isKindOfClass & 1) != 0) {
    BOOL v5 = [v3 linkLayerType] == 3;
  }

  return v5;
}

- (BOOL)hmmtrHasIPServer:(id)a3
{
  id v3 = a3;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  BOOL v5 = 0;
  if (v3 && (isKindOfClass & 1) != 0) {
    BOOL v5 = (unint64_t)([v3 linkLayerType] - 1) < 2;
  }

  return v5;
}

- (BOOL)isHMMTRAccessoryServer:(id)a3
{
  id v3 = a3;
  objc_opt_class();
  BOOL v4 = objc_opt_isKindOfClass() & (v3 != 0);

  return v4;
}

- (void)setCHIPReportHandler:(id)a3
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  BOOL v5 = [(HMDHAPAccessory *)self chipAccessoryServer];
  id v6 = v5;
  if (v5)
  {
    [v5 setCHIPReportHandler:v4];
  }
  else
  {
    id v7 = (void *)MEMORY[0x1D9452090]();
    unint64_t v8 = self;
    id v9 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = HMFGetLogIdentifier();
      int v11 = 138543362;
      uint64_t v12 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_ERROR, "%{public}@Could not find CHIP accessory server to set report handler", (uint8_t *)&v11, 0xCu);
    }
  }
}

- (void)handleCHIPSendRemoteRequestMessage:(id)a3
{
  id v4 = a3;
  BOOL v5 = [(HMDHAPAccessory *)self chipAccessoryServer];
  if (v5)
  {
    [(HMDHAPAccessory *)self handleCHIPSendRemoteRequestMessage:v4 chipAccessoryServer:v5];
  }
  else
  {
    id v6 = [(HMDAccessory *)self home];
    id v7 = [v6 homeManager];
    unint64_t v8 = [v7 accessoryBrowser];
    id v9 = [v8 chipAccessoryServerBrowser];
    id v10 = [(HMDHAPAccessory *)self matterNodeID];
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = __60__HMDHAPAccessory_CHIP__handleCHIPSendRemoteRequestMessage___block_invoke;
    v11[3] = &unk_1E6A17DA0;
    void v11[4] = self;
    id v12 = v4;
    [v9 discoverAccessoryServerWithNodeID:v10 completion:v11];
  }
}

uint64_t __60__HMDHAPAccessory_CHIP__handleCHIPSendRemoteRequestMessage___block_invoke(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) handleCHIPSendRemoteRequestMessage:*(void *)(a1 + 40) chipAccessoryServer:a2];
}

- (NSNumber)chipNodeId
{
  int v2 = [(HMDHAPAccessory *)self chipAccessoryServer];
  id v3 = [v2 chipNodeId];

  return (NSNumber *)v3;
}

- (void)handleUpdatedCHIPPropertiesOnAccessoryModel:(id)a3 actions:(id)a4
{
  v112[1] = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  id v8 = v6;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v9 = v8;
  }
  else {
    id v9 = 0;
  }
  id v10 = v9;
  long long v104 = v8;

  int v11 = [(HMDHAPAccessory *)self chipStorage];
  id v12 = (void *)[v11 copy];

  uint64_t v13 = [(HMDHAPAccessory *)self chipStorage];
  int v14 = [v13 updateUsingAccessoryModel:v10];

  if (v14)
  {
    uint64_t v15 = [v12 pairings];
    if (v15)
    {
      uint64_t v16 = (void *)v15;
      id v17 = [v12 pairings];
      id v18 = [(HMDHAPAccessory *)self chipStorage];
      uint64_t v19 = [v18 pairings];
      char v20 = [v17 isEqualToSet:v19];

      if ((v20 & 1) == 0)
      {
        id v21 = [(HMDHAPAccessory *)self chipStorage];
        __int16 v22 = [v21 pairings];
        uint64_t v23 = [v12 pairings];
        [(HMDHAPAccessory *)self handleUpdatedPairings:v22 previousPairings:v23];
      }
    }
    BOOL v24 = (unint64_t)[v7 source] < 2;
    long long v111 = @"HMDAccessoryCHIPStorageIsLocalChangeNotificationKey";
    id v25 = [NSNumber numberWithBool:v24];
    v112[0] = v25;
    id v26 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v112 forKeys:&v111 count:1];

    logAndPostNotification(@"HMDAccessoryCHIPStorageUpdatedNotification", self, v26);
    [v7 markChanged];
  }
  id v27 = [v10 chipVendorID];

  long long v102 = v12;
  if (!v27) {
    goto LABEL_21;
  }
  uint64_t v28 = [(HMDHAPAccessory *)self matterVendorID];
  if (v28)
  {
    uint64_t v29 = (void *)v28;
    __int16 v30 = [(HMDHAPAccessory *)self matterVendorID];
    if ([v30 isEqualToNumber:&unk_1F2DC9E20])
    {
      id v31 = [(HMDHAPAccessory *)self matterVendorID];
      uint64_t v32 = [v10 chipVendorID];
      char v33 = HMFEqualObjects();

      if ((v33 & 1) == 0) {
        goto LABEL_13;
      }
    }
    else
    {
    }
    long long v43 = [(HMDHAPAccessory *)self matterVendorID];
    uint64_t v44 = [v10 chipVendorID];

    if (v43 != v44)
    {
      uint64_t v41 = v7;
      id v45 = (void *)MEMORY[0x1D9452090]();
      long long v46 = self;
      id v47 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        __int16 v48 = HMFGetLogIdentifier();
        uint64_t v49 = [v10 chipVendorID];
        __int16 v50 = [(HMDHAPAccessory *)v46 matterVendorID];
        *(_DWORD *)buf = 138543874;
        long long v106 = v48;
        __int16 v107 = 2112;
        long long v108 = v49;
        __int16 v109 = 2112;
        long long v110 = v50;
        _os_log_impl(&dword_1D49D5000, v47, OS_LOG_TYPE_ERROR, "%{public}@Matter accessory vendorID cannot be set to %@, is already set to %@", buf, 0x20u);
      }
      goto LABEL_22;
    }
LABEL_21:
    uint64_t v41 = v7;
LABEL_22:
    int v42 = 0;
    goto LABEL_23;
  }
LABEL_13:
  uint64_t v34 = (void *)MEMORY[0x1D9452090]();
  id v35 = self;
  uint64_t v36 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
  {
    unint64_t v37 = HMFGetLogIdentifier();
    uint64_t v38 = [(HMDHAPAccessory *)v35 matterVendorID];
    uint64_t v39 = [v10 chipVendorID];
    *(_DWORD *)buf = 138543874;
    long long v106 = v37;
    __int16 v107 = 2112;
    long long v108 = v38;
    __int16 v109 = 2112;
    long long v110 = v39;
    _os_log_impl(&dword_1D49D5000, v36, OS_LOG_TYPE_INFO, "%{public}@Updating Matter accessory vendorID from %@ to %@", buf, 0x20u);
  }
  uint64_t v40 = [v10 chipVendorID];
  [(HMDHAPAccessory *)v35 setMatterVendorID:v40];

  uint64_t v41 = v7;
  [v7 markChanged];
  int v42 = 1;
LABEL_23:
  BOOL v51 = objc_msgSend(v10, "chipProductID", v102);

  if (!v51) {
    goto LABEL_36;
  }
  uint64_t v52 = [(HMDHAPAccessory *)self matterProductID];
  if (v52)
  {
    long long v53 = (void *)v52;
    __int16 v54 = [(HMDHAPAccessory *)self matterProductID];
    if ([v54 isEqualToNumber:&unk_1F2DC9E20])
    {
      long long v55 = [(HMDHAPAccessory *)self matterProductID];
      __int16 v56 = [v10 chipProductID];
      char v57 = HMFEqualObjects();

      if ((v57 & 1) == 0) {
        goto LABEL_27;
      }
    }
    else
    {
    }
    __int16 v65 = [(HMDHAPAccessory *)self matterProductID];
    id v66 = [v10 chipProductID];

    if (v65 != v66)
    {
      uint64_t v67 = (void *)MEMORY[0x1D9452090]();
      uint64_t v68 = self;
      long long v69 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
      {
        long long v70 = HMFGetLogIdentifier();
        long long v71 = [v10 chipProductID];
        long long v72 = [(HMDHAPAccessory *)v68 matterProductID];
        *(_DWORD *)buf = 138543874;
        long long v106 = v70;
        __int16 v107 = 2112;
        long long v108 = v71;
        __int16 v109 = 2112;
        long long v110 = v72;
        _os_log_impl(&dword_1D49D5000, v69, OS_LOG_TYPE_ERROR, "%{public}@Matter accessory productID cannot be set to %@, is already set to %@", buf, 0x20u);
      }
      if ((v42 & 1) == 0) {
        goto LABEL_42;
      }
      goto LABEL_37;
    }
LABEL_36:
    if (!v42) {
      goto LABEL_42;
    }
    goto LABEL_37;
  }
LABEL_27:
  uint64_t v58 = (void *)MEMORY[0x1D9452090]();
  __int16 v59 = self;
  id v60 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
  {
    id v61 = HMFGetLogIdentifier();
    unsigned __int16 v62 = [(HMDHAPAccessory *)v59 matterProductID];
    char v63 = [v10 chipProductID];
    *(_DWORD *)buf = 138543874;
    long long v106 = v61;
    __int16 v107 = 2112;
    long long v108 = v62;
    __int16 v109 = 2112;
    long long v110 = v63;
    _os_log_impl(&dword_1D49D5000, v60, OS_LOG_TYPE_INFO, "%{public}@Updating Matter accessory productID from %@ to %@", buf, 0x20u);
  }
  uint64_t v64 = [v10 chipProductID];
  [(HMDHAPAccessory *)v59 setMatterProductID:v64];

  [v41 markChanged];
LABEL_37:
  uint64_t v73 = [(HMDHAPAccessory *)self matterVendorID];
  if (!v73) {
    goto LABEL_42;
  }
  long long v74 = (void *)v73;
  uint64_t v75 = [(HMDHAPAccessory *)self matterProductID];
  if (!v75) {
    goto LABEL_41;
  }
  long long v76 = (void *)v75;
  long long v77 = [(HMDHAPAccessory *)self matterVendorID];
  if ([v77 isEqualToNumber:&unk_1F2DC9E20])
  {

LABEL_41:
    goto LABEL_42;
  }
  long long v100 = [(HMDHAPAccessory *)self matterProductID];
  char v101 = [v100 isEqualToNumber:&unk_1F2DC9E20];

  if ((v101 & 1) == 0) {
    logAndPostNotification(@"HMDAccessoryVendorIDProductIDUpdatedNotification", self, 0);
  }
LABEL_42:
  long long v78 = [v10 supportedLinkLayerTypes];

  if (!v78) {
    goto LABEL_54;
  }
  uint64_t v79 = [(HMDHAPAccessory *)self supportedLinkLayerTypes];
  if (!v79) {
    goto LABEL_46;
  }
  long long v80 = (void *)v79;
  long long v81 = [(HMDHAPAccessory *)self supportedLinkLayerTypes];
  if ([v81 isEqualToNumber:&unk_1F2DC9E20])
  {
    long long v82 = [(HMDHAPAccessory *)self supportedLinkLayerTypes];
    long long v83 = [v10 supportedLinkLayerTypes];
    char v84 = HMFEqualObjects();

    if ((v84 & 1) == 0)
    {
LABEL_46:
      __int16 v85 = (void *)MEMORY[0x1D9452090]();
      long long v86 = self;
      __int16 v87 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v87, OS_LOG_TYPE_INFO))
      {
        long long v88 = HMFGetLogIdentifier();
        long long v89 = [(HMDHAPAccessory *)v86 supportedLinkLayerTypes];
        __int16 v90 = [v10 supportedLinkLayerTypes];
        *(_DWORD *)buf = 138543874;
        long long v106 = v88;
        __int16 v107 = 2112;
        long long v108 = v89;
        __int16 v109 = 2112;
        long long v110 = v90;
        _os_log_impl(&dword_1D49D5000, v87, OS_LOG_TYPE_INFO, "%{public}@Updating matter accessory supported link layer types from %@ to %@", buf, 0x20u);
      }
      uint64_t v91 = [v10 supportedLinkLayerTypes];
      [(HMDHAPAccessory *)v86 setSupportedLinkLayerTypes:v91];

      [v41 markChanged];
      goto LABEL_54;
    }
  }
  else
  {
  }
  __int16 v92 = [(HMDHAPAccessory *)self supportedLinkLayerTypes];
  uint64_t v93 = [v10 supportedLinkLayerTypes];

  if (v92 != v93)
  {
    long long v94 = (void *)MEMORY[0x1D9452090]();
    __int16 v95 = self;
    long long v96 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
    {
      long long v97 = HMFGetLogIdentifier();
      long long v98 = [v10 supportedLinkLayerTypes];
      long long v99 = [(HMDHAPAccessory *)v95 supportedLinkLayerTypes];
      *(_DWORD *)buf = 138543874;
      long long v106 = v97;
      __int16 v107 = 2112;
      long long v108 = v98;
      __int16 v109 = 2112;
      long long v110 = v99;
      _os_log_impl(&dword_1D49D5000, v96, OS_LOG_TYPE_ERROR, "%{public}@Matter accessory supported link layer types cannot be set to %@, is already set to %@", buf, 0x20u);
    }
  }
LABEL_54:
}

void __47__HMDHAPAccessory_CHIP__configureCHIPAccessory__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    id v4 = (void *)MEMORY[0x1D9452090]();
    id v5 = *(id *)(a1 + 32);
    id v6 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = HMFGetLogIdentifier();
      int v8 = 138543618;
      id v9 = v7;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_ERROR, "%{public}@Failed to update fabric label for accessory: %@", (uint8_t *)&v8, 0x16u);
    }
  }
  [*(id *)(a1 + 32) _fetchPairingsAndUpdateTransaction];
}

- (void)removeAllCHIPPairingsWithCompletion:(id)a3
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [(HMDHAPAccessory *)self chipAccessoryServer];
  id v6 = (void *)MEMORY[0x1D9452090]();
  id v7 = self;
  int v8 = HMFGetOSLogHandle();
  id v9 = v8;
  if (v5)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      __int16 v10 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v16 = v10;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Removing all CHIP pairings", buf, 0xCu);
    }
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    id v13[2] = __61__HMDHAPAccessory_CHIP__removeAllCHIPPairingsWithCompletion___block_invoke;
    v13[3] = &unk_1E6A17D78;
    void v13[4] = v7;
    id v14 = v4;
    [v5 removeAllPairingsWithCompletionHandler:v13];
  }
  else
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      id v11 = HMFGetLogIdentifier();
      *(_DWORD *)buf = 138543362;
      uint64_t v16 = v11;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_ERROR, "%{public}@Could not find CHIP accessory server to handle remove all CHIP pairings request", buf, 0xCu);
    }
    uint64_t v12 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    (*((void (**)(id, void *))v4 + 2))(v4, v12);
  }
}

void __61__HMDHAPAccessory_CHIP__removeAllCHIPPairingsWithCompletion___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  id v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v8 = HMFGetLogIdentifier();
      int v12 = 138543618;
      uint64_t v13 = v8;
      __int16 v14 = 2112;
      id v15 = v3;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_ERROR, "%{public}@Failed to remove all CHIP pairings: %@", (uint8_t *)&v12, 0x16u);
    }
    uint64_t v9 = *(void *)(a1 + 40);
    __int16 v10 = [MEMORY[0x1E4F28C58] hmErrorWithCode:-1];
    (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      id v11 = HMFGetLogIdentifier();
      int v12 = 138543362;
      uint64_t v13 = v11;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Successfully removed all CHIP pairings", (uint8_t *)&v12, 0xCu);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

- (id)waitForDoorLockClusterObjectWithFlow:(id)a3
{
  id v4 = a3;
  id v5 = objc_alloc(MEMORY[0x1E4F65420]);
  id v6 = [(HMDAccessory *)self workQueue];
  id v7 = (void *)[v5 initWithQueue:v6];

  int v8 = [(HMDHAPAccessory *)self waitForChipAccessoryServerWithFlow:v4];
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  void v16[2] = __62__HMDHAPAccessory_CHIP__waitForDoorLockClusterObjectWithFlow___block_invoke;
  v16[3] = &unk_1E6A17D28;
  id v9 = v4;
  id v17 = v9;
  __int16 v10 = [v8 inContext:v7 then:v16];
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  v14[2] = __62__HMDHAPAccessory_CHIP__waitForDoorLockClusterObjectWithFlow___block_invoke_2;
  v14[3] = &unk_1E6A17D50;
  void v14[4] = self;
  id v15 = v9;
  id v11 = v9;
  int v12 = [v10 inContext:v7 recover:v14];

  return v12;
}

uint64_t __62__HMDHAPAccessory_CHIP__waitForDoorLockClusterObjectWithFlow___block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 createDoorLockClusterObjectWithFlow:*(void *)(a1 + 32)];
  if (v4)
  {
    id v5 = v4;

    return 3;
  }
  else
  {
    uint64_t v7 = _HMFPreconditionFailure();
    return __62__HMDHAPAccessory_CHIP__waitForDoorLockClusterObjectWithFlow___block_invoke_2(v7);
  }
}

uint64_t __62__HMDHAPAccessory_CHIP__waitForDoorLockClusterObjectWithFlow___block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = (void *)MEMORY[0x1D9452090]();
  id v5 = *(id *)(a1 + 32);
  id v6 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    uint64_t v7 = HMFGetLogIdentifier();
    int v8 = [*(id *)(a1 + 40) UUID];
    int v13 = 138543874;
    __int16 v14 = v7;
    __int16 v15 = 2112;
    uint64_t v16 = v8;
    __int16 v17 = 2112;
    id v18 = v3;
    _os_log_impl(&dword_1D49D5000, v6, OS_LOG_TYPE_ERROR, "%{public}@[Flow: %@] Failed to fetch chipAccessoryServer and create doorLockCluster with error: %@", (uint8_t *)&v13, 0x20u);
  }
  id v9 = v3;
  __int16 v10 = v9;
  if (v9)
  {
    id v11 = v9;
  }
  else
  {
    [MEMORY[0x1E4F28C58] hmfUnspecifiedError];
    objc_claimAutoreleasedReturnValue();
  }

  return 2;
}

- (id)waitForChipAccessoryServerWithFlow:(id)a3
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = objc_alloc(MEMORY[0x1E4F65420]);
  id v6 = [(HMDAccessory *)self workQueue];
  uint64_t v7 = (void *)[v5 initWithQueue:v6];

  int v8 = (void *)MEMORY[0x1D9452090]();
  id v9 = self;
  __int16 v10 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    id v11 = HMFGetLogIdentifier();
    int v12 = [v4 UUID];
    int v13 = [(HMDHAPAccessory *)v9 didConfigureCHIPAccessoryServerFuture];
    __int16 v14 = [(HMDHAPAccessory *)v9 didConfigureCHIPAccessoryServerFuture];
    [v14 isFinished];
    __int16 v15 = HMFBooleanToString();
    *(_DWORD *)buf = 138544130;
    id v25 = v11;
    __int16 v26 = 2112;
    id v27 = v12;
    __int16 v28 = 2112;
    uint64_t v29 = v13;
    __int16 v30 = 2112;
    id v31 = v15;
    _os_log_impl(&dword_1D49D5000, v10, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] didConfigureCHIPAccessoryServerFuture: %@, isFinished: %@", buf, 0x2Au);
  }
  uint64_t v16 = [(HMDHAPAccessory *)v9 didConfigureCHIPAccessoryServerFuture];
  __int16 v17 = [v16 hmfFuture];
  id v18 = [v17 timeout:60.0];
  v22[0] = MEMORY[0x1E4F143A8];
  v22[1] = 3221225472;
  v22[2] = __60__HMDHAPAccessory_CHIP__waitForChipAccessoryServerWithFlow___block_invoke;
  v22[3] = &unk_1E6A17D00;
  v22[4] = v9;
  id v23 = v4;
  id v19 = v4;
  char v20 = [v18 inContext:v7 then:v22];

  return v20;
}

uint64_t __60__HMDHAPAccessory_CHIP__waitForChipAccessoryServerWithFlow___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) chipAccessoryServer];
  id v5 = (void *)MEMORY[0x1D9452090]();
  id v6 = *(id *)(a1 + 32);
  uint64_t v7 = HMFGetOSLogHandle();
  int v8 = v7;
  if (v4)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v9 = HMFGetLogIdentifier();
      __int16 v10 = [*(id *)(a1 + 40) UUID];
      int v18 = 138544130;
      id v19 = v9;
      __int16 v20 = 2112;
      id v21 = v10;
      __int16 v22 = 2048;
      id v23 = v4;
      __int16 v24 = 2112;
      id v25 = v4;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_INFO, "%{public}@[Flow: %@] Found chipAccessoryServer: %p %@", (uint8_t *)&v18, 0x2Au);
    }
    v4;
    uint64_t v11 = 1;
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v12 = HMFGetLogIdentifier();
      int v13 = [*(id *)(a1 + 40) UUID];
      int v18 = 138543618;
      id v19 = v12;
      __int16 v20 = 2112;
      id v21 = v13;
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_ERROR, "%{public}@[Flow: %@] Failed to find chipAccessoryServer after timeout", (uint8_t *)&v18, 0x16u);
    }
    id v14 = [MEMORY[0x1E4F28C58] hmErrorWithCode:2];
    __int16 v15 = v14;
    if (v14)
    {
      id v16 = v14;
    }
    else
    {
      [MEMORY[0x1E4F28C58] hmfUnspecifiedError];
      objc_claimAutoreleasedReturnValue();
    }

    uint64_t v11 = 2;
  }

  return v11;
}

- (void)setDidConfigureCHIPAccessoryServer
{
  id v2 = [(HMDHAPAccessory *)self didConfigureCHIPAccessoryServerFuture];
  [v2 finishWithNoResult];
}

+ (double)chipPairingModeActiveDuration
{
  id v2 = [MEMORY[0x1E4F65530] sharedPreferences];
  id v3 = [v2 preferenceForKey:@"chipPairingModeActiveDuration"];
  id v4 = [v3 numberValue];

  [v4 doubleValue];
  double v6 = v5;

  return v6;
}

- (void)profile:(id)a3 didUpdateWoWLANInfos:(id)a4
{
  id v5 = a4;
  double v6 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v6);

  id v15 = [(HMDHAPAccessory *)self connectivityInfo];
  uint64_t v7 = [v15 accessoryIdentifier];
  int v8 = v7;
  if (v7)
  {
    id v9 = v7;
  }
  else
  {
    id v9 = [(HMDAccessory *)self identifier];
  }
  __int16 v10 = v9;

  uint64_t v11 = [HMFConnectivityInfo alloc];
  int v12 = [v15 woBLEInfo];
  int v13 = [(HMFConnectivityInfo *)v11 initWithAccessoryIdentifier:v10 woBLEInfo:v12 woWLANInfos:v5];

  if ((HMFEqualObjects() & 1) == 0)
  {
    id v14 = [(HMDHAPAccessory *)self transactionWithObjectChangeType:2];
    [v14 setConnectivityInfo:v13];
    [(HMDHAPAccessory *)self _wol_runAccessoryTransaction:v14 localOnly:0];
  }
}

- (void)profile:(id)a3 didUpdateAccessoryState:(unint64_t)a4
{
  double v6 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v6);

  [(HMDHAPAccessory *)self setSuspendedState:a4];
}

- (void)_handleWakeSuspendedAccessoryMessage:(id)a3
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if ([(HMDHAPAccessory *)self _validateIncomingMessage:v4])
  {
    id v5 = [v4 numberForKey:*MEMORY[0x1E4F2C8C0]];
    if (v5)
    {
      double v6 = [(HMDHAPAccessory *)self lpmProfile];
      uint64_t v7 = [v5 unsignedIntegerValue];
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3221225472;
      v14[2] = __61__HMDHAPAccessory_WoL___handleWakeSuspendedAccessoryMessage___block_invoke;
      v14[3] = &unk_1E6A18758;
      id v15 = v4;
      [v6 wakeAccessoryWithType:v7 completion:v14];

      int v8 = (void (**)(void, void, void))v15;
    }
    else
    {
      id v9 = (void *)MEMORY[0x1D9452090]();
      __int16 v10 = self;
      uint64_t v11 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        int v12 = HMFGetLogIdentifier();
        *(_DWORD *)buf = 138543618;
        __int16 v17 = v12;
        __int16 v18 = 2112;
        id v19 = v4;
        _os_log_impl(&dword_1D49D5000, v11, OS_LOG_TYPE_ERROR, "%{public}@Unable to validate wake type from message: %@", buf, 0x16u);
      }
      int v8 = [v4 responseHandler];
      int v13 = [MEMORY[0x1E4F28C58] hmErrorWithCode:3];
      ((void (**)(void, void *, void))v8)[2](v8, v13, 0);
    }
  }
}

void __61__HMDHAPAccessory_WoL___handleWakeSuspendedAccessoryMessage___block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a3;
  id v5 = [v3 responseHandler];
  v5[2](v5, v4, 0);
}

- (BOOL)_validateIncomingMessage:(id)a3
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = [v4 responseHandler];

  if (!v5)
  {
    uint64_t v11 = (void *)MEMORY[0x1D9452090]();
    int v12 = self;
    int v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      id v14 = HMFGetLogIdentifier();
      int v21 = 138543874;
      __int16 v22 = v14;
      __int16 v23 = 2112;
      id v24 = v4;
      __int16 v25 = 2080;
      uint64_t v26 = "-[HMDHAPAccessory(WoL) _validateIncomingMessage:]";
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_ERROR, "%{public}@No response handler in %@: %s", (uint8_t *)&v21, 0x20u);
    }
    goto LABEL_16;
  }
  if ([v4 isRemote])
  {
    double v6 = (void *)MEMORY[0x1D9452090]();
    uint64_t v7 = self;
    int v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      id v9 = HMFGetLogIdentifier();
      int v21 = 138543618;
      __int16 v22 = v9;
      __int16 v23 = 2112;
      id v24 = v4;
      __int16 v10 = "%{public}@This message should only be sent over XPC: %@";
LABEL_14:
      _os_log_impl(&dword_1D49D5000, v8, OS_LOG_TYPE_ERROR, v10, (uint8_t *)&v21, 0x16u);

      goto LABEL_15;
    }
    goto LABEL_15;
  }
  id v15 = [v4 proxyConnection];
  __int16 v16 = [v15 entitlements];

  if (![v4 isEntitledForAPIAccess]
    || ![v4 isEntitledForSPIAccess]
    || (v16 & 0x100) == 0)
  {
    double v6 = (void *)MEMORY[0x1D9452090]();
    uint64_t v7 = self;
    int v8 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      id v9 = HMFGetLogIdentifier();
      int v21 = 138543618;
      __int16 v22 = v9;
      __int16 v23 = 2112;
      id v24 = v4;
      __int16 v10 = "%{public}@Unable to process the request to insufficient privileges for message: %@";
      goto LABEL_14;
    }
LABEL_15:

    __int16 v18 = [v4 responseHandler];
    id v19 = [MEMORY[0x1E4F28C58] hmErrorWithCode:17];
    ((void (**)(void, void *, void))v18)[2](v18, v19, 0);

LABEL_16:
    BOOL v17 = 0;
    goto LABEL_17;
  }
  BOOL v17 = 1;
LABEL_17:

  return v17;
}

- (void)_registerForMessages_lowPowerMode
{
  v7[1] = *MEMORY[0x1E4F143B8];
  if ([(HMDHAPAccessory *)self supportsWoL])
  {
    id v3 = +[HMDXPCMessagePolicy policyWithEntitlements:261];
    id v4 = [(HMDAccessory *)self msgDispatcher];
    uint64_t v5 = *MEMORY[0x1E4F2C8B8];
    v7[0] = v3;
    double v6 = [MEMORY[0x1E4F1C978] arrayWithObjects:v7 count:1];
    [v4 registerForMessage:v5 receiver:self policies:v6 selector:sel__handleWakeSuspendedAccessoryMessage_];
  }
}

- (void)_wol_updateWakingViaCharacteristicForWriteResponses:(id)a3
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [(HMDHAPAccessory *)self wakingViaCharacteristicWithIID];

  if (v5)
  {
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    id v17 = v4;
    id v6 = v4;
    uint64_t v7 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)v19;
      while (2)
      {
        for (uint64_t i = 0; i != v8; ++i)
        {
          if (*(void *)v19 != v9) {
            objc_enumerationMutation(v6);
          }
          uint64_t v11 = *(void **)(*((void *)&v18 + 1) + 8 * i);
          int v12 = [(HMDHAPAccessory *)self wakingViaCharacteristicWithIID];
          int v13 = [v11 request];
          id v14 = [v13 characteristic];
          id v15 = [v14 instanceID];
          int v16 = [v12 isEqualToNumber:v15];

          if (v16)
          {
            [(HMDHAPAccessory *)self setWakingViaCharacteristicWithIID:0];
            goto LABEL_12;
          }
        }
        uint64_t v8 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
        if (v8) {
          continue;
        }
        break;
      }
    }
LABEL_12:

    id v4 = v17;
  }
}

- (void)_wol_updateWakingViaCharacteristicForWriteRequests:(id)a3
{
  id v8 = a3;
  if ([(HMDHAPAccessory *)self isSuspended])
  {
    id v4 = [(HMDHAPAccessory *)self wakingViaCharacteristicWithIID];

    if (!v4)
    {
      if ([(HMDHAPAccessory *)self canWakeBasedOnCharacteristicRequests:v8])
      {
        uint64_t v5 = [v8 firstObject];
        id v6 = [v5 characteristic];
        uint64_t v7 = [v6 instanceID];
        [(HMDHAPAccessory *)self setWakingViaCharacteristicWithIID:v7];
      }
    }
  }
}

- (void)_wol_processReadWriteResponseForCharacteristic:(id)a3 isRead:(BOOL)a4 error:(id)a5
{
  BOOL v6 = a4;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  id v9 = a5;
  if ([(HMDHAPAccessory *)self isSuspended])
  {
    BOOL v10 = 0;
    if (v9) {
      goto LABEL_14;
    }
  }
  else
  {
    if ([(HMDAccessory *)self isReachable]) {
      goto LABEL_14;
    }
    BOOL v10 = [(HMDHAPAccessory *)self suspendedState] < 2;
    if (v9) {
      goto LABEL_14;
    }
  }
  if (!v10)
  {
    if (!v6
      || ![(HMDHAPAccessory *)self canReturnCachedValueForCharacteristic:v8])
    {
      uint64_t v11 = (void *)MEMORY[0x1D9452090]();
      int v12 = self;
      int v13 = HMFGetOSLogHandle();
      uint64_t v14 = 1;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        id v15 = HMFGetLogIdentifier();
        if (v6) {
          int v16 = "read";
        }
        else {
          int v16 = "write";
        }
        id v17 = [(HMDAccessory *)v12 identifier];
        int v25 = 138543874;
        uint64_t v26 = v15;
        __int16 v27 = 2080;
        __int16 v28 = v16;
        __int16 v29 = 2112;
        __int16 v30 = v17;
        uint64_t v14 = 1;
        _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_INFO, "%{public}@The accessory is no longer suspended per the %s response. Updating the internal state for %@", (uint8_t *)&v25, 0x20u);
      }
      goto LABEL_28;
    }
    goto LABEL_29;
  }
LABEL_14:
  if ([v9 isHMError])
  {
    if (!-[HMDHAPAccessory isSuspended](self, "isSuspended") && [v9 code] == 103)
    {
      uint64_t v11 = (void *)MEMORY[0x1D9452090]();
      long long v18 = self;
      int v13 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        long long v19 = HMFGetLogIdentifier();
        if (v6) {
          long long v20 = "read";
        }
        else {
          long long v20 = "write";
        }
        long long v21 = [(HMDAccessory *)v18 identifier];
        int v25 = 138543874;
        uint64_t v26 = v19;
        __int16 v27 = 2080;
        __int16 v28 = v20;
        __int16 v29 = 2112;
        __int16 v30 = v21;
        _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_INFO, "%{public}@The accessory is suspended per %s the response. Updating the internal state for %@", (uint8_t *)&v25, 0x20u);
      }
      uint64_t v14 = 3;
LABEL_28:

      [(HMDHAPAccessory *)self setSuspendedState:v14];
      goto LABEL_29;
    }
    if ([(HMDHAPAccessory *)self isSuspended]
      && ([v9 code] == 4 || objc_msgSend(v9, "code") == 54))
    {
      uint64_t v11 = (void *)MEMORY[0x1D9452090]();
      __int16 v22 = self;
      int v13 = HMFGetOSLogHandle();
      uint64_t v14 = 1;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        uint64_t v23 = HMFGetLogIdentifier();
        id v24 = [(HMDAccessory *)v22 identifier];
        int v25 = 138543618;
        uint64_t v26 = v23;
        __int16 v27 = 2112;
        __int16 v28 = v24;
        uint64_t v14 = 1;
        _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_INFO, "%{public}@The accessory is now unreachable. Updating the internal state for %@", (uint8_t *)&v25, 0x16u);
      }
      goto LABEL_28;
    }
  }
LABEL_29:
}

- (void)_wol_processDidRemoveHPAccessoryServer:(id)a3
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if ([(HMDHAPAccessory *)self canWakeUpViaWoL])
  {
    if ([v4 wakeNumber])
    {
      if ([(HMDHAPAccessory *)self isSuspended])
      {
        uint64_t v5 = [(HMDAccessory *)self home];
        int v6 = [v5 isCurrentDeviceAvailableResident];

        if (v6)
        {
          uint64_t v7 = (void *)MEMORY[0x1D9452090]();
          id v8 = self;
          id v9 = HMFGetOSLogHandle();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
          {
            BOOL v10 = HMFGetLogIdentifier();
            uint64_t v11 = [(HMDAccessory *)v8 identifier];
            int v12 = 138543618;
            int v13 = v10;
            __int16 v14 = 2112;
            id v15 = v11;
            _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@The suspended accessory: '%@' is no longer reachable. Updating the suspended state.", (uint8_t *)&v12, 0x16u);
          }
          [(HMDHAPAccessory *)v8 setSuspendedState:1];
        }
      }
    }
    if ([v4 wakeNumber]) {
      [(HMDHAPAccessory *)self setReachableViaBSP:0];
    }
  }
}

- (void)_wol_updateSuspendCapableHAPAccessoryServer:(id)a3
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if ([(HMDHAPAccessory *)self canWakeUpViaWoL])
  {
    uint64_t v5 = [v4 suspendedAccessory];

    if (!v5)
    {
      int v6 = [(HMDHAPAccessory *)self connectivityInfo];
      uint64_t v7 = [v6 woWLANInfo];
      BOOL v8 = [v7 wakeType] == 2;

      id v9 = [(HMDHAPAccessory *)self lpmProfile];
      BOOL v10 = (void *)[v9 newHAPSuspendedAccessoryFromAccessoryConnectivityInfoWithType:v8];
      [v4 setSuspendedAccessory:v10];

      id v11 = v4;
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        int v12 = v11;
      }
      else {
        int v12 = 0;
      }
      id v13 = v12;

      if (v13)
      {
        id v21 = 0;
        [v13 getBonjourDeviceDNSName:&v21];
        id v14 = v21;
        if (v14)
        {
          id v15 = [v13 suspendedAccessory];
          [v15 setDnsName:v14];
        }
      }
      uint64_t v16 = (void *)MEMORY[0x1D9452090]();
      id v17 = self;
      long long v18 = HMFGetOSLogHandle();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        long long v19 = HMFGetLogIdentifier();
        long long v20 = [v11 suspendedAccessory];
        *(_DWORD *)buf = 138543618;
        uint64_t v23 = v19;
        __int16 v24 = 2112;
        int v25 = v20;
        _os_log_impl(&dword_1D49D5000, v18, OS_LOG_TYPE_INFO, "%{public}@Updating the accessory server with HAPSuspendedAccessory: %@", buf, 0x16u);
      }
    }
  }
}

- (void)_wol_runAccessoryTransaction:(id)a3 localOnly:(BOOL)a4
{
  if (a4) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = 2;
  }
  BOOL v6 = !a4;
  if (a4) {
    uint64_t v7 = @"HMDHAPAccessoryWoLUpdateLocallyLabel";
  }
  else {
    uint64_t v7 = @"HMDHAPAccessoryWoLUpdateLabel";
  }
  id v8 = a3;
  id v12 = +[HMDBackingStoreTransactionOptions optionsWithSource:v6 destination:v5 mustReplay:0 mustPush:0];
  id v9 = [(HMDAccessory *)self home];
  BOOL v10 = [v9 backingStore];
  id v11 = [v10 transaction:v7 options:v12];

  [v11 add:v8 withMessage:0];
  [v11 run];
}

- (void)_wakeSuspendedHAPAccessoryToPerformOperation:(int64_t)a3 linkType:(int64_t)a4 operationBlock:(id)a5 errorBlock:(id)a6 activity:(id)a7
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  id v12 = a5;
  id v13 = a6;
  id v35 = a7;
  [(HMDAccessory *)self uuid];

  [(HMDHAPAccessory *)self suspendedState];
  id v14 = (id)HAPAccessorySuspendedStateDescription();
  [(HMDAccessory *)self isReachable];
  id v15 = (void *)MEMORY[0x1D9452090]([(HMDAccessory *)self isRemotelyReachable]);
  uint64_t v16 = self;
  id v17 = HMFGetOSLogHandle();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    long long v18 = HMFGetLogIdentifier();
    if ((unint64_t)a4 >= 3) {
      long long v19 = @"Undefined";
    }
    else {
      long long v19 = off_1E6A0B860[a4];
    }
    char v33 = v19;
    if ((unint64_t)a3 > 0xA) {
      long long v20 = @"Undefined";
    }
    else {
      long long v20 = off_1E6A0B878[a3];
    }
    uint64_t v34 = v20;
    [(HMDHAPAccessory *)v16 suspendedState];
    uint64_t v32 = HAPAccessorySuspendedStateDescription();
    id v21 = v13;
    int64_t v22 = a4;
    int64_t v23 = a3;
    id v24 = v12;
    if ([(HMDAccessory *)v16 isReachable]) {
      int v25 = @"YES";
    }
    else {
      int v25 = @"NO";
    }
    BOOL v26 = [(HMDAccessory *)v16 isRemotelyReachable];
    *(_DWORD *)buf = 138544642;
    __int16 v27 = @"YES";
    if (!v26) {
      __int16 v27 = @"NO";
    }
    int v42 = v18;
    __int16 v43 = 2112;
    uint64_t v44 = v33;
    __int16 v45 = 2112;
    long long v46 = v34;
    __int16 v47 = 2112;
    __int16 v48 = v32;
    __int16 v49 = 2112;
    __int16 v50 = v25;
    id v12 = v24;
    a3 = v23;
    a4 = v22;
    id v13 = v21;
    __int16 v51 = 2112;
    uint64_t v52 = v27;
    _os_log_impl(&dword_1D49D5000, v17, OS_LOG_TYPE_INFO, "%{public}@Waking suspended accessory with linkType: %@, operation: %@, suspendedState: %@, reachable: %@, remotely reachable: %@", buf, 0x3Eu);
  }
  objc_initWeak((id *)buf, v16);
  __int16 v28 = [(HMDHAPAccessory *)v16 lpmProfile];
  v36[0] = MEMORY[0x1E4F143A8];
  v36[1] = 3221225472;
  v36[2] = __113__HMDHAPAccessory_WoL___wakeSuspendedHAPAccessoryToPerformOperation_linkType_operationBlock_errorBlock_activity___block_invoke;
  v36[3] = &unk_1E6A18730;
  id v29 = v35;
  id v37 = v29;
  objc_copyWeak(v40, (id *)buf);
  v40[1] = (id)a4;
  v40[2] = (id)a3;
  id v30 = v13;
  id v38 = v30;
  id v31 = v12;
  id v39 = v31;
  [v28 wakeAccessoryWithCompletion:v36];

  objc_destroyWeak(v40);
  objc_destroyWeak((id *)buf);
}

void __113__HMDHAPAccessory_WoL___wakeSuspendedHAPAccessoryToPerformOperation_linkType_operationBlock_errorBlock_activity___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  id v37 = a2;
  id v5 = a3;
  [*(id *)(a1 + 32) begin];
  id v38 = *(id *)(a1 + 32);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    uint64_t v7 = (void *)MEMORY[0x1D9452090]();
    id v8 = WeakRetained;
    HMFGetOSLogHandle();
    id v9 = (id)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      HMFGetLogIdentifier();
      id v10 = (id)objc_claimAutoreleasedReturnValue();
      unint64_t v11 = *(void *)(a1 + 64);
      if (v11 > 2) {
        id v12 = @"Undefined";
      }
      else {
        id v12 = off_1E6A0B860[v11];
      }
      id v13 = v12;
      unint64_t v14 = *(void *)(a1 + 72);
      if (v14 > 0xA) {
        id v15 = @"Undefined";
      }
      else {
        id v15 = off_1E6A0B878[v14];
      }
      uint64_t v16 = v15;
      [v8 suspendedState];
      HAPAccessorySuspendedStateDescription();
      id v17 = (id)objc_claimAutoreleasedReturnValue();
      int v18 = [v8 isReachable];
      long long v19 = @"NO";
      *(_DWORD *)buf = 138544642;
      id v42 = v10;
      __int16 v43 = 2112;
      if (v18) {
        long long v19 = @"YES";
      }
      id v44 = v5;
      __int16 v45 = 2112;
      long long v46 = v13;
      __int16 v47 = 2112;
      __int16 v48 = v16;
      __int16 v49 = 2112;
      id v50 = v17;
      __int16 v51 = 2112;
      uint64_t v52 = v19;
      _os_log_impl(&dword_1D49D5000, v9, OS_LOG_TYPE_INFO, "%{public}@Did configure / wake up the suspended accessory with error: %@, linkType: %@, operation: %@, suspendedState: %@, reachable: %@ ", buf, 0x3Eu);
    }
    id v20 = *(id *)(a1 + 32);
    [v8 uuid];

    [v8 suspendedState];
    id v21 = (id)HAPAccessorySuspendedStateDescription();
    [v37 isReachable];
    [v5 domain];

    [v5 code];
    if (v5)
    {
      if (*(void *)(a1 + 40))
      {
        int64_t v22 = (void *)MEMORY[0x1E4F28C58];
        uint64_t v39 = *MEMORY[0x1E4F28A50];
        id v40 = v5;
        int64_t v23 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v40 forKeys:&v39 count:1];
        id v24 = [v22 hmErrorWithCode:4 userInfo:v23];

        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      }
    }
    else
    {
      uint64_t v25 = *(void *)(a1 + 48);
      if (v25)
      {
        if (v37)
        {
          (*(void (**)(void))(v25 + 16))();
        }
        else
        {
          BOOL v26 = (void *)MEMORY[0x1D9452090]();
          id v27 = v8;
          HMFGetOSLogHandle();
          __int16 v28 = (id)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
          {
            HMFGetLogIdentifier();
            id v29 = (id)objc_claimAutoreleasedReturnValue();
            id v30 = [v27 identifier];
            unint64_t v31 = *(void *)(a1 + 72);
            if (v31 > 0xA) {
              uint64_t v32 = @"Undefined";
            }
            else {
              uint64_t v32 = off_1E6A0B878[v31];
            }
            char v33 = v32;
            unint64_t v34 = *(void *)(a1 + 64);
            if (v34 > 2) {
              id v35 = @"Undefined";
            }
            else {
              id v35 = off_1E6A0B860[v34];
            }
            uint64_t v36 = v35;
            *(_DWORD *)buf = 138544130;
            id v42 = v29;
            __int16 v43 = 2112;
            id v44 = v30;
            __int16 v45 = 2112;
            long long v46 = v33;
            __int16 v47 = 2112;
            __int16 v48 = v36;
            _os_log_impl(&dword_1D49D5000, v28, OS_LOG_TYPE_INFO, "%{public}@Retrieving accessory: %@ for operation: '%@' over link: '%@'", buf, 0x2Au);
          }
          [v27 _retrieveHAPAccessoryToPerformOperation:*(void *)(a1 + 72) linkType:*(void *)(a1 + 64) operationBlock:*(void *)(a1 + 48) errorBlock:*(void *)(a1 + 40) activity:*(void *)(a1 + 32)];
        }
      }
    }
  }

  __HMFActivityScopeLeave();
}

- (BOOL)_handleUpdatedServicesForLowPowerModeProfile
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = [(HMDAccessory *)self workQueue];
  dispatch_assert_queue_V2(v3);

  BOOL v4 = [(HMDHAPAccessory *)self supportsWoL];
  uint64_t v5 = [(HMDHAPAccessory *)self lpmProfile];
  BOOL v6 = (HMDLowPowerModeProfile *)v5;
  int v7 = !v4;
  if (v4 && !v5)
  {
    id v8 = [(HMDHAPAccessory *)self findServiceWithServiceType:@"00000221-0000-1000-8000-0026BB765291"];
    id v9 = [HMDLowPowerModeProfile alloc];
    id v10 = [(HMDAccessory *)self workQueue];
    BOOL v6 = [(HMDLowPowerModeProfile *)v9 initWithAccessory:self powerManagementservice:v8 workQueue:v10];

    unint64_t v11 = (void *)MEMORY[0x1D9452090]();
    id v12 = self;
    id v13 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      unint64_t v14 = HMFGetLogIdentifier();
      int v22 = 138543618;
      int64_t v23 = v14;
      __int16 v24 = 2112;
      uint64_t v25 = v6;
      _os_log_impl(&dword_1D49D5000, v13, OS_LOG_TYPE_INFO, "%{public}@Adding new Low Power Mode profile: %@", (uint8_t *)&v22, 0x16u);
    }
    [(HMDAccessory *)v12 addAccessoryProfile:v6];
LABEL_13:

    goto LABEL_14;
  }
  if (!v5) {
    int v7 = 0;
  }
  if (v7 != 1)
  {
    BOOL v20 = 0;
    goto LABEL_16;
  }
  [(HMDAccessory *)self removeAccessoryProfile:v5];
  if ([(HMDAccessory *)self isSuspendCapable])
  {
    id v15 = (void *)MEMORY[0x1D9452090]([(HMDHAPAccessory *)self setSuspendedState:0]);
    uint64_t v16 = self;
    id v17 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      int v18 = HMFGetLogIdentifier();
      long long v19 = [(HMDAccessory *)v16 identifier];
      int v22 = 138543618;
      int64_t v23 = v18;
      __int16 v24 = 2112;
      uint64_t v25 = v19;
      _os_log_impl(&dword_1D49D5000, v17, OS_LOG_TYPE_INFO, "%{public}@Updating accessory's suspended capability to NO for %@", (uint8_t *)&v22, 0x16u);
    }
    id v8 = [(HMDHAPAccessory *)v16 transactionWithObjectChangeType:2];
    [v8 setSuspendCapable:MEMORY[0x1E4F1CC28]];
    [(HMDHAPAccessory *)v16 _wol_runAccessoryTransaction:v8 localOnly:0];
    goto LABEL_13;
  }
LABEL_14:
  BOOL v20 = 1;
LABEL_16:

  return v20;
}

- (void)updateSuspendedStateWithWakeNumber:(id)a3 hapAccessory:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  id v8 = [(HMDAccessory *)self workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __72__HMDHAPAccessory_WoL__updateSuspendedStateWithWakeNumber_hapAccessory___block_invoke;
  block[3] = &unk_1E6A19668;
  void block[4] = self;
  id v12 = v6;
  id v13 = v7;
  id v9 = v7;
  id v10 = v6;
  dispatch_async(v8, block);
}

void __72__HMDHAPAccessory_WoL__updateSuspendedStateWithWakeNumber_hapAccessory___block_invoke(id *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = [a1[4] suspendedState];
  int v3 = [a1[5] unsignedIntValue];
  if (v3) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = v2 == 3;
  }
  if (v4)
  {
    id v12 = (void *)MEMORY[0x1D9452090]();
    id v13 = a1[4];
    unint64_t v14 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      id v15 = HMFGetLogIdentifier();
      id v16 = a1[5];
      id v17 = HAPAccessorySuspendedStateDescription();
      int v18 = [a1[6] identifier];
      int v21 = 138544130;
      int v22 = v15;
      __int16 v23 = 2112;
      id v24 = v16;
      __int16 v25 = 2112;
      uint64_t v26 = v17;
      __int16 v27 = 2112;
      __int16 v28 = v18;
      _os_log_impl(&dword_1D49D5000, v14, OS_LOG_TYPE_INFO, "%{public}@Received wake number update: '%@' from a '%@' accessory: %@", (uint8_t *)&v21, 0x2Au);
    }
    [a1[4] setSuspendedState:1];
    long long v19 = [a1[4] lpmProfile];
    BOOL v20 = [v19 pendingWakeBlock];

    if (v20) {
      v20[2](v20, 0);
    }
  }
  else if (v3)
  {
    uint64_t v5 = (void *)MEMORY[0x1D9452090]();
    id v6 = a1[4];
    id v7 = HMFGetOSLogHandle();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = HMFGetLogIdentifier();
      id v9 = a1[5];
      id v10 = HAPAccessorySuspendedStateDescription();
      unint64_t v11 = [a1[6] identifier];
      int v21 = 138544130;
      int v22 = v8;
      __int16 v23 = 2112;
      id v24 = v9;
      __int16 v25 = 2112;
      uint64_t v26 = v10;
      __int16 v27 = 2112;
      __int16 v28 = v11;
      _os_log_impl(&dword_1D49D5000, v7, OS_LOG_TYPE_INFO, "%{public}@Received wake number update: '%@' from a '%@' accessory: %@", (uint8_t *)&v21, 0x2Au);
    }
    [a1[4] setSuspendedState:3];
  }
}

- (BOOL)shouldDiscoverSuspendCapableAccessoryServer:(id)a3
{
  id v4 = a3;
  if ([v4 wakeNumber])
  {
    [(HMDHAPAccessory *)self setReachableViaBSP:1];
LABEL_4:
    [(HMDHAPAccessory *)self setSuspendedState:3];
    BOOL v7 = 0;
    goto LABEL_5;
  }
  [(HMDHAPAccessory *)self setReachableViaBSP:0];
  uint64_t v5 = [v4 name];
  int v6 = [v5 containsString:*MEMORY[0x1E4F5B7A8]];

  if (v6) {
    goto LABEL_4;
  }
  if ([(HMDHAPAccessory *)self isSuspended]) {
    [(HMDHAPAccessory *)self setSuspendedState:1];
  }
  id v9 = [(HMDHAPAccessory *)self lpmProfile];
  id v10 = [v9 pendingWakeBlock];

  if (v10)
  {
    unint64_t v11 = [(HMDAccessory *)self workQueue];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __68__HMDHAPAccessory_WoL__shouldDiscoverSuspendCapableAccessoryServer___block_invoke;
    block[3] = &unk_1E6A186E0;
    id v13 = v10;
    dispatch_async(v11, block);
  }
  BOOL v7 = 1;
LABEL_5:

  return v7;
}

uint64_t __68__HMDHAPAccessory_WoL__shouldDiscoverSuspendCapableAccessoryServer___block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

- (BOOL)canReturnCachedValueForCharacteristic:(id)a3
{
  uint64_t v3 = canReturnCachedValueForCharacteristic__onceToken;
  id v4 = a3;
  if (v3 != -1) {
    dispatch_once(&canReturnCachedValueForCharacteristic__onceToken, &__block_literal_global_183349);
  }
  uint64_t v5 = (void *)canReturnCachedValueForCharacteristic__characteristicTypes;
  int v6 = [v4 type];

  char v7 = [v5 containsObject:v6];
  return v7;
}

void __62__HMDHAPAccessory_WoL__canReturnCachedValueForCharacteristic___block_invoke()
{
  v2[1] = *MEMORY[0x1E4F143B8];
  v2[0] = *MEMORY[0x1E4F2CE48];
  uint64_t v0 = [MEMORY[0x1E4F1C978] arrayWithObjects:v2 count:1];
  v1 = (void *)canReturnCachedValueForCharacteristic__characteristicTypes;
  canReturnCachedValueForCharacteristic__characteristicTypes = v0;
}

- (HMDLowPowerModeProfile)lpmProfile
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v2 = [(HMDAccessory *)self accessoryProfiles];
  uint64_t v3 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v12;
LABEL_3:
    uint64_t v6 = 0;
    while (1)
    {
      if (*(void *)v12 != v5) {
        objc_enumerationMutation(v2);
      }
      id v7 = *(id *)(*((void *)&v11 + 1) + 8 * v6);
      objc_opt_class();
      id v8 = (objc_opt_isKindOfClass() & 1) != 0 ? v7 : 0;
      id v9 = v8;

      if (v9) {
        break;
      }
      if (v4 == ++v6)
      {
        uint64_t v4 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
        if (v4) {
          goto LABEL_3;
        }
        goto LABEL_12;
      }
    }
  }
  else
  {
LABEL_12:
    id v7 = 0;
  }

  return (HMDLowPowerModeProfile *)v7;
}

- (BOOL)isPoweringOn
{
  uint64_t v3 = +[HMDBTLEAdvertiser sharedAdvertiser];
  LOBYTE(self) = [v3 isAdvertisingForAccessory:self];

  return (char)self;
}

- (void)wirelessPowerOn:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __51__HMDHAPAccessory_WirelessResume__wirelessPowerOn___block_invoke;
  v7[3] = &unk_1E6A19530;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

uint64_t __51__HMDHAPAccessory_WirelessResume__wirelessPowerOn___block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _wirelessPowerOn:*(void *)(a1 + 40)];
}

- (void)_wirelessPowerOn:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    aBlocuint64_t k = v4;
    if ([(HMDHAPAccessory *)self custom1WoBLE])
    {
      uint64_t v5 = +[HMDBTLEAdvertiser sharedAdvertiser];
      id v6 = [(HMDHAPAccessory *)self powerOnCompletionRoutines];
      id v7 = _Block_copy(aBlock);
      [v6 addObject:v7];

      [v5 powerOn:self];
    }
    else
    {
      (*((void (**)(void *, void))aBlock + 2))(aBlock, 0);
    }
    id v4 = aBlock;
  }
}

- (void)powerOnComplete:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(HMDAccessory *)self workQueue];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = __51__HMDHAPAccessory_WirelessResume__powerOnComplete___block_invoke;
  v7[3] = &unk_1E6A197C8;
  void v7[4] = self;
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void __51__HMDHAPAccessory_WirelessResume__powerOnComplete___block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  uint64_t v2 = objc_msgSend(*(id *)(a1 + 32), "powerOnCompletionRoutines", 0);
  uint64_t v3 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)v9;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v9 != v5) {
          objc_enumerationMutation(v2);
        }
        (*(void (**)(void))(*(void *)(*((void *)&v8 + 1) + 8 * v6++) + 16))();
      }
      while (v4 != v6);
      uint64_t v4 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
    }
    while (v4);
  }

  id v7 = [*(id *)(a1 + 32) powerOnCompletionRoutines];
  [v7 removeAllObjects];
}

- (void)wirelessResumeInit
{
  if ([(HMDHAPAccessory *)self custom1WoBLE]) {
    id v2 = +[HMDBTLEAdvertiser initializeAdvertiser];
  }
}

@end